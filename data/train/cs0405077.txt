{
  "article_text": [
    "dynamic systems with many interacting components are encountered in areas ranging from econometric modeling to communications to material science . individual components and their local interactions may or may not be complex , but their mere multiplicity often creates a complexity which needs to be addressed .    as an example , consider the flexchan feature , introduced in new releases of the tdma wireless system . according to the flexchan method , each base station that serves a cell in the service area , periodically checks interference level on different channels and dynamically rearranges the channels in the order of the increase of the expected interference .",
    "a new service request ( a new call or a handoff request from a mobile with the call in progress ) is allocated according to an accepted strategy taking into account availability of free channels and the segregation order .",
    "for instance , a `` greedy '' strategy places the call on the unoccupied channel with the least expected interference .",
    "all the channel capacity of the system is potentially available to each cell in flexchan in contrast with fixed allocation schemes , that are largely in use today .",
    "the latter prespecifies a partition of capacity among the cells in anticipation of the traffic . under the flexchan ,",
    "cells themselves negotiate the capacity , dynamically forming an allocation pattern in response to the actual traffic .",
    "thus , the flexchan eliminates the manual planning , reduces the operating cost and presumably increases capacity and qos .",
    "does it ? will the channel segregation adapt to the traffic , or maybe it will instead oscillate somehow , with base stations `` fighting '' each other for the capacity ? if it does adapt , how long would the adaptation process take depending on algorithm parameters such as the frequency of checking the interference by base stations ?",
    "short of actual system deployment , only simulations can answer these questions .    to be convincing , the simulation should be dynamic with base stations asynchronously working out their flexchan routine while users are moving in the service area .",
    "many base stations should be represented in order to demonstrate the algorithm viability ; it is possible to imagine how the algorithm would work for just a few base stations , but break down for , say , a hundred base stations .",
    "it becomes obvious that a crucial element of this simulation is the computing efficiency of the simulation algorithm .",
    "this paper reviews algorithmic and programming techniques which were used to answer the posed questions by simulation@xcite .",
    "the program was written so that , say , for about 100 base stations and 1000 active mobiles , simulating one hour of operation requires only several hours of processing on a single pc or workstation .",
    "similar algorithmic concepts and techniques for improving efficiency of _ discrete event _ simulations recur in diverse applications such as :    - an econometric model of telephone companies , like at&t and mci , fighting among themselves for the residential telephone market quotas . to attract the customers ,",
    "the players introduce various payment plans , like `` friends and family '' or `` volume discount . ''",
    "a question may be : which policy / discount works better given the same cost for the player .",
    "the customers behave randomly , their response is staggered , but they tend to behave in accordance with their individual economic interests .",
    "it was possible to simulate such systems with more than 100,000 customers with individualized connections and `` habits '' in calling each other during several simulated years with a single run taking a few minutes on a pc .",
    "- a dynamic routing in a wired network , like the long distance at&t network , where the use of an `` anticipating '' data structure allows one to cut processing time of simulating one operating hour from a hundred hours to under a ten hours and where further speed improvement using parallel processing shrinks the processing time to a few minutes .    - multiparticle studies in computational physics , and material science , such as a model of magnetization , a model of particle deposition , a study of impurity - perturbed crystals . here",
    "`` lazy '' evaluation , poisson dispensing , and parallel processing lead to several order of magnitude speed improvements .",
    "some simulations previously thought impossible , as they would take years to complete under old techniques , with the new programming techniques move to the category of possible ones , those that can be completed in several hours .",
    "this paper is organized as follows .",
    "sections [ s : edr ] , [ s : lazy ] , and [ s : poisson ] present techniques and concepts for simulating multicomponent systems on a uniprocessor .",
    "the advantages and difficulties of event - driven processing are discussed in section [ s : edr ] , the balance between `` lazy '' and anticipatory methods of evaluation is explained in section [ s : lazy ] , and a general method of event - driven simulation which avoids , and which is faster than the event list method is introduced in section [ s : poisson ] .",
    "sections [ s : sequent ] and [ s : relax ] present technique for simulating efficiently large multicomponent systems on a multiprocessor . a `` cautious '' technique which avoids speculative computations",
    "is discussed in section [ s : sequent ] .",
    "if the latter technique is not feasible , one may resort to the synchronous relaxation method , presented in section [ s : relax ] .",
    "the lessons learned in the course of the practical application of the discussed methods are discussed in conclusion .",
    "a time - driven description of a dynamic system involves the global clock .",
    "the time - driven computer model keeps in memory the global state of the system and modifies the entire state as the global time advances in finite increments .",
    "although time - driven models are intuitive and convenient to think of , one should try to avoid them in simulations because of their computational inefficiency .",
    "converting the model from the time - driven to an event - driven form , whenever such conversion is possible , is a single best improvement to a computer simulation . that is a classical textbook recommendation . in a general case ,",
    "it is not known , though , how to do the conversion .      as an example of the conversion ,",
    "consider simulation of a collection of chaotically colliding billiard balls . despite its toyish appearance ,",
    "the `` billiards '' simulation technically is non - trivial and has serious applications .    for simplicity consider billiards in one dimension .",
    "we may imagine a gutter bounded from both ends , which contains @xmath0 absolutely hard elastic balls of equal mass and size .",
    "the width of the gutter is just enough to let the balls move without friction in one dimension .",
    "the gutter is placed horizontally which excludes the effect of gravitation on the ball movements . the gutter filled with @xmath1 balls",
    "is shown at the bottom of figure [ gutter ] which also presents the initial time - space trajectories of the balls for times @xmath2 .",
    "the trajectories are indicated by dashed lines , they are initiated at @xmath3 by the shown positions and velocities .    to simulate the system evolution in a time - driven way , we integrate equations of motion along small time segments of duration @xmath4 .",
    "thus , starting with time @xmath5 we advance the state to time @xmath4 , then to @xmath6 , then to @xmath7 , and so on .",
    "if a ball experiences no collision during the advancement interval , then , because there is no friction , we have @xmath8 where @xmath9 is the one - dimensional position coordinate and @xmath10 is the velocity of the ball ( center ) at time @xmath11 .    at each step",
    "the time - driven method monitors distances between components that might come in contact .",
    "ball - ball collisions are detected by monitoring distances @xmath12 between centers of balls @xmath13 and @xmath14 .",
    "such a collision occurs during time interval @xmath15 if @xmath12 becomes smaller that ball diameter @xmath16 at time @xmath17 , while @xmath18 at time @xmath11 .",
    "once detected , the collision is processed by exchanging velocities of the balls at time @xmath19 : @xmath20    it follows , that for a single ball the algorithm detects and processes at most one collision during a @xmath4 step . with a large @xmath4",
    ", the algorithm may fail to represent interdependent collisions that follow over a single @xmath4 step .",
    "hence , @xmath4 determines the accuracy of the simulation ; smaller @xmath4 higher the accuracy .",
    "a high accuracy is required in many applications of the billiards simulation , for instance , for generating a pattern of impurity perturbed crystal .",
    "a material scientist might be interested to know the geometry of displacements of particles in a crystal formed of identical particles with a tiny fraction of inserted isolated particles of a different kind , the impurity .",
    "the mechanism of generating a displacement pattern in two dimensions , see figures [ hex ] and [ mosaic ] , can be modeled by billiards as follow .",
    "we introduce an impurity _ larger _ particle into a perfect hexagonal crystal of circular particles of common diameter packed inside a bounded geometric shape , say , inside a hexagon . to fit the larger diameter circle we loosen the assembly by simultaneously decreasing the diameters of all the circles .",
    "the decrease of the particles matches the excess size of the impurity so that we then able to substitute a single regular particle with the larger impurity particle without creating particle overlaps .",
    "the impurity particle is in the center in figures [ hex ] and [ mosaic ] .",
    "we then randomly assign a velocity to each particle and let them all uniformly increase in diameter , so that the ratios of the diameters of the particles remain constant .",
    "`` swelling '' particles chaotically move in different directions colliding with each other thereby negotiating the limited free space inside the bounded region until the final `` jammed '' state delivers the sought pattern .",
    "figure [ hex ] represents vectors of displacement of the particles from their respective original positions in the unperturbed crystal and figure [ mosaic ] represents the particles themselves in the central square fragment of the pattern in figure [ hex ] .",
    "the pattern is robust .",
    "it repeats itself under different initial conditions within a range of parameters such as a ratio of the larger particle to the regular ones and a rate of particle expansion .    at the final phase of the expansion , when the particles are almost `` jammed '' a quick sequence of interdependent collisions has a high chance to occur within the array of 11,000 particle .",
    "the accuracy required for capturing this interdependence is high and the @xmath4 required for it is small .",
    "should the @xmath4 be not small enough , the simulation fails to produce the correct pattern .",
    "unfortunately , the accuracy does not agree with the efficiency of computations . in a typical @xmath4 step ,",
    "if the @xmath4 is small , the state of most particles is advanced according to with no collision .",
    "such is the case for the @xmath4 step shown in figure [ gutter ] .",
    "the no - collision advancements waste computing power : generating the pattern similar to the one shown in figures [ hex ] and [ mosaic ] would take more than a year on a personal computer .    that is an estimate though , because the time - driven method was never tried successfully in this example . instead",
    ", the pattern was generated using an event - driven method and the computations for a pattern like the one in figures [ hex ] and [ mosaic ] were typically completed in under 10 hours of processing on a pc .",
    "the event - driven method assumes a discrete event model of the system , wherein the system and its components change their states instantaneously at discrete times ; those changes are called the _",
    "events_. the state remains constant on the intervals between the events .",
    "the trajectory of the system is a directed acyclic _ event dependency graph_. the nodes of it are the events , and the links represent cause - effect relations in pairs of events .",
    "this graph can be also viewed as a data - flow diagram . to each node - event",
    "corresponds the event _ descriptor _ , which consists of the time of the event and of the specification of the state change represented by the event .",
    "if events @xmath21 are all the immediate causes of event @xmath22 , then the descriptor of event @xmath22 is a function of the descriptors of @xmath21 .",
    "generating the descriptor of event @xmath22 from the descriptors of @xmath22 s causes is _ processing _ event @xmath22 .",
    "figure [ gutter ] represents not only the 4-ball system trajectory but can be also viewed as the event dependency graph corresponding to this trajectory .",
    "the events @xmath23 , @xmath24 , are ball - ball and ball - wall collisions .",
    "the arrows from an event to an event along a ball trajectory can be seen as cause - effect links on the event dependency graph or as data - dependency links of the data - flow diagram .",
    "an event descriptor here consists of : the collision time , the positions and velocities of the involved balls immediately after the collision .",
    "one can check , for instance , that ( the descriptor of ) event @xmath25 , a collision of balls 3 and 4 , is a function of ( the descriptors of ) event @xmath26 , a collision of 2 and 3 , and @xmath27 , a bounce of 4 against the right end of the gutter .",
    "namely , the time component of @xmath25 descriptor , @xmath28 , is computed as @xmath29 where @xmath30 and @xmath31 are position and velocity of ball @xmath13 , @xmath32 , at time @xmath11 , @xmath33 is the time of event @xmath23 as indicated on the time axis in figure [ gutter ] , and @xmath16 is the ball diameter . as claimed , the right hand - side in is a function of event @xmath27 descriptor , including @xmath34 , @xmath35 , and ( negative ) @xmath36 , and event @xmath26 descriptor , including @xmath37 , @xmath38 , and ( positive ) @xmath39 .    producing the simulated history of a system under study is the goal of a simulation .",
    "the goal is achieved by processing events along the history .",
    "but how do we know which events to process ?",
    "neither the event descriptors nor the topology of the event dependency graph is known in advance .",
    "the event - driven simulation must do both construct the event dependency graph and process the events on it .",
    "the former activity , is also referred to as event _",
    "scheduling_.    the task of designing an efficient scheduling usually constitutes the main difficulty of recasting a time - driven model into an event - driven form .",
    "a well known mechanism of scheduling an event - driven simulation on a uniprocessor is a _ queue of events_. with the queue one is able to insert future events in the schedule , and to retrieve the next event for processing .",
    "a popular data structure @xcite for the event queue is _ heap _ with which either operation is performed in order of @xmath40 computing operations where @xmath0 is the number of events in the queue .",
    "by contrast , a straightforward scheduling method would need order of @xmath0 operations either for retrieving or for inserting or for both .",
    "if @xmath41 , say , then slow down may be substantial .",
    "it should be stressed though , that handling event queue efficiently does not cover the entire task of efficient event - driven simulation @xcite .",
    "the simulationist also has to impose appropriate modeling assumptions .",
    "for example , in the simulation of billiards , were the balls not absolutely hard , the collisions would not be instantaneous . instead of a simple velocity exchange in ,",
    "this would force a ( slow ) time - driven evaluation of the collisions .",
    "equally important for the speed of computation is the assumption of the motion without friction . with friction , the ball motions would not be integrable as simply as in .",
    "the wireless simulations discussed in section [ s : intro ] are naturally of a discrete event type , events being call arrival , termination , handoff , interference measurement , adjustment of the channel segregation order . among few exceptions",
    "is the users mobility .",
    "the users may move along curvy trajectories with variable speeds .",
    "it is decided , however , that the simulated users move with constant velocities along straight line segments . as in the billiards model",
    ", this assumption leads to an event - driven processing .",
    "validity of the simulation results is not seriously affected because a curvy motion with variable velocity can be approximated with a sequence of the motions of the considered type .",
    "selecting a model agreeable with the event - driven mechanism and using an efficient event queue may still be not enough for efficiency of an event - driven simulation .",
    "the following sections will discuss more techniques and approaches toward the goal of a fast multicomponent simulation .",
    "a simulation may generate queries concerning the system state .",
    "the anticipatory method can be defined as constructing answers for questions which have not yet been asked .",
    "it can be contrasted with a `` lazy '' evaluation method according to which generation of the answer is delayed until the latest possible moment when the query is issued .",
    "the anticipatory evaluation tends to be event - driven , while the lazy evaluation time - driven .",
    "let us discuss the two approaches in the following simple example . in the wireless simulation , discussed in section [",
    "s : intro ] , it is necessary to output , as a function of time , the number of mobile users that request but do not obtain a connection .",
    "together with other information , this quantity is to be displayed on the pc screen as the simulation progresses .",
    "thus , given a time increment @xmath4 , for each time instance @xmath42 , the simulation is supposed to report the number of @xmath43 users among all the users present at time @xmath11 .",
    "the lazy method is straightforward : we scan the list of users and depending on whether a user is @xmath43 or non-@xmath43 at time  @xmath11 , increment the corresponding quantity @xmath44 by one or not . before each scanning instance",
    "@xmath11 , we reset counter @xmath44 to @xmath5 .",
    "this is obviously a time - driven method .",
    "the anticipatory method is driven by events . it does not reset or recompute @xmath43 at each reporting time instant .",
    "instead , it maintains the correct value of @xmath43 continuously by updating it appropriately at every event which may change @xmath43 .",
    "such events are : call arrivals to the system , call releases from the system , and users that obtain a connection after a period of retrials . for example , when a user arrives to the system , we would increment @xmath43 by one if the user does not immediately get connected .    note that both solutions `` deliver '' the same value of counter @xmath43 .",
    "this facilitates the development of the simulation program . in the initial phase ,",
    "one may program a simpler lazy solution . then an anticipatory solution should be programmed .",
    "both solutions should then be tried in representative examples , where first we compare values of the results , and then , after the values are found identical , we compare the running times .",
    "an example of the anticipatory data structure is space _ sectorization_. billiards simulation in dimensions two and higher share this method with wireless mobile simulations .",
    "the query , in the case of wireless simulations , may be to locate all the mobiles that are close to a given point @xmath45 on the plane .",
    "similar queries exist in the billiards simulation .",
    "let us consider the wireless simulation case .",
    "there exists a straightforward method to locate all mobiles which are within a given distance  @xmath46 from the point @xmath45 . in this method",
    ", we would find the position @xmath47 of each mobile , compute the distance  @xmath48 from @xmath47 to @xmath45 , and then select those  @xmath49 for which @xmath50 . in practice",
    ", @xmath46  is small and there are just a few such  @xmath49 , but to find them we would have to scan all the mobiles .    a structure that helps reduce the computation cost is partitioning the simulation area into smaller sectors .",
    "the geometry of a sector may be different , a usual choice is a square .",
    "given such a square @xmath51 , there is a set of all the mobiles @xmath52 that are inside it . knowing positions of all the mobiles , we can , of course , find the set @xmath52 using a total scan of all mobiles when a query is offered . in the anticipatory method , we maintain the sets @xmath52 continuously independently of queries .",
    "this entails updating two such sets each time a mobile crosses a demarcation line between the squares ; the crossing becomes an extra event to process .",
    "having invested in this anticipatory structure , we now find the mobiles @xmath46-close to a point @xmath45 in a different manner .",
    "namely , we first determine the square @xmath53 in which @xmath45 is located , then scan nearby squares @xmath51 that intersect with any circle of radius  @xmath46 with center anywhere in @xmath53 , and then check only the mobiles that belong to sets @xmath52 .      the same two query evaluation approaches , anticipatory and lazy , can be considered with respect to web search engines . for many query types , when a search request is submitted on a web search service , a lazy _ on line _ evaluation of the request is non - feasible .",
    "too few users would be willing to wait for the server to scan the world wide web .",
    "the global scanning is being performed but _ off line_. mechanical and manual methods are used to create structures which contain answers to various anticipated questions and mechanisms exist to quickly retrieve these answers concentrated at a few data base sites of the search server .",
    "the `` economics '' of a web server query evaluation and that in a simulation are different , though . in the former , high computational and manual labor costs are justifiable by the need of short response time . in the latter ,",
    "an anticipatory method can be only justified if total computing effort when using the method decreases .    with a lazy evaluation , while there may be high cost of retrieving the answer when needed , no resource is spent for anticipating the question . with an anticipatory evaluation ,",
    "the cost of retrieving the answer may be smaller , but possibly a high investment may be needed for anticipating the question .",
    "anticipatory mechanisms should be advanced only as far as savings on the retrieving end of the balance are higher than spendings on the investing end .",
    "the situation may be illustrated with the following example @xcite of simulating a circuit - switched wired network , like the at&t telephone network . in the model ,",
    "the network consists of @xmath0 nodes that represent the switches and @xmath54 links that connect the nodes .",
    "a link consists of a fixed number ( possibly zero ) of _ trunks_. the model assumes , that if a call is to be carried along some path in the network , then one trunk from each link on the path must be allocated for the exclusive use of the call .",
    "the model also assumes that calls are randomly generated between node pairs ( @xmath55 ) and that a _ routing policy _ decides whether to block ( reject ) such a call or carry it on some path between @xmath56 and @xmath57 .",
    "the simulation is used to assess the quality of different routing policies in terms of the blocking produced for given traffic loads .",
    "consider the _",
    "least busy alternative _ ( lba ) policy and the _ aggregated least busy alternative _ ( alba ) policy . both policies allocate a trunk on the link between nodes @xmath56 and @xmath57 if an idle trunk is available . if not , both offer the call to a two - link path that uses an additional node @xmath58 .",
    "the intermediate node @xmath58 is called the _",
    "via_. in lba policy , the overflowing call is offered to the two - link path that has the most idle capacity .",
    "specifically , path @xmath59 is used if @xmath60 maximizes @xmath61 where @xmath62 is the number of idle trunks currently on link @xmath63 .",
    "if no idle capacity is available - expression is zero for all @xmath58 - then the call is blocked .",
    "the alba policy is a coarsening of lba , which is less costly to implement .",
    "the overflow calls are offered to a two - link path with a minimum _",
    "load class_. load classes are defined by a fixed number of prespecified capacity boundaries .",
    "for instance , three load classes can be defined with boundaries , where say @xmath6480% and @xmath6590% .",
    "if on a given link the proportion of occupied trunks is @xmath66 , then the link belongs to the load class @xmath13 with @xmath67 .",
    "thus , class 1 contains the lightly loaded links , class 2 contains the moderately loaded links , and class 3 contains the heavily loaded links .",
    "the load class of a two - link pass is defined to be the smaller of the load classes of the two links . an overflowing call between @xmath56 and @xmath57 uses a two - link path whose load class is the minimum among all two - link paths between this node pair . if no two - link path has sufficient idle capacity , then the call is blocked .",
    "the query subject to discussion here is finding the via @xmath58 when no idle capacity exists on the direct path @xmath68 .",
    "the `` lazy '' method operates exactly as the definition says : when the query is issued , it scans all possible vias @xmath58 , for each @xmath58 computes the idle capacity and chooses the @xmath58 which yields the maximum to in the case of lba policy , or it chooses a via with the minimum of the load class in the case of alba policy .    an anticipatory data structure may be suggested for the case of lba policy which for each node pair ( @xmath55 ) consists of a list of vias @xmath58 sorted decreasingly according to . whenever a least busy via is needed , the first via in the list is chosen which greatly decreases the computations on the retrieving end of the balance .",
    "on the investing end of the balance , each time a trunk is allocated or freed on any link @xmath69 , the @xmath70 sorted lists for all links ( @xmath55 ) which can use either @xmath71 or @xmath72 as a via have to be updated .",
    "as a result , there is no overall saving if anticipatory approach is used for the lba simulation .",
    "however , for the alba simulation , the anticipatory approach yields a significant improvement comparing with the lazy approach .",
    "the capacity of a link is usually measured in hundreds if not thousands of trunks while there are typically only a few , say three load classes . thus , when a link trunk occupancy changes , the link rarely changes its load class . if the load class does not change , no expensive update of sorted class - via lists is needed .    in the alba case , both lazy and anticipatory methods were tried . while a useful lazy simulation run of the network took more than 100 hours",
    ", the corresponding anticipatory simulation run took 3 to 10 hours on the same uniprocessor .",
    "we now examine event - driven billiards simulations with respect to the topic of anticipatory vs. lazy evaluation .",
    "the query concerning a ball location is better accommodated by the anticipatory sectoring as discussed above .",
    "another basic query in the billiards simulation is : which collision has to be processed next ? in the anticipatory method of d.  rapaport @xcite , the data structure , which accommodates",
    "the answer , includes for each ball a set of all future events which can not be easily excluded .",
    "( future collisions with distant balls in dimensions two and higher can be excluded using the sectoring method . )",
    "the minimum time event in this list is the best candidate event to next occur with the given ball .",
    "the minimum time event among all the best candidates is the query answer .",
    "this event is to be processed next .",
    "maintaining such lists is an easy task for the gutter billiards , as there are only two candidates for a collision with any ball @xmath13 , its left neighbor @xmath73 and its right neighbor @xmath14 .",
    "( the neighbor may be a gutter end for balls 1 and @xmath0 . )    in higher dimensions , the task of maintaining the lists becomes more involved , since many balls can not be excluded beforehand as candidates for future collisions of a ball , even if using the sectoring method .",
    "these anticipatory lists may include large and variable number of candidates and they have to be examined and updated for each event processed .",
    "on the positive side , method @xcite handles easily the collision _ preemption _ which occurs as follows .",
    "suppose the algorithm schedules a collision of two balls , say @xmath74 and @xmath75 , for some future time @xmath76 and this collision becomes the best candidate event to occur for each ball @xmath74 and @xmath75 .",
    "however , before the processing reaches time @xmath76 , a third ball , say @xmath77 , intercepts ball @xmath74 with a collision scheduled to occur at time @xmath78 so that @xmath79",
    ". now , of course , the collision of @xmath74 with @xmath77 becomes the best candidate for @xmath74 .",
    "what should become the new best candidate for ball @xmath75 ?",
    "the answer is ready , anticipated in the list of ball @xmath75 : the previously rated next - best candidate event for ball @xmath75 is upgraded in status to become the best candidate .",
    "this anticipatory event - driven algorithm can be contrasted with the method @xcite , which also presents an event - driven , but `` lazy '' simulation algorithm for billiards . here",
    "only one future event is kept in each individual ball list . maintaining",
    "this structure is easy : when a better candidate emerges , it replaces the old one , which is simply discarded .    however , we should reexamine for the `` lazy '' method the described above collision preemption situation with balls @xmath74,@xmath75 , and @xmath77",
    ". what will be the new candidate event for ball @xmath75 ?",
    "the solution @xcite introduces a new event type on a ball trajectory , an `` advancement '' event .",
    "when processing such an event , the ball is advanced to the new position without changing its velocity .",
    "thus , when the collision between @xmath74 and @xmath75 , which was scheduled for time @xmath76 , is preempted by an earlier collision between @xmath74 and @xmath77 , the new candidate event for ball @xmath75 is such an advancement to the former collision site with ball @xmath74 .",
    "the time of the advancement event is @xmath76 , which is the time of the previously scheduled and then discarded collision of @xmath74 and @xmath75 .",
    "this is similar to the time - driven @xmath4 advancement in ; the lazy method @xcite can be viewed as a fall back to a time - driven mechanism .",
    "however , the lazy method proved to be not slower than the anticipatory method , while the overall algorithm is simpler .",
    "consider in more detail mentioned in section [ s : intro ] econometric model @xcite of two competing telephone providers , name them company 1 and company 2 ( the model generalizes easily to @xmath80 providers ) .",
    "the model also includes @xmath0 telephone customers . at any time",
    "instant @xmath11 each customer subscribes either to company 1 or to company 2 .",
    "let @xmath81 denote the subscription status of customer @xmath13 , @xmath82 , at time @xmath11 , so @xmath83 or @xmath84 .",
    "potential bill amounts @xmath85 can be computed for each customer @xmath13 if being a subscriber to company @xmath86 , @xmath87 .",
    "that is , the service would cost @xmath88 dollars per month to customer @xmath13 if @xmath89 .",
    "for example , to compute @xmath88 under the mci s `` friends and family '' plan , we add up the minutes - per - month customer @xmath13 calls all his / her calling parties who subscribe to the same provider ( here the mci ) , and multiply this by the plan discount price .",
    "then we add the minutes - per - month customer @xmath13 calls the calling parties who subscribe to the other provider , multiplied by the larger regular price .",
    "according to this model , a tendency to switch the provider originates in comparing alternative bills : if @xmath90 then customer @xmath13 wants to be served by provider 1 , and if @xmath91 , then by provider 2 . a customer who subscribes to one provider but wants to be served by the other one is subject to a `` pull '' to the opposite provider .",
    "the intensity of the pull toward provider 1 for customer @xmath13 who is currently with provider 2 in case @xmath90 is expressed by the rate @xmath92 where @xmath93 is an explicitly defined monotonically increasing function .",
    "if such customer @xmath13 is with provider 2 at time @xmath11 , then during a small time interval @xmath94 , customer @xmath13 tosses a coin and switches to provider 1 with probability @xmath95 .",
    "if the switch attempt is not successful , the switch is similarly reattempted during the next interval @xmath96 , then next interval and so on .",
    "a similarly defined `` pull '' toward company 2 affects a customer @xmath13 who is currently served by but is not happy with company 1 .",
    "the switch attempts are statistically independent of each other for different customers within the same @xmath4 interval and they do not depend on the system state before time @xmath11 .",
    "the model assumes an individual calling pattern for each customer @xmath13 ; the pattern is defined by specifying minutes - per - month @xmath97 customer @xmath13 calls each `` friend '' @xmath51 of his / her . the calling habits of the customers are stationary , that is , the calling volume matrix @xmath98 is independent of time .",
    "the parameters of the providers plans , e.g. , prices , are also time - independent .",
    "( these assumptions can be relaxed . ) despite the stationarity , @xmath88 and the strength @xmath99 of the pull may change with time , @xmath100 , @xmath101 .",
    "this is so , because in plans like `` friends and family '' when your call - destination `` friend '' switches the allegiance , it affects your bill .",
    "you become more susceptible to switching to the same provider if your `` friend '' has done so , and that is what plans like `` friends and family '' count upon .      an obvious method of simulating the outlined model",
    "is time - driven , it proceeds exactly as the model states .",
    "time is increased in small @xmath4 steps . at each step",
    "each customer who is not satisfied with the provider randomly attempts to switch .",
    "then based on the new assignments @xmath102 , new @xmath88 and new rates @xmath99 are computed to be valid for the next @xmath4 step .",
    "now we describe an alternative event - driven method of simulating this model .",
    "the method is based on the observation that the sequence of times of switching allegiance for each customer forms a poisson process with the rate @xmath99 which varies in time , @xmath103 .",
    "note that a stationary poisson process ( that with a constant arrival rate @xmath104 ) can be simulated as a sequence of arrival times @xmath105 with independent distributed exponentially with mean @xmath106 interarrival times .",
    "that is , given arrival @xmath107 , to sample @xmath108 one draws an independent sample @xmath109 of a random value uniformly distributed in @xmath110 , and then one computes @xmath111 .    the poisson property is preserved when several arrival processes are aggregated into a single arrival process .",
    "say , we have @xmath0 poisson arrival processes and @xmath13th process has arrival rate @xmath112 , @xmath113 .",
    "the aggregate process is defined as the one that has an arrival when any component process does .",
    "so defined , the aggregate is also a poisson process .",
    "the arrival rate of the aggregate is @xmath114 .",
    "one way of arranging an event - driven simulation of the competition between the telephone providers is as follows .",
    "a next anticipated switch event is associated with each of the @xmath0 customers . the event time is generated by sampling the exponential distribution with the current rate of `` pull '' discussed above .",
    "the case of rate 0 is reserved for customers who are satisfied with the provider .",
    "such a customer does not wish to switch and the next switch time is set to infinity .",
    "the event queue is arranged as usual .",
    "processing each customer switch modifies some rates @xmath99 .",
    "this , in turn , modifies the time remaining to switch in the events scheduled for the affected customers ; sometimes it may reduce the rate to 0 which would postpone the switch event to the infinite future .    having the poisson property preserved under the aggregation",
    ", the event - driven simulation of this model can be arranged in a different way without presampling and then updating future switch events and without the event queue . in the alternative method ,",
    "these are replaced with the following _ poisson dispenser _ mechanism .",
    "a single poisson arrival stream with rate @xmath115 is generated and then is being `` dispensed '' among the component poisson streams in accordance with their partial arrival rates @xmath116 , larger the @xmath116 more probable is to delegate an arrival of the aggregate process to customer @xmath13 s process .",
    "rate @xmath116 of a component poisson process may experience changes within the time interval between the consecutive arrivals of the component process .",
    "by contrast , the aggregate rate @xmath115 remains constant between arrivals of its process .",
    "hence the interarrivals of the aggregate are distributed exponentially ; once next event is scheduled its time never gets changed or postponed .",
    "this simplifies and speeds up the computing .",
    "the dispenser procedure consists of the cyclic repetition of the two steps specified below ; the execution begins with @xmath117 and current time @xmath118 .",
    "+   +   +   +   + this procedure is formulated above for a general multicomponent system . in the considered example , a telephone customer is a component , and the state change of component @xmath13 is switch @xmath119 of the telephone provider for customer @xmath13 , where map @xmath120 turns 1 into 2 and 2 into 1 as required to effect the provider switch .",
    "since after the switch the customer is `` happy '' with the new provider , the new arrival rate in step 2 is zero ; it may become positive again later as a result of `` friends '' switching .",
    "also , values @xmath121 , are indeed a probability distribution , as @xmath122 and @xmath123 .    in a straightforward method",
    "the selection in step 2 is implemented as follows .",
    "first , we draw an independent sample @xmath109 of a random value uniformly distributed in @xmath110",
    ". then we scan monotonically non - decreasing sequence @xmath124 , @xmath125 , ... @xmath126 , ... @xmath127 , fitting value @xmath128 between consecutive terms @xmath129 .",
    "this is possible , since @xmath130 .",
    "the found @xmath13 is index of the customer to whom the arrival is delegated .",
    "unfortunately , an order of @xmath0 computations is required for the scanning and this is slow for a large @xmath0 .",
    "better methods exist .",
    "figure [ tree ] exemplifies the binary tree method in which the component @xmath13 is found in @xmath131 steps ( if @xmath0 is a whole degree of 2 ; otherwise @xmath132 steps ) .",
    "this method also starts with an independent sample @xmath109 of a random value uniformly distributed in @xmath110 .",
    "then , instead of a linear scan , a binary tree is traced to fit this value .",
    "the tracing is started from the root which is entered with @xmath133 .",
    "we then steer our way down the tree in @xmath131 steps . at step @xmath134 ,",
    "having value @xmath135 , @xmath136 , we enter node with inscription @xmath137 on it .",
    "if @xmath135 happens to be smaller than @xmath138 , then we go to the left branch @xmath138 producing @xmath139 .",
    "if @xmath140 , then we go to the right branch @xmath141 producing @xmath142 .    to maintain current the weights on the tree , each time a rate @xmath99 changes , the contents of @xmath143 nodes is updated .",
    "the update begins with the bottom node @xmath13 , continues up , and terminates at the root .",
    "a useful simulation run is the switching history of several thousand customers during a few simulated years .",
    "a time - driven version takes several computing hours to complete the run .",
    "the corresponding event - driven version with a poisson dispenser implemented using the binary tree , takes several seconds .",
    "the latter version allows one to easily simulate markets of a much larger size while keeping the running time bearable .",
    "for example the behavior of a 100,000-customer market during several simulated years can be simulated in less than 2 minutes .",
    "another application for the dispenser technique , is an _ ising spin model _",
    "@xcite in computational physics . as a computational mechanism ,",
    "the ising spin simulation is very similar to the econometric model of competition between the telephone providers which has been just discussed .",
    "@xmath0 ferromagnetic particles are in place of @xmath0 telephone customers . an external magnetic field pulling the particles so that they would align in the field s direction plays the role of the economic incentive for customers to `` align '' their allegiance to the provider which gives best saving .",
    "and the additional local magnetic field around a particle when its neighbors have already aligned is analogous to the additional incentive for a customer to switch the provider when the customer s calling parties have done so .",
    "specifically , the magnetic state called _ spin _ of each particle @xmath13 , takes on two values , @xmath144 or @xmath145 .",
    "depending on the current spins @xmath146 of the near - neighbors @xmath51 of particle @xmath13 , pulls to flip @xmath83 to @xmath147 and to flip @xmath148 to 1 are defined .",
    "the dependence involves external field direction and intensity .",
    "( the form of this dependence is not essential for the present discussion . ) similarly to the model discussed before , the flip mechanism is probabilistic .",
    "simulation of the dynamics of ising spins can thus be arranged using the efficient binary tree poisson dispenser mechanism discussed above . in this method flipping one spin takes @xmath149 computations .",
    "one feature in the ising model is different from the telephone competition model though .",
    "the ising particles are arranged in a regular fashion .",
    "for example , they are placed in vertices of a two - dimensional square lattice where each particle has four near - neighbors : at the north , east , south , and west . by contrast , the calling volume matrix @xmath97 which defines calling parties of a customer is not assumed to be regular . because of the regularity in the ising model , for any particle , there is only a small number of possible combinations of neighboring particle states .",
    "let us count these combinations , say , for a planar square grid arrangement of the particles .",
    "each of the north , east , south , and west spin can take on 2 values , which yields 16 combinations .",
    "the particle itself can be in the two spin states .",
    "hence there are at most 32 different combinations each of which may define a different pull - to - flip rate .",
    "therefore there are at most 32 different rates and this finite set is the same for all @xmath0 particles .",
    "( examining the form in which the rate depends on the combination , this set further reduces to only 10 different rates @xcite . ) thus , each of the @xmath0 leaves in the dispenser tree contains one of a small number of possible values .",
    "the finiteness allows one @xcite to improve the poisson dispenser algorithm so that delegating one arrival of the aggregate process to a component process takes a constant amount of computations , instead of @xmath149 computations .",
    "sequential random update is a general mechanism for modeling evolution of a multicomponent dynamic system . in this model",
    ", we consider a system with @xmath0 components , the state of the system is composed of states @xmath102 of its components , the system state changes at discrete instances @xmath150 according to the following cyclic procedure .",
    "+   +   +   +   + both the ising spin model and the model of competition between telephone providers discussed in section [ s : poisson ] fit the sequential random update scheme , if two transformations are made : 1 ) uniformizing the event arrival rates among the system components , 2 ) abandoning the continuous time and retaining only the update counter @xmath49 .",
    "the latter transformation is obvious .",
    "let us explain the former one .",
    "we choose an upper bound @xmath151 on the event arrival rates @xmath116 among the components .",
    "this can be easily done in the ising model : @xmath151 is the largest among the finite number of possible rates @xmath99 , see the discussion in section [ ss : ising ] . in the provider competition model ,",
    "the most `` unhappy '' customer yields the upper bound on the switch rate .",
    "we attribute the same rate @xmath151 to all components so that the components are selected with equal probability as required in step 1 above .",
    "suppose a component @xmath13 at step 1 is selected . to compensate for the smaller rate with which the component @xmath13 is being updated",
    ", we make an additional coin toss and choose to update state @xmath102 in step 2 with probability @xmath152 . with the complimentary probability @xmath153 the state does not change .",
    "the no - change of state @xmath102 does not violate the format of the procedure ; it is a special case of the update when @xmath154 .",
    "the model of circuit - switched wired network discussed in section [ s : lazy ] almost fits this scheme , if we take @xmath155 links between the switches as components and equate the number of occupied trunks on a link with the state of the component .",
    "if different node pairs @xmath156 have different call arrival rates , we uniformize the rates as in the previous two models . the feature that does not fit the scheme is that when a call request arrives between a node pair @xmath157 and is placed via node @xmath58 instead of the direct link , the state of components @xmath158 and @xmath159 is updated instead of the state of the original component @xmath157 .",
    "other instances of the sequential random update include cellular arrays and neural nets .",
    "we will now discuss an example @xcite of a _",
    "ballistic particle deposition_. the deposition model is aimed at studying morphology of amorphous layers growing on planar substrates , the subject of interest to material scientists . in the model , spheres of equal diameters",
    "1 are falling vertically down toward the flat horizontal surface , see an example in figure [ 100disk ] .",
    "the deposition process is arranged as follows .",
    "particles are deposited one at a time . to deposit a particle , first its center @xmath160 coordinate",
    "is sampled randomly and uniformly over the adsorbing range .",
    "the range is segment ( 0,10 ) in figure [ 100disk ] .",
    "different particles have their @xmath160 generated independently of each other . the initial height of the center , is chosen sufficiently high above the surface .",
    "then the particle is falling vertically down until a contact occurs .",
    "for the particles that begin the process , the contact is likely to be with the adsorbing surface . later in the process",
    ", a falling particle is more likely to contact a stationary one , deposited before . in either case",
    ", the first contact instantly stops the incoming particle thus defining its @xmath161 coordinate .",
    "the ballistic deposition scheme is an instance of the random sequential update .",
    "we split the adsorbing range into sectors of equal measure ( congruent segments in 2d or planar figures of equal area in 3d ) and declare sectors to be the components of the system .",
    "the particle order index @xmath49 becomes the update order index .",
    "the state @xmath162 of component @xmath13 consists of the coordinates of those among the first @xmath49 particles , that have been deposited over sector @xmath13 .",
    "that is , say in a two dimensional case , the @xmath160 of those particles centers must be in segment @xmath13 .    a particle from sector @xmath13 but located close to the sector s boundary may attach itself to a particle which was earlier deposited in sector @xmath51 , @xmath163 .",
    "that is how components / sectors @xmath51 may get involved in the state update of component @xmath13 in step [ stateupd ] of the sequential update scheme .",
    "whereas figure [ 100disk ] represents a small - scale `` educational '' example of deposition in two dimensions , interesting simulations are in three dimensions with two dimensional adsorbing range of a size larger than say 1000@xmath1641000 .",
    "many millions if not billions of particles are supposed to be processed . figure [ cumden ] presents particle density as a function of both time and height @xmath161 in a three dimensional deposition of 100 million particles . running such an experiment on a workstation",
    "would take about a week of execution time .",
    "can parallel processing be employed to speed up the deposition and other sequential update schemes ?",
    "one idea of making the update scheme parallel may be to have a parallel computer dedicate @xmath0 processing elements ( pes ) to the @xmath0 components of the system so that @xmath165 would host component @xmath13 , @xmath166 .",
    "the components would be updated concurrently without an organizing order .",
    "@xmath165 would repeatedly update the state of component @xmath13 , asynchronously obtaining from other pes the current values of states of those components @xmath51 which are required for computing the new value of state of component @xmath13 .",
    "this proposal can be criticized from several viewpoints .",
    "the most basic objection is that it violates the standard model of reproducible computer execution .",
    "this entails various shortcomings .",
    "the generated trajectory of the system may be different from that generated sequentially .",
    "say in the deposition example , the deposit structures generated in parallel may be statistically different from those generated sequentially .",
    "moreover , the state change trajectories resulted in different runs of the same system with the same initial states , in general , will be different .",
    "this is very inconvenient as it makes both studying the obtained structures and debugging the simulation program very difficult .",
    "another proposal is to use @xmath167 pes .",
    "a single `` master '' pe would be dedicated to dispensing the updates among the components .",
    "the @xmath0 `` slave '' pes would host the @xmath0 components .",
    "a `` slave '' would be responsible for updating the state of the hosted component . without further elaboration of the `` master - slaves '' scheme",
    ", we note that it can be organized so that the computations are reproducible and generate trajectories identical to those in the sequential procedure .",
    "moreover , for a small number of pes , the procedure may even be efficient . however , it does not scale for a large number of pes .",
    "the sequential dispensing performed by the `` master '' becomes a bottleneck for a large @xmath0 .      in the example of ballistic deposition",
    ", we now describe another method of running the sequential random update scheme in parallel .",
    "unlike the `` chaotic '' and the `` master - slaves '' methods , this method possesses both desirable properties : it generates a reproducible , correct simulated trajectory , and its good performance scales to a large size systems and large number @xmath0 of pes .",
    "the first step of the method is a reformulation of the sequential random update scheme in continuous time . in the old formulation",
    "the components are updated at discrete instances @xmath168 . in the new formulation",
    "the components are updated at instances @xmath169 of the continuous time , the instances constitute a poisson process . an arbitrary positive @xmath170 is chosen and fixed . the rate of the poisson process is @xmath171 .",
    "it follows , that each of the @xmath0 component processes also has arrivals that form a poisson process .",
    "the component processes will be mutually independent .",
    "the rate of each component process will be @xmath170 .",
    "of course , in the ising spins simulation model and in the provider competition model we have the poisson processes to start with .",
    "we can reuse them with their original rates for the purpose of rendering the models in parallel .",
    "however , in the deposition model , the poisson process is an additional structure , introduced only for the purpose of running the model in parallel .    in the poisson dispenser method discussed in section [ s : poisson ] , we aggregated arrivals of individual components into a single stream which was to be sampled by the sequential computer . here",
    "we do the opposite , namely , disaggregate the summary poisson arrival stream into the independent streams of the components and let each component @xmath13 stream be sampled by a separate @xmath165 which would be also responsible for maintaining state @xmath102 of component @xmath13 .",
    "let @xmath172 denote the poisson clock maintained by @xmath165 .",
    "that is , changes of state @xmath102 occur at time instances @xmath173 .",
    "in the beginning of simulation each @xmath165 sets its poisson clock @xmath172 to 0 and has @xmath102 assume its initial value .",
    "then each @xmath165 asynchronously from other pes executes the following procedure , which can be called `` cautious advancements . ''",
    "+   +   +   +   + the pes may execute this procedure with no other synchronization than that in the wait statement in step [ wait ] , which is supposed to assure the `` cautious advancement '' of local times @xmath174 . because of the asynchrony , it might be not obvious that the procedure is correctly defined , let alone works correctly .",
    "for example , if concurrently with @xmath165 updating @xmath102 and using state values @xmath175",
    ", @xmath176 is changing @xmath175 , is the state update in step [ pstateupd ] well defined ?",
    "it was shown @xcite that the cautious advancement scheme is correctly defined , works and is correct .",
    "specifically , with probability 1 , during an update of state @xmath102 , other states @xmath175 , the values of which are used in the @xmath102 update , are not themselves being changed .",
    "cautious advancement is deadlock - free : no pe waits forever in step [ wait ] .",
    "the sequence of updates obtained by merging the sequences of component updates generated by each pe is statistically identical to the sequence generated by the sequential procedure .",
    "reproducibility also takes place : if the cautious advancement procedure is executed twice with the same initial settings , including the same seeds of pseudorandom number generators , used for sampling poisson arrivals , then the two resulting sequences of state updates will be identical with probability 1 .",
    "this is despite that execution timings in different runs may be different .    to get insight into the behavior of the cautious advancements ,",
    "consider a simple example presented in figure [ tlines ] .",
    "time lines of 10 components of a simulated model are depicted . for concreteness",
    ", we assume that the model represents the deposition of unit diameter circular particles over the segment of length 10 as in figure [ 100disk ] . in the latter case",
    ", the substrate segment ( 0,10 ) is divided into 10 smaller segments : [ 0,1),[1,2), ...",
    "segment [ @xmath177 ) is component @xmath13 and it is hosted by @xmath165 .",
    "dots on the time lines mark the poisson arrivals . at each arrival to segment [ @xmath177 ) ,",
    "a particle with coordinate @xmath160 , @xmath178 , is deposited . given that both the particle diameter and component segment length are unity , to know the landing height of the particle , there is no need to know positions of particles previously deposited over segments that are more than one component - segment away .",
    "however , a caution is exercised with respect to the immediate left and right neighbors of segment [ @xmath177 ) .",
    "@xmath165 only deposits a particle at time @xmath174 if its two neighbors advanced their simulated times to reach or exceed @xmath174 .",
    "the immediate left neighbor is segment [ @xmath179 ) , unless @xmath180 .",
    "the immediate right neighbor is segment [ @xmath181 ) , unless @xmath182 .",
    "points 0 and 10 representing the same point , the immediate left neighbor of component 1 is component @xmath0 , whose immediate right neighbor is component 1 . to be able to relate the arrival times for neighbors 1 and @xmath0 , the time line of component 1",
    "is drawn twice .",
    "although no additional synchronization is necessary for correctness and efficiency of the general cautious advancement procedure , it would help in understanding the procedure of deposition , if we assume that it is executed in lockstep .",
    "that is , no pe executes step 2 , before step 1 is completed by all the pes that are non - waiting at step [ wait ] of a preceding cycle .",
    "then , in step [ wait ] , all pes check the simulated times achieved by their neighbors . as a result , the set of all pes splits into those able to proceed further , and the rest which must wait .",
    "the non - waiting pes begin step [ pstateupd ] only after all pes have finished the checking in step [ wait ] .",
    "finally , the new cycle by the non - waiting pes begins not earlier , than all the non - waiting pes have updated their state , i.e. , deposited a particle .",
    "the lockstep execution enables us to say at which cycle each state update occurs , that is , each particle gets deposited .",
    "in the situation of figure [ tlines ] , @xmath183 , @xmath184 , and @xmath185 are lucky to process an event at cycle 1 , while the rest of pes are waiting .",
    "values @xmath186 , and @xmath187 get advanced to the second arrival time and as a result @xmath188 , @xmath189 , @xmath190 , and @xmath191 can process their events at cycle 2 .",
    "values @xmath192 , and @xmath193 get advanced to the second arrival time and as a result @xmath184 is lucky again and processes its second event .    in figure [ tlines ] ,",
    "the cycle - per - event assignment is followed up to cycle 10 . as an exercise",
    ", the reader may continue the task for the following cycles .",
    "the computational efficiency is determined by the fraction of non - waiting pes at each cycle .",
    "this fraction is close to 25% on average in the example shown .",
    "looking at the picture it seems likely that the fraction remains bounded from below and separated from zero when the size of the system gets larger and number of pes increases proportionally .",
    "mathematical studies @xcite of this assertion confirm it in a general case .",
    "this means scalability of the parallel simulation performed by the cautious advancement mechanism . using additional methods @xcite , in particular , allowing one pe to hold a larger sector or segment ,",
    "the efficiency can be substantially increased , e.g. , from 25% to 60% and higher .",
    "the mentioned above 100 million particle deposition experiment was run on a maspar mp-1216 computer with 16,384 pes .",
    "the run took 620 seconds ( instead of a week on a workstation ) .",
    "it becomes clear from the deposition example , that the efficiency of the cautious advancement parallel method for sequential random update depends on the topology of the connections among the components .",
    "the sparse fixed connections and a large diameter of the connection graph increase the efficiency .",
    "a small - diameter graph with all - to - all connections or close to such makes the pes to be too cautious ; too few of them would be non - waiting . in the worst case only one pe dares to advance the local time during a cycle while all the other pes are cautiously waiting .",
    "that is the case in the circuit - switched network simulation , where node pairs @xmath156 are close to each other in the sense of network connectivity .",
    "even if we somehow resolved the difficulty that this model does not completely fit the random sequential update model as discussed in the beginning of the section , its parallel execution by the described method would not be efficient .",
    "however , the actual event dependency along the executional path is rather sparse which presents an opportunity for parallelism .",
    "unfortunately , this parallelism is not extracted by the cautious advancement method , because the method requires a variable event dependency graph to be upper bounded by the fixed component connectivity graph .",
    "ising model and the phone provider competition model have a sparse component connectivity , but they still may fail to produce an efficient simulation using the described technique .",
    "this is because , for example in the ising model , among the parameters the spin flip rate depends on is the temperature @xcite , and a low temperature causes the ratio between a particle update rate and its upper bound to be large .",
    "even though a high enough fraction of pes do not wait with processing their events , most of the processed events are trivial time advancements without a flip .",
    "this ruins the efficiency of the parallel execution in low temperature regimes",
    ".    a successful use of the cautious advancement technique and its further developments for an ising model at a non - very - low temperature has been demonstrated @xcite with the model running on 400 pes of a parallel supercomputer t3e and yielding a speedup of 260 .",
    "another example is a wireless simulation @xcite where the calls are dynamically arriving at random positions in the service area according to a fixed distribution and the users are not moving during the calls . with such assumptions it is possible to arrange a variant of efficient cautious advancement parallel processing .",
    "next section discusses an alternative method of parallel execution .",
    "it aims to extract parallelism as it emerges during the execution rather than relying on a worst case estimate given by the connectivity graph .",
    "also it needs no uniformization of the event arrival rates .",
    "as in section [ s : sequent ] , we consider a discrete event simulation of a dynamic system with @xmath0 components .",
    "the simulation is to be performed on a parallel computer with @xmath0 processing elements .",
    "as before , the procedure is to give each pe a component to host , and have the pe produce the state change history of that component .",
    "the method to do so will be different from the one discussed in section [ s : sequent ] .",
    "unlike the previous method in which the event processing is final , the present method involves speculative computations wherein an event can be processed and then later rejected .",
    "the procedure was called _ synchronous relaxation_@xcite .    in this procedure",
    ", each pe keeps track of the simulated time before which no event is to be rejected in the course of further processing ; this quantity is called _ committed time . _ the pes increase the committed time in lockstep , its value is common to all pes .",
    "each step consists of several iterations . at each iteration , while the committed time value does not change , each pe produces a speculative state change trajectory of the component it hosts beyond the committed time .",
    "the pe extends the trajectory until its local time reaches the committed time plus @xmath4 , where @xmath4 is the step size of committed time increases . unlike the @xmath4 of a time - driven simulation discussed in section [ s : edr ] , here",
    "@xmath4 does not define the accuracy of simulation and may be not small .",
    "since components are , in general , connected , to produce a correct trajectory of its component , a pe needs to know the correct histories of other components .",
    "but they are not known , because other pes are in the same quandary .",
    "the mechanism of generating the correct trajectories is by iterations . during the first iteration",
    ", each pe makes the simplest assumption about the trajectories of the other components , for example , that the other trajectories are empty of events , i.e. , states do not change .",
    "this will enable the pe to produce the hosted component trajectory .",
    "after every pe generates the speculative trajectory for additional @xmath4 units , they compare the trajectories .",
    "this comparison phase is started only after all pes have generated the trajectories . as a rule",
    ", a pe will detect inconsistencies between the assumed and actually generated trajectories of other components .",
    "if so , pes perform more iterations .    during subsequent iterations ,",
    "if a pe needs to know the trajectory of a component hosted by another pe , it uses the trajectory generated in the last iteration .",
    "the goal of producing correct trajectories at a step is achieved if no pe detects any inconsistencies between the assumed and actually generated trajectories of other pes .",
    "once this happens , all pes increase committed time by @xmath4 and continue .",
    "the synchronous relaxation parallel algorithm @xcite , used on a maspar computer with 16,384 pes , cuts the running time of simulating a circuit - switched wired network to a few minutes ( from several hours in the best sequential implementation on a fast workstation ) .",
    "naturally , the efficiency of the synchronous relaxation method relies on the convergence to be achieved at each step in a small number of iterations . to assess the number of iterations we examine the event dependency graph . for the event chains like the one in figure  [ chain ] there will be many iterations .",
    "figure [ chain ] depicts an artificially difficult , worst case example .",
    "such event dependency graph may correspond to a single indivisible object which moves in space visiting the areas hosted by different pes .",
    "it is not feasible to make an efficient parallel simulation in such a special example .    in figure [ levels ] , on the other hand , an `` average '' example is presented .",
    "it is obtained by randomly `` sprinkling '' the events - circles and possible event dependency links on the time - space diagram , without a particular application in mind . a good upper bound on the number of iterations",
    "can be supplied by counting _",
    "levels_. the levels can be identified without knowing the system partitioning into components hence no such partitioning is shown in figure  [ levels ] .",
    "level 0 consists of already processed events that are positioned below the @xmath4 strip .",
    "level 1 consists of those events at or above the lower boundary of the strip , which are immediate effects of only level 0 events . by induction ,",
    "level @xmath86 consists of the events at or above the lower boundary of the strip , whose immediate causes are events at levels @xmath194 . in addition , to qualify for being on level @xmath86 , the event must have al least one event on level @xmath195 among its immediate causes .",
    "before the step begins , all level 0 events are correct .",
    "after all the pes generate their trajectories at iteration 1 , all level 1 events at least will be among the correctly settled events .",
    "it can be seen by induction that after iteration @xmath86 , all events on level @xmath86 or lower are correct .",
    "thus , the number of levels for those events of the event dependency graph that fit within the considered @xmath4-strip is an upper bound on the number of iterations needed for correctly determining all events for this strip .",
    "the actual number of iterations can be smaller than this upper bound for two reasons : 1 ) initial guesses of events are correct , 2 ) the event dependency subgraph hosted by a pe contains a complete set of cause - effects for several levels without need to know events in the neighboring pes .",
    "situation 1 is not always negligibly rare : in the applications in which there are only two choices for an event , reasonable initial guessing might save iterations .",
    "an extreme case of situation 2 is completely independent subsystems hosted by different pes , or , for that matter , just a single pe which hosts the entire system . in these conditions ,",
    "all events are determined correctly at the first iteration .",
    "the question remains : how many event levels fits in the @xmath4-strip on an `` average '' ?",
    "a conjecture can be proposed which says , that , in a `` generic '' example , if @xmath0 tends to infinity , the `` average '' number of levels increases not faster than @xmath40 .",
    "this has been established in several applications , for example , in the simulation of circuit - switched networks @xcite .",
    "one may notice a similarity of the synchronous relaxation algorithm and the time warp algorithm @xcite .",
    "indeed , both algorithms use speculative event processing .",
    "the time warp procedure can be qualified as an _ asynchronous _ relaxation . instead of frequent synchronization",
    ", the original tw procedure allows each pe to proceed at its own pace , without explicitly synchronizing with other pes . as a result of tighter synchronization ,",
    "the synchronous relaxation performs better than the tw in a worst case .",
    "the tw is known to sometimes enter undesirable modes like rollback avalanche or cascading , which might slow down unduly even well parallelizable simulations . unlike the synchronous relaxation , no mathematical guarantee of scalability of the tw algorithm to a large @xmath0 has been offered .    whenever there is a choice between a method with speculative computations and a method without , if both methods should deliver a scalable parallel simulation , the non - speculative method should be taken because speculative computations always involve a heavy computing overhead .",
    "sometimes for the same simulation model in some regimes one can do well without speculative computations , while in the other regimes one can not .",
    "such is the ising model example .",
    "the uniformization entails a heavy overhead only for a low temperature and then synchronous relaxation is warranted . for higher temperatures ,",
    "the method discussed in section [ s : sequent ] provides a reasonable alternative .",
    "there are many aspects in computer simulations , such as visualization , user interface , convenience and efficiency of programming etc .",
    "the aspect which comes first in simulating large dynamic systems is that of computing efficiency .",
    "a lesson learned from experiences in such tasks is that computing efficiency is determined by the properties of the underlying computational technique whereas the choice of the best technique is not defined by the modeling area",
    ". the same algorithmic idea may work well across diverse applications and modeling areas .",
    "another lesson is that no single `` silver bullet '' technique for efficient simulation has been offered thus far and that a concrete simulation model may need a combination of available techniques to work fast .",
    "sometimes one has to modify the model to fit a good technique . yet in other cases very substantial improvements in computing speed are achieved if a basic technique is modified or augmented to fit the application , rather than being used in a fixed `` prepackaged '' form .",
    "s.  eick , a.g .",
    "greenberg , b.d .",
    "lubachevsky , and a.  weiss ,  synchronous relaxation for parallel simulation with applications to circuit switched networks , \" _ acm trans .  on modeling and computer simulation * 3 * _ , no .  4 , pp .",
    "287314 , 1993 .",
    "greenberg , b.d .",
    "lubachevsky , d.m .",
    "nicol , and p.e .",
    "wright ,  efficient massively parallel simulation of dynamic channel assignment schemes for wireless cellular communications , \" _ proc .",
    "8th workshop on parallel and distributed simulation , pads94 _ , edinburgh , scotland , uk , pp.187 - 194 .",
    "linhart , b.d .",
    "lubachevsky , r.  radner , and m.j .",
    "meurer ,  ` friends and family ' and related pricing strategies , \" proc .",
    "2nd russian - swedish control conference , aug . 1995 , st.petersburg state technical university , russia , pp . 192 - 196 ."
  ],
  "abstract_text": [
    "<S> a computer simulation has to be fast to be helpful , if it is employed to study the behavior of a multicomponent dynamic system . </S>",
    "<S> this paper discusses modeling concepts and algorithmic techniques useful for creating such fast simulations . </S>",
    "<S> concrete examples of simulations that range from econometric modeling to communications to material science are used to illustrate these techniques and concepts . </S>",
    "<S> the algorithmic and modeling methods discussed include event - driven processing , `` anticipating '' data structures , and `` lazy '' evaluation , poisson dispenser , parallel processing by cautious advancements and by synchronous relaxations . </S>",
    "<S> the paper gives examples of how these techniques and models are employed in assessing efficiency of capacity management methods in wireless and wired networks , in studies of magnetization , crystalline structure , and sediment formation in material science , in studies of competition in economics . </S>"
  ]
}