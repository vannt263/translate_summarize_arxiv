{
  "article_text": [
    "discrete - event systems  @xcite ( des ) can be modelled by finite automata over an alphabet of actions / events @xmath0 .",
    "the fault diagnosis problem  @xcite for des consists in detecting _",
    "faulty _ sequences in the system . a _",
    "faulty _ sequence is a sequence of the des containing an occurrence of a special event @xmath1 .",
    "it is assumed that an external _ observer _ which has to detect faults , knows the specification / model of the des , but can partially observe the system at runtime : it is able to observe sequences of _ observable _ events in @xmath2 . based on this knowledge",
    ", it has to announce whether an observation ( in @xmath3 ) stems from a faulty sequence ( in @xmath4 ) .",
    "checking diagnosability of des can be done in ptime and computing a diagnoser amounts to determinizing the des ( exptime )  @xcite .    _ * fault diagnosis for timed automata . * _ the fault diagnosis problem for timed automata ( ta ) has been introduced and solved by s.  tripakis in  @xcite , where he proved that checking diagnosability of a timed automaton is pspace - complete . in the timed case however , the diagnoser may be a turing machine .",
    "in a subsequent work by p.  bouyer  and f.  chevalier  @xcite , the problem of checking whether a timed automaton is diagnosable using a diagnoser which is a _ deterministic _ timed automaton ( dta ) was studied , and they proved that this problem was 2exptime - complete .    _ * our contribution and related work . * _ in  @xcite ( and  @xcite for an extended version ) , we have introduced _ dynamic observers _ for fault diagnosis of des . in this framework , an observer can choose dynamically which events it is going to observe and make a new choice after each occurrence of any ( currently ) observable event .",
    "in  @xcite we have shown how to compute ( 2exptime ) a _ most permissive observer _ which represents all the the dynamic observers that ensures that a des is diagnosable . in  @xcite",
    "we have furthermore introduced a notion of _ cost _ of an observer , and proved that an optimal observer could also be computed in 2exptime .    in this paper , we extend the previous results for systems given by timed automata .",
    "we first settle the complexity of some optimization problems with static observers ( section  [ sec - static ] ) .",
    "we then focus on dynamic _ timed _ observers , and show how to compute ( section  [ sec - dynamic ] ) a most permissive ( timed ) dynamic observer , under the assumption of bounded _ resources_. in section  [ sec - cost ] , we define a notion of _ cost _ for timed observers ( which extends the one we have defined for des in@xcite ) and show how to compute the cost of a given observer . we also discuss the problem of synthesizing an optimal timed dynamic observer .",
    "@xmath0 denotes a finite alphabet and @xmath5 where @xmath6 is the _",
    "unobservable _ action .",
    "@xmath7 is the set of boolean values , @xmath8 the set of natural numbers , @xmath9 the set of integers and @xmath10 the set of rational numbers .",
    "@xmath11 is the set of real numbers and @xmath12 is the non - negative real numbers .      let @xmath13 be a finite set of variables called _ clocks_. a _ clock valuation _ is a mapping @xmath14 .",
    "we let @xmath15 be the set of clock valuations over @xmath13 .",
    "we let @xmath16 be the _",
    "zero _ valuation where all the clocks in @xmath13 are set to @xmath17 ( we use @xmath18 when @xmath13 is clear from the context ) . given @xmath19",
    ", @xmath20 denotes the valuation defined by @xmath21 .",
    "we let @xmath22 be the set of _ convex constraints _ on @xmath13 , the set of conjunctions of constraints of the form @xmath23 with @xmath24 and @xmath25 . given a constraint @xmath26 and a valuation @xmath27",
    ", we write @xmath28 if @xmath29 is satisfied by @xmath27 .",
    "given @xmath30 and a valuation @xmath27 , @xmath31 $ ] is the valuation defined by @xmath31(x)=v(x)$ ] if @xmath32 and @xmath31(x)=0 $ ] otherwise .",
    "the set of finite ( resp .",
    "infinite ) words over @xmath0 is @xmath33 ( resp .",
    "@xmath34 ) and we let @xmath35 .",
    "we let @xmath36 be the empty word .",
    "a _ language _",
    "@xmath37 is any subset of @xmath38 .",
    "a finite ( resp .",
    "infinite ) _ timed word _ over @xmath0 is a word in @xmath39 ( resp .",
    "@xmath40 ) .",
    "@xmath41 is the duration of a timed word @xmath42 which is defined to be the sum of the durations ( in @xmath12 ) which appear in @xmath42 ; if this sum is infinite , the duration is @xmath43 .",
    "note that the duration of an infinite word can be finite , and such words which contain an infinite number of letters , are called _ zeno _ words .",
    "@xmath44 is the set of finite timed words over @xmath0 , @xmath45 , the set of infinite timed words and @xmath46 .",
    "timed language _ is any subset of @xmath47 .    in this paper",
    "we write timed words as @xmath48 where the real values are the durations elapsed between two letters : thus @xmath49 occurs at global time @xmath50 .",
    "we let @xmath51 be the _ untimed _ version of @xmath42 obtained by erasing all the durations in @xmath42 , @xmath52 .",
    "given a timed language @xmath37 , we let @xmath53 .",
    "let @xmath54 be the projection of timed words of @xmath47 over timed words of @xmath55 .",
    "when projecting a timed word @xmath42 on a sub - alphabet @xmath56 , the durations elapsed between two events are set accordingly : for instance @xmath57 ( projection erases some letters but keep the time elapsed between two letters ) . given @xmath56 , @xmath58 .",
    "timed automata ( ta ) are finite automata extended with real - valued clocks to specify timing constraints between occurrences of events . for a detailed presentation of the fundamental results for timed automata ,",
    "the reader is referred to the seminal paper of r.  alur and d.  dill  @xcite .",
    "[ def - ta ] a _ timed automaton _",
    "@xmath59 is a tuple @xmath60 @xmath61 @xmath62 where : @xmath37 is a finite set of _ locations _ ; @xmath63 is the _ initial location _ ; @xmath13 is a finite set of _ clocks _ ; @xmath0 is a finite set of _ actions _ ; @xmath64 is a finite set of _ transitions _ ; for @xmath65 , @xmath29 is the _ guard _ , @xmath66 the _ action _ , and @xmath67 the _ reset _ set ; @xmath68 associates with each location an _ invariant _ ; as usual we require the invariants to be conjunctions of constraints of the form @xmath69 with @xmath70 .",
    "@xmath71 and @xmath72 are respectively the _ final _ and _ repeated _ sets of locations .",
    "a _ state _ of @xmath59 is a pair @xmath73 .",
    "@xmath74 of @xmath59 from @xmath75 is a ( finite or infinite ) sequence of alternating _ delay _ and _ discrete _ moves : @xmath76 for every @xmath77 :    * @xmath78 for @xmath79 ; * there is some transition @xmath80 : ( @xmath81 ) @xmath82 and ( @xmath83 ) @xmath84 $ ] .",
    "the set of finite ( resp .",
    "infinite ) runs from a state @xmath85 is denoted @xmath86 ( resp .",
    "@xmath87 ) and we define @xmath88 , @xmath89 and finally @xmath90 .",
    "if @xmath74 is finite and ends in @xmath91 , we let @xmath92 .",
    "because of the denseness of the time domain , the transition graph of @xmath59 is infinite ( uncountable number of states and delay edges ) .",
    "the _ trace _ , @xmath93 , of a run @xmath74 is the timed word @xmath94 .",
    "we let @xmath95 . for @xmath96 ,",
    "we let @xmath97 . a finite ( resp .",
    "infinite ) timed word @xmath42 is _ accepted _ by @xmath59 if it is the trace of a run of @xmath59 that ends in an @xmath98-location ( resp . a run that reaches infinitely often an @xmath99-location ) .",
    "@xmath100 ( resp .",
    "@xmath101 ) is the set of traces of finite ( resp .",
    "infinite ) timed words accepted by @xmath59 , and @xmath102 is the set of timed words accepted by @xmath59 . in the sequel",
    "we often omit the sets @xmath99 and @xmath98 in ta and this implicitly means @xmath103 and @xmath104 .",
    "a timed automaton @xmath59 is _ deterministic _ if there is no @xmath105 labelled transition in @xmath59 , and if , whenever @xmath106 and @xmath107 are transitions of @xmath59 , @xmath108 .",
    "@xmath59 is _ complete _ if from each state @xmath109 , and for each action @xmath66 , there is a transition @xmath106 such that @xmath28 .",
    "we note the class of deterministic timed automata .    a finite automaton ( fa ) is a particular ta with @xmath110 .",
    "consequently guards and invariants are vacuously true and time elapsing transitions do not exist .",
    "we write @xmath111 @xmath112 for a fa .",
    "a run is thus a sequence of the form : @xmath113 where for each @xmath77 , @xmath114 .",
    "definitions of traces and languages are straightforward . in this case , the duration of a run @xmath74 is the number of steps ( including @xmath105-steps ) of @xmath74 : if @xmath74 is finite and ends in @xmath115 , @xmath116 and otherwise @xmath117 .      the _ region graph _",
    "@xmath118 of a ta @xmath59 is a finite quotient of the infinite graph of @xmath59 which is time - abstract bisimilar to @xmath59  @xcite .",
    "it is a finite automaton ( fa ) on the alphabet @xmath119 .",
    "the states of @xmath118 are pairs @xmath120 where @xmath121 is a location of @xmath59 and @xmath67 is a _ region _ of @xmath15 .",
    "more generally , the edges of the graph are tuples @xmath122 where @xmath123 are states of @xmath118 and @xmath124 .",
    "genuine unobservable moves of @xmath59 labelled @xmath105 are labelled by tuples of the form @xmath125 in @xmath118 .",
    "an edge @xmath126 in the region graph corresponds to a discrete transition of @xmath59 with guard @xmath29 , action @xmath127 and reset set @xmath99 . a @xmath105 move in @xmath118 stands for a delay move to the time - successor region .",
    "the initial state of @xmath118 is @xmath128 .",
    "a final ( resp .",
    "repeated ) state of @xmath118 is a state @xmath120 with @xmath129 ( resp .",
    "@xmath130 ) .",
    "a fundamental property of the region graph  @xcite is :    [ thm - alur ] @xmath131 .    in other words :    1 .",
    "if @xmath42 is accepted by @xmath118 , then there is a timed word @xmath27 with @xmath132 @xmath27 is accepted by @xmath59 .",
    "if @xmath27 is accepted by @xmath59 , then @xmath51 is accepted @xmath118 .",
    "the ( maximum ) size of the region graph is exponential in the number of clocks and in the maximum constant of the automaton @xmath59 ( see  @xcite ) : @xmath133 where @xmath134 is the largest constant used in @xmath59 .",
    "[ def - prod - sync ] let @xmath135 @xmath136 for @xmath137 , be two ta @xmath138 .",
    "the _ product _ of @xmath139 and @xmath140 is the ta @xmath141 @xmath142 given by : @xmath143 ; @xmath144 ; @xmath145 ; @xmath146 ; and @xmath147 and @xmath148 if :    * either @xmath149 , and ( @xmath81 ) @xmath150 for @xmath151 and @xmath152 ; ( @xmath83 ) @xmath153 and ( @xmath154 ) @xmath155 ; * or for @xmath151 or @xmath152 , @xmath156 , and ( @xmath81 ) @xmath157 ; ( @xmath83 ) @xmath158 and ( @xmath154 ) @xmath159 ;    and finally @xmath160 .",
    "to model timed systems with faults , we use timed automata on the alphabet @xmath161 where @xmath1 is the _ faulty _ ( and unobservable ) event .",
    "we only consider one type of fault , but the results we give are valid for many types of faults @xmath162 : indeed solving the many types diagnosability problem amounts to solving @xmath163 one type diagnosability problems  @xcite .",
    "the observable events are given by @xmath2 and @xmath105 is always unobservable .",
    "the system we want to supervise is given by a ta @xmath164@xmath165 .",
    "[ fig - ex - diag1 ] gives an example of such a system .",
    "invariants in the automaton @xmath166 are written within square brackets as in @xmath167 $ ] .",
    "( l0 ) @xmath63 ; ( l1 ) [ above right = of l0,xshift=-1cm , yshift=0.5cm , label=-87:@xmath167 $ ] ] @xmath168 ; ( l2 ) [ above right = of l1,label=-87:@xmath167 $ ] ] @xmath169 ; ( l3 ) [ below right = of l1,label=-87:@xmath167 $ ] ] @xmath170 ; ( l4 ) [ above right = of l3 ] @xmath171 ; ( l5 ) [ below right = of l0 ] @xmath172 ; ( l0 ) edge node[pos=0.5 ] @xmath1 ( l1 ) edge[bend angle=30,bend left ] node[pos=0.5 ] @xmath66 ( l5 ) edge node[pos=0.5 ] @xmath173 ( l5 ) edge[bend angle=30,bend right ] node[swap , pos=0.7 ] @xmath49 ( l5 ) ( l1 ) edge [ pos=0.7 ] node @xmath66 ; @xmath174 ( l2 ) ( l1 ) edge node @xmath66 ; @xmath175 ( l3 ) ( l2 ) edge [ ] node @xmath173 ( l4 ) ( l3 ) edge [ ] node @xmath49 ( l4 ) ; ( l4 ) edge[loop above ] node @xmath105 ( l4 ) ; ( l5 ) edge[loop right ] node @xmath105 ( l5 ) ;    let @xmath176 .",
    "a run of @xmath59 @xmath177 is @xmath178-faulty if : ( 1 ) there is an index @xmath81 @xmath179 and ( 2 ) the duration of the run @xmath180 is larger than @xmath178 .",
    "we let @xmath181 be the set of @xmath178-faulty runs of @xmath59 .",
    "note that by definition , if @xmath182 then @xmath183 . we let @xmath184 be the set of faulty runs of @xmath59 , and @xmath185 be the set of non - faulty runs of @xmath59 .",
    "moreover we use @xmath186 and @xmath187 which are the traces erases @xmath105 and @xmath1 .",
    "] of @xmath178-faulty and non - faulty runs of @xmath59 .",
    "the purpose of fault diagnosis is to detect a fault as soon as possible .",
    "faults are unobservable and only the events in @xmath188 can be observed as well as the time elapsed between these events .",
    "whenever the system generates a timed word @xmath42 , the observer can only see @xmath189 .",
    "if an observer can detect faults in this way it is called a _",
    "diagnoser_. a diagnoser must detect a fault within a given delay @xmath176 .",
    "[ def - diag ] let @xmath59 be a ta over the alphabet @xmath190 , @xmath191 and @xmath176 .",
    "@xmath192-diagnoser _ for @xmath59 is a mapping @xmath193 such that :    * for each @xmath194 , @xmath195 , * for each @xmath196 , @xmath197 .",
    "@xmath59 is @xmath192-diagnosable if there exists a @xmath192-diagnoser for @xmath59 .",
    "@xmath59 is @xmath188-diagnosable if there is some @xmath176 @xmath59 is @xmath192-diagnosable .    the ta @xmath166 in fig .",
    "[ fig - ex - diag1 ] with @xmath198 is @xmath199-diagnosable . for the timed words with an @xmath66 followed by either a @xmath173 or a @xmath49 a fault must have occurred .",
    "otherwise no fault should be reported .",
    "if @xmath200 , in @xmath166 there are two runs : @xmath201 that satisfy @xmath202 , and thus @xmath166 is not @xmath203-diagnosable . to diagnose a fault in @xmath166",
    ", @xmath66 must be observed .",
    "assume @xmath204 is a ta .",
    "the classical fault diagnosis problems are the following :    [ prob - delta - diag ] + inputs : a ta @xmath59 , @xmath2 , and @xmath176 .",
    "+ problem : is @xmath59 @xmath192-diagnosable ?",
    "[ prob - diag ] + inputs : a ta @xmath59 and @xmath2 .",
    "+ problem : is @xmath59 @xmath188-diagnosable ?    [ prob - delay ] + inputs : a ta @xmath59 and and @xmath2 .",
    "+ problem : if @xmath59 is @xmath188-diagnosable , what is the minimum @xmath178 @xmath59 is @xmath192-diagnosable ?",
    "according to definition  [ def - diag ] , @xmath59 is @xmath188-diagnosable , , there is some @xmath176 @xmath59 is @xmath192-diagnosable .",
    "thus @xmath59 is not @xmath188-diagnosable @xmath205 , @xmath59 is not @xmath192-diagnosable .",
    "moreover a trace based definition of @xmath192-diagnosability can be stated as : @xmath59 is @xmath192-diagnosable @xmath206 this gives a necessary and sufficient condition for non @xmath188-diagnosability : @xmath207 or in other words , there is no pair of runs @xmath208 with @xmath209 , @xmath210 the @xmath188-traces of which are equal .",
    "complexity results for the diagnosis problems on timed automata were established in  @xcite ( see  @xcite for a comprehensive study ) and problems  [ prob - delta - diag][prob - delay ] are pspace - complete ( note that pspace - completeness already holds for @xmath211 ) .",
    "in this section , we extend the results of  @xcite to systems given by ta .",
    "[ prob - static - minimum ] + inputs : a ta @xmath204 and @xmath212 .",
    "+ problem :    * is there any set @xmath2 , with @xmath213 @xmath59 is @xmath188-diagnosable ?",
    "* if the answer to  ( a ) is `` yes '' , compute the minimum value for @xmath163 .",
    "problem  [ prob - static - minimum ] is pspace - complete .",
    "pspace - easiness for ( a ) can be established as follows : guess a set @xmath188 with @xmath213 and check ( in pspace ) whether @xmath59 is @xmath188-diagnosable .",
    "this proves npspace and thus in pspace .",
    "pspace - hardness follows from the reduction of problem  [ prob - diag ] to problem  [ prob - static - minimum].(a ) with @xmath214 .",
    "this establishes pspace - completeness for ( a ) . computing the minimum @xmath163",
    "can be done using a binary search ( dichotomy ) and thus ( b ) is also in pspace .",
    "the previous results also hold in a more general setting using _",
    "masks_. masks are useful to capture the notion of _ distinguishability _ among observable events .",
    "indeed , there are cases where two events @xmath66 and @xmath173 are observable but not distinguishable , that is , the diagnoser knows that @xmath66 or @xmath173 occurred , but not which of the two .",
    "this is not the same as considering @xmath66 and @xmath173 to be unobservable , since in that case the diagnoser would not be able to detect the occurrence of @xmath66 or @xmath173 .",
    "distinguishability of events is captured by the notion of a _ mask _",
    "@xcite .",
    "[ def - mask ] a _ mask _ @xmath215 ( of size @xmath163 ) over @xmath0 is a total , surjective function @xmath216 .",
    "@xmath217 induces a morphism @xmath218 , where @xmath219 and @xmath220 , for @xmath221 and @xmath222 .",
    "for example , if @xmath223 , @xmath224 and @xmath225 , @xmath226 , @xmath227 , then we have @xmath228 .",
    "[ def - mask - diag ] let @xmath215 be a mask over @xmath0 .",
    "a mapping @xmath229 is a _",
    "@xmath230-diagnoser _ for @xmath59 if :    * for each @xmath231 , @xmath232 ; * for each @xmath233 , @xmath234 .",
    "@xmath59 is @xmath230-diagnosable if there is a @xmath230-diagnoser for @xmath59 .",
    "@xmath59 is said to be @xmath215-diagnosable if there is some @xmath178 such that @xmath59 is @xmath230-diagnosable . given a mask @xmath215 and @xmath59 ,",
    "checking whether @xmath59 is @xmath215-diagnosable can be done in pspace : it suffices to replace each event @xmath235 by @xmath236 and check for diagnosability .",
    "it is pspace - complete as using an identity mask of cardinality @xmath237 solves problem  [ prob - diag ] .",
    "the counterpart of problem  [ prob - static - minimum ] with masks is the following :    [ prob - static - mask ] + inputs : a ta @xmath204 and @xmath212 .",
    "+ problem :    * is there any mask @xmath215 , @xmath59 is @xmath215-diagnosable ? *",
    "if the answer to  ( a ) is `` yes '' , compute the minimum value for @xmath163 .",
    "[ thm - mask ] problem  [ prob - static - mask ] is pspace - complete .",
    "pspace - easiness is proved by : 1 ) guessing a mask @xmath215 and checking ( in pspace ) that @xmath59 is @xmath215-diagnosable .",
    "pspace - hardness is proved as follows .",
    "if there is a mask @xmath215 with @xmath214 @xmath59 is @xmath215-diagnosable , then , as @xmath217 is surjective , it must be the case that @xmath217 is a one - to - one mapping from @xmath0 to @xmath238 .",
    "it follows that @xmath59 is @xmath0-diagnosable .",
    "conversely , assume @xmath239 . if @xmath59 is @xmath0-diagnosable then there is a mask @xmath240 with @xmath241 @xmath59 is @xmath240-diagnosable .",
    "hence problem  [ prob - static - mask].(a ) is pspace - complete .",
    "problem  [ prob - static - mask].(b ) can be solved in pspace as well using a binary search .",
    "it is not difficult to reduce reachability for ta with one action to checking whether there is a mask of size @xmath242 and thus problem  [ prob - static - mask].(b ) is pspace - complete .",
    "the assumption that a mask is surjective can be lifted still preserving theorem  [ thm - mask ] . indeed ,",
    "if there is a mask @xmath240 @xmath59 is @xmath240-diagnosable and @xmath217 is not surjective , then we can build @xmath243 with @xmath244 surjective @xmath59 is @xmath243-diagnosable ( intuitively , @xmath244 is more discriminating than @xmath217 and has a greater distinguishing power ) .",
    "the use of _ dynamic observers _ was already advocated for des in  @xcite .",
    "we start with an example that shows that dynamically choosing what to observe can be even more efficient using timing information .",
    "let @xmath166 be the automaton of figure  [ fig - ex - diag1 ] . to diagnose @xmath166 , we can use a _ dynamic observer _ that switches @xmath66 , @xmath173 and @xmath49-sensors on / off .",
    "if we do not measure time , to be able to detect faults in @xmath166 , we have to switch the @xmath66 sensor on at the beginning .",
    "when an @xmath66 has occurred , we must be ready for either an @xmath173 or a @xmath49 and therefore , switch on the @xmath173 and @xmath49 sensors on .",
    "a dynamic observer must thus first observe @xmath245 and after an occurrence of @xmath66 , observe @xmath246 .",
    "if the observer can measure time using a clock , say @xmath247 , it can first switch the @xmath66 sensor on .",
    "if an @xmath66 occurs when @xmath248 , then switch the @xmath173 sensor on and if @xmath249 switch the @xmath49 sensor on .",
    "this way the observer never has to observe more than event at each point in time .",
    "the choice of the events to observe can depend on the choices the observer has made before and on the observations ( event , time - stamp ) it has made . moreover",
    "an observer may have _ unbounded _ memory .",
    "the following definition extends the notion of observers introduced in  @xcite to the timed setting .",
    "[ def - observer2 ] an _ observer _ over @xmath0 is a _ deterministic and complete _ timed automaton @xmath250 @xmath251 together with a mapping @xmath252 , where @xmath253 is a ( possibly infinite ) set of locations , @xmath254 is the initial location , @xmath0 is the set of observable events , @xmath255 is the transition function ( a total function ) , and @xmath256 is a labeling function that specifies the set of events that the observer wishes to observe when it is at location @xmath163 .",
    "the invariant . ] @xmath257 maps every location to @xmath258 , implying that an observer can not prevent time from elapsing .",
    "we require that , for any location @xmath163 and any @xmath221 , if @xmath259 then @xmath260 : this means the observer does not change its location nor resets its clocks when an event it has chosen not to observe occurs .    as an observer is deterministic",
    "we let @xmath261 denote the state @xmath262 reached after reading the timed word @xmath42 and @xmath263 is the set of events @xmath264 observes after @xmath42 .",
    "an observer defines a _ transducer _ which is a mapping @xmath265\\ ! ] } : \\tw^*(\\sigma)\\rightarrow \\tw^*(\\sigma)$ ] . given a word @xmath42 , @xmath265\\!]}(w)$ ]",
    "is the output of the transducer on @xmath42 .",
    "it is called the _ observation _ of @xmath42 by the observer .",
    "[ def - obsk - diag ] let @xmath59 be a ta over @xmath190 and be an observer over @xmath0 .",
    "@xmath266 is an _",
    "@xmath267-diagnoser _ for @xmath59 if :    * @xmath268 , @xmath269\\!]}(\\trace(\\rho)))=0 $ ] and * @xmath270 , @xmath269\\!]}(\\trace(\\rho)))=1 $ ] .",
    "@xmath59 is @xmath267-diagnosable if there is an @xmath267-diagnoser for @xmath59 .",
    "@xmath59 is -diagnosable if there is some @xmath178 such that @xmath59 is @xmath267-diagnosable .",
    "we now show how to check @xmath264-diagnosability when the observer @xmath264 is a dta .",
    "[ prob - dynamic - ta ] + inputs : a ta @xmath204 and an observer given by a @xmath271 .",
    "+ problem :    * is @xmath59 @xmath264-diagnosable ? *",
    "if the answer to  ( a ) is `` yes '' , compute the minimum @xmath176 @xmath59 is @xmath267-diagnosable .",
    "problem  [ prob - dynamic - ta ] is pspace - complete .",
    "pspace - hardness follows from the fact that taking an observer which always observes @xmath2 solves problem  [ prob - diag ] .",
    "we prove that problem  [ prob - dynamic - ta ] is in pspace .",
    "the following construction is an extension of the one for des  @xcite . recall that @xmath264 is complete .",
    "define the timed automaton @xmath272 as follows : @xmath273 and the transition relation @xmath274 is given by :    * @xmath275 iff @xmath276 @xmath277 , @xmath278 and @xmath279 if @xmath280 , @xmath281 otherwise ; * @xmath282 iff @xmath283 @xmath277 .",
    "the ta @xmath284 is an unfolding of @xmath59 which reveals what is observable at each product location .    from the previous construction",
    ", it follows that : for each @xmath285 , @xmath59 is @xmath267-diagnosable iff @xmath284 is @xmath286-diagnosable . as the size of @xmath284 is @xmath287 , we can solve problem  [ prob - dynamic - ta].(a ) in pspace .",
    "problem  [ prob - dynamic - ta].(b ) can also be solved using a binary search , in pspace .      in this section",
    "we address the problem of _ synthesizing _ a dynamic observer which ensures diagnosability .",
    "following  @xcite , we want to compute a _",
    "most permissive _ observer ( @xmath288 if none exists ) , which gives a representation of all the good observers . indeed ,",
    "checking whether there exists a dta observer @xmath264 @xmath59 is @xmath264-diagnosable is not an interesting problem : it suffices to check that @xmath59 is @xmath0-diagnosable as the dta observer which observes @xmath0 continuously will be a solution .    when synthesizing ( deterministic ) timed automata , an important issue is the amount of _ resources _ the timed automaton can use : this can be formally defined  @xcite by the ( number of ) clocks , @xmath289 , that the automaton can use , the maximal constant @xmath290 , and a _ granularity _ @xmath291 .",
    "as an example , a ta of resource @xmath292 can use two clocks , @xmath49 and @xmath293 , and the clocks constraints using the rationals @xmath294 where @xmath295 and @xmath296 .",
    "a _ resource _",
    "@xmath297 is thus a triple @xmath298 where @xmath289 is finite set of clocks , @xmath299 and @xmath300 is the",
    "_ granularity_. is the class of of resource @xmath297 .",
    "notice that the number of locations of the in is not bounded and hence this family has an infinite ( yet countable ) number of elements .",
    "we now focus on the following problem :    [ prob - dynamic - synth ] + inputs : a ta @xmath204 , @xmath176 , and a resource @xmath298 .",
    "+ problem : compute the set @xmath256 of all observers in , @xmath59 is @xmath267-diagnosable iff @xmath301 .    for des ,",
    "the previous problem can be solved by computing a most permissive observer , and we refer to  @xcite section  5.5 for the formal definition of the most permissive observer .",
    "this can be done in 2exptime  @xcite , and the solution is a reduction to a safety control problem under partial observation .",
    "for the timed case , we can not use the same solution as controller synthesis under partial observation is undecidable  @xcite .",
    "the solution we present for problem  [ prob - dynamic - synth ] is a modification of an algorithm originally introduced in  @xcite .      in case",
    "a ta @xmath59 is @xmath188-diagnosable , the diagnoser is a mapping  @xcite which performs a state estimate of @xmath59 after a timed word @xmath42 is read by @xmath59 . for des ,",
    "it is obtained by _ determinizing _ the system , but we can not always determinize a ta @xmath59 ( see  @xcite ) . and unfortunately testing whether a timed automaton is determinizable is undecidable  @xcite .",
    "p.  bouyer and f.  chevalier in  @xcite considers the problem of deciding whether there exists a diagnoser which is a dta using resources in @xmath297 :    [ prob - dtamu ] + inputs : a ta @xmath204 , @xmath176 , and a resource @xmath298 .",
    "+ problem : is there any @xmath302 @xmath59 is @xmath303-diagnosable ?",
    "problem  [ prob - dtamu ] is 2exptime - complete .",
    "the solution to the previous problem is based on the construction of a _ two - player game _ , the solution of which gives the _ set _ of all @xmath304 diagnosers ( the most permissive diagnosers ) which can diagnose @xmath59 ( or @xmath288 is there is none ) .",
    "we recall here the construction of the two - player game .",
    "let @xmath305 be a ta , @xmath306 .",
    "define @xmath307 as follows :    * @xmath308 , for @xmath309 , @xmath310 elements are copies of the locations in @xmath37 , * @xmath311 is ( new ) clock not in @xmath13 , * for @xmath121 , @xmath312 , @xmath313 , and @xmath314 , * the transition relation is given by : * * for @xmath315 , @xmath316",
    "if @xmath317 and @xmath318 , * * for @xmath319 , @xmath320 if @xmath317 and @xmath321 , * * @xmath322 if @xmath317 and @xmath321 , * * @xmath323 .    the previous construction creates @xmath324 copies of @xmath59 : the system starts in copy @xmath242 , when a fault occurs it switches to copy @xmath325 , resetting the clock @xmath311 , and when in copy @xmath325 ( a fault has occurred ) it can switch to copy @xmath324 after @xmath178 time units . we can then define @xmath326 as the non - faulty locations , and @xmath327 as the @xmath178-faulty locations .    given a resource @xmath328 ( @xmath329 ) , a _ minimal guard _ for @xmath297 is a guard which defines a region of granularity @xmath297 .",
    "we define the ( symbolic ) _ universal automaton _ @xmath330 by :    * @xmath331 , * @xmath332 for each @xmath333 @xmath235 , @xmath334 , and @xmath29 is a minimal guard for @xmath297 .",
    "@xmath335 is finite because @xmath336 is finite .",
    "nevertheless @xmath335 is not deterministic because it can choose to reset different sets of clocks @xmath337 for a pair `` ( guard , letter ) '' @xmath338 . to diagnose @xmath59",
    ", we have to find when a set of clocks has to be reset .",
    "this can provide enough information to distinguish @xmath178-faulty words from non - faulty words .",
    "the algorithm of  @xcite requires the following steps :    1 .",
    "define the region graph @xmath339 , 2 .",
    "compute a _",
    "projection _ of this region graph : * let @xmath333 be a label of an edge in @xmath340 , * let @xmath341 be the unique minimal guard @xmath342\\ ! ] } \\subseteq      { [ \\![g']\\!]}$ ] ; * define the projection @xmath343 by @xmath344 with @xmath345 if @xmath346 and @xmath347 otherwise .",
    "+ the projected automaton @xmath348 is the automaton @xmath339 where each label @xmath349 is replaced by @xmath350 .",
    "determinize @xmath348 ( removing @xmath105 actions ) and obtain @xmath351 , 4 .",
    "build a two - player safety game @xmath352 as follows : * each transition @xmath353 in @xmath351 yields a transition in @xmath352 of the form : * the round - shaped state are the states of player  1 , whereas the square - shaped states are player  0 states ( the choice of the clocks to reset ) . *",
    "the @xmath354 states ( for player  0 ) are the states of the form @xmath355 with both a @xmath178-faulty ( in @xmath327 ) and a non - faulty ( in @xmath326 ) location .",
    "the main results of  @xcite are :    * there is a ta @xmath356 @xmath59 is @xmath303-diagnosable iff player  0 can win the safety game `` avoid bad '' @xmath352 , * it follows that problem  [ prob - dtamu ] can be solved in 2exptime as @xmath352 has size doubly exponential in @xmath59 , @xmath178 and @xmath297 , * the acceptance problem for alternating turing machines of exponential space can be reduced to problem  [ prob - dtamu ] and thus it is 2exptime - hard .",
    "we now show how to modify the previous algorithm to solve problem  [ prob - dynamic - synth ] , and obtain the following result :    problem  [ prob - dynamic - synth ] can be solved in 2exptime .",
    "we modify the previous algorithm as follows :    1 .",
    "the automaton @xmath335 is defined as follows : each location corresponds to a choice of a subset of events to observe .",
    "define the ( symbolic ) _ universal automaton _ @xmath357 by : * for @xmath358 , @xmath359 , * @xmath360 for each @xmath361 , @xmath333 @xmath235 , @xmath334 , and @xmath29 is a minimal guard for @xmath297 .",
    "when computing @xmath362 , the set of observable events ( step  2 in the algorithm of section  [ sec - algo ] ) are defined according to the location @xmath363 of @xmath364 .",
    "formally , the projection of @xmath235 is @xmath66 if the location of @xmath364 is @xmath363 and @xmath365 and @xmath105 otherwise .",
    "the size of @xmath362 is @xmath366 where @xmath134 is the maximal constant of @xmath367 ; it is thus exponential in @xmath297 and @xmath0 .",
    "the determinization is thus doubly exponential in @xmath59 , @xmath297 and @xmath0 .",
    "we can then build a new game @xmath368 as described in section  [ sec - algo ] before . the proof that the most permissive strategy in the new game @xmath368 is the most permissive observer is along the lines of the one given in  @xcite with minor modifications . solving a safety game",
    "is linear in the size of the game and thus computing the most permissive observer of resource @xmath297 can de done in 2exptime .    in",
    "@xcite it is also proved that for event recording automata ( era )  @xcite problem  [ prob - dtamu ] becomes pspace - complete .",
    "this result does not carry over in our case , as there is still an exponential step with the choice of the sets of events to be observed .",
    "in this section we extend the notion of _ cost _ defined for finite state observers in  @xcite to the case of timed observers .",
    "weighted / priced timed automata were introduced in  @xcite and they extend ta with _ prices / costs / weights _ on the time elapsing and discrete transitions .",
    "a _ priced timed automaton ( pta ) _ is a pair @xmath369 where @xmath370 @xmath371 is a timed automaton and @xmath372 is a",
    "_ cost function _ which is a mapping from @xmath373 to @xmath8 .",
    "let @xmath374 be a run of @xmath59 .",
    "we denote by @xmath375 the discrete transition taken from @xmath376 to @xmath377 .",
    "the _ cost _ of the run @xmath74 is defined by : @xmath378 the _ mean cost _ of @xmath74 is defined to be the cost per time unit and given are not taken into account . ] by @xmath379 .",
    "the cost of runs of duration @xmath380 is defined by @xmath381\\!]}(\\varrho ) ) \\",
    "| \\ { { \\textit{dur}}}(\\varrho)=t \\}\\mathpunct.$ ] the _ maximal mean cost _ of @xmath382 is @xmath383 .",
    "the minimal mean cost is defined dually and denoted @xmath384 .      to select a best or optimal dynamic observer which ensures @xmath178-diagnosability , we need to define a metric to compare them .",
    "we extend the one defined in  @xcite for des to take into account ( real ) time elapsing .",
    "let @xmath59 be a ta and @xmath264 a dta observer .",
    "@xmath264 is extended into a p(d)ta by associating costs with locations and transitions .",
    "the cost associated with the discrete transitions is the cost of switching on the sensors for a set of observable events , and the cost of a location is the cost per time unit of having a set of sensors activated .",
    "let @xmath74 be a run of @xmath59 . as is deterministic ( and complete )",
    "there is exactly one run of @xmath264 the trace of which is @xmath265\\!]}(\\trace(\\varrho))$ ] . given @xmath74 ,",
    "let @xmath265\\!]}(\\varrho)$ ] be this unique run .",
    "the average cost of the run @xmath74 observed by is @xmath385\\!]}(\\varrho))$ ] .",
    "given @xmath380 , the _ maximal mean cost _ of runs of duration @xmath386 is defined by : @xmath387\\!]}(\\varrho))\\}\\mathpunct.\\ ] ] the _ maximal average cost _ of the pair @xmath388 is defined @xmath389 we can then state the following problem :    [ prob - cost - obs ] + inputs : a ta @xmath59 and @xmath390 a pdta observer .",
    "+ problem : compute @xmath391 .",
    "the computation of optimal infinite schedules for ta has been addressed in  @xcite .",
    "the main result of  @xcite is :    [ thm - pat ] given a pta @xmath59 , computing @xmath392 and @xmath393 is pspace - complete .",
    "the definition of the cost of an observer is exactly the definition of the maximal mean cost in  @xcite and thus :    problem  [ prob - cost - obs ] is pspace - complete .",
    "pspace - easiness follows from theorem  [ thm - pat ] : note that theorem  [ thm - pat ] assumes that the ta is bounded which is not a restriction as every ta can be transformed into an equivalent ( timed bisimilar ) bounded ta . for pspace - hardness , to compute the maximal mean cost of a pdta @xmath394 , let @xmath59 be the universal automaton on the alphabet of @xmath394 .",
    "consider @xmath394 as an observer and solve problem  [ prob - cost - obs ] .",
    "this solves the maximal mean cost computation problem for dta .",
    "this completes the hardness proof .",
    "checking whether the mean cost of a given observer is less than @xmath395 requires that we have computed or are given such an observer .",
    "a more difficult version of problem  [ prob - cost - obs ] is to check for the existence of cheap dynamic observer :    [ prob - bounded - cost ] + inputs : a ta @xmath204 , @xmath176 , @xmath297 a resource and @xmath396 .",
    "+ problem :    * is there a dynamic observer @xmath356 @xmath59 is @xmath303-diagnosable and @xmath397 ? * if the answer to  ( a ) is `` yes '' , compute a witness dynamic observer ?",
    "we can not provide of proof that problem  [ prob - bounded - cost ] is decidable .",
    "however , we give a lower bound for problem  [ prob - bounded - cost ] and later discuss the exact complexity .",
    "problem  [ prob - bounded - cost ] is 2exptime - hard .",
    "we reduce problem  [ prob - dtamu ] which is 2exptime - hard  @xcite to problem  [ prob - bounded - cost ] .",
    "let @xmath59 be a ta for which we want to check whether there exists a dta observer @xmath356 @xmath59 is @xmath398-diagnosable .",
    "let @xmath349 be a fresh letter not in @xmath0 .",
    "define the automaton @xmath394 depicted on figure  [ fig - reduc - bounded ] .",
    "the upper part of @xmath394 generates faulty and non - faulty runs with each letter including @xmath349 . from each location of @xmath59 ( bottom part )",
    ", we add a @xmath105 transition to the initial state of @xmath394 . the transitions of @xmath59 are not depicted .",
    "for @xmath394 to be diagnosable with @xmath399 , we must have : 1 ) @xmath349 always observable and 2 ) @xmath0 always observable .",
    "moreover , if @xmath59 is @xmath400-diagnosable , then @xmath394 is @xmath401-diagnosable .",
    "conversely , if @xmath394 is @xmath401-diagnosable , then @xmath394 is @xmath400-diagnosable .",
    "hence @xmath59 is @xmath400-diagnosable iff @xmath394 is @xmath401-diagnosable .",
    "define the cost of the locations to be @xmath242 , and @xmath17 for the transitions in @xmath394 .",
    "@xmath394 is diagnosable with a dta @xmath356 iff there is a dynamic ( yet it has to choose @xmath402 continuously ) observer @xmath403 with @xmath404 .",
    "it follows that : there exists a diagnoser @xmath403 @xmath59 is @xmath400-diagnosable iff @xmath394 is @xmath405-diagnosable with a dta observer @xmath406 and @xmath407 .",
    "( l0 ) ;    ( l1 ) [ above right = of l0 ] ; ( l2 ) [ right = of l0,xshift=1 cm ] ; ( l4 ) [ above right = of l2 ] ; ( l5 ) [ right = of l2,xshift=1 cm ] ;    ( s1 ) [ below left = of l0,xshift=-.3 cm ] @xmath408 ; ( s2 ) [ right = of s1,yshift=-.7cm , xshift=-.4cm , label=-90:@xmath409 @xmath408 ; ( s3 ) [ below = of s2,xshift=1.2 cm ] @xmath408 ; ( s4 ) [ right = of s3,xshift=2 cm ] @xmath408 ; ( s5 ) [ right = of s2,xshift=1 cm ] @xmath408 ; ( env ) ;    ( l0 ) edge node[pos=0.5 ] @xmath1 ( l1 ) edge node[swap , pos=0.5,swap ] @xmath349 ( l2 ) ( l1 ) edge [ pos=0.5 ] node @xmath349 ( l2 ) ( l2 ) edge node @xmath1 ( l4 ) ( l4 ) edge node @xmath410 ( l5 ) ( l2 ) edge [ ] node @xmath410 ( l5 ) ; ( l0 ) edge[dashed , bend left ] node @xmath105 ( s2 ) ; ( s1 ) edge[dashed , bend left ] node[pos=0.2 ] @xmath105 ( l0 ) ; ( s2 ) edge[dashed , bend left ] node[pos=0.2 ] @xmath105 ( l0 ) ; ( s3 ) edge[dashed , bend right ] node @xmath105 ( l0 ) ; ( s4 ) edge[dashed , bend right , swap ] node[pos=0.3 ] @xmath105 ( l0 ) ; ( s5 ) edge[dashed , bend right , swap ] node[pos=0.1 ] @xmath105 ( l0 ) ;    the status of problem  [ prob - bounded - cost ] is clearly unsettled as the 2exptime - hardness result does not imply it is even decidable .",
    "a solution to this problem would be to mimic the one given for des  @xcite : solve a mean payoff _ timed _ game with a counterpart of zwick and paterson algorithm  @xcite using the most permissive observers obtained in section  [ sec - synth ] .",
    "the type of priced timed games we would have to solve has the following features : 1 ) they are turn - based , as one player picks up ( controllable moves ) a set of events to be observed and then hands it over to the other player who tries to produce a confusing run ( uncontrollable moves ) ; 2 ) they have at least two clocks ( one for the system @xmath59 and one for the dta observer ) ; 3 ) the controllable choices are _ urgent _ no time can elapse in player  1 locations .",
    "we denote s - ptga for the class of timed game automata previously defined .",
    "unfortunately , there is no counterpart of the general result of zwick & paterson for timed automata .",
    "only very few results are known for timed mean payoff games  @xcite and none of them can be used in our setting .",
    "nevertheless , due to the particular nature of the mean payoff price timed game we construct ( in the class s - ptga ) , we might be able to compute the optimal choices of observable events using an algorithm similar to  @xcite .",
    "hence we could obtain a 2exptime algorithm for problem  [ prob - bounded - cost ] .",
    "the results of the paper are summarized by the line `` ta '' in table  [ tab - summary ] .",
    "the complexity / decidability status of problem  [ prob - bounded - cost ] is left open .",
    "a solution to this problem would be to solve the following optimization problem on the class of s - ptga :     + inputs : a s - ptga @xmath382 , a set of _ bad _ states and @xmath396 .",
    "+ problem : is there a strategy @xmath1 for player  1 in @xmath59 @xmath411 ( @xmath59 controlled by @xmath1 ) avoids _ bad _ and satisfies @xmath412 ?",
    "f.  cassez , s.  tripakis , and k.  altisen , `` sensor minimization problems with static or dynamic observers for fault diagnosis , '' in _",
    "conf . on application of concurrency to system design ( acsd07)_.1em plus 0.5em minus 0.4emieee computer society , 2007 , pp . 9099 .",
    " , `` synthesis of optimal dynamic observers for fault diagnosis of discrete - event systems , '' in _ proceedings of the 1st ieee & ifip international symposium on theoretical aspects of software engineering ( tase07)_.1em plus 0.5em minus 0.4emieee computer society , 2007 , pp",
    ". 316325 .",
    "yoo and s.  lafortune , `` polynomial - time verification of diagnosability of partially - observed discrete - event systems , '' _ ieee transactions on automatic control _ ,",
    "47 , no .  9 , pp . 14911495 , sept .",
    "s.  tripakis , `` fault diagnosis for timed automata , '' in _ proceedings of the international conference on formal techniques in real time and fault tolerant systems ( ftrtft02 ) _ , ser .",
    "lncs , w.  damm and e .-",
    "olderog , eds .",
    "2469.1em plus 0.5em minus 0.4emspringer verlag , 2002 , pp .",
    "205224 .",
    "f.  cassez , `` a note on fault diagnosis algorithms , '' in _ 48th ieee conference on decision and control and 28th chinese control conference_.1em plus 0.5em minus 0.4emshanghai , p.r .",
    "china : ieee computer society , dec .",
    "2009 .",
    "p.  bouyer , d.  dsouza , p.  madhusudan , and a.  petit , `` timed control with partial observability , '' in _ proceedings of the 15th international conference on computer aided verification ( cav03 ) _ , ser .",
    "lncs , w.  a. hunt , jr and f.  somenzi , eds .",
    "2725.1em plus 0.5em minus 0.4emboulder , colorado , usa : springer , july 2003 , pp . 180192 .",
    "r.  alur , l.  fix , and t.  a. henzinger , `` a determinizable class of timed automata , '' in _ proceedings of the 6th international conference on computer aided verification ( cav94 ) _ , ser .",
    "lncs , vol .",
    "818.1em plus 0.5em minus 0.4emspringer verlag , 1994 , pp .",
    "g.  behrmann , a.  fehnker , t.  hune , k.  g. larsen , p.  pettersson , j.  romijn , and f.  vaandrager , `` minimum - cost reachability for priced timed automata , '' in _ proc .",
    "4th international workshop on hybrid systems : computation and control ( hscc01 ) _ , ser .",
    "lncs , vol .",
    "2034.1em plus 0.5em minus 0.4emspringer , 2001 , pp .",
    "147161 .",
    "r.  alur , s.  la  torre , and g.  j. pappas , `` optimal paths in weighted timed automata , '' in _ proc .",
    "hybrid systems : computation and control ( hscc01 ) _ , ser .",
    "lncs , vol .",
    "2034.1em plus 0.5em minus 0.4emspringer , 2001 , pp .",
    "4962 .",
    "p.  bouyer , k.  g. larsen , n.  markey , and j.  i. rasmussen , `` almost optimal strategies in one - clock priced timed automata , '' in _ proceedings of the 26th conference on foundations of software technology and theoretical computer science ( fsttcs06 ) _ , ser .",
    "lncs , n.  garg and s.  arun - kumar , eds .",
    "4337.1em plus 0.5em minus 0.4em kolkata , india : springer , dec .",
    "2006 , pp . 345356 .",
    "p.  bouyer , u.  fahrenberg , k.  g. larsen , n.  markey , and j.  srba , `` infinite runs in weighted timed automata with energy constraints , '' in _ proceedings of the 6th international conference on formal modelling and analysis of timed systems ( formats08 ) _ , ser .",
    "lncs , f.  cassez and c.  jard , eds .",
    "5215.1em plus 0.5em minus 0.4emsaint - malo , france : springer , sept .",
    "2008 , pp . 3347 .",
    "p.  bouyer , th .",
    "brihaye , m.  jurdziski , r.  lazi , and m.  rutkowski , `` average - price and reachability - price games on hybrid automata with strong resets , '' in _ proceedings of the 6th international conference on formal modelling and analysis of timed systems ( formats08 ) _ , ser .",
    "lncs , f.  cassez and c.  jard , eds .",
    "5215.1em plus 0.5em minus 0.4emsaint - malo , france : springer , sept .",
    "2008 , pp . 6377 .",
    "p.  bouyer , u.  fahrenberg , k.  g. larsen , and n.  markey , `` timed automata with observers under energy constraints , '' in _ proceedings of the 13th international conference on hybrid systems : computation and control ( hscc10 ) _ , k.  h. johansson and w.  yi , eds.1em plus 0.5em minus 0.4emstockholm , sweden : acm press , apr .",
    "2010 , to appear ."
  ],
  "abstract_text": [
    "<S> in this paper we extend the work on _ dynamic observers _ for fault diagnosis  @xcite to timed automata . </S>",
    "<S> we study sensor minimization problems with static observers and then address the problem of computing the most permissive dynamic observer for a system given by a timed automaton . </S>"
  ]
}