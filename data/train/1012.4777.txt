{
  "article_text": [
    "moduli spaces of smooth algebraic curves have been defined and then compactified in algebraic geometry by deligne and mumford in their seminal paper  @xcite .",
    "a conceptually important extension of this notion in the case of pointed curves was introduced by knudsen  @xcite .",
    "the points in the boundary of the moduli spaces of pointed , nodal curves with finite automorphism group .",
    "these curves are called _ stable curves _ ( or pointed stable curves ) .",
    "the topology of one such curve is encoded in a combinatorial object , called",
    "_ stable graph_. the boundary of the moduli space admits a topological stratification , made of loci whose points are curves with a fixed topological type and a prescribed assignment of the marked points on each irreducible component .",
    "the combinatorics of the stable graphs have been investigated in several papers in algebraic geometry , for many different purposes ( see for instance  @xcite ) .",
    "our aim with this program is to provide a useful and effective tool to generate all the stable graphs of genus @xmath0 with @xmath1 unordered marked points up to isomorphism , for low values of @xmath0 and @xmath1 .",
    "we construct an algorithm to generate all the stable graphs of genus @xmath0 with @xmath1 unordered marked points .",
    "our program uses then the software ` nauty `  @xcite to eliminate isomorphic graphs from the list of graphs thus created . since to check that two stable graphs",
    "are isomorphic is computationally onerous , we try to generate a low number of stable graphs , provided that we want at least one for every isomorphism class .",
    "the algorithm generates recursively the vectors of genera , number of marked points , number of loops , and the adjacency matrix .",
    "while it fills these data , it checks the stability condition and the condition on the total genus as early as possible , in order to minimize the time spent on the branches of the recursion that do not lead to stable graphs .",
    "some analysis of the algorithm s performances can be seen in section  [ sec : performance ] .",
    "programs for enumerative computations on @xmath3 have been implemented in both maple and macaulay2  ( @xcite ) .",
    "our program can be used , for example , to improve the results of  ( * ? ? ?",
    "* section 5 ) , or to prove combinatorial results on the moduli space of pointed stable curves with low genus ( cfr .",
    "@xcite , for example corollary  5.3 ) .",
    "from now on , we fix two natural numbers @xmath4 and @xmath5 such that @xmath6 . for every @xmath7 , we define @xmath8 and @xmath9 to be the symmetric group on  the  set  @xmath10 .    *",
    "an _ undirected multigraph _",
    "@xmath11 is a couple @xmath12 with @xmath13 a finite set of _ vertices _ and @xmath14 a finite multiset of _ edges _ with elements in @xmath15 . *",
    "the multiplicity of the edge @xmath16 in @xmath14 is denoted by @xmath17 . * the _ total multiplicity _ of @xmath11 , or its _ number of edges _",
    ", is @xmath18 : the cardinality of @xmath14 as a multiset . *",
    "the _ degree _ of a vertex @xmath19 is @xmath20 . *",
    "a _ colored undirected multigraph _ is a multigraph with some additional data attached to each vertex .",
    "[ def : stable graph ] a _ stable graph _ of type @xmath21 is a colored undirected multigraph @xmath22 , subject to the following conditions .    1 .",
    "the color of a vertex @xmath19 is given by a pair of natural numbers @xmath23 .",
    "the two numbers are called respectively the _ genus _ and the _ number of marked points _ of the vertex @xmath19 .",
    "[ it : condition connected ] @xmath11 is connected .",
    "[ it : condition genus ] its _ total genus _ , defined as @xmath24 , equals @xmath4 .",
    "its _ total number of marked points _ , defined as @xmath25 , equals @xmath5 .",
    "[ it : condition stability ] stability condition : @xmath26 for every vertex @xmath19 with @xmath27 .    the number @xmath28 is often called the _ number of half edges _ associated to the vertex @xmath19 .",
    "condition [ it : condition stability ] can be rephrased in : for every vertex @xmath19 of genus @xmath29 , its number of half edges is at least @xmath30 .",
    "two stable graphs @xmath31 and @xmath32 are _ isomorphic _ if there is a bijection @xmath33 such that :    * @xmath34 for every @xmath35 ; * @xmath36 and @xmath37 for every @xmath38 .",
    "our task is to generate one stable graph for each isomorphism class .",
    "note that from the definition just given , we are working with an unordered set of marked points .",
    "the output of the program are the boundary strata of the moduli space of stable , genus @xmath0 curves with @xmath1 unordered points @xmath39 .",
    "in this section we describe the general ideas of our algorithm .",
    "let us first introduce the notation we use in the program .",
    "[ not : gnla ] the set of vertices @xmath13 will always be @xmath10 , so that vertices will be identified with natural numbers @xmath40 . the multiplicity of the edge between @xmath41 and @xmath42 will be denoted by @xmath43 : the symmetric matrix @xmath44 is called the _ adjacency matrix _ of the stable graph . for convenience , we will denote @xmath45 : it is the vector whose elements are the number of loops at the vertex @xmath42 . for simplicity , we will consider @xmath46 , @xmath47 , @xmath48 , @xmath43 to be defined also for @xmath41 or @xmath42 outside @xmath10 , in which case their value is always assumed to be @xmath29 .    in the following , we assume @xmath49 in order not to deal with degenerate cases .",
    "there are trivially @xmath50 stable graphs of type @xmath21 with one vertex . indeed ,",
    "if there is exactly one vertex , the choice of the genus uniquely determines the number of loops on it after definition  [ def : stable graph ] .",
    "the program uses recursive functions to generate the data that constitute a stable graph . in order",
    ", it generates the numbers @xmath46 , then the numbers @xmath47 , @xmath48 ( the diagonal part of the matrix @xmath44 ) , and finally , row by row , a symmetric matrix representing @xmath44 .",
    "when all the data have been generated , it tests that all the conditions of definition  [ def : stable graph ] hold , in particular that the graph is actually connected and satisfies the stability conditions .",
    "then it uses the software ` nauty `  @xcite to check if this graph is isomorphic to a previously generated graph .",
    "if this is not the case , it adds the graph to the list of graphs of genus @xmath4 with @xmath5 marked points .",
    "a priori , for each entry of @xmath0 , @xmath1 , @xmath51 , and @xmath44 the program tries to fill that position with all the integers .",
    "this is of course not possible , indeed it is important to observe here that each datum is bounded . from below , a trivial bound is @xmath29 , that is , no datum can be negative . instead ,",
    "a simple upper bound can be given for each entry of @xmath0 by the number @xmath4 , and for each entry of @xmath1 by the number @xmath5 .",
    "for @xmath51 and @xmath44 , upper bounds are obtained from @xmath4 using the condition on the total genus ( condition  [ def : stable graph ] ) .",
    "these bounds are coarse : section [ sec : ranges ] will be devoted to proving sharper bounds , from above and from below .",
    "also , we will make these bounds dynamical : for instance assigning the value @xmath52 clearly lowers the bound for @xmath53 .",
    "the improvement of these bounds is crucial for the performance of the algorithm . in any case , once we know that there are bounds , we are sure that the recursion  terminates .",
    "the algorithm follows this principle : we want to generate the smallest possible number of couples of isomorphic stable graphs .",
    "to do so , we generalize the idea that to generate a vector for every class of vectors of length @xmath54 modulo permutations , the simplest way is to generate vectors whose entries are increasing .",
    "the program fills the data row by row in the matrix : @xmath55 and generates only matrices whose columns are ordered .",
    "loosely speaking , we mean that we are ordering the columns lexicographically , but this requires a bit of care , for two reasons :    * the matrix @xmath44 needs to be symmetric ; in the program we generate only the strictly upper triangular part ; * the diagonal of @xmath44 need not be considered when deciding if a column is greater than or equal to the previous one .",
    "therefore , to be precise , we define a relation ( _ order _ ) for adjacent columns .",
    "let us call  @xmath56 and @xmath57 two adjacent columns of the matrix  .",
    "they are said to be equivalent if  @xmath58 for any @xmath59 . if they are not equivalent , denote with @xmath60 the minimum index such that @xmath61 and @xmath62",
    ". then we state the relation @xmath63 if and only if @xmath64 .",
    "we do not define the relation for non - adjacent columns .",
    "we say that the data are ordered when the columns are weakly increasing , that is if , for all @xmath42 , either @xmath56 is equivalent to @xmath57 or @xmath63 .    to ensure that the columns are ordered ( in the sense we explained before ) , the program keeps track of _",
    "we start filling the genus vector @xmath0 in a non decreasing way , and every time a value @xmath46 strictly greater than @xmath65 is assigned , we put a division before @xmath42 .",
    "this means that , when assigning the value of @xmath47 , we allow the algorithm to start again from @xmath29 instead of @xmath66 , because the column @xmath57 is already bigger than the column @xmath56 .    after completing @xmath0 ,",
    "we start filling the vector @xmath1 in such a way that , within two divisions , it is non decreasing .",
    "again we introduce a division before @xmath42 every time we assign a value  @xmath47 strictly greater than @xmath66 .",
    "we follow this procedure also for the vector @xmath51 .    finally , we start filling the rows of the matrix @xmath44 . here",
    "the procedure is a bit different . indeed even if for the purpose of filling the matrix it is enough to deal only with the upper triangular part , imposing",
    "the conditions that the columns are ordered involves also the lower triangular part .",
    "a small computation gives that the value of @xmath43 is assigned starting from : @xmath67 and we put a division before @xmath41 if @xmath68 and a division before @xmath42 if @xmath69 .",
    "we can not conclude immediately that this procedure gives us all possible data up to permutations as in the case of a single vector .",
    "this is because the transformation that the whole matrix undergoes when a permutation is applied is more complicated : for the first three rows ( the vectors @xmath0 , @xmath1 , @xmath51 ) , it just permutes the columns , but for the remaining rows , it permutes both rows and columns . indeed , to prove that the procedure of generating only ordered columns does not miss any stable graph is the content of the following section .",
    "we want to prove the following result .    [ prop : main ] the algorithm described in the previous section generates at least one graph for every isomorphism class of stable graphs .    from now on , besides @xmath4 and @xmath5 , we also fix the number of vertices @xmath54 , and focus on proving that the algorithm generates at least one graph for every isomorphism class of stable graphs with @xmath54 vertices .",
    "we have decided previously to encode the data of a stable graph in a @xmath70 matrix @xmath71 ( cfr .  ) .",
    "we denote by @xmath72 the set of all such matrices , and by @xmath73 the set of all @xmath74 matrices that are generated by the algorithm described in the previous section .",
    "we can assume that the graphs generated by the algorithm are stable , since we explicitly check connectedness and stability .",
    "in other words , we can assume the inclusion @xmath75 .",
    "hence , in order to prove proposition  [ prop : main ] , we will show that every @xmath76 is in @xmath73 up to applying a permutation of @xmath10 .",
    "the idea is to give a characterization ( lemma  [ lemma : char ] ) of the property of being an element of @xmath73 .",
    "recall first that the algorithm generates only matrices whose columns are ordered , as described in section  [ sec : description ] . more explicitly , if @xmath77 , then @xmath78 if and only if : @xmath79    let us call a piece of data @xmath46 , @xmath47 , @xmath48 , or @xmath43 a _ breaking position _ if it does not satisfy the condition above .",
    "observe that a matrix @xmath76 has a breaking position if and only if @xmath4 is not an element of @xmath73 .",
    "we now introduce a total order on the set @xmath72 of matrices @xmath80 .",
    "if @xmath4 is such a matrix , let @xmath81 be the vector obtained by juxtaposing the vectors @xmath0 , @xmath1 , @xmath51 and the rows of the upper triangular part of @xmath44 .",
    "for example , if @xmath82 ( with the same structure as  ) , then we define @xmath83    [ def : order ] if @xmath84 , we write @xmath85 if and only if @xmath81 is smaller than @xmath86 in the lexicographic order . in this case",
    "we say that the matrix @xmath4 is smaller than the matrix @xmath87 .",
    "note that this total order on the set of matrices must not be confused with the partial order described in section  [ sec : description ] . from now on we will always refer to the latter order on @xmath72 .",
    "if @xmath88 is a permutation and @xmath89 is a graph , then we can apply @xmath90 to the entries of the data of @xmath4 , obtaining an isomorphic graph .",
    "the action of @xmath90 on @xmath4 is : @xmath91 where @xmath92 , @xmath93 , @xmath94 and @xmath95 .",
    "we denote this new matrix by @xmath96 .",
    "we write @xmath97 for the element of @xmath9 that corresponds to the transposition of @xmath98 .",
    "now we are able to state the characterization we need to prove proposition  [ prop : main ] .",
    "[ lemma : char ] let @xmath76 ; then @xmath99 if and only if @xmath4 is minimal in the set @xmath100 with respect to the order given in definition  [ def : order ] .    we will prove that @xmath4 is not minimal if and only if there is a breaking position .",
    "assume there is at least one breaking position in @xmath4 .",
    "if there is one in @xmath0 , @xmath1 , or @xmath51 , it is trivial to see that transposing the corresponding index with the previous one gives a smaller matrix .",
    "if this is not the case , let @xmath43 be a breaking position such that @xmath101 is not a breaking position whenever @xmath102 ( the position @xmath103 is the first breaking position of its column ) .",
    "we deduce that @xmath104 , @xmath105 , @xmath106 , and that for all @xmath102 not in @xmath107 , we have @xmath108 .",
    "let @xmath109 ; the vectors @xmath0 , @xmath1 , and @xmath51 ( the first three rows ) coincide in @xmath4 and @xmath87 .",
    "* if @xmath110 , the smallest breaking position is in the upper triangular part of @xmath44 ; it is then clear that @xmath111 . *",
    "if @xmath112 , the smallest breaking position is in the lower triangular part ; by using the symmetry of the matrix @xmath44 we again obtain @xmath111 ( see the right part of figure  [ fig : a ] ) .    at ( -1,7.5 ) @xmath113 ; at ( 12.5,-1 ) @xmath114 ; at ( 11.5,7.5 ) @xmath115 ; at ( 12.5,7.5 ) @xmath116 ; at ( 7.5,11.5 ) @xmath115 ; at ( 7.5,12.5 ) @xmath116 ; ( 8,11 )  ( 8,13 )  ( 15,13 )  ( 15,11 )  cycle ; ( 11,8 )  ( 13,8 )  ( 13,15 )  ( 11,15 )  cycle ; ( 0,11 )  ( 0,13 )  ( 7,13 )  ( 7,11 )  cycle ; ( 11,0 )  ( 13,0 )  ( 13,7 )  ( 11,7 )  cycle ;    ( 0,0 )  ( 15,0 )  ( 15,15 )  ( 0,15 )  cycle ; in 1,2, ... ,14 ( 0 , ) ",
    "( 15 , ) ; ( , 0 )  ( , 15 ) ; in 0,1, ... ,14 ( , ) ",
    "( , + 1 )  ( + 1,+1 )  ( + 1 , )  cycle ;    at ( -1,11.5 ) @xmath113 ; at ( 7.5,-1 ) @xmath114 ; at ( 6.5,11.5 ) @xmath115 ; at ( 7.5,11.5 ) @xmath116 ; at ( 11.5,6.5 ) @xmath115 ; at ( 11.5,7.5 ) @xmath116 ; ( 12,6 )  ( 12,8 )  ( 15,8 )  ( 15,6 )  cycle ; ( 6,12 )  ( 8,12 )  ( 8,15 )  ( 6,15 )  cycle ; ( 0,6 )  ( 0,8 )  ( 11,8 )  ( 11,6 )  cycle ; ( 6,0 )  ( 8,0 )  ( 8,11 )  ( 6,11 )  cycle ;    ( 0,0 )  ( 15,0 )  ( 15,15 )  ( 0,15 )  cycle ; in 1,2, ...",
    ",14 ( 0 , )  ( 15 , ) ; ( , 0 )  ( , 15 ) ; in 0,1, ...",
    ",14 ( , ) ",
    "( , + 1 )  ( + 1,+1 )  ( + 1 , )  cycle ;    conversely , let @xmath42 be such that @xmath117 .",
    "then consider the first entry ( reading from left to right ) of the vector @xmath81 that is strictly bigger than @xmath86 .",
    "this is a breaking position .",
    "notice that if it occurs in the matrix @xmath44 ( equivalently , in the last @xmath54 rows ) , it is actually the first breaking position of its column .",
    "the proof of proposition  [ prop : main ] follows arguing as in this example .",
    "let @xmath118 be the graph of the previous example : @xmath119      \\hline\\\\[1pt ]      \\bullet & 1 & 1 & 1\\\\      1 & \\bullet & 2 & 1\\\\      1 & 2 & \\bullet & 0\\\\      1 & 1 & 0 & \\bullet    \\end{smallmatrix}\\right)}\\text{.}\\ ] ] this graph is stable but not in @xmath73 because , for example , @xmath120 implies that @xmath121 is a breaking position .",
    "thus we apply the permutation @xmath122 , obtaining the graph @xmath123      \\hline\\\\[1pt ]      \\bullet & 1 & 1 & 1\\\\      1 & \\bullet & 1 & 2\\\\      1 & 1 & \\bullet & 0\\\\      1 & 2 & 0 & \\bullet    \\end{smallmatrix}\\right ) } \\prec g_0\\text{.}\\ ] ] now @xmath124 is a breaking position ; applying @xmath125 , we obtain @xmath126      \\hline\\\\[1pt ]      \\bullet & 1 & 1 & 1\\\\      1 & \\bullet & 1 & 0\\\\      1 & 1 & \\bullet & 2\\\\      1 & 0 & 2 & \\bullet    \\end{smallmatrix}\\right ) } \\prec g_1\\text{.}\\ ] ] this introduces a new breaking position at @xmath127 , so we apply the transposition @xmath128 : @xmath129      \\hline\\\\[1pt ]      \\bullet & 1 & 1 & 0\\\\      1 & \\bullet & 1 & 1\\\\      1 & 1 & \\bullet & 2\\\\      0 & 1 & 2 & \\bullet    \\end{smallmatrix}\\right ) } \\prec g_2\\text{.}\\ ] ] the graph @xmath130 is finally in @xmath73 and indeed no transposition can make it smaller .",
    "recall that we have to prove that for every @xmath76 , there is a permutation @xmath88 such that @xmath131 .",
    "so , let @xmath132 .",
    "if @xmath99 , then we are done ; otherwise , @xmath4 does not satisfy the condition of lemma  [ lemma : char ] , hence there is a transposition @xmath133 such that @xmath134 .",
    "the iteration of this process comes to an end ( that is , we arrive to a matrix in @xmath73 ) since the set @xmath135 is finite .",
    "in section  [ sec : description ] we have introduced the algorithm , by describing the divisions . in this section",
    "we introduce accurate ranges for the possible values of @xmath0 , @xmath1 , @xmath51 and @xmath44 .",
    "we will deduce from the conditions of definition  [ def : stable graph ] some other necessary conditions that can be checked before the graph is defined in its entirety .",
    "more precisely , every single datum is assigned trying all the possibilities within a range that depends upon the values of @xmath4 and @xmath5 , and upon the values of the data that have already been filled .",
    "the conditions we describe in the following are not the only ones possible ; we tried other possibilities , but heuristically the others we tried did not give any improvement .",
    "the order in which we assign the value of the data is @xmath0 , @xmath1 , @xmath51 , and finally the upper triangular part of @xmath44 row after row .",
    "suppose we are assigning the @xmath41-th value of one of the vectors @xmath0 , @xmath1 or @xmath51 , or the @xmath103-th value of @xmath44 .",
    "we define the following derived variables @xmath136 , @xmath137 and @xmath138 that depend upon the values that have already been assigned to @xmath0 , @xmath1 , @xmath51 , @xmath44 .",
    "we let @xmath136 be the maximum number of edges that could be introduced in the subsequent iterations of the recursion , and @xmath137 be the number of couples of ( different ) vertices already connected by an edge .",
    "we let @xmath138 be the number of vertices @xmath139 to which the algorithm has assigned @xmath140 .",
    "note that the final value of @xmath138 is determined when the first genus greater than @xmath29 is assigned , in particular the final value of @xmath138 is determined at the end of the assignment of the values to the vector @xmath0 . on the other hand , @xmath137 starts to change its value only when the matrix @xmath44 begins to be filled .    _",
    "after _ the assignment of the @xmath41-th value , the derived values @xmath136 , @xmath137 and @xmath138",
    "are then updated according to the assignment itself .",
    "[ not : partial_assign ] when deciding @xmath0 , @xmath1 , or @xmath51 , we let @xmath141 be the minimum between @xmath142 and the number of half edges already assigned to the @xmath41-th vertex .",
    "this is justified by the fact that we know that , when we will fill the matrix @xmath44 , we will increase by one the number of half edges at the vertex @xmath41 in order to connect it to the rest of the graph .",
    "whenever @xmath143 , @xmath141 is the number of _ stabilizing _ half edges at the vertex @xmath41 : one half edge is needed to connect the vertex to the rest of the graph , and then at least two more half edges are needed to stabilize the vertex . when deciding @xmath43 , it is also useful to have defined @xmath144 , the total number of half edges that hit the @xmath41-th vertex .",
    "finally , we define @xmath145    we are now ready to describe the ranges in which the data can vary .",
    "we study subsequently the cases of @xmath0 , @xmath1 , @xmath51 and @xmath44 , thus following the order of the recursions of our algorithm .",
    "each range is described by presenting a first list of general constraints on the parameters and then by presenting a second list containing the actual ranges in the last line .",
    "when the algorithm is deciding the value of @xmath146 , we have the following situation :    * @xmath147 by condition  [ it : condition genus ] ; * amongst the @xmath136 edges , there are necessarily @xmath148 non - loop edges ( to connect the graph ) ; these @xmath148 edges give one half edge for each vertex , whereas we can choose arbitrarily where to send the other @xmath149 half edges ; conversely , the @xmath150 half edges of the remaining edges can be associated to any vertex ; therefore , the maximum number of half edges ( not counting those that are needed to connect the graph ) is @xmath151 ; * we need @xmath152 half edges to stabilize the genus @xmath29 vertices , since one half edge comes for free from the connection of the graph .",
    "we use the following conditions to limit the choices we have for @xmath146 :    1 .",
    "since @xmath0 is the first vector to be generated , there is no division before @xmath41 , hence @xmath153 remember that @xmath154 whenever @xmath155 ; 2 .",
    "we need at least @xmath148 non - loop edges , hence ( using the fact that @xmath156 ) @xmath157 3 .   in order to stabilize the @xmath138 vertices of genus @xmath29 ( using the fact that one stabilizing half edge comes for free by connection ) we must have @xmath158      when deciding @xmath159 , we have the following situation :    * as before , @xmath160 , and the maximum number of half edges still to be assigned is @xmath161 ; * we need @xmath162 half edges to stabilize the first @xmath138 vertices ; * if @xmath143 , we need @xmath163 more half edges to stabilize the first @xmath164 vertices .",
    "the following conditions define then the ranges for the possible choices for @xmath159 :    1 .",
    "if there is not a division before @xmath41 ( that is , if @xmath165 ) , then we require @xmath166 ; otherwise , just @xmath167 ; 2 .",
    "we can not assign more than @xmath5 marked points , hence ( where we treat the case of @xmath143 in a special way ) @xmath168 3 .   if @xmath143 , for the purpose of stabilizing the first @xmath164 curves we can not use marked points anymore , therefore we have @xmath169      when deciding @xmath171 , this is the situation :    * @xmath172 , and the maximum number of half edges still to assign is @xmath173 ;    the conditions on @xmath170 are then the following :    1 .",
    "if there is not a division before @xmath41 , then we require @xmath174 ; otherwise , just @xmath175 ; 2 .",
    "we need at least @xmath148 non - loop edges , hence @xmath176 3 .",
    "let @xmath139 be the index of the genus @xmath29 vertex with the least number of stabilizing half edges such that @xmath177 ; it already has @xmath178 half edges , but we can not use loops anymore to stabilize it ; hence , @xmath179 4 .   assume @xmath143 ; if @xmath180 , we are adding to the @xmath41-th vertex @xmath181 stabilizing half edges , and to stabilize the @xmath138 genus @xmath29 vertices , we need to have @xmath182 5 .",
    "assume @xmath143 ; after deciding @xmath170 , we still have @xmath136 edges to place , and each of them can contribute with one half edge to the stabilization of the @xmath41-th vertex ; moreover , one of these half edges is already counted for the stabilization ; hence @xmath183      when deciding @xmath43 , this is the situation :    * earlier in notation [ not : partial_assign ] , we observed that for the purpose of filling the vectors @xmath0,@xmath1 and @xmath51 we could consider a genus @xmath29 vertex stabilized when it had at least two half - edges ( since the graph is going to be connected eventually ) .",
    "when assigning the values of @xmath44 , the stability condition goes back to its original meaning , i.e. each vertex has at least @xmath30 half edges .",
    "* @xmath184 ; * we have already placed edges between @xmath137 couples of different vertices ;    here are the constraints that @xmath43 must satisfy :    1 .",
    "if there is not a division before @xmath41 , then we require @xmath185 ; otherwise , just @xmath186 ; 2 .",
    "if there is not a division before @xmath42 , then we require @xmath187 ; 3 .",
    "we need at least @xmath188 ( if positive ) edges to connect the graph , because if @xmath189 , @xmath137 will increase by @xmath190 ( this estimate could be very poor , but enforcing the connectedness condition in its entirety before completing the graph is too slow ) , hence : @xmath191 4 .",
    "@xmath43 contributes with at most @xmath192 stabilizing half edges ; hence , to stabilize the @xmath138 genus @xmath29 vertices , we need @xmath193 5 .",
    "if @xmath194 ( that is , if this is the last chance to add half edges to the @xmath41-th vertex ) , then we add enough edges from @xmath41 to @xmath148 in order to stabilize the vertex @xmath41 ; moreover , if up to now we did not place any non - loop edge on the vertex @xmath41 , we impose @xmath195 .",
    "the complexity of the problem we are trying to solve is intrinsically higher than polynomial , because already the amount of data to generate increases ( at least ) exponentially with the genera and the number of marked points .",
    "we also observed an exponential growth of the ratio between the time required to solve an instance of the problem and the number of graphs generated .",
    "anyway , our program is specifically designed to attack the problem of stable graphs , and it can be expected to perform better than any general method to generate graphs applied to our situation .",
    "we present here some of the results obtained when testing our program on an intel core2 quad processor q9450 at 2.66ghz .",
    "the version we tested is not designed for parallel processing , hence it used only one of the four cores available .",
    "however , when computing a specific graph , the program needs to keep in the memory only the graphs with the same values in the vectors @xmath0 , @xmath1 , @xmath51 : memory usage becomes therefore negligible .",
    "moreover this shows that we can assign the computations of stable graphs with prescribed @xmath0 , @xmath1 , @xmath51 to different cores or cpus , thus having a highly parallelized implementation of the program .    .",
    "]    .for small @xmath4 , the maximum @xmath5 such that all stable graphs of type @xmath197 can be computed in less than @xmath198 minutes . in the last column",
    "we show the ratio of duplicated graphs among the total number of those created by our generation algorithm . [ cols=\">,>,>,>,>\",options=\"header \" , ]     in table  [ tab : number ] we list , for each genus @xmath4 , the maximum number of marked points @xmath5 for which we can compute all the stable graphs of type @xmath21 under 15 minutes .    in figure  [ fig : plot ] we show all the couples @xmath21 that we computed against the time needed ; the lines connect the results referring to the same genus . from this plot",
    "it seems that , for fixed @xmath4 , the required time increases exponentially with @xmath5 .",
    "however , we believe that in the long run the behaviour will be worse than exponential .",
    "this is suggested also by the fact that the ratio of non - isomorphic stable graphs over those created by our generation algorithm tends to zero as @xmath4 and @xmath5 grow ( see  figure  [ fig : plot_duplicated ] ) .",
    "more benchmarks and up - to - date computed results are available at ` boundary ` s webpage , http://people.sissa.it/~maggiolo/boundary/[`http://people.sissa.it/~maggiolo/boundary/ ` ] .",
    "both the authors want to acknowledge their host institutions , sissa and kth .",
    "the second author was partly supported by the wallenberg foundation .",
    "both authors were partly supported by prin `` geometria delle variet algebriche e dei loro spazi di moduli '' , by istituto nazionale di alta matematica .",
    "the authors are also very grateful to susha parameswaran for linguistic suggestions , and to the referees for suggesting further improvements of the presentation .",
    "s.  busonero , m.  melo , and l.  stoppino , _ on the complexity group of stable curves _ , adv . in geometry",
    "* 11 * ( 2011 ) , no .",
    "2 , 241272 , [ http://arxiv.org/abs/0808.1529[arxiv:0808.1529 ] ] . p.",
    "deligne and d.  mumford , _ the irreducibility of the space of curves of given genus _ , inst .",
    "hautes tudes sci .",
    "publ . math .",
    "* 36 * ( 1969 ) , 75109 .",
    "m.  a.  van  opstall and r.  veliche , _ maximally symmetric stable curves ii _ , http://arxiv.org/abs/math/0608799[arxiv:math/0608799 ] .",
    "s.  yang , _ intersection numbers on @xmath200 _ , journal of software for algebra and geometry , * 2 * ( 2010 ) , 15 ."
  ],
  "abstract_text": [
    "<S> we present and prove the correctness of the program ` boundary ` , whose sources are available at http://people.sissa.it/~maggiolo/boundary/[`http://people.sissa.it/~maggiolo/boundary/ ` ] . given two natural numbers @xmath0 and @xmath1 satisfying @xmath2 , the program generates all genus @xmath0 stable graphs with @xmath1 unordered marked points . </S>",
    "<S> each such graph determines the topological type of a nodal stable curve of arithmetic genus @xmath0 with @xmath1 unordered marked points . </S>",
    "<S> our motivation comes from the fact that the boundary of the moduli space of stable genus @xmath0 , @xmath1-pointed curves can be stratified by taking loci of curves of a fixed topological type . </S>"
  ]
}