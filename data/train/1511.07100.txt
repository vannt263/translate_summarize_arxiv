{
  "article_text": [
    "the logspace computational model entails algorithms which use a read - only input array and @xmath0 working memory . for general graphs , there is no known deterministic logspace algorithm for the shortest path problem .",
    "in fact , the shortest path problem is nl - complete , so the existence of a logspace algorithm would imply that l = nl @xcite . in this paper , we reduce the logspace shortest path problem to biconnected graphs , and present a linear time logspace shortest path algorithm for parameter - constrained graphs .",
    "an important result under the logspace computational model which is used in the sequel is reingold s deterministic polynomial time algorithm @xcite for the undirected @xmath1-connectivity problem ( ustcon ) of determining whether two vertices in an undirected graph belong to the same connected component .",
    "there are a number of randomized logspace algorithms for ustcon ( see , for example , @xcite ) which perform faster than reingold s algorithm but whose output may be incorrect with a certain probability .",
    "there are also a number of logspace algorithms for the shortest path problem and other graph problems on special types of graphs ( see @xcite ) . as a rule , due to time - space trade - off , improved space - efficiency",
    "is achieved on the account of higher time - complexity .",
    "often the trade - off is rather large , yielding time complexities of @xmath2  for some constant @xmath3 significantly larger than 1 \" @xcite . in particular ,",
    "the time complexity of reingold s ustcon algorithm remains largely uncharted but is possibly of very high order .",
    "the linear time logspace shortest path algorithm presented in this paper avoids this shortcoming , at the expense of some loss of generality .",
    "its time ( and space ) complexity is the best possible , since a hypothetical sublinear - time algorithm would fail to print a shortest path of length @xmath4 .",
    "this paper is organized as follows . in the next section",
    ", we recall some basic definitions and introduce a few concepts which will be used in the sequel . in section  3",
    ", we present a reduction of the logspace shortest path algorithm to biconnected graphs . in section  4 ,",
    "we present a linear time logspace algorithm for parameter - constrained graphs .",
    "we conclude with some final remarks in section  5 .",
    "a _ logspace algorithm _ is an algorithm which uses @xmath0 working memory , where @xmath5 is the size of the input . in addition , the input and output are respectively read - only and write - only , and do not count toward the space used .",
    "the _ shortest path problem _ requires finding a path between two given vertices @xmath6 and @xmath7 in a graph @xmath8 , such that the sum of the weights of the edges constituting the path is as small as possible . in general ,",
    "if @xmath6 and @xmath7 are not in the same connected component , or if the connected component containing @xmath6 and @xmath7 also contains a negative - weight cycle , the shortest path does not exist .",
    "for simplicity , we will assume there are no negative - weight cycles in @xmath8 , although the proposed algorithms can be easily modified to detect ( and terminate at ) such cycles without any increase in overall complexity .",
    "we will also assume that @xmath8 is encoded by its adjacency list , where vertices are labeled with the first @xmath5 natural numbers .",
    "the @xmath9 neighbor of vertex @xmath10 is accessed with @xmath11 in @xmath12 time , and _ _ degree__@xmath13 .",
    "an _ articulation point _ in @xmath8 is a vertex whose deletion increases the number of connected components of @xmath8 .",
    "block _ is a maximal subgraph of @xmath8 which has no articulation points ; if @xmath8 has a single block , then @xmath8 is _",
    "biconnected_. the _ block tree _ @xmath14 of @xmath8 is the bipartite graph with parts @xmath15 and @xmath16 , where @xmath15 is the set of articulation points of @xmath8 and @xmath16 is the set of blocks of @xmath8 ; @xmath17 is adjacent to @xmath18 if and only if @xmath19 contains @xmath20 .",
    "we define the _ i d _ of a block in @xmath8 to be @xmath21 , where _ largest _ and _ smallest _ are the largest and smallest vertices in the block with respect to their labeling from 1 to @xmath5 .",
    "clearly , each block in @xmath8 has a unique _ id_. note also that it is possible to lexicographically compare the @xmath22s of two or more blocks , i.e. , if @xmath23 and @xmath24 , then @xmath25 if @xmath26 or if @xmath27 and @xmath28 .    given numbers @xmath29 , @xmath30 , and @xmath31 , we define the _ next _ number after @xmath31 as follows :    @xmath32    we extend this definition to a list @xmath33 of not necessarily distinct numbers by defining the _ next _ number in @xmath33 after @xmath31 to be a number in @xmath33 larger than @xmath31 by the smallest amount , or if no such number exists , to be the smallest number in @xmath33 .",
    "next _ number in @xmath33 can be found with logspace and @xmath34 time , given sequential access to the elements of @xmath33 , by repeatedly applying the _ next _ function .",
    "let _ _ connected__@xmath35 be an implementation of reingold s ustcon algorithm which takes in two vertices of a graph @xmath36 and returns _ true _ if they belong to the same connected component , and _",
    "false _ otherwise .",
    "let _ _ pathinblock__@xmath35 be a polynomial time , logspace oracle which takes in two vertices of a biconnected graph @xmath36 and prints the shortest path between them .",
    "clearly , the encoding of a graph @xmath36 can be reduced with logspace and polynomial time to the encoding of some induced subgraph @xmath37 $ ] .",
    "thus , by transitivity and closure of reductions , the functions _ _ connected__@xmath38;v_1,v_2)$ ] and _ _ pathinblock__@xmath39;v_1,v_2)$ ] can be used with logspace and polynomial time , where @xmath40 and @xmath16 are sets of vertices computed at runtime and @xmath41 $ ] is biconnected .",
    "the _ connected _ function reduces the logspace shortest path problem to connected graphs . in this section",
    ", we will further reduce this problem to biconnected graphs , by presenting a logspace algorithm for finding the shortest path between two vertices in an arbitrary graph using the oracle _",
    "pathinblock_.      let @xmath8 be a graph of order @xmath5 , and @xmath42 and @xmath43 be two vertices that belong to the same block ; the set of all vertices in this block will be referred to as _",
    "_ block__@xmath44 . using the _ connected _ function ,",
    "is easy to construct a logspace function _ _ isinblock__@xmath45 which returns _ true _",
    "when @xmath46 is part of _ _ block__@xmath44 and _ false _ otherwise ; see table 1 for pseudocode .",
    "this procedure can be used to access the vertices in @xmath47 sequentially . a similar procedure _ _ areinblock__@xmath48 can be defined which returns _ true _ when @xmath49 and @xmath46 are in the same block , and _",
    "false _ otherwise .",
    "a vertex of @xmath8 is an articulation point if and only if two of its neighbors are not in the same block .",
    "thus , using the _ isinblock _ function , we can construct a function _",
    "_ isarticulation__@xmath50 which returns _ true _",
    "when @xmath46 is an articulation point and _ false _ otherwise ; see table 1 for pseudocode .",
    "we also define the function @xmath51 , which goes through the vertices of _ _ block__@xmath44 and returns ( _ largest , smallest _ ) , where _ largest _ and _ smallest _ are respectively the largest and smallest vertices in _ _",
    "block__@xmath44 according to their labeling .",
    "let @xmath31 be an articulation point is not an articulation point , and can be used in special cases , e.g. , when @xmath8 only has one block .",
    "] in _ _ block__@xmath44 . to find the _ next _ articulation point in _",
    "_ block__@xmath44 after @xmath31 , we can create a function _ _ nextarticulation__@xmath52 which uses each articulation point in _ _",
    "block__@xmath44 as a member of list @xmath33 and applies the _ next _ function .",
    "note that the vertices in @xmath33 do not have to be stored , but can be generated one at a time ; see table 1 for pseudocode .",
    "similarly , to identify the block containing @xmath31 and having the _ next _ @xmath22 after @xmath51 , we can create a function _ _ nextblock__@xmath52 which uses the _",
    "_ id__s of the blocks identified by @xmath31 and each of its neighbors as members of a list @xmath33 and applies the _ next _ function .",
    "note that the _ _ id__s in @xmath33 do not have to be stored but can be computed one at a time ; see table 1 for pseudocode .",
    "finally , given articulation point @xmath31 and vertex @xmath46 in the same block , we will call the component of @xmath53 which contains @xmath31 the _ subgraph of g rooted at block@xmath54 containing p _ , or",
    "_ _ subgraph__@xmath54 .",
    "this subgraph can be traversed with logspace by starting from @xmath31 and repeatedly moving to the _ next _ block and to the _ next _ articulation point until the starting block is reached again .",
    "this procedure indeed gives a traversal , since it corresponds to visiting the _ next _ neighbor in the block tree @xmath14 of @xmath8 , which generates an euler subtour traversal ( cf .",
    "@xcite ) . in addition , during the traversal of _ _",
    "subgraph__@xmath54 , each vertex can be compared to a given vertex @xmath7 , in order to determine whether the subgraph contains @xmath7 .",
    "thus , we can create a function _",
    "_ isinsubgraph__@xmath55 which returns _ true _ if @xmath7 is in _ _ subgraph__@xmath54 and _ false _ otherwise ; see table 1 for pseudocode",
    ".      using the subroutines outlined in the previous section and the oracle _ pathinblock _ , we propose the following logspace algorithm for finding the shortest path in a graph @xmath8 .",
    "the main idea is to print the shortest path one block at a time by locating @xmath7 in one of the subgraphs rooted at the current block .",
    "algorithm 1 finds the correct shortest path between vertices @xmath6 and @xmath7 in graph @xmath8 with logspace and polynomial time , using a shortest path oracle for biconnected graphs .",
    "let @xmath56 and @xmath57 ; the shortest path between @xmath58 and @xmath59 is @xmath60 , where @xmath61 are articulation points and @xmath62 are ( possibly empty ) subpaths which contain no articulation points .",
    "let @xmath63 for @xmath64 , so that _ _",
    "pathinblock__@xmath65;p_i , p_{i+1})=p_ip_ip_{i+1}$ ] .",
    "suppose the subpath @xmath66 , @xmath67 , has already been printed and that the vertex @xmath68 is stored in memory .",
    "in each iteration of the main loop , the function _ _ isinsubgraph__@xmath69 returns _ true _ only for @xmath70 when run for all articulation points @xmath31 in all blocks containing @xmath68 .",
    "the function _ _",
    "pathinblock__@xmath65,p_i , p_{i+1})$ ] is then used to print @xmath71 and @xmath72 .",
    "finally , @xmath68 is replaced in memory by @xmath72 , and this procedure is repeated until @xmath59 is reached . since the main loop is entered only if the shortest path is of finite length , the algorithm terminates , and since each subpath printed is between two consecutive articulation points of @xmath73 , the output of algorithm 1 is the correct shortest path between @xmath6 and @xmath7 .    since the _ connected _ function is logspace , the _ isinblock _ , _ isarticulation _ and _ isinsubgraph _ functions are each logspace .",
    "only a constant number of variables , each of size @xmath0 , are simultaneously stored in algorithm 1 , and every function call is to a logspace function ( assuming the _ pathinblock _ oracle is logspace ) ; thus , the space complexity of algorithm 1 is @xmath0 .",
    "note that since the vertices in _ _ block__@xmath44 can not be stored in memory simultaneously , a call to the function _",
    "_ pathinblock__@xmath74,v_1,v_2)$ ] needs to be realized by a logspace reduction , i.e. , the vertices @xmath42 and @xmath43 are stored , and whenever the function _ pathinblock _",
    "needs to access an entry of the adjacency list of @xmath75 $ ] , it recomputes it by going through the vertices of @xmath8 and using the function _",
    "isinblock_.    similarly , since the _ connected _ function uses polynomial time , the _ isinblock _ , _ isarticulation _ and _ isinsubgraph _ functions each use polynomial time .",
    "the main loop is executed at most @xmath76 times , and each iteration calls a constant number of polynomial time functions ( assuming the _ pathinblock _ oracle uses polynomial time ) ; thus , the time complexity of algorithm 1 is @xmath2 for some constant @xmath3 . @xmath77",
    "let _ _ bellmanford__@xmath35 be an implementation of the bellman - ford shortest path algorithm @xcite which takes in two vertices of a graph @xmath36 and prints out the shortest path between them . let _",
    "_ hopcrofttarjan__@xmath78 be an implementation of hopcroft and tarjan s algorithm @xcite which returns all blocks and articulation points of a graph @xmath36 . if the size of @xmath36 is bounded by a constant , _",
    "bellmanford _ and _ hopcrofttarjan _ can each be used with constant time and a constant number of memory cells .",
    "let @xmath8 be a graph of order @xmath5 with maximum vertex degree @xmath79 and maximum biconnected component size @xmath80",
    ". we will regard @xmath79 and @xmath80 as fixed constants , independent of @xmath5 . using these constraints and some additional computational techniques",
    ", we will reformulate algorithm 1 as a linear - time logspace shortest path algorithm which does not rely on an oracle .",
    "asymptotically , both the time and space requirements of this algorithm are the best possible and can not be improved ; see corollary 1 for more information .      by the assumption on the structure of @xmath8 , the number of vertices at distance at most @xmath80 from a specified vertex @xmath46",
    "is bounded by @xmath81 .",
    "thus , any operations on a subgraph induced by such a set of vertices can be performed with constant time and a constant number of memory cells , each with size @xmath0 ; note that since each vertex of @xmath8 has a bounded number of neighbors , @xmath82 $ ] can be found in constant time for any set @xmath40 of bounded size . in particular , we can construct a function _ _ blockscontaining__@xmath50 which uses _ hopcrofttarjan _ to return all blocks containing a given vertex @xmath46 and all articulation points in these blocks ; see below for pseudocode .",
    "using the set of blocks and articulation points given by the _ blockscontaining _",
    "function , we can define functions _",
    "_ isinblock__@xmath45 , _ _",
    "areinblock__@xmath48 , _ _",
    "isarticulation__@xmath50 , _ _",
    "id__@xmath44 , _ _",
    "nextarticulation__@xmath52 , and _ _ nextblock__@xmath52 analogous to the ones described in section 3 , each of which uses @xmath0 space and @xmath12 time .",
    "we can also construct an analogue of _ _",
    "isinsubgraph__@xmath55 , which uses time proportional to the size of _ _ subgraph__@xmath54 ; in particular , the time for traversing the entire graph @xmath8 via an euler tour of its block tree is @xmath76 ( provided @xmath8 is connected ) since there are @xmath76 calls to the _ nextarticulation _ function and @xmath76 calls to the _ nextblock _ function .    finally , it will be convenient to define the following functions : _ _ adjacentpoints__@xmath44 which returns the set of articulation points belonging to blocks containing @xmath43 but not @xmath42 if @xmath83 and the set of articulation points belonging to blocks containing @xmath43 if @xmath84 ( this function is slight modification of _ blockscontaining _ ) ; _ _ last__@xmath85 which returns the last element of a list @xmath33 ; _ _ traversecomponent__@xmath86 which traverses the component containing a vertex @xmath6 and returns _ true _ if @xmath7 is in the same component and _ false _ otherwise ( this function is identical to _ isinsubgraph _ , with a slight modification in the stopping condition ) .",
    "we now present a modified version of algorithm 1 , which uses the subroutines outlined in the previous section as well as some additional computational techniques such as  simulated parallelization \" ( introduced by asano et al .",
    "@xcite ) aimed at reducing its runtime .",
    "algorithm 2 finds the correct shortest path between vertices @xmath6 and @xmath7 in graph @xmath8 with bounded degree and biconnected component size using logspace and linear time .    using the notation in the proof of theorem 1 , suppose the subpath @xmath87 has already been printed ; @xmath59 can not be in _ _",
    "subgraph__@xmath88 , so there is no need to run _ _ isinsubgraph__@xmath89 .",
    "adjacentpoints__@xmath90 is the set of feasible articulation points .",
    "moreover , if @xmath59 is not in _ _",
    "subgraph__@xmath91 for all - but - one feasible articulation points , then the last of these must be @xmath72 and there is no need to run _",
    "_ isinsubgraph__@xmath92 .",
    "finally , two subgraphs rooted at @xmath93 can be traversed concurrently with the technique of simulated parallelization : instead of traversing the feasible subgraphs one - after - another , we maintain two copies of the _ isinsubgraph _ function and use them to simultaneously traverse two subgraphs .",
    "we do this in serial ( without the use of a parallel processor ) by iteratively advancing each copy of the function in turn ; if one subgraph is traversed , the corresponding copy of the function terminates and another copy is initiated to traverse the next unexplored subgraph .",
    "thus , algorithm 2 is structurally identical to algorithm 1 and prints the correct shortest path between @xmath6 and @xmath7 .",
    "only a constant number of variables , each of size @xmath0 , are simultaneously used in algorithm 2 , and every function call is to a logspace function ; moreover , keeping track of the internal states of two logspace functions can be done with logspace , so the space complexity of algorithm 2 is @xmath0 .    finally , to verify the time complexity , note that by traversing two subgraphs at once , we can deduce which subgraph contains @xmath7 in the time it takes to traverse all subgraphs which do _ not _ contain @xmath7 or @xmath6 .",
    "thus , each subgraph rooted at _ _",
    "block__@xmath94 , @xmath95 , which does not contain @xmath7 or @xmath6 will be traversed at most once , so the time needed to print the shortest path is of the same order as the time needed to traverse @xmath8 once .",
    "@xmath77    the time and space complexity of algorithm 2 is the best possible for the class of graphs considered .",
    "let @xmath8 be a graph of order @xmath5 ; the shortest path between two vertices in @xmath8 may be of length @xmath4 so any shortest path algorithm will require at least @xmath4 time to print the path",
    ". moreover , a pointer to an entry in the adjacency list of @xmath8 has size @xmath96 , so printing each edge of the shortest path requires at least @xmath4 space . @xmath77",
    "we have reduced the logspace shortest path problem to biconnected graphs using techniques such as computing instead of storing , transitivity of logspace reductions , and reingold s ustcon result .",
    "we have also proposed a linear time logspace shortest path algorithm for graphs with bounded degree and biconnected component size , using techniques such as simulated parallelization and constant - time and -space calls to functions over graphs with bounded size .",
    "future work will be aimed at further reducing the logspace shortest path problem to triconnected graphs using spqr - tree decomposition , and to @xmath80-connected graphs using branch decomposition or the decomposition of holberg @xcite .",
    "another direction for future work will be to generalize algorithm 2 by removing or relaxing the restrictions on vertex degree and biconnected component size .",
    "this material is based upon work supported by the national science foundation under grant no .",
    "1450681 .",
    "jakoby , a. , tantau , t. , logspace algorithms for computing shortest and longest paths in series - parallel graphs .",
    "fsttcs 2007 : foundations of software technology and theoretical computer science .",
    "springer berlin heidelberg , 216227 ( 2007 )"
  ],
  "abstract_text": [
    "<S> in this paper , we reduce the logspace shortest path problem to biconnected graphs ; in particular , we present a logspace shortest path algorithm for general graphs which uses a logspace shortest path oracle for biconnected graphs . </S>",
    "<S> we also present a linear time logspace shortest path algorithm for graphs with bounded vertex degree and biconnected component size , which does not rely on an oracle . </S>",
    "<S> the asymptotic time - space product of this algorithm is the best possible among all shortest path algorithms .    </S>",
    "<S> * keywords : * logspace algorithm , shortest path , biconnected graph , bounded degree </S>"
  ]
}