{
  "article_text": [
    "in recent years , it has become clear that certain interacting particle systems studied in combinatorics and statistical physics have a common underlying structure .",
    "these systems are characterized by an _ abelian property _ which says changing the order of certain interactions has no effect on the final state of the system . up to this point",
    ", the tools used to study these systems  least action principle , local - to - global principles , burning algorithm , transition monoids and critical groups  have been developed piecemeal for each particular system .",
    "following dhar @xcite , we aim to identify explicitly what these various systems have in common and exhibit them as special cases of what we call an _",
    "abelian network_.    intuition suggests that noncommutativity is a major source of dynamical richness and complexity . yet",
    "abelian networks produce surprisingly rich and intricate large - scale patterns from local rules @xcite . just as in physics one",
    "infers from macroscopic observations the properties of microscopic particles , we would like to be able to infer from the large - scale behavior of a cellular automaton something about the local rules that generate that behavior . in particular , are there certain large - scale features that can only be produced by _ noncommutative _ local interactions ? by",
    "now a lot is known about the computational complexity of the abelian sandpile model @xcite ; see @xcite for a recent compilation .",
    "the requirement that a distributed network produce the same output regardless of the order in which processors act would seem to place a severe restriction on the kinds of tasks it can perform . yet",
    "abelian networks can perform some highly nontrivial tasks , such as solving certain linear and nonlinear integer programs ( see [ s.mip ] ) .",
    "are there other computational tasks that _ require _ noncommutativity ?    in this paper and its sequels , by defining abelian networks and exploring their fundamental properties , we hope to take a step toward making these questions precise and eventually answering them . after giving the formal definition of an abelian network in [ s.definition ] ,",
    "we survey a number of examples in [ s.examples ] . these include the well - studied sandpile and rotor networks as well as two _ non - unary _ examples : oil and water , and abelian mobile agents . in [ s.leastaction ]",
    "we prove a least action principle for abelian networks and explore some of its consequences .",
    "one consequence is that `` local abelianness implies global abelianness '' ( lemma  [ l.localglobalabelian ] ) .",
    "another is that abelian networks solve optimization problems of the following form : given a nondecreasing function @xmath0 , find the coordinatewise smallest vector @xmath1 such that @xmath2 ( if it exists ) .",
    "this paper is the first in a series of three . in the sequel",
    "@xcite we give conditions for a finite abelian network to halt on all inputs .",
    "such a network has a natural invariant attached to it , the _ critical group _ ,",
    "whose structure we investigate in @xcite .",
    "this section begins with the formal definition of an abelian network , which is based on deepak dhar s model of _ abelian distributed processors _ @xcite .",
    "the term `` abelian network '' is convenient when one wants to refer to a collection of communicating processors as a single entity .",
    "some readers may wish to look at the examples in [ s.examples ] before reading this section in detail .",
    "let @xmath3 be a directed graph , which may have self - loops and multiple edges .",
    "associated to each vertex @xmath4 is a _ processor _",
    "@xmath5 , which is an automaton with a single input feed and multiple output feeds , one for each edge @xmath6 .",
    "each processor reads the letters in its input feed in first - in - first - out order .    the processor @xmath5 has an input alphabet @xmath7 and state space @xmath8 .",
    "its behavior is governed by a _ transition function _ @xmath9 and _ message passing functions _ @xmath10 associated to each edge @xmath6 .",
    "formally , these are maps @xmath11 where @xmath12 denotes the free monoid of all finite words in the alphabet @xmath13 .",
    "we interpret these functions as follows .",
    "if the processor @xmath5 is in state @xmath14 and processes input @xmath15 , then two things happen :    1 .",
    "processor @xmath5 transitions to state @xmath16 ; and 2 .   for each edge @xmath6 , processor",
    "@xmath17 receives input @xmath18 .",
    "if more than one @xmath5 has inputs to process , then changing the order in which processors act may change the order of messages arriving at other processors . concerning this issue",
    ", dhar writes that    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` in many applications , especially in computer science , one considers such networks where the speed of the individual processors is unknown , and where the final state and outputs generated should not depend on these speeds .",
    "then it is essential to construct protocols for processing such that the final result does not depend on the order at which messages arrive at a processor . ''",
    "@xcite _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    :    1 .   the * halting status * ( i.e. , whether or not processing eventually stops ) .",
    "the * final output * ( final states of the processors ) .",
    "3 .   the * run time * ( total number of letters processed by all @xmath5 ) .",
    "the * local run times * ( number of letters processed by a given @xmath5 ) .",
    "the * specific local run times * ( number of times a given @xmath5 processes a given letter @xmath19 ) .    a priori it is not obvious that these goals are actually achievable by any nontrivial network . in [ s.leastaction ]",
    "we will see , however , that a simple local commutativity condition ensures all five goals are achieved . to state this condition",
    ", we extend the domain of @xmath9 and @xmath10 to @xmath20 : if @xmath21 is a word in alphabet @xmath7 beginning with @xmath15 , then set @xmath22 and @xmath23 , where the product denotes concatenation of words .",
    "let @xmath24 be the free commutative monoid generated by @xmath25 , and write @xmath26 for the natural map @xmath27 , so that @xmath28 for @xmath29 denotes the number of letters @xmath15 in the word @xmath30 .",
    "[ d.abelianprocessor ] ( abelian processor ) the processor @xmath5 is called _ abelian _ if for any words @xmath31 such that @xmath32 , we have for all @xmath33 and all edges @xmath6 @xmath34 that is , permuting the letters input to @xmath5 does not change the resulting state of the processor @xmath5 , and may change each output word sent to @xmath17 only by permuting its letters .",
    "[ d.abeliannetwork ] ( abelian network ) an _ abelian network _ on a directed graph @xmath3 is a collection of automata @xmath35 indexed by the vertices of @xmath36 , such that each @xmath5 is abelian .",
    "we make a few remarks about the definition :    \\1 .",
    "the definition of an abelian network is _ local _ in the sense that it involves checking a condition on each processor individually .",
    "as we will see , these local conditions imply a `` global '' abelian property ( lemma  [ l.localglobalabelian ] ) .",
    "\\2 . a processor @xmath5 is called _ unary _ if its alphabet @xmath7 has cardinality  @xmath37 .",
    "a unary processor is trivially abelian , and any network of unary processors is an abelian network .",
    "most of the examples of abelian networks studied so far are actually unary networks ( an exception is the block - renormalized sandpile defined in @xcite ) .",
    "non - unary networks represent an interesting realm for future study . the `` oil and water model '' defined in [ s.oilwater ] is an example of an abelian network that is not a block - renormalized unary network .",
    "cellular automata are traditionally studied on the grid @xmath38 or on other lattices , but they may be defined on any directed graph  @xmath36 . indeed , we would like to suggest that the study of cellular automata on @xmath36 could be a fruitful means of revealing interesting graph - theoretic properties of  @xmath36 .",
    "abelian networks may be viewed as cellular automata enjoying the following two properties .",
    "abelian networks can update asynchronously . *",
    "traditional cellular automata update in parallel : at each time step , all cells _ simultaneously _ update their states based on the states of their neighbors . since perfect simultaneity is hard to achieve in practice , the physical significance of parallel updating cellular automata is open to debate .",
    "abelian networks do not require the kind of central control over timing needed to enforce simultaneous parallel updates , because they reach the same final state no matter in what order the updates occur .",
    "abelian networks do not rely on shared memory . * implicit in the update rule of cellular automata is an unspecified mechanism by which each cell is kept informed of the states of its neighbors .",
    "the lower - level interactions needed to facilitate this exchange of information in a physical implementation are absent from the model .",
    "abelian networks include these interactions by operating in a `` message passing '' framework instead of the `` shared memory '' framework of cellular automata : an individual processor in an abelian network can not access the states of neighboring processors , it can only read the messages they send .",
    "figure  [ fig : venn ] shows increasingly general classes of abelian networks .",
    "the oldest and most studied is the _",
    "abelian sandpile model _",
    "@xcite , also called _ chip - firing _",
    "@xcite . given a directed graph @xmath3 , the processor at each vertex @xmath4 has input alphabet @xmath39 and state space @xmath40 , where @xmath41 is the outdegree of @xmath42 .",
    "the transition function is @xmath43 ( formally we should write @xmath44 , but when @xmath45 we omit the redundant first argument . ) the message passing functions are @xmath46 for each edge @xmath6 . here",
    "@xmath47 denotes the empty word .",
    "thus each time the processor at vertex @xmath42 transitions from state @xmath48 to state @xmath49 , it sends one letter to each of its out - neighbors ( figure  [ f.sandpile ] ) .",
    "when this happens we say that vertex @xmath42 _ topples _ ( or `` fires '' ) .     showing a vertex @xmath42 and its outneighbors",
    "middle : state diagram for @xmath42 in a sandpile network .",
    "dots represent states , arrows represent transitions when a letter is processed , and dashed vertical lines indicate when letters are sent to the neighbors .",
    "bottom : state diagram for @xmath42 in a toppling network with @xmath51.,title=\"fig : \" ] +   showing a vertex @xmath42 and its outneighbors @xmath50 .",
    "middle : state diagram for @xmath42 in a sandpile network .",
    "dots represent states , arrows represent transitions when a letter is processed , and dashed vertical lines indicate when letters are sent to the neighbors .",
    "bottom : state diagram for @xmath42 in a toppling network with @xmath51.,title=\"fig : \" ] +   showing a vertex @xmath42 and its outneighbors @xmath50 .",
    "middle : state diagram for @xmath42 in a sandpile network .",
    "dots represent states , arrows represent transitions when a letter is processed , and dashed vertical lines indicate when letters are sent to the neighbors .",
    "bottom : state diagram for @xmath42 in a toppling network with @xmath51.,title=\"fig : \" ]      these have the same transition and message passing functions as the sandpile networks above , but we allow the number of states @xmath41 ( called the _ threshold _ of vertex @xmath42 ) to be different from the outdegree of @xmath42 . these networks can be concretely realized in terms of `` chips '' : if a vertex in state @xmath14 has @xmath52 letters in its input feed , then we say that there are @xmath53 chips at that vertex .",
    "when @xmath42 has at least @xmath41 chips , it can _ topple _ , losing @xmath41 chips and sending one chip along each outgoing edge . in a sandpile network the total number of chips is conserved , but in a toppling network , chips may be created ( if @xmath41 is less than the outdegree of @xmath42 , as in the last diagram of figure  [ f.sandpile ] ) or destroyed ( if @xmath41 is larger than the outdegree of @xmath42 ) .    note that some chips are `` latent '' in the sense that they are encoded by the internal states of the processors .",
    "for example if a vertex @xmath42 with @xmath51 is in state  @xmath49 , receives one chip and processes it , then the letter representing that chip is gone , but the internal state increases to  @xmath37 representing a latent chip at @xmath42 .",
    "if @xmath42 receives another chip and processes it , then its state returns to @xmath49 and it topples by sending one letter to each out - neighbor .    it is convenient to specify a toppling network by its _ laplacian _ , which is the @xmath54 matrix @xmath55 with diagonal entries @xmath56 and off - diagonal entries @xmath57 . here",
    "@xmath58 is the number of edges from @xmath42 to @xmath59 in the graph @xmath36 .",
    "sometimes it is useful to consider toppling networks where the number of chips at a vertex may become negative @xcite .",
    "we can model this by enlarging the state space of each processor to include @xmath60 ; these additional states have transition function @xmath61 and send no messages . in [ s.mip ] we will see that these enlarged toppling networks solve certain integer programs .      it is common to consider the sandpile network @xmath62 with a _ sink _",
    "@xmath63 , a vertex whose processor has only one state and never sends any messages .",
    "if every vertex of @xmath36 has a directed path to the sink , then any finite input to @xmath62 will produce only finitely many topplings .",
    "the set of _ recurrent states _ of a sandpile network with sink is in bijection with objects of interest in combinatorics such as oriented spanning trees and @xmath36-parking functions @xcite .",
    "recurrent states of more general abelian networks are defined and studied in the sequel paper @xcite .",
    "[ s.counter ] a _ counter _ is a unary processor with state space @xmath64 and transition @xmath65 , which never sends any messages .",
    "it behaves like a sink , but keeps track of how many letters it has received .      in this simple model of crack formation",
    ", each vertex @xmath42 has a threshold @xmath66 .",
    "vertex @xmath42 becomes `` infected '' as soon as at least @xmath66 of its in - neighbors are infected .",
    "infected vertices remain infected forever .",
    "a question that has received a lot of attention @xcite due to its subtle scaling behavior is : what is the probability the entire graph becomes infected , if each vertex independently starts infected with probability @xmath67 ? to realize bootstrap percolation as an abelian network , we take @xmath39 and @xmath68 , with @xmath69 and @xmath70 the internal state @xmath14 of the processor @xmath5 keeps track of how many in - neighbors of @xmath42 are infected .",
    "when this count reaches the threshold , @xmath5 sends a letter to each out - neighbor of @xmath42 informing them that @xmath42 is now infected .",
    "a _ rotor _ is a unary processor @xmath5 that outputs exactly one letter for each letter input .",
    "that is , for all @xmath33 @xmath71 inputting a single letter into a network of rotors yields an infinite walk @xmath72 , where vertex @xmath73 is the location of the single letter present after @xmath74 processings .",
    "this _ rotor walk _ has been studied under various names : in computer science it was introduced as a model of autonomous agents exploring a territory ( `` ant walk , '' @xcite ) and later studied as a means of broadcasting information through a network @xcite . in statistical physics",
    "it was proposed as a model of self - organized criticality ( `` eulerian walkers , '' @xcite ) .",
    "propp proposed rotor walk as a way of derandomizing certain features of random walk @xcite .     in a simple rotor network .",
    "the out - neighbors @xmath50 of @xmath42 are served repeatedly in a fixed order . ]",
    "most commonly studied are the _ simple _ rotor networks on a directed graph @xmath36 , in which the out - neighbors of vertex @xmath42 are served repeatedly in a fixed order @xmath75 ( figure  [ f.rotor ] ) .",
    "formally , we set @xmath76 , with transition function @xmath77 and message passing functions @xmath78      enlarge each state space @xmath8 of a simple rotor network to include a transient state @xmath79 , which transitions to state @xmath49 but passes no message . starting with all processors in state @xmath79 , the effect is that each vertex `` absorbs '' the first letter it receives , and behaves like a rotor thereafter .",
    "if we input @xmath74 letters to one vertex @xmath80 , then each letter performs a rotor walk starting from @xmath80 until reaching a site that has not yet been visited by any previous walk , where it gets absorbed .",
    "propp @xcite proposed this model as a way of derandomizing a certain random growth process ( internal dla ) .",
    "when the underlying graph is the square grid @xmath81 , the resulting set of @xmath74 visited sites is very close to circular @xcite , and the final states of the processors display intricate patterns that are still not well understood .     in the dartois - rossin height arrow model ( top ) and",
    "eriksson s periodically mutating game ( bottom).,title=\"fig : \" ] +    in the dartois - rossin height arrow model ( top ) and eriksson s periodically mutating game ( bottom).,title=\"fig : \" ]      dartois and rossin  @xcite proposed a common generalization of rotor and sandpile networks called the _ height - arrow model_. diaconis and fulton @xcite and eriksson  @xcite studied generalizations of chip - firing in which each vertex has a stack of instructions .",
    "when a vertex accumulates enough chips to follow the top instruction in its stack , it pops that instruction off the stack and follows it .",
    "these and all preceding examples are _ unary networks _ , that is , abelian networks in which each alphabet @xmath7 has cardinality  @xmath37 .",
    "informally , a unary network on a graph @xmath36 is a system of local rules by which _",
    "indistinguishable _ chips move around on the vertices of @xmath36 .",
    "next we discuss two non - unary examples .       in a network whose underlying graph",
    "is a path or a cycle .",
    "when an agent arrives at vertex @xmath42 , she transitions the state of @xmath42 ( upward if her own state is red , rightward if blue ) ; updates her own state to red or blue according to the color of the line crossed ; and moves to @xmath82 or @xmath83 according to whether the line is solid or dashed . in this example",
    "@xmath84 , and the boxes indicate periodicity in the diagram.,scaledwidth=60.0% ]    in the spirit of @xcite , one could replace the messages in our definition of abelian networks by mobile agents each of which is an automaton . as a function of its own internal state @xmath15 and the state @xmath14 of the vertex  @xmath42 it currently occupies",
    ", an agent acts by doing three things :    1 .",
    "it changes its own state to @xmath85 ; and 2 .",
    "it changes the state of  @xmath42 to @xmath16 ; and 3 .",
    "it moves to a neighboring vertex @xmath86 .",
    "two or more agents may occupy the same vertex , in which case we require that the outcome of their actions is the same regardless of the order in which they act . for purposes of deciding whether two outcomes are the same",
    ", we regard agents with the same internal state and location as indistinguishable .",
    "this model may appear to lie outside our framework of abelian networks , because the computation is located in the moving agents ( who carry their internal states with them ) instead of in the static processors .",
    "however , a moment s thought shows that it has identical behavior to the abelian network with transition function @xmath9 and message passing function @xmath87 abelian mobile agents generalize the rotor networks ( [ s.rotor ] ) by dropping the requirement that processors be unary .",
    "the defining property of abelian mobile agents is that each processor sends exactly one letter for each letter received . in figure  [ f.agents ]",
    "this property is apparent from the fact that each segment of the square grid lies on exactly one message line .",
    "this is a non - unary generalization of sandpiles , inspired by paul tseng s asynchronous algorithm for solving certain linear programs @xcite .",
    "each edge of @xmath36 is marked either as an oil edge or a water edge .",
    "when a vertex topples , it sends out one oil chip along each outgoing oil edge and also one water chip along each outgoing water edge .",
    "the interaction between oil and water is that a vertex is permitted to topple if and only if sufficiently many chips of _ both _ types are present at that vertex . unlike most of the preceding examples ,",
    "oil and water can not be realized with a finite state space @xmath8 , because an arbitrary number of oil chips could accumulate at @xmath42 and be unable to topple if no water chips are present .",
    "we set @xmath88 and @xmath89 , with transition function @xmath90 the internal state of the processor at @xmath42 is a vector @xmath91 keeping track of the total number chips of each type it has received ( figure  [ f.oilwater ] ) .",
    "stochastic versions of the oil and water model are studied in @xcite .",
    "has outgoing oil edges to @xmath92 and @xmath93 , and water edges to @xmath92 and @xmath94 .",
    "bottom : each dot represents a state in @xmath88 , with the origin at lower left .",
    "a toppling occurs each time the state transition crosses one of the bent lines ( for example , by processing an oil @xmath95 in state @xmath96 , resulting in transition to state @xmath97).,title=\"fig : \" ] +   has outgoing oil edges to @xmath92 and @xmath93 , and water edges to @xmath92 and @xmath94 .",
    "bottom : each dot represents a state in @xmath88 , with the origin at lower left .",
    "a toppling occurs each time the state transition crosses one of the bent lines ( for example , by processing an oil @xmath95 in state @xmath96 , resulting in transition to state @xmath97).,title=\"fig : \" ]      in a stochastic abelian network , we allow the transition functions to depend on a probability space @xmath98 : @xmath99 a variety of models in statistical mechanics  including classical markov chains and branching processes , branching random walk , certain directed edge - reinforced walks , internal dla @xcite , the oslo model @xcite , the abelian manna model @xcite , excited walk @xcite , the kesten - sidoravicius infection model @xcite , two - component sandpiles and related models derived from abelian algebras @xcite , activated random walkers @xcite , stochastic sandpiles @xcite , and low - discrepancy random stack @xcite  can all be realized as stochastic abelian networks . in at least one case",
    "@xcite the abelian nature of the model enabled a major breakthrough in proving the existence of a phase transition .",
    "stochastic abelian networks are beyond the scope of the present paper and will be treated in a sequel .",
    "our first aim is to prove a least action principle for abelian networks , lemma  [ l.leastaction ] . this principle says  in a sense to be made precise  that each processor in an abelian network performs the minimum amount of work possible to remove all messages from the network .",
    "various special cases of the least action principle to particular abelian networks have enabled a flurry of recent progress : bounds on the growth rate of sandpiles @xcite , exact shape theorems for rotor aggregation @xcite , proof of a phase transition for activated random walkers @xcite , and a fast simulation algorithm for growth models @xcite .",
    "the least action principle was also the starting point for the recent breakthrough by pegden and smart @xcite showing existence of the abelian sandpile scaling limit .",
    "the proof of the least action principle follows diaconis and fulton ( * ? ? ?",
    "* theorem  4.1 ) .",
    "our observation is that their proof actually shows something more general : it applies to any abelian network . moreover , as noted in @xcite , the proof applies even to executions that are complete but not legal . to explain the last point requires a few definitions .",
    "let @xmath100 be an abelian network with underlying graph @xmath3 , total state space  @xmath101 and total alphabet  @xmath102 . in this section we do not place any finiteness restrictions on @xmath100",
    ": the underlying graph may be finite or infinite , and the state space @xmath8 and alphabet @xmath7 of each processor may be finite or infinite .    we may view the entire network @xmath100 as a single automaton with alphabet @xmath25 and state space @xmath103 . for its states we will use the notation @xmath104 , where @xmath105 and @xmath106 .",
    "if @xmath107 the state @xmath104 corresponds to the configuration of the network @xmath100 such that    * for each @xmath29 , there are @xmath108 letters of type @xmath15 present ; and * for each @xmath4 , the processor at vertex @xmath42 is in state @xmath109 .    allowing @xmath110 to have negative coordinates",
    "is a useful device that enables the least action principle ( lemma  [ l.leastaction ] below ) .",
    "formally , @xmath104 is just an alternative notation for the ordered pair @xmath111 . the decimal point in @xmath104",
    "is intended to evoke the intuition that the internal states @xmath112 of the processors represent latent `` fractional '' messages .",
    "note that @xmath104 indicates only the states of the processors and the _ number _ of letters present of each type .",
    "it gives no information about the order in which letters are to be processed .",
    "indeed , one of our goals is to show that the order does not matter ( theorem  [ t.wishlist ] ) .    for @xmath4 and @xmath19 , denote by @xmath113 the map @xmath114 where @xmath9 is the transition function of vertex @xmath42 ( defined in [ s.definition ] ) .",
    "we define the state transition @xmath115 by @xmath116 where @xmath117 is @xmath37 if @xmath118 and @xmath49 otherwise ; and @xmath119 is the number of @xmath120 s produced when processor @xmath5 in state @xmath109 processes the letter @xmath15 . in other words ,",
    "@xmath121 where @xmath122 is the message passing function of edge @xmath123 , and the sum is over all outgoing edges @xmath123 from @xmath42 ( both sides are vectors in @xmath124 ) .    having defined @xmath125 for letters @xmath15 , we define @xmath126 for a word @xmath127 as the composition @xmath128 . to generalize equation",
    ", we extend the domain of @xmath129 to @xmath130 as follows .",
    "let @xmath131 and let @xmath132 where @xmath133 is the unique vertex such that @xmath134 .",
    "note that if @xmath135 and @xmath136 for @xmath137 , then @xmath138 since @xmath139 acts by identity on @xmath140 and @xmath141 acts by identity on @xmath8 .",
    "recall that @xmath142 and @xmath28 is the number of occurrences of letter @xmath15 in the word @xmath30 . from the definition of @xmath125 we have by induction on @xmath143 @xmath144 where @xmath145 .    in the next lemma and throughout this paper , inequalities on vectors",
    "are coordinatewise .",
    "[ l.monotonicity ] _",
    "( monotonicity ) _ for @xmath146 and @xmath106 , if @xmath147 , then @xmath148 .    for",
    "a vertex @xmath4 let @xmath149 be the projection defined by @xmath150 for @xmath19 and @xmath151 ( the empty word ) for @xmath152 .",
    "equation implies that @xmath153 so it suffices to prove the lemma for @xmath31 for each @xmath4 .",
    "fix @xmath4 and @xmath31 with @xmath147 .",
    "then there is a word @xmath154 such that @xmath155 . given a letter @xmath156 , if @xmath157 then @xmath158 . if @xmath6 , then since @xmath5 is an abelian processor , @xmath159 the first term on the right side equals @xmath160 , and the remaining term is nonnegative , completing the proof .    [ l.piscommute ] for @xmath146 , if @xmath32 , then @xmath161 .",
    "suppose @xmath162 .",
    "then for any @xmath106 we have @xmath163 by lemma  [ l.monotonicity ] .",
    "since @xmath139 and @xmath141 commute for all @xmath164 , we have @xmath165 .",
    "hence the right side of is unchanged by substituting @xmath166 for @xmath30 .",
    "an _ execution _ is a word @xmath167 .",
    "it prescribes an order in which letters in the network are to be processed . for simplicity",
    ", we consider only finite executions in the present paper , but we remark that infinite executions ( and non - sequential execution procedures ) are also of interest @xcite .",
    "fix an initial state @xmath104 and an execution @xmath168 , where each @xmath169 .",
    "set @xmath170 and @xmath171 the _ result _ of executing @xmath30 is @xmath172 .",
    "our goal is to compare the results of different executions .",
    "the letter @xmath29 is called a _ legal move _ from @xmath104 if @xmath173 . an execution @xmath174",
    "is called _ legal _ for @xmath104 if @xmath175 is a legal move from @xmath176 for each @xmath177 .",
    "an execution @xmath174 is called _ complete _ for @xmath104 if @xmath178 for all @xmath29 .",
    "[ l.leastaction ] _ ( least action principle ) _ if @xmath168 is legal for @xmath104 and @xmath179 is complete for @xmath104 , then @xmath147 and @xmath180 .    noting that @xmath181 and @xmath182",
    ", it suffices to prove @xmath147 .",
    "supposing for a contradiction that @xmath183 , let @xmath184 be the smallest index such that @xmath185 .",
    "let @xmath186 and @xmath187 .",
    "then @xmath188 , and @xmath189 for all @xmath190 .",
    "since @xmath15 is a legal move from @xmath191 , we have by and lemma  [ l.monotonicity ] @xmath192 since @xmath166 is complete , the right side is @xmath193 by , which yields the required contradiction .",
    "[ l.dichotomy ] _ ( halting dichotomy ) _ for a given initial state @xmath112 and input @xmath110 to an abelian network @xmath100 , either    1 .",
    "there does not exist a finite complete execution for @xmath104 ; or 2 .",
    "every legal execution for @xmath104 is finite , and any two complete legal executions @xmath194 for @xmath104 satisfy @xmath162 .",
    "if there exists a finite complete execution , say of length @xmath63 , then every legal execution has length @xmath195 by lemma  [ l.leastaction ] . if @xmath30 and @xmath166 are complete legal executions , then @xmath196 by lemma  [ l.leastaction ]",
    ".    note that in case ( 1 ) any finite legal execution @xmath30 can be extended by a legal move : since @xmath30 is not complete , there is some letter @xmath197 such that @xmath198 is legal .",
    "so in this case there is an infinite word @xmath199 such that @xmath200 is a legal execution for all @xmath201 .",
    "the _ halting problem _ for abelian networks asks , given @xmath100 , @xmath110 and @xmath112 , whether ( 1 ) or ( 2 ) of lemma  [ l.dichotomy ] is the case . in case ( 2 ) we say that @xmath100 _ halts _ on input @xmath104 . in the sequel",
    "@xcite we characterize the finite abelian networks that halt on all inputs .",
    "[ d.odometer ] ( odometer ) if @xmath100 halts on input @xmath104 , we denote by @xmath202_a = |w|_a$ ] the total number of letters @xmath15 processed during a complete legal execution @xmath30 of @xmath104 .",
    "the vector @xmath202 \\in \\n^a$ ] is called the _ odometer _ of @xmath104 . by lemma  [ l.dichotomy ] ,",
    "the odometer does not depend on the choice of complete legal execution @xmath30 .",
    "no messages remain at the end of a complete legal execution @xmath30 , so the network ends in state @xmath203 .",
    "hence by , the odometer can be written as @xmath204 = |w| = \\xx + \\mathbf{n}(w,\\qq)\\ ] ] which simply says that the total number of letters processed ( of each type @xmath197 ) is the sum of the letters input and the letters produced by message passing .",
    "the coordinates of the odometer are the `` specific local run times '' from [ s.definition ] .",
    "we can summarize our progress so far in the following theorem .",
    "[ t.wishlist ] abelian networks have properties from [ s.definition ] .    by lemma  [ l.dichotomy ] the halting status does not depend on the execution , which verifies item ( a ) .",
    "moreover for a given @xmath205 any two complete legal executions have the same odometer , which verifies items ( c)(e ) .",
    "the odometer and initial state @xmath112 determine the final state @xmath206 , which verifies ( b ) .",
    "the next lemma illustrates a general theme of _ local - to - global principles _ in abelian networks .",
    "suppose we are given a partition @xmath207 of the vertex set into `` interior '' and `` output '' nodes , and that the output nodes never send messages ( for example , the processor at each output node could be a counter , [ s.counter ] ) .",
    "we allow the possibility that @xmath208 is empty .",
    "if @xmath100 halts on all inputs , then we can regard the induced subnetwork @xmath209 of interior nodes as a single processor @xmath210 with input alphabet @xmath211 , state space @xmath212 , and an output feed for each edge @xmath213 .",
    "[ l.localglobalabelian ] _ ( local abelianness implies global abelianness ) _",
    "if @xmath100 halts on all inputs and @xmath5 is an abelian processor for each @xmath214 , then @xmath210 is an abelian processor .",
    "given an input @xmath215 and an initial state @xmath216 , we can process one letter at a time to obtain a complete legal execution for @xmath217 .",
    "now suppose we are given inputs @xmath218 such that @xmath219 .",
    "by lemma  [ l.dichotomy ] , any two complete legal executions @xmath194 for @xmath217 satisfy @xmath162 .",
    "in particular , @xmath220 , so the final state of @xmath210 does not depend on the order of input .",
    "now given @xmath214 , let @xmath221 be the word obtained from @xmath30 by deleting all letters not in @xmath7 . then @xmath222 .",
    "for each edge @xmath213 ,",
    "since @xmath5 is an abelian processor , @xmath223 so for each @xmath156 the number of letters @xmath15 sent along @xmath224 does not depend on the order of input .",
    "for another example of a local - to - global principle , see ( * ? ? ?",
    "* lemma  2.6 ) .",
    "further local - to - global principles in the case of rotor networks are explored in @xcite .      in this section",
    "we describe a class of optimization problems that abelian networks can solve .",
    "let @xmath25 be a finite set and @xmath225 a nondecreasing function : @xmath226 whenever @xmath227 ( inequalities are coordinatewise ) .",
    "let @xmath228 be a vector with all coordinates positive , and consider the following problem .",
    "let us call a vector @xmath230 _ feasible _ if @xmath2 .",
    "if @xmath231 and @xmath232 are both feasible , then their coordinatewise minimum is feasible : @xmath233 therefore if a feasible vector exists then the minimizer is unique and independent of the positive vector @xmath234 : it is simply the coordinatewise minimum of all feasible vectors .",
    "let @xmath100 be an abelian network with finite alphabet @xmath25 and finite or infinite state space @xmath235 .",
    "fix @xmath107 and @xmath106 , and let @xmath236 be given by @xmath237 where @xmath238 is defined as @xmath239 for any word @xmath30 such that @xmath240 .",
    "the function @xmath241 is well - defined and nondecreasing by lemma  [ l.monotonicity ] .",
    "recall the odometer @xmath202 $ ] is the vector of specific local runtimes ( definition  [ d.odometer ] ) .    _",
    "( abelian networks solve monotone integer programs ) _ [ t.mip ]    1 .",
    "if @xmath100 halts on input @xmath104 , then @xmath242 $ ] is the unique minimizer of .",
    "if @xmath100 does not halt on input @xmath104 , then has no feasible vector @xmath243 .    by , any complete execution @xmath30 for @xmath104 satisfies @xmath244 ; and conversely , if @xmath2 then any @xmath167 such that @xmath240 is a complete execution for @xmath104 .",
    "if @xmath100 halts on input @xmath104 then the odometer @xmath202 $ ] is defined as @xmath245 for a complete _ legal _ execution @xmath30 . by the least action principle ( lemma  [ l.leastaction ] ) , for each @xmath29 we have @xmath204_a = \\min \\ { |w|_a \\ , : \\",
    ", w \\mbox { is a complete execution for } \\xx.\\qq \\}\\ ] ] so @xmath202 $ ] is the coordinatewise minimum of all feasible vectors .",
    "if @xmath100 does not halt on input @xmath104 , then there does not exist a complete execution for @xmath104 , so there is no feasible vector .    for any nondecreasing @xmath236",
    ", there is an abelian network @xmath246 that solves the corresponding optimization problem .",
    "its underlying graph is a single vertex @xmath42 with a loop @xmath247 .",
    "it has state space @xmath248 , transition function @xmath249 and message passing function satisfying @xmath250 for all @xmath29 and @xmath106 . for the input",
    "we take @xmath251 and @xmath252 .",
    "in general the problem is nonlinear , but in the special case of a _ toppling network _",
    "it is equivalent to a linear integer program of the following form . @xmath253 here @xmath228 has all coordinates positive ; @xmath55 is the laplacian matrix ( [ s.toppling ] ) ; and @xmath254 where @xmath108 is the number of chips input at @xmath15 and @xmath255 is the threshold of @xmath15 .",
    "the coordinate @xmath256 of the minimizer is the number of times @xmath15 topples . to see the equivalence of and for toppling networks , note that @xmath241 takes the following form for a toppling network : @xmath257 where @xmath258 is the diagonal matrix with diagonal entries @xmath255 , and @xmath259 denotes the coordinatewise greatest integer function . using that @xmath260 is a nonnegative matrix , one checks that @xmath261 is feasible for if and only if @xmath262 is feasible for .",
    "we indicate here a few directions for further research on abelian networks .",
    "other directions are indicated in the sequels @xcite .      what does an abelian network `` know '' about its underlying graph ?",
    "for instance , chan , church and grochow @xcite have shown that a rotor network can detect whether its underlying graph is planar ( with edge orderings respecting the planar embedding ) .",
    "theorem  [ t.wishlist ] shows that abelian networks can compute asynchronously , and theorem  [ t.mip ] gives an example of something they can compute",
    ". it would be interesting to explore whether abelian networks can perform computational tasks like shortest path , pagerank , image restoration and belief propagation .",
    "in [ s.cellular ] we have emphasized that abelian networks do not rely on shared memory .",
    "yet there are quite a few examples of processes with a global abelian property that do .",
    "perhaps the simplest is _ sorting by adjacent transpositions _",
    ": suppose @xmath36 is the path of length @xmath74 and each vertex @xmath42 has state space @xmath263 .",
    "the processors now live on the edges : for each edge @xmath264 the processor @xmath265 acts by swapping the states @xmath266 and @xmath267 if @xmath268 .",
    "this example does not fit our definition of abelian network because the processors of edges @xmath269 and @xmath270 share access to the state @xmath266 .",
    "indeed , from our list of five goals in this example satisfies items ( a)(c ) only : the final output is always sorted , and the run time does not depend on the execution , but the local run times do depend on the execution .    what is the right definition of an abelian network with shared memory ?",
    "examples could include the numbers game of mozes @xcite , @xmath52-cores of graphs and hypergraphs , wilson cycle popping @xcite and its extension by gorodezky and pak @xcite , source reversal @xcite and cluster firing @xcite .",
    "the work of krohn and rhodes @xcite led to a detailed study of how the algebraic structure of monoids relates to the computational strength of corresponding classes of automata .",
    "it would be highly desirable to develop such a dictionary for classes of automata _",
    "networks_. thus one would like to weaken the abelian property and study networks of solvable automata , nilpotent automata , etc .",
    "such networks are nondeterministic  the output depends on the order of execution  so their theory promises to be rather different from that of abelian networks",
    ". it could be fruitful to look for networks that exhibit only limited nondeterminism .",
    "a concrete example is a sandpile network with annihilating particles and antiparticles , studied by robert cori ( unpublished ) and in @xcite under the term `` inverse toppling . ''",
    "the authors thank spencer backman , olivier bernardi , deepak dhar , anne fey , sergey fomin , christopher hillar , michael hochman , alexander holroyd , benjamin iriarte , mia minnes , ryan odonnell , david perkinson , james propp , leonardo rolla , farbod shokrieh , allan sly and peter winkler for helpful discussions .",
    "sergio caracciolo , guglielmo paoletti and andrea sportiello , multiple and inverse topplings in the abelian sandpile model .",
    "_ the european physical journal - special topics _ * 212*(1)2344 , 2012 .",
    "http://arxiv.org/abs/1112.3491[arxiv:1112.3491 ]      yao - ban chan , jean - franois marckert , and thomas selig , a natural stochastic extension of the sandpile model on a graph , _ j. combin .",
    "theory a _ * 120*(7):19131928 , 2013 .",
    "http://arxiv.org/abs/1209.2038[arxiv:1209.2038 ]    denis chebikin and pavlo pylyavskyy , a family of bijections between @xmath36-parking functions and spanning trees , _ j. combin .",
    "theory a _ * 110*(1):3141 , 2005 .",
    "http://arxiv.org/abs/math/0307292[arxiv:math/0307292 ]                deepak dhar , studying self - organized criticality with exactly solved models , 1999 .",
    "deepak dhar , some results and a conjecture for manna s stochastic sandpile model , _ physica a _ * 270*:6981 , 1999 .",
    "http://arxiv.org/abs/cond-mat/9902137[arxiv:cond-mat/9902137 ]          ronald dickman , leonardo t. rolla and vladas sidoravicius , activated random walkers : facts , conjectures and challenges , _ j. stat .",
    "phys . _ * 138*(1 - 3):126142 , 2010 .",
    "http://arxiv.org/abs/0910.2725[arxiv:0910.2725 ]    benjamin doerr , tobias friedrich and thomas sauerwald , quasirandom rumor spreading , _ proceedings of the nineteenth annual acm - siam symposium on discrete algorithms ( soda 08 ) _ , pages 773781 , 2008 .",
    "http://arxiv.org/abs/1012.5351[arxiv:1012.5351 ]                        giuliano pezzolo giacaglia , lionel levine , james propp and linda zayas - palmer , local - to - global principles for the hitting sequence of a rotor walk , _ electr",
    ".  j. combin . _ * 19*:p5 , 2012 .",
    "http://arxiv.org/abs/1107.4442[arxiv:1107.4442 ]    alexander e. holroyd , sharp metastability threshold for two - dimensional bootstrap percolation , _ probab .",
    "theory related fields _ , * 125*(2):195224 , 2003 .",
    "http://arxiv.org/abs/math/0206132[arxiv:math/0206132 ]    alexander e. holroyd , lionel levine , karola mszros , yuval peres , james propp and david b. wilson , chip - firing and rotor - routing on directed graphs , in _ in and out of equilibrium 2 _ , pages 331364 , progress in probability * 60 * , birkhuser , 2008 .",
    "http://arxiv.org/abs/0801.3306[arxiv:0801.3306 ]    alexander e. holroyd and james g. propp , rotor walks and markov chains , in _ algorithmic probability and combinatorics _ , american mathematical society , 2010 .",
    "http://arxiv.org/abs/0904.4507[arxiv:0904.4507 ]",
    "v. b. priezzhev , deepak dhar , abhishek dhar and supriya krishnamurthy , eulerian walkers as a model of self - organised criticality , _ phys .",
    "lett . _ * 77*:50795082 , 1996 .",
    "http://arxiv.org/abs/cond-mat/9611019[arxiv:cond-mat/9611019 ]    alexander postnikov and boris shapiro , trees , parking functions , syzygies , and deformations of monomial ideals .",
    "_ trans .",
    "soc . _ * 356*(8):31093142 , 2004 .",
    "http://arxiv.org/abs/math.co/0301110[arxiv:math.co/0301110 ]      james",
    "propp , random walk and random aggregation , derandomized , 2003 .",
    "james propp , discrete analog computing with rotor - routers .",
    "_ chaos _ * 20*:037110 , 2010 .",
    "http://arxiv.org/abs/1007.2389[arxiv:1007.2389 ]    leonardo t. rolla and vladas sidoravicius , absorbing - state phase transition for driven - dissipative stochastic dynamics on @xmath272 , _ inventiones math .",
    "_ * 188*(1):127150 , 2012 .",
    "http://arxiv.org/abs/0908.1152[arxiv:0908.1152 ]      israel a. wagner , michael lindenbaum and alfred m. bruckstein , smell as a computational resource  a lesson we can learn from the ant , _ 4th israeli symposium on theory of computing and systems _ , pages 219230 , 1996 ."
  ],
  "abstract_text": [
    "<S> in deepak dhar s model of abelian distributed processors , automata occupy the vertices of a graph and communicate via the edges . </S>",
    "<S> we show that two simple axioms ensure that the final output does not depend on the order in which the automata process their inputs . </S>",
    "<S> a collection of automata obeying these axioms is called an _ abelian network_. </S>",
    "<S> we prove a least action principle for abelian networks . as an application </S>",
    "<S> , we show how abelian networks can solve certain linear and nonlinear integer programs asynchronously . in </S>",
    "<S> most previously studied abelian networks , the input alphabet of each automaton consists of a single letter ; in contrast , we propose two non - unary examples of abelian networks : _ oil and water _ and _ abelian mobile agents_. </S>"
  ]
}