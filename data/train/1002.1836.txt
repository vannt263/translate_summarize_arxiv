{
  "article_text": [
    "type inference of logic programs is the problem of computing , at compile time , a representation of the terms that the predicate arguments will be bound to during execution of the program .",
    "this kind of type inference involves not only assigning types to procedure arguments out of a predefined set of type definitions , as in traditional type inference , but also the more complex problem of inferring the type definitions themselves , similarly to what is done in _",
    "shape analysis_. although most logic programming languages are either untyped or allow mixing typed and untyped code , inferring type information for the entire program is important since it allows the compiler to generate more efficient code and it has well - known advantages in detecting programming errors early .",
    "for instance , simple uses of such information include better indexing , specialized unification , and more efficient code generation .",
    "more advanced uses include compile - time garbage collection and non - termination detection .",
    "there are also other areas in which type information can be useful .",
    "for example , during verification and debugging it can provide information to the programmer that is not straightforward to obtain by manual inspection of the program .",
    "in this paper we use the _ set constraint - based _ approach  @xcite .",
    "we propose an algorithm for solving a set constraint system that relates the set of possible values of the program variables , by transforming it into a system whose solutions provide the type definitions for the variables involved in _",
    "parameterized regular form_. we focus on types which are conservative approximations of the meaning of predicates , and hence , over - approximations of the _ success set _ ( in contrast to the approach of inferring well - typings , as in , e.g. ,  @xcite , which may differ from the actual success set of the program ) .",
    "type inference via set constraint solving was already proposed in  @xcite",
    ". however , most existing algorithms  @xcite are either too complicated or lacking in precision for some classes of programs .",
    "we try to alleviate these problems by , first , generating simple equations ; second , using a comparatively straightforward procedure for solving them ; and , third , using a non - standard operation during solving that improves precision by `` guessing '' values . at the same time , we attack a more ambitious objective since our resulting types , that we call _ parameterized _ , are more expressive than in previous proposals .        [ cols= \" < ,",
    "in order to study the practicality of our method we have implemented a prototype analyzer in ` ciao `   ( ` http://www.ciaohome.org `  @xcite ) and processed a representative set of benchmarks taken mostly from the plai ( the ` ciao `  program analyzer ) and gaia  @xcite sets .",
    "we chose the _ non - deterministic finite tree automaton _",
    "( nfta)-based analysis  @xcite for comparison .",
    "we believe that this is a fair comparison since it also over - approximates the success set of a program in a bottom - up fashion ( inferring regular types ) .",
    "its implementation is publicly available ( ` http://saft.ruc.dk/tattoo/index.php ` ) and it is also written in ` ciao ` .",
    "we decided not to compare herein with top - down , widening - based type analyses ( e.g.  @xcite ) , since it is not clear how they relate to our method .",
    "we leave this comparison as interesting future work .",
    "the results are shown in table  [ table : results ] .",
    "the fourth and seventh columns show analysis times in seconds for both analyses on an intel core duo 1.33ghz cpu , 1 gb ram , and ubuntu 8.10 linux os .",
    "the time for reading the program and generating the constraints is omitted because it is always negligible compared to the analysis time .",
    "column shows the number of type descriptors ( i.e. , predicate argument positions ) which will be considered for the accuracy test ( all type descriptors are considered for the timing results ) . for simplicity , we report only on the argument positions belonging to the main predicate .",
    "note that execution of these predicates often reaches all the predicates in the program and thus the accuracy of the types for those positions is often a good summary of precision for the whole program .",
    "columns labeled show the number of type descriptions inferred by nfta and our approach that are different from type _ any_. to test precision further , we have added to each benchmark a query that fails , which is shown in the last column ( ) . columns labeled show whether this is captured by the analysis or not .    regarding _ accuracy _ ,",
    "our experiments show that parameterized types allow inferring type descriptors with significant better precision .",
    "our approach inferred type descriptions different from _ any _ for every one of the 35 argument positions considered , while nfta inferred only 13 .",
    "moreover , those type descriptors were accurate enough to capture type emptiness ( i.e. , failure ) in 10 over 13 cases , whereas nfta could only catch two errors .",
    "the cases of , , and deserve special attention , since our method could not capture emptiness for them . for the types inferred are not precise enough to capture that the second argument is not in disjunctive normal form .",
    "this is due to the lack of inter - variable dependencies in our set - based approach .",
    "however , emptiness is easily captured for other calls such as ` dnf(x , b ) . `",
    "a similar reasoning holds for since the analysis infers that the types of the pegs are the union of ` a ` , ` b ` , ` c ` , ` e ` , and ` f ` . finally , the success of depends on a run - time condition , and thus no static analysis can catch the possible error .",
    "regarding _ efficiency _ , we expected our analysis to be slower than other less expressive methods ( like nfta ) , since our method is more expressive than previous proposals .",
    "table  [ table : results ] shows that this is indeed the case , but the differences are reasonable for the selected set of benchmarks , specially considering the improvement in accuracy .",
    "further research is of course needed using larger programs ( see sect .",
    "[ sec : conclusionsfuture ] ) , but we find the results clearly encouraging .",
    "type inference , i.e. , inferring type definitions from a program , has received a lot of attention in logic programming . mishra and reddy  @xcite propose the inference of ground regular trees that represent types , and compute an upper approximation of the success set of a program .",
    "the types inferred are monomorphic .",
    "zobel  @xcite also proposes a type inference method for a program , where the type of a logic program is defined as a recursive ( regular ) superset of its logical consequences .",
    "however , the inference procedure does not derive truly polymorphic types : the type variables are just names for types that are defined by particular type rules .    in  @xcite an inference method",
    "called type reconstruction is defined , which derives types for the predicates and variables of a program .",
    "the types are polymorphic but they are fixed in advance . on the contrary ,",
    "our inference method constructs type definitions during the analysis . in",
    "@xcite the idea is that the least set - based model of a logic program can be seen as the exact herbrand model of an approximate logic program .",
    "this approximate program is a regular unary program , which has a specific syntactic form which limits its computational power .",
    "for example , type parameters can not be expressed .",
    "the work of  @xcite also builds regular unary programs , and their type inference derives such programs .",
    "however , the types remain monomorphic .",
    "heintze and jaffar  @xcite defined an elegant method for semantic approximation , which was the origin of set - based analysis of logic programs .",
    "the semantics computes , using set substitutions , a finite representation of a model of the program that is an approximation of its least model .",
    "unfortunately , the algorithm of  @xcite was rather complicated and practical aspects were not addressed .",
    "such practical aspects were addressed instead in subsequent work  @xcite , simplifying the process .",
    "however , our equations are still simpler : for example , we do not make use of _ projections _ , i.e. , expressions of the form @xmath0 , where @xmath1 is a constructor , the meaning of , e.g. , @xmath2 being that @xmath3 . also , and more importantly",
    ", these approaches do not take advantage of parameters , and the types obtained are again always monomorphic .",
    "type inference has also been approached using the technique of abstract interpretation .",
    "a fixpoint is computed , in most cases with the aid of a widening operation to limit the growth of the type domain .",
    "this technique is also used in  @xcite . however , none of the analyses proposed to date ( e.g. ,  @xcite ) is parametric .",
    "it is not clear how the approach based on abstract domains with widening compares to the set constraints - based approach .",
    "an interesting avenue for future work , however , is to define our analysis as a fixpoint .",
    "this is possible in general due to a result by cousot and cousot  @xcite which shows that rewriting systems like ours can be defined alternatively in terms of a fixpoint computation .",
    "directional types  @xcite are based on viewing a predicate as a procedure that maps a call type to a success type .",
    "this captures some dependencies between arguments , but they are restricted to monomorphic types .",
    "it would be interesting to build this idea into our approach .",
    "we believe that some imprecision found in analyzing recursive calls with input arguments could be alleviated by using equations which captured both calls and successes",
    ". the relation of these with directional types might be worth investigating .",
    "bruynooghe , gallagher , humbeeck , and schrijvers  @xcite develop analyses for type inference which are also based on the set constraints approach . however , their analyses infer well - typings , so that the result is not an approximation of the program success set , as in our case . in consequence , their algorithm is simpler , mainly because they do not need to deal with intersection . in  @xcite the monomorphic analysis of  @xcite",
    "is extended to the polymorphic case , using types with an expressiveness comparable to our parameterized types .",
    "the set constraints approach to type analysis is also taken in nfta  @xcite , which is probably the closest to ours",
    ". however , the types inferred in this analysis , which are approximations of the program success set , are not parametric and as a result the analysis is less precise than ours , as shown in our experiments .",
    "the work of  @xcite aims at inferring parametric types that approximate the success set .",
    "although independently developed , it includes some of the ideas we propose .",
    "however , the authors do not use the set - based approach , and their inference algorithm is rather complex .",
    "the latter made the authors abandon that line of work and the approach was not developed , switching instead to well - typings .",
    "to conclude , using the set constraints approach we have proposed a simple type inference based on the rewriting of equations which , despite its simplicity , allows enhanced expressiveness .",
    "this is achieved by using type variables with a global scope as true parameters of the equations .",
    "the improved expressiveness allows for better precision , at an additional cost in efficiency , which is , nevertheless , not high .    during our tests ,",
    "we have identified potential bottlenecks in our analysis which may appear in large programs and which are worth investigating in future research .",
    "some practical issues were already addressed by heintze in  @xcite , that we have not considered , concentrating instead in this paper on the precision and soundness of our approach . in particular , it is well - known that a naive dnf expansion may make the size of an expression grow exponentially .",
    "however , we use simple rules for minimizing the number of expressions ( such as computing only intersections that will survive after simplification ) which work quite well in practice . even for larger programs we expect these rules to be effective , based on the experience of  @xcite .",
    "an efficient method for storing the new intersections generated in line  [ eq : capcons ] in simp is also needed for the scalability of the system .",
    "we use the same simple technique as  @xcite . note that the size of the table is in the worst case @xmath4 where @xmath5 is the number of original variables in the program .",
    "however , the size of the table actually grows almost linearly in our experiments ( we omitted these results due to space limitations ) .",
    "even if the size of the table were to grow faster , we believe that we can mitigate this effect with similar techniques ( e.g. , use of bdds ) to  @xcite , because of the high level of redundancy .",
    "we have also observed that the replacement performed in lines  [ solve : replace-1 ] and  [ solve : replace-2 ] of solve may be expensive for large programs .",
    "we think that there are many opportunities for reducing this limitation ( e.g. , dependency directed updating  @xcite ) .",
    "+ * acknowledgments : * the authors would like to thank john gallagher and the anonymous referees for useful comments on previous versions of this paper .",
    "this work was funded in part by eu projects fet ist-15905 _ mobius _ , ist-215483 _ scube _ , fet ist-231620 _ hats _ , and 06042-espass , ministry of science projects 1tin-2008 - 05624 _ doves _ , ministry of industry project fit-340005 - 2007 - 14 , cam project s-0505/tic/0407 _ promesas _ , and singapore ministry of education academic research fund no .",
    "rp-252 - 000 - 234 - 112 .",
    "m.  bruynooghe and j.  gallagher . nferring polymorphic types from logic programs . in _ international symposium on logic - based program synthesis and transformation ( lopst  r04)_. preproceedings , july 2004 .",
    "m.  bruynooghe , j.  gallagher , and w.  humbeeck .",
    "inference of well - typings for logic programs with application to termination analysis . in _",
    "12th international static analysis symposium ( sas05 ) _ , volume 3672 of _ lncs _ , pages 3551 .",
    "springer - verlag , 2005 .",
    "f.  bueno , d.  cabeza , m.  carro , m.  hermenegildo , p.  lpez - garca , and g.  puebla ( eds . ) .",
    "he ciao system .",
    "manual ( v1.13 ) .",
    "technical report , school of cs ( upm ) , 2006 .",
    "available at ` http://www.ciaohome.org ` .",
    "p.  cousot and r.  cousot .",
    "formal language , grammar and set - constraint - based program analysis by abstract interpretation . in _ proc .",
    "acm conf .  on functional programming langguages and computer architecture _ ,",
    "pages 170181 .",
    "acm press , new york , ny , 1995 .",
    "j.  gallagher and g.  puebla .",
    "bstract interpretation over non - deterministic finite tree automata for set - based analysis of logic programs . in _",
    ".  symp .  on practical aspects of decl .",
    "languages _ , number 2257 in lncs , pages 243261 .",
    "springer - verlag , january 2002 .",
    "gallagher and d.a .",
    "de  waal .",
    "fast and precise regular approximations of logic programs . in pascal van  hentenryck , editor , _ proc .  of the 11th international conference on logic programming _ , pages 599613 . mit press , 1994 .",
    "h.  saglam and j.  gallagher . approximating logic programs using types and regular descriptions .",
    "technical report cstr-94 - 19 , department of computer science , university of bristol , bristol bs8 1tr , 1994 .",
    "p.  van  hentenryck , a.  cortesi , and b.  le charlier .",
    "type analysis of prolog using type graphs . in _",
    "acm sigplan94 conference on programming language design and implementation _ , pages 337348 .",
    "acm sigplan notices vol .",
    "29 no . 6 , 1994 .",
    "c.  vaucheret and f.  bueno .",
    "ore precise yet efficient type inference for logic programs . in _ international static analysis symposium _",
    ", volume 2477 of _ lecture notes in computer science _ , pages 102116 .",
    "springer - verlag , september 2002 ."
  ],
  "abstract_text": [
    "<S> we propose a method for inferring _ parameterized regular types _ for logic programs as solutions for systems of constraints over sets of finite ground herbrand terms ( set constraint systems ) . </S>",
    "<S> such parameterized regular types generalize _ parametric _ regular types by extending the scope of the parameters in the type definitions so that such parameters can relate the types of different predicates . </S>",
    "<S> we propose a number of enhancements to the procedure for solving the constraint systems that improve the precision of the type descriptions inferred . </S>",
    "<S> the resulting algorithm , together with a procedure to establish a set constraint system from a logic program , yields a program analysis that infers tighter safe approximations of the success types of the program than previous comparable work , offering a new and useful efficiency vs.  precision trade - off . </S>",
    "<S> this is supported by experimental results , which show the feasibility of our analysis . </S>"
  ]
}