{
  "article_text": [
    "the one - sided matching problem is concerned with the allocation of indivisible goods to self - interested agents with privately known preferences .",
    "monetary transfers are not permitted , which makes this problem different from auctions and other settings with transferable utility . the first version of this problem was introduced by @xcite , and",
    "has since attracted much attention from mechanism designers ( e.g. , @xcite ) . in practice ,",
    "such problems often arise in situations that are of great importance to peoples lives .",
    "for example , students must be matched to schools , teachers to training programs , houses to tenants , etc .",
    "@xcite .",
    "as mechanism designers , we care specifically about _ efficiency _ , _ fairness _ , and _",
    "strategyproofness_. @xcite showed that it is impossible to achieve the optimum on all three dimensions simultaneously , which makes the one - sided matching problem an interesting mechanism design challenge .",
    "especially strategyproofness is a severe design constraint : the folklore random serial dictatorship mechanism is strategyproof and anonymous , but only _ ex - post efficient . _",
    "the more demanding _ ordinal efficiency _ is achieved by the probabilistic serial mechanism ( @xmath0 ) , but any mechanism that guarantees ordinal efficiency and strategyproofness will violate symmetry @xcite . finally , _",
    "rank efficiency _ , an even stronger efficiency concept , can be achieved via rank - value mechanisms @xcite , but is incompatible even with _",
    "weak strategyproofness_. obviously , trade - offs are necessary , and researchers have called for useful relaxations ( e.g. , @xcite ) .    in recent years , some progress on _ approximate strategyproofness _ has been made for quasi - linear domains ( see @xcite for a survey ) .",
    "however , these approaches do not translate to the matching domain , where a relaxed notion of strategyproofness has remained elusive so far . in our view , a relaxed strategyproofness concept should address the following two questions that commonly arise in this domain :    1",
    ".   what honest and useful strategic advice can we give to agents ?",
    "how can we measure `` how strategyproof '' a manipulable mechanism is , e.g. , @xmath0  or the boston mechanism ?    in this paper , we take an axiomatic approach to the problem of characterizing and relaxing strategyproofness of one - sided matching mechanisms . our new _ partial strategyproofness _",
    "concept provides intriguing answers to both questions .",
    "suppose an agent considers swapping two adjacent objects in its reported preference order , e.g. , from @xmath1 to @xmath2 .",
    "our axioms restrict the way in which the mechanism can react to this kind of change of report ( i.e. , how this can affect the allocation of the reporting agent ) .",
    "the first axiom , _ swap monotonicity _ , requires that either the allocation remains unchanged , or the allocation for @xmath3 must strictly increase , and the allocation for @xmath4 must strictly decrease .",
    "this means that the mechanism is responsive to the agent s ranking of @xmath4 and @xmath3 and the swap affects at least the objects @xmath4 and @xmath3 , if any .",
    "the second axiom , _ upper invariance _",
    ", requires that the allocation for all objects strictly preferred to @xmath4 does not change under the swap .",
    "this essentially means that the mechanism is robust to manipulation by truncation , i.e. , falsely claiming higher preference for an outside option .",
    "upper invariance was introduced by @xcite ( called _ weak invariance _ in their paper ) as one of the axioms to characterize @xmath0 .",
    "finally , we introduce _ lower invariance _ , which requires that the allocation does not change for any object that the agent ranks below @xmath3 .",
    "it turns out that one - sided matching mechanisms are strategyproof if and only if they satisfy all three axioms , which is our first main result .      for our second main result",
    "we drop the lower invariance axiom . to understand incentives in mechanisms that are swap monotonic and upper invariant",
    ", we define a relaxed notion of strategyproofness .",
    "intuitively , the mechanism must be strategyproof on a restricted domain , where agents have sufficiently different values for different objects .",
    "a utility function satisfies _ uniformly relatively bounded indifference _ with respect to _ bound _ @xmath5 $ ] ( @xmath6 ) if , given @xmath1 , the agent s normalized value for @xmath3 is at least a factor @xmath7 lower than its value for @xmath4 , i.e. , @xmath8 .",
    "we say that a mechanism is _",
    "@xmath7-partial strategyproof _ if the mechanism is strategyproof for all agents whose utility functions are bounded away from indifference by the factor @xmath7 .",
    "our second main result is the following equivalence : for any setting ( i.e. , number of agents , number of objects , and object capacities ) a mechanism is swap monotonic and upper invariant if and only if it is @xmath7-partially strategyproof for some @xmath5 $ ] .",
    "the main contributions of this paper are an axiomatic characterization of strategyproofness and a characterization of @xmath7-partial strategyproofness , an intuitive relaxation of strategyproofness .",
    "we obtain the following results :    1 .",
    "* axiomatic characterization of strategyproof mechanisms ( thm .",
    "[ thm : characteriaztion_sp ] ) : * we show that a mechanism is swap monotonic , upper invariant , and lower invariant _ if and only if _ it is strategyproof .",
    "* axiomatic characterization of -partially strategyproof mechanisms ( thm .",
    "[ thm : characterization_psp ] ) : * we show that a mechanism is upper invariant and swap monotonic _ if and only if _ there exists @xmath5 $ ] such that it is @xmath7-partially strategyproof . here , the bound @xmath7 may depend on the setting .",
    "* maximality of the domain restriction ( thm .",
    "[ thm : maximality ] ) : * we show that given any setting with @xmath9 objects , any bound @xmath10 , and any utility function @xmath11 that violates @xmath6 , there exists a mechanism @xmath12 that is @xmath7-partially strategyproof , but manipulable for @xmath11 .",
    "* degree of strategyproofness and computability ( def .",
    "[ def : parameter_rho ] & prop .",
    "[ prop : verify_urbi ] ) : * we introduce the maximum value of @xmath7 as a measure for the degree of strategyproofness of a mechanism .",
    "we also show how @xmath7-partial strategyproofness can be algorithmically verified and how the degree of strategyproofness can be computed ( although the algorithm we present has exponential complexity ) .    to the best of our knowledge ,",
    "we present the first axiomatic characterization of strategyproof one - sided matching mechanisms in the vnm - utility domain .",
    "based on this , our axiomatic treatment leads to a new way of thinking about how to relax strategyproofness .",
    "furthermore , @xmath7-partial strategyproofness is the first parametric relaxation of strategyproofness in this domain .",
    "we also demonstrate how @xmath7-partial strategyproofness can be used to analyze the incentive properties of popular non - strategyproof mechanisms , like probabilistic serial or variants of the boston mechanism .",
    "while the seminal paper on one - sided matching mechanisms by @xcite proposed a mechanism that elicits agents _ cardinal _ utilities , this approach has proven problematic because it is difficult if not impossible to elicit cardinal utilities in settings without money .",
    "for this reason , recent work has focused on _ ordinal mechanisms _",
    ", where agents submit ordinal preference reports , i.e. , rankings over all objects ( for an example see @xcite , or @xcite for a systematic argument ) .",
    "throughout this paper , we only consider ordinal mechanisms .    for the deterministic case , strategyproofness of one - sided matching mechanisms has been studied extensively .",
    "@xcite showed that the only group - strategyproof , ex - post efficient , reallocation - proof mechanisms are hierarchical exchanges .",
    "characterizations of strategyproof , efficient , and reallocation - consistent @xcite or consistent @xcite mechanisms are also available .",
    "the only deterministic , strategyproof , ex - post efficient , non - bossy , and neutral mechanisms are known to be serial dictatorships @xcite .",
    "furthermore , @xcite showed that all group - strategyproof , ex - post efficient mechanisms are trading cycles mechanisms .",
    "@xcite gave a characterization of strategyproofness that is similar in spirit to ours , but is restricted to deterministic social choice domains .",
    "for non - deterministic mechanisms , @xcite showed that random serial dictatorship ( @xmath13 ) is equivalent to the core from random endowments mechanism for house allocation .",
    "@xcite extended their result by showing that taking any ex - post efficient , strategyproof , non - bossy , deterministic mechanism and assigning agents to roles in the mechanism uniformly at random is equivalent to @xmath13 .",
    "however , it is still an open conjecture whether @xmath13  is the unique mechanism that is anonymous , ex - post efficient , and strategyproof .",
    "the research community has also introduced stronger efficiency concepts , such as ordinal efficiency .",
    "the original probabilistic serial ( @xmath0 ) mechanism introduced by @xcite was only defined for strict preferences .",
    "@xcite introduced an extension of the @xmath0 mechanism that allows agents to be indifferent between goods .",
    "recently , @xcite showed that the unique mechanism that is ordinally fair and non - wasteful is @xmath0 with uniform eating speeds .",
    "@xcite had already shown that @xmath0 is not strategyproof , but @xcite recently found that its nash equilibria can lead to ordinally dominated outcomes .",
    "while incentive concerns for @xmath0 may be severe for small settings , they get less problematic for larger settings : @xcite showed that for a fixed number of object types and a fixed agent , @xmath0 makes it a dominant strategy for that agent to be truthful if the number of copies of each object is sufficiently large .    while ex - post efficiency and ordinal efficiency are the most well - studied efficiency concepts for one - sided matching mechanisms , some mechanisms used in practice aim to maximize _ rank efficiency _ , which is a further refinement of ordinal efficiency @xcite .",
    "however , no rank efficient mechanism can be strategyproof in general",
    ". other popular mechanisms , like the boston mechanism @xcite , are highly manipulable but nevertheless in frequent use .",
    "@xcite found practical evidence from combinatorial course allocation , suggesting that using a non - strategyproof mechanism may lead to higher social welfare than using an ex - post efficient and strategyproof mechanism , such as @xmath13 .",
    "this challenges whether strategyproofness should be a hard constraint for mechanism designers .",
    "given that strategyproofness is such a strong restriction , many researchers have tried to relax it , using various notions of _ approximate strategyproofness_. for example , @xcite took this approach in the voting domain and quantified the incentives to manipulate ( for certain normalized utilities ) .",
    "@xcite proposed the interesting competitive equilibrium from approximately equal incomes mechanism for the domain of combinatorial assignments . for the single - object assignment domain ,",
    "this reduces to @xmath13 .",
    "finally , @xcite used a machine learning approach to design mechanisms with `` good '' incentive properties . instead of requiring strategyproofness ,",
    "they minimize the agents ex - post regret , i.e. , the utility increase an agent could gain from manipulating",
    ". however , their notion of approximate strategyproofness only applies in quasi - linear domains and does not translate to the matching domain .",
    "our axiomatic approach differs from these ideas , because instead of quantifying manipulation incentives ( i.e. , the potential utility gain from manipulation ) , we consider strategyproofness - like guarantees , which need only hold on a specified subset of the entire utility space .",
    "recently , @xcite proposed a desideratum called _ strategyproof in the large _",
    "( sp - l ) , which is applicable to the matching domain and formalizes the intuition that as the number of agents in the market gets large , the incentives for individual agents to misreport their preferences vanish in the limit . in contrast , our concepts presented in this paper apply to any problem size .    in order to compare different mechanisms by their vulnerability to manipulation",
    ", @xcite introduced a general framework .",
    "it is consistent with the measure for the degree of strategyproofness we propose in this paper .",
    "however , our concept has two advantages : it yields a parametric relaxation of strategyproofness and we show that it is computable .",
    "we discuss the connection in more detail in section [ subsec.degree_of_sp.vulnerability ] .",
    "a _ setting _ @xmath14 consists of a set @xmath15 of @xmath16 _ agents _ , a set @xmath17 of @xmath18 _ objects _ , and a vector @xmath19 of _ capacities _ , i.e. , there are @xmath20 units of object @xmath21 available .",
    "we assume that supply satisfies demand , i.e. , @xmath22 , since we can always add dummy objects .",
    "agents are endowed with _",
    "von neumann - morgenstern ( vnm ) utilities _ @xmath23 over the objects .",
    "if @xmath24 , we say that agent @xmath25 _ prefers object @xmath4 over object @xmath3 _ , which we denote by @xmath26 .",
    "we work with the standard model , which excludes indifferences , i.e. , @xmath27 implies @xmath28 .",
    "a utility function @xmath29 is _ consistent _ with _ preference ordering _",
    "@xmath30 if @xmath26 whenever @xmath24 .",
    "given a preference ordering @xmath30 , the corresponding _ type _",
    "@xmath31 is the set of all utilities that are consistent with @xmath30 , and @xmath32 is the set of all types , called the _",
    "type space_. we use types and preference orderings synonymously .",
    "an _ allocation _ is a ( possibly probabilistic ) assignment of objects to agents .",
    "it is represented by an @xmath33-matrix @xmath34 satisfying the _ fulfillment constraint _ @xmath35 , the _ capacity constraint _",
    "@xmath36 , and @xmath37 $ ] for all @xmath38 .",
    "the entries of the matrix are interpreted as probabilities , where @xmath25 gets @xmath21 with probability @xmath39 .",
    "an allocation is _ deterministic _ if @xmath40 for all @xmath41 . the birkhoff - von neumann theorem and its extensions @xcite",
    "ensure that given any allocation , we can always find a lottery over deterministic assignments that implements these marginal probabilities .",
    "finally , let @xmath42 denote the space of all allocations .",
    "a _ mechanism _ is a mapping @xmath43 that chooses an allocation based on a profile of reported types .",
    "we let @xmath44 denote the allocation that agent @xmath25 receives if it reports type @xmath45 and the other agents report @xmath46 .",
    "note that mechanisms only receive type profiles as input .",
    "thus , we consider _ ordinal _ mechanisms , where the allocation is independent of the actual vnm utilities .",
    "if @xmath25 and @xmath47 are clear from the context , we may abbreviate @xmath44 by @xmath48 .",
    "the expected utility for @xmath25 is given by the dot product @xmath49 , i.e. , @xmath50 for _ strategyproof _ mechanisms , reporting truthfully maximizes agents expected utility :    [ def : sp ] a mechanism @xmath51 is _ strategyproof _ if for any agent @xmath52 , any type profile @xmath53 , any misreport @xmath54 , and any utility @xmath55 we have @xmath56    our model encompasses classical one - sided matching problems , such as house allocation and school choice markets , where only one side of the market has preferences .",
    "it is also straightforward to accommodate outside options .",
    "priorities over the agents can be included implicitly in the mechanism .",
    "we now define our axioms . a type @xmath57 that differs from another type @xmath58 by just a swap of two adjacent objects in the corresponding preference orderings",
    "is said to be in the _ neighborhood _ @xmath59 of @xmath58 .",
    "[ def : neighborhood ] the _ neighborhood _ of a type @xmath58 is the set @xmath59 of all types @xmath57 such that there exists @xmath60 with @xmath61    the _ upper contour set _ of an object @xmath4 with respect to some type @xmath58 is the set of objects that are strictly preferred to @xmath4 by an agent of type @xmath58 , and the _ lower contour set _ are all the objects that the agent likes strictly less than @xmath4 .",
    "formally :    [ def : contour_set ] for a type @xmath62 , the _ upper contour set _ @xmath63 and _ lower contour set _",
    "@xmath64 are given by @xmath65    a swap of two adjacent objects is a basic manipulation .",
    "our axioms limit the way in which a mechanism can change the allocation under this basic manipulation .",
    "this makes the axioms intuitive and simple .",
    "[ ax : sc ] a mechanism @xmath51 is _ swap monotonic _",
    "if for any agent @xmath66 , any type profile @xmath67 , and any type @xmath68 ( i.e. , in the neighborhood of @xmath45 ) with @xmath69 under @xmath45 and @xmath70 under @xmath71 , one of the following holds :    1 .",
    "@xmath25 s allocation is unaffected by the swap , i.e. , @xmath72 , or 2 .",
    "@xmath25 s allocation for @xmath73 strictly decreases and its allocation for @xmath74 strictly increases , i.e. , @xmath75    swap monotonicity is an intuitive axiom , because it simply requires the mechanism to react to the swap in a _",
    "direct _ and _ responsive _ way .",
    "the swap reveals information about the relative ranking of @xmath73 and @xmath74 for the agent ; thus , if anything changes about the allocation for that agent , the objects @xmath73 and @xmath74 must be affected directly , or else no other object may be affected .",
    "in addition , the mechanism must respond to the agent s preferences by allocating more of the object the agent claims to like more and less of the object the agent claims to like less .",
    "consider a mechanism that gives you chocolate ice cream if you ask for vanilla , and gives you vanilla if you ask for chocolate .",
    "this mechanism is obviously extremely manipulable , and swap monotonicity prevents this kind of manipulability .",
    "nevertheless , even swap monotonic mechanisms may be manipulable in a first order - stochastic dominance sense .",
    "however , the manipulations must involve changes of the allocation of other objects besides @xmath73 and @xmath74 as well .",
    "example [ ex : sc_not_wi_manip ] presents such a mechanism .",
    "[ ex : sc_not_wi_manip ] consider a mechanism where reporting @xmath76 leads to an allocation of @xmath77 of @xmath78 , respectively , and reporting @xmath79 leads to an allocation of @xmath80 .",
    "this mechanism is swap monotonic , but the latter allocation first order - stochastically dominates the former for @xmath45 .",
    "thus , even under swap monotonicity , manipulations by some agent may produce first order - stochastically dominant outcomes for that agent .    to ensure that this does not happen , we need an additional axiom .    [",
    "ax : wi ] a mechanism @xmath51 is _ upper invariant _ if for any agent @xmath66 , any type profile @xmath67 , and any type @xmath68 with @xmath69 under @xmath45 and @xmath81 under @xmath71 , @xmath25 s allocation for the upper contour set @xmath82 is unaffected by the swap , i.e. , @xmath83 for all @xmath84 .    intuitively , under upper invariance , an agent can not influence the allocation of one of its better choices by swapping two less preferred objects .",
    "upper invariance was introduced by @xcite as one of the central axioms to characterize the probabilistic serial mechanism .",
    "if a null object is present and the mechanism is individually rational , then upper invariance is equivalent to _",
    "truncation robustness_. truncation robustness is a type of robustness to manipulation that is important in theory and application : it prevents that by bringing the null object up in its report , an agent can increase its chances of being allocated a more preferred object .",
    "many mechanisms from the literature satisfy upper invariance , such as random serial dictatorship , probabilistic serial , the boston mechanism , and student - proposing deferred acceptance .",
    "[ ax : li ] a mechanism @xmath51 is _ lower invariant _ if for any agent @xmath66 , any type profile @xmath67 , and any type @xmath68 with @xmath69 under @xmath45 and @xmath81 under @xmath71 , @xmath25 s allocation for the lower contour set @xmath85 is unaffected by the swap , i.e. , @xmath86 for all @xmath87 .",
    "lower invariance complements upper invariance : it requires that an agent can not influence the allocation for _ less _ preferred objects by swapping two more preferred objects .",
    "lower invariance has a subtle effect on incentives : if agents were endowed with upward - lexicographic preferences @xcite , mechanisms that are not lower invariant will be manipulable for these agents , even if they are swap monotonic and upper invariant .",
    "arguably , lower invariance is the least intuitive axiom , but it turns out to be the missing link to characterize strategyproof mechanisms . in section [ sec.psp ] , we will drop lower invariance for the characterization of partially strategyproof mechanisms .",
    "note that our axioms describe the behavior of the mechanism from each agent s perspective individually .",
    "this is sufficient , since we only consider strategyproofness - like concepts , not best - responses to the strategies of other agents .",
    "in this section , we present our first main result , an axiomatic characterization of strategyproof one - sided matching mechanisms .",
    "[ thm : characteriaztion_sp ] a mechanism @xmath51 is strategyproof if and only if it is swap monotonic , upper invariant , and lower invariant .    assuming strategyproofness , consider a swap of two adjacent objects in the report of some agent . towards contradiction , assume that @xmath51 violates either upper or lower invariance , and construct a utility function such that the agent finds a beneficial manipulation to @xmath51 .",
    "the key idea is to make the agent almost indifferent between the two objects that are swapped , such that utility gains on other objects can be sufficiently high to make the manipulation attractive . with upper and lower invariance",
    "established , swap monotonicity follows as well .",
    "if @xmath51 satisfies the axioms , we show that no swap of two adjacent objects can ever be a beneficial manipulation . using a result from @xcite ,",
    "this _ local _ strategyproofness can be extended to _",
    "global _ strategyproofness .",
    "theorem [ thm : characteriaztion_sp ] illustrates why strategyproofness is such a strong requirement .",
    "if an agent swaps two adjacent objects in its reported preference order , the only thing that a strategyproof mechanism can do ( if anything ) is to increase the allocation for the object that is brought forward and decrease the allocation for the object that is brought back by the same amount .",
    "in the previous section , we have seen that swap monotonicity , upper invariance , and lower invariance are necessary and sufficient conditions for strategyproofness .",
    "example [ ex : sc_not_wi_manip ] has shown that swap monotonicity and upper invariance are essential to guarantee at least truncation robustness and the absence of manipulations in a first order - stochastic dominance sense .",
    "lower invariance is the least intuitive and the least important of the axioms for good incentives .",
    "obviously , mechanisms that violate lower invariance are not strategyproof .",
    "however , we will show that they are still strategyproof for a large subset of the utility functions .",
    "this will lead to a relaxed notion of strategyproofness , which we call _ partial strategyproofness _ : we will show that swap monotonicity and upper invariance are equivalent to partial strategyproofness on the subset of utility functions with _ uniformly relatively bounded indifference_. example [ ex : ps_rel_manip ] provides the intuition for this new concept .",
    "[ ex : ps_rel_manip ] consider the probabilistic serial mechanism in a setting with 3 agents and 3 objects with unit capacity .",
    "the agents have types @xmath88 and agents @xmath89 and @xmath90 report truthfully . when reporting @xmath91 truthfully , agent 1 receives @xmath92 with probabilities @xmath93 , respectively .",
    "if it reports @xmath94 , it will receive allocation @xmath95 instead .",
    "suppose agent 1 has utility @xmath96 from object @xmath97 .",
    "whether or not the misreport @xmath98 increases agent 1 s expected utility depends on its relative value for @xmath4 over @xmath3 : if @xmath99 is close to @xmath100 , then agent 1 will find it beneficial to report @xmath98 .",
    "if @xmath99 is significantly larger than @xmath100 , then agent 1 will want to report truthfully . precisely , the manipulation is not beneficial if @xmath101 , i.e. , if @xmath102 .",
    "we observe that the incentive to manipulate hinges on the `` degree of indifference '' agent 1 exhibits between objects @xmath4 and @xmath3 : the closer to indifference the agent is , the higher the incentive to misreport .      generalizing the idea from example [ ex : ps_rel_manip ]",
    ", we introduce the concept of _ uniformly relatively bounded indifference _ : loosely speaking , an agent must value any object at least a factor @xmath7 less than the next better object ( after appropriate normalization ) .",
    "[ def : urbi ] a utility function @xmath103 satisfies _ uniformly relatively bounded indifference with respect to bound @xmath104 $ ] ( @xmath6 ) _ if for any objects @xmath105 with @xmath106 @xmath107    r0.37",
    "if @xmath108 , uniformly relatively bounded indifference has an intuitive interpretation , because ( [ eq : urbi_constraint ] ) simplifies to @xmath109 : given a choice between two objects @xmath4 and @xmath3 , the agents must value @xmath3 at least a factor @xmath7 less than @xmath4 ( @xmath110 in example [ ex : ps_rel_manip ] ) .    for a geometric interpretation of @xmath6 ,",
    "consider figure [ fig : geom_urbi ] : the condition means that the agent s utility function , represented by the vector @xmath103 , can not be arbitrarily close to the indifference hyperplane @xmath111 between the types @xmath58 and @xmath57 , i.e. , it must lie within the shaded area of type @xmath58 , and @xmath112 would violate @xmath6 . for convenience",
    "we introduce the following convention : for a given setting , we denote by @xmath6  the set of all utility functions that satisfy uniformly relatively bounded indifference with respect to @xmath7 for the number of objects defined by the setting .    [ rem : geom_share_intuition ] to gain some intuition about the `` size '' of the set @xmath6 , consider a setting with @xmath113 objects .",
    "suppose @xmath114 and the utilities for the first and second choice are determined by drawing a vector uniformly at random from @xmath115 ( i.e. , the open unit square excluding the indifference hyperplane ) .",
    "then the share of utilities that satisfy @xmath6  is @xmath7 , e.g. , if @xmath116 , the probability of drawing a utility function from @xmath117 is @xmath118 . in figure",
    "[ fig : geom_urbi ] , this corresponds to the area of the shaded triangle over the area of the larger triangle formed by the @xmath119-axis , the diagonal , and the vertical dashed line on the right .",
    "we now define a relaxed notion of strategyproofness . for some set @xmath120 of utility functions , a mechanism",
    "@xmath51 is _ @xmath120-partially strategyproof _ if for agents with utility functions in @xmath120 it is a dominant strategy to report truthfully . in the following",
    "we will focus exclusively on @xmath7-partial strategyproofness .",
    "therefore , we formally define :    [ def : psp ] given a setting @xmath14 and a bound @xmath104 $ ] , mechanism @xmath51 is _ @xmath7-partially strategyproof in the setting @xmath14 _ if for any agent @xmath52 , any type profile @xmath67 , any misreport @xmath121 , and any utility @xmath122 , we have @xmath123    when the setting is clear from the context , we simply write _ @xmath7-partially strategyproof _ or _ @xmath7-psp _ without explicitly stating the setting . in section [ subsec.psp.result ] , we will present our second main result , a characterization of @xmath7-psp mechanisms by the axioms swap monotonicity and upper invariance .",
    "but first we explain the relation of @xmath7-psp to the established concepts strategyproofness and weak strategyproofness .",
    "obviously , strategyproofness implies @xmath7-partial strategyproofness for any bound @xmath104 $ ] and any setting : for strategyproofness the incentive constraint ( [ eq : incentive_constraint_urbi_psp ] ) must hold for _ all _ possible utility functions .",
    "in contrast , @xmath7-partial strategyproofness requires ( [ eq : incentive_constraint_urbi_psp ] ) to hold only for _ a subset _ of the utility functions , namely @xmath6 .",
    "@xmath7-partial strategyproofness is equivalent to requiring that @xmath51 is strategyproof for the restricted domain where agents utility functions are uniformly relatively bounded away from indifference by a factor @xmath7 .",
    "it inherits the strategic simplicity from strategyproofness , but with a caveat : a market designer can only give the honest advice that the agent need not deliberate about other agents preferences and reports and that reporting truthfully is a dominant strategy _ if _ the agent s utility function lies within @xmath6 .",
    "but this advice is valid , even if other agents may have utilities outside @xmath6 .",
    "weak strategyproofness is a relaxation of strategyproofness .",
    "it was employed by @xcite to describe the incentive properties of the probabilistic serial mechanism . under weakly strategyproof mechanisms",
    ", agents can not attain a strictly first order - stochastically dominant outcome by manipulation .",
    "[ def : wsp ] a mechanism is _ weakly strategyproof _ if for any type profile @xmath124 , the outcome from truthful reporting is never strictly first order - stochastically dominated by the outcome from any misreport for agent @xmath25 .",
    "weak strategyproofness is equivalent to requiring that for a given type profile @xmath125 and a potential misreport @xmath71 , there exists a utility @xmath55 such that @xmath126 .",
    "this turns out to be an extremely weak requirement : in particular , @xmath29 can depend on @xmath71 . the mechanism might still offer a manipulation to the agent with utility @xmath29 .",
    "the only guarantee given is that reporting @xmath71 will not increase its expected utility . to see",
    "just how weak the requirement is , consider example [ ex : ivan ] in appendix [ app.ex_ivan ] : even though the mechanism is weakly strategyproof , it is possible that an agent of a given type will find it beneficial to misreport , independent of its utility function . in contrast , @xmath7-partial strategyproofness provides an incentive guarantee for all agents with utilities in @xmath6 , and is therefore a strictly stronger condition , i.e. , @xmath7-partial strategyproofness implies weak strategyproofness .      in this section ,",
    "we show that dropping lower invariance as an axiom , but requiring swap monotonicity and upper invariance , leads to @xmath7-partially strategyproof mechanisms .",
    "[ thm : characterization_psp ] given a setting @xmath14 , a mechanism @xmath51 is @xmath7-partially strategyproof for some @xmath127 $ ] if and only if @xmath51 is swap monotonic and upper invariant .",
    "suppose , an agent has true type @xmath128 and is considering a misreport @xmath129 , where only the positions of objects ranked below @xmath130 are changed . we first show that under swap monotonicity and upper invariance , it suffices to consider misreports @xmath57 for which the allocation of @xmath131 strictly decreases .",
    "the key insight comes from considering certain chains of swaps and their impact on the allocation ( _ canonical transitions _ in lemma [ lem : b_decrease ] ) .",
    "then we show that for sufficiently small @xmath5 $ ] , the decrease in expected utility that corresponds to the decrease in the allocation of @xmath131 is sufficient to deter manipulation by any agent whose utility function satisfies @xmath6 , even though its allocation for less preferred objects @xmath132 may improve . finally , we show that a strictly positive @xmath7 can be chosen uniformly for all type profiles and misreports .",
    "thus , the bound @xmath7 depends only on the mechanism and the setting .    to see the other direction , we assume towards contradiction that the mechanism is not upper invariant . for any @xmath127",
    "$ ] we construct a utility function that satisfies @xmath6 , but for which the mechanism would be manipulable . the key idea is to make the agent almost indifferent between the two objects that are swapped , so that the value from attaining more of a better choice is sufficient to yield a beneficial manipulation . finally , using upper invariance",
    ", swap monotonicity follows in a similar fashion .",
    "theorem [ thm : characterization_psp ] answers the first question raised in the introduction , because giving strategic advice to the agents is straightforward for @xmath7-partially strategyproof mechanisms : for any agent whose values for different objects differ by at least a factor @xmath7 , it is a dominant strategy to report truthfully .",
    "[ rem : weldef ] for @xmath133 we have @xmath134 by construction . therefore , a mechanism that is @xmath135-partially strategyproof will also be @xmath7-partially strategyproof . furthermore , since the incentive constraint ( [ eq : incentive_constraint_urbi_psp ] ) is a weak inequality , the set of utilities for which a mechanism is partially strategyproof is topologically closed .",
    "thus , there exists some maximal value @xmath136 $ ] , for which the mechanism is @xmath137-partially strategyproof , but it is not @xmath7-partially strategyproof for any @xmath138 .",
    "theorem [ thm : characterization_psp ] says that a mechanism @xmath51 is swap monotonic and upper invariant if and only if it is @xmath7-partially strategyproof for _ some _ bound @xmath7 . despite this equivalence ,",
    "this does not imply that the set of utility functions on which @xmath51 is partially strategyproof is _ exactly equal _ to the set @xmath6 .",
    "example [ ex : non_urbi_psp ] shows that we can not hope for an exact equality : for some mechanism , the set of utilities where a mechanism is partially strategyproof may be strictly larger than any set @xmath6  contained within .",
    "however , in theorem [ thm : maximality ] we will show that the @xmath6  domain restriction is maximal : consider a mechanism @xmath51 that is @xmath7-partially strategyproof for some bound @xmath10 , and hence swap monotonic and upper invariant .",
    "_ maximality _ by theorem [ thm : maximality ] means that , unless we are given additional structural information about @xmath51 , @xmath6  is in fact the largest set of utilities for which partial strategyproofness can be guaranteed .",
    "[ ex : non_urbi_psp ] consider a setting with @xmath139 agents and @xmath139 objects in unit capacity . in this setting ,",
    "the adaptive boston mechanism @xcite is @xmath7-partially strategyproof for any @xmath140 , but not @xmath7-partially strategyproof for any @xmath141 .",
    "however , an agent with utility function @xmath142 will not find a beneficial manipulation for any report @xmath143 from the other agents , i.e. , @xmath144  is @xmath145-partially strategyproof in this setting .",
    "but @xmath146 , since @xmath147 to verify this , we can compute @xmath148 , e.g. , using algorithm [ alg : compute ] in section [ sec.computation ] , and verify for any possible type profile @xmath149 and any misreport @xmath150 that the agent of type @xmath58 with utility @xmath11 will not find reporting @xmath57 beneficial .",
    "we now show maximality of the @xmath6  domain restriction .",
    "[ thm : maximality ] for any setting @xmath14 with @xmath9 , any bound @xmath10 , and any utility function @xmath151 that violates @xmath6 , there exists a mechanism @xmath12 such that    1 .",
    "@xmath12 is @xmath7-partially strategyproof , but 2 .",
    "there exists a type @xmath152 and reports @xmath153 such that @xmath154    if @xmath11 violates @xmath6 , there must be a pair of objects @xmath105 such that @xmath155 we construct the mechanism @xmath12 explicitly , considering a particular agent @xmath25 .",
    "@xmath12 allocates a constant vector to @xmath25 , except when @xmath25 reports type @xmath57 with @xmath156 . in that case @xmath12 allocates less of @xmath4 , more of @xmath3 , and less of @xmath25 s reported last choice ( say , @xmath97 ) to @xmath25 .",
    "then @xmath12 is swap monotonic and upper invariant .",
    "the re - allocation between @xmath4 , @xmath3 , and @xmath97 must be constructed in such a way that @xmath25 would want to manipulate if its utility is @xmath11 , but would not want to manipulate if its utility satisfied @xmath6 .",
    "we show that this is possible .",
    "note that if some additional constraints are imposed on the space of possible mechanisms , the mechanism @xmath12 constructed in the proof of theorem [ thm : maximality ] may no longer be feasible , such that the counterexample fails .",
    "however , as long as we know nothing more about the mechanism besides @xmath7-partial strategyproofness , we can not rule out the possibility that an agent with some utility function outside @xmath6  may want to manipulate .",
    "the following corollary makes this argument precise .",
    "[ cor : set_urbi ] for any setting @xmath14 with @xmath9 , we have @xmath157    this means that the when considering the set of @xmath7-partially strategyproof mechanisms , the set of utilities for which they are _ all _ partially strategyproof is _ exactly equal _ to @xmath6 .",
    "thus , there is no larger domain restriction for which all these mechanisms will also be strategyproof .",
    "recall theorem [ thm : characterization_psp ] , which shows that a mechanism is @xmath7-partially strategyproof if and only if it is swap monotonic and upper invariant .",
    "this leads to a new , intuitive measure for the degree of strategyproofness of swap monotonic , upper invariant mechanisms : the largest possible relative indifference bound @xmath7 for which the mechanism is still @xmath7-partially strategyproof .",
    "[ def : parameter_rho ] given a setting @xmath14 and a mechanism @xmath51 that is upper invariant and swap monotonic , define the _ degree of strategyproofness ( dosp ) _ of @xmath51 by @xmath158 | f \\text { is } r\\text{-psp in the setting } ( n , m,\\mathbf{q } ) \\right\\}. \\label{eq : def_rho}\\ ] ]      by remark [ rem : weldef ] , @xmath159 is well - defined , and by theorem [ thm : characterization_psp ] it is strictly positive .",
    "maximality of the @xmath6  domain restriction ( corollary [ cor : set_urbi ] ) implies that when measuring the degree of strategyproofness of swap monotonic and upper invariant mechanisms using @xmath159 , no utility functions are omitted for which a guarantee could also be given .",
    "dosp also allows for the comparison of two mechanisms : @xmath160 means that @xmath51 is partially strategyproof on a larger @xmath161 domain restriction than @xmath162 . and",
    "without any further information on the mechanisms , by theorem [ thm : maximality ] , this comparison is the best that can be made for the sets of utility functions for which the mechanisms are partially strategyproof .",
    "[ rem : geom_share_intuition_cont ] from a quantitative perspective one might ask for `` how many more '' utility functions @xmath51 is partially strategyproof compared to @xmath162 . recall remark [ rem : geom_share_intuition ] , where we considered @xmath117 in a setting with 3 objects , @xmath163 , and the remaining utilities for the first and second choice were chosen uniformly at random for the unit square .",
    "suppose that @xmath164 and @xmath165 .",
    "given this particular measure , the set @xmath166 is twice the `` size '' of @xmath117 , i.e. , the guarantee for @xmath51 extends over twice as many utility functions as the guarantee for @xmath162 .",
    "thus , in some sense , @xmath51 is `` twice as strategyproof '' as @xmath162 .",
    "this answers the second question raised in the introduction as to how the degree of strategyproofness of a manipulable mechanism can be measured .",
    "@xcite proposed an interesting method for comparing mechanisms by their vulnerability to manipulation .",
    "for the expected utility case their comparison states that @xmath162 is _ as intensely and strongly manipulable ( ism ) as @xmath51 _ if whenever an agent with utility @xmath103 finds a beneficial manipulation to @xmath51 , the same agent in the same situation finds a manipulation for @xmath162 that yields a weakly greater increase in expected utility .",
    "ism and dosp are _ consistent _ in the following sense :    [ prop : dosp_ism_consistent ] for any setting @xmath167 ) ,    1 .",
    "[ item : ism_dosp ] if @xmath162 is as intensely and strongly manipulable as @xmath51 , then @xmath168 .",
    "[ item : dosp_ism ] if @xmath160 and @xmath51 and @xmath162 are comparable by ism , then @xmath162 is as intensely and strongly manipulable as @xmath51 .",
    "the proof is given in appendix [ app.prop_consistent ] . despite this consistency , neither concept is always better at _ strictly _ differentiating mechanisms : ism may be inconclusive when dosp yields a strict winner , but dosp may also indicate indifference ( i.e. , @xmath169 ) when one of the mechanisms is in fact intensely and strongly _ more _ manipulable .",
    "an important difference between ism and dosp is that ism considers each type profile separately , while the @xmath7-partial strategyproofness constraint must hold uniformly for _ all _ type profiles .",
    "thus , ism yields a best response notion while dosp yields a dominant strategy notion of incentives .",
    "however , dosp has two important advantages .",
    "first , @xcite do not present a method to perform the ism comparison algorithmically , and the definition is such a method is not straightforward . in contrast , @xmath170 is computable , as we will show in section [ sec.computation ] .",
    "second , and more importantly , dosp is a parametric measure while ism is not .",
    "a mechanism designer could easily express a minimal acceptable degree of strategyproofness and then consider only mechanisms satisfying this constraint , while this is not possible using ism .",
    "* input * : setting @xmath14 , mechanism @xmath51 , inverse bound @xmath171 + * variables * : agent @xmath25 , type profile @xmath172 , type @xmath71 , vector @xmath173 , polynomial @xmath119 , counter @xmath174 , choice function @xmath175 + [ alg : verify ]    we now present an algorithm to determine whether a mechanism is @xmath7-partially strategyproof for given @xmath7 . an algorithm to compute @xmath159 , i.e. , the degree of strategyproofness , can also be derived from this procedure .",
    "note that our main result is the _ computability _ of @xmath7-partial strategyproofness , _ not _ the development of _ efficient _ algorithms .",
    "yet , we will briefly discuss the complexity of the algorithms and point out opportunities for improvement .",
    "we first develop an equivalent condition for @xmath7-partial strategyproofness that does not involve uncountably many utility functions . to simplify notation",
    ", we mostly omit the arguments @xmath176 , and @xmath71 in the formulation of proposition [ prop : verify_urbi ] , even though constraint ( [ eq : poly_constraint ] ) is required to hold for any possible combination of these .",
    "[ prop : verify_urbi ] given a setting @xmath14 and a mechanism @xmath51 , for any agent @xmath52 , any type profile @xmath177 , any misreport @xmath178 , and    1 .   for any object @xmath179",
    "let @xmath180 be the change in the allocation of @xmath21 to @xmath25 as @xmath25 changes its report between @xmath45 and @xmath71 while the other agents report @xmath47 , and 2 .   for @xmath60 ,",
    "define polynomials ( in @xmath181 ) recursively by @xmath182 and @xmath183 , where @xmath184 is the @xmath174th choice of an agent of type @xmath45",
    ".    then @xmath51 is @xmath7-partially strategyproof if and only if for all agents @xmath52 , type profiles @xmath185 , misreports @xmath178 , ranks @xmath186 , and @xmath171 we have @xmath187    to see that @xmath7-partial strategyproofness implies ( [ eq : poly_constraint ] ) , assume towards contradiction that ( [ eq : poly_constraint ] ) is violated for some set of arguments @xmath188 , and @xmath189 .",
    "consider a utility function with relative utility differences exactly equal to @xmath7 , except @xmath190 with @xmath191 .",
    "this utility function satisfies @xmath6 .",
    "however , exploiting the violation of ( [ eq : poly_constraint ] ) , an agent with this utility will want to manipulate the mechanism if @xmath192 is chose sufficiently small .",
    "for the other direction , consider an agent with any utility function in @xmath6 .",
    "using horner s method , we decompose the agent s incentive .",
    "if ( [ eq : poly_constraint ] ) holds , this incentive is positive , i.e , any agent with that utility function will not want to misreport .",
    "* input * : setting @xmath14 , mechanism @xmath51 ( upper invariant , swap monotonic ) + * variables * : agent @xmath25 , type profile @xmath172 , type @xmath71 , vector @xmath173 , reals @xmath193 , polynomial @xmath119 , counter @xmath174 , choice function @xmath175 + [ alg : compute ]    proposition [ prop : verify_urbi ] yields a method for verifying or falsifying that a given mechanism @xmath51 is @xmath7-partially strategyproof in a given setting .",
    "algorithm [ alg : verify ] implements this method .",
    "it iterates through all agents , type profiles , and possible misreports . for each combination it constructs the vector @xmath173 of changes in the allocation and checks whether constraint ( [ eq : poly_constraint ] ) is violated .",
    "if this is ever the case , @xmath51 is not @xmath7-partially strategyproof by proposition [ prop : verify_urbi ] . otherwise , if the iterations finish without a violation , @xmath51 is @xmath7-partially strategyproof .",
    "we can also derive a method to compute the degree of strategyproofness , @xmath159 .",
    "[ cor : compute ] the degree of strategyproofness is given by @xmath194 \\left| \\begin{array}{c }   \\forall i \\in n , ( t_i , t_{-i } ) \\in t^n , t_i ' \\in t , k \\in\\{1,\\ldots , m-1\\ } : \\\\ x_k\\left(\\frac{1}{r},i , t_i , t_i',t_{-i}\\right ) \\geq 0\\end{array } \\right.\\right\\}. \\label{eq : compute_rho_cor}\\ ] ]    algorithm [ alg : compute ] implements this calculation .",
    "initially , the guess for @xmath137 is optimistically set to 1 . like algorithm [ alg :",
    "verify ] , the algorithm then iterates through all combinations of agents , type profiles , and possible misreports and finds the largest root @xmath195 of the polynomials @xmath196 for each combination . if at any iteration the current @xmath137 is higher than the inverse of the largest root @xmath197 , @xmath137 is updated to @xmath197 .",
    "thus , at termination , @xmath137 is equal to the largest bound for which the constraints ( [ eq : poly_constraint ] ) are all satisfied .",
    "the computational complexity of algorithm [ alg : verify ] is @xmath198 , i.e. , exponential in the number of objects and agents .",
    "@xmath199 is the computational complexity for determining a single outcome of the mechanism .",
    "computing @xmath159 using algorithm [ alg : compute ] has computational complexity @xmath200 , where @xmath201 is the complexity of finding the largest root of the polynomial .",
    "this root can be found in polynomial time via the lll - algorithm @xcite .      in the most general case ( without any additional structure ) , a mechanism is specified in terms of a set of allocation matrices @xmath202 .",
    "this set will contain @xmath203 matrices of dimension @xmath204 .",
    "consequently , the size of the problem is @xmath205 in terms of @xmath206 , algorithm [ alg : verify ] has complexity @xmath207{s}\\right)$ ] .",
    "thus , for the general case , there is not much room for improvement , since any correct and complete algorithm will have complexity @xmath208 ( we must consider all type profiles ) .",
    "if additional structure is available , faster algorithms may be possible : for anonymous mechanisms , the number of type profiles to consider reduces from @xmath203 to @xmath209 .",
    "this can be further reduced to @xmath210 if the mechanism is neutral as well .",
    "these reductions apply to both algorithms . of course",
    ", even with these reductions , the computational effort to run algorithms [ alg : verify ] and [ alg : compute ] is prohibitively high for large settings .",
    "however , it is likely that more efficient algorithms exist for mechanisms with additional restrictions , and bounds may be derived analytically for interesting mechanisms , such as @xmath0 . having shown computability , we leave questions regarding the design of efficient algorithms for specific mechanisms to future research .",
    "we now apply our new @xmath7-partial strategyproofness concept to a number of popular and new mechanisms .",
    "table [ tb : psp_known_mechanisms ] provides an overview how the different mechanisms fare on swap monotonicity , upper invariance , and lower invariance , and consequently on strategyproofness and @xmath7-partial strategyproofness .",
    ".comparison of mechanisms by axioms , strategyproofness , and @xmath7-partial strategyproofness . [ cols=\"^,^,^,^,^,^ \" , ]      random serial dictatorship is strategyproof ( see @xcite ) .",
    "thus , it satisfies all three axioms and is @xmath211-partially strategyproof for any setting .",
    "upper invariance of @xmath0  follows from theorem 2 of @xcite .",
    "proposition [ prop : ps_sc ] yields swap monotonicity .",
    "[ prop : ps_sc ] @xmath0  is swap monotonic .",
    "we consider the times at which objects are exhausted under the simultaneous eating algorithm .",
    "suppose an agent swaps two objects , e.g. , from @xmath212 to @xmath156 .",
    "if anything changes about that agent s allocation , the agent will now spend _ strictly more _",
    "time consuming @xmath3 . by the time @xmath3",
    "is exhausted , there will be _ strictly less of @xmath4 available _ or there will be _ strictly more competition _ at @xmath4 ( relative to reporting @xmath1 ) .    since ps is manipulable ( see example [ ex : ps_rel_manip ] )",
    ", it is not strategyproof , and hence by theorem [ thm : characteriaztion_sp ] it can not be lower invariant in general .",
    "however , since it is swap monotonic and upper invariant , it is @xmath7-partially strategyproof by theorem [ thm : characterization_psp ] .",
    "this is a much stronger property than weak strategyproofness ( from @xcite ) .",
    "this generalizes earlier findings by @xcite , who shows that probabilistic serial is _",
    "convex strategyproof_.",
    "@xcite have shown that for a fixed number of objects @xmath18 and an agent @xmath25 with a fixed utility function over these objects , @xmath25 will not want to misreport if there are sufficiently many copies of each object .",
    "note that this does not mean that the mechanism becomes strategyproof in some finite setting .",
    "however , we conjecture that the result of @xcite can be strengthened in the following sense : for @xmath18 constant and @xmath213 : @xmath214 .",
    "numerical results presented in @xcite support this hypothesis , but we leave a proof of this hypothesis to future research .",
    "we consider the boston mechanism with single tie - breaking and no priorities @xcite . intuitively , this mechanism is upper invariant , because the object to which an agent applies in the @xmath174th round has no effect on the applications or allocations in previous rounds ( see @xcite for a formal proof ) .",
    "the boston mechanism is , however , neither swap monotonic nor lower invariant , as example [ ex : bm_not_sc_li ] shows .",
    "[ ex : bm_not_sc_li ] consider the setting with @xmath215 , @xmath216 , unit capacities , and the type profile @xmath217 agent 1 s allocation is @xmath218 for the objects @xmath4 through @xmath219 , respectively .",
    "if agent 1 swaps @xmath3 and @xmath97 in its report , the allocation will be @xmath220 .",
    "first , note that the allocation for @xmath3 has not changed , but the overall allocation has , which violates swap monotonicity .",
    "second , the allocation of @xmath219 has changed , even though it is in the lower contour set of @xmath97 , which violates lower invariance .",
    "the boston mechanism is `` nave '' , since it lets agents apply at their second , third , etc .",
    "choices , even if these were already exhausted in previous rounds , such that agents `` waste '' rounds .",
    "therefore , we will refer to it as the _ nave _ boston mechanism _ ( nbm)_.      obvious manipulation strategies arise from this nave approach of @xmath221 : an agent who knows that its second choice will already be exhausted in the first round is better off ranking its third choice second , because this will increase its chances at all remaining objects in a first order - stochastic dominance sense without forgoing any chances at its second choice object .",
    "if instead , the agent automatically `` skipped '' exhausted objects in the application process , this manipulation strategy would no longer be effective .",
    "in @xcite we have shown that such an _ adaptive _ boston mechanism ( @xmath144 ) is swap monotonic and upper invariant , and thus @xmath7-partially strategyproof .",
    "@xcite used simulations to study how unsophisticated ( truthful ) agents are disadvantaged under @xmath221  and finds evidence that such an adaptive correction may be attractive .",
    "indeed , in @xcite we have also shown that @xmath144 retains imperfect rank dominance over @xmath13 in the limit .",
    "_ imperfectly rank dominates _ another mechanism",
    "@xmath51 if the resulting allocation from @xmath162 is never rank dominated , but sometimes rank dominates the allocation from @xmath51 .",
    "`` limit '' here means for @xmath222 . ]",
    "this makes @xmath144 an interesting alternative to the widely used @xmath221 , as it is less manipulable than @xmath221 , yet in a sense more efficient than @xmath13 . finally ,",
    "since @xmath144 is not strategyproof , it can not be lower invariant , which completes the row in table [ tb : psp_known_mechanisms ] .",
    "@xcite introduced rank efficiency , a strict refinement of ex - post and ordinal efficiency .",
    "rank efficient mechanisms are often considered in practical applications . however , no rank efficient mechanism is even weakly strategyproof ( theorem 3 in @xcite )",
    ". furthermore , any rank efficient mechanism will be neither swap monotonic , nor upper invariant , nor lower invariant ( examples [ ex : rv_not_wi_sc ] and [ ex : rv_not_li ] in appendix [ app.ex_rv ] ) , and thus not @xmath7-partially strategyproof for any bound @xmath127 $ ] .",
    "this suggests that despite the attractive efficiency properties , manipulability must be a serious concern when considering rank efficient mechanisms .      in @xcite",
    ", we show how hybrid mechanisms can facilitate the trade - off between strategyproofness and efficiency for one - sided matching mechanisms .",
    "the main idea is to consider convex combinations of two mechanisms , one of which has good incentives while the other brings good efficiency properties . under certain technical assumptions ,",
    "these hybrid mechanisms are @xmath7-partially strategyproof , but can also improve efficiency beyond the ex - post efficiency of @xmath13 . furthermore , the trade - off is scalable in the sense that the mechanism designer can accept a lower degree of strategyproofness in exchange for more efficiency .",
    "the construction of hybrids can be shown to work with @xmath13  and @xmath0  as well as with @xmath13  and @xmath144 .",
    "note that prior to the introduction of @xmath7-partial strategyproofness , no measure existed to evaluate the degree of strategyproofness of such hybrid mechanisms .",
    "in this paper , we have presented a new axiomatic approach to characterizing and relaxing strategyproofness of one - sided matching mechanisms in the vnm utility domain .",
    "first , we have shown that a mechanism is strategyproof if and only if it satisfies _ swap monotonicity _ , _ upper invariance _ , and",
    "_ lower invariance_. this illustrates why strategyproofness is such a strong requirement : if an agent swaps two adjacent objects , e.g. , from @xmath212 to @xmath2 , in its reported preference order , the only thing that a strategyproof mechanism can do ( if anything ) is to increase the allocation of @xmath3 and decrease the allocation of @xmath4 by the same amount .",
    "second , we have shown that by dropping the least intuitive axiom , lower invariance , the class of @xmath7-partially strategyproof mechanisms emerges .",
    "these mechanisms are strategyproof for agents with sufficiently different values for different objects .",
    "we have also shown that the @xmath6  domain restriction is maximal .",
    "this implies that @xmath6  is the largest set of utility functions for which partial strategyproofness can be guaranteed without knowledge of further properties of the mechanism .",
    "finally , the characterization via uniformly relatively bounded utilities has allowed us to define a measure for the degree of strategyproofness of a mechanism .",
    "this measure is simple and consistent with the method of comparing mechanisms by their vulnerability to manipulation recently proposed by @xcite .",
    "furthermore , this measure is parametric , and we have shown that it is computable .    the @xmath7-partial strategyproofness concept can be applied to gain a better understanding of the incentives of many popular , non - strategyproof mechanisms .",
    "we have shown that the probabilistic serial mechanism is @xmath7-partially strategyproof , which is a significantly better description of the incentive properties than weak strategyproofness ( from @xcite ) and gives insights into the incentives of ps for settings of any size ( in contrast to large settings , as in @xcite ) . while the boston mechanism in its nave form is not even weakly strategyproof , an adaptive variant ( @xmath144 ) is in fact @xmath7-partially strategyproof .",
    "finally , @xmath7-partial strategyproofness can be used to measure the incentive properties of new hybrid mechanisms , as constructed in @xcite , which enable a parametric trade - off between strategyproofness and efficiency .",
    "our new @xmath7-partial strategyproofness concept has an axiomatic motivation .",
    "it differs from prior approaches to relaxing strategyproofness in that it is parametric , computable , and applies not only in the limit , but in settings of any size .",
    "we believe this will lead to new insights in the analysis of existing non - strategyproof matching mechanisms and facilitate the design of new ones .",
    "xx    \\1998 .",
    "`` random serial dictatorship and the core from random endowments in house allocation problems . '' _ econometrica _ , 66(3 ) :  689702 .",
    "`` school choice : a mechanism design approach . ''",
    "_ american economic review _ , 93(3 )",
    ":  729747 .",
    "`` the new york city high school match . ''",
    "_ american economic review _ , 95(2 ) :  364367 .",
    "`` strategyproofness in the large as a desideratum for market design . '' _ in proceedings of the 13th acm conference on electronic commerce ( ec)_.    \\2013 .",
    "`` the computational complexity of random serial dictatorship . '' _ economics letters _ , 121(3 ) :  341  345 .    \\2013 . `` random serial dictatorship : the one and only . '' mimeo .    \\2013 .",
    "`` convex strategy - proofness with an application to the probabilistic serial mechanism . ''",
    "mimeo , uc berkeley .",
    "`` two necessary conditions for strategy - proofness : on what domains are they also sufficient ? '' _ games and economic behavior _ , 75(2 ) :  490  509 .    \\2001 .",
    "`` a new solution to the random assignment problem . ''",
    "_ journal of economic theory _ , 100(2 ) :  295328 .",
    "`` the combinatorial assignment problem : approximate competitive equilibrium from equal incomes . '' _ journal of political economy _ , 119(6 ) :  10611103 .",
    "`` matching `` versus '' mechanism design . ''",
    "_ acm sigecom exchanges _ , 11(2 ) :  415 .",
    "`` the multi - unit assignment problem : theory and evidence from course allocation at harvard . '' _ american economic review _ , 102(5 ) :  22372271 .",
    "`` designing random allocation mechanisms : theory and applications . ''",
    "_ american economic review _ , 103(2 ) :  585623 .",
    "2011_a_. `` on mechanisms eliciting ordinal preferences . '' working paper , mit .",
    "`` when are local incentive constraints sufficient ? '' _ econometrica _ , 80(2 ) :  661686 .",
    "2011_b_. `` a quantitative approach to incentives : application to voting rules . '' working paper , mit .",
    "`` probabilistic assignment : a two - fold axiomatic approach . ''",
    "working paper .",
    "`` payment rules through discriminant - based classifiers . '' _ in proceedings of the 13th acm conference on electronic commerce ( ec)_.    \\2006 . `` efficient priority rules . '' _ games and economic behavior _ , 55(2 ) :  372  384 .",
    "mini special issue : electronic market design .",
    "`` consistent house allocation . ''",
    "_ economic theory _ , 30(3 ) :  561574 .",
    "`` games of school choice under the boston mechanism . ''",
    "_ journal of public economics _",
    ", 90(1 - 2 ) :  215237 .",
    "`` a rank - based refinement of ordinal efficiency and a new ( but familiar ) class of ordinal assignment mechanisms . '' working paper .",
    "`` two axiomatic approaches to the probabilistic serial mechanism . ''",
    "_ theoretical economics_. forthcoming .",
    "`` strategy - proof , efficient , and nonbossy quota allocations . '' _ social choice and welfare _ ,",
    "33(3 ) :  505515 .    \\1979 .",
    "`` the efficient allocation of individuals to positions . '' _ the journal of political economy _ , 87(2 ) :  293314 .",
    "`` a solution to the random assignment problem on the full preference domain . '' _ journal of economic theory _ , 131(1 ) :  231250 .",
    "`` an equilibrium analysis of the probabilistic serial mechanism . '' working paper , zeyin university , istanbul , .",
    "`` incentives in the probabilistic serial mechanism . ''",
    "_ journal of economic theory _ , 145(1 ) :  106123 .",
    "`` factoring polynomials with rational coefficients . ''",
    "_ mathematische annalen _ , 261(4 ) :  515534 .",
    ". `` approximate strategyproofness . ''",
    "_ current science _ , 103(9 ) :  10211032 .",
    "2014_a_. `` hybrid mechanisms : trading off strategyproofness and efficiency in one - sided matching . '' working paper .",
    "2014_b_. `` the nave versus the adaptive boston mechanism . ''",
    "working paper .",
    "`` school choice : the case for the boston mechanism . '' in _ proceedings of the 1st conference on auctions , market mechanisms and their applications ( amma)_. boston , ma .",
    "`` matching and market design . '' in in _ the new palgrave dictionary of economics_. palgrace macmillan .",
    "`` strategyproof assignment by hierarchical exchange . '' _ econometrica _ , 68(6 ) :  pp .",
    "14031433 .",
    "`` school admissions reform in chicago and england : comparing mechanisms by their vulnerability to manipulation . ''",
    "_ american economic review _ , 103(1 ) :  80106 .",
    "`` incentive compatible allocation and exchange of discrete resources . '' working paper .",
    "`` on a conjecture by gale about one - sided matching problems . '' _ journal of economic theory _ , 52(1 ) :  123135 .",
    "sp @xmath223 upper invariance & lower invariance & swap monotonicity : :    first we show that a strategyproof mechanism must be upper invariant    and lower invariant , then we use this to obtain swap monotonicity as    well .",
    "+    sp @xmath223 upper invariance ; ;      suppose a mechanism @xmath51 is strategyproof , but is not      upper invariant",
    ". then we can find      @xmath67 and      @xmath224 such that      @xmath225      by assumption there exists a smallest index @xmath226 such      that      @xmath227      @xmath130 is the most preferred object for which the      allocation changes . without loss of generality      @xmath228 , since otherwise we reverse the roles of      @xmath45 and @xmath71 .",
    "suppose , @xmath25      has a utility function      @xmath229      where in particular @xmath230 and      @xmath231 .",
    "from this misreport ,      @xmath25 will gain some probability for @xmath130 ,      but may loose all of its probability for @xmath131 .",
    "since the allocation is unchanged for the objects      @xmath232 , the change in utility is      lower - bounded by @xmath233      which is positive for sufficiently large @xmath234 and small      @xmath235 .",
    "thus , the mechanism would not be strategyproof ,      a contradiction .",
    "sp @xmath223 lower invariance . ; ;      this is analogous to the previous argument for upper invariance :      suppose a mechanism @xmath51 is strategyproof , but not lower      invariant .",
    "similar to the previous case , we find the type profile      @xmath67 and      @xmath224 , such that there exists a largest      index @xmath236 with      @xmath237      suppose , @xmath25 has a utility function      @xmath238      where in particular @xmath239 and      @xmath240 . from this misreport ,      @xmath25 will lose some probability for @xmath130 ,      but will also gain probability for some object it prefers to      @xmath130 , since the allocation is unchanged for the      @xmath241 .",
    "furthermore , all probability for      objects @xmath242 may be converted to      probability just for @xmath243 .",
    "the change in utility is      lower - bounded by      @xmath244      which is positive for sufficiently large @xmath234 and small      @xmath235 .",
    "thus , the mechanism would not be strategyproof ,      a contradiction .",
    "sp @xmath223 swap monotonicity ; ;      suppose a mechanism @xmath51 is strategyproof , then we have      already established that it is upper and lower invariant .",
    "thus , when      an agent swaps two consecutive objects in its preference ordering ,      the allocation can only change for these two objects .",
    "suppose , the      agent changes @xmath69 to      @xmath70 .",
    "if the allocation of      @xmath73 increases , the allocation of @xmath74      must decrease by the same amount ( otherwise the result is not a      valid allocation ) .",
    "if the true preference order is      @xmath69 , then this swap is a beneficial      manipulation , which contradicts strategyproofness .",
    "upper invariance & lower invariance & swap monotonicity @xmath223 sp : :    consider any type profile @xmath53    and some misreport @xmath68 by @xmath25    in the neighborhood of the true type @xmath45 of    @xmath25 . from upper invariance , lower invariance , and swap    monotonicity",
    "it follows that @xmath71 is not a beneficial    manipulation : either the allocation remains unchanged , or    @xmath25 trades some probability at an object it prefers for    probability at an object it likes less .",
    "hence , the mechanism is not    manipulable by swaps . by proposition 1 from @xcite this implies    strategyproofness .      [ ex : ivan ] ( adapted from @xcite ) suppose , an agent of type @xmath245 can either report truthfully or misreport as @xmath57 or @xmath246 , where @xmath247 and @xmath248 .",
    "the resulting allocations are as follows : @xmath249 let @xmath250 denote strict first order - stochastic dominance with respect to the preference order of type @xmath58 .",
    "then @xmath251 @xmath252 @xmath253 i.e. , the allocations do not dominate each other for any type .",
    "in fact , if the agent had type @xmath57 or @xmath246 , it would have a dominant strategy to report truthfully , i.e , @xmath254    however , if the agent reports @xmath57 and @xmath246 with probability @xmath255 each , the allocation is @xmath256 which strictly first order - stochastically dominates @xmath257 for @xmath58 . as a consequence , the agent would definitely want to manipulate the mechanism , but whether @xmath57 or @xmath246 is the best misreport depends on the agent s utility function .        throughout the proof",
    ", we fix a setting @xmath14 and use the abbreviated notation @xmath48 , for @xmath44 .",
    "define @xmath258 this is the smallest non - vanishing value by which the allocation of any object changes between two different types any agent could report . since @xmath259 are finite , @xmath260 must be strictly positive ( otherwise @xmath51 is constant ) .",
    "upper invariance & swap monotonicity implies r - psp : :    we must show that there exists @xmath5 $ ] such that no    agent with utility in @xmath6  can benefit from    submitting a false report .",
    "suppose , agent @xmath25 of type    @xmath45 with    @xmath261 is considering to misrepresent its    type as @xmath262 .",
    "let @xmath3 be the most preferred    object for which the allocation changes , i.e. , for all    @xmath263 @xmath264    @xmath265 such an object must exist , because    otherwise the allocations would be equal under both reports and    @xmath266 would not be a beneficial manipulation .",
    "lemma    [ lem : b_decrease ] yields that the allocation for @xmath3 weakly    decreases .",
    "since the allocation for @xmath3 must change by    assumption , a weak decrease implies a strict decrease .",
    "thus , reporting    @xmath266 instead of @xmath45 will necessarily    decrease the probability of @xmath25 getting @xmath3 by    at least @xmath260 .",
    "non of the probabilities for the    objects @xmath267 are affected .",
    "hence , in the best    case ( for the agent ) , all remaining probability is concentrated on    @xmath268 .",
    "the maximum utility gain for @xmath25 is    upper bounded by    @xmath269 .",
    "the    manipulation is guaranteed not to be beneficial if    @xmath270    this sufficient condition is satisfied by all utilities in    @xmath6  with the choice of    @xmath271 .",
    "r - psp implies swap monotonicity & upper invariance : :    @xmath272    +    upper invariance ; ;      suppose @xmath51 is @xmath7-partially strategyproof      for some fixed @xmath5 $ ] , i.e. , no agent with a      utility function satisfying @xmath6  can      benefit from misrepresenting its type .",
    "we want to show that      @xmath51 is upper invariant .",
    "suppose a type @xmath58      with      @xmath273      suppose further that a swap of @xmath97 and @xmath219      changes the allocation of some object ranked before @xmath97 ,      and let @xmath4 be the most preferred such object .",
    "define      @xmath260 as in ( [ eq : define_epsilon ] ) , then without      loss of generality the allocation of @xmath4 increases by at      least @xmath260 due to this swap ( if it decreases ,      consider the reverse swap ) .",
    "this means that by swapping      @xmath97 and @xmath219 , an agent of type      @xmath58 could gain at least probability      @xmath260 for object @xmath4 . because      @xmath4 was the highest ranking object for which the      allocation changed , the worst thing that can happen from the agent s      perspective is that it looses all of its chances to get      @xmath3 and gets its last choice instead .",
    "hence ,      @xmath274 is a lower      bound for the benefit an agent of type @xmath58 can have from      swapping @xmath97 and @xmath219 in its report .",
    "the      manipulation is guaranteed to be strictly beneficial if      @xmath275      but for any @xmath127 $ ] , the set      @xmath6  will contain a utility function      satisfying this condition .",
    "this is a contradiction to the assumption      that no agent with a utility function in      @xmath6  will have a strictly beneficial      manipulation .",
    "consequently , @xmath51 must be upper invariant .",
    "swap monotonicity ; ;      suppose @xmath51 is @xmath7-partially strategyproof      for some fixed @xmath5 $ ] .",
    "we know already that      @xmath51 must be upper invariant . towards contradiction ,",
    "assume that upon a swap of two adjacent objects @xmath4 and      @xmath3 ( from @xmath212 to      @xmath156 ) by a type @xmath58 agent , the      mechanism violates swap monotonicity .",
    "say that      @xmath276      then one of the following holds :      +      1 .",
    "[ case_a_increase ] the allocation of @xmath4 increases ,      2 .",
    "[ case_a_const_b_increase]or the allocation of @xmath4      remains constant , and the allocation of @xmath3 increases ,      3 .",
    "[ case_a_const_b_decrease]or the allocation of @xmath4      remains constant , and the allocation of @xmath3 decreases ,      4 .",
    "[ case_a_b_const]or the allocations of @xmath4 and      @xmath3 remain constant , but it allocation changes for some      object @xmath277 ,      5 .",
    "[ case_a_b_decrease]or the allocations of both @xmath4      and @xmath3 decrease .      +      because of upper invariance , we know that the allocation of objects      ranking above @xmath4 can not be affected",
    ". therefore , in case      [ case_a_increase ] , the agent can gain at least      @xmath260 probability of getting @xmath4 , with      @xmath260 defined as in ( [ eq : define_epsilon ] ) .",
    "then ,      the worst thing ( for the agent ) that could happen is that it looses      all its chances of getting anything but its least preferred object .",
    "hence , @xmath278 is      a lower bound for the benefit the agent can have from swapping      @xmath4 and @xmath3 .",
    "but as in the proof of upper      invariance , this leads to a contradiction .",
    "+      in case [ case_a_const_b_increase ] , the agent gains at least      @xmath260 probability for @xmath3 , but may      loose shares in the next lower ranking object @xmath97 .",
    "again , the lower bound for the benefit is      @xmath279 which      leads to a contradiction .",
    "note that if @xmath3 is the lowest      ranking object , this case is impossible .",
    "+      case [ case_a_const_b_decrease ] is symmetric to case      [ case_a_const_b_increase ] , and we can consider the reverse swap      instead .",
    "+      in case [ case_a_b_const ] , let @xmath219 be the highest ranking      object for which the allocation changes , which must lie after      @xmath3 because of upper invariance . then without loss of      generality , the agent can increase its chances of getting      @xmath219 by at least @xmath260 , but potentially      looses all chances for the next lower ranking object      @xmath280 .",
    "this again leads to a contradiction .",
    "+      for case [ case_a_b_decrease ] , we consider the reverse swap , which is      covered by case [ case_a_increase ] .",
    "+      we have shown that none of the cases [ case_a_increase ] through      [ case_a_b_decrease ] can occur under a mechanism that is      @xmath7-partially strategyproof .",
    "therefore , the mechanism      must satisfy strict swap monotonicity .",
    "[ lem : b_decrease ] given a setting @xmath14 , a upper invariant and swap monotonic mechanism @xmath51 ( in this setting ) , and @xmath281 such that ( [ eq : ordering_a_b_c ] ) and ( [ eq : no_change_in_upper ] ) from the proof of theorem [ thm : characterization_psp ] hold .",
    "then the allocation for @xmath3 must weakly decrease , i.e. , @xmath282        a transition can be interpreted as a sequence of swaps of adjacent objects that transform one type into another if applied in order .",
    "suppose , @xmath288 then the _ canonical transition _ is the transition that results from starting at @xmath58 and swapping @xmath289 ( which may not be in first position for @xmath58 ) up until it is in first position",
    ". then do the same for @xmath290 , until it is in second position , and so on , until @xmath57 is obtained .    to prove the lemma ,",
    "consider the first part of canonical transition from @xmath266 to @xmath45 : @xmath289 is swapped with its predecessors until it reaches its final position at the front of the ranking .",
    "with each swap the share of @xmath289 allocated to @xmath25 can only increase or stay constant , because the mechanism is swap monotonic .",
    "on the other hand , once @xmath289 is at the front of the ranking , the allocation of @xmath289 will remain unchanged during the rest of the transition .",
    "this is because @xmath51 is upper invariant , i.e. , no change of order below the first position can affect the allocation of the first ranking object . but",
    "@xmath291 , and hence non of the swaps involving @xmath289 will have any effect on the allocation of @xmath289 .",
    "but by swap monotonicity this means that non of the swaps will have any effect on the allocation at all .",
    "next consider the second part of transition , where @xmath290 is brought into second position by swapping it upwards .",
    "the same argument applies to show that the overall allocation must remain unchanged .",
    "the same is true for @xmath292 .",
    "thus , we arrive at a type @xmath293 under @xmath71 all of the @xmath73 are in the same positions are for type @xmath45 , @xmath3 holds some position below its rank for type @xmath45 , and some of the @xmath294 are ranking above @xmath3 ( possibly in a different order ) . from the previous argument",
    "we know that @xmath295    as a consequence , without loss of generality , we can consider a misreport @xmath266 , for which the order of the objects ranking above @xmath3 under @xmath45 ( the @xmath73 ) remains unchanged . assume towards contradiction that @xmath296 by a similar argument as above , we can consider swapping @xmath3 up to the position directly after @xmath130 to get @xmath297 which differs from @xmath45 only beyond the position of @xmath3 .",
    "swap monotonicity yields that each swap will weakly increase the probability that @xmath25 gets @xmath3 .",
    "then by assumption @xmath298 however , upper invariance implies @xmath299 since the orderings of @xmath45 and @xmath300 coincide up to and including the position of @xmath3 .",
    "this is a contradiction , and hence the probability of @xmath25 getting @xmath3 must weakly decrease under @xmath301 .      by assumption , @xmath11 violates @xmath6 .",
    "thus , for some pair @xmath105 of adjacent objects in the preference order corresponding to @xmath11 we have @xmath155 additionally , @xmath3 is not the last choice of @xmath25 , since the constraint @xmath302 is trivially satisfied .",
    "we now need to define the mechanism @xmath12 that offers a manipulation to an agent with utility @xmath11 , but would not offer any manipulation to an agent whose utility satisfies @xmath6 . for partial strategyproofness , an agent should not have a beneficial manipulation for any set of reports from the other agents .",
    "thus , it suffices to specify @xmath12 for a single set of reports @xmath47 , where only agent @xmath25 can vary its report .",
    "the allocation for @xmath25 must then be specified for any possible report @xmath303 from @xmath25 . in order to prove the theorem",
    ", this specification must be consistent with upper invariance and swap monotonicity .",
    "* for a report @xmath303 with @xmath1 , @xmath305 * for a report @xmath303 with @xmath2 , we adjust the original allocation by @xmath306 where @xmath307 , @xmath308 , @xmath309 . here",
    "@xmath219 denotes the last choice . in case @xmath310",
    ", both @xmath311 and @xmath312 are added .",
    "note that if the last object changes , the allocation for the new last object is decreased ( by adding @xmath312 ) , and the allocation of the previous last object is increased ( by adding @xmath312 ) .",
    "this mechanism is upper invariant : swapping the order of @xmath4 and @xmath3 induces a change in the allocation of @xmath4,@xmath3 , and the last object @xmath219 .",
    "therefore no higher ranking object is affected .",
    "swapping the last and the second to last object also only changes the allocation for these two object .",
    "this mechanism is also swap monotonic : swapping @xmath4 and @xmath3 changes the allocation for both objects in the correct way , since @xmath313 . swapping",
    "the last to objects also changes the allocation appropriately , since @xmath314 .",
    "no other change of report changes the allocation .",
    "case @xmath315 : : :    in this case , the true preference order is @xmath1 .",
    "swapping @xmath4 and @xmath3 in its order is    beneficial for @xmath25 if    @xmath316    @xmath317    ( [ eq : tildei_wants_to_manip ] ) is satisfied if    @xmath318 since    @xmath319    by construction .",
    "case @xmath320 : : :    swapping @xmath4 and @xmath3 should no longer be    beneficial for @xmath25 .",
    "this is the case if    @xmath321    @xmath322 ( [ eq : abi_wants_to_manip ] )    is satisfied if @xmath323 since    @xmath324 by    construction .",
    "case @xmath325 : : :    swapping @xmath3 and @xmath4 to @xmath1    should not be beneficial for @xmath25 .",
    "this is the case if    @xmath326    @xmath327 ( [ eq : bai_wants_to_manip ] )    is satisfied if    @xmath328 since    @xmath329 for    agents with @xmath2 by construction .",
    "this means that if @xmath311 and @xmath330 satisfy ( [ eq : tildei_wants_to_manip_final]),([eq : abi_wants_to_manip_final ] ) , and ( [ eq : bai_wants_to_manip_final ] ) , the mechanism @xmath12 is in fact what we are looking for . given some @xmath331 , we can choose @xmath311 appropriately , since @xmath332 , @xmath333 , and @xmath334 since @xmath25 and @xmath47 could be chosen arbitrarily , anonymity is not a significant constraint .      to see [ item : ism_dosp ] ) , note that if @xmath51 is as intensely and strongly manipulable as @xmath162 , then any agent who can manipulate @xmath162 also finds a manipulation to @xmath51 . thus , the set of utilities on which @xmath162 is partially strategyproof can not be larger than the set of utilities on which @xmath51 is partially strategyproof .",
    "this in turn implies @xmath168 .    for [ item : dosp_ism ] )",
    ", observe that if @xmath160 , then there exists a utility function @xmath11 in @xmath335 , which is not in @xmath336 , and for which @xmath162 is manipulable , but @xmath51 is not .",
    "thus , @xmath51 can not be as intensely and strongly manipulable as @xmath162 , but the reverse is possible .",
    "@xmath337 ( [ eq : poly_constraint ] ) satisfied : :    let @xmath171 .",
    "assume towards contradiction that    ( [ eq : poly_constraint ] ) is not satisfied for some    @xmath338 , and    @xmath339 , i.e. ,    @xmath340 let    @xmath341 , and consider the    utility function @xmath29 with    +    * @xmath342 ,    * @xmath343 if    @xmath344 ,    * @xmath345 ,    +    for some large @xmath206 .",
    "then @xmath29 satisfies    @xmath6 .",
    "thus , if @xmath51 is    @xmath7-partially strategyproof , @xmath25 with utility    function @xmath29 should not find a beneficial manipulation .",
    "+    the utility gain from reporting truthfully over reporting    @xmath71 for @xmath25 is @xmath346    since @xmath347 by assumption    and @xmath206 can be chosen arbitrarily large ,    ( [ eq : util_bound_delta ] ) is negative .",
    "thus , the incentive constraint it    violated , and @xmath25 finds a beneficial misreport    @xmath71 , a contradiction .",
    "( [ eq : poly_constraint ] ) satisfied @xmath348 : :    towards contradiction , assume that @xmath51 is not    @xmath7-partially strategyproof , i.e. , there exist    @xmath338 and utility    function @xmath122 such that    @xmath349    ( without loss of generality assume    @xmath350 ) .",
    "we can re - write this term    using horner s method and get @xmath351    dropping the arguments @xmath352 for the sake of    brevity .",
    "this term is definitely negative , but we can also find the    smallest @xmath353 for which    @xmath354    is negative , and for all @xmath355 ,    @xmath356 thus , we can consecutively replace    the @xmath357 by @xmath181 ,    since @xmath29 satisfies @xmath6  and    only make the term smaller , i.e. , @xmath358 but since    @xmath359 , it follows that    @xmath360 , and hence constraint    ( [ eq : poly_constraint ] ) is not satisfied , a contradiction .",
    "suppose agent @xmath25 is considering the following two reports that only differ by the ordering of @xmath119 and @xmath361 : @xmath362 the probabilistic serial mechanism is implemented via the simultaneous eating algorithm , objects are continuously consumed as time progresses .",
    "let @xmath363 be the time when object @xmath21 is exhausted under report @xmath45 , and @xmath364 the time when @xmath21 is exhausted under report @xmath71 .    if @xmath365 , the last of the objects @xmath73 is exhausted only after the first of @xmath119 and @xmath361 is exhausted . by upper invariance , @xmath366 .",
    "this means that by the time @xmath25 arrives at @xmath119 ( under report @xmath45 ) or at @xmath361 under report @xmath71 , one of them is already exhausted .",
    "thus , @xmath25 will proceed directly to the respective other object .",
    "the consumption pattern does not differ between the two reports , i.e. , the allocation does not change .",
    "now suppose that @xmath367",
    ". then @xmath25 received no shares of @xmath361 under @xmath45 .",
    "but under @xmath71 , it consumes shares of @xmath361 from @xmath368 until @xmath369 .",
    "thus , @xmath25 s share in @xmath361 strictly increases .",
    "furthermore , @xmath25 consumed shares of @xmath119 from @xmath368 until @xmath370 under report @xmath45 . under report",
    "@xmath71 , @xmath25 arrives at @xmath119 only later at @xmath369 .",
    "the same agents that consumed @xmath119 under report @xmath45 will also be consuming @xmath119 under report @xmath71 and at the same times .",
    "in addition , there may be some agents who arrive together with @xmath25 from @xmath361 .",
    "thus , under report @xmath71 agent @xmath25 faces strictly more competition for weakly less capacity of @xmath119 , implying that its share of @xmath119 will strictly decrease .",
    "note that if @xmath25 faced no competition at @xmath361 , it was the only agent at @xmath361 , and thus consumes it until time @xmath211 . in this case the allocation will also decrease , because @xmath25 arrived later under report @xmath71 .",
    "finally , suppose that @xmath371 .",
    "under report @xmath71 , agent @xmath25 will arrive strictly earlier at @xmath361 , i.e. , the competing agents will be the same and arrive at the same times or later ( if they arrived from @xmath119 ) .",
    "thus , the allocation for @xmath361 will strictly increase under report @xmath71 .",
    "furthermore , @xmath25 might not receive any shares of @xmath119 under report @xmath71 , a strict decrease . otherwise ,",
    "the argument why @xmath25 receives strictly less shares of @xmath119 under @xmath71 is the same as for the case `` @xmath372 '' .",
    "[ ex : rv_not_wi_sc ] consider the setting @xmath215 , @xmath216 , @xmath373 , and the type profile @xmath374 the unique rank efficient allocation is @xmath375 .",
    "suppose agent 1 changes its report to @xmath376 now the only rank efficient allocation is @xmath377 .",
    "the reports @xmath378 and @xmath379 differ by two swaps : @xmath380 and @xmath381 .",
    "thus , at least one of these swaps must have increased the likelihood of getting object @xmath4 for agent 1 .",
    "this contradicts upper invariance .",
    "also , under no report out of @xmath382 did agent 1 have any probability of getting objects @xmath3 or @xmath97 .",
    "hence , the swap that changes the allocation involved a change of position of either object @xmath3 or @xmath97 , but the probability for each remained zero , a contradiction to swap monotonicity .",
    "agent 1 could change its report to @xmath387 in which case @xmath388 is the unique rank efficient allocation .",
    "hence , either the swap @xmath389 or the swap @xmath390 changed the allocation for @xmath219 , a contradiction to lower invariance ."
  ],
  "abstract_text": [
    "<S> we study one - sided matching mechanisms where agents have vnm utility functions and report ordinal preferences . </S>",
    "<S> we first show that in this domain strategyproof mechanisms are characterized by three intuitive axioms : _ swap monotonicity _ , _ upper invariance _ , and _ </S>",
    "<S> lower invariance_. our second result is that dropping lower invariance leads to an interesting new relaxation of strategyproofness , which we call _ partial strategyproofness_. in particular , we show that mechanisms are swap monotonic and upper invariant if and only if they are strategyproof on a restricted domain where agents have sufficiently different valuations for different objects . </S>",
    "<S> furthermore , we show that this domain restriction is maximal and use it to define a single - parameter measure for the _ degree of strategyproofness _ of a manipulable mechanism . </S>",
    "<S> we also provide an algorithm that computes this measure . </S>",
    "<S> our new partial strategyproofness concept finds applications in the incentive analysis of non - strategyproof mechanisms , such as the probabilistic serial mechanism , different variants of the boston mechanism , and the construction of new hybrid mechanisms . </S>"
  ]
}