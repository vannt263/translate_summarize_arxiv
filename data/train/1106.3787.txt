{
  "article_text": [
    "ellipses are useful in many applied scenarios , and in widely disparate fields . in our research , which happens to be in two very different areas , we have encountered a common need for efficiently calculating the overlap area between two ellipses .    in one case , the design for a solar calibrator on - board an orbiting satellite required an efficient algorithm for ellipse overlap area .",
    "imaging systems aboard satellites rely on semi - conductor detectors whose performance changes over time due to many factors . to produce consistent data , some means of calibrating the detectors",
    "is required ; see , e.g. , @xcite .",
    "some systems use the sun as a light source for calibration . in a typical solar calibrator",
    ", incident sunlight passes through an attenuator grating and impinges on a diffuser plate , which is oriented obliquely to the attenuator grating .",
    "the attenuator grating is a pattern of circular openings .",
    "when sunlight passes through the circular openings , projections of the circles onto the oblique diffuser plate become small ellipses .",
    "the projection of the large circular entrance aperture on the oblique diffuser plate is also an ellipse .",
    "the total incident light on the calibrator is proportional to the sum of all the areas of the smaller ellipses that are contained within the larger entrance aperture ellipse .",
    "however , as the calibration process proceeds , the satellite is moving through its orbit , and the angle from the sun into the calibrator changes ( ~7@xmath0 in 2 minutes ) .",
    "the attenuator grating ellipses thus move across the entrance aperture , and some of the smaller ellipses pass in and out of the entrance aperture ellipse during calibration .",
    "movement of the small ellipses across the aperture creates fluctuations in the total amount of incident sunlight reaching the calibrator in the range of 0.3 to 0.5% .",
    "this jitter creates errors in the calibration algorithms . in order to model the jitter ,",
    "an algorithm is required for determining the overlap area of two ellipses .",
    "monte carlo integration had been used ; however , the method is numerically intensive because it converges very slowly , so it was not an attractive approach for modeling the calibrator due to the large number of ellipses that must be modeled .    in a more down - to - earth setting",
    ", populated places such as city streets or building corridors can become quite congested while crowds of people are moving about .",
    "understanding the dynamics of pedestrian movement in these scenarios can be beneficial in many ways .",
    "pedestrian dynamics can provide critical input to the design of buildings or city infrastructure , for example by predicting the effects of specific crowd management strategies , or the behavior of crowds utilizing emergency escape routes .",
    "current research in pedestrian dynamics is making steady progress toward realistic modeling of local movement ; see , e.g. , @xcite . the model presented in @xcite",
    "is based on the concept of elliptical volume exclusion for individual pedestrians .",
    "each model pedestrian is surrounded by an elliptical footprint area that the model uses to anticipate obstacles and other pedestrians in or near the intended path .",
    "the footprint area is influenced by an individuals velocity ; for example , the exclusion area in front of a fast - moving pedestrian is elongated when compared to a slower - moving individual , since a pedestrian is generally thinking a few steps ahead .",
    "as pedestrians travel through a confined space , their collective exclusion areas become denser , and the areas will eventually begin to overlap . a force - based model will produce a repulsive force between overlapping exclusion areas , causing the pedestrians to slow down or change course when the exclusion force becomes large .",
    "implementing the force - based model with elliptical exclusion areas in a simulation requires calculating the overlap area between many different ellipses in the most general orientations .",
    "the ellipse area overlap algorithm must also be efficient , so as not to bog down the simulation .",
    "simulations for both the satellite solar calibrator and force - based pedestrian dynamic model require efficient calculation of the overlap area between two ellipses . in this paper",
    ", we provide an algorithm that has served well for both applications .",
    "the core component of the overlap area algorithm is based on determining the area of an _ ellipse segment _ , which is the area between a secant line and the ellipse boundary .",
    "the segment algorithm forms the basis of an application for calculating the overlap area between two general ellipses .",
    "consider an ellipse that is centered at the origin , with its axes aligned to the coordinate axes . if the semi - axis length along the _ x_-axis is _ a _ , and the semi - axis length along the _",
    "y_-axis is _ b _ ,",
    "then the ellipse is defined by a locus of points that satisfy the implicit polynomial equation @xmath1 the same ellipse can be defined parametrically by : @xmath2 the area of such an ellipse can be found using the parameterized form with the gauss - green formula :    @xmath3dt}\\\\ = & \\frac{1}{2}\\int^{2\\pi}_0{a\\cdot \\cos(t)\\cdot b\\cdot \\cos(t)-b\\cdot \\sin(t)\\cdot ( -a)\\cdot \\sin(t)]dt } \\\\ = & \\frac{a\\cdot b}{2}\\int^{2\\pi } _ 0{\\cos^2(t)+\\sin^2(t)]dt}=\\frac{a\\cdot b}{2}\\int^{2\\pi } _ 0{dt}\\\\ = & \\pi \\cdot a\\cdot b   \\end{split}\\ ] ]      we define the _ ellipse sector _ between two points ( @xmath4 , @xmath5 ) and ( @xmath6 , @xmath7 ) on the ellipse as the area that is swept out by a vector from the origin to the ellipse , beginning at ( @xmath4 , @xmath5 ) , as the vector travels along the ellipse in a counter - clockwise direction from ( @xmath4 , @xmath5 ) to ( @xmath6 , @xmath7 ) .",
    "an example is shown in fig .",
    "the gauss - green formula can also be used to determine the area of such an ellipse sector .",
    "@xmath8     and @xmath9.,title=\"fig:\",width=192 ] +    the parametric angle @xmath10 that is formed between the @xmath11-axis and a point ( @xmath11 , @xmath12 ) on the ellipse is found from the ellipse parameterizations : @xmath13    for a circle ( @xmath14 in the ellipse implicit polynomial form ) , the parametric angle corresponds to the geometric ( visual ) angle that a line from the origin to the point ( @xmath11 , @xmath12 ) makes with the @xmath11-axis .",
    "however , the same can not be said for an ellipse ; that is , the geometric ( visual ) angle is _ not _ the same as the parametric angle used in the area calculation . for example , consider the ellipse in fig .",
    "[ fig1 ] ; the implicit polynomial form is @xmath15 suppose the point ( @xmath16 , @xmath17 ) is at @xmath18 .",
    "the point is on the ellipse , since @xmath19    a line segment from the origin to @xmath18 forms an angle with the @xmath11-axis of @xmath20/4 ( @xmath210.7485398 ) .",
    "however , the ellipse parametric angle to the same point is : @xmath22 the same angle can also be found from the parametric equation for @xmath12 : @xmath23 the angle found by using the parametric equations does not match the geometric angle to the point that defines the angle .    when determining the parametric angle for a given point ( @xmath11 , @xmath12 ) on the ellipse , the angle must be chosen in the proper quadrant , based on the signs of @xmath11 and @xmath12 .",
    "for the ellipse in fig .",
    "[ fig1 ] , suppose the point ( @xmath24 , @xmath25 ) is at @xmath26 .",
    "the parametric angle that is determined from the equation for @xmath11 is : @xmath27    the parametric angle that is determined from the equation for @xmath12 is :    @xmath28    the apparent discrepancy is resolved by recalling that inverse trigonometric functions are usually implemented to return a ` principal value ' that is within a conventional range .",
    "the typical ( principal - valued ) @xmath29 function returns angles in the range 0 = @xmath10 = @xmath20 , and the typical ( principal - valued ) @xmath30 function returns angles in the range @xmath31 . when the principal - valued inverse trigonometric functions return angles in the typical ranges , the ellipse parametric angles , defined to be from the @xmath11-axis , with positive angles in the counter - clockwise direction , can be found with the relations in table [ tab1 ] .",
    ".relations for finding the parametric angle that corresponds to a given point ( _ x _ , _ y _ ) on the ellipse _",
    "_ x__@xmath32/__a__@xmath32 + _ _ y__@xmath32/__b__@xmath32 = 1 .",
    "the parametric angle is formed between the positive _ x_-axis and a line drawn from the origin to the given point , with counterclockwise being positive .",
    "for the standard ( principal - valued ) inverse trigonometric functions , the resulting angle will be in the range 0 @xmath33 for any point on the ellipse . [ cols=\"<,<\",options=\"header \" , ]     for robustness , the algorithm should avoid divide - by - zero and inverse - trigonometric errors , so data checks should be included . the ellipse parameters @xmath34 and @xmath35 must be greater than zero .",
    "a check is provided to determine whether the points are on the ellipse , to within some numerical tolerance , @xmath36 .",
    "since the points can only be checked as being on the ellipse to within some numerical tolerance , it may still be possible for the @xmath11-values to be slightly larger than @xmath34 , leading to an error when calling the inverse trigonometric functions with the argument @xmath37 . in this case",
    ", the algorithm checks whether the @xmath11-value close to @xmath34 or @xmath34 , that is within a distance that is less than the numerical tolerance .",
    "if the closeness condition is met , then the algorithm assumes that the calling function passed a value that is indeed on the ellipse near the point ( @xmath34 , 0 ) or ( @xmath34 , 0 ) , so the value of @xmath11 is nudged back to @xmath34 or @xmath34 to avoid any error when calling the inverse trigonometric functions . the core algorithm , including all data checks , is shown in list .",
    "[ code1 ] .    ....",
    "ellipse_segment ( a , b , x1 , y1 , x2 , y2 )   do if ( a   0 or b   0 )       then return ( -1 , error_ellipse_parameters )             : data check              2    2      2   2               2   2      2   2   do if ( |x1 /a + y1 /b  1| >   or |x1 /a + y1 /b",
    " 1| > )       then return ( -1 , error_points_not_on_ellipse )          : data check   do if ( |x1|/a > )       do if |x1| - a >           then return ( -1 , error_inverse_trig )                : data check          else do if x1 < 0                then x1   -a                else x1   a   do if ( |x2|/a > )       do if |x2| - a >           then return ( -1 , error_inverse_trig )                : data check          else do if x2 < 0                    then x2   -a                    else x2   a   do if ( y1 < 0 )                      : angle quadrant formula ( table 1 )       then 1   2  acos ( x1/a )       else 1   acos ( x1/a )   do if ( y2 < 0 )                      : angle quadrant formula ( table 1 )       then 2   2  acos ( x2/a )       else 2   acos ( x2/a )   do if ( 1 > 2 )                                 : must start with 1 < 2       then 1   1 - 2   do if ( ( 2  1 ) > )                        : store sign of triangle area       then trsgn   + 1.0       else trsgn   + 1.0   area   0.5*(a*b*(2 - 1 )  trsgn*|x1*y2 - x2*y1| )   return ( area , normal_termination ) ....    an implementation of the ellipse_segment algorithm written in c  code is shown in appendix  [ appa ] .",
    "the code compiles under cygwin-1.7.7 - 1 , and returns the following values for the two test cases presented in fig .",
    "[ fig1 ] and fig .",
    "[ fig2 ] :    ....          cc call_es.c ellipse_segment.c -o call_es.exe          ./call_es         calling ellipse_segment.c         fig . 1 : segment area =                9.52864712 , return_value = 0         fig .",
    "2 : segment area =              15.60409411 , return_value = 0         sum of ellipse segments = 25.13274123         ellipse area by pi*a*b =            25.13274123 ....",
    "the core segment algorithm is based on an ellipse that is centered at the origin with its axes aligned to the coordinate axes .",
    "the algorithm can be extended to more general ellipses , such as rotated and/or translated ellipse forms .",
    "start by considering the case for a standard ellipse with semi - major axis lengths of @xmath34 and @xmath35 that is centered at the origin and with its axes aligned with the coordinate axes .",
    "suppose that the ellipse is rotated through a counter - clockwise angle @xmath38 , and that the ellipse is then translated so that its center is at the point ( @xmath39 , @xmath40 ) .",
    "the rotated+translated ellipse could then be defined by the set of parameters ( @xmath34 , @xmath35 , @xmath39 , @xmath40 , @xmath41 ) , with the understanding that the rotation through _",
    "@xmath38 _ is performed before the translation through ( @xmath39 , @xmath40 ) .",
    "the approach for extending the core segment area algorithm will be to determine analogs on the standard ellipse corresponding to any points of intersection between a shape of interest and the general rotated and translated ellipse . to identify corresponding points , features of the shape of interest",
    "are translated by ( @xmath39 , @xmath40 ) , and then rotated by @xmath41 .",
    "the translated+rotated features are used to determine any points of intersection with a similar ellipse that is centered at the origin with its axes aligned to the coordinate axes .",
    "then , the core segment algorithm can be called with the translated+rotated intersection points .",
    "rotation and translation are affine transformations that are also length- and area - preserving .",
    "in particular , the semi - axis lengths in the general rotated ellipse are preserved by both transformations , and corresponding points on the two ellipses will demarcate equal partition areas .",
    "[ fig3 ] illustrates this idea , showing the ellipse of fig .",
    "[ fig1 ] which has been rotated counter - clockwise through an angle @xmath42 , then translated by @xmath43 .",
    "suppose that we desire to find the area of the rotated+translated ellipse sector defined by the line @xmath44 , where the line ` direction ' travels from lower - right to upper - left , as shown in fig .",
    "we describe an approach for finding a segment in a rotated+translated ellipse , based on the core ellipse segment algorithm .",
    "an ellipse that is centered at the origin , with its axes aligned to the coordinate axes , is defined parametrically by @xmath2 suppose the ellipse is rotated through an angle @xmath41 , with counter - clockwise being positive , and that the ellipse is then to be translated to put its center is at the point ( @xmath39 , @xmath40 ) .",
    "any point ( @xmath11 , @xmath12 ) on the standard ellipse can be rotated and translated to end up in a corresponding location on the new ellipse by using the transformation : @xmath45=\\left [ \\begin{array}{cc } { \\cos   \\left(\\varphi \\right)\\ } & -{\\sin   \\left(\\varphi \\right)\\ } \\\\   { \\sin   \\left(\\varphi \\right)\\ } & { \\cos   \\left(\\varphi \\right)\\ } \\end{array } \\right]\\cdot \\left [ \\begin{array}{c } x \\\\   y \\end{array } \\right]+\\left [ \\begin{array}{c } h \\\\   k \\end{array } \\right]\\ ] ] rotation and translation of the original standard ellipse does not change the ellipse area , or the semi - axis lengths .",
    "one important feature of the algorithms presented here is that the semi - axis lengths @xmath34 and @xmath35 are in the direction of the @xmath11- and _ y_-axes , respectively , in the _ un - rotated _ (",
    "standard ) ellipse . in its rotated orientation",
    ", the semi - axis length @xmath34 will rarely be oriented horizontally ( in fact , for @xmath46 , the semi - axis length @xmath34 will be oriented vertically ) .",
    "regardless of the orientation of the rotated+translated ellipse , the algorithms presented here assume that the values of @xmath34 and @xmath35 passed into the algorithm represent the semi - axis lengths along the @xmath11- and @xmath12-axes , respectively , for the corresponding un - rotated , un - translated ellipse .",
    "the angle @xmath41 is the amount of counter - clockwise rotation required to put the ellipse into its desired location .",
    "specifying a negative value for @xmath41 will rotate the standard ellipse through a clockwise angle .",
    "the angle @xmath41 can be specified in anywhere in the range ( 8 , + 8) ; the working angle in the code will be computed from the given angle , modulo @xmath47 , to avoid any potential errors ( ? ) when calculating trigonometric values .",
    "the translation ( @xmath39 , @xmath40 ) is the absolute movement along the coordinate axes of the ellipse center to move a standard ellipse into its desired location .",
    "negative values of @xmath39 move the standard ellipse to the left ; negative values of @xmath40 move the standard ellipse down .    to find the area between the given line and the rotated+translated ellipse , the two curve equations can be solved simultaneously to find any points of intersection . but instead of searching for the points of intersection with the rotated+translated ellipse , it is more efficient to transform the two given points that define the line back through the translation ( @xmath39 , @xmath40 ) then rotation through @xmath41 . the new line determined by the translated+rotated points will pass through the standard ellipse at points that are analogous to where the original line intersects the rotated+translated ellipse .    the transformations required to move the given points ( @xmath48 , @xmath49 ) and ( @xmath24 , @xmath25 ) into an orientation with respect to a standard ellipse that is analogous to their orientation to the given ellipse are the inverse of what it took to rotate+translate the ellipse to its desired position .",
    "the translation is performed first , then the rotation : @xmath50=\\left [ \\begin{array}{cc } { \\cos   \\left(-\\varphi \\right)\\ } & -{\\sin   \\left(-\\varphi \\right)\\ } \\\\   { \\sin   \\left(-\\varphi \\right)\\ } & { \\cos   \\left(-\\varphi \\right)\\ } \\end{array } \\right]\\cdot \\left [ \\begin{array}{c } x_i - h \\\\",
    "y_i - k \\end{array } \\right]\\ ] ] multiplying the vector by the matrix , and simplifying the negative - angle trig functions gives the following expressions for the translated+rotated points : @xmath51 the two new points @xmath52 and @xmath53 can be used to determine a line , _",
    "e.g_. , by the point - slope method : @xmath54 the equation can also be formulated in an alternative way to accommodate cases where the translated+rotated line is vertical , or nearly so :    @xmath55    points of intersection are found by substituting the line equations into the standard ellipse equation , and solving for the remaining variable . for each case , define the slope as : @xmath56    then the two substitutions proceed as follows :    @xmath57\\cdot x^2\\\\ + & \\left[2\\cdot \\left(y_{1_0}\\cdot m_{yx}-{\\left(m_{yx}\\right)}^2\\cdot x_{1_0}\\right)\\right]\\cdot x\\\\ + & \\left[{\\left(y_{1_0}\\right)}^2 - 2\\cdot m_{yx}\\cdot x_{1_0}\\cdot y_{1_0}+{\\left(m_{yx}\\cdot x_{1_0}\\right)}^2-b^2\\right]\\\\ = & 0 \\end{split}\\ ] ]    @xmath58\\cdot y^2\\\\ + & \\left[2\\cdot \\left(x_{1_0}\\cdot m_{xy}-{\\left(m_{xy}\\right)}^2\\cdot y_{1_0}\\right)\\right]\\cdot y\\\\ + & \\left[{\\left(x_{1_0}\\right)}^2 - 2\\cdot m_{xy}\\cdot x_{1_0}\\cdot y_{1_0}+{\\left(m_{xy}\\cdot y_{1_0}\\right)}^2-a^2\\right]\\\\ = & 0 \\end{split}\\ ] ]    if the translated+rotated line is not vertical , then use the first equation to find the @xmath11-values for any points of intersection .",
    "if the translated+rotated line is close to vertical , then the second equation can be used to find the @xmath12-values for any points of intersection . since points of intersection between the line and the ellipse are determined by solving a quadratic equation @xmath59 , there are three cases to consider :    1 .",
    "@xmath60 : complex conjugate roots ( no points of intersection ) 2 .",
    "@xmath61 : one double real root ( 1 point of intersection ; line tangent to ellipse ) 3 .",
    "@xmath62 : two real roots ( 2 points of intersection ; line crosses ellipse )    for the first two cases , the segment area will be zero . for the third case , the two points of intersection can be sent to the core segment area algorithm .",
    "however , to enforce a consistency in area measures returned by the core algorithm , the integration direction is specified to be from the first point to the second point . as such",
    ", the ellipse line overlap algorithm should be sensitive to the order that the points are passed to the core segment algorithm .",
    "we suggest giving the line a ` direction ' from the first given point on the line to the second .",
    "the line ` direction ' can then be used to determine which is to be the first point of intersection , i.e. , the first intersection point is where the line enters the ellipse based on what ` direction ' the line is pointing . the segment area that will be returned from ellipse_segment by passing the line s entry location as the first intersection point is the area within the ellipse to the right of the line s path .",
    "the approach outlined above for finding the overlap area between a line and a general ellipse is implemented in the ellipse_line_overlap algorithm , with pseudo - code shown in list .",
    "[ code2 ] .",
    "the ellipse is passed to the algorithm by specifying the counterclockwise rotation angle @xmath41 and the translation ( @xmath39 , @xmath40 ) that takes a standard ellipse and moves it to the desired orientation , along with the semi - axes lengths , @xmath63 and @xmath64 .",
    "the line is passed to the algorithm as two points on the line , ( @xmath48 , @xmath49 ) and ( @xmath24 , @xmath25 ) .",
    "the ` direction ' of the line is taken to be from ( @xmath48 , @xmath49 ) toward ( @xmath24 , @xmath25 ) .",
    "then , the segment area returned from ellipse_segment will be the area within the ellipse to the right of the line s path .    ....",
    "( area , code ) $ \\leftarrow$ ellipse\\_line\\_overlap ( a , b , h , k,$\\varphi $ , x1,y1,x2,y2 )    do if ( a $ \\le$ 0 or b $ \\le$ 0 )         then return ( -1 , error_ellipse_parameters )      : data_check      do if ( $ |\\varphi|   > 2\\pi $ )         then $ \\varphi \\leftarrow ( \\varphi\\ ;   \\text{modulo}\\ ; 2\\pi ) $ : bring $ \\varphi $ into $ -2\\pi \\le \\varphi < 2\\pi $ ( ? )      do if ( $ |x1| /a > 2\\pi $ )         then x1 $ \\leftarrow$ -a      x10 $ \\leftarrow \\cos(\\varphi ) * ( x1 - h ) + \\sin(\\varphi ) * ( y1 - k)$      y10 $ \\leftarrow -\\sin(\\varphi ) * ( x1 - h ) + \\cos(\\varphi ) * ( y1 - k)$",
    "x20 $ \\leftarrow \\cos(\\varphi)*(x2 - h ) + \\sin(\\varphi ) * ( y2 - k)$      y20 $ \\leftarrow -\\sin(\\varphi ) * ( x2 - h ) + \\cos(\\varphi ) * ( y2 - k)$      do if ( $ |x20 - x10|   > \\varepsilon$ )                             : line is not vertical         then m $ \\leftarrow$ ( y20 - y10)/(x20 - x10 )   : store quadratic coefficients              a $ \\leftarrow$ ( b${}^{2}$ + ( a*m)${}^{2}$)/$a^{2}$              b $ \\leftarrow$ ( 2.0*(y10*m -- $ m^{2}$*x10 ) )              c $ \\leftarrow$ ( y10${}^{2}$ - 2.0*m*y10*x10 + ( m*x10)${}^{2}$ -- b${}^{2}$ )         else if ( |y20 -- y10|   $ > \\varepsilon $ )                 : line is not horizontal              then m $ \\leftarrow$ ( x20 - x10)/(y20 - y10 )     : store quadratic coeffs                   a $ \\leftarrow$ ( a${}^{2}$ +",
    "( b*m)${}^{2}$)/b${}^{2}$                   b $ \\leftarrow$ ( 2.0*(x10*m -- m${}^{2}$*y10 ) )                   c $ \\leftarrow$(x10${}^{2}$ - 2.0*m*y10*x10 + ( m*y10)${}^{2}$ -- a${}^{2}$ )         else return ( -1 , error_line_points )       : line points too $ \\text{close}$      discrim $ \\leftarrow$ b${}^{2}$ - 4.0*a*c      do if ( discrim $ < $ 0.0 )                  : line does not cross ellipse         then return ( 0 , no_intersect )         else if ( discrim $ > $ 0.0 )                 : two intersection points         then root1 $ \\leftarrow$ ( -b - sqrt ( discrim))/(2.0*a )              root2 $ \\leftarrow$ ( -b + sqrt ( discrim))/(2.0*a )         else return ( 0 , tangent )                : line tangent $ \\text{to}$ ellipse      do if ( $ | x20 - x10|   > \\varepsilon $ )                         : roots are x - values         then do if ( x10 $ < $ x20 )         : order pts same as line direction                 then x1 $ \\leftarrow$ root1                      x2 $ \\leftarrow$ root2                 else x1",
    "$ \\leftarrow$ root2                      x2 $ \\leftarrow$ root1         else do if ( y10 $ < $ y20 )                       : roots are y - values                 then y1 $ \\leftarrow$ root1        : order pts same as line direction                      y2 $ \\leftarrow$ root2                 else y1 $ \\leftarrow$ root2                      y2 $ \\leftarrow$ root1      ( area , code ) $ \\leftarrow$ ellipse_segment ( a , b , x1,y1,x2,y2 )      do if ( code $ < $ normal_termination )         then return ( -1.0 , code )         else return ( area , two_intersection_points ) ....    an implementation of the ellipse_line_overlap algorithm in c - code is shown in appendix  [ appb ] .",
    "the code compiles under cygwin-1.7.7 - 1 , and returns the following values for the test cases presented above in fig .",
    "[ fig3 ] , with both line ` directions ' :    ....   cc call_el.c ellipse_line_overlap.c ellipse_segment.c -o call_el.exe     ./call_el    calling ellipse_line_overlap.c     area =                     4.07186819 , return_value = 102     reverse : area =            21.06087304 , return_value = 102     sum of ellipse segments =        25.13274123     total ellipse area by pi*a*b =   25.13274123 ....      the method described above for determining the area between a line and an ellipse can be extended to the task of finding the overlap area between two general ellipses .",
    "suppose the two ellipses are defined by their semi - axis lengths , center locations and axis rotation angles .",
    "let the two sets of parameters ( @xmath65 , @xmath66 , @xmath67 , @xmath68 , @xmath69 ) and ( @xmath70 , @xmath71 , @xmath72 , @xmath73 , @xmath74 ) define the two ellipses for which overlap area is sought .",
    "the approach presented here will be to first translate both ellipses by an amount ( @xmath67 , @xmath68 ) that puts the center of the first ellipse at the origin .",
    "then , both translated ellipses are rotated about the origin by an angle @xmath69 that aligns the axes of the first ellipse with the coordinate axes ; see fig .",
    "intersection points are found for the two translated+rotated ellipses , using ferrari s quartic formula .",
    "finally , the segment algorithm described above is employed to find all the pieces of the overlap area .",
    ".,width=192 ]    for example , consider a case of two general ellipses with two ( non - tangential ) points of intersection , as shown in fig .",
    "the translation+rotation transformations that put the first ellipse at the origin and aligned with the coordinate axes do not alter the overlap area . in the case shown in fig .",
    "[ fig4 ] , the overlap area consists of one segment from the first ellipse and one segment from the second ellipse . the segment algorithm presented above can be used directly for ellipses centered at the origin and aligned with the coordinate axes .",
    "as such , the desired segment from the first ellipse can be found immediately with the segment algorithm , based on the points of intersection . to find the desired segment of the second ellipse , the approach presented here further translates and rotates the second ellipse so that the segment algorithm can also be used directly .",
    "the overlap area for the case shown in fig .",
    "[ fig4 ] is equal to the sum of the two segment areas , as shown in fig .",
    "other cases , e.g. with 3 and 4 points of intersection , can also be handled using the segment algorithm .",
    "the overlap area algorithm presented here finds the area of appropriate sector(s ) of each ellipse , which are demarcated by any points of intersection between the two ellipse curves . to find intersection points ,",
    "the two ellipse equations are solved simultaneously .",
    "this step can be accomplished by using the implicit polynomial forms for each ellipse . the first ellipse equation , in its translated+rotated position is written as an implicit polynomial using the appropriate semi - axis lengths :    @xmath75    in a general form of this problem",
    ", the translation+rotation that puts the first ellipse centered at the origin and oriented with the coordinate axes will typically leave the second ellipse displaced and rotated . the implicit polynomial form for a more general ellipse that is rotated and/or translated away from the origin",
    "is written in the conventional way as :    @xmath76    any points of intersection for the two ellipses will satisfy these two equations simultaneously .",
    "an intermediate goal is to find the implicit polynomial coefficients in ellipse eq .",
    "[ eq2 ] that describe the second ellipse after the translation+rotation that puts the first ellipse centered at the origin and oriented with the coordinate axes .",
    "the parameters that describe the second ellipse after the translation+rotation can be determined from the original parameters for the two ellipses .",
    "the first step is to translate the second ellipse center ( @xmath72 , @xmath73 ) through an amount ( @xmath67 , @xmath68 ) , then rotate the center - point through @xmath69 to give a new center point ( @xmath77 , @xmath78 ) : @xmath79 the coordinates for a point ( @xmath80 , @xmath81 ) on the second ellipse in its new translated+rotated position can be found from the following parametric equations , based on an ellipse with semi - axis lengths @xmath70 and @xmath71 that is centered at the origin , then rotated and translated to the desired position :    @xmath82    to find the implicit polynomial coefficients from the parametric form , further transform the locus of points ( _ _ x__@xmath83 , _ _",
    "y__@xmath83 ) so that they lie on the ellipse ( @xmath70 , @xmath71 , 0 , 0 , 0 ) , which is accomplished by first translating ( @xmath80 , @xmath81 ) through ( (@xmath67  @xmath72 ) , (@xmath68 ",
    "@xmath73 ) ) and then rotating the point through the angle (@xmath69  @xmath74 ) :",
    "@xmath84    the locus of points ( @xmath11 , @xmath12 ) should satisfy the standard ellipse equation with the appropriate semi - axis lengths :    @xmath85    finally , the implicit polynomial coefficients for ellipse eq .  [ eq2 ] are found by substituting the expressions for the point ( @xmath11 , @xmath12 ) into the standard ellipse equation , yielding the following ellipse equation :    @xmath86}^2}{a^2_2}\\\\   + & \\frac{{\\left[{\\sin   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)\\cdot \\left(x_{tr}-\\left(h_1-h_2\\right)\\right)\\ } + { \\cos   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)\\ } \\cdot \\left(y_{tr}-\\left(k_1-k_2\\right)\\right)\\right]}^2}{b^2_2}\\\\ = & 1   \\end{split}\\ ] ]    where ( @xmath87 , @xmath81 ) are defined as above .",
    "expanding the terms , and then re - arranging the order to isolate like terms yields the following expressions for the implicit polynomial coefficients of a general ellipse with the set of parameters ( @xmath70 , @xmath71 , @xmath77 , @xmath78 , @xmath74 ",
    "@xmath69 ) : + @xmath88\\ } } { a^2_2}\\\\ + & \\frac{2\\cdot { \\sin   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)\\cdot \\left[k_{2_{tr}}\\cdot { \\cos   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)\\ } -h_{2_{tr}}\\cdot { \\sin   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)\\ } \\right]\\ } } { b^2_2 } \\\\ ee=&\\frac{-2\\cdot { \\sin   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)\\cdot \\left[h_{2_{tr}}\\cdot { \\cos   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)+k_{2_{tr}}\\cdot { \\sin   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)\\ } \\ } \\right]\\ } } { a^2_2}\\\\ + & \\frac{2\\cdot { \\cos   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)\\cdot \\left[h_{2_{tr}}\\cdot { \\sin   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)\\ } -k_{2_{tr}}\\cdot { \\cos   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)\\ } \\right]\\ } } { b^2_2 } \\\\ ff=&\\frac{{\\left[h_{2_{tr}}\\cdot { \\cos   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)+k_{2_{tr}}\\cdot { \\sin   \\left({\\varphi } _ 2-{\\varphi } _ 1\\right)\\ } \\ } \\right]}^2}{a^2_2}\\\\ + & \\frac{{\\left[h_{2_{tr}}\\cdot { \\sin   \\left({\\varphi } _",
    "2-{\\varphi } _ 1\\right)\\ } -k_{2_{tr}}\\cdot { \\cos   \\left({\\varphi } _ 2-{\\varphi } _",
    "1\\right)\\ } \\right]}^2}{b^2_2}-1 \\end{split}\\ ] ]    for the area overlap algorithm presented in this paper , the points of intersection between the two general ellipses are found by solving simultaneously the two implicit polynomials denoted above as ellipse eq .",
    "[ eq1 ] and ellipse eq .",
    "[ eq2 ] . solving for @xmath11 in the first equation :    @xmath89    substituting these expressions for @xmath11 into ellipse eq .",
    "[ eq2 ] and then collecting terms yields a quartic polynomial in @xmath12 .",
    "it turns out that substituting either the positive or the negative root gives the same quartic polynomial coefficients , which are :    @xmath90\\cdot y^4+cy\\left[3\\right]\\cdot y^3+cy\\left[2\\right]\\cdot y^2+cy\\left[1\\right]\\cdot y+cy\\left[0\\right]=0\\ ] ]    where :    @xmath91}{b_1}=&{a^4_1\\cdot aa}^2+b^2_1\\cdot \\left[a^2_1\\cdot \\left({bb}^2 - 2\\cdot aa\\cdot cc\\right)+b^2_1\\cdot { cc}^2\\right ] \\\\",
    "\\frac{cy\\left[3\\right]}{b_1}=&2\\cdot b_1\\cdot \\left[b^2_1\\cdot cc\\cdot ee+a^2_1\\cdot \\left(bb\\cdot dd - aa\\cdot ee\\right)\\right ] \\\\",
    "\\frac{cy\\left[2\\right]}{b_1}=&a^2_1\\cdot \\left\\{\\left[b^2_1\\cdot \\left(2\\cdot aa\\cdot cc-{bb}^2\\right)+{dd}^2 - 2\\cdot aa\\cdot ff\\right]-2\\cdot { a^2_1\\cdot aa}^2\\right\\}\\\\ + & b^2_1\\cdot \\left(2\\cdot cc\\cdot ff+{ee}^2\\right ) \\\\   \\frac{cy\\left[1\\right]}{b_1}=&2\\cdot b_1\\cdot \\left[a^2_1\\cdot \\left(aa\\cdot ee - bb\\cdot dd\\right)+ee\\cdot ff\\right ] \\\\ \\frac{cy\\left[0\\right]}{b_1}=&\\left[a_1\\cdot \\left(a_1\\cdot aa - dd\\right)+ff\\right]\\cdot \\left[a_1\\cdot \\left(a_1\\cdot aa+dd\\right)+ff\\right ]   \\end{split}\\ ] ]    in theory , the quartic polynomial will have real roots if and only if the two curves intersect .",
    "if the ellipses do not intersect , then the quartic will have only complex roots .",
    "furthermore , any real roots of the quartic polynomial will represent _ y_-values of intersection points between the two ellipse curves . as with the quadratic equation that arises in the ellipse - line overlap calculation",
    ", the ellipse - ellipse overlap algorithm should handle all possible cases for the types of quartic polynomial roots :    1 .",
    "four real roots ( distinct or not ) ; the ellipse curves intersect .",
    "2 .   two real roots ( distinct or not ) and one complex - conjugate pair ; the ellipse curves intersect .",
    "no real roots ( two complex - conjugate pairs ) ; the ellipse curves do not intersect .    for the method we present here ,",
    "polynomial roots are found using ferrari s quartic formula .",
    "a numerical implementation of ferrari s formula is given in @xcite .",
    "for complex roots are returned , and any roots whose imaginary part is returned as zero is a real root .",
    "when the polynomial coefficients are constructed as shown above , the general case of two distinct ellipses typically results in a quartic polynomial , i.e. , the coefficient @xmath92 $ ] is non - zero . however , certain cases lead to polynomials of lesser degree .",
    "fortunately , the solver in @xcite is conveniently modular , providing separate functions biquadroots , cubicroots and quadroots to handle all the possible polynomial cases that arise when seeking points of intersection for two ellipses .    if the polynomial solver returns no real roots to the polynomial , then the ellipse _ curves _ do not intersect .",
    "it follows that the two ellipse _ areas _ are either disjoint , or one ellipse area is fully contained inside the other ; all three possibilities are shown in fig .",
    "each sub - case in fig .",
    "[ fig6 ] requires a different overlap - area calculation , i.e. either the overlap area is zero ( case 0 - 3 ) , or the overlap is the area of the first ellipse ( case 0 - 2 ) , or the overlap is the area of the second ellipse ( case 0 - 1 ) . when the polynomial has no real roots , geometry can be used to determine which specific sub - case of fig .",
    "[ fig6 ] is represented .",
    "an efficient logic starts by determining the relative size of the two ellipses , e.g. , by comparing the product of semi - axis lengths for each ellipse .",
    "the area of an ellipse is proportional to the product of its two semi - axis lengths , so the relative size of two ellipses can be determined by comparing the product of semi - axis lengths : @xmath93    suppose the first ellipse is larger than the second ellipse , then @xmath94 . in this case , if the second ellipse center ( @xmath77 , @xmath78 ) is inside the first ellipse , then the second ellipse is wholly contained within the first ellipse ( case 0 - 1 ) ; otherwise , the ellipses are disjoint ( case 0 - 3 ) .",
    "the logic relies on the fact that there are no intersection points , which is indicated whenever there are no real solutions to the quartic polynomial . to test whether the second ellipse center ( @xmath77 , @xmath78 ) is inside the first ellipse , evaluate the first ellipse equation at the point @xmath95 , and @xmath96",
    "; if the result is less than one , then the point ( @xmath77 , @xmath78 ) is inside the first ellipse . the complete logic for determining overlap area when @xmath97 is :",
    "if the polynomial has no real roots , and @xmath98 , and @xmath99 , then the first ellipse wholly contains the second , otherwise the two ellipses are disjoint .        alternatively , suppose that the second ellipse is larger than the first ellipse , then @xmath100 . if the first ellipse center ( 0 , 0 ) is inside the second ellipse , then the first ellipse is wholly contained within the second ellipse ( case 0 - 2 ) ; otherwise the ellipses are disjoint ( case 0 - 3 ) .",
    "again , the logic relies on the fact that there are no intersection points , to test whether ( 0 , 0 ) is inside the second ellipse , evaluate the second ellipse equation at the origin ; if the result is less than zero , then the origin is inside the second ellipse . the complete logic for determining overlap area when @xmath100 is :",
    "if the polynomial has no real roots , and @xmath100 , and @xmath101 , then the second ellipse wholly contains the first , otherwise the two ellipses are disjoint .",
    "suppose that the two ellipses are the same size , i.e. , @xmath102 . in this case , when no intersection points exist , the ellipses must be disjoint ( case 0 - 3 ) .",
    "it also turns out that the polynomial solver of @xcite will return no real solutions if the ellipses are identical .",
    "this special case is also handled in the overlap area algorithm presented below .",
    "pseudo - code for a function nointpts that determines overlap area for the cases depicted in fig .",
    "[ fig6 ] is shown in fig .",
    "if the polynomial solver returns either two or four real roots to the quartic equation , then the ellipse curves intersect . for the algorithm presented here ,",
    "all of the various possibilities for the number and type of real roots are addressed by creating a list of distinct real roots .",
    "the first step is to loop through the entire array of complex roots returned by the polynomial solver , and retrieve only real roots , i.e. , only those roots whose imaginary component is zero .",
    "the algorithm presented here then sorts the real roots , allowing for an efficient check for multiple roots . as the sorted list of real roots",
    "is traversed , any root that is ` identical ' to the previous root can be skipped .",
    "each distinct real root of the polynomial represents a @xmath12-value where the two ellipses intersect .",
    "each @xmath12-value can represent either one or two potential points of intersection . in the first case ,",
    "suppose that the polynomial root is @xmath103 ( or @xmath104 ) , then the @xmath12-value produces a single intersection point , which is at ( 0 , @xmath66 ) ( or ( 0 , -@xmath66 ) ) . in the second case ,",
    "if the @xmath12-value is in the open interval ( @xmath105 , @xmath66 ) , then there are two potential intersection points where the @xmath12-value is on the first ellipse :    @xmath106    each potential intersection point ( @xmath107 , @xmath108 ) is evaluated in the second ellipse equation :    @xmath109    if the expression evaluates to zero , then the point ( @xmath11 , @xmath12 ) is on both ellipses , i.e. , it is an intersection point . by checking all points ( @xmath11 , @xmath12 ) for each value of @xmath12 that is a root of the polynomial ,",
    "a list of distinct intersection points is generated .",
    "the number of distinct intersection points must be either 0 , 1 , 2 , 3 or 4 .",
    "the case of zero intersection points is described above , with all possible sub - cases illustrated in fig .",
    "if there is only one distinct intersection point , then the two ellipses must be tangent at that point .",
    "the three possibilities for a single tangent point are shown in fig .",
    "[ fig7 ] .        for the purpose of determining overlap area ,",
    "the cases of 0 or 1 intersection points can be handled in the same way .",
    "when two intersection points exist , there are three possible sub - cases , shown in fig .",
    "it is possible that both of the intersection points are tangents ( case 2 - 1 and case 2 - 2 ) . in both of these sub - cases",
    ", one ellipse must be fully contained within the other .",
    "the only other possibility for two intersection points is a partial overlap ( case 2 - 3 ) .",
    "each sub - case in fig .",
    "[ fig8 ] requires a different overlap - area calculation .",
    "when two intersection points exist , either both of the points are tangents , or the ellipse curves cross at both points . specifically , when there are two intersection points , if one point is a tangent , then both points must be tangents . and",
    ", if one point is not a tangent , then neither point is a tangent .",
    "so , it suffices to check one of the intersection points for tangency .",
    "suppose the ellipses are tangent at an intersection point ; then , points that lie along the first ellipse on either side of the intersection will lie in the same region of the second ellipse ( inside or outside ) . that is , if two points are chosen that lie on the first ellipse , one on each side of the intersection , then both points will either be inside the second ellipse , or they will both be outside the second ellipse .",
    "if the ellipse curves cross at the intersection point , then the two chosen points will be in different regions of the second ellipse .",
    "a logic based on testing points that are adjacent to a tangent point can be implemented numerically to test whether an intersection point is a tangent or a cross - point . starting with an intersection point ( @xmath11 , @xmath12 ) ,",
    "calculate the parametric angle on the first ellipse , by the rules in table  [ tab1 ] :    @xmath110    a small perturbation angle is then calculated . for the method presented here ,",
    "we seek to establish an angle that corresponds to a point on the first ellipse that is a given distance , approximately @xmath111 , away from the intersection point : @xmath112 the angle @xmath113 is then used with the parametric form of the first ellipse to determine two points adjacent to ( @xmath11 , @xmath12 ) :    @xmath114    each of the points is then evaluated in the second ellipse equation : @xmath115    if the value of @xmath116 is positive , then the point ( @xmath107 , @xmath108 ) is outside the second ellipse .",
    "it follows that the product of the two test - point evaluations @xmath117 will be positive if the intersection point is a tangent , since at a tangent point both test points will be on the same side of the ellipse .",
    "the product of the test - point evaluations will be negative if the two ellipse curves cross at the intersection point , since the test points will be on opposite sides of the ellipse .",
    "the function istanpt implements this logic to check whether an intersection point is a tangent or a cross - point ; pseudo - code is shown in fig .",
    "when there are two intersection points , the istanpt function can be used to differentiate the case 2 - 3 ( fig .  [ fig8 ] ) from the cases 2 - 1 and 2 - 2 .",
    "either of the two known intersection points can be checked with istanpt .",
    "if the intersection point is a tangent , then both of the intersection points must be tangents , so the case is either 2 - 1 or 2 - 2 , and one ellipse must be fully contained within the other . for cases 2 - 1 and 2 - 2 , the geometric logic used for 0 or 1 intersection points can also be used , i.e. , the function nointpts can be used to determine the overlap area for these cases .",
    "if the two ellipse curves cross at the tested intersection point , then the case must be 2 - 3 , representing a partial overlap between the two ellipse areas .    for case 2 - 3 , with partial overlap between the two ellipses ,",
    "the approach for finding overlap area is based on using the two points ( @xmath4 , @xmath49 ) and ( @xmath24 , @xmath25 ) with segment the algorithm ( table 2 ; fig .  [ fig2 ] ) to determine the partial overlap area contributed by each ellipse .",
    "the total overlap area is the sum of the two segment areas .",
    "the two intersection points divide each ellipse into two segment areas ( see fig .  [ fig5 ] ) .",
    "only one sector area from each ellipse contributes to the overlap area .",
    "the segment algorithm returns the area between the secant line and the portion of the ellipse from the first point to the second point traversed in a counter - clockwise direction . for the overlap area calculation",
    ", the two points must be passed to the segment algorithm in the order that will return the correct segment area .",
    "the default order is counter - clockwise from the first point ( @xmath48 , @xmath49 ) to the second point ( @xmath24 , @xmath25 ) .",
    "a check is made to determine whether this order will return the desired segment area .",
    "first , the parametric angles corresponding to ( @xmath48 , @xmath49 ) and ( @xmath24 , @xmath25 ) on the first ellipse are determined , by the rules in table  [ tab1 ] :    @xmath118    @xmath119    then , a point between ( @xmath48 , @xmath49 ) and ( @xmath24 , @xmath25 ) that is on the first ellipse is found :    @xmath120    the point ( @xmath121 , @xmath122 ) is on the first ellipse between ( @xmath48 , @xmath49 ) and ( @xmath24 , @xmath25 ) when travelling counter- clockwise from ( @xmath48 , @xmath49 ) and ( @xmath24 , @xmath25 ) .",
    "if ( @xmath121 , @xmath122 ) is inside the second ellipse , then the desired segment of the first ellipse contains the point ( @xmath121 , @xmath122 ) . in this case",
    ", the segment algorithm should integrate in the default order , counterclockwise from ( @xmath48,@xmath49 ) to ( @xmath24 , @xmath25 ) .",
    "otherwise , the order of the points should be reversed before calling the segment algorithm , causing it to integrate counterclockwise from ( @xmath24 , @xmath25 ) to ( @xmath48 , @xmath49 ) .",
    "the area returned by the segment algorithm is the area contributed by the first ellipse to the partial overlap .",
    "the desired segment from the second ellipse is found in a manner to the first ellipse segment . a slight difference in the approach",
    "is required because the segment algorithm is implemented for ellipses that are centered at the origin and oriented with the coordinate axes ; but , in the general case the intersection points ( @xmath48 , @xmath49 ) and ( @xmath24 , @xmath25 ) lie on the second ellipse that is in a displaced and rotated location .",
    "the approach presented here translates and rotates the second ellipse to the origin so that the segment algorithm can be used .",
    "it suffices to translate then rotate the two intersection points by amounts that put the second ellipse centered at the origin and oriented with the coordinate axes : @xmath123 the new points ( @xmath124 , @xmath125 ) and ( @xmath126 , @xmath127 ) lie on the second ellipse after a translation+rotation that puts the second ellipse at the origin , oriented with the coordinate axes . the new points can be used as inputs to the segment algorithm to determine the overlap area contributed by the second ellipse . as with the first ellipse , the order of the points must be determined so that the segment algorithm returns the appropriate area .",
    "the default order is counter - clockwise from the first point ( @xmath124 , @xmath125 ) to the second point ( @xmath126 , @xmath127 ) .",
    "a check is made to determine whether this order will return the desired segment area .",
    "first , the parametric angles corresponding to points ( @xmath124 , @xmath125 ) and ( @xmath126 , @xmath127 ) on the second ellipse are determined , by the rules in table  [ tab1 ] :    @xmath128    @xmath129    then , a point on the second ellipse between ( @xmath124 , @xmath125 ) and ( @xmath126 , @xmath127 ) is found :    @xmath130    the point ( @xmath121 , @xmath122 ) is on the second ellipse between ( @xmath124 , @xmath125 ) and ( @xmath126 , @xmath127 ) when travelling counter- clockwise from ( @xmath124 , @xmath125 ) and ( @xmath126 , @xmath127 ) . the new point ( _ _ x__@xmath131 , _ _",
    "y__@xmath131 ) lies on the centered second ellipse . to determine the desired segment of the second ellipse , the new point ( @xmath121 , @xmath122 )",
    "must be rotated then translated back to a corresponding position on the once - translated+rotated second ellipse :    @xmath132    if ( @xmath133 , @xmath134 ) is inside the first ellipse , then the desired segment of the second ellipse contains the point ( @xmath121 , @xmath122 ) . in this case , the segment algorithm should integrate in the default order , counterclockwise from ( @xmath124 , @xmath125 ) to ( @xmath126 , @xmath127 ) .",
    "otherwise , the order of the points should be reversed before calling the segment algorithm , causing it to integrate counterclockwise from ( @xmath126 , @xmath127 ) to ( @xmath124 , @xmath125 ) .",
    "the area returned by the segment algorithm is the area contributed by the second ellipse to the partial overlap .",
    "the sum of the segment areas from the two ellipses is then equal to the ellipse overlap area .",
    "the twointpts function calculates the overlap area for partial overlap with two intersection points ( case 2 - 3 ) ; pseudo - code is shown in fig .",
    "there are two possible sub - cases for three intersection points , shown in fig .",
    "one of the three points must be a tangent point , and the ellipses must cross at the other two points .",
    "the cases are distinct only in the sense that the tangent point occurs with ellipse 2 on the interior side of ellipse 1 ( case 3 - 1 ) , or with ellipse 2 on the exterior side of ellipse 1 ( case 3 - 2 ) .",
    "the overlap area calculation is performed in the same manner for both cases , by calling the twointpts function with the two cross - point intersections .",
    "the istanpt function can be used to determine which point is a tangent ; the remaining two intersection points are then passed to twointpts . this logic is implemented in the threeintpts function , with pseudo - code in fig .",
    "there is only one possible case for four intersection points , shown in fig .",
    "the two ellipse curves must cross at all four of the intersection points , resulting in a partial overlap .",
    "the overlap area consists of two segments from each ellipse , and a central convex quadrilateral . for the approach presented here ,",
    "the four intersection points are sorted ascending in a counter - clockwise order around the first ellipse .",
    "the ordered set of intersection points is ( @xmath48 , @xmath49 ) , ( @xmath24 , @xmath25 ) , ( @xmath135 , @xmath136 ) and ( @xmath137 , @xmath138 ) . the ordering allows a direct calculation of the quadrilateral area .",
    "the standard formula uses the cross - product of the two diagonals : @xmath139    the point ordering also simplifies the search for the appropriate segments of each ellipse that contribute to the overlap area .",
    "suppose that the first two sorted points ( @xmath48 , @xmath49 ) and ( @xmath24 , @xmath25 ) demarcate a segment of the first ellipse that contributes to the overlap area , as shown in fig .",
    "[ fig9 ] and fig .",
    "[ fig10 ] .",
    "it follows that the contributing segments from the first ellipse are between ( @xmath48 , @xmath49 ) and ( @xmath24 , @xmath25 ) , and also between ( @xmath135 , @xmath136 ) and ( @xmath137 , @xmath138 ) . in this case , the contributing segments from the second ellipse are between ( @xmath24 , @xmath25 ) and ( @xmath135 , @xmath136 ) , and between ( @xmath137 , @xmath138 ) and ( @xmath48 , @xmath49 ) . to determine which segments contribute to the overlap area , it suffices to test whether a point midway between ( @xmath48 , @xmath49 ) and ( @xmath24 , @xmath25 ) is inside or outside the second ellipse .",
    "the segment algorithm is used for each of the four areas , and added to the quadrilateral to obtain the total overlap area .",
    "an implementation of the ellipse_ellipse_overlap algorithm in c - code is shown in appendix[appc ] .",
    "the code compiles under cygwin-1.7.7 - 1 , and returns the following values for the test cases presented above in fig .",
    "[ fig6 ] , fig .",
    "[ fig7 ] , fig .",
    "[ fig8 ] and fig .",
    "[ fig9 ] :    ....   cc call\\_ee.c ellipse\\_ellipse\\_overlap.c -o call\\_ee.exe     ./call\\_ee     calling ellipse\\_ellipse\\_overlap.c         case 0 - 1 : area =       6.28318531 , return_value = 111               ellipse 2 area by pi*a2*b2 =       6.28318531     case 0 - 2 : area =       6.28318531 , return_value = 110               ellipse 1 area by pi*a1*b1 =       6.28318531     case 0 - 3 : area =       0.00000000 , return_value = 103               ellipses are disjoint , ovelap area = 0.0         case 1 - 1 : area =       6.28318531 , return_value = 111               ellipse 2 area by pi*a2*b2 =       6.28318531     case 1 - 2 : area =       6.28318531 , return_value = 110               ellipse 1 area by pi*a1b1 =       6.28318531     case 1 - 3 : area =      -0.00000000 , return_value = 107               ellipses are disjoint , ovelap area = 0.0         case 2 - 1 : area =      10.60055478 , return_value = 109               ellipse 2 area by pi*a2*b2 =      10.60287521     case 2 - 2 : area =       6.28318531 , return_value = 110               ellipse 1 area by pi*a1b1 =       6.28318531     case 2 - 3 : area =       3.82254574 , return_value = 107         case 3 - 1 : area =       7.55370392 , return_value = 107     case 3 - 2 : area =       5.67996234 , return_value = 107         case 4 - 1 : area =      16.93791852 , return_value = 109 ....    ....    ( area , code ) $ \\leftarrow$ ellipse_ellipse_overlap ( a1,b1,h1,k1,$\\varphi $ 1,a2,b2,h2,k2,$\\varphi $ 2 )     do if ( a1 = 0 or b1 = 0 ) or ( a2 = 0 or b2 = 0 )        then return ( -1 , error_ellipse_parameters )            : data check     do if ( $ |\\varphi 1|   >",
    "2\\pi $ )        then $ \\varphi 1 \\leftarrow ( \\varphi 1 \\text{modulo}\\ , 2\\pi $ )     do if ( $ |\\varphi 2|   >",
    "2\\pi $ )        then $ \\varphi 2 \\leftarrow ( \\varphi 2 \\text{modulo}\\ , 2\\pi $ )     h2_tr $ \\leftarrow$ ( h2 - h1)*cos ( $ \\varphi 1 $ ) + ( k2 - k1)*sin ( $ \\varphi 1 $ )      : trans+rot ell2     k2_tr $ \\leftarrow$ ( h1 - h2)*sin ( $ \\varphi 1 $ ) + ( k2 - k1)*cos ( $ \\varphi 1 $ )     $ \\varphi 2r$ $ \\leftarrow$ $ \\varphi 2 $ -- $ \\varphi 1 $     do if ( $ |\\varphi 2r| > 2\\pi $ )        then $ \\varphi 2r \\leftarrow ( \\varphi 2r modulo 2\\pi $ )     aa $ \\leftarrow$ cos${}^{2}$($\\varphi $ 2r)/a2${}^{2}$ + sin${}^{2}$($\\varphi $ 2r)/b2${}^{2}$      : build\\ , $ \\text{implicit}$\\ , coeffs ell2tr     bb $ \\leftarrow$ 2*cos ( $ \\varphi $ 2r)*sin ( $ \\varphi $ 2r)/a2${}^{2}$ -- 2*cos ( $ \\varphi $ 2r)*sin ( $ \\varphi $ 2r)/b2${}^{2}$     cc $ \\leftarrow$ sin${}^{2}$($\\varphi $ 2r)/a2${}^{2}$ + cos${}^{2}$($\\varphi $ 2r)/b2${}^{2}$     dd $ \\leftarrow$ -2*cos ( $ \\varphi $ 2r)*(cos ( $ \\varphi $ 2r)*h2_tr + sin ( $ \\varphi $ 2r)*k2_tr)/a2${}^{2}$          - 2*sin ( $ \\varphi $ 2r)*(sin ( $ \\varphi $ 2r)*h2_tr - cos ( $ \\varphi $ 2r)*k2_tr)/b2${}^{2}$    ee $ \\leftarrow$ -2*sin ( $ \\varphi $ 2r ) * ( cos ( $ \\varphi $ 2r)*h2_tr + sin ( $ \\varphi $ 2r)*k2_tr)/a2${}^{2}$          + 2*cos ( $ \\varphi $ 2r ) * ( sin ( $ \\varphi $ 2r)*h2_tr - cos ( $ \\varphi $ 2r)*k2_tr)/b2${}^{2}$    ff $ \\leftarrow$ ( -cos ( $ \\varphi",
    "$ 2r)*h2_tr - sin ( $ \\varphi $ 2r)*k2_tr)${}^{2}$/a2${}^{2}$           + ( sin ( $ \\varphi $ 2r)*h2_tr - cos ( $ \\varphi $ 2r)*k2_tr)${}^{2}$/b2${}^{2}$ - 1        : build quartic polynomial coefficients from the two ellipse eqns     cy[4 ] $ \\leftarrow$ a1${}^{4}$*aa${}^{2}$ + b1${}^{2}$*(a1${}^{2}$*(bb${}^{2}$ - 2*aa*cc)+ b1${}^{2}$*cc${}^{2}$ )     cy[3 ] $ \\leftarrow$ 2*b1*(b1${}^{2}$*cc*ee + a1${}^{2}$*(bb*dd - aa*ee ) )     cy[2 ] $ \\leftarrow$ a1${}^{2}$*((b1${}^{2}$*(2*aa*cc -- bb${}^{2}$ ) + dd${}^{2}$ - 2*aa*ff )             -2*a1${}^{2}$*aa${}^{2}$ + b1${}^{2}$*(2*cc*ff + ee${}^{2}$ )     cy[1 ] $ \\leftarrow$ 2*b1*(a1${}^{2}$*(aa*ee -- bb*dd ) + ee*ff )     cy[0 ] $ \\leftarrow$ ( a1*(a1*aa",
    "--dd ) + ff)*(a1*(a1*aa + dd ) + ff )     py[0 ] $ \\leftarrow$ 1     do if ( $ |cy[4]|>$ 0 )                                : solve quartic eq        then for i $ \\leftarrow$ 0 to 3 by 1                py[4-i ] $ \\leftarrow$ cy[i]/cy[4 ]             r[][]$\\leftarrow$ biquadroots ( py [ ] )             nroots $ \\leftarrow$ 4        else if ( $ |cy[3]|   > 0 $ )                             : solve cubic eq        then for i $ \\leftarrow$ 0 to 2 by 1                py[3-i ] $ \\leftarrow$ cy[i]/cy[3 ]             r [ ] [ ] $ \\leftarrow$ cubicroots ( py [ ] )             nroots $ \\leftarrow$ 3        else if ( $ |cy[2]| > 0 $ )                         : solve quadratic eq        then for i $ \\leftarrow$ 0 to 1 by 1                py[2-i ] $ \\leftarrow$ cy[i]/cy[2 ]             r [ ] [ ] $ \\leftarrow$ quadroots ( py [ ] )             nroots $ \\leftarrow$ 2        else if ( $ |cy[1]| > 0 $ )                            : solve linear eq        then r[1][1 ] $ \\leftarrow$ ( -cy[0]/cy[1 ] )             r[2][1 ] $ \\leftarrow$ 0             nroots $ \\leftarrow$ 1        else                                    : completely degenerate eq             nroots $ \\leftarrow$ 0     nychk $ \\leftarrow$ 0                                       : identify $ \\text{real}$ roots     for i $ \\leftarrow$ 1 to nroots by 1        do if ( $ |r[2][i]| < \\text{eps}$ )           then nychk $ \\leftarrow$ nychk + 1                ychk[nychk ] $ \\leftarrow$ r[1][i]*b1     for j $ \\leftarrow$ 2 to nychk by 1                             : sort $ \\text{real}$ roots        tmp0 $ \\leftarrow$ ychk[j ]        for k $ \\leftarrow$ ( j -- 1 ) to 1 by -1           do if ( ychk[k ] = tmp0 )              then break              else ychk[k+1 ] $ \\leftarrow$ ychk[k ]        ychk[k+1 ] $ \\leftarrow$ tmp0     nintpts $ \\leftarrow$ 0                                : find intersection points     for i $ \\leftarrow$ 1 to nychk by 1        do if ( ( $ i > 1 $ ) and ( $ |ychk[i ] - ychk[i-1]|<$ eps/2 ) )           then continue        do if ( $ |ychk[i]|>$ -b1 )           then x1 $ \\leftarrow$ 0           else x1$\\leftarrow$ ?",
    "a1*sqrt ( 1.0 - ychk[i]${}^{2}$/b1${}^{2}$ )        x2 $ \\leftarrow$ -x1        do if ( $ |ellipse2tr ( x1,ychk[i],aa , bb , cc , dd , ee , ff)|<$ eps/2 )           then nintpts $ \\leftarrow$ nintpts + 1                do if ( nintpts $ > $ 4 )                   then return ( -1 , error_intersection_pts )                xint[nintpts ] $ \\leftarrow$ x1                yint[nintpts ] $ \\leftarrow$ ychk[i ]        do if ( ( $ |ellipse2tr ( x2 , ychk[i],aa , bb , cc , dd , ee , ff)|<$ eps/2 )           and ( $ |x2 - x1|   > $ eps/2 ) )           then nintpts $ \\leftarrow$ nintpts + 1                do if ( nintpts $ > $ 4 )                   then return ( -1 , error_intersection_pts )                xint[nintpts ] $ \\leftarrow$ x1                yint[nintpts ] $ \\leftarrow$ ychk[i ]     switch ( nintpts )         : handle all cases for \\ # of intersection pts        case 0 :        case 1 :           ( overlaparea , code ) $ \\leftarrow$ nointpts ( a1,b1,a2,b2,h1,k1,h2,k2,aa ,               bb , cc , dd , ee , ff )           return ( overlaparea , code )        case 2 :           code $ \\leftarrow$ istanpt ( xint[1],yint[1],a1,b1,aa , bb , cc , dd , ee , ff )           do if ( code = = tangent_point )              then ( overlaparea , code ) $ \\leftarrow$ nointpts ( a1,b1,a2,b2,h1,k1 ,                       h2,k2,aa , bb , cc , dd , ee , ff )              else ( overlaparea , code ) $ \\leftarrow$ twointpts ( xint[],yint[],a1 ,                    phi_1,a2,b2,h2_tr , k2_tr , phi_2,aa , bb , cc , dd , ee , ff )           return ( overlaparea , code )        case 3 :           ( overlaparea , code ) $ \\leftarrow$ threeintpts ( xint , yint , a1,b1,phi_1 ,               a2,b2,h2_tr , k2_tr , phi_2,aa , bb , cc , dd , ee , ff )           return ( overlaparea , code )        case 4 :           ( overlaparea , code ) $ \\leftarrow$ fourintpts ( xint , yint , a1,b1,phi_1 ,                a2 , b2,h2_tr , k2_tr , phi_2,aa , bb , cc , dd , ee , ff )           return ( overlaparea , code ) ....    ....     ( overlaparea , code ) $ \\leftarrow$ nointpts ( a1,b1,a2,b2,h1,k1,h2_tr , k2_tr , aa ,                                    bb , cc , dd , ee , ff )      relsize $ \\leftarrow$ a1*b1 - a2*b2      do if ( relsize $ > $ 0 )         then do if ( ( ( h2_tr*h2_tr)/(a1*a1)+(k2_tr*k2_tr)/(b1*b1 ) ) $ < $ 1.0 )                 then return ( $ \\pi $ * a2*b2,ellipse2_inside_ellipse1 )                 else return ( 0 , disjoint_ellipses )         else do if ( relsize $ < $ 0 )                 then do if ( ff $ < $ 0 )                         then return ( $ \\pi $ * a1*b1,ellipse1_inside_ellipse2 )                         else return ( 0 , disjoint_ellipses )         else do if ( ( h1 = h2_tr ) and ( k1 = k2_tr ) )                 then return ( $ \\pi $ * a1*b1 , ellipses_are_identical )                 else return ( -1 , error_calculations ....    ....   ( overlaparea , code ) $ \\leftarrow$ twointpts ( xint[],yint[],a1,b1,$\\varphi $ 1,a2,b2,h2_tr ,                                     k2_tr,$\\varphi $ 2,aa , bb , cc , dd , ee , ff )    do if ( $ |x[1]|>$ a1 )                       : avoid inverse trig errors       then do if ( x[1 ] $ < $ 0 )               then x[1 ] $ \\leftarrow$ -a1               else x[1 ] $ \\leftarrow$ a1    do if ( y[1 ] $ < $ 0 )             : find parametric angle for ( x[1 ] , y[1 ] )       then $ \\theta $ 1 $",
    "\\leftarrow$ 2$\\pi $ -- arccos ( x[1]/a1 )       else $ \\theta $ 1 $ \\leftarrow$ arccos ( x[1]/a1 )    do if ( $ |x[2]|>$ a1 )                       : avoid inverse trig errors       then do if ( x[2 ] $ < $ 0 )               then x[2 ] $ \\leftarrow$ -a1               else x[2 ] $ \\leftarrow$ a1    do if ( y[2 ] $ < $ 0 )             : find parametric angle for ( x[2 ] , y[2 ] )       then $ \\theta $ 2 $ \\leftarrow$ 2$\\pi $ -- arccos ( x[2]/a1 )       else $ \\theta $ 2 $ \\leftarrow$ arccos ( x[2]/a1 )    do if ( $ \\theta $ 1 $ > $ $ \\theta $ 2 )                                : $ \\text{go}$ ccw from $ \\theta $ 1 $ \\text{to}$\\ , $ \\theta $ 2       then tmp $ \\leftarrow$ $ \\theta $ 1 , $ \\theta $ 1 $ \\leftarrow$ $ \\theta $ 2 , $ \\theta $ 2 $ \\leftarrow$ tmp    xmid $ \\leftarrow$ a1*cos ( ( $ \\theta $ 1 + $ \\theta $ 2)/2 )    ymid $ \\leftarrow$ b1*sin ( ( $ \\theta $ 1 + $ \\theta $ 2)/2 )    do if ( aa*xmid${}^{2}$+bb*xmid*ymid+cc*ymid${}^{2}$+dd*xmid+ee*ymid+ff $ > $ 0 )       then tmp $ \\leftarrow$ $ \\theta $ 1 , $ \\theta $ 1$\\leftarrow$ $ \\theta $ 2 , $ \\theta $ 2 $ \\leftarrow$ tmp    do if ( $ \\theta $ 1 $ > $ $ \\theta $ 2 )                     : segment algorithm for ellipse 1       then $ \\theta $ 1 ? $ \\theta $ 1 - 2$\\pi $    do if ( ( $ \\theta $ 2 - $ \\theta $ 1 ) $ > $ $ \\pi $ )       then trsign $ \\leftarrow$ 1       else trsign $ \\leftarrow$ -1    area1 $ \\leftarrow$ ( a1*b1*($\\theta $ 2 - $ \\theta $ 1 ) + trsign*\\textbar x[1]*y[2 ] - x[2]*y[1])\\textbar /2    x1\\_tr $ \\leftarrow$ ( x[1 ] - h2\\_tr)*cos($\\varphi $ 1 -- $ \\varphi $ 2 ) + ( y[1 ] - k2\\_tr)*sin($\\varphi $ 2 -- $ \\varphi $ 1 )    y1\\_tr $ \\leftarrow$ ( x[1 ] - h2\\_tr)*sin($\\varphi $ 1 -- $ \\varphi $ 2 ) + ( y[1 ] - k2\\_tr)*cos($\\varphi $ 1 -- $ \\varphi $ 2 )    x2\\_tr $ \\leftarrow$ ( x[2 ] - h2\\_tr)*cos($\\varphi $ 1 -- $ \\varphi $ 2 ) + ( y[2 ] - k2\\_tr)*sin($\\varphi $ 2 -- $ \\varphi $ 1 )    y2\\_tr ?",
    "( x[2 ] - h2\\_tr)*sin($\\varphi $ 1 -- $ \\varphi $ 2 ) + ( y[2 ] - k2\\_tr)*cos($\\varphi $ 1 -- $ \\varphi $ 2 )    do if ( $ |x1\\_tr|>$ a2 )                      : avoid inverse trig errors       then do if ( x1_tr $ < $ 0 )               then x1_tr $ \\leftarrow$ -a2               else x1_tr $ \\leftarrow$ a2    do if ( y1_tr $ < $ 0 )           : find parametric angle for ( x1_tr , y1_tr )       then $ \\theta $ 1 $",
    "\\leftarrow$ 2$\\pi $ -- arccos ( x1_tr / a2 )       else $ \\theta $ 1 $ \\leftarrow$ arccos ( x1_tr / a2 )    do if ( $ |x2_tr|>$ a2 )                      : avoid inverse trig errors       then do if ( x2_tr $ < $ 0 )               then x2_tr $ \\leftarrow$ -a2               else x2_tr $ \\leftarrow$ a2    do if ( y2_tr $ < $ 0 )          : find parametric angle for ( x2_tr , y2_tr )       then $ \\theta $ 2 $ \\leftarrow$ 2$\\pi $ -- arccos ( x2_tr / a2 )       else $ \\theta $ 2 $ \\leftarrow$ arccos ( x2_tr / a2 )    do if ( $ \\theta $ 1 $ > $ $ \\theta $ 2 )                                : $ \\text{go}$ ccw from $ \\theta $ 1 $ \\text{to}$\\ , $ \\theta $ 2       then tmp $ \\leftarrow$ $ \\theta $ 1 , $ \\theta $ 1 $ \\leftarrow$ $ \\theta $ 2 , $ \\theta $ 2 $ \\leftarrow$ tmp    xmid $ \\leftarrow$ a2*cos ( ( $ \\theta $ 1 + $ \\theta $ 2)/2 )    ymid $ \\leftarrow$ b2*sin ( ( $ \\theta $ 1 + $ \\theta $ 2)/2 )    xmid_rt = xmid*cos($\\varphi $ 2 -- $ \\varphi $ 1 ) + ymid*sin($\\varphi $ 1 -- $ \\varphi $ 2 ) + h2_tr    ymid_rt = xmid*sin($\\varphi $ 2 -- $ \\varphi $ 1 ) + ymid*cos($\\varphi $ 2 -- $ \\varphi $ 1 ) + k2_tr    do if ( xmid_rt${}^{2}$/a1${}^{2}$ + ymid_rt${}^{2}$/b1${}^{2}$ $ > $ 1 )       then tmp $ \\leftarrow$ $ \\theta $ 1 , $ \\theta $ 1 $ \\leftarrow$",
    "$ \\theta $ 2 , $ \\theta $ 2 $ \\leftarrow$ tmp    do if ( $ \\theta $ 1 $ > $ $ \\theta $ 2 )                     : segment algorithm for ellipse 2       then $ \\theta $ 1 $ \\leftarrow$ $ \\theta $ 1 - 2$\\pi $    do if ( ( $ \\theta $ 2 - $ \\theta $ 1 ) $ > $ $ \\pi $ )        then trsign $ \\leftarrow$ 1        else trsign $ \\leftarrow$ -1    area2 $ \\leftarrow$ ( a2*b2*($\\theta $ 2 - $ \\theta $ 1 )     + trsign*$|x1_tr*y2_tr - x2\\_tr*y1_tr)|$ /2     return ( area1 + area2 , two_intersection_points ) ....    ....   overlaparea , code ) $ \\leftarrow$ threeintpts ( xint[],yint[],a1,b1,$\\varphi $ 1,a2,b2,h2_tr ,                                     k2_tr,$\\varphi $ 2,aa , bb , cc , dd , ee , ff ) tanpts $ \\leftarrow$ 0    for i $ \\leftarrow$ 1 to nychk by 1       code $ \\leftarrow$ istanpt istanpt ( x[i],y[i],a1,b1,aa , bb , cc , dd , ee , ff )       do if ( code = tangent_point )          then tanpts $ \\leftarrow$ tanpts + 1               tanindex $ \\leftarrow$ i    do if not ( tanpts = 1 )       then return ( -1 , error_intersection_points )    switch ( tanindex )                    : store the intersection points       case 1 :                        : tangent point is $ \\text{in}$ ( x[1 ] , y[1 ] )          xint[1 ] $ \\leftarrow$ xint[3 ]          yint[1 ] $ \\leftarrow$ yint[3 ]       case 2 :                        : tangent point is $ \\text{in}$ ( x[2 ] , y[2 ] )          xint[2 ] $ \\leftarrow$ xint[3 ]          yint[2 ] $ \\leftarrow$ yint[3 ]    ( overlaparea , code ) $ \\leftarrow$ twointpts ( xint[],yint[],a1,b1,$\\varphi $ 1,a2,b2,h2_tr ,                                     k2_tr,$\\varphi $ 2,aa , bb , cc , dd , ee , ff )    return ( overlaparea , three_intersection_points ) ....    .... verlaparea , code ) $ \\leftarrow$ fourintpts ( xint[],yint[],a1,b1,$\\varphi $ 1,a2,b2,h2_tr ,                                   k2_tr,$\\varphi $ 2,aa , bb , cc , dd , ee , ff )     for i $ \\leftarrow$ 1 to 4 by 1                       : avoid inverse trig errors        do if ( $ |xint[i]|>$ a1 )           then do if ( xint[i ] $ < $ 0 )                   then xint[i ] $ \\leftarrow$ -a1                   else xint[i ] $ \\leftarrow$ a1        do if ( yint[i ] $ < $ 0 )                       : find parametric angles           then $ \\theta $ [ i ] $ \\leftarrow$ 2$\\pi $ -- arccos ( xint[i]/a1 )           else $ \\theta",
    "$ [ i ] $ \\leftarrow$ arccos ( xint[i]/a1 )     for j $ \\leftarrow$ 2 to 4 by 1                         : put points $ \\text{in}$ ccw order        tmp0 $ \\leftarrow$ $ \\theta $ [ j ]        tmp1 $ \\leftarrow$ xint[j ]        tmp2 $ \\leftarrow$ yint[j ]        for k $ \\leftarrow$ ( j-1 ) to 1 by -1                 : insertion sort by angle           do if ( $ \\theta $ [ k ]",
    "$ < $ = tmp0 )              then break              else $ \\theta $ [ k+1 ] $ \\leftarrow$ $ \\theta $ [ k ]                   xint[k+1 ] $ \\leftarrow$ xint[k ]                   yint[k+1 ] $ \\leftarrow$ yint[k ]     area1 $ \\leftarrow$ ( |(xint[3 ] -- xint[1])*(yint[4 ] -- yint[2 ] ) --     xint[4 ] - xint[2])*(yint[3 ] -- yint[1])| /2 )     : quad area     for i $ \\leftarrow$ 1 to 4 by 1                      : translate+rotate ellipse 2        xint_tr[i ] $ \\leftarrow$ ( xint[i ] -- h2_tr)*cos ( $ \\varphi $ 1 -- $ \\varphi $ 2 )          + ( yint[i ] -- k2_tr)*sin ( $ \\varphi $ 2 -- $ \\varphi $ 1 )        yint_tr[i ] $ \\leftarrow$ ( xint[i ] -- h2_tr)*sin ( $ \\varphi $ 1 -- $ \\varphi $ 2 )          + ( yint[i ] -- k2_tr)*cos ( $ \\varphi $ 1 -- $ \\varphi $ 2 )        do if ( $ |xint_tr[i]|>$ a2 )              : avoid inverse trig errors           then do if ( xint_tr[i ] $ < $ 0 )                   then xint_tr[i ] $ \\leftarrow$ -a2                   else xint_tr[i ] $ \\leftarrow$ a2        do",
    "if ( yint_tr[i ] $ < $ 0 ) : find param angles for ( xint_tr , yint_tr )           then $ \\theta $ _ tr[i ] $ \\leftarrow$ 2$\\pi $ -- arccos ( xint_tr[i]/a2 )           else $ \\theta $ _ tr[i ] $ \\leftarrow$ arccos ( xint_tr[i]/a2 )     xmid $ \\leftarrow$ a1*cos ( ( $ \\theta $ 1 + $ \\theta $ 2)/2 )     ymid $ \\leftarrow$ b1*sin ( ( $ \\theta $ 1 + $ \\theta $ 2)/2 )     do if ( aa*xmid${}^{2}$+bb*xmid*ymid+cc*ymid${}^{2}$+dd*xmid+ee*ymid+ff $ < $ 0 )        then area2 = ( a1*b1*($\\theta $ [ 2 ] - $ \\theta $ [ 1 ] )       - |(xint[1]*yint[2 ] - xint[2]*yint[1])|)/2             area3 = ( a1*b1*($\\theta $ [ 4 ] - $ \\theta $ [ 3 ] )       - |(xint[3]*yint[4 ] - xint[4]*yint[3])|)/2             area4 = ( a2*b2*($\\theta $ _ tr[3 ] - $ \\theta $ _ tr[2 ] )       - |(xint\\_tr[2]*yint_tr[3 ] - xint_tr[3]*yint_tr[2])| ) /2             area5 = ( a2*b2*($\\theta $ _ tr[1 ] - $ \\theta $ _ tr[4 ] - twopi ) )       - |(xint_tr[4]*yint_tr[1 ] - xint_tr[1]*yint_tr[4])| /2 )        else area2 = ( a1*b1*($\\theta $ [ 3 ] - $ \\theta $ [ 2 ] )        - |(xint[2]*yint[3 ] - xint[3]*yint[2])|)/2             area3 = ( a1*b1*($\\theta $ [ 1 ] - ( $ \\theta $ [ 4 ] - twopi ) )       - |(xint[4]*yint[1 ] - xint[1]*yint[4])|)/2             area4 = ( a2*b2*($\\theta $ _ tr[2 ] - $ \\theta $ _ tr[1 ] )       - |(xint_tr[1]*yint_tr[2 ] - xint_tr[2]*yint_tr[1])|)/2             area5 = ( a2*b2*($\\theta $ _ tr[4 ] - $ \\theta $ _ tr[3 ] )       - |(xint_tr[3]*yint_tr[4 ] - xint_tr[4]*yint_tr[3])|)/2     return ( area1+area2+area3+area4+area5 , four_intersection_points ) ....    ....   code $ \\leftarrow$ istanpt ( x , y , a1,b1,aa , bb , cc , dd , ee , ff )     do if ( $ |x|>$ a1 )                         : avoid inverse trig errors        then do if x $ < $ 0                then x $ \\leftarrow$ -a1                else x $ \\leftarrow$ a1     do if ( y $ < $ 0 )                     : find parametric angle for ( x , y )        then $ \\theta $ $ \\leftarrow$ 2$\\pi $ -- arccos ( x / a1 )        else $ \\theta $ $ \\leftarrow$ arccos ( x / a1 )     branch $ \\leftarrow$ v(x${}^{2}$ + y${}^{2}$ )                    : determine perturbation angle     do if ( branch $ < $ 100*eps )        then eps_radian $ \\leftarrow$ 2*eps        else eps_radian $ \\leftarrow$ arcsin ( 2*eps / branch )     x1 $ \\leftarrow$ a1*cos ( $ \\theta $ + eps_radian )       : create test points on each side",
    "y1 $ \\leftarrow$ b1*cos ( $ \\theta $ + eps_radian )       : of the input point ( x , y )     x2 $ \\leftarrow$ a1*cos ( $ \\theta $ - eps_radian )     y2 $ \\leftarrow$ b1*cos ( $ \\theta $ - eps_radian )     test1 $ \\leftarrow$ aa*x1${}^{2}$+bb*x1*y1+cc*y1${}^{2}$+dd*x1+ee*y1+ff     test2 $ \\leftarrow$ aa*x2${}^{2}$+bb*x2*y2+cc*y2${}^{2}$+dd*x2+ee*y2+ff     do if ( test1*test2 $ > $ 0 )         then return tangent_point         else return intersection_point ....",
    "....       / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *     *     *   function : double ellipse_segment     *     *   purpose :   given the parameters of an ellipse and two points that lie on     *             the ellipse , this function calculates the ellipse segment area      *             between the secant line and the ellipse .",
    "points are input as     *             ( x1 , y1 ) and ( x2 , y2 ) , and the segment area is defined to be      *             between the secant line and the ellipse from the first point     *             ( x1 , y1 ) to the second point ( x2 , y2 ) in the counter - clockwise     *             direction .",
    "*     *   reference : hughes and chraibi ( 2011 ) , calculating ellipse overlap areas     *     *   dependencies : math.h    for calls to trig and absolute value functions       *                 program_constants.h   error message codes and constants     *     *   inputs :    1 .",
    "double a       ellipse semi - axis length in x - direction     *             2 .",
    "double b       ellipse semi - axis length in y - direction      *             3 .",
    "double x1      x - value of the first point on the ellipse     *             4 .",
    "double y1      y - value of the first point on the ellipse      *             5 .",
    "double x2      x - value of the second point on the ellipse      *             6 .",
    "double y2      y - value of the second point on the ellipse      *     *   outputs :   1 .",
    "int * messagecode   stores diagnostic information     *                                  integer codes in program_constants.h     *     *   return :    the value of the ellipse segment area :     *             -1.0 is returned in case of an error with input data     *     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /          //===========================================================================     //== include ansi c system and user - defined header files = = = = = = = = = = = = = = = = = = = =     //===========================================================================     # include \" program_constants.h \"          double ellipse_segment ( double a , double b , double x1 , double y1 , double x2 ,                             double y2 , int * messagecode )     {         double theta1 ;   //-- parametric angle of the first point         double theta2 ;   //-- parametric angle of the second point         double trsign ;   //--",
    "sign of the triangle area         double pi = 2.0 * asin \\eqref{grindeq__1_0 _ } ;    //-- a maximum - precision value of pi         double twopi = 2.0 * pi ;         //-- a maximum - precision value of 2*pi              //--",
    "check the data first",
    "//-- each of the ellipse axis lengths must be positive         if ( ! ( a $ > $ 0.0 ) \\textbar \\textbar   ! ( b $ > $ 0.0 ) )         {             ( * messagecode ) = error_ellipse_parameters ;             return -1.0 ;         }              //-- points must be on the ellipse , within eps , which is defined         //-- in the header file",
    "program_constants.h         if ( ( fabs ( ( x1*x1)/(a*a ) + ( y1*y1)/(b*b ) - 1.0 ) $ > $ eps ) textbar textbar                ( fabs ( ( x2*x2)/(a*a ) + ( y2*y2)/(b*b ) - 1.0 ) $ > $ eps ) )         {             ( * messagecode ) = error_points_not_on_ellipse ;             return -1.0 ;         }                 //-- avoid inverse trig calculation errors : there could be an error          //-- if \\textbar x1/a\\textbar   $ > $ 1.0 or \\textbar x2/a\\textbar   $ > $ 1.0 when calling acos ( )         //-- if execution arrives here , then the point is on the ellipse          //-- within eps .",
    "try to adjust the value of x1 or x2 before giving         //--",
    "up on the area calculation         if ( fabs ( x1)/a $ > $ 1.0 )         {             //-- if execution arrives here , already know that \\textbar x1\\textbar   $ > $ a             if ( ( fabs ( x1 ) - a ) $ > $ eps )             {                 //-- if x1 is not close to a or -a , then give up                 ( * messagecode ) = error\\_inverse\\_trig ;                 return -1.0 ;             }             else             {                 //-- nudge x1 back to a or -a , so acos ( ) will work                 x1 = ( x1 $ < $ 0 ) ?",
    "-a : a ;             }         }              if ( fabs ( x2)/a $ > $ 1.0 )         {             //-- if execution arrives here , already know that \\textbar x2\\textbar   $ > $ a             if ( ( fabs ( x2 ) - a ) $ > $ eps )             {                 //-- if x2 is not close to a or -a , then give up                 ( * messagecode ) = error_inverse_trig ;                 return -1.0 ;             }             else             {                 //--",
    "nudge x2 back to a or -a , so acos ( ) will work                 x2 = ( x2 $ < $ 0 ) ?",
    "-a : a ;             }         }              //-- calculate the parametric angles on the ellipse         //--",
    "the parametric angles depend on the quadrant where each point         //-- is located .",
    "see table 1 in the reference .         if ( y1 $ < $ 0.0 )     //-- quadrant iii or iv             theta1 = twopi - acos ( x1 / a ) ;         else              //-- quadrant i or ii                   theta1 = acos ( x1 / a ) ;                     if ( y2 $ < $ 0.0 )     //--",
    "quadrant iii or iv             theta2 = twopi - acos ( x2 / a ) ;         else              //--",
    "quadrant i or ii                   theta2 = acos ( x2 / a ) ;                 //-- need to start the algorithm with theta1 $ < $ theta2         if ( theta1 $ > $ theta2 )             theta1 -= twopi ;                 //-- if the integration angle is less than pi ,",
    "subtract the triangle         //--",
    "area from the sector , otherwise add the triangle area .         if ( ( theta2 - theta1 ) $ > $ pi )             trsign = 1.0 ;         else             trsign = -1.0 ;                 //-- the ellipse segment is the area between the line and the ellipse ,          //-- calculated by finding the area of the radial sector minus the area          //-- of the triangle created by the center of the ellipse and the two          //-- points .   first term is for the ellipse sector ; second term is for         //-- the triangle between the points and the origin .",
    "area calculation         //-- is described in the reference .",
    "( * messagecode ) = normal_termination ;         return ( 0.5*(a*b*(theta2 - theta1 ) + trsign*fabs ( x1*y2 - x2*y1 ) ) ) ;          } ....",
    "....       / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *     *     *   function : double ellipse_line_overlap     *     *   purpose :   given the parameters of an ellipse and two points on a line ,      *             this function calculates the area between the two curves .   if      *             the line does not cross the ellipse , or if the line is tangent      *             to the ellipse , then this function returns an area of 0.0     *             if the line intersects the ellipse at two points , then the      *             function returns the area between the secant line and the      *             ellipse .   the line is considered to have a direction from     *             the first given point ( x1,y1 ) to the second given point ( x2,y2 )     *             this function determines where the line crosses the ellipse     *             first , and where it crosses second .",
    "the area returned is      *             between the secant line and the ellipse traversed counter-     *             clockwise from the first intersection point to the second     *             intersection point .",
    "*     *   reference : hughes and chraibi ( 2011 ) , calculating ellipse overlap areas     *     *   dependencies : math.h   for calls to trig and absolute value functions       *                 program_constants.h   error message codes and constants     *                 ellipse_segment.c   core algorithm for ellipse segment area     *     *   inputs :    1 .",
    "double phi     ccw rotation angle of the ellipse , radians     *             2 . double a       ellipse semi - axis length in x - direction     *             3 .",
    "double b       ellipse semi - axis length in y - direction     *             4 .",
    "double h       horizontal offset of ellipse center     *             5 .",
    "double k       vertical offset of ellipse center     *             6 .",
    "double x1      x - value of the first point on the line     *             7 .",
    "double y1      y - value of the first point on the line      *             8 .",
    "double x2      x - value of the second point on the line      *             9 .",
    "double y2      y - value of the second point on the line      *     *   outputs :   1 .",
    "int * messagecode   returns diagnostic information     *                                  integer codes in program_constants.h     *     *   return :    the value of the ellipse segment area :     *             -1.0 is returned in case of an error with the data or      *             calculation     *             0.0 is returned if the line does not cross the ellipse , or if     *             the line is tangent to the ellipse     *     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /          //===========================================================================     //== define program constants = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =     //===========================================================================     # include \" program_constants.h \"   //-- error message codes and constants          //===========================================================================     //== dependent functions = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =     //===========================================================================     double textbf{ellipse_segment } ( double a , double b , double x1 , double y1 , double x2 ,                             double y2 , int * messagecode ) ;          double \\textbf{ellipse_line_overlap } ( double phi , double a , double b , double h ,                                  double k , double x1 , double y1 , double x2 ,                                  double y2 , int * messagecode )     \\ {         //=======================================================================         //== define local variables = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =         //=======================================================================         double x10 ;      //-- translated , rotated x - value of the first point          double y10 ;      //-- translated , rotated y - value of the first point         double x20 ;      //--",
    "translated , rotated x - value of the second point         double y20 ;      //-- translated ,",
    "rotated y - value of the second point         double cosphi = textbf{cos } ( phi ) ;   //-- store cos(phi ) to avoid multiple calcs         double sinphi = \\textbf{sin } ( phi ) ;   //-- store sin(phi ) to avoid multiple calcs         double m ;        //-- line slope , calculated from input line slope         double a , b , c ;    //--",
    "quadratic equation coefficients a*x\\^{}2 + b*x + c         double discrim ;    //--",
    "quadratic equationdiscriminant b\\^{}2 - 4*a*c         double x1 , x2 ;     //--",
    "x - values of intersection points         double y1 , y2 ;     //--",
    "y - values of intersection points         double mid_x ;      //-- midpoint of the rotated x - values on the line         double theta1parm ;   //-- parametric angle of first point         double theta2parm ;   //-- parametric angle of second point         double xmidpoint ;    //-- x - value midpoint of secant line         double ymidpoint ;    //-- y - value midpoint of secant line         double root1 , root2 ;   //--",
    "temporary storage variables for roots         double segment_area ;   //--",
    "stores the ellipse segment area             //-- check the data first         //-- each of the ellipse axis lengths must be positive         if ( ! ( a $ > $ 0.0 ) \\textbar \\textbar   ! ( b $ > $ 0.0 ) )         {             ( * messagecode ) = error_ellipse_parameters ;             return -1.0 ;         }              //-- the rotation angle for the ellipse should be between -2pi and 2pi ( ? )         if ( ( \\textbf{fabs } ( phi ) $ > $ ( 2.0*pi ) ) )             phi = \\textbf{fmod } ( phi , twopi ) ;                 //-- for this numerical routine , the ellipse will be translated and         //-- rotated so that it is centered at the origin and oriented with          //-- the coordinate axes .         //--",
    "then , the ellipse will have the implicit ( polynomial ) form of         //--    x\\^{}2/a\\^{}2 + y+2/b\\^{}2 = 1                 //-- for the line , the given points are first translated by the amount         //-- required to put the ellipse at the origin , e.g. , by ( -h , -k ) .           //--",
    "then , the points are rotated by the amount required to orient          //-- the ellipse with the coordinate axes , e.g. , through the angle -phi .",
    "x10 = cosphi*(x1 - h ) + sinphi*(y1 - k ) ;",
    "y10 = -sinphi*(x1 - h ) + cosphi*(y1 - k ) ;",
    "x20 = cosphi*(x2 - h ) + sinphi*(y2 - k ) ;",
    "y20 = -sinphi*(x2 - h ) + cosphi*(y2 - k ) ;                 //-- to determine if the line and ellipse intersect , solve the two         //--",
    "equations simultaneously , by substituting y = y10 + m*(x - x10 )          //-- and x = x10 + mxy*(y - y10 ) into the ellipse equation ,          //-- which results in two quadratic equations in x.",
    "see the reference         //-- for derivations of the quadratic coefficients .                 //--",
    "if the new line is not close to being vertical , then use the          //--",
    "first derivation         if ( \\textbf{fabs } ( x20 - x10 ) $ > $ eps )         {             //--    ( ( b\\^{}2 + a\\^{}2*m\\^{}2)/(a\\^{}2 ) ) * x\\^{}2             //--    2*(y10*m - m\\^{}2*x10 ) * x             //--    ( y10\\^{}2 - 2*m*y10*x10 + m\\^{}2*x10\\^{}2 - b\\^{}2 )",
    "m = ( y20 - y10)/(x20 - x10 ) ;             a = ( b*b + a*a*m*m)/(a*a ) ;             b = 2.0*(y10*m - m*m*x10 ) ;             c = ( y10*y10 - 2.0*m*y10*x10 + m*m*x10*x10 - b*b ) ;         }         //--",
    "if the new line is close to being vertical , then use the          //--",
    "second derivation         else if ( \\textbf{fabs } ( y20 - y10 ) $ > $ eps )         {             //--    ( ( a\\^{}2 + b\\^{}2*m\\^{}2)/(b\\^{}2 ) ) * y\\^{}2             //--    2*(x10*m - m\\^{}2*y10 ) * y             //--    ( x10\\^{}2 - 2*m*y10*x10 + m\\^{}2*y10\\^{}2 - a\\^{}2 )             m = ( x20 - x10)/(y20 - y10 ) ;             a = ( a*a + b*b*m*m)/(b*b ) ;             b = 2.0*(x10*m - m*m*y10 ) ;             c = ( x10*x10 - 2.0*m*y10*x10 + m*m*y10*y10 - a*a ) ;         }         //-- if the two given points on the line are very close together in          //-- both x and y directions , then give up         else         {             ( * messagecode ) = error_line_points ;             return -1.0 ;         }                     //-- once the coefficients for the quadratic equation in x are         //--",
    "known , the roots of the quadratic polynomial will represent          //-- the x- or y - values of the points of intersection of the line          //-- and the ellipse .",
    "the discriminant can be used to discern            //--",
    "which case has occurred for the given inputs :         //--     1 .",
    "$ 0         //--        quadratic has complex conjugate roots .",
    "//--        the line and ellipse do not intersect         //--     2 .",
    "discr = 0         //--",
    "quadratic has one repeated root         //--        the line and ellipse intersect at only one point         //--        i.e. , the line is tangent to the ellipse         //--     3 .",
    "discr $ > $ 0         //--",
    "quadratic has two distinct real roots",
    "//--        the line crosses the ellipse at two points         discrim = b*b - 4.0*a*c ;         if ( discrim $ < $ 0.0 )         {             //-- line and ellipse do not intersect             ( * messagecode ) = no_intersection_points ;             return 0.0 ;         }         else if ( discrim $ > $ 0.0 )         {             //-- two real roots exist , so calculate them             //--",
    "the larger root is stored in root2             root1 = ( -b - \\textbf{sqrt } ( discrim ) ) / ( 2.0*a ) ;             root2 = ( -b + \\textbf{sqrt } ( discrim ) ) / ( 2.0*a ) ;         }         else         {             //--",
    "line is tangent to the ellipse             ( * messagecode ) = line_tangent_to_ellipse ;             return 0.0 ;         }              //-- decide which roots go into which x or y values         if ( \\textbf{fabs } ( x20 - x10 ) $ > $ eps ) //-- roots are x - values         {             //-- order the points in the same direction as x10 -$>$ x20             if ( x10 $ < $ x20 )             {                 x1 = root1 ;                 x2 = root2 ;             }             else             {                 x1 = root2 ;                 x2 = root1 ;             }                  //-- the y - values can be calculated by substituting the             //--",
    "x - values into the line equation y = y10 + m*(x - x10 )             y1 = y10 + m*(x1 - x10 ) ;             y2 = y10 + m*(x2 - x10 ) ;         }         else     //-- roots are y - values         {             //-- order the points in the same direction as y10 -$>$ y20             if ( y10 $ < $ y20 )             {                 y1 = root1 ;                 y2 = root2 ;             }             else             {                 y1 = root2 ;                 y2 = root1 ;             }                  //-- the x - values can be calculated by substituting the             //--",
    "y - values into the line equation x = x10 + m*(y - y10 )             x1 = x10 + m*(y1 - y10 ) ;             x2 = x10 + m*(y2 - y10 ) ;         }                 //-- arriving here",
    "means that two points of intersection have been         //-- found .",
    "pass the ellipse parameters and intersection points to          //--",
    "the ellipse_segment ( ) routine .",
    "segment_area = \\textbf{ellipse_segment } ( a , b , x1 , y1 , x2 , y2 , messagecode ) ;                 //-- the message code will indicate whether the function encountered         //--",
    "any errors         if ( ( * messagecode ) $ < $ 0 )         {             return -1 ;         }         else         {             ( * messagecode ) = two_intersection_points ;             return segment_area ;         }     } ....",
    ".... / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *    *    *   function : double ellipse_ellipse_overlap    *    *   purpose :   given the parameters of two ellipses , this function calculates    *             the area of overlap between the two curves .",
    "if the ellipses are    *             disjoint , this function returns 0.0 ; if one ellipse is contained    *             within the other , this function returns the area of the enclosed    *             ellipse ; if the ellipses intersect , this function returns the    *             calculated area of overlap .",
    "*    *   reference : hughes and chraibi ( 2011 ) , calculating ellipse overlap areas    *    *   dependencies : math.h   for calls to trig and absolute value functions      *                 program_constants.h   error message codes and constants    *    *   inputs :    1 .",
    "double phi_1   ccw rotation angle of first ellipse , radians    *             2 .",
    "double a1      semi - axis length in x - direction first ellipse    *             3 .",
    "double b1      semi - axis length in y - direction first ellipse     *             4 .",
    "double h1      horizontal offset of center first ellipse    *             5 .",
    "double k1      vertical offset of center first ellipse    *             6 .",
    "double phi_2   ccw rotation angle of second ellipse , radians    *             7 .",
    "double a2      semi - axis length in x - direction second ellipse    *             8 .",
    "double b2      semi - axis length in y - direction second ellipse    *             9 .",
    "double h2      horizontal offset of center second ellipse     *            10 .",
    "double k2      vertical offset of center second ellipse    *    *   outputs :   1 .",
    "int * rtncode   returns diagnostic information integer code    *                                  integer codes in program_constants.h    *    *   return :    the calculated value of the overlap area    *             -1 is returned in case of an error with the calculation    *              0 is returned if the ellipses are disjoint    *              pi*a*b of smaller ellipse if one ellipse is contained within    *                     the other ellipse    *    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /        //===========================================================================    //== define program constants = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =    //===========================================================================    # include \" program_constants.h \"   //-- error message codes and constants        //===========================================================================",
    "//== dependent functions = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =    //===========================================================================    double nointpts ( double a1 , double b1 , double a2 , double b2 , double h1 ,                      double k1 , double h2_tr , double k2_tr , double aa , double bb ,                      double cc , double dd , double ee , double ff , int * rtncode ) ;        double twointpts ( double xint [ ] , double yint [ ] , double a1 , double b1 ,                       double phi_1 , double a2 , double b2 , double h2_tr ,                       double k2_tr , double phi_2 , double aa , double bb ,                       double cc , double dd , double ee , double ff , int * rtncode ) ;        double threeintpts ( double xint [ ] , double yint [ ] , double a1 , double b1 ,                         double phi_1 , double a2 , double b2 , double h2_tr ,                         double k2_tr , double phi_2 , double aa , double bb ,                         double cc , double dd , double ee , double ff ,                        int * rtncode ) ;        double fourintpts ( double xint [ ] , double yint [ ] , double a1 , double b1 ,                        double phi_1 , double a2 , double b2 , double h2_tr ,                        double k2_tr , double phi_2 , double aa , double bb ,                        double cc , double dd , double ee , double ff , int * rtncode ) ;        int istanpt ( double x , double y , double a1 , double b1 , double aa , double bb ,                 double cc , double dd , double ee , double ff ) ;        double ellipse2tr ( double x , double y , double aa , double bb ,                        double cc , double dd , double ee , double ff ) ;        //-- functions for solving the quartic equation from netlib / toms    void biquadroots ( double p [ ] , double r[][5 ] ) ;    void cubicroots ( double p [ ] , double r[][5 ] ) ;    void quadroots ( double p [ ] , double r[][5 ] ) ;        //===========================================================================    //== ellipse - ellipse overlap = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =    //===========================================================================    double ellipse_ellipse_overlap ( double phi_1 , double a1 , double b1 ,                                     double h1 , double k1 , double phi_2 ,                                     double a2 , double b2 , double h2 , double k2 ,                                     int * rtncode )    {        //=======================================================================        //== define local variables = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =        //=======================================================================        int i , j , k , nroots , nychk , nintpts , fnrtncode ;        double aa , bb , cc , dd , ee , ff , h2_tr , k2_tr , a22 , b22 , phi_2r ;        double cosphi , cosphi2 , sinphi , sinphi2 , cosphisinphi ;        double tmp0 , tmp1 , tmp2 , tmp3 ;        double cy[5 ] = { 0.0 } , py[5 ] = { 0.0 } , r[3][5 ] = { 0.0 } ;        double x1 , x2 , y12 , y22 ;        double ychk[5 ] = { 0.0 } , xint[5 ] , yint[5 ] ;        double area1 , area2 , overlaparea ;            //=======================================================================",
    "//== data check = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =        //=======================================================================        //--",
    "each of the ellipse axis lengths must be positive        if ( ( ! ( a1 $ > $ 0.0 ) \\textbar \\textbar   ! ( b1 $ > $ 0.0 ) ) \\textbar \\textbar   ( ! ( a2 $ > $ 0.0 ) \\textbar \\textbar   ! ( b2 $ > $ 0.0 ) ) )        {            ( * rtncode ) = error_ellipse_parameters ;            return -1.0 ;        }            //--",
    "the rotation angles should be between -2pi and 2pi ( ? )        if ( ( fabs ( phi_1 ) $ > $ ( twopi ) ) )            phi_1 = fmod ( phi_1 , twopi ) ;        if ( ( fabs ( phi_2 ) $ > $ ( twopi ) ) )            phi_2 = fmod ( phi_2 , twopi ) ;            //=======================================================================",
    "//== determine the two ellipse equations from input parameters = = = = = = = = = =        //=======================================================================        //-- finding the points of intersection between two general ellipses        //-- requires solving a quartic equation .   before attempting to solve the        //--",
    "quartic , several quick tests can be used to eliminate some cases        //-- where the ellipses do not intersect .",
    "optionally , can whittle away        //-- at the problem , by addressing the easiest cases first .            //--",
    "working with the translated+rotated ellipses simplifies the        //-- calculations .",
    "the ellipses are translated then rotated so that the        //--",
    "first ellipse is centered at the origin and oriented with the         //--",
    "coordinate axes .   then , the first ellipse will have the implicit         //-- ( polynomial ) form of",
    "//--    x\\^{}2/a1\\^{}2 + y+2/b1\\^{}2 = 1               //-- for the second ellipse , the center is first translated by the amount        //-- required to put the first ellipse at the origin , e.g. , by ( -h1 , -k1 )          //-- then , the center of the second ellipse is rotated by the amount        //-- required to orient the first ellipse with the coordinate axes , e.g. ,        //-- through the angle -phi_1 .        //--",
    "the translated and rotated center point coordinates for the second        //--",
    "ellipse are found with the rotation matrix , derivations are         //-- described in the reference .",
    "cosphi = cos ( phi_1 ) ;        sinphi = sin ( phi_1 ) ;        h2_tr = ( h2 - h1)*cosphi + ( k2 - k1)*sinphi ;        k2_tr = ( h1 - h2)*sinphi + ( k2 - k1)*cosphi ;        phi_2r = phi_2 - phi_1 ;        if ( ( fabs ( phi_2r ) $ > $ ( twopi ) ) )            phi_2r = fmod ( phi_2r , twopi ) ;                   //--",
    "calculate implicit ( polynomial ) coefficients for the second ellipse        //-- in its translated - by ( -h1 , -h2 ) and rotated - by -phi_1 postion        //--",
    "aa*x^{}2 + bb*x*y + cc*y^{}2 + dd*x + ee*y + ff = 0        //--",
    "formulas derived in the reference        //-- to speed things up , store multiply - used expressions first         cosphi = cos ( phi_2r ) ;        cosphi2 = cosphi*cosphi ;        sinphi = sin ( phi_2r ) ;        sinphi2 = sinphi*sinphi ;        cosphisinphi = 2.0*cosphi*sinphi ;        a22 = a2*a2 ;        b22 = b2*b2 ;        tmp0 = ( cosphi*h2_tr + sinphi*k2_tr)/a22 ;        tmp1 = ( sinphi*h2_tr - cosphi*k2_tr)/b22 ;        tmp2 = cosphi*h2_tr + sinphi*k2_tr ;        tmp3 = sinphi*h2_tr - cosphi*k2_tr ;            //--",
    "implicit polynomial coefficients for the second ellipse        aa = cosphi2/a22 + sinphi2/b22 ;        bb = cosphisinphi / a22 - cosphisinphi / b22 ;        cc = sinphi2/a22 + cosphi2/b22 ;        dd = -2.0*cosphi*tmp0 - 2.0*sinphi*tmp1 ;        ee = -2.0*sinphi*tmp0 + 2.0*cosphi*tmp1 ;        ff = tmp2*tmp2/a22 + tmp3*tmp3/b22 - 1.0 ;                 //=======================================================================        //== create and solve the quartic equation to find intersection points = =        //=======================================================================        //-- if execution arrives here , the ellipses are at least ' close ' to        //-- intersecting .        //-- coefficients for the quartic polynomial in y are calculated from        //-- the two implicit equations .        //--",
    "formulas for these coefficients are derived in the reference .",
    "cy[4 ] = pow ( a1 , 4.0)*aa*aa + b1*b1*(a1*a1*(bb*bb - 2.0*aa*cc )                + b1*b1*cc*cc ) ;        cy[3 ] = 2.0*b1*(b1*b1*cc*ee + a1*a1*(bb*dd - aa*ee ) ) ;        cy[2 ] = a1*a1*((b1*b1*(2.0*aa*cc - bb*bb ) + dd*dd   - 2.0*aa*ff )                        - 2.0*a1*a1*aa*aa ) + b1*b1*(2.0*cc*ff + ee*ee ) ;        cy[1 ] = 2.0*b1*(a1*a1*(aa*ee - bb*dd ) + ee*ff ) ;        cy[0 ] = ( a1*(a1*aa - dd ) + ff)*(a1*(a1*aa + dd ) +",
    "ff ) ;            //-- once the coefficients for the quartic equation in y are known , the        //-- roots of the quartic polynomial will represent y - values of the         //-- intersection points of the two ellipse curves .        //--",
    "the quartic sometimes degenerates into a polynomial of lesser         //--",
    "degree , so handle all possible cases .",
    "if ( fabs ( cy[4 ] ) $ > $ 0.0 )        {            //== quartic coefficient nonzero , use quartic formula = = = = = = = = = = = = = = =            for ( i = 0 ; i $ < $ = 3 ; i++ )                py[4-i ] = cy[i]/cy[4 ] ;            py[0 ] = 1.0 ;                       biquadroots ( py , r ) ;            nroots = 4 ;        }        else if ( fabs ( cy[3 ] ) $ > $ 0.0 )        {            //== quartic degenerates to cubic , use cubic formula = = = = = = = = = = = = = = = =            for ( i = 0 ; i $ <",
    "$ = 2 ; i++ )                py[3-i ] = cy[i]/cy[3 ] ;            py[0 ] = 1.0 ;                cubicroots ( py , r ) ;            nroots = 3 ;        }        else if ( fabs ( cy[2 ] ) $ > $ 0.0 )        {            //== quartic degenerates to quadratic , use quadratic formula = = = = = = = =            for ( i = 0 ; i $ < $ = 1 ; i++ )                py[2-i ] = cy[i]/cy[2 ] ;            py[0 ] = 1.0 ;                quadroots ( py , r ) ;            nroots = 2 ;        }        else if ( fabs ( cy[1 ] ) $ > $ 0.0 )        {            //== quartic degenerates to linear : solve directly = = = = = = = = = = = = = = = = = =            //-- cy[1]*y + cy[0 ] = 0            r[1][1 ] = ( -cy[0]/cy[1 ] ) ;            r[2][1 ] = 0.0 ;            nroots = 1 ;        }        else        {            //== completely degenerate quartic : ellipses identical ? ? ?",
    "= = = = = = = = = = =            //-- a completely degenerate quartic , which would seem to            //-- indicate that the ellipses are identical .   however , some            //-- configurations lead to a degenerate quartic with no            //-- points of intersection .            nroots = 0 ;        }               //=======================================================================        //== check roots of the quartic : are they points of intersection ?",
    "= = = = = = =        //=======================================================================        //--",
    "determine which roots are real , discard any complex roots        nychk = 0 ;        for ( i = 1 ; i $ < $ = nroots ; i++ )        {            if ( fabs ( r[2][i ] ) $ < $ eps )            {                nychk++ ;                ychk[nychk ] = r[1][i]*b1 ;            }        }               //-- sort the real roots by straight insertion        for ( j = 2 ; j $ < $ = nychk ; j++ )        {            tmp0 = ychk[j ] ;                       for ( k = j - 1 ; k $ > $ = 1 ; k-- )            {                if ( ychk[k ] $ < $ = tmp0 )                    break ;                               ychk[k+1 ] = ychk[k ] ;            }                       ychk[k+1 ] = tmp0 ;        }            //-- determine whether polynomial roots are points of intersection        //-- for the two ellipses        nintpts = 0 ;        for ( i = 1 ; i $ < $ = nychk ; i++ )        {            //--",
    "check for multiple roots            if ( ( i $ > $ 1 ) \\&\\ & ( fabs ( ychk[i ] - ychk[i-1 ] ) $ < $ ( eps/2.0 ) ) )                continue ;                //-- check intersection points for ychk[i ]            if ( fabs ( ychk[i ] ) $ > $ b1 )                x1 = 0.0 ;            else                x1 = a1*sqrt ( 1.0 - ( ychk[i]*ychk[i])/(b1*b1 ) ) ;            x2 = -x1 ;                   if ( fabs(ellipse2tr(x1 , ychk[i ] , aa , bb , cc , dd , ee , ff ) ) $ < $ eps/2.0 )            {                nintpts++ ;                if ( nintpts $ > $ 4 )                {                    ( * rtncode ) = error_intersection_pts ;                    return -1.0 ;                }                xint[nintpts ] = x1 ;                yint[nintpts ] = ychk[i ] ;            }                if ( ( fabs(ellipse2tr(x2 , ychk[i ] , aa , bb , cc , dd , ee , ff ) ) $ < $ eps/2.0 )                \\&\\ & ( fabs ( x2 - x1 ) $ > $ eps/2.0 ) )            {                nintpts++ ;                if ( nintpts $ > $ 4 )                {                    ( * rtncode ) = error_intersection_pts ;                    return -1.0 ;                }                xint[nintpts ] = x2 ;                yint[nintpts ] = ychk[i ] ;            }        }            //=======================================================================",
    "//== handle all cases for the number of intersction points = = = = = = = = = = = = = =        //=======================================================================        switch ( nintpts )        {            case 0 :            case 1 :                overlaparea = nointpts ( a1 , b1 , a2 , b2 , h1 , k1 , h2_tr , k2_tr , aa ,                                        bb , cc , dd , ee , ff , rtncode ) ;                return overlaparea ;                           case 2 :                //--",
    "when there are two intersection points , it is possible for                //-- them to both be tangents , in which case one of the ellipses                //--",
    "is fully contained within the other .",
    "check the points for                //-- tangents ; if one of the points is a tangent , then the other                //-- must be as well , otherwise there would be more than 2                 //-- intersection points .",
    "fnrtncode = istanpt ( xint[1 ] , yint[1 ] , a1 , b1 , aa , bb , cc , dd ,                                      ee , ff ) ;                    if ( fnrtncode = = tangent_point )                    overlaparea = nointpts ( a1 , b1 , a2 , b2 , h1 , k1 , h2_tr , k2_tr ,                                            aa , bb , cc , dd , ee , ff , rtncode ) ;                else                    overlaparea = twointpts ( xint , yint , a1 , b1 , phi_1 , a2 , b2 ,                                             h2_tr , k2_tr , phi_2 , aa , bb , cc , dd ,                                             ee , ff , rtncode ) ;                return overlaparea ;                           case 3 :                //-- when there are three intersection points , one and only one                //-- of the points must be a tangent point .                overlaparea = threeintpts ( xint , yint ,   a1 , b1 , phi_1 , a2 , b2 ,                                           h2_tr , k2_tr , phi_2 , aa , bb , cc , dd ,                                            ee , ff , rtncode ) ;                return overlaparea ;                           case 4 :                //-- four intersections points has only one case .                overlaparea = fourintpts ( xint , yint ,   a1 , b1 , phi_1 , a2 , b2 ,                                          h2_tr , k2_tr , phi_2 , aa , bb , cc , dd ,                                           ee , ff , rtncode ) ;                return overlaparea ;                       default :",
    "//-- should never get here ( but get compiler warning for missing                //--",
    "return value if this line is omitted )                ( * rtncode ) = error_intersection_pts ;                return -1.0 ;        }    }        double ellipse2tr ( double x , double y , double aa , double bb ,                        double cc , double dd , double ee , double ff )    {        return ( aa*x*x + bb*x*y + cc*y*y + dd*x + ee*y + ff ) ;    }        double nointpts ( double a1 , double b1 , double a2 , double b2 , double h1 ,                      double k1 , double h2_tr , double k2_tr , double aa , double bb ,                     double cc , double dd , double ee , double ff , int * rtncode )    {        //-- the relative size of the two ellipses can be found from the axis        //-- lengths         double relsize = ( a1*b1 ) - ( a2*b2 ) ;               if ( relsize $ > $ 0.0 )        {            //-- first ellipse is larger than second ellipse .            //--",
    "if second ellipse center ( h2_tr , k2_tr ) is inside            //--",
    "first ellipse , then ellipse 2 is completely inside             //--",
    ". otherwise , the ellipses are disjoint .",
    "if ( ( ( h2_tr*h2_tr ) / ( a1*a1 )                 + ( k2_tr*k2_tr ) / ( b1*b1 ) ) $ < $ 1.0 )            {                ( * rtncode ) = ellipse2_inside_ellipse1 ;                return ( pi*a2*b2 ) ;            }            else            {                ( * rtncode ) = disjoint_ellipses ;                return 0.0 ;            }        }        else if ( relsize $ < $ 0.0 )        {            //--",
    "second ellipse is larger than first ellipse            //-- if first ellipse center ( 0 , 0 ) is inside the            //--",
    "second ellipse , then ellipse 1 is completely inside            //--",
    "ellipse 2 . otherwise , the ellipses are disjoint            //--",
    "aa*x^{}2 + bb*x*y + cc*y\\^{}2 + dd*x + ee*y + ff = 0            if ( ff $ < $ 0.0 )            {                ( * rtncode ) = ellipse1_inside_ellipse2 ;                return ( pi*a1*b1 ) ;            }            else            {                ( * rtncode ) = disjoint_ellipses ;                return 0.0 ;            }        }        else        {            //-- if execution arrives here , the relative sizes are identical .            //--",
    "are the ellipses the same ?",
    "check the parameters to see .            if ( ( h1 = = h2_tr ) \\&\\ & ( k1 = = k2_tr ) )            {                ( * rtncode ) = ellipses_are_identical ;                return ( pi*a1*b1 ) ;            }            else            {                //-- should never get here , so return error                ( * rtncode ) = error_calculations ;                return -1.0 ;            }        } //--",
    "end if ( relsize $ > $ 0.0 )    }        //-- two distinct intersection points ( x1 , y1 ) and ( x2 , y2 ) find overlap area    double twointpts ( double x [ ] , double y [ ] , double a1 , double b1 , double phi_1 ,                       double a2 , double b2 , double h2_tr , double k2_tr ,                       double phi_2 , double aa , double bb , double cc , double dd ,                       double ee , double ff , int * rtncode )    {        double area1 , area2 ;        double xmid , ymid , xmid_rt , ymid_rt ;        double theta1 , theta2 ;        double tmp , trsign ;        double x1_tr , y1_tr , x2_tr , y2_tr ;        double discr ;        double cosphi , sinphi ;            //-- if execution arrives here , the intersection points are not        //--",
    "tangents .               //--",
    "determine which direction to integrate in the ellipse_segment        //--",
    "routine for each ellipse .            //--",
    "find the parametric angles for each point on ellipse 1        if ( fabs ( x[1 ] ) $ > $ a1 )            x[1 ] = ( x[1 ] $ < $ 0 ) ?",
    "-a1 : a1 ;        if ( y[1 ] $ < $ 0.0 )       //-- quadrant iii or iv            theta1 = twopi - acos ( x[1 ] / a1 ) ;        else              //--",
    "quadrant i or ii                  theta1 = acos ( x[1 ] / a1 ) ;                   if ( fabs ( x[2 ] ) $ > $ a1 )            x[2 ] = ( x[2 ] $ < $ 0 ) ?",
    "-a1 : a1 ;        if ( y[2 ] $ < $ 0.0 )       //-- quadrant iii or iv            theta2 = twopi - acos ( x[2 ] / a1 ) ;        else              //-- quadrant",
    "i or ii                  theta2 = acos ( x[2 ] / a1 ) ;            //--",
    "logic is for proceeding counterclockwise from theta1 to theta2        if ( theta1 $ > $ theta2 )        {            tmp = theta1 ;            theta1 = theta2 ;            theta2 = tmp ;        }            //-- find a point on the first ellipse that is different than the two        //-- intersection points .",
    "xmid = a1*cos ( ( theta1 + theta2)/2.0 ) ;          ymid = b1*sin ( ( theta1 + theta2)/2.0 ) ;                 //-- the point ( xmid , ymid ) is on the first ellipse ' between ' the two        //-- intersection points ( x[1 ] , y[1 ] ) and ( x[2 ] , y[2 ] ) when travelling         //--",
    "counter- clockwise from ( x[1 ] , y[1 ] ) to ( x[2 ] , y[2 ] ) .",
    "if the point        //-- ( xmid , ymid ) is inside the second ellipse , then the desired segment        //-- of ellipse 1 contains the point ( xmid , ymid ) , so integrate         //-- counterclockwise from ( x[1 ] , y[1 ] ) to ( x[2 ] , y[2 ] ) .   otherwise ,         //--",
    "integrate counterclockwise from ( x[2 ] , y[2 ] ) to ( x[1 ] , y[1 ] )        if ( ellipse2tr ( xmid , ymid , aa , bb , cc , dd , ee , ff ) $ > $ 0.0 )        {            tmp = theta1 ;            theta1 = theta2 ;            theta2 = tmp ;        }            //-- here is the ellipse segment routine for the first ellipse        if ( theta1 $ > $ theta2 )            theta1 -= twopi ;        if ( ( theta2 - theta1 ) $ > $ pi )            trsign = 1.0 ;        else            trsign = -1.0 ;        area1 = 0.5*(a1*b1*(theta2 - theta1 )                 + trsign*fabs ( x[1]*y[2 ] - x[2]*y[1 ] ) ) ;                //-- find ellipse 2 segment area .   the ellipse segment routine        //-- needs an ellipse that is centered at the origin and oriented        //-- with the coordinate axes .",
    "the intersection points ( x[1 ] , y[1 ] ) and        //-- ( x[2 ] , y[2 ] ) are found with both ellipses translated and rotated by        //-- ( -h1 , -k1 ) and -phi_1 .",
    "further translate and rotate the points        //-- to put the second ellipse at the origin and oriented with the        //--",
    "coordinate axes .",
    "the translation is ( -h2_tr , -k2_tr ) , and the        //-- rotation is -(phi_2 - phi_1 ) = phi_1 - phi_2        cosphi = cos ( phi_1 - phi_2 ) ;",
    "sinphi = sin ( phi_1 - phi_2 ) ;        x1_tr = ( x[1 ] - h2_tr)*cosphi + ( y[1 ] - k2_tr)*-sinphi ;        y1_tr = ( x[1 ] - h2_tr)*sinphi + ( y[1 ] - k2_tr)*cosphi ;        x2_tr = ( x[2 ] - h2_tr)*cosphi + ( y[2 ] - k2_tr)*-sinphi ;        y2_tr = ( x[2 ] - h2_tr)*sinphi + ( y[2 ] - k2_tr)*cosphi ;               //-- determine which branch of the ellipse to integrate by finding a        //-- point on the second ellipse , and asking whether it is inside the        //-- first ellipse ( in their once - translated+rotated positions )        //-- find the parametric angles for each point on ellipse 1        if ( fabs ( x1_tr ) $ > $ a2 )            x1_tr = ( x1_tr $ < $ 0 ) ?",
    "-a2 : a2 ;        if ( y1_tr $ < $ 0.0 )      //-- quadrant iii or iv            theta1 = twopi - acos ( x1_tr / a2 ) ;        else              //-- quadrant i or ii                  theta1 = acos ( x1_tr / a2 ) ;                   if ( fabs ( x2_tr ) $ > $ a2 )            x2_tr = ( x2_tr $ < $ 0 ) ?",
    "-a2 : a2 ;        if ( y2_tr $ < $ 0.0 )      //-- quadrant iii or iv            theta2 = twopi - acos ( x2_tr / a2 ) ;        else              //-- quadrant i or ii                  theta2 = acos ( x2_tr / a2 ) ;            //--",
    "logic is for proceeding counterclockwise from theta1 to theta2        if ( theta1 $ > $ theta2 )        {            tmp = theta1 ;            theta1 = theta2 ;            theta2 = tmp ;        }            //-- find a point on the second ellipse that is different than the two        //-- intersection points .",
    "xmid = a2*cos ( ( theta1 + theta2)/2.0 ) ;          ymid = b2*sin ( ( theta1 + theta2)/2.0 ) ;               //--",
    "translate the point back to the second ellipse in its once-        //--",
    "translated+rotated position        cosphi = cos ( phi_2 - phi_1 ) ;        sinphi = sin ( phi_2 - phi_1 ) ;        xmid_rt = xmid*cosphi + ymid*-sinphi + h2_tr ;        ymid_rt = xmid*sinphi + ymid*cosphi + k2_tr ;            //-- the point ( xmid_rt , ymid_rt ) is on the second ellipse ' between ' the        //-- intersection points ( x[1 ] , y[1 ] ) and ( x[2 ] , y[2 ] ) when travelling        //--",
    "counterclockwise from ( x[1 ] , y[1 ] ) to ( x[2 ] , y[2 ] ) .",
    "if the point        //-- ( xmid_rt , ymid_rt ) is inside the first ellipse , then the desired         //--",
    "segment of ellipse 2 contains the point ( xmid_rt , ymid_rt ) , so         //--",
    "integrate counterclockwise from ( x[1 ] , y[1 ] ) to ( x[2 ] , y[2 ] ) .          //--",
    "otherwise , integrate counterclockwise from ( x[2 ] , y[2 ] ) to         //-- ( x[1 ] , y[1 ] )        if ( ( ( xmid_rt*xmid_rt)/(a1*a1 ) + ( ymid_rt*ymid_rt)/(b1*b1 ) ) $ > $ 1.0 )        {            tmp = theta1 ;            theta1 = theta2 ;            theta2 = tmp ;        }            //-- here is the ellipse segment routine for the second ellipse        if ( theta1 $ > $ theta2 )            theta1 -= twopi ;        if ( ( theta2 - theta1 ) $ > $ pi )            trsign = 1.0 ;        else            trsign = -1.0 ;        area2 = 0.5*(a2*b2*(theta2 - theta1 )                 + trsign*fabs ( x1_tr*y2_tr - x2_tr*y1_tr ) ) ;                ( * rtncode ) = two_intersection_points ;        return area1 + area2 ;    }        //-- three distinct intersection points , must have two intersections    //-- and one tangent , which is the only possibility    double threeintpts ( double xint [ ] , double yint [ ] , double a1 , double b1 ,                         double phi_1 , double a2 , double b2 , double h2_tr ,                         double k2_tr , double phi_2 , double aa , double bb ,                         double cc , double dd , double ee , double ff ,                        int * rtncode )    {        int i , tanpts , tanindex , fnrtn ;        double overlaparea ;            //-- need to determine which point is a tangent , and which two points        //-- are intersections        tanpts = 0 ;        for ( i = 1 ; i $ <",
    "$ = 3 ; i++ )        {            fnrtn = istanpt ( xint[i ] , yint[i ] , a1 , b1 , aa , bb , cc , dd , ee , ff ) ;                if ( fnrtn = = tangent_point )            {                tanpts++ ;                tanindex = i ;            }        }               //-- there must be 2 intersection points and only one tangent        if ( tanpts !",
    "= 1 )        {            //-- should never get here unless there is a problem discerning            //-- whether or not a point is a tangent or intersection            ( * rtncode ) = error_intersection_pts ;            return -1.0 ;        }               //-- store the two interesection points into ( x[1 ] , y[1 ] ) and         //-- ( x[2 ] , y[2 ] )        switch ( tanindex )        {            case 1 :                xint[1 ] = xint[3 ] ;                yint[1 ] = yint[3 ] ;                break ;                case 2 :                xint[2 ] = xint[3 ] ;                yint[2 ] = yint[3 ] ;                break ;                case 3 :                //--",
    "intersection points are already in the right places                break ;        }            overlaparea = twointpts ( xint , yint , a1 , b1 , phi_1 , a2 , b2 , h2_tr , k2_tr ,                                 phi_2 , aa , bb , cc , dd , ee , ff , rtncode ) ;        ( * rtncode ) = three_intersection_points ;        return overlaparea ;    }        //--",
    "four intersection points    double fourintpts ( double xint [ ] , double yint [ ] , double a1 , double b1 ,                        double phi_1 , double a2 , double b2 , double h2_tr ,                        double k2_tr , double phi_2 , double aa , double bb ,                        double cc , double dd , double ee , double ff , int * rtncode )    {        int i , j , k ;        double xmid , ymid , xint_tr[5 ] , yint_tr[5 ] , overlaparea ;        double theta[5 ] , theta_tr[5 ] , cosphi , sinphi , tmp0 , tmp1 , tmp2 ;        double area1 , area2 , area3 , area4 , area5 ;               //-- only one case , which involves two segments from each ellipse , plus        //-- two triangles .        //-- get the parametric angles along the first ellipse for each of the",
    "//-- intersection points        for ( i = 1 ; i $ < $ = 4 ; i++ )        {            if ( fabs ( xint[i ] ) $ > $ a1 )                xint[i ] = ( xint[i ] $ < $ 0 ) ?",
    "-a1 : a1 ;            if ( yint[i ] $ < $ 0.0 )    //-- quadrant iii or iv                theta[i ] = twopi - acos ( xint[i ] / a1 ) ;            else              //-- quadrant i or ii                      theta[i ] = acos ( xint[i ] / a1 ) ;        }                   //-- sort the angles by straight insertion , and put the points in         //-- counter - clockwise order        for ( j = 2 ; j $ < $ = 4 ; j++ )        {            tmp0 = theta[j ] ;            tmp1 = xint[j ] ;            tmp2 = yint[j ] ;                       for ( k = j - 1 ; k $ > $ = 1 ; k-- )            {                if ( theta[k ] $ <",
    "$ = tmp0 )                    break ;                               theta[k+1 ] = theta[k ] ;                xint[k+1 ] = xint[k ] ;                yint[k+1 ] = yint[k ] ;            }                       theta[k+1 ] = tmp0 ;            xint[k+1 ] = tmp1 ;            yint[k+1 ] = tmp2 ;        }               //-- find the area of the interior quadrilateral        area1 = 0.5*fabs ( ( xint[3 ] - xint[1])*(yint[4 ] - yint[2 ] )                         - ( xint[4 ] - xint[2])*(yint[3 ] - yint[1 ] ) ) ;            //-- the intersection points lie on the second ellipse in its once        //--",
    "translated+rotated position .",
    "the segment algorithm is implemented        //-- for an ellipse that is centered at the origin , and oriented with        //--",
    "the coordinate axes ; so , in order to use the segment algorithm        //-- with the second ellipse , the intersection points must be further",
    "//-- translated+rotated by amounts that put the second ellipse centered        //-- at the origin and oriented with the coordinate axes .",
    "cosphi = cos ( phi_1 - phi_2 ) ;        sinphi = sin ( phi_1 - phi_2 ) ;        for ( i = 1 ; i $ < $ = 4 ; i++ )        {            xint_tr[i ] = ( xint[i ] - h2_tr)*cosphi + ( yint[i ] - k2_tr)*-sinphi ;            yint_tr[i ] = ( xint[i ] - h2_tr)*sinphi + ( yint[i ] - k2_tr)*cosphi ;                       if ( fabs ( xint_tr[i ] ) $ > $ a2 )                xint_tr[i ] = ( xint_tr[i ] $ < $ 0 ) ?",
    "-a2 : a2 ;            if ( yint_tr[i ] $ < $ 0.0 )     //-- quadrant iii or iv                theta_tr[i ] = twopi - acos ( xint_tr[i]/a2 ) ;            else              //-- quadrant i or ii                      theta_tr[i ] = acos ( xint_tr[i]/a2 ) ;        }            //-- get the area of the two segments on ellipse 1        xmid = a1*cos ( ( theta[1 ] + theta[2])/2.0 ) ;          ymid = b1*sin ( ( theta[1 ] + theta[2])/2.0 ) ;               //--",
    "the point ( xmid , ymid ) is on the first ellipse ' between ' the two        //-- sorted intersection points ( xint[1 ] , yint[1 ] ) and ( xint[2 ] , yint[2 ] )        //-- when travelling counter- clockwise from ( xint[1 ] , yint[1 ] ) to         //--",
    "( xint[2 ] , yint[2 ] ) .   if the point ( xmid , ymid ) is inside the second         //--",
    "ellipse , then one desired segment of ellipse 1 contains the point         //--",
    "( xmid , ymid ) , so integrate counterclockwise from ( xint[1 ] , yint[1 ] )        //-- to ( xint[2 ] , yint[2 ] ) for the first segment , and from         //-- ( xint[3 ] , yint[3 ] to ( xint[4 ] , yint[4 ] ) for the second segment .",
    "if ( ellipse2tr ( xmid , ymid , aa , bb , cc , dd , ee , ff ) $ < $ 0.0 )        {            area2 = 0.5*(a1*b1*(theta[2 ] - theta[1 ] )                    - fabs ( xint[1]*yint[2 ] - xint[2]*yint[1 ] ) ) ;            area3 = 0.5*(a1*b1*(theta[4 ] - theta[3 ] )                    - fabs ( xint[3]*yint[4 ] - xint[4]*yint[3 ] ) ) ;            area4 = 0.5*(a2*b2*(theta_tr[3 ] - theta_tr[2 ] )                    - fabs ( xint_tr[2]*yint_tr[3 ] - xint_tr[3]*yint_tr[2 ] ) ) ;            area5 = 0.5*(a2*b2*(theta_tr[1 ] - ( theta_tr[4 ] - twopi ) )                    - fabs ( xint_tr[4]*yint_tr[1 ] - xint_tr[1]*yint_tr[4 ] ) ) ;        }        else        {            area2 = 0.5*(a1*b1*(theta[3 ] - theta[2 ] )                    - fabs ( xint[2]*yint[3 ] - xint[3]*yint[2 ] ) ) ;            area3 = 0.5*(a1*b1*(theta[1 ] - ( theta[4 ] - twopi ) )                    - fabs ( xint[4]*yint[1 ] - xint[1]*yint[4 ] ) ) ;            area4 = 0.5*(a2*b2*(theta[2 ] - theta[1 ] )                    - fabs ( xint_tr[1]*yint_tr[2 ] - xint_tr[2]*yint_tr[1 ] ) ) ;            area5 = 0.5*(a2*b2*(theta[4 ] - theta[3 ] )                    - fabs ( xint_tr[3]*yint_tr[4 ] - xint_tr[4]*yint_tr[3 ] ) ) ;        }            overlaparea = area1 + area2 + area3 + area4 + area5 ;        ( * rtncode ) = four_intersection_points ;        return overlaparea ;    }        //-- check whether an intersection point is a tangent or a cross - point    int istanpt ( double x , double y , double a1 , double b1 , double aa , double bb ,                 double cc , double dd , double ee , double ff )    {        double x1 , y1 , x2 , y2 , theta , test1 , test2 , branch , eps_radian ;            //-- avoid inverse trig calculation errors : there could be an error         //-- if \\textbar x1/a\\textbar   $ > $ 1.0 when calling acos ( ) .   if execution arrives here ,         //--",
    "then the point is on the ellipse within eps .",
    "if ( fabs ( x ) $ > $ a1 )            x = ( x $ < $ 0 ) ? -a1 : a1 ;            //-- calculate the parametric angle on the ellipse for ( x , y )        //-- the parametric angles depend on the quadrant where each point        //-- is located .   see table 1 in the reference .        if ( y $ < $ 0.0 )      //--",
    "quadrant iii or iv            theta = twopi - acos ( x / a1 ) ;        else              //--",
    "quadrant i or ii                  theta = acos ( x / a1 ) ;            //-- determine the distance from the origin to the point ( x , y )        branch = sqrt ( x*x + y*y ) ;            //-- use the distance to find a small angle , such that the distance        //-- along ellipse 1 is approximately 2*eps        if ( branch $ < $ 100.0*eps )            eps_radian = 2.0*eps ;        else            eps_radian = asin ( 2.0*eps / branch ) ;            //-- determine two points that are on each side of ( x , y ) and lie on        //--",
    "the first ellipse        x1 = a1*cos ( theta + eps_radian ) ;        y1 = b1*sin ( theta + eps_radian ) ;        x2 = a1*cos ( theta - eps_radian ) ;        y2 = b1*sin ( theta - eps_radian ) ;               //-- evaluate the two adjacent points in the second ellipse equation        test1 = ellipse2tr ( x1 , y1 , aa , bb , cc , dd , ee , ff ) ;        test2 = ellipse2tr ( x2 , y2 , aa , bb , cc , dd , ee , ff ) ;            //-- if the ellipses are tangent at the intersection point , then        //-- points on both sides will either both be inside ellipse 1 , or",
    "//-- they will both be outside ellipse 1        if ( ( test1*test2 ) $ > $ 0.0 )            return tangent_point ;        else            return intersection_point ;    }        //===========================================================================    //--",
    "cacm algorithm 326 : roots of low order polynomials .    //--",
    "nonweiler , terence r.f . , cacm algorithm 326 : roots of low order     //-- polynomials , communications of the acm , vol .",
    "4 , pages     //-- 269 - 270 ( 1968 ) . translated into c and programmed by m. dow , anusf ,    //--",
    "australian national university , canberra , australia .    //--",
    "accessed at http://www.netlib.org/toms/326 .    //--",
    "modified to void functions , integers replaced with floating point    //-- where appropriate , some other slight modifications for readability    //-- and debugging ease .    //===========================================================================",
    "void quadroots ( double p [ ] , double r[][5 ] )    {        / *        array r[3][5 ]   p[5 ]        roots of poly",
    "p[0]*x^{}2 + p[1]*x + p[2]=0        x = r[1][k ] + i r[2][k ]   k=1,2        * /        double b , c , d ;        b =- p[1]/(2.0*p[0 ] ) ;        c = p[2]/p[0 ] ;        d = b*b - c ;        if(d$>$=0.0 )        {            if(b$>$0.0 )                 b=(r[1][2]=(sqrt(d)+b ) ) ;            else                    b=(r[1][2]=(-sqrt(d)+b ) ) ;            r[1][1]=c / b ;             r[2][1]=(r[2][2]=0.0 ) ;        }        else        {            d=(r[2][1]=sqrt(-d ) ) ;             r[2][2]=-d ;            r[1][1]=(r[1][2]=b ) ;        }        return ;    }        void cubicroots(double p [ ] , double r[][5 ] )    {        / *        array r[3][5 ]   p[5 ]        roots of poly p[0]*x\\^{}3 + p[1]*x\\^{}2 + p[2]*x + p[3 ] = 0        x = r[1][k ] + i r[2][k ]   k=1, ... ,3        assumes 0$<$arctan(x)$<$pi/2 for x$>$0        * /        double s , t , b , c , d ;        int k ;        if(p[0]!=1.0 )        {            for(k=1;k$<$4;k++ )                 p[k]=p[k]/p[0 ] ;             p[0]=1.0 ;        }        s = p[1]/3.0 ;         t = s*p[1 ] ;        b=0.5*(s*(t/1.5-p[2])+p[3 ] ) ;        t=(t - p[2])/3.0 ;        c = t*t*t ;         d = b*b - c ;        if(d$>$=0.0 )        {            d = pow((sqrt(d)+fabs(b)),1.0/3.0 ) ;            if(d!=0.0 )            {                if(b$>$0.0 )                     b =- d ;                else                     b = d ;                c = t / b ;            }            d = r[2][2]=sqrt\\eqref{grindeq__0_75_}*(b - c ) ;             b = b+c ;            c = r[1][2]=-0.5*b - s ;            if((b$>$0.0 \\&\\ & s$<$=0.0 ) \\textbar \\textbar   ( b$<$0.0 \\&\\ & s$>$0.0 ) )            {                r[1][1]=c ;                 r[2][1]=-d ;                 r[1][3]=b - s ;                r[2][3]=0.0 ;            }            else            {                r[1][1]=b - s ;                 r[2][1]=0.0 ;                 r[1][3]=c ;                r[2][3]=-d ;            }        }   / * end 2 equal or complex roots * /        else        {            if(b==0.0 )                d = atan\\eqref{grindeq__1_0_}/1.5 ;            else                d = atan(sqrt(-d)/fabs(b))/3.0 ;            if(b$<$0.0 )                b=2.0*sqrt(t ) ;            else                b=-2.0*sqrt(t ) ;            c = cos(d)*b ;             t =- sqrt\\eqref{grindeq__0_75_}*sin(d)*b-0.5*c ;            d =- t - c - s ;             c = c - s ;             t = t - s ;            if(fabs(c)$>$fabs(t ) )            {                r[1][3]=c ;            }            else            {                r[1][3]=t ;                 t = c ;            }            if(fabs(d)$>$fabs(t ) )            {                r[1][2]=d ;            }            else            {                r[1][2]=t ;                 t = d ;            }            r[1][1]=t ;            for(k=1;k$<$4;k++ )                 r[2][k]=0.0 ;        }        return ;    }        void biquadroots(double p[],double r[][5 ] )    {        / *        array r[3][5 ]   p[5 ]        roots of poly p[0]*x\\^{}4 + p[1]*x\\^{}3 + p[2]*x\\^{}2 + p[3]*x + p[4 ] = 0        x = r[1][k ] + i r[2][k ]   k=1, ... ,4        * /        double a , b , c , d , e ;        int k , j ;        if(p[0 ] !",
    "= 1.0 )        {            for(k=1;k$<$5;k++ )                 p[k]=p[k]/p[0 ] ;            p[0]=1.0 ;        }        e=0.25*p[1 ] ;        b=2.0*e ;        c = b*b ;        d=0.75*c ;        b = p[3]+b*(c - p[2 ] ) ;        a = p[2]-d ;        c = p[4]+e*(e*a - p[3 ] ) ;        a = a - d ;        p[1]=0.5*a ;        p[2]=(p[1]*p[1]-c)*0.25 ;        p[3]=b*b/(-64.0 ) ;        if(p[3]$<$0.0 )        {            cubicroots(p , r ) ;            for(k=1;k$<$4;k++ )            {                if(r[2][k]==0.0 \\&\\ & r[1][k]$>$0.0 )                {                    d = r[1][k]*4.0 ;                     a = a+d ;                    if(a$>$=0.0 \\&\\ & b$>$=0.0 )                        p[1]=sqrt(d ) ;                    else if(a$<$=0.0 \\&\\ & b$<$=0.0 )                        p[1]=sqrt(d ) ;                    else                         p[1]=-sqrt(d ) ;                    b=0.5*(a+b / p[1 ] ) ;                    goto quad ;                }            }        }        if(p[2]$<$0.0 )        {            b = sqrt(c ) ;             d = b+b - a ;            p[1]=0.0 ;             if(d$>$0.0 )                 p[1]=sqrt(d ) ;        }        else        {            if(p[1]$>$0.0 )                b = sqrt(p[2])*2.0+p[1 ] ;            else                b =- sqrt(p[2])*2.0+p[1 ] ;            if(b!=0.0 )            {                p[1]=0.0 ;            }            else            {                for(k=1;k$<$5;k++ )                {                    r[1][k]=-e ;                    r[2][k]=0.0 ;                }                goto end ;            }        }    quad :        p[2]=c / b ;         quadroots(p , r ) ;        for(k=1;k$<$3;k++ )            for(j=1;j$<$3;j++ )                 r[j][k+2]=r[j][k ] ;        p[1]=-p[1 ] ;         p[2]=b ;         quadroots(p , r ) ;        for(k=1;k$<$5;k++ )             r[1][k]=r[1][k]-e ;    end :        return ;    } ....",
    ".... program\\_constants.h :                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        nonweiler , terence r.f . , _ cacm algorithm 326 : roots of low order polynomials _ , communications of the acm , vol . * 11 * no .",
    "4 , pages 269 - 270 ( 1968 ) . translated into c and programmed by m. dow , anusf , australian national university , canberra , australia .",
    "accessed at http://www.netlib.org/toms/326 ."
  ],
  "abstract_text": [
    "<S> we present a general algorithm for finding the overlap area between two ellipses . </S>",
    "<S> the algorithm is based on finding a segment area ( the area between an ellipse and a secant line ) given two points on the ellipse . </S>",
    "<S> the gauss - green formula is used to determine the ellipse sector area between two points , and a triangular area is added or subtracted to give the segment area . for two ellipses , overlap area is calculated by adding the areas of appropriate sectors and polygons . </S>",
    "<S> intersection points for two general ellipses are found using ferrari s quartic formula to solve the polynomial that results from combining the two ellipse equations . </S>",
    "<S> all cases for the number of intersection points ( 0 , 1 , 2 , 3 , 4 ) are handled . </S>",
    "<S> the algorithm is implemented in c - code , and has been tested with a range of input ellipses . </S>",
    "<S> the code is efficient enough for use in simulations that require many overlap area calculations .    </S>",
    "<S> gary b. hughes    mohcine chraibi </S>"
  ]
}