{
  "article_text": [
    "constraint programming ( cp ) is widely used to solve a variety of practical problems such as planning and scheduling @xcite , and industrial configuration @xcite .",
    "constraints can either be represented explicitly , by a table of allowed assignments , or implicitly , by specialized algorithms provided by the constraint solver .",
    "these algorithms may take as a parameter a _ description _ that specifies exactly which kinds of assignments a particular instance of a constraint should allow .",
    "such implicitly represented constraints are known as global constraints , and a lot of the success of cp in practice has been attributed to solvers providing them @xcite .    the theoretical properties of constraint problems , in particular the computational complexity of different types of problem , have been extensively studied and quite a lot is known about what restrictions on the general _ constraint satisfaction problem _ are sufficient to make it tractable @xcite . in particular , many structural restrictions , that is , restrictions on how the constraints in a problem interact , have been identified and shown to yield tractable classes of csp instances @xcite .",
    "however , much of this theoretical work has focused on problems where each constraint is explicitly represented , and most known structural restrictions fail to yield tractable classes for problems with global constraints , even when the global constraints are fairly simple @xcite .",
    "theoretical work on global constraints has to a large extent focused on developing efficient algorithms to achieve various kinds of local _ consistency _ for individual constraints .",
    "this is generally done by pruning from the domains of variables those values that can not lead to a satisfying assignment @xcite .",
    "another strand of research has explored conditions that allow global constraints to be replaced by collections of explicitly represented constraints @xcite .",
    "these techniques allow faster implementations of algorithms for _ individual constraints _ , but do not shed much light on the complexity of problems with multiple _ overlapping _ global constraints , which is something that practical problems frequently require .    as such ,",
    "in this paper we investigate what properties of explicitly represented constraints structural restrictions rely on to guarantee tractability . identifying such properties will allow us to find global constraints that also possess them , and lift well - known structural restrictions to instances with such constraints .",
    "as discussed in  @xcite , when the constraints in a family of problems have unbounded arity , the way that the constraints are _ represented _ can significantly affect the complexity .",
    "previous work in this area has assumed that the global constraints have specific representations , such as propagators  @xcite , negative constraints  @xcite , or gdnf / decision diagrams  @xcite , and exploited properties particular to that representation .",
    "in contrast , we will use a definition of global constraints that allows us to discuss different representations in a uniform manner .",
    "furthermore , as the results we obtain will rely on a relationship between the size of a global constraint and the number of its satisfying assignments , we do not need to reference any specific representation .    as a running example",
    ", we will use the connected graph partition problem ( cgp ) @xcite , defined below .",
    "the cgp is the problem of partitioning the vertices of a graph into bags of a given size while minimizing the number of edges that span bags .",
    "the vertices of the graph could represent components to be placed on circuit boards while minimizing the number of inter - board connections .",
    "[ prob : cgp ] we are given an undirected and connected graph @xmath0 , as well as @xmath1 .",
    "can @xmath2 be partitioned into disjoint sets @xmath3 with @xmath4 such that the set of broken edges @xmath5 has cardinality @xmath6 or less ?",
    "this problem is -complete @xcite , even for fixed @xmath7 .",
    "we are going to use the results in this paper to show a new result , namely that the cgp is tractable for every fixed @xmath6 .",
    "in this section , we define the basic concepts that we will use throughout the paper . in particular , we give a precise definition of global constraints , and illustrate it with a few examples .",
    "let @xmath2 be a set of variables , each with an associated set of domain elements .",
    "we denote the set of domain elements ( the domain ) of a variable @xmath8 by @xmath9 .",
    "we extend this notation to arbitrary subsets of variables , @xmath10 , by setting @xmath11 .",
    "an _ assignment _ of a set of variables @xmath2 is a function @xmath12 that maps every @xmath13 to an element @xmath14 .",
    "we denote the restriction of @xmath15 to a set of variables @xmath16 by @xmath17 .",
    "we also allow the special assignment @xmath18 of the empty set of variables .",
    "in particular , for every assignment @xmath15 , we have @xmath19 .",
    "let @xmath20 be a set of assignments of a set of variables @xmath2 .",
    "the _ projection _ of @xmath20 onto a set of variables @xmath21 is the set of assignments @xmath22 .",
    "note that when @xmath23 we have @xmath24 , but when @xmath25 and @xmath26 , we have @xmath27 .    [ def : disjoint - union ]",
    "let @xmath28 and @xmath29 be two assignments of disjoint sets of variables @xmath30 and @xmath31 , respectively .",
    "the _ disjoint union _ of @xmath28 and @xmath29 , denoted @xmath32 , is the assignment of @xmath33 such that @xmath34 for all @xmath35 , and @xmath36 for all @xmath37 .",
    "global constraints have traditionally been defined , somewhat vaguely , as constraints without a fixed arity , possibly also with a compact representation of the constraint relation .",
    "for example , in @xcite a global constraint is defined as `` a constraint that captures a relation between a non - fixed number of variables '' .",
    "below , we offer a precise definition similar to the one in @xcite , where the authors define global constraints for a domain @xmath38 over a list of variables @xmath39 as being given intensionally by a function @xmath40 computable in polynomial time .",
    "our definition differs from this one in that we separate the general _ algorithm _ of a global constraint ( which we call its _ type _ ) from the specific description .",
    "this separation allows us a better way of measuring the size of a global constraint , which in turn helps us to establish new complexity results .",
    "[ def : glob - const ] a _ global constraint type _ is a parameterized polynomial - time algorithm that determines the acceptability of an assignment of a given set of variables .",
    "each global constraint type , @xmath41 , has an associated set of _ descriptions _",
    ", @xmath42 .",
    "each description @xmath43 specifies appropriate parameter values for the algorithm @xmath41 .",
    "in particular , each @xmath43 specifies a set of variables , denoted by @xmath44 .",
    "a _ global constraint _ @xmath45 $ ] , where @xmath46 , is a function that maps assignments of @xmath44 to the set @xmath47 .",
    "each assignment that is allowed by @xmath45 $ ] is mapped to 1 , and each disallowed assignment is mapped to 0 .",
    "extension _ or _",
    "constraint relation _ of @xmath45 $ ] is the set of assignments , @xmath15 , of @xmath44 such that @xmath45(\\theta ) = 1 $ ] .",
    "we also say that such assignments _ satisfy _ the constraint , while all other assignments _ falsify _ it .",
    "when we are only interested in describing the set of assignments that satisfy a constraint , and not in the complexity of determining membership in this set , we will sometimes abuse notation by writing @xmath48 $ ] to mean @xmath45(\\theta ) = 1 $ ] .    as can be seen from the definition above , a global constraint is not usually explicitly represented by listing all the assignments that satisfy it . instead , it is represented by some description @xmath49 and some algorithm @xmath41 that allows us to check whether the constraint relation of @xmath45 $ ] includes a given assignment .",
    "to stay within the complexity class , this algorithm is required to run in polynomial time .",
    "as the algorithms for many common global constraints are built into modern constraint solvers , we measure the _ size _ of a global constraint s representation by the size of its description .",
    "[ example : egc ] a very general global constraint type is the _ extended global cardinality _ constraint type  @xcite .",
    "this form of global constraint is defined by specifying for every domain element @xmath50 a finite set of natural numbers @xmath51 , called the cardinality set of @xmath50 .",
    "the constraint requires that the number of variables which are assigned the value @xmath50 is in the set @xmath51 , for each possible domain element @xmath50 .    using our notation",
    ", the description @xmath49 of an egc global constraint specifies a function @xmath52 that maps each domain element to a set of natural numbers .",
    "the algorithm for the egc constraint then maps an assignment @xmath15 to @xmath53 if and only if , for every domain element @xmath54 , we have that @xmath55 .",
    "[ example : table - const ] a rather degenerate example of a a global constraint type is the _ table _ constraint .    in this case the description @xmath49 is simply a list of assignments of some fixed set of variables , @xmath44 .",
    "the algorithm for a table constraint then decides , for any assignment of @xmath44 , whether it is included in @xmath49 .",
    "this can be done in a time which is linear in the size of @xmath49 and so meets the polynomial time requirement .",
    "_ negative _ constraints are complementary to table constraints , in that they are described by listing",
    "_ forbidden _ assignments .",
    "the algorithm for a negative constraint @xmath45 $ ] decides , for any assignment of @xmath44 , whether whether it is _ not _ included in @xmath49 .",
    "observe that disjunctive clauses , used to define propositional satisfiability problems , are a special case of the negative constraint type , as they have exactly one forbidden assignment .",
    "we observe that any global constraint can be rewritten as a table or negative constraint .",
    "however , this rewriting will , in general , incur an exponential increase in the size of the description .",
    "as can be seen from the definition above , a table global constraint is explicitly represented , and thus equivalent to the usual notion of an explicitly represented constraint .",
    "an instance of the constraint satisfaction problem ( csp ) is a pair @xmath56 where @xmath2 is a finite set of _ variables _ , and @xmath57 is a set of _ global constraints _ such that for every @xmath45    \\in c$ ] , @xmath58 . in a csp instance , we call @xmath44 the _ scope _ of the constraint @xmath45 $ ] .    a _ classic _ csp instance is one where every constraint is a table constraint",
    ".    a _ solution _ to a csp instance @xmath59 is an assignment @xmath15 of @xmath2 which satisfies every global constraint , i.e. , for every @xmath45 \\in c$ ] we have @xmath60 $ ] .",
    "we denote the set of solutions to @xmath61 by @xmath62 .",
    "the _ size _ of a csp instance @xmath59 is @xmath63      \\in c } |\\delta|$ ] .",
    "[ example : cgp - as - csp ] given a connected graph @xmath64 , @xmath65 , and @xmath6 , we build a csp instance @xmath66 as follows .",
    "the set @xmath67 will have a variable @xmath8 for every @xmath13 with domain @xmath68 , while the set @xmath69 will have a boolean variable @xmath41 for every edge in @xmath70 .",
    "the set of constraints @xmath57 will have an egc constraint @xmath71 on @xmath67 with @xmath72 for every @xmath73 .",
    "likewise , @xmath57 will have an egc constraint @xmath74 on @xmath69 with @xmath75 and @xmath76 .    finally , to connect @xmath67 and @xmath69 , the set @xmath57 will have for every edge @xmath77 , with corresponding variable @xmath78 , a table constraint on @xmath79 requiring @xmath80 .",
    "as an example , [ fig : cgp - ext - example ] shows this encoding for the cgp on the graph @xmath81 , that is , a simple cycle on five vertices .",
    "this encoding follows the definition of [ prob : cgp ] quite closely , and can be done in polynomial time .",
    "in recent years , there has been a flurry of research into identifying tractable classes of classic csp instances based on restrictions on the hypergraphs of csp instances , known as structural restrictions .",
    "below , we present and discuss a few representative examples . to present the various structural restrictions",
    ", we will use the framework of width functions , introduced by adler @xcite .",
    "a hypergraph @xmath82 is a set of vertices @xmath2 together with a set of hyperedges @xmath83 .",
    "given a csp instance @xmath59 , the hypergraph of @xmath61 , denoted @xmath84 , has vertex set @xmath2 together with a hyperedge @xmath44 for every @xmath45 \\in c$ ] .    a _ tree decomposition _ of a hypergraph @xmath82 is a pair @xmath85 where @xmath86 is a tree and @xmath87 is a labelling function from nodes of @xmath86 to subsets of @xmath2 , such that    1 .   for every @xmath13 , there exists a node @xmath88 of @xmath86 such that @xmath89 , 2 .   for every hyperedge @xmath90 ,",
    "there exists a node @xmath88 of @xmath86 such that @xmath91 , and 3 .   for every @xmath13 , the set of nodes @xmath92 induces a connected subtree of @xmath86 .",
    "let @xmath93 be a hypergraph .",
    "a _ width function _ on @xmath94 is a function @xmath95 that assigns a positive real number to every nonempty subset of vertices of @xmath94 .",
    "a width function @xmath96 is monotone if @xmath97 whenever @xmath98 .",
    "let @xmath99 be a tree decomposition of @xmath94 , and @xmath96 a width function on @xmath94 .",
    "the _ @xmath96-width _ of @xmath99 is @xmath100 .",
    "the _ @xmath96-width _ of @xmath94 is the minimal @xmath96-width over all its tree decompositions .    in other words ,",
    "a width function on a hypergraph @xmath94 tells us how to assign weights to nodes of tree decompositions of @xmath94 .",
    "let @xmath101 .",
    "the treewidth @xmath102 of a hypergraph @xmath94 is the @xmath96-width of @xmath94 .",
    "let @xmath93 be a hypergraph , and @xmath103 .",
    "an edge cover for @xmath104 is any set of hyperedges @xmath105 that satisfies @xmath106 .",
    "the edge cover number @xmath107 of @xmath104 is the size of the smallest edge cover for @xmath104 .",
    "it is clear that @xmath108 is a width function .",
    "the generalized hypertree width @xmath109 of a hypergraph @xmath94 is the @xmath108-width of @xmath94 .",
    "next , we define a relaxation of hypertree width known as fractional hypertree width , introduced by grohe and marx @xcite .",
    "let @xmath93 be a hypergraph , and @xmath103 .",
    "a _ fractional edge cover _ for @xmath104 is a function @xmath110 $ ] such that @xmath111 for every @xmath112 .",
    "we call @xmath113 the weight of @xmath114",
    "fractional edge cover number _ @xmath115 of @xmath104 is the minimum weight over all fractional edge covers for @xmath104 .",
    "it is known that this minimum is always rational @xcite .",
    "the _ fractional hypertree width _",
    "@xmath116 of a hypergraph @xmath94 is the @xmath117-width of @xmath94 .    for a class of hypergraphs @xmath118 and",
    "a notion of width @xmath65 , we write @xmath119 for the maximal @xmath65-width over the hypergraphs in @xmath118 . if this is unbounded we write @xmath120 ; otherwise @xmath121 .",
    "all the above restrictions can be used to guarantee tractability for classes of csp instances where all constraints are table constraints .",
    "[ thm : width - tract ] let @xmath118 be a class of hypergraphs .",
    "for every @xmath122 , any class of classic csp instances whose hypergraphs are in @xmath118 is tractable if @xmath123 .    to go beyond fractional hypertree width , marx @xcite recently introduced the concept of submodular width .",
    "this concept uses a set of width functions satisfying a condition ( submodularity ) , and considers the @xmath96-width of a hypergraph for every such function @xmath96 .",
    "let @xmath93 be a hypergraph .",
    "a width function @xmath96 on @xmath94 is _ submodular _ if for every set @xmath124 , we have @xmath125 .",
    "let @xmath94 be a hypergraph .",
    "the _ submodular width _",
    "@xmath126 of @xmath94 is the maximum @xmath96-width of @xmath94 taken over all monotone submodular width functions @xmath96 on @xmath94 .    for a class of hypergraphs @xmath118",
    ", we write @xmath127 for the maximal submodular width over the hypergraphs in @xmath118 .",
    "if this is unbounded we write @xmath128 ; otherwise @xmath129 .",
    "unlike for fractional hypertree width and every other structural restriction discussed so far , the running time of the algorithm given by marx for classic csp instances with bounded submodular width has an exponential dependence on the number of vertices in the hypergraph of the instance .",
    "the class of classic csp instances with bounded submodular width is therefore not tractable .",
    "however , this class is what is called fixed - parameter tractable @xcite .",
    "a _ parameterized problem instance _ is a pair @xmath130 , where @xmath61 is a problem instance , such as a csp instance , and @xmath131 a parameter .",
    "let @xmath132 be a class of parameterized problem instances .",
    "we say that @xmath132 is _ fixed - parameter tractable _",
    "( in ) if there is a function @xmath96 of one argument , as well as a constant @xmath133 , such that every problem @xmath134 can be solved in time @xmath135 .    the function @xmath96 can be arbitrary , but must only depend on the parameter @xmath136 .",
    "for csp instances , a natural parameterization is by the size of the hypergraph of an instance , measured by the number of vertices . since the hypergraph of an instance has a vertex for every variable , for every csp instance @xmath59 we consider the parameterized instance @xmath137 .",
    "[ cor : subw ] let @xmath118 be a class of hypergraphs .",
    "if @xmath138 , then a class of classic csp instances whose hypergraphs are in @xmath118 is in .",
    "the three structural restrictions that we have just presented form a hierarchy @xcite : for every hypergraph @xmath94 , @xmath139 .",
    "as the example below demonstrates , [ thm : width - tract ] does not hold for csp instances with arbitrary global constraints , even if we have a fixed , finite domain .",
    "[ example:3col ] the -complete problem of 3-colourability @xcite is to decide , given a graph @xmath140 , whether the vertices @xmath2 can be coloured with three colours such that no two adjacent vertices have the same colour .",
    "we may reduce this problem to a csp with egc constraints ( cf .",
    "example  [ example : egc ] ) as follows : let @xmath2 be the set of variables for our csp instance , each with domain @xmath141 . for every edge @xmath142 , we post an egc constraint with scope @xmath143 , parameterized by the function @xmath144 such that @xmath145 .",
    "finally , we make the hypergraph of this csp instance have low width by adding an egc constraint with scope @xmath2 parameterized by the function @xmath146 such that @xmath147 .",
    "this reduction clearly takes polynomial time , and the hypergraph @xmath94 of the resulting instance has @xmath148 .",
    "as the constraint with scope @xmath2 allows all possible assignments , any solution to this csp is also a solution to the 3-colourability problem , and vice versa .    likewise , [ cor : subw ] does not hold for csp instances with arbitrary global constraints if we allow the variables unbounded domain size , that is , change the above example to @xmath136-colourability . with",
    "that in mind , in the rest of the paper we will identify properties of extensionally represented constraints that these structural restrictions exploit to guarantee tractability .",
    "then , we are going to look for restricted classes of global constraints that possess these properties .",
    "to do so , we will use the following definitions .",
    "a _ constraint catalogue _ is a set of global constraints .",
    "a csp instance @xmath56 is said to be over a constraint catalogue  @xmath149 if for every @xmath45 \\in c$ ] we have @xmath45 \\in { \\ensuremath{\\gamma}}$ ] .",
    "[ def : csprestricted ] let @xmath149 be a constraint catalogue , and let @xmath150 be a class of hypergraphs .",
    "we define @xmath151 to be the class of csp instances over @xmath149 whose hypergraphs are in @xmath118 .",
    "allows us to discuss classic csp instances alongside instances with global constraints .",
    "let @xmath152 be the constraint catalogue containing all table global constraints .",
    "the classic csp instances are then precisely those that are over @xmath152 . in particular , we can now restate [ thm : width - tract , cor : subw ] as follows .",
    "[ thm : width - new - notation ] let @xmath118 be a class of hypergraphs . for every @xmath122 ,",
    "the class of csp instances @xmath153 is tractable if @xmath154 .",
    "furthermore , if @xmath129 then @xmath155 is in .",
    "we are going to start our investigation by considering fractional hypertree width in more detail . to obtain tractability for classic csp instances of bounded fractional hypertree width , grohe and marx @xcite use a bound on the number of solutions to a classic csp instance , and show that this bound is preserved when we consider parts of a csp instance .",
    "the following definition formalizes what we mean by `` parts '' , and is required to state the algorithm that grohe and marx use in their paper .",
    "[ def : constraint - projection ] let @xmath45 $ ] be a constraint",
    ". the _ projection of @xmath45 $ ] _ onto a set of variables @xmath156 is the constraint @xmath157)$ ] such that @xmath158)$ ] if and only if there exists @xmath48 $ ] with @xmath159 .    for a csp instance @xmath59 and @xmath103",
    "we define @xmath160 , where @xmath161 is the least set containing for every @xmath45 \\in c$ ] such that @xmath162 the constraint @xmath163)$ ] .",
    "their algorithm is given as [ alg : enum - solutions ] , and is essentially the usual recursive search algorithm for finding all solutions to a csp instance by considering smaller and smaller sub - instances using constraint projections .",
    "@xmath164 solutions    to show that [ alg : enum - solutions ] does indeed find all solutions , we will use the following property of constraint projections .",
    "[ lemma : solution - projection ] let @xmath59 be a csp instance . for every @xmath103 ,",
    "we have @xmath165 .    given @xmath59 , let @xmath103 be arbitrary , and let @xmath166 \\in c \\mid x \\cap { \\ensuremath{\\mathcal{v}}}(\\delta ) \\not=",
    "\\emptyset\\}$ ] . for every @xmath167 and constraint @xmath45 \\in c'$ ]",
    "we have that @xmath168 $ ] since @xmath15 is a solution to @xmath61 . by [ def : constraint - projection ]",
    ", it follows that for every @xmath45 \\in c'$ ] , @xmath169)$ ] .",
    "since the set of constraints of @xmath170 is the least set containing for each @xmath45 \\in c'$ ] the constraint @xmath163)$ ] , we have @xmath171 , and hence @xmath172 .",
    "since @xmath104 was arbitrary , the claim follows .",
    "let @xmath61 be a csp instance .",
    "we have that @xmath173 .",
    "the proof is by induction on the set of variables @xmath2 in @xmath61 .",
    "for the base case , if @xmath174 , the empty assignment is the only solution .    otherwise , choose a variable @xmath175 , and let @xmath176 . by induction , we can assume that @xmath177 .",
    "since for every @xmath167 there exists @xmath178 such that @xmath179 , and furthermore @xmath180 , it follows by [ lemma : solution - projection ] that @xmath171 . since [ alg : enum - solutions ] checks every assignment of the form @xmath181 for every @xmath182 and @xmath178",
    ", it follows that @xmath173 .",
    "the time required for this algorithm depends on three key factors , which we are going to enumerate and discuss below .",
    "let    1 .",
    "@xmath183 be the maximum of the number of solutions to each of the instances @xmath184 , 2 .",
    "@xmath185 be the maximum time required to check whether an assignment is a solution to @xmath61 , and 3 .",
    "@xmath186 be the maximum time required to construct any instance @xmath184 .",
    "there are @xmath187 calls to @xmath188 .",
    "for each call , we need @xmath186 time to construct the projection , while the double loop takes at most @xmath189 time . therefore , letting @xmath190 , the running time of [ alg : enum - solutions ] is bounded by @xmath191 .    since constructing the projection of a classic csp instance",
    "can be done in polynomial time , and likewise checking that an assignment is a solution , the whole algorithm runs in polynomial time if @xmath183 is a polynomial in the size of @xmath61 . for fractional hypertree width ,",
    "grohe and marx show the following .",
    "[ lemma : fhw - few - solutions ] a classic csp instance @xmath61 has at most @xmath192 solutions .",
    "since fractional hypertree width is a monotone width function , it follows that for any instance @xmath59 and @xmath103 , @xmath193 .",
    "therefore , for classic csp instances of bounded fractional hypertree width @xmath183 is indeed polynomial in @xmath194 .",
    "having few solutions for every projection of a csp instance is thus a property that makes fractional hypertree width yield tractable classes of classic csp instances .",
    "more importantly , we have shown that this property allows us to find all solutions to a csp instance @xmath61 , even with global constraints , if we can build arbitrary projections of @xmath61 in polynomial time .",
    "in other words , with these two conditions we should be able to reduce instances with global constraints to classic instances in polynomial time .",
    "however , on reflection there is no reason why we should need few solutions for _ every _ projection .",
    "instead , consider the following reduction .",
    "[ def : part - assignment - checking ] a global constraint catalogue @xmath195 allows _ partial assignment checking _ if for any constraint @xmath45",
    "\\in \\gamma$ ] we can decide in polynomial time whether a given assignment @xmath15 to a set of variables @xmath196 is contained in an assignment that satisfies @xmath45 $ ] , i.e.  whether there exists @xmath197 $ ] such that @xmath198 .    as an example , a catalogue that contains arbitrary egc constraints ( cf .",
    "[ example : egc ] ) does not satisfy [ def : part - assignment - checking ] , since checking whether an arbitrary egc constraint has a satisfying assignment is -hard @xcite . on the other hand , a catalogue that contains only egc constraints whose cardinality sets are intervals does satisfy [ def : part - assignment - checking ] @xcite .    if a catalogue @xmath195 satisfies [ def : part - assignment - checking ]",
    ", we can for any constraint @xmath45 \\in \\gamma$ ] build arbitrary projections of it , that is , construct the global constraint @xmath157)$ ] for any @xmath199 , in polynomial time .",
    "[ def : intersection - vertices ] let @xmath56 be a csp instance .",
    "the set of _ intersection variables _ of any constraint @xmath45",
    "\\in p$ ] is @xmath200 \\in c    - \\{e[\\delta]\\}\\}$ ] .",
    "[ def : ind - const ] let @xmath59 be a csp instance .",
    "for every @xmath45 \\in c$ ] , let @xmath201 be the assignment to @xmath202 that assigns a special value @xmath203 to every variable .",
    "the _ table constraint induced by @xmath45 $ ] _ is @xmath204 ) =    e'[\\delta']$ ] , where @xmath205 , and @xmath206 contains for every assignment @xmath207 the assignment @xmath208 .",
    "if every constraint in a csp instance @xmath59 allows partial assignment checking , then building @xmath204)$ ] for any @xmath45 \\in c$ ] can be done in polynomial time when @xmath209 is itself polynomial in the size of @xmath61 for every subset @xmath104 of @xmath210 .",
    "to do so , we can invoke [ alg : enum - solutions ] on the instance @xmath211 .",
    "the definition below expresses this idea .",
    "[ def : sparse - intersections ] a class of csp instances @xmath212 _ has sparse intersections _ if there exists a constant @xmath133 such that for every constraint @xmath45 $ ] in any instance @xmath213 , we have that for every @xmath214 , @xmath215 .",
    "if a class of instances @xmath212 has sparse intersections , and the instances are all over a constraint catalogue that allows partial assignment checking , then we can for every constraint @xmath45 $ ] of any instance from @xmath212 construct @xmath204)$ ] in polynomial time . while this definition considers the instance as a whole , one special case of it is the case where every constraint has few solutions in the size of its description ,",
    "that is , there is a constant @xmath133 and the constraints are drawn from a catalogue @xmath195 such that for every @xmath45 \\in \\gamma$ ] , we have that @xmath216\\}| \\leq |\\delta|^c$ ] .",
    "[ thm : decomp - to - classic ] let @xmath212 be a class of csp instances over a catalogue that allows partial assignment checking .",
    "if @xmath212 has sparse intersections , then we can in polynomial time reduce any instance @xmath217 to a classic csp instance @xmath218 with @xmath219 , such that @xmath218 has a solution if and only if @xmath61 does .",
    "let @xmath220 be an instance from such a class @xmath221 . for each @xmath45 \\in c$",
    "] , @xmath218 will contain the table constraint @xmath204)$ ] from [ def : ind - const ] .",
    "since @xmath61 is over a catalogue that allows partial assignment checking , and @xmath212 has sparse intersections , computing @xmath204)$ ] can be done in polynomial time by invoking [ alg : enum - solutions ] on @xmath211 .",
    "it is clear that @xmath222 .",
    "all that is left to show is that @xmath218 has a solution if and only if @xmath61 does .",
    "let @xmath15 be a solution to @xmath59 .",
    "for every @xmath45 \\in    c$ ] , we have that @xmath223 by [ def : constraint - projection , def : intersection - vertices ] , and the assignment @xmath224 that assigns the value @xmath225 to each @xmath226 \\in c}{\\ensuremath{\\mathsf{iv}}}(\\delta)$ ] , and @xmath203 to every other variable is therefore a solution to @xmath218 .    in the other direction ,",
    "if @xmath15 is a solution to @xmath218 , then @xmath15 satisfies @xmath204)$ ] for every @xmath45 \\in c$ ] . by [ def : ind - const ]",
    ", this means that @xmath227 , and by [ def : constraint - projection ] , there exists an assignment @xmath228}$ ] with @xmath228}|_{{\\ensuremath{\\mathsf{iv}}}(\\delta ) } =    \\theta|_{{\\ensuremath{\\mathsf{iv}}}(\\delta)}$ ] that satisfies @xmath45 $ ] . by [ def : intersection - vertices ]",
    ", the variables not in @xmath210 do not occur in any other constraint in @xmath61 , so we can combine all the assignments @xmath228}$ ] to form a solution @xmath224 to @xmath61 such that for @xmath45 \\in c$ ] and @xmath229 we have @xmath230}(v)$ ] .    from [ thm : decomp - to - classic ] , we get tractable and fixed - parameter tractable classes of csp instances with global constraints .    [",
    "corollary : subproblem - csp ] let @xmath118 be a class of hypergraphs , and @xmath149 a catalogue that allows partial assignment checking . if @xmath231 has sparse intersections , then @xmath231 is tractable or in if @xmath155 is .",
    "let @xmath118 and @xmath149 be given . by [ thm : decomp - to - classic ] , we can reduce any @xmath232 to an instance @xmath233 in polynomial time . since @xmath218 has a solution if and only if @xmath61 does , tractability or fixed - parameter tractability of @xmath155 implies the same for @xmath234 .",
    "recall the connected graph partition problem ( [ prob : cgp ] ) : given a connected graph @xmath94 , as well as natural numbers @xmath65 and @xmath6 , can the vertices of @xmath94 be partitioned into bags of size at most @xmath65 , such that no more than @xmath6 edges are broken . using the csp encoding we gave in [ example : cgp - as - csp ] , as well as",
    "[ corollary : subproblem - csp ] , we will show a new result , that this problem is tractable if @xmath6 is fixed . to simplify the analysis ,",
    "we assume without loss of generality that @xmath235 , which means that any solution has at least one broken edge .    we claim that if @xmath6 is fixed , then the constraint @xmath236 $ ] allows partial assignment checking , and has only a polynomial number of satisfying assignments .",
    "the latter implies that for any instance @xmath61 of the cgp , @xmath237 is polynomial in the size of @xmath61 for every subset of @xmath238 .",
    "furthermore , we will show that for the constraint @xmath239 $ ] , we also have that @xmath240 is polynomial in the size of @xmath61 . that @xmath241 allows partial assignment checking follows from a result by rgin  @xcite , since the cardinality sets of @xmath241 are intervals .",
    "first , we show that the number of satisfying assignments to @xmath74 is limited . since @xmath74 limits the number of ones in any solution to @xmath6 or fewer , the number of satisfying assignments to this constraint is the number of ways to choose up to @xmath6 variables to be assigned one .",
    "this is bounded by @xmath242 , and so we can generate them all in polynomial time .",
    "now , let @xmath15 be such a solution .",
    "how many solutions to @xmath61 contain @xmath15 ?",
    "well , every constraint on @xmath79 with @xmath243 allows at most @xmath244 assignments , and there are at most @xmath6 such constraints .",
    "so far we therefore have at most @xmath245 requires @xmath246 . consider the graph @xmath247 containing for every constraint on @xmath248 with @xmath249 the vertices @xmath250 and @xmath8 as well as the edge @xmath251 .",
    "since the original graph was connected , every connected component of @xmath247 contains at least one vertex which is in the scope of some constraint with @xmath243 .",
    "therefore , since equality is transitive , each connected component of @xmath247 allows at most one assignment for each of the @xmath252 assignments to the other variables of @xmath61 .",
    "we therefore get a total bound of @xmath252 on the total number of solutions to @xmath61 , and hence to @xmath253 .    the hypergraph of any csp instance @xmath61 encoding the cgp has two hyperedges covering the whole problem , so the hypertree width of this hypergraph is two",
    ". therefore , we may apply [ corollary : subproblem - csp , thm : width - tract ] to obtain tractability when @xmath6 is fixed . as this problem is -complete for fixed @xmath7 @xcite",
    ", @xmath6 is a natural parameter to try and use .",
    "as it happens , in this problem we can drop the requirement of partial assignment checking for the constraint @xmath241 .",
    "all its variables are intersection variables , and the instance has few solutions even if we disregard @xmath241 .",
    "thus , we need only check whether any of those solutions satisfy @xmath241 , and checking whether an assignment to the whole scope of a constraint satisfies it can always be done in polynomial time by [ def : glob - const ] . in the next section , we turn this observation into a general result .",
    "if a class of csp instances includes constraints from a catalogue that is not known to allow partial assignment checking , we may still obtain tractability in some cases by applying the notion of a back door set . a ( strong ) back door set",
    "@xcite is a set of variables in a csp instance that , when assigned , make the instance easy to solve .",
    "below , we are going to adapt this notion to individual constraints .",
    "[ def : back - doors ] let @xmath149 be a global constraint catalogue .",
    "a _ back door _ for a constraint @xmath45 \\in { \\ensuremath{\\gamma}}$ ] is any set of variables @xmath196 ( called a back door set ) such that we can decide in polynomial time whether a given assignment @xmath15 to a set of variables @xmath254 is contained in an assignment that satisfies @xmath45 $ ] , i.e.  whether there exists @xmath197 $ ] such that @xmath255 .",
    "trivially , for every constraint @xmath45 $ ] the set of variables @xmath44 is a back door set , since by [ def : glob - const ] we can always check in polynomial time if an assignment to @xmath44 satisfies the constraint @xmath45 $ ] .",
    "the key point about back doors is that given a catalogue @xmath195 , adding to each @xmath45 \\in \\gamma$ ] with back door set @xmath10 an arbitrary set of assignments to @xmath10 produces a catalogue @xmath256 that allows partial assignment checking . adding a set of assignments @xmath20 means to add @xmath20 to the description , and modify the algorithm @xmath41 to only accept an assignment if it contains a member of @xmath20 in addition to previous requirements .",
    "furthermore , given a csp instance @xmath61 containing @xmath45 $ ] , as long as @xmath257 , adding @xmath20 to @xmath45 $ ] produces an instance that has exactly the same solutions .",
    "this point leads to the following definition .",
    "[ def : sparse - back - door - cover ] let @xmath258 be a catalogue that allows partial assignment checking and @xmath259 a catalogue .",
    "for every instance @xmath59 over @xmath260 , let @xmath261 be the instance with constraint set @xmath262 and set of variables @xmath263 \\in c'\\}$ ] .",
    "a class of csp instances @xmath212 over @xmath264 has _ sparse back door cover _ if there exists a constant @xmath133 such that for every instance @xmath265 and constraint @xmath45 \\in c$ ] , if @xmath45 \\not\\in    \\gamma_{pac}$ ] , then there exists a back door set @xmath10 for @xmath45 $ ] with @xmath266 for every @xmath267 .",
    "sparse back door cover means that for each constraint that is not from a catalogue that allows partial assignment checking , we can in polynomial time get a set of assignments @xmath20 for its back door set using [ alg : enum - solutions ] , and so turn this constraint into one that does allow partial assignment checking .",
    "this operation preserves the solutions of the instance that contains this constraint .",
    "[ lemma : backdoors ] if a class of csp instance @xmath212 has sparse back door cover , then we can in polynomial time reduce any instance @xmath268 to an instance @xmath269 such that @xmath270 and @xmath271 .",
    "furthermore , the class of instances @xmath272 is over a catalogue that allows partial assignment checking .",
    "let @xmath273 .",
    "we construct @xmath269 by adding to every @xmath45 \\in c$ ] such that @xmath45 \\not\\in \\gamma_{pac}$ ] , with back door set @xmath10 , the set of assignments @xmath274 , which we can obtain using [ alg : enum - solutions ] . by [ def : sparse - back - door - cover ]",
    ", we have for every @xmath275 that @xmath276 , so [ alg : enum - solutions ] takes polynomial time since @xmath258 does allow partial assignment checking .",
    "it is clear that @xmath277 , and since @xmath278 , the set of solutions stays the same , i.e.  @xmath279 .",
    "finally , since we have replaced each constraint @xmath45 $ ] in @xmath61 that was not in @xmath258 by a constraint that does allow partial assignment checking , it follows that @xmath269 is over a catalogue that allows partial assignment checking .",
    "one consequence of [ lemma : backdoors ] is that we can sometimes apply [ thm : decomp - to - classic ] to a csp instance that contains a constraint for which checking if a partial assignment can be extended to a satisfying one is hard .",
    "we can do so when the variables of that constraint are covered by the variables of other constraints that do allow partial assignment checking  but only if the instance given by those constraints has few solutions .    as a concrete example of this",
    ", consider again the encoding of the cgp that we gave in [ example : cgp - as - csp ] .",
    "the variables of constraint @xmath241 are entirely covered by the instance @xmath269 obtained by removing @xmath241 .",
    "as the entire set of variables of a constraint is a back door set for it , and the instance @xmath269 has few solutions ( cf .",
    "[ sect : cgp - app ] ) , this class of instances has sparse back door cover .",
    "as such , the constraint @xmath241 could , in fact , be arbitrary without affecting the tractability of this problem .",
    "in particular , the requirement that @xmath241 allows partial assignment checking can be dropped .",
    "in this paper , we have investigated properties that many structural restrictions rely on to yield tractable classes of csp instances with explicitly represented constraints . in particular",
    ", we identify a relationship between the number of solutions and the size of a csp instance as being one such property . using this insight",
    ", we show that known structural restrictions yield tractability for any class of csp instances with global constraints that satisfies this property .",
    "in particular , the above implies that the structural restrictions we consider yield tractability for classes of instances where every global constraint has few satisfying assignments relative to its size .    to illustrate our result",
    ", we apply it to a known problem , the connected graph partition problem , and use it to identify a new tractable case of this problem .",
    "we also demonstrate how the concept of back doors , subsets of variables that make a problem easy to solve once assigned , can be used to relax the conditions of our result in some cases .    as for future work , one obvious research direction to pursue",
    "is to find a complete characterization of tractable classes of csp instances with sparse intersections .",
    "another avenue of research would be to apply the results in this paper to various kinds of valued csp .",
    "aschinger , m. , drescher , c. , friedrich , g. , gottlob , g. , jeavons , p. , ryabokon , a. , thorstensen , e. : optimization methods for the partner units problem . in : proc .",
    "lncs , vol . 6697 , pp .",
    "419 . springer ( 2011 )    aschinger , m. , drescher , c. , gottlob , g. , jeavons , p. , thorstensen , e. : structural decomposition methods and what they are good for . in : schwentick , t. , drr , c. ( eds . ) proc .",
    "lipics , vol .  9 , pp .",
    "1228 ( 2011 )                        gaspers , s. , szeider , s. : backdoors to satisfaction . in : bodlaender , h.l . , downey , r. , fomin , f.v . , marx , d. ( eds . ) the multivariate algorithmic revolution and beyond , lncs , vol .",
    "7370 , pp .",
    "springer ( 2012 )                  van hoeve , w.j . ,",
    "katriel , i. : global constraints . in : rossi ,",
    "f. , van beek , p. , walsh , t. ( eds . ) handbook of constraint programming , foundations of artificial intelligence , vol .  2 , pp .",
    "elsevier ( 2006 )"
  ],
  "abstract_text": [
    "<S> a wide range of problems can be modelled as constraint satisfaction problems ( csps ) , that is , a set of constraints that must be satisfied simultaneously . </S>",
    "<S> constraints can either be represented extensionally , by explicitly listing allowed combinations of values , or implicitly , by special - purpose algorithms provided by a solver . </S>",
    "<S> such implicitly represented constraints , known as global constraints , are widely used ; indeed , they are one of the key reasons for the success of constraint programming in solving real - world problems .    in recent years , a variety of restrictions on the structure of csp instances that yield tractable classes have been identified . </S>",
    "<S> however , many such restrictions fail to guarantee tractability for csps with global constraints . in this paper </S>",
    "<S> , we investigate the properties of extensionally represented constraints that these restrictions exploit to achieve tractability , and show that there are large classes of global constraints that also possess these properties . </S>",
    "<S> this allows us to lift these restrictions to the global case , and identify new tractable classes of csps with global constraints . </S>"
  ]
}