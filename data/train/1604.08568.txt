{
  "article_text": [
    "graphs , and , particularly , attributed graphs  @xcite , are becoming increasingly popular to model different kinds of networks ( e.g. , social networks , sensor networks , and the kind ) for analysis in a classical way , and also for performing online analytical processing ( olap ) on graphs  @xcite . also , these kinds of graphs underlie the data model of neo4j , probably the most popular graph database for social network analysis at the time of writing this paper  @xcite , together with allegrograph . in spite of the fact that social networks are heavily changing structures , not much attention has yet been paid to temporal graph databases ( see section  [ sec : related ] ) . in this paper we introduce our approach to this topic , based on attribute graph data models .",
    "we first present a temporal data model , consisting in a data structure ( an attribute graph ) , and a set of constraints .",
    "then , we sketch a temporal query language , called teg - ql ( for temporal graph query language ) , an sql / sparql - like style language , with the idea of facilitating the translation to cypher , the language that comes with neo4j .",
    "we provide extensive examples of the possible use of teg - ql .",
    "we also describe a prototype we have implemented , allowing time navigation of temporal graphs ( and of the result of a teg - ql query ) . throughout the paper we will be using a running example consisting in a network containing two kinds of nodes , representing persons and buildings .",
    "edges in this network are of two kinds : one , representing friendship relationships between people across time ; the other one telling the buildings where people had lived through time .",
    "nodes contain information about the of the people , type of building , number of bedrooms in the apartment , etc .",
    "in addition , nodes and edges have a temporal attribute , which is a temporal element indicating the periods of validity of the node and/or the edge .",
    "the rest of the paper is structured as follows : section  [ sec : related ] discusses related work .",
    "then , section  [ sec : datamodel ] introduces the data model we propose .",
    "section  [ sec : query ] presents teg - ql by example .",
    "section  [ sec : imple ] briefly explains the basics of our implementation and translation from teg - ql to neo4j .",
    "we conclude in section  [ sec : conclu ] .",
    "there is an extensive bibliography on graph database models .",
    "this is comprehensively studied in  @xcite .",
    "surprisingly , given the clear need for temporal graph modeling , querying , and analysis , the number of works on the subject is not that large .",
    "we survey some work next , and compare against our proposal .",
    "the model we describe in the next section , fits in what are called _ attributed graphs _ , which are appropriate for online analytical processing on graphs  @xcite .",
    "for example , attributes in this model allow us to aggregate nodes and edges , provided we define an attribute hierarchy over them .",
    "this is one of the reasons of our modeling choice .",
    "a temporal graph model has been presented in  @xcite , where temporal data are organized in so - called frames , namely the finest unit of temporal aggregation .",
    "a frame is associated with a time interval and allows to retrieve the status of the social network during such interval .",
    "one limitation of that model is that it does not allow registering changes in attributes of the nodes and that frame nodes become too cluttered with edges ( one for each actor and for each relationship that existed in that frame ) .",
    "redundant data are also a problem since each frame is connected to all the existing data , so a frequently changing graph becomes full of redundant connections .",
    "opposite to this model , to keep track of the changes in the value of node attributes , we define _ attribute _ and _ value _ nodes .",
    "khurana and deshpande  @xcite have studied methods to efficiently query historical graphs .",
    "they focus on the particular problem of querying the state of a network as of a certain point ( snapshot ) in time .",
    "also , the authors work on a data model that is based on versioning . basically , they store the current graph , plus a series of deltas , which contain the graph variation over time . our model , on the contrary , is based on timestamps , where the complete history is stored in the same graph .",
    "this is a typical trade - off problem in temporal databases , discussed also in the temporal xml area  @xcite . with goals different than ours , han et al .",
    "@xcite presented an engine for temporal graph mining , and kostakos  @xcite show the use of temporal graphs to represent dynamic events .",
    "we now define the temporal data model supporting our proposal .",
    "we base the model in the notion of attribute graphs , that is , graphs whose nodes and edges are annotated with attributes , describing their characteristics .",
    "[ def : tempgraph ] a _ temporal graph _ is a structure @xmath0 @xmath1 where g is the name of the graph , @xmath2 is a set of edges , and @xmath3 @xmath4 @xmath5 and @xmath6 are sets of nodes , denoted _ object nodes _ , _ edge nodes _ , _ attribute nodes_,and _ value nodes _ , respectively . every node in the graph",
    "is associated with a tuple ( ` name`,`interval ` ) .",
    "the ` name ` represents the content of the node , and the ` interval ` represent the period(s ) in which the node is ( was ) valid and it is a temporal element . as usual in temporal databases ,",
    "a special value @xmath7 is used to represent that the node is currently valid .    in the definition",
    "above , object nodes represent entities ( e.g. , ) , edge nodes represent relationships between object nodes ( e.g. , , , ) , attribute nodes describe entities ( e.g. , ) ; finally , value nodes represent the value of an attribute ( e.g. , ) .",
    "the underlying idea is to allow not only to query the graph , but also to perform olap analysis .",
    "this is why , instead of placing edges between two object nodes , we define _ edge nodes _ , which will make aggregation over edges easier .",
    "we do not address olap analysis of graphs here .",
    "figure  [ fig : title_interval ] depicts a portion of a graph showing the ` name ` and ` interval ` properties of the different node types , using our running example .",
    "the properties labeling the nodes are , from top to bottom , ` i d ` , ` name ` and ` interval ` .",
    "this way , the node with ` id`=4 ( in light green ) is an _ edge node _ , the node with ` id`=1 ( in red ) is an _",
    "object node _",
    ", the node with ` id`=2 ( purple ) is an _ attribute node _ , and the one with ` id`=3 ( grey ) is a _",
    "value node_.        before introducing this graph s constraints , we introduce some notation .",
    "we denote edge nodes as @xmath8 , meaning that @xmath9 is an edge node connected to object nodes @xmath10 and @xmath11 .",
    "an edge will be represented by @xmath12 where @xmath10 and @xmath11 are nodes connected by the edge @xmath13 .",
    "an attribute node will be represented as @xmath14 where @xmath15 is the object or edge node connected to @xmath10 .",
    "finally , we denote a value node as @xmath16 where @xmath10 is the attribute node connected to @xmath17 .",
    "[ def : tempconst ] for the graph in definition [ def : tempgraph ] , the following constraints hold :    1 .",
    "@xmath18[res : ids - start ] 2 .",
    "@xmath19 3 .",
    "@xmath20 4 .",
    "@xmath21[res : ids - end ] 5 .",
    "@xmath22 [ res : same - value ] 6 .",
    "@xmath23 [ res : connection - start ] 7 .",
    "@xmath24 8 .",
    "@xmath25 9 .",
    "@xmath26 [ res : connection - end ] 10 .",
    "@xmath27 [ res : cardinality - start ] 11 .",
    "@xmath28 12 .",
    "@xmath29 13 .",
    "@xmath30 [ res : cardinality - end ] 14 .",
    "@xmath31 [ res : intervals - start ] 15 .",
    "@xmath32 16 .",
    "@xmath33 17 .",
    "@xmath34 [ res : intervals - end ]    constraints [ res : ids - start ] through [ res : ids - end ] state that no two nodes can have the same i d .",
    "constraint [ res : same - value ] requires coalescing all nodes with the same value ; thus , the interval becomes a temporal element which includes all periods where the node had such value .",
    "figure  [ fig : same - value ] explains this .",
    "constraints [ res : connection - start ] through [ res : connection - end ] state how the nodes must be connected , namely : ( a ) object nodes can only be connected to edge nodes or attribute nodes ; ( b ) edge nodes can only be connected to object nodes or attribute nodes ; ( c ) attribute nodes can be connected to non - attribute nodes ; and ( d ) value nodes can only be connected to attribute nodes .",
    "the cardinalities of these connections is stated by constraints [ res : cardinality - start ] through [ res : cardinality - end ] .",
    "edge nodes must be connected to exactly two different object nodes through exactly one edge , attribute nodes must be connected by only one edge to either an object node or an edge node , and value nodes must only be connected to one attribute node with one edge . constraint [ res : cardinality - end ] states that there can not be more than one edge between any given pair of nodes .",
    "constraints [ res : intervals - start ] to [ res : intervals - end ] restrict the values of the ` interval ` property .",
    "finally , constraint [ res : intervals - end ] forces value nodes connected to the same attribute node to have non - overlapping intervals .",
    "[ fig : tiger ]   ( left ) ; a graph compliant with constraint [ res : same - value ] ( right),title=\"fig:\",scaledwidth=35.0% ]",
    "we now sketch through examples our query language .",
    "the syntax of the language resembles the one of sql , having the typical ` select - from - where ` form .",
    "queries , as usual in graphs , are based on pattern matching .",
    "thus , the ` from ` clause contains one or more paths ( of fixed or variable length ) , over which a selection is performed . the `",
    "select ` clause may either mention just attributes or paths .",
    "the temporal semantics in embedded in the language , as is normally the case in temporal databases  @xcite .",
    "that is , the answer to the query is a temporal graph , although the query may not mention temporal attributes .",
    "however , this can be changed by the ` snapshot ` modifier , which allows to retrieve the state of the graph at a certain point in time , or the ` in ` modifier , which allows retrieving the status of the graph in a certain interval .",
    "there is also the possibility of indicating if we want all the components of the graph , or only the object nodes , and so on .",
    "we show these in the examples below .",
    "we start with a query retrieving object nodes .",
    "consider the query _",
    "buildings where john smith lives or lived_. this query just returns the nodes in the graph representing the buildings , and it is expressed in teg - ql as :    ....             select building             from person - livedin->building             where person.name = ' john smith '    ....    we now move to queries returning paths in the ` select ` clause .",
    "these paths are very similar as the paths in cypher ( the query language for neo4j ) paths .",
    "consider the query _ people and buildings such that a person named john smith has lived in such buildings . _",
    "the predicate we are looking for is .",
    "the query is expressed in teg - ql as :    ....              select person - livedin->building              from person - livedin->building              where person.name = ' john smith '    ....    that is , we take the paths matching the ` from ` clause , and filter them using the condition in the where clause .",
    "figure [ fig : queries - pat - attributes ] ( left ) shows the result .",
    "the center node ( in orange ) is the ` person ` node that represents john smith , middle nodes ( yellow ) nodes are the edge nodes representing the relationships ; and outer nodes ( blue ) are the nodes .",
    "if we just want to return certain attributes , we specify them in a comma - separated list , between parenthesis , in the ` select ` clause ( like in sql , also a can be used to represent selecting every attribute of the node ) .",
    "the next query shows this : we just want the street of the buildings satisfying the condition in the previous query .",
    "this is expressed as follows .    ....",
    "select person - livedin->building(street )                  from person - livedin->building                  where person.name = ' john smith '               ....    we only return the attribute of the nodes of type .",
    "figure [ fig : queries - pat - attributes ] ( right ) shows the result . from inside out , the nodes are of type ( in pink , representing john smith ) , , , , and the value node with the street name ( in green ) .",
    "a typical query in social network analysis asks for friendship relationships .",
    "let us start with _ friends of someone called john smith_. below we show the teg - ql expression , and figure  [ fig : john - smith ] depicts the result , showing clusters of people who know someone with the name `` john smith '' .    ....",
    "select person - friend->p2                 from person - friend->person as p2                 where person.name = ' john smith '               ....        we mentioned that teg - ql supports multiple paths in the ` select ` and ` from ` clauses , allowing also a kind of join between paths .",
    "consider the query _ places where john smith lived , along with john s friends .",
    "_ the query reads in teg - ql :    ....                 select *                  from person - livedin->building ,                      person as p2-friend->person as p3                                     where person.name = ' john smith '                        and p2.name= ' john smith '               ....    this query is equivalent to :    ....                 select *                  from person as p2<-friend - person - livedin->building                                     where person.name = ' john smith '                ....    here , the path in the ` from ` clause reminds cypher syntax . note that in neo4j the nodes are of the same type , thus , the path ` person - friend - person ` represents , in an abstract way , a traversal of two nodes , while , physically , the traversal of three nodes .",
    "variable length paths are also supported , allowing for example , to ask for the _ friends of john smith s friends _ , also a typical social network query .    ....",
    "select *                  from person - friend[1 .. 3]->person                                       where person.name = ' john smith '                ....    we conclude the section showing the use of the ` snapshot ` and ` in ` modifiers .",
    "the query below returns all the people named john smith , and the buildings where they live , during 1990 .    ....",
    "select person - livedin->building                  from person - livedin->building                  where person.name = ' john smith '                  snapshot 1990               ....    note that we assume a temporal granularity at the _ year _ level here .",
    "we do not get into the details of how to manipulate granularities here .",
    "figure [ fig : living_in_1990 ] shows the result .",
    "pink nodes represent nodes , blue nodes represent nodes , and yellow nodes represent the relationship .",
    "the in predicate allows selecting an interval where nodes and edges were valid .",
    "the next query is similar to the one above , just selecting those paths existing between 1986 and 1989 .    ....",
    "select *                  from person - livedin->building                  where person.name = ' john smith '                  in [ 1986 - 1989 ]    ....",
    "in this section we explain how teg - ql queries are translated into cypher ( the neo4j language ) , and describe the visual interface , that makes use of the temporal model to navigate the graphs across time . to allow understanding the process ,",
    "let us comment on the cypher syntax .",
    "cypher queries match paths and then return parts of that paths .",
    "a simple query which returns every node , reads :    ....           match ( n )   return n             ....    node labels can be specified by modifying the node matcher , like the following query , which returns all the nodes with the ` object ` label .    ....",
    "match ( n : object ) return n            ....    in neo4j , edges are also labeled , so a path can be queried based on these labels .",
    "the following query shows how we match a path of length one between 2 nodes of type person and the relationship representing friendship .    ....",
    "match ( o : object { title : ' person'})-->(e : edge { title : ' friend ' } )         -- > ( o1:object:'person ' )    return o , e , o1       ....      a teg - ql query is translated and executed as follows .",
    "first , we translate each path in the ` from ` clause , checking if each element of each path has an alias , and building the actual cypher path .",
    "an object node is translated as ` element.alias:object title : element.name ` ; an edge node , is translated as ` element.name:edge title : element.name ` .",
    "after this , we have our first sentence that , for every path in the ` from ` looks like :    ....    match ( element1.alias:object { title : element1.name})-- >        ( element2.name:edge { title : element2.name})-- >        ( element3.alias:object { title : element3.name } ) ...    ....    we then expand the ` select ` clause with the corresponding attributes .",
    "if the attributes are empty we do nothing . if the attribute `` * '' is present , then we want all the attributes .",
    "if the attributes are explicit , we translate them one by one . for this , we build a cypher path from the object or edge nodes , adding the attribute node and the value node(s ) .",
    "for example if we have ` person(age , gender ) ` the translated query will look like this :    ....    match ( person : object { title : person})-->(x : attribute { title : age } )           -- > ( y : value ) ,     match ( person : object { title : person})-->(w : attribute { title : gender } )           -- > ( z : value )        ....    finally we address the ` where ` statement .",
    "we split ` and`s and ` or`s and translate each part as follows .",
    "if an _ i d _ is present , we produce the path to that i d , if it is not already present ; if is a constant we translate it as it is .",
    "for example if in the ` where ` condition we have ` person.age = 12 and person.gender = male ` , the translated query will look like this :    ....   match ( person : object { title : person})-- >          ( x : attribute { title : age})-- > ( y : value ) ,    match ( person : object { title : person})-- >          ( w : attribute { title : gender})-- > ( z : value )    where y = 12 and z = \" male \"     ....    once the query has been executed and the result retrieved , we treat the temporal conditions ` snapshot ` and ` in ` .",
    "this is done by a java application that interprets the query and filters the result retrieved by neo4j .",
    "of course , this is a nave way of treating this part of the query . in future work",
    "we will address the problem of query processing .",
    "finally , we have implemented a prototype to process queries , and a visual interface ] .",
    "this interface allows the user to see the graph ( i.e. , the result of a query ) at a certain point in time ( a snapshot ) , or navigate it across time making use of a sliding bar .",
    "figure [ fig : timeline ] depicts two states of a graph , as displayed in the interface , showing the friends of `` our '' john smith at two points in time .",
    "we ran very preliminary tests over our nave implementation , using a t2.micro on the amazon cloud , with a high frequency intel xeon processors with turbo up to 3.3ghz cpu , and 1 gb ram .",
    "we built a graph containing 1000 people nodes , 100 building nodes , 2500 friendship relationships , and 500 lived - in relationships .",
    "for the ram we had available , we could not build larger neo4j graphs , since neo4j can not handle them .",
    "translation times are negligible , as expected ; just to give an idea of execution times , for queries like the ones showed in the example , those times go from 4 to 6 seconds .",
    "the reader can try these queries at the url mentioned above .",
    "we have described our approach to model and query temporal graph , which we believe is a relevant problem , for example , in social network analysis , given the dynamic nature of such networks .",
    "future work will focus on expanding the capabilities of teg - ql , and , most of all , on addressing the problem of query optimization , for which , we believe that efficient indexing techniques must be developed , opening an interesting research field ."
  ],
  "abstract_text": [
    "<S> in spite of the extensive literature on graph databases ( gdbs ) , temporal gdbs have not received too much attention so far . </S>",
    "<S> temporal gbds can capture , for example , the evolution of social networks across time , a relevant topic in data analysis nowadays . in this paper </S>",
    "<S> we propose a data model and query language ( denoted teg - ql ) for temporal gdbs , based on the notion of attribute graphs . </S>",
    "<S> this allows a straightforward translation to neo4j , a well - known gbd . </S>",
    "<S> we present extensive examples of the use of teg - ql , and comment our implementation .    </S>",
    "<S> neo4j , graph database , temporal graphs </S>"
  ]
}