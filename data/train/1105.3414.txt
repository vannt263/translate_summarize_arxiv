{
  "article_text": [
    "answer set programming ( asp ) , namely logic programming under the answer set semantics @xcite , is a constraint programming paradigm , which has been successfully deployed in many applications @xcite .",
    "recently , asp was extended to include constraints to facilitate reasoning with sets of atoms .",
    "these constraints include weight constraints @xcite , aggregates @xcite and abstract constraints @xcite . among them ,",
    "weight constraints and aggregates are the most widely used constraints in practice . in this paper , logic programs with weight constraints and aggregates",
    "will be referred to as _ weight constraint _ and _ aggregate programs _ , respectively .",
    "the semantics of weight constraint programs , called the _ stable model semantics _ , is well established and implemented in a number of asp solvers @xcite .",
    "especially , the results of the asp solver competitions @xcite show that clasp is an efficient solver that implements this semantics .    for aggregate programs , various semantics",
    "have been proposed @xcite .",
    "the one proposed in @xcite ( previously in @xcite ) , called the _ ultimate stable semantics _ , is based on an iterative construction on partial interpretations .",
    "the same semantics is reformulated by @xcite and extended to logic programs with arbitrary abstract constraint atoms , which embodies a key concept called _ conditional satisfaction_. since this reformulation is conceptually simpler , as it does not resort to 3-valued logic , in this paper we call this semantics _ conditional satisfaction - based_. among the semantics for aggregate programs , this semantics is known to be the most conservative , in the sense that any answer set under this semantics is an answer set under others , but the reverse may not hold . the relationships of these semantics have been studied in @xcite . in this paper , we refer to the semantics based on conditional satisfaction as the _ answer set semantics_.    despite the fact that weight constraint and aggregate programs are among the most popular classes of programs in practice , the relationship among them has not been fully studied , both in semantics and in representation .    in this paper",
    ", we study the relationship between the stable model semantics and the answer set semantics .",
    "we show that for a broad class of weight constraint programs , called _ strongly satisfiable programs _ , the stable model semantics agrees with the answer set semantics .",
    "for example , weight constraint programs where weight constraints are upper bound free are all strongly satisfiable .",
    "this result is useful in that we are now sure that the known properties of the answer sets also hold for these programs .",
    "one important property is that any answer set is a _",
    "well - supported model _",
    "@xcite , ensuring that any conclusion must be supported by a non - circular justification in the sense of @xcite .",
    "our study further reveals that for weight constraint programs where the stable model and answer set semantics disagree , stable models may be circularly justified .",
    "we then show that the gap between the two can be closed by a transformation , which translates an arbitrary weight constraint program to a strongly satisfiable program so that the answer sets of the original program are exactly the stable models of the translated program .",
    "we further demonstrate the precise difference between the two semantics using a more general logic programming framework , logic programs with nested expressions .",
    "we propose yet another transformation from weight constraint programs to logic programs with nested expressions which preserves the answer set semantics .",
    "we compare this transformation to the one given in @xcite , which is faithful to the stable model semantics .",
    "interestingly , the difference is small but subtle : given a weight constraint @xmath0 u$ ] , where @xmath1 and @xmath2 are lower and upper bounds , respectively , and @xmath3 $ ] expresses a collection of literals with weights , while in our transformation the satisfaction of the upper bound is interpreted directly as `` less than or equal to @xmath2 '' , in @xcite the interpretation is by negation - as - failure `` not greater than @xmath2 '' .",
    "the observation that the gap between the answer set and the stable model semantics can be closed by a transformation leads to an approach for computing answer sets of aggregate programs using the asp solvers that implement the stable models semantics of weight constraint programs .",
    "we propose such an approach where aggregate programs are encoded compactly as weight constraint programs and their answer sets are computed using a stable model solver .",
    "we conducted a series of experiments to evaluate this approach .",
    "the results suggest that representing aggregates by weight constraints is a promising alternative to the explicit handling of aggregates in logic programs .",
    "besides efficiency , another advantage is at the system level : an aggregate language can be built on top of a stable models solver with a simple front end that essentially transforms standard aggregates to weight constraints in linear time .",
    "this is in contrast with the state - of - the - art in handling aggregates in asp , which typically requires an explicit implementation for each aggregate .",
    "the paper is organized as follows .",
    "the next section gives preliminary definitions . in section",
    "[ relate ] we relate the stable model semantics with the answer set semantics .",
    "we first establish a sufficient condition for the two to coincide , and then discuss their differences . in section",
    "[ transform ] , we present a transformation to close the gap between the two semantics , followed by section  [ aggr - wprogram ] where we show how to represent aggregate programs by weight constraint programs .",
    "further in section [ nested - expression ] , to pinpoint the precise difference between the stable model semantics and the answer set semantics for weight constraint programs , by proposing a transformation from weight constraint programs to logic programs with nested expressions which preserves the answer set semantics , and comparing this with that of @xcite .",
    "we implemented a prototype system called alparse and in section  [ experiments ] we report some experimental results .",
    "section  [ conclusion ] concludes the paper .",
    "a preliminary version of this paper has appeared as @xcite .",
    "the main extensions here include : ( i ) section [ nested - expression ] , where we propose a transformation from weight constraint programs to logic programs with nested expressions which preserves the answer set semantics - this transformation shows exactly what makes the answer set semantics differ from the stable model semantics ; ( ii ) section [ experiments ] , where experiments are expanded including the benchmarks for aggregate programs used in the 2007 asp solver competition @xcite ; and ( iii ) the proofs of all the theorems and lemmas .",
    "throughout the paper , we assume a fixed propositional language with a countable set of propositional atoms .",
    "a _ weight constraint _ is of the form @xmath4 \\ , u \\label{w - form}\\end{aligned}\\ ] ] where each @xmath5 , @xmath6 is an atom , and each atom and not - atom ( negated atom ) is associated with a _ weight_. atoms and not - atoms are also called _ literals _ ( the latter may be emphasized as _ negative _ literals).the literal set of a weight constraint @xmath7 , denoted @xmath8 , is the set of literals occurring in @xmath7 .",
    "the numbers @xmath1 and @xmath2 are the _ lower _ and _ upper bounds _ , respectively .",
    "the weights and bounds are real numbers .",
    "either of the bounds may be omitted in which case the missing lower bound is taken to be @xmath9 and the missing upper bound by @xmath10 .",
    "a set of atoms @xmath11 satisfies a weight constraint @xmath7 of the form ( [ w - form ] ) , denoted @xmath12 , if ( and only if ) @xmath13 , where @xmath14 @xmath11 satisfies a set of weight constraints",
    "@xmath15 if @xmath16 for every @xmath17 .    a weight constraint @xmath7 is _ monotone _ if for any two sets @xmath18 and @xmath19 , if @xmath20 and @xmath21 , then @xmath22 ; otherwise , @xmath7 is _",
    "nonmonotone_. there are some special classes of nonmonotone weight constraints .",
    "@xmath7 is _ antimonotone _ if for any @xmath18 and @xmath19 , @xmath22 and @xmath21 imply @xmath20 ; @xmath7 is _ convex _",
    "if for any @xmath18 and @xmath19 such that @xmath21 , if @xmath20 and @xmath22 then for any @xmath23 such that @xmath24 we have @xmath25 .    a _ weight constraint program _",
    "is a finite set of _ weight rules _ of the form @xmath26 where each @xmath27 is a weight constraint . given a ( weight ) rule @xmath28 of the above form , we will use @xmath29 to denote @xmath30 and @xmath31 the conjunction of the weight constraints in the body of the rule .",
    "we will use @xmath32 to denote the set of the atoms appearing in a program @xmath33 .",
    "weight constraint programs are often called _ lparse programs _ , which generally refer to the kind of non - ground , function - free logic programs one can write based on the lparse syntax .",
    "these programs are grounded before calling an asp solver . in this paper , for the theoretical study we always assume a given weight constraint program is ground .    given a weight constraint program @xmath33 , if the head of each rule in @xmath33 is of the form @xmath34~1 $ ] where @xmath35 is an atom , then @xmath33 is said to be _",
    "basic_. if , in addition , all the weight constraints in the bodies of rules in @xmath33 are of the form @xmath36~1 $ ] , where @xmath1 is a literal , then we have a normal program . we will simply write a weight constraint @xmath36~1 $ ] as @xmath1 , since they are equivalent in terms of satisfaction .",
    "as pointed out by @xcite , negative weights and negative literals are closely related in that they can replace each other and that one is inessential when the other is available .",
    "negative weights can be eliminated by applying the following transformation @xcite : given a weight constraint @xmath7 of the form ( [ w - form ] ) , if @xmath37 , then replace @xmath38 with @xmath39 and increase the lower bound to @xmath40 and the upper bound to @xmath41 ; if @xmath42 , then replace @xmath43 with @xmath44 and increase the lower bound to @xmath45 and the upper bound to @xmath46 .    for instance",
    ", the weight constraint    @xmath47 ~1 $ ]    can be transformed to    @xmath48 ~4 $ ]    note that this transformation is satisfaction - preserving , in the sense that for any weight constraint @xmath7 and set of atoms @xmath11 , @xmath16 iff @xmath49 , where @xmath50 is obtained by applying the transformation .    from now on",
    ", we assume that negative weights are always eliminated by the above transformation .",
    "the stable models of weight constraint programs are defined using the reduct of weight constraints , which is defined as follows : the _ reduct _ of a weight constraint @xmath7 of the form ( [ w - form ] ) w.r.t .",
    "a set of atoms @xmath11 , denoted by @xmath51 , is the weight constraint @xmath52\\end{aligned}\\ ] ] where @xmath53 .",
    "let @xmath33 be a weight constraint program and @xmath11 a set of atoms .",
    "the reduct of @xmath33 w.r.t .",
    "@xmath11 , denoted @xmath54 , is defined by @xmath55    [ smodels - semantics ] let @xmath33 be a weight constraint program and @xmath56 .",
    "@xmath11 is an _ stable model _ of @xmath33 iff",
    "the following two conditions hold :    1 .",
    "@xmath57 , 2 .",
    "@xmath11 is the deductive closure of @xmath54 .",
    "note that @xmath54 is a monotone basic weight constraint program .",
    "the deductive closure of such a program can be constructed using the operator @xmath58 defined in @xcite .",
    "let @xmath33 be a monotone basic weight constraint program .",
    "the operator @xmath58 is defined as @xmath59    we note that , for a monotone program @xmath33 , the operator @xmath58 is monotone with respect to @xmath19 .",
    "then we have the lemma below .",
    "[ sm - fixpoint ] given a weight constraint program @xmath33 , a set of atoms @xmath11 is a stable model of @xmath33 iff @xmath57 and @xmath60 .",
    "let @xmath33 be a weight constraint program and @xmath11 a set of atoms .",
    "@xmath54 is a monotone program .",
    "the deductive closure of @xmath54 is the least fixpoint of @xmath61 .",
    "then the lemma follows from definition [ smodels - semantics ] .",
    "following @xcite , we define the syntax and semantics for aggregate programs below .",
    "an aggregate is a constraint on a set of atoms taking the form @xmath62 where @xmath63 is an _ aggregate function_. the standard aggregate functions are those in @xmath64sum , count , avg , max , min@xmath65 .",
    "the set @xmath66 is called an _",
    "intensional set _",
    ", where @xmath67 is a predicate , and @xmath68 is a variable which takes value from a set @xmath69 , called the _ variable domain_.",
    "the relational operator @xmath70 is from @xmath71 and @xmath72 is either a variable or a numeric constant .",
    "the _ domain _ of an aggregate @xmath73 , denoted @xmath74 , is the set of atoms @xmath75 .",
    "the size of an aggregate is @xmath76 .",
    "for an aggregate @xmath73 , the intensional set @xmath66 , the variable domain @xmath77 , and the domain of an aggregate @xmath74 can also be a multiset which may contain duplicate members .",
    "let @xmath11 be a set or multiset of atoms .",
    "@xmath11 is a _ model _ of ( satisfies ) an aggregate @xmath73 , denoted @xmath78 , if @xmath79 holds , otherwise @xmath11 is not a model of ( does not satisfy ) @xmath73 , denoted @xmath80 .    for instance , consider the aggregate @xmath81 , where @xmath82 . for the sets @xmath83 and @xmath84",
    ", we have @xmath85 and @xmath86 . for the multiset @xmath87",
    ", we have @xmath88 .",
    "an aggregate program is a set of rules of the form @xmath89 where @xmath90 is an atom and @xmath91 are aggregates.s could also be atoms or negative atoms . here",
    "we focus on aggregates .",
    "the results can be extended to the general case , where the atoms and negative atoms are treated exactly the same as that in normal logic programs @xcite . ] for a rule @xmath28 of the form ( [ aggr - rule - form ] ) , we use @xmath29 and @xmath31 to denote @xmath90 and the set @xmath92 , respectively .",
    "the definition of _ answer set _ of aggregate programs is based on the notion of _ conditional satisfaction_.    [ aggr - cond - sat ] let @xmath73 be an aggregate and @xmath18 and @xmath19 two sets of atoms .",
    "@xmath18 conditionally satisfies @xmath73 , w.r.t .",
    "@xmath19 , denoted @xmath93 , iff @xmath94 and for every set @xmath23 such that @xmath95 , @xmath96 .",
    "@xmath18 conditionally satisfies a set of aggregates @xmath15 w.r.t .",
    "@xmath19 , if @xmath97 for every @xmath98 .    given two sets @xmath18 and @xmath19 , and an aggregate program @xmath33 , the operator @xmath99 is defined as :    @xmath100 .",
    "@xmath101 is monotone w.r.t .",
    "its first argument , given that the second argument is fixed .",
    "following @xcite , given a set of atoms @xmath11 , the least fixpoint of @xmath101 w.r.t @xmath11 is defined as @xmath102 , where @xmath103 and @xmath104 , for all @xmath105 .",
    "[ @xcite ] [ aggr - ans ] let @xmath33 be an aggregate program and @xmath11 a set of atoms .",
    "@xmath11 is an _ answer set _ of @xmath33 iff @xmath11 is a model of @xmath33 and @xmath106 .      to present our results , it is notationally important to lift the concepts of conditional satisfaction and answer set to weight constraints . given a weight constraint @xmath7 , the _ domain of @xmath7 _ , denoted @xmath107 , is the set @xmath108 .",
    "let @xmath7 be a weight constraint and @xmath18 and @xmath19 be two sets of atoms .",
    "@xmath18 conditionally satisfies @xmath7 , w.r.t .",
    "@xmath19 , denoted @xmath109 , if for all @xmath23 such that @xmath110 , we have @xmath111 .",
    "first , the answer sets of a basic weight constraint program are defined using the concept of conditional satisfaction .",
    "[ answer - set ]",
    "let @xmath33 be a basic weight constraint program and @xmath11 a set of atoms .",
    "@xmath11 is an answer set of @xmath33 iff @xmath11 is a model of @xmath33 and @xmath112 .",
    "then , following @xcite , the answer sets of a general weight constraint program are defined as the answer sets of its _",
    "instances_.    let @xmath33 be a weight constraint program , @xmath28 a rule in @xmath33 of the form ( [ w - rule - form ] ) , and @xmath11 a set of atoms .",
    "the _ instance of @xmath28 w.r.t .",
    "@xmath11 _ is    @xmath113    the _ instance of @xmath33 w.r.t .",
    ", denoted @xmath114 , is the program @xmath115    note that an instance of a program is a basic program .",
    "[ w - program - ans ] let @xmath33 be a weight constraint program and @xmath11 a set of atoms .",
    "@xmath11 is an answer set of @xmath33 iff @xmath11 is an answer set of the instance of @xmath33 w.r.t .",
    "@xmath11 .    in the next section",
    ", we will show that , for some weight constraint programs the stable model and the answer set semantics coincide , while , for some others these semantics are different .    before ending this section , we give a useful proposition , which shows a one - to - one correspondence between the stable models / answer sets of an arbitrary weight constraint program and those of its basic program counterparts .",
    "this result will be used later in this paper .",
    "[ basic ] let @xmath33 be a weight constraint program and @xmath11 a model of @xmath33 . define    @xmath116 ,    then , @xmath11 is a stable model ( resp .",
    "answer set ) of @xmath33 iff @xmath11 is a stable model ( resp .",
    "answer set ) of @xmath117 .",
    "the correspondence between answer sets follows from definition [ w - program - ans ] above . for the correspondence between stable models , note that @xmath118 .",
    "in this section , we relate answer sets with stable models .",
    "first , we give a sufficient condition under which they agree with each other .",
    "then , we show the difference between these semantics , that is , stable models that are not answer sets may be circular justified , based on a formal notion of circular justification . at the end , we discuss the related justifications in the literature .      we show that for a broad class of weight constraint programs , the stable models are precisely answer sets , and vice versa .    given a weight constraint @xmath7 of the form ( [ w - form ] ) and a set of atoms @xmath11",
    ", we define @xmath119 and @xmath120 .",
    "since @xmath7 is always clear by context , we will simply write @xmath121 and @xmath122 .    let @xmath11 be a set of atoms and @xmath7 a weight constraint of the form ( [ w - form ] ) .",
    "@xmath7 is said to be _ strongly satisfiable by @xmath11 _ if @xmath16 implies that for any @xmath123 , @xmath124 .",
    "@xmath7 is _ strongly satisfiable _ if for any set of atoms @xmath11 , @xmath7 is strongly satisfiable by @xmath11 .",
    "a weight constraint program @xmath33 is _ strongly satisfiable _ if every weight constraint that appears in the body of a rule in @xmath33 is strongly satisfiable .    intuitively , a strongly satisfiable weight constraint is a weight constraint whose upper bound is large enough to guarantee that , if a set of atoms satisfies the constraint , then any of its subset also satisfies the constraint .",
    "strongly satisfiable programs constitute a nontrivial class of programs .",
    "in particular , weight constraints @xmath7 that possess one of the following syntactically checkable conditions are strongly satisfiable .",
    "* @xmath8 contains only atoms ; * @xmath125 .",
    "note that upper - bound free weight constraints satisfy the second condition above .",
    "the following constraints are all strongly satisfiable : @xmath126~2 \\\\ 1~[a=1 , { \\texttt{not } } b = 2]~3 \\\\ 1~[a=1,{\\texttt{not } } b = 2 ] \\end{array}\\ ] ] but the weight constraint @xmath127~2\\ ] ] is not , since it is satisfied by @xmath128 but not by @xmath129 .",
    "strongly satisfiable weight constraints are not necessarily convex or monotone .",
    "[ strong - satisfiable - not - convex ] let @xmath73 be the following weight constraint @xmath130\\ ] ] since @xmath73 is upper bound free , it is strongly satisfiable . but @xmath73 is neither monotone nor convex , as @xmath131 , @xmath132 , and @xmath133 .",
    "we show that the stable model semantics coincides with the answer set semantics for strongly satisfiable programs .",
    "we need a lemma .",
    "[ key - lemma ] let @xmath7 be a weight constraint of the form ( [ w - form ] ) , and @xmath19 and @xmath11 be sets of atoms such that @xmath134 .",
    "then ,    * if @xmath135 then @xmath136 and @xmath137 . * if @xmath136 and @xmath7 is strongly satisfiable by @xmath11 , then @xmath135",
    ".    \\(i ) we prove it by contraposition .",
    "that is , we show that if @xmath138 or @xmath139 , then @xmath140 .",
    "the case of @xmath138 is simple , which leads to @xmath141 hence @xmath142 .",
    "assume @xmath139 . by definition ,",
    "the lower bound is violated , i.e. , @xmath143 , where @xmath144 .",
    "let @xmath145 , where @xmath146 and @xmath147 .",
    "since @xmath148 and @xmath143 , we have @xmath149 .",
    "then , from @xmath147 and the assumption @xmath139 , we get @xmath150 .",
    "it then follows from @xmath146 that @xmath151 . by construction",
    ", we have @xmath152 , and therefore we conclude @xmath142 .",
    "\\(ii ) assume @xmath153 and @xmath7 is strongly satisfiable by @xmath11 .",
    "we show @xmath139 .",
    "we have either @xmath154 or @xmath155 . if @xmath155 then clearly @xmath139 .",
    "assume @xmath154 .",
    "then from @xmath142 , we have @xmath156 , @xmath157 , such that @xmath151 . since @xmath7 is strongly satisfiable by @xmath11 , if @xmath16 then for any @xmath158 , where @xmath123 , @xmath159 .",
    "assume @xmath16 .",
    "let @xmath18 be such that @xmath160 and @xmath161 .",
    "it is clear that @xmath159 leads to @xmath162 .",
    "thus , since @xmath16 , that @xmath151 is due to the violation of the lower bound , i.e. , @xmath163 .",
    "now consider @xmath164 , i.e. , we restrict @xmath165 to @xmath166 and expand @xmath167 to @xmath122 . note that by construction , it still holds that @xmath168 . clearly , that @xmath151 leads to @xmath169 , which is due to the violation of the lower bound , as @xmath170 , i.e. , we have @xmath171 . by definition , we have @xmath172 , where @xmath173 .",
    "note that since @xmath174 , we have @xmath175 . since @xmath176 , it follows that @xmath177 .",
    "now since @xmath178 is precisely the same constraint as @xmath51 , we have @xmath179 , and therefore @xmath143 .",
    "this shows @xmath139 .",
    "[ smodels - son ] let @xmath33 be a weight constraint program and @xmath56 .",
    "suppose for any weight constraint @xmath7 appearing in the body of a rule in @xmath33 , @xmath7 is strongly satisfiable by @xmath11 .",
    "then , @xmath11 is a stable model of @xmath33 iff @xmath11 is an answer set of @xmath33 .    due to proposition [ basic ] ,",
    "we only need to prove the claim for basic weight constraint programs .",
    "assume @xmath33 is a basic weight constraint program and @xmath11 a model of @xmath33 such that all weight constraints in @xmath33 are strongly satisfiable by @xmath11 .",
    "it suffices to prove that for any positive integer @xmath180 , @xmath181 , by induction on @xmath180 .",
    "_ base case _ : @xmath182 .",
    "we have @xmath183 .",
    "_ induction step _ : assume , for any @xmath184 , @xmath181 , and prove that @xmath185 .",
    "let @xmath35 be an atom such that @xmath186 and @xmath187 .",
    "then there exists a rule @xmath188 such that @xmath189 and @xmath190 , for each @xmath191 .",
    "it then follows from part ( ii ) of lemma [ key - lemma ] that @xmath192 .",
    "then @xmath193 by the induction hypothesis .",
    "so , @xmath194 . thus @xmath195 .",
    "similarly , we can show @xmath196 using part ( i ) of lemma [ key - lemma ] .",
    "thus @xmath185 .",
    "we therefore conclude @xmath197 .",
    "the following theorem follows from theorem  [ smodels - son ] and the definition of strongly satisfiable programs .",
    "[ ss - program - answer - set ] let @xmath33 be a strongly satisfiable weight constraint program and @xmath56 .",
    "@xmath11 is a stable model of @xmath33 iff @xmath11 is an answer set of @xmath33 .",
    "[ coincide ]      it has been shown that for logic programs with arbitrary abstract constraints the semantics based on conditional satisfaction are the most conservative in that the answer sets under this semantics are answer sets / stable models of a number of other semantics @xcite .",
    "it is then expected that the same holds true for programs with concrete constraints such as weight constraints .",
    "let @xmath33 be a weight constraint program .",
    "every answer set of @xmath33 is a stable model of @xmath33 , but the converse does not hold .",
    "let @xmath11 be a set of atoms . using part ( i ) of lemma [ key - lemma ] , it is easy to show by induction that for any positive integer @xmath180 , we have @xmath198 . for",
    "the converse , see the counterexample in example  [ key - example ] below .",
    "question arises as why some stable models are not answer sets . later in section  [ nested - expression ]",
    ", we will give a technical answer to this question .",
    "here , we suggest that in these extra stable models there may exist circular justifications",
    ". consider the following example .",
    "[ key - example ] let @xmath33 be a single - rule program : @xmath199~ 0\\end{aligned}\\ ] ] let @xmath200 and @xmath201 .",
    "the weight constraint @xmath202~ 0 $ ] in @xmath33 is not strongly satisfiable , since although @xmath203 satisfies the upper bound , its subset @xmath204 does not .",
    "both @xmath204 and @xmath203 are stable models by definition [ smodels - semantics ] .",
    "note that this is because @xmath205 and @xmath206 .",
    "but , @xmath204 is an answer set and @xmath203 is not , by definition [ w - program - ans ] .    the reason that @xmath203 is not an answer set of @xmath33 is due to the fact that @xmath35 is derived by its being in @xmath203 .",
    "this kind of circular justification can be seen more intuitively below using equivalence substitutions .",
    "* the weight constraint is substituted with an equivalent aggregate : @xmath207 where @xmath208 . *",
    "the weight constraint is transformed to an equivalent one without negative literal , but with a negative weight , according to @xcite : @xmath209{-1}\\ ] ] * the weight constraint is substituted with an equivalent _ abstract constraint atom _",
    "@xcite , where @xmath210 is a finite set of ground atoms called the _",
    "domain _ , and @xmath211 is a collection of subsets of @xmath210 called _ admissible solutions_. in this example , the set @xmath212 satisfies the abstract constraint atom , since the admissible solution @xmath129 in it is satisfied by @xmath23 . ] : @xmath213    for the claim of equivalence , note that for any set of atoms @xmath11 , we have : @xmath2140 $ ] iff @xmath215{-1}$ ] iff @xmath216 iff @xmath217 .    for logic programs with abstract constraint atoms",
    ", it is often said that all of the major semantics coincide for programs with monotone constraints .",
    "for example , this is the case for the semantics proposed in @xcite .",
    "what is unexpected is that this is not the case for the stable model semantics for weight constraint programs . by the standard definition of monotonicity ,",
    "the constraint @xmath202~ 0 $ ] is actually monotone",
    "!    one may think that the culprit for @xmath203 above is because it is not a minimal model .",
    "however , the following example shows that stable models that are minimal models may still be circularly justified .",
    "consider the following weight constraint program @xmath33 ( obtained from the one in example  [ key - example ] by adding the second rule ) : @xmath199~ 0\\\\ f \\leftarrow { \\texttt{not } } f , { \\texttt{not } } a\\end{aligned}\\ ] ] now , @xmath218 is a minimal model of @xmath33 , and also a stable model of @xmath33 , but clearly @xmath35 is justified by its being in @xmath11 .",
    "we now give a more formal account of _ circular justification _ for stable models , borrowing the idea of _ unfounded sets _",
    "previously used for normal programs @xcite and logic programs with monotone and antimonotone aggregates @xcite .    [ cj ]",
    "let @xmath33 be an weight constraint program and @xmath11 a stable model of @xmath33 .",
    "@xmath11 is said to be _ circularly justified _ , or simply _ circular _ , if there exists a non - empty set @xmath219 such that @xmath220 , @xmath221 does not satisfy the body of any rule @xmath188 such that @xmath222 .",
    "otherwise @xmath11 is said to be _ non - circular_.    [ as - not - cj ] let @xmath33 be a weight constraint program and @xmath11 a stable model of @xmath33 . if @xmath11 is an answer set of @xmath33 , then @xmath11 is not circular .",
    "let @xmath33 be a weight constraint program and @xmath11 an answer set of @xmath33 .",
    "assume @xmath11 is circular .",
    "then there exists a non - empty subset @xmath223 such that @xmath220 , @xmath224 does not satisfy the body of any rule @xmath188 such that @xmath222 . by a simple induction on the construction of @xmath225 , it can be shown that for each of such @xmath226 , we have @xmath227 .",
    "this contradicts the assumption that @xmath11 is an answer set .",
    "example [ key - example ] shows that extra stable models ( the stable models that are not answer sets ) of a program may be circular . however , not all extra stable models are necessarily circular , according to definition [ cj ] .",
    "therefore , the notion of circularity given in definition [ cj ] only serves as a partial characterization of circular justification .",
    "[ non - cj - extra ] consider a weight constraint program @xmath33 that consists of the following three rules .",
    "@xmath228 \\label{rule-2 } \\\\ b & \\leftarrow & [ { \\texttt{not } } b=1]0 \\label{rule-3}\\end{aligned}\\ ] ] @xmath229 is a stable model but not an answer set of @xmath33 .",
    "however , it can be verified that @xmath11 is not circular under definition [ cj ] : @xmath230 can be derived from the first rule if we do nt have @xmath230 , and by the second rule if we do .",
    "we shall comment that other forms of non - circular nature of answer sets have been formulated in different ways , e.g. , by the existence of a level mapping @xcite and by a translation of a constraint to sets of solutions @xcite .",
    "a semantics is a formal account of intuitions of what justifications for atoms in a stable model ought to be . for weight constraint programs ,",
    "there are different intuitions .",
    "consider the single - rule program @xmath33 in example [ key - example ] again @xmath2310\\end{aligned}\\ ] ] one possible interpretation of how @xmath35 is `` justified '' to be in a stable model is by using the transformation proposed in @xcite . by the transformation , @xmath33 is translated to @xmath232 , which consists the following rules : @xmath2330\\\\ b & \\leftarrow & 0[a=1]0\\end{aligned}\\ ] ] it can be verified that the set @xmath234 is a stable model of @xmath232 .",
    "the justification of @xmath35 is : given @xmath11 , @xmath230 can not be in any stable model of @xmath232 by the second rule , then @xmath35 can be derived by the first rule . note that the above transformation introduces the new atom @xmath230 in the translated program @xmath232 .",
    "it assumes that @xmath235 implies something new to the original program .",
    "the justification of atom @xmath35 depends on the truth status of the new atom @xmath230 .",
    "whether such a justification is intuitive seems arguable .",
    "another justification of @xmath35 is by transforming the program @xmath33 to a program with nested expressions @xcite .",
    "we will discuss this in more details later in section [ relation - fl - translation ] .",
    "for this example , we also note that the set @xmath234 is not an answer set under any semantics based on computations studied in @xcite .",
    "we show that the gap between the answer set semantics and the stable model semantics can be closed by a transformation , which translates a weight constraint program to a strongly satisfiable program whose stable models are free of circular justifications . in this way , we are able to apply current asp systems that implement the stable model semantics to compute answer sets for weight constraint programs . in particular , later on",
    "we will use strongly satisfiable programs to represent aggregate programs , so that an implementation of aggregate programs can be realized by an implementation of weight constraint programs .",
    "we present an encoding of a weight constraint , where a weight constraint is represented by two strongly satisfiable weight constraints .",
    "this encoding captures conditional satisfaction for weight constraints in terms of standard satisfaction .",
    "in other words , for weight constraints , the encoding allows conditional satisfaction to be checked by standard satisfaction .",
    "let @xmath7 be a weight constraint of the form ( [ w - form ] ) .",
    "the _ strongly satisfiable encoding _ of @xmath7 , denoted @xmath236 , consists of the following constraints : @xmath237 \\\\ \\\\ w_u : -u+ \\sum_{i=1}^{n}{w_{a_i}}+ \\sum_{i=1}^{m}{w_{b_i}}[{\\texttt{not } } a_1=w_{a_1 } , ... , { \\texttt{not } } a_n = w_{a_n } , b_1=w_{b_1 } , ... , b_m = w_{b_m } ] \\end{array}\\ ] ]    intuitively , @xmath238 and @xmath239 are to code the lower and upper bound constraints of @xmath7 , respectively .",
    "it is easy to verify that the encoding is satisfaction - preserving , as shown below .",
    "[ sat - preserving ] let @xmath7 be a weight constraint , @xmath236 be its strongly satisfiable encoding , and @xmath11 be a set of atoms .",
    "@xmath12 iff @xmath240 and @xmath241 .",
    "the satisfaction of @xmath238 is trivial , since @xmath238 is just the lower bound part of @xmath7 .",
    "we show that @xmath239 is the upper bound part of @xmath7 .",
    "note that the upper bound part of @xmath7 is @xmath242 which is equivalent to @xmath243 by the transformation that eliminates the negative weights ( introduced in section [ sec - sm - semantics ] ) , the constraint ( [ c-2 ] ) is equivalent to the weight constraint @xmath239 .    using lemmas [ key - lemma ] and [ sat - preserving ] , we establish the following theorem .",
    "[ cond - sat - reduct ] let @xmath7 be a weight constraint , @xmath236 be the strongly satisfiable encoding of @xmath7 , and @xmath19 and @xmath11 be two sets of atoms such that @xmath244 . @xmath245 iff @xmath246 and @xmath247 .",
    "( @xmath248 ) since @xmath249 is the same as @xmath51 , by part ( i ) of lemma [ key - lemma ] , we have @xmath250 . in the following ,",
    "we show @xmath247 .",
    "assume @xmath245 and @xmath244 .",
    "then , by definition , we have @xmath22 , and @xmath251 such that @xmath252 and @xmath253 , @xmath111 .",
    "let @xmath254 such that @xmath255 and @xmath256 . under this notation , from the assumption @xmath245 and @xmath244 , we get @xmath252 and @xmath257 .",
    "it follows that @xmath162 , that is , @xmath258 .",
    "this implies @xmath259 , from which the following inequations can be derived    @xmath260 the last one shows @xmath247 .",
    "( @xmath261 ) assume @xmath250 and @xmath262 .",
    "since neither has an upper bound , both of them are strongly satisfiable . from part ( ii ) of lemma [ key - lemma ]",
    ", we have @xmath263 and @xmath264 .",
    "it then follows @xmath251 such that @xmath265 and @xmath257 , @xmath266 and @xmath267 .",
    "then by theorem [ sat - preserving ] , we have @xmath251 such that @xmath265 and @xmath257 , @xmath111 .",
    "this shows @xmath245 .      using the strongly satisfiable encoding of weight constraints ,",
    "a weight constraint program can be translated to a strongly satisfiable program , so that the answer sets of the original program are precisely the stable models of the translated program and vice versa ..    let @xmath33 be a weight constraint program .",
    "the _ strongly satisfiable translation _ of @xmath33 , denoted @xmath268 , is the program obtained by replacing each @xmath7 in the body of rules in @xmath33 by the strongly satisfiable encoding of @xmath7 .",
    "[ ans - strong - programs ] let @xmath33 be a weight constraint program and @xmath11 a set of atoms .",
    "@xmath11 is an answer set of @xmath33 iff @xmath11 is a stable model of @xmath268 .    due to proposition",
    "[ basic ] , we only need to prove the claim for basic weight constraint programs .",
    "using theorem [ cond - sat - reduct ] , we have a one - to - one correspondence between the derivations based on conditional satisfaction ( definition  [ answer - set ] ) and the derivations in the construction of the least model ( definition  [ sm - fixpoint ] ) , which can be shown by an easy induction on the length of these constructions .",
    "consider a program @xmath33 with a single rule : @xmath269 2\\ ] ] @xmath268 consists of @xmath269,~1 [ a = 3]\\ ] ] the weight constraints in @xmath268 are all upper bound - free , hence @xmath268 is strongly satisfiable .",
    "both @xmath270 and @xmath129 are stable models of @xmath33 , but @xmath270 is the only stable model of @xmath268 , which is also the only answer set of @xmath33 .",
    "in this section , we propose an approach to computing the answer sets of an aggregate program .",
    "for this , we translate an aggregate program to a strongly satisfiable weight constraint program and then compute its stable models as answer sets .",
    "this section shows that the aggregates can be encoded as weight constraints . in the following ,",
    "given sets @xmath11 and @xmath19 , it is convenient to express the set @xmath11 , restricted to @xmath19 , as @xmath271 which is defined by @xmath272 .",
    "[ w - encoding ] let @xmath73 be an aggregate in the form ( [ aggregate - form ] ) .",
    "a set of weight constraints @xmath273 is an _ weight constraint encoding _ ( or _ encoding _ ) of @xmath73 , denoted @xmath274 , if for any model @xmath11 of @xmath73 , there is a model @xmath275 of @xmath274 such that @xmath276 , and for any model @xmath275 of @xmath274 , @xmath277 is a model of @xmath73 .",
    "we show the encoding of aggregates of the form ( [ aggregate - form ] ) , where the operator @xmath278 is @xmath279 .",
    "the encoding can be easily extended to other relational operators except for the operator @xmath280 ( more on @xmath280 later in this section ) .",
    "for example , aggregate @xmath281 can be expressed as @xmath282 .",
    "the encoding works for the aggregates whose variable domain contains only integers . for the aggregates whose variable domain contains real numbers ,",
    "each real number can be converted to an integer by multiplying a factor . in this case , the @xmath72 ( in the formula ( [ aggregate - form ] ) ) also needs to be processed accordingly .    for convenience , below we may write negative weights in weight constraints .",
    "recall that negative weights can be eliminated by a simple transformation .    *",
    "@xmath283 * + these aggregates can be encoded by weight constraints rather directly .",
    "for instance , aggregate @xmath284 can be represented by @xmath285\\end{aligned}\\ ] ] where the domain of the aggregate is @xmath286 .",
    "note that , a multiset in @xmath284 can be encoded directly by a weight constraint , since the latter does not require distinct literals in it .",
    "for example , for the aggregate @xmath287 where @xmath68 is defined by the multiset @xmath288 , the aggregate can be encoded by the weight constraint @xmath289 $ ] .",
    "we note that aggregates @xmath290 and @xmath291 can be encoded simply by substituting the weights in ( [ sum ] ) with @xmath292 and @xmath293 ( for avg the lower bound @xmath180 is also replaced by zero ) , respectively . + * @xmath294 * + let @xmath295 be an aggregate .",
    "the idea in the encoding of @xmath73 is that for a set of numbers @xmath296 , the maximum number in @xmath19 is greater than or equal to @xmath180 if and only if    @xmath297    for each atom @xmath298 , two new literals @xmath299 and @xmath300 are introduced .",
    "the encoding @xmath274 consists of the following constraints .",
    "i \\leq n\\\\ \\label{max-2 } 0~[p(a_i)=-d_i , p^{+}(a_i)=d_i],~1\\leq i \\leq n\\\\ \\label{max-3 } 0~[p(a_i)=d_i , p^{-}(a_i)=-d_i],~1\\leq i \\leq n\\\\ \\label{max-4 } 1~[p(a_1)=d_1 , p^{+}(a_1)=d_1 , p^{-}(a_1)=-d_1 , \\nonumber \\\\ ... ,   p(a_n)=d_n , p^{+}(a_n)=d_n , p^{-}(a_n)=-d_n]\\\\ \\label{max-5 } 1~[p(a_1)=1 , ... , p(a_n)=1]\\end{aligned}\\ ] ] where @xmath302 .    in the following , for any model @xmath11 of such an encoding",
    ", @xmath303 means @xmath304 and @xmath305 means @xmath306 .    the constraints ( [ max-1 ] ) , ( [ max-2 ] ) and ( [ max-3 ] ) are used to encode @xmath307 . clearly ,",
    "if @xmath308 , we have @xmath309 and @xmath310 ; if @xmath311 , we have @xmath312 and @xmath313 ; and if @xmath314 , we have @xmath309 or @xmath312 .    the constraint ( [ max-4 ] ) encodes the relation ( [ max - relation ] ) and the constraint ( [ max-5 ] ) guarantees that a model of @xmath274 is not an empty set . + * @xmath315 * + let @xmath316 be an aggregate .",
    "the idea in the encoding of @xmath73 is that for a set of numbers @xmath296 , the minimal number in @xmath19 is greater than or equal to @xmath180 if and only if @xmath317    similar to @xmath294 , the aggregate @xmath315 can be encoded by the following weight constraints .",
    "i \\leq n\\\\ \\label{min-2 } 0~[p^{+}(a_i)=d_i , p(a_i)=-d_i],~1\\leq i \\leq n\\\\ \\label{min-3 } 0~[p^{-}(a_i)=-d_i , p(a_i)=d_i],~1\\leq i \\leq n\\\\ \\label{min-4 } 0~[p(a_1)=d_1 , p^{+}(a_1)=-d_1 , p^{-}(a_1)=d_1 , \\nonumber \\\\ ... ,",
    "p(a_n)=d_n , p^{+}(a_n)=-d_n , p^{-}(a_n)=d_n]~ 0\\\\ \\label{min-5 } 1~[p(a_1)=1 , ... , p(a_n)=1]\\end{aligned}\\ ] ] where @xmath319 .",
    "the constraint ( [ min-1 ] ) , ( [ min-2 ] ) and ( [ min-3 ] ) are the same to the first three constraints in the encoding of @xmath294 ( except for the value of @xmath320 ) , respectively . the constraint ( [ min-4 ] ) encodes the relation ( [ min - relation ] ) and the constraint ( [ min-5 ] ) guarantees that a model of @xmath274 is not an empty set .",
    "+ we note that all the encodings above result in weight constraints whose collective size is linear in the size of the domain of the aggregate being encoded .    in the encoding of @xmath294 ( similarly for @xmath315 ) , the first three constraints are the ones between the literal @xmath298 and the newly introduced literals @xmath299 and @xmath300",
    ". we call them _ auxiliary constraints_.",
    "the last two constraints code the relation between @xmath298 and @xmath321 , where @xmath322 .",
    "we call them _ relation constraints_. let @xmath73 be an aggregate , we denote the set of auxiliary constraints in @xmath274 by @xmath323 and the set of relation constraints by @xmath324 .",
    "if @xmath73 is aggregate @xmath325 , @xmath326 , or @xmath327 , we have that @xmath328 , because no new literals are introduced in their encodings .",
    "[ encoding - aggr ] the set of weight constraint ( [ sum ] ) , the set of weight constraints from ( [ max-1 ] ) to ( [ max-5 ] ) , and the set of weight constraints from ( [ min-1 ] ) to ( [ min-5 ] ) , are weight constraint encodings ( definition [ w - encoding ] ) of the aggregates @xmath325 , @xmath294 , and @xmath315 , respectively .",
    "the proof for the encoding of aggregate @xmath325 is straightforward .",
    "the proof for the encoding of aggregate @xmath315 is similar to that for @xmath294 , which we show below .",
    "let @xmath11 be a set of atoms and @xmath78 .",
    "suppose @xmath329 and @xmath330 .",
    "then , we can construct @xmath275 as follows :    a.   @xmath331 and @xmath332 , if @xmath333 and @xmath334 ; b.   @xmath331 and @xmath335 , if @xmath333 and @xmath336 .",
    "we use @xmath337 to @xmath338 to denote the weight constraints in ( [ max-1 ] ) to ( [ max-5 ] ) .",
    "it is easy to check that the weight constraints @xmath337 , @xmath339 , and @xmath340 are satisfied by @xmath275 . since @xmath330 , we have @xmath341 and @xmath342 .",
    "therefore @xmath343 and @xmath338 are also satisfied by @xmath275 .",
    "so @xmath344 .",
    "let @xmath275 be a set of atoms and @xmath344 .",
    "since @xmath275 satisfies @xmath337 , @xmath339 and @xmath340 , we have @xmath309 and @xmath310 , for @xmath334 ; @xmath312 and @xmath313 , for @xmath311 ; and @xmath309 or @xmath312 , if @xmath314 . since @xmath345 and @xmath346 , there must be an @xmath347 , such that @xmath334 and @xmath348 .",
    "that is , @xmath349 .",
    "then , we have @xmath78 .",
    "we translate an aggregate program @xmath33 to a weight constraint program , denoted @xmath350 , as follows :    1 .",
    "for each rule of the form ( [ aggr - rule - form ] ) in @xmath33 , we include in @xmath351 a weight rule of the form @xmath352 where @xmath353 is the conjunction of the weight constraints that encode the aggregate @xmath354 ; and 2 .",
    "if there are newly introduced literals in the encoding of aggregates , the _ auxiliary rule _ of the form @xmath355 is included in @xmath351 , for each auxiliary constraint @xmath7 of each atom @xmath298 in the aggregates .",
    "note that a weight constraint program @xmath33 can be translated to a strongly satisfiable program using the translation @xmath268 given in section [ transform ] .",
    "we have the following theorem establishing the correctness of the transformation @xmath356 .",
    "[ thm - translation ] let @xmath33 be an aggregate program where the relational operator is not @xmath280 . for any stable model @xmath11 of @xmath357 , @xmath358 is an answer set of @xmath33 . for any answer set @xmath11 for @xmath33 ,",
    "there is a stable model @xmath275 of @xmath357 such that @xmath359",
    ".    the rules of the form ( [ transformed - rule - form ] ) are the translated counterpart of the rules in @xmath33",
    ". the auxiliary rules of the form ( [ auxiliary - rule - form ] ) are added to enforce the auxiliary constraints .",
    "note that @xmath357 is a strongly satisfiable program .",
    "then the theorem follows from theorem [ ans - strong - programs ] and theorem [ encoding - aggr ] .",
    "* remark * for an aggregate where the relation operator is not @xmath280 , the aggregate can be encoded by a conjunction of weight constraints as we have shown in this section . in this case",
    ", logic equivalence leads to equivalence under conditional satisfaction .",
    "that is why we only need to ensure that an encoding is satisfaction - preserving .",
    "for an aggregate where the relation operator is @xmath280 , two classes are distinguished .",
    "one consists of aggregates of the forms @xmath360 .",
    "for these aggregates , the operator @xmath280 can be treated as the disjunction of the operators @xmath361 and @xmath362. consider the aggregate @xmath363 .",
    "@xmath73 is logically equivalent to @xmath364 , where @xmath365 and @xmath366 .",
    "let @xmath18 and @xmath19 be two sets of atoms , it is easy to show that @xmath93 iff @xmath367 or @xmath368 .",
    "the other class consists of the aggregates of the forms @xmath369 , @xmath370 , @xmath371 , and @xmath372 . for these aggregates ,",
    "the operator @xmath280 can not be treated as the disjunction of @xmath361 and @xmath362 , since the conditional satisfaction may not be preserved .",
    "below is an example .",
    "consider the aggregates @xmath373 , @xmath374 , and @xmath375 .",
    "note that @xmath73 is logically equivalent to @xmath364 .",
    "consider @xmath376 and @xmath377 . while @xmath19 conditionally satisfies @xmath73 w.r.t .",
    "@xmath11 ( i.e. , @xmath378 ) , it is not the case that @xmath19 conditionally satisfies @xmath379 w.r.t .",
    "@xmath11 or @xmath19 conditionally satisfies @xmath380 w.r.t . @xmath11 .",
    "in this section , we further relate answer sets with stable models in terms of logic programs with nested expressions .",
    "we formulate a transformation of weight constraint programs to programs with nested expressions and compare this transformation to the one in @xcite .",
    "the comparison reveals that the difference of the semantics lies in the different interpretations of the constraint on the upper bounds of weight constraints in a program : while our transformation interprets it directly , namely as `` less than or equal to '' , the one in @xcite interprets it as `` not greater than '' , which may create double negations ( the atoms that are preceded by ` not ` ` not ` ) in nested expressions .",
    "it is the semantics of these double negations that differentiates the two semantics .      in the language of nested expressions ,",
    "_ elementary formulas _ are atoms .",
    "the classical negation is irrelevant here . ] and symbols @xmath381 ( false ) and @xmath382 ( true ) .",
    "_ formulas _ are built from elementary formulas using the unary connective @xmath383 and the binary connectives , ( conjunction ) and ; ( disjunction ) .",
    "a rule with nested expressions is of the form @xmath384 where both @xmath385 and @xmath386 are formulas . for a rule @xmath28 of the form ( [ nested - rule - form ] )",
    ", we use @xmath29 and @xmath31 to denote the @xmath386 and the @xmath385 of @xmath28 , respectively .",
    "a program with nested expressions is a set of rules with nested expressions .",
    "the satisfaction of a formula by a set of atoms @xmath11 is defined as follows :    * for a literal @xmath1 , @xmath387 if @xmath388 * @xmath389 * @xmath390 * @xmath391 if @xmath392 and @xmath393 * @xmath394 if @xmath392 or @xmath393 * @xmath395 if @xmath396 .",
    "the reduct of a formula @xmath397 with respect to a set of atoms @xmath11 , denoted @xmath398 , is defined recursively as follows :    * for an elementary formula @xmath397 , @xmath399 * @xmath400 * @xmath401 * @xmath402    the reduct of a program @xmath33 with respect to a set of atoms @xmath11 is the set of rules @xmath403 for each rule of the form ( [ nested - rule - form ] ) in @xmath33 .",
    "the concept of a stable model is defined as follows .",
    "[ @xcite ] let @xmath33 be a logic program with nested expressions and @xmath11 a set of atoms .",
    "@xmath11 is a stable model of @xmath33 if @xmath11 is a minimal model of @xmath54 .",
    "we present a nested expression encoding , called the _ direct nested expression encoding _ of weight constraints .",
    "we show that conditional satisfaction of a weight constraint can be captured by the standard satisfaction of the reduct of the encoding of the weight constraint .    in the rest of the paper",
    ", we will use the following notation : for a set of literals @xmath68 , we define @xmath404 and @xmath405 .    given a weight constraint @xmath7 of the form ( [ w - form ] ) , the _ nested expression encoding _ of @xmath7 , denoted @xmath406 , is the formula @xmath407\\end{aligned}\\ ] ] where @xmath408 is the set of atoms in @xmath7 . for @xmath409 and @xmath410 for @xmath411 .",
    "then we can rewrite this formula as @xmath412\\ ] ] ]    intuitively , @xmath406 is a nested expression representing the sets that satisfy @xmath7 .",
    "let @xmath4131 $ ] be a weight constraint .",
    "the subsets of @xmath408 that satisfy @xmath7 are @xmath414 and @xmath415 .",
    "thus @xmath416 .    an interesting result of the directed encoding",
    "is that for the resulting nested expression , conditional satisfaction is precisely the satisfaction of the _ reduct _ of the expression .",
    "that is , given a weight constraint @xmath7 and two sets of atoms @xmath134 , @xmath417 if and only if @xmath418 .    before giving this result",
    ", we prove a lemma first .",
    "[ nested - lemma-1 ] let @xmath7 be a weight constraint , @xmath406 its nested expression encoding , and @xmath236 its strongly satisfiable encoding .",
    "then , for any two sets of atoms @xmath19 and @xmath11 such that @xmath244 , @xmath419 iff @xmath246 and @xmath247 .",
    "in this proof , given a weight constraint @xmath7 of the form ( [ w - form ] ) , we denote @xmath420 and @xmath421 ; we express @xmath406 as a disjunction of conjunctions @xmath422 s , i.e. , @xmath423 , for some @xmath424 . for notational convenience",
    ", such a conjunction may be referred to as a set as well , i.e. , given a conjunction @xmath425 , we may use the same @xmath422 to denote the set @xmath426 , and vice versa .",
    "given a set @xmath19 , we use the notation @xmath427 .    since the proof is mainly about mathematical transformation , for convenience , we present it as a set of mechanical inferences .",
    "( @xmath248 ) we give a detailed proof for @xmath250 .",
    "the proof of @xmath247 is similar .",
    "\\(1 ) assume @xmath418 and @xmath134 .",
    "\\(2 ) @xmath428 such that @xmath429 , due to ( 1 ) and the definition of @xmath406 .",
    "\\(3 ) @xmath430 , we have @xmath431 , that is , @xmath432 , due to ( 2 ) .",
    "\\(4 ) @xmath433 , due to ( 2 ) .",
    "\\(5 ) @xmath434 , due to ( 2 ) .",
    "\\(6 ) @xmath435 , due to ( 5 ) .",
    "\\(7 ) @xmath436 , due to ( 4 ) .",
    "\\(8 ) @xmath437 where @xmath438 , due to ( 3 ) .",
    "\\(9 ) @xmath439 , due to ( 6 ) , ( 7 ) and ( 8) .",
    "\\(10 ) @xmath440 , due to ( 9 ) .",
    "\\(11 ) @xmath441 , due to ( 10 ) .",
    "\\(12 ) @xmath246 , due to ( 11 ) .",
    "( @xmath261 )    \\(1 ) assume @xmath246 , @xmath247 and @xmath134 .",
    "\\(2 ) @xmath442 , due to ( 1 ) .",
    "\\(3 ) @xmath443 , due to ( 1 ) .",
    "\\(4 ) @xmath444 , due to ( 3 ) .",
    "\\(5 ) let @xmath445 .",
    "\\(6 ) @xmath446 , due to ( 5 ) and ( 1 ) .",
    "\\(7 ) @xmath447 , due to ( 4 ) and ( 6 ) .",
    "\\(8 ) @xmath448 , due to ( 2 ) and ( 7 ) .",
    "\\(9 ) @xmath449 , due to ( 8) .",
    "\\(10 ) @xmath450 , due to ( 9 ) .",
    "\\(11 ) @xmath451 , due to ( 5 ) .",
    "\\(12 ) @xmath418 , due to ( 11 ) .",
    "[ nested - theorem-1 ] let @xmath7 be a weight constraint , and @xmath19 and @xmath11 two sets of atoms . then",
    ", @xmath245 iff @xmath419 .",
    "this follows from theorem [ cond - sat - reduct ] and lemma [ nested - lemma-1 ] .      using the direct nested expression encoding of weight constraints ,",
    "a weight constraint program can be translated to a program with nested expressions , such that the answer sets of the original program are precisely the stable models of the translated program and vice versa .",
    "let @xmath33 be a weight constraint program and @xmath28 a rule of the form ( [ w - rule - form ] ) in @xmath33 .",
    "the _ nested expression translation of @xmath28 _ , denoted @xmath452 , is the rule of the form @xmath453 where @xmath454 are the positive literals in @xmath30 .",
    "intuitively , the conjunctive term @xmath455 represent that we are free to choose the atoms in the head of the rule to include in an answer set .",
    "let @xmath33 be a weight constraint program .",
    "the _ nested expression translation of @xmath33 _ , denoted @xmath456 , is the program obtained by replacing each rule @xmath28 in @xmath33 by @xmath452 .",
    "let @xmath33 be a weight constraint program , @xmath28 a rule in @xmath33 , and @xmath11 a set of atoms . by the definitions of @xmath452 and the reduct of a nested expression , we know that the reduct of @xmath452 w.r.t .",
    "@xmath11 , denoted @xmath457 , is the rule of the form @xmath458 where @xmath459 .",
    "we will use this fact in the proofs below .",
    "our main result is that the answer sets of a weight constraint program coincide with the stable models of its nested expression translation . to establish this , we need to show a one - to - one correspondence between the least fixpoint of the operator @xmath460 applied on a weight constraint program is the unique minimal model of the reduct of its nested expression translation .    to show the main theorem , we prove two lemmas firstly .",
    "one shows the coincidence of the satisfaction of a weight constraint , its nested expression encoding , and the reduct of the nested encoding . then using this lemma",
    ", we show the coincidence of the models of a weight constraint program , its nested expression translation , and the reduct of its nested expression translation .",
    "the later lemma helps to establish the correspondence between the least fixpoint of the operator @xmath460 and the minimal model of the program reduct .",
    "[ ne - reduct - satisfaction ] let @xmath7 be a weight constraint of the form ( [ w - form ] ) , @xmath406 its nested expression encoding , and @xmath11 a set atoms .",
    "then , @xmath16 iff @xmath461 iff @xmath462 .    that @xmath12 iff @xmath461 follows directly from the definition of @xmath406 .",
    "we give a proof of the claim @xmath461 iff @xmath462 .",
    "suppose @xmath463 .",
    "( @xmath248 ) since @xmath464 , there is an @xmath450 such that @xmath465 and @xmath466 . by the definition of the reduct of a nested expression , we have @xmath467 and then @xmath462 .",
    "( @xmath261 ) since @xmath462 , there is an @xmath450 such that @xmath468 . by the definition of reduct , we have @xmath465 and @xmath466",
    ". therefore @xmath469 and then @xmath461 .",
    "[ ne - program - reduct - model ] let @xmath33 a weight constraint program and @xmath11 a set of atoms . @xmath57",
    "iff @xmath470 iff @xmath471 .",
    "the equivalence @xmath57 iff @xmath470 holds simply because @xmath456 is satisfaction - preserving .",
    "we give a proof of the statement @xmath470 iff @xmath471 .",
    "( @xmath248 ) suppose @xmath470 .",
    "let @xmath472 be a rule of the form ( [ ne_rule_reduct ] ) .",
    "if @xmath473 for all @xmath474 , then by lemma [ ne - reduct - satisfaction ] , we have @xmath475 for all @xmath474 . since @xmath470 , then @xmath476",
    "again by lemma [ ne - reduct - satisfaction ] , we know @xmath477 . since @xmath459 , we have @xmath478 . as",
    "@xmath479 is arbitrary in @xmath480 , we conclude @xmath471 .",
    "( @xmath261 ) suppose @xmath471 .",
    "let @xmath481 be a rule of the form ( [ ne - rule - form ] ) .",
    "if @xmath475 for all @xmath482 , then by lemma [ ne - reduct - satisfaction ] , we have @xmath473 for all @xmath474 . since @xmath471 , then @xmath477",
    "again by lemma [ ne - reduct - satisfaction ] , we know @xmath476 .",
    "it is obvious that @xmath483 .",
    "so @xmath484 .",
    "as @xmath28 is any rule in @xmath456 , we have @xmath470 .",
    "[ nested - theorem ] let @xmath33 be a weight constraint program , @xmath456 the nested expression translation of @xmath33 , and @xmath11 a set of atoms .",
    "then , @xmath11 is an answer set of @xmath33 iff @xmath11 is a stable model of @xmath456 .",
    "( @xmath248 ) let @xmath33 be a weight constraint program and @xmath11 an answer set of @xmath33",
    ". then @xmath57 and @xmath485 . by lemma [ ne - program - reduct - model ] , @xmath470 and @xmath471 .",
    "we prove by contradiction that @xmath11 is a minimal model of @xmath480 .",
    "suppose for some @xmath486 such that @xmath487 .",
    "note that by lemma [ ne - program - reduct - model ] , we also have @xmath488 .",
    "let @xmath489 .",
    "then , there exists a rule @xmath490 of the form ( [ w - rule - form ] ) satisfying that @xmath491 and @xmath492 such that @xmath493 , for all @xmath494 .",
    "note that @xmath495 , hence theorem [ nested - theorem-1 ] is applicable , from which we know @xmath496 , for all @xmath494 . since @xmath497 , we must have @xmath498 , which contradicts to the assumption that @xmath499 .",
    "we therefore conclude that @xmath11 is a minimal model of @xmath480 , i.e. , @xmath11 is a stable model of @xmath456 .",
    "( @xmath261 ) let @xmath33 be a weight constraint program and suppose @xmath11 is a minimal model of @xmath480 .",
    "by lemma [ ne - program - reduct - model ] , @xmath11 is a model of @xmath33 . by the definitions of the operator @xmath101 and @xmath114",
    ", we have @xmath500 .",
    "let @xmath501 .",
    "we will prove that @xmath502 .",
    "for this , let s assume it is not the case , i.e. , @xmath503 . since @xmath11 is a minimal model of @xmath480 , we have @xmath504 .",
    "then there is a rule @xmath28 of the form ( [ w - rule - form ] ) in @xmath33 and its corresponding rule @xmath452 of the form ( [ ne_rule_reduct ] ) in @xmath480 such that @xmath505 for all @xmath506 , and @xmath507 . since @xmath508 , for the rule @xmath452 , we have @xmath509 .",
    "it follows that for some @xmath510 , @xmath511 . as @xmath507",
    ", it must be the case that @xmath512 such that @xmath513 . by theorem [ nested - theorem-1 ] , however , that @xmath505 for all @xmath506 leads to @xmath514 for all @xmath515 .",
    "then , by the definitions of the operator @xmath101 and @xmath114 , we must have @xmath516 .",
    "this is a contradiction .",
    "therefore , it must be the case that @xmath502 , and it follows that @xmath11 is an answer set of @xmath33 .",
    "consider the program @xmath33 in example [ non - cj - extra ] .",
    "its nested expression translation @xmath456 consists of the following rules .",
    "@xmath517 it can be verified that the only stable model of @xmath456 is @xmath129 , which is also the only answer set of @xmath33 .",
    "ferraris and lifschitz @xcite proposed a nested expression encoding of weight constraints . using this encoding , a weight constraint program can be translated to a program with nested expressions , such that there is a one - to - one correspondence between the stable models of the weight constraint program and the stable models of its translated program with nested expressions .",
    "the difference between our nested expression translation and ferraris and lifschitz s translation ( fl - translation ) lies in the interpretation of the upper bound constraint of a weight constraint .    to illustrate this difference ,",
    "let s denote a weight constraint @xmath7 of the form ( [ w - form ] ) by @xmath518u$ ] , where @xmath3=[a_1 = w_{a_1}, ...",
    ",a_n = w_{a_n } , { \\texttt{not } } b_1= w_{b_1}, ... ,{\\texttt{not } } b_m= w_{b_m}]$ ] .",
    "we call that @xmath518 $ ] and @xmath3u$ ] the lower bound constraint and upper bound constraint of @xmath7 , respectively .",
    "obviously , the lower bound and upper bound constraints are also weight constraints .    in our translation , the upper bound constraint @xmath3u$ ] is _ directly _ encoded by the sets of atoms that satisfy it . in the fl - translation , @xmath3u$ ]",
    "is encoded as @xmath519 $ ] , where @xmath520 $ ] is further encoded as the sets of atoms that satisfy the weight constraint @xmath520 $ ] , possibly creating double negations .",
    "this difference is the _ only _ reason that the stable models of our translated program are the answer sets of the original program while the stable models of the fl - translated program are the stable models of the original program .",
    "it should be clear that the extra stable models that are not answer sets are created by double negations generated by the indirect interpretation in the fl - translation .",
    "we use the following example for an illustration .",
    "consider the program @xmath33 in example [ key - example ] , which consist of a single rule @xmath5210\\end{aligned}\\ ] ] by our translation , @xmath456 consists of @xmath522 the only stable model of @xmath456 is @xmath270 , which is the unique answer set of @xmath33 . by the fl - translation , the translated program @xmath117 is @xmath523 the stable models of @xmath117 are @xmath270 and @xmath129 . among them ,",
    "the set @xmath129 is not an answer set , but it is justified by the stable model semantics through the double negation @xmath524 .",
    "the theoretical studies show that an aggregate program can be translated to a weight constraint program whose stable models are precisely the answer sets of the original program .",
    "this leads to a prototype implementation called alparse to compute the answer sets for aggregate programs . in alparse ,",
    "an aggregate program is firstly translated to a strongly satisfiable program using the translation given in section [ aggr - wprogram ] , then the stable models of the translated strongly satisfiable program are computed using an asp solver that implements the stable model semantics for weight constraint programs . in the next two subsections , we use smodels version 2.34 and clasp version 2.0.3 respectively as the underlying asp solver of alparse and",
    "compare alparse with the implementations of aggregate programs smodels@xmath525 and dlv version 2007 - 10 - 11 .",
    "the experiments are run on scientific linux release 5.1 with 3ghz cpu and 1 gb ram .",
    "the reported time of alparse consists of the transformation time ( from aggregate programs to strongly satisfiable programs ) , the grounding time ( calling to lparse version 1.1.2 for smodels and gringo version 2.0.3 for clasp ) , and the search time ( by smodels or clasp ) .",
    "the time of smodels@xmath525 consists of grounding time , search time and unfolding time ( computing the solutions to aggregates ) .",
    "the time of dlv includes the grounding time and search time ( the grounding phase is not separated from the search in dlv ) .",
    "all times are in seconds .      in this section ,",
    "we compare our approach with two systems , smodels@xmath525 and dlv .    * comparison with smodels@xmath525 *    we compare the encoding approach proposed in last section to the unfolding approach implemented in the system smodels@xmath525 @xcite.ielkaban / asp - aggr.html . ] the aggregates used in the first and second set of problems ( the company control and employee raise problems ) are @xmath325 ; the third set of problems ( the party invitation problems ) are @xmath326 , and the fourth and fifth set of problems ( the nm1 and nm2 , respectively ) are @xmath294 and @xmath315 , respectively .",
    "the experimental results are reported in table [ smodels - a ] , where the `` sample size '' is measured by the argument used to generate the test cases .",
    "the times are the average of one hundred randomly generated instances for each sample size .",
    "the results show that smodels is often faster than smodels@xmath525 , even though both use the same search engine .",
    "scale - up could be a problem for smodels@xmath525 , due to exponential blowup .",
    "for instance , for an aggregate like @xmath526 , smodels@xmath525 would list all _ aggregate solutions _",
    "@xcite in the unfolded program , whose number is @xmath527 . for a large domain @xmath19 and @xmath180 being around @xmath528 ,",
    "this is a huge number .",
    "if one or a few solutions are needed , alparse takes much less time to compute the corresponding weight constraints than smodels@xmath525 .",
    "* comparison with dlv *    in @xcite the seating problem was chosen to evaluate the performance of dlv .",
    "the problem is to generate a sitting arrangement for a number of guests , with @xmath529 tables and @xmath530 chairs per table .",
    "guests who like each other should sit at the same table ; guests who dislike each other should not sit at the same table .",
    "the aggregate used in the problem is @xmath326 .",
    "we use the same setting to the problem instances as in @xcite .",
    "the results are shown in table [ seating ] .",
    "`` tables '' and `` chairs '' are the number of tables and the number of chairs at each table , respectively .",
    "the instance size is the number of atom occurrences in a ground program .",
    "we report the result of the average over one hundred randomly generated instances for each problem size .",
    "the experiments show that , by encoding logic programs with aggregates as weight constraint programs , alparse solves the problem efficiently . for large instances ,",
    "the running time of alparse is about one order of magnitude lower than that of dlv and the sizes of the instances are also smaller than those in the language of dlv .",
    "we use the benchmarks reported in an asp solver competition and run all instances for each benchmark . in the experiments",
    ", we set the cutoff time to 600 seconds .",
    "the instances that are solved in the cutoff time are called `` solvable '' , otherwise `` unsolvable '' .",
    "table [ alparse - summary ] is a summary of the results . in the table ,",
    "the  time  is the average running time in seconds for the solvable instances .",
    "it can be seen that alparse constantly outperforms dlv by several orders of magnitude , except for the benchmark of towers of hanoi .",
    "the system clasp has progressed to support aggregates @xmath325 , @xmath315 and @xmath294 .",
    "the aggregates used in the benchmarks are @xmath325 except for towers of hanoi where the aggregate @xmath294 is used .",
    "the aggregate @xmath325 is essentially the same as weight constraints .",
    "we compare the clasp programs with the aggregate @xmath294 and the corresponding translated weight constraint programs ( note that , the answer sets of this aggregate program correspond to those of the corresponding weight constraint program ) .",
    "the performances of clasp on these two kinds of programs are similar .",
    "as we have mentioned , the transformation approach indicates that it is important to focus on an efficient implementation of aggregate @xmath325 rather than on the implementation of other aggregates one by one , since they can be encoded by @xmath325 .",
    "can be translated to @xmath325 , using a logarithm transformation , thanks to tomi janhunen for the comments during the presentation of @xcite . ]",
    ".benchmarks used by smodels@xmath525 [ cols=\"<,>,>,>\",options=\"header \" , ]",
    "we have shown that for a large class of programs the stable model semantics coincides with the answer set semantics based on conditional satisfaction . in general , answer sets admitted by the latter are all stable models . when a stable model is not an answer set , it may be circularly justified .",
    "we have proposed a transformation , by which a weight constraint program can be translated to strong satisfiable program , such that all stable models are answer sets and thus well - supported models .",
    "we have also given another transformation from weight constraint programs to logic programs with nested expressions which preserves the answer set semantics .",
    "in conjunction with the one given in @xcite , their difference reveals precisely the relation between stable models and answer sets .    as an issue of methodology",
    ", we have shown that most standard aggregates can be encoded by weight constraints .",
    "therefore the asp systems that support weight constraints can be applied to efficiently compute the answer sets of logic programs with aggregates .",
    "the experimental results demonstrate the effectiveness of this approach .",
    "currently , alparse does not handle programs with aggregates like @xmath531 or @xmath532 , due to the fact that the complexity of such programs is higher than @xmath533 .",
    "what is the best way to include this practically requires further investigation ."
  ],
  "abstract_text": [
    "<S> weight constraint and aggregate programs are among the most widely used logic programs with constraints . in this paper </S>",
    "<S> , we relate the semantics of these two classes of programs , namely the stable model semantics for weight constraint programs and the answer set semantics based on conditional satisfaction for aggregate programs . both classes of programs </S>",
    "<S> are instances of logic programs with constraints , and in particular , the answer set semantics for aggregate programs can be applied to weight constraint programs . </S>",
    "<S> we show that the two semantics are closely related . </S>",
    "<S> first , we show that for a broad class of weight constraint programs , called _ strongly satisfiable programs _ , the two semantics coincide . </S>",
    "<S> when they disagree , a stable model admitted by the stable model semantics may be circularly justified . </S>",
    "<S> we show that the gap between the two semantics can be closed by transforming a weight constraint program to a strongly satisfiable one , so that no circular models may be generated under the current implementation of the stable model semantics . </S>",
    "<S> we further demonstrate the close relationship between the two semantics by formulating a transformation from weight constraint programs to logic programs with nested expressions which preserves the answer set semantics . </S>",
    "<S> our study on the semantics leads to an investigation of a methodological issue , namely the possibility of compact representation of aggregate programs by weight constraint programs . </S>",
    "<S> we show that almost all standard aggregates can be encoded by weight constraints compactly . </S>",
    "<S> this makes it possible to compute the answer sets of aggregate programs using the asp solvers for weight constraint programs . </S>",
    "<S> this approach is compared experimentally with the ones where aggregates are handled more explicitly , which show that the weight constraint encoding of aggregates enables a competitive approach to answer set computation for aggregate programs .    </S>",
    "<S> [ firstpage ]    stable model , weight constraint , aggregates , logic programs with constraints . </S>"
  ]
}