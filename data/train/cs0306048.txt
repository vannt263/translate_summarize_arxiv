{
  "article_text": [
    "scientists have recognized the importance of portable and efficient mechanisms for storing large datasets created and used by their applications .",
    "the network common data form ( netcdf ) @xcite is one such mechanism used by a number of applications .",
    "netcdf intends to provide a common data access method for atmospheric science applications to deal with a variety of data types that encompass single - point observations , time series , regularly spaced grids , and satellite or radar images @xcite .",
    "today several organizations have adopted netcdf as a data access standard @xcite .",
    "the netcdf design consists of both a portable file format and an easy - to - use application programming interface ( api ) for storing and retrieving netcdf files across multiple platforms .",
    "more and more scientific applications choose netcdf as their output file format .",
    "while these applications become computational and data intensive , they tend to be parallelized on high - performance computers . hence , it is highly desirable to have an efficient parallel programming interface to the netcdf files .",
    "unfortunately , the original design of netcdf interface is proving inadequate for parallel applications because of its lack of a parallel access mechanism .",
    "in particular , there is no support for concurrently writing to a netcdf file .",
    "hence , parallel applications operating on netcdf files must serialize access .",
    "traditionally , parallel applications write to netcdf files through one of the allocated process which easily becomes a performance bottleneck .",
    "the serial i / o access is both slow and cumbersome to the application programmer .    to facilitate parallel i / o operations ,",
    "we have defined a parallel api for concurrently accessing netcdf files . with minimum changes to the names and argument lists , this interface maintains the look and feel of the serial netcdf interface while the implementation underneath incorporates well - known parallel i / o techniques such as collective i / o to allow high - performance data access .",
    "we implement this work on top of mpi - io , which is specified by mpi-2 standard @xcite and is freely available on most platforms .",
    "since mpi has become de facto parallel mechanism for communication and i / o on most parallel environments , this approach is portable across different platforms .",
    "hierarchical data format version 5 ( hdf5 ) @xcite also provides a portable file format and programming interfaces for storing multidimensional arrays together with ancillary data in a single file .",
    "it supports parallel i / o and its implementation is also built on top of mpi - io .",
    "however , the hdf5 api is too flexible and cumbrous to become an easy - to - use standard since it adds more programming features and completely re - designs the api from its previous version .",
    "our parallel netcdf interface , on the other hand , is more concise , closer to the original api , and goes much closer to mpi - io interface , which introduces less overhead while providing more optimization opportunities for performance enhancement .",
    "the goal of this work is to make the parallel netcdf interface a data access standard for parallel scientific applications .",
    "we run a couple of benchmarks using parallel netcdf and parallel hdf5 , exploring both artificially made access patterns from our own benchmark and the ones from a real application called flash @xcite . in our experiments ,",
    "parallel netcdf brings significant i / o improvement and shows better performance than parallel hdf5 in the flash i / o benchmark @xcite .",
    "the rest of this paper is organized as follows .",
    "section [ sec : related ] reviews some related work . section [ sec : background ] presents the design background of netcdf and points out its potential usage in parallel scientific applications .",
    "the design and implementation of our parallel netcdf is described in section [ sec : design ] .",
    "experimental performance results are given in section [ sec : results ] .",
    "section [ sec : conclusion ] concludes the paper .",
    "considerable research has been done on data access for scientific applications .",
    "the work has focused on data i / o performance and data management convenience .",
    "two projects , mpi - io and hdf , are most closely related to our research .",
    "mpi - io is a parallel i / o interface specified in the mpi-2 standard .",
    "it is implemented and used on a wide range of platforms .",
    "the most popular implementation , romio @xcite is implemented portably on top of an abstract i / o device layer @xcite that enables portability to new underlying i / o systems .",
    "one of the most important features in romio is collective i / o operations , which adopt a two - phase i / o strategy @xcite and improve the parallel i / o performance by significantly reducing the number of i / o requests that would otherwise result in many small , noncontiguous i / o requests",
    ". however , mpi - io reads and writes data in a raw format without providing any functionality to effectively manage the associated metadata . nor does it guarantee data portability , thereby making it inconvenient for scientists to organize , transfer , and share their application data .",
    "hdf is a file format and software , developed at ncsa , for storing , retrieving , analyzing , visualizing , and converting scientific data .",
    "the most popular versions of hdf are hdf4 @xcite and hdf5 @xcite .",
    "the design goal of hdf4 is mainly to deal with sequential data access and its apis are consistent with its earlier versions . on the other hand ,",
    "hdf5 is a major revision in which its apis are completely re - designed .",
    "both versions store multidimensional arrays together with ancillary data in portable , self - describing file formats .",
    "the support for parallel data access in hdf5 is built on top of mpi - io , which ensures its portability since mpi - io has become a de facto standard for parallel i / o .",
    "however , the fact that hdf5 file format is not compatible with hdf4 can be inconvenient for existing hdf4 programmers to migrate their applications to hdf5 . furthermore , hdf5 adds several new features , such as hierarchical file structure , to describe more metadata , but it also increases the difficulties for the implementation of parallel data access underneath . and the overhead involved may make hdf5 perform much worse than its underlying mpi - io . by using a number of scientific applications ,",
    "this problem is addressed in @xcite .",
    "netcdf is an abstraction that supports a view of data as a collection of self - describing , portable , array - oriented objects that can be accessed through a simple interface .",
    "it defines a file format as well as a set of programming interfaces for storing and retrieving data in the form of arrays in netcdf files .",
    "we first describe the netcdf file format and its serial api and then consider various approaches to access netcdf files in parallel computing environments .",
    "netcdf stores data in an array - oriented dataset , which contains dimensions , variables , and attributes .",
    "physically , the dataset file is divided into two parts : file header and array data .",
    "the header contains all information ( or metadata ) about dimensions , attributes , and variables except for the variable data itself , while the data part contains arrays of variable values ( or raw data ) .",
    "the netcdf file header first defines a number of dimensions , each with a name and a length .",
    "these dimensions are used to define the shapes of variables in the dataset .",
    "one dimension can be unlimited and is used as the most significant dimension ( record dimension ) for growing - size variables .",
    "following the dimensions , a list of named attributes are used to describe the properties of the dataset ( e.g. , data range , purpose , associated applications ) .",
    "these are called global attributes and are separate from attributes associated with individual variables .",
    "the basic units of named data in a netcdf dataset are variables , which are multidimensional arrays .",
    "the header part describes each variable by its name , shape , named attributes , data type , array size , and data offset , while the data part stores the array values for one variable after another , in their defined order .    to support variable - size arrays ( e.g. , data growing with time stamps )",
    ", netcdf introduces record variables and uses a special technique to store such data .",
    "all record variables share the same unlimited dimension as their most significant dimension and are expected to grow together along that dimension . the rest , less significant dimensions all together define the shape for one record of the variable . for fixed - size array ,",
    "each array is stored in a contiguous file space starting from a given offset . for variable - size arrays ,",
    "netcdf first defines a _ record _ of an array as a subarray comprising all fixed dimensions and the records of all such arrays are stored interleaved in the arrays defined order .",
    "figure  [ figure : fileformat ] illustrates the storage layouts for fixed - size and variable - size arrays in a netcdf file .    in order to achieve network transparency ( machine - independence ) ,",
    "both the header and data parts of the file are represented in an well - defined format similar to xdr ( external data representation ) but extended to support efficient storage of arrays of non - byte data .",
    "-0.1 in      the original netcdf api was designed for serial codes to perform netcdf operations through a single process . in the serial netcdf library ,",
    "a typical sequence of operations to write a new netcdf dataset is to create the dataset ; define the dimensions , variables and attributes ; write variable data ; and close the dataset .",
    "reading an existing netcdf dataset involves first opening the dataset ; inquiring about dimensions , variables , and attributes ; reading variable data ; and closing the dataset .",
    "these netcdf operations can be divided into the following five categories .",
    "refer to @xcite for details of each function in the netcdf library .",
    "( )    * dataset functions * : create / open / close a dataset , set the dataset to define / data mode , and synchronize dataset changes to disk    * define mode functions * : define dataset dimensions and variables    * attribute functions * : manage adding , changing , and reading attributes of datasets    * inquiry functions * : return dataset metadata : dim(id , name , len ) , var(name , ndims , shape , i d )    * data access functions * : provide the ability to read / write variable data in one of the five access methods : single value , whole array , subarray , subsampled array ( strided subarray ) and mapped strided subarray    the i / o implementation of the serial netcdf api is built on the native i / o system calls and has its own buffering mechanism in user space . its design and optimization techniques are suitable for serial access but are not efficient or even not possible for parallel access , nor do they allow further performance gains provided by modern parallel i / o techniques .",
    "-0.1 in    today most scientific applications are programmed to run in parallel environments due to the increasing requirements on data amount and computational resources .",
    "it is highly desirable to develop a set of parallel apis for accessing netcdf files that employs appropriate parallel i / o techniques . in the meantime , programming convenience is also important , since scientific users may desire to spend minimum effort on dealing with i / o operations . before presenting our design on parallel netcdf",
    ", we would like to discuss current approaches for using netcdf in parallel programs in a message - passing environment .",
    "the first and most straightforward approach is described in the scenario of figure  [ figure : parallelization](a ) in which one process is in charge of collecting / distributing data and performing i / o to a single netcdf file using the serial netcdf api .",
    "the i / o requests from other processes are carried out by shipping all the data through this single process .",
    "the drawback of this approach is that collecting all i / o data on a single process can easily cause an i / o performance bottleneck and may overwhelm its memory capacity .    to avoid unnecessary data shipping ,",
    "an alternative approach is to have all processes perform their i / o independently using the serial netcdf api , as shown in figure  [ figure : parallelization](b ) . in this case ,",
    "all netcdf operations can proceed concurrently , but over multiple files , one for each process .",
    "however , using multiple files to store a single netcdf dataset results the complexity and difficulty of data management .",
    "this approach also destructs the purpose of netcdf design on easy data integration and management .",
    "a third approach introduces a new set of apis with parallel access semantics and optimized parallel i / o implementation such that all processes perform i / o operations cooperatively or collectively through the parallel netcdf library to access a single netcdf file .",
    "this approach , as shown in figure  [ figure : parallelization](c ) , both frees the users from dealing with details of parallel i / o and provides more opportunities for employing various parallel i / o optimizations in order to obtain higher performance .",
    "we discuss the details of this parallel netcdf design and implementation in the next section .",
    "to facilitate convenient and high - performance parallel access to netcdf files , we define a new parallel interface and provide a prototype implementation . since a large number of existing users are running their applications over netcdf , our parallel netcdf design retains the original netcdf file format ( version 3 ) and introduces minimum changes from the original interface .",
    "we distinguish the parallel api from the original serial api by prefixing the c function calls with `` ncmpi _ '' and the fortran function calls with `` nfmpi _ '' .",
    "our parallel netcdf api is built on top of mpi - io .",
    "the parallel netcdf built on mpi - io can benefit from several well - known optimizations already used in existing mpi - io implementations , such as data sieving and two - phase i / o strategies @xcite in romio .",
    "figure  [ figure : hierarchy ] describes the overall architecture for our design .    in parallel netcdf ,",
    "a file is opened , operated , and closed by the participating processes in a communication group . in order for these processes to operate on the same file space , especially the structural information contained in the file header",
    ", a number of changes have been made to the original serial netcdf api .",
    "for the function calls that create / open a netcdf file , an mpi communicator is added in the argument list to define the participating i / o processes within the file s open and close scope .",
    "mpi_info object is also added to pass user access hints to the mpi - io for further optimizations . by describing the collection of processes with a communicator",
    ", we provide the underlying implementation with information that can be used to ensure file consistency .",
    "the mpi_info hint provides users the ability to deliver the high level access information to netcdf and mpi - io libraries , such as file access patterns and file system specifics to direct optimization .",
    "we keep the same syntax and semantics for the parallel netcdf define mode functions , attribute functions , and inquiry functions as the original ones .",
    "these functions are also made collective to guarantee consistency of dataset structure among the participating processes in the same mpi communication group .",
    "for instance , the define mode functions is required to be called by the processes with the same values .",
    "the major effort of this work is the parallelization of the data access functions .",
    "we provide two sets of data access apis : a _ high - level api _ that mimics the serial netcdf data access functions and serves an easy path for original netcdf users to migrate to the parallel interface , and a _",
    "flexible api _ that provides a more mpi - like style of access . specifically , the flexible api uses more mpi functionality in order to provide better handling of internal data representations and to more fully expose the capabilities of mpi - io to the application programmer .",
    "the major difference between the two is the use of mpi derived data types .",
    "we believe using mpi derived datatypes can better illustrate the access patterns than the subarray mapping methods used in original api .",
    "-0.1 in    the most important change from the original netcdf interface with respect to data access functions is the split of data mode into two distinct modes : collective and non - collective data modes in which collective function names end with `` _ all '' .",
    "similar to mpi - io , the collective functions are synchronous across the processes in the communicator associated to the opened netcdf file , while the non - collective functions are not .",
    "using collective operations can provide the underlying parallel netcdf implementation an opportunity to further optimize access to the netcdf file .",
    "these optimizations are performed without further intervention by the application programmer and have been proven to provide dramatic performance improvement in multidimensional dataset access @xcite .",
    "figure  [ figure : code ] gives an example code of using our parallel netcdf api to write and read a dataset using collective i / o .",
    "the parallel api implementation is discussed in two parts : header i / o and parallel data i / o . we first describe out implementation strategies for dataset functions , define mode functions , attribute functions , and inquiry functions that access the netcdf file header .",
    "-0.1 in      internally , the header is read / written only by a single process , although a copy is cached in local memory on each process .",
    "the define mode functions , attribute functions , and inquiry functions all work on the local copy of the file header .",
    "since they are all in - memory operations not involved in any file i / o , they bear few changes from the serial netcdf api . they are made collective , but this feature does not necessarily imply inter - process synchronization . in some cases , however , when the header definition is changed synchronization is needed to verify that the values passed in by all processes match . in all possible cases",
    "we allow inter - process communications .",
    "the dataset functions , unlike the other functions cited , need complete reimplementation because they are in charge of collectively opening / creating datasets , performing header i / o and file synchronization for all processes , and managing inter - process communication . we build these functions over mpi - io so that they have better portability and provide more optimization opportunities .",
    "the basic idea is to let the root process fetch the file header , broadcast it to all processes when opening a file , and write the file header at the end of definition if any modification occurs in the header part .",
    "since all define mode and attribute functions are collective and require all processes in the communicator to provide the same arguments when adding / removing / changing definitions , the local copies of the file header shall be the same across all processes once the file is collectively opened and until it is closed .      since the majority of time spent accessing a netcdf file",
    "is in data access , the data i / o must be efficient . by implementing the data access functions above mpi - io , we enable a number of advantages and optimizations .    for each of the five data access methods in the flexible data access functions , we represent the data access pattern as an mpi file view ( a set of data visible and accessible from an open file @xcite ) , which is constructed from the variable metadata ( shape , size , offset , etc . ) in the netcdf file header and start [ ] , count [ ] , stride [ ] , imap [ ] , mpi_datatype arguments provided by users . for parallel access , particularly for collective access , each process has a different file view ; and all processes in combination can make a single mpi - io request to transfer large contiguous data as a whole , thereby preserving useful semantic information that would otherwise be lost if the transfer were expressed as per process noncontiguous requests .",
    "the high - level data access functions are implemented in terms of the flexible data access functions , so that existing users migrating from serial netcdf can also benefit from the mpi - io optimizations . however , the flexible data access functions are closer to mpi - io and hence incur less overhead .",
    "they accept a user - specified mpi derived datatype and pass it directly to mpi - io for optimal handling of in - memory data access patterns .    in some cases ( for instance , in record variable access ) the data",
    "is stored interleaved by record and the contiguity information is lost , so the existing mpi - io collective i / o optimization may not help . in that case , we need more optimization information from users , such as the number , order , and record indices of the record variables they will access consecutively . with such information we can collect multiple i / o requests over a number of record variables and optimize the file i / o over a large pool of data transfers , thereby producing more contiguous and larger transfers .",
    "this kind of information is passed in as an mpi_info hint when a user opens or creates a netcdf dataset .",
    "we implement our user hints in parallel netcdf for all such specific optimization points , while a number of standard hints are passed down for mpi - io to take control of optimal parallel i / o behaviors .",
    "thus experienced users have the opportunity to tune their applications for further performance gains .",
    "there are a number of advantages within the design and implementation of our parallel netcdf , as compared to other related work , like hdf5 .",
    "first of all , the parallel netcdf design and implementation is optimized for the netcdf file format so that the data i / o performance is as good as the mpi - io .",
    "the netcdf file chooses linear data layout , in which the data arrays are either stored in contiguous space and in a predefined order or interleaved in a regular pattern .",
    "this regular and highly predictable data layout enables the parallel netcdf data i / o implementation to simply pass the data buffer , metadata ( fileview , mpi_datatype , etc . ) , and other optimization information to mpi - io , and all parallel i / o operations are carried out in the same manner as when mpi - io alone is used .",
    "thus , there is very little overhead , and the parallel netcdf performance should be nearly the same as mpi - io if only raw data i / o performance is compared .",
    "on the other hand , parallel hdf5 uses tree - like file structure that are similar to the unix file system and the data is dispersedly laid out using super block , header blocks , data blocks , extended header blocks and extended data blocks .",
    "this irregular layout pattern may make it difficult to pass user access pattern directly to mpi - io especially for the case of variable - size arrays .",
    "instead , parallel hdf5 uses dataspace and hyperslabs to define the data organization , map and transfer data between memory space and the file space and does buffer packing / unpacking in a recursive way , while these can otherwise be directly handled by mpi - io in a more efficient and optimized way .",
    "secondly , the parallel netcdf implementation manages to keep the overhead involved in header i / o as low as possible . in the netcdf",
    "file , there is only one header which contains all necessary information for direct access of each data array and each array is associated with a predefined , numerical i d that can be efficiently inquired when it is needed to access the array .",
    "so , by maintaining a local copy of the header on each process , our implementation saves a lot of inter - process synchronization as well as avoids repeated access of the file header each time the header information is needed to access a single array .",
    "all header information can be accessed directly in local memory and inter - process synchronization is needed only during the definition of the dataset . and",
    "once the definition of the dataset is created , each array can be identified by its permanent i d and accessed at any time by any process , without any collective open / close operation .",
    "however , in hdf5 , the header metadata is dispersed in separate header blocks for each object and , in order to operate on an object , it has to iterate through the entire namespace to get the header information of that object and then open , access and close it .",
    "this kind of access method may be inefficient for parallel access , since the parallel hdf5 designs the open / close of each object as collective operations , which force all participating processes to communicate when accessing one single object , not to mention the cost of file access to locate and fetch the header information of that object .",
    "lastly , the programming interface of the parallel netcdf is concise and designed for easy usage , and the file format is fully compatible with serial netcdf .",
    "porting existing serial netcdf application to parallel netcdf should be straightforward because the parallel api contains nearly all functions of the serial api with parallel semantics but with minimum change of function names and argument lists .",
    "however , there are also limitations in parallel netcdf . unlike hdf5",
    ", netcdf does not support hierarchical group based organization of data objects and since it lays out the data in a linear order , adding fixed - size array or extending the file header may be very costly once the file is created and has existing data stored , though moving the existing data to extended area is performed in parallel .",
    "also , parallel netcdf does not provide functionality to combine two or more files in memory through software mounting , as hdf5 does . nor does netcdf support data compression within its file format .",
    "fortunately , these features can all be achieved by external software , sacrificing some manageability of the files .",
    "-0.1 in    to evaluate the performance and scalability of our parallel netcdf with that of serial netcdf , we ran some experiments and compared the results .",
    "we also compared the performance of parallel netcdf with that of parallel hdf5 , using the flash i / o benchmark .",
    "the experiments were run on an ibm sp-2 machine .",
    "this system is a teraflop - scale clustered smp with 144 compute nodes .",
    "each compute node has 4 gb of memory shared among its eight 375 mhz power3 processors .",
    "all the compute nodes are interconnected by switches and also connected via switches to the multiple i / o nodes running the gpfs parallel file system .",
    "there are 12 i / o nodes , each with dual 222 mhz processes .",
    "the aggregate disk space is 5 tb and the peak i / o bandwidth is 1.5 gb / s .",
    "we wrote a test code ( in c language ) to evaluate the performance of the current implementation of parallel netcdf .",
    "this test code was originally developed in fortran by woo - sun yang and chris ding at lawrence berkeley national laboratory ( lbl ) .",
    "basically it reads / writes a three - dimensional array field tt(z , y , x ) from / into a single netcdf file , where z = level is the most significant dimension and x = longitude is the least significant dimension .",
    "the test code partitions the three dimensional array along z , y , x , zy , zx , yx , and zyx axes , respectively , as illustrated in figure  [ figure : partition ] .",
    "all data i / o operations in these tests used collective i / o . for comparison purpose ,",
    "we prepared the same test using the original serial netcdf api and ran it in serial mode , in which a single processor reads / writes the whole array .",
    "-0.1 in    figure  [ figure : lblbenchnetcdf ] shows the performance results for reading and writing 64 mb and 1 gb netcdf datasets .",
    "generally , the parallel netcdf performance scales with the number of processes .",
    "because of collective i / o optimization , the performance difference made by various access patterns is small , although partitioning in the z dimension generally performs better than in the x dimension because of the different access contiguity .",
    "the overhead involved is inter - process communication , which is negligible comparing to the disk i / o when using large file size .",
    "the i / o bandwidth does not scale in direct proportion because the number of i / o nodes ( and disks ) is fixed so that the dominating disk access time at i / o nodes is almost fixed . as expected ,",
    "the parallel netcdf outperforms the original serial netcdf as the number of processes increases .",
    "the difference between the serial netcdf performance and the parallel netcdf performance with single processor is because of their different i / o implementations and different i / o caching / buffering strategies . in the serial netcdf case ,",
    "if , as in figure  [ figure : parallelization](a ) , multi - processors were used and the root processor needed to collect partitioned data and then perform the serial netcdf i / o , the performance would be much worse and decrease with the number of processors because of the additional communication cost and division of a large i / o request into a series of small requests .",
    "-0.1 in    the flash i / o benchmark simulates the i / o pattern of an important scientific application called flash @xcite .",
    "it recreates the primary data structures in the flash code and produces a checkpoint file , a plotfile with centered data , and a plotfile with corner data , using parallel hdf5 .",
    "basically , these three output files contains a series of multidimensional arrays , and the access pattern is simple ( block , * , ... ) , which is similar to the z partition in figure  [ figure : partition ] . in each of the files",
    ", the benchmark writes the related arrays in a fixed order from contiguous user buffers , respectively .",
    "the i / o routines in the benchmark are identical to the routines used by flash , so any performance improvements made to the benchmark program will be shared by flash . in our experiments , in order to focus on the data i / o performance , we modified this benchmark , removed the part of code writing attributes , ported it to parallel netcdf , and observed the effect of our new parallel i / o approach .",
    "figure  [ figure : flashio ] shows the performance results of the flash i / o benchmark using parallel netcdf and parallel hdf5 .",
    "we tested both small data size and large data size .",
    "the parameters used in these two experiments are : ( a ) nxb = nyb = nzb = 8 , nguard = 4 , number of blocks = 80 , and nvar = 24 ; ( b ) nxb = nyb = nzb = 16 , nguard = 8 , number of blocks = 80 , and nvar = 24 .",
    "although both i / o libraries are built above mpi - io , the parallel netcdf has much less overhead and outperforms parallel hdf5 by almost doubling the overall i / o rate .",
    "the extra overhead involved in the current release of hdf5 ( version 5 - 1.4.3 ) includes inter - process synchronizations and file header access performed internally in parallel open / close of every dataset ( analogous to a netcdf variable ) and recursive handling of the hyperslab used for parallel access , which makes the packing of the hyperslabs into contiguous buffers take a relatively long time .",
    "in this work , we extend the serial netcdf interface to facilitate parallel access , and we provide an implementation for a subset of this new parallel netcdf interface . by building on top of mpi - io",
    ", we gain a number of interface advantages and performance optimizations users can benefit from by using this parallel netcdf package , as shown by our test results .",
    "so far , a number of users from lbl , ornl , and university of chicago are using our parallel netcdf library .",
    "future work involves developing a production - quality parallel netcdf api ( for c , c++ , fortran , and other programming languages ) and making it freely available to the high - performance computing community .",
    "moreover , we need to develop a mechanism for matching the file organization to access patterns , and we need to develop cross - file optimizations for addressing common data access patterns .      this work is sponsored by scientific data management center of doe scidac isics program and jointly conducted at northwestern university and argonne national laboratory .",
    "this research was also supported in part by nsf cooperative agreement aci-9619020 through computing resources provided by the national partnership for advanced computational infrastructure at the san diego supercomputer center .",
    "we thank woo - sun yang from lbl for providing us the test code for performance evaluation and nagiza f. samatova and david bauer at ornl for using our library and for giving us feedback and valuable suggestions .",
    "b. fryxell , k. olson , p. ricker , f. x. timmes , m. zingale , d. q. lamb , p. macneice , r. rosner , and h. tufo .",
    "`` flash : an adaptive mesh hydrodynamics code for modelling astrophysical thermonuclear flashes , '' _ astrophysical journal suppliment _ , 2000 , pp .",
    "131 - 273 .",
    "r. rew and g. davis , `` the unidata netcdf : software for scientific data access , '' _ sixth international conference on interactive information and processing systems for meteorology , oceanography and hydrology _ , anaheim , ca , february 1990 .",
    "r. thakur , w. gropp , and e. lusk .",
    "`` an abstract - device interface for implementing portable parallel - i / o interfaces''(adio ) , in _ proceedings of the 6th symposium on the frontiers of massively parallel computation _ , october 1996 , pp .",
    "180 - 187 .",
    "r. thakur , w. gropp , and e. lusk .",
    "`` on implementing mpi - io portably and with high performance , '' in _ proceedings of the sixth workshop on input / output in parallel and distributed systems _ , may 1999 , pp .",
    "23 - 32 .",
    "r. thakur , r. ross , e. lusk , and w. gropp , `` users guide for romio : a high - performance , portable mpi - io implementation , '' technical memorandum no .",
    "234 , mathematics and computer science division , argonne national laboratory , revised january 2002 ."
  ],
  "abstract_text": [
    "<S> dataset storage , exchange , and access play a critical role in scientific applications . for such purposes netcdf serves as a portable and efficient file format and programming interface , which is popular in numerous scientific application domains . </S>",
    "<S> however , the original interface does not provide a efficient mechanism for parallel data storage and access .    in this work </S>",
    "<S> , we present a new parallel interface for writing and reading netcdf datasets . </S>",
    "<S> this interface is derived with minimum changes from the serial netcdf interface but defines semantics for parallel access and is tailored for high performance . </S>",
    "<S> the underlying parallel i / o is achieved through mpi - io , allowing for dramatic performance gains through the use of collective i / o optimizations . </S>",
    "<S> we compare the implementation strategies with hdf5 and analyze both . </S>",
    "<S> our tests indicate programming convenience and significant i / o performance improvement with this parallel netcdf interface . </S>"
  ]
}