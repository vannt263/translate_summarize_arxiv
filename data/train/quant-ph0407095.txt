{
  "article_text": [
    "a very significant potential application of quantum computers lies in their ability to efficiently solve the problem of finding discrete logarithms over finite groups .",
    "it is this ability that makes quantum computers capable , in principle , of undermining the security of elliptic curve cryptographic systems , which are widely used by industry and government to protect sensitive information .",
    "there is no known classical algorithm for solving the discrete logarithm problem in polynomial time . in 1994 ,",
    "peter shor @xcite described a quantum algorithm for solving this problem in polynomial time .",
    "the construction of medium- or large - scale quantum computers has turned out to be an enormous technological challenge . for most of the proposed ( practical ) schemes for implementing quantum computers , qubits are a very ` expensive ' resource . thus there is a significant practical interest in optimizing quantum algorithms to use as few qubits as possible . in @xcite , proos and zalka give an optimized implementation of the discrete logarithm algorithm , for the particular case of elliptic curve groups .",
    "they consider only elliptic curves over the prime fields @xmath0 .",
    "many elliptic curve cryptosystems use elliptic curves over the binary fields @xmath3 however .",
    "so it is important to examine the number of qubits required to implement the discrete logarithm algorithm for elliptic curve groups over these binary fields . in this direction , we show how to decompose the group operation into a series of smaller , individually reversible , steps ( following the approach taken in @xcite ) .",
    "some of these steps will involve divisions of elements in the binary field @xmath3 . to solve this problem ,",
    "we show how to implement the extended euclidean algorithm for polynomials , and optimize this implementation to use few qubits .",
    "an _ elliptic curve _ over a field @xmath5 is the set of points @xmath6 satisfying @xmath7 subject to some additional conditions on the constants @xmath8 , together with a ` point at infinity ' , denoted @xmath9 . for the particular case of curves over the finite fields @xmath3 , the defining equation and additional conditions simplify as follows .",
    "1 .   @xmath10 _ ( non - supersingular curves ) _ @xmath11 2 .",
    "@xmath12 _ ( supersingular curves ) _",
    "@xmath13    an elliptic curve over @xmath3 is the set of points @xmath14 that satisfy one of the above two formulae , together with the point at infinity @xmath9 .",
    "a particular curve of one of the above types is specified by giving values to the constants @xmath15 ( and @xmath16 in the case of a supersingular curve ) .",
    "the set of points on a given elliptic curve forms a group under the following operation of addition .",
    "let @xmath17 and @xmath18 , where @xmath19 , be two distinct points on a curve over @xmath3 .",
    "the point @xmath20 is defined as follows .    1 .",
    "_ non - supersingular curves _ @xmath21 @xmath22 @xmath23 2 .",
    "_ supersingular curves _ @xmath24 @xmath25 @xmath23    following the argument in @xcite , we can avoid dealing with the cases @xmath26 ( point doubling ) @xmath27 , and @xmath28 , and restrict ourselves to the generic group addition formulae in terms of @xmath29 above .",
    "the key observation is that in a superposition ( such as we would have in the quantum discrete logarithm algorithm ) , situations other than the generic case will occur for only a small fraction of the elements in superposition , and so by ignoring them the fidelity loss will be negligible .",
    "let @xmath30 be a cyclic group , and let @xmath31 be a generator for @xmath30 .",
    "the discrete logarithm problem with respect to the base @xmath31 is the following . given a group element @xmath32 ,",
    "find the unique integer @xmath33 $ ] such that @xmath34 . recall that shor s quantum algorithm for solving the discrete logarithm problem makes use of a unitary operator that performs @xmath35 where @xmath36 and @xmath37 are integers in the range @xmath38 $ ] .",
    "consider an elliptic curve @xmath39 and let @xmath40 be a point on @xmath39 .",
    "consider the cyclic subgroup of the elliptic curve group generated by @xmath40 .",
    "we are interested in solving the discrete logarithm problem for this subgroup .",
    "the group operation is written additively , so the discrete logarithm problem is the following .",
    "given a point @xmath41 in the subgroup generated by @xmath40 , find the unique integer @xmath42 $ ] such that @xmath43 .",
    "the unitary operation @xmath44 used in shor s algorithm performs @xmath45 employing the semiclassical fourier transform of griffiths and niu @xcite as detailed in @xcite , for the discrete logarithm algorithm it suffices to be able to implement @xmath46 writing @xmath47 and @xmath48 , we want to implement @xmath49",
    "we now show how to decompose the group operation for curves over @xmath3 into a sequence of individually reversible steps .",
    "doing so allows the implementation of the group operation with a smaller number of ancillary qubits .",
    "we will use the following notation .",
    "when we write @xmath50 , we are referring to a ( not necessarily reversible ) computation transforming the value @xmath36 into the value @xmath37 .",
    "when we write @xmath51 , we are referring to a _",
    "reversible _ computation which can be seen as transforming @xmath36 into @xmath37 , or as transforming @xmath37 into @xmath36 .    for a fixed point @xmath52 ,",
    "define @xmath53 .",
    "we want to decompose the operation @xmath54 for simplicity , in the following we will write the values without the dirac _ ket _ symbols .    1 .",
    "_ _ non - supersingular curves__we have @xmath55 the group operation is decomposed as @xmath56 the second step in the above decomposition is a division , and the fourth step is a multiplication , where in each case one of the operands is uncomputed in the process .",
    "all the other steps involve only additions ( and the third step also requires the squaring of @xmath57 ) .",
    "it turns out that the number of qubits required to perform the group operation is bounded by the number of qubits required to perform a division or multiplication where one of the operands is uncomputed in the process .",
    "_ _ supersingular curves__we have @xmath58 the group operation is decomposed as @xmath59 as in the non - supersingular case , the second step in the above decomposition is a division , and the fourth step is a multiplication , where in each case one of the operands is uncomputed in the process .",
    "the other steps involve only additions , and one squaring .",
    "so again the qubit - space requirement for the group operation is that for a division or multiplication where one of the operands is uncomputed in the process .    in both the supersingular and non - supersingular case ,",
    "the qubit space requirement of the group operation is determined by that of performing a division or multiplication , where one of the operands is uncomputed in the process .",
    "such a multiplication can be achieved by running such a division backwards , so we turn our attention to implementing divisions of the form @xmath60 , using as few qubits as possible .",
    "following @xcite the division is decomposed into the following four reversible steps .",
    "@xmath61 the letters over the arrows are @xmath62 for standard polynomial multiplication , and @xmath39 for `` euclid s algorithm '' .",
    "the second @xmath62 is really a standard polynomial multiplication run backwards to uncompute @xmath37 .",
    "we know how to implement standard multiplication in @xmath3 using @xmath63 qubits by @xcite , so it remains to show how to implement the extended euclidean algorithm for polynomials to compute inverses in @xmath3 .",
    "suppose @xmath64 and @xmath65 are two binary polynomials in the variable @xmath66 , of degrees less than @xmath62 ( i.e. @xmath67 ) .",
    "suppose @xmath68 and @xmath69 are not both 0 , and are such that @xmath70 .",
    "the _ greatest common divisor _ of @xmath68 and @xmath69 , denoted @xmath71 , is the binary polynomial of highest degree that divides both @xmath68 and @xmath69 .",
    "the classical euclidean algorithm for finding @xmath71 is based on the fact that @xmath72 , for all binary polynomials @xmath73 . if we divide @xmath69 by @xmath68 ( by standard long division of polynomials ) , obtaining a quotient polynomial @xmath74 and a remainder polynomial @xmath75 satisfying @xmath76 , then @xmath77 . by the fact observed above , we have @xmath78 .",
    "the classical euclidean algorithm for polynomials makes this replacement repeatedly until one of the arguments is 0 .",
    "if we set @xmath79 and @xmath80 , the euclidean algorithm performs the following sequence of divisions : @xmath81 the fact above gives us the corresponding sequence of equalities : @xmath82 at this point we have the result , since @xmath83 .",
    "the algorithm is guaranteed to terminate , since the degree of one of the arguments strictly decreases in each step . moreover ,",
    "the algorithm is efficient because the number of iterations is bounded by the degree of @xmath68 ( which is at most @xmath62 ) .",
    "recall that the @xmath84 of two integers @xmath15 can always be written as a linear combination of @xmath85 and @xmath86 having integral coefficients .",
    "the same is true for the @xmath84 of two polynomials @xmath87 .",
    "that is , there exist polynomials @xmath88 in @xmath3 such that @xmath89 the _ extended euclidean algorithm for polynomials _ is the same as the euclidean algorithm for polynomials except that it also keeps track of the ` coefficient ' polynomials @xmath88 above .",
    "it does so through the following recurrences .",
    "@xmath90 and @xmath91 it is not hard to show that for @xmath92 we have @xmath93 , where the @xmath94 s are defined as in the euclidean algorithm for polynomials , and the @xmath95 and the @xmath96 are defined by the above recurrences .    for reference , we write the extended euclidean algorithm for polynomials in pseudo - code below .",
    "the notation @xmath97 is intended to mean that we assign the value of @xmath37 to the variable named @xmath36",
    ".    extended euclidean algorithm for polynomials    1 .",
    "@xmath98 2 .",
    "@xmath99 3 .",
    "@xmath100 4 .",
    "@xmath101 5 .",
    "@xmath102 6 .",
    "@xmath103 7 .",
    "@xmath104 8 .",
    "@xmath105 9 .",
    "* while * @xmath106 * do * 1 .   _",
    "_ temp__@xmath107 2 .",
    "@xmath108 3 .",
    "@xmath109__temp _ _ 4 .",
    "_ _ temp__@xmath110 5 .",
    "@xmath111 6 .",
    "@xmath112 _ temp _ 7 .",
    "@xmath113 8 .",
    "@xmath114 9 .",
    "@xmath115 10 .",
    "@xmath105 10 . *",
    "* return**@xmath116    inverses in @xmath3 can be computed using the extended euclidean algorithm for polynomials , as follows .",
    "suppose @xmath117 is an irreducible polynomial of degree @xmath62 , and let @xmath118 be a binary polynomial of degree @xmath119 .",
    "then @xmath120 , and the extended euclidean algorithm for polynomials finds binary polynomials @xmath121 and @xmath122 such that @xmath123 .",
    "but this means that @xmath124 , and so @xmath125 .",
    "the coefficient @xmath122 of @xmath126 is not needed for the inversion of @xmath73 , and so we only need to record the coefficient @xmath121 of @xmath73 throughout the algorithm .",
    "we now turn our attention to quantum implementations of the extended euclidean algorithm for polynomials for computing the inverse of an element @xmath73 . following @xmath4",
    ", our implementations will maintain two ordered pairs @xmath127 and @xmath128 .",
    ", where @xmath68 and @xmath69 record the sequence of remainders in the euclidean algorithm for polynomials , and @xmath85 and @xmath86 record the updated coefficient of @xmath73 for each of the past two iterations of the algorithm .",
    "we call these ordered pairs _ euclidean pairs_. the algorithm begins with @xmath129 , and @xmath130 ( where @xmath126 is an irreducible polynomial of degree @xmath62 ) . note that @xmath131 . we will always store the euclidean pair with the smaller - degree polynomial in the second co - ordinate first .",
    "that is , we store the euclidean pairs in the order @xmath132 where @xmath133 .",
    "we then want to perform long division of @xmath69 by @xmath68 , obtaining a quotient polynomial @xmath134 and a remainder polynomial @xmath135 satisfying @xmath136 ( the second equality follows since the field is binary ) , where @xmath134 is the quotient polynomial of @xmath137 , which we denote as @xmath138 .",
    "we will then replace @xmath69 by @xmath139 , and @xmath86 by @xmath140 . since @xmath77 , after the above replacement we will have to interchange the euclidean pairs to maintain the ordering so that the pair with the smaller - degree polynomial in the second co - ordinate appears first .",
    "so one iteration of the algorithm can be written as @xmath141 at the beginning of the euclidean algorithm , we start with @xmath142 , and so @xmath133 and @xmath143 . it is easy to see that this condition is preserved in every iteration of the algorithm .",
    "this implies that we will have @xmath144 .",
    "so we can write @xmath145 so while @xmath134 is computed from the second co - ordinates of the euclidean pairs @xmath146 , it can be uncomputed from the first coordinates of the modified euclidean pairs @xmath147 .",
    "thus each iteration of the euclidean algorithm is individually reversible , and can be written as @xmath148 this is decomposed into the following three individually reversible steps : @xmath149 where `` swap '' refers to the operation of switching the two euclidean pairs . since @xmath150 , the second operation above is simply the reverse of the first operation .    to perform the division @xmath151 we can use long division of the binary polynomial @xmath69 by @xmath68 . to implement this long division ,",
    "the basic idea is to shift @xmath68 all the way to the left ( i.e. we shift @xmath68 left by @xmath152 bits ) .",
    "then we start shifting @xmath68 to the right one bit at a time , each time conditionally doing a subtraction . for the binary field @xmath3",
    "this is simplified by virtue of the fact that subtraction is the same as addition , and is achieved by a bitwise @xmath153 operation .",
    "this bitwise xor can be implemented quantumly using cnot gates , and no ancillary qubits .",
    "( furthermore , these cnots could in principle be performed in parallel , allowing us to do addition in a single step . )",
    "note that in our long divisions we are doing more work than necessary . often the degree of @xmath69 will be less than @xmath154 , and so it would not be necessary to shift @xmath68 all the way to the left ( we could just shift it so the most significant bits of @xmath68 and @xmath69 line - up ) . for simplicity , in the naive implementation we do not take advantage of this fact , but will do so when we look at an optimized implementation .      to implement the long division ,",
    "there are some subcomponents that we will need to implement .",
    "we describe implementations of some of these subcomponents here , optimizing for the number of qubits .    in what follows",
    ", we will show how to implement some operation , and then use that operation _ controlled _ on the value(s ) of some other qubit(s ) .",
    "we need to consider whether this can be done without the requirement for any additional qubits , or an unreasonable increase in the running time .",
    "fortunately , by @xcite , given a gate performing @xmath155 , we can construct a gate performing a _",
    "controlled_-@xmath155 ( that is , @xmath155 conditioned on a control qubit being in state @xmath156 ) with no additional ancillary qubits , and a small overhead in running time . using this result repeatedly",
    ", we can implement @xmath155 conditioned on any desired pattern of control qubits ( e.g. @xmath155 may be applied only when a three - qubits control register is in the state @xmath157 ) with no additional ancillary qubits , and a small overhead in running time .",
    "we will use this result implicitly in the following .    for the long division",
    ", we will need to compute the degree of @xmath68 .",
    "the circuit shown in figure [ fig_degree ] accomplishes this .",
    "each of the hollow circles in the figure denotes a @xmath158-_control _ ( that is , the @xmath159 operation is applied if the control qubit is @xmath160 ) . to uncompute the degree , we can simply run the circuit shown in figure [ fig_degree ] backwards .",
    "the circuit in figure [ fig_degree ] uses a sequence of @xmath62 decrementing ( -1 ) gates , each of which is controlled by the values of some of the qubits of @xmath161 .",
    "these decrementing gates update the value of @xmath162 , being computed into a @xmath163-qubit register . in figure [ fig_dec ] , we show how to implement an incrementing ( + 1 ) gate using only one additional ancillary qubit .    the ancillary qubit becomes the most - significant - bit of the result .",
    "if we only apply the incrementing circuit to integers in the range @xmath164 $ ] , we know that the ancillary qubit will always be @xmath160 at the output .",
    "decrementing is accomplished by running this circuit backwards , with the ancillary qubit initially set to @xmath160 .",
    "as long as we apply the decrementing circuit to integers in the range @xmath165 $ ] , we know that the ancillary qubit will always be @xmath156 at the output .",
    "so we can reset the ancillary qubit to @xmath160 with a not gate after each decrement gate , and re - use that ancillary qubit for the next decrement gate .",
    "henceforth when we count qubits in this paper , we will always assume @xmath166 , and write @xmath167 for convenience .",
    "similarly for @xmath168 .",
    "so the degree of @xmath169 can be computed using @xmath170 qubits ( a @xmath167-qubit register into which the result is computed and stored , and 1 ancillary qubit shared by the decrementing gates ) .",
    "we also need to implement shifts of our quantum registers . for our purpose",
    "it will suffice to implement a cyclic shift .",
    "we will make use of the quantum swap gate , which swaps two qubits .",
    "a swap gate can be implemented using 3 cnot gates , and no ancillary qubits , as shown in figure [ fig_swap ] .",
    "right shifts can be implemented by an analogous circuit .",
    "a left cyclic shift gate which shifts the state of an @xmath171-qubit register to the left cyclically by one qubit is implemented using @xmath172 swap gates , and no ancillary qubits , as shown in figure [ fig_shift ] .",
    "a left shift of @xmath173 qubits can be implemented by concatenating @xmath173 single - qubit left shifts together .",
    "note that right shifts can be performed in an analogous manner . we will also need to implement a shift conditioned on the value contained in a quantum register .",
    "that is , a quantum implementation of the operation @xmath174 the controlled shift operation above is implemented by the circuit shown in figure [ fig_cshift ] , where @xmath121 denotes the number of bits in the binary representation of @xmath173 .",
    "now that we can compute the degrees of polynomials in @xmath3 , and perform shifts of quantum registers , we can state an algorithm to reversibly compute the long division @xmath175 ( note the algorithm requires @xmath133 ) .    12 cm * long division *    1 .   initialize @xmath176 .",
    "2 .   compute @xmath162 .",
    "3 .   compute @xmath177 .",
    "4 .   shift @xmath68 left by @xmath152 positions .",
    "5 .   while @xmath178 do 1 .   if @xmath179 , then set @xmath180 and replace @xmath69 with @xmath181 .",
    "2 .   shift @xmath68 to the right one bit .",
    "3 .   @xmath182 .",
    "uncompute @xmath162 .    at the end of the long division ,",
    "the register originally containing @xmath69 will contain @xmath183 . also , the auxiliary counter @xmath184 will be zeroed , and so can be re - used .",
    "the conditional setting of @xmath185 in step ( 4.1 ) can be accomplished by a cnot gate , with @xmath186 as the control qubit and @xmath187 as the target qubit .",
    "then , conditioned on @xmath187 , the operation @xmath188 can be accomplished by cnot gates between the corresponding qubits of @xmath68 and @xmath69 . to conditionally apply this operation , we replace these cnot gates by toffoli gates , with @xmath187 as the additional control qubit .",
    "in the discrete logarithm algorithm , the extended euclidean algorithm for polynomials will be applied to a superposition of inputs . for this reason we have to be careful that the steps of the algorithm are appropriately synchronized , so that each element in the superposition is undergoing the same step at any given time . in the naive implementation described above ,",
    "we shift @xmath68 left by @xmath152 bits . the number of computational steps to perform this shift depends on @xmath162 .",
    "when the computation is applied to a superposition of inputs , @xmath162 will be different for the different elements in the superposition .",
    "thus the number computational steps is different for different elements in superposition .",
    "this means the stages of the algorithm will not be properly synchronized between elements in superposition .",
    "this synchronization problem can be solved by applying a general technique of _ synchronizing _ the implementation @xcite .",
    "we explain synchronization by way of an example .",
    "suppose a computation @xmath73 consists of some sequence of three simple reversible operations @xmath189 , @xmath190 and @xmath191 ( and no other operations ) .",
    "the time taken to perform each of the operations @xmath192 is independent of the input .",
    "this means that on a superposition of inputs , the time required to perform the operation @xmath189 ( for example ) is the same for all elements in the superposition .    the quantum computation @xmath73 is some sequence of the operations @xmath189 , @xmath190 and @xmath191 , in any order , and with repetitions . for example , @xmath73 applied to the input basis state @xmath193 might consist of @xmath189 applied 4 times , followed by @xmath190 applied 1 time , followed by @xmath191 applied 2 times , followed by @xmath189 applied 1 time , followed by @xmath190 applied 3 times .",
    "that is , @xmath194 the synchronization problem is that for another input basis state @xmath195 ( in a superposition of inputs ) , the sequence of operations might be different .",
    "for example , on @xmath195 the same computation @xmath73 might consist of @xmath189 applied 1 time , followed by @xmath190 applied 4 times , followed by @xmath191 applied 1 time , followed by @xmath189 applied 3 times .",
    "that is , @xmath196 the idea of synchronization is to have _ all _ the computations in the superposition cycle through the 3 operations repeatedly , each time allowing the computation to either apply the operation once , or not apply it ( wait for the next operation ) .",
    "the cycle is repeated a sufficient number of times so that sufficiently many of the computations in superposition have finished . for the computation @xmath73 above",
    "applied to the two input basis states @xmath193 and @xmath195 , this is illustrated in figure [ fig_desynch ] . in the figure , the operation applied at each step are indicated by an @xmath197 in the corresponding box .",
    "we now describe more explicitly how to implement synchronization .",
    "there must be a way for the computation to tell when a series of @xmath198 s is finished and the next one should begin .",
    "we want to do this reversibly , so there must be a way to tell both when an @xmath198 is the first in a series , and when it is last in a series . in each @xmath198",
    "we can include a a sequence of gates which flips a flag qubit @xmath126 if @xmath198 is the first in a sequence , and another mechanism that flips @xmath126 if @xmath198 is the last in a sequence .",
    "we also make use of a small `` counter '' register @xmath16 to control which operation is scheduled to be applied at the current step .",
    "thus we have a triple @xmath199 where @xmath36 stands for the actual data .",
    "we initialize both @xmath126 and @xmath16 to 1 to signify that the first operation will be the first in a sequence of @xmath189 operations .",
    "the physical quantum - gate sequence which we apply is @xmath200 where the @xmath201 are the @xmath198 conditioned on @xmath202 and @xmath203 stands for `` advance counter '' .",
    "these operations act as follows on the triple : @xmath204 where @xmath201 does nothing if @xmath205 , the symbol `` @xmath206 '' means xor , and @xmath207 is taken from @xmath208 . in the middle of a sequence of @xmath198 s",
    "the flag @xmath126 is 0 , and so the counter does nt advance .",
    "the last in a sequence of @xmath198 s will set @xmath209 and the counter will advance in the next @xmath203 step .",
    "the first operation of the next series resets @xmath126 to 0 , so that this series can progress .",
    "of course , even though the individual steps in the algorithm are synchronized , the computations in the superposition will in general finish the extended euclidean algorithm after different numbers of iterations . for those that finish earlier than others",
    ", we can not simply have them `` halt '' and wait for the others to finish ( this would result in an implementation that is not reversible ) . to ensure reversibility , those elements in superposition that halt early must increment a small counter at each time step until the other elements in superposition finish .",
    "we will call this small counter the `` halting counter '' .    we do not describe in detail how to apply synchronization to repair the naive implementation , but instead proceed with a better optimized implementation that will make use of synchronization .",
    "the starting point for an optimized implementation is the observation that large quotients occur relatively rarely in the extended euclidean algorithm for polynomials . in the naive implementation by shifting @xmath68 all the way to the left in the long divisions",
    ", we were doing more work than necessary .",
    "our optimized implementation will make use of `` adaptive '' long divisions , whose behaviour is conditioned on the sizes of the arguments .",
    "in fact , any @xmath1 algorithm ( classical or quantum ) must do this kind of adaptive division . for a quantum implementation",
    ", we will then note that since large quotients occur rarely , we can bound the size of the quotient with a negligible loss in fidelity .",
    "the other main observation underlying the optimized implementation is that in the naive implementation we were using much more space than necessary to store the euclidean pairs . in the naive implementation we used a separate @xmath62-qubit register for each of @xmath210 .",
    "it turns out that this is twice as much space as is necessary .    at every stage of the extended euclidean algorithm for polynomials",
    "we have @xmath211 .    _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ * proof : * initially we have @xmath212 and so @xmath211 , so the claim is true at the first iteration .",
    "each iteration transforms @xmath213 so we have @xmath214 and so the claim is true after each iteration.@xmath215 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    an immediate corollary of this claim is    at every stage of the extended euclidean algorithm for polynomials we have @xmath216    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ * proof : * since @xmath133 we have @xmath217 similarly , since @xmath143 we have @xmath218 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    by the corollary , we see that a single @xmath62-qubit register will be sufficient to store both @xmath85 and @xmath68 , and a second @xmath62-qubit register is sufficient to store both @xmath86 and @xmath69 .",
    "thus @xmath68 and @xmath85 can _ share _ a single @xmath62-qubit register , and @xmath86 and @xmath69 can share a second @xmath62-qubit register .",
    "this reduces the total space to store @xmath210 from @xmath219 to @xmath63 .",
    "the problem with this approach is that the relative sizes of @xmath85 and @xmath68 change from one iteration to the next , and thus so does the boundary between @xmath68 and @xmath85 within the single @xmath62-qubit register ( similarly for @xmath86 and @xmath69 ) .",
    "further , at any iteration , this boundary may be different between elements in superposition .",
    "so we need a way to quantumly calculate the position of this boundary for each iteration .",
    "first , observe that the boundary between @xmath68 and @xmath85 can be at the same position as the boundary between @xmath69 and @xmath86 , in any iteration ( since @xmath133 ) .",
    "second , notice that the boundary can be easily determined if we know the degrees of @xmath210 .",
    "it will turn out to be convenient to store @xmath68 and @xmath85 in a single register in opposing directions .",
    "that is , the most significant bit of @xmath68 is at one end of the register , and the most significant bit of @xmath85 is at the extreme other end of the register . between @xmath68 and @xmath85",
    "the register will be padded with zeros .",
    "similarly for @xmath69 and @xmath86 .",
    "the situation for register sharing is illustrated in figure [ fig_reg_share ] .    from figure [ fig_reg_share ]",
    "it can be seen that the boundary for register - sharing can be determined from @xmath220 or from @xmath221 .",
    "our strategy will be to store the degree of each of @xmath210 at each step , and use either @xmath220 or @xmath221 ( depending on what operation we are performing ) to determine the boundary . for convenience , we will keep track of the degrees of all of @xmath222 and @xmath86 , requiring 4 separate @xmath167-qubit registers .    as before , we focus on implementing the long division @xmath223 the long division algorithm is modified slightly as a result of the new strategy for storing @xmath68 and @xmath69 .",
    "note that we do not need to initially shift @xmath68 all the way towards the high order end , since the most significant bits of @xmath68 and @xmath69 are already in the same position .",
    "instead of shifting @xmath68 one bit at a time towards the low order end at each step , we shift @xmath69 one bit at a time towards the high order end . at each stage , a new bit of @xmath134 is first read out from the high order bit of @xmath69 .",
    "then , controlled on the new bit of @xmath134 ( equivalently the high order bit of @xmath69 ) @xmath69 is xored with @xmath68 ( this is the conditional subtraction ) .",
    "then @xmath69 is shifted towards the high order end by 1 bit , and the value of @xmath221 is decremented by 1 . note that no significant bits of @xmath69 are lost in the shift , because after the conditional xor operation , we know the high order bit of @xmath69 will be 0 .",
    "after the long division is complete , the remaining operation is to shift off any leading ( high order ) zeros in the final value of @xmath69 , and decrement the value of @xmath221 accordingly .",
    "this is done so that the most significant bits of @xmath68 and @xmath69 are in corresponding positions for the next iteration .",
    "the operations @xmath189 and @xmath190 for implementing the long division in a synchronized manner are as follows :    1 .   1 .",
    "the high - order bit of @xmath69 becomes the next bit of @xmath134 ( starting at the high - order bit of @xmath134 and working down ) .",
    "2 .   conditioned on the new bit of @xmath134",
    ", @xmath69 is replaced with @xmath224 .",
    "@xmath69 is shifted towards the high order end by 1 bit , and @xmath221 is decremented by 1 .",
    "@xmath69 is shifted towards the high order end by 1 bit , and @xmath221 is decremented by 1 .    the first in a sequence of @xmath189 operations is recognized by the condition @xmath176 . the last in a sequence of @xmath189 operations is recognized by @xmath225 . when performing the last in a sequence of @xmath189 operations ,",
    "only part @xmath226 is performed ( so parts @xmath227 and @xmath228 can be conditioned on the flag qubit ) .",
    "the first in a sequence of @xmath190 operations is recognized by @xmath225 .",
    "the last in a sequence of @xmath190 operations is recognized when the bit in the high - order `` slot '' of the register containing @xmath69 is is @xmath156 .",
    "the long division algorithm is illustrated by an example .",
    "suppose we have the following : @xmath229 the long division @xmath137 as would be performed by hand is shown in figure [ fig_longdiv ] .",
    "the long division as performed by the algorithm is shown in figure [ fig_example ] .",
    "one feature of the algorithm suggested by the example is that the qubits can be spatially arranged so that operations are performed on neighbouring qubits .",
    "note that in the implementation of shifts ( figure [ fig_shift ] ) the cnot gates are between adjacent qubits as well ) .",
    "this might be advantageous for a given physical implementation . in figure [ fig_example ] , note that blank cells contain the value 0 , but are shown as blank to make it easier to understand the steps of the long division .",
    "we have omitted the details of how to condition the steps of the long division on the value which determines the boundary for register sharing .",
    "for example , in the implementation of @xmath230 , the operations on @xmath231 will be conditioned on the value in the register containing @xmath220 ( from which the boundary position for register sharing can be determined ) .",
    "these details are very complicated , but the techniques for implementing controlled - gates in @xmath232 indicate that it can be done with no ancillary qubits , and a polynomial increase in time .",
    "we saw in section [ sec_decompose_group_op ] that the number of qubits required to implement the elliptic curve group operation is bounded by the number of qubits required to implement the extended euclidean algorithm for polynomials . here",
    "we count the number of qubits required by our implementation .    by using register sharing ,",
    "the values of @xmath210 can be stored using @xmath63 qubits .",
    "the values of @xmath233 must be initially computed and stored , requiring @xmath234 qubits ( as seen in section [ sec_tools ] ) .",
    "we also need to store the value of the quotient @xmath134 .",
    "we noted that in the extended eulcidean algorithm for polynomials large quotients are rare .",
    "in @xcite it is shown that by bounding the size of @xmath134 to @xmath235 bits , the total loss of fidelity will be at most @xmath236 , which is acceptable in the context of shor s algorithm .",
    "so we store @xmath134 in a register of @xmath235 qubits .    for the synchronization",
    "we need a flag qubit @xmath126 , and 2-qubit counter register @xmath16 ( to index the 4 operations @xmath237 and @xmath190 used in the synchronization ) . recall that we also need a `` halting counter '' , as the computations in the superposition will finish the extended euclidean algorithm for polynomials after different numbers of iterations .",
    "the exact size of this halting counter depends on the exact time complexity of the algorithm . however , as our implementation is clearly polynomial in @xmath62 , we know that the size of the halting counter will be at most logarithmic in @xmath62 .",
    "we will write @xmath238 for the number of qubits required for the halting counter , where it is understood that @xmath238 is @xmath239 .",
    "such a halting counter would be required in any quantum implementation of the extended euclidean algorithm for polynomials .",
    "so we have that the qubit space complexity for our implementation of the extended euclidean algorithm for polynomials , and thus of the elliptic curve group operation for curves over @xmath3 , is @xmath240",
    "this research was supported by mitacs ( mathematics of information technology and complex systems ) , nserc ( national science and engineering research council ) , cse ( communications security establishment ) , csi ( canadian foundation for innovation ) , orcdf ( ontario research and development challenge fund ) , and prea ( premier s research excellence awards ) ."
  ],
  "abstract_text": [
    "<S> shor s quantum algorithm for discrete logarithms applied to elliptic curve groups forms the basis of a `` quantum attack '' of elliptic curve cryptosystems . to implement this algorithm on a quantum computer requires the efficient implementation of the elliptic curve group operation . </S>",
    "<S> such an implementation requires we be able to compute inverses in the underlying field . in @xcite , proos and zalka </S>",
    "<S> show how to implement the extended euclidean algorithm to compute inverses in the prime field @xmath0 . </S>",
    "<S> they employ a number of optimizations to achieve a running time of @xmath1 , and a space - requirement of @xmath2 qubits ( there are some trade - offs that they make , sacrificing a few extra qubits to reduce running - time ) . in practice </S>",
    "<S> , elliptic curve cryptosystems often use curves over the binary field @xmath3 . in this paper , we show how to implement the extended euclidean algorithm for polynomials to compute inverses in @xmath3 . </S>",
    "<S> working under the assumption that qubits will be an ` expensive ' resource in realistic implementations , we optimize specifically to reduce the qubit space requirement , while keeping the running - time polynomial . </S>",
    "<S> our implementation here differs from that in @xmath4 for @xmath0 , and we are able to take advantage of some properties of the binary field @xmath3 . </S>",
    "<S> we also optimize the overall qubit space requirement for computing the group operation for elliptic curves over @xmath3 by decomposing the group operation to make it `` piecewise reversible '' ( similar to what is done in @xcite for curves over @xmath0 ) . </S>"
  ]
}