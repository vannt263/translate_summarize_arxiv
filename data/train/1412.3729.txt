{
  "article_text": [
    "android is currently the most widespread operating system for mobile devices .",
    "applications running on this system can be downloaded from anywhere , hence reliability is a major concern for its users . in this paper",
    ", we consider applications that may run into an infinite loop , which may cause a resource exhaustion , for instance the battery if the loop continuously uses a sensor as the gps .",
    "android programs are written in java and compiled to the google s dalvik virtual machine ( dvm ) bytecode format  @xcite before installation on a device .",
    "we provide a set of rules for compiling a dalvik bytecode program into a constraint logic program  @xcite .",
    "non - termination of the resulting program entails that of the original one , hence the technique we have presented before  @xcite for proving non - termination of constraint logic programs can be used for proving non - termination of dalvik programs .",
    "we model the memory and the objects it contains with _ arrays _ , so we compile dalvik programs to logic programs with array constraints and we consider the theory of arrays presented in  @xcite .",
    "we briefly describe the operational semantics of the dvm ( see  @xcite for a complete description ) . unlike the jvm which is stack - based",
    ", the dvm is register - based .",
    "each method uses its own array of registers and invoked methods do not affect the registers of invoking methods .",
    "the number of registers used by a method is statically known . at the beginning of an execution , the @xmath0 arguments to a method land in its last @xmath0 registers and the other registers",
    "are initialized to 0 .",
    "many dalvik bytecode instructions are similar , so we concentrate on a restricted set which exemplifies the operations that the dvm performs .    *",
    "@xmath1 move constant @xmath2 into register @xmath3 ( _ i.e. , _ the register at index @xmath3 in the array of registers of the method where this instruction occurs ) . * @xmath4 move the content of register @xmath5 into register @xmath3 .",
    "* @xmath6 store the sum of the content of register @xmath5 and constant @xmath2 into register @xmath3 . * @xmath7 if the content of register @xmath8 is less than the content of register @xmath9 then jump to program point @xmath10 , otherwise execute the immediately following instruction .",
    "* @xmath11 jump to program point @xmath10 . * @xmath12 where @xmath13 is a sequence of register indexes and @xmath14 is a method .",
    "the content @xmath15 of register @xmath16 ,  , @xmath17 of register @xmath18 are the _ actual parameters _ of the call .",
    "value @xmath15 is called _",
    "receiver _ of the call and must be @xmath19 ( the equivalent of null in java ) or a reference to an object @xmath20 .",
    "in the former case , the computation stops with an exception .",
    "otherwise , a lookup procedure is started from the class of @xmath20 upwards along the superclass chain , looking for a method with the same signature as @xmath14 .",
    "that method is run from a state where its last registers are bound to @xmath21 .",
    "* @xmath22 return from a void method . *",
    "@xmath23 move a reference to a new object of class @xmath24 into register @xmath3 .",
    "* @xmath25 ( resp .",
    "@xmath26 ) the content @xmath27 of register @xmath8 must be @xmath19 or a reference to an object @xmath20 .",
    "if @xmath27 is @xmath19 , the computation stops with an exception .",
    "otherwise , @xmath28 ( the value of field @xmath29 of @xmath20 ) is stored into register @xmath3 ( resp .",
    "the content of register @xmath5 is stored into @xmath28 ) .",
    "we model a _ memory _ as a pair @xmath30 where @xmath31 is an array of _ objects _ and @xmath8 is the index into this array where the next insertion will take place .",
    "an _ object _",
    "@xmath20 is an array of terms of the form @xmath32 $ ] where @xmath33 is the name of the class of @xmath20 , @xmath34 , ",
    ", @xmath35 are the names of the fields defined in this class and @xmath36 ,  , @xmath37 are the current values of these fields in @xmath20 .",
    "so , the first component of a memory is an array of arrays of terms and a memory location is an index into this array .",
    "memory locations start at 1 and 0 corresponds to the ` null ` value .",
    "our compilation rules are given in fig .",
    "[ fig : compilation - simple][fig : compilation - memory - constraints ] .",
    "we associate a predicate symbol @xmath38 to each program point @xmath10 of the dalvik program @xmath39 under consideration .",
    "we generate clauses with constraints on integer and array terms .",
    "our constraint theory combines the theory of integers with that of arrays defined in  @xcite .",
    "our clp domain of computation @xmath40 ( values interpreting constraints ) is the union of @xmath41 with the set @xmath42 of arrays of terms of the form @xmath43 where @xmath8 is an integer and with the set of arrays of elements of @xmath42 .",
    "the read @xmath44 $ ] returns the value stored at position @xmath8 of the array @xmath31 and the write @xmath45 is @xmath31 modified so that position @xmath8 has value @xmath46 . for multidimensional arrays , we abbreviate @xmath44\\cdots[j]$ ] with @xmath47 $ ] .",
    "each rule considers an instruction @xmath48 occurring at a program point @xmath10 .",
    "we let @xmath49 and @xmath50 be sequences of distinct variables where @xmath51 is the number of registers used by the method where @xmath48 occurs . for each @xmath52 $ ] , variable @xmath53 ( resp .",
    "@xmath54 ) models the content of register @xmath8 before ( resp .",
    "after ) executing @xmath48 .",
    "we let @xmath55 denote the input memory and @xmath56 the output memory .",
    "so , @xmath57 and @xmath55 ( or @xmath58 $ ] ) in the head of the clauses are input parameters while @xmath56 is an output parameter .",
    "we let @xmath59 denote the sequence @xmath60 and @xmath61 ( where @xmath52 $ ] ) the sequence @xmath62 .",
    "by @xmath63 we mean the length of sequence @xmath64 . for any method @xmath14 , @xmath65 is the program point where @xmath14 starts , @xmath66 is the number of registers used by @xmath14 and @xmath67 is the set of all the methods with the same signature as @xmath14 .",
    "some compilation rules are rather straightforward .",
    "for instance , @xmath1 moves constant @xmath2 into register @xmath3 , so in fig .",
    "[ fig : compilation - simple ] the output register variable @xmath68 is set to @xmath2 while the other register variables remain unchanged ( modelled with @xmath69 ) .",
    "rules for @xmath70 , @xmath71 and @xmath72 are similar . in fig .",
    "[ fig : compilation - invoke ] , we consider method calls . the instruction @xmath73 is compiled into a set of clauses ( one for each method with the same signature as @xmath14 ) which impose that @xmath74 ( the receiver of the call ) is a non-`null ` location ( _ i.e. , _",
    "@xmath75 ) . therefore , if @xmath76 , the execution of the generated clp program fails , as the original dalvik program . if @xmath75 , the lookup procedure begins . for each @xmath77 , this is modelled with the call @xmath78 which starts from the class of the object at location @xmath74 in memory @xmath55 and searches for the closest method @xmath79 with the same signature as @xmath14 upwards along the superclass chain . if @xmath80 , this call succeeds , otherwise it fails . then",
    ", @xmath81 is executed , modelled with @xmath82 , with some registers @xmath83 initialized as expected .",
    "when the execution of @xmath81 has finished , control jumps to the following instruction ( _ i.e. , _",
    "@xmath84 ) . in fig .",
    "[ fig : compilation - memory - constraints ] , we consider some memory - related instructions that we compile to clauses with array constraints .",
    "@xmath85    @xmath86    @xmath87    @xmath88    @xmath89,m ' ) \\leftarrow            \\big\\{o[0]=w,\\ o[1]=f_1(0),\\ \\ldots,\\ o[n]=f_n(0),\\\\[1ex ]            \\hspace{8mm}a_1=a\\{i\\leftarrow o\\},\\ v'_d = i,\\            i_1 = i + 1\\big\\}\\cup \\mathit{id}_{-d},\\            p_{q+1}(\\tilde{v}',[a_1,i_1],m ' )          \\end{array }        } \\ ] ]    @xmath90,m ' ) \\leftarrow          \\big\\{v_i>0,\\ a[v_i , f ] = f(v'_d)\\big\\ } \\cup \\mathit{id}_{-d},\\          p_{q+1}(\\tilde{v}',[a , i],m ' )        } \\ ] ]    @xmath91,m ' ) \\leftarrow            \\big\\{v_i>0,\\ o = a[v_i],\\ o[f ] = f(x),\\            o_1 = o\\{f\\leftarrow f(v_s)\\},\\\\[1ex ]            \\hspace{8mm}a_1 = a\\{v_i \\leftarrow o_1\\}\\big\\ } \\cup \\mathit{id},\\            p_{q+1}(\\tilde{v}',[a_1,i],m ' )          \\end{array }        } \\ ] ]    [ theorem : underapproximation ] let @xmath39 be a dalvik bytecode program and @xmath92 its clp compilation . if there is a computation @xmath93 in @xmath92 then there is an execution @xmath94 of @xmath39 .    more precisely , if there is a finite ( resp .",
    "infinite ) computation in @xmath92 starting from a query @xmath95,m')$ ] ( where @xmath96 , @xmath31 and @xmath8 are values in @xmath40 and @xmath56 is an output variable ) , then there is a finite ( resp .",
    "infinite ) execution of @xmath39 , using the same program points , starting from values corresponding to @xmath96 and @xmath31 in the dvm registers and memory .",
    "the following proposition is a clp reformulation of a result presented in  @xcite .",
    "[ proposition : non - termination ] let @xmath97 and @xmath98 be some clauses .",
    "suppose there exists a set @xmath99 such that formul @xmath100 $ ] and @xmath101 $ ] are true .",
    "then , @xmath102 has an infinite computation in @xmath103 .",
    "consider the android program in fig .",
    "[ fig : alias - loop ] , with the java syntax on the left and the corresponding dalvik bytecode @xmath39 on the right , where ` v0 ` , ` v1 ` ,  denote registers 0 , 1 ,   method ` loop ` in class ` myactivity ` is called when the user taps a button displayed by the application .",
    "execution of this method does not terminate because in the call to ` m ` , the objects ` o1 ` and ` o2 ` are aliased and therefore by decrementing ` x.i ` we are also decrementing ` this.i ` in the loop of method ` m ` .",
    ".... public class loops {                   .method public m(iloops)v    int i ;                                   .registers 4    public void m(int n , loops x ) {      0 :   iget v0 , v1 , loops->i : i",
    "while ( this.i < n ) {               1 :   if - lt v0 , v2 , 3        this.i++ ;                        2 :   return - void        x.i-- ;                           3 :   iget v0 , v1 , loops->i : i      }                                  4 :   add - int / lit8 v0 , v0 , 0x1    }                                    5 :   iput v0 , v1 , loops->i : i }                                      6 :   iget v0 , v3 , loops->i : i                                        7 :   add - int / lit8 v0 , v0 , -0x1                                        8 :   iput v0 , v3 , loops->i : i                                        9 :   goto 0                                        .end method    public class myactivity extends activity {    ...                                  .method public loop(landroid / view / view;)v    public void loop(view v ) {               .registers 5      loops o1 = new loops ( ) ;            10 :   new - instance v0 , loops           loops o2 = o1 ;                     11 :   invoke - direct { v0 } , loops-><init>()v      o1.m(2 , o2 ) ;                       12 :   move - object v1 , v0    }                                    13 :   const/16 v2 , 0x2    ...                                  14 :   invoke - virtual { v0 , v2 , v1 } , loops->m(iloops)v }                                      15 :   return - void                                        .end method ....    we get the following clauses for program points 0 and 14 : @xmath104,m ' ) & \\leftarrow &    \\{a[v_1,f ] = i(v'_0)\\}\\cup\\mathit{id}_{-0},\\    p_1(\\tilde{v}',[a , i],m')\\\\[2ex ]    p_{14}(\\tilde{v},m , m ' ) & \\leftarrow &    \\{v_0>0\\}\\cup\\mathit{id},\\    \\mathit{lookup}_p(m , v_0,\\texttt{loops->m(iloops)v},0),\\\\    & & p_0(0,v_0,v_2,v_1,m , m_1),\\    p_{15}(\\tilde{v}',m_1,m ' ) \\end{array}\\ ] ]    let @xmath92 denote the clp program resulting from the compilation of @xmath39 .",
    "the set of _ binary unfoldings _",
    "@xcite of @xmath92 contains the following clauses @xmath105,m ' ) \\leftarrow    \\big\\ {    v_1>0,\\ o = a[v_1],\\ o[f]=i(x),\\ x < v_2,\\\\[1ex ]    & \\hspace{0.8cm}o_1=o\\{f\\leftarrow i(x+1)\\},\\ a_1=a\\{v_1\\leftarrow o_1\\},\\\\[1ex ]    & \\hspace{0.8cm}v_3>0,\\ o ' = a_1[v_3],\\ o'[f']=i(x'),\\ v'_0 = x'-1,\\\\[1ex ]    & \\hspace{0.8cm}o'_1=o'\\{f'\\leftarrow i(v'_0)\\},\\ a_2=a_1\\{v_3\\leftarrow o'_1\\ }      \\big\\ } \\cup\\mathit{id}_{-0},\\    p_0(\\tilde{v}',[a_2,i],m ' ) \\\\[2ex ]    r ' : &    p_{10}(\\tilde{v},[a , i],m ' ) \\leftarrow    \\{o[0]=\\mathit{loops},\\ o[1 ] = i(0),\\    a_1=a\\{i\\leftarrow o\\},\\\\[1ex ]    & \\hspace{0.8cm}i_1=i+1,\\ i > 0\\},\\    p_0(0,i,2,i,[a_1,i_1],m_1 ) \\end{array}\\ ] ] where @xmath51 corresponds to the path @xmath106 and @xmath107 to the path @xmath108 in @xmath39 . in @xmath107",
    ", @xmath109 corresponds to both @xmath110 and @xmath111 , which expresses that @xmath110 and @xmath111 are aliased .",
    "note that @xmath112 , the address of @xmath109 , is passed to @xmath113 both as second and fourth parameter , which corresponds in @xmath51 to @xmath114 ( ` this ` in method ` m ` ) and @xmath115 ( ` x ` in ` m ` ) .",
    "moreover , when @xmath116 in @xmath51 , we have @xmath117 , @xmath118 and @xmath119 , hence @xmath120 .",
    "therefore , we have @xmath121 , so @xmath122 .",
    "the logical formul of proposition  [ proposition : non - termination ] are true for the set @xmath123 .",
    "hence , @xmath124 has an infinite computation in @xmath103 , which implies  @xcite that @xmath124 has an infinite computation in @xmath92 .",
    "so by theorem  [ theorem : underapproximation ] , @xmath39 has an infinite execution from program point  10 .",
    "we plan to implement the technique described above and to write a solver for array constraints .",
    "currently , our compilation rules only consider the operational semantics of dalvik , a part of the android platform .",
    "we also plan to extend them by considering the operational semantics of other components of android , for instance _ activities _ that we have studied in  @xcite ."
  ],
  "abstract_text": [
    "<S> we present a set of rules for compiling a dalvik bytecode program into a logic program with array constraints . </S>",
    "<S> non - termination of the resulting program entails that of the original one , hence the techniques we have presented before for proving non - termination of constraint logic programs can be used for proving non - termination of dalvik programs . </S>"
  ]
}