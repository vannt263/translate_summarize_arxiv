{
  "article_text": [
    "inspection of bridges , tunnels , wind turbines , and other large civil engineering structures for defects is a time - consuming , costly , and potentially dangerous task . in the future , _ smart coating _ technology , or _",
    "smart paint _ , could do the job more efficiently and without putting people in danger .",
    "the idea behind smart coating is to form a thin layer of a specific substance on an object which then makes it possible to measure a condition of the surface ( such as temperature or cracks ) at any location , without direct access to the location .",
    "the concept of smart coating already occurs in nature , such as proteins closing wounds , antibodies surrounding bacteria , or ants surrounding food to transport it to their nest .",
    "these diverse examples suggest a broad range of applications of smart coating technology in the future , including repairing cracks or monitoring tension on bridges , repairing space craft , fixing leaks in a nuclear reactor , or stopping internal bleeding .",
    "we continue the study of coating problems in the context of self - organizing programmable matter consisting of simple computational elements , called particles , that can establish and release bonds and can actively move in a self - organized way using the geometric version of the amoebot model presented in  @xcite . in doing so , we proceed to investigate the runtime analysis of our universal coating algorithm , introduced in  @xcite .",
    "we first show that coating problems do not only have a ( trivial ) linear lower bound on the runtime , but that there is also a linear lower bound on the competitive gap between the runtime of fully local coating algorithms and coating algorithms that rely on global information .",
    "we then investigate the worst - case time complexity of our universal coating algorithm and show that it terminates within a linear number of rounds with high probability ( w.h.p . ) , where @xmath0 is the number of particles in the system and @xmath1 is a constant . ] , which implies that our algorithm is optimal in terms of worst - case runtime and also in a competitive sense .",
    "moreover , our simulation results show that in practice the competitive ratio of our algorithm is often better than linear .      in the _ geometric amoebot model _",
    ", we consider the graph @xmath2 , where @xmath3 is the infinite regular triangular grid graph .",
    "each vertex in @xmath4 is a position that can be occupied by at most one particle ( see figure  [ fig : graph_handover](a ) ) .",
    "each particle occupies either a single node or a pair of adjacent nodes in @xmath2 .",
    "any structure a particle system can form can be represented as a subgraph of @xmath2 .",
    "two particles occupying adjacent nodes are _ connected _ by a _",
    "bond _ , and we refer to such particles as _ neighbors_. the bonds",
    "do not only ensure that the particles form a connected structure but they are also used for exchanging information as explained below .",
    "particles move by executing a series of _ expansions _ and _ contractions_. a particle which occupies one node is _ contracted _ and can expand to an unoccupied adjacent node to occupy two nodes .",
    "if it occupies two nodes it is _ expanded _ and can contract to occupy a single node . in figure",
    "[ fig : graph_handover](b ) , we illustrate a set of expanded and contracted particles on the underlying graph @xmath2 . for an expanded particle",
    ", we denote the node the particle last expanded into as the _ head _ of the particle and the other occupied node as its _",
    "tail_. for a contracted particle , the single node occupied by the particle is both its head and its tail .    , where nodes of @xmath2 are shown as black circles .",
    "( b ) shows five particles on @xmath2 ; the underlying graph @xmath2 is depicted as a gray mesh ; a contracted particle is depicted as a single black circle and an expanded particle is depicted as two black circles connected by an edge .",
    "( c ) depicts the resulting configuration after a handover was performed by particles @xmath5 and @xmath6 in ( b ) . ]",
    "[ fig : graph_handover ]    to stay connected as they move , neighboring particles coordinate their motion in a _ handover _ , which can occur in two ways .",
    "a contracted particle @xmath5 can initiate a handover by expanding into a node occupied by an expanded neighbor @xmath6 , `` pushing '' @xmath6 and forcing it to contract .",
    "alternatively , an expanded particle @xmath6 can initiate a handover by contracting `` pulling '' a contracted neighbor @xmath5 to the node it is vacating , thereby forcing @xmath5 to expand .",
    "figures  [ fig : graph_handover](b ) and  [ fig : graph_handover](c ) illustrate two particles labeled @xmath5 and @xmath6 performing a handover .",
    "particles are _ anonymous _ but each has a collection of uniquely labeled _ ports _ corresponding to the edges incident to the nodes the particle occupies",
    ". bonds between adjacent particles are formed through ports that face each other .",
    "the particles are assumed to have a common _ chirality _ , meaning they share the same notion of _ clockwise ( cw ) direction_. this allows each particle @xmath5 to label its ports counting in the clockwise direction ; without loss of generality , we assume each particle labels its head and tail ports from @xmath7 to @xmath8 .",
    "however , particles may have different offsets of the labelings , so they do not share a common sense of orientation . each particle hosts a local memory of constant size for which any neighboring particle has read and write access",
    ". with this mechanism particles can communicate by writing into each other s memory .",
    "the _ configuration _ @xmath9 of the system at the beginning of time @xmath10 consists of the nodes in @xmath2 occupied by the object and the set of particles , and for each particle @xmath5 , @xmath9 contains the current state of @xmath5 , including whether it is expanded or contracted , its port labeling , and the contents of its local memory .    following the standard asynchronous model of computation  @xcite",
    ", we assume that the system progresses through atomic _",
    "activations _ of individual particles . at each ( atomic )",
    "activation a particle can perform at most one movement and an arbitrary bounded amount of computation involving its local memory and the shared memories of its neighbors .",
    "a classical result under this model is that for any asynchronous execution of atomic particle activations , we can organize these activations sequentially still producing the same end configuration  @xcite .",
    "we count ( asynchronous ) time in terms of the number of activations .",
    "a _ round _ is over once each particle has been activated at least once .",
    "we assume the activation sequence to be _ fair _ , i.e. , for each particle @xmath5 and any point in time @xmath10 , @xmath5 will eventually be activated at some time @xmath11 .      in the _ universal coating problem",
    "_ we consider an instance @xmath12 where @xmath13 represents the particle system and @xmath14 represents the fixed object to be coated .",
    "let @xmath15 be the number of particles in the system , @xmath16 be the set of nodes occupied by @xmath13 , and @xmath17 be the set of nodes occupied by @xmath14 ( when clear from the context , we may omit the @xmath18 notation ) .",
    "for any two nodes @xmath19 , the _ distance _ @xmath20 between @xmath21 and @xmath22 is the length of the shortest path in @xmath2 from @xmath21 to @xmath22 .",
    "the distance @xmath23 between a @xmath24 and @xmath25 is defined as @xmath26 .",
    "define _ layer @xmath27 _ to be the set of nodes that have a distance @xmath27 to the object , and let @xmath28 be the number of nodes in layer @xmath27 .",
    "an instance is _ valid _ if the following properties hold :    1 .",
    "the particles are all contracted and are initially in the _ idle _ state .",
    "the subgraphs of @xmath2 induced by @xmath17 and @xmath29 , respectively , are connected , i.e. , there is a single object and the particle system is connected to the object .",
    "the subgraph of @xmath2 induced by @xmath30 is connected , i.e. , the object @xmath14 has no holes .",
    "does contain holes , we consider the subset of particles in each connected region of @xmath30 separately . ]",
    "@xmath30 is @xmath31-connected , i.e. , @xmath14 can not form _ tunnels _ of width less than @xmath31 .",
    "note that a width of at least @xmath32 is needed to guarantee that the object can be evenly coated .",
    "the coating of narrow tunnels requires specific technical mechanisms that complicate the protocol without contributing to the basic idea of coating , so we ignore such cases in favor of simplicity .",
    "a configuration @xmath9 is _ legal _ if and only if all particles are contracted and @xmath33 meaning that all particles are as close to the object as possible or",
    "_ coat @xmath14 as evenly as possible_. a configuration @xmath9 is said to be _ stable _ if no particle in @xmath9 ever performs a state change or movement .",
    "an algorithm _ solves _ the universal coating problem if , starting from any valid instance , it reaches a _ stable legal configuration _ in a finite number of rounds .",
    "many approaches have been proposed with potential applications in smart coating ; these can be categorized as active and passive systems . in passive systems ,",
    "particles move based only on their structural properties and interactions with their environment , or have only limited computational ability and lack control of their motion .",
    "examples include dna self - assembly systems ( see , e.g. , the surveys in  @xcite ) , population protocols  @xcite , and slime molds  @xcite .",
    "our focus is on active systems , in which computational particles control their actions and motions to complete specific tasks .",
    "coating has been extensively studied in the area of _ swarm robotics _ , but not commonly treated as a stand - alone problem ; it is instead examined as part of _ collective transport _ ( e.g. ,  @xcite ) or _ collective perception _ ( e.g. ,",
    "see respective section of  @xcite ) .",
    "some research focuses on coating objects as an independent task under the name of _ target surrounding _ or _",
    "boundary coverage_. the techniques used in this context include stochastic robot behaviors  @xcite , rule - based control mechanisms  @xcite and potential field - based approaches  @xcite .",
    "while the analytic techniques developed in swarm robotics are somewhat relevant to this work , those systems have more computational power and movement capabilities than those studied in this work .",
    "michail and spirakis recently proposed a model  @xcite for network construction inspired by population protocols  @xcite .",
    "the population protocol model is related to self - organizing particle systems but is different in that agents ( corresponding to our particles ) can move freely in space and establish connections at any time .",
    "it would , however , be possible to adapt their approach to study coating problems under the population protocol model . in  @xcite we presented our universal coating algorithm and proved its correctness .",
    "we also showed it to be worst - case work - optimal , where work is measured in terms of number of particle movements .",
    "in this paper we continue the analysis of the _ universal coating algorithm _ introduced in  @xcite . as our main contribution in this paper",
    ", we investigate the runtime of our algorithm and prove that our algorithm terminates within a _ linear number of rounds _ with high probability .",
    "we also present a matching linear lower bound for local - control coating algorithms that holds with high probability .",
    "we use this lower bound to show a _ linear lower bound on the competitive gap _ between fully local coating algorithms and coating algorithms that rely on global information , which implies that our algorithm is also optimal in a competitive sense .",
    "we then present some simulation results demonstrating that in practice the competitive ratio of our algorithm is often much better than linear .      in section  [ sec : algo ] , we again present the algorithm introduced in  @xcite .",
    "we present a comprehensive formal runtime analysis of our algorithm , by first presenting some lower bounds on the competitive ratio of any local - control algorithm in section  [ sec : performance ] , and then proving that our algorithm has a runtime of @xmath34 rounds w.h.p .  in section  [ sec : wcruntime ] , which matches our lower bounds .",
    "in this section , we summarize the universal coating algorithm introduced in  @xcite ( see  @xcite for a detailed description ) .",
    "this algorithm is constructed by combining a number of asynchronous primitives , which are integrated seamlessly without any underlying synchronization .",
    "the _ spanning forest _ primitive organizes the particles into a spanning forest , which determines the movement of particles while preserving system connectivity ; the _ complaint - based coating _ primitive coats the first layer by bringing any particles not yet touching the object into the first layer while there is still room ; the _ general layering _ primitive allows each layer @xmath27 to form only after layer @xmath35 has been completed , for @xmath36 ; and the _ node - based leader election _ primitive elects a node in layer 1 whose occupant becomes the leader particle , which is used to trigger the general layering process for higher layers .",
    "we define the set of _ states _ that a particle can be in as _ idle _ , _ follower _ , _ root _ , and _ retired_. in addition to its state , a particle maintains a constant number of other flags , which in our context are constant size pieces of information visible to neighboring particles .",
    "a flag @xmath37 owned by some particle @xmath5 is denoted by @xmath38 .",
    "recall that a _ layer _ is the set of nodes @xmath39 that are equidistant to the object @xmath14 .",
    "a particle keeps track of its current layer number in @xmath40 . in order to respect the constant - size memory constraint of particles ,",
    "we take all layer numbers modulo @xmath41 . each root particle",
    "@xmath5 has a flag @xmath42 which stores a port label pointing to a node of the object if @xmath43 , and to an occupied node adjacent to its head in layer @xmath44 if @xmath45 .",
    "we now describe the coating primitives in more detail .",
    "the * _ spanning forest primitive _ * ( algorithm  [ alg : spanningforestalgorithm ] ) organizes the particles into a spanning forest @xmath46 , which yields a straightforward mechanism for particles to move while preserving connectivity ( see  @xcite for details ) .",
    "initially , all particles are _",
    "idle_. a particle @xmath5 touching the object changes its state to _",
    "root_. for any other idle particle @xmath5 , if @xmath5 has a root or a follower in its neighborhood , it stores the direction to one of them in @xmath47 , changes its state to _ follower _ , and generates a complaint flag ; otherwise , it remains idle .",
    "a follower particle @xmath5 uses handovers to follow its parent and updates the direction @xmath47 as it moves in order to maintain the same parent in the tree ( note that the particular particle at @xmath47 may change due to @xmath5 s parent performing a handover with another of its children ) . in this way",
    ", the trees formed by the parent relations stay connected , occupy only the nodes they covered before , and do not mix with other trees .",
    "a root particle @xmath5 uses the flag @xmath48 to determine its movement direction . as @xmath5 moves , it updates @xmath48 so that it always points to the next position of a clockwise movement around the object . for any particle @xmath5 , we call the particle occupying the position that @xmath47 resp . @xmath48 points to the _ predecessor _ of @xmath5 .",
    "if a root particle does not have a predecessor , we call it a _ super - root_.    a particle @xmath5 acts depending on its state as described below : +    lx * idle * : & if @xmath5 is adjacent to the object @xmath14 , it becomes a _ root _ particle , makes the current node it occupies a _ leader candidate position _ , and starts running the leader election algorithm .",
    "if @xmath5 is adjacent to a _ retired _ particle , @xmath5 also becomes a _",
    "root _ particle .",
    "if a neighbor @xmath49 is a root or a follower , @xmath5 sets the flag @xmath47 to the label of the port to @xmath49 , puts a _ complaint flag _ in its local memory , and becomes a _",
    "follower_. if none of the above applies , @xmath5 remains idle .",
    "+ * follower * : & if @xmath5 is contracted and adjacent to a retired particle or to @xmath14 , then @xmath5 becomes a _ root",
    "_ particle .",
    "if @xmath5 is contracted and has an expanded parent , then @xmath5 initiates handover@xmath50 ( algorithm  [ alg : handover ] ) ; otherwise , if @xmath5 is expanded , it considers the following two cases : @xmath51 if @xmath5 has a contracted child particle @xmath6 , then @xmath5 initiates handover@xmath50 ; @xmath52 if @xmath5 has no children and no idle neighbor , then @xmath5 contracts .",
    "finally , if @xmath5 is contracted , it runs the function forwardcomplaint@xmath53 ( algorithm  [ alg : complaint ] ) .",
    "+ * root * : & if particle @xmath5 is in layer 1 , @xmath5 participates in the leader election process .",
    "if @xmath5 is contracted , it first executes markerretiredconditions@xmath50 ( algorithm  [ alg : retiredcondition ] ) and becomes _ retired _ , and possibly also a _ marker _ , accordingly .",
    "if @xmath5 does not become retired , then if it has an expanded root in @xmath48 , it initiates handover@xmath50 ; otherwise , @xmath5 calls layerextension@xmath50 ( algorithm  [ alg : boundarydirectionalgorithm ] ) .",
    "if @xmath5 is expanded , it considers the following two cases : @xmath51 if @xmath5 has a contracted child , then @xmath5 initiates handover@xmath50 ; @xmath52 if @xmath5 has no children and no idle neighbor , then @xmath5 contracts .",
    "finally , if @xmath5 is contracted , it runs forwardcomplaint@xmath54 . +",
    "* retired * : & @xmath5 clears a potential complaint flag from its memory and performs no further action .",
    "the * _ complaint - based coating primitive _ * is used for the coating of the first layer .",
    "each time a particle @xmath5 holding at least one complaint flag is activated , it forwards one to its predecessor as long as that predecessor holds less than two complaint flags .",
    "we allow each particle to hold up to two complaint flags to ensure that a constant size memory is sufficient for storing the complaint flags and so the flags quickly move forward to the super - roots .",
    "a contracted super - root @xmath5 only expands to @xmath48 if it holds at least one complaint flag , and when it expands , it consumes one of these complaint flags .",
    "all other roots @xmath5 move towards @xmath48 whenever possible ( i.e. , no complaint flags are required ) by performing a handover with their predecessor ( which must be another root ) or a successor ( which is a root or follower of its tree ) , with preference given to a follower so that additional particles enter layer 1 .",
    "as we will see , these rules ensure that whenever there are particles in the system that are not yet at layer 1 , eventually one of these particles will move to layer 1 , unless layer 1 is already completely filled with contracted particles .",
    "@xmath5 initiates a handover with particle @xmath6 @xmath5 initiates a handover with particle @xmath6 @xmath5 initiates a handover with particle @xmath6    @xmath5 forwards one complaint flag to @xmath6    the * _ leader election primitive _ * runs during the complaint - based coating primitive to elect a node in layer 1 as the leader position .",
    "this primitive is similar to the algorithm presented in  @xcite with the difference that leader candidates are nodes instead of static particles ( which is important because in our case particles may still move during the leader election primitive ) .",
    "the primitive only terminates once all positions in layer 1 are occupied . once the leader position is determined , all positions in layer 1 are filled by contracted particles and whatever particle currently occupies that position becomes the _",
    "leader_. this leader becomes a marker particle , marking a neighboring position in the next layer as a _ marked position _ which determines a starting point for layer 2 , and becomes _ retired_.",
    "once a contracted root @xmath5 has a retired particle in the direction @xmath48 , it retires as well , which causes the particles in layer 1 to become retired in counter - clockwise order . at this point ,",
    "the general layering primitive becomes active , which builds subsequent layers until there are no longer followers in the system .",
    "if the leader election primitive does not terminate ( which only happens if @xmath55 and layer 1 is never completely filled ) , then the complaint flags ensure that the super - roots eventually stop , which eventually results in a stable legal coating .",
    "the layer number of any node occupied by the object is equal to 0 .",
    "let @xmath6 be any neighbor of @xmath5 with smallest layer number ( modulo @xmath41 ) .",
    "@xmath56 @xmath57 @xmath58 @xmath59    * extending layer @xmath40 * @xmath5 expands in direction @xmath48 @xmath5 consumes a complaint flag , if it holds one    in the * _ general layering primitive _ * , whenever a follower is adjacent to a retired particle , it becomes a root .",
    "root particles continue to move along positions of their layer in a clockwise ( if the layer number is odd ) or counter - clockwise ( if the layer number is even ) direction until they reach either the marked position of that layer , a retired particle in that layer , or an empty position of the previous layer ( which causes them to change direction ) .",
    "complaint flags are no longer needed to expand into empty positions .",
    "followers follow their parents as before .",
    "a contracted root particle @xmath5 may retire if : ( i ) it occupies the marked position and the marker particle in the lower layer tells it that all particles in that layer are retired ( which it can determine locally ) , or ( ii ) it has a retired particle in the direction @xmath48 .",
    "once a particle at a marked position retires , it becomes a marker particle and marks a neighboring position in the next layer as a marked position .",
    "@xmath60 , @xmath61 @xmath62 @xmath63 @xmath64 @xmath65    @xmath5 becomes a _ retired _",
    "particle    @xmath5 becomes a _ retired _",
    "particle    @xmath5 becomes a _ retired _ particle",
    "recall that a _ round _ is over once every particle in @xmath13 has been activated at least once .",
    "the _ runtime _ @xmath66 of a coating algorithm @xmath67 is defined as the worst - case number of rounds ( over all sequences of particle activations ) required for @xmath67 to solve the coating problem @xmath12 . certainly , there are instances @xmath12 where every coating algorithm has a runtime of @xmath68 ( see lemma  [ lem : lowerbound ] ) , though there are also many other instances where the coating problem can be solved much faster . since a worst - case runtime of @xmath68 is fairly large and therefore not very helpful to distinguish between different coating algorithms , we intend to study the runtime of coating algorithms relative to the best possible runtime .",
    "[ lem : lowerbound ] the worst - case runtime required by any local - control algorithm to solve the universal coating problem is @xmath68 .     particles ( black dots ) in a line connected to the surface via a single particle @xmath69.,width=226 ]    [ fig : worstcaseretiredstructure ]    assume the particles @xmath70 form a single line of @xmath0 particles connected to the surface via @xmath69 ( figure  [ fig : worstcaseretiredstructure ] ) .",
    "suppose @xmath71 .",
    "since @xmath72 , it will take @xmath68 rounds in the worst - case ( requiring @xmath73 movements ) until @xmath74 touches the object s surface .",
    "this worst - case can happen , for example , if @xmath74 performs no more than one movement ( either an expansion or a contraction ) per round .",
    "unfortunately , a large lower bound also holds for the competitiveness of any local - control algorithm . a coating algorithm @xmath67 is called _ @xmath75-competitive _ if for any valid instance @xmath12 , @xmath76 \\leq c \\cdot { \\ensuremath{\\text{opt}}}(p , o ) + k\\ ] ] where @xmath77 is the minimum runtime needed to solve the coating problem @xmath12 and @xmath78 is a value independent of @xmath12 .",
    "[ thm : competitiveness ] any local - control algorithm that solves the universal coating problem has a competitive ratio of @xmath68 .",
    "we construct an instance of the coating problem @xmath12 which can be solved by an optimal algorithm in @xmath79 rounds , but requires any local - control algorithm @xmath68 times longer .",
    "let @xmath14 be a straight line of arbitrary ( finite ) length , and let @xmath13 be a set of particles which entirely occupy layer 1 , with the exception of one missing particle below @xmath14 equidistant from its sides and one additional particle above @xmath14 in layer 2 equidistant from its sides ( see figure  [ fig : opt1borders ] ) .",
    "an optimal algorithm could move the particles to solve the coating problem for the given example in @xmath79 rounds , as in figure  [ fig : opt2 ] .",
    "note that the optimal algorithm always maintains the connectivity of the particle system , so its runtime is valid even under the constraint that any connected component of particles must stay connected .",
    "however , for our local - control algorithms we allow particles to disconnect from the rest of the system .    .",
    "the particles are all contracted and occupy the positions around the object , with the exception that there is one unoccupied node below the object and one extra particle above the object",
    ". borders @xmath80 and @xmath81 are shown as red lines . ]",
    "[ fig : opt1borders ]    now consider an arbitrary local - control algorithm @xmath82 for the coating problem . given a round @xmath83 ,",
    "we define the _ imbalance _ @xmath84 at border @xmath80 as the net number of particles that have crossed @xmath80 from the top of @xmath14 to the bottom until round @xmath83 ; similarly , the imbalance @xmath85 at border @xmath81 is defined to be the net number of particles that have crossed @xmath81 from the bottom of @xmath14 to the top until round @xmath83 .",
    "[ fig : opt2 ]    certainly , there is an activation sequence in which information and particles can only travel a distance of up to @xmath86 nodes towards @xmath80 or @xmath81 within the first @xmath86 rounds .",
    "hence , for any @xmath87 , the probability distributions of @xmath84 and @xmath85 are independent of each other .",
    "additionally , particles up to a distance of @xmath86 from @xmath80 and @xmath81 can not distinguish between which border they are closer to , since the position of the gap is equidistant from the borders .",
    "this symmetry also implies that @xmath88=\\pr[\\phi_r(r)=k]$ ] for any integer @xmath89 .",
    "let us focus on round @xmath90 .",
    "we distinguish between the following cases .",
    "then there are more particles than positions in layer 1 above @xmath14 , so the coating problem can not be solved yet .",
    "@xmath92 . from our insights above we know that for any two values @xmath93 and @xmath94 , @xmath95 and @xmath96 = \\pr[\\phi_l(n/4)=k_2 $ ] and @xmath97 $ ] .",
    "hence , the cumulative probability of all outcomes where @xmath98 is equal to the cumulative probability of all outcomes where @xmath99 . if @xmath98 , then there are again more particles than positions in layer 1 above @xmath14 , so the coating problem can not be solved yet .",
    "thus , the probability that @xmath67 has not solved the coating problem after @xmath86 rounds is at least @xmath100 , and therefore @xmath101 \\geq 1/2 \\cdot n/4 = n/8 $ ] . since , on the other hand , @xmath102 ,",
    "we have established a linear competitive ratio .",
    "therefore , even the competitive ratio can be very high in the worst case .",
    "we will revisit the notion of competitiveness in section  [ sec : experimental ] .",
    "in this section , we show that our algorithm solves the coating problem within a linear number of rounds w.h.p .. we start with some basic notation in section  [ sec : preliminaryanalysis ] .",
    "section  [ sec : parallel ] presents a simpler synchronous parallel model for particle activations that we can use to analyze the worst - case number of rounds .",
    "section  [ sec : firstlayer ] presents the analysis of the number of rounds required to coat the first layer .",
    "finally , in section  [ sec : higherlayers ] , we analyze the number of rounds required to complete all other coating layers , once layer 1 has been completed .",
    "we start with some notation .",
    "recall that @xmath28 denotes the number of nodes of @xmath2 at distance @xmath27 from object @xmath14 ( i.e. , the number of nodes in layer @xmath27 ) .",
    "let @xmath103 be the the layer number of the final layer for @xmath0 particles ( i.e. , @xmath103 satisfies @xmath104 ) .",
    "layer @xmath27 is said to be _ complete _ if every node in layer @xmath27 is occupied by a contracted retired particle ( for @xmath105 ) , or if all particles have reached their final position , are contracted , and never move again ( for @xmath106 ) .    given a configuration @xmath9 , we define a directed graph @xmath107 over all nodes in @xmath2 occupied by _ active _ ( follower or root ) particles in @xmath9 . for every expanded active particle @xmath5 in @xmath9",
    ", @xmath107 contains a directed edge from the tail to the head of @xmath5 . for every follower @xmath5",
    ", @xmath107 has a directed edge from the head of @xmath5 to @xmath47 . for the purposes of constructing @xmath107 , we also define parents for root particles : a root particle @xmath5 sets @xmath47 to be the active particle @xmath6 occupying the node in direction @xmath48 once @xmath5 has performed its first handover expansion with @xmath6 . for every root particle @xmath5",
    ", @xmath107 has a directed edge from the head of @xmath5 to @xmath47 , if it exists . certainly , since every node has at most one outgoing edge in @xmath107 , the nodes of @xmath107 form either a collection of disjoint trees or a ring of trees .",
    "a ring of trees may occur in any layer , but only temporarily ; the leader election primitive ensures that a leader emerges and retires in layer 1 and marker particles emerge and retire in higher layers , causing the ring in @xmath107 to break .",
    "the super - roots defined in section  [ subsec : coatingprimitives ] correspond to the roots of the trees in @xmath107 .",
    "a _ movement _ executed by a particle @xmath5 can be either a _ sole contraction _ in which @xmath5 contracts and leaves a node unoccupied , a _ sole expansion _ in which @xmath5 expands into an adjacent unoccupied node , a _ handover contraction with @xmath49 _ in which @xmath5 contracts and forces its contracted neighbor @xmath49 to expand into the node it vacates , or a _ handover expansion with @xmath49 _ in which @xmath5 expands into a node currently occupied by its expanded neighbor @xmath49 , forcing @xmath49 to contract .      in this section ,",
    "we show that instead of analyzing our algorithm for asynchronous activations of particles , it suffices to consider a much simpler model of parallel activations of particles .",
    "movement schedule _ to be a sequence of particle system configurations @xmath108 .",
    "[ defn : parallelschedule ] a movement schedule @xmath108 is called a _ parallel schedule _",
    "if each @xmath109 is a valid configuration of a connected particle system ( i.e. , each particle is either expanded or contracted , and every node of @xmath2 is occupied by at most one particle ) and for every @xmath110 is reached from @xmath109 such that for every particle @xmath5 one of the following properties holds :    1 .",
    "@xmath5 occupies the same node(s ) in @xmath109 and @xmath111 , 2 .",
    "@xmath5 expands into an adjacent node that was empty in @xmath109 , 3 .",
    "@xmath5 contracts , leaving the node occupied by its tail empty in @xmath111 , or 4 .",
    "@xmath5 is part of a handover with a neighboring particle @xmath49 .",
    "while these properties allow at most one contraction or expansion per particle in moving from @xmath109 to @xmath111 , multiple particles may move in this time .    consider an arbitrary fair asynchronous activation sequence @xmath82 for a particle system , and let @xmath112 , for @xmath113 , be the particle system configuration at the end of asynchronous round @xmath27 in @xmath82 if each particle moves according to algorithm  [ alg : spanningforestalgorithm ] .",
    "a _ forest schedule _",
    "@xmath114 is a parallel schedule @xmath108 with the property that @xmath115 is a forest of one or more trees , and each particle @xmath5 follows the unique path @xmath116 which it would have followed according to @xmath82 , starting from its position in @xmath117 .",
    "this implies that @xmath118 remains a forest of trees for every @xmath119 .",
    "a forest schedule is said to be _ greedy _ if all particles perform movements according to definition  [ defn : parallelschedule ] in the direction of their unique paths whenever possible .",
    "we begin our analysis with a result that is critical to both describing configurations of particles in greedy forest schedules and quantifying the amount of progress greedy forest schedules make over time .",
    "specifically , we show that if a forest s configuration is `` well - behaved '' at the start , then it remains so throughout its greedy forest schedule , guaranteeing that progress is made once every two configurations .",
    "[ lem : expparentchild ] given any fair asynchronous activation sequence @xmath82 , consider any greedy forest schedule @xmath120 .",
    "if every expanded parent in @xmath117 has at least one contracted child , then every expanded parent in @xmath109 also has at least one contracted child , for @xmath119 .",
    "suppose to the contrary that @xmath109 is the first configuration that contains an expanded parent @xmath5 which has all expanded children .",
    "we consider all possible expanded and contracted states of @xmath5 and its children in @xmath121 and show that none of them can result in @xmath5 and its children all being expanded in @xmath109 .",
    "first suppose @xmath5 is expanded in @xmath121 ; then by supposition , @xmath5 has a contracted child @xmath6 . by definition  [ defn : parallelschedule ]",
    ", @xmath6 can not perform any movements with its children ( if they exist ) , so @xmath5 performs a handover contraction with @xmath6 , yielding @xmath5 contracted in @xmath109 , a contradiction .",
    "so suppose @xmath5 is contracted in @xmath121 .",
    "we know @xmath5 will perform either a handover with its parent or a sole expansion in direction @xmath48 since it is expanded in @xmath109 by supposition .",
    "thus , any child of @xmath5 in @xmath121  say @xmath6  does not execute a movement with @xmath5 in moving from @xmath121 to @xmath109 .",
    "instead , if @xmath6 is contracted in @xmath121 then it remains contracted in @xmath109 since it is only permitted to perform a handover with its unique parent @xmath5 ; otherwise , if @xmath6 is expanded , it performs either a sole contraction if it has no children or a handover with one of its contracted children , which it must have by supposition . in either case",
    ", @xmath5 has a contracted child in @xmath109 , a contradiction .    as a final observation , two trees of the forest",
    "may `` merge '' when the super - root @xmath122 of one tree performs a sole expansion into an unoccupied node adjacent to a particle @xmath6 of another tree .",
    "however , since @xmath122 is a root and thus only defines @xmath6 as its parent after performing a handover expansion with it , the lemma holds in this case as well .",
    "for any particle @xmath5 in a configuration @xmath9 of a forest schedule , we define its _ head distance _",
    "@xmath123 ( resp . , _ tail distance _",
    "@xmath124 ) to be the number of edges along @xmath116 from the head ( resp . , tail ) of @xmath5 to the end of @xmath116 . depending on",
    "whether @xmath5 is contracted or expanded , we have @xmath125 . for any two configurations @xmath9 and @xmath126 and any particle @xmath5 , we say that @xmath9 _ dominates @xmath126 w.r.t .",
    "@xmath5 _ , denoted @xmath127 , if and only if @xmath128 and @xmath129 .",
    "we say that @xmath9 _ dominates _",
    "@xmath126 , denoted @xmath130 , if and only if @xmath9 dominates @xmath126 with respect to every particle .",
    "then it holds :    [ lem : forestdom ] given any fair asynchronous activation sequence @xmath82 which begins at an initial configuration @xmath131 in which every expanded parent has at least one contracted child , there is a greedy forest schedule @xmath114 with @xmath132 such that @xmath133 for all @xmath113 .",
    "we first introduce some supporting notation .",
    "let @xmath134 be the sequence of movements @xmath5 executes according to @xmath82 .",
    "let @xmath135 denote the remaining sequence of movements in @xmath136 after the forest schedule reaches @xmath109 , and let @xmath137 denote the first movement in @xmath135 .",
    "a greedy forest schedule @xmath114 can be constructed from configuration @xmath132 such that , for every @xmath113 , configuration @xmath109 is obtained from @xmath121 by executing only the movements of a greedily selected , mutually compatible subset of @xmath138 .",
    "argue by induction on @xmath27 , the current configuration number .",
    "@xmath117 is trivially obtained , as it is the initial configuration .",
    "assume by induction that the claim holds up to @xmath121 .",
    "w.l.o.g .",
    "let @xmath139 , for @xmath140 , be the greedily selected , mutually compatible subset of movements that @xmath141 performs in moving from @xmath121 to @xmath109 .",
    "suppose to the contrary that a movement @xmath142 is executed by a particle @xmath143 .",
    "it is easily seen that @xmath144 can not be @xmath145 ; since @xmath145 was excluded when @xmath146 was greedily selected , it must be incompatible with one or more of the selected movements and thus can not also be executed at this time .",
    "so @xmath147 , and we consider the following cases :    @xmath145 is a sole contraction . then @xmath5 is expanded and has no children in @xmath121 , so we must have @xmath148 , since there are no other movements @xmath5 could execute , a contradiction .",
    "@xmath145 is a sole expansion .",
    "then @xmath5 is contracted and has no parent in @xmath121 , so we must have @xmath148 , since there are no other movements @xmath5 could execute , a contradiction .",
    "@xmath145 is a handover contraction with @xmath6 , one of its children . then at some time in @xmath141 before reaching @xmath121 , @xmath6 became a descendant of @xmath5 ; thus , @xmath6 must also be a descendant of @xmath5 in @xmath121 .",
    "if @xmath6 is not a child of @xmath5 in @xmath121 , there exists a particle @xmath149 such that @xmath6 is a descendant of @xmath150 , which is in turn a descendant of @xmath5 .",
    "so in order for @xmath145 to be a handover contraction with @xmath6 , @xmath151 must include actions which allow @xmath150 to `` bypass '' its ancestor @xmath5 , which is impossible .",
    "so @xmath6 must be a child of @xmath5 in @xmath121 , and must be contracted at the time @xmath145 is performed . if @xmath6 is also contracted in @xmath121 , then once again we must have @xmath148 .",
    "otherwise , @xmath6 is expanded in @xmath121 , and must have become so before @xmath121 was reached . but",
    "this yields a contradiction : since @xmath141 is greedy , @xmath6 would have contracted prior to this point by executing either a sole contraction if it has no children , or a handover contraction with a contracted child whose existence is guaranteed by lemma  [ lem : expparentchild ] , since every expanded parent in @xmath117 has a contracted child .",
    "@xmath145 is a handover expansion with @xmath6 , its unique parent .",
    "then we must have that @xmath152 is a handover contraction with @xmath5 , and an argument analogous to that of case 3 follows .",
    "we conclude by showing that each configuration of the greedy forest schedule @xmath141 constructed according to the claim is dominated by its asynchronous counterpart .",
    "argue by induction on @xmath27 , the configuration number . since @xmath132 , we have that @xmath153 .",
    "assume by induction that for all rounds @xmath154 , we have @xmath155 .",
    "consider any particle @xmath5 .",
    "since @xmath141 is constructed using the exact set of movements @xmath5 executes according to @xmath82 and each time @xmath5 moves it decreases either its head distance or tail distance by @xmath156 , it suffices to show that @xmath5 has performed at most as many movements in @xmath141 up to @xmath109 as it has according to @xmath82 up to @xmath112 .",
    "if @xmath5 does not perform a movement between @xmath121 and @xmath109 , we trivially have @xmath157",
    ". otherwise , @xmath5 performs movement @xmath145 to obtain @xmath109 from @xmath121 .",
    "if @xmath5 has already performed @xmath145 according to @xmath82 before reaching @xmath158 , then clearly @xmath157 .",
    "otherwise , @xmath145 must be the next movement @xmath5 is to perform according to @xmath82 , since @xmath5 has performed the same sequence of movements in the asynchronous execution as it has in @xmath141 up to the respective rounds @xmath35 , and thus has equal head and tail distances in @xmath121 and @xmath158 . it remains to show that @xmath5 can indeed perform @xmath145 between @xmath158 and @xmath112 .",
    "if @xmath145 is a sole expansion , then @xmath5 is the super - root of its tree ( in both @xmath121 and @xmath158 ) and must also be able to expand in @xmath158 . similarly ,",
    "if @xmath145 is a sole contraction , then @xmath5 has no children ( in both @xmath121 and @xmath158 ) and must be able to contract in @xmath158 . if @xmath145 is a handover expansion with its parent @xmath6 , then @xmath6 must be expanded in @xmath121 .",
    "parent @xmath6 must also be expanded in @xmath158 ; otherwise @xmath159 , contradicting the induction hypothesis .",
    "an analogous argument holds if @xmath145 is a handover contraction with one of its contracted children .",
    "therefore , in any case we have @xmath157 , and since the choice of @xmath5 was arbitrary , @xmath133 .",
    "we can show a similar dominance result when considering complaint flags .",
    "[ defn : complaintparallelschedule ] a movement schedule @xmath108 is called a _",
    "complaint - based parallel schedule _",
    "if each @xmath109 is a valid configuration of a particle system in which every particle holds at most _ one _ complaint flag ( rather than two , as described in algorithm  [ alg : complaint ] ) and for every @xmath160 , @xmath111 is reached from @xmath109 such that for every particle @xmath5 one of the following properties holds :    1 .",
    "@xmath5 does not hold a complaint flag and property 1 , 3 , or 4 of definition  [ defn : parallelschedule ] holds , 2 .",
    "@xmath5 holds a complaint flag @xmath161 and expands into an adjacent node that was empty in @xmath109 , consuming @xmath161 , 3 .",
    "@xmath5 forwards a complaint flag @xmath161 to a neighboring particle @xmath49 which either does not hold a complaint flag in @xmath109 or is also forwarding its complaint flag .    a _ complaint - based forest schedule",
    "_ @xmath114 has the same properties as a forest schedule , with the exception that @xmath108 is a complaint - based parallel schedule as opposed to a parallel schedule .",
    "a complaint - based forest schedule is said to be _ greedy _ if all particles perform movements according to definition  [ defn : complaintparallelschedule ] in the direction of their unique paths whenever possible .",
    "we can now extend the dominance argument to hold with respect to _ complaint distance _ in addition to head and tail distances .",
    "for any particle @xmath5 holding a complaint flag @xmath161 in configuration @xmath9 , we define its complaint distance @xmath162 to be the number of edges along @xmath116 from the node @xmath5 occupies to the end of @xmath116 . for any two configurations @xmath9 and @xmath126 and any complaint flag @xmath161 , we say that _",
    "@xmath9 dominates @xmath126 w.r.t .",
    "@xmath161 _ , denoted @xmath163 , if and only if @xmath164 . extending the previous notion of dominance",
    ", we say that _",
    "@xmath9 dominates @xmath126 _ , denoted @xmath130 , if and only if @xmath9 dominates @xmath126 with respect to every particle and with respect to every complaint flag .",
    "it is also possible to construct a greedy complaint - based forest schedule whose configurations are dominated by their asynchronous counterparts , as we did for greedy forest schedules in lemma  [ lem : forestdom ] .",
    "many of the details are the same , so as to avoid redundancy we highlight the differences here .",
    "the most obvious difference is the inclusion of complaint flags .",
    "definition  [ defn : complaintparallelschedule ] restricts particles to holding at most one complaint flag at a time , where algorithm  [ alg : complaint ] allows a capacity of two .",
    "this allows the asynchronous execution to not `` fall behind '' the parallel schedule in terms of forwarding complaint flags .",
    "basically , definition  [ defn : complaintparallelschedule ] allows a particle @xmath5 holding a complaint flag @xmath161 in the parallel schedule to forward @xmath161 to its parent @xmath6 even if @xmath6 currently holds its own complaint flag , so long as @xmath6 is also forwarding its flag at this time .",
    "the asynchronous execution does not have this luxury of synchronized actions , so the mechanism of buffering up to two complaint flags at a time allows it to `` mimic '' the pipelining of forwarding complaint flags that is possible within one round of a complaint - based parallel schedule .",
    "another slight difference is that a contracted particle can not expand into an empty adjacent node unless it holds a complaint flag to consume .",
    "however , this restriction reflects algorithm  [ alg : boundarydirectionalgorithm ] , so once again the greedy complaint - based forest schedule can be constructed directly from the movements taken in the asynchronous execution .",
    "moreover , since this restriction can only cause a contracted particle to remain contracted , the conditions of lemma  [ lem : expparentchild ] are still upheld .",
    "thus , we obtain the following lemma :    [ lem : flagforestdom ] given any fair asynchronous activation sequence @xmath82 which begins at an initial configuration @xmath131 in which every expanded parent has at least one contracted child , there is a greedy complaint - based forest schedule @xmath165 with @xmath132 such that @xmath133 for all @xmath113 .",
    "by lemmas  [ lem : forestdom ] and  [ lem : flagforestdom ] , once we have an upper bound for the time it takes a greedy forest schedule to reach a final configuration , we also have an upper bound for the number of rounds required by the asynchronous execution .",
    "hence , the remainder of our proofs will serve to upper bound the number of parallel rounds any greedy forest schedule would require to solve the coating problem for a given valid instance @xmath12 , where @xmath166 .",
    "let @xmath167 be such a greedy forest schedule , where @xmath117 is the initial configuration of the particle system @xmath13 ( of all contracted particles ) and @xmath168 is the final coating configuration .    in sections  [ sec : firstlayer ] and  [ sec",
    ": higherlayers ] , we will upper bound the number of parallel rounds required by @xmath169 in the worst case to coat the first layer and higher layers , respectively . more specifically",
    ", we will bound the worst - case time it takes to complete a layer @xmath27 once layers @xmath170 have been completed . for convenience",
    ", we will not differentiate between complaint - based and regular forest schedules in the following sections , since the same dominance result holds whether or not complaint flags are considered . to prove these bounds , we need one last definition : a _ forest  path schedule _",
    "@xmath171 is a forest schedule @xmath172 with the property that all the trees of @xmath115 are rooted at a path @xmath173 , and each particle @xmath5 must traverse @xmath80 in the same direction .",
    "our algorithm must first organize the particles using the spanning forest primitive , whose runtime is easily bounded :    following the spanning forest primitive , the particles form a spanning forest within @xmath174 rounds .    initially all particles are idle . in each round any idle particle adjacent to the object , an active ( follower or root ) particle , or a retired particle becomes active .",
    "it then sets its parent flag if it is a follower , or becomes the root of a tree if it is adjacent to the object or a retired particle . in each round",
    "at least one particle becomes active , so  given @xmath0 particles in the system  it will take @xmath174 rounds in the worst case until all particles join the spanning forest .    for ease of presentation ,",
    "we assume that the particle system is of sufficient size to fill the first layer ( i.e. , @xmath175 ; the proofs can easily be extended to handle the case when @xmath176 ) ; we also assume that the root of a tree also generates a complaint flag upon its activation ( this assumption does not hurt our argument since it only increases the number of the flags generated in the system ) .",
    "let @xmath177 be the greedy forest  path schedule where @xmath178 is a truncated version of @xmath169 , @xmath179  for @xmath180  is the configuration in @xmath169 in which layer @xmath156 becomes complete , and @xmath181 is the path of nodes in layer @xmath156 .",
    "the following lemma shows that the algorithm makes steady progress towards completing layer @xmath156 .",
    "[ lem : progresslayer1 ] consider a round @xmath27 of the greedy forest  path schedule @xmath182 , where @xmath183 . then within the next two parallel rounds of @xmath182 ,",
    "@xmath51 at least one complaint flag is consumed , @xmath52 at least one more complaint flag reaches a particle in layer @xmath156 , @xmath184 all remaining complaint flags move one position closer to a super - root along @xmath181 , or @xmath185 layer @xmath156 is completely filled ( possibly with some expanded particles ) .",
    "if layer 1 is filled , @xmath185 is satisfied ; otherwise , there exists at least one super - root in @xmath118 .",
    "we consider several cases :    there exists a super - root @xmath122 in @xmath118 which holds a complaint flag .",
    "if @xmath122 is contracted , then it can expand and consume its flag by the next round . otherwise , consider the case when @xmath122 is expanded .",
    "if it has no children , then within the next two rounds it can contract and expand again , consuming its complaint flag ; otherwise , by lemma  [ lem : expparentchild ] , @xmath122 must have a contracted child with which it can perform a handover to become contracted in @xmath111 and then expand and consume its complaint flag by @xmath186 . in any case , @xmath51 is satisfied .",
    "no super - root in @xmath118 holds a complaint flag and not all complaint flags have been moved from follower particles to particles in layer 1 .",
    "let @xmath187 be a sequence of particles in layer 1 such that each particle holds a complaint flag , no follower child of any particle except @xmath188 holds a complaint flag , and no particles between the next super - root @xmath122 and @xmath69 hold complaint flags . then , as each @xmath189 forwards its flag to @xmath190 according to definition  [ defn : complaintparallelschedule ] , the follower child of @xmath188 holding a flag is able to forward its flag to @xmath188 , satisfying @xmath52 .",
    "no super - root in @xmath118 holds a complaint flag and all remaining complaint flags are held by particles in layer 1 . by definition  [ defn : complaintparallelschedule ] , since no preference needs to be given to flags entering layer 1 , all remaining flags will move one position closer to a super - root in each round , satisfying @xmath184 .",
    "we use lemma  [ lem : progresslayer1 ] to show first that layer @xmath156 will be filled with particles ( some possibly still expanded ) in @xmath174 rounds . from that point on , in another",
    "@xmath174 rounds , one can guarantee that expanded particles in layer @xmath156 will each contract in a handover with a follower particle , and hence all particles in layer @xmath156 will be contracted , as we see in the following lemma :    [ lemma : filled ] after @xmath174 rounds , layer 1 must be filled with contracted particles .",
    "we first prove the following claim :    after @xmath191 rounds of @xmath141 , layer @xmath156 must be filled with particles .",
    "suppose to the contrary that after @xmath192 rounds , layer 1 is not completely filled with particles .",
    "then none of these rounds could have satisfied @xmath185 of lemma  [ lem : progresslayer1 ] , so one of @xmath193 , or @xmath184 must be satisfied every two rounds .",
    "case @xmath51 can be satisfied at most @xmath194 times ( accounting for at most @xmath195 rounds ) , since a super - root expands into an unoccupied position of layer 1 each time a complaint flag is consumed .",
    "case @xmath184 can also be satisfied at most @xmath194 times ( accounting for at most @xmath195 rounds ) , since once all remaining complaint flags are in layer 1 , every flag must reach a super - root in @xmath194 moves .",
    "thus , the remaining @xmath196 rounds must satisfy @xmath52 @xmath197 times , implying that @xmath197 flags reached particles in layer 1 from follower children .",
    "but each particle can hold at most one complaint flag , so at least @xmath198 flags must have been consumed and the super - roots have collectively expanded into at least @xmath198 unoccupied positions , a contradiction .    by the claim , it will take at most @xmath191 rounds until layer @xmath156 is completely filled with particles ( some possibly expanded ) . in at",
    "most another @xmath194 rounds , every expanded particle in layer @xmath156 will contract in a handover with a follower particle ( since @xmath199 ) , and hence all particles in layer @xmath156 will be contracted after @xmath200 rounds .    once layer @xmath156 is filled , the leader election primitive can proceed .",
    "the full description of the universal coating algorithm in  @xcite uses a node - based version of the leader election algorithm in  @xcite for this primitive . for consistency",
    ", we kept this description of the primitive in this paper as well .",
    "however , in order to formally prove with high probability guarantees on the runtime of our universal coating algorithm , we use a monte carlo variant of the leader election algorithm in  @xcite .",
    "a description of this variant and its corresponding proofs appear in  @xcite .",
    "this updated algorithm elects a leader with high probability and gives the following runtime bound .",
    "[ lem : leaderelection ] within @xmath174 further rounds , a position of layer 1 has been elected as the leader position , w.h.p .    once a leader position has been elected and either no more followers exist ( if @xmath201 ) or all positions are completely filled by contracted particles ( which can be checked in an additional @xmath202 rounds ) , the particle currently occupying the leader position becomes the leader particle . once a leader has emerged , the particles on layer @xmath156 retire , which takes @xmath202 further rounds .",
    "together , we get :    [ cor : layer1 ] the worst - case number of rounds for @xmath169 to complete layer @xmath156 is @xmath174 , w.h.p .",
    "we again use the dominance results we proved in section  [ sec : parallel ] to focus on parallel schedules when proving an upper bound on the worst - case number of rounds  denoted by @xmath203  for building layer @xmath27 once layer @xmath35 is complete , for @xmath204 .",
    "the following lemma provides a more general result which we can use for this purpose .",
    "[ lem : tree - time ] consider any greedy forest  path schedule @xmath171 with @xmath205 and any @xmath89 such that @xmath206 .",
    "if every expanded parent in @xmath117 has at least one contracted child , then in at most @xmath207 configurations , nodes @xmath208 will be occupied by contracted particles .",
    "let @xmath122 be the super - root closest to @xmath209 , and suppose @xmath122 initially occupies node @xmath210 in @xmath117 .",
    "additionally , suppose there are at least @xmath89 active particles in @xmath117 ( otherwise , we do not have sufficient particles to occupy @xmath89 nodes of @xmath80 ) .",
    "argue by induction on @xmath89 , the number of nodes in @xmath80 starting with @xmath209 which must be occupied by contracted particles .",
    "first suppose that @xmath211 .",
    "by lemma  [ lem : expparentchild ] , every expanded parent has at least one contracted child in any configuration @xmath212 , so @xmath122 is always able to either expand forward into an unoccupied node of @xmath80 if it is contracted or contract as part of a handover with one of its children if it is expanded .",
    "thus , in at most @xmath213 configurations , @xmath122 has moved forward @xmath214 positions , is contracted , and occupies its final position @xmath215 .",
    "now suppose that @xmath216 and that each node @xmath217 , for @xmath218 , becomes occupied by a contracted particle in at most @xmath219 configurations .",
    "it suffices to show that @xmath220 also becomes occupied by a contracted particle in at most two additional configurations .",
    "let @xmath5 be the particle currently occupying @xmath220 ( such a particle must exist since we supposed we had sufficient particles to occupy @xmath89 nodes and @xmath141 ensures the particles follow this unique path ) . if @xmath5 is contracted in @xmath221 , then it remains contracted and occupying @xmath220 , so we are done . otherwise , if @xmath5 is expanded , it has a contracted child @xmath6 by lemma  [ lem : expparentchild ] .",
    "particles @xmath5 and @xmath6 thus perform a handover in which @xmath5 contracts to occupy only @xmath220 at @xmath222 , proving the claim .    for convenience , we introduce some additional notation .",
    "let @xmath223 denote the number of particles of the system that will not belong to layers 1 through @xmath35 , i.e. , @xmath224 , and let @xmath225 ( resp .",
    ", @xmath226 ) be the round ( resp . ,",
    "configuration ) in which layer @xmath27 becomes complete .",
    "when coating some layer @xmath27 , each root particle either moves either @xmath227 through the nodes in layer @xmath27 in the set direction @xmath228 ( cw or ccw ) for layer @xmath27 , or @xmath229 through the nodes in layer @xmath230 in the opposite direction over the already retired particles in layer @xmath27 until it finds an empty position in layer @xmath27 .",
    "we bound the worst - case scenario for these two movements independently in order to get a an upper bound on @xmath203 .",
    "let @xmath231 be the path of nodes in layer @xmath27 listed in the order that they appear from the marker position @xmath232 following direction @xmath228 , and let @xmath233 be the greedy forest  path schedule where @xmath234 is a section of @xmath169 . by lemma  [ lem : tree - time ] , it would take @xmath235 rounds for all @xmath227 movements to complete ; an analogous argument shows that all @xmath229 movements complete in @xmath236 rounds .",
    "this implies the following lemma :    [ lem : layeri2 ] starting from configuration @xmath237 , the worst - case additional number of rounds for layer @xmath27 to become complete is @xmath235 .",
    "putting it all together , for layers @xmath238 through @xmath103 :    [ cor : higherlayers ] the worst - case number of rounds for @xmath169 to coat layers 2 through @xmath103 is @xmath174 .",
    "starting from configuration @xmath239 , it follows from lemma  [ lem : layeri2 ] that the worst - case number of rounds for @xmath169 to reach a legal coating of the object is upper bounded by @xmath240 where @xmath1 is a constant .",
    "combining corollaries  [ cor : layer1 ] and  [ cor : higherlayers ] , we get that @xmath169 requires @xmath174 rounds w.h.p .  to coat any given valid object @xmath14 starting from any valid initial configuration of the set of particles @xmath13 . by lemmas  [ lem : forestdom ] and  [ lem : flagforestdom ]",
    ", the worst - case behavior of @xmath169 is an upper bound for the runtime of our universal coating algorithm , so we conclude :    [ thm : chain ] the total number of asynchronous rounds required for the universal coating algorithm to reach a legal coating configuration , starting from an arbitrary valid instance @xmath12 , is @xmath174 w.h.p . , where @xmath0 is the number of particles in the system .",
    "in this section we present a brief simulation - based analysis of our algorithm which shows that in practice our algorithm exhibits a better than linear average competitive ratio .",
    "since @xmath77 ( as defined in section  [ sec : performance ] ) is difficult to compute in general , we investigate the competitiveness with the help of an appropriate lower bound for @xmath77 .",
    "recall the definitions of the distances @xmath241 and @xmath242 for @xmath243 and @xmath25 .",
    "consider any valid instance @xmath12 .",
    "let @xmath244 be the set of all legal particle positions of @xmath12 ; that is , @xmath244 contains all sets @xmath25 such that the positions in @xmath245 constitute a coating of the object @xmath14 by the particles in the system .",
    "we compute a lower bound on @xmath77 as follows .",
    "consider any @xmath246 , and let @xmath247 denote the complete bipartite graph on partitions @xmath13 and @xmath245 .",
    "for each edge @xmath248 , set the cost of the edge to @xmath249 .",
    "every perfect matching in @xmath247 corresponds to an assignment of the particles to positions in the coating .",
    "the maximum edge weight in a matching corresponds to the maximum distance a particle has to travel in order to take its place in the coating .",
    "let @xmath250 be the set of all perfect matchings in @xmath247 .",
    "we define the _ matching dilation _ of @xmath12 as @xmath251 since each particle has to move to some position in @xmath245 for some @xmath246 to solve the coating problem , we have @xmath252 .",
    "the search for the matching that minimizes the maximum edge cost for a given @xmath246 can be realized efficiently by reducing it to a flow problem using edges up to a maximum cost of @xmath75 and performing binary search on @xmath75 to find the minimal @xmath75 such that a perfect matching exists .",
    "we note that our lower bound is not tight .",
    "this is due to the fact that it only respects the distances that particles have to move but ignores the congestion that may arise , i.e. , in certain instances the distances to the object might be very small , but all particles may have to traverse one `` chokepoint '' and thus block each other .",
    "[ fig : simresults ]    we implemented the universal coating algorithm in the amoebot simulator ( see @xcite for videos ) . for simplicity",
    ", each simulation is initialized with the object @xmath14 as a regular hexagon of object particles ; this is reasonable since the particles need only know where their immediate neighbors in the object s border are relative to themselves , which can be determined independently of the shape of the border . the particle system @xmath13 is initialized as idle particles attached randomly around the hexagon s perimeter .",
    "the parameters that were varied between instances are the radius of the hexagon and the number of ( initially idle ) particles in @xmath13 .",
    "each experimental trial randomly generates a new initial configuration of the system .",
    "figure  [ fig : simresults](a ) shows the number of rounds needed to complete the coating with respect to the hexagon object radius and the number of particles in the system .",
    "the number of rounds plotted are averages over 20 instances of a given @xmath253 with 95% confidence intervals .",
    "these results show that , in practice , the number of rounds required increases linearly with particle system size .",
    "this agrees with our expectations , since leader election depends only on the length of the object s surface while layering depends on the total number of particles . figure  [ fig : simresults](b ) shows the ratio of the number of rounds to the matching dilation of the system .",
    "these results indicate that , in experiment , the average competitive ratio of our algorithm may exhibit closer to logarithmic behaviors .",
    "figure  [ fig : simresults](c ) shows the number of rounds needed to complete the coating as the radius of the hexagon object is varied .",
    "the runtime of the algorithm appears to increase linearly with both the number of active particles and the size of the object being coated , and there is visibly increased runtime variability for systems with larger radii .",
    "this paper continued the study of universal coating in self - organizing particle systems .",
    "the runtime analysis shows that our universal coating algorithm , presented in  @xcite , terminates in a linear number of rounds , so it is worst - case optimal .",
    "this , along with the linear lower bound on the competitive gap between local and global algorithms , further shows our algorithm to be competitively optimal .",
    "furthermore , the simulation results show the competitive ratio of our algorithm is better than linear in practice . in the future",
    ", we would like to apply the algorithm and analysis to the case of bridging , in which particles create structures across gaps between disconnected objects .",
    "we would also like to extend the algorithm to have self - stabilization capabilities , so that it could successfully complete coating without human intervention after occasional particle failure or outside interference ."
  ],
  "abstract_text": [
    "<S> imagine coating buildings and bridges with smart particles ( also coined smart paint ) that monitor structural integrity and sense and report on traffic and wind loads , leading to technology that could do such inspection jobs faster and cheaper and increase safety at the same time . in this paper </S>",
    "<S> , we study the problem of uniformly coating objects of arbitrary shape in the context of _ self - organizing programmable matter _ , i.e. , the programmable matter consists of simple computational elements called particles that can establish and release bonds and can actively move in a self - organized way . </S>",
    "<S> particles are anonymous , have constant - size memory and utilize only local interactions in order to coat an object . </S>",
    "<S> we continue the study of our universal coating algorithm by focusing on its runtime analysis , showing that our algorithm terminates within a _ linear number of rounds _ with high probability . </S>",
    "<S> we also present a matching linear lower bound that holds with high probability . </S>",
    "<S> we use this lower bound to show a _ linear lower bound on the competitive gap _ between fully local coating algorithms and coating algorithms that rely on global information , which implies that our algorithm is also optimal in a competitive sense . </S>",
    "<S> simulation results show that the competitive ratio of our algorithm may be better than linear in practice . </S>"
  ]
}