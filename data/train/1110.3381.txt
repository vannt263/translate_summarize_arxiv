{
  "article_text": [
    "consider an input text string @xmath0 $ ] and the set @xmath20 of its suffixes @xmath21 $ ] ( @xmath22 ) under the lexicographic order , where @xmath23 $ ] is an endmarker symbol @xmath24 smaller than any other symbol in @xmath2 .",
    "the alphabet @xmath25 from which the symbols in @xmath2 are drawn is unbounded : as is standard in stringology , we assume that any two symbols in @xmath25 can only be compared and this takes @xmath26 time . hence , comparing symbolwise any two suffixes in  @xmath20 may require @xmath27 time in the worst case .",
    "we study _ partial computation _ problems in data compression and text indexing for @xmath2 where we want to quickly get a sense of the lexicographic distribution of the text suffixes .",
    "[ [ partial - data - compression . ] ] partial data compression .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    the burrows - wheeler transform @xmath28 ( a.k.a .",
    "bwt ) @xcite of text string  @xmath2 is at the heart of the ` bzip2 ` family of text compressors , and has many applications . the @xmath29th symbol in @xmath28 is @xmath30 $ ] if and only if @xmath31 is the @xmath29th suffix in the sorting ( except the borderline case @xmath32 , for which we take @xmath23 $ ] ) .",
    "there are now efficient methods that convert @xmath2 to @xmath28 and vice versa , taking @xmath33 time for unbounded alphabets in the worst case .",
    "a partial compression problem is to consider a range @xmath34 $ ] of @xmath35 consecutive symbols in  @xmath28 .",
    "can we compute @xmath36 efficiently ?",
    "more precisely , can we compute @xmath36 without computing the entire @xmath28 ?",
    "this is an interesting building block for partial estimation of data compression ratio .",
    "there is prior work that studies partial compression problems where a range @xmath37 $ ] needs to be compressed ( by lempel - ziv or burrows - wheeler or one of the other compression methods ) .",
    "this can be accomplished in @xmath38 time using off - the - shelf tools . instead ,",
    "what is interesting in our question above is that we seek a range in the _ compressed _ string @xmath28 , and computing @xmath39 $ ] amounts to sorting a set of irregular , arbitrarily scattered suffixes @xmath40 for which we do not know the positions @xmath41 _ a priori _ !",
    "[ [ partial - text - indexing . ] ] partial text indexing .",
    "+ + + + + + + + + + + + + + + + + + + + + +    several text indexes , such as suffix arrays  @xcite and suffix trees  @xcite , are based on the lexicographic order of the suffixes in the text @xmath2 and the longest common prefix ( _ lcp _ ) information among them .",
    "these can be computed in @xmath4 time using well - known algorithms that exploit properties of suffixes , time solution since 70 s for constant - size alphabet  @xmath25  @xcite and , more recently , for ( bounded universe ) integer alphabet  @xmath25  @xcite ; otherwise , it uses @xmath42 comparisons in unbounded alphabets  @xmath25 . ] while the rest of the indexes can be easily built in @xmath27 time .",
    "we define a _",
    "@xmath35-partial text index _ as a range @xmath43 $ ] of the index ( consecutive entries of the suffix array or leaves from the suffix tree ) : this corresponds to a sorted set of irregularly scattered suffixes @xmath44 for which we do not know their positions @xmath45 _ a priori _ , together with the length of their longest common prefix ( _ lcp _ ) .",
    "the technical challenge here is similar to partial compression above , but additionally , we need to compute ( _ lcp _ ) information .",
    "we refer the reader to sections  [ sub : partial - data - compression : full ] and  [ sub : partial - text - indexing : full ] for a more detailed discussion .",
    "[ [ basic - questions . ] ] basic questions .",
    "+ + + + + + + + + + + + + + + + +    can _ partial suffix - based _ computations like compression and indexing above , be solved more efficiently than solving the _ total _ problems ? besides the inherent interest in such problems and their structure that will let us parameterize their complexity in terms of @xmath46 $ ]",
    ", the main applied interest is that these partial problems give us a way to look at spots of a long string and get a sense for the complexity of data , be it for compressibility or performance of a full - text index .",
    "the central technical challenge is the following . given @xmath35 symbols , sorting them",
    "is trivial .",
    "however , if we have to sort @xmath35 arbitrary suffixes , they are of size @xmath5 in the worst case , and we can not afford to compare them symbolwise . in the worst case , it is better to perform a total sorting in @xmath33 time when @xmath47 , as the suffixes overlap in arbitrary ways and we have to avoid rescanning the symbols repeatedly .",
    "can we better this @xmath33 bound ?    [ [ our - results . ] ] our results .",
    "+ + + + + + + + + + + + +    we introduce a new adaptive approach to suffix sorting and order statistics .",
    "[ the : bwt2 ] [ the : bwt2:full ] [ the : index2:full ] given a text @xmath2 of length @xmath48 , partial compression and partial text indexing problems can be solved in @xmath49 time .",
    "hence for @xmath8 , partial compressing and text indexing problems can be solved asymptotically faster than their total counterparts . in particular , for @xmath50 , these partial problems can be solved in @xmath27 time , which is quite rare in the comparison model .",
    "we can also provide a bound for an arbitrary choice of @xmath35 ranks @xmath9 in the suffix order .",
    "[ the : bwt1 ] [ the : bwt1:full ] [ the : index1:full ] given a text @xmath2 of length @xmath48 , partial compression and indexing can be solved using @xmath51 time and comparisons , where @xmath15 , @xmath16 , and @xmath17 for @xmath18 ; here , @xmath52 are the ranks of the suffixes involved in the output .",
    "the algorithms behind theorem  [ the : bwt2 ] use an intermediate stage before applying the algorithms behind the more general theorem  [ the : bwt1 ] , as otherwise the cost would be @xmath53 by choosing consecutive ranks @xmath9 from the given range of values ( i.e. @xmath54 for @xmath55 ) .",
    "the above partial - computation problems share a common bottleneck : the _ suffix multi - selection _ problem , which is to output the suffixes of rank @xmath9 under the lexicographic order , where @xmath10 , @xmath11 $ ] .",
    "special cases of this problem are well known : @xmath12 is the standard suffix sorting problem , and @xmath13 is the recently studied suffix selection for which @xmath27-time comparison - based solutions are now known  @xcite .",
    "we refer the reader to section  [ sec : our - problem : full ] for a more detailed discussion .",
    "[ theo : main ] [ theo : main : full ] given a text @xmath2 of length @xmath48 , the @xmath35 text suffixes with ranks @xmath56 ( and the _ lcp _ s between consecutive suffixes ) can be found within the bound stated in equation  .",
    "this is optimal .",
    "[ [ related - work . ] ] related work .",
    "+ + + + + + + + + + + + +    a long running theme in string matching has been matching for suffixes of a string , what one can do for atomic elements .",
    "the earliest suffix tree algorithms of 70 s  @xcite were interesting because they sort suffixes of a string over constant - sized alphabet in @xmath27 time , matching the bucket sorting bound for @xmath48 elements .",
    "however , it took lot longer to match the @xmath27 time of radix sorting for strings over an integer alphabet in 90 s  @xcite , and in other computing models  @xcite . for selection , the classic @xmath27 time bound for atomic elements from 70 s",
    "was matched only recently for string suffix selection  @xcite .",
    "similarly , it has been a technical challenge as we show here to match the multi - selection bound of atomic elements for string suffixes .",
    "multi - selection for suffixes is not only interesting for reasons multi - selection problem in general is interesting , i.e. , for statistical analysis of string suffixes , but also because it emerges naturally as the computational bottleneck of several problems like the partial compression and indexing problems described above , which have no natural counterpart in study of atomic elements .",
    "for the sake of completeness , we recall that multi - selection of atomic elements includes basic problems such as sorting ( @xmath12 ) and selection ( @xmath13 ) as special cases @xcite .",
    "selection algorithms that work in expected linear time  @xcite or worst - case linear time  @xcite are now in textbooks .",
    "multi - selection can also model intermediate problems between sorting and selection : for example , setting equally spaced @xmath57 s , it corresponds to the quantile problem in statistics .",
    "the asymptotically optimal number of comparison ( and running time ) is that in equation   as proved in  @xcite . )",
    "can be refined by studying the actual constant factors hidden in the @xmath58  notation @xcite .",
    "several papers have studied other variations @xcite . ]",
    "our suffix multi - selection algorithm is optimal , matching the lower bound even for atomic elements !    [ [ paper - organization . ] ] paper organization .",
    "+ + + + + + + + + + + + + + + + + + +    we first give more details on partial data compression , partial text indexing and suffix multiselection in section  [ sec : our - applications : full ] , so as to relate the former two problems to the latter one .",
    "then , the rest of the paper is devoted to suffix multi - selection ( theorem  [ theo : main : full ] ) with the following organization .",
    "we give the main ideas in and introduce the main concepts of subproblems and agglomerates , their data structures and algorithms , in section  [ sec : def ] .",
    "the top - level description of our multi - selection of suffixes is given in section  [ sec : algorithm ] , and then all the implementation details are given in section  [ sec : details - optimal - algorithm ] .",
    "finally , we focus on the correctness and the analysis of the costs in sections  [ sec : correctness - analysis ] and  [ sec : proofs ]",
    "we discuss here some of the new features that make the multi - selection problem on suffixes interesting and challenging , and focus on its applications to data compression and text indexing .",
    "to evaluate the benefits of our findings , we present some examples illustrating which tasks can be done optimally with known techniques and which can not . at the same time we show that using our novel techniques , we can now perform optimally the latter tasks , which only had suboptimal algorithms so far .    .bwt",
    "@xmath28 for the text @xmath59 and its relation with the sorted suffixes .",
    "[ cols=\"^,^,^,^ , < \" , ]      the burrows - wheeler transform ( bwt ) @xcite is at the heart of the ` bzip2 ` family of text compressors . consider all the @xmath48 circular shifts of the text @xmath60 as shown in the first column ( _ original _ ) of table  [ tab : bwt : full ] .",
    "perform a lexicographic sorting of these shifts , as shown in the second column ( _ sorted _ ) : if we single out the last symbol from each of the circular shifts in this order , we obtain a sequence @xmath28 of @xmath48 symbols that is called the bwt of @xmath2 .",
    "interestingly , not only we can recover @xmath2 from @xmath28 alone , but typically @xmath28 is more compressible than @xmath2 itself using 0th - order compressors ( e.g.  @xcite ) .",
    "its relation with suffix sorting is well known : the @xmath29th symbol in @xmath28 is @xmath30 $ ] if and only if @xmath31 is the @xmath29th suffix in the sorting ( except the borderline case @xmath32 , for which we take @xmath23 $ ] ) , as shown in the third column ( _ suffixes _ ) .",
    "data compression ratio can be partially estimated by choosing a suitable sample @xmath36 of @xmath28 for statistical purposes .",
    "there are several ways to make this choice , some are easy and some others are not , as we show next .",
    "it is easy to build @xmath36 if we take every other @xmath61th suffix in @xmath2 .",
    "for example , @xmath62 gives @xmath63 since we pick @xmath64 and then perform their lexicographic sorting , namely , @xmath65 .",
    "the latter is a simple variant of the standard suffix sorting and takes @xmath66 time : the text @xmath2 is conceptually partitioned as a sequence of @xmath67 macro - symbols , where each macro - symbol is a segment of @xmath61 actual symbols in @xmath2 ( could be less in the last one ) .",
    "suffix sorting requires @xmath68 macro - comparison , each involving @xmath61 symbolwise comparisons , thus giving the above bound .    what if @xmath36 is chosen by taking every other @xmath61th symbol _ directly _ in @xmath28 ?",
    "contrarily to the previous situation , here we guarantee a uniform sampling from @xmath28 .",
    "for example , @xmath62 gives @xmath69 , which corresponds to selecting the suffixes @xmath70 as shown in boldface in table  [ tab : bwt : full ] .",
    "here comes a crucial observation : even though we sample from @xmath28 with regularity , the starting positions of the chosen suffixes from the input text @xmath2 form an _ irregular _ pattern and are difficult to predict without suffix sorting .",
    "we are not aware of any better approach other than performing a full execution of suffix sorting and , then , making a post - processing to single out every other @xmath61th sorted item .",
    "this yields a suboptimal cost of @xmath33 which should be compared to the @xmath71 cost in equation   by setting @xmath72 for @xmath73 and @xmath74 .",
    "in general , specifying ranks @xmath9 gives the sample made up of the @xmath75th , @xmath76th ,  ",
    ", @xmath77th symbols of @xmath28 : using the algorithm giving the cost in  , we can look at specific parts of the compressed string , without paying the full suffix sorting cost .",
    "we refer the reader to theorem  [ the : bwt1:full ] .",
    "an intriguing situation arises when we consider just a segment of @xmath35 consecutive symbols .",
    "let us first consider a text segment @xmath78 $ ] , where @xmath79 and @xmath80 .",
    "it takes @xmath81 time to perform a suffix sorting and compute the bwt of that segment alone ; or @xmath49 time to sort the consecutive suffixes @xmath82 whose starting positions lie in that segment , and then find their induced symbols inside @xmath28 .",
    "once again , these are simple variations of suffix sorting .",
    "what if we want to compute only a segment @xmath83 $ ] of @xmath79 consecutive symbols instead of the whole @xmath28 ?",
    "for example , @xmath84 = { \\ensuremath{\\mathtt{s}}}{\\ensuremath{\\mathtt{s}}}{\\ensuremath{\\mathtt{m}}}$ ] corresponds to suffixes @xmath85 in table  [ tab : bwt : full ] .",
    "in general , the starting positions of these suffixes form an irregular pattern and , as far as we know , the best that we can do is performing a _ full _ suffix sorting in @xmath86 time . instead ,",
    "setting @xmath87 , we obtain that @xmath88 , @xmath89 , and @xmath54 for @xmath90 . hence , the cost implied by equation   is @xmath91 , and the computed longest common prefixes in theorem  [ theo : main : full ] will also provide the contexts for estimating the empirical entropy of  @xmath28 restricted to the segment @xmath83 $ ] .",
    "even better , we can obtain @xmath49 using the same algorithm behind equation   and an analysis focussed on this special case ( i.e. the wanted ranks form an interval of consecutive values , see lemma  [ lem : multisel : contiguous : full ] ) . when @xmath92 , this compares favorably with the suboptimal @xmath33 cost of building  @xmath28 explicitly .",
    "we refer the reader to theorem  [ the : bwt2:full ] .",
    "several text indexes , such as suffix arrays  @xcite and suffix trees  @xcite , are based on the lexicographic order of the suffixes in the text @xmath2 and the longest common prefix ( _ lcp _ ) information among them . ultimately , the suffix sorting and the _ lcp _ information constitute the kernel upon which the rest of the index can be easily built in @xmath27 time .",
    "an instance of suffix tree for the text @xmath60 is shown in figure  [ fig : sampled : full](left ) , and consists of a compacted trie storing all the suffixes of @xmath2 .",
    "based on the above observation , we define a _ @xmath35-partial text index _ as a subset of @xmath35 suffixes plus their _ lcp _ information . having this",
    ", we can build the suffix array or the suffix tree restricted to these @xmath35 suffixes in @xmath93 time .",
    "hence , the problem of building a @xmath35-partial text index tantamounts to performing a sorting of these @xmath35 suffixes and finding their _ lcp _ information .",
    "we discuss two ways of choosing these @xmath35 suffixes .",
    "one possibility is sampling every other @xmath61th _ suffix _ in @xmath2 , as shown in figure  [ fig : sampled : full](center ) with @xmath62 .",
    "this is the _ sampled _ suffix tree introduced in @xcite , and its construction is a simple variant of the standard one and takes @xmath94 time : as previously mentioned , the text @xmath2 is conceptually partitioned as a sequence of @xmath95 macro - symbols .",
    "another possibility is sampling every other @xmath61th _ leaf _ directly from the suffix tree , as shown in figure  [ fig : sampled : full](right ) with @xmath62 .",
    "however , with the current techniques we have a suboptimal solution : build first the whole suffix tree in @xmath33 time and then perform a post - processing to select the wanted leaves and their ancestors ( removing the possible unary nodes thus created ) . using the algorithm behind equation   and the related longest common prefix information as a byproduct , we are able to build this @xmath35-partial index in @xmath71 time by fixing @xmath72 for @xmath73 and @xmath74 .",
    "contrarily to the sampled suffix tree above , here the starting positions of the chosen suffixes form an _ irregular _ pattern even though we sample from the suffix tree with regularity .    in general , given a text @xmath2 and its ranks @xmath9",
    ", we want to build the @xmath35-partial text index for the suffixes having those ranks .",
    "for example , when employing a suffix tree , the @xmath35-partial text index gives the subtrie made up of the @xmath75th , @xmath76th ,  ",
    ", @xmath77th leaves of the suffix tree for @xmath2 .",
    "but we do not want to build that full suffix tree explictly in @xmath33 time . using the algorithm behind equation",
    ", we can attain this goal .",
    "we refer the reader to theorem  [ the : index1:full ] .",
    "a somewhat surprising situation arises when considering just a segment of @xmath35 consecutive symbols .",
    "consider first the @xmath35-partial index build on the text segment @xmath78 $ ] , where @xmath79 and @xmath96 .",
    "it takes @xmath81 time to build the suffix array or the suffix tree for that segment alone , or @xmath49 time to build them for the consecutive suffixes @xmath97 whose starting positions lie in that segment .",
    "once again , these are simple variations of known algorithms .",
    "this is not the case when computing just a segment of @xmath35 consecutive entries in the suffix array , or just a chunk of @xmath35 consecutive leaves from the suffix tree .",
    "clearly , we do not want the suboptimal solution that builds the entire suffix array or suffix tree in @xmath33 time .",
    "ours is a special case of @xmath35-partial text index , since the wanted suffixes have _ consecutive ranks _ @xmath98 .",
    "the @xmath99 cost implied by equation   can be refined ( using lemma  [ lem : multisel : contiguous : full ] ) so that we obtain @xmath49 , comparing favorably with the suboptimal cost of building the suffix array / tree entirely .",
    "in general , the task of computing only a chunk of @xmath35 consective entries from the suffix array or the suffix tree falls within the following result .",
    "we refer the reader to theorem  [ the : index2:full ] .      given a set @xmath20 of @xmath48 elements from a total order @xmath100 , the rank of @xmath101 is @xmath102 $ ] if @xmath103 is the @xmath29th smallest in  @xmath20 , namely , @xmath104 for integers @xmath10 , where each @xmath105 $ ] , the _ multi - selection _ problem is to select the elements of rank @xmath9 from @xmath20 .",
    "multi - selection includes basic problems such as sorting and selection as special cases .",
    "when @xmath12 , it finds the ranks for all the elements , making it straightforward to arrange them in sorted order @xcite .",
    "when @xmath13 , it corresponds to the standard selection problem : given an integer @xmath102 $ ] , the goal is to return the element of rank @xmath29 in  @xmath20 .",
    "selection algorithms that work in expected linear time  @xcite or worst - case linear time  @xcite are now in textbooks .",
    "it can also model intermediate problems bewteen sorting and selection : for example , setting equally spaced @xmath57 s , it corresponds to the quantile problem in statistics .",
    "multi - selection can thus arise in applications for partitioning the input , say for a recursive approach .",
    "to the best of our knowledge the first algorithm for multi - selection was given in @xcite , thus establishing that the _ asymptotically _ optimal number of comparison ( and running time ) is that in equation  , where @xmath15 and @xmath16 and @xmath106 for @xmath18 .",
    "the formula in  ( [ eq : multi - bound ] ) can be intuitively read as follows .",
    "find the @xmath107 smallest elements , then the @xmath108 next smallest elements , and so on , up to the last @xmath109 ones .",
    "the resulting arrangement is almost sorted , and can be fully sorted by ordering each individual group of @xmath110 elements independently in @xmath111 time .",
    "hence , take the total sorting cost of @xmath112 , subtract the cost of sorting each group , i.e. @xmath113 , and add @xmath114 to read all the elements as a baseline .",
    "note that rewriting  ( [ eq : multi - bound ] ) as @xmath115 , where @xmath116 , we can reformulate the bound in  ( [ eq : multi - bound ] ) as @xmath117 where @xmath118 is the empirical 0th - order entropy where @xmath119 is the empirical probability of having the @xmath120th group of size @xmath110 .",
    "the asymptotical optimality of  ( [ eq : multi - bound ] ) can be further refined by studying the actual constant factors hidden in the @xmath58 notation .",
    "any comparison - based algorithm must perform at least @xmath121 comparisons to solve multi - selection , and the algorithm in  @xcite is nearly optimal in this sense .",
    "it attains @xmath122 expected comparisons and @xmath123 comparisons in the worst case , taking @xmath124 running time . for the interested reader ,",
    "other papers have studied further features in @xcite .",
    "we focus on the asymptotically optimality of the bound in  ( [ eq : multi - bound ] ) and call _ optimal _ an algorithm that asymptotically meets that bound , namely , @xmath125 in the worst case . unless specified , the running time is always proportional to the number of pairwise comparisons between elements .    in this paper",
    ", we study the analog of the multi - selection problem in stringology .",
    "consider an input text string @xmath0 $ ] and the set @xmath20 of its suffixes @xmath21 $ ] ( @xmath22 ) under the lexicographic order .",
    "let @xmath23 $ ] be an endmarker symbol , denoted by @xmath24 , which is smaller than any other symbol in @xmath2 .",
    "the alphabet @xmath25 from which the symbols in @xmath2 are drawn is unbounded and the comparison model is adopted : any two symbols in @xmath25 can only be compared and this takes constant time .",
    "hence , comparing symbolwise any two suffixes in  @xmath20 may requires @xmath27 time in the worst case .",
    "given ranks @xmath10 , the _ suffix multi - selection _ problem is to output the suffixes of rank @xmath126 in @xmath20 .",
    "our main contribution is that we extend the asymptotically optimal bound in  ( [ eq : multi - bound ] ) to the suffixes in @xmath20 .",
    "we refer the reader to theorem  [ theo : main : full ] .",
    "recall that the length of the _ longest common prefix _ of any two suffixes @xmath127 and @xmath31 is defined as the smallest @xmath128 such that @xmath129 \\neq t[j+\\ell]$ ] .",
    "we also can obtain this info as a byproduct , which is useful for the problems mentioned in sections  [ sub : partial - data - compression : full ] and  [ sub : partial - text - indexing : full ] .",
    "for the given string @xmath0 $ ] , let @xmath23 $ ] be an endmarker symbol , denoted by @xmath24 , that is smaller than any symbol of the alphabet and does not appear elsewhere in @xmath2 .",
    "let @xmath130 $ ] be the @xmath131-th suffix of @xmath2 , and @xmath132 be the set of all these suffixes .",
    "given the set @xmath133 of ranks @xmath134 , we want to select the suffixes @xmath135 such that @xmath136 has rank @xmath137 in  @xmath20 , for @xmath138 . since we already know that @xmath139 is the smallest suffix of @xmath2 , we can assume wlog that @xmath140 . also , we use @xmath100 and @xmath141 to denote string comparison according to the lexicographical order . for any two sets @xmath142 ,",
    "notation @xmath143 indicates that @xmath144 for any pair @xmath145 .",
    "our main goal is to prove theorem  [ theo : main ] , as this is the major obstacle when proving theorems  [ the : bwt2]  [ the : bwt1 ] .",
    "the tricks of the trade all rely on the following `` golden rule '' on the _ lcp _ information for the suffixes : for any integer @xmath146 , if @xmath147 for some integer @xmath148 , then @xmath149 .",
    "thus , if @xmath127 and @xmath31 have been compared , the direct comparison of the first @xmath150 symbols of @xmath151 and @xmath152 can be avoided .",
    "conversely , if @xmath151 and @xmath152 have been compared , the comparison of all but the first @xmath153 symbols in @xmath127 and @xmath31 can be avoided .",
    "unfortunately , we can not always rely on the golden rule here . when comparing @xmath127 and  @xmath31 , we do not yet know whether or not both @xmath151 and @xmath152 will have to be compared ( directly or indirectly by transitivity ) for a choice of @xmath154 , or vice versa : simply put",
    ", we can not predict at each stage of the computation whether the comparison between @xmath151 and @xmath152 will occur or not in the future .      at the beginning , all the suffixes form a single problem @xmath155 . at the end , we want to obtain a partition of @xmath20 into _ subproblems _ , namely , @xmath156 , such that @xmath157 contains all the suffixes in @xmath20 of rank @xmath29 with @xmath158 for @xmath159 .",
    "although each @xmath157 is not internally sorted , still @xmath160 .    at an arbitrary stage of the computation ,",
    "the suffixes in @xmath20 and the ranks in @xmath133 are partitioned amongst the _ subproblems_. let us call @xmath161 the subproblems in the current stage , where @xmath162 , and let @xmath163 be the set of ranks associated with subproblem @xmath164 , for @xmath165 .",
    "namely , @xmath166 iff @xmath167 , where @xmath168 is the number of lexicographically smaller suffixes .",
    "[ [ status . ] ] status .",
    "+ + + + + + +    a subproblem @xmath164 is @xmath169 if @xmath170 , and @xmath171 if @xmath172 and @xmath173 . a subproblem @xmath164 and its suffixes are _ exhausted _ if @xmath174 . a subproblem @xmath164 and its suffixes are _ degenerate _ if each of these suffixes share an _ empty _ prefix with any of the wanted suffixes @xmath175 .",
    "( note that @xmath176 a degenerate subproblem is also exhausted and @xmath177 @xmath139 is always degenerate since we assume @xmath178 . )",
    "a subproblem @xmath164 is never merged with others and can only be refined into smaller subproblems . a partition of @xmath164 into @xmath179 is called a _ refinement _ if for any two @xmath180 either @xmath181 or @xmath182 : note that the refinement is a stronger notion than the partition , since it also takes into account of the lexicographic order among the suffixes .    during the computation",
    "a subproblem can be either _ active _ or _",
    "inactive_. if @xmath173 then @xmath164 is active . an _ active _ subproblem is subjected to the _ refinement _ , whereas this does not hold anymore once it becomes _",
    "inactive_. if @xmath164 is inactive then @xmath174 and thus it is exhausted .",
    "( the latter is a necessary condition : not all the exhausted subproblems are inactive . )",
    "once a subproblem becomes inactive it will stay inactive until the end .",
    "degenerate subproblems are inactive since the start .",
    "we give a complete characterization in section  [ subsec : agglomerates ] .",
    "[ [ integer - labels - and - neighborhood . ] ] integer labels and neighborhood .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    ideally , we would like to maintain the integer label @xmath168 for each subproblem @xmath164 during the refining process . using the integer labels , we can define a total order relation @xmath183 and an equivalence relation @xmath184 on the suffixes of @xmath2 .",
    "consider any two suffixes @xmath185 and their subproblems labels @xmath186 .",
    "we have that @xmath187 iff _ ( 1 ) _",
    "@xmath188\\le t[j']$ ] when both @xmath189 and @xmath190 are degenerate or _",
    "@xmath191 otherwise .",
    "similarly , @xmath192 iff _",
    "( 1 ) _ @xmath188=t[j']$ ] when both @xmath127 and @xmath31 are degenerate or _ ( 2 ) _",
    "@xmath193 otherwise .",
    "the total order @xmath183 is consistent with the lexicographical order : if @xmath187 and @xmath194 then @xmath195 . if the labels for two suffixes are known then comparing them according to @xmath183 and @xmath184 takes @xmath196 time .    after an active subproblem @xmath164 becomes inactive , it is possible that some of its suffixes are moved to form other inactive subproblems @xmath197 s but we still need the value of @xmath198 .",
    "for this reason , we need to introduce a more general notion , that of _ neighborhood _ @xmath199 , to preserve what was once an individual active subproblem @xmath164 . summing up : if @xmath164 is _ active _ then @xmath200 ; else , @xmath201 . in any case",
    ", the reference label is @xmath202 .    for the sake of description , each subproblem @xmath164 or neighborhood @xmath203 , and by extension each suffix in them ,",
    "is conceptually associated with an _ @xmath204-string _ @xmath205 . if @xmath164 is _ non - degenerate _ then @xmath31 has @xmath205 as prefix iff @xmath206 .",
    "if @xmath164 is _ degenerate _ , a weaker property holds since @xmath207 : for any @xmath208 not in @xmath203 , either @xmath209 or @xmath210 . observing that only the integer labels are used to compare suffixes according to @xmath183 and @xmath184 , the @xmath204-strings will not be maintained during the computation .",
    "for the presentation in the paper , we will focus on subproblems rather than neighbors , keeping in mind that the label of an inactive subproblem is that defined for its neighborhood .    [ [ rationale . ] ] rationale .",
    "+ + + + + + + + + + +    we refine the subproblems as follows .",
    "we pick an unsolved subproblem @xmath164 and refine it into smaller ones : we find the closest ranks @xmath211 for @xmath164 partitioning it `` evenly , '' namely , @xmath212 .",
    "then , we select the suffixes @xmath213 with ranks @xmath211 and partition @xmath164 into three new subproblems according to @xmath136 and @xmath214 . the new subproblem with the middle suffixes is exhausted since it has no ranks associated ( and will form @xmath215 ) , while the other two subproblems are still unsolved .",
    "the goal is to reach a situation in which each subproblem  @xmath164 is either exhausted ( @xmath216 for some @xmath120 ) or solved ( @xmath217 for rank @xmath137 and some @xmath120 ) : namely , @xmath218 is the resulting refinement of the initial problem  @xmath20 .",
    "this scheme works if we suppose that @xmath20 contains independent strings .",
    "unfortunately , @xmath20 contains the suffixes of @xmath2 and so the rescanning cost is the main obstacle .",
    "we group subproblems into agglomerates to model the interplay among suffixes that share the _ same _ @xmath204-string .",
    "we represent each agglomerate as a threaded dynamic tree where each node represents a subproblem ( a subset of suffixes ) , as illustrated in the example of fig .",
    "[ fig : big : full ] .",
    "[ [ dependency . ] ] dependency .",
    "+ + + + + + + + + + +    for any two subproblems @xmath219 , we say that @xmath164 depends directly on @xmath208 if the following hold : @xmath176 @xmath220 or @xmath177 @xmath221 and for each @xmath222 we have that @xmath223 .",
    "we extend this relation by transitivity , denoted @xmath224 , which is a partial order .",
    "when @xmath225 we say that @xmath164 _ depends on _ @xmath208 . we extend this terminology to single suffixes : a suffix @xmath226",
    "_ depends on _ @xmath227 ( denoted by @xmath228 ) if @xmath229 , @xmath230 and @xmath231 , for @xmath232 .",
    "[ [ partial - order - and - tree - representation . ] ] partial order and tree representation .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a set of subproblems is an _ agglomerate _",
    "@xmath233 if there exists @xmath234 such that @xmath235 , for each @xmath236 ( i.e. @xmath233 has a maximum according to the partial order @xmath224 ) .",
    "the hasse diagram according to @xmath224 for an agglomerate @xmath233 is a tree whose root is the _ maximum _ subproblem and the leaves are the _ minimal _ subproblems of @xmath233 .",
    "moreover , the children of an internal node are subproblems directly depending on it ( see fig .",
    "[ fig : big : full ] ) .",
    "we denote by @xmath237 the number of subproblems in @xmath233 , and apply tree terminology to agglomerates .",
    "a suffix @xmath238 ( @xmath239 ) is a _ contact suffix _ if @xmath240 and @xmath241 .",
    "a subproblem @xmath234 is a _ contact subproblem _ if it contains at least one contact suffix .",
    "each leaf of @xmath233 is a contact node .",
    "also , some internal nodes may be contact ones .",
    "when we consider the contact nodes in preorder ( see grey nodes in fig .",
    "[ fig : big : full ] ) , we call this the _ contact visiting order_. contacts nodes are useful for the refinement .",
    "[ [ status.-1 ] ] status .",
    "+ + + + + + +    an agglomerate @xmath233 is _ exhausted _ if all its subproblems are either exhausted or solved .",
    "an unsolved subproblem of an agglomerate @xmath233 is a _ leading subproblem _ if none of its ancestors in @xmath233 are unsolved .",
    "an agglomerate @xmath233 is _ unsolved _ if the following holds :    [ prop : leading - subproblem ] there exists a leading subproblem @xmath242 in  @xmath233 s.t .",
    "+ @xmath176  each ancestor of @xmath242 has only one child , and @xmath177  none of the ancestors of @xmath242 is a contact node .    note that property  [ prop : leading - subproblem].@xmath176 implies that an unsolved agglomerate has only one leading subproblem . at any time , a subproblem @xmath234 is _ active _ iff @xmath233 is unsolved and either @xmath176 @xmath164 is unsolved or @xmath177 @xmath164 is not solved and is a contact node of @xmath233 ( in this case @xmath164 can be exhausted but still active ) . for any agglomerate @xmath233 and two active subproblems @xmath243 ,",
    "the following properties hold : @xmath244  @xmath245 and  @xmath246 have a non - void common suffix ; @xmath247  if @xmath164 is a descendant of @xmath208 in @xmath233 then @xmath246 is a proper suffix of @xmath245 .",
    "[ [ columns . ] ] columns .",
    "+ + + + + + + +    the agglomerates induce columns : a _ column _ @xmath248 of @xmath233 is the pair @xmath249 such that @xmath250 where @xmath251 is a contact suffix ( i.e. it belongs to one of @xmath233 s contact nodes ) and @xmath252 is a root suffix of @xmath233 ( i.e. it belongs to @xmath233 s root ) . each column @xmath253 $ ] is a contiguous substring of @xmath2 and , at any time , all the columns of all the agglomerates form a non - overlapping partition of  @xmath2 . a column @xmath249 is associated with the contact subproblem @xmath208 such that @xmath254 .",
    "we will denote by @xmath255 the number of columns associated with a contact subproblem @xmath208 . in fig .",
    "[ fig : big : full ] , each agglomerate has its columns depicted beside its tree .",
    "the columns are shown as contiguous substrings of @xmath2 ( and @xmath2 as a non - overlapping partitioning of the columns ) .",
    "for any agglomerate @xmath233 , the number of its root suffixes , the number of its contact suffixes , the number of its columns and , if @xmath233 is unsolved , the number of suffixes in its leading subproblem are all the same : we denote this quantity by  @xmath256 .    [ [ data - structures . ] ] data structures .",
    "+ + + + + + + + + + + + + + + +    the algorithmic challenge behind agglomerates is that the total cost of refining each individual subproblem could be prohibitive : there is a hidden rescanning cost that we must avoid . as we will describe late , the refining algorithm will pick an unsolved agglomerate @xmath233 , and process it by refining _",
    "simultaneously _ all of its subproblems according to the ranks of its leading subproblem @xmath242 . this is a non - trivial task .",
    "for example , to achieve optimality ( section  [ sec : correctness - analysis ] ) the refinement of @xmath233 must be executed in time proportional to the number @xmath257 ( i.e @xmath256 ) of suffixes in @xmath242 plus the number of newly created subproblems , whereas @xmath233 can contain many more subproblems and suffixes .",
    "the main structure for an agglomerate @xmath233 is its hasse diagram according to @xmath224 , which is a tree with @xmath237 nodes , each one representing a subproblem of @xmath233 .",
    "double links between children and parent are maintained .",
    "if @xmath233 is unsolved , we also maintain @xmath244  a pointer to its leading subproblem @xmath242 and @xmath247  the number of nodes in the path between @xmath233 s root and @xmath242 .",
    "only @xmath258 suffixes are stored for @xmath233 , i.e. its @xmath256 columns .",
    "they are divided into lists , one for each contact subproblem of @xmath233 : the one for @xmath208 contains all the @xmath255 columns @xmath249 such that @xmath254 ( see fig .  [",
    "fig : big : full ] ) .",
    "we call _ skip node _ one that is a branching node ( i.e. one with two or more children ) or a contact node or the root of @xmath233 ( the conditions are not mutually exclusive ) . for each skip",
    "node @xmath208 we maintain a _",
    "skip link _ which is a double link between @xmath208 and its lowest ancestor that is also a skip node . clearly , the graph induced by the skip links is also a tree .",
    "we refer to it as @xmath233 s _ skip tree_. for each internal skip node @xmath208 and each child @xmath259 of @xmath208 in the skip tree , we maintain a _ guide link _ that goes from @xmath208 to the highest node of @xmath233 that is @xmath176 _ unsolved _ and @xmath177 both a descendant of @xmath208 and an ancestor of @xmath259 ( if any such node exists ) .",
    "the skip tree of @xmath233 with its guide links requires @xmath260 space .    besides the pointers needed by the linked structures containing it , each subproblem @xmath164 carries @xmath196 words of information : @xmath244 its integer label @xmath198 , @xmath247 @xmath261 and , when @xmath164 is a contact node , the following additional information : @xmath262 @xmath263 @xmath264 a pointer to the list of its columns and @xmath265 a pointer to the root of @xmath233 . for a generic subproblem @xmath164 , we do not explicitly maintain ( e.g. in a list associated with @xmath164 ) either its suffixes or its ranks in @xmath163 .",
    "the space required to store an agglomerate @xmath233 is just @xmath266 memory words .",
    "we also maintain some _ global _ bookkeeping structures that are shared among the agglomerates .",
    "@xmath244  for each contact or root suffix @xmath127 , a pointer",
    "@xmath267 $ ] to the subproblem to which it belongs .",
    "@xmath247  a sorted linked list @xmath268 of all the subproblems . @xmath262  an array @xmath269 to find the nearest rank in @xmath133 in constant time , so that the set of ranks @xmath163 of any unsolved subproblem @xmath164 can be retrieved in @xmath270 time .      before describing the general refining scheme in section  [ sec :",
    "algorithm ] , we discuss some useful operations that operate on agglomerates .",
    "the slice operation takes in input an agglomerate @xmath233 and assumes that each column @xmath271 of @xmath233 has been tagged with an integer in @xmath272 , for some @xmath273 .",
    "for any suffix @xmath127 of a subproblem in @xmath233 , let us denote by @xmath274 the tag of the column @xmath271 to which it belongs ( @xmath275 ) .",
    "slice@xmath276 obtains the following _ without _ changing the columns of @xmath233 :    each subproblem @xmath277 is partitioned ( not necessarily this gives a refinement ) into new subproblems @xmath278 , where @xmath279 and all the suffixes @xmath280 have the same tag @xmath274 , for each @xmath281 ( after the partitioning @xmath282 ceases to exist ) . if all the suffixes of some @xmath277 already have the same tag , @xmath282 remains unmodified .",
    "all the subproblems in @xmath233 , both the new ones and the unmodified ones , are distributed into new agglomerates @xmath283 such that , for each @xmath284 and for each suffix @xmath285 , we have that @xmath286 .",
    "hence @xmath287 , with @xmath288 newly created subproblems .",
    "[ lem : slice : comp ] slicing @xmath233 into @xmath283 takes @xmath289 time .    the _ join operation _",
    "join@xmath290 is much simpler .",
    "an agglomerate @xmath291 is _ joinable _ with @xmath233 if there exists a contact subproblem @xmath277 such that , for each suffix @xmath127 of the root subproblem @xmath292 of @xmath291 , it is @xmath293 .",
    "hence @xmath294 is an agglomerate and , by joining with @xmath233 , we have that @xmath291 disappears and only @xmath233 remains ( their trees are fused with @xmath292 child of @xmath282 ) , thus some columns are _",
    "[ lem : join : comp ] if @xmath291 is joinable with @xmath233 then the join operation requires @xmath295 time .    during the computation we may need to combine the above two operations .",
    "let agglomerates @xmath233 and @xmath296 be unsolved and exhausted , respectively .",
    "also let us assume that @xmath233 is joinable with @xmath296 and let @xmath297 be @xmath233 s root .",
    "the slicejoin@xmath298 operation does the following : @xmath176 it slices @xmath296 into @xmath299 and @xmath300 , where @xmath271 is a column of @xmath299 iff @xmath301 ; @xmath177 it joins @xmath233 with @xmath299 .",
    "[ lem : slicejoin : comp ] slicejoin@xmath298 requires @xmath302 time .",
    "[ [ initialization - stage . ] ] initialization stage .",
    "+ + + + + + + + + + + + + + + + + + + + +    we begin by initializing the bookkeeping data structures described in section  [ subsec : agglomerates ] .",
    "then , let mselmset be an optimal multi - selection algorithm for a _ multiset _ of items , thus generalizing the result in @xcite to multisets ( see section  [ subsec : mselmset : algo : full ] ) .",
    "we call mselmset@xmath303,\\ldots , t[n]\\right\\}},\\mathcal{r}\\right)$ ] using the alphabet order : this refines the suffixes in @xmath20 according to their first symbols into the pivotal multisets @xmath304 , @xmath305,@xmath306 ,   , @xmath307 , @xmath308 .",
    "each @xmath309 forms a degenerate subproblem @xmath164 since no ranks fall within it , whereas each @xmath310 forms either a solved or unsolved subproblem @xmath208 .",
    "the agglomerates are initialized as singletons : each @xmath282 forms an agglomerate @xmath311 that is either exhausted ( i.e. @xmath282 is either solved or exhausted ) or unsolved ( i.e. it satisfies property  [ prop : leading - subproblem ] ) .",
    "each @xmath311 is moved into one of the groups @xmath312 and @xmath313 , which will be used in the rest of the computation .",
    "[ [ refinement - stage . ] ] refinement stage .",
    "+ + + + + + + + + + + + + + + + +    we proceed with the _ refine and aggregate stage_. we execute a loop until the group @xmath312 is empty . in each iteration of the loop",
    "we pick an agglomerate from @xmath312 and we apply to it the _ refine and aggregate process _ , shortly rap , described in section  [ subsec : rap ] . during each rap",
    ", some _ temporary agglomerates _ will be created and they may not fulfill the characterization given in section  [ subsec : agglomerates ] .",
    "thus , any agglomerate created during a rap is to be considered as _ temporary _ until it disappears ( since it is joined with another ) or it is moved into either one of the global groups @xmath312 and @xmath313 , at the end of rap .    [",
    "[ finalization - stage . ] ] finalization stage .",
    "+ + + + + + + + + + + + + + + + + + +    once @xmath312 is empty , we run a finalization stage that returns the @xmath35 wanted suffixes @xmath175 by suitably scanning @xmath268 .",
    "[ [ first - step - establishing - which - kind - of - agglomerate . ] ] first step : establishing which kind of agglomerate .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the first kind is when @xmath233 is _ core cyclic _ : there is one contact subproblem @xmath314 , called the _ core _ of @xmath233 , such that @xmath244  there exists at least one column @xmath271 of @xmath233 with @xmath315 , and @xmath247  for each column @xmath249 of @xmath233 , either @xmath316 or @xmath317 . for example , consider fig .",
    "[ fig : big : full ] , where @xmath318 is core cyclic with core @xmath319 : the only two columns @xmath249 of @xmath320 with @xmath321 are @xmath322 and @xmath323 , while the others have @xmath324 .",
    "the columns in the core @xmath325 are all _ equal _ and _ consecutive _ inside  @xmath2 .",
    "the second kind is when @xmath233 is _ generic _",
    "( i.e. not core cyclic ) as illustrated by the example in fig .",
    "[ fig : big : full ] : agglomerate @xmath326 is generic and `` acyclic '' , as each column @xmath249 of @xmath326 has @xmath327 ; instead , agglomerate @xmath328 is generic and `` cyclic '' , as @xmath329 and @xmath330 have @xmath331 and @xmath332 .",
    "more formally , a generic and `` acyclic '' agglomerate  @xmath233 has each of its columns @xmath249 with @xmath333 ; a generic and `` cyclic '' agglomerate  @xmath233 is one where there exist columns @xmath271 and @xmath334 such that @xmath335 and @xmath336 but @xmath337 .",
    "note that cyclic agglomerates of the second kind are treated differently from those of the first kind .",
    "[ [ second - step - building - the - keys - for - the - agglomerate . ] ] second step : building the keys for the agglomerate .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we assign a _",
    "key _ to each column of agglomerate @xmath233 .",
    "if @xmath233 is core cyclic ( i.e. first kind ) , the key for each column @xmath338 is as follows .",
    "let @xmath339 be the maximal sequence of ( equal ) columns of @xmath233 such that @xmath340 .",
    "the key for @xmath338 is the sequence @xmath341 .",
    "if @xmath233 is generic ( i.e. second kind , acyclic or not ) , each column @xmath338 simply gets @xmath342 as key .",
    "what about individual suffixes ?",
    "the key of each @xmath127 is _ implicitly _ the same as that assigned to _ its _",
    "column @xmath271 , where @xmath275 .",
    "however , unlike the columns of @xmath233 , we do not access each suffix of @xmath233 to actually assign it its key , which is retrieved on the fly only when needed . recall that at any time the total order @xmath183 and the equivalence relation @xmath184 are defined on the suffixes ( section  [ subsec : subproblems ] ) .",
    "hence , any two keys can be compared in @xmath196 , since these suffixes are either contact or root , so we can use to retrieve their labels : if @xmath233 is core cyclic , its key becomes @xmath343 for labels @xmath198 ( repeated @xmath344 times for @xmath345 , @xmath346 ,   , @xmath347 ) and @xmath348 ( for @xmath349 ) ; if @xmath233 is generic , its key becomes a single label ( for @xmath342 ) .",
    "[ [ third - step - multi - selection - on - the - leading - subproblem - seen - as - a - multiset . ] ] third step : multi - selection on the leading subproblem seen as a multiset .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we retrieve the ranks @xmath350 of the leading subproblem @xmath242 of @xmath233 , using ( section  [ subsec : agglomerates ] ) .",
    "we also retrieve all the suffixes of @xmath242 ( not explicitly stored for @xmath242 ) and their keys computed in the second step , in @xmath351 time . then , we call mselmset@xmath352 , where the ranks are @xmath353 for the label @xmath354 of @xmath242 , and the order among keys is the one given by @xmath183 and @xmath184 . let the resulting pivotal multisets be @xmath355 , where @xmath356 contains the suffixes that are candidates for some ranks and @xmath357 .",
    "we assign _ tags _ to the columns in  @xmath233 that are consistent with the order among these pivotal multisets , so that suffixes in the same multiset receive the same tag .",
    "( this is useful for the refinement in the next step . ) for each @xmath358 , let @xmath359 be the number of @xmath360 with @xmath361 ( some of the @xmath362 s may be empty ) .",
    "we use them to tag each column @xmath248 of @xmath233 : the tag is @xmath363 if the suffix of @xmath242 that corresponds to @xmath248 belongs to @xmath364 ; the tag is @xmath365 if that suffix belongs to @xmath310 , or @xmath366 if that suffix belongs to @xmath362 , for some @xmath367 .",
    "[ [ fourth - step - slicing - the - agglomerate . ] ] fourth step : slicing the agglomerate .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we perform the slicing of @xmath233 ( section  [ subsec : agg : oper ] ) using the @xmath153 tags computed in the third step .",
    "we call slice@xmath276 and obtain agglomerates @xmath283 , where the columns in each @xmath368 have the same tag and , for @xmath369 , the tag of @xmath368 is different from that of @xmath370 .",
    "then @xmath283 are moved into four groups : the two global ones previously mentioned , @xmath313 and @xmath312 , and two local ones for temporary agglomerates , called @xmath371 and @xmath372 , according to the following rule for the given @xmath368 , where @xmath373 :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath374  ` if ` @xmath368 s tag corresponds to a multiset @xmath362 ( see the third step ) , move it to @xmath371 ; + @xmath374  ` else ` @xmath368 s tag corresponds to a multiset @xmath310 : + @xmath375  ` if ` @xmath376 , move @xmath368 to @xmath313 ; + @xmath375  ` else if ` @xmath233 was generic and there is a column @xmath249 of @xmath368 with @xmath377 , + move @xmath368 to @xmath312 ( since @xmath368 satisfies property  [ prop : leading - subproblem ] ) ; + @xmath375  ` else ` move @xmath368 to @xmath372 . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    this step has a subtle point , since it implicitly induces the refinement of many subproblems simultaneously without paying the rescanning cost .",
    "not only the leading subproblem @xmath242 is refined into its pivotal multisets using its ranks in @xmath378 , but each active subproblem @xmath164 of @xmath233 is refined as well .",
    "however , the refinement of @xmath379 could be coarser than what obtained by refining @xmath164 directly using its ranks in @xmath163 : indeed , as pointed out in section  [ subsec : agglomerates ] , the @xmath204-string @xmath380 is a proper suffix of @xmath245 , the @xmath204-string of @xmath164 ( descendant of @xmath242 ) . but",
    "@xmath164 s induced refinement is for free since the cost is charged to @xmath242 , and any subsequent refinement for @xmath164 will surely create new subproblems , for which we can pay ( see what claimed for data structures in section  [ subsec : agglomerates ] and lemma  [ lem : slice : comp ] ) .    [",
    "[ fifth - step - processing - textttundecided_g . ] ] fifth step : processing @xmath371 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the group @xmath371 collects the temporary agglomerates @xmath368 s for which there are no ranks from @xmath378 falling within @xmath368 .",
    "however , there could be other ranks in @xmath381 that could involve @xmath368 .",
    "hence , @xmath176  @xmath368 may or may not contain unsolved subproblems , and @xmath177  even if @xmath368 contains unsolved subproblems , it may not satisfy property  [ prop : leading - subproblem ] .",
    "( here we may create a neighborhood from a subproblem of @xmath368 as discussed in section  [ subsec : subproblems ] . ) for each @xmath368 in @xmath371 , we retrieve the topmost unsolved subproblems @xmath382 from @xmath368 in preorder , in @xmath383 time using its skip tree ( section  [ subsec : agglomerates ] ) .",
    "since no ancestor of @xmath384 is unsolved , we assign tag @xmath385 to its columns , @xmath386 .",
    "we assign tag @xmath387 to the remaining columns of @xmath368 , which are not associated with any @xmath384 .",
    "we call slice@xmath388 with these @xmath387 tags : for @xmath389 , we create a new agglomerate @xmath390 with leading subproblem @xmath391 and put it into @xmath312 .",
    "we create a new agglomerate @xmath392 , exhausted by construction , and put it into @xmath313 .",
    "[ [ sixth - step - processing - textttjoinable_g . ] ] sixth step : processing @xmath372 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    this step represents the `` aggregate '' part of rap . for each agglomerate @xmath368 in @xmath372 , let @xmath393 be the agglomerate with which @xmath368 is joinable ( section  [ subsec : agg : oper ] ) .",
    "note that @xmath393 is either in @xmath312 or @xmath313 ( but not in @xmath372 , see the fourth step ) .",
    "if @xmath393 is in @xmath312 , or if @xmath394 , we call join@xmath395 and move the resulting agglomerate in @xmath312 . in this way , we maintain property  [ prop : leading - subproblem ] : if @xmath393 is unsolved , then it satisfies the property ; if @xmath393 is exhausted , the leading subproblem of @xmath368 is also viable for the agglomerate obtained from join@xmath395 ( since @xmath394 ) .",
    "if @xmath393 is in @xmath313 and @xmath396 : we call slicejoin@xmath395 producing @xmath397 and @xmath398 .",
    "we move @xmath397 to @xmath312 as it satisfies property  [ prop : leading - subproblem ] .",
    "we move @xmath398 to @xmath313 : since @xmath393 was exhausted , it did not have a leading subproblem and @xmath368 s leading subproblem is not viable for the resulting @xmath398 ( since @xmath396 , at least one of the conditions of property  [ prop : leading - subproblem ] is violated ) .",
    "consider the multi - selection problem on _ multisets _ of elements that are comparable in @xmath196 time .",
    "the multi - selection algorithm in @xcite does not exploit the presence of equal elements .",
    "let us describe our variant . given a multiset @xmath399 and @xmath35 ranks @xmath400 , we want to partition @xmath399 into its _ pivotal multisets _",
    "@xmath355 such that the following holds :    for any @xmath401 , for any @xmath402 , we have that @xmath403 ; moreover , for any @xmath404 , we have that @xmath405 .",
    "the elements in @xmath406 are equal and @xmath407 is the multiplicity of @xmath408 .    for each rank",
    "@xmath57 there exists a @xmath356 such that each @xmath409 in @xmath356 has rank @xmath57 .    for each @xmath356 there",
    "exists a rank @xmath57 such that each @xmath409 in @xmath356 has rank @xmath57 .",
    "notice that @xmath410 and @xmath411 whereas there may be some @xmath412 .",
    "let us now describe our algorithm .",
    "1 .   mselmset@xmath413 2 .   if @xmath414 exit .",
    "if @xmath13 select and output the element of rank @xmath75 .",
    "3 .   find the largest @xmath415 . then select the element @xmath416 ( @xmath417 ) with rank @xmath418 ( @xmath419 ) and all the elements of @xmath399 that are equal to @xmath416 ( @xmath417 ) .",
    "[ alg : mm : step : part : full ] partition @xmath399 into @xmath420 such that @xmath244 @xmath421 ( @xmath422 ) contains all the elements in @xmath399 equal to @xmath416 ( @xmath417 ) and @xmath247 for any @xmath423 we have that @xmath424 .",
    "5 .   find the largest @xmath425 .",
    "call mselmset@xmath426 .",
    "let @xmath427 .",
    "find the smallest @xmath428 s.t .",
    "@xmath429 . +",
    "call mselmset@xmath430 .    the complexity of mselmset can be expressed in terms of the sizes of the pivotal multisets of @xmath399 w.r.t .",
    "@xmath431 . for the sake of description",
    ", we will assume that @xmath432 .",
    "[ lem : multisel : multiset : full ] the running time of the algorithm mselmset on a multiset @xmath399 is upper bounded by @xmath433 for a suitable integer constant @xmath434 .    from step  [ alg : mm :",
    "step : part : full ] and because of the choice of @xmath416 and @xmath417 , it is clear that @xmath421,@xmath435 and @xmath422 are three of the pivotal multisets .",
    "let @xmath421 and @xmath435 be @xmath436 and @xmath437 , respectively ( thus @xmath422 is @xmath438 ) .",
    "also , the algorithm never breaks any pivotal multiset and the partitioning of the input elements for the recursive calls is also a partitioning of the ( yet unknown ) pivotal multisets .",
    "all the non - recursive steps of the algorithm require @xmath439 time , for a suitable integer constant @xmath434 .",
    "therefore we have that the running time is upper bounded by the function @xmath440 . to prove the upper bound for @xmath441 we use the function @xmath442 .",
    "let us show that @xmath443 .",
    "since the algorithm does not break @xmath399 s pivotal multisets , we know that the pivotal multisets of @xmath444 and @xmath445 are @xmath446 and @xmath447 , respectively . hence , by induction , we have that @xmath448 @xmath449 @xmath450 thus , by the definition of @xmath441 , the relation between @xmath344 and @xmath441 is proven .",
    "all we have to do now is to prove that @xmath451 , and the wanted upper bound for @xmath441 will follow by subtraction . by the definition of @xmath421",
    "we know that both @xmath452 and @xmath453 are less than @xmath454 .",
    "thus , by induction we have the following : @xmath455 .      [",
    "[ first ] ] _ first : _ + + + + + + + +    for each agglomerate @xmath368 in @xmath371 , we find its highest ( i.e. closest to the tree root of @xmath368 ) unsolved subproblems ( if any ) and we collect them in @xmath456 .",
    "since visiting the whole tree of @xmath368 would cost too much ( @xmath457 time ) , we use @xmath368 s skip tree and its guide links . in this way",
    "the visit takes @xmath458 time . specifically , we use two other lists @xmath459 and @xmath460 ( initially empty ) besides @xmath456 , starting from the root with procedure leadvisit@xmath461 defined as follows for a generic subproblem @xmath297 :    1 .",
    "if @xmath297 is unsolved , we append @xmath297 , @xmath462 and @xmath463 at the end of @xmath456 , @xmath460 and @xmath459 , respectively , and return . 2 .",
    "otherwise , if @xmath297 is a contact node , we append @xmath464 and @xmath465 to @xmath460 and @xmath459 , respectively ( but we do not return yet ) .",
    "3 .   for each child @xmath466 of @xmath297 ( in @xmath368 s skip tree ) , from the leftmost to the rightmost one , we do the following .",
    "if @xmath297 has a guide link to an ancestor @xmath467 of @xmath466 , we append @xmath467 , @xmath462 and @xmath468 at the end of @xmath456 , @xmath460 and @xmath459 , respectively , and return . otherwise , if no such guide link exists , we call leadvisit@xmath469 ) .",
    "[ [ second ] ] _ second : _",
    "+ + + + + + + + +    for each agglomerate @xmath368 in @xmath371 , we tag its columns so that we are able to either @xmath244  classify @xmath368 as unsolved or exhausted or @xmath247  partition @xmath368 into some smaller unsolved or exhausted agglomerates .",
    "basically , a column @xmath248 of @xmath368 has the tag @xmath470 , @xmath471 , if the subtree rooted at the node @xmath208 in position @xmath470 in @xmath456 contains the contact node with which @xmath248 is associated .",
    "otherwise , if no such node exists in @xmath456 , @xmath248 has the tag @xmath472 . specifically , we compute the ( inclusive ) prefix sum @xmath473 of @xmath459 and set @xmath474=0 $ ] .",
    "we scan the columns of @xmath368 in contact visiting order ( i.e. by using the preorder of the contact nodes in @xmath368 ) .",
    "let us consider the @xmath120-th one of them and let @xmath470 , @xmath475 , be the index such that @xmath476 < j\\le{\\texttt{scon}}_{i}[l]$ ] .",
    "the @xmath120-th column is tagged with @xmath470 ( @xmath472 ) if @xmath477=1 $ ] ( @xmath478 ) .",
    "[ [ third ] ] _ third : _ + + + + + + + +    for each agglomerate @xmath368 in @xmath371 , we perform the slicing with the above tags .",
    "let @xmath479 .",
    "if the tags of @xmath368 are all equal to some @xmath470 s.t .",
    "@xmath480 ( to @xmath481 ) , we move @xmath368 to @xmath312 ( to @xmath313 ) and the step ends . otherwise , we call slice@xmath388 obtaining @xmath482 and , possibly , @xmath483 , where @xmath484 is the agglomerate whose columns have @xmath470 as tag , for each @xmath485 .",
    "the node in position @xmath470 of @xmath456 is the leading subproblem of @xmath484 , for each @xmath480 . finally , we move @xmath483 to @xmath313 , and all the other @xmath486 s to @xmath312 .    to understand why the above computation is correct ,",
    "let us describe some properties of the tagging done .",
    "for any suffix @xmath31 , let us denote with @xmath487 the tag of the column @xmath338 such that @xmath488 .",
    "if a subproblem @xmath297 of @xmath368 is _ unsolved _ then the following holds : @xmath244 @xmath489 , for any two @xmath490 and @xmath247 @xmath491 .    on the other hand ,",
    "if for a subproblem @xmath297 of @xmath368 we have that conditions @xmath244 and @xmath247 hold , then on the path from @xmath297 to the root there has to be at least one _ unsolved subproblem _ whose suffixes have the same tag @xmath492 as @xmath297 s ( maybe only @xmath297 itself , if it is unsolved ) .",
    "also , the highest unsolved subproblem on said path must be the one in position @xmath493 in @xmath456 .",
    "given the definition of slice in section  [ subsec : agg : oper ] , the correctness follows .      as we have seen in section  [ subsec : agg : oper ] , the slice operation receives in input an agglomerate @xmath233 whose columns have been tagged with integers in @xmath272 , where @xmath273 .",
    "note that there should be at least two columns with different tags , since otherwise we do not need to run the slicing .    during the slice operation we deal with instances of the following _ grouping problem _ : we are given a list @xmath28 of objects , each with an integer tag in @xmath494",
    "( where the tags of the columns are @xmath153 but during parts of the slicing we will need an extra tag for special purposes ) .",
    "we want to partition @xmath28 into @xmath495 lists @xmath496 such that an object @xmath497 iff @xmath498 s tag is @xmath120 , for each @xmath499 .",
    "note that the order in which the lists @xmath496 are produced does not necessarily have to follow the order of the tags .",
    "also , the problem is easy if @xmath500 since it falls within the radix sort scheme . in our case",
    ", we can spend @xmath501 preprocessing time and space beforehand : after that , for each instance @xmath28 of the grouping problem , we assume that @xmath502 , and we can not pay @xmath501 time but just @xmath503 time .    the procedure group solves the above problem as follows . between one call and the other",
    ", it reuses the same array @xmath504 of @xmath505 slots that is allocated at the beginning of the slice operation and is never reset from one call to another .",
    "each slot @xmath506 $ ] has two fields : @xmath506.p$ ] , a list pointer , and @xmath506.t$ ] , an integer .",
    "let @xmath507 be an integer timestamp unique for each call ( since we can just maintain an increasing integer throughout all the calls to group ) .",
    "while we scan @xmath28 , we build a list @xmath36 of lists and then return it .",
    "let @xmath434 be the tag of the current object @xmath498 . during the scan we have two cases : @xmath176 if @xmath508.t\\not=\\eta$ ] , we set @xmath508.t=\\eta$ ] and start a new list @xmath509 with @xmath498 as first element ; also , we append @xmath509 to @xmath36 and set @xmath508.p$ ] to point to @xmath510 ; @xmath177 if @xmath508.t=\\eta$ ] , we append @xmath498 to the list pointed by @xmath508.p$ ] .",
    "[ lem : grouping : full ] after @xmath501 preprocessing time and space , each call to the procedure group requires @xmath511 time .    at this point",
    ", we can describe slice@xmath276 , which has three main phases : pruning , slicing , and finishing .",
    "the goal is to identify some relevant nodes in the tree reprensenting the agglomerate  @xmath233 .",
    "speficically , a node @xmath234 is _ homogeneous _ if all the columns associated with all the contact nodes in the subtree rooted at @xmath164 have the same tag .",
    "we want to find the set @xmath512 of the _ highest _",
    "( i.e. closest to the root ) _ homogeneous nodes _ of @xmath233 and tag each one of them _ with the common tag of their columns_. let us recall ( lemma  [ lem : slice : comp ] ) that we need an implementation of slice with a time complexity that is of the order of the number of columns of @xmath233 plus the total number of the new subproblems created .",
    "hence , we can not touch all the homogeneous nodes of @xmath233 since they will not be refined into new subproblems at this stage .",
    "if we are able to find the set @xmath512 efficiently then , later on , each subtree of @xmath233 rooted at a node in @xmath512 will be just linked to the corresponding new agglomerate without accessing any of its internal nodes .",
    "the pruning phase proceeds with the following steps .",
    "[ [ first-1 ] ] _ first : _",
    "+ + + + + + + +    we traverse _ the skip tree of @xmath233 _ level by level from the bottom one .",
    "* for each @xmath513 at the lowest level we do the following .",
    "@xmath176 since @xmath513 is a contact node ( and a leaf ) , we call group on its ( tagged ) column list .",
    "@xmath177 then we tag @xmath513 with @xmath434 ( resp .",
    ", with @xmath505 ) if from group we get only one list @xmath510 ( resp . , we get more than one list ) .",
    "* for each @xmath164 at a generic level ( different from the lowest ) we do the following .",
    "@xmath176 if @xmath164 is a leaf , we perform the same steps as we did at the lowest level .",
    "@xmath177 otherwise , if @xmath164 is an internal node , we call group on the list of objects , where each object is one of @xmath164 s children ( and their tags ) ; if @xmath164 is also a contact node , we add more objects to the list , where each object is one of @xmath164 s columns ( which already have tags ) .",
    "@xmath514 then we tag @xmath164 as we did at the lowest level .",
    "[ [ second-1 ] ] _ second : _",
    "+ + + + + + + + +    we traverse @xmath233 s _ skip tree _ with the following recursive skipvisit@xmath461 , starting from the root .",
    "skipvisit@xmath515 is defined for a node @xmath164 in the skip tree as follows : @xmath176 if @xmath164 s tag is @xmath516 , we output a pointer to @xmath164 and return ; @xmath177 otherwise , if the tag is @xmath505 we call skipvisit@xmath517 , for each child ( in the skip tree ) @xmath197 of @xmath164 .",
    "[ [ third-1 ] ] _ third : _ + + + + + + + +    we are ready to retrieve and mark the nodes to be added to @xmath512 .",
    "( note that the root @xmath297 can not belong to @xmath512 . ) for each node @xmath164 outputted in the previous step , we proceed as follows :    we retrieve @xmath164 s parent in the skip tree @xmath208 .",
    "if @xmath164 is the @xmath103-th child of @xmath208 in the skip tree of @xmath233 , we find @xmath208 s @xmath103-th child in the tree of @xmath233 , say @xmath518 : note that @xmath164 is a descendant of @xmath518 in the tree of @xmath233 ( they could be even the same node in some cases )",
    ". then we mark @xmath518 ( since we add it to @xmath519 ) and tag it with @xmath164 s tag .",
    "if @xmath164 and @xmath518 are not the same node , we do the following .",
    "@xmath244 we create a _ temporary skip link _ between them ( for the next phase  the slicing phase ) .",
    "@xmath247 let @xmath520 be the ancestor node of @xmath164 pointed by the corresponding guide link of @xmath208 ( if any ) .",
    "for the sake of clarity , observe that traversing the tree of @xmath233 from its root to @xmath164 , we meet @xmath208 , @xmath518 , @xmath520 , and @xmath164 .",
    "we create a _ temporary guide link _ between @xmath518 and @xmath520 ( they may be the same node in some cases ) .    [ [ fourth ] ] _ fourth : _",
    "+ + + + + + + + +    let @xmath521 be the set of nodes of @xmath233 that are not in a subtree rooted at a node belonging to @xmath512 .",
    "we assign to each @xmath522 a _ fingerprint _ that is a unique integer from @xmath523 ( any choice would do , for example the dfs numbering ) .",
    "[ lem : pruning - phase : full ] the pruning phase requires @xmath289 time .",
    "the goal is to actually slice the agglomerate @xmath233 into the agglomerates defined by the columns tags , as claimed in lemma  [ lem : slice : comp ] , with some provisions .",
    "indeed , the only missing things to complete this task are the following : @xmath244  the link between each contact node and the root ; @xmath247  the contact node list ; @xmath262  the correct labels and the correct ordering in @xmath268 for the new subproblems created ; @xmath264  the guide links of skip nodes that are not descendant of any node in @xmath512 . we will deal with these things in the next phase  the finishing phase .    we invoke the recursive procedure slicerec@xmath524 on the root of @xmath233 . a generic call slicerec@xmath461 , where @xmath297 indcates now a generic node in  @xmath233 , has three cases .",
    "[ [ mathcalp_r - is - a - leaf . ] ] @xmath525 is a leaf . + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    first , we call group on @xmath297 s column list and obtain @xmath495 lists @xmath526 . by scanning each @xmath527",
    "we obtain @xmath244 all the distinct tags @xmath528 and @xmath247 @xmath529 where @xmath530 is the number of columns in list @xmath527 .",
    "second , we create @xmath531 new subproblems @xmath532 and insert them into in place of @xmath297 .",
    "if @xmath297 was @xmath233 s leading subproblem , we set @xmath532 to be leading subproblems of their respective agglomerates ( they might not actually be , see section  [ sub : undecided - details : full ] ) . for each @xmath533 : @xmath244 we set @xmath534 s tag and fingerprint to @xmath535 and @xmath297 s fingerprint , respectively ; @xmath247 we set @xmath536 , @xmath534 s column list pointer and @xmath537 to @xmath530 , @xmath527 and @xmath538 , respectively .",
    "finally , we eliminate @xmath297 and return @xmath539 .",
    "[ [ mathcalp_r - is - a - contact - node - but - not - a - leaf . ] ] @xmath525 is a contact node but not a leaf .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    if @xmath540 , we return it immediately ( it has been tagged in the previous phase  the pruning phase ) .",
    "otherwise we proceed as follows .",
    "first , we call slicerec@xmath541 , for each child @xmath534 of @xmath297 . from each call",
    "slicerec@xmath541 we receive a set @xmath542 of root nodes .",
    "we call group on the list with the objects in @xmath543 , where @xmath544 contains @xmath297 s columns .",
    "this produces @xmath495 lists @xmath526 . by scanning the lists ,",
    "we obtain @xmath244 all the distinct tags @xmath528 and @xmath247 pairs @xmath545 , where lists @xmath546 and @xmath547 contain all the columns and all the nodes in @xmath527 , respectively ( some of them may be empty ) .",
    "then by scanning each @xmath548 and @xmath549 we obtain @xmath262 @xmath529 , where @xmath530 is the number of columns in @xmath548 , and @xmath264 @xmath550 , where @xmath551 is the total number of suffixes in each subproblem in list @xmath547 .",
    "second , we create @xmath531 new subproblems @xmath532 and insert them in in place of @xmath297 . if @xmath297 was @xmath233 s leading subproblem , we set @xmath532 to be leading subproblems of their respective agglomerates ( same as the above case when @xmath297 is a leaf ) . for each @xmath533 : @xmath244 we set @xmath534 s tag and fingerprint to @xmath535 and @xmath297 s fingerprint , respectively ; @xmath247 we set @xmath536 , @xmath534 column list pointer ( in case @xmath534 is a new contact node ) and @xmath537 to @xmath552 , @xmath548 and @xmath538 , respectively ; @xmath262 we make the nodes in @xmath549 be @xmath534 s children .",
    "third , for each @xmath534 and each child @xmath553 of @xmath534 we do as follows .",
    "if @xmath534 is not a skip node but its only child @xmath553 _ is _ , we create a temporary link between them .",
    "if neither @xmath534 nor @xmath553 is a skip node , we redirect to @xmath534 the ( only ) temporary link that goes into @xmath553 .",
    "if @xmath534 is a skip node and @xmath553 _ is not _ , we redirect to @xmath534 the temporary link that goes into @xmath553 , and we change it into a skip link .",
    "if _ both _ @xmath534 and @xmath553 are skip nodes , we create a skip link between them .",
    "after that , we eliminate @xmath297 and return @xmath539 .",
    "[ [ mathcalp_r - is - not - a - contact - node . ] ] @xmath525 is not a contact node .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    this case is analogous to the previous one , only simpler , because @xmath297 is not a contact node and no new contact nodes can be created from it .    [",
    "lem : slicing - phase : full ] the slicing phase requires @xmath289 time .      the finishing phase adds the missing information from the previous phase  the slicing phase .",
    "it proceeds with the following steps .",
    "[ [ first-2 ] ] _ first : _ + + + + + + + +    we sort _ all _ the new subproblems @xmath208 s according the keys @xmath554 , where @xmath555 and @xmath556 are @xmath208 s fingerprint and tag , respectively .",
    "since each @xmath554 has @xmath557 bits , we can use radix sort .",
    "[ [ second-2 ] ] _ second : _",
    "+ + + + + + + + +    after the sorting , for each old _ active _ subproblem @xmath164 , we have that new subproblems @xmath558 are grouped together _ and _ in their correct relative order .",
    "hence , we can reattach them in @xmath268 in the correct order and also set the correct label @xmath559 for each one of them . if @xmath164 was inactive , we leave @xmath558 and their labels as they are .",
    "[ [ third-2 ] ] _ third : _",
    "+ + + + + + + +    for each new agglomerate @xmath368 we build its contact node list by visiting its skip tree .",
    "then we scan its contact node list and for each contact node we set the link to @xmath368 s root .",
    "[ [ fourth-1 ] ] _ fourth : _",
    "+ + + + + + + + +    for each new agglomerate @xmath368 we need to create the guide links for the skip nodes of @xmath368 that are not descendants of the nodes in @xmath512 . to that end , we call guidevisit@xmath515 , defined as follows , on @xmath368 s root .    for each child @xmath197 of @xmath164 in @xmath233 s",
    "_ skip tree _ , we scan the nodes @xmath560 of @xmath233 s _ tree _ that are both _ descendants of @xmath164 _ and _ ancestors of @xmath197 _ starting from the highest one .",
    "we keep scanning them until we find a @xmath560 that falls into one of three cases : @xmath244 it is unsolved , @xmath247 it is in @xmath512 or @xmath262 it is @xmath197 . in case",
    "@xmath244 we create a guide link between @xmath164 and @xmath560 . in case @xmath247",
    "if @xmath560 has a temporary guide link ( possibly created in the pruning phase ) to a node @xmath520 , we create a guide link between @xmath164 and @xmath520 . otherwise no guide link is created .",
    "we call guidevisit@xmath517 , for each child @xmath197 of @xmath164 in @xmath233 s _ skip tree_.    [ lem : finishing - phase : full ] the finishing phase requires @xmath289 time .      given an agglomerate @xmath291 that is joinable to @xmath233",
    ", we need to attach the root of @xmath291 to a suitable place in @xmath233 .",
    "let @xmath561 be the contact subproblem such that @xmath562 , for each suffix @xmath127 of the root subproblem @xmath292 of @xmath291 . the operation join@xmath290 ( see section  [ subsec : agg : oper ] ) proceeds with the following steps .",
    "[ [ first-3 ] ] _ first : _ + + + + + + + +    we fuse the trees of @xmath233 and @xmath291 by making @xmath292",
    "be the new leftmost children of @xmath282 .",
    "[ [ second-3 ] ] _ second : _ + + + + + + + + +    let @xmath28 and @xmath36 be the contact node lists of @xmath233 and @xmath291 , respectively .",
    "let @xmath563 and @xmath564 be the predecessor and successor of @xmath282 in @xmath28 , respectively .",
    "let @xmath565 and @xmath566 be the leftmost and the rightmost node in @xmath36 , respectively . if after the fusion @xmath282 is not ( is still ) a contact node , we link @xmath563 ( @xmath282 ) to @xmath565 and @xmath566 to @xmath564 .",
    "[ [ third-3 ] ] _ third : _",
    "+ + + + + + + +    let us define @xmath520 as follows : @xmath176 if @xmath282 is still a skip node after the fusion ( it may not be a contact node anymore ) , then @xmath520 is @xmath282 ; @xmath177 otherwise @xmath520 is the ancestor of @xmath282 pointed by its skip link .",
    "if @xmath292 is a contact or branching node , we create a skip link between @xmath520 and @xmath292 .",
    "otherwise @xmath292 is not a skip node of the final agglomerate .",
    "hence , the only skip link from a node in @xmath291 to @xmath292 is redirected to @xmath520 .",
    "we do the same with the only guide link of @xmath292 .",
    "[ [ fourth-2 ] ] _ fourth : _ + + + + + + + + +    each column @xmath567 of @xmath291",
    "is changed into @xmath568 where @xmath271 is the column of @xmath233 associated with @xmath282 such that @xmath569 .",
    "the column @xmath271 is deleted since @xmath570 is not a contact suffix anymore .",
    "[ [ fifth ] ] _ fifth : _ + + + + + + + +    we set the root pointer of each contact node of @xmath291 to @xmath233 s root .    since the total number of skip links , columns and contact nodes of @xmath291 and deleted pairs of @xmath233 is @xmath295 , lemma  [ lem :",
    "join : comp ] is proven .",
    "let us now describe the slicejoin@xmath298 operation used in the last step of rap and whose effect has been described in section  [ subsec : agg : oper ] .",
    "let @xmath233 and @xmath296 be unsolved and exhausted , respectively , and let us assume that @xmath233 is joinable with @xmath296 .",
    "let @xmath282 be the contact node of @xmath296 such that @xmath562 , for each suffix @xmath127 of the root subproblem @xmath297 of @xmath233 .",
    "for the slicing part of slicejoin , we _ do not _ explicitly tag @xmath296 s columns but , conceptually , we would have the following : @xmath176 only two tags ( @xmath462 and @xmath571 ) for the columns ; @xmath177 @xmath282 is the only contact subproblem of @xmath296 with some columns with tag @xmath462 , and all the other columns with tag @xmath571 . because of that , we know that the only subproblems of @xmath296 that are partitioned during the slicing part of slicejoin are @xmath282 and its ancestors . thus , we do not need the pruning phase of slice because @xmath282 is the only non - homogeneous node .",
    "the slicing phase is the same as in slice except for two things .",
    "first , the recursion does not touch any node that is not on the path from the root of @xmath296 to @xmath282 ( since they are implicitly in @xmath512 ) .",
    "second , when we treat @xmath282 ( which is a contact node ) we do not touch its column list at all , we just create the two subproblems @xmath572 and @xmath573 , and we link _ the whole column list _ of @xmath282 to @xmath573 ( which will be part of @xmath300 and is still a contact node ) .",
    "we can leave in the column list of @xmath573 all those columns that , after a normal slice of @xmath296 , would end up being associated with @xmath572 without incurring in any trouble for two reasons : @xmath176 after the join of @xmath233 and @xmath299 they would disappear anyway , and @xmath177 @xmath300 is exhausted and its contact nodes are not active anymore .",
    "we also do not need the finishing phase of slice , since all the subproblems in @xmath296 are exhausted and @xmath233 will join with @xmath299 after the slicing part of slicejoin .    because of the characteristics of @xmath299 , to join @xmath233 with it we just @xmath176 link @xmath233 s root to the only contact node of @xmath299 and @xmath177 change each column @xmath271 of @xmath233 to @xmath574 , where @xmath470 is the number of nodes @xmath299 ( whose tree is just a path ) .",
    "thus , lemma  [ lem : slicejoin : comp ] follows as a corollary of lemma  [ lem : slice : comp ] .",
    "we finally have to store into @xmath268 all the @xmath35 wanted suffixes .",
    "note that we need to retrieve them from the columns that contains them . to this end , we output the set of @xmath35 pairs @xmath575 in the following way .",
    "we scan @xmath268 and for each subproblem @xmath282 that is both _ solved _ and a _ leaf _ we do as follows .",
    "first we add @xmath576 to @xmath577 , where @xmath578 and @xmath579 are @xmath282 s only rank and only suffix .",
    "then we retrieve all the ancestors of @xmath282 ( in the tree of its agglomerate ) that are also solved .",
    "they are all the nodes closest to @xmath282 in its leaf - to - root path .",
    "let @xmath580 be the @xmath581-th closest one of them , we add @xmath582 to @xmath577 , where @xmath583 is the only rank of @xmath580 ( and @xmath584 is clearly @xmath580 s only suffix ) .    [",
    "lem : finalization - stage : full ] the finalization stage requires @xmath27 time .",
    "[ sec : analysis : full ]    correctness and complexity are strictly related , so we discuss them together . here",
    "we give the lemmas needed to prove the theorems stated in the introduction , and few proofs .",
    "we devote section  [ sec : proofs ] to the remaining proofs .",
    "consider first a simplified scenario where we have to perform multi - selection on a prefix - free set @xmath585 of @xmath48 _ independent _ strings of total length  @xmath28 , using our set @xmath586 of @xmath35 ranks .",
    "we adopt the same notation as in formula   and section  [ sec : def ] .",
    "we run mselmset@xmath587 on the first symbol of all the strings in @xmath585 .",
    "this partitions the strings into unsolved , solved and exhausted subproblems : @xmath164 is unsolved when it contains all the strings with the same first symbols and @xmath588 ; or , @xmath164 is solved when @xmath170 ; finally , if @xmath164 is exhausted then @xmath174 and the first symbols of its strings may not be the same .",
    "we repeat the refining steps until there are no more unsolved subproblems .",
    "we pick any unsolved subproblem @xmath164 .",
    "let @xmath589 be the length of the common prefix ( of its strings ) examined so far : we invoke mselmset@xmath590 using the alphabetic order on the symbols @xmath591 $ ] for @xmath592 .",
    "thus we refine @xmath164 into smaller subproblems , classify them as described above , and repeat the steps .",
    "[ lem : msel : strings : comp ] the running time of the multi - selection algorithm with @xmath35 ranks for a prefix - free set of @xmath48 independent strings of total length @xmath28 is upper bounded by @xmath593 .",
    "here we focus on the multi - selection for our set  @xmath20 of @xmath48 suffixes , and show how to consider them as a set of @xmath48 independent _ virtual _ strings .",
    "[ lem : msel : suffixes : comp ] the running time of the suffix multi - selection algorithm for a text of length @xmath48 is upper bounded by @xmath594 , where @xmath595 is the total time required by all the raps minus the time for the mselmset calls .    consider the computation described in sections  [ sec : def ] and  [ sec : algorithm ] , and the _ virtual symbol cost _ of the calls to mselmset : when applied to a subproblem @xmath242 , it performs comparisons using a certain order on @xmath242 s keys , which can be seen as the _ virtual _ symbols of independent strings . indeed , these virtual symbols are exclusively created and `` used '' for @xmath242 . unlike @xmath2 s symbols , virtual symbols are not shared by subproblems .",
    "each @xmath242 has associated @xmath257 virtual strings that are made up of all the virtual symbols _ created _ to refine @xmath242 during several raps , every time @xmath242 is the leading subproblem of its current agglomerate . and , unlike the suffixes of @xmath2 , all the virtual strings are independent .",
    "let @xmath28 be the total number of virtual symbols thus created by all the raps .",
    "lemma  [ lem : msel : strings : comp ] reports the virtual symbol cost for all the mselmset calls , that is , their total contribution to the final cost of our multi - selection algorithm .",
    "we have to add the cost of the rest of the computation , which is @xmath596 by definition .",
    "it remains to show that @xmath597 , thus proving the claimed bound .",
    "when mselmset is applied to @xmath242 , let @xmath233 be the agglomerate for which @xmath242 is its leading subproblem .",
    "the number @xmath257 of virtual symbols created in this call satisfies @xmath598 .",
    "since the rap computation time for this step ( minus the call to mselmset ) is @xmath599 ( e.g. lemmas  [ lem : slice : comp]  [ lem : slicejoin : comp ] ) , this computation time is an upper bound for @xmath257 . summing up over all the raps",
    ", we obtain that the total number @xmath28 of virtual symbols thus created is upper bounded by the computation time of all the raps minus the mselmset calls , namely , @xmath597 .",
    "[ lem : msel : ksuffixes : comp ] the running time of the suffix multi - selection algorithm for a text of length @xmath48 is upper bounded by @xmath600 when @xmath586 is an interval of @xmath35 consecutive ranks .",
    "we need an intermediate stage to find the suffixes of ranks @xmath75 and @xmath77 , and create a subproblem with the remaining @xmath601 ones .",
    "after that , we run our multi - selection .",
    "[ lem : rapn ] independently of the choice of the ranks in @xmath586 , @xmath602 .",
    "we give an analysis based on counting the following _ types of events _ : : when some @xmath208 is partitioned into @xmath179 ( during a slice or at the beginning of a slicejoin ) .",
    ": when some @xmath603 is recognized as one of the wanted suffixes with rank in @xmath586 ( third step of rap ) .",
    ": when some suffix @xmath604 becomes exhausted , where @xmath242 is the leading subproblem of @xmath233 ( third step of rap ) .",
    ": when a column of @xmath291 is fused with one of @xmath233 ( during join@xmath290 or at the end of a slicejoin ) .",
    ": when processing a column @xmath249 of @xmath233 such that @xmath271 is also in @xmath233 and satisfies @xmath605 , while @xmath251 and @xmath570 do not belong to the same subproblem ( second step of rap ) .",
    "_ claim : _ there are overall @xmath606 events occurring in any execution of our algorithms . indeed , the same event can not repeat .",
    "a column is never divided and a subproblem is never merged with others . if a suffix is exhausted or a wanted suffix is found , they can never be in an unsolved subproblem again .",
    "an inner collision is unique , since the two colliding columns will not be part of the same agglomerate .",
    "since we start with @xmath48 columns and one subproblem , the total number of events is @xmath606 .    for a generic rap on an agglomerate @xmath233 ,",
    "let @xmath607 be the number of events thus occurring .",
    "since the overall number of events is @xmath27 , this implies that @xmath608 .",
    "we show that @xmath609 , where @xmath610 is the number of created subproblems .",
    "consider events  , and observe that their contribution is @xmath610 , which is the sum of three quantities : @xmath611 , where @xmath283 are the agglomerates into which @xmath233 is sliced in the fourth step ; @xmath612 , where @xmath613 are the agglomerates into which each @xmath368 is sliced in the fifth step ; @xmath614 , where @xmath615 denotes all the @xmath368 s in @xmath372 that need a slicejoin in the sixth step .",
    "as for events   , they totalize at least @xmath256 in number and occur in the fourth step .",
    "namely , the number of s and s is at least the total number of columns of @xmath616 s that go to @xmath313 or to @xmath371 : each column of each @xmath616 moved to @xmath371 corresponds to  , and each column of each @xmath616 moved to @xmath313 corresponds to either   or  .",
    "the number of s and s is at least the total number of columns of the @xmath368 s that are moved to @xmath372 and @xmath312 , respectively .",
    "since the total number of involved columns in the fourth step is @xmath287 , we obtain the claimed number .    at this point , to prove @xmath602 , it remains to see that the cost of a generic rap ( mselmset excluded ) on an agglomerate @xmath233 is @xmath617 time .",
    "the first three steps of the rap take @xmath260 time .",
    "the costs of the fourth and fifth steps are given by lemma  [ lem : slice : comp ] : precisely , @xmath618 and @xmath619 . by lemmas  [ lem : join : comp ] and  [ lem : slicejoin : comp ] , the total cost of the sixth step is @xmath620 . since @xmath621 @xmath622 , the total cost is @xmath623 and @xmath624 .",
    "for any two subproblems @xmath164 and @xmath625 such that @xmath626 , let @xmath627 be the length of the longest common prefix of any two suffixes @xmath628 and @xmath629 .",
    "we have the following :    [ lem : lcp ] the suffix multi - selection algorithm can support @xmath627 queries in @xmath196 time , for any two @xmath630 such that @xmath626 , without changing its asymptotic time complexity .",
    "consider a snapshot of the computation , recalling that we maintain the sorted linked list @xmath268 of all the subproblems ( where some of them belong to the same neighborhood ) .",
    "suppose by induction that we have the _ lcp _ s between consecutive subproblems .",
    "we use a cartesian tree ( ct ) plus lowest common ancestor ( lca ) dynamic queries to compute the _",
    "lcp _ for any two subproblems .",
    "we maintain the induction at the end of the slice  operation : when @xmath616 is sliced into @xmath631 , the newly created subproblems @xmath632 for each @xmath633 are stored contiguously in @xmath268 .",
    "we compute @xmath634 ,   , @xmath635 using using their keys , the ct , and the lca queries , in @xmath636 time , which we can pay for . since these _ lcp _",
    "s are longer , we just need to add @xmath637 new leaves to ct , without increasing the asymptotic complexity .",
    "in order to prove the upper bound for the time complexity of our suffix multi - selection algorithm , we first need to prove the complexity of the following algorithm for multi - selection of _ independent strings _ ( i.e. not sharing symbols ) .",
    "we have a set @xmath585 of @xmath48 _ independent strings _ of total length @xmath28 such that none of them is the prefix of another .",
    "we want to select the @xmath35 strings with ranks in @xmath638 , where @xmath639 .",
    "let @xmath640 and @xmath641 be @xmath464 and @xmath642 respectively .    in our multi - selection algorithm for independent strings a subproblem @xmath164 is a subset of @xmath585 associated with @xmath244 @xmath643 , @xmath247 @xmath644 , the number of strings in @xmath585 that are less than each one in @xmath164 and @xmath262 an offset @xmath645 , where @xmath646 is the length of the shortest string in @xmath164 .    1 .",
    "[ multistring : stepone : full ] we put in @xmath312 the first subproblem @xmath647 where @xmath648 , @xmath649 and @xmath650 .",
    "[ multistring : steptwo : full ] we repeat the following steps until @xmath312 is empty . 1 .",
    "[ multistring : steptwo : a : full ] we pick a subproblem @xmath164 in @xmath312 and we call mselmset@xmath651 where @xmath652\\;\\vert\\ ; s\\in{\\mathcal{p}_{i}}\\right\\}}$ ] and @xmath653 .",
    "this partitions @xmath399 into its pivotal multisets @xmath355 .",
    "[ multistring : steptwo : b : full ] for each @xmath310 , we collect the set @xmath654 of the strings corresponding to the symbols in @xmath310 , and we set @xmath655 , @xmath656 and @xmath657 .",
    "3 .   if @xmath658 we move @xmath197 to @xmath659 . otherwise , we move @xmath197 to @xmath312 .",
    "[ multistring : stepthree : full ] for each @xmath164 in @xmath659 , we output @xmath660 , where @xmath661 and @xmath662 .    [",
    "lem : msel : strings : comp : full ] the running time of the multi - selection algorithm for a set @xmath585 of independent ( and prefix free ) strings of total length @xmath28 is upper bounded by @xmath663 where @xmath434 is a suitable integer constant , @xmath15 , @xmath16 , @xmath106 for @xmath18 , and @xmath664 is the smallest number of symbols we need to probe to find the wanted strings .",
    "the _ offset size _ of a subproblem @xmath164 is the total length of the strings in @xmath665\\ ; \\vert\\ ; s\\in{\\mathcal{p}_{i}}\\right\\}}$ ] .",
    "it is easy to see that the computations on distinct subproblems proceed independently from one another .",
    "hence , we prove the thesis by induction on the offset size of subproblems .",
    "let us consider subproblem @xmath666 ( step  [ multistring : stepone : full ] ) , its corresponding multiset @xmath399 and the pivotal multisets of @xmath399 computed in step  [ multistring : steptwo : full ] . because of lemma  [ lem : multisel : multiset : full ] , after the first execution of step  [ multistring : steptwo : a : full ] the terms @xmath667 and @xmath668 of the wanted upper bound are accounted for .",
    "let us first deal with the pivotal multisets @xmath669 of @xmath399 such that @xmath670 .",
    "they correspond to solved subproblems and they are not involved in step  [ multistring : steptwo : full ] any longer .",
    "let us consider all the maximal consecutive groups of them .",
    "let one such group be @xmath671 , for some @xmath672 .",
    "we know that @xmath672 is associated with just one rank @xmath673 , @xmath674 and the only string in the corresponding subproblem is the one of rank @xmath673 in @xmath585 .",
    "analogously , @xmath675 is associated with just one rank @xmath676 and so forth up to @xmath677 included .",
    "hence , for any such @xmath678 , we have that @xmath679 . therefore , because of lemma  [ lem : multisel : multiset : full ] , the term @xmath680 of the wanted bound is accounted for .",
    "what we have said so far does not hold for @xmath681 ( unless it is the rightmost one of all the pivotal multisets @xmath669 ) .",
    "let us deal with these cases later .",
    "let us now consider any pivotal multiset @xmath682 created in the first execution of step  [ multistring : steptwo : full ] and containing more that one symbol .",
    "let @xmath683 the subproblem corresponding to @xmath682 .",
    "let @xmath684 be the ranks corresponding to @xmath682 and let @xmath685 be the number of symbols in @xmath399 less than the ones in @xmath682 .",
    "since @xmath683 has offset size less than the one of @xmath666 , by inductive hypothesis we know that the algorithm retrieves the strings of @xmath585 with ranks @xmath684 using time    @xmath686 @xmath687    where @xmath688 is the smallest number of symbols we need to probe to find the wanted strings amongst the ones in @xmath683 ( since @xmath689 , i.e. the first symbol of each string in @xmath683 can be skipped ) .",
    "let us call @xmath690 the _ left inductive term _ and the two terms @xmath691 , @xmath692 _ inductive remainder terms_. we will deal with them later .",
    "by lemma  [ lem : multisel : multiset : full ] , we have term @xmath693 from the first execution of step  [ multistring : steptwo : a : full ] .",
    "we can upper bound that term by the two - term expression @xmath694 .",
    "the first term @xmath695 can be cancelled with the opposite term in the expression given by the inductive hypothesis .    for each rank @xmath696 the term @xmath697 of the wanted upper bound",
    "is accounted for , since it is in the expression given by the inductive hypothesis . amongst the ranks corresponding to @xmath698",
    ", @xmath699 is the one with which we have yet to deal .",
    "let us first assume that @xmath700 . if that is true , we know that @xmath701 , where we denoted with @xmath702 the number of strings in @xmath683 with rank ( in @xmath585 ) greater than or equal to @xmath699 . but @xmath703 . hence , to obtain the term @xmath704 for",
    "the wanted bound , we need to mix the terms @xmath705 ( from the inductive hypothesis on @xmath683 ) and @xmath706 ( from the first execution of step  [ multistring : steptwo : a : full ] ) .",
    "it is easy to prove that for any @xmath707 , @xmath708 .",
    "thus , we have that    @xmath709 @xmath710    thus , we have now obtained the @xmath704 term for the last rank @xmath699 of @xmath682 for the case @xmath700 .",
    "however , we still have to deal with the extra @xmath711 , let us call it the _ extra remainder term_.    let us now consider the case @xmath712 . thus we can use the inductive hypothesis and in this case @xmath713 contributes to the bound a _",
    "left inductive term _ @xmath714 ( analogous to the @xmath690 for @xmath715 ) , where @xmath716 is the smallest rank associated with @xmath713 and @xmath717 is the number of symbols in @xmath399 less than the ones in @xmath713 . the term @xmath704 is obtained in the same way we did before , only this time we have to mix three intervals instead of two , since in this case @xmath718 .",
    "hence , in this case the _ extra remainder term _ is @xmath719 .",
    "before we account for all the remainder terms , we still need to deal with the rightmost multiset of each maximal consecutive group of those multisets @xmath720 such that @xmath721 .",
    "the ( single ) ranks @xmath722 of each one of these rightmost multisets are the only ones for which we have not yet obtained the term @xmath723 of the wanted upper bound . for any such multiset @xmath406 with rank @xmath724 ( @xmath725 ) , @xmath726 can be obtained in the exact same way we did above and hence we have an extra remainder term for each one of these ranks too .",
    "finally , let us account for the remainder terms .",
    "for each @xmath682 , we have at most three kinds of remainders : @xmath691 , @xmath692 and a third kind that is at most @xmath719 , where @xmath699 is the largest rank associated with @xmath682 and @xmath688 is the smallest number of symbols we need to probe to find the wanted strings amongst the ones in @xmath683 ( if any ) .",
    "overall , the first and third kinds are upper bounded by @xmath727 . by the definition of the second kind of remainder and since all the @xmath48 symbols in @xmath399 need to be probed to find the wanted strings , we have that @xmath728 .",
    "let us consider the pruning phase .",
    "in the first step , the level - by - level visit of the skip tree of @xmath233 can be easily done in @xmath260 : the skip tree contains only contact and branching subproblems , hence its has @xmath260 nodes ; also , by lemma  [ lem : grouping : full ] , all the calls to group have a total cost which is linear in the number of columns of @xmath233 , which is @xmath256 .",
    "about the second step , the cost of skipvisit on the skip tree is clearly @xmath260 .",
    "so is the cost of the third step where we do an @xmath196 amount of work for each node in @xmath512 . in the fourth step",
    "we do @xmath196 amount of work for each subproblem that is not in a subtree rooted at some @xmath729 . by the definition of @xmath512 we already know that each one of the subproblems we touch in the fourth step will be later partitioned into two or more smaller subproblems .",
    "thus they are certainly less than @xmath288 ( which is the total number of new subproblems that are created by the slicing of @xmath233 ) .",
    "thus the pruning phase takes @xmath289 time .",
    "let us consider the slicing phase .",
    "first of all , slicerec performs a depth first visit of the tree of @xmath233 that whenever encounters a node in @xmath512 it does not go any deeper .",
    "thus , the total number of nodes visited is equal to the number of subproblems that are partitioned into two or more subproblems by the slice operation .",
    "let us consider the internal nodes of @xmath233 .",
    "for any such @xmath297 , in the first step , after the recursive calls to slicerec have returned , we call group on a list containing @xmath730 objects , where @xmath731 is the set of contact suffixes of @xmath297 ( if it is a contact node ) and @xmath732 is the number of subproblems into which the @xmath131-th child of @xmath297 has been refined into ( during the recursive call )",
    ". we charge each @xmath732 term to the corresponding child .",
    "the second step costs @xmath733 time .",
    "the third step requires @xmath196 amount of work for each one of the children of each new subproblem into which @xmath297 has been partitioned : we charge any such @xmath196 amount of work the the corresponding child .",
    "thus , the total cost for an internal node @xmath297 of @xmath233 ( including the costs charged to @xmath297 by its parent ) is @xmath733 .    for each leaf @xmath297 of @xmath233 , the total work we do is of the order of the number of columns of @xmath297 ( by lemma  [ lem : grouping : full ] ) .",
    "the amount charged to @xmath297 by its parent is of the same order .",
    "thus , overall the cost for all the leaves of @xmath233 , the internal nodes of @xmath233 and the new nodes of each @xmath368 is @xmath289 .",
    "finally let us consider the finishing phase .",
    "in the first step we can use radix sorting and thus the first and second steps take @xmath734 time .",
    "the third step accesses each skip node of each new agglomerate @xmath196 times , thus costing @xmath260 . the fourth step , accesses at most all the nodes that are not descendants of any node in @xmath512 . by using @xmath269 , each access to establish",
    "if a node is unsolved takes @xmath196 time .",
    "thus the total cost of the fourth step is @xmath734 .      at this point ,",
    "theorem  [ theo : main : full ] follows directly from the following lemmas  [ lem : msel : suffixes : comp : full ] and  [ lem : rapn : full ] , whose proofs detail some of the ideas presented in section  [ sec : correctness - analysis ] .",
    "[ lem : msel : suffixes : comp : full ] the running time of the suffix multi - selection algorithm for a text of length @xmath48 is upper bounded by @xmath594 , where @xmath595 is the total time required by all the raps minus the time for the mselmset calls .",
    "the cost of the initialization stage is dominated by the call to mselmset ( building takes @xmath606 time ) . by lemma  [ lem : multisel :",
    "multiset : full ] , we know that the cost of that call is within our target bound .",
    "after the refine and aggregate stage , the cost of the finalization stage ( section  [ sub : finalization - stage : full ] ) is @xmath606 .",
    "let us now account for the contribution of the calls to mselmset to the total cost . instead of the normal time cost ,",
    "let us consider the _ virtual symbol cost _ of the calls to mselmset : a call to mselmset costs or ( conceptually ) _ creates _",
    "@xmath103 virtual symbols if the multiset that it receives in input has @xmath103 objects .",
    "the virtual symbols created by the call to mselmset for some leading subproblem are exclusively created and `` used '' for that subproblem .",
    "thus , unlike @xmath2 s symbols , virtual symbols are not shared by subproblems .",
    "naturally , virtual symbols form virtual strings : each subproblem @xmath164 has associated @xmath261 _ virtual strings _ that are made up of all the virtual symbols that will be created during the computation to refine @xmath164 every time it is the leading subproblem of its current agglomerate . and , unlike the suffixes of @xmath2 , all the virtual strings are _",
    "independent_.    picking an unsolved agglomerate @xmath233 and refining it with a rap can be seen as a two - part process : @xmath244 picking an unsolved subproblem , the leading subproblem of @xmath233 , and refining it with the call to mselmset ; @xmath247 refining all the other unsolved subproblems of @xmath233 with the rest of the rap ( mainly the call to slice ) .",
    "thus , if we take aside all the @xmath247 parts of the raps and if we consider the subproblems to be subsets of virtual strings , then the suffix multi - selection algorithm behaves exactly like the multi - selection algorithm for independent strings in section  [ subsec : msel : strings : full ] .",
    "therefore , by lemma  [ lem : msel : strings : comp : full ] , we have that the cost of the algorithm is @xmath735 , where",
    "@xmath15 , @xmath16 , @xmath106 for @xmath18 , @xmath28 is the total number of virtual symbols ( and @xmath595 is the total cost of the @xmath247 parts of the rap)s .",
    "let us evaluate @xmath28 . as we have seen above , a rap an agglomerate @xmath233 creates a number of new virtual symbols that is equal to the cardinality of the multiset passed to mselmset ( equal to @xmath256 ) . since it is not computed during mselmset call , the cardinality of such multiset must be @xmath736 ( where @xmath737 denotes the total cost of the rap on @xmath233 minus the cost of the mselmset call )",
    ". therefore @xmath738 .",
    "[ lem : rapn : full ] @xmath602 .",
    "let us first evaluate the total cost of the steps of a rap on an agglomerate @xmath233 minus the cost of the call to mselmset in the third step .    about the first step , to verify which kind of an agglomerate we are dealing with ( generic or core cyclic ) @xmath196 scans of the contact node list of @xmath233 ( while using the structure ) are enough .",
    "thus , the first step takes @xmath260 time .",
    "about the second step , the slightly more complex case is when @xmath233 is core cyclic . in that case",
    "we first find find the columns @xmath271 such that @xmath739 , then their keys and from those we produce the keys for all the other columns .",
    "as we noticed , we do not actually access each suffix of @xmath233 to assign it its key .",
    "we do that only with @xmath233 s columns .",
    "thus , the second step takes @xmath260 time .",
    "about the third step .",
    "thanks to , retrieving the @xmath740 ranks of the leading subproblem @xmath242 of @xmath233 takes @xmath741 time . as we said , there is a 1-to-1 correspondence between the leading suffixes and the root suffixes .",
    "hence , retrieving the suffixes of @xmath242 s and their keys takes @xmath742 .",
    "we will deal with the cost of the call to mselmset later .",
    "scanning the pivotal multisets and tagging the the columns after the call to mselmset clearly cost @xmath260 . if we exclude mselmset , the cost of the third step is @xmath260 ( since @xmath743 ) .",
    "the cost of the fourth step is dominated by the cost of the call slice@xmath276 which , by lemma  [ lem : slice : comp ] , is @xmath744 , where @xmath745 are the agglomerates into which @xmath233 is sliced .",
    "let us consider the fifth step and , in particular , its three substeps described in section  [ sub : undecided - details : full ] .",
    "in the first substep , we call leadvisit on the root of each agglomerate in ` undecided_g `",
    ". leadvisit accesses the nodes of the skip tree of the agglomerate it received in input and for each node does @xmath196 time worth of work . in the second substep",
    "we compute the prefix sum array @xmath473 of @xmath459 for each @xmath746 and then we tag each column of @xmath368 .",
    "so both substeps require @xmath747 time . in the third substep",
    "we call slice@xmath388 for each @xmath746 .",
    "all those calls clearly dominates the total cost of the substep . for each @xmath746 , let @xmath748 be the @xmath481 agglomerates into which @xmath368 is sliced ( for simplicity s sake let us assume that there is a @xmath483 , i.e. an exhausted agglomerate , for each @xmath368 ) . by lemma  [ lem : slice : comp ] , the total cost of the third substep is @xmath749 .",
    "finally , in the sixth step we operate on each @xmath750 .",
    "we have two cases in which we either do a join or a slicejoin between @xmath368 and the agglomerate @xmath393 with which @xmath368 is joinable . in the second case ,",
    "let @xmath397 be the agglomerate `` sliceable '' from @xmath393 such that @xmath271 is a column of @xmath397 iff @xmath751",
    ". by lemmas  [ lem : join : comp ] and  [ lem : slicejoin : comp ] the total cost of the sixth step is @xmath752 in the first case and @xmath753 in the second . let us denote with @xmath615 all the @xmath368 s in @xmath372 that need a slicejoin in the eighth step .",
    "excluding the cost of the call to mselmset in the third step and , since @xmath754 ( in the fourth step some of the @xmath368 s sliced from @xmath233 may have been moved to ` unsolved_g ` ) , the total time for the rap is @xmath755    to complete the analysis of @xmath595 let us introduce the _ events_. during the algorithm five kinds of crucial events happen .",
    "@xmath244 _ column fusions _ : when during a join@xmath290 ( or at the end of a slicejoin ) a column of @xmath249 of @xmath291 is fused with the column @xmath271 of @xmath233 such that @xmath756 , to form the column @xmath757 .",
    "@xmath247 _ subproblem creations _ :",
    "when during a slice ( or at the beginning of a slicejoin ) some subproblem @xmath208 is partitioned into smaller subproblems @xmath179 , we have _",
    "@xmath563 subproblem creation events_. @xmath262 _ suffix exhaustions _ : when during the third step of a rap for @xmath233 , after the mselmset call , some suffix @xmath604 , where @xmath242 is the leading subproblem of @xmath233 , becomes exhausted ( i.e. @xmath758 belongs to a pivotal multiset @xmath759 , thus we know for sure that it is not one of the wanted suffixes ) . @xmath264 _ suffix discoveries _ : when during the third step of a rap for @xmath233 , some suffix @xmath760 in @xmath242 , the leading subproblem of @xmath233 , is recognized as one of the wanted suffixes ( i.e. @xmath760 belongs to a pivotal multiset @xmath761 such that @xmath762 ) .",
    "@xmath265 _ inner collisions _ : when during the second step of a rap for @xmath233 , we encounter a column @xmath249 of @xmath233 such that @xmath271 , where @xmath605 , is also in @xmath233 while @xmath251 and @xmath570 do not belong to the same subproblem .    a column is never divided into smaller ones and a subproblem is never merged with others to form a larger subproblem .",
    "also , when a suffix becomes exhausted or a wanted suffix is discovered , they can never be in an unsolved subproblem again .",
    "finally , the same inner collision can not be repeated after the rap in which it has been detected has ended , since the two columns colliding will not be part of the same agglomerate any longer . by all the above ,",
    "it is easy to see that one particular event can not be repeated twice .",
    "since there are @xmath48 suffixes and we start with @xmath48 columns and one subproblem , we can conclude that the total number of events during the computation is @xmath606 , or @xmath763 to be precise .",
    "let us establish how many events take place _ during _ a generic rap for an agglomerate @xmath233 .",
    "let us start with _",
    "subproblem creations_. in the fourth step , for each agglomerate @xmath368 sliced from @xmath233 , we have @xmath764 subproblem creations , one for each new ( i.e. not coming from @xmath233 ) subproblem in @xmath368 .",
    "analogously , in the third substep of the fifth step ( section  [ sub : undecided - details : full ] ) , for each @xmath746 and for each @xmath486 sliced from @xmath368 , we have @xmath765 subproblem creations .",
    "finally , in the eighth step , for each @xmath766 , we have @xmath767 subproblem creations . summing up",
    ", @xmath768 subproblem creations take place during the rap for an agglomerate @xmath233 .",
    "the total number of _ suffix discoveries _ and _ suffix exhaustions _ occurring during the rap on @xmath233 is equal to the total number of columns of the agglomerates that in the fourth step are moved either to @xmath313 or to @xmath371 .",
    "each column of each agglomerate moved to @xmath371 corresponds to a _",
    "suffix exhaustion_. each column of each agglomerate moved to @xmath313 corresponds to either a _ suffix discovery _ or a _",
    "suffix exhaustion_. analogously , the numbers of _ column fusions _ and _ inner collisions _ during the rap of @xmath233 are equal to the total numbers of columns of the @xmath368 s that in the fourth step are moved to @xmath372 and @xmath312 , respectively . since @xmath769 , we can conclude that the _ total number of events _ occurring during the rap for @xmath233 is @xmath770 .",
    "as we have seen , if we exclude the calls to mselmset , the cost of the rap for @xmath233 is @xmath771 .",
    "therefore the total time required by all the raps minus the time for the mselmset calls is of the order of the total number of events , which is @xmath606 .",
    "theorem  [ the : bwt2 ] follows directly from lemmas  [ lem : multisel : contiguous : full ] and  [ lem : lcp : full ] .",
    "[ lem : multisel : contiguous : full ] given a text @xmath2 of @xmath48 symbols drawn from an unbounded alphabet and @xmath35 consecutive ranks @xmath772",
    "( i.e. @xmath773 ) , the @xmath35 text suffixes of ranks @xmath772 can be found using @xmath774 time and comparisons .    to retrieve the wanted suffixes in @xmath775 time",
    "we first apply the suffix multi - selection algorithm on @xmath2 with only @xmath75 and @xmath77 .",
    "then we go through an _ intermediate stage _ that takes the subproblems left by the suffix multi - selection and prepares them for a second suffix multi - selection .",
    "after that we apply again the suffix multi - selection on @xmath2 but this time @xmath244 we use all the ranks @xmath772 and @xmath247 we skip the _ initialization stage _ ( because of the work done in the intermediate stage ) .",
    "let us give the details of the process .",
    "we execute the suffix multi - selection algorithm on @xmath2 with @xmath776 .",
    "after the computation ends , we have the two wanted suffixes , let them be @xmath777 and @xmath778 ( @xmath779 ) , the exhausted agglomerates and a subproblem list @xmath780 , ( @xmath781 ) , with the following properties .",
    "@xmath244 @xmath782 and @xmath783 ( they are the only solved subproblems ) .",
    "@xmath247 @xmath784 , @xmath785 and @xmath786 , for each @xmath787 , @xmath788 and @xmath789 , respectively .",
    "@xmath262 all together the subproblems @xmath625 with @xmath788 contains _ exactly _ @xmath601 suffixes and they are the ones with ranks @xmath790 ( but for each of those suffixes we do not know which @xmath790 is its rank ) .",
    "the _ intermediate stage _ has the following steps .",
    "first , for each subproblem in @xmath791 we retrieve its suffixes .",
    "recall that for each agglomerate @xmath616 only contact and root suffixes are explicitly stored during the computation . to retrieve all the suffixes of each @xmath792 we simply need to visit the tree of @xmath616 from its root with suffixvisit@xmath461 defined as follows .",
    "@xmath176 if @xmath297 is a leaf then @xmath793 . after we retrieved the suffixes of @xmath297 we return the set @xmath794 .",
    "@xmath177 otherwise , if @xmath297 is a contact node ( but not a leaf ) we retrieve @xmath795 .",
    "@xmath514 in any case , we call suffixvisit@xmath796 for each children @xmath797 of @xmath297 , let @xmath798 be the set of all the suffixes we receive from all these recursive calls .",
    "@xmath799 then , we set @xmath800 and we return the set @xmath794 .",
    "second , with a scan of @xmath791 , we do the following .",
    "we merge @xmath666 with all the subproblems in its neighborhood @xmath801 , let them be @xmath802 , into one ( the subproblems in the same neighborhood are adjacent in @xmath791 ) .",
    "we do the same for @xmath803 and its neighborhood @xmath804 , then for @xmath805 and so forth until all the subproblems @xmath784 have been treated .",
    "after that we do the same for all the subproblems @xmath806 .",
    "finally we merge all the subproblems @xmath625 with @xmath788 into one , let it be @xmath807 .",
    "after the first step , the new @xmath808 maintains the same properties of the original one .",
    "however , the meaning of _ the integer labels _ of the subproblems may have changed .",
    "now for each subproblem @xmath809 , @xmath198 is the number of suffixes of @xmath2 that are lexicographically smaller than each @xmath810 ( because now for each @xmath164 we have that @xmath200 , whereas originally that was guaranteed only for @xmath811 and @xmath812 ) .",
    "third , for each @xmath813 , let @xmath127 s _ key _ be its first symbol @xmath814 $ ] .",
    "we call mselmset@xmath815 and we obtain @xmath807 s pivotal subsets @xmath816 .",
    "since we know that @xmath807 contains all and only the @xmath601 suffixes with ranks @xmath790 , all the @xmath817 _ are void_. thus , from each @xmath406 we create a subproblem @xmath818 with the following properties : @xmath244 @xmath819 and @xmath247 @xmath820 is the number of suffixes of @xmath2 smaller than each one in @xmath818 . after this step",
    "we have @xmath821 .",
    "fourth , from each @xmath164 with @xmath822 or @xmath823 ( they are all exhausted ) we make an agglomerate @xmath368 and we move it to @xmath313 .",
    "we do the same for @xmath811 and @xmath812 ( although , as subproblems , they are solved ones ) .",
    "finally , from each @xmath824 we make an agglomerate @xmath825 and we move it to @xmath312 .    after the intermediate stage , we apply again the suffix multi - selection algorithm on @xmath2 with the full rank set @xmath826 in the following way .",
    "we skip the initialization stage completely and we start immediately with the refine and aggregate stage ( using @xmath268 , @xmath312 , @xmath313 , the agglomerates and the subproblems we already have after the intermediate stage ) . the rest of the computation proceeds normally .",
    "let us now evaluate the cost of the whole computation .",
    "the first call of the suffix multi - selection algorithm is done with just two ranks , @xmath75 and @xmath77 .",
    "thus , by theorem  [ theo : main : full ] , its cost is @xmath606 .",
    "let us consider the intermediate stage .",
    "the first step requires @xmath606 time : for each agglomerate @xmath616 , suffixvisit costs @xmath827 where @xmath828 . for the second step",
    "a scan of @xmath268 is enough and the cost is @xmath606 .",
    "the cost of the third step si dominated by the cost of the call to mselmset . since it is done on a multiset of @xmath601 elements ( and with a set of @xmath601 ranks ) ,",
    "its cost is clearly @xmath829 .",
    "finally , an @xmath606 time scan of @xmath268 is enough for the fourth step .",
    "let us now consider the cost of the second execution of the suffix multi - selection .",
    "the complexity proof is the same of the one for theorem  [ theo : main : full ] except for two aspects .",
    "first , there is no initialization stage , thus the cost of finding the pivotal multisets of @xmath830,\\ldots , t[n]\\right\\}}$ ] disappears .",
    "second , the total contribution of the mselmset calls made during the whole refine and aggregate stage changes as follows .",
    "the total number of suffixes of all the leading subproblems is at most @xmath601 .",
    "thus the total number of virtual strings is at most @xmath601 . on the other hand , the events that take place during all the raps",
    "are still @xmath606 .",
    "thus , the total number of virtual symbols in the virtual strings is @xmath606 .",
    "all the other additional costs of the raps remain the same .",
    "therefore , by lemma  [ lem : msel : strings : comp : full ] , we have that the total cost of the second call of the suffix multi - selection is is @xmath775 .    for any two subproblems @xmath164 and @xmath625 such that @xmath626 , let @xmath627 be the length of the longest common prefix of any two suffixes @xmath628 and @xmath629 .",
    "let us extend the notation to neighborhoods : for any two @xmath626 , @xmath831 is equal to @xmath627 .",
    "we have the following :    [ lem : lcp : full ] the suffix multi - selection algorithm can be modified ( without changing its asymptotical time complexity ) so that @xmath627 can be computed in @xmath196 time , for any two @xmath630 such that @xmath626 .",
    "as we have seen , for any subproblem @xmath164 , the subproblems in its neighborhood @xmath203 are in contiguous positions in @xmath268 .",
    "we maintain another list @xmath832 whose elements represent the neighborhoods : the @xmath131-th element in @xmath832 represents the @xmath131-th contiguous group of subproblems in @xmath268 forming a neighborhood .",
    "each @xmath164 in @xmath268 has a link to the element in @xmath832 corresponding to its neighborhood .",
    "we also maintain a third list @xmath833 such that if @xmath164 and @xmath625 are in two adjacent neighborhoods @xmath834 $ ] and @xmath835 $ ] then @xmath836={\\mathit{lcp}\\!\\left({{\\mathcal{p}_{i}},{\\mathcal{p}_{i'}}}\\right)}$ ] .",
    "a cartesian tree is maintained on @xmath833 and a structure for dynamic lca queries ( e.g. @xcite ) is maintained on the cartesian tree .",
    "@xmath268 , @xmath832 and @xmath833 are updated in the finishing phase of the slice operation ( see section  [ subsubsec : slice : finishing : full ] ) .",
    "as we have seen , a subproblem @xmath164 in @xmath268 is replaced by a partitioning @xmath837 of it .",
    "if @xmath164 was active then the partitioning is necessarily a refining one , otherwise we do not care .",
    "thus , if @xmath164 was inactive , the set of the suffixes whose subproblem belong to @xmath203 does not change and neither @xmath832 nor @xmath833 needs to be updated .    on the other hand ,",
    "if @xmath164 was active then @xmath200 and @xmath838 , for each @xmath839 .",
    "thus , the element in @xmath832 for @xmath203 is replaced by the ones for @xmath840 .",
    "since the partitioning is a refining one , we have that @xmath841 and @xmath842 , where @xmath843 and @xmath844 are ( were ) the predecessor and successor of @xmath164 in @xmath832 . thus the corresponding entries in @xmath833 do not need to be updated ( and neither does the cartesian tree nor the structure for lca queries ) .",
    "the values @xmath845 can be easily found by doing @xmath846 lca queries . since @xmath164 has been refined , we know that none of the values @xmath845 can be smaller than either @xmath847 or @xmath848 .",
    "thus each pair of insertions of @xmath849 in @xmath832 and of @xmath850 in @xmath833 corresponds to the insertion of a leaf on the cartesian tree built on @xmath833 .",
    "this kind of updates of the structure for lca queries can be done in @xmath196 time ( hence adding an extra @xmath606 term to the complexity bound for the suffix multi - selection algorithm ) .",
    "we studied partial compression and text indexing problems , and as a technical piece , the suffix multi - selection problem .",
    "the main theme is that when comparing an arbitrary set of suffixes which might overlap in sophisticated ways , we need to devise methods to avoid rescanning characters to get optimal results . we achieve this with a variety of structural observations and carefully arranging computations , and achieve bounds optimal with respect to those known for atomic elements .",
    "other partial suffix problems will be of great interest in stringology and its applications .",
    "m.  farach",
    ". optimal suffix tree construction with large alphabets . in _ proceedings of the 38th annual symposium on foundations of computer science ( focs ) _ , pages 137143 .",
    "ieee computer society press , 1997 .                                               with @xmath851 symbols and @xmath852 ranks in @xmath133 .",
    "agglomerates @xmath328 , @xmath320 , and @xmath326 are unsolved , while @xmath853 , @xmath854 and @xmath855 are exhausted .",
    "the columns of each agglomerate are pictured beside it ( as contiguous substrings of @xmath2 ) .",
    "@xmath2 is pictured as a partitioning of the columns of the agglomerates . ]"
  ],
  "abstract_text": [
    "<S> consider an input text string @xmath0 $ ] drawn from an unbounded alphabet , so text positions can be accessed using comparisons . </S>",
    "<S> we study _ partial _ computation in suffix - based problems for data compression and text indexing such as    * retrieve any segment of @xmath1 consecutive symbols from the burrows - wheeler transform of @xmath2 , which is at the heart of the ` bzip2 ` family of text compressors , and * retrieve any chunk of @xmath3 consecutive entries of the suffix array or the suffix tree , two popular text indexing data structures for  @xmath2 .    </S>",
    "<S> prior literature would take @xmath4 comparisons ( and time ) to solve these problems by solving the _ total _ problem of building the entire burrows - wheeler transform or text index for  @xmath2 , and performing a post - processing to single out the wanted portion . </S>",
    "<S> the technical challenge is that the suffixes of interest are potentially of size @xmath5 and overlap in intricate ways : we have to use structural properties of these overlaps to avoid rescanning them repeatedly . </S>",
    "<S> we introduce a novel adaptive approach to partial computational problems above , and solve both the partial problems in @xmath6 comparisons and time , improving the best known running times of @xmath7 for @xmath8 .    </S>",
    "<S> these partial - computation problems are intimately related since they share a common bottleneck : the _ suffix multi - selection _ problem , which is to output the suffixes of rank @xmath9 under the lexicographic order , where @xmath10 , @xmath11 $ ] . </S>",
    "<S> special cases of this problem are well known : @xmath12 is the suffix sorting problem that is the workhorse in stringology with hundreds of applications , and @xmath13 is the recently studied suffix selection .    </S>",
    "<S> we show that suffix multi - selection can be solved in @xmath14 time and comparisons , where @xmath15 , @xmath16 , and @xmath17 for @xmath18 . </S>",
    "<S> this is asymptotically optimal , and also matches the bound in @xcite for multi - selection on atomic elements ( not suffixes ) . matching the bound known for atomic elements for strings is a long running theme and challenge from @xmath19 s , which we achieve for the suffix multi - selection problem . </S>",
    "<S> the partial suffix problems as well as the suffix multi - selection problem have many applications . </S>"
  ]
}