{
  "article_text": [
    "the subject of arithmetic constraints on reals has attracted a great deal of attention in the literature .",
    "for some reason arithmetic constraints on integer intervals have not been studied even though they are supported in a number of constraint programming systems .",
    "in fact , constraint propagation for them is present in ecl@xmath0ps@xmath1 , sicstus prolog , gnu prolog , ilog solver and undoubtedly most of the systems that support constraint propagation for linear constraints on integer intervals . yet , in contrast to the case of linear constraints  see notably @xcite  we did not encounter in the literature any analysis of this form of constraint propagation .",
    "in this paper we study these constraints in a systematic way .",
    "it turns out that in contrast to linear constraints on integer intervals there are a number of natural approaches to constraint propagation for these constraints .    to define them we introduce integer interval arithmetic that is modeled after the real interval arithmetic , see e.g. , @xcite",
    "there are , however , essential differences since we deal with integers instead of reals .",
    "for example , multiplication of two integer intervals does not need to be an integer interval . in passing by we",
    "show that using integer interval arithmetic we can also define succinctly the well - known constraint propagation for linear constraints on integer intervals . in the second part of the paper",
    "we compare the proposed approaches by means of a set of benchmarks .",
    "we review here the standard concepts of a constraint and of a constraint satisfaction problem .",
    "consider a sequence of variables @xmath2 where @xmath3 , with respective domains @xmath4 associated with them .",
    "so each variable @xmath5 ranges over the domain @xmath6 . by a    _ constraint _",
    "@xmath7 on @xmath8 we mean a subset of @xmath9 . given an element @xmath10 of @xmath9 and a subsequence @xmath11 of @xmath8 we denote by @xmath12 $ ] the sequence @xmath13 .",
    "in particular , for a variable @xmath5 from @xmath8 , @xmath14 $ ] denotes @xmath15 .",
    "a    _ constraint satisfaction problem _    , in short csp , consists of a finite sequence of variables @xmath8 with respective domains @xmath16 , together with a finite set @xmath17 of constraints , each on a subsequence of @xmath8 . we write it as @xmath18 , where @xmath19 and @xmath20 .    by a    _ solution _",
    "to @xmath21 we mean an element @xmath22 such that for each constraint @xmath23 on a sequence of variables @xmath8 we have @xmath24 \\in c$ ] .",
    "we call a csp    _ consistent _    if it has a solution and    _ inconsistent _    if it does not",
    ". two csps with the same sequence of variables are called    _ equivalent _    if they have the same set of solutions . in what follows",
    "we consider csps the constraints of which are defined in a simple language and identify the syntactic description of a constraint with its meaning being the set of tuples that satisfy it .",
    "we view    _ constraint propagation _    as a process of transforming csps that maintains their equivalence . in what follows",
    "we define this process by means of proof rules that act of csps and preserve equivalence .",
    "an interested reader can consult @xcite for a precise explanation of this approach to describing constraint propagation .      to define the arithmetic constraints use the alphabet that comprises    * variables , * two constants , 0 and 1 , * the unary minus function symbol ` @xmath25 ' , * three binary function symbols , ` + ' , ",
    "@xmath25and ` @xmath26 ' , all written in the infix notation .    by an    _ arithmetic expression _    we mean a term formed in this alphabet and by an    _ arithmetic constraint _    a formula of the form @xmath27 where @xmath28 and @xmath29 are arithmetic expressions and @xmath30 .",
    "for example @xmath31 is an arithmetic constraint . here",
    "@xmath32 is an abbreviation for @xmath33 and similarly with the other expressions .",
    "if ` @xmath26 ' is not used in an arithmetic constraint , we call it a    _ linear constraint _    .    by an    _ extended arithmetic expression _    we mean a term formed in the above alphabet extended by the unary function symbols ` @xmath34 ' and ` @xmath35{.}$ ] ' for each @xmath36 and the binary function symbol ` @xmath37 ' written in the infix notation .",
    "for example @xmath38{(y^2 \\cdot z^4)/(x^2 \\cdot u^5 ) } \\label{eq : extended}\\ ] ] is an extended arithmetic expression . here",
    ", in contrast to the above @xmath32 is a term obtained by applying the function symbol ` @xmath39 ' to the variable @xmath40 .",
    "the extended arithmetic expressions will be used only to define constraint propagation for the arithmetic constraints .",
    "fix now some arbitrary linear ordering @xmath41 on the variables of the language . by a    _ monomial _    we mean an integer or a term of the form @xmath42 where @xmath43 , @xmath44 are different variables ordered w.r.t .",
    "@xmath41 , and @xmath45 is a non - zero integer and @xmath46 are positive integers .",
    "we call then @xmath47 the    _ power product _    of this monomial .    next , by a    _ polynomial _    we mean a term of the form @xmath48 where @xmath49 , at most one monomial @xmath50 is an integer , and the power products of the monomials @xmath51 are pairwise different . finally , by a    _ polynomial constraint _",
    "we mean an arithmetic constraint of the form @xmath52 , where @xmath28 is a polynomial with no monomial being an integer , @xmath30 , and @xmath53 is an integer .",
    "it is clear that by means of appropriate transformation rules we can transform each arithmetic constraint to a polynomial constraint .",
    "for example , assuming the ordering @xmath54 on the variables , the arithmetic constraint ( [ eq : arithcon ] ) can be transformed to the polynomial constraint @xmath55 so , without loss of generality , from now on we shall limit our attention to the polynomial constraints .    next ,",
    "let us discuss the domains over which we interpret the arithmetic constraints . by an",
    "_ integer interval _    , or an    _ interval _    in short , we mean an expression of the form @xmath56\\ ] ] where @xmath45 and @xmath53 are integers ; @xmath57 $ ] denotes the set of all integers between @xmath45 and @xmath53 , including @xmath45 and @xmath53 . if @xmath58 , we call @xmath57 $ ] the    _ empty interval _    and denote it by @xmath59 . finally , by a    _ range _",
    "we mean an expression of the form @xmath60 where @xmath40 is a variable and @xmath61 is an interval .",
    "to reason about the arithmetic constraints we employ a generalization of the arithmetic operations to the sets of integers .      for @xmath62 sets of integers we define the following operations :    * addition : @xmath63 * subtraction : @xmath64 * multiplication : @xmath65 * division : @xmath66 * exponentiation : @xmath67 for each natural number @xmath49 , * root extraction : @xmath68{x } : = { \\mbox{$\\{{x \\in { \\cal z } \\mid x ^n \\in x}\\}$}},\\ ] ] for each natural number @xmath49 .",
    "all the operations except division are defined in the expected way .",
    "we shall return to it at the end of section [ sec : third ] . at the moment it suffices to note the division operation",
    "is defined for all sets of integers , including @xmath69 and @xmath70 .",
    "this division operation corresponds to the following division operation on the sets of reals introduced in @xcite :    @xmath71 for a ( n integer or real ) number @xmath45 and @xmath72 we identify @xmath73 with @xmath74 and @xmath75 with @xmath76 .    to present the rules we are interested in we",
    "shall also use the addition and division operations on the sets of real numbers .",
    "addition is defined in the same way as for the sets of integers , and division is defined above . in @xcite",
    "it is explained how to implement these operations .",
    "further , given a set @xmath77 of integers or reals , we define @xmath78 @xmath79    when limiting our attention to intervals of integers the following simple observation is of importance .",
    "[ note:1 ] for @xmath62 integer intervals and @xmath45 an integer the following holds :    * @xmath80 , @xmath81 are integer intervals .",
    "* @xmath82 is an integer interval .",
    "* @xmath83 does not have to be an integer interval , even if @xmath84 or @xmath85 .",
    "* @xmath86 does not have to be an integer interval .",
    "* for each @xmath87  @xmath88 does not have to be an integer interval .",
    "* for odd @xmath87  @xmath35{x}$ ] is an integer interval . * for even @xmath87  @xmath35{x}$ ] is an integer interval or a disjoint union of two integer intervals .",
    "for example we have @xmath89 + [ 3 .. 8 ] = [ 5 .. 12],\\ ] ] @xmath90 - [ 1 .. 8 ] = [ -5 .. 6],\\ ] ] @xmath91 \\cdot [ 1 .. 2 ] = { \\mbox{$\\{{3,6}\\}$}},\\ ] ] @xmath92/[-1 .. 2 ] = { \\mbox{$\\{{-5,-4,-3,2,3,4,5}\\}$}},\\ ] ] @xmath93/[-1 .. 2 ] = { \\cal z},\\ ] ] @xmath94 ^ 2 = { \\mbox{$\\{{1,4}\\}$}},\\ ] ] @xmath38{[-30 .. 100 ] } = [ -3 .. 4],\\ ] ] @xmath95{[-100 .. 9 ] } = [ -3 .. 3],\\ ] ] @xmath95{[1 .. 9 ] } = [ -3 .. -1 ] \\cup [ 1 .. 3].\\ ] ] to deal with the problem that non - interval domains can be produced by some of the operations we introduce the following operation on the subsets of the set of the integers @xmath96 : @xmath97 for example @xmath98/[-1 .. 2 ] ) = [ -5 .. 5]$ ] and @xmath99/[-1 .. 2 ] ) = { \\cal z}$ ] .      to define constraint propagation for the arithmetic constraints on integer intervals we shall use the integer set arithmetic , mainly limited to the integer intervals .",
    "this brings us to the discussion of how to implement the introduced operations on the integer intervals .",
    "since we are only interested in maintaining the property that the sets remain integer intervals or the set of integers @xmath96 we shall clarify how to implement the intersection , addition , subtraction and root extraction operations of the integer intervals and the @xmath100 closure of the multiplication , division and exponentiation operations on the integer intervals .",
    "the case when one of the intervals is empty is easy to deal with .",
    "so we assume that we deal with non - empty intervals @xmath101 $ ] and @xmath102 $ ] , that is @xmath103 and @xmath104 .",
    "[ [ intersection - addition - and - subtraction ] ] intersection , addition and subtraction + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    it is easy to see that @xmath105 \\cap [ c .. d ] = [ max(a , c) .. min(b , d)],\\ ] ] @xmath105 + [ c .. d ] = [ a+c\\ .. \\ b+d],\\ ] ] @xmath105 - [ c .. d ] = [ a - d\\ .. \\ b - c].\\ ] ] so the interval intersection , addition , and subtraction are straightforward to implement .    [",
    "[ root - extraction ] ] root extraction + + + + + + + + + + + + + + +    the outcome of the root extraction operator applied to an integer interval will be an integer interval or a disjoint union of two integer intervals .",
    "we shall explain in section [ sec : first ] why it is advantageous not to apply @xmath100 to the outcome .",
    "this operator can be implemented by means of the following case analysis .",
    "_ suppose @xmath106 is odd",
    ". then @xmath68{[a .. b ] } = [ { \\left \\lceil \\sqrt[n]{a } \\right \\rceil } .. { \\left \\lfloor \\sqrt[n]{b } \\right \\rfloor}].\\ ] ]    _ case 2 .",
    "_ suppose @xmath106 is even and @xmath107 .",
    "then    @xmath68{[a .. b ] } = { \\mbox{$\\emptyset$}}.\\ ] ]    _ case 3 .",
    "_ suppose @xmath106 is even and @xmath108 .",
    "then @xmath68{[a .. b ] } = [ -{\\left \\lfloor |\\sqrt[n]{b}| \\right \\rfloor } .. -{\\left \\lceil |\\sqrt[n]{a^{+}}| \\right \\rceil } ]                \\cup [ { \\left \\lceil |\\sqrt[n]{a^{+}}| \\right \\rceil } .. { \\left \\lfloor |\\sqrt[n]{b}| \\right \\rfloor } ] \\ ] ] where @xmath109 .    [ [ multiplication ] ] multiplication + + + + + + + + + + + + + +    for the remaining operations we only need to explain how to implement the @xmath100 closure of the outcome .",
    "first note that @xmath110 \\cdot [ c .. d ] )    =   [ min(a ) ..",
    "max(a ) ] , \\ ] ] where @xmath111 .",
    "using an appropriate case analysis we can actually compute the bounds of @xmath112 \\cdot [ c .. d])$ ] directly in terms of the bounds of the constituent intervals .",
    "[ [ division ] ] division + + + + + + + +    in contrast , the @xmath100 closure of the interval division is not so straightforward to compute .",
    "the reason is that , as we shall see in a moment , we can not express the result in terms of some simple operations on the interval bounds .",
    "consider non - empty integer intervals @xmath113 $ ] and @xmath102 $ ] . in analyzing the outcome of @xmath114/[c ..",
    "d])$ ] we distinguish the following cases .    _ case 1 .",
    "_ suppose @xmath115 $ ] and @xmath116 $ ] .",
    "then by definition @xmath114/[c .. d ] ) = { \\cal z}$ ] .",
    "for example , @xmath117/[-2 .. 8 ] ) = { \\cal z}.\\ ] ]    _ case 2 .",
    "_ suppose @xmath118 $ ] and @xmath119 .",
    "then by definition @xmath120/[c .. d ] ) = { \\mbox{$\\emptyset$}}$ ] .",
    "for example , @xmath121/[0 .. 0 ] ) = { \\mbox{$\\emptyset$}}.\\ ] ]    _ case 3 .",
    "_ suppose @xmath118 $ ] and @xmath122 and @xmath123 .",
    "it is easy to see that then @xmath124/[c .. d ] ) = [ -e .. e],\\ ] ] where @xmath125 . for example ,",
    "@xmath126/[-2 .. 5 ] ) = [ -100 .. 100].\\ ] ]    _ case 4 .",
    "_ suppose @xmath118 $ ] and either @xmath127 and @xmath128 or @xmath129 and @xmath130 .",
    "then @xmath120/[c .. d ] ) = int([a .. b]/([c .. d ] -   { \\mbox{$\\{{0}\\}$}}))$ ] .",
    "for example @xmath131/[-7 .. 0 ] ) = int([1 .. 100]/[-7 .. -1]).\\ ] ] this allows us to reduce this case to case 5 below .    _ case 5 .",
    "_ suppose @xmath132 $ ] .",
    "this is the only case when we need to compute @xmath120/[c ..",
    "d])$ ] indirectly .",
    "first , observe that we have @xmath133/[c .. d ] ) { \\mbox{$\\:\\subseteq\\:$}}[{\\left \\lceil min(a ) \\right \\rceil } .. { \\left \\lfloor max(a ) \\right \\rfloor}],\\ ] ] where @xmath134 .",
    "however , the equality does not need to hold here . indeed , note for example that @xmath135/[9 .. 11 ] ) = [ 16 .. 16]$ ] , whereas for @xmath136 , @xmath137 we have @xmath138 and @xmath139 .",
    "the problem is that the value 16 is obtained by dividing 160 by 10 and none of these two values is an interval bound .",
    "this complication can be solved by preprocessing the interval @xmath140 $ ] so that its bounds are actual divisors of an element of @xmath57 $ ] .",
    "first , we look for the least @xmath141 $ ] such that @xmath142\\ \\exists u \\in { \\cal z}\\ u\\cdot c ' = x$ ] . using a case analysis ,",
    "the latter property can be established without search .",
    "suppose for example that @xmath143 and @xmath144 . in this case , if @xmath145 , then @xmath146 has the required property .",
    "similarly , we look for the largest @xmath147 $ ] for which an analogous condition holds .",
    "/ [ c .. d ] ) = [ \\lceil\\textit{min\\/}(a)\\rceil .. \\lfloor\\textit{max\\/}(a)\\rfloor]$ ] , where @xmath149 .",
    "[ [ exponentiation ] ] exponentiation + + + + + + + + + + + + + +    the @xmath100 closure of the interval exponentiation is straightforward to implement by distinguishing the following cases .",
    "_ case 1 . _",
    "suppose @xmath106 is odd",
    ". then @xmath133^n ) = [ a^n .. \\ : b ^n].\\ ] ]    _ case 2 .",
    "_ suppose @xmath106 is even and @xmath150 .",
    "then @xmath133^n ) = [ a^n .. \\ : b ^n].\\ ] ]    _ case 3 .",
    "_ suppose @xmath106 is even and @xmath151",
    ". then @xmath133^n ) = [ b^n .. \\ : a^n].\\ ] ]    _ case 4 .",
    "_ suppose @xmath106 is even and @xmath152 and @xmath153",
    ". then @xmath133^n ) = [ 0 ..   max(a^n , b^n ) ] .\\ ] ]      given now an extended arithmetic expression @xmath28 each variable of which ranges over an integer interval , we define @xmath154 as the integer interval or the set @xmath96 obtained by systematically replacing each function symbol by the application of the @xmath100 operation to the corresponding integer set operation .",
    "for example , for the extended arithmetic expression @xmath155{(y^2 \\cdot    z^4)/(x^2 \\cdot u^5)}$ ] of ( [ eq : extended ] ) we have @xmath156{int(int(y^2 ) \\cdot int(z^4))/int(int(x^2 ) \\cdot int(u^5))}),\\ ] ] where @xmath40 ranges over @xmath8 , etc .",
    "the discussion in the previous subsection shows how to compute @xmath154 given an extended arithmetic expression @xmath28 and the integer interval domains of its variables .",
    "the following lemma is crucial for our considerations .",
    "it is a counterpart of the so - called ` fundamental theorem of interval arithmetic ' established in @xcite .",
    "because we deal here with the integer domains an additional assumption is needed to establish the desired conclusion .",
    "[ lem : correctness ] let @xmath28 be an extended arithmetic expression with the variables @xmath157 .",
    "assume that each variable @xmath5 of @xmath28 ranges over an integer interval @xmath158 .",
    "choose @xmath159 for @xmath160 $ ] and denote by @xmath161 the result of replacing in @xmath28 each occurrence of a variable @xmath5 by @xmath162 .",
    "suppose that each subexpression of @xmath161 evaluates to an integer .",
    "then the result of evaluating @xmath161 is an element of @xmath154 .",
    "*  the proof follows by a straightforward induction on the structure of @xmath28 .",
    "even though we focus here on arithmetic constraints on integer intervals , it is helpful to realize that the integer interval arithmetic is also useful to define in a succinct way the well - known rules for constraint propagation for linear constraints . to this end consider first a constraint @xmath163 , where @xmath3 , @xmath164 are non - zero integers , @xmath165 are different variables , and @xmath53 is an integer .",
    "to reason about it we can use the following rule parametrized by @xmath166 $ ] :    _ linear equality _",
    "where    * for @xmath168 @xmath169 * @xmath170 - \\{j\\ } } a_i \\cdot x_i)/a_j\\big{)}.\\ ] ]    note that by virtue of note [ note:1 ] @xmath171 - \\{j\\ } } int(a_i \\cdot d_i))/a_j.\\ ] ]    to see that this rule preserves equivalence suppose that for some @xmath172 we have @xmath173 .",
    "then for @xmath166 $ ] we have @xmath174 - \\{j\\ } } a_i \\cdot d_i)/a_j\\ ] ] which by the correctness lemma [ lem : correctness ] implies that @xmath175 - \\{j\\ } } a_i \\cdot x_i)/a_j\\big{)},\\ ] ] i.e. , @xmath176 .    next , consider a constraint @xmath177 , where @xmath178 and @xmath53 are as above .",
    "to reason about it we can use the following rule parametrized by @xmath166 $ ] :    _ linear inequality",
    "_ @xmath179    where    * for @xmath168 @xmath169 * @xmath180 - \\{j\\ } } a_i \\cdot x_i)/a_j)\\ ] ]    to see that this rule preserves equivalence suppose that for some @xmath172 we have @xmath181 .",
    "then @xmath182 - \\{j\\ } } a_i \\cdot d_i $ ] . by the correctness lemma [ lem : correctness ] @xmath183 - \\{j\\ } } a_i \\cdot d_i \\in int(b - \\sigma_{i \\in [ 1 .. n ] - \\{j\\ } } a_i \\cdot x_i),\\ ] ] so by definition @xmath184 - \\{j\\ } } a_i \\cdot x_i)\\ ] ] and consequently @xmath185 - \\{j\\ } } a_i \\cdot x_i)/a_j\\ ] ] this implies that @xmath176 .",
    "we now move on to a discussion of constraint propagation for the arithmetic constraints on integer intervals . to illustrate the first approach consider the following example .",
    "consider the constraint @xmath186 and the ranges @xmath187 $ ] and @xmath188 $ ] .",
    "we can rewrite it as @xmath189{\\frac{40 + x}{y } } \\right \\rfloor}\\ ] ] since @xmath40 assumes integer values .",
    "the maximum value the expression on the right - hand side can take is @xmath190{140 } \\right \\rfloor}$ ] , so we conclude @xmath191 . by reusing ( [ eq : x3 ] ) ,",
    "now with the information that @xmath192 $ ] , we conclude that the maximum value the expression on the right - hand side of ( [ eq : x3 ] ) can take is actually @xmath190{45 } \\right \\rfloor}$ ] , from which it follows that @xmath193 .    in the case of",
    "@xmath194 we can isolate it by rewriting the original constraint as @xmath195 from which it follows that @xmath196 , since by assumption @xmath197 .",
    "so we could reduce the domain of @xmath40 to @xmath198 $ ] and the domain of @xmath194 to @xmath199 $ ] .",
    "this interval reduction is optimal , since @xmath200 and @xmath201 are both solutions to the original constraint @xmath202 .",
    "more formally , we consider a polynomial constraint @xmath203 where @xmath204 , no monomial @xmath50 is an integer , the power products of the monomials are pairwise different and @xmath53 is an integer .",
    "suppose that @xmath157 are its variables ordered w.r.t .",
    "@xmath41 .",
    "select a non - integer monomial @xmath205 and assume it is of the form @xmath206 where @xmath43 , @xmath207 are different variables ordered w.r.t .",
    "@xmath41 , @xmath45 is a non - zero integer and @xmath46 are positive integers .",
    "so each @xmath208 variable equals to some variable in @xmath209 .",
    "suppose that @xmath210 equals to @xmath211 .",
    "we introduce the following proof rule :    _ polynomial equality _",
    "@xmath212    where    * for @xmath168 @xmath169 * @xmath213{int\\left(({b- \\sigma_{i \\in [ 1 .. m ] - \\{{\\ell}\\ } } m_i})/s\\right)}\\ \\right)\\ ] ] and @xmath214    to see that this rule preserves equivalence choose some @xmath172 .",
    "to simplify the notation , given an extended arithmetic expression @xmath29 denote by @xmath215 the result of evaluating @xmath29 after each occurrence of a variable @xmath5 is replaced by @xmath15 .",
    "suppose that @xmath216 .",
    "then @xmath217 - \\{{\\ell}\\ } } m'_i,\\ ] ] so by the correctness lemma [ lem : correctness ] applied to @xmath218 - \\{{\\ell}\\ } } m'_i$ ] and to @xmath28 @xmath219 - \\{{\\ell}\\ } } m_i)/int(s).\\ ] ] hence @xmath220{int(b- \\sigma_{i \\in [ 1 .. m ] - \\{{\\ell}\\ } } m_i)/int(s)}\\ ] ] and consequently @xmath221{int\\left(({b- \\sigma_{i \\in [ 1 .. m ] - \\{{\\ell}\\ } } m_i})/s\\right)}\\ \\right)\\ ] ] i.e. , @xmath176 .",
    "note that we do not apply @xmath100 to the outcome of the root extraction operation .",
    "for even @xmath222 this means that the second operand of the intersection can be a union of two intervals , instead of a single interval . to see why this is desirable , consider the constraint @xmath223 in the presence of ranges @xmath224 $ ] , @xmath225 $ ] . using the @xmath100 closure of the root extraction",
    "we would not be able to update the lower bound of @xmath40 to 5 .",
    "next , consider a polynomial constraint @xmath226 below we adopt the assumptions and notation used when defining the _ polynomial equality _ rule . to formulate the appropriate rule",
    "we stipulate that for extended arithmetic expressions @xmath28 and @xmath29 @xmath227 with @xmath228 .    to reason about this constraint we use the following rule :    _ polynomial inequality _",
    "@xmath229    where    * for @xmath168 @xmath169 * @xmath230{int\\left(^{\\leq}(b- \\sigma_{i \\in [ 1 .. m ] - \\{{\\ell}\\ } } m_i)/s\\right)}\\ \\right)\\ ] ]    to prove that this rule preserves equivalence choose some @xmath172 .",
    "as above given an extended arithmetic expression @xmath29 we denote by @xmath215 the result of evaluating @xmath29 when each occurrence of a variable @xmath5 in @xmath29 is replaced by @xmath15 .",
    "suppose that @xmath231 .",
    "then @xmath232 - \\{{\\ell}\\ } } m'_i.\\ ] ] by the correctness lemma [ lem : correctness ] @xmath233 - \\{{\\ell}\\ } } m'_i \\in int(b- \\sigma_{i \\in [ 1 .. m ] - \\{{\\ell}\\ } } m_i),\\ ] ] so by definition @xmath234 - \\{{\\ell}\\ } } m_i).\\ ] ] hence by the definition of the division operation on the sets of integers @xmath235 - \\{{\\ell}\\ } } m_i)/int(s)\\ ] ] consequently @xmath220{^{\\leq}int(b- \\sigma_{i \\in [ 1 .. m ] - \\{{\\ell}\\ } } m_i)/int(s)}\\ ] ] this implies that @xmath176 .",
    "note that the set @xmath236 - \\{{\\ell}\\ } } m_i)$ ] is not an interval .",
    "so to properly implement this rule we need to extend the implementation of the division operation discussed in subsection [ subsec : implementation ] to the case when the numerator is an extended interval .",
    "our implementation takes care of this .    in an optimized version of this approach",
    "we simplify the fractions of two polynomials by splitting the division over addition and subtraction and by dividing out common powers of variables and greatest common divisors of the constant factors .",
    "subsequently , fractions whose denominators have identical power products are added .",
    "we used this optimization in the initial example by simplifying @xmath237 to @xmath238 .",
    "the reader may check that without this simplification step we can only deduce that @xmath239 .    to provide details of this optimization , given two monomials @xmath28 and @xmath29",
    ", we denote by @xmath240\\ ] ] the result of performing this simplification operation on @xmath28 and @xmath29 .",
    "for example , @xmath241 $ ] equals @xmath242 , whereas @xmath243 $ ] equals @xmath244 .    in this approach",
    "we assume that the domains of the variables @xmath245 , @xmath246 of @xmath205 do not contain 0 .",
    "( one can easily show that this restriction is necessary here ) . for a monomial @xmath28 involving variables ranging over the integer intervals that do not contain 0 , the set @xmath154 either contains only positive numbers or only negative numbers . in the first case we write @xmath247 and in the second case we write @xmath248 .    the new domain of the variable @xmath211 in the _ polynomial inequality _",
    "rule is defined using two sequences @xmath249 and @xmath250 of extended arithmetic expressions such that @xmath251\\ \\textrm{and}\\      \\frac{m_i'}{s_i ' } = - [ \\frac{m_i}{s } ] \\ \\textrm{for $ i \\in [ 1 .. m]$.}\\ ] ] let @xmath252 - \\{{\\ell}\\ } \\}$ ] and for an extended arithmetic expression @xmath253 let @xmath254 - \\{{\\ell}\\ } \\mid s_i ' = t\\}$ ] .",
    "we denote then by @xmath255 the polynomial @xmath256 .",
    "the new domains are then defined by @xmath257      { ^{\\leq}int\\left ( \\sigma_{t \\in s}\\ \\frac{p_{t}}{t}\\right)}\\ \\right)\\ ] ] if @xmath247 , and by @xmath257      { ^{\\geq}int\\left(\\sigma_{t \\in s}\\ \\frac{p_{t}}{t}\\right)}\\ \\right)\\ ] ] if @xmath248 . here",
    "the @xmath154 notation used in the correctness lemma [ lem : correctness ] is extended to expressions involving the division operator on real intervals in the obvious way .",
    "we define the @xmath100 operator applied to a bounded set of real numbers , as produced by the division and addition operators in the above two expressions for @xmath258 , to denote the smallest interval of real numbers containing that set .",
    "in this approach we limit our attention to a special type of polynomial constraints , namely the ones of the form @xmath259 , where @xmath28 is a polynomial in which each variable occurs _ at most once _ and where @xmath53 is an integer .",
    "we call such a constraint a _ simple polynomial constraint_. by introducing auxiliary variables that are equated with appropriate monomials we can rewrite each polynomial constraint into a sequence of simple polynomial constraints .",
    "this allows us also to compute the integer interval domains of the auxiliary variable from the integer interval domains of the original variables .",
    "we apply then to the simple polynomial constraints the rules introduced in the previous section .    to see that the restriction to simple polynomial constraints can make a difference consider the constraint @xmath260 in presence of the ranges @xmath261 $ ] .",
    "we rewrite it into the sequence @xmath262 where @xmath263 are auxiliary variables , each with the domain @xmath264 $ ] .",
    "it is easy to check that the _ polynomial equality _ rule introduced in the previous section does not yield any domain reduction when applied to the original constraint @xmath265 . in presence of the discussed optimization the domain of @xmath40",
    "gets reduced to @xmath198 $ ] .    however , if we repeatedly apply the _ polynomial equality _",
    "rule to the simple polynomial constraint @xmath266 , we eventually reduce the domain of @xmath267 to the empty set ( since this constraint has no integer solution in the ranges @xmath268 $ ] ) and consequently can conclude that the original constraint @xmath269 has no solution in the ranges @xmath261 $ ] , without performing any search .",
    "in this approach we focus on a small set of ` atomic ' arithmetic constraints .",
    "we call an arithmetic constraint    _ atomic _    if it is in one of the following two forms :    * a linear constraint , * @xmath270 .",
    "it is easy to see that using appropriate transformation rules involving auxiliary variables we can transform each arithmetic constraint to a sequence of atomic arithmetic constraints . in this transformation , as in the second approach , the auxiliary variables are equated with monomials so we can easily compute their domains .",
    "the transformation to atomic constraints can strengthen the reduction .",
    "consider for example the constraint @xmath271 and ranges @xmath272 $ ] , @xmath273 $ ] , and @xmath274 $ ] . the first approach without optimization and the second approach can not find a solution without search . if , as a first step in transforming this constraint into a linear constraint , we introduce an auxiliary variable @xmath275 to replace @xmath276 , we are effectively solving the constraint @xmath277 with the additional range @xmath278 $ ] , resulting in only one duplicate occurrence of a variable instead of two . with variable @xmath275 introduced ( or using the optimized version of the first approach ) constraint propagation alone",
    "finds the solution @xmath279 , @xmath280 , @xmath281 , @xmath282 .",
    "we explained already in section [ sec : intermezzo ] how to reason about linear constraints .",
    "( we omitted there the treatment of the disequalities which is routine . )",
    "next , we focus on the reasoning for the multiplication constraint @xmath283 in presence of the non - empty ranges @xmath284 , @xmath285 and @xmath286 . to this end",
    "we introduce the following three domain reduction rules :    _ multiplication 1 _",
    "@xmath287    _ multiplication 2 _",
    "@xmath288    _ multiplication 3 _",
    "@xmath289    the way we defined the multiplication and the division of the integer intervals ensures that the _ multiplication _ rules _ 1,2 _ and _ 3 _ are equivalence preserving .",
    "consider for example the _ multiplication 2 _ rule .",
    "take some @xmath290 and @xmath291 such that @xmath292",
    ". then @xmath293 , so @xmath294 and a fortiori @xmath295 .",
    "consequently @xmath296 .",
    "this shows that the _ multiplication 2 _ rule is equivalence preserving .",
    "the following example shows an interaction between all three _ multiplication _ rules .",
    "[ exa : mult ] consider the csp @xmath297 , y \\in [ 9 .. 11 ] , z \\in [ 155 .. 161 ] \\rangle}}.\\ ] ]    to facilitate the reading we underline the modified domains .",
    "an application of the _ multiplication 2 _ rule yields @xmath298 } , y \\in [ 9 .. 11 ] , z \\in [ 155 .. 161 ] \\rangle}}\\ ] ] since , as already noted in in subsection [ subsec : implementation ] , @xmath299/[9 .. 11 ] ) = [ 16 .. 16]$ ] , and @xmath300 \\cap int([16 .. 16 ] ) = [ 16 .. 16]$ ] .",
    "applying now the _ multiplication 3 _ rule we obtain @xmath301 , y \\in \\underline{[10 .. 10 ] } , z \\in [ 155 .. 161 ] \\rangle}\\ ] ] since @xmath299/[16 .. 16 ] = [ 10 .. 10]$ ] and @xmath302 \\cap int([10 .. 10 ] ) = [ 10 .. 10]$ ] .",
    "next , by the application of the _ multiplication 1 _ rule we obtain @xmath301 , y \\in [ 10 .. 10 ] , z \\in \\underline{[160 .. 160 ] } \\rangle}\\ ] ] since @xmath303 \\cdot [ 10 .. 10 ] = [ 160 .. 160]$ ] and @xmath299 \\cap int([160 .. 160 ] ) = [ 160 .. 160]$ ] .    so using all three multiplication rules we could solve the csp ( [ eq : example ] ) .",
    "now let us clarify why we did not define the division of the sets of integers @xmath304 and @xmath305 by @xmath306 the reason is that in that case for any set of integers @xmath304 we would have @xmath307 .",
    "consequently , if we adopted this definition of the division of the integer intervals , the resulting _ multiplication _ _ 2 _ and _ 3 _ rules would not be anymore equivalence preserving . indeed , consider the csp @xmath308 , y   \\in [ 0 .. 0],z \\in [ -8 .. 10 ] \\rangle}.\\ ] ] then we would have @xmath309/[0 .. 0 ]   = { \\mbox{$\\emptyset$}}$ ] and consequently by the _ multiplication _ _ 2 _ rule we could conclude @xmath310,z \\in [ -8 .. 10 ] \\rangle}.\\ ] ] so we reached an inconsistent csp while the original csp is consistent .    in the remainder of the paper we will also consider variants of this third approach that allow squaring and exponentiation as atomic constraints . for this purpose",
    "we explain the reasoning for the constraint @xmath311 in presence of the non - empty ranges @xmath284 and @xmath285 , and for @xmath312 . to this end",
    "we introduce the following two rules in which to maintain the property that the domains are intervals we use the @xmath100 operation of section [ sec : interval ] :    _ exponentiation _",
    "_ root extraction _ @xmath314{d_x } ) \\rangle}}\\ ] ]    to prove that these rules are equivalence preserving suppose that for some and @xmath315 we have @xmath316",
    ". then @xmath317 , so @xmath318 and consequently @xmath319 .",
    "also @xmath320{d_x}$ ] , so @xmath321{d_x}$ ] , and consequently @xmath322{d_x})$ ] .",
    "in this section we describe the benchmark experiments that were performed to compare the proposed approaches .",
    "these experiments were performed using a single solver of the dice ( distributed constraint environment ) framework .",
    "dice  @xcite is a framework for solver cooperation , implemented using techniques from coordination programming .",
    "it is developed around an experimental constraint solver , called opensolver , which is particularly suited for coordination .",
    "the coordination and cooperation aspects are irrelevant from the point of view of this paper .",
    "relevant aspects of the opensolver are :    * it implements a branch - and - infer tree search algorithm for constraint solving .",
    "the inference stage corresponds to constraint propagation and is performed by repeated application of domain reduction functions ( drfs ) that correspond to the domain reduction rules associated with the considered constraints .",
    "* this algorithm is abstract in the sense that the actual functionality is determined by software plug - ins in a number of predefined categories .",
    "these categories correspond to various aspects of the abstract branch - and - infer tree search algorithm .",
    "relevant categories are : variable domain types , domain reduction functions , schedulers that control the application of the drfs , branching strategies that split the search tree after constraint propagation has terminated , and several categories corresponding to different aspects of a search strategy that determine how to traverse a search tree .    all experiments were performed using the ` integerinterval ` variable domain type plug - in .",
    "domains of this type consist of an indication of the type of the interval ( bounded , unbounded , left / right - bounded , or empty ) , and a pair of arbitrary precision integer bounds .",
    "this plug - in , and the interval arithmetic operations on it are built using the gnu mp library  @xcite .",
    "the branching strategy that we used selects variables using the chronological ordering in which the auxiliary variables come last .",
    "the domain of the selected variable is split into two subdomains using bisection , so the resulting search trees are binary trees . in all experiments we searched for all solutions , traversing the entire search tree by means of depth - first leftmost - first chronological backtracking .    for the experiments in this paper",
    "a drf plug - in has been developed that implements the domain reduction rules discussed in the previous sections .",
    "the scheduler plug - in used in the benchmarks keeps cycling through the sequence of drfs , applying drfs that have been scheduled for execution . when a drf is applied , and some variable domain is modified , all drfs that depend on these changes are scheduled for execution , including possibly the one that has just been applied .",
    "the cycling stops when no more drfs are scheduled for execution , or when the domain of a variable becomes empty .    as an alternative to cycling",
    ", the scheduler can be supplied with a _ schedule _ : a sequence of indices into the sequence of drfs .",
    "the scheduler will then cycle through this schedule instead , and consider drfs for application in the specified order .",
    "this is used in combination with the second and third approach , where we distinguish _ user _ constraints from the constraints that are introduced to define the values of auxiliary variables . before considering for execution a drf @xmath323 that is part of the implementation of a user constraint , we make sure that all auxiliary variables that @xmath323 relies on are updated . for this purpose , the indices of the drfs that update these variables precede the index of @xmath323 in the schedule .",
    "if @xmath323 can change the value of an auxiliary variable , its index is followed by the indices of the drfs that propagate back these changes to the variables that define the value of this auxiliary variable .    for the third approach , there can be hierarchical dependencies between auxiliary variables .",
    "much like the hc4 algorithm of  @xcite , the schedule specifies a bottom - up traversal of this hierarchy in a forward evaluation phase and a top - down traversal in a backward propagation phase before and after applying a drf of a user constraint , respectively . in the forward evaluation phase ,",
    "the drfs that are executed correspond to rules _ multiplication 1 _ and _ exponentiation_. the drfs of the backward propagation phase correspond to _ multiplication 2 _ and _ 3 _ , and _ root extraction_. it is easy to construct examples showing that the use of hierarchical schedules can be beneficial compared to cycling through the rules .",
    "the proposed approaches were implemented by first rewriting arithmetic constraints to polynomial constraints , and then to a sequence of drfs that correspond with the rules of the approach used .",
    "we considered the following methods :    1a : :    the first approach , discussed in section [ sec : first ] , 1b : :    the optimization of the first approach discussed at the end of section    [ sec : first ] that involves dividing out common powers of variables , 2a : :    the second approach , discussed in section [ sec : second ] .",
    "the conversion    to simple polynomial constraints is implemented by introducing an    auxiliary variable for every non - linear monomial .",
    "this procedure may    introduce more auxiliary variables than necessary .",
    "2b : :    an optimized version of approach 2a , where we stop introducing    auxiliary variables as soon as the constraints contain no more    duplicate occurrences of variables .",
    "3a : :    the third approach , discussed in section [ sec : third ] , allowing only    linear constraints and multiplication as atomic constraints .",
    "3b : :    idem , but also allowing @xmath324 as an atomic constraint .",
    "3c : :    idem , allowing @xmath325 for all @xmath87 as an    atomic constraint .    approaches 2 and 3 involve an extra rewrite step , where the auxiliary variables are introduced .",
    "the resulting csp is then rewritten according to approach 1a . during the first rewrite step the hierarchical relations between the auxiliary variables",
    "are recorded and the schedules are generated as a part of the second rewrite step . for approaches 2b and 3 the question of which auxiliary variables to introduce is an optimization problem in itself .",
    "some choices result in more auxiliary variables than others .",
    "we have not treated this issue as an optimization problem but relied on heuristics .",
    "we are confident that these yield a realistic implementation . in our experiments",
    "we used the following benchmarks .",
    "[ [ cubes ] ] cubes + + + + +    the problem is to find all natural numbers @xmath326 that are a sum of four different cubes , for example @xmath327 this problem is modeled as follows : @xmath328,\\ x_1,x_2,x_3,x_4 \\in { \\cal z }     \\rangle     \\end{array}\\ ] ]    [ [ opt ] ] opt + + +    we are interested in finding a solution to the constraint @xmath329 in the integer interval @xmath330 $ ] for which the value of @xmath331 is maximal .",
    "[ [ fractions ] ] fractions + + + + + + + + +    this problem is taken from  @xcite : find distinct nonzero digits such that the following equation holds : @xmath332 there is a variable for each letter .",
    "the initial domains are @xmath333 $ ] . to avoid symmetric solutions an ordering",
    "is imposed : @xmath334 also two redundant constraints are added : @xmath335 because division is not present in the arithmetic expressions , the above constraints are multiplied by the denominators of the fractions to obtain arithmetic constraints .",
    "two representations for this problem were studied :    * _ fractions1 _ in which five constraints are used : one equality and four inequalities for the ordering and the redundant constraints , * _ fractions2 _ , used in  @xcite , in which three auxiliary variables , @xmath336 and @xmath337 , are introduced to simplify the arithmetic constraints : @xmath338 , @xmath339 , and @xmath340 .    additionally , in both representations , 36 disequalities @xmath341 , @xmath342 , ...",
    ", @xmath343 are used .    [ [ kyoto ] ] kyoto + + + + +    the problem is to find the number @xmath106 such that the alphanumeric equation    [ cols= \" < , < , < , < , < , < \" , ]      +    for the _ cubes _ and _ opt _ problems , the constraints are already in simple form , so approaches 1a , 1b and 2b are identical .",
    "also all non - linear terms involve either a multiplication or an exponentiation , so also approaches 2a and 3c are the same .",
    "the results of these experiments clearly show the disadvantage of implementing exponentiation by means of multiplication : the search space grows because we increase the number of variable occurrences and lose the information that it is the same number that is being multiplied . for _ opt _ and approach 3a",
    ", the run did not complete within reasonable time and was aborted .",
    "columns e and i of table  [ tab - elapsed ] compare the propagation achieved by our approaches with two other systems , respectively ecl@xmath0ps@xmath1 version 5.6ps@xmath1 constraint logic programming system .",
    "see http://www-icparc.doc.ic.ac.uk/eclipse ] using the ic library , and ilog solver 5.1 using type iloint . for this purpose",
    "we ran the test problems without search , and compared the results of constraint propagation .",
    "a mark ` = ' means that the computed domains are the same , ` + ' that our approach achieved stronger propagation than the solver that we compare with , and ` - ' that propagation is weaker . for _ cubes _ , ecl@xmath0ps@xmath1 computes the same domains as those computed according to approach 3b , so here the reduction is stronger than for 3a , but weaker than for the other approaches .",
    "for _ opt _ ecl@xmath0ps@xmath1 and ilog solver compute the same domains .",
    "these domains are narrower than those computed according to approaches 3a and 3b , but the other approaches achieve stronger reduction . in all other cases except for _ kyoto _ and approach 1b the results of all three solvers are the same .    for both representations for the fractions puzzle , the symbolic manipulation of approach 1b is able to achieve a significant reduction of the search tree , but this is not reflected in the timings . for _",
    "fractions1 _ the elapsed time even increases .",
    "the reason is that computing the domain updates involves adding intervals of real numbers .",
    "the arithmetic operations on such intervals are more expensive than their counterparts on integer intervals , because the bounds have to be maintained as rational numbers .",
    "arithmetic operations on rational numbers are more expensive because they involve the computation of greatest common divisors .",
    "for _ kyoto _ the symbolic manipulation did not reduce the size of the search tree , so the effect is even more severe .",
    "in general , the introduction of auxiliary variables leads to a reduction of the number of interval operations compared to approach  1a .",
    "the reason is that auxiliary variables prevent the evaluation of subexpressions that did not change .",
    "this effect is strongest for _ fractions1 _ , where the main constraint contains a large number of different power products . without auxiliary variables",
    "all power products are evaluated for every _ polynomial equality _",
    "rule defined by this constraint , even those power products the variable domains of which did not change . with auxiliary variables the intervals for such unmodified terms are available immediately , which leads to a significant reduction of the number of interval multiplications .",
    "the effect that stronger reduction is achieved as a result of introducing auxiliary variables , mentioned in section  [ sec : third ] , is seen for both representations of the _ fractions _ benchmark .",
    "the effect described in section  [ sec : second ] is not demonstrated by these experiments .    if we do nt consider the symbolic manipulation of approach 1b , approach 3c leads to the smallest total number of interval operations in all cases , but the scheduling mechanism discussed in section  [ sec - experiments ] is essential for a consistent good performance .",
    "if for example the schedule is omitted for _ opt _ , the number of interval operations almost triples , and performance of approach 2a and 3c is then much worse than that of approach 1a .",
    "the total numbers of interval operations in table  [ tab - numbers ] do not fully explain all differences in elapsed times .",
    "one of the reasons is that different interval operations have different costs .",
    "especially the preprocessing of the numerator interval for integer interval division , discussed in subsection  [ subsec : implementation ] , is potentially expensive , which may explain why for _ opt _ , approach 1a runs faster than approach 2a , even though the total number of interval operations is higher . among the many other factors that may be of influence , some overhead is involved in applying a drf , so if the number of applications differs significantly for two experiments , this probably influences the elapsed times as well ( _ cubes _ , 1a , 2a , _ opt _ , 1a , 2a , _ fractions2 _ , 2a , 2b ) .",
    "the elapsed times are not the only measure that is subject to implementation details . for example",
    ", we implemented division by a constant interval @xmath344 $ ] as multiplication by a constant , which is more efficient in our implementation .",
    "such decisions are reflected in the numbers reported in table  [ tab - numbers ] .",
    "in this paper we discussed a number of approaches to constraint propagation for arithmetic constraints on integer intervals . to assess them we implemented them using the dice ( distributed constraint environment ) framework of @xcite , and compared their performance on a number of benchmark problems .",
    "we can conclude that :    * implementation of exponentiation by multiplication gives weak reduction . in our third approach @xmath325",
    "should be an atomic constraint .",
    "* the optimization of the first approach , where common powers of variables are divided out , can significantly reduce the size of the search tree , but the resulting reduction steps rely heavily on the division and addition of rational numbers . these operations can be expected to be more expensive than their integer counterparts , because they involve the computation of greatest common divisors . * introducing auxiliary variables can be beneficial in two ways : it may strengthen the propagation , as discussed in sections  [ sec : second ] and  [ sec : third ] , and it may prevent the evaluation of subexpressions the variable domains of which did not change . * as a result , given a proper scheduling of the rules , the second and third approach perform better than the first approach without the optimization , in terms of numbers of interval operations .",
    "actual performance depends on many implementation aspects .",
    "however for our test problems the results of variants 2a , 2b and 3c do not differ significantly .",
    "in general , our implementation is slow compared to , for example , ilog solver .",
    "a likely cause is that we use arbitrary precision integers .",
    "we chose this representation to avoid having to deal with overflow , but an additional benefit is that large numbers can be represented exactly .    a different approach would be to use floating - point arithmetic and then round intervals inwards to the largest enclosed integer interval .",
    "this was suggested in  @xcite and implemented in for example realpaver .",
    "a benefit of this inward rounding approach is that all algorithms that were developed for constraints on the reals are immediately available .",
    "a disadvantage is that for large numbers no precise representation exists , i.e. , the interval defined by two consecutive floating - point numbers contains more than one integer .",
    "but it is debatable whether an exact representation is required for such large numbers .",
    "we realize that the current set of test problems is rather limited .",
    "in addition to puzzles , some more complex non - linear integer optimization problems should be studied .",
    "we plan to further evaluate the proposed approaches on non - linear integer models for the sat problem .",
    "also we would like to study the relationship with the local consistency notions that have been defined for constraints on the reals and give a proper characterization of the local consistencies computed by our reduction rules .",
    "this work was performed during the first author s stay at the school of computing of the national university of singapore .",
    "the work of the second author was supported by nwo , the netherlands organization for scientific research , under project number 612.069.003 .",
    "f.  benhamou , f.  goualard , l.  granvilliers , and j .- f .",
    "puget . revising hull and box consistency . in _ proceedings of the 16th international conference on logic programming ( iclp99 )",
    "_ , pages 230244 . the mit press , 1999"
  ],
  "abstract_text": [
    "<S> we propose here a number of approaches to implement constraint propagation for arithmetic constraints on integer intervals . to this end </S>",
    "<S> we introduce integer interval arithmetic . </S>",
    "<S> each approach is explained using appropriate proof rules that reduce the variable domains . </S>",
    "<S> we compare these approaches using a set of benchmarks . </S>"
  ]
}