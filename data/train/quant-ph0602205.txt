{
  "article_text": [
    "quantum entanglement is an important resource in many applications of quantum cryptography and quantum communication .",
    "some well - known examples are teleportation @xcite , quantum key distribution @xcite and superdense coding @xcite .",
    "these applications require pure and maximally entangled qubit pairs , called bell state pairs , that are shared by two remote parties .",
    "one party prepares the bell states and sends one qubit to the other party via some quantum channel . in a realistic setting , this channel is not perfect : uncontrollable influences of the environment ( decoherence ) will affect the qubit sent , resulting in qubit pairs that are in a mixed state and unsuitable for the application in mind .",
    "entanglement distillation is the process of applying local operations ( local with respect to the parties ) to the mixed state qubit pairs combined with classical communication ( locc ) in order to obtain pure bell state pairs .",
    "typically , we assume stationarity of the quantum channel , affecting all qubit pairs in the same way . as a result",
    ", we have @xmath0 copies of the same mixed two - qubit state @xmath1 .",
    "protocols like hashing or breeding @xcite have a net output of @xmath2 qubit pairs whose states approach pure bell states if @xmath0 goes to infinity .",
    "we call such protocols _ asymptotic _ and the fraction of distilled bell states per initial copy the _ yield _ @xmath3 . breeding differs from hashing by the use of an initial pool of predistilled bell state pairs , but",
    "these protocols are known to be equivalent .",
    "the classical communication between the parties in both hashing and breeding is only in one direction . with two - way communication , higher yields",
    "can be achieved @xcite .",
    "indeed , the two parties can choose between alternative courses of the protocol based on information on intermediate stages .",
    "we call such a protocol _ adaptive_.    entanglement distillation protocols , apart from being necessary for applications , are also interesting for theoretical purposes .",
    "the important entanglement measure _ entanglement of distillation _ of @xmath1 is defined as the maximal asymptotic yield .",
    "it is lower bounded by the yields of all distillation protocols and in itself a lower bound for all sensible measures of entanglement @xcite .",
    "therefore , significantly improving distillation protocols brings us closer to a better understanding of the irreversible nature of entanglement manipulation .",
    "our protocol is based on the breeding protocol , with the incorporation of two - way communication . until recently , the breeding or hashing protocol were the only existing asymptotic protocols , apart from the slightly better performing variant of ref .",
    "adaptive upgrades of breeding / hashing mostly consist of breeding / hashing preceded by non - asymptotic recurrence - like schemes , resulting in higher yields only for low - fidelity states @xcite .",
    "also the adaptive protocols of ref .",
    "@xcite violate all kinds of one - way communication quantum error correction bounds , yet asymptotically do not perform any better than breeding / hashing . but vollbrecht and verstraete @xcite came up with protocols that introduce two - way communication on an asymptotic level , improving breeding / hashing for all states .",
    "however , their protocols are rather ad hoc : further improvements are suggested by exhaustive searches over a rather untransparent decision space .",
    "we will explain the principles that are at the basis of the improvements and create new protocols that , by exploiting these ideas , outperform all existing schemes significantly .",
    "like all protocols mentioned , our protocols work for copies of a state @xmath1 that is diagonal in the bell - basis , also called _ bell - diagonal_. if @xmath1 is not bell - diagonal , separate optimal single - copy distillation protocols can be applied to each copy to make them bell - diagonal @xcite .",
    "a nice feature of bell - diagonal states is that they can be entirely interpreted in classical information theory . indeed , the state @xmath4 is equivalent to a statistical ensemble of tensor products of bell states . in the breeding protocol ,",
    "information on @xmath4 is gathered from measurements on the bell state pairs ( ebits ) of the initial pool , after letting them locally interact with @xmath4 .",
    "one bit of information is gained for every ebit measurement , or equivalently , the entropy of @xmath4 is reduced by one bit . when the entropy of @xmath4 is reduced to zero , the ensemble has become a pure tensor product of bell states . as will be explained in sec .",
    "[ secbreed ] , breeding can be divided into successive stages of partial information extraction , yielding an equivalent protocol .",
    "the basic principle of our protocol is at every stage to replace measurements on ebits by measurements on a finite number of copies , whenever there are two equiprobable outcomes .",
    "it can be verified that the entropy of the global state is then reduced by more than one bit .",
    "this is because whenever an observable is measured , the state is projected onto the eigenspace of the observable , thereby eliminating the entropy associated with the outcomes of observables not commuting with the one measured .",
    "we will explain how our protocol is organized as to have as many replacements as possible .",
    "this paper is organized as follows . in the preliminary section  [ secprel ] ,",
    "an overview is given of the binary language in which our protocols are efficiently described .",
    "we also explain the two relevant ways of extracting information on an unknown tensor product of bell states . in sec .",
    "[ secbreed ] , we briefly explain the breeding protocol , partial breeding and the improvement of ref .  @xcite . in sec .",
    "[ secentred ] we elaborate on the principle of _ entropy reduction _ , on which our protocol is mainly based .",
    "the way equiprobable outcomes are forced and other ideas simplifying our protocols are then described in sec .",
    "[ secprotocol ] .",
    "we also give a method for numerically calculating the yield .",
    "this is finally illustrated for werner states in sec .",
    "[ secwerner ] .",
    "we conclude in sec .",
    "[ secconclusion ] .",
    "in this section we give a short overview of the binary language in which distillation protocols are often expressed . for a detailed discussion and proofs of these results",
    "we refer to refs .",
    "@xcite .",
    "bell states can be represented by assigning two - bit vectors to the bell states as follows @xmath5 we consider all bell states shared by two parties @xmath6 and @xmath7 . in the following , all `` local '' operations are local with respect to the partition into @xmath6 and @xmath7 . in an analogous way ,",
    "the pauli matrices are identified with two - bit vectors : @xmath8 & = & \\sigma_{00 } \\\\",
    "\\sigma_x & = & \\left[\\begin{array}{rr}0&1\\\\1&0\\end{array}\\right ] & = & \\sigma_{01 } \\\\",
    "\\sigma_z & = & \\left[\\begin{array}{rr}1&0\\\\0&-1\\end{array}\\right ] & = & \\sigma_{10 } \\\\",
    "\\sigma_y & = & \\left[\\begin{array}{rr}0&-i\\\\i&0\\end{array}\\right ] & = & \\sigma_{11}. \\end{array}\\ ] ] for notational convenience , we will often denote a binary vector by a string ( e.g. 1010 means @xmath9^t$ ] ) . a tensor product of @xmath0 bell states",
    "can then be described by a @xmath10-bit vector , e.g. @xmath11 .",
    "the same rule applies for a kronecker product of pauli matrices .",
    "the _ pauli group _ is defined to contain all kronecker products of pauli matrices with an additional complex phase factor in @xmath12 , called pauli operators . in the following",
    ", we will only consider hermitian pauli operators and neglect overall phase factors .    for all @xmath13 ,",
    "the following relations hold : @xmath14 where `` @xmath15 '' denotes equality up to an overall phase factor @xcite .",
    "all addition of binary objects is done modulo 2 .",
    "two pauli operators @xmath16 and @xmath17 commute if the _ symplectic inner product _",
    "@xmath18 is equal to zero , or @xmath19.\\ ] ]    a clifford operator @xmath20 maps the pauli group to itself under conjugation , and can be represented by a symplectic matrix @xmath21 : @xmath22 symplecticity of @xmath23 is expressed by @xmath24 . in the context of distillation protocols , we have the following interesting result @xcite : let @xmath20 be represented by @xmath23 and @xmath25 be the complex conjugate of @xmath20 , then it holds : @xmath26      information on an unknown tensor product of @xmath0 bell states @xmath27 , in the context of distillation protocols , is extracted under the form of an inner product @xmath28 , where @xmath29 is an arbitrary nonzero @xmath10-bit vector .",
    "we will call this action a _ parity check_. this can be done in two ways :    1 .   by local clifford operations on the tensor product and an appended ebit @xmath30 , followed by the local measurement of the ebit ; 2 .   by directly performing local measurements on @xmath31 .",
    "we explain the two ways in more detail , and call them _ appended ebit measurement _ ( aem ) and _ bilateral pauli measurement _ ( bpm ) respectively .    by means of local clifford operations ( [ lc ] ) , we first transform @xmath30 into @xmath32 .",
    "the symplectic matrix @xmath23 that corresponds to this action is @xmath33.\\ ] ] then , a @xmath34 measurement is performed on both sides of the appended ebit .",
    "the product of the outcomes is equal to @xmath35 .",
    "indeed , the outcomes of a @xmath36 measurement performed locally on an ebit correlate as follows : @xmath37 it follows that the product of the outcomes of a bilateral ( i.e. on both sides ) measurement @xmath38 on a tensor product of bell states @xmath39 equals @xmath40.\\ ] ]    an aem does not affect the state @xmath31 .",
    "therefore , this procedure can be repeated consecutively for different @xmath29 , like in the breeding protocol .",
    "however , the same does not hold for a bpm . because our protocol will consist of both methods in various combinations , we need to sort out how this can be done . in ref .",
    "@xcite , we showed that , in theory , a bpm is equivalent to the following procedure :    1 .",
    "perform local clifford operations ( [ lc ] ) that correspond to a symplectic @xmath23 of which the last row is @xmath41 : such a @xmath23 can always be found , for every @xmath42 ; 2 .   then , perform a bilateral @xmath34 measurement on the last qubit pair ; 3 .",
    "finally , apply the inverse of the local clifford operations of the first step .",
    "note that the result is no longer a tensor product of bell states , as the last of the qubit pairs is measured in the second step , leaving it in a separable state .",
    "since an aem leaves the state @xmath31 unaffected , we only need to worry about the situation after a bpm .",
    "the only irreversible step applied is the measurement of the last qubit pair , which yields knowledge of @xmath28 but destroys any other information contained by this pair . after this step ,",
    "we are left with the state @xmath43 , where @xmath44 is equal to @xmath23 without the last two rows .",
    "the only information on @xmath31 left for us to extract is the information we can extract from @xmath43 .",
    "clearly , we can perform parity checks yielding @xmath45 , for all @xmath46 .",
    "this is equivalent to determining @xmath47 , for all @xmath48 that satisfy @xmath49 . indeed , as @xmath23 is symplectic , all such @xmath50 are in the column space of @xmath51 $ ] , or @xmath52 , for some @xmath46 and @xmath53 .",
    "since @xmath28 was already determined , we know @xmath54 by determining @xmath45 from the new state .",
    "in general , every time we determine @xmath28 of @xmath31 by a bpm , afterwards we can only access @xmath47 where @xmath49 , whatever method we use .",
    "this should not come as a surprise , because when @xmath55 , the pauli measurements @xmath38 and @xmath56 anticommute , so their outcomes can not be determined both .    in reality , after a bpm , we should continue working with the transformed state represented by @xmath57 .",
    "but this requires knowledge of the whole matrix @xmath23 , while the parity check is specified only by @xmath29 .",
    "as explained in the previous paragraph , we can describe all future actions in terms of @xmath58 : we only need to know which bpm have been done .",
    "this yields a much more transparent description of the procotol .",
    "in this section , we start by briefly explaining the breeding protocol , which was introduced in ref .  @xcite .",
    "basicly , information on @xmath0 copies of a bell - diagonal mixed state is extracted sacrificing ebits until the state is a pure tensor product of @xmath0 bell states ( i.e. zero entropy ) .",
    "we show then how the breeding protocol can be divided into successive stages of _ partial information extraction _ , yielding an equivalent protocol . depending on the outcome of one such stage ,",
    "a different strategy can be applied , yielding a protocol that uses two - way communication .",
    "we call such a protocol _ adaptive _ , as it adapts to intermediate outcomes",
    ". we will explain an improvement of the breeding protocol that has been found in this way by vollbrecht and verstraete  @xcite .",
    "for details , we refer to refs .",
    "@xcite .",
    "the breeding protocol starts from @xmath0 copies of a bell - diagonal mixed state @xmath59 the global state @xmath4 is equivalent to a statistical ensemble of pure states @xmath27 , with corresponding probabilities @xmath60 ( e.g. @xmath61 ) .",
    "consequently , the state can be regarded as an unknown pure state @xmath31 .",
    "the goal now is to determine @xmath58 .",
    "once we have pinned down @xmath31 , we can transform the state to @xmath62 by performing the unitary transformation @xmath63 on the @xmath7 side . with probability approaching 1 for large @xmath0 ,",
    "this unknown @xmath58 is contained in the _ typical set _ @xmath64 that has @xmath65 elements @xcite , where @xmath66 consecutive parity checks @xmath28 , where all @xmath29 are random , each on average rule out half of @xmath64 .",
    "consequently , to obtain zero entropy ( i.e. only one candidate left ) , about @xmath67 aem are needed , each at the cost of one ebit .",
    "therefore , the yield of the protocol , which is the number of ebits that are distilled for every copy , is equal to @xmath68 .",
    "partial information on @xmath58 is extracted by restricting to parity checks @xmath28 , where @xmath29 is of the form @xmath69 @xmath70 is some fixed and finite @xmath2-bit vector ( @xmath2 is even and divides @xmath10 ) and random @xmath71 take over the role of @xmath29 .",
    "we will call this technique _ partial breeding_. note that it is completely specified by @xmath70",
    ". therefore we will denote it by pb @xmath70 .",
    "we illustrate how partial breeding works with an example .",
    "let @xmath72 , and divide @xmath58 into vectors of @xmath73 bits ( i.e. @xmath74 pairs ) .",
    "every such @xmath2-bit vector @xmath75 is either an element of @xmath76 , if @xmath77 , or of @xmath78 , if @xmath79 .",
    "for this example , we have @xmath80 we have for instance @xmath81 in the same way as for breeding , a typical set can be associated with the distribution of @xmath76 and @xmath78 .",
    "this set has @xmath82 elements , where @xmath83 therefore , we need @xmath84 aem to determine @xmath85 for all m - bit vectors @xmath75 constituting @xmath58 , with probability close to 1 . for this example , we have @xmath86    we have considered partial information extraction on a sequence of identically and independently distributed random variables over the set @xmath87 .",
    "but the same idea can also be applied to the sets @xmath76 and @xmath78 . once we have carried out the previous pb step , we know for every 4-bit vector ( 2 pairs ) , whether it is in @xmath76 or @xmath78 .",
    "if we bring all vectors in @xmath76 together , again we have i.i.d .",
    "random variables over @xmath76 , and again we could perform partial breeding , this time for instance pb @xmath88 . combining this with for instance pb @xmath89 for @xmath78 , we get to know for every 4 bits in which of the following sets they are : @xmath90 it can be verified that the total number of aem needed in the first and second pb step of this example is equal to @xmath91 which is exactly the entropy that is associated with the partition into @xmath92 times the number of 4-bit vectors in @xmath58 .",
    "this is a consequence of the fact that @xcite @xmath93 so it is of no importance how a certain situation is attained , the number of aem (= the cost in ebits ) always equals the total information gain .",
    "we can continue performing pb steps in this way until all sets considered are singletons .",
    "we then have determined @xmath58 completely , at the cost of @xmath67 ebits .",
    "of course , there is no point in dividing the breeding protocol in successive stages of partial breeding . in ref .",
    "@xcite , @xmath76 pairs are further purified by breeding , but the @xmath78 pairs are treated differently : on the first pair of every @xmath78 state , a bpm @xmath94 is performed , yielding the parity @xmath94 of this pair .",
    "as the pair is measured , it is lost , but the measurement also provides information on the second pair .",
    "this one is in @xmath95 if the outcome was @xmath96 and in @xmath97 if the outcome was @xmath98 .",
    "so in both cases , we end up with a rank two bell - diagonal state , for which it has been proved that the breeding protocol is optimal @xcite .",
    "the yield of this protocol is calculated in ref .",
    "@xcite , and turns out to be greater than that of breeding .",
    "but the reason why this necessarily must be so , remains obscure .",
    "we will shed light to this issue in the next section .",
    "the reason why the protocol of ref .  @xcite outperforms the breeding protocol , lies in the difference between an aem and a bpm .",
    "if a parity check is performed on a finite number @xmath99 of pairs , represented by an ensemble of vectors @xmath100 , the resulting state will have lower entropy by a bpm than by an aem .",
    "next to extracting information under the form of the parity , a bpm results in the mapping of different vectors to the same new vector , resulting in an extra entropy reduction .    to see this , we recall the procedure to carry out a bpm explained in sec .",
    "[ secinfoex ] . if @xmath85 is the parity we would like to know , we first perform local cliffords represented by a symplectic @xmath101 of which the last row is @xmath102 , followed by a bilateral @xmath34 measurement on the last pair .",
    "this results in a new state ( with one pair less ) represented by @xmath103 . by the measurement",
    ", we learn @xmath85 , but we also lose @xmath104 , where @xmath105 is the second last row of @xmath23 .",
    "this loss causes all @xmath75 with the same result @xmath103 and outcome @xmath85 to be mapped to the same vector @xmath103 .",
    "note that the outcomes should be equal as well , otherwise one of the two is ruled out . from the symplecticity of @xmath23 , it follows that @xmath75 and @xmath106 are mapped together .",
    "indeed , @xmath107 and @xmath108 .",
    "consequently , the new state is represented by the ensemble of vectors @xmath103 , with probabilities @xmath109 .",
    "this addition of probabilities results in the extra entropy reduction .",
    "let us illustrate this with an example .",
    "we have two pairs represented by an ensemble of 4-bit vectors and we perform a bpm @xmath110 . we are left with only one pair represented by an ensemble of 2-bit vectors .",
    "the probabilities are @xmath111 if the outcome is @xmath96 , and @xmath112 if the outcome is @xmath98 .",
    "note that we do not identify these probabilities with the two - bit vectors @xmath103 : all future actions are described entirely in terms of the original vectors @xmath75 , as explained in sec .  [ secinfoex ] .",
    "if we would have used an aem , then we would still have two pairs , but represented only by 8 vectors instead of 16 , with probabilities @xmath113 if the outcome is @xmath96 , and @xmath114 if the outcome is @xmath98 .",
    "the average difference in entropy is equal to @xmath115 and is always positive .",
    "indeed , for all @xmath116 , we have : @xmath117 + [ ( x+y)\\log_2(x+y ) ] \\\\ = ( x+y)h(\\frac{x}{x+y},\\frac{y}{x+y } ) ,   \\end{array}\\ ] ] where @xmath118 is the binary entropy function , plotted in fig .",
    "[ h ] .",
    "the binary entropy function @xmath119.,scaledwidth=45.0% ]    this plot shows that the entropy reduction , given by the right hand side of eq .",
    "( [ hred ] ) , is larger the more the colliding vectors @xmath75 and @xmath106 are equiprobable .",
    "if one probability relative to the other becomes small , the entropy reduction vanishes .",
    "that is the reason why the hashing protocol @xcite , which is the same as breeding but the parity checks are bpm instead of aem , has the same yield as the breeding protocol : again , we use the fact that almost all weight comes from vectors @xmath120 . since the @xmath29 are completely random , so are @xmath121 .",
    "therefore , the probabilities @xmath122 of @xmath121 are infinitesimal ( as @xmath0 is large ) compared to the probabilities @xmath123 of @xmath58 @xcite .",
    "a variant of hashing @xcite , where some of the bpm are on a finite number of copies resulting in a nonzero entropy reduction , performs slightly better than hashing .",
    "it is clear that we should focus on bpm on small numbers of copies , because there lies the benefit of the entropy reduction .",
    "however , up till now , we have only spoken of the information gain , but we also have to take the cost into account .",
    "pb requires aem , each at the cost of one ebit , whereas a bpm is at the cost of one of the copies .",
    "but as in the end all non - measured copies will be pure bell states , this will not make the difference . by construction",
    ", every aem in pb has equiprobable outcomes , and therefore yields one bit of information .",
    "the same does hold for a bpm if @xmath29 has infinite length and is random . indeed , hashing is equivalent to breeding .",
    "but if we are to perform small non - random parity checks , the outcomes are not necessarily equiprobable and therefore yield less than one bit of information . if the outcomes are equiprobable , improvement is guaranteed .",
    "note that the bpm @xmath94 on the first pair of two @xmath78 pairs does have equiprobable outcomes , which explains the improvement of ref .",
    "@xcite over breeding .",
    "so in some way , we should try to spot as many finite equiprobable parity checks as possible and carry them out by bpm .",
    "in the following , we will denote the all - zeros @xmath2-bit vector by @xmath124 and the all - ones vector by @xmath125 . for any binary vector @xmath100",
    ", we will denote @xmath126 by @xmath127 . whenever a parity check @xmath128 has been performed on @xmath99 qubit pairs with outcome @xmath53 ( we will call @xmath129 the outcome instead of @xmath130 )",
    ", we will denote the resulting state by @xmath131 $ ] if the parity check was a bpm and by @xmath132 otherwise .",
    "recall from sec .",
    "[ secentred ] that the probabilities of @xmath131 $ ] are ( up to normalization ) @xmath133 , whereas the probabilities of @xmath132 are @xmath134 , where in both cases all @xmath75 satisfy @xmath135 .",
    "learning the parity of a number of qubit pairs by partial breeding or bpm causes statistical dependence of the pairs involved , which makes the continuation of the protocol very complicated .",
    "however , this statistical dependence can be undone , which we refer to as _",
    "decoupling_. the idea of decoupling is best explained by an example .",
    "suppose by pb @xmath110 , we learn for every two copies of a bell - diagonal qubit pair its state @xmath136 .",
    "where the states of the copies were independent before , this obviously no longer holds afterwards .",
    "but if next we perform pb @xmath137 on all first pairs , yielding for a particular first pair its state @xmath138 , where the state of both pairs was @xmath136 , we now have two independent pairs @xmath138 and @xmath139 .",
    "indeed , we have learned the parities @xmath140 and @xmath141 , which is equivalent to knowing @xmath141 and @xmath142 , or @xmath137 for both pairs .",
    "so where the first pb coupled the ensembles of the two pairs , the second decoupled them again .",
    "the same does hold for pb @xmath140 followed by bpm @xmath143 on the first pair .",
    "this is equivalent to bpm @xmath143 on the first pair and pb @xmath144 on the second pair . and",
    "it can be verified that bpm @xmath140 followed by bpm @xmath143 on the first pair is equivalent to bpm @xmath143 on the first pair and bpm @xmath144 on the second pair .",
    "this idea was also used in the adaptive stabilizer code formalism of ref .",
    "@xcite .",
    "however , this decoupling rule does not hold for bpm followed by pb .",
    "once we have carried out a bpm on a number of qubit pairs , we have statistical dependence not only by the knowledge of the overall parity , but also by the mapping together of vectors as explained in sec .",
    "[ secentred ] .",
    "it is this dependence that we denote by square brackets . although the knowledge on the parities decouples by pb , this mapping does not . as an example , let bpm @xmath110 followed by pb @xmath145 have outcome 0 and 1 on two particular pairs respectively .",
    "the resulting state of the pairs is @xmath146 $ ] and has probabilities : @xmath147 therefore , once a bpm is carried out on a number of qubit pairs , we have to take it into account until it is later decoupled by a bpm on some of the qubit pairs .",
    "we summarize all scenarios ( the parity check on @xmath148 is always @xmath149 ) : @xmath150\\alpha^{(m ) } \\\\   & & \\rightarrow 1 : & [ 1^{(m)}]\\bar{\\alpha}^{(m ) } \\end{array}\\ ] ] if the considered state was connected to others by previous bpm , like in @xmath151 $ ] , the state transforms as follows : @xmath152 & \\rightarrow 0 : & [ x~0^{(m)}\\alpha^{(m)}~y ] \\\\   & & \\rightarrow 1 : & [ x~1^{(m)}\\bar{\\alpha}^{(m)}~y ] \\\\ \\hline \\fbox{bpm } & [ x~\\alpha^{(2m)}~y ] & \\rightarrow 0 : & [ 0^{(m)}][x~\\alpha^{(m)}~y ] \\\\   & & \\rightarrow 1 : & [ 1^{(m)}][x~\\bar{\\alpha}^{(m)}~y ] \\end{array}\\ ] ]    note that decoupling is nothing more than linearity of parity checks . whenever we have performed a number of parity checks ,",
    "these generate a space of parity checks .",
    "any generating set of this space is equivalent to the original set of parity checks .",
    "e.g. @xmath153 is equivalent to @xmath154 .",
    "we will use decoupling parity checks because they result in a transparent distillation protocol .      in sec .",
    "[ secinfoex ] , we showed that , once we have performed a bpm , we have to make sure that all following parity checks commute with it .",
    "there is a way in which this is automatically achieved .",
    "all vectors of the form @xmath155 commute ( we could also have taken @xmath156 or @xmath94 ) . indeed , for all @xmath10-bit vectors @xmath157 , it holds : @xmath158\\right)^t\\left(i_n\\otimes\\left[\\begin{array}{cc}0&1\\\\1&0\\end{array}\\right]\\right)\\left(y\\otimes\\left[\\begin{array}{c}1\\\\1\\end{array}\\right]\\right)=0.\\ ] ] therefore , if we stick to parity checks of this form , we do not have to care about commutability any more . in this way , for every qubit pair we can find out whether it is @xmath159 or @xmath160 .",
    "for now , let us assume we go up to this point but not further : we want to find an optimal way of reaching the point where every pair is determined as @xmath159 or @xmath160 .",
    "whenever we spot parity checks with equiprobable outcomes , we should perform it by bpm .",
    "we will now explain how to do this .",
    "suppose we have @xmath2 qubit pairs , determined as @xmath161 by a previous parity check @xmath162 .",
    "then the parity check @xmath149 has equiprobable outcomes .",
    "indeed , it holds that @xmath163 clearly , both possibilities have the same initial probability @xmath164 or @xmath165 after normalization . therefore , performing the parity check @xmath128 on the left half yields the parities of both halfs and this information equals one bit . by performing a bpm",
    ", we have the extra entropy reduction .",
    "furthermore , this bpm decouples the two halves of the state .    however , if the @xmath2 pairs are @xmath166 we do not have equiprobable possibilities . with a little trick ,",
    "we still are able to force an equiprobable outcome parity check . two states of this kind can be written as @xmath167 with an extra pb @xmath168 , we can distinguish the first two possibilities from the last two ( as indicated by the line ) .",
    "if the outcome is 1 , again we have two equiprobable possibilities @xmath169 and @xmath170 , that are separated by a bpm @xmath128 on one of the four @xmath2-bit vectors .",
    "if the outcome is 0 , the possibilities are not equiprobable , but again we can bring two of these results together , with possibilities @xmath171 and performing pb @xmath172 separating the possibilities as indicated by the line , and so forth .",
    "clearly , this trick can be repeated endlessly .",
    "we calculate the average fraction @xmath173 of @xmath174 on half of which a bpm @xmath128 is performed ( note that @xmath175 ) .",
    "the procedure explained in the previous paragraph is recursive : at each step , we combine two random variables with two possible values @xmath176 and @xmath177 ( @xmath178 )",
    ". the variables of the next step are @xmath179 and @xmath180 , and so on .",
    "therefore , it is possible to calculate @xmath173 in a recursive way . let @xmath181 be the probability to reach the situation under consideration and @xmath182 the total number of @xmath174 involved in the present step .",
    "initially , we have @xmath183 from the procedure explained in the previous paragraph , we have the following recursion relation : @xmath184 at each step , we have a probability @xmath185 that one of the @xmath2-bit vectors involved is detemined by bpm .",
    "so each step yields another fraction @xmath186 of @xmath174 on half of which a bpm is performed .",
    "it can be verified that the total sum of these fractions over all steps is equal to @xmath187 in practice , it suffices to truncate the procedure after a few steps , since the terms in the summation of eq .",
    "( [ f ] ) decrease exponentially fast .",
    "the protocol starts with pb @xmath188 .",
    "the next step is an iteration of the procedure explained in sec .",
    "[ secequi ] , for @xmath189 , where we use the update rules ( [ up1 ] ) and ( [ up2 ] ) . for",
    "now , we will treat all @xmath174 in the same way , i.e. we do not favour particular states being parity checked by bpm . as a consequence",
    ", every @xmath174 has the same probability @xmath173 of undergoing a bpm @xmath149 .",
    "we find that , from one step to the next , the states transform as follows : @xmath1900^{(m ) } & \\eta(0^{(2m)})/2 \\\\   & \\rightarrow & [ 1^{(m)}]1^{(m ) } & \\eta(0^{(2m)})/2 \\\\   & \\rightarrow & 0^{(m)}0^{(m ) } & \\frac{p_{0^{(m)}}^2}{p_{0^{(m)}}^2+p_{1^{(m)}}^2}-\\frac{\\eta(0^{(2m)})}{2 } \\\\   & \\rightarrow & 1^{(m)}1^{(m ) } & \\frac{p_{1^{(m)}}^2}{p_{0^{(m)}}^2+p_{1^{(m)}}^2}-\\frac{\\eta(0^{(2m)})}{2 } \\\\",
    "\\hline 1^{(2 m ) } & \\rightarrow & [ 0^{(m)}]1^{(m ) } & 1/2 \\\\   & \\rightarrow & [ 1^{(m)}]0^{(m ) } & 1/2 \\end{array}\\ ] ] with these rules , we are able to calculate the frequencies ( i.e. the expected number of occurrences per @xmath191 qubit pairs ) of all possibilities from one step to the next . after the last step ,",
    "we are left only with @xmath159 and @xmath160 pairs , in various combinations of bpm ( denoted by square brackets ) . within square brackets , permutations of pairs",
    "yield equivalent states .",
    "therefore , we do not have to calculate the frequencies of all possibilities , but only up to a permutation of the pairs : between square brackets , only the number @xmath192 of @xmath174 and @xmath193 of @xmath161 matter .",
    "we denote this by @xmath194 $ ] .",
    "the possibilities in the end are then : @xmath195 with frequencies @xmath196),\\ldots , f([0,2^{q}])$ ] .",
    "note that these must satisfy @xmath197 where we define @xmath198 and @xmath199 . by partial breeding alone ,",
    "@xmath200 ebits would have been sacrificed .",
    "now , for every bpm , we have one ebit less that has been measured .",
    "therefore , the total cost of ebits per qubit pair up to this point equals @xmath201 } f([n_0,n_1 ] ) .\\ ] ]    but the protocol is not finished yet .",
    "breeding is optimal for the pairs that have never been involved in some bpm , as they are independent rank two bell diagonal states @xcite .",
    "we show that breeding is optimal for all pairs .",
    "although equiprobable parity checks can still be found , they will no longer result in an entropy reduction if carried out by a bpm .",
    "indeed , all further parity checks @xmath70 must be entirely built of @xmath156 and @xmath94 , because for every pair we already know the parity @xmath137 .",
    "therefore , @xmath202 too is built of @xmath156 and @xmath94 .",
    "since every pair is either @xmath203 or @xmath204 , the mapping of vectors vanishes : one of the two vectors mapped to the same new vector has already been ruled out by the parity checks , because @xmath205 .",
    "deprived of the benefit of entropy reduction by bpm , the best thing left is to gain one bit of information for every measurement .",
    "the number of ebits needed per qubit pair equals the entropy per pair @xmath206 left in the overall state .",
    "it can be verified that @xmath207 ) & = & -\\frac{1}{2}\\sum\\limits_{i=0}^{n_0}\\sum\\limits_{j=0}^{n_1 } { n_0 \\choose i}{n_1 \\choose j } p(i , j)\\log_2 p(i , j),\\end{aligned}\\ ] ] @xmath208{cl } \\mbox{where } & \\begin{array}[t]{ccc } q_{00}=\\frac{p_{00}}{p_{00}+p_{11 } } , & \\qquad & q_{11}=\\frac{p_{11}}{p_{00}+p_{11 } } , \\\\",
    "q_{01}=\\frac{p_{01}}{p_{01}+p_{10 } } , & \\qquad & q_{10}=\\frac{p_{10}}{p_{01}+p_{10 } } , \\end{array } \\\\",
    "& p(i , j)=q_{00}^i q_{11}^{n_0-i } q_{01}^j q_{10}^{n_1-j}+q_{00}^{n_0-i } q_{11}^i q_{01}^{n_1-j } q_{10}^j .",
    "\\end{array}\\ ] ] now all non - measured qubit pairs are pure ebits .",
    "the fraction of non - measured pairs equals @xmath209}f([n_0,n_1]).\\ ] ] if we substract the total number of measured ebits , which is the sum of ( [ ebits1 ] ) and ( [ ebits2 ] ) , from this value ( [ nonmeas ] ) , we get the yield of the protocol : @xmath210      it can be verified that the entropy reduction is larger for a bpm on a small number of pairs than on a large number of pairs . in the first version of our protocol , we did not make use of this , since all @xmath174 were treated equally .",
    "so there is still room for improvement . as an example , consider the following situation : @xmath211[*****]\\ ] ] where all `` @xmath212 '' are either @xmath213 or @xmath214 , and a parity check @xmath128 on one of them ( with equiprobable outcomes ) determines them all .",
    "then it is better to do a bpm on one of the first three , resulting in @xmath215[**][*****]\\ ] ] than on one of the last five , resulting in @xmath211[*][****].\\ ] ] indeed , it can be verified that @xmath216)-s([**])$ ] is larger than @xmath217)-s([****])$ ] .",
    "we show how to increase the number of bpm on small numbers of pairs . at each step",
    ", we have @xmath174 and @xmath161 , distributed over all possibilities .",
    "we carry out bpm @xmath149 on all @xmath161 , so there the situation remains the same .",
    "but the same can not be done for all @xmath174 : there the ones that are linked by bpm ( i.e. in square brackets ) to a small number of pairs , should be taken first . every @xmath174 is part of some state @xmath6 , where @xmath192 is nonzero .",
    "we now order all possibilities @xmath194 $ ] according to increasing @xmath218 and on a second level according to increasing @xmath192 .",
    "so for example @xmath219<[6,2]<[4,5]$ ] .",
    "we favour small @xmath192 on a second level because all @xmath161 will be certainly reduced , on average resulting in smaller @xmath192 and @xmath193 in the end .",
    "we also define that all @xmath194<0^{(2m)}$ ]",
    ". probably better orderings can be found , but we do not want to complicate things further .",
    "we define @xmath220 and @xmath221 with the same formula but `` @xmath222 '' replaced by `` @xmath223 '' . @xmath224 and @xmath221 are the fractions of all @xmath174 that are part of some @xmath225 and @xmath226 respectively .",
    "note that @xmath227)=0 $ ] and @xmath228 .",
    "we combine the @xmath174 for the procedure explained in sec .",
    "[ secequi ] as follows : first we divide all @xmath174 in two equally large sets ( i.e. both sets contain @xmath229 elements ) : every @xmath174 of the first set is part of some @xmath230 that of every element of the second set .",
    "now every @xmath174 of the first set is combined with one of the second set and pb @xmath168 is performed . whenever the outcome is @xmath231 ( the probability of which is calculated in the same way as in sec .",
    "[ secequi ] ) , a bpm @xmath149 is performed on the first @xmath174 .",
    "all @xmath232 with outcome @xmath233 are again divided in two halves , according to the ordening of every first @xmath174 . by continuing in this way",
    ", the fraction @xmath234 of @xmath174 , part of some @xmath6 , on which a bpm @xmath149 is performed , can be calculated , and equals @xmath235 @xmath236 as in eq .",
    "( [ f ] ) , the terms in the second summation in eq .",
    "( [ fa ] ) decrease exponentially fast .",
    "therefore , when @xmath237 is large , the procedure may be truncated after a number of steps . in the update rules ( [ update ] ) ,",
    "@xmath173 must be replaced by @xmath234 .",
    "note that we have different update rules for different possibilities @xmath6 . with this , we end up with the same possibilities ( [ poss ] ) but with different frequencies @xmath196),\\ldots , f([0,2^{q}])$ ] . to calculate the yield , we still use eqs .",
    "( [ entropies ] ) and ( [ yield ] ) .",
    "we have numerically calculated the yield of the protocols explained in sec .",
    "[ secprotocol ] for werner states .",
    "werner states are bell - diagonal states where @xmath238 and @xmath239 .",
    "@xmath240 is also called the _ fidelity _ of the state .",
    "werner states are typically the result of one party preparing bell states @xmath241 and sending one qubit of the pair to the other party via the depolarization channel @xmath242 in figs .",
    "[ new1 ] and [ new2 ] , we have plotted the yields of the protocols of sec .  [ secnum ] and [ secsmall ] , for @xmath243 .",
    "we truncate the procedure of sec .",
    "[ secequi ] after 10 steps .",
    "we see that with increasing @xmath50 , the yields of the protocols increase but converge .",
    "this is due to the fact that the entropy reduction is smaller for bpm on larger numbers of pairs .",
    "also notice in fig .",
    "[ new2 ] that the yields of the protocol of sec .",
    "[ secsmall ] are larger than the yields for corresponding @xmath50 of that of sec .",
    "[ secnum ] .     the yields of the protocol of sec .",
    "[ secsmall ] , where bpm on small numbers of pairs are favoured ( solid lines ) , compared to the yields of that of sec .",
    "[ secnum ] ( dotted lines ) , for @xmath243 .",
    "again , the yield increases with increasing @xmath50 and converges for large @xmath50.,scaledwidth=45.0% ]     the yields of the protocol of sec .",
    "[ secsmall ] , where bpm on small numbers of pairs are favoured ( solid lines ) , compared to the yields of that of sec .",
    "[ secnum ] ( dotted lines ) , for @xmath243 .",
    "again , the yield increases with increasing @xmath50 and converges for large @xmath50.,scaledwidth=45.0% ]    we see that the yield of our best protocol is zero when @xmath244 .",
    "this is better than breeding ( @xmath245 ) , but in order to distill states with lower fidelity , we first have to apply a numer of iterations of recurrence @xcite . before every recurrence iteration , one - qubit local clifford operations , yielding a permutation of the bell states ,",
    "are applied to each pair such that @xmath246 for the transformed pairs @xcite .",
    "recurrence itself consists of a bpm @xmath110 on every two pairs , after which all remaining pairs where this parity check yielded 1 , are discarded .",
    "the remaining pairs where the outcome was 0 , have higher fidelity and are kept for a next iteration or for an asymptotic protocol . note that the discarding can be interpreted as an extra bpm @xmath145 , which has equiprobable outcomes .",
    "the relative difference of the yields.,scaledwidth=45.0% ]     the relative difference of the yields.,scaledwidth=45.0% ]    therefore , the recurrence iterations before our protocol only improve it by the fact that also non - equiprobable parity checks are carried out by bpm .",
    "the not being maximal of the information gain is more than compensated by the entropy reduction for low - fidelity states .",
    "a next generation of protocols should incorporate a more complex criterion for bpm than merely equiprobable parity check outcomes , but we will not go deeper into that issue . we have compared the yield of breeding preceded by recurrence iterations to that of our protocol preceded by recurrence iterations in fig .",
    "the discontinuities in the slope are due to the fact that the optimal number of recurrence iterations is dependent on the fidelity .",
    "we have also plotted the relative difference in fig .",
    "[ rel ] , which is the difference of the yields divided by the yield of breeding preceded by recurrence iterations .",
    "the sawtooth - like shape is caused by the fact that the discontinuities in the slopes of the yields do not coincide for the two protocols .",
    "we have presented a new asymptotic distillation protocol , that , based on the important principle of entropy reduction , outperforms all previous asymptotic protocols . doing so , we have shed light on issues that were not clear before , such as the reason of the benefit of recurrence .",
    "although we can not claim to approach the entanglement of distillation , we certainly have tightened its lower bound .",
    "we also have mentioned roads that are still open for investigation .",
    "however , we feel that searching for further improvement will result in highly complicated protocols , possibly the product of an exhaustive search in a superexponential decision space .",
    "research funded by a ph.d .",
    "grant of the institute for the promotion of innovation through science and technology in flanders ( iwt - vlaanderen ) .",
    "bdm acknowledges the katholieke universiteit leuven , belgium .",
    "research supported by research council kul : goa ambiorics , coe ef/05/006 optimization in engineering , several phd / postdoc & fellow grants ; flemish government : fwo : phd / postdoc grants , projects , g.0407.02 ( support vector machines ) , g.0197.02 ( power islands ) , g.0141.03 ( identification and cryptography ) , g.0491.03 ( control for intensive care glycemia ) , g.0120.03 ( qit ) , g.0452.04 ( new quantum algorithms ) , g.0499.04 ( statistics ) , g.0211.05 ( nonlinear ) , g.0226.06 ( cooperative systems and optimization ) , g.0321.06 ( tensors ) , g.0553.06 ( vitamined ) , research communities ( iccos , anmmm , mldm ) ; iwt : phd grants , gbou ( mcknow ) , eureka - flite2 ; belgian federal science policy office : iuap p5/22 ( `` dynamical systems and control : computation , identification and modelling '' , 2002 - 2006 ) ; podo - ii ( cp/40 : tms and sustainability ) ; eu : fp5-quprodis ; ernsi ; contract research / agreements : ismc / ipcos , data4s , tml , elia , lms ."
  ],
  "abstract_text": [
    "<S> we present a new asymptotic bipartite entanglement distillation protocol that outperforms all existing asymptotic schemes . </S>",
    "<S> this protocol is based on the breeding protocol with the incorporation of two - way classical communication . like breeding , </S>",
    "<S> the protocol starts with an infinite number of copies of a bell - diagonal mixed state . </S>",
    "<S> breeding can be carried out as successive stages of partial information extraction , yielding the same result : one bit of information is gained at the cost ( measurement ) of one pure bell state pair ( ebit ) . </S>",
    "<S> the basic principle of our protocol is at every stage to replace measurements on ebits by measurements on a finite number of copies , whenever there are two equiprobable outcomes . in that case , the entropy of the global state is reduced by more than one bit . </S>",
    "<S> therefore , every such replacement results in an improvement of the protocol . we explain how our protocol is organized as to have as many replacements as possible . </S>",
    "<S> the yield is then calculated for werner states . </S>"
  ]
}