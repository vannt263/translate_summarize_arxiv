{
  "article_text": [
    "size and complexity of software systems has increased tremendously .",
    "therefore , the development of high - quality software requires rigorous application of sophisticated software engineering methods .",
    "one such method which has become very popular is the unified modeling language .",
    "uml @xcite has been developed by the `` three amigos '' booch , jacobson , and rumbaugh as a common framework for designing and implementing object - oriented software .",
    "uml contains many different notations to describe the static and dynamic behavior of a system on all different levels and phases of the software design process .",
    "although uml provides a common notational framework for requirements and design , uml , as any other language , does not eliminate bugs and errors .",
    "these bugs must be found and fixed in order to end up with a correctly working and reliable system .",
    "it is well known , that debugging a large software system is a critical issue and can be a major cost - driving factor .",
    "changes which have to be applied to the system ( e.g. , to fix a bug ) are becoming substantially more expensive , the later they are detected ( figure  [ fig : bugcosts ] ) .",
    "when an error is detected early during the definition phase , its cost is relatively low , because it only influences the requirements definition .",
    "bugfixes in a product already shipped can be up to 60100 times more expensive @xcite .",
    "therefore , it is mandatory to start with debugging as early in the project as possible . in this paper , we will discuss an approach which supports debugging of scenarios ( more precisely uml sequence diagrams ) with respect to given domain knowledge .",
    "this is done as a part of an algorithm @xcite which can synthesize uml statecharts from a number of sequence diagrams .",
    "this synthesis step can be seen as a transformation from requirements to system design .",
    "it does not only facilitate fast and justifiable design from requirements ( sequence diagrams ) , but also substantially helps to debug the generated designs . because sequence diagrams usually cover only parts of the system s intended behavior , the generated statecharts need to be refined and modified manually . by applying the synthesis algorithm in a `` backward '' way",
    ", the refined statechart can be checked against the requirements .",
    "each conflict is reported to the user and indicates a bug .    for practical applicability of any debugging aid , the presentation of the bug , its cause and effect is of major importance . in our approach ,",
    "we rely on logic - based explanation technology : all conflicts correspond to failure in logical reasoning about sequence diagrams , statecharts , and domain knowledge",
    ". ongoing work , as discussed in the conclusions , uses methods from automated deduction to point the user to the exact place where the conflict occurred and which parts of the models and specification are affected .    this paper is organized as follows : section  2 gives an overview of major uml notations and a typcial iterative software design process .",
    "then we will describe how sequence diagrams are annotated for a justified synthesis of statecharts ( section  4 ) .",
    "based on this algorithm we discuss methods for debugging a sequence diagram and a synthesized statechart . in section  7",
    "we discuss future work and conclude .    throughout this paper",
    ", we will use one example to illustrate our approach .",
    "the example concerns the interaction between an espresso vending machine and a user who is trying to obtain a cup of coffee .",
    "this example ( based on the atm example discussed in @xcite ) is rather small , yet complex enough to illustrate the main issues .",
    "the requirements presented here are typical scenarios for user interaction with the machine ( e.g. , inserting a coin , selecting the type of coffee the user wants , reaction on invalid choices , and pressing the cancel button ) .",
    "more details of the requirements will be discussed when the corresponding uml notations have been introduced .",
    "the unified modeling language is the result of an effort to bring together several different object - oriented software design methods .",
    "uml has been developed by booch , jacobson and rumbaugh @xcite and has gained wide - spread acceptance .",
    "a variety of tools support the development in uml ; among them are rhapsody @xcite , rational s rose @xcite , or argo / uml @xcite .    on the top - level ,",
    "requirements are usually given in the form of _ use cases _ , describing goals for the user and system interactions .",
    "for more detail and refinement , uml contains three major groups of notations : _ class diagrams _ for describing the static structure , _ interaction diagrams _ for requirements , and _ state diagrams _ and _ activity diagrams _ for defining dynamic system behavior .",
    "below , we will illustrate the notations which are important for our approach to debugging of uml designs .",
    "although no explicit development process is prescribed for uml , uml design usually follows the steps of inception , elaboration , construction , and transition , used in an iterative manner . in this paper",
    ", we will not elaborate on the process model . for details , cf .",
    ", e.g. , @xcite .",
    "the importance of support for debugging of uml designs on the level of sequence diagrams ( requirements ) , and statecharts becomes evident , when we look at a graphical representation of an iterative development process ( figure  [ fig : process ] ) .",
    "the design starts by analyzing the ( physical ) process at the lower left part of the figure .",
    "the result of the analysis comprises the requirements ( e.g. , as a set of sequence diagrams ) , and _ knowledge _ about the domain ( henceforth called domain theory ) .",
    "based on these , a _ model _ of the system is developed , consisting of class diagrams , statecharts and activity diagrams .",
    "this model must now be implemented .",
    "modern software engineering tools provide automatic code - generation ( or at least support ) for this step .",
    "finally , the produced system must be verified against the physical process , and its performance tuned .",
    "traditionally , the way to get a working system is simulation ( process  requirements  model ) , and testing ( requirements  model  system ) . here , errors and bugs have to be found and removed . within an _ iterative _ design process ,",
    "these steps are performed over and over again , depicted by the circular arcs . to keep these iterations fast ( and thus cost - effective ) , powerful techniques for _ debugging requirements _ against domain knowledge , and models against requirements are vital .",
    "our approach supports this kind of debugging and it will be discussed in the next section , following a short description of the basic concepts of class diagrams , sequence diagrams , and statecharts .",
    "a _ class diagram _ is a notation for modeling the static structure of a system .",
    "it describes the classes in a system and the relationships between them .",
    "figure  [ fig : class : atm1 ] shows an example of a class diagram for our coffee - vending machine example . in an object - oriented fashion , the main class ( here `` coffee machine '' ) is broken down into sub - classes .",
    "the aggregation relation ( @xmath0 ) shows when one class is _ part of _ another one .",
    "the generalization relation ( @xmath1 ) shows when one class is _ an instance of _ another . for further details , see e.g. , @xcite .",
    "_ statecharts _ @xcite , are finite state machines extended with hierarchy and orthogonality .",
    "they allow a complex system to be expressed in a compact and elegant way .",
    "figure  [ fig : sc - general ] shows a simple example of a statechart .",
    "nodes can either be simple nodes ( a1 , a2 , a3 , b , and c ) , or composite nodes ( node a in the figure ) which themselves contain other statecharts .",
    "the initial node in a statechart is marked by @xmath2 .",
    "transitions between states have labels of the form @xmath3/a$ ] . if event @xmath4 occurs and guard @xmath5 holds , then the transition may be selected to fire which results in action @xmath6 being taken and a state change occurring .",
    "this behavior is extended in a natural way to handle composite nodes .",
    "scenarios describe concrete examples of the system s intended behavior . in uml scenarios",
    "can be expressed as _",
    "sequence diagrams_. a _ sequence diagram _",
    "( sd ) shows the interaction between objects of a system over time .",
    "the sd in figure  [ atmbadac ] is an example for interactions between the objects `` user '' , the user interface of the coffee machine ( `` coffee - ui '' ) , and the machine ( `` control '' ) itself .",
    "the vertical lines represent the time - line for the given object , defining the object s life during the interaction . messages ( like `` insert coin '' )",
    "are exchanged between the objects .",
    "figure  [ atmbadpw ] is a different scenario for our coffee - machine .",
    "it describes an invalid selection by the user ( e.g. , choosing sugar and sweetener at the same time ) .",
    "the simplicity of sequence diagrams makes them suitable for expressing requirements as they can be easily understood by customers , requirements engineers and software developers alike .",
    "unfortunately , the lack of semantic content in sequence diagrams makes them ambiguous and therefore difficult to interpret .",
    "let us assume that in our example , there exists an additional sequence diagram , sd0 , identical to sd1 in figure [ atmbadac ] except that there are two `` insert coins '' messages adjacent to each other .",
    "there are three possible ways to interpret the conjunction of the two sds  either a cup of coffee costs one or two coins ( ridiculous ! ) , or it costs just one coin , in which case sd0 is incorrect . the other case ( two coins needed ) invalidates sd1 . in practice ,",
    "such ambiguities are often resolved by examining the informal requirements documentation but , in some cases , ambiguities may go undetected leading to costly software errors .    for the automatic generation of ( conflict - free ) designs , such documents are usually too informal .",
    "on the other hand , the need to provide a full formal domain theory containing all semantic information is clearly too much a burden for the designer and thus not acceptable in practice .",
    "our approach allows for a compromise : the user can annotate messages in a sequence diagram with a pre / post - condition style specification expressed in ocl , uml s logic - based specification and constraint language . for successful conflict detection ( and statechart synthesis ) ,",
    "only a small percentage of messages need to be annotated at all .",
    "this specifications should include the declaration of global _ state variables _ , where a state variable represents some important aspect of the system , e.g. , whether or not a coin is in the coffee - vending machine .",
    "pre- and post - conditions should then include references to those variables .",
    "our experience with the case studies carried out so far ( see conclusions ) is that the state variables and their data types usually directly `` fall out '' from the class diagram .",
    "note that not every message needs to be given a specification , although , clearly , the more semantic information that is supplied , the better the quality of the conflict detection . currently , our algorithm only exploits constraints of the form @xmath7 , but there may be something to be gained from reasoning about other constraints using an automated theorem prover , e.g. , @xcite or constraint solving techniques .",
    "[ domain - theory ] gives specifications for selected messages in our coffee - machine example .",
    "here , the state variables are the boolean variables coininmachine , coininreturnslot , coffeetypeselected , the variable coin reflecting the number of coins in the machine ( 0 , or 1 ) , and selectedcoffeetype . in order to talk about all values of the state variables at a given point ,",
    "we use the notion of a _ state vector_. this is a vector of values of the state variables . in our example , the state vector has the following form :    ....             < coininmachine^ , coininreturnslot^ , coffeetypeselected^ ,              coin^ , selectedcoffeetype^ > ....    the notation @xmath8 extends the possible value for a state variable by an undetermined value , denoted by a `` ? '' , i.e. , @xmath9 . for use with our algorithm , we will annotate each message of a sequence diagram with a statevector where the values of the state variables are determined by the algorithm described below .",
    "0.98    ....    coininmachine , coininreturnslot , coffeetypeselected : boolean coin : 0 .. 1 selectedcoffeetype : enum { none , espresso , cappuchino , milk }    context insert coin     pre :   coininmachine = f ;      post : coininmachine = t   and coin = 1 ;     context enter selection ( ct                : enum { none , espresso , cappuchino , milk } )     pre :   coffeetypeselected = f ;      post : coffeetypeselected = t   and selectedcoffeetype = ct ;     context take coin     pre :   coininreturnslot = t ;      post : coininreturnslot = f   and coininmachine = f ;     context display ready light     pre :   coininreturnslot = f   and coininmachine = f ;      post :      context request selection     pre :   coffeetypeselected = f ;      post :      context release coin     pre :   coin = 1 ;      post : coffeetypeselected = f and coininreturnslot = t and            coin=0 and coininmachine = f and            selectedcoffeetype = none ;     context request take coin     pre :   coininreturnslot = t ;     post :      context acknowledge cancel     pre :   coininmachine = t ;     post :    ....",
    "the framework for debugging uml designs is based upon an algorithm for automatic synthesis of statecharts from sequence diagrams and a domain theory @xcite . the process to convert a number of sds into a structured statechart consists of several steps : in the first step ,",
    "each sd is annotated and conflicts between the sd and the domain theory ( and hence , other sds ) are detected and reported to the user .",
    "then , a statechart for each of the objects in the sd is generated ; and all statecharts for an object are merged into a single statechart .",
    "the final step of the synthesis introduces hierarchy by grouping nodes into composite nodes , thus enhancing readability . in this paper , we are only concerned with the first , conflict detection part ( as a basis for debugging ) , and the final result , the statechart . for details on the algorithm",
    "see @xcite .",
    "there are two kinds of constraints imposed on a sequence diagram : constraints on the state vector given by the ocl specification , and constraints on the ordering of messages given by the sd itself .",
    "these constraints must be solved and arising conflicts be reported to the user .",
    "more formally , the process of conflict detection can be written as follows .",
    "an annotated sequence diagram is a sequence of messages @xmath10 , with @xmath11 where the @xmath12 , @xmath13 are the state vectors immediately before and after message @xmath14 is being sent .",
    "@xmath15 will be used to denote either @xmath12 or @xmath13 ; @xmath16 $ ] denotes the element at position @xmath17 in @xmath12 ( similarly for @xmath13 ) .",
    "in the first step of the synthesis process , we assign values to the variables in the state vectors as shown in figure  [ extend - sv ] .",
    "the variable instantiations of the initial state vectors are obtained directly from the message specifications ( lines  1,2 ) : if message @xmath14 assigns a value @xmath18 to a variable of the state vector in its pre- or post - condition , then this variable assignment is used .",
    "otherwise , the variable in the state vector is set to an undetermined value @xmath19 .",
    "since each message is specified independently , the initial state vectors will contain a lot of unknown values .",
    "most ( but not all ) of these can be given a value in one of two ways : two state vectors , @xmath20 and @xmath21 ( @xmath22 ) , are considered the same if they are unifiable ( line 6 ) .",
    "this means that there exists a variable assignment @xmath23 such that @xmath24 .",
    "this situation indicates a potential loop within a sd .",
    "the second means for assigning values to variables is the application of the frame axiom ( lines  8,9 ) , i.e. , we can assign unknown variables of a pre - condition with the value from the preceeding post - condition , and vice versa .",
    "this means that values of state variables are propagated as long as they are not changed by a specific pre- or post - condition .",
    "this also assumes that there are no hidden side - effects between messages .",
    "a conflict ( line  11 ) is detected and reported if the state vector immediately following a message and the state vector immediately preceding the next message differ .    _",
    "_ an annotated sd + _ output . _",
    "a sd with extended annotations    1 * for *  each message @xmath14 * do * +  2 @xmath14 has a precond @xmath25 * then * @xmath26 : = y$ ] * else * @xmath26 : = \\,?$ ] * fi * +  3 @xmath14 has a postcond @xmath25 * then * @xmath27 : = y$ ] * else * @xmath27 : = \\,?$ ] * fi * +  4  each state vector @xmath20 * do * +  5 there is some @xmath28 and = some unifier @xmath23 with @xmath24 * then * +  6 unify @xmath20 and @xmath21 ; +  7 propagate instantiations with frame axiom : +  8 @xmath29 with @xmath30 : * if * @xmath16 = \\ , ? $ ] * then * @xmath16 : = s^{{\\mbox{{\\em\\footnotesize post}}}}_{i-1}[j]$ ] * fi * +  9 @xmath31 = \\ ,",
    "? $ ] * then * @xmath31 : = s^{{\\mbox{{\\em\\footnotesize pre}}}}_{i}[j]$ ] * fi * + 10 there is some @xmath32 with @xmath27 \\neq s^{{\\mbox{{\\em\\footnotesize pre}}}}_{i+1}[j]$ ] * then * + 11 report conflict ; + 12 ; +    let us consider how this algorithm operates on the first few messages of sd1 from figure  [ atmbadac ] .",
    "when annotating the first message ( `` display ready light '' ) , we obtain the following state vector on the side of the user - interface : @xmath33 .",
    "the values of the first two state variables are determined by the message s pre - condition in the domain theory .",
    "the state - vector @xmath34 on the receiving side of our message only consists of `` ? '' . as a pre - condition for the message `` insert coin '' we have coininmachine = f.",
    "thus we have @xmath35 as the state vector .",
    "all other messages in sd1 are annotated in a similar way .",
    "now , our algorithm ( lines  412 ) tries to unify state vectors and propagate the variable assignments . in our case",
    ", the attempt to unify @xmath34 with @xmath36 would assign the value f to the first variable in @xmath34 , yielding @xmath37 .",
    "now , both state vectors are equal . then , variable values are propagated using the frame axiom . in our case",
    ", we can propagate the value of coininreturnslot = f ( from @xmath38 ) into @xmath34 and @xmath36 , because the domain theory does not prescribe specific values of this state variable at these messages .",
    "hence , its current value f can be used in the other state vectors , finally yielding @xmath39 . after performing all unification and propagation steps ,",
    "we obtain an annotated sequence diagram as shown in figure  [ atm - extended ] .",
    "the conflict indicated there will be discussed in the next section .",
    "the algorithm from the previous section detects conflicts of a sd with the domain theory ( and thus with other sequence diagrams ) .",
    "any such conflict which is detected corresponds to a bug which needs to be fixed .",
    "the bug can be in the sequence diagrams , which means that one or more sequences of actions are not compatible with the domain theory , and henceforth with other sds .",
    "such a situation often occurs when sequence diagrams and domain theory for a large system are developed by different requirements engineers .",
    "our algorithm is capable of directly pointing to the location where the conflict with the domain theory occurs . the respective message , together with the instantiated pre- and post - conditions , as well as the required state vector values are displayed .",
    "this feature allows to easily debug the sequence diagram . of course",
    ", the error could be in the domain theory instead .",
    "for example , one designer could have set up pre- or post - conditions which are too restrictive to be applicable for scenarios , specified by other designers . in that case , the domain theory must be debugged and modified . our algorithm can also provide substantial support here , because it is able to display the exact location where the conflicting state variables have been instantiated . especially in long sequence diagrams the place where a state variable is instantiated and the place where the conflict occurs can be far apart .",
    "the current version of our algorithm provides only rudimentary feed - back as demonstrated in the example below",
    ". future work ( which also allows richer ocl constructs to be used ) requires more elaborate , human - readable descriptions of the error trace .",
    "automated theorem provers and work on proof presentation , like the ilf system @xcite will be used for that purpose .",
    "such a system will not only _ explain _ the possible reasons for a conflict , but can also give ( heuristics - driven ) hints to the user on how to fix the problem .",
    "the following example shows , how conflict detection can be used for debugging : figure [ atm - extended ] shows sd1 from figure [ atmbadac ] after the state vectors have been extended by our algorithm of figure  [ extend - sv ] .",
    "our procedure has detected a conflict with the domain theory . as an output it provides the messages and state vectors which are involved in the conflict :    .... conflict in sd1 : object coffee - ui   statevector after   \" insert coin \"         = < t , f , t,1,none > [ msg 2 ]   statevector before \" request selection \"   = < t , f , f,1,none > [ msg 3 ]    conflict in variable \" coffeetypeselected \"    conflict occurred as consequence of unification of     statevector after \" display ready light \" = < f , f , t,0,none > [ msg 1 ]     statevector after \" display ready light \" = < f , f , t,0,none > [ msg 11 ]     statevector after",
    "\" take coin \"           = < f , f , t,0,none > [ msg 10 ] ....    this arises because state vectors sv1 ( state vector before `` display ready light '' ) and sv2 ( after `` take coin '' ) are unified ( figure  9 shows the instantiations of the vectors after unification ) .",
    "this corresponds to the fact that the coffee machine returns to its initial state after `` take coin '' is executed .",
    "the state vectors tell us that there is a potential loop at this point .",
    "a second execution of this loop causes the state variable `` coffeetypeselected '' to true , when the system asks for a selection .",
    "however , the domain theory tells us that this variable must be false as a pre - condition of the `` request selection '' message .",
    "hence , there is a conflict , which represents the fact that the developer probably did not account for the loop when designing the domain theory .",
    "the user must now decide on a resolution of this conflict  i.e. , to debug this situation .",
    "the user either    * can tell the system that the loop is not possible , in which case the unifier that detected the loop is discarded .",
    "this amounts to modifying the annotated sequence diagram ( by restricting possible interpretations ) .",
    "the user can * modify the sequence diagram at some other point , e.g. , by adding messages ; or * modify the domain theory . in our example",
    ", the action taken might be that the domain theory is updated by giving `` release coin '' the additional postcondition coffeetypeselected = false .",
    "this extra post - condition resets the value of the variable ( i.e. , the selection ) when the user is asked to remove the coin .",
    "the position of the change has been obtained by systematically going backwards from sv2 .",
    "although possible locations are automatically given by the system , the decision where to fix the bug ( at `` release coin '' or at `` take coin '' ) must be made by the user . here ,",
    "the second possibility was chosen , because the specification for that message modified a state variable which is related to the variable which caused the conflict .",
    "when the statechart synthesis algorithm successfully terminates , it has generated a human - readable , hierarchically structured statechart , reflecting the information contained in the sds and the domain theory . in general , however , sequence diagrams usually describe only parts of the intended dynamic behavior of a system . therefore , the generated statechart can only be a _ skeleton _ rather than a full - fledged system design .",
    "thus , the designer usually will extend , refine , and modify the resulting statechart manually .",
    "our approach takes this into account by generating a well structured , human - readable statechart which facilitates manual refinement and modification",
    ".    however , these manual actions can be sources of errors which will have to be found and removed from the design . in the following ,",
    "we describe two approaches , addressing this problem .",
    "the traditional way to find bugs in a statechart is to run simulations and large numbers of test cases .",
    "most commercial tools for statecharts , like betterstate , statemate , or rhapsody support these techniques .",
    "some tools also provide more advanced means for analysis , like detection of deadlocks , dead branches , non - deterministic choices , or even model checking for proving more elaborate properties . in this paper",
    ", we will not discuss these techniques .",
    "whenever a design ( in our case the statechart ) is modified , care must be taken that all requirements specifications are still met , or that an appropriate update is made .",
    "traditionally , this is done manually by updating the requirements document ( if it is done at all ) .",
    "bugs are usually not detected ( and not even searched for ) until the finished implementation is tested .",
    "thereby , late detection of bugs leads to increased costs . by considering the `` reverse '' direction of our synthesis algorithm , we are able to    * check that all sequence diagrams are still valid , i.e. , that they represent a possible sequence of events and actions of the system * detect conflicts between the current design ( statechart ) and one or more sds , and * detect inconsistencies with respect to the domain theory .",
    "the basic principle of that technique is that we take one sequence diagram after the other , together with the domain theory , and check if that sequence of messages is a possible execution sequence in the given statechart . here",
    "again we use logic - based techniques , similar to those described above ( unification of state vectors , value propagation with the frame axiom ) .",
    "an inconsistency between the ( modified ) statechart and the sd indicates a bug ( in the sd or sc ) . by successively applying patches to the sd ( by removing or adding messages to the sd ) the algorithm searches for possible ways to obtain an updated and consistent sd . since in general more than one possible fix for an inconsistency exists , we perform an iterative deepening search resulting in a solution with the fewest modifications to the sequence diagram .",
    "we are aiming to extend this search by applying heuristics to select `` good '' fixes .    here again , the form of feed - back to the user is of major importance .",
    "we are envisioning that the system can update the requirements and provide explanations for conflicts in a similar way as described above .",
    "the statechart in figure  [ fig : sc - deb ] has been refined .",
    "the transition between @xmath40 and @xmath41 has been extended in such a way that first event @xmath42 , then @xmath43 with action @xmath44 has to occur before the state @xmath41 is reached .",
    "the original statechart has been generated from a sequence diagram as shown on the right - hand side of fig .",
    "the modification of the statechart is propagated back to the sequence diagrams where the change is clearly marked . in this example , the extension could be made without causing a conflict .",
    "however , it is advisable for the designer and/or the requirements engineer to carefully observe these changes in order to make sure that these modified requirements still meet the original intended system behavior .",
    "we have presented a method for debugging uml sequence diagrams and statecharts during early stages in the software development process . based on an algorithm , designed for justified synthesis of statecharts ,",
    "we have identified two points where conflicts ( as a basis for debugging ) can be detected : during extending the annotations of a sd ( conflicts w.r.t . the domain theory ) , and updating of sequence diagrams based upon a refined or modified statechart .",
    "the algorithm which is described in @xcite has been implemented in java and has been used for several smaller case studies in the area of object - oriented systems , user interfaces , and agent - based systems @xcite .",
    "current work on this part include integration this algorithm into a commercial uml tool ( magicdraw ) .",
    "currently we are extending our synthesis algorithm to provide the debugging facilities described in this paper .",
    "future work will mainly focus on integrating and extending explanation technology into our system .    debugging large designs with lengthy and complex domain theories",
    "vitally depends upon an elaborate way of providing feed - back to the user .",
    "starting from the basic information about a conflict ( i.e. , a failed unification ) , we will use theorem proving techniques of abduction and counter - example generation to provide as much feed - back as possible on where the bug might be , and how to fix the problem .",
    "these techniques will be combined with tools capable of presenting a logic statement in human - readable , problem - specific way ( e.g. , ilf @xcite ) .",
    "only , if debugging feedback can be given in the notation of the engineering domain rather than in some logic framework , such debugging aids will be accepted in practice .",
    "it is believed that uml ( and tools based upon this notation ) will have a substantial impact on how software development is made . by providing techniques which do not only facilitate design by synthesis , but also provide powerful means to debug requirements and designs in early stages we are able to contribute to tools which are useful in design of large software systems ."
  ],
  "abstract_text": [
    "<S> design of large software systems requires rigorous application of software engineering methods covering all phases of the software process . </S>",
    "<S> debugging during the early design phases is extremely important , because late bug - fixes are expensive .    in this paper , we describe an approach which facilitates debugging of uml requirements and designs . </S>",
    "<S> the unified modeling language ( uml ) is a set of notations for object - orient design of a software system . </S>",
    "<S> we have developed an algorithm which translates requirement specifications in the form of annotated sequence diagrams into structured statecharts . </S>",
    "<S> this algorithm detects conflicts between sequence diagrams and inconsistencies in the domain knowledge . after synthesizing statecharts from sequence diagrams , </S>",
    "<S> these statecharts usually are subject to manual modification and refinement . by using the `` backward '' direction of our synthesis algorithm , we are able to map modifications made to the statechart back into the requirements ( sequence diagrams ) and check for conflicts there . fed back to </S>",
    "<S> the user conflicts detected by our algorithm are the basis for deductive - based debugging of requirements and domain theory in very early development stages . </S>",
    "<S> our approach allows to generate explanations on why there is a conflict and which parts of the specifications are affected . </S>"
  ]
}