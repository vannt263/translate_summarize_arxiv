{
  "article_text": [
    "language models play an important role in many applications like speech recognition , machine translation , information retrieval and nature language understanding .",
    "traditionally , the back - off n - gram models @xcite are the standard approach to language modeling .",
    "recently , neural networks have been successfully applied to language modeling and have achieved the state - of - the - art performance in many tasks . in neural network language models ( nnlm ) , the feedforward neural networks ( fnn ) and recurrent neural networks ( rnn ) @xcite are two popular architectures .",
    "the basic idea of nnlms is to use a projection layer to project discrete words into a continuous space and estimate word conditional probabilities in this space , which may be smoother to better generalize to unseen contexts .",
    "fnn language models ( fnn - lm ) @xcite usually use a limited history within a fixed - size context window to predict the next word .",
    "rnn language models ( rnn - lm ) @xcite adopt a time - delayed recursive architecture for the hidden layers to memorize the long - term dependency in language .",
    "therefore , it is widely reported that rnn - lms usually outperform fnn - lms in language modeling . while rnns are theoretically powerful , the learning of rnns needs to use the so - called back - propagation through time ( bptt ) @xcite due to the internal recurrent feedback cycles .",
    "the bptt significantly increases the computational complexity of the learning algorithms and it may cause many problems in learning , such as gradient vanishing and exploding @xcite .",
    "more recently , some new architectures have been proposed to solve these problems .",
    "for example , the long short term memory ( lstm ) rnn @xcite is an enhanced architecture to implement the recurrent feedbacks using various learnable gates , and it has obtained promising results on handwriting recognition @xcite and sequence modeling @xcite . moreover ,",
    "the so - called temporal - kernel recurrent neural networks ( tkrnn ) @xcite have been proposed to handle the gradient vanishing problem .",
    "the main idea of tkrnn is to add direct connections between units in all time steps and every unit is implemented as an efficient leaky integrator , which makes it easier to learn the long - term dependency . along this line",
    ", a temporal - kernel model has been successfully used for language modeling in @xcite .    comparing with rnn - lms , fnn - lms",
    "can be learned in a simpler and more efficient way .",
    "however , fnn - lms can not model the long - term dependency in language due to the fixed - size input window . in this paper",
    ", we propose a novel encoding method for discrete sequences , named _ fixed - size ordinally - forgetting encoding _ ( fofe ) , which can almost uniquely encode any variable - length word sequence into a fixed - size code . relying on a constant",
    "forgetting factor , fofe can model the word order in a sequence based on a simple ordinally - forgetting mechanism , which uses the position of each word in the sequence .",
    "both the theoretical analysis and the experimental simulation have shown that fofe can provide _ almost _ unique codes for variable - length word sequences as long as the forgetting factor is properly selected . in this work ,",
    "we apply fofe to neural network language models , where the fixed - size fofe codes are fed to fnns as input to predict next word , enabling fnn - lms to model long - term dependency in language .",
    "experiments on two benchmark tasks , penn treebank corpus ( ptb ) and large text compression benchmark ( ltcb ) , have shown that fofe - based fnn - lms can not only significantly outperform the standard fixed - input fnn - lms but also achieve better performance than the popular rnn - lms with or without using lstm . moreover",
    ", our implementation also shows that fofe based fnn - lms can be learned very efficiently on gpus without the complex bptt procedure .",
    "assume vocabulary size is @xmath0 , nnlms adopt the 1-of - k encoding vectors as input . in this case , each word in vocabulary is represented as a one - hot vector @xmath1 .",
    "the 1-of - k representation is a context independent encoding method .",
    "when the 1-of - k representation is used to model a word in a sequence , it can not model its history or context .",
    "we propose a simple context - dependent encoding method for any sequence consisting of discrete symbols , namely _ fixed - size ordinally - forgetting encoding _ ( fofe ) . given a sequence of words ( or any discrete symbols ) , @xmath2 , each word @xmath3 is first represented by a 1-of - k representation @xmath4 , from the first word @xmath5 to the end of the sequence @xmath6 , fofe encodes each partial sequence ( history ) based on a simple recursive formula ( with @xmath7 ) as : @xmath8 where @xmath9 denotes the fofe code for the partial sequence up to @xmath3 , and @xmath10 ( @xmath11 ) is a constant forgetting factor to control the influence of the history on the current position .",
    "let s take a simple example here , assume we have three symbols in vocabulary , e.g. , _ a _ , _ b _ , _ c _ , whose 1-of - k codes are @xmath12 $ ] , @xmath13 $ ] and @xmath14 $ ] respectively . in this case , the fofe code for the sequence _",
    "\\{abc } _ is @xmath15 $ ] , and that of _ \\{abcbc } _ is @xmath16 $ ] .",
    "obviously , fofe can encode any variable - length discrete sequence into a fixed - size code .",
    "moreover , it is a recursive context dependent encoding method that smartly models the order information by various powers of the forgetting factor .",
    "furthermore , fofe has an appealing property in modeling natural languages that the far - away context will be gradually forgotten due to @xmath17 and the nearby contexts play much larger role in the resultant fofe codes .",
    "given the vocabulary ( of @xmath0 symbols ) , for any sequence @xmath18 with a length of @xmath19 , based on the fofe code @xmath20 computed as above , if we can always decode the original sequence @xmath18 unambiguously ( perfectly recovering @xmath18 from @xmath20 ) , we say fofe is unique .",
    "[ theorem - fofe - alpha - less - half ] if the forgetting factor @xmath10 satisfies @xmath21 , _ fofe _ is unique for any @xmath0 and @xmath19 .",
    "the proof is simple because if the fofe code has a value @xmath22 in its @xmath23-th element , we may determine the word @xmath24 occurs in the position @xmath25 of @xmath18 without ambiguity since no matter how many times @xmath24 occurs in the far - away contexts ( @xmath26 ) , they do not sum to @xmath22 ( due to @xmath27 ) .",
    "if @xmath24 appears in any closer context ( @xmath28 ) , the @xmath23-th element must be larger than @xmath22 .    for @xmath29",
    ", we have the following theorem :    [ theorem - fofe - alpha - less - one ] for @xmath29 , given any finite values of @xmath0 and @xmath19 , _ fofe _ is almost unique everywhere for @xmath30 , except only a finite set of countable choices of @xmath10 .",
    "the complete proof @xcite is given in appendix a. based on theorem [ theorem - fofe - alpha - less - one ] , fofe is unique almost everywhere between @xmath31 only except a countable set of isolated choices of @xmath10 . in practice ,",
    "the chance to exactly choose these isolated values between @xmath31 is extremely slim , realistically almost impossible due to quantization errors in the system . to verify this",
    ", we have run simulation experiments for all possible sequences up to @xmath32 symbols to count the number of collisions .",
    "each collision is defined as the maximum element - wise difference between two fofe codes ( generated from two different sequences ) is less than a small threshold @xmath33 . in figure",
    "[ fig : collisions ] , we have shown the number of collisions ( out of the total @xmath34 tested cases ) for various @xmath10 values when @xmath35 , @xmath36 and @xmath37 . , the magnitudes of the resultant fofe codes become much larger . as a result ,",
    "the number of collisions ( as measured by a fixed absolute threshold @xmath33 ) becomes smaller .",
    "] the simulation experiments have shown that the chance of collision is extremely small even when we allow a word to appear any times in the context . obviously , in a natural language , a word normally does not appear repeatedly within a near context .",
    "moreover , we have run the simulation to examine whether collisions actually occur in two real text corpora , namely ptb ( 1 m words ) and ltcb ( 160 m words ) , using @xmath35 , we have not observed a single collision for nine different @xmath10 values between @xmath38 $ ] ( incremental @xmath39 ) .",
    "the architecture of a fofe based neural network language model ( fofe - fnnlm ) is as shown in figure [ fig : fofe_bigram ] .",
    "it is similar to standard bigram fnn - lms except that it uses a fofe code to feed into neural network lm at each time instance .",
    "moreover , the fofe can be easily scaled to other n - gram based neural network lms . for example , figure [ fig : fofe_trigram ] is an illustration of fixed - size ordinally forgetting encoding based tri - gram neural network language model .",
    "fofe is a simple recursive encoding method but a direct sequential implementation may not be efficient for the parallel computation platform like gpus .",
    "here , we will show that the fofe computation can be efficiently implemented as sentence - by - sentence matrix multiplications , which are particularly suitable for the mini - batch based stochastic gradient descent ( sgd ) method running on gpus .    given a sentence , @xmath40 , where each word is represented by a 1-of - k code as @xmath4 @xmath41 .",
    "the fofe codes for all partial sequences in @xmath18 can be computed based on the following matrix multiplication : @xmath42 \\left [ \\begin{gathered } { \\bf e}_1 \\hfill \\\\ { \\bf e}_2 \\hfill \\\\ { \\bf e}_3 \\hfill \\\\",
    "\\hspace{0.1 cm } \\vdots   \\hfill \\\\ { \\bf e}_t \\hfill \\\\",
    "\\end{gathered }   \\right ] = { \\bf m } { \\bf v}\\ ] ] where @xmath43 is a matrix arranging all 1-of - k codes of the words in the sentence row by row , and @xmath44 is a @xmath19-th order lower triangular matrix . each row vector of @xmath45 represents a fofe code of the partial sequence up to each position in the sentence .",
    "this matrix formulation can be easily extended to a mini - batch consisting of several sentences .",
    "assume that a mini - batch is composed of n sequences , @xmath46 , we can compute the fofe codes for all sentences in the mini - batch as follows : @xmath47   \\left [ \\begin{gathered } { \\bf v}_1 \\hfill \\\\ { \\bf v}_2\\hfill \\\\ \\quad   \\vdots   \\hfill \\\\ { \\bf v}_n \\hfill \\\\",
    "\\end{gathered }   \\right ] = { \\bf \\bar{m } } { \\bf \\bar{v}}\\ ] ]        when feeding the fofe codes to fnn as shown in figure [ fig : fofe_bigram ] , we can compute the activation signals ( assume @xmath48 is the activation function ) in the first hidden layer for all histories in @xmath18 as follows : @xmath49 where @xmath50 denotes the word embedding matrix that projects the word indices onto a continuous low - dimensional continuous space . as",
    "above , @xmath51 can be done efficiently by looking up the embedding matrix .",
    "therefore , for the computational efficiency purpose , we may apply fofe to the word embedding vectors instead of the original high - dimensional one - hot vectors . in the backward pass",
    ", we can calculate the gradients with the standard back - propagation ( bp ) algorithm rather than bptt . as a result ,",
    "fofe based fnn - lms are the same as the standard fnn - lms in terms of computational complexity in training , which is much more efficient than rnn - lms .",
    "we have evaluated the fofe method for nnlms on two benchmark tasks : i ) the penn treebank ( ptb ) corpus of about 1 m words , following the same setup as @xcite .",
    "the vocabulary size is limited to 10k .",
    "the preprocessing method and the way to split data into training / validation / test sets are the same as @xcite .",
    "ii ) the large text compression benchmark ( ltcb ) @xcite . in ltcb",
    ", we use the _ enwik9 _",
    "dataset , which is composed of the first @xmath52 bytes of enwiki-20060303-pages-articles.xml .",
    "we split it into three parts : training ( 153 m ) , validation ( 8.9 m ) and testing ( 8.9 m ) sets .",
    "we limit the vocabulary size to 80k for ltcb and replace all out - of - vocabulary words by a @xmath53unk@xmath54 token .",
    "details of the two datasets can be found in table [ tab : datasets ] .",
    ".the size of ptb and ltcb corpora in words . [ cols=\"^,^,^,^\",options=\"header \" , ]     [ tab : wiki_summary ]    we have further examined the fofe based fnn - lms on a much larger text corpus , i.e. ltcb , which contains articles from wikipedia .",
    "we have trained several baseline systems : i ) two n - gram lms ( 3-gram and 5-gram ) using the modified kneser - ney smoothing without count cutoffs ; ii ) several traditional fnn - lms with different model sizes and input context windows ( bigram , trigram , 4-gram and 5-gram ones ) ; iii ) an rnn - lm with one hidden layer of 600 nodes using the toolkit in @xcite , in which we have further used a spliced sentence bunch in @xcite to speed up the training on gpus .",
    "moreover , we have examined four fofe based fnn - lms with various model sizes and input window sizes ( two 1st - order fofe models and two 2nd - order ones ) . for all nnlms , we have used an output layer of the full vocabulary ( 80k words ) . in these experiments ,",
    "we have used an initial learning rate of 0.01 , and a bigger mini - batch of 500 for fnn - lmms and of 256 sentences for the rnn and fofe models .",
    "experimental results in table [ tab : wiki_summary ] have shown that the fofe - based fnn - lms can significantly outperform the baseline fnn - lms ( including some larger higher - order models ) and also slightly overtake the popular rnn - based lm , yielding the best result ( perplexity of 107 ) on the test set .",
    "in this paper , we propose the fixed - size ordinally - forgetting encoding ( fofe ) method to _ almost _ uniquely encode any variable - length sequence into a fixed - size code . in this work",
    ", fofe has been successfully applied to neural network language modeling .",
    "next , fofe may be combined with neural networks @xcite for other nlp tasks , such as sentence modeling / matching , paraphrase detection , machine translation , question and answer and etc .",
    "this work was supported in part by the science and technology development of anhui province , china ( grants no .",
    "2014z02006 ) and the fundamental research funds for the central universities from china , as well as an nserc discovery grant from canadian federal govenment .",
    "we appreciate dr .",
    "barlas oguz at microsoft for his insightful comments and constructive suggestions on theorem [ theorem - fofe - alpha - less - one ] .",
    "* theorem 2 : * _ for @xmath29 , given any finite values of @xmath0 and @xmath19 , _ fofe _ is almost unique everywhere for @xmath30 , except only a finite set of countable choices of @xmath10 . _",
    "* proof : * when we decode a given fofe code of an unknown sequence @xmath18 ( assume the length of @xmath18 is not more than @xmath19 ) , for any single value @xmath55 in the @xmath23-th position of the fofe code , there are only two possible cases that may lead to ambiguity in decoding : ( i ) word @xmath24 appears in the current location of @xmath18 ; or ( ii ) word @xmath24 appears multiple times in the history of @xmath18 and the total contribution of them happens to be @xmath55 .",
    "for case ( ii ) to happen , the forgetting factor @xmath10 needs to satisfy at least one of the following polynomial equations : @xmath56 where the above coefficients , @xmath57 , are equal to either @xmath58 or @xmath59 .",
    "if the word @xmath24 appears in the @xmath25-th location ahead in the history , we have @xmath60 . otherwise , @xmath61 . we know , each equation in eq.([eq - fofe - unique - formula ] ) is a @xmath19-th ( or lower ) order polynomial equation .",
    "it can have at most @xmath19 real roots for @xmath10 .",
    "moreover , since @xmath62 , we can only have a finite set of equations in eq.([eq - fofe - unique - formula ] ) .",
    "the total number is not more than @xmath63 .",
    "therefore , in total , we can only have a finite number of @xmath10 values that may satisfy at least one equation in eq.([eq - fofe - unique - formula ] ) , i.e. , at most @xmath64 possible roots @xcite . among them , only a fraction of these roots lies between @xmath31 . except these countable choices of @xmath10 values , eq.([eq - fofe - unique - formula ] ) never holds for any other @xmath10 values between @xmath31 . as a result ,",
    "case ( ii ) never happens in decoding except some isolated points of @xmath10 .",
    "this proves that the resultant fofe code is _ almost _ unique between @xmath31 .",
    "@xmath65    slava katz .",
    "estimation of probabilities from sparse data for the language model component of a speech recognizer .",
    "_ ieee transactions on acoustics , speech and signal processing ( assp ) _ , volume 35 , no 3 , pages 400 - 401 .",
    "tomas mikolov , stefan kombrink , lukas burget , jan cernocky and sanjeev khudanpur .",
    "extensions of recurrent neural network language model . in _ proc . of international conference on acoustics , speech and signal processing ( icassp ) _ , pages 5528 - 5531 .",
    "yong - zhe shi , wei - qiang zhang , meng cai and jia liu .",
    "temporal kernel neural network language model . in _ proc . of international conference on acoustics , speech and signal processing ( icassp)_. pages 8247 - 8251 ."
  ],
  "abstract_text": [
    "<S> in this paper , we propose the new fixed - size ordinally - forgetting encoding ( fofe ) method , which can almost uniquely encode any variable - length sequence of words into a fixed - size representation . </S>",
    "<S> fofe can model the word order in a sequence using a simple ordinally - forgetting mechanism according to the positions of words . in this work , </S>",
    "<S> we have applied fofe to feedforward neural network language models ( fnn - lms ) . </S>",
    "<S> experimental results have shown that without using any recurrent feedbacks , fofe based fnn - lms can significantly outperform not only the standard fixed - input fnn - lms but also the popular recurrent neural network ( rnn ) lms . </S>"
  ]
}