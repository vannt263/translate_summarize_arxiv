{
  "article_text": [
    "the interplay between _ group theory _ and _ computational complexity _ has been the source of a number of elegant constructions and computational insights .",
    "a line of work @xcite in the late 1980s gave characterizations of various complexity classes in terms of products over finite groups .",
    "a primary motivation of some of this work was to obtain an efficient simulation of circuits by branching programs , such as in the celebrated theorem of barrington @xcite . beyond this",
    "however , the underlying encoding of computation by group products has proven to be a useful tool in other areas .",
    "a typical encoding has the following form .",
    "let @xmath9 be a group with identity element @xmath10 , let @xmath11 be a boolean function , and let @xmath12 be an input to @xmath11 . then the encoding @xmath13 is a vector @xmath14 such that @xmath15 . for such encodings a number of efficiency aspects are of interest , including the size of the group , the length of the encoding , and the complexity of computing it . in some cases a short encoding can be computed with much fewer resources than are needed to compute @xmath11 , yielding the result that the decoding problem , i.e.  computing iterated products over @xmath9 , is as hard as computing @xmath11 .",
    "recently , the author and viola @xcite gave an application of these group encodings to _ leakage - resilient cryptography_. this area studies cryptographic models in which the adversary obtains more information from an algorithm than just its input / output behavior .",
    "the extra information is commonly modeled by providing the adversary with the output of a computationally restricted `` leakage function '' of its choosing , applied to ( the bits carried on ) the wires of a circuit implementing the algorithm . a general goal in this area is to compile any circuit @xmath16 into a functionally equivalent circuit @xmath17 such that any attack on @xmath17 exploiting this extra information can in fact be carried out just using input / output access , and hence does not succeed under standard hardness assumptions .",
    "the @xcite construction provides a rather generic way to construct such a compiler , given any group @xmath9 satisfying the following property with respect to a set of leakage functions @xmath18 .",
    "this property says that for an element @xmath19 , functions in @xmath18 can not distinguish between vectors with product @xmath5 and those with product @xmath20 .",
    "[ hard - def ] let @xmath9 be a group . for @xmath19 and @xmath21 ,",
    "the _ @xmath1-product problem over @xmath22 _ is to decide , given @xmath23 such that @xmath24 , which product it has .",
    "let @xmath25 denote the uniform distribution over @xmath26 .",
    "a set of functions @xmath18 is _",
    "@xmath27-fooled by @xmath22 _ if @xmath28 for every @xmath29 .",
    "the @xcite construction obtains security against leakage classes that are @xmath27-fooled by @xmath22 for _ every _ @xmath19 . a key technical contribution there is to show that a number of well - studied classes of functions have this property when @xmath30 , where @xmath31 denotes the group of even permutations on @xmath32 points .",
    "in particular they show that for every @xmath33 , functions including parity , majority , inner product , and communication protocols are @xmath34-fooled by @xmath35 , yielding a compiler that provides security against leakage from these functions .",
    "they also make the following conjecture , whose proof would yield a compiler that provides security against leakage from the class nc@xmath7 of log - depth , fan - in-2 circuits .    if _ nc_@xmath0 _",
    "l _ then for every @xmath36 , _",
    "nc_@xmath7 is @xmath34-fooled by @xmath4 .",
    "some support for this conjecture comes from the work of cook and mckenzie @xcite on the relationship between l = log - space and iterated group products .",
    "their results can be used to show that the following problem is l - complete : given @xmath37 , determine if @xmath38 .",
    "( the difference from definition [ hard - def ] is that @xmath12 s product is not guaranteed to be in @xmath39 . )",
    "if one could instead show that the @xmath1-product problem is l - complete for every @xmath36 , the conjecture follows from the random self - reducibility of iterated group products @xcite .",
    "however , it was not clear how to show this for even a single @xmath1 .",
    "we show that indeed the @xmath1-product problem is l - complete for every @xmath36 , and as a result we prove the above conjecture .",
    "theoremthmallalphahard [ thm : allalphahard ] assume that there is a circuit family @xmath16 of depth @xmath3 such that for sufficiently large @xmath40 , there exists @xmath36 such that @xmath16 decides the @xmath1-product problem over @xmath4 . then _",
    "nc_@xmath41 _ l. _    corollarythmmain [ thm : nc1 ] if _",
    "l _ , then _",
    "nc_@xmath7 is @xmath34-fooled by @xmath4 for infinitely many @xmath40 and all @xmath36 .",
    "more precisely , if _ nc_@xmath0 _",
    "then for all @xmath43 , infinitely many @xmath40 , and all @xmath36 , the class of",
    "_ nc_@xmath7 circuits with depth @xmath44 and output length @xmath44 is @xmath45-fooled by @xmath4 .    in combination with @xcite , corollary",
    "[ thm : nc1 ] yields a compiler that is secure against nc@xmath7 leakage .",
    "as noted in @xcite , even 1 bit of leakage from nc@xmath7 breaks nearly all previous constructions @xcite ( in fact leakage from tc@xmath46 nc@xmath7 is already enough to break these ) .",
    "furthermore , securing circuits against arbitrary polynomial - time leakage is known to be _ impossible _ , due to the impossibility of obfuscation @xcite .",
    "we note that , like some other compilers @xcite , in the multi - query setting the @xcite construction uses a so - called `` secure hardware component '' . specifically , the compiled circuits have a gate that produces a uniform sample from @xmath4 with product @xmath20 , and whose internal computation is not visible to the leakage function .",
    "[ [ on - the - amount - of - leakage . ] ] on the amount of leakage .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + +    the amount of nc@xmath7 leakage tolerated using corollary [ thm : nc1 ] is logarithmic in the security parameter , which is smaller than one might wish ( and smaller than can be achieved against other leakage classes ) .",
    "this limitation seems to be inherent when starting from an assumption such as nc@xmath7 @xmath47 l. one approach to circumventing this is by instead starting from a _ compression bound _ ,",
    "i.e.  a bound on the correlation between nc@xmath7 circuits with @xmath48 output bit and functions in l. indeed , the compression bound due to dubrov and ishai @xcite against ac@xmath49 was used by @xcite to achieve security against a linear amount of ac@xmath49 leakage .    in this",
    "setting however , there is an issue which is that the proof of theorem [ thm : allalphahard ] gives a turing reduction to the @xmath1-product problem , as opposed to a many - one reduction .",
    "with such a reduction it is not clear how to translate a ( hypothetical ) nc@xmath7 circuit compressing the @xmath1-product problem into a circuit compressing an arbitrary language in l , and therefore a generic assumption on the inability of nc@xmath7 to compress l does not immediately yield improved leakage bounds . in light of this , it would be interesting to show that the @xmath1-product problem is l - complete under many - one reductions . jumping ahead , showing this for any fixed @xmath36 would suffice to show it for all @xmath1 via theorem [ thm : localmap ] .",
    "we refer the reader to @xcite for further details on leakage - resilience , and now give an overview of the proof of theorem [ thm : allalphahard ] .",
    "the proof of corollary [ thm : nc1 ] given theorem [ thm : allalphahard ] uses straightforward techniques and appears in  [ sec : puttingtogether ] .",
    "[ [ the - cook - mckenzie - construction . ] ] the cook - mckenzie construction .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    our starting point is the work by cook and mckenzie @xcite who show that a number of problems related to @xmath8 , the group of all permutations on @xmath40 points , are complete for l. a key tool in their work is the following construction of a permutation that encodes acceptance of a given branching program on a given input .",
    "( we equate l with the set of polynomial - size branching programs . )",
    "theoremcookmckenzie [ thm : cook - mckenzie ] there exists @xmath50 and a circuit @xmath16 of depth @xmath51 such that , on input @xmath52 where @xmath53 is a branching program of size @xmath54 , @xmath16 outputs a permutation @xmath55 such that @xmath53 accepts @xmath12 iff @xmath56 and @xmath40 are in the same cycle in @xmath57 s disjoint cycle representation .",
    "recall that any permutation can be uniquely written as a product of disjoint cycles . throughout , when a permutation @xmath58 is the input or output of an algorithm , it is given in @xmath59-bit pointwise representation as @xmath60 .",
    "inversion and pairwise multiplication in @xmath8 can then be implemented in nc@xmath7 , because each essentially amounts to indexing an element from an array of length @xmath40 .",
    "theorem [ thm : cook - mckenzie ] is proved by constructing a permutation @xmath57 that performs one step of a depth - first search in @xmath53 when projecting to the edges consistent with the input @xmath12 .",
    "the nodes are labeled by @xmath61 $ ] , and the labels of the start and accept nodes ( @xmath56 and @xmath40 wlog ) are in the same cycle of @xmath57 iff the accept node is reachable from the start node . as observed to us by eric allender and v. arvind ( personal communication ) , theorem [ thm : cook - mckenzie ] can be used to show that the following very natural problem is l - complete : given @xmath62 , decide if @xmath38 .",
    "a simple embedding trick shows that this problem remains l - complete even over the group @xmath2 ( see  [ sec : decide - id - hard ] ) .",
    "however it was not clear whether theorem [ thm : cook - mckenzie ] could be used to show that the @xmath1-product problem is l - complete , for every or even for a single @xmath36 .",
    "the issue is that the permutation @xmath57 constructed in theorem [ thm : cook - mckenzie ] depends on the structure of the branching program @xmath53 when projecting to the edges whose labels match the input @xmath12 .",
    "so while the reduction to the `` product @xmath63 '' problem always produces a vector with product @xmath20 when @xmath64 , when @xmath65 the product can change depending on @xmath12 , rather than being fixed to some @xmath1 .    before explaining how we overcome this",
    ", we briefly review some facts and terminology about permutations that will be used ; a more detailed discussion appears in e.g.  @xcite .",
    "[ [ permutation - groups . ] ] permutation groups .",
    "+ + + + + + + + + + + + + + + + + + +    @xmath8 is the group of all permutations on @xmath61 = \\{1,\\ldots , t\\}$ ] .",
    "any permutation can be written as a product of transpositions , and the permutation is called _ even _ or _ odd _ depending on whether the number of transpositions in this product is even or odd .",
    "thus the product of two permutations is even iff both are even or both are odd .",
    "@xmath66 is the group of all even permutations on @xmath61 $ ] .",
    "a _ @xmath43-cycle _",
    "@xmath67 is a permutation that maps @xmath68 for @xmath69 and @xmath70 .",
    "a @xmath43-cycle is an even permutation iff @xmath43 is odd , because any @xmath43-cycle can be written as a product of @xmath71 transpositions @xmath72 .",
    "every permutation can be uniquely written as a product of disjoint cycles , and the list of these cycles lengths is the _ cycle type _ of the permutation .",
    "@xmath73 are _ conjugate _ if there exists @xmath74 such that @xmath75 .",
    "conjugacy is an equivalence relation and partitions @xmath9 into its conjugacy classes . in @xmath8 ,",
    "two permutations are conjugate iff they have the same cycle type . in @xmath2",
    "this continues to hold if that cycle type contains either an even - length cycle or two cycles of the same length , but for cycle types consisting of distinct odd lengths ( including length @xmath56 ) there are two distinct conjugacy classes .",
    "for example , the two 5-cycles @xmath76 and @xmath77 are conjugate in @xmath78 and @xmath79 but not in @xmath80 nor @xmath81 .",
    "the _ commutator _ of two elements @xmath73 is denoted @xmath82 $ ] and defined by @xmath82 : = \\alpha \\beta \\alpha^{-1 } \\beta^{-1}$ ] .",
    "we will use the fact that for every @xmath1 , @xmath83 = [ { \\textsf{id}},\\alpha ] = { \\textsf{id}}$ ] .",
    "we now explain the proof of theorem [ thm : allalphahard ] , which has two steps .",
    "we first show that if nc@xmath7 can decide the @xmath1-product problem for any fixed @xmath36 , then it can do so for every @xmath36 .",
    "next we show that the @xmath1-product problem is l - complete for the specific choice of @xmath84 .",
    "the combination of these implies that if nc@xmath7 can decide the @xmath1-product problem for any @xmath1 , then nc@xmath41 l. in light of the above discussion on the amount of leakage , we remark that only the latter step uses a turing reduction .",
    "[ [ mapping - group - products . ] ] mapping group products .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    we reduce the @xmath1-product problem to the @xmath85-product problem , for any @xmath86 , by constructing an nc@xmath7 map @xmath87 that maps @xmath1-products to @xmath85-products while preserving @xmath10-products .",
    "namely , this map satisfies @xmath88 for every @xmath89 .",
    "( to prove theorem [ thm : nc1 ] we choose @xmath90 , but here we keep them separate to make the blowup in output length clear .",
    ") moreover @xmath91 has the nice property that each output element depends on only 1 input element , i.e.  it is _",
    "1-local_.    if @xmath1 and @xmath85 are in the same conjugacy class , then there is a simple 1-local nc@xmath7 map with no blowup in length that satisfies ( [ eq : a2bmap ] ) .",
    "this map is @xmath92 where @xmath93 satisfies @xmath75 .",
    "but because @xmath1 and @xmath85 are in the same conjugacy class only if they have the same cycle type , to map between permutations of different cycle types a different technique is needed .",
    "our idea is to use _ commutation _ to map between permutations of different cycle types , and combined with conjugation as above this allows us to construct a map from any @xmath1 to any @xmath85 .",
    "as noted previously commutation is identity - preserving , i.e.  @xmath94 = [ { \\textsf{id}},\\gamma ] = { \\textsf{id}}$ ] for every @xmath95 , which makes it a good candidate for maps satisfying ( [ eq : a2bmap ] ) .",
    "one limitation is that commutation doubles the length of the vector , i.e.  we compute @xmath96 to map @xmath1-products to @xmath97$]-products while preserving @xmath10-products .",
    "but by using @xmath98 commutations , here the total length increase is limited to a factor of @xmath99 .",
    "we note that our use of commutation is different than in barrington s construction @xcite .",
    "there it is used to simulate and , and each commutator is formed from two vectors whose products are both unknown . here",
    "we use it to manipulate cycle structure , and each commutator is formed from a vector whose product is unknown and a fixed group element .",
    "our framework for using commutation to map between different cycle types has three steps .    1 .",
    "_ reduce to a product of two disjoint transpositions . _",
    "( lemma [ lem : to - doub - transp ] ) + we first convert any @xmath100 into a product of two disjoint transpositions . for example",
    "if @xmath1 s disjoint cycle representation contains a 4-cycle @xmath101 , then commutating with @xmath102 yields @xmath97 = ( a\\ c)(b\\ d)$ ] .",
    "2 .   _ grow the number of transpositions . _",
    "( lemma [ lem : growtranspositions ] ) + from a product of disjoint transpositions , we use one commutation to double the number of transpositions , and @xmath103 commutations to convert from @xmath104 to @xmath105 disjoint transpositions .",
    "for example if @xmath106 , then commutating with @xmath107 yields @xmath97 = ( a\\ b)(c\\ d)(e\\ f)(g\\ h)$ ] .",
    "3 .   _ combine transpositions into cycles . _",
    "( lemmas [ lem : oddcycles]-[lem : evencycles ] ) + we finally convert products of disjoint transpositions into longer cycles . for example if @xmath108 , then commutating with @xmath109 yields the @xmath110-cycle @xmath97 = ( a_1\\ \\cdots\\ a_k\\ b_k\\ \\cdots\\ b_1\\ c)$ ] .",
    "in total we use @xmath98 commutations .",
    "this turns out to be tight for certain starting and target permutations as shown in the following theorem , and thus for these permutations a map satisfying ( [ eq : a2bmap ] ) with smaller output length requires different techniques .",
    "( the theorem also holds if both commutations and conjugations are allowed . )    there exist @xmath111 such that @xmath1 can not be converted to @xmath85 with fewer than @xmath112 commutations .",
    "that is , for every @xmath113 and every sequence @xmath114 , @xmath115 , \\gamma_2 ] , \\cdots ] , \\gamma_\\ell]$ ] .    for @xmath36 ,",
    "let @xmath116\\ |\\ \\alpha(i ) \\neq i\\}|$ ] denote the number of points moved ( i.e.  not fixed ) by @xmath1 .",
    "we show that @xmath117 ) \\leq 2 \\cdot m(\\alpha)$ ] for every @xmath1 and @xmath95 , i.e.  the number of points moved by @xmath97 $ ] is at most twice the number of points moved by @xmath1 .",
    "this implies the theorem by choosing @xmath118 and @xmath119 , because @xmath120 and @xmath121 .",
    "pick @xmath93 . observe that @xmath122 has the same cycle type as @xmath1 because it is conjugate to @xmath1 in @xmath8 .",
    "this implies @xmath123 , and therefore @xmath97=\\alpha\\gamma\\alpha^{-1}\\gamma^{-1}$ ] moves at most @xmath124 points because any such point must be moved by either @xmath1 or @xmath122 .",
    "[ [ hardness - for - a - single - element . ] ] hardness for a single element .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    to prove that the @xmath125-product problem is l - complete , we reduce from the problem of deciding if @xmath126 has product @xmath20 .",
    "that is , from any @xmath126 we compute a vector @xmath127 such that @xmath128 has product @xmath20 if @xmath12 does , and otherwise @xmath128 has product @xmath129 .    as in step 1 above , we first show that if @xmath130 then there is some @xmath131 ( which depends on @xmath1 ) such that @xmath132 $ ] is a double - transposition , i.e.  a product of two disjoint transpositions .",
    "then because all double - transpositions are conjugate in @xmath2 there is some @xmath133 such that @xmath134 \\cdot \\gamma_2 = ( 1\\ 2)(3\\ 4)$ ] , and a vector with this product can be computed from @xmath12 in nc@xmath7 if we know @xmath135 .",
    "the problem of course is that we do not know @xmath135 without knowing @xmath136 which we can not compute .",
    "we resolve this by showing that for any @xmath100 , @xmath137 and @xmath138 as above can be taken from the set of permutations that are fixed on all but @xmath139 points in @xmath61 $ ] .",
    "since there are @xmath140 such permutations , we can thus construct a set of @xmath141 vectors such that if @xmath12 has product @xmath20 then they all do , and otherwise some vector has product @xmath129",
    ". then the proof is completed by applying an nc@xmath7 circuit deciding the @xmath125-product problem to each vector and a depth-@xmath3 or tree to the results .",
    "[ [ organization . ] ] organization .",
    "+ + + + + + + + + + + + +    the rest of the paper is organized as follows . in  [ sec : mapping ] we describe our mapping between group products and construct the function @xmath91 defined above for any @xmath1 and @xmath85 . in  [ sec:1234 ]",
    "we show that the @xmath125-product problem is l - complete . together",
    "these prove theorem [ thm : allalphahard ] , and in  [ sec : puttingtogether ] we prove corollary [ thm : nc1 ] .",
    "in this section we prove the following theorem .    [ thm : localmap ] let @xmath142 and let @xmath143 .",
    "then for all @xmath144 there is a 1-local function @xmath145 computable in depth @xmath3 that maps @xmath1-products to @xmath85-products while preserving the identity , i.e.  that satisfies @xmath146 : @xmath147    the function @xmath11 is constructed by concatenating compositions of functions from the following two families , where the compositions are given by lemma [ lem : convert ] . @xmath148",
    "[ lem : convert ] let @xmath142 and let @xmath149 such that @xmath100 and @xmath85 is either a cycle of odd length @xmath43 or is the product of two disjoint even - length cycles of total length @xmath43 . then , there is a sequence @xmath150 such that @xmath151 , where @xmath152 and @xmath153 .",
    "any function given by this lemma yields a 1-local function @xmath154 computable in depth @xmath3 that maps @xmath1-products to @xmath85-products while preserving the identity .    we prove the case @xmath155 , but the argument extends immediately to any @xmath144 .",
    "fix @xmath111 , and consider the unique representation of @xmath85 as a set of disjoint cycles @xmath156 .",
    "( here @xmath16 contains only those cycles with length @xmath48 . )",
    "the idea is to apply lemma [ lem : convert ] to each cycle @xmath157 , obtaining @xmath158 such that @xmath159 . then letting @xmath11 output the concatenation of these @xmath160 , the resulting function maps @xmath1-products to @xmath85-products while preserving the identity .",
    "further , its output length is @xmath161 .",
    "the only technical complication has to do with cycles of even length : if @xmath57 is a cycle of even length then it is an odd permutation , and so there can be no composition of functions from  and  that maps @xmath162 .",
    "we handle this by pairing the cycles of even length , which we can do because @xmath16 must contain an even number of cycles of even length as each is an odd permutation and @xmath85 is an even permutation .",
    "so , for each such pair of even - length cycles @xmath163 , we instead apply lemma [ lem : convert ] to get a function @xmath160 such that @xmath164 .      to prove lemma [ lem : convert ] , we implement the procedure described in  [ sec : techniques ] .",
    "namely , we first use @xmath165 commutations to convert a given @xmath36 to a double - transposition , then @xmath103 commutations to convert to a product of roughly @xmath166 disjoint transpositions , and finally @xmath165 commutations and 1 conjugation to convert to either a cycle of odd length @xmath43 or to the product of two disjoint even - length cycles with total length @xmath43 .    [",
    "lem : to - doub - transp ] let @xmath167 . for every @xmath168 , there exist @xmath169 such that @xmath170,\\gamma_2]$ ] is a double - transposition .",
    "further , each @xmath171 is either a double - transposition or a 3-cycle .",
    "we consider five cases based on @xmath1 s cycle structure . in all cases except the last , in fact only one commutation is needed to obtain a double - transposition , but we can use two by noting that @xmath172 = ( a\\ d)(b\\ c)$ ] .    1 .",
    "if @xmath1 contains a double - transposition @xmath173 , then @xmath174 = ( a\\ d)(b\\ c)$ ] .",
    "if @xmath1 is a 3-cycle @xmath175 , then @xmath176 = ( a\\ d)(b\\ c)$ ] .",
    "if @xmath1 contains two 3-cycles @xmath177 , then @xmath178 = ( a\\ d)(b\\ e)$ ] .",
    "if @xmath1 contains a 4-cycle @xmath101 , then @xmath176 = ( a\\ c)(b\\ d)$ ] . 5 .",
    "if @xmath1 contains a @xmath179-cycle @xmath67 , then @xmath180 = ( a_1\\ a_4\\ a_3)$ ] and apply case 2 .",
    "[ lem : growtranspositions ] for every double - transposition @xmath36 and even @xmath181 , there exist @xmath182 such that @xmath183 , \\gamma_2 ] , \\cdots ] , \\gamma_{\\log k}]$ ] is a product of @xmath43 disjoint transpositions .",
    "given @xmath106 , we can double the number of transpositions by commutating with @xmath184 to get @xmath97 = ( a\\ b)(c\\ d)(e\\ f)(g\\ h)$ ] . repeating this @xmath185 times ( with appropriate modifications to @xmath95 )",
    "grows the number of transpositions from 2 to @xmath43 . to handle @xmath43 that is not a power of 2 ,",
    "note that any @xmath173 can be `` maintained '' rather than doubled by instead commutating with @xmath175 as in the proof of lemma [ lem : to - doub - transp ] .",
    "we now show how to commutate a product of disjoint transpositions to obtain either an odd - length cycle ( lemma [ lem : oddcycles ] ) or the product of two even - length cycles ( lemma [ lem : evencycles ] ) .",
    "[ lem : oddcycles ] let @xmath40 be even and @xmath186 be any cycle of odd length @xmath187 . for any @xmath36 that is the product of either @xmath188 or @xmath189 disjoint transpositions ( depending on which is even ) , there are @xmath190 such that either @xmath191 = \\beta$ ] or @xmath192,\\gamma_3 ] = \\beta$ ] .",
    "we first show that @xmath1 can be converted to a @xmath43-cycle with @xmath165 commutations .",
    "afterwards we observe that by first using 1 conjugation , these commutations can be made to produce the specific @xmath43-cycle @xmath85 .",
    "if @xmath188 is even , then let @xmath193 be any product of @xmath194 disjoint transpositions .",
    "choosing @xmath195 , where @xmath196 is distinct from all @xmath71 points permuted by @xmath1 , we get that @xmath197 = ( a_1\\ \\cdots\\ a_{k'}\\ b_{k'}\\ \\cdots\\ b_1\\ c)\\ ] ] is a @xmath43-cycle .",
    "( we only need one commutation in this case . )",
    "if instead @xmath189 is even ( so @xmath198 ) , then let @xmath1 be any product of @xmath189 disjoint transpositions .",
    "first , commutate once as above to get a @xmath199-cycle @xmath200 we now show that there is another @xmath199-cycle @xmath201 such that @xmath202 is a @xmath43-cycle .",
    "this implies that we can convert @xmath203 to a @xmath43-cycle with one more commutation , namely by commutating with @xmath93 such that @xmath204 .",
    "( such @xmath95 must exist because the set of @xmath199-cycles forms a conjugacy class in @xmath2 when @xmath205 . )",
    "take the @xmath199-cycle @xmath206 where @xmath207 are distinct from the @xmath208 points permuted by @xmath203 .",
    "then letting @xmath209 denote the sequence @xmath210 , we have that @xmath211 is a @xmath43-cycle ( permuting points @xmath212 ) .    having converted @xmath1 to a @xmath43-cycle with @xmath165 commutations , one might hope to then use 1 conjugation to convert to the specific @xmath43-cycle @xmath85 .",
    "however when @xmath213 , the @xmath43-cycles form two distinct conjugacy classes in @xmath2 so we can not do this .",
    "we instead note that the points permuted by the @xmath43-cycle depend directly on the points permuted by @xmath1 ( and the extra points @xmath214 ) , and that products of an equal number of disjoint transpositions are conjugate in @xmath2 .",
    "so by _ first _ using 1 conjugation to modify @xmath1 appropriately , the above commutations yield @xmath85 .",
    "[ lem : evencycles ] let @xmath142 and @xmath186 be any product of two disjoint cycles of even lengths @xmath215",
    ". denote @xmath216 . for any @xmath36 that is the product of either @xmath166 or @xmath217 disjoint transpositions ( depending on which is even ) ,",
    "there exist @xmath218 such that @xmath134 \\cdot \\gamma_2 = \\beta$ ] .",
    "we first use one commutation to convert @xmath1 to the product of a @xmath219-cycle and a @xmath220-cycle , and then one conjugation to convert it to @xmath85 ( which here we can do without the complication mentioned at the end of lemma [ lem : oddcycles ] ) .",
    "we assume that @xmath221 , and at the end mention how to handle the two cases @xmath222 and @xmath223 .",
    "if @xmath166 is even , let @xmath224 be any product of @xmath225 disjoint transpositions , where @xmath226 and @xmath227 .",
    "we will show that there exists @xmath201 that is the product of @xmath166 disjoint transpositions such that @xmath228 is the product of a @xmath219-cycle and a @xmath220-cycle . as in lemma",
    "[ lem : oddcycles ] , this implies that we can convert @xmath1 to the desired form by commutating with @xmath93 such that @xmath229 .",
    "define @xmath230 where @xmath231 $ ] are distinct from each point permuted by @xmath1 .",
    "( such @xmath232 must exist because @xmath233 and @xmath142 , and thus @xmath234 . )",
    "then we have that @xmath235 is the product of two disjoint cycles of lengths @xmath236 and @xmath237 .",
    "if instead @xmath217 is even , let @xmath238 be any product of @xmath239 disjoint transpositions .",
    "this time we define @xmath240 where again @xmath232 are distinct from each of the @xmath241 points permuted by @xmath1 ( here we use @xmath242 , @xmath243 )",
    ". then we have that @xmath244 is the product of two disjoint cycles of lengths @xmath236 and @xmath237 .",
    "finally we handle the two cases @xmath222 and @xmath223 .",
    "if @xmath222 then @xmath1 and @xmath85 are both double - transpositions and can be made equal with a single conjugation . otherwise denote @xmath106 , and",
    "note that there is another double - transposition @xmath245 such that @xmath246 .",
    "thus @xmath1 can be commutated to the product of a 2-cycle and a 4-cycle , and a conjugation can make it equal to @xmath85 .",
    "lemma [ lem : convert ] follows immediately from lemmas [ lem : to - doub - transp]-[lem : evencycles ] . the only cases not explicitly covered by these are when @xmath247 in which case lemma [ lem : convert ] is vacuous , and when @xmath85 is a 3-cycle ( because lemma [ lem : oddcycles ] only handles @xmath179-cycles ) . for the latter , note that by assumption we must have @xmath248 .",
    "we first convert @xmath1 to a 5-cycle @xmath249 using lemmas [ lem : to - doub - transp]-[lem : oddcycles ] , then use one commutation with @xmath250 to convert to @xmath251 , and finally use one conjugation to convert to @xmath85 .",
    "in this section we show that the @xmath125-product problem is l - complete .",
    "[ thm : some - hard - alpha ] if for sufficiently large @xmath40 there is a circuit of depth @xmath3 that decides the @xmath125-product problem over @xmath4 , then _",
    "nc_@xmath41 _ l. _    we use the following theorem which is proved afterwards and says that deciding if an input vector has product @xmath20 is l - complete .",
    "theoremdecideidhard [ thm : decide - id - hard ] if for sufficiently large @xmath40 there is a circuit of depth @xmath3 that decides if its input in @xmath4 has product @xmath20 , then _",
    "nc_@xmath41 _ l. _    to prove theorem [ thm : some - hard - alpha ] from theorem [ thm : decide - id - hard ] , we show how to construct a set of @xmath141 vectors from an input vector @xmath126 such that , if @xmath12 has product @xmath20 then they all do , and otherwise some vector has product @xmath129 .",
    "then we apply the circuit deciding the @xmath125-product problem to each vector , and a depth-@xmath3 or tree to the outputs .",
    "the vectors are constructed using commutation and conjugation via lemma [ lem : to - doub - transp ] .",
    "assume that there is a circuit @xmath16 of depth @xmath3 that decides the @xmath125-product problem .",
    "we construct a circuit @xmath252 of depth @xmath3 that decides if its input has product @xmath20 , which in combination with theorem [ thm : decide - id - hard ] proves the theorem .",
    "lemma [ lem : to - doub - transp ] shows that for every @xmath168 , there exist @xmath169 such that @xmath253,\\gamma_2]$ ] is a double - transposition and each @xmath171 is either a double - transposition or a 3-cycle .",
    "we observe in the claim following this proof that for every double - transposition @xmath254 , there exists @xmath255 such that @xmath256 and @xmath257 permutes @xmath139 points .    for any such choice of @xmath258 , let @xmath259 denote a circuit of depth @xmath3 that satisfies @xmath260,\\gamma_2 ] \\cdot \\gamma_3\\ ] ] for every @xmath36 and @xmath126 .",
    "the crucial point is that if @xmath261 then there exists @xmath95 such that @xmath262 , and otherwise @xmath263 for every @xmath95 .",
    "observe that the number of double - transpositions in @xmath2 is @xmath264 , the number of @xmath265-cycles is @xmath266 , and the number of permutations that permute @xmath139 points is @xmath267 , all of which are @xmath141 .",
    "thus on input @xmath12 , @xmath252 checks in depth @xmath3 if any of these @xmath141 choices of @xmath268 satisfies @xmath269 .",
    "let @xmath270 .",
    "for every double - transposition @xmath36 , there exists @xmath93 such that @xmath271 and @xmath95 permutes @xmath139 points .",
    "denote @xmath106 . any injective function @xmath272 $ ] maps @xmath1 and @xmath125 to two double - transpositions in @xmath273 .",
    "since the latter are conjugate , and since the @xmath274 that `` witnesses '' this conjugacy necessarily permutes @xmath139 points , applying @xmath275 ( suitably defined ) to @xmath95 yields an element in @xmath2 that permutes @xmath139 points and witnesses the conjugacy of @xmath1 and @xmath125 .",
    "recall from  1 the following encoding of branching programs by permutations .",
    "the proof of this theorem is implicit in ( * ? ? ?",
    "* prop .  1 ) .",
    "next we use this to show that the problem of deciding if a vector over @xmath8 has product @xmath20 is l - complete .",
    "this proof is due to eric allender and v.  arvind ( personal communication ) , and we include it with their permission .",
    "[ thm : allender - arvind ] if for sufficiently large @xmath40 there is a circuit of depth @xmath3 that decides if its input in @xmath276 has product = @xmath10 , then",
    "_ nc_@xmath41 _ l_.    let a string @xmath12 and a branching program @xmath53 of size @xmath277 be given .",
    "let @xmath50 be as in theorem [ thm : cook - mckenzie ] .",
    "we first construct @xmath40 vectors in @xmath278 such that @xmath53 accepts @xmath12 iff the product of some vector is a permutation that maps @xmath279 .",
    "let @xmath55 be given by theorem [ thm : cook - mckenzie ] .",
    "notice that @xmath56 and @xmath40 are in the same cycle in @xmath57 s disjoint cycle representation iff @xmath280 such that @xmath281 maps @xmath279 .",
    "thus for @xmath282 we construct the @xmath43th vector to have product @xmath281 , by concatenating @xmath43 copies of @xmath57 and @xmath283 copies of @xmath10 .",
    "( up to now this construction appears in @xcite . )",
    "next we transform @xmath284 to @xmath285 satisfying @xmath286 this is done via the map @xmath287 where @xmath288 and we embed @xmath289 into @xmath290 in the canonical way .",
    "this is computable in depth @xmath3 .    to see that ( [ eq : map - to - id ] ) holds , denote @xmath291 and @xmath292 .",
    "if @xmath293 , then @xmath294 and so @xmath295 . on the other hand",
    "if @xmath296 , then it can be checked that @xmath297 and @xmath298 , and it is clear that @xmath299 for @xmath300 since @xmath301 is not touched by @xmath302 and @xmath303 is not touched by @xmath304 .",
    "thus we have constructed @xmath40 vectors in @xmath305 such that @xmath53 accepts @xmath12 iff some vector has product @xmath306 .",
    "we can reduce the vectors length to @xmath307 in depth @xmath3 by multiplying adjacent permutations . finally , applying the circuit in the assumption of the theorem and an or - tree yields a circuit of depth @xmath3 that decides if @xmath53 accepts @xmath12 .    to conclude the proof of theorem [ thm : decide - id - hard ] , we observe that there is an embedding @xmath308 computable in nc@xmath7 that preserves the identity product .",
    "@xmath309 is defined by @xmath310 if @xmath1 is even and @xmath311 if @xmath1 is odd .",
    "it can be checked that this is a homomorphism , and thus @xmath312 .",
    "computing @xmath309 requires deciding if @xmath313 is odd or even , which can be done in depth @xmath3 by checking if there are an odd or even number of pairs @xmath314 such that @xmath315 .",
    "theorem [ thm : allalphahard ] is immediate from theorems [ thm : localmap ] and [ thm : some - hard - alpha ] . we now prove corollary [ thm : nc1 ] from theorem [ thm : allalphahard ] using the random self - reducibility of group products ( cf .",
    "* thm .  3.9 ) ) .",
    "assume that there exists @xmath43 such that for sufficiently large @xmath40 , there exists @xmath36 and a circuit @xmath16 of depth @xmath44 such that @xmath316 , where recall that @xmath317 is the uniform distribution over @xmath318 .",
    "let @xmath319 be the set that maximizes @xmath320 - \\pr[c(d_{\\textsf{id } } ) \\in s]$ ] , and note that checking @xmath321 can be done in depth @xmath3 .",
    "thus , there exists @xmath322 of depth @xmath3 such that @xmath323 - \\pr[c'(d_{\\textsf{id } } ) = 1 ] \\geq t^{-k}.\\ ] ] define @xmath324 $ ] and @xmath325 $ ] , and note that @xmath326 .",
    "let @xmath327 be the randomized circuit of depth @xmath3 that computes as follows on input @xmath126 .",
    "first for @xmath328 , @xmath327 samples @xmath329 independently from @xmath317 where @xmath330 .",
    "this is done by choosing uniform @xmath331 for each @xmath332 and computing @xmath333 . then @xmath327 outputs @xmath1 if @xmath334 and otherwise outputs @xmath10 .",
    "this implies the theorem , as follows . by a union bound",
    "there is a way to fix the random coins of @xmath327 such that @xmath336 for every @xmath12 satsifying @xmath24 .",
    "this solves the @xmath1-product problem in nc@xmath7 , and thus by theorem [ thm : allalphahard ] we have nc@xmath41 l.        now assume @xmath38 .",
    "then @xmath343 , and since @xmath344 by ( [ eqn - circuit ] ) , we have @xmath345 . then using another chernoff bound , we have @xmath346 \\geq 1",
    "- \\pr[x \\geq \\mu(1 + 1/(3t^k ) ) ] \\geq 1 - e^{-\\mu \\cdot t^{-3k } } \\geq 1 - 2^{-t^3}. \\qedhere\\ ] ]        we are grateful to eric allender and v.  arvind for sharing the proof of theorem [ thm : allender - arvind ] and allowing us to include it here , and to emanuele viola for helpful discussions and comments on a previous draft of this paper .",
    "boaz barak , oded goldreich , russell impagliazzo , steven rudich , amit sahai , salil  p. vadhan , and ke  yang . on the ( im)possibility of obfuscating programs . in _ int .",
    "cryptology conf .",
    "( crypto ) _ , pages 118 , 2001 .",
    "sebastian faust , tal rabin , leonid reyzin , eran tromer , and vinod vaikuntanathan . protecting circuits from leakage : the computationally - bounded and noisy cases . in _ int .",
    "conf .  on the theory and applications of cryptographic techniques ( eurocrypt ) _ ,",
    "pages 135156 , 2010 ."
  ],
  "abstract_text": [
    "<S> we show that if nc@xmath0 l , then for every element @xmath1 of the alternating group @xmath2 , circuits of depth @xmath3 can not distinguish between a uniform vector over @xmath4 with product @xmath5 and one with product @xmath6 identity . </S>",
    "<S> combined with a recent construction by the author and viola in the setting of leakage - resilient cryptography [ stoc 13 ] , this gives a compiler that produces circuits withstanding leakage from nc@xmath7 ( assuming nc@xmath0 l ) . </S>",
    "<S> for context , leakage from nc@xmath7 breaks nearly all previous constructions , and security against leakage from p is impossible . </S>",
    "<S> we build on work by cook and mckenzie [ j.  algorithms 87 ] establishing the relationship between l @xmath6 logarithmic space and the symmetric group @xmath8 . </S>",
    "<S> our techniques include a novel algorithmic use of commutators to manipulate the cycle structure of permutations in @xmath2 </S>",
    "<S> .    [ section ] [ theorem]lemma [ theorem]corollary [ theorem]fact [ theorem]definition [ theorem]assumption </S>"
  ]
}