{
  "article_text": [
    "for long - term n - body simulations , it is essential that the drift in the values of conserved quantities is kept to a minimum .",
    "the total energy is often used as an indicator of such a drift . during the last fifteen years",
    ", two approaches have been put forward to improve numerical conservation of energy and other theoretically conserved quantities : symplectic integration schemes , where the simulated system is guaranteed to follow a slightly perturbed hamiltonian system , and time - symmetric integration schemes , where the simulated system follows the same trajectory in phase space , when run backwards or forwards    in both cases , for symplectic as well as for time - symmetric schemes , the introduction of adaptive time steps tends to destroy the desired properties .",
    "symplectic schemes are perturbed to different hamiltonians at different choices of time step length , and therefore lose their global symplecticity .",
    "time - symmetric schemes typically determine their time step length at the beginning of a step , which implies that running a step backwards gives a slightly different length for that step .",
    "see @xcite for a recent review of various attempts to remedy this situation .    in practice , many large - scale simulations in stellar dynamics use a block time - step approach , where the only allowed values for the time step length are powers of two @xcite .",
    "the name derives from the fact that , with this recipe , many particles will share the same step size , which implies that their orbit integration can be performed in parallel .",
    "an added benefit , in the case of individual time steps , is the fact that block time steps allow one to predict the positions of all particles only once per block time step , rather than separately for each particle that needs to be moved forward .",
    "since parallelization is rapidly becoming essential for any major simulation , we explore in this paper the possibility to extend time symmetry to the use of block time steps .    in section 2 ,",
    "we analyze some of the problems that occur when applying existing methods to the case of block time steps , and we offer a novel solution , with a truly time symmetric choice of time step , with the restriction that we only allow changes of a factor two in the direction of increasing and decreasing the time step . in section 3",
    ", we present numerical tests of our new scheme , which show the superiority of our approach over various alternatives .",
    "section 4 sums up .",
    "it is surprisingly easy to introduce a time - symmetric version for any adaptive self - starting integration scheme .",
    "let @xmath0 be the @xmath1-dimensional phase space vector for a system with @xmath2 degrees of freedom , and let @xmath3 be the operator that maps the phase space vector of the system at time @xmath4 to a new phase space vector at time @xmath5 .",
    "any choice of self - starting integration scheme , together with a recipe to determine the next time step @xmath6 , at time @xmath4 and phase space value @xmath7 , defines the precise form of @xmath3 .",
    "the recipe for making any such scheme time - symmetric was given by @xcite , as :    @xmath8    where @xmath9 can be any time step criterion .",
    "note that this recipe leads to an implicit integration scheme , which can be solved most easily through iteration . in practice ,",
    "one or two iterations suffice to get excellent accuracy , but at the cost of doubling or tripling the number of force calculations that need to be performed .",
    "extensions of this implicit symmetrization idea have been presented by @xcite and @xcite .",
    "since we will need to inspect the idea of iteration below in more detail , let us write out the process here explicitly .",
    "we start with the given state @xmath10 and the implicit equation for @xmath11 of the form    @xmath12    the first guess for @xmath11 is    @xmath13    and we can consider this as our zeroth - order iteration . with this guess in hand , we can now start to iterate , finding    @xmath14    as our first - order iteration .",
    "this will already be much closer to the final value , as long as the time steps are small enough and the function @xmath6 does not fluctuate too rapidly . in general , the @xmath15 iteration will yield a value for @xmath11 of    @xmath16    we will now consider the application of these techniques to block time steps . for the purpose of illustrating the use of block time steps , it will suffice to use the leapfrog scheme ( also known as the verlet - strmer - delambre scheme , according to the authors who rediscovered this scheme at roughly century - long intervals ) , which we present here in a self - starting , but still time - symmetric form :    @xmath17      to start with , we apply the recipe of @xcite to block time steps .",
    "let us define a block time step at level @xmath18 as having a length :    @xmath19    where @xmath20 is the maximum time step length .",
    "starting with the continuum choice of    @xmath21    we now force each time step to take on the block value @xmath22 for the smallest @xmath18 value that obeys the condition @xmath23 . in more formal terms ,",
    "@xmath24 for the unique @xmath18 value for which    @xmath25    the problem with this approach is that we are no longer guaranteed to find convergence for our iteration process , as can be seen from the following example .",
    "let @xmath26 and let the time derivative of @xmath27 along the orbit be @xmath28 .",
    "we then get the following results for our attempt at iteration .",
    "@xmath29    @xmath30/2 ) )    \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i([0.502 + ( 0.502 + 0.5*(-0.01))]/2 ) )          \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i([0.502 + 0.497]/2 ) )                        \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i(0.4995 ) )         = f(\\xi_i , 0.25)\\end{aligned}\\ ] ]    @xmath31/2 ) )         \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i([0.502 + ( 0.502 + 0.25*(-0.01))]/2 ) )          \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i([0.502 + 0.4995]/2 ) )                        \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i(0.50075 ) )          = f(\\xi_i , 0.5)\\end{aligned}\\ ] ]    and from here on , @xmath32 for every odd value of @xmath33 and @xmath34 for every even value of @xmath33 : the process of iteration will never converge .    under realistic conditions , for slowly varying @xmath35 functions and small time steps ,",
    "this flip - flop behavior will not occur often , but it will occur sometimes , for a non - negligible fraction of the time .",
    "we can see this already from the above example : for a linear decrease in the @xmath35 function of @xmath28 , we will get flip - flopping not only for @xmath26 but for any value in the finite range @xmath36 .    since iteration converges correctly over the rest of the interval @xmath37 , we conclude that in this particular case flip - flopping occurs about one quarter of one percent of the time , over this interval .",
    "this is far too frequent to be negligible in a realistic situation .",
    "clearly , a straightforward extension of the implicit iterative time symmetrization approach does not work for block time steps , because iteration does not converge .",
    "we have to add some feature , in some way .",
    "our first attempt at a solution is to take the smallest of the two values in a flip - flop situation .",
    "the most straightforward solution of the flip - flop dilemma is like cutting the gordian knot : we just take the lowest value of the two alternate states .",
    "the drawback of this solution is that in general we need at least two iterations for each time step , to make sure that we have spotted , and then correctly treated , all flip - flop situation . in general , it is only at the third iteration that it becomes obvious that a flip - flop is occurring . to see this ,",
    "consider the previous example with a starting value of @xmath38 . in that case",
    "we will get @xmath39 and @xmath40 , just as when we started with @xmath26 .",
    "the difference shows up only at the second iteration , where we now find @xmath41 , a value that will hold for all higher iterations as well .",
    "the original iterative approach to time symmetry in practice already gives good results when we use only one iteration .",
    "this implies a penalty , in terms of force calculations per time steps , of a factor two compared to non - time - symmetric explicit integration .",
    "now the use of flip - flop resolution will force us to always take at least two iterations per step , raising the penalty to become at least a factor of three .",
    "however , there is a more serious problem : there is still no guarantee that taking the lowest value in a flip - flop situation leads to a time - symmetric recipe .",
    "in fact , what is even more important , we have not yet checked whether our symmetric block time - step scheme is really time symmetric , in the absence of flip - flop complications .    in order to investigate these questions ,",
    "let us return to the example we used above , but instead of a linear time derivative , let us now use a quadratic time derivative for the @xmath35 function that gives the estimate for the time step size . rather than writing a formal definition ,",
    "let us just state the values , while shifting the time scale so that @xmath42 coincides with the particle position being @xmath10 :    @xmath43    when we start at time @xmath42 , and we integrate forwards . we find :    @xmath29    @xmath30/2 ) )    \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i([0.502 + 0.499]/2 ) )                        \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i(0.5005 ) )         = f(\\xi_i , 0.5)\\end{aligned}\\ ] ]    and so on : all further @xmath33th iterations will result in @xmath44 .",
    "there is no flip - flop situation , when moving forward in time .",
    "however , when we now turn the clock backward , after taking this step of half a time unit , we start with the value @xmath45 , which leads to a first step back of @xmath46 .",
    "the end point of the first step back is @xmath47 with @xmath48 .",
    "therefore , also here there is no flip - flop situation : all iterations , while going backward , result in a time step size of @xmath46 .",
    "we have thus constructed a counter example , where forward integration would proceed with time step @xmath49 and subsequent backward integration would proceed with time step @xmath46 .",
    "clearly , our scheme is not yet time symmetric , even in the absence of a flip - flop case .",
    "let us rethink the whole procedure .",
    "the basic problem has been that the very first step in any of our algorithms proposed so far has not been time symmetric .",
    "the very first step moves forward , and leads to a newly evolved system at the end of the first step . only _",
    "after _ making such a trial integration , do we look back , and try to restore symmetry .",
    "however , as we have seen , the danger is large that this trial integration is not exhaustive : it may already go too far , or not far enough , and thereby it may simply overlook a type of move that the same algorithm would make if we would start out in the time - reversed direction .    formulating the problem in this way ,",
    "immediately suggests a solution . at any point in time , let us first try to make the largest step that is allowed .",
    "if that step turns out to be too large for our algorithm , we try a step that is half that size .",
    "if that step is too large still , we again half the size , and so on , until we find a step size that agrees with our algorithm , _ when evaluated in both time directions .",
    "_ a similar treatment has been described by quin et al ( 1997 ) .",
    "this type of approach is clearly more symmetric than what we have attempted so far . instead of using information of the physical system at the starting point of the next integration step , we only use a mathematical criterion to find the largest time step size allowed at that point , _ and",
    "we then apply the physical criteria symmetrically in both directions .",
    "_    let us give an example . if the largest time step size is chosen to be unity , then at time @xmath50 we start by considering this time step .",
    "we try , in this order @xmath51 , @xmath49 , @xmath46 , and so on , until we find a time step for which integration starting in the forward direction , and integration starting in the backward direction , both result in the new time step being acceptable .",
    "let us say that this is the case for @xmath52 .",
    "after taking this step , we are at time @xmath53 .",
    "the largest time step allowed at that point , forward or backward , is @xmath52 .",
    "any larger time step would result in non - alignment of the block time steps : in the backward direction it would jump over @xmath50 .",
    "so at this point we start by considering once more @xmath52 .",
    "if that time step is too large , we try half that time step , halving it successively until we find a satisfactory time step size .",
    "imagine that the second time step size is also @xmath52 .",
    "in that case , we land at @xmath47 . from there on",
    ", the maximum allowed time step size is @xmath46 , so the first try should be that size .    in principle",
    ", this approach seems to be really time symmetric .",
    "however , there is a huge problem with this type of scheme , as we have just formulated it .",
    "imagine the system to crawl along with time steps of , say @xmath54 , and reaching time @xmath55 .",
    "our new recipe then suggests to start by trying @xmath51 , a 1024-fold increase in time step !",
    "whatever subtle physical effect it was that forced us to take such small time steps , is completely ignored by the mathematical recipe that forces us to look at such a ridiculously large time step .    for example",
    ", in the case of stellar dynamics , a double star may force the stars that orbit each other to take time steps that are necessarily far shorter than the orbital period .",
    "starting out with a trial step size that is far larger than an orbital period may or may not give spuriously safe - looking results .",
    "clearly , we have to exclude such enormous jumps in time step .      the simplest solution to taming sudden unphysical increases in time steps",
    "is to allow at most an increase of a factor two , in either the forward or the backward direction .",
    "this then implies that we can only allow decreases of a factor two , and not more than two , in either direction .",
    "the reason is that a decrease of a factor four in one direction in time would automatically translate into an increase of a factor four in the other direction .",
    "note that we have to be careful with our time step criterion . if we allow time steps that are too large , we may encounter situations where our time step criterion would suggest us to shrink time steps by a factor of four , from one step to the other .",
    "since our algorithm does not allow this , we can at most shrink by a factor of two , which may imply an unacceptably large step . however , if our time step criterion is sufficiently strict , allowing only reasonably small time steps too start with , it will be able to resolve the gradients in the criterion in such as way as to handle all changes gracefully through halving and doubling .",
    "when we apply this restriction to the scheme outlined in the previous subsection , we arrive at the following compact algorithm .",
    "first a matter of notation .",
    "any block time step , of size @xmath56 , connects two points in time , only one of which can be written at @xmath57 , with @xmath58 an integer .",
    "let us call that time value an _ even time _",
    ", from the point of view of the given time step size , and let us call that other time value an _ odd time_. to give an example , if @xmath52 , than @xmath59 are all even times , while @xmath60 are all odd times",
    ".    here is our algorithm :    * when we start in a given direction in time , at a given point in time , we should determine the time step size of the last step made by the system . in that way , we can determine whether the current time is even or odd , with respect to that last time step .",
    "* if the current time is odd , our one and only choice is : to continue with the same size time step , or to halve the time step .",
    "first , we try to continue with the same time step .",
    "if , upon iteration , that time step qualifies according to the time - symmetry criterion used before , eq .",
    "[ blockcondition ] , we continue to use the same time step size as was used in the previous time step .",
    "if not , we use half of the previous time step . *",
    "if the current time step is even , we have a choice between three options for the new time step size : doubling the previous time step size , keeping it the same , or halving it .",
    "we first try the largest value , given by doubling . if eq.[blockcondition ] shows us that this larger time step is not too large , we accept it , otherwise we consider keeping the time step size the same .",
    "if eq.[blockcondition ] shows us that keeping the time step size the same is okay , we accept that choice , otherwise we just halve the time step , in which case no further testing is needed .    note that in this scheme , we always start with the largest possible candidate value for the time step size .",
    "subsequently , we may consider smaller values , but the direction of consideration is always from larger to smaller , never from smaller to larger .",
    "this guarantees that we do not run into the flip - flop problem mentioned above .",
    "we present here the results for a gravitational two - body integration . the relative orbit of the two point masses forms an ellipse with an eccentricity of @xmath61 .",
    "we have chosen a time unit such that the period of the orbit is @xmath62 .    we have implemented four different integration schemes :    \\0 ) the original time - symmetric integration scheme described by @xcite , where there is a continuous choice of time step size .",
    "this is the approach described in section [ subsec : implicit ] .",
    "we have used five iterations for each step .",
    "\\1 ) a block - time - step generalization , with a fixed number of iterations .",
    "this is the approach analyzed in section [ subsec : flipflop ] . here , too , we chose five iterations for each step .",
    "\\2 ) a block time step generalization , with a variable number of iterations .",
    "if after five iterations , the fourth and the fifth iterations still give a different block time step size , then we choose the smallest of the two .",
    "this recipe avoids flip - flop situations .",
    "it is the approach described in section [ subsec : noflipflop ] .",
    "the algorithm described in the next section , [ subsec : firsttry ] , we have not implemented here , because it is guaranteed to lead to large errors in those cases where a new large time step is allowed again just before pericenter passage .",
    "we therefore switched directly to the following section :    \\3 ) the implementation of our favorite algorithm , where we start with a truly time symmetric choice of time step , with the restrictions that we only allow changes of a factor two in the direction of increasing and decreasing the time step , and that we only allow an increase of time step on the so - called even time boundaries .",
    "this is the approach given in section [ subsec : secondtry ] .    .",
    "the top line with highest slope corresponds to algorithm 1 , the line with intermediate slope corresponds to algorithm 2 , and below those the two lines for algorithms 0 and 3 are indistinguishable in this figure.,scaledwidth=90.0% ]        in figures [ fig1 ] and [ fig2 ] we show the results of integrating our highly eccentric binary with these four integration schemes . in each case , the largest errors are produced by algorithm 1 ) , smaller errors are produced by algorithm 2 ) , and even smaller errors appear with algorithm 3 ) . finally , algorithm 0 ) gives the smallest errors .",
    "figure [ fig1 ] shows the energy error in the two - body integration as a function of time .",
    "as is generally the case for time - symmetric integration , the errors that occur during one orbit are far larger than the systematic error that is generated during a full orbit . to bring this out more clearly , figure",
    "[ fig2 ] shows the error only one time per orbit , at apocenter , the point in the orbit where the two particles are separated furthest from each other , and the error is the smallest .",
    "finally , figure [ fig3 ] shows the same data as figure [ fig2 ] , but for a period of time that is ten times longer . in both figures [ fig2 ] and [ fig3 ] ,",
    "it is clear that the first two block time steps algorithms , 1 ) and 2 ) , both show a linear drift in energy .",
    "this is a clear sign of the fact that they violate time symmetry .",
    "note that in both figures algorithm 3 ) gives rise to a time dependency that looks like a random walk .",
    "this may well be the best that can be done with block time steps , when we require time symmetry .    , but for a duration that is ten times longer.,scaledwidth=90.0% ]",
    "to sum up , we have succeeded in constructing an algorithm for time symmetrizing block time steps that does not show a linear growth of energy errors . as far as we know , this is the first such algorithm that has been discovered .",
    "we expect this algorithm to have practical value for a wide range of large - scale parallel n - body simulations .",
    "we acknowledge conversations with joachim stadel at the ipam workshop on n - body problems in astrophysics , in april 2005 , where he presented a time symmetric version of the preprint by @xcite which is similar to our first attempt at a solution , described in section [ subsec : firsttry ] .",
    "see also his phd thesis , available as `` www-theorie.physik.unizh.ch/~stadel/downloads/thesis.ps '' .",
    "m.k . and h.s .",
    "acknowledge research support from itu - sun ceaet grant 5009 - 2003 - 03 .",
    "p.h . thanks prof .",
    "ninomiya for his kind hospitality at the yukawa institute at kyoto university , through the grants - in - aid for scientific research on priority areas , number 763 , `` dynamics of strings and fields '' , from the ministry of education , culture , sports , science and technology , japan .",
    "hut , p. , funato , y. , kokubo , e. , makino , j. & mcmillan , s. , 1997 , _ time symmetrization meta - algorithms _ , in _ computational astrophysics _ ,",
    "d. a. clarke and m. j. west , asp conference series , vol .",
    "123 ( san francisco : asp ) , pp ."
  ],
  "abstract_text": [
    "<S> time - symmetric integration schemes share with symplectic schemes the property that their energy errors show a much better behavior than is the case for generic integration schemes . allowing adaptive time steps typically leads to a loss of symplecticity . </S>",
    "<S> in contrast , time symmetry can be easily maintained , at least for a continuous choice of time step size . in large - scale n - body simulations , however , one often uses block time steps , where all time steps are forced to take on values as powers of two . </S>",
    "<S> this greatly facilitates parallelization , and hence code efficiency . </S>",
    "<S> straightforward implementation of time - symmetry , translated to block time steps , faces significant hurdles . </S>",
    "<S> for example , iteration can lead to oscillatory behavior , and even when such behavior is suppressed , energy errors show a linear drift in time . </S>",
    "<S> we present an approach that circumvents these problems .    ,    ,    </S>",
    "<S> ,    n - body simulations , celestial mechanics , stellar dynamics    95.10.ce,98.10.+z </S>"
  ]
}