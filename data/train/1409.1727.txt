{
  "article_text": [
    "in some of the problems we may face with complicated functions of the z - transform variable , @xmath0 , whose inverse transform either can not be calculated analytically or the required calculations are quite tedious .",
    "clearly , numerical methods should be used in dealing with such problems to find the inverse z - transform . at this time ,",
    "as far as the author knows , the main contribution in the field of numerical inversion of z - transform is @xcite , which may seem complicated for software implementation .",
    "moreover , so far no application of this method is reported in the literature .",
    "the aim of this brief paper is to represent two very simple and effective methods for numerical inversion of the z - transform , which can be easily implemented by software .    as a well - known classical fact , @xmath1 $ ] and its z - transform @xmath2",
    "are related through the following equation @xmath3=\\frac{1}{2\\pi j}\\oint_c x(z ) z^{n-1}dz,\\ ] ] where @xmath4 is a closed simple counterclockwise contour considered in the region of convergence ( roc ) . at the first looking it may seem that the most straightforward method for obtaining the inverse z - transform of the given @xmath2 is to calculate the integral in ( [ int_z ] ) numerically . for this purpose , assuming",
    "that the roc of @xmath2 is equal to @xmath5 @xmath6 we can perform the numerical integration on the contour @xmath7 , where @xmath8 and @xmath9 is an arbitrarily chosen constant such that @xmath10 . for the absolutely summable @xmath1 $ ]",
    ", @xmath9 can be considered equal to unity which leads to @xmath11=\\frac{1}{2\\pi}\\int_0^{2\\pi } x(e^{j\\omega } ) e^{j\\omega n } d\\omega.\\ ] ] the above equation simply represents the inverse fourier transform of @xmath12 .",
    "the main problem with this approach ( as well as all of the others based on the numerical evaluation of an integral ) is that sometimes it does not lead to accurate results .",
    "more precisely , according to the residue theorem the @xmath1 $ ] calculated from ( [ int_z ] ) must be independent of the special contour used for integration ( which , of course , satisfies the general conditions ) .",
    "but in practice it is observed that when the contour is considered as a circle inside the roc , changing the radius of circle considerably changes the amplitude of the samples of @xmath1 $ ] ( in the numerical examples presented at the end of this paper it is observed that the most accurate results are obtained when the radius of circle is considered equal to unity ) . especially , the numerical integration algorithms may lead to less accurate results for larger values of @xmath13 ( note that the frequency of the kernel of ( [ int_four ] ) is increased by increasing @xmath13 ) .",
    "the other problem with this technique is that for any value of @xmath13 we have to evaluate the integral again , which may be time consuming . by the way , calculation of the inverse z - transform by numerical evaluation of an integral",
    "is a well - known method widely used by researchers .",
    "the aim of this paper is to discuss on two less famous methods .    in the following discussions it is assumed that the signal @xmath1 $ ] whose z - transform is known is equal to zero for all @xmath14 .",
    "moreover , it is assumed that the signal under consideration is absolutely summable which is equal to the fact that all poles of @xmath2 are located inside the unit circle . +",
    "* remark 1 .",
    "* the methods proposed in this paper can still be used even if @xmath1 $ ] is not absolutely summable . for this purpose",
    "we can simply use the equation @xmath15\\right\\ } = x(a^{-1}z)$ ] for some @xmath16 to map all poles of @xmath2 to the region inside the unit circle . + the rest of this paper",
    "is organized as the following .",
    "the first and the second method for numerical inversion of the z - transform are explained in sections 2 and 3 , respectively .",
    "two numerical examples are studied in section 4 .",
    "the first method is based on truncating the absolutely summable signal whose z - transform is known , forming a linear system of algebraic equations , and then solving it . according to the definition of z - transform ,",
    "@xmath1 $ ] and @xmath17\\}$ ] are related through the following equation : @xmath18 z^{-n}.\\ ] ] ( recall that , without a considerable loss of generality , in this paper it is assumed that @xmath2 does not have any poles at infinity , i.e. @xmath19 , which is equivalent to the fact that @xmath1=0 $ ] for @xmath14 ) .",
    "clearly , eq . ( [ sec1 ] ) holds for any @xmath0 in the roc . for example , for @xmath20 we have @xmath21 z_1^{-n}.\\ ] ] considering the fact that @xmath1 $ ] is absolutely summable , in the above equation @xmath1 $ ] tends to zero as @xmath13 tends to infinity .",
    "moreover , the weights @xmath22 in ( [ sec2 ] ) also rapidly tend to zero by increasing the value of @xmath13 provided that @xmath23 ( note that according to the above discussion the region outside the unit circle necessarily belongs to roc ) .",
    "it concludes that the sigma in the righthand side of ( [ sec2 ] ) can safely be approximated by its first few terms as the following : @xmath24 z_1^{-n},\\ ] ] where @xmath25 is chosen sufficiently large .    assuming that @xmath26 are ( random ) points chosen from roc , eq .",
    "( [ sec3 ] ) leads to the following approximate linear algebraic equation : @xmath27 \\\\",
    "x[1 ] \\\\    \\vdots",
    "\\\\    x[n ] \\\\",
    "\\end{array}% \\right),\\end{gathered}\\ ] ] where @xmath28 is the number of ( random ) points chosen from roc .",
    "assuming @xmath29^t$ ] , @xmath30 , \\ldots , x[n]]^t$ ] , and @xmath31 eq . ( [ eq1 ] ) can be written as @xmath32 which contains @xmath25 variables and @xmath28 equations .",
    "assuming @xmath33 this equation ( theoretically ) has a unique solution provided that the points @xmath34 ( @xmath35 ) are suitably chosen such that the @xmath36 given in ( [ a ] ) is full rank .    in the simulations of this paper the value of @xmath28",
    "is considered slightly larger than @xmath25 ( more precisely , @xmath37 ) and the points @xmath34 ( @xmath35 ) are randomly chosen from the region defied by @xmath38 .",
    "then the solution of ( [ eq1 ] ) is obtained by finding the @xmath39 which minimizes @xmath40 ( such a solution can easily be obtained by using the matlab command @xmath41 , i.e. , @xmath42 ) . + * remark 2 . * in practice it is observed that using the @xmath34 such that @xmath43 makes the problem ill - conditioned for larger values of @xmath25 ( even if @xmath34 belongs to roc ) .",
    "hence , points inside the unit circle should be avoided .",
    "as mentioned earlier , the second proposed method is based on the discrete fourier transform ( dft ) , which can effectively be calculated through the fast fourier transform ( fft ) ( see the and commands in matlab ) . before explaining our method , we need to briefly review the main result of dft .",
    "the following discussion can be found in @xcite with more details .",
    "consider the discrete - time signal @xmath1 $ ] for which we have @xmath1=0 $ ] , @xmath14 , and @xmath44\\}=x(e^{j\\omega})$ ] .",
    "obviously @xmath45 is periodic with period @xmath46 .",
    "let us take @xmath25 samples of @xmath45 at each period and denote it as @xmath47 $ ] ; that is @xmath47= x(e^{j\\omega})|_{\\omega=2\\pi k / n}$ ] , @xmath48 .",
    "it can be easily verified that @xmath47 $ ] is also periodic with period @xmath25 .",
    "now , one can prove that @xcite if @xmath47 $ ] ( @xmath49 ) is considered as the coefficients of a periodic signal like @xmath50 $ ] , then @xmath1 $ ] and @xmath50 $ ] are related through the following equation : @xmath51=\\sum_{r=-\\infty } ^\\infty x[n - rn].\\ ] ] considering the fact that @xmath1=0 $ ] for @xmath14 , eq . ( [ dft1 ] ) can further be written as @xmath52=\\sum_{r=-\\infty } ^0 x[n - rn].\\ ] ]    according to the above discussion , the inverse discrete fourier transform ( idft ) of @xmath47 $ ] ( i.e. , the idft of samples of @xmath53\\}$ ] ) is equal to @xmath50 $ ] as given in ( [ dft2 ] ) .",
    "but , @xmath50 $ ] is an approximation for @xmath1 $ ] provided that @xmath54=0 $ ] ( which is the case in our problem since @xmath1 $ ] is assumed to be absolutely summable ) and @xmath25 is chosen sufficiently large .",
    "it concludes that in order to find the inverse z - transform of @xmath2 , whose all poles are located inside the unit circle and has no poles at infinity , first we calculate @xmath55 ( which is valid since the unit circle belongs to roc according to our previous assumption )",
    ". then we calculate the samples of @xmath45 at frequencies @xmath56 , where @xmath49 and @xmath25 is a sufficiently big number .",
    "denote the @xmath57th sample of @xmath45 as @xmath58 $ ] .",
    "taking the idft of @xmath58 $ ] ( using , e.g. , the matlab command ) we arrive at @xmath50 $ ] whose first @xmath25 samples ( i.e. , @xmath50 $ ] for @xmath59 ) are approximately equal to @xmath1 $ ] .",
    "the reason for this statement is that according to ( [ dft2 ] ) we have @xmath60=x[n]+\\sum_{r=-\\infty } ^{-1 } x[n - rn].\\ ] ] but the sigma in the righthand side of ( [ dft3 ] ) converges to zeros very rapidly and consequently we have @xmath50 \\approx x[n]$ ] ( more detailed discussion can be found in the following ) .",
    "the following is a brief explanation of the second method for calculation of the inverse z - transform of @xmath2 whose all poles are located inside the unit circle and has no poles at infinity :    1 .",
    "calculate @xmath61 .",
    "2 .   calculate @xmath58=x(e^{j\\omega})|_{\\omega=2\\pi k / n}$ ] , @xmath62 ( increasing the value of @xmath25 increases the accuracy of results ) .",
    "3 .   calculate the idft of @xmath58 $ ] ( using the matlab command ) to arrive an approximation like @xmath50 $ ] for @xmath1=z^{-1}\\ { x(z)\\}$ ] .      in the following we discuss on the error caused by the above method in a simple case .",
    "according to ( [ dft3 ] ) we have @xmath63=x[n]+\\sum^\\infty_{r=1 } x[n+rn].\\ ] ] the second term in the righthand side of ( [ dft4 ] ) indicates the error caused by the proposed method , i.e. , if @xmath64=0 $ ] then @xmath50=x[n]$ ] and the inversion is errorless .    assuming that @xmath65\\}$ ] is a rational function in @xmath0 whose farthest pole from the origin is simple and located at @xmath66 ( @xmath16 ) , for sufficiently large values of @xmath13 we have @xmath67\\sim a a^n\\quad ( n\\rightarrow\\infty),\\ ] ] for some @xmath68 .",
    "hence , the corresponding error in the @xmath13th sample of @xmath1 $ ] ( assuming sufficiently large values for @xmath25 ) is obtained as the following : @xmath69 = \\sum^\\infty_{r=1 } x[n+rn]\\approx \\sum^\\infty_{r=1 } a a^{n+rn},\\ ] ] which leads to : @xmath70\\approx\\frac{aa^{n+n}}{1-a^n } , \\quad n=0,\\ldots , n-1.\\ ] ] ( note that according to ( [ dft4 ] ) the error in , e.g. , @xmath71 $ ] is equal to @xmath72+x[2n]+x[3n]+\\ldots$ ] . on the other hand , for sufficiently large values of @xmath25",
    "the approximation given in ( [ dft5 ] ) is valid which leads to the error calculated above for the @xmath13th sample of @xmath1 $ ] ) .",
    "it can be easily verified that the error calculated from ( [ err_dft ] ) is a monotonically increasing function of @xmath73 , that is , smaller the value of @xmath74 ( which is equal to the amplitude of the largest pole of @xmath2 ) smaller the amplitude of error in all samples of @xmath50 $ ] .",
    "moreover , it is observed that increasing the value of @xmath25 is highly effective for decreasing the error in @xmath50 $ ] .",
    "in fact , for a fixed @xmath13 the error in @xmath50 $ ] is approximately proportional to @xmath75 , which means that duplication of @xmath25 decreases the error in @xmath50 $ ] by the factor of @xmath75 ( for example , assuming @xmath76 , application of @xmath77 instead of @xmath78 decreases the error @xmath79 times ) .",
    "fortunately , the fft algorithm is capable of working with large values of @xmath25 .",
    "finally , note that according to ( [ err_dft ] ) the absolute error is larger in the first samples of @xmath50 $ ] ( i.e. , smaller values of @xmath13 ) .",
    "a similar discussion can be presented for rational @xmath2 with repeated poles , which is not discussed here . + * remark 3 . *",
    "note that a function in non - integer ( fractional ) powers of @xmath0 can not be obtained by taking the z - transform from any real - world discrete - time signal .",
    "for example , there is no @xmath1 $ ] such that @xmath80\\}=1/(1 - 0.5z^{-0.5})$ ] ( however , there is a @xmath81 such that , e.g. , @xmath82 , where @xmath83 stands for the laplace transform ) .",
    "the reason is that @xmath2 is necessarily single - valued by definition which can not be equal to any multi - valued ( fractional - order ) function of @xmath0 .",
    "that is why the fractional calculus does not have a discrete - time dual .",
    "two numerical examples are presented in this section in support of the proposed methods . in each case",
    ", the numerical inversion is performed directly by using ( [ int_four ] ) as well as the proposed algorithms , and then the results are compared . in all of the following simulations ,",
    "the integrals in ( [ int_z ] ) and ( [ int_four ] ) are evaluated numerically using the matlab r2009a command .",
    "+ * example 1 . *",
    "consider @xmath84 whose roc is equal to @xmath85 . the inverse z - transform of this function can be obtained through the laurent series expansion as the following @xmath86 which concludes that @xmath87=0,\\quad x[1]=x[2]=1 , \\quad x[3]=\\frac{1}{3}\\ ] ] @xmath88=0,\\quad x[5]=\\frac{1}{30 } , \\ldots\\ ] ] and @xmath1=0 $ ] , @xmath14 . figs .",
    "[ fig_ex11](a)-(c ) show the inverse z - transform of @xmath2 when the first method , second method , and eq .",
    "( [ int_four ] ) is applied , respectively . figs .",
    "[ fig_ex12](a)-(c ) show the absolute error caused by each of these methods , respectively .",
    "as mentioned earlier , in case of using ( [ int_z ] ) we will see that ( in practice ) the value of @xmath1 $ ] depends on the especial shape of the contour @xmath4",
    "[ fig_ex13](a)-(c ) show the @xmath1 $ ] obtained through ( [ int_z ] ) when @xmath4 is considered as a circle with radius @xmath89 , respectively .",
    "as it can be observed in this figure , the radius of contour highly affects the resulted @xmath1 $ ] .",
    "however , comparing fig .",
    "[ fig_ex13 ] with fig .",
    "[ fig_ex11 ] concludes that the most accurate result corresponds to @xmath90 .",
    "+          * example 2 . *",
    "consider the z - transform given in the following expression @xmath91 which can further be written as @xmath92 as it is observed , according to the complexity of the resulted expression it is really difficult to extract the complete inverse z - transform from it ( however , it can be easily verified that @xmath93=x[1]=e$ ] and @xmath94=e(1/2!+1/2!)=e$ ] ) .",
    "[ fig_ex21](a)-(c ) show the inverse z - transform of @xmath2 when the first method , second method , and eq .",
    "( [ int_four ] ) is applied , respectively . figs .",
    "[ fig_ex22](a)-(c ) show the absolute error caused by each of these methods . figs .",
    "[ fig_ex23](a)-(c ) show the @xmath1 $ ] obtained through ( [ int_z ] ) when @xmath4 is considered as a circle with radius @xmath89 , respectively .",
    "this figure clearly shows that the most accurate result corresponds to @xmath90 ."
  ],
  "abstract_text": [
    "<S> in some of the problems , complicated functions of the z - transform variable , @xmath0 , appear which either can not be inverted analytically or the required calculations are quite tedious . in such cases numerical methods should be used to find the inverse z - transform . </S>",
    "<S> the aim of this paper is to propose two simple and effective methods for this purpose . </S>",
    "<S> the only restriction on the signal ( whose z - transform is given ) is that it must be absolutely summable ( of course , this limitation can be removed by a suitable scaling ) . </S>",
    "<S> the first proposed method is based on the discrete fourier transform ( dft ) and the second one is based on solving a linear system of algebraic equations , which is obtained after truncating the signal whose z - transform is known . </S>",
    "<S> numerical examples are also presented to confirm the efficiency of the proposed methods . </S>",
    "<S> functions in non - integer powers of @xmath0 are also briefly discussed and it is shown that such functions can not be obtained by taking the z - transform from any discrete - time signal .    </S>",
    "<S> numerical inverse z - transform , discrete fourier transform , irrational , fractional , non - integer power of @xmath0 </S>"
  ]
}