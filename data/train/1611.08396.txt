{
  "article_text": [
    "cpu - enforced memory protection is fundamental to modern computer security : for each memory access request , the cpu verifies whether this request meets the memory access policy .",
    "however , the infamous rowhammer attack  @xcite undermines this access control model by exploiting a hardware fault ( triggered through software ) to flip targeted bits in memory .",
    "the cause for this hardware fault is due to the tremendous density increase of memory cells in modern dram chips , allowing electrical charge of one memory cell to affect that of an adjacent memory cell .",
    "[ ref : refresh ] unfortunately , increased refresh rates of dram modules  as suggested by some hardware manufacturers  can not eliminate this effect  @xcite .",
    "in fact , the fault appeared as a surprise to hardware manufacturers , simply because it does not appear during normal system operation .",
    "rowhammer attacks repetitively read ( _ hammer _ ) from the same physical memory address in very short time intervals which eventually leads to a bit flip in a physically co - located memory cell",
    ".    * rowhammer attack diversity .",
    "* although it might seem that single bit flips are not per - se dangerous , recent attacks demonstrate that rowhammer can be used to undermine access control policies and manipulate data in various ways",
    ". in particular , it allows for tampering with the isolation between user and kernel mode  @xcite . for this",
    ", a malicious user - mode application locates vulnerable memory cells and forces the operating system to fill the physical memory with page - table entries ( ptes ) , i.e. , entries that define access policies to memory pages . manipulating one pte by means of a bit flip allows the malicious application to alter memory access policies , building a custom page table hierarchy , and finally assigning kernel permissions to a user - mode memory page .",
    "rowhammer attacks have made use of specific cpu instructions to force dram access and avoid cache effects .",
    "however , prohibiting applications from executing these instructions , as suggested in  @xcite , is ineffective because recent rowhammer attacks do no longer depend on special instructions  @xcite . as such",
    ", rowhammer has become a versatile attack technique allowing compromise of co - located virtual machines  @xcite , and enabling sophisticated control - flow hijacking attacks  @xcite without requiring memory corruption bugs  @xcite .",
    "lastly , a recent attack , called drammer  @xcite , demonstrates that rowhammer is not limited to x86-based systems but also applies to mobile devices running arm processors",
    ".    * rowhammer mitigation . *",
    "the common belief is that the rowhammer fault can not be fixed by means of any software update , but requires production and deployment of redesigned dram modules .",
    "hence , existing legacy systems will remain vulnerable for many years , if not forever .",
    "an initial defense approach performed through a bios update was unsuccessful as it only slightly increased the difficulty to conduct the attack  @xcite .",
    "the only other software - based mitigation of rowhammer , we are aware of , is a heuristic - based approach that relies on hardware performance counters  @xcite .",
    "however , it induces a worst - case overhead of 8% and suffers from false positives which impedes its deployment in practice .",
    "* goals and contributions . *",
    "the goal of this paper is to develop the first practical and generic software - based defenses against rowhammer attacks that can instantly protect existing vulnerable legacy systems without suffering from any performance overhead and false positives .",
    "intuitively , a defense against rowhammer needs to prevent the dangerous bit flips by disabling vulnerable memory pages .",
    "kim et al .",
    "@xcite were first discussing this idea , however , they conclude that this mitigation will generate very high overhead and significantly reduce the amount of available memory . to validate this defense approach , we developed our first mitigation scheme , called , that systematically scans the memory to identify and blacklist vulnerable memory pages .",
    "we implemented as a bootloader extension to support and protect a wide range of operating systems .",
    "in contrast , to the conclusion drawn in  @xcite , we show that is highly efficient and prevents all existing rowhammer attacks . on the other hand ,",
    "it is not yet known whether memory vulnerable to bit flips changes over time or under different experiment conditions ( e.g. , temperature , methodology to identify bit flips ) . this motivated us to develop a second and more generic mitigation scheme , called , that does not aim to prevent bit flips but rather remove the dangerous effects ( i.e. , exploitation ) of bit flips .",
    "this is achieved by limiting bit flips to memory pages that are already in the address space of the malicious application , i.e. , memory pages that are per - se untrusted . for this",
    ", we extend the operating system kernel to enforce a strong physical isolation of different system entities , e.g. , user and kernel space .    to summarize ,",
    "our main contributions are :    * we present practical software - based defenses against rowhammer .",
    "in contrast to existing solutions , our defenses require no hardware changes  @xcite , do not deploy unreliable heuristics  @xcite , and still allow legacy applications to execute instructions that are believed to alleviate rowhammer attacks  @xcite .",
    "* we systematically revisit the practicality and effectiveness of an intuitive mitigation approach that proposes marking memory , vulnerable to rowhammer , unavailable to the system .",
    "we also developed a prototype , , which implements this approach for the first time .",
    "* we propose a generic enforcement mechanism for operating system kernels , , to mitigate rowhammer attacks .",
    "our design ensures that the attacker can only flip bits in memory that is already under her control .",
    "* we present two prototype implementations , one for the linux kernel version  4.6and one for the grub bootloader , and demonstrate their effectiveness in mitigating all previously presented rowhammer attacks  @xcite . [ ref : armintro ] * we successfully applied our linux kernel patch for to the android version  4.4for google s nexus devices .",
    "this allows us to also mitigate drammer  @xcite , a recent rowhammer - based privilege escalation exploit on arm .",
    "* we extensively evaluate the performance , robustness and security of our defense approaches against rowhammer attacks to demonstrate the effectiveness and high practicality of both  and .",
    "in particular , our performance measurements indicate no computational overhead for common user and kernel benchmarks .",
    "[ ref : focus - kexpl ] note that recent research demonstrates a variety of exploitation strategies that rely on rowhammer  @xcite .",
    "while these attacks show the versatility of rowhammer , they are not always practical .",
    "for example , attacking the browser with rowhammer can take up to 45 minutes  @xcite , and attacking a virtual machine may require a couple of days of preparation time  @xcite .",
    "hence , our proof - of - concept implementation of aims to mitigate practical rowhammer attacks that escalate the privileges to the superuser root by manipulating the kernel page tables  @xcite .",
    "we discuss further deployment cases in section  [ sec : disc : gcatt ] .",
    "in this section we provide the basic background knowledge necessary for understanding the remainder of this paper .",
    "a dram module , as shown in figure  [ fig : dram ] , is structured hierarchically .",
    "the hardware module is called dual inline memory module ( dimm ) , which is physically connected through a channel to the memory controller .",
    "modern desktop systems usually feature two channels facilitating parallel accesses to memory .",
    "the dimm can be divided into one or two ranks corresponding to its front- and backside .",
    "each rank contains multiple banks which are the chips that contain the memory cells .",
    "each bank is organized in columns and rows , as shown in figure  [ fig : dram2 ] .",
    "an individual memory cell consists of a capacitor and a transistor . to store a bit in a memory cell ,",
    "the capacitor is electrically charged . by reading a bit from a memory cell ,",
    "the cell is discharged , i.e. , read operations are destructive . to prevent information loss , read operations also trigger a process that writes the bit back to the cell .",
    "a read operation always reads out the bits from a whole row , and the result is first saved in the row buffer before it is then transferred to the memory controller .",
    "the row buffer is also used to write back the content into the row of memory cells to restore their content .",
    "it is noteworthy to mention that there exists a non - linear mapping between physical memory address and the rank - bank - row on the hardware module .",
    "consequently , two consecutive physical memory addresses can be mapped to memory cells that are located on different ranks , banks , or rows .",
    "for example , on intel ivy bridge cpus the 20th bit of the physical address determines the rank . as such , the consecutive physical addresses 0x2fffff and 0x300000 can be located on front and back side of the dimm for this architecture .",
    "the knowledge of the physical memory location on the dimm is important for both rowhammer attacks and defenses , since bit flips can only occur on the same bank . for intel processors ,",
    "the exact mapping is not officially documented , but has been reverse engineered  @xcite .          as mentioned",
    "before , memory access control is an essential building block of modern computer security , e.g. , to achieve process isolation , isolation of kernel code , and manage read - write - execute permission on memory pages .",
    "modern systems feature a variety of mechanisms to isolate memory , e.g. , paging  @xcite , virtualization  @xcite , iommu  @xcite , and special execution modes like sgx  @xcite and smm  @xcite .",
    "however , these mechanisms enforce their isolation through hardware that mediates the physical memory accesses ( in most cases the cpu ) .",
    "hence , memory assigned to isolated entities can potentially be co - located in physical memory on the same bank .",
    "since a rowhammer attack induces bit flips in co - located memory cells , it provides a subtle way to launch a remote attack to undermine memory isolation .",
    "recently , various rowhammer - based attacks have been presented .",
    "specifically , rowhammer was utilized to undermine isolation of operating system and hypervisor code , and escape from application sandboxes leveraged in web browsers . in the following ,",
    "we describe the challenges and workflow of rowhammer attacks . a more elaborated discussion on real - world , rowhammer - based exploits will be provided in section  [ sec : relatedwork ] .",
    "the rowhammer fault allows an attacker to influence the electrical charge of individual memory cells by activating neighboring memory cells . in particular ,",
    "kim et al .",
    "@xcite demonstrate that repeatedly activating two rows separated by only one row , called _ aggressor rows _",
    "( and   in figure  [ fig : dram2 ] ) , lead to a bit flip in the enclosed row  , called _ victim row_. to do so , the attacker has to overcome the following challenges : ( i )  undermine memory caches to directly perform repetitive reads on physical dram memory , and ( ii )  gain access to memory co - located to data critical to memory isolation .",
    "overcoming challenge ( i ) is complicated because modern cpus feature different levels of memory caches which mediate read and write access to physical memory .",
    "caches are important as processors are orders of magnitude faster than current dram hardware , turning memory accesses into a bottleneck for applications  @xcite .",
    "usually , caches are transparent to software , but many systems feature special instructions , e.g. , ` clflush ` or ` movnti ` for x86  @xcite , to undermine the cache .",
    "further , caches can be undermined by using certain read - access patterns that force the cache to reload data from physical memory .",
    "such patterns exist , because cpu caches are much smaller than physical memory , and system engineers have to adopt an eviction strategy to effectively utilize caches . through alternating accesses to addresses which reside in the same cache line",
    ", the attacker can force the memory contents to be fetched from physical memory .",
    "the attacker s second challenge ( ii ) is to achieve the physical memory constellation shown in figure  [ fig : dram2 ] .",
    "the attacker needs access to the aggressor rows in order to be able to activate ( _ hammer _ ) them ( rows and   in figure  [ fig : dram2 ] ) .",
    "additionally , the victim row must contain data which is attackable by a bit flip ( in figure  [ fig : dram2 ] ) .",
    "both conditions can not be enforced by the attacker , however , he can achieve them with high probability through the following approaches .",
    "first , the attacker allocates memory hoping that the aggressor rows are contained in the allocated memory .",
    "if the operating system maps the attacker s allocated memory to the physical memory containing the aggressor rows the attacker has achieved the first condition .",
    "since the attacker has no influence on the mapping between virtual memory and physical memory he can not directly influence this step , but he can increase the probability by allocating large amounts of memory ; also , the attacker can repeat this step until he succeeds .",
    "once the attacker has the aggressor rows under his control he releases all allocated memory except the parts containing the aggressor rows .",
    "next , the attacker needs the data he wants to manipulate to be stored in the victim row .",
    "again , he can not directly influence which data is stored in the physical memory and needs to resort to a probabilistic approach .",
    "the attacker induces the creation of many copies of the victim data with the goal that one copy of the victim data will be placed in the victim row .",
    "the attacker can not directly verify whether the second step was successful , he has to execute the rowhammer attack and check if the attack is successful , otherwise he has to repeat the second step .    in  @xcite , the authors successfully implemented this approach to compromise the kernel from an unprivileged user process .",
    "they gain control over the aggressor rows and then make the os create huge amounts of page table entries with the goal of placing one page table entry in the victim row . by flipping a bit in a page table entry",
    "the authors gain control over a subtree of the page tables allowing them to manipulate memory access control policies .",
    "our threat model is in line with related work  @xcite : rowhammer - based attacks assume that the adversary is capable of executing malicious code in an isolated environment .",
    "depending on the attack scenario , the isolated environment can be a javascript to launch browser - based attacks , a malicious user - mode application to construct kernel exploits , or an entire operating system for running attacks against co - located virtual machines in a cloud setting .",
    "the goal of an adversary is to undermine the isolation . in other words ,",
    "the attacker aims to break out of the established trust boundary by inducing bit flips in memory that does not belong to the isolated environment .",
    "ultimately , an adversary gains a higher privilege level than originally assigned to the isolated environment .",
    "our threat model differentiates between _ reliable _ and _ unreliable _ bit flips .",
    "the former can be reproduced , e.g. , across multiple reboots , the latter can not be produced on every attempt to flip a bit through rowhammer .",
    "note that _ all _ available rowhammer - based attacks depend on reliable bit flips .",
    "however , in this paper , we consider software - defenses against both types of bit flips .",
    "in this section , we present the high - level idea and design of our practical software - based defenses against rowhammer attacks .",
    "our first defense , dubbed , mitigates malicious _ bit flips _ by marking memory vulnerable to rowhammer as unavailable at boot - time . in contrast , our second defense , called , tackles the malicious _ effect _ of rowhammer - induced bit flips by instrumenting the operating system s memory allocator to constrain bit flips to the boundary where the attacker s malicious code executes ( cf .",
    "section  [ sec : threat - model ] ) .",
    "both solutions and are completely transparent to applications , and do not require any hardware changes .",
    "we provide a detailed description of our implementation of both solutions in section  [ ref : limite820 ] .",
    "prior to launching a rowhammer attack , the attacker needs to probe the memory to locate vulnerable memory .",
    "hence , a software - only defense needs to identify the vulnerable memory parts and mark them as unavailable .",
    "while simple in theory , it was commonly believed that this defense strategy is inefficient and significantly reduces the amount of available memory  @xcite . to validate this",
    ", we developed , a new bootloader extension that locates and disables vulnerable memory parts ( see figure  [ fig_b - catt_design ] ) .",
    "implementing this defense strategy is challenging without inducing performance penalties .",
    "while we investigated different implementation strategies , we opted for a bootloader extension in order to protect a wide range of operating systems .",
    "that is , our bootloader - based approach does not require any changes to the operating system and is fully compatible with legacy systems .    in general ,",
    "all bootloaders commit a list of available memory to the operating system  ( ) . this list is dynamically obtained during boot time using the system s firmware ( e.g. , bios / uefi ) .",
    "it is common that certain physical memory addresses can not be used by the operating system , e.g. , the memory reserved for hardware devices such as graphics or network cards .",
    "extends the bootloader and hooks into this process .",
    "specifically , it adds the physical addresses of vulnerable memory to the list of unavailable memory  ( ) . to locate vulnerable addresses , we re - use techniques from existing rowhammer exploitation tools  @xcite and slightly adjust them for the purpose of our approach .",
    "note that this analysis is performed offline prior the system is protected with  ( ) . from the operating system",
    "s perspective , the vulnerable physical memory simply becomes unavailable  ( ) . since handling unavailable memory regions is a core functionality of operating systems , adheres to common system functionality .",
    "note that takes a snapshot of vulnerable memory addresses .",
    "since there is no security guarantee that vulnerable memory changes over time or other memory addresses get vulnerable under different test conditions , we developed a second prototype that provides long - term protection against rowhammer attacks .",
    "our second defense , called , follows a different and more generic defense strategy : it tolerates rowhammer - induced bit flips , but prevents bit flips from affecting memory belonging to higher - privileged _ security domains _ , e.g. , the operating system kernel or co - located virtual machines . as discussed in section  [ sec : background : rowhammer ] , a rowhammer attack requires the adversary to bypass the cpu cache .",
    "further , the attacker must arrange the physical memory layout such that the targeted data is stored in a row that is physically adjacent to rows that are under the control of the attacker .",
    "hence , ensures that memory between these two entities is physically separated by at least one row .",
    "to do so , extends the physical memory allocator to partition the physical memory into security domains . supports a wide range of memory partitioning levels , i.e.",
    ", the granularity of security domainscan be tuned from coarse - grained levels such as the separation between user and kernel memory to fine - grained memory partition within a single process .",
    "figure  [ fig_g - catt_design ] illustrates the concept . without the attacker",
    "is able to craft a memory layout , where two aggressor rows enclose a victim row of a higher - privileged domain such as row in figure  [ fig : dram2 ] . with in place ,",
    "the rows which are controlled by the attacker are grouped into the security domain  a , whereas memory belonging to higher - privileged entities resides with their own security domain(e.g .",
    ", the security domain  b ) .",
    "both domains are physically separated by at least one row which will not be assigned to any security domain .    * security domains . * the definition of security domainsis critical to ensure the effectiveness of .",
    "judging from previous privilege escalation attacks , good candidates for such domains are kernel and user - mode , virtual machines , as well as plugins and scripts in web browsers .",
    "privilege escalation attacks are popular and pose a severe threat to modern systems . in particular , the isolation of kernel and user - mode is critical and the most appealing attack target . if a user - space application gains kernel privileges , the adversary can typically compromise the entire system . due to the importance of these attacks and the fact that rowhammer - based exploits on kernels are highly practical , we focus our proof - of - concept implementation on kernel and user - space isolation .",
    "that is , we define and maintain two security domains : a security domainfor kernel memory allocations , and one security domainfor user - mode memory allocations ( see also figure  [ fig_g - catt_design ] ) .",
    "note that can be extended to support further security domains .",
    "for instance , in virtualized environments , virtual machines as well as the hypervisor can be treated as individual security domains . to prevent rowhammer attacks crossing the isolation boundaries of processes in user - mode , would need to assign security domainsat the granularity of processes .",
    "however , many security domainsassociated with many memory allocations and deallocations will eventually lead to inefficient usage of memory , i.e. , memory fragmentation .",
    "if memory fragmentation is an issue , could resort in only assigning a dedicated security domain for untrusted third - party processes . for in - process isolation , e.g. , to prevent rowhammer - based sandboxing escapes in browsers",
    "@xcite , needs to distinguish the allocations of trusted browser code and untrusted sandboxed code .",
    "although we have not yet implemented security domainsbeyond kernel and user - mode , we believe that there no major conceptual obstacles in supporting security domainsfor each of the described scenarios",
    ".    * challenges . *",
    "the physical isolation of data raises the challenge of how to effectively isolate the memory of different system entities . to tackle this challenge ,",
    "we first require knowledge of the mapping between physical addresses and memory banks . since an attacker can only corrupt data within one bank , but not across banks , only has to ensure that security domainsof different system entities are isolated within each bank .",
    "however , as mentioned in section  [ sec : background : dram - mapping ] , hardware vendors do not specify the exact mapping between physical address and banks .",
    "fortunately , pessl et al .",
    "@xcite and xiao et al .",
    "@xcite provide a methodology to reverse engineer the mapping . for , we use this methodology to discover the physical addresses of rows .",
    "lastly , we need to ensure that the physical memory management component is aware of the isolation policy . this is vital as the memory management components have to ensure that newly allocated memory is adjacent only to memory belonging to the same security domain . to tackle this challenge",
    ", we instrumented the memory allocator to keep track of the domain association of physical memory and serve memory requests by selecting free memory from different pools depending on the security domain of the requested memory .",
    "both of our software - based defenses are based on modifications to low - level system software components , i.e. , the bootloader ( ) and the operating system kernel ( ) .",
    "we chose grub2 and linux 4.6 as targets for our proof - of - concept implementations for two reasons : ( 1 ) their source code is freely available , and ( 2 ) both projects are widely used .",
    "first , we briefly describe how blacklists rowhammer - affected pages .",
    "thereafter , we explain the implementation of s policy enforcement mechanism in the linux kernel which allows for the partitioning of physical memory into isolated security domains .",
    "note that our prototype implementation of targets x86-based systems , whereas targets both x86 and arm - based systems . until today",
    ", rowhammer attacks have been only demonstrated for these two prominent architectures .",
    "furthermore , as mentioned before , our prototype implementations target rowhammer exploits that aim at violating the isolation between kernel and user - mode since these are the most prominent and practical types of rowhammer exploits .      to mitigate the exploitation of the rowhammer hardware bug in legacy systems , features a blacklisting mechanism to prevent the operating system from using vulnerable pages .",
    "recall that kim et al .",
    "@xcite concluded that blacklisting is not practical if the majority of rows are susceptible to rowhammer .",
    "however , our evaluation ( section  [ sec : eval : rowhammertest : bcatt ] ) suggests that only a fraction of rows are vulnerable in practice .",
    "this is also in line with previous work  @xcite .",
    "in fact , we noticed that blacklisting vulnerable memory is highly practical as it only requires a small extension to the bootloader ( 64 lines of code ) .",
    "we exploit the fact that operating systems already feature a function that allows blacklisting certain physical memory addresses .",
    "specifically , x86 compatible operating systems detect usable memory through the so - called ` e820 map `  @xcite .",
    "this map contains a list of usable physical memory",
    ". it can be obtained from the bios through the interrupt number 0xe820 . on modern systems ,",
    "this map is not directly requested by the operating system .",
    "in contrast , the bootloader forwards the map to the operating system .",
    "[ ref : limite820 ] to prevent rowhammer attacks , instruments the grub2 bootloader to add physical addresses of vulnerable memory to the ` e820 map ` .",
    "note that the original e820 specification only supports 128 entries .",
    "however , the efi platform initialization specification  which is also supported by grub2  does not limit the number of entries  @xcite .",
    "in fact , grub2 first allocates a buffer to store both the original e820 map and additional entries . once it has stored the original e820 entries into this buffer , it passes a pointer to this buffer to the operating system .",
    "our patch increases the size of the allocated buffer to additionally fit the entries for the blacklisted pages .",
    "[ sec : highlvl : gcatt ]        figure  [ fig : bcatt - detail ] depicts the detailed workflow of . after upgrading the existing grub2 installation ,",
    "the vulnerable memory rows are identified with the help of publicly available tools during an offline analysis  @xcite .",
    "these programs scan the memory of the machine for vulnerable pages by allocating large amounts of memory and trying to produce bit flips .",
    "we made some modifications , which we describe in detail in section [ sec : rowhammer - test ] .",
    "further , these rows are included as an environment variable in the boot configuration file of grub2 ( step  ) .",
    "next , the bios starts grub2 which then requests the ` e820 map ` ( step   ) .",
    "before grub2 starts the operating system , it reads out the environment variable and extends the ` e820 map ` ( step   ) .",
    "henceforth , the linux kernel will not use the vulnerable memory thereby preventing the attacker from leveraging rowhammer - based attacks .      in our proof - of - concept implementation of",
    ", we focus on hardening linux against rowhammer - based attacks since its memory allocator is open - source .",
    "we successfully applied the described changes to the x86-kernel version 4.6 and the android kernel for nexus devices in version 4.4.[ref : armimpl ]    the basic idea underlying our generic software - based rowhammer defense is to physically separate rows that belong to different security domains .",
    "operating systems are not per - se aware of the notions of cells and rows , but rather build memory management based on paging .",
    "commodity operating systems use paging to map virtual addresses to physical addresses .",
    "the size of a page varies among architectures . on x86 and arm ,",
    "the page size is typically 4096 bytes ( 4k ) . as we described in section",
    "[ sec : background : dram - mapping ] , dram hardware consists of much smaller units of memory , i.e. , individual memory cells storing single bits .",
    "eight consecutive memory cells represent a byte , 4096 consecutive bytes a page frame , two to four page frames a row . hence , our implementation of changes low - level components of the kernel to make the operating system aware of the concept of memory rows .    in the following ,",
    "we describe how we map individual memory pages to domains , keep track of different domains , modify the physical memory allocator , and define partitioning policies for the system s dram hardware .      to be able to decide whether two pages belong to the same security domain we need to keep track of the security domain for each page frame .",
    "fortunately , the kernel already maintains meta data about each individual page frame .",
    "more specifically , each individual page frame is associated with exactly one meta data object ( ` struct page ` ) .",
    "the kernel keeps a large array of these objects in memory .",
    "although these objects describe physical pages , this array is referred to as _ virtual memory map _ , or ` vmemmap ` . the page frame number ( pfn ) of a physical page",
    "is used as an offset into this array to determine the corresponding ` struct page ` object . to be able to associate a page frame with a security domain , we extend the definition of ` struct page ` to include a field that encodes the security domain .",
    "since our prototype implementation targets rowhammer attacks that aim at violating the separation of kernel and user - space , we encode security domain 0 for kernel - space , and 1 for user - space . for preventing rowhammer attacks crossing the process boundary , could exploit the process identification number ( pid ) to distinguish security domains . as such",
    ", each process will be treated as a separate security domain , and the kernel will be associated with its own security domain .",
    "the extension of the page frame meta data objects enables us to assign pages to security domains .",
    "however , this assignment is dynamic and changes over time . in particular , a page frame may be requested , allocated , and used by one domain , after it has been freed by another domain .",
    "note that this does not violate our security guarantees , but is necessary for the system to manage physical memory dynamically . yet",
    ", we need to ensure that page frames being reallocated continue to obey our security policy .",
    "therefore , we reset the security domain upon freeing a page .    upon memory allocation ,",
    "needs to correctly set the security domain of the new page . to do so , we require information about the requesting domain . for our case , where we aim at separating kernel and user - space domains ,",
    "utilizes the call site information , which is propagated to the memory allocator by default .",
    "specifically , each allocation request passes a range of flags to the page allocator .",
    "these flags encode whether an allocation is intended for the kernel or the user - space .",
    "we leverage this information and separate the two domains by setting the domain field of the respective page frame .",
    "when processes request memory , the kernel initially only creates a virtual mapping without providing actual physical page frames for the process .",
    "instead , it only assigns physical memory on demand , i.e. , when the requesting process accesses the virtual mapping a page fault is triggered .",
    "thereafter , the kernel invokes the physical page allocator to search for usable pages and installs them under the virtual address the process attempted to access .",
    "we modified the page fault handler , which initiates the allocation of a new page , to pass information about the security domain to the page allocator .",
    "next , the page is allocated according to our policy and sets the domain field of the page frame s meta data object to the security domain of the interrupted process .",
    "the linux kernel uses different levels of abstraction for different memory allocation tasks .",
    "the physical page allocator , or _ zoned buddy allocator _ is the main low - level facility handling physical page allocations .",
    "it exports its interfaces through functions such as ` alloc_pages ` , which can be used by other kernel components to request physical pages .",
    "in contrast to higher - level allocators , the buddy allocator only allows for allocating sets of memory pages with a cardinality which can be expressed as a power of two ( this is referred to as the _ order _ of the allocation ) .",
    "hence , the buddy allocator s smallest level of granularity is a single memory page .",
    "we modify the implementation of the physical page allocator in the kernel to include a mechanism for separating and isolating allocated pages according to the security domain of the origin of the allocation request .",
    "in particular , the page allocator already performs maintenance checks on free pages .",
    "we extend these maintenance checks to add our partitioning policy before the allocator returns a physical page .",
    "if this check fails , the page allocator is not allowed to return the page in question , but has to continue its search for another free page .",
    "separating and isolating different security domains is essential to our proposed mitigation .",
    "for this reason , we incorporate detailed knowledge about the platform and its dram hardware configuration into our policy implementation .",
    "while our policy implementation for a target system largely depends on its architecture and memory configuration , this does not represent a fundamental limitation .",
    "indeed , independent research  @xcite has provided the architectural details for the most prevalent architectures , i.e. , it shows that the physical address to dram mapping can be reverse engineered automatically for undocumented architectures .",
    "hence , it is possible to develop similar policy implementations for architectures and memory configurations beyond x86 and arm .",
    "we build on this prior research and leverage the physical address to dram mapping information to enforce strict physical isolation . in the following ,",
    "we describe our implementation of the partitioning strategy for isolating kernel and user - space , as well as providing an implementation strategy for isolating individual user processes .",
    "* kernel - user isolation .",
    "* to achieve physical separation of user and kernel space we adopt the following strategy : we divide each bank into a top and a bottom part , with a separating row in - between .",
    "page frames for one domain are exclusively allocated from the part that was assigned to that domain .",
    "the part belonging to the kernel domain is determined by the physical location of the kernel image . as a result",
    ", user and kernel space allocations may be co - located within one bank , but never within adjacent rows .",
    "different partitioning policies would be possible in theory : for instance , we could confine the kernel to a certain dram bank to avoid co - location of user domains within a single bank . however , this would likely result in a severe increase of memory latency , since reads and writes to a specific memory bank are served by the bank s row buffer .",
    "the benefit of our partitioning policy stems from the fact that we distribute memory belonging to the kernel security domain over multiple banks thereby not negatively impacting performance . for our solution towards kernel isolation , we only need to calculate the row index of a page frame .",
    "more specifically , we calculate this index from the physical address ( pa ) in the following way :    @xmath0    because all possible row indices are present once per bank , this equation determines the row index of the given physical address .",
    "we note , that this computation is in line with the available rowhammer exploits @xcite and the reported physical to dram mapping recently reverse engineered @xcite .",
    "since the row index was shown to depend only on the number of dram modules for all intel architectures prior to skylake @xcite , our implementation for this policy is applicable to a wide range of system setups , and can be adjusted without introducing major changes to fit other configurations as well .",
    "* isolating user processes . * to physically isolate individual user processes , we suggest a more flexible partitioning policy , i.e. , not requiring user space pages to be confined to a certain part of dram .",
    "instead , we propose to check process pages for conflicting security domains dynamically .",
    "for instance , the kernel could prevent the physical memory allocator from assigning a page to a process , which contains neighboring memory cells in the rows directly above or below , that already belong to another process . in case",
    "such a memory constellation is detected , the buddy allocator would deny handing out the page , otherwise it would be allowed to assign the page to the requesting process . while this partitioning policy is much more fine - grained than the policy",
    "we adopt for isolating the kernel from processes , our implemented mechanism supports such a strategy in principle .",
    "however , implementing this policy is more complex than maintaining a fixed boundary between two domains , since we also need to calculate the channel , rank , and bank index for each page frame in this case .",
    "hence , an implementation of a process - isolation policy is more specific to the individual hardware setup and would require several different implementations to support additional hardware configurations .",
    "[ cols= \" < , < , < , < , < , < , < , < , < , < , < \" , ]     our mitigations restrict the operating systems access to the physical memory . to ensure that this has no effect on the overall stability",
    ", we performed numerous stress tests with the help of the linux test project ( ltp )  @xcite .",
    "these tests are designed to cause problems for the operating system .",
    "we first run these tests on a vanilla debian 8.2 installation to receive a baseline for the evaluation of and .",
    "we summarize our results in table  [ tab : robustness ] , and report no deviations for our mitigations compared to the baseline .",
    "further , we also did not encounter any problems during the execution of the other benchmarks .",
    "thus , we conclude that and do not affect the stability of the protected system .",
    "both of our prototype implementations target linux - based systems .",
    "linux is open - source allowing us to implement our defenses .",
    "further , all publicly available rowhammer attacks target this operating system . already protects all operating systems that can be loaded with the commodity bootloader grub2 .",
    "further , can be easily ported to memory allocators deployed in other operating systems . in this section ,",
    "we discuss in detail the generality and coverage aspects of our software - based defenses against rowhammer .",
    "[ sec : disc : bcatt ] extending the grub2 bootloader to blacklist vulnerable memory allows us to protect all linux - based systems , openbsd , and xen  @xcite .",
    "xen is an open - source hypervisor that is widely deployed on production systems .",
    "similar to the linux kernel , xen receives the list of available and reserved memory through grub2 .",
    "hence , the current implementation of can defeat recently presented rowhammer attacks in a cloud scenario  @xcite .",
    "unfortunately , grub2 is not capable of directly booting windows systems .",
    "instead , in order to boot windows , grub2 starts the native bootloader of the windows installation .",
    "this process is called _",
    "chainloading_. grub2 does not pass the list of unavailable memory addresses to the windows bootloader , i.e. , the windows components discover the memory layout by themselves . to make available to windows three approaches are possible :",
    "( 1 )  microsoft extends its bootloader to include the modifications we applied to grub2 .",
    "( 2 )  the bios vendor adapts and provides a modified ` e820 ` which includes vulnerable memory .",
    "( 3 )  grub2 hooks into the ` e820 ` bios interrupt allowing to add vulnerable memory when the windows bootloader searches for usable memory .    in the current implementation of we",
    "do not support uefi .",
    "however , since uefi provides a similar mechanism to the ` e820 map ` , there are no obstacles to add support for uefi in .",
    "[ sec : disc : gcatt ] with our current implementation of we focus on isolating the user and kernel memory to prevent privilege escalation attacks , because this is the most practical and single publicly available attack vector .",
    "however , as described in section  [ sec : impl : processisolation ] , we are currently looking into isolating memory of user processes , i.e. , assigning a security domainper process .",
    "although we are not aware of any cross - process rowhammer attacks we anticipate to see such attacks in the future as an alternative to kernel - based privilege escalation attacks .",
    "further , these attacks are conceptually similar to cross - vm attacks which have been already demonstrated recently  @xcite .    by isolating the physical memory of different processes ,",
    "can stop such attacks ( cf . section  [ sec : impl : processisolation ] ) .",
    "similarly , when implementing in the hypervisor , physical memory of different virtual machines ( vms ) can be isolated .",
    "in fact , our design also allows an fine - grained isolation _ within _ a process .",
    "separation within a single process has many security applications , e.g. , application sandboxes , or isolating attacker - controllable data . as an example , in 2014 , microsoft improved the heap allocator for internet explorer which separates the heap and objects on the heap into two parts .",
    "as shown in figure  [ fig : ieattack ] , data objects in virtual memory are divided into meta data and payload data .",
    "the payload data ( ` buffer1 ` and ` buffer2 ` ) are attacker - controlled data . the meta data ( ` length ` and ` * ptr ` ) are usually isolated from the attacker .",
    "in the example from figure  [ fig : ieattack ] , the array object is comprised of a memory buffer ( ` buffer2 ` ) , a pointer to the buffer ( ` buffer * ptr ` ) and a field for the length ( ` length ` ) . on a monolithic heap",
    "the meta data ( ` length ` and ` * ptr ` ) would be adjacent with the corresponding buffer ( ` buffer2 ` ) . in this case",
    ", the attacker can overwrite the meta data by overflowing ` buffer2 ` .",
    "the separated heap , as shown in figure  [ fig : ieattack ] , prevents this attack , as an overflow in ` buffer2 ` would only affect other attacker - controlled data ( e.g. , ` buffer1 ` ) .",
    "however , the separation of meta data and payload data exists only in the virtual memory space . in the physical memory space meta data and payload data",
    "can still be stored in adjacent locations : figure  [ fig : ieattack ] shows a possible mapping of the data into physical memory .",
    "given this setting , the attacker can modify the meta data by leveraging rowhammer . by `` hammering '' ` buffer1 ` and ` buffer2 `",
    ", she can launch a double - sided rowhammer attack . as a result",
    ", she can modify data belonging to security domaina by accessing data of security domainb  @xcite .    to prevent such attacks",
    ", the security domainisolation needs to be expanded into the physical memory space . allows the creation of arbitrary security domains",
    "however , is implemented in the kernel while the semantics of the security domains ( the separated heaps ) are only known to the application .",
    "hence , to enable applications to have isolation in the physical memory space this information must be provided to the physical memory allocator in the kernel .",
    "this can be achieved by extending the memory allocation interface of the kernel ( e.g. , ` malloc ` ) with an additional parameter allowing an application to indicate which security domain should be assigned to the newly allocated memory .",
    "the rowhammer attack is not limited to x86-based systems , but has been recently shown to also affect the arm platform  @xcite .",
    "the arm architecture is predominant in mobile systems , and used in many smartphones and tablets .",
    "as is not dependent on any x86 specific properties , it can be easily adapted for arm based systems .",
    "we demonstrate this by applying our extended physical memory allocator to the android kernel for nexus devices in version 4.4 .",
    "since there are no major deviations in the implementation of the physical page allocator of the kernel between android and stock linux kernel , we did not encounter any obstacles during the port .",
    "[ ref : armimpl ]      [ sec : discussion ]    relies on the fact that all vulnerable memory pages can be identified and blacklisted . in general , the problem of discovering vulnerable bits is orthogonal to the enforcement mechanism by . for our prototype implementation and evaluation , we use the rowhammer testing tool developed and published by google  @xcite . however , there are two factors that impact the comprehensiveness of identifying vulnerable bits : spatial coverage and temporal coverage . since identifying vulnerable memory",
    "is not required for , we focus on for the following discussion on this aspect .",
    "the memory coverage of the rowhammer testing tool is limited to the physical memory it can access . since the rowhammer testing tool executes as an ordinary process on the system , it has no influence on the physical memory assigned when allocating memory .",
    "in particular , there are parts of physical memory which will never be assigned to the rowhammer test tool , as some memory is reserved by other systems entities , e.g. , memory reserved by the kernel .",
    "figure  [ fig : coverage ] shows an abstract view of the memory assignment during multiple runs of the rowhammer testing tool .",
    "note that the kernel memory as well as the reserved memory can never be assigned to a process .",
    "hence , the rowhammer testing tool can never test these regions for vulnerable bits .",
    "additionally , the rowhammer testing tool has to share the system s memory with other processes .",
    "figure  [ fig : coverage ] shows that the rowhammer testing tool can not allocate all memory since other processes ( and other dynamic components like loadable kernel modules ",
    "lkm ) also require memory .",
    "however , since these memory allocations are dynamic they can easily change among reboots and runs .",
    "figure  [ fig : coverage ] shows that the coverage of the rowhammer testing tool for each individual run is limited . however , the _ cumulative _ coverage of the rowhammer testing tool achieves coverage of the entire process allocatable memory .",
    "lastly , even if the rowhammer testing tool can not detect all vulnerable memory bits , it still can detect all bits that are exploitable from the attacker s point of view , i.e. , the attacker leverages the same techniques as the rowhammer testing tool to detect vulnerable bits .",
    "rowhammer is a novel attack technique . to the best of our knowledge",
    ", there are no studies on the system s susceptibility to rowhammer over a large time frame .",
    "however , one could easily imagine that memory cells could wear - off over time and cells which have been unaffected before become vulnerable .",
    "since there is no data available whether this can happen or at which rate cells can become vulnerable , no definitive statements can be made at the time of writing . in general ,",
    "if cells become vulnerable over time , the detection of vulnerable pages would need to be repeated periodically for .",
    "as mentioned before , these updates can be fully automated to run without requiring user interaction .",
    "[ ref : temporal ] moreover , an attacker can not simply utilize newly appearing victim pages , but would have to repeat the memory profiling for the targeted machine as well .",
    "in this section , we provide an overview of existing rowhammer attack techniques , their evolution , and proposed defenses .",
    "thereafter , we discuss the shortcomings of existing work on mitigating rowhammer attacks and compare them to our two software - based defenses .",
    "kim et al .",
    "@xcite were the first to conduct experiments and analyze the effect of bit flipping due to repeated memory reads .",
    "they found that this vulnerability can be exploited on intel and amd - based systems .",
    "their results show that over 85% of the analyzed dram modules are vulnerable .",
    "the authors highlight the impact on memory isolation , but they do not provide any practical attack .",
    "seaborn and dullien  @xcite published the first practical rowhammer - based privilege - escalation attacks using the x86 ` clflush ` instruction . in their first attack , they use rowhammer to escape the native client ( nacl )  @xcite sandbox .",
    "nacl aims to safely execute native applications by 3rd - party developers in the browser .",
    "using rowhammer malicious developers can escape the sandbox , and achieve remote code execution on the target system . with their second attack",
    "seaborn and dullien utilize rowhammer to compromise the kernel from an unprivileged user - mode application .",
    "combined with the first attack , the attacker can remotely compromise the kernel without exploiting any software vulnerabilities . to compromise the kernel ,",
    "the attacker first fills the physical memory with page - table entries by allocating a large amount of memory .",
    "next , the attacker uses rowhammer to flip a bit in memory .",
    "since the physical memory is filled with page - table entries , there is a high probability that an individual page - table entry is modified by the bit flip in a way that enables the attacker to access other page - table entries , modify arbitrary ( kernel ) memory , and eventually completely compromise the system .",
    "qiao and seaborn  @xcite implemented a rowhammer attack with the x86 ` movnti ` instruction . since the ` memcpy ` function of ` libc `    which is linked to nearly all c programs    utilizes the ` movnti ` instruction , the attacker can exploit the rowhammer bug with code - reuse attack techniques  @xcite .",
    "hence , the attacker is not required to inject her own code but can reuse existing code to conduct the attack .",
    "aweke et al .",
    "@xcite showed how to execute the rowhammer attack without using any special instruction ( e.g. , ` clflush ` and ` movnti ` ) .",
    "the authors use a specific memory - access pattern that forces the cpu to evict certain cache sets in a fast and reliable way .",
    "they also concluded that a higher refresh rate for the memory would not stop rowhammer attacks .",
    "gruss et al .",
    "@xcite demonstrated that rowhammer can be launched from javascript .",
    "however , they were only able to flip bits of their own memory which limited the impact of the attack .",
    "later , bosman et al .",
    "@xcite extended this work by exploiting the memory deduplication feature of windows  10 to create counterfeit javascript objects , and corrupting these objects through rowhammer to gain arbitrary read / write access within the browser . in their follow - up work ,",
    "razavi et al .",
    "@xcite applied the same attack technique to compromise cryptographic ( private ) keys of co - located virtual machines .",
    "concurrently , xiao et al .",
    "@xcite presented another cross virtual machine attack where they use rowhammer to manipulate page - table entries of xen .",
    "further , they presented a methodology to automatically reverse engineer the relationship between physical addresses and rows and banks . independently ,",
    "pessl et al .",
    "@xcite also presented a methodology to reverse engineer this relationship .",
    "based on their findings , they demonstrated cross - cpu rowhammer attacks , and practical attacks on ddr4 .",
    "van der veen et al .",
    "@xcite recently demonstrated how to adapt the rowhammer exploit to escalate privileges in android on smartphones .",
    "since the authors use the same exploitation strategy of seaborn and dullien , can successfully prevent this privilege escalation attack . while the authors conclude that it is challenging to mitigate rowhammer in software , we present two viable implementations that can mitigate practical rowhammer attacks .    note that all these attacks require memory belonging to a higher - privileged domain ( e.g. , kernel ) to be physically co - located to memory that is under the attacker s control .",
    "since our defenses prevent direct co - location , we mitigate these rowhammer attacks .",
    "kim et al .",
    "@xcite present a number of possible mitigation strategies .",
    "most of their solutions involve changes to the hardware , i.e. , improved chips , refreshing rows more frequently , or error - correcting code memory .",
    "however , these solutions are not very practical : the production of improved chips requires an improved design , and a new manufacturing process which would be costly , and hence , is unlikely to be implemented .",
    "the idea behind refreshing the rows more frequently ( every 32ms instead of 64ms ) is that the attacker needs to hammer rows many times to destabilize an adjacent memory cell which eventually causes the bit flip .",
    "hence , refreshing ( stabilizing ) rows more frequently could prevent attacks because the attacker would not have enough time to destabilize individual memory cells .",
    "[ ref : refreshrate ] nevertheless , aweke et al .",
    "@xcite were able to conduct a rowhammer attack within 32ms .",
    "therefore , a higher refresh rate alone can not be considered as an effective countermeasure against rowhammer .",
    "error - correcting code ( ecc ) memory is able to detect and correct single - bit errors . as observed by kim et al .",
    "@xcite rowhammer can induce multiple bit flips which can not be detected by ecc memory .",
    "further , ecc memory has an additional space overhead of around 12% and is more expensive than usual dram , therefore it is rarely used .",
    "kim et al .",
    "@xcite also suggest to disable faulty rows similar to our that we present in section  [ sec : highlvl : bcatt ] .",
    "however , they provide no implementation and evaluation . in contrast , we present the full implementation and evaluation of . while the authors concluded that this strategy is not practical , we demonstrate that it is an efficient and practical solution that effectively prevents rowhammer attacks as a short - term solution .",
    "kim et al . suggest to use probabilistic adjacent row activation ( para ) to mitigate rowhammer attacks .",
    "as the name suggests , reading from a row will trigger an activation of adjacent rows with a low probability . during the attack ,",
    "the malicious rows are activated many times .",
    "hence , with high probability the victim row gets refreshed ( stabilized ) during the attack .",
    "the main advantage of this approach is its low performance overhead .",
    "however , it requires changes to the memory controller .",
    "thus , para is not suited to protect legacy systems .    to the best of our knowledge aweke et al .",
    "@xcite proposed the only other software - based mitigation against rowhammer .",
    "their mitigation , coined anvil , uses performance counters to detect high cache - eviction rates which serves as an indicator of rowhammer attacks  @xcite .",
    "however , this defense strategy has three disadvantages : ( 1 )  it requires the cpu to feature performance counters .",
    "in contrast , our defenses do not rely on any special hardware features .",
    "( 2 )  anvil s worst case run - time overhead for spec cpu2006 is 8% , whereas our worst case overhead is 0.29% ( see table  [ tab : perf ] ) .",
    "( 3 )  anvil is a heuristic - based approach .",
    "hence , it naturally suffers from false positives ( although the fp rate is below 1% on average ) .",
    "in contrast , we provide deterministic approaches that are guaranteed to stop rowhammer attacks .",
    "rowhammer is a hardware fault , triggered by software , allowing the attacker to flip bits in physical memory and undermine cpu - enforced memory access control .",
    "recently , researchers have demonstrated the power and consequences of rowhammer attacks by breaking the isolation between virtual machines , user and kernel mode , and even enabling traditional memory - corruption attacks in the browser .    in this paper",
    "we introduce two practical and effective defenses against rowhammer , and .",
    "extends the bootloader to blacklist vulnerable memory which completely prevents the attacker from inducing bit flips through rowhammer .",
    ", on the other hand , is a generic mitigation that tolerates rowhammer attacks by dividing the physical memory into security domains , and limiting rowhammer - induced bit flips to the attacker - controlled security domain .    our detailed evaluation of and verifies that both schemes prevent",
    "all known rowhammer attacks .",
    "further , our mitigation schemes do not affect the run - time performance or the stability of the system .",
    "the authors thank simon schmitt for sacrificing his personal laptop to the cause of science .    this work was supported in part by the german science foundation ( project s2 , crc 1119 crossing ) , the european union s seventh framework programme ( 609611 , practice ) , and the german federal ministry of education and research within crisp .      .",
    "intel 64 and ia-32 architectures software developer s manual - chapter  15 secure virtual machine nested paging .",
    "http://developer.amd.com/resources/documentation-articles/developer-guides-manuals , 2012 .",
    "z.  b. aweke , s.  f. yitbarek , r.  qiao , r.  das , m.  hicks , y.  oren , and t.  austin .",
    "anvil : software - based protection against next - generation rowhammer attacks . in _",
    "21st international conference on architectural support for programming languages and operating systems _ , asplos , 2016 .",
    "m.  conti , s.  crane , l.  davi , m.  franz , p.  larsen , c.  liebchen , m.  negro , m.  qunaibit , and a .-",
    "losing control : on the effectiveness of control - flow integrity under stack attacks . in _",
    "acm sigsac conference on computer and communications security _ , ccs , 2015 .",
    "d.  gruss , c.  maurice , and s.  mangard .",
    "rowhammer.js : a cache attack to induce hardware faults from a website . in _",
    "13th conference on detection of intrusions and malware and vulnerability assessment _ , dimva , 2016 .        .",
    "intel 64 and ia-32 architectures software developer s manual - chapter  28 vmx support for address translation .",
    "http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf .",
    "y.  kim , r.  daly , j.  kim , c.  fallin , j.  h. lee , d.  lee , c.  wilkerson , k.  lai , and o.  mutlu .",
    "flipping bits in memory without accessing them : an experimental study of dram disturbance errors . in _",
    "41st annual international symposium on computer architecture _ , isca , 2014 .",
    "f.  schuster , t.  tendyck , c.  liebchen , l.  davi , a .- r .",
    "sadeghi , and t.  holz .",
    "counterfeit object - oriented programming : on the difficulty of preventing code reuse attacks in c++ applications . in _",
    "36th ieee symposium on security and privacy _",
    ", s&p , 2015 .",
    "k.  z. snow , f.  monrose , l.  davi , a.  dmitrienko , c.  liebchen , and a.  sadeghi .",
    "just - in - time code reuse : on the effectiveness of fine - grained address space layout randomization . in _",
    "34th ieee symposium on security and privacy _",
    ", s&p , 2013 .",
    "v.  van  der veen , y.  fratantonio , m.  lindorfer , d.  gruss , c.  maurice , g.  vigna , h.  bos , k.  razavi , and c.  giuffrida .",
    "drammer : deterministic rowhammer attacks on commodity mobile platforms . in _",
    "acm sigsac conference on computer and communications security _ , ccs , 2016 .",
    "b.  yee , d.  sehr , g.  dardyk , j.  b. chen , r.  muth , t.  ormandy , s.  okasaka , n.  narula , and n.  fullagar .",
    "native client : a sandbox for portable , untrusted x86 native code . in _",
    "30th ieee symposium on security and privacy _ , s&p , 2009 ."
  ],
  "abstract_text": [
    "<S> rowhammer is a hardware bug that can be exploited to implement privilege escalation and remote code execution attacks . </S>",
    "<S> previous proposals on rowhammer mitigation either require hardware changes or follow heuristic - based approaches ( based on cpu performance counters ) . to date </S>",
    "<S> , there exists no instant protection against rowhammer attacks on legacy systems .    in this paper , we present the design and implementation of two practical and efficient software - only defenses against rowhammer attacks . </S>",
    "<S> our defenses prevent the attacker from leveraging rowhammer to corrupt physically co - located data in memory that is owned by a different system entity . </S>",
    "<S> our first defense , , extends the system bootloader to disable vulnerable physical memory . </S>",
    "<S> is highly practical , does not require changes to the operating system , and can be deployed on virtually all x86-based systems . </S>",
    "<S> while is able to stop all known rowhammer attacks , it does not yet tackle the fundamental problem of missing memory isolation in physical memory . to address this problem , we introduce our second defense , a generic solution that extends the physical memory allocator of the os to physically isolate the memory of different system entities ( e.g. , kernel and user space ) .    as proof of concept , we implemented on x86 , and our generic defense , , on x86 and arm to mitigate rowhammer - based kernel exploits . </S>",
    "<S> our extensive evaluation shows that both mitigation schemes ( i )  can stop available real - world rowhammer attacks , ( ii )  impose virtually no run - time overhead for common user and kernel benchmarks as well as commonly used applications , and ( iii )  do not affect the stability of the overall system . </S>"
  ]
}