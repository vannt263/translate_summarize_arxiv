{
  "article_text": [
    "verification is undecidable already for simple programs , but modern programming languages support a variety of sophisticated features that make it all the more complicated . these advanced features  such as arrays , pointers , dynamic allocation of resources , and object - oriented abstract data types  are needed because they raise the level of abstraction thus making programmers more productive and programs less buggy .",
    "verification techniques have also progressed rapidly over the years , in an attempt to keep the pace with the development of programming languages .",
    "automated verification requires expressive program logics and powerful decision procedures . in response to the evolution of modern programming languages , new decidable program logic fragments and combination techniques for different fragments",
    "have mushroomed especially in recent years .",
    "many of the most successful contributions have focused on verifying relatively restricted aspects of a program s behavior , for example by decoupling pointer structure and functional properties in the formal analysis of a dynamic data structure .",
    "this narrowing choice , partly deliberate and partly required by the formidable difficulty of the various problems , is effective because different aspects are often sufficiently decoupled so that each of them can be analyzed in isolation with the most appropriate , specific technique .",
    "this paper contributes to the growing repertory of special program logics by exploring the decidability of properties of _ sequences of elements _ of homogeneous type .",
    "these can abstract fundamental features of several data structures : arrays imprimis , but also the sequence of values stored in a dynamically allocated list , or the content of a stack or a queue .",
    "we take a new angle on reasoning about sequences , based on the _ theory of concatenation _ : a first - order theory where variables are interpreted as words ( or sequences ) over a finite alphabet and can be composed by concatenating them .",
    "algorithm for solving word equations @xcite implies the decidability of the quantifier - free fragment of the theory of concatenation .",
    "based on this , we introduce a first - order _ theory of sequences _ @xmath3 whose elements are integers .",
    "section [ sec : decision ] presents a decision procedure for the quantifier - free fragment of @xmath3 , which encodes the validity problem into the quantifier - free theory of concatenation .",
    "the decision procedure is in pspace ; it is known , however , that makanin s algorithm is reasonably efficient in practice @xcite .    the theory of sequences @xmath3 allows concatenating sequences to build new ones , and it includes presburger arithmetic over elements of a sequence . on the other hand",
    ", it forbids explicit indexed access to elements , which differentiates it from the theory of arrays and extensions thereof ( see section [ sec : related ] ) .",
    "the resulting quantifier - free fragment has significant expressiveness , in spite of its limitations in representing subsequences of variable length .",
    "in particular , we show some interesting properties that are inexpressible in powerful decidable array logics ( such as those in @xcite ) but are expressible in our theory of sequences .",
    "conversely , there exist decidable properties of extensions of the theory of arrays that are inexpressible in @xmath3 .",
    "these results support our claim that the theory of sequences provides a fresh angle on reasoning about sequences , orthogonal to most approaches that model sequences as arrays .    in order to better assess the limits of our theory of sequences",
    ", we also prove that several natural extensions of the quantifier - free fragment of @xmath3 are undecidable . finally , we demonstrate reasoning about sequence - manipulating programs with annotations written in the quantifier - free fragment of @xmath3 .",
    "a couple of examples in section [ sec : programs ] illustrate the usage of @xmath3 formulas with the standard machinery of axiomatic semantics and backward reasoning .",
    "[ [ paper - outline . ] ] paper outline .",
    "+ + + + + + + + + + + + + +    section [ sec : concatenation ] presents the theory of concatenation and summarizes a few decidability and undecidability results about it .",
    "section [ sec : sequences ] introduces our theory of integer sequences @xmath3 , demonstrates its expressiveness , provides a decision procedure for its quantifier - free fragment , and shows undecidable extensions of the theory .",
    "section [ sec : programs ] illustrates how to use the theory @xmath3 to reason about programs in the standard axiomatic semantics framework .",
    "finally , section [ sec : related ] reviews related work and section [ sec : conclusion ] concludes by outlining future work .",
    "this section introduces some basic notation ( section [ sec : preliminaries ] ) and summarizes some results about the first - order theory of concatenation ( section [ sec : dec - concatenation ] ) that we will use in the remainder of the paper .    in the rest of the paper , we assume familiarity with the standard syntax and terminology of first - order theories ( e.g. , @xcite ) ; in particular , we assume the standard abbreviations and symbols of first - order theories with the following operator precedence @xmath4 .",
    "@xmath5 denotes the set of free variables of a formula @xmath6 . with standard terminology ,",
    "a formula @xmath6 is a _ sentence _ iff it is _ closed _",
    "iff @xmath7 . given a regular expression @xmath8 over @xmath9 , the @xmath8-fragment of a first - order theory is the set of all formulas of the theory in the form @xmath10 , where @xmath11 is quantifier - free .",
    "the universal and existential fragments are synonyms for the @xmath12- and @xmath13-fragment respectively .",
    "a fragment is decidable iff the validity problem is decidable for its sentences .",
    "it is customary to define the validity and satisfiability problems for a quantifier - free formula @xmath11 as follows : @xmath11 is valid iff the universal closure of @xmath11 is valid , and @xmath11 is satisfiable iff the existential closure of @xmath11 is valid . as a consequence of this definition , the decidability of a quantifier - free fragment whose",
    "formulas are closed under negation is tantamount to the decidability of the universal or existential fragments .",
    "correspondingly , in the paper we will allow some freedom in picking the terminology that is most appropriate to the context .",
    "@xmath14 denotes the set of integer numbers and @xmath15 denotes the set of nonnegative integers .",
    "given a set @xmath16 of constants , a _ sequence _ over @xmath17 is any word @xmath18 for some @xmath19 where @xmath20 for all @xmath21 .",
    "the symbol @xmath22 denotes the _ empty sequence _ , for which @xmath23 .",
    "@xmath24 denotes the _ length _ of @xmath25 .",
    "@xmath26 denotes the set of all finite sequences over @xmath17 including @xmath27 .",
    "it is also convenient to introduce the shorthand @xmath28 with @xmath29 to describe _ subsequences _ of a given sequence @xmath25 ; it is defined as follows .",
    "@xmath30 for two sequences @xmath31 , @xmath32 denotes their _ concatenation _ : the sequence @xmath33 . we will drop the concatenation symbol whenever unambiguous .",
    "the structure @xmath34 is also referred to as the _ free monoid _ with generators in @xmath17 and neutral element @xmath22 .",
    "the size @xmath35 is called _ rank _ of the free monoid and it can be finite or infinite .",
    "the theory of concatenation is the first - order theory @xmath36 with signature @xmath37 where @xmath38 is the equality predicate , to distinguish it from the standard arithmetic equality symbol @xmath39 used later in the paper .",
    "] @xmath40 is the binary concatenation function and @xmath41 is a set of unary ( monadic ) predicate symbols called _",
    "regularity constraints_. we sometimes write @xmath42 as @xmath43 and @xmath44 abbreviates @xmath45 .",
    "an interpretation of a formula in the theory of concatenation is a structure @xmath46 where @xmath34 is a free monoid , @xmath47 is a collection of regular subsets of @xmath26 , and @xmath48 is a mapping from variables to values in @xmath26 .",
    "the satisfaction relation @xmath49 for formulas in @xmath36 is defined in a standard fashion with the following assumptions .    *",
    "any variable @xmath50 takes the value @xmath51 ; * the concatenation @xmath52 of two variables @xmath53 takes the value @xmath54 ; * for each @xmath55 , the corresponding @xmath56 defines the set of sequences @xmath57 for which @xmath58 holds ( this also subsumes the usage of constants ) .",
    "the following propositions summarize some decidability results about fragments of the theory of concatenation ; they all are known results , or corollaries of them .",
    "the standard presentation of these results focuses on solving equations over sequences with free variables and , correspondingly , on existential fragments of the equational theory . on the contrary , in this paper we will mostly focus on the universal fragment , given its aptness for annotating sequence - manipulating programs ( see section [ sec : programs ] ) .",
    "it is straightforward , however , to rephrase the results in terms of the dual existential fragments , given the availability of negation in the language .",
    "[ prop : decidable ] the universal and existential fragments of the theory of concatenation over free monoids with finite rank are decidable in pspace .",
    "decidability is a consequence of makanin s seminal result on word equations @xcite and its extensions to the full existential ( and universal ) fragments @xcite .",
    "pspace complexity is a consequence of plandowski s recent results @xcite and the fact that transforming first - order formulas into a single word equation introduces only a polynomial blow - up .",
    "the only catch is that the standard presentation assumes formulas in the canonical form @xmath59 where regularity constraints do not appear in @xmath60 .",
    "this is , however , without loss of generality as we can put any universal formula @xmath61 in canonical form : first rewrite @xmath11 into @xmath62 for fresh @xmath63 and @xmath64 .",
    "then , put @xmath11 in negated normal form and eliminate occurrences of regularity predicates by applying exhaustively the rules : @xmath65}{\\psi[x_n \\doteq h^+_m ] } \\qquad \\inferrule{\\psi[\\neg { \\mathrm{r}}_m(x_n)]}{\\psi[x_n \\doteq h^-_m]}\\ ] ] it is not difficult to see that this transformation preserves satisfiability and introduces a blow - up which is quadratic at most .",
    "[ prop : undecidable ]    * @xcite the @xmath66 and @xmath67 fragments of the theory of concatenation are undecidable ; in particular the @xmath68-fragment is undecidable already for negation - free formulas .",
    "* @xcite the existential and universal fragments of the extension of the theory of concatenation over the free monoid @xmath69 with : ( 1 ) two length functions @xmath70 and @xmath71 ; or ( 2 ) the function @xmath72 are undecidable .",
    "a set of sequences @xmath73 is _ universally ( resp .",
    "existentially ) definable from concatenation _ iff there is a universal ( resp .",
    "existential ) formula @xmath74 $ ] with @xmath75 ) = \\ { x \\}$ ] such that @xmath76 \\}$ ] .",
    "[ prop : definable ]    * the set @xmath77 is neither universally nor existentially definable from concatenation . *",
    "the equal length predicate @xmath78 is not definable in the existential and universal fragments of concatenation .",
    "bchi and senger prove in ( * ? ? ?",
    "* corollary 3 ) that @xmath79 is not existentially definable .",
    "a very similar argument shows that @xmath80 is also not existentially definable ( using the terminology of ( * ? ? ?",
    "* corollary 3 ) , the spacers of @xmath81 relative to the atom @xmath82 are @xmath83 and there are only @xmath84 words in @xmath85 with these spacers ) .",
    "the existential non - definability of @xmath85 entails the existential non - definability of the set @xmath86 by contradiction as follows .",
    "assume that @xmath87 were existentially definable ; then @xmath88 could be defined as @xmath89 ( that is , @xmath90 ) , a contradiction . finally , @xmath79 is universally definable from concatenation iff @xmath87 is existentially definable from concatenation .",
    "in fact , the complement set @xmath91 is @xmath92 with @xmath93 clearly existentially and universally definable from concatenation .",
    "this concludes the proof of the first part of the proposition .    the second part is proved in ( * ? ? ? * theorem 1 ) for the existential fragment and it is straightforward to adapt that proof to universal definability .",
    "it is currently unknown whether the extension of the existential or universal fragment of concatenation with @xmath94 is decidable , while allowing membership constraints over deterministic context - free language gives an undecidable theory @xcite .",
    "this section introduces a first - order theory of sequences ( section [ sec : seq - theory - def ] ) with arithmetic , gives a decision procedure for its universal fragment ( section [ sec : decision ] ) , and shows that `` natural '' larger fragments are undecidable ( section [ sec : extensions ] ) .",
    "we present an arithmetic theory of sequences whose elements are integers .",
    "it would be possible to make the theory parametric with respect to the element type . focusing on integers ,",
    "however , makes the presentation clearer and more concrete , with minimal loss of generality as one can introduce any theory definable in the integer arithmetic fragment .",
    "[ [ syntax . ] ] syntax .",
    "+ + + + + + +    properties of integers are expressed in presburger arithmetic whose signature is : @xmath95 then , our theory @xmath3 of sequences with integer values has signature @xmath96 operator precedence is : @xmath97 followed by logic connectives and quantifiers with the previously defined precedence .",
    "we will generally consider formulas in prenex normal form @xmath98 where @xmath8 is a quantifier prefix and @xmath11 is quantifier - free written in the grammar : @xmath99 with @xmath100 ranging over variable names .",
    "[ [ semantics . ] ] semantics .",
    "+ + + + + + + + + +    an interpretation of a sentence of @xmath3 is a structure @xmath101 with the following assumptions .    *",
    "@xmath102 have the same meaning as in the theory of concatenation . *",
    "as far as arithmetic is concerned : * * the interpretation of a sequence @xmath103 of integers is the first integer in the sequence @xmath104 , with the convention that the interpretation of the empty sequence is @xmath105 . * * conversely , the interpretation of an integer value @xmath106 is the singleton sequence @xmath25 . * * addition , subtraction , equality , and less than are interpreted accordingly .",
    "the satisfaction relation is then defined in a standard fashion .",
    "[ [ shorthands . ] ] shorthands .",
    "+ + + + + + + + + + +    we introduce several shorthands to simplify the writing of complex formulas .    * a symbol for every constant @xmath107 , defined as obvious . * @xmath108 , @xmath109 , @xmath110 , and @xmath111 defined respectively as @xmath112 , @xmath113 , @xmath114 , and @xmath115 . * shorthands such as @xmath116 or @xmath117 for @xmath118 .",
    "* bounded length predicates such as @xmath119 for a variable @xmath50 and a constant @xmath107 abbreviating @xmath120 with @xmath121 a regular constraint interpreted as @xmath122 .",
    "the definition of derived expressions such as @xmath123 is also as obvious .",
    "* subsequence functions such as @xmath124 for a variable @xmath50 and two constants @xmath29 with the intended semantics ( see section [ sec : preliminaries ] ) .",
    "we define these functions in the theory @xmath3 by the following rewriting rules , defined on formulas in prenex normal form with quantifier prefix @xmath8 : + @xmath125 \\\\          \\hline \\\\          { \\mathcal{q}}\\forall u , v , w { \\;\\bullet\\;}\\left ( \\begin{array}{l }              \\kappa_1 \\wedge x \\doteq uvw \\wedge |u| = k_1 - 1 \\wedge |v| = k_2 - k_1 + 1 \\\\              \\vee\\quad    \\kappa_2 \\wedge x \\doteq uvw \\wedge |u| = k_1 - 1 \\wedge |w| = - k_2   \\\\",
    "\\vee\\quad    \\kappa_3 \\wedge x \\doteq uvw \\wedge |v| = -k_1 + k_2 + 1 \\wedge |w| = - k_2 \\\\              \\vee\\quad    \\neg ( \\kappa_1 \\vee \\kappa_2 \\vee \\kappa_3 ) \\wedge u \\doteq v \\doteq w \\doteq \\epsilon               \\end{array } \\right )          \\rightarrow \\psi[v ]          \\end{array}\\ ] ] + where : @xmath126 * @xmath127 and @xmath128 for the first @xmath129 and last element @xmath130 of @xmath50 , respectively .",
    "a few examples demonstrate the expressiveness of the universal fragment of @xmath3 to specify properties of sequences .    1 .   * equality * : sequences @xmath131 and @xmath132 are equal .",
    "@xmath133 2 .",
    "* bounded equality * : sequences @xmath131 and @xmath132 are equal in the _ constant _ interval @xmath134 $ ] for @xmath135 .",
    "@xmath136 3 .",
    "* boundedness * : no element in sequence @xmath131 is greater than value @xmath132 .",
    "@xmath137 4 .",
    "* sortedness * : sequence @xmath131 is sorted ( strictly increasing ) .",
    "@xmath138 5 .",
    "* injectivity * : @xmath131 has no repeated elements .",
    "@xmath139 6 .",
    "* partitioning * : sequence @xmath131 is partitioned at _ constant _ position @xmath140 .",
    "@xmath141 7 .",
    "* membership * : _ constant _ element @xmath107 occurs in sequence @xmath131 .",
    "@xmath142 8 .   * non - membership",
    "* : no element in sequence @xmath131 has value @xmath132 .",
    "@xmath143 9 .",
    "* periodicity * : in non - empty sequence @xmath131 , elements on even positions have value @xmath105 and elements on odd positions have value @xmath144 ( notice that @xmath145 if @xmath146 is empty ) . @xmath147 10 .",
    "* comparison * between indices and values : for every index @xmath0 , element at position @xmath0 in the non - empty sequence @xmath131 has value @xmath148 .",
    "@xmath149 11 .",
    "* disjunction of value constraints * : for every pair of positions @xmath150 in the sequence @xmath131 , either @xmath151 or @xmath152 .",
    "@xmath153    [ [ comparison - with - theories - of - arrays . ] ] comparison with theories of arrays .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    properties such as strict sortedness ( [ eq : strictly - increasing ] ) , periodicity ( [ eq : periodicity ] ) , and comparisons between indices and values ( [ eq : comparison ] ) are inexpressible in the array logic of bradley et al .",
    "the latter is inexpressible also in the logic of ghilardi et al .",
    "@xcite because presburger arithmetic is restricted to indices .",
    "properties such as ( [ eq : disjunction ] ) are inexpressible both in the sil array logic of @xcite  because quantification on multiple array indices is disallowed  and in the related lia logic of @xcite  because disjunctions of comparisons of array elements are disallowed .",
    "extensions of each of these logics to accommodate the required features would be undecidable .",
    "conversely , properties such as _ permutation _ , bounded equality _ for an interval specified by indices _",
    ", length constraints _ for a variable value _ , membership _ for a variable value _ , and the _ subsequence _ relation ,",
    "are inexpressible in the universal fragment of @xmath3 .",
    "notice that membership and the subsequence relation are expressible in the dual existential fragment of @xmath3 , while the other properties seem to entail undecidability of the corresponding @xmath3 fragment ( see section [ sec : extensions ] )",
    ". bounded equality , length constraints , and membership , on the other hand , are expressible in all the logics of @xcite , and @xcite outlines a decidable extension which supports the subsequence relation ( see section [ sec : related ] ) .",
    "this section presents a decision procedure @xmath154 for the universal fragment of @xmath3 .",
    "the procedure transforms any universal @xmath3 formula into an equi - satisfiable universal formula in the theory of concatenation over the free monoid @xmath155 .",
    "the basic idea is to encode integers as sequences over the four symbols @xmath156 : the sequence @xmath157 encodes a nonnegative integer @xmath158 , while the sequence @xmath159 encodes a negative integer @xmath160 .",
    "suitable rewrite rules encode all quantifier - free presburger arithmetic in accordance with this convention .",
    "the next subsection [ sec : dec - proc ] outlines the decision procedure @xmath154 , while subsection [ sec : correctness ] illustrates its correctness and discusses its complexity .",
    "consider a universal formula of @xmath3 in prenex normal form : @xmath161 where @xmath11 is quantifier - free .",
    "modify ( [ eq : prenex ] ) by application of the following steps .    1 .",
    "introduce fresh variables to normalize formulas into the following form : @xmath162 clearly , we can achieve this by applying exhaustively rewrite rules that operate on @xmath11 such as : @xmath163}{e \\doteq x { \\circ}y   \\rightarrow \\psi[e ] }     \\qquad \\inferrule{\\psi[x + y]}{f = x + y   \\rightarrow \\psi[f]}\\ ] ] for fresh variables @xmath164 .",
    "2 .   for each variable @xmath165",
    ", introduce the fresh variables @xmath166 ( for head , tail , sign , modulus ) and rewrite @xmath11 as : @xmath167 3 .",
    "apply the following rule exhaustively to remove arithmetic equalities : + @xmath168}{\\psi[h_i \\doteq h_j ] } \\qquad \\inferrule{\\psi[x_i = 0]}{\\psi[h_i \\in 0 ] } \\qquad \\inferrule{\\psi[x_i = 1]}{\\psi[h_i \\in 1]}\\ ] ] 4 .",
    "apply the following rule exhaustively to remove differences : + @xmath169}{\\psi[x_i = x_k + x_j]}\\ ] ] 5 .",
    "apply the following rule exhaustively to remove comparisons : @xmath170 \\\\      \\hline \\\\",
    "\\left(\\begin{array}{l }          m_i \\doteq m_j   \\\\",
    "\\vee\\ ; m_i \\doteq m_j p \\\\          \\vee\\ ; m_j \\doteq m_i p      \\end{array } \\right ) \\rightarrow      \\psi      \\left[\\begin{array}{c }          s_i \\doteq d \\wedge s_j \\doteq c \\\\          \\vee \\\\          s_i",
    "\\doteq s_j \\doteq c",
    "\\wedge m_j \\doteq m_i p \\\\          \\vee \\\\",
    "s_i \\doteq s_j \\doteq d \\wedge m_i \\doteq m_j p      \\end{array } \\right ]      \\end{array}\\ ] ] for fresh @xmath171",
    "apply the following rule exhaustively to remove sums : + @xmath172 \\\\",
    "\\hline      \\left(\\begin{array}{l }          m_i \\doteq m_j   \\\\",
    "\\vee\\ ; m_i \\doteq m_j p \\\\          \\vee\\ ; m_j \\doteq m_i p      \\end{array } \\right ) \\rightarrow      \\psi      \\left[\\begin{array}{c }          s_i \\doteq s_j \\wedge x_k \\doteq a s_i m_i m_j a   \\\\",
    "\\\\          s_i \\not\\doteq s_j \\wedge m_i \\doteq m_j \\wedge x_k \\doteq aca",
    "\\\\          \\vee",
    "\\\\          s_i \\not\\doteq s_j \\wedge m_i \\doteq m_j p \\wedge x_k \\doteq a s_i pa",
    "\\\\          \\vee \\\\          s_i \\not\\doteq s_j \\wedge m_j \\doteq m_i p \\wedge x_k \\doteq a s_j pa      \\end{array } \\right ]      \\end{array}\\ ] ] for fresh @xmath171 . 7 .",
    "modify the meaning of regularity constraints as follows : let @xmath173 be defined by a regular expression with constants in @xmath14 .",
    "substitute every occurrence of a nonnegative constant @xmath107 by @xmath174 ; every occurrence of a negative constant @xmath107 by @xmath175 ; every occurrence of set @xmath14 by @xmath176 .",
    "the resulting formula is again in form ( [ eq : prenex ] ) where @xmath11 is now a quantifier - free formula in the theory of concatenation over @xmath155 ; its validity is decidable by proposition [ prop : decidable ] .",
    "let us sketch the correctness argument for the decision procedure @xmath154 , which shows that the transformed formula is equi - satisfiable with the original one .",
    "the justification for step 1 is straightforward . after applying it a series of substitutions",
    "eliminates arithmetic by reducing it to equations over the theory of concatenation with the unary encoding of integers defined above .",
    "step 2 requires that any variable @xmath177 is a sequence of the form @xmath178 and introduces fresh variables to denote significant parts of the sequence : @xmath179 aliases the first element of the sequence which is further split into its sign @xmath180 ( @xmath181 for nonnegative and @xmath182 for negative ) and its absolute value @xmath183 encoded as a unary string in @xmath184 .",
    "the second term of the disjunction deals with the case of @xmath177 being @xmath22 , which has the same encoding as @xmath105 .",
    "the following steps replace elements of the signature of presburger arithmetic by rewriting them as equations over sequences with the given encoding .",
    "step 3 reduces the arithmetic equality of two sequences of integers to equivalence of the sequences encoding their first elements .",
    "step 4 rewrites equations involving differences with equations involving sums .",
    "step 5 reduces arithmetic comparisons of two sequences of integers to a case discussion over the sequences @xmath185 encoding their first elements .",
    "let @xmath186 be a sequence in @xmath187 encoding the difference between the absolute values corresponding to @xmath179 and @xmath188 ; obviously such a @xmath186 always exists unless the absolute values are equal .",
    "then , @xmath179 encodes an integer strictly less than @xmath188 iff one of the following holds : ( 1 ) @xmath179 is a negative value and @xmath188 is a nonnegative one ; ( 2 ) both @xmath179 and @xmath188 are a nonnegative value and the sequence of @xmath189 s in @xmath188 is longer than the sequence of @xmath189 s in @xmath179 ; or ( 3 ) both @xmath179 and @xmath188 are a negative value and the sequence of @xmath189 s in @xmath179 is longer than the sequence of @xmath189 s in @xmath188 .",
    "step 6 reduces the comparison between the value of a sum of two variables and a third variable to an analysis of the three sequences @xmath190 encoding the first elements of the three variables . as in step 6",
    ", the unary sequence @xmath186 encodes the difference between the absolute values corresponding to @xmath179 and @xmath188 . then , @xmath191 encodes the sum of the values encoded by @xmath179 and @xmath188 iff one of the following holds : ( 1 ) @xmath179 and @xmath188 have the same sign and @xmath191 contains a sequence of @xmath189 s which adds up the sequences of @xmath189 s of @xmath179 and @xmath188 , still with the same sign ; ( 2 ) @xmath179 and @xmath188 have opposite sign but same absolute value , so @xmath191 must encode @xmath105 ; ( 3 ) @xmath179 and @xmath188 have opposite sign and the absolute value of @xmath179 is greater than the absolute value of @xmath188 , so @xmath191 has the same sign as @xmath179 and the difference of absolute values as its absolute value ; or ( 4 ) @xmath179 and @xmath188 have opposite sign and the absolute value of @xmath188 is greater than the absolute value of @xmath179 , so @xmath191 has the same sign as @xmath188 and the difference of absolute values as its absolute value .    finally , step 7 details how to translate the interpretation of the regular constraints over @xmath14 into the corresponding regularity constraints over @xmath156 with the given integer encoding .",
    "it is not difficult to see that all rewriting steps in the decision procedure @xmath154 increase the size of @xmath11 at most quadratically ( this accounts for fresh variables as well ) .",
    "hence , the pspace complexity of the universal fragment of the theory of concatenation ( proposition [ prop : decidable ] ) carries over to @xmath154 .",
    "the universal fragment of @xmath3 is decidable in pspace with the decision procedure @xmath154 .",
    "the following extensions of the universal fragment of @xmath3 are undecidable .    1 .   the @xmath192 and @xmath193 fragments . 2",
    "for any pair of integer constants",
    "@xmath194 , the extension with the two length functions @xmath195 counting the number of occurrences of @xmath158 and @xmath160 in @xmath50 .",
    "the extension with an equal length predicate @xmath78 .",
    "the extension with a sum function @xmath196 .",
    "1 .   sentences with one quantifier alternation are undecidable already for the theory of concatenation without arithmetic and over a monoid of finite rank ( proposition [ prop : undecidable ] ) .",
    "notice that the set of sentences that are expressible both in the @xmath192 and in the @xmath193 fragment is decidable ( * ? ? ?",
    "4.4 ) ; however , this set lacks a simple syntactic characterization . 2 .",
    "corollary of proposition [ prop : undecidable ] .",
    "we encode the universal theory of @xmath197  where @xmath198  in the universal fragment of @xmath3 extended by the @xmath94 predicate ; undecidability follows from the undecidability of the existential and universal theories of @xmath199 ( * ? ? ?",
    "* corollary 5 ) .",
    "all we have to do is showing that @xmath200 is universally definable in @xmath3 with @xmath94 . to this end , first define @xmath201 as a sequence that begins with value @xmath202 , ends with value @xmath144 , and where every element is the successor of the element that follows .",
    "@xmath203 as a result @xmath201 is in the form @xmath204 and hence has length @xmath202 . and full index arithmetic as well",
    "] then , @xmath205 is universally definable as the sequence @xmath186 with the same length as @xmath201 , whose last element is @xmath50 , and where every element is obtained by doubling the value of the element that follows : @xmath206 hence @xmath186 has the form @xmath207 which encodes the desired value @xmath208 in @xmath3 .",
    "( notice that the two universal definitions of @xmath201 and @xmath186 can be combined into a single universal definition by conjoining the definition of @xmath186 to the consequent in the definition of @xmath201 ) .",
    "4 .   for any sequence @xmath50 over @xmath209",
    "define @xmath210 as @xmath211 . then , proposition [ prop : undecidable ] implies undecidability because this extension of @xmath3 can define universal sentences over the free monoid @xmath69 with the function @xmath212 .",
    "the decidability of the following is instead currently unknown : the extension of the universal fragment with a function @xmath213 defined as the sequence @xmath214 .",
    "the fragment allows the definition of the set @xmath215 as the sequences @xmath50 such that @xmath216 .",
    "this is inexpressible in the universal fragment of the theory of concatenation , but the decidability of the resulting fragment is currently unknown ( see proposition [ prop : definable ] ) .",
    "this section outlines a couple of examples that demonstrate using formulas in the theory @xmath3 to reason about sequence - manipulating programs .",
    "an implementation of the decision procedure @xmath154 is needed to tackle more extensive examples ; it is currently underway .",
    "the examples are in eiffel - like pseudo - code @xcite ; it is not difficult to detail an axiomatic semantics and a backward substitution calculus , using the universal fragment of @xmath3 , for the portions of this language used in the examples .",
    "m.65 m.35    .... merge_sort ( a : array ) : array local l , r : array do     if |a| $ \\leq$ 1 then        { sorted(a ) }        result : = a     else        l , r : = a[1:|a|/2 ] , a[|a|/2 + 1 : |a| ]        { l $ \\cat$ r = a }        l , r : = merge_sort ( l ) , merge_sort ( r )        { sorted(l ) $ \\wedge$ sorted(r ) }        from result : = $ \\epsilon$        { invariant sorted(result ) $ \\wedge$ sorted(l ) $ \\wedge$ sorted(r ) $ \\wedge$                     $ \\last$(result ) $ \\leq$ $ \\first$(l ) $ \\wedge$ $ \\last$(result ) $ \\leq$ $ \\first$(r ) }        until |l| = 0 $ \\vee$ |r| = 0        loop           if l.first > r.first then             result : = result $ \\cat$ r.first ; r : = r.rest           else             result : = result $ \\cat$ l.first ; l : = l.rest           end        end        if |l| > 0 then           { |r| = 0 }   result : = result $ \\cat$ l        else           { |l| = 0 }   result : = result $ \\cat$ r        end { ensure   sorted(result ) } ....    &    .... reverse ( a : list ) : list local v : integer ; s : stack do     from s : = $ \\epsilon$     { invariant s $ \\catl$ a = old a }      until a = $ \\epsilon$     loop        s.push ( a.first )        a : = a.rest     end     from result : = $ \\epsilon$     { invariant          s $ \\catl$ result$\\rev$ = old a }     until s = $ \\epsilon$     loop        v : = s.top        s.pop ; result.extend ( v )     end { ensure result$\\rev$ = old a } ....    [ [ reversal . ] ] reversal .",
    "+ + + + + + + + +    in table [ tab : merge - sort ] ( right ) , a program reverses a sequence of integers , given as a list @xmath82 , using a stack @xmath217 .",
    "the query `` first '' returns the first element in a list , and the command `` extend '' adds an element to the right of a list ; the query `` top '' and the commands `` pop '' and `` push '' for a stack have the usual semantics . in the annotations",
    ", @xmath217 is modeled by a sequence whose first element is the bottom of the stack , whereas the expression @xmath218 denotes the value of @xmath82 upon entering the routine .",
    "the superscript @xmath219 denotes the reversal of a sequence .",
    "we do not know if the extension of @xmath3 by a reversal function is decidable .",
    "however , the following two simple update axioms are sufficient to handle any program which builds the reverse @xmath220 of a sequence @xmath131 starting from an empty sequence and adding one element at a time : @xmath221 after rewriting @xmath222 into @xmath223 the implication is straightforward to check for validity .",
    "the rest of the program is also simple to check with standard backward reasoning techniques .    [",
    "[ mergesort . ] ] mergesort .",
    "+ + + + + + + + + +    consider a straightforward recursive implementation of the mergesort algorithm ; table [ tab : merge - sort ] ( left ) shows an annotated version , where @xmath224 denotes the concatenation operator in the programming language ( whose semantics is captured by the corresponding logic operator @xmath40 ) .",
    "the annotations specify that the routine produces a sorted array , where predicate @xmath225 is defined as : @xmath226 it is impossible to express in @xmath3 another component of the full functional specification : the output is a permutation of the input .",
    "this condition is inexpressible in most of the expressive decidable extensions of the theory of arrays that are currently known , such as @xcite ( see also section [ sec : related ] ) .",
    "complementary automated verification techniques  using different abstractions such as the multiset @xcite  can , however , verify this orthogonal aspect .",
    "we must also abstract away the precise splitting of array @xmath82 into two halves in line 8 .",
    "the way in which @xmath82 is partitioned into @xmath227 and @xmath228 is however irrelevant as far as correctness if concerned ( it only influences the complexity of the algorithm ) , hence we can simply over - approximate the instruction on line 8 by a nonderministic splitting in two continuous non - empty parts .    from the annotated program , we can generate verification conditions by standard backward reasoning .",
    "universal sentences of @xmath3 can express the verification conditions , hence the verification process can be automated .",
    "let us see an example on the non - trivial part of the process , namely checking that the formula on lines 1314 is indeed an inductive invariant .",
    "consider the `` then '' branch on line 18 .",
    "backward substitution of the invariant yields : @xmath229    this condition must be discharged by the corresponding loop invariant hypothesis : @xmath230 ) entails ( [ eq : merge - bsub ] ) discharges the corresponding verification condition .",
    "elements of this condition can be encoded in the universal fragment of @xmath3 and proven using the decision procedure of section  [ sec : decision ] ; for instance , the fact that @xmath231 , @xmath232 , @xmath233 , and @xmath234 imply @xmath235 corresponds to the validity of ( all free variables are implicitly universally quantified ) : @xmath236",
    "pioneering efforts on automated program verification focused on very simple data types  in most cases just scalar variables  as the inherent difficulties were already egregious .",
    "as verification techniques progressed and matured , more complex data types were considered , such as lists ( usually _  la _ lisp ) , arrays , maps , and pointers , up to complex dynamic data structures .",
    "arrays in particular received a lot of attention , both for historical reasons ( programming languages have been offering them natively for decades ) , and because they often serve as the basis for implementing more complex data structures .",
    "more generally , a renewed interest in developing decision procedures for new theories and in integrating existing ones has blossomed over the last few years .",
    "a review of this staggering amount of work is beyond the scope of this paper ; for a partial account and further references we refer the reader to e.g. , @xcite ( and @xcite for applications ) . in this section ,",
    "we review approaches that are most similar to ours and in particular which yield decidable logics that can be compared directly to our theory of sequences ( see section [ sec : examples ] ) .",
    "this is the case with several of the works on the theory of arrays and extensions thereof .",
    "[ [ the - theory - of - arrays . ] ] the theory of arrays .",
    "+ + + + + + + + + + + + + + + + + + + + +    mccarthy initiated the research on formal reasoning about arrays @xcite .",
    "his theory of arrays defines the axiomatization of the basic access operations of _ read _ and _ write _ for quantifier - free formulas and without arithmetic or extensionality ( i.e. , the property that if all elements of two arrays are equal then the arrays themselves are equal ) .",
    "mccarthy s work has usually been the kernel of every theory of arrays : most works on ( automated ) reasoning about arrays extend mccarthy s theory with more complex ( decidable ) properties or efficiently automate reasoning within an existing theory .",
    "thus , a series of work extended the theory of arrays with arithmetic @xcite and with sorting predicates on array segments @xcite ; automated reasoning within these theories is possible only for restricted classes of programs .",
    "extensionality is another very significant extension to the theory of arrays @xcite , which has now become standard as it is decidable .",
    "the fast technological advances in automated theorem proving over the last years have paved the way for efficient implementations of the theory of arrays ( usually with extensionality ) .",
    "these implementations use a variety of techniques such as smt solving @xcite , saturation theorem proving @xcite , and abstraction @xcite .",
    "automated invariant inference is an important application of these decision procedures , which originated a specialized line of work @xcite .",
    "[ [ decidable - extensions - of - the - theory - of - arrays . ] ] decidable extensions of the theory of arrays .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the last few years have seen an acceleration in the development of decidable extensions of the extensional theory of arrays with more expressive predicates and functions .",
    "bradley et al .",
    "@xcite develop the _ array property fragment _ , a decidable subset of the @xmath193 fragment of the theory of arrays .",
    "array property _ is a formula of the form @xmath237 , where the universal quantification is restricted to index variables , @xmath238 is a guard on index variables with arithmetic ( restricted to existentially quantified variables ) , and @xmath239 is a constraint on array values without arithmetic or nested reads , and where no universally quantified index variable is used to select an element that is written to .",
    "the array property fragment is decidable with a decision procedure that eliminates universal quantification on index variables by reducing it to conjunctions on a suitable finite set of index values .",
    "extensions of the array property fragment that relax any of the restrictions on the form of array properties are undecidable .",
    "bradley et al .",
    "also show how to adapt their theory of arrays to reason about maps .",
    "ghilardi et al .  @xcite develop `` semantic '' techniques to integrate decision procedures into a decidable extension of the theory of arrays .",
    "their @xmath240 theory merges the quantifier - free extensional theory of arrays with dimension and presburger arithmetic over indices into a decidable logic .",
    "two extensions of the @xmath240 theory are still decidable : one with a unary predicate that determines if an array is _ injective _ ( i.e. , it has no repeated elements ) ; and one with a function that returns the _ domain _ of an array ( i.e. , the set of indices that correspond to definite values ) .",
    "ghilardi et al",
    ".  suggest that these extensions might be the basis for automated reasoning on separation logic models .",
    "the framework of @xcite also supports other decidable extensions , such as the _ prefix _ , and _ sorting _ predicates , as well as the _ map _ combinator also discussed in @xcite .",
    "de moura and bjrner @xcite introduce _ combinatory array logic _ , a decidable extension of the quantifier - free extensional theory of arrays with the _ map _ and _ constant - value _ combinators ( i.e. , array functors ) . the _ constant - value _",
    "combinator defines an array with all values equal to a constant ; the _ map _ combinator applies a @xmath241-ary function to the elements at position @xmath0 in @xmath241 arrays @xmath242 . de",
    "moura and bjrner define a decision procedure for their combinatory array logic , which is implemented in the z3 smt solver .",
    "habermehl et al .",
    "introduce powerful logics to reason about arrays with integer values @xcite ; unlike most related work , the decidability of their logic relies on automata - theoretic techniques for a special class of counter automata .",
    "more precisely , @xcite defines the _ logic of integer arrays _ * lia * , whose formulas are in the @xmath193 fragment and allow presburger arithmetic on existentially quantified variables , difference and modulo constraints on index variables , and difference constraints on array values . forbidding disjunctions of difference constraints on array values is necessary to ensure decidability .",
    "the resulting fragment is quite expressive , and in particular it includes practically useful formulas that are inexpressible in other decidable expressive fragments such as @xcite .",
    "the companion work @xcite introduces the _ single index logic _ * sil * , consisting of existentially quantified boolean combinations of formulas of the form @xmath243 , where the universal quantification is restricted to index variables , @xmath238 is a positive boolean combination of bound and modulo constraints on index variables , and @xmath239 is a conjunction of difference constraints on array values .",
    "again , the restrictions on quantifier alternations and boolean combinations are tight in that relaxing one of them leads to undecidability .",
    "the expressiveness of * sil * is very close to that of * lia * , and the two logics can be considered two variants of the same basic kernel .",
    "the other work @xcite shows how to use * sil * to annotate and reason automatically about array - manipulating programs ; the tight correspondence between * sil * and a class of counter automata allows the automatic generation of loop invariants and hence the automation of the full verification process .",
    "[ [ other - approaches . ] ] other approaches .",
    "+ + + + + + + + + + + + + + + + +    static analysis and abstract interpretation techniques have also been successfully applied to the analysis of array operations , especially with the goal of inferring invariants automatically ( e.g. , @xcite ) .",
    "future work will investigate the decidability of the universal fragment of @xmath3 extended with `` weak '' predicates or functions that slightly increase its expressiveness ( such as that outlined at the end of section [ sec : extensions ] ) .",
    "we will study to what extent the decision procedure for the universal fragment of @xmath3 can be integrated with other decidable logic fragments ( and possibly with the dual existential fragment ) .",
    "we will investigate how to automate the generation of inductive invariants for sequence - manipulating programs by leveraging the decidability of the universal fragment of @xmath3 .",
    "finally , we will implement the decision procedure , integrate it within a verification environment , and assess its empirical effectiveness on real programs ."
  ],
  "abstract_text": [
    "<S> we present a first - order theory of sequences with integer elements , presburger arithmetic , and regular constraints , which can model significant properties of data structures such as arrays and lists . </S>",
    "<S> we give a decision procedure for the quantifier - free fragment , based on an encoding into the first - order theory of concatenation ; the procedure has pspace complexity . </S>",
    "<S> the quantifier - free fragment of the theory of sequences can express properties such as sortedness and injectivity , as well as boolean combinations of periodic and arithmetic facts relating the elements of the sequence and their positions ( e.g. , `` for all even @xmath0 s , the element at position @xmath0 has value @xmath1 or @xmath2 '' ) . </S>",
    "<S> the resulting expressive power is orthogonal to that of the most expressive decidable logics for arrays . </S>",
    "<S> some examples demonstrate that the fragment is also suitable to reason about sequence - manipulating programs within the standard framework of axiomatic semantics . </S>"
  ]
}