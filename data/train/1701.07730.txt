{
  "article_text": [
    "a key challenge for the future wireless networks is the increasing video traffic demand , which reached 70% of total mobile ip traffic in 2015 @xcite .",
    "classical downlink systems can not meet this demand since they have limited resource blocks , and therefore as the number of simultaneous video transfers @xmath0 increases , the per - video throughput vanishes as @xmath1 .",
    "recently it was shown that scalable per - video throughput can be achieved if the communications are synergistically designed with caching at the receivers . indeed , the recent breakthrough of _ coded caching _ @xcite has inspired a rethinking of wireless downlink .",
    "different video sub - files are cached at the receivers , and video requests are served by coded multicasts .    by careful selection of sub - file caching and exploitation of the broadcast wireless channel ,",
    "the transmitted signal is simultaneously useful for decoding at users with different video requests .",
    "although this scheme  theoretically proved to scale well  can potentially resolve the future downlink bottleneck , several limitations hinder its applicability in practical systems @xcite . in this work ,",
    "we take a closer look to the limitations that arise from the fact that _ coded caching was originally designed for a symmetric error - free shared link . _",
    "if instead we consider a realistic model for the wireless channel , we observe that a naive application of coded caching faces a _ short - term _ limitation : since the channel qualities of the users fluctuate over time and our transmissions need to reach all users , the transmissions need to be designed for the worst channel quality .",
    "this is in stark contrast with standard downlink techniques , like _ opportunistic scheduling _",
    "@xcite , which serve the user with the best instantaneous channel quality .",
    "thus , a first challenge is to discover a way to allow coded caching technique to opportunistically exploit the fading of the wireless channel .",
    "apart from the fast fading consideration , there is also a _ long - term _ limitation due to the network topology .",
    "the user locations might vary , which leads to consistently poor channel quality for the ill - positioned users .",
    "the classical coded caching scheme is designed to deliver equal video shares to all users , which leads to ill - positioned users consuming most of the air time and hence driving the overall system performance to low efficiency . in the literature , this problem has been resolved by the use of fairness among user throughputs @xcite . by allowing poorly located users to receive less throughput than others , precious airtime is saved and the overall system performance is greatly increased . since the sum throughput rate and equalitarian fairness are typically the two extreme cases , past works have proposed the use of alpha - fairness @xcite which allows to select the coefficient @xmath2 and drive the system to any desirable tradeoff point in between of the two extremes .",
    "previously , the alpha - fair objectives have been studied in the context of ( i ) multiple user activations @xcite , ( ii ) multiple antennas @xcite and ( iii ) broadcast channels @xcite . however ,",
    "here the fairness problem is further complicated by the interplay between scheduling and the coded caching operation . in particular",
    ", we wish to shed light into the following questions : _ what is the right user grouping and how we should design the codewords to achieve our fairness objective while adapting to changing channel quality ? _    to address these questions , we study the content delivery over a realistic block - fading broadcast channel , where the channel quality varies across users and time . in this setting , we design a scheme that decouples transmissions from coding . in the transmission side ,",
    "we select the multicast user set dynamically depending on the instantaneous channel quality and user urgency captured by queue lengths . in the coding side",
    ", we adapt the codeword construction of @xcite depending on how fast the transmission side serves each user set . combining with an appropriate congestion controller , we show that this approach yields our alpha - fair objective .",
    "more specifically , our approaches and contributions are summarized below :    * we impose a novel queueing structure which decomposes the channel scheduling from the codeword construction .",
    "although it is clear that the codeword construction needs to be adaptive to channel variation , our scheme ensures this through our _ backpressure _ that connects the user queues and the codeword queues .",
    "hence , we are able to show that this decomposition is without loss of optimality . *",
    "we then provide an online policy consisting of ( i ) admission control of new files into the system ; ( ii ) combination of files to perform coded caching ; ( iii ) scheduling and power control of codeword transmissions to subset of users on the wireless channel .",
    "we prove that the long - term video delivery rate vector achieved by our scheme is a near optimal solution to the alpha - fair optimization problem under the specific coded caching scheme @xcite .",
    "* through numerical examples , we demonstrate the superiority of our approach versus ( a ) opportunistic scheduling with unicast transmissions and classical network caching ( storing a fraction of each video ) , ( b ) standard coded caching based on transmitting - to - all .",
    "since coded caching was first proposed @xcite and its potential was recognized by the community , substantial efforts have been devoted to quantify the gain in realistic scenarios , including decentralized placement @xcite , non - uniform popularities @xcite , and device - to - device ( d2d ) networks @xcite .",
    "a number of recent works replace the original perfect shared link with wireless channels @xcite .",
    "commonly in the works with wireless channels , the performance of coded caching is limited by the user in the worst channel condition because the wireless multicast capacity is determined by the worst user ( * ? ? ?",
    "* chapter 7.2 ) .",
    "this limitation of coded caching has been recently highlighted in @xcite , while similar conclusions and some directions are given in @xcite .",
    "our work is the first to addresses this aspect by jointly designing the transmissions over the broadcast channel and scheduling appropriate subsets of users .",
    "most past works deal with _ offline _ caching in the sense that both cache placement and delivery phases are performed once and do not capture the random and asynchronous nature of video traffic .",
    "the papers @xcite addressed partly the online nature by studying cache eviction strategies , and delay aspects . in this paper",
    ", we explore a different online aspect .",
    "requests for video files arrive in an online fashion , and transmissions are scheduled over time - varying wireless channels .",
    "online transmission scheduling over wireless channels has been extensively studied in the context of opportunistic scheduling @xcite and network utility maximization @xcite .",
    "prior works emphasize two fundamental aspects : ( a ) the balancing of user rates according to fairness and efficiency considerations , and ( b ) the opportunistic exploitation of the time - varying fading channels .",
    "related to our work are the studies of wireless downlink with broadcast degraded channels ; @xcite gives a maxweight - type of policy and @xcite provides a throughput optimal policy based on a fluid limit analysis .",
    "our work is the first to our knowledge that studies coded caching in this setting .",
    "the new element in our study is the joint consideration of user scheduling with codeword construction for the coded caching delivery phase .",
    "we study a wireless downlink consisting of a base station and @xmath0 users .",
    "the users are interested in downloading files over the wireless channel .",
    "the performance metric is the _ time average delivery rate of files _ to user @xmath3 , denoted by @xmath4 .",
    "hence our objective is expressed with respect to the vector of delivery rates @xmath5 .",
    "we are interested in the _ fair file delivery _ problem : @xmath6    where @xmath7 denotes the set of all feasible delivery rate vectors  clarified in the following subsection  and the utility function corresponds to the _ alpha fair _ family of concave functions obtained by choosing : @xmath8    for some arbitrarily small @xmath9 ( used to extend the domain of the functions to @xmath10 ) . tuning the value of @xmath2 changes the shape of the utility function and",
    "consequently drives the system performance @xmath11 to different points : ( i ) @xmath12 yields max sum delivery rate , ( ii ) @xmath13 yields max - min delivery rate @xcite , ( iii ) @xmath14 yields proportionally fair delivery rate @xcite .",
    "choosing @xmath15 leads to a tradeoff between max sum and proportionally fair delivery rates .",
    "the optimization is designed to allow us tweak the performance of the system ; we highlight its importance by an example .",
    "suppose that for a 2-user system @xmath7 is given by the convex set shown on figure [ fig : example ] .",
    "different boundary points are obtained as solutions to .",
    "if we choose @xmath12 , the system is operated at the point that maximizes the sum @xmath16 .",
    "the choice @xmath13 leads to the maximum @xmath17 such that @xmath18 , while @xmath19 maximizes the sum of logarithms .",
    "the operation point a is obtained when we always broadcast to all users at the weakest user rate and use @xcite for coded caching transmissions .",
    "note that this results in a significant loss of efficiency due to the variations of the fading channel , and consequently a lies in the interior of @xmath7 .",
    "we may infer that the point @xmath13 is obtained by avoiding transmissions to users with instantaneous poor channel quality but still balancing their throughputs in the long run .      to analyze the set of feasible rate vectors",
    "@xmath7 we need to zoom in the detailed model of transmissions .    * caching model .",
    "* there are @xmath20 equally popular files @xmath21 , each @xmath22 bits long .",
    "the files are available to the base station .",
    "user @xmath3 is equipped with cache memory @xmath23 of @xmath24 bits , where @xmath25 $ ] .",
    "caching placement is performed during off - peak hour , and the goal is to fill the caches up to the memory constraint with selected bits . to this end , we need to select @xmath0 _ caching functions _",
    "@xmath26 which map the files @xmath21 into the cache contents @xmath27 the caching functions can be used to cache a few entire files , or a small fraction from each file , or even coded combinations of subfiles @xcite .",
    "it is important to note that the caching functions are selected once , without knowledge of future requests , and are fixed throughout our system operation .    * downlink channel model .",
    "* we consider a standard block - fading broadcast channel , such that the channel state remains constant over a slot of @xmath28 channel uses and changes from one slot to another in an i.i.d . manner .",
    "the channel output of user @xmath3 in any channel use of slot @xmath29 is given by @xmath30 where the channel input @xmath31 is subject to the power constraint @xmath32 \\leq pt_{\\rm slot}$ ] ; @xmath33 are additive white gaussian noises with covariance matrix identity of size @xmath28 , assumed independent of each other ; @xmath34 are channel fading coefficients @xmath35 independently distributed across time and users , with @xmath36 denoting the path - loss parameter of user @xmath3 .    *",
    "encoding and transmissions . *",
    "the transmissions aim to contribute information towards the delivery of a specific vector of file requests @xmath37 , where @xmath38 denotes the index of the requested file by user @xmath3 in slot @xmath29 . here",
    "@xmath20 is the video library size , typically in the order of 10k .",
    "the requests are generated randomly , and whenever a file is delivered to user @xmath3 , the next request of this user will be for another randomly selected file .    at each time slot , the base station observes the channel state @xmath39 and the request vector up to @xmath29 , @xmath40 , constructs a transmit symbol using the _ encoding function _ @xmath41 .",
    "@xmath42    finally , it transmits a codeword @xmath43 for the @xmath28 channel uses over the fading broadcast channel in slot @xmath29 .",
    "the encoding function may be chosen at each slot to contribute information to a selected subset of users @xmath44 .",
    "this allows several possibilities , e.g. to send more information to a small set of users with good instantaneous channel qualities , or less information to a large set that includes users with poor quality .",
    "* decoding .",
    "* at slot @xmath29 , each user @xmath3 observes the local cache contents @xmath23 and the sequence of channel outputs so far @xmath45 and employs a _ decoding function _",
    "@xmath46 to determine the decoded files .",
    "let @xmath47 denote the number of files decoded by user @xmath3 after @xmath29 slots .",
    "the decoding function @xmath46 is a mapping    @xmath48 the decoded files of user @xmath3 at slot @xmath29 are given by @xmath49 , and depend on the channel outputs and states up to @xmath29 , the local cache contents , and the requested files of all users up to @xmath29 .",
    "a file is incorrectly decoded if it does not belongs to the set of requested files .",
    "the number of incorrectly decoded files are then given by @xmath50 and the number of correctly decoded files at time @xmath29 is : @xmath51    a rate vector @xmath52 is said to be _ feasible _ @xmath53 if there exist functions @xmath54 , [ f_t ] , [ \\xi_k])$ ] such that :    @xmath55    where the rate is measured in file / slot .",
    "in contrast to past works which study the performance of one - shot coded caching @xcite , our rate metric measures the ability of the system to continuously deliver files to users .",
    "finding the optimal policy is very complex . in this paper , we restrict the problem to specific class of policies given by the following mild assumptions :    the admissible policies have the following characteristics :    1 .",
    "the caching placement and delivery follow the decentralized scheme @xcite .",
    "the users request distinct files , i.e. , the ids of the requested files of any two users are different .",
    "since we restrict our action space , the delivery rate feasibility region , @xmath56 , of the class of policies @xmath57 is smaller than the one for the original problem @xmath7 .",
    "however , these restrictions allow us to come up with a concrete solution approach .",
    "note that the optimal cache and transmission design policy is already a very hard problem even in the simple case of broadcast transmissions with a fixed common rate , and the method in @xcite , @xcite are practical approaches with good performance .",
    "in addition , looking at demand ids when combining files would be very complex and , because of the big library sizes , is not expected to bring substantial gains ( it is improbable that two users will make request for the same file in close time instances ) .",
    "in this section we briefly review decentralized coded caching , first proposed in @xcite , and used by all admissible policies @xmath57 .",
    "we set @xmath58 the normalized memory size . under the memory constraint of @xmath24 bits ,",
    "each user @xmath3 independently caches a subset of @xmath59 bits of file @xmath60 , chosen uniformly at random for @xmath61 . by letting @xmath62",
    "denote the sub - file of @xmath63 stored exclusively in the cache memories of the user set @xmath64 , the cache memory @xmath23 of user @xmath3 after decentralized placement is given by @xmath65 , \\forall { { \\cal j}}\\ni k , \\forall i = 1,\\dots , n \\}.\\end{aligned}\\ ] ] the size of each sub - file measured in bits is given by @xmath66 .",
    "the above completely determine the caching functions .",
    "once the requests of all users are revealed , the offline scheme proceeds to the delivery of the requested files ( delivery phase ) . assuming that user @xmath3 requests file @xmath3 , i.e. @xmath67 , the server generates and conveys the following codeword simultaneously useful to the subset of users @xmath64 : @xmath68 where @xmath69 denotes the bit - wise xor operation .",
    "the main idea here is to create a codeword useful to a subset of users by exploiting the receiver side information established during the placement phase .",
    "it is worth noticing that the _ coded _ delivery with xors significantly reduces the number of transmissions .",
    "compared to uncoded delivery , where the sub - files are sent sequentially and the number of transmissions are equal to @xmath70 , the coded delivery requires the transmission of @xmath71 , yielding a reduction of a factor @xmath72 . in a practical case of @xmath73 , it has been proved that decentralized coded caching achieves the total number of transmissions , measured in the number of files , given by @xcite @xmath74 on the other hand , in uncoded delivery , the number of transmissions is given by @xmath75 since it exploits only _ local _ caching gain at each user .",
    "for a system with @xmath76 users and normalized memory of @xmath77 , the minimum transmissions required by uncoded delivery is @xmath78 and that of decentralized coded caching is @xmath79 , yielding a gain of factor @xmath80 .    in order to further illustrate the placement and delivery of decentralized coded caching",
    ", we provide an three - user example .    for the case of @xmath81 users in fig.[fig :",
    "ex3 ] , let us assume that user 1 , 2 , 3 , requests file @xmath82 , respectively . after the placement phase , a given file @xmath83 will be partitioned into 8 subfiles .",
    "codewords to be sent are the following    * @xmath84 , @xmath85 and @xmath86 to user @xmath87 , @xmath79 and @xmath88 respectively .",
    "* @xmath89 is intended to users @xmath90 .",
    "once received , user @xmath87 decodes @xmath91 by combining the received codeword with @xmath92 given in its cache .",
    "similarly user @xmath79 decodes @xmath92 .",
    "the same approach holds for codeword @xmath93 to users @xmath94 and codeword @xmath95 to users @xmath96 * @xmath97 is intended users @xmath98 .",
    "user @xmath87 can decode @xmath99 by combining the received codeword with @xmath100 given in its cache .",
    "the same approach is used for user @xmath79 , @xmath88 to decode @xmath101 , @xmath102 respectively .",
    "in this section , we address the question on how the transmitter shall convey private and multiple common messages , each intended to a subset of users , while opportunistically exploiting the underlying wireless channel .",
    "we start by remarking that the channel in for a given channel realization @xmath103 corresponds to the gaussian degraded broadcast channel . without loss of generality ,",
    "let us assume @xmath104 so that the following markov chain holds .",
    "@xmath105 the capacity region of the degraded broadcast channel for @xmath0 private messages and a common message is well - known @xcite . in this section ,",
    "we consider a more general setup where the transmitter wishes to convey @xmath106 mutually independent messages , denoted by @xmath107 , where @xmath108 denotes the message intended to the users in subset @xmath109 .",
    "each user @xmath3 must decode all messages @xmath107 for @xmath110 . by letting @xmath111",
    "denote the multicast rate of the message @xmath108 , we say that the rate - tuple @xmath112 is achievable if there exists encoding and decoding functions which ensure the reliability and the rate condition .",
    "the capacity region is defined as the supremum of the achievable rate - tuple , where the rate is measured in bit / channel use .",
    "[ th : capacity_bc ] the capacity region @xmath113 of a @xmath0-user degraded gaussian broadcast channel with fading gains @xmath114 and @xmath106 independent messages @xmath107 is given by @xmath115 for non - negative variables @xmath116 such that @xmath117 .",
    "please refer to appendix [ appendix : bc_capacity_proof ] for the proof .",
    "the achievability builds on superposition coding at the transmitter and successive interference cancellation at receivers . for @xmath81 ,",
    "the transmit signal is simply given by @xmath118 where @xmath119 are mutually independent gaussian distributed random variables satisfying the power constraint and @xmath120 denotes the signal corresponding to the message @xmath108 intended to the subset @xmath121 .",
    "user 3 ( the weakest user ) decodes @xmath122 by treating all the other messages as noise .",
    "user 2 decodes first the messages @xmath123 and then jointly decodes @xmath124 .",
    "finally , user 1 ( the strongest user ) successively decodes @xmath125 and , finally , @xmath126 .    later in our online coded caching scheme",
    "we will need the capacity region @xmath113 , and more specifically , we will need to characterize its boundary . to this end",
    ",    it suffices to consider the weighted sum rate maximization : @xmath127 we first simplify the problem using the following theorem .    the weighted sum rate maximization with @xmath106 variables in reduces to a simpler problem with @xmath0 variables , given by @xmath128 where @xmath129 denotes the largest weight for user @xmath3 @xmath130    the proof builds on the simple structure of the capacity region .",
    "we first remark that for a given power allocation of other users , user @xmath3 sees @xmath131 messages @xmath132 for all @xmath64 such that @xmath133 with the equal channel gain . for a given set of @xmath134 , the capacity region of these messages is a simple hyperplane characterized by @xmath131 vertices @xmath135 for @xmath136 , where @xmath137 is the sum rate of user @xmath3 in the rhs of and @xmath138 is a vector with one for the @xmath60-th entry and zero for the others .",
    "therefore , the weighted sum rate seen is maximized for user @xmath3 by selecting the vertex corresponding to the largest weight , denoted by @xmath139 .",
    "this holds for any @xmath3 .",
    "we provide an efficient algorithm to solve this power allocation problem as a special case of the parallel gaussian broadcast channel studied in ( * ? ? ?",
    "* theorem 3.2 ) .",
    "following @xcite , we define the rate utility function for user @xmath3 given by @xmath140 where @xmath141 is a lagrangian multiplier .",
    "the optimal solution corresponds to selecting the user with the maximum rate utility at each @xmath142 and the resulting power allocation for user @xmath3 is @xmath143_+ = u_k(z )   \\right \\}/p\\end{aligned}\\ ] ] with @xmath141 satisfying @xmath144_+.\\end{aligned}\\ ] ]",
    "this section presents first the queued delivery network and its feasible rate region of arrival rates , then describes the proposed control policy .      at each time slot @xmath29",
    ", the controller _ admits _ @xmath145 files to be delivered to user @xmath3 , and hence @xmath145 is a control variable . as our model dictates , the succession of requested files for user @xmath3 is determined uniformly at random",
    ".    * queueing model . *",
    "the base station organizes the information into the following types of queues :    1 .   * user queues * to store admitted files , one for each user",
    ". the buffer size of queue @xmath3 is denoted by @xmath146 and expressed in number of files .",
    "* codeword queues * to store codewords to be multicast .",
    "there is one codeword queue for each subset of users @xmath147 .",
    "the size of codeword queue @xmath64 is denoted by @xmath148 and expressed in bits .    a queueing policy @xmath149 performs the following operations : ( i ) decides how many files to admit into the user queues @xmath146 in the form of @xmath150 variables , ( ii )",
    "then it decides how to combine together files from different user queues to be encoded into the form of multiple codewords which represent the required broadcast transmissions for the reception of this file ",
    "these codewords are stored in the appropriate codeword queues @xmath148 , ( iii ) and last it decides the encoding function @xmath151 .",
    "( ii ) and ( iii ) are further clarified in the next section .",
    "a queue @xmath152 is said to be ( strongly ) stable if @xmath153 < \\infty.\\ ] ] a queueing system is said to be stable if all its queues are stable . moreover , the stability region of a system is the set of all arrival rates such that the system is stable .",
    "the above definition implies that the average delay of each job in the queue is finite .    in our problem , if we develop a policy that keeps _ user queues _",
    "@xmath154 stable , then all admitted files will , at some point , be combined into codewords . if in addition _",
    "codeword queues _",
    "@xmath155 are stable , then all generated codewords will reach their destinations , meaning that all receivers will be able to decode the admitted files that they requested .",
    "[ lem : equivalence ] the region of all feasible delivery rates @xmath7 is the same as the stability region of the system ( i.e. the set of all demand arrival rates for which there exists a policy that stabilizes the queueing system ) .",
    "let @xmath156,$ ] denote the time average number of admitted files for user @xmath3 .",
    "lemma [ lem : equivalence ] implies the following corollary .",
    "[ cor : equivalentoptimization ] solving is equivalent to finding a policy @xmath149 such that @xmath157    see appendix [ appendix : equivalence_proof ]      contrary to the offline coded caching in @xcite ,",
    "we propose an online delivery scheme consisting of the following three blocks . each block is operated at each slot .    1 .",
    "* admission control : * at the beginning of each slot , the controller decides how many requests for each user , @xmath145 should be pulled into the system from the infinite reservoir .",
    "* routing : * the cumulative accepted files for user @xmath3 are stored in the admitted demand queue whose size is given by @xmath146 for @xmath158 .",
    "the server decides the combinations of files to perform coded caching .",
    "the decision at slot @xmath29 for a subset of users @xmath159 , denoted by @xmath160 , refers to the number of combined requests for this subset of users .",
    "it is worth noticing that offline coded caching lets @xmath161 for @xmath162 and zero for all the other subsets .",
    "the size of the queue @xmath163 evolves as : @xmath164^+ + a_k(t )   \\label{eq : codewordqueues}\\end{aligned}\\ ] ] if @xmath165 , the server creates codewords by applying offline coded caching explained in section [ * * ] for this subset of users as a function of the cache contents @xmath166 .",
    "* scheduling : * the codewords intended to the subset @xmath64 of users are stored in codeword queue whose size is given by @xmath167 for @xmath168 .",
    "given the instantaneous channel realization @xmath169 and the queue state @xmath170 , the server performs scheduling and rate allocation .",
    "namely , at slot @xmath29 , it determines the number @xmath171 of bits per channel use to be transmitted for the users in subset @xmath172 . by letting @xmath173",
    "denote the number of bits generated for codeword queue @xmath174 when offline coded caching is performed to the users in @xmath64 , codeword queue @xmath172 evolves as @xmath175^+   + \\sum_{{{\\cal j}}:{{\\cal i}}\\subseteq{{\\cal j}}}b_{{{\\cal j}},{{\\cal i}}}\\sigma_{{{\\cal j}}}(t )     \\end{aligned}\\ ] ] where @xmath176 .    in",
    "order determine our proposed policy , namely the set of decisions @xmath177 at each slot @xmath29 , we first characterize the feasible region @xmath7 as a set of arrival rates @xmath178 .",
    "we let @xmath179 denote the probability that the channel state at slot @xmath29 is @xmath180 where @xmath181 is the set of all possible channel states .",
    "we let @xmath113 denote the capacity region for a fixed channel state @xmath182 .",
    "then we have the following    [ th : feasibilityregion ] a demand rate vector is feasible , i.e. @xmath183 , if and only if there exist @xmath184 , @xmath185 , \\forall { { \\cal i}}\\subseteq \\{1,\\dots , k\\}$ ] such that : @xmath186    constraint says that the service rate at which admitted demands are combined to form codewords is greater than the arrival rate , while implies that the long - term average transmission rate @xmath187 for the subset @xmath172 of users should be higher than the rate at which bits of generated codewords for this group arrive . in terms of the queueing system defined , these constraints impose that the service rates of each queue should be greater than their arrival rates , thus rendering them stable .",
    "theorem [ th : feasibilityregion ] implies that the set of feasible average delivery rates is a convex set .      in order to perform the utility maximization",
    ", we need to introduce one more set of queues .",
    "these queues are virtual , in the sense that they do not hold actual file demands or bits , but are merely counters to drive the control policy .",
    "each user @xmath3 is associated with a queue @xmath188 which evolves as follows : @xmath189^+ + \\gamma_k(t)\\end{aligned}\\ ] ]    where @xmath190 represents the arrival process to the virtual queue and is given by @xmath191\\end{aligned}\\ ] ] in the above , @xmath192 is a parameter that controls the utility - delay tradeoff achieved by the algorithm ( see theorem [ th : optimality_infinite ] ) .",
    "the general intuition here is as follows : observe that the number @xmath145 of admitted demands is the service rate for the virtual queues @xmath188 .",
    "the control algorithm actually seeks to optimize the time average of the virtual arrivals @xmath190 . however , since @xmath188 is stable , its service rate , which is the actual admission rate , will be greater than the rate of the virtual arrivals , therefore giving the same optimizer .",
    "stability of all other queues will guarantee that admitted files will be actually delivered to the users .",
    "we present our on - off policy for admission control and routing . for every user @xmath3 ,",
    "admission control chooses @xmath145 demands given by @xmath193    for every subset @xmath109 , routing combines @xmath194 demands of users in @xmath64 given by @xmath195      in order to stabilize all _ codeword queues _ , the scheduling and resource allocation explicitly solve the following weighted sum rate maximization at each slot @xmath29 where the weight of the subset @xmath64 corresponds to the queue length of @xmath196 @xmath197 we propose to apply the power allocation algorithm in section [ section : broadcasting ] to solve the above problem by sorting users in a decreasing order of channel gains and treating @xmath148 as @xmath198 .",
    "in adition , we assume that the number of channel uses in one coherence block is large enough such that the decoding error from choosing channel codes with rate @xmath199 is very small . in this case",
    ", no feedback from the receivers is given .",
    "we conclude this section by providing an example of our proposed online delivery network for @xmath81 users as illustrated in fig .",
    "[ fig : queueing_system_real ] .     users .",
    "dashed lines represent wireless transmissions , solid circles files to be combined and solid arrows codewords generated . ]    at slot @xmath29 the server decides to combine @xmath200 requested by user @xmath79 with @xmath201 requested by user @xmath79 and to process @xmath202 requested by user @xmath87 uncoded",
    ". therefore @xmath203 and @xmath204 otherwise . given this codeword construction ,",
    "codeword queues have inputs as described in table i.    [ tab:1 ]    .codeword queues inputs . [ cols=\"^,^\",options=\"header \" , ]     in addition , data from queues @xmath205 are transmitted .",
    "in thi section , we present the main result of the paper , that our proposed online algorithm leads to close to optimal performance for all policies in the class @xmath57 :    [ th : optimality_infinite ] let @xmath206 the mean time - average delivery rate for user @xmath3 achieved by the proposed policy .",
    "then @xmath207 where @xmath208 is the sum of all queue lengths at the beginning of time slot @xmath29 , thus a measure of the mean delay of file delivery .",
    "the above theorem states that , by tuning the constant @xmath209 , the utility resulting from our online policy can be arbitrarily close to the optimal one , where there is a tradeoff between the guaranteed optimality gap @xmath210 and the upper bound on the total buffer length @xmath211 .    for proving the theorem",
    ", we use the lyapunov function @xmath212 and specifically the related drift - plus - penalty quantity , defined as : @xmath213 .",
    "the proposed algorithm is such that it minimizes ( a bound on ) this quantity .",
    "the main idea is to use this fact in order to compare the evolution of the drift - plus - penalty under our policy and two `` static '' policies , that is policies that take random actions ( admissions , demand combinations and wireless transmissions ) , drawn from a specific distribution , based only on the channel realizations ( and knowledge of the channel statistics ) .",
    "we can prove from theorem 4 that these policies can attain every feasible delivery rate .",
    "the first static policy is one such that it achieves the stability of the system for an arrival rate vector @xmath214 such that @xmath215 . comparing with our policy , we deduce strong stability of all queues and the bounds on the queue lengths by using a foster - lyapunov type of criterion . in order to prove near - optimality",
    ", we consider a static policy that admits file requests at rates @xmath216 and keeps the queues stable in a weaker sense ( since the arrival rate is now in the boundary @xmath56 ) . by comparing the drift - plus - penalty quantities and using telescopic sums and jensen s inequality on the time average utilities ,",
    "we obtain the near - optimality of out proposed policy .",
    "the full proof is in appendix [ appendix : performance_proof ] .",
    "in this section , we compare our proposed delivery scheme with the following two other schemes , all building on decentralized cache placement in and .    * * unicast opportunistic scheduling * : for any request , the server sends the remaining @xmath217 bits to the corresponding user without combining any files .",
    "here we only exploit the local caching gain . in each slot",
    "the serve sends with full power to user @xmath218 where @xmath219 is the empirical average rate for user @xmath3 up to slot @xmath29 . * * standard coded caching * : we use decentralized coded caching among all @xmath0 users . for the delivery ,",
    "non - opportunistic tdma transmission is used .",
    "the server sends sequentially codewords @xmath220 to the subset of users @xmath64 at the weakest user rate among @xmath64 : @xmath221once the server has sent codewords @xmath222 , every user is able to decode one file",
    ". then the process is repeated for all the demands .",
    "we consider the system with normalized memory of @xmath223 , power constraint @xmath224 , file size @xmath225 bits and number of channel uses per slot @xmath226 .",
    "we divide users into two classes of @xmath227 users each : strong users with @xmath228 and weak users with @xmath229 .",
    "we compare the three algorithms for the cases where the objective of the system is sum rate maximization ( @xmath12 ) and proportional fairness ( @xmath19 ) .",
    "the results are depicted in fig .",
    "[ subfig-1:sumrates ] and  [ subfig-2:utilities ] , respectively .",
    "regarding the sum rate objective , standard coded caching performs very poorly , indicative of the adverse effect of users with bad channel quality .",
    "it is notable that our proposed scheme outperforms the unicast opportunistic scheme , which maximizes the sum rate if only private information packets are to be conveyed .",
    "the relative merit of our scheme increases as the number of users grows .",
    "this can be attributed to the fact that our scheme can exploit any available multicast opportunities . _",
    "our result here implies that , in realistic wireless systems , coded caching can indeed provide a significant throughput increase when an appropriate joint design of routing and opportunistic transmission is used .",
    "_    regarding the proportional fair objective , we can see that the average sum utility increases with a system dimension for three schemes although our proposed scheme provides a gain compared to the two others .",
    "we provided an algorithm to solve the problem of ensuring fairness in the long term delivery rates in wireless systems employing decentralized coded caching .",
    "our results imply that appropriately combining the opportunism arising from the fading channels with the multicasting opportunities that arise from coded caching can mitigate the harmful impact of users with bad channel conditions in standard coded caching schemes and provide significant increase in the performance of the system .",
    "we provide the converse proof for @xmath81 and the general case @xmath230 follows readily .",
    "notice that the channel output of user @xmath3 in for @xmath231 channel use can be equivalently written as @xmath232 where @xmath233 for @xmath234 and @xmath235 identity matrix of size @xmath231 . since @xmath236 , we set @xmath237 } m_{{{\\cal k}}}$ ] the message that must be decoded by user @xmath3 ( user @xmath3 decodes all bits that user @xmath238 decodes ) at rate @xmath239 .",
    "more explicitly , @xmath240 , @xmath241 , @xmath242 . by fano s inequality ,",
    "we have @xmath243 consider @xmath244 since @xmath245 , there exist @xmath246 such that @xmath247 using and we obtain @xmath248    next consider @xmath249 using the conditional entropy power inequality in @xcite , we have @xmath250 and imply @xmath251 equivalent to @xmath252 since @xmath253 , there exists @xmath254 such that @xmath255 and @xmath256 using , and it follows @xmath257              superposition coding achieves the upper bound . for @xmath273 , generate random sequences @xmath274 , @xmath275 $ ] each i.i.d . @xmath276 . to transmit a triple message @xmath277 the encoder set @xmath278 . for decoding :    * receiver @xmath88 recover @xmath279 from @xmath280 by considering @xmath281 as noise .",
    "the probability of error tends to zero as @xmath282 if @xmath283 .",
    "* receiver @xmath79 uses successive cancellation .",
    "first , it decodes @xmath279 from @xmath284 by considering @xmath281 as noise .",
    "the probability of error tends to zero as @xmath282 if @xmath285 .",
    "since @xmath286 and @xmath287 , the later condition is satisfied .",
    "second , it subtracts off @xmath288 and recover @xmath289 from @xmath290 by treating @xmath291 as noise .",
    "the probability of error tends to zero as @xmath282 if @xmath292 . *",
    "receiver @xmath87 uses successive cancellation twice .",
    "first , it decodes @xmath279 from @xmath293 by considering @xmath281 as noise .",
    "the probability of error tends to zero as @xmath282 if @xmath294 .",
    "since @xmath295 and @xmath287 , the later condition is satisfied .",
    "second , it subtracts off @xmath288 and decodes @xmath289 by treating @xmath291 as noise .",
    "the probability of error tends to zero as @xmath282 if @xmath296 .",
    "since @xmath297 and @xmath298 , the later condition is satisfied .",
    "last , it subtracts off @xmath289 and recover @xmath291 .",
    "the probability of error tends to zero as @xmath282 if @xmath299 .      from lemma [ lem : equivalence ] and corollary [ cor : equivalentoptimization ]",
    ", it suffices to prove that under the online policy the queues are strongly stable and the resulting time average admission rates maximize the desired utility function subject to minimum rate constraints .",
    "we first look at policies that take random decisions based only on the channel realizations .",
    "since the feasibility region @xmath56 is a convex set ( see theorem ) , any point in it can be achieved by properly time - sharing over the possible control decisions .",
    "we focus on two such policies , one that achieves the optimal utility and another on that achieves ( i.e. admits and stabilizes the system for that ) a rate vector in th @xmath314 interior of @xmath56 .",
    "we then have the following lemmas :    [ lem : staticoptimalpolicy ] define a policy @xmath315 that in each slot where the channel states are @xmath182 works as follows : ( i ) it pulls random user demands with mean @xmath316 , and it gives the virtual queues arrivals with mean @xmath317 as well ( ii ) the number of combinations for subset @xmath64 is a random variable with mean @xmath318 and uniformly bounded by @xmath319 , ( iii ) selects one out of @xmath320 suitably defined rate vectors @xmath321 with probability @xmath322 .",
    "the parameters above are selected such that they solve the following problem : @xmath323 then , @xmath324 results in the optimal delivery rate vector ( when all possible policies are restricted to set @xmath325 ) .",
    "[ lem : stablepolicy ] define a policy @xmath326 that in each slot where the channel states are @xmath182 works as follows : ( i ) it pulls random user demands with mean @xmath327 such that @xmath328 , and gives the virtual queues",
    "random arrivals with mean @xmath329 for some @xmath330 ( ii ) the number of combinations for subset @xmath64 is a random variable with mean @xmath331 and uniformly bounded by @xmath319 , ( iii ) selects one out of @xmath320 suitably defined rate vectors @xmath321 with probability @xmath332 .",
    "the parameters above are selected such that : @xmath333 for some appropriate @xmath334 .",
    "then , the system under @xmath335 has mean incoming rates of @xmath336 and is strongly stable .",
    "the proof of the performance of our proposed policy is based on applying lyapunov optimization theory @xcite with the following as lyapunov function @xmath337 defining its drift as @xmath338 , using the queue evolution equations and the fact that @xmath339^+)^2\\leq x^2 $ ] , we have @xmath340 where @xmath341 is a constant that depends only on the parameters of the system . adding the quantity @xmath342 to both hands of and rearranging the right hand side",
    ", we have @xmath343    now observe that the control algorithm minimizes right hand side of given the channel state @xmath169 ( for any channel state ) .",
    "therefore , taking expectations over the channel state distributions , for every vectors @xmath344^k , \\bar{\\mathbf{\\gamma}}\\in [ 1,\\gamma_{max}]^k , \\bar{\\mathbf{\\sigma}}\\in conv(\\{0, .. ,\\sigma_{max}\\}^m ) ,   \\bar{\\mu}\\in \\sum_{{\\pmb{h}}\\in\\mathcal{h}}\\pi_{{\\pmb{h}}}\\gamma({\\pmb{h}})$ ] it holds that @xmath345 we will use to compare our policy with the static policies defined in lemmas [ lem : staticoptimalpolicy ] , [ lem : stablepolicy ] . more specifically , replacing the time averages we get from the static stabilizing policy @xmath335 of lemma [ lem : stablepolicy ] for some @xmath346",
    ", we get that thre exist @xmath347 such that @xmath348 since @xmath349 , it follows that @xmath350 , therefore , we have from the foster - lyapunov criterion that the system @xmath351 has a unique stationary probability distribution , under which the mean queue lengths are finite . , then @xmath352 , i.e. their length is deterministically bounded ] therefore the queues are strongly stable under our proposed policy .",
    "* proof of near optimal utility : * here we compare @xmath149 with the static optimal policy @xmath324 from lemma [ lem : staticoptimalpolicy ] . since @xmath324 takes decisions irrespectively of the queue lengths , we can replace quantities @xmath353 with the time averages corresponding to @xmath324 , i.e. @xmath354 .",
    "we thus have : @xmath355 taking expectations over @xmath356 for both sides and summing the inequalities for @xmath357 we get @xmath358 assuming @xmath359 ( this assumption is standard in this line of work , for example it holds if the system starts empty ) , taking the limit as @xmath360 goes to infinity gives @xmath361 in addition , since @xmath362 are concave , jensen s inequality implies @xmath363 proving the near optimality of the online policy follows from the above and the fact that @xmath364 ( since the virtual queues @xmath188 are strongly stable ) .",
    "g. caire , r. r. muller and r. knopp ,  hard fairness versus proportional fairness in wireless communications : the single - cell case , \" in ieee trans .",
    "theory , vol .",
    "1366 - 1385 , april 2007 .",
    "denote @xmath300 the number of files that have been admitted to the system for user @xmath3 up to slot @xmath29 . also , note that due to our restriction on the class of policies @xmath57 and our assumption about long enough blocklengths , there are no errors in decoding the files , therefore the number of files correctly decoded for user @xmath3 till slot @xmath29 is @xmath47 . since @xmath301 , if suffices to show that for every arrival rate vector @xmath183 , there exists a policy in @xmath57 for which the delivery rate vector is @xmath302 .",
    "we shall deal only with the interior of @xmath56 ( arrival rates at the boundaries of stability region are exceptional cases ) .",
    "take any arrival rate vector @xmath303 . from (",
    "* theorem 4.5 ) it follows that for any there exists a randomized demand combination and transmission policy @xmath304 , the probabilities of which depending only on the channel state realization each slot , for which the system is strongly stable .",
    "in addition , any arrival rate vector can be constructed via a randomized admission policy . since the channels are i.i.d .",
    "random with a finite state space and queues are measured in files and bits , the system now evolves as a discrete time markov chain @xmath305 , which can be checked that is aperiodic , irreducible ad with a single communicating class . in that case",
    ", strong stability means that the markov chain is ergodic with finite mean .",
    "further , this means that the system reaches to the set of states where all queues are zero infinitely often .",
    "let @xmath306 $ ] be the number of timeslots between the @xmath307th and @xmath308th visit to this set ( we make the convention that @xmath309 $ ] is the time slot that this state is reached for the first time ) . in addition , let @xmath310 , \\hat{d}_k[n]$ ] be the number of demands that arrived and were delivered in this frame , respectively . then , since within this frame the queues start and end empty , we have @xmath311 = \\hat{d}_k[n ] , \\forall n , \\forall k.\\ ] ]"
  ],
  "abstract_text": [
    "<S> the performance of existing _ coded caching _ </S>",
    "<S> schemes is sensitive to worst channel quality , a problem which is exacerbated when communicating over fading channels . in this paper </S>",
    "<S> we address this limitation in the following manner : _ in short - term _ , we allow transmissions to subsets of users with good channel quality , avoiding users with fades , while _ in long - term _ we ensure fairness across the different users . our online scheme combines ( i ) joint scheduling and power control for the broadcast channel with fading , and ( ii ) congestion control for ensuring the optimal long - term average performance . </S>",
    "<S> we restrict the caching operations to the decentralized scheme of @xcite , and subject to this restriction we prove that our scheme has near - optimal overall performance with respect to the convex alpha - fairness coded caching optimization . by tuning the coefficient alpha , </S>",
    "<S> the operator can differentiate user performance with respect to video delivery rates achievable by coded caching . </S>",
    "<S> we demonstrate via simulations our scheme s superiority over legacy coded caching and unicast opportunistic scheduling , which are identified as special cases of our general framework .    </S>",
    "<S> broadcast channel , coded caching , fairness , lyapunov optimization . </S>"
  ]
}