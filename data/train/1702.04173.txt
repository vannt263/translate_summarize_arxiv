{
  "article_text": [
    "_ access control _ is one of the most important security services in multi - user computer systems , providing a mechanism for constraining the interaction between ( authenticated ) users and protected resources .",
    "generally , access control is implemented by an authorization service , which includes an _ authorization decision function _ for deciding whether a user request to access a resource ( an `` access request '' ) should be permitted or not . in its simplest form an authorization decision function",
    "either returns an @xmath1 or @xmath2 decision .",
    "most implementations of access control use _ authorization policies _ , where a user request to access a resource is evaluated with respect to a policy that defines which requests are authorized .",
    "many recent languages for the specification of authorization policies are designed for `` open '' , distributed systems ( rather than the more traditional `` closed '' , centralized systems in which the set of users was assumed to be known in advance ) . such languages do not necessarily rely on user identities to specify policies ; instead , policies are defined in terms of other user and resource attributes .",
    "the most widely used attribute - based access control ( abac ) language is xacml  @xcite .",
    "however , xacml suffers from poorly defined and counterintuitive semantics  @xcite , and is inconsistent in its articulation of policy evaluation .",
    "ptaclis a more formal language for specifying authorization policies  @xcite , providing a concise syntax for policy targets and precise semantics for policy evaluation .",
    "crampton and williams  @xcite recently introduced the notion of _ canonical completeness _ for abac languages , showing that xacml and ptaclare not canonically complete and developing a variant of ptaclthat is canonically complete .",
    "these results apply to languages that support three decision values , which are assumed to be totally ordered .",
    "however , there are certain situations where it is useful to have four decisions available , and some languages , such as pbel  @xcite , bellog  @xcite and rumpole  @xcite , use four decisions , which are partially ordered .    in this paper , we extend existing results to languages that support four decision values , which need not be totally ordered .",
    "we show that pbel  @xcite , perhaps the best - known four - valued abac language , is not canonically complete .",
    "we then develop a canonically complete abac language , based on ptaclsyntax and semantics .",
    "the language is abstract , but its operators could be implemented as combining algorithms in xacml , thereby leveraging the features that xacml provides for specifying attribute - based requests and targets , the evaluation of targets with respect to requests , and the storage and evaluation of policies .    in section  [",
    "sec : background ] we discuss background material and related work , which provides us with the primary motivation for this paper : to develop a canonically complete @xmath3-valued logic to support a tree - structured authorization language .",
    "the main contributions of this work are :    * to extend jobe s work on canonical completeness in multi - valued logics to the case where the set of truth values forms a lattice ( section  [ sec : canonical - completeness - in - lattice - based - logic ] ) ; * to establish that existing @xmath3-valued logics are not canonically complete ( section  [ sec : canon - complete - belnap ] ) ; * to construct a canonically complete @xmath3-valued logic ( section  [ sec : canon - suitable - set ] ) ; * to construct a @xmath3-valued , canonically complete authorization language for abac ( section  [ sec : canonically - complete - abac - lang-4val ] ) .",
    "we conclude the paper with a summary of our contributions and a discussion of future work .",
    "in this section , we summarize background material and related work , including tree - structured abac languages , canonical completeness , and four - valued languages for abac , thereby providing motivation for the work in the remainder of the paper .",
    "let @xmath4 be a set of truth values .",
    "the set of formulae @xmath5 that can be written in a ( multi - valued ) propositional logic @xmath6 is defined by @xmath4 and the set of operators @xmath7 . for brevity",
    ", we will write @xmath8 when @xmath4 and @xmath7 are obvious from context .    let @xmath4 be a totally ordered set of @xmath9 truth values , @xmath10 , with @xmath11 .",
    "then we say @xmath6 is _ canonically suitable _ if and only if there exist two formulas @xmath12 and @xmath13 of arity @xmath14 in @xmath5 such that @xmath15 returns @xmath16 and @xmath17 returns @xmath18 .",
    "we will usually write @xmath12 and @xmath13 using the infix operators @xmath19 and @xmath20 respectively",
    ".    standard propositional logic with truth values @xmath21 and @xmath22 , and operators @xmath23 and @xmath24 , representing disjunction and negation , respectively , is canonically suitable : @xmath15 is simply , while @xmath17 is @xmath25 ( that is , conjunction ) .    a function @xmath26 is completely specified by a truth table containing @xmath27 columns and @xmath28 rows .",
    "however , not every truth table can be represented by a formula in a given logic @xmath6 .",
    "@xmath8 is said to be _ functionally complete _ if for every function @xmath26 , there is a formula @xmath29 of arity @xmath27 whose evaluation corresponds to the truth table . in section  [ sec : tree - structured - languages - for - abac ] , we explain why we may regard a tree - structured authorization language as a logic defined by a set of decisions and the set of policy - combining operators . in this sense , xacml is not functionally complete  @xcite , while ptacl  @xcite and pbel are  @xcite .    a _ selection operator",
    "_ @xmath30 is an @xmath27-ary operator defined as follows : @xmath31 we will write @xmath32 to denote the tuple @xmath33 when no confusion can occur . note that @xmath34 is the same for all @xmath35 , and @xmath36 for all @xmath37 .",
    "illustrative examples of binary selection operators ( for a @xmath3-valued logic ) are shown in figure  [ fig : ex - selection - operators ] .",
    "@xmath38    selection operators play a central role in the development of canonically complete logics because an arbitrary function @xmath39 can be expressed in terms of selection operators .",
    "consider , for example , the function @xmath40 then it is easy to confirm that @xmath41 moreover , @xmath42 for any @xmath43 .",
    "thus , @xmath44 in other words , we can express @xmath45 as the `` disjunction '' ( @xmath19 ) of `` conjunctions '' ( @xmath20 ) of unary selection operators .",
    "more generally , given the truth table of function @xmath39 , we can write down an equivalent function in terms of selection operators",
    ". specifically , let @xmath46 then , for all @xmath37 , @xmath47 jobe established a number of results connecting the functional completeness of a logic with the unary selection operators , summarized in the following theorem .",
    "[ thm : jobe - functional - completeness ] a logic @xmath8 is functionally complete if and only if each unary selection operator is equivalent to some formula in @xmath8 .",
    "the _ normal form _ of formula @xmath48 in a canonically suitable logic is a formula @xmath49 that has the same truth table as @xmath48 and has the following properties :    * the only binary operators it contains are @xmath19 and @xmath20 ; * no binary operator is included in the scope of a unary operator ; * no instance of @xmath19 occurs in the scope of the @xmath20 operator .    in other words , given a canonically suitable logic @xmath8 containing unary operators @xmath50 , a formula in normal form has the form @xmath51 where @xmath52 is a unary operator defined by composing the unary operators in @xmath50 . in the usual @xmath14-valued propositional logic with a single unary operator ( negation )",
    "this corresponds to disjunctive normal form .",
    "a canonically suitable logic is _ canonically complete _ if every unary selection operator can be expressed in normal form .",
    "it is known that there are canonically suitable @xmath53-valued logics that are :    not functionally complete  ;    functionally complete but not canonically complete  ( * ? ? ?",
    "* theorem 4 ) ; and    canonically complete ( and hence functionally complete )  ( * ? ? ? * theorem 6 ) .",
    "jobe defined a canonically complete @xmath53-valued logic  @xcite .",
    "the operators and the construction of the unary selection operators using these operators are given in appendix  [ app : jobe-3-val ] .",
    "the expression for @xmath45 above could be expressed in normal form , providing we could find suitable unary operators for a @xmath3-valued logic . in section  [ sec : unary - ops - totally - ordered - logics ]",
    "we explain how to produce a suitable set of unary operators for an @xmath9-valued logic .",
    "let @xmath54 be a set of _",
    "authorization decisions_. typically , we assume @xmath54 contains the values @xmath21 , @xmath22 and @xmath55 representing `` deny '' , `` allow '' and `` not - applicable '' , respectively .",
    "we call @xmath21 and @xmath22 _ conclusive _ decisions .",
    "let @xmath56 be an associative binary operator defined on @xmath54 and @xmath57 be a unary operator defined on @xmath54 .",
    "then    * an _ atomic policy _ is a pair @xmath58 , where @xmath59 is a decision in @xmath54 and @xmath60 is a _",
    "target predicate _ ; * an atomic policy is a _ policy _ ; * if @xmath61 and @xmath62 are policies , then @xmath63 and @xmath64 are policies .",
    "we will write @xmath61 to denote the policy @xmath65 .    the first stage in policy evaluation for a request @xmath66 is to determine whether a policy is `` applicable '' to @xmath66 or not .",
    "every ( well - formed ) request @xmath66 , allows us to assign a truth value to the target @xmath60 .",
    "specifically , @xmath60 may evaluate to true , in which case the associated policy is _ applicable _ ; otherwise the policy is _ not applicable_. then , writing @xmath67 to denote the truth value assigned to @xmath60 by @xmath66 and @xmath68 to denote the decision assigned to policy @xmath61 for request @xmath66 , we define : @xmath69    it is easy to see that we may represent a policy as a tree .",
    "hence , we describe policy languages of this nature as _ tree - structured_. the first stage in policy evaluation corresponds to labeling the nodes of tree applicable or not applicable .",
    "we then compute a decision for non - leaf nodes in the tree by combining the decisions assigned to their respective children .",
    "figure  [ fig : policy - tree - example ] shows the tree for the policy @xmath70 and the evaluation of that policy for a request @xmath66 such that @xmath71 for all @xmath72 except @xmath73 .    at ( 0,0 ) ( a ) ; at ( -1,0 ) ( b ) ; at ( -0.5,1 ) ( c ) ; at ( -0.5,2 ) ( d ) ; at ( 0.5,2 ) ( e ) ; at ( 0,3 ) ( f ) ; ( a )  ( c ) ; ( b )  ( c ) ; ( c )  ( d ) ; ( d ) ",
    "( f ) ; ( e )  ( f ) ;    at ( 0,0 ) ( a ) ; at ( -1,0 ) ( b ) ; at ( -0.5,1 ) ( c ) ; at ( -0.5,2 ) ( d ) ; at ( 0.5,2 ) ( e ) ; at ( 0,3 ) ( f ) ; ( a )  ( c ) ; ( b )  ( c ) ; ( c )  ( d ) ; ( d ) ",
    "( f ) ; ( e ) ",
    "( f ) ;    there are several tree - structured abac languages in the literature , including the oasis standard xacml , pbel and ptacl  @xcite .",
    "these languages differ to some extent in the choices of @xmath54 and the set of operators that are used .",
    "xacml , for example , defines several rule- and policy - combining algorithms ( which may be regarded as binary operators ) , but no unary operators .",
    "pbel and ptacl prefer to define a rather small set of operators : ptacl defines a single binary operator and two unary operators , whereas pbel defines two binary operators and a single unary operator .",
    "xacml and ptacl use a three - valued decision set comprising @xmath21 , @xmath22 and @xmath55 , to which pbel adds @xmath74 , which represents `` conflict '' .    the main difference between existing languages , however , is the extent to which they are complete in the senses defined in section  [ sec : completeness - in - mvalued - logics ]  @xcite .",
    "we summarize these differences in table  [ tbl : properties - abac - languages ] , where cs , fc and cc denote canonically suitable , functionally complete and canonically complete , respectively . in section",
    "[ sec : canon - complete - belnap ] , we prove that pbel is canonically suitable but not canonically complete .",
    ".properties of abac languages [ cols= \" < , > , > , > \" , ]      one of the main difficulties with using a tree - structured language is writing the desired policy using the operators provided by the language .",
    "in particular , if it is not possible to express a policy using a single target and decision , the policy author must engineer the desired policy by combining sub - policies using the set of operators specified in the given language .",
    "this is a non - trivial task , in general .",
    "moreover , in xacml it may be impossible to write the desired policy due to its functional incompleteness .",
    "thus , a policy author may be forced to write a policy that approximates the desired policy , which may lead to unintended or undesirable decisions for certain requests .",
    "an alternative approach , supported by xacml , is to define custom combining algorithms .",
    "however , there is no guarantee that the addition of a new combining algorithm will make xacml functionally complete .",
    "thus , more and more custom algorithms may be required over time .",
    "this , in turn , will make the design decisions faced by policy authors ever more complicated , thereby increasing the chances of errors and misconfigurations .",
    "in other words , we believe it is preferable to define a small number of operators having unambiguous semantics and providing functional completeness . a functionally complete abac language , such as ptacl , can be used to construct any conceivable policy using the operators provided by the language .",
    "however , policy authors still face the challenge of finding the correct way to combine sub - policies using those operators to construct the desired policy .    for example , ptacldefines three policy operators @xmath75 and @xmath76 . to express xacml s deny- and permit - overrides in ptaclrequires significant effort . for convenience ,",
    "we introduce the operator @xmath77 : @xmath78 it is then possible to show that @xmath79 the operators @xmath80 and @xmath81 are equivalent to the permit- and allow - overrides policy - combining algorithms in xacml . as can be seen , the definitions of these operators in terms of the ptacloperators are complex , and , more generally , it is a non - trivial task to derive such formulae .",
    "disjunctive normal form in propositional logic makes it trivial to write down a logical formula , using only conjunction , disjunction and negation , that is equivalent to an arbitrary boolean function expressed in the form of a truth table .",
    "similarly , a canonically complete abac language , such as ptacl(e )  @xcite , makes it possible to write down a policy in normal form from its decision table . in this paper",
    ", we show that there exist @xmath3-valued canonically complete logics in which the set of truth values forms a lattice .",
    "we discuss why and how this can simplify policy generation in section  [ sec : ptacl4-operators - policies ] .",
    "in addition , policies in normal form may be more efficient to evaluate .",
    "given a formula in a 3-valued logic expressed in normal form , any literal that evaluates to 0 causes the entire clause to evaluate to 0 , while any clause evaluating to 1 means the entire formula evaluates to 1 . in short ,",
    "the time required for policy evaluation may be reduced in many cases .",
    "( this is similar to the way in which algorithms such as first - applicable in xacml work : once an applicable policy is found policy evaluation terminates , even if there are additional policies that could be evaluated . )",
    "the xacml 2.0 standard includes a fourth authorization decision `` indeterminate ''  @xcite .",
    "this is used to indicate errors have occurred during policy evaluation , meaning that a decision could not be reached .",
    "the xacml 3.0 standard extends the definition of the indeterminate decision to indicate decisions that might have been reached , had evaluation been possible  @xcite .",
    "however , the indeterminate decision is used in xacml 3.0 for more than reporting errors .",
    "it is also used as a decision in the `` only - one - applicable '' combining algorithm , which returns indeterminate if two or more sub - policies are applicable .",
    "more generally , a conflict decision is used in pbel ( and languages such as rumpole and bellog ) to indicate that two sub - policies return different conclusive decisions .",
    "pbel is functionally complete . in the remainder of this paper , we show that pbel is not canonically complete and then develop a canonically complete @xmath3-valued abac language .",
    "we first recall the definition of a lattice .",
    "suppose @xmath82 is a partially ordered set .",
    "then for a subset @xmath83 of @xmath84 , we say @xmath85 is an _ upper bound _ of @xmath83 if @xmath86 for all @xmath87 .",
    "we say @xmath88 is a _ least upper bound _ or _ supremum _ of @xmath83 if @xmath89 for all upper bounds @xmath85 of @xmath83 .",
    "note that a least upper bound of @xmath83 ( if it exists ) is unique .",
    "we define _ greatest lower bound _ or _",
    "infimum _ in an analogous way .",
    "a lattice @xmath82 is a partially ordered set such that for all @xmath90 there exists a least upper bound of @xmath91 and @xmath92 , denoted @xmath93 , and a greatest lower bound of @xmath91 and @xmath92 , denoted by @xmath94 .",
    "the least upper bound of @xmath91 and @xmath92 is written as @xmath95 ( the `` join '' of @xmath91 and @xmath92 ) and the greatest lower bound is written as @xmath96 ( the `` meet '' of @xmath91 and @xmath92 ) . if @xmath82 is a finite lattice , as we will assume henceforth , then @xmath82 has a maximum element ( that is , a unique maximal element ) and a minimum element .    in the remainder of this section",
    "we    describe belnap logic  @xcite , a well - known @xmath3-valued lattice - based logic ;    extend the definitions of canonical suitability , selection operators and canonical completeness to lattices ; and    show that belnap logic and pbel are not canonically complete .",
    "belnap logic was developed with the intention of defining ways to handle inconsistent and incomplete information in a formal manner .",
    "it uses the truth values @xmath21 ,",
    "@xmath22 , @xmath55 , and @xmath74 , representing `` false '' , `` true '' , `` lack of information '' and `` too much information '' , respectively . in the remainder of this paper , we will denote the four valued decision set @xmath97 by @xmath98 .",
    "the truth values @xmath21 , @xmath22 , @xmath55 and @xmath74 have an intuitive interpretation in the context of access control : @xmath21 and @xmath22 are interpreted as the standard `` deny '' and `` allow '' decisions , @xmath55 is interpreted as `` not - applicable '' and @xmath74 represents a conflict of decisions .",
    "pbel is a @xmath3-valued tree - structured abac language  @xcite based on belnap logic .",
    "the set of truth values in belnap logic admits two orderings : a truth ordering @xmath99 and a knowledge ordering @xmath100 . in the truth ordering , @xmath21 is the minimum element and @xmath22 is the maximum element , while @xmath55 and @xmath74 are incomparable indeterminate values . in the knowledge ordering , @xmath55 is the minimum element , @xmath74 is the maximum element while @xmath21 and @xmath22 are incomparable . both @xmath101 and @xmath102",
    "are lattices , forming the interlaced bilattice illustrated in figure  [ fig : four - structure ] .",
    "( -1.5,-0.6 )  ( 1.5,-0.6 ) node(xline)[right ] @xmath60 ; ( -1.5,-0.6 )  ( -1.5,2.5 ) node(yline)[above ] @xmath103 ; at ( 0,0 ) ( a ) ; at ( -1,1 ) ( b ) ; at ( 1,1 ) ( c ) ; at ( 0,2 ) ( d ) ; ( a )  ( c ) ; ( a )  ( b ) ; ( b )  ( d ) ; ( c )  ( d ) ;    we write the meet and join in @xmath101 as @xmath104 and @xmath105 , respectively ; and the meet and join in @xmath102 as @xmath106 and @xmath107 , respectively .",
    "( we use the subscript @xmath108 to differentiate the belnap operators from the ptacloperators @xmath109 and @xmath77 . )",
    "we may interpret values in @xmath4 as operators of arity @xmath21 ( that is , constants ) .",
    "then it is known that @xmath110 is functionally complete  ( * ? ? ?",
    "* theorem 12 ) and that @xmath111 is a minimal functionally complete set of operators  ( * ? ? ?",
    "* proposition 17 ) .",
    "the truth tables for the binary operators @xmath104 , @xmath105 , @xmath106 , @xmath107 and @xmath112 are shown in figure  [ fig : belnap - operators ] ( in appendix  [ app : belnap - ops ] ) . the unary operator @xmath24 has the effect of switching the values @xmath21 and @xmath22 , leaving @xmath55 and @xmath74 fixed ; in other words , it acts like `` classical '' negation .",
    "jobe s definition of canonical suitability for multi - valued logics assumes a total ordering on the set of truth values .",
    "given that belnap logic  @xcite , on which pbel is based , is a @xmath3-valued logic in which the set of truth values forms a lattice , we seek to extend the definition of canonical suitability to lattice - based logics .",
    "let @xmath8 be a logic associated with a lattice @xmath113 of truth values .",
    "then @xmath8 is _ canonically suitable _ if and only if there exist in @xmath8 two formulas @xmath12 and @xmath13 of arity @xmath14 such that @xmath15 returns sup@xmath114 and @xmath17 returns inf@xmath114 . if a logic is canonically suitable , we will write @xmath15 and @xmath17 using infix binary operators as @xmath115 and @xmath116 , respectively .",
    "the existence of @xmath93 and @xmath117 is guaranteed in a lattice ; this is not true in general for partially ordered sets . and for a totally ordered ( finite ) set , @xmath118 and @xmath119 , so our definitions are compatible with those of jobe s for totally ordered sets of truth values .",
    "we now extend the definition of selection operators to a lattice - based logic .",
    "let @xmath8 be a logic associated with a lattice @xmath113 of truth values , with minimum truth value @xmath120 .",
    "then , for @xmath35 , the @xmath27-ary _ selection operator _ @xmath121 is defined as follows : @xmath122 note @xmath123 for all @xmath124",
    ".    the definitions for normal form and canonically completeness for lattice - based logics are identical to total - ordered logics .",
    "nevertheless , we reiterate the definitions here in the interests of clarity .",
    "the _ normal form _ of formula @xmath48 in a canonically suitable logic is a formula @xmath49 that has the same truth table as @xmath48 and has the following properties :    * the only binary operators it contains are @xmath19 and @xmath20 ; * no binary operator is included in the scope of a unary operator ; * no instance of @xmath19 occurs in the scope of the @xmath20 operator .",
    "a canonically suitable logic is _ canonically complete _ if every unary selection operator can be expressed in normal form .",
    "having extended the definitions of canonical suitability , selection operators and canonical completeness to lattices , we now investigate how these concepts can be applied to belnap logic  @xcite .",
    "the meet and join operators of the two lattices @xmath101 and @xmath102 defined in belnap logic are different .",
    "canonical suitability for a @xmath3-valued logic , defined as it is in terms of the ordering on the set of truth values , will thus depend on the ordering we choose on @xmath98 .",
    "consequently , the @xmath20 and @xmath19 operators , along with the selection operators , will differ depending on the lattice that we choose .    in section  [ sec",
    ": canonically - complete - abac - lang-4val ] , we will argue in more detail for the use of a lattice - based ordering on @xmath98 to support a tree - structured abac language .",
    "for now , we state that we will use knowledge - ordered lattice @xmath102 . can be derived using existing methods  @xcite .",
    "] the intuition is that the minimum value in this lattice is @xmath55 ( rather than @xmath21 in @xmath101 ) and that this value should be the default value for a policy ( being returned when the policy is not applicable to a request ) . in the interests of brevity , we will henceforth write @xmath125 , rather than @xmath102 .",
    "it follows from the functional completeness of @xmath126 that @xmath127 is canonically suitable .",
    "a similar argument applies to @xmath128 , the set of operators used in pbel .",
    "as @xmath55 is the minimum truth value in the lattice @xmath125 , the @xmath27-ary selection operator @xmath129 for @xmath125 is defined by the following function : @xmath130 examples of selection operators are shown in figure  [ fig : selection - operators ] .    @xmath131    functional completeness also implies all unary selection operators can be expressed as formulas in the logics @xmath127 and @xmath132 .",
    "however , we have the following result , from which it follows that neither of these logics is canonically complete .",
    "[ pro : belnap - normal - form ] @xmath133 is not canonically complete .",
    "it is impossible to represent all unary selection operators in normal form .",
    "the statement follows from the following observations :    belnap logic defines one unary operator @xmath134 ;    the only binary operators that may be used in normal form are @xmath107 ( @xmath20 ) and @xmath106 ( @xmath19 ) ; and    for any operator @xmath135 we have @xmath136 .",
    "thus it is impossible to construct a unary operator of the form @xmath137 for any @xmath138 .",
    "pbel is not a canonically complete authorization language .",
    "pbel uses the set of operators @xmath139 , which is a subset of @xmath140 .",
    "thus , by proposition  [ pro : belnap - normal - form ] , this is not a canonically complete set of operators , so @xmath141 is not canonically complete either .",
    "hence , we may conclude that pbel is not a canonically complete authorization language .",
    "in the proof of proposition  [ pro : belnap - normal - form ] , we were unable to construct all unary selection operators using operators from the set @xmath142 , because there is no operator in which @xmath143 .",
    "this suggests that we will require at least one additional unary operator @xmath57 , say , such that @xmath144 .",
    "accordingly , we start with the unary operator , sometimes called `` conflation ''  @xcite , such that @xmath145 conflation is analogous to negation @xmath146 , but inverts knowledge values rather than truth values .",
    "in addition to @xmath147 , we include the operator @xmath106 in our set of operators , since this is the join operator for @xmath125 .",
    "[ pro : canonically - suitable - operators - for - belnap ] @xmath148 is canonically suitable .",
    "informally , the proof follows from the fact that @xmath147 and @xmath106 have exactly the same effect on @xmath125 as @xmath24 and @xmath104 have on @xmath101 .",
    "more formally , the following equivalence holds  @xcite : @xmath149 the decision table establishing this equivalence is given in figure  [ fig : bkor - encoding ] ( in appendix  [ app : canonical - suitability - proof ] ) .",
    "hence , we conclude that the set of operators @xmath150 is canonically suitable , since @xmath20 corresponds to @xmath106 and @xmath19 corresponds to @xmath107 .",
    "@xmath148 is not functionally complete .",
    "the proof follows from the following observations :    for the operators @xmath147 and @xmath106 , @xmath151 and @xmath152 ; and    any operator @xmath153 which is a combination of @xmath147 and @xmath106 , we have @xmath154 .    thus it is impossible to construct an operator in which @xmath155 .    to summarize : @xmath133 is not canonically complete and @xmath148 is not functionally complete .",
    "we now investigate what additional operators should be defined to construct a set of operators which is canonically complete ( and hence functionally complete ) .",
    "given that we can not use any operators besides @xmath19 and @xmath20 in normal form , we focus on defining additional unary operators on @xmath125 .",
    "an important observation at this point is that any permutation ( that is , a bijection ) @xmath156 defines a unary operator on @xmath98 .",
    "accordingly , we now explore the connections between the group of permutations on @xmath98 and unary operators on @xmath98 .",
    "the _ symmetric group _",
    "@xmath157 on a finite set of @xmath158 symbols is the group whose elements are all permutations of the elements in @xmath84 , and whose group operation @xmath153 is function composition . in other words , given two permutations @xmath159 and @xmath160 ,",
    "@xmath161 is a permutation such that @xmath162 we write @xmath163 to denote the permutation obtained by composing @xmath164 with itself @xmath103 times .",
    "a _ transposition _ is a permutation which exchanges two elements and keeps all others fixed",
    ". given two elements @xmath165 and @xmath166 in @xmath84 , the permutation @xmath167 is a transposition , which we denote by @xmath168 . a _",
    "cycle _ of _ length _",
    "@xmath169 is a permutation @xmath164 for which there exists an element @xmath91 in @xmath84 such that @xmath170 are the only elements changed by @xmath164 .",
    "given @xmath165 , @xmath166 and @xmath171 in @xmath84 , for example , the permutation @xmath172 is a cycle of length @xmath53 , which we denote by @xmath173 .",
    "( cycles of length two are transpositions . )",
    "the symmetric group @xmath174 is _ generated _ by its cycles .",
    "that is , every permutation may be represented as the composition of some combination of cycles .",
    "in fact , stronger results are known .",
    "we first introduce some notation .",
    "let @xmath175 and let @xmath176 denote the symmetric group on the set of elements @xmath177 .",
    "then @xmath157 is trivially isomorphic to @xmath178 ( via the mapping @xmath179 ) .",
    "[ thm : n-1-transpositions ] for @xmath180 , @xmath176 is generated by the transpositions @xmath181    [ thm : ab - arb - transp - gen - set ] for @xmath182 , the transposition @xmath183 and the cycle @xmath184 generate @xmath176 if and only if the greatest common divisor of @xmath185 and @xmath27 equals @xmath22 .",
    "in other words , it is possible to find a generating set comprising only transpositions , and it is possible to find a generating set containing only two elements .",
    "we now define three unary operators @xmath186 and @xmath187 , which swap the value of @xmath55 and the truth value in the operator s subscript . the truth tables for these operators are shown in figure  [ fig : transpositions - btran ] .",
    "note that @xmath187 is identical to the conflation operator @xmath147 .",
    "however , in the interests of continuity and consistency we will use the @xmath187 notation in the remainder of this section .",
    "@xmath188    notice that @xmath189 , @xmath190 and @xmath187 permute the elements of @xmath98 and correspond to the transpositions @xmath191 , @xmath192 and @xmath193 , respectively .",
    "thus we have the following elementary result .",
    "[ prop : any - permutation ] any permutation on @xmath98 can be expressed using only operators from the set @xmath194 .",
    "the operators @xmath186 and @xmath187 are the transpositions @xmath195 and @xmath193 respectively . by theorem  [ thm : n-1-transpositions ]",
    ", these operators generate all the permutations in @xmath196 .",
    "[ lem : any - tuple-1234 ] it is possible to express any function @xmath197 as a formula in @xmath198 .    for convenience ,",
    "we represent the function @xmath197 as the tuple @xmath199 then , given @xmath200 , we define the function @xmath201 thus , for example , @xmath202 .",
    "then it is easy to see that for all @xmath203 @xmath204 that is @xmath205 .",
    "thus , it remains to show that we can represent @xmath206 , @xmath207 , @xmath208 and @xmath209 as formulas using the operators in @xmath210 .",
    "first consider the permutations @xmath211 , @xmath212 and @xmath213 , represented by the tuples @xmath214 , @xmath215 and @xmath216 , respectively .",
    "and @xmath217 are not important : it suffices that each of @xmath211 , @xmath212 and @xmath213 are permutations ; once @xmath218 is chosen such that @xmath219 , then @xmath217 is fixed . ] since @xmath211 , @xmath212 and @xmath213 are permutations , we know they can be written as some combination of the unary operators .",
    "moreover , @xmath220 clearly , we can construct @xmath207 , @xmath208 and @xmath209 in a similar fashion .",
    "the result now follows .",
    "the decision tables showing the construction of @xmath206 ( column 5 ) and @xmath48 ( column 10 ) are shown in figure  [ fig : constructing - a - b - c - d ] .",
    "@xmath221    [ thm : func - and - canon - complete ] @xmath198 is functionally and canonically complete .",
    "by lemma  [ lem : any - tuple-1234 ] , it is possible to express any function @xmath197 as a formula using operators from the set @xmath210 .",
    "in particular , all unary selection operators can be expressed in this way .",
    "hence by theorem  [ thm : jobe - functional - completeness ] , the set of operators @xmath210 is functionally complete .",
    "moreover , all formulae constructed in the proof of lemma  [ lem : any - tuple-1234 ] contain only the binary operators @xmath222 and @xmath223 , and unary operators defined as compositions of @xmath186 and @xmath187 .",
    "thus , by definition , the unary selection operators are in normal form .",
    "@xmath224 is functionally and canonically complete .",
    "the conflation operator @xmath147 and @xmath187 are identical .",
    "hence @xmath225 therefore , the set of operators is canonically suitable , and , by theorem  [ thm : func - and - canon - complete ] , it is functionally and canonically complete ( since we can construct @xmath107 ) .",
    "[ cor : minimal - set - of - operators - for - canonically - complete-4-valued - logic ] let @xmath226 be the unary operator corresponding to the permutation given by the cycle @xmath227 . then @xmath228 is functionally and canonically complete .    by theorem  [ thm : ab - arb - transp - gen - set ] , @xmath187 and @xmath229 generate all permutations in @xmath196 .",
    "the remainder of the proof follows immediately from lemma  [ lem : any - tuple-1234 ] and theorem  [ thm : func - and - canon - complete ] .",
    "it is important to note that we could choose any transposition @xmath183 , such that @xmath230 .",
    "we specifically selected the transposition @xmath231 , as this has the effect of reversing the minimum and maximum knowledge values .",
    "another choice for this transposition is one which swaps 0 and 1 , specifically the transposition @xmath232 .",
    "this transposition is the truth negation operator @xmath146 , which in the context of access control is a useful operator , since it swaps allow and deny decisions .",
    "having shown the construction for a canonically complete 4-valued logic , in which the set of logical values forms a lattice , we briefly return to totally ordered logics .",
    "we construct a totally ordered , canonically complete @xmath9-valued logic ( thus extending the work of jobe , who only showed how to construct a canonically complete @xmath53-valued logic ) .",
    "let @xmath4 be a totally ordered set of @xmath9 truth values , @xmath233 , with @xmath234 .",
    "we define two unary operators @xmath235 and @xmath229 , which are the transposition @xmath236 and the cycle @xmath237 , respectively .",
    "in addition , we define one binary operator @xmath238 , where @xmath239 .",
    "[ prop : any - permutation - total - ord ] any permutation on @xmath4 can be expressed using only operators from the set @xmath240 .",
    "the operator @xmath235 is the transposition @xmath236 and the operator @xmath229 is the cycle @xmath237 . by theorem  [ thm : ab - arb - transp - gen - set ] , these operators generate all the permutations in @xmath241 .",
    "@xmath242 is canonically suitable .",
    "clearly @xmath243 , it remains to show the operator @xmath19 can be expressed in @xmath8 . by proposition  [ prop : any - permutation - total - ord ]",
    "we can express any permutation of @xmath4 in terms of @xmath235 and @xmath229 .",
    "in particular , we can express the permutation @xmath45 , where @xmath244 , which swaps the values @xmath22 and @xmath9 , @xmath14 and @xmath245 , and so on .",
    "we denote the unary operator which realizes this permutation by @xmath246",
    ". then @xmath247 .",
    "@xmath248 is functionally and canonically complete .",
    "we omit the proof , as it proceeds in an analogous manner to those for lemma  [ lem : any - tuple-1234 ] and theorem  [ thm : func - and - canon - complete ] .",
    "it is interesting to note that we have constructed a canonically complete @xmath9-valued logic which uses only two unary operators .",
    "this is somewhat unexpected ; intuition would suggest that @xmath245 unary operators are required for a canonically complete @xmath9-valued logic .",
    "having identified a canonically complete set of operators for belnap logic , we now investigate how this set of operators can be used in an abac language , and consider the advantages in doing so .",
    "crampton and williams  @xcite showed the operators in ptaclcan be replaced with an alternative set of operators , taken from jobe s logic @xmath249 , to obtain a canonically complete @xmath53-valued abac language . in the remainder of this section ,",
    "we describe a 4-valued lattice - ordered version of ptacl , based on the lattice , which we denote by @xmath0 .",
    "we first reiterate there is value in having an abac language for which policy evaluation can return a fourth value @xmath74 .",
    "such a value is used in both xacml and pbel , although its use in xacml is somewhat ad hoc and confusing since it can be used to indicate    an error in policy evaluation , or    a decision that arises for a particular operator during normal policy evaluation .",
    "we will use this fourth value to denote that ( normal ) policy evaluation has led to conflicting decisions ( and we do not wish to use deny - overrides or similar operators to resolve the conflict at this point in the evaluation ) .",
    "( we explain how we handle indeterminacy arising from errors in policy evaluation in section  [ sec : indeterminacy ] . )",
    "two specific operators , `` only - one - applicable '' ( ) and `` unanimity '' ( ) could make use of @xmath74 : the operator returns the value of the applicable sub - policy if there is only one such policy , and @xmath74 otherwise ; whereas the operator returns @xmath74 if the sub - policies return different decisions , and the common decision otherwise .",
    "the decision tables for these operators are shown in figure  [ fig : ooa - unanimity ] .",
    ".45 @xmath250    .45 @xmath251    in establishing canonical completeness for ptacl(e ) , crampton and williams assumed a total order on the set of decisions ( @xmath252 ) .",
    "this ordering does not really reflect the intuition behind the use of @xmath21 , @xmath22 and @xmath55 in abac languages . in the context of access control , @xmath21 and @xmath22 are incomparable conclusive decisions , and @xmath55 and @xmath74 are decisions that reflect the inability to reach a conclusive decision either because a policy or its sub - policies are inapplicable ( @xmath55 ) or because a policy s sub - policies return conclusive decisions that are incompatible in some sense ( @xmath74 ) .",
    "moreover , we can subsequently resolve @xmath55 and @xmath74 into one of two ( incomparable ) conclusive decisions using unary operators such as `` deny - by - default '' and `` allow - by - default '' .",
    "( the truth - based ordering on @xmath98 does not correspond nearly so well to the above intuitions . )",
    "we define the set of operators for @xmath0 to be @xmath253 , which we established is canonically complete in corollary  [ cor : minimal - set - of - operators - for - canonically - complete-4-valued - logic ] .",
    "recall that @xmath187 is equivalent to conflation @xmath57 ; we will use the simpler notation @xmath57 in the remainder of this section .",
    "an atomic policy has the form @xmath58 , where @xmath60 is a target and @xmath254 .",
    "( there is no reason for an atomic policy to return @xmath74  which signifies a conflict has taken place  in an atomic policy . )",
    "then we have the following policy semantics .",
    "we now show how to represent the operator only - one - applicable ( @xmath256 ) in normal form .",
    "( recall that it is possible to represent this operator as a formula in pbel ; however , it is non - trivial to derive such a formula . )",
    "using the truth table in figure  [ fig : ooa - unanimity ] and by definition of the selection operators and @xmath19 , we have is equivalent to @xmath257 moreover , @xmath258 and @xmath259 is a function @xmath197 , which can be represented as a composition of unary operators .",
    "hence , we can derive a formula in normal form for @xmath260 .",
    "functional completeness implies we can write any binary operator ( such as xacml s deny - overrides policy - combining algorithm ) as a formula in @xmath261 , and hence we can use any operator we wish in @xmath0 policies .",
    "however , canonical completeness and the decision set @xmath102 allows for a completely different approach to constructing abac policies .",
    "suppose a policy administrator has identified three sub - policies @xmath262 , @xmath263 and @xmath264 and wishes to define an overall policy @xmath61 in terms of the decisions obtained by evaluating these sub - policies .",
    "then the policy administrator can tabulate the desired decision for all relevant combinations of decisions for the sub - policies , as shown in the table below .",
    "the default decision is to return @xmath55 , indicating that @xmath61 is `` silent '' for other combinations .",
    "@xmath265 then , treating @xmath61 as a function of its sub - policies , we have @xmath266 the construction of @xmath61 as a `` disjunction '' ( @xmath19 ) of selection operators ensures that the correct value is returned for each combination of values ( in much the same as disjunctive normal form may be used to represent the rows in a truth table ) .",
    "note that if @xmath262 , @xmath263 and @xmath264 evaluate to a tuple of values other than one of the rows in the table , each of the selection operators will return @xmath55 and thus @xmath61 will evaluate to @xmath55 .",
    "each operator of the form @xmath267 can be represented as the `` conjunction '' ( @xmath20 ) of unary selection operators ( specifically @xmath268 ) .    of course",
    ", one would not usually construct the normal form by hand , as we have done above .",
    "indeed , we have developed an algorithm which takes an arbitrary policy expressed as a decision table as input , and outputs the equivalent normal form expressed in terms of the operators @xmath269 . in order to develop this algorithm",
    ", we also derived expressions for the unary selection operators in terms of the operators @xmath269 .",
    "( in lemma  [ lem : any - tuple-1234 ] we only showed that such expressions exist . )",
    "our implementation of the algorithm , comprising just less than @xmath270 lines of python code , shows the ease with which construction of policies can be both automated and simplified , utilizing the numerous advantages that have been discussed throughout this paper .",
    "xacml uses the indeterminate value in two distinct ways :    1 .   as a decision returned ( during normal evaluation ) by the `` only - one - applicable '' policy - combining algorithm ; and 2 .   as a decision returned when some ( unexpected ) error has occurred in policy evaluation",
    "has occurred .    in the second case ,",
    "the indeterminate value is used to represent alternative outcomes of policy evaluation ( had the error not occurred ) .",
    "we believe that the two situations described are quite distinct and require different policy semantics . however , the semantics of indeterminacy in xacml are confused because    the indeterminate value is used in two different ways , as described above , and    there is no clear and uniform way of establishing the values returned by the combining algorithms when an indeterminate value is encountered .",
    "we have seen how @xmath74 may be used to represent decisions for operators such as @xmath260 and @xmath271 .",
    "we handle errors in target evaluation ( and thus indeterminacy ) using sets of possible decisions  @xcite .",
    "( this approach was adopted in a rather ad hoc fashion in xacml 3.0 , using an extended version of the indeterminate decision . ) informally , when target evaluation fails , denoted by @xmath272 , ptaclassumes that either @xmath273 or @xmath274 could have been returned , and returns the union of the ( sets of ) decisions that would have been returned in both cases .",
    "the formal semantics for policy evaluation in @xmath0 in the presence of indeterminacy are defined in figure  [ fig : ptacl - indeterminacy ] .",
    "@xmath275    the semantics for the operators @xmath269 operate on sets , rather than single decisions , in the natural way . a straightforward induction on the number of operators in a policy establishes that the decision set returned by these extended semantics will be a singleton if no target evaluation errors occur",
    "; moreover , that decision will be the same as that returned by the standard semantics .",
    "xacml is a well - known , standardized language , and many of the components and features of xacml are well - defined .",
    "however , it has been shown that the rule- and policy - combining algorithms defined in the xacml standard suffer from some shortcomings  @xcite , notably inconsistencies between the rule- and policy - combining algorithms .",
    "ptacl , on which @xmath0 is based , is a tree - structured abac language that is explicitly designed to use the same general policy structure and evaluation methods as xacml .",
    "however , ptacldiffers substantially from xacml in terms of policy combination operators and semantics .",
    "thus , we suggest that @xmath0 operators could replace the rule- and policy - combining algorithms of xacml , while those parts of the language and architecture that seem to function well may be retained .",
    "specifically , we use the xacml architecture to :    specify requests ;    specify targets ;    decide whether a policy target is applicable to a given request ; and    use the policy decision point to evaluate policies .",
    "in addition , we would retain the enforcement architecture of xacml , in terms of the policy decision , policy enforcement and policy administration points , and the relationships between them .",
    "we believe it would be relatively easy to modify the xacml pdp to    * handle four decisions , extending the current set of values ( `` allow '' , `` deny '' and `` not - applicable '' ) to include `` conflict '' ; * implement the policy operators @xmath269 as custom combining algorithms ; and * work with decision sets , in order to handle indeterminacy in a uniform manner .",
    "for illustrative purposes , appendix  [ app : a ] specifies the modified decision set and pseudocode for the operator @xmath106 in the format used by the xacml standard .",
    "the main difference to end - users would be in the simplicity of policy authoring . using standard xacml , policy authors must decide which rule- and policy - combining algorithms should be used to develop a policy or policy set that is equivalent to the desired policy .",
    "this is error - prone and it may not even be possible to express the desired policy using only the xacml combining algorithms . using xacml with the policy - combining mechanisms of @xmath0 , we can present an entirely different interface for policy authoring to the end - user .",
    "the policy author would first specify the atomic policies ( xacml rules ) , then combine atomic policies using decision tables to obtain more complex policies ( as illustrated in section  [ sec : ptacl4-operators - policies ] ) .",
    "those policies can be further combined by specifying additional decision tables . at each stage",
    "a back - end policy compiler can be used to convert those policies into policy sets ( using @xmath0 operators ) that can be evaluated by the xacml engine .",
    "attribute - based access control is of increasing importance , due to the increasing use of open , distributed , interconnected and dynamic systems .",
    "the introduction of _ canonically complete _ abac languages  @xcite provides the ability to express any desired policy in a normal form , which allows for the possibility of specifying policies in the form of a decision table and then automatically compiling them into the language . in this paper",
    ", we make important contributions to the understanding of canonical completeness in multi - valued logics and thus in abac languages .",
    "first , we extend jobe s work on canonical completeness to multi - valued logics to the case where the set of truth values forms a lattice .",
    "we show that the belnap set of operators  @xcite ( and thus any subset thereof ) is not canonically complete , hence any abac language based on these operators can not be canonically complete .",
    "in particular , pbel  @xcite , probably the most well known @xmath3-valued abac language , is not canonically complete .",
    "we introduce a new four - valued logic @xmath276 which is canonically complete , without having to explicitly construct the unary selection operators in normal form ( unlike jobe  @xcite and crampton and williams  @xcite ) . by identifying the connection between the generators of the symmetric group and the unary operators of logics , we have developed a simple and generic method for identifying a set of unary operators that will guarantee the functional and canonical completeness of an @xmath9-valued lattice - based logic .",
    "we also showed that there is a set of operators containing only three connectives which is functionally complete for belnap logic , in contrast to the set of size four identified by arieli and avron  @xcite .",
    "second , we show in @xmath0 how the canonically complete set of operators @xmath277 can be used in an abac language , and present the advantages of doing so . in particular ,",
    "we are no longer forced to use a totally ordered set of three decisions to obtain canonical completeness ( as in the case in ptacl(e ) ) . moreover ,",
    "the overall design of ptacland hence @xmath0 is compatible with the overall structure of xacml policies .",
    "we discuss how the xacml decision set and rule - combining algorithms can be modified to support @xmath0 .",
    "doing so enables us to retain the rich framework provided by xacml for abac ( in terms of its languages for representing targets and requests ) and its enforcement architecture ( in terms of the policy enforcement , policy decision and policy administration points ) .",
    "thus , we are able to propose an enhanced xacml framework within which any desired policy may be expressed .",
    "moreover , the canonical completeness of @xmath0 , means that the desired policy may be represented in simple terms by a policy author ( in the form of a decision table ) and automatically compiled into a pdp - readable equivalent policy .",
    "our work paves the way for a considerable amount of future work .",
    "in particular , we intend to develop a modified xacml pdp that implements the @xmath0 operators .",
    "we also hope to develop a policy authoring interface in which users can simply state what decision a policy should return for particular combinations of decisions from sub - policies .",
    "this would enable us to evaluate the usability of such an interface and compare the accuracy with which policy authors can generate policies using standard xacml combining algorithms compared with the methods that @xmath0 can support .    on the more technical side",
    ", we would like to revisit the notion of _ monotonicity _",
    "@xcite in targets and how this affects policy evaluation in abac languages .",
    "the definition of monotonicity is dependent on the ordering chosen for the decision set and existing work on monotonicity assumes the use of a totally ordered @xmath53-valued set ( comprising @xmath21 , @xmath55 and @xmath22 ) .",
    "so it will be interesting to consider how the use of a @xmath3-valued lattice - ordered decision set affects monotonicity .",
    "we also intend to investigate methods of _ policy compression _",
    ", analogous to the minimization of boolean functions  @xcite , where we take the canonical form of a policy ( generated from a decision table ) and rewrite it in such a way as to minimize the number of terms in the policy .",
    "10    the value of the four values . , 1 ( 1998 ) , 97141 .    a useful four - valued logic . in",
    "modern uses of multiple - valued logic_. springer , 1977 , pp .",
    "537 .    an algebra for composing access control policies . , 1 ( 2002 ) , 135 .    access control via belnap logic : intuitive , expressive , and analyzable policy composition",
    ", 1 ( 2011 ) , 9 .    an authorization framework resilient to policy evaluation failures . in _",
    "computer security - esorics 2010 , 15th european symposium on research in computer security , athens , greece , september 20 - 22 , 2010 . proceedings _ ( 2010 ) , d.  gritzalis , b.  preneel , and m.  theoharidou , eds .",
    "6345 of _ lecture notes in computer science _ , springer , pp .",
    "472487 .    : a language for attribute - based access control in open systems . in _ principles of security and trust - first international conference , post 2012 , proceedings",
    ", p.  degano and j.  d. guttman , eds .",
    "7215 of _ lecture notes in computer science_. springer , 2012 , pp .  390409 .    on completeness in languages for attribute - based access control .",
    "in _ proceedings of the 21st acm on symposium on access control models and technologies , sacmat 2016 , shanghai , china , june 5 - 8 , 2016 _ ( 2016 ) , x.  s. wang , l.  bauer , and f.  kerschbaum , eds . ,",
    "acm , pp .  149160 .",
    "bilattices and the semantics of logic programming .",
    ", 1&2 ( 1991 ) , 91116 .    . , 04 ( 1962 ) , 409422 .",
    "access control policy combining : theory meets practice . in _",
    "sacmat 2009 , 14th acm symposium on access control models and technologies , proceedings _ ( 2009 ) , pp .",
    "135144 .    . ,",
    "( 1930 ) , 5557 .",
    "rumpole : an introspective break - glass access control language .",
    ", 1 ( 2014 ) , 2:12:32 .    minimization of boolean functions . , 6 ( 1956 ) , 14171444 .    , 2005 .",
    "http://docs.oasis-open.org/xacml/2.0/access-control-xacml-2.0-core-spec-os.pdf .",
    "d - algebra for composing access control policy decisions . in _ proceedings of the 2009 acm symposium on information , computer and communications security , asiaccs 2009 , sydney , australia , march 10 - 12 , 2009 _ ( 2009 ) , w.  li , w.  susilo , u.  k. tupakula , r.  safavi - naini , and v.  varadharajan , eds . ,",
    "acm , pp .  298309 .",
    "an algebra for fine - grained integration of xacml policies . in _",
    "sacmat 2009 , 14th acm symposium on access control models and technologies , stresa , italy , june 3 - 5 , 2009 , proceedings _",
    "( 2009 ) , pp .  6372 .    ,",
    "http://docs.oasis-open.org/xacml/3.0/xacml-3.0-core-os-en.html .",
    "decentralized composite access control . in",
    "_ post _ ( 2014 ) , vol .",
    "8414 of _ lecture notes in computer science _ ,",
    "springer , pp .  245264 .    a propositional policy algebra for access control . , 2 ( 2003 ) , 286325 .",
    "consider the 3-valued logic @xmath278  @xcite , whose operators @xmath279 and @xmath280 are defined in figure  [ table : jobelogic ] .",
    "@xmath281    it is easy to establish that @xmath282 thus @xmath278 is canonically suitable  ( * ? ? ?",
    "* theorem 6 ) .",
    "the normal - form formulas for the unary selection operators are shown in figure  [ fig : normal - form - selection - ops - in - e ] .",
    "( note that @xmath283 is the same for all @xmath72 . )",
    "thus @xmath278 is functionally and canonically complete  ( * ? ? ?",
    "* theorem 7 ) .",
    "hence , it is possible to construct a canonically complete @xmath53-valued logic using the operators @xmath284 .",
    ".4 @xmath286    .4 @xmath287    .4 @xmath288    .4 @xmath289    .4 @xmath290    .4 @xmath291",
    "the decision table in figure  [ fig : bkor - encoding ] establishes the equivalence of @xmath292 and @xmath293 , which proves that is a canonically suitable logic ( proposition  [ pro : canonically - suitable - operators - for - belnap ] ) .",
    "in figures  [ fig : ptacl - decisions - in - xacml ] and  [ fig : ptacl - ops - in - xacml ] we illustrate how @xmath0 extensions could be incorporated in xacml by encoding the @xmath0 decisions and @xmath106 operator using the syntax of the xacml standard .    ....",
    "< xs : element name=``decision ''           type=``xacml : decisiontype''/ > < xs : simpletype name=``decisiontype '' >   < xs : restriction base=``xs : string '' >     < xs : enumeration value=``permit''/ >     < xs : enumeration value=``deny''/ >     < xs : enumeration value=``conflict''/ >",
    "< xs : enumeration value=``notapplicable''/ >   < /xs : restriction > < /xs : simpletype > ....    .... decision ptaclcombiningalgorithm(node [ ] children ) {   boolean atleastonedeny   = false ;   boolean atleastonepermit   = false ;   for ( i=0 ; i < lengthof(children ) ; i++ )   {     decision decision = children[i].evaluate ( ) ;     if ( decision = = notapplicable )     {   return notapplicable ;   }     if ( decision = = permit )     {       atleastonepermit = true ;       continue ;     }     if ( decision = = deny )     {       atleastonedeny = true ;       continue ;     }     if ( decision = = conflict )     {   continue ;   }   }   if ( atleastonedeny & & atleastonepermit )   {   return notapplicable ;   }   if ( atleastonedeny )   {   return deny ;   }   if ( atleastonepermit )   {   return permit ;   }   return conflict ; } ...."
  ],
  "abstract_text": [
    "<S> the study of canonically complete attribute - based access control ( abac ) languages is relatively new . </S>",
    "<S> a canonically complete language is useful as it is functionally complete and provides a `` normal form '' for policies . </S>",
    "<S> however , previous work on canonically complete abac languages requires that the set of authorization decisions is totally ordered , which does not accurately reflect the intuition behind the use of the allow , deny and not - applicable decisions in access control . </S>",
    "<S> a number of recent abac languages use a fourth value and the set of authorization decisions is partially ordered . in this paper , we show how canonical completeness in multi - valued logics can be extended to the case where the set of truth values forms a lattice . </S>",
    "<S> this enables us to investigate the canonical completeness of logics having a partially ordered set of truth values , such as belnap logic , and show that abac languages based on belnap logic , such as pbel , are not canonically complete . </S>",
    "<S> we then construct a canonically complete four - valued logic using connections between the generators of the symmetric group ( defined over the set of decisions ) and unary operators in a canonically suitable logic . </S>",
    "<S> finally , we propose a new authorization language @xmath0 , an extension of ptacl , which incorporates a lattice - ordered decision set and is canonically complete . </S>",
    "<S> we then discuss how the advantages of @xmath0 can be leveraged within the framework of xacml . </S>"
  ]
}