{
  "article_text": [
    "picat is a simple , and yet powerful , logic - based multi - paradigm programming language .",
    "the desire for a logic - based general - purpose programming language that is as powerful as python for scripting , and on a par with opl @xcite and minizinc @xcite for modeling combinatorial problems , led to the design of picat .",
    "early attempts to introduce arrays and loops into prolog for modeling failed to produce a satisfactory language : most noticeably , array accesses are treated as functions only in certain contexts ; and loops require the declaration of global variables in eclipse @xcite and local variables in b - prolog @xcite .",
    "picat departs from prolog in many aspects , including the successful introduction of arrays and loops .",
    "picat uses pattern - matching rather than unification in the selection of rules .",
    "unification might be a natural choice in horn clause resolution @xcite for theorem proving , but its power is rarely needed for general programming tasks .",
    "pattern - matching rules are fully indexed , and therefore picat can be more scalable than prolog .",
    "unification can be considered as an equation over terms @xcite , and just like constraints over finite domains , picat supports unification as an explicit call .",
    "non - determinism , a powerful feature of logic programming , makes concise solutions possible for many problems , including simulation of non - deterministic automata , parsers of ambiguous grammars , and search problems .",
    "nevertheless , non - determinism is not needed for deterministic computations . in prolog ,",
    "horn clauses are backtrackable by default .",
    "as it is undecidable to detect determinism in general @xcite , programmers tend to excessively use the cut operator to prune unnecessary clauses .",
    "picat supports explicit non - determinism , which renders the cut operator unnecessary .",
    "rules are deterministic unless they are explicitly denoted as backtrackable .",
    "picat supports functions , like many other logic - based languages , such as curry @xcite , erlang @xcite , and mozart - oz @xcite . in prolog , it s often that queries fail , but the system gives no clue about the source of the failure .",
    "functions should be used instead of relations , unless multiple answers are required .",
    "functions are more convenient to use than predicates because ( 1 ) functions are guaranteed to succeed with a return value ; ( 2 ) function calls can be nested ; and ( 3 ) the directionality of functions enhances the readability .",
    "many combinatorial problems can be formulated as constraint satisfaction problems ( csps ) .",
    "there are three kinds of systematic solvers for solving csps , namely , constraint programming ( cp ) , mixed integer programming ( mip ) , and sat solving .",
    "cp uses constraint propagation to prune search spaces , and uses heuristics to guide search @xcite .",
    "mip relies on lp relaxation and branch - and - cut to find optimal integer solutions @xcite",
    ". sat performs unit propagation and clause learning to prune search spaces , and employs heuristics and learned clauses to perform non - chronological backtracking @xcite .",
    "no solver is superior all the time ; sometimes , extensive experimentation is necessary to find a suitable solver .",
    "picat provides a common interface with cp , sat , and mip solvers for solving csps . for each solver",
    ", picat provides a separate module of built - ins for creating decision variables , specifying constraints , and invoking the solver .",
    "the common interface allows for seamless switching from one solver to another .",
    "the basic language constructs , such as arrays and loops , make picat a powerful modeling language for these solvers .",
    "tabling @xcite can be used to cache the results of certain calculations in memory and reuse them in subsequent calculations through a quick table lookup .",
    "as computer memory grows , tabling is becoming increasingly important for offering dynamic programming solutions for many problems .",
    "picat s tabling system is inherited from b - prolog @xcite .",
    "picat has a planner module . for a planning problem ,",
    "the programmer only needs to specify conditions on the final states and the set of actions , and to call the planner on an initial state to find a plan or an optimal plan .",
    "the planner , which is implemented by the use of tabling , performs a state - space search and tables every state that is encountered during search .    a joint effort by the system and the programmer is needed to deal with the state explosion problem .",
    "the picat system stores all structured ground terms in a table , so ground terms that are shared by states are only tabled once .",
    "the enhanced _ hash - consing _",
    "technique @xcite also stores hash codes in order to speed up computation of hash codes and equality tests of terms .",
    "the picat system also performs _ resource - bounded tabled search _ , which prunes parts of the search space that can not lead to acceptable plans . in order to exploit these techniques , the programmer needs to design a good representation for states that facilitates sharing and removes symmetries . for certain problems",
    ", the programmer can also employ domain knowledge and heuristics to help prune the search space .",
    "picat s planner has produced surprising and encouraging results .",
    "it overwhelmingly outperforms the cutting - edge asp and pddl planners on many benchmarks used in recent asp and ipc competitions .",
    "the picat encodings of the benchmarks , which are as compact as the asp and pddl encodings , are available at picat-lang.org .",
    "this paper gives an overview of picat s facilities for combinatorial search .",
    "it also offers a glimpse of the language features .",
    "the readers are referred to @xcite for the details of the language .",
    "picat follows a different doctrine than prolog in offering the core logic programming concepts .",
    "this section gives a brief overview of picat s basic language constructs .",
    "the facilities for combinatorial search , including tabling , solver modules for csps , and a module for planning , will be described later .",
    "other features of picat , which are not covered in this overview , include assignments , global maps , action rules for defining event - driven actors , a simple module system , modules for everyday programming tasks ( basic , math , io , util , and os ) , and a module for probabilistic reasoning and learning with prism @xcite .",
    "a logic variable is a value holder , and a value is a term , which can be another variable . in addition to the basic data types in prolog , picat also provides strings , arrays , and maps .",
    "a double - quoted string is represented as list of single - character atoms , and all of the built - ins on lists , such as the concatenation function ` + + ` , can also be applied to strings .",
    "an _ array _ takes the form ` { t_1,\\ldots , t_{n } } ` . in the current implementation ,",
    "an array is a special structure with the name ` { } ` .",
    "a _ map _ is a hash - table that is represented as a structure , containing a set of key - value pairs .",
    "picat allows function calls in arguments . for this reason",
    ", it requires structures to be preceded with a dollar sign in order for them to be treated as data .",
    "for example , ` $ student(mary ,",
    "cs,3.8 ) ` is a structure , not a function call . special structures , such as ( a",
    ", b ) and ( a;b ) , as well as head patterns , are not required to have a dollar sign .    for each type",
    ", picat provides a set of built - in functions and predicates . the index notation ` x[i ] ` , where @xmath0 references a compound value and @xmath1 is an integer expression , is a special function that returns the component of @xmath0 at index @xmath1 .",
    "the index of the first element of a list or a structure is 1 .",
    "picat also allows oop notations for accessing attributes and for calling predicates and functions .",
    "the notation ` a_1.f(a_2,\\ldots , a_k ) ` is the same as ` f(a_1,a_2,\\ldots , a_k ) ` , unless @xmath2 is an atom , in which case @xmath2 must be a module qualifier for @xmath3 .",
    "the notation @xmath4 , where @xmath5 is not in the form @xmath6 , is the same as the function call ` get(a , attr ) ` .",
    "a structure is assumed to have two attributes called ` name ` and ` length ` .      in picat ,",
    "predicates and functions are defined with pattern - matching rules .",
    "picat has two types of rules : the non - backtrackable rule @xmath7`=>`@xmath8 , and the backtrackable rule @xmath7`?=>`@xmath8 . in a predicate definition",
    ", the @xmath9 takes the form @xmath10 , where @xmath11 is called the predicate name , and @xmath12 is called the arity . the condition @xmath13 , which is an optional goal , specifies a condition under which the rule is applicable . for a call @xmath14 ,",
    "if @xmath14 matches @xmath9 and @xmath13 succeeds , then the rule is said to be _ applicable _ to @xmath14 . for a head",
    "in which a variable occurs more than once , such as p(x , x ) , a call matches the pattern only if the arguments are identical . unlike the pattern matching that is used in concurrent logic languages @xcite",
    ", a call fails rather than freezes when it contains insufficiently instantiated arguments .",
    "a pattern can contain _ as - patterns _ in the form ` v@pattern ` , where @xmath15 is a new variable in the head , and @xmath16 is a non - variable term .",
    "the as - pattern ` v@pattern ` is the same as ` pattern ` in pattern matching , but after pattern matching succeeds , @xmath15 is made to reference the term that matches @xmath16 .",
    "as - patterns can be used to avoid re - constructing existing terms .",
    "when applying a rule to call @xmath14 , picat rewrites @xmath14 into @xmath17 .",
    "if the used rule is non - backtrackable , then the rewriting is a commitment , and the program can never backtrack to @xmath14 .",
    "however , if the used rule is backtrackable , then the program will backtrack to @xmath14 once @xmath17 fails , meaning that @xmath17 will be rewritten back to @xmath14 , and the next applicable rule will be tried on @xmath14 .",
    "pattern matching does not change the status of the variables in a call . in order to bind a variable @xmath0 in a call to a value @xmath18",
    ", users can call the unification @xmath19 . while it is not illegal to bind variables in @xmath13",
    ", @xmath13 normally contains only tests , and all unification calls should be written in @xmath17 .",
    "for example ,    ....      member(x,[y| _ ] ) ?",
    "= > x = y .",
    "member(x,[_|l ] ) = > member(x , l ) .",
    "....    the first rule is backtrackable .",
    "this predicate can be used to retrieve elements from a given list one by one through backtracking .",
    "a function call always succeeds with a return value , unless an exception occurs .",
    "functions are defined with non - backtrackable rules in the form @xmath20`=`@xmath21`=>`@xmath8 , where @xmath20 is a function pattern in the form @xmath22 , and @xmath23 is an expression . when both @xmath13 and @xmath17 are true , the rule can be written as @xmath20`=`@xmath23 .",
    "functions are compiled into predicates .",
    "a function call never fails due to failures in pattern matching .",
    "if no rule is applicable to a function call , then the system throws an unresolved_function_call exception .",
    "picat allows loops in rule bodies .",
    "loops are compiled into tail - recursive predicates .",
    "a ` foreach ` statement takes the form    aa = aaa = aaa = aaa = aaa = aaa = aaa ` foreach ( e_1 in d_1 , cond_1 , \\ldots , e_n in d_n , cond_n ) ` + @xmath24 + ` end `    where each iterator , @xmath25 , can be followed by an optional condition @xmath26 . within each iterator",
    ", @xmath27 is an iterating pattern , and @xmath28 is an expression that gives a compound value .",
    "the ` foreach ` statement means that @xmath24 is executed for every possible combination of values @xmath29 , @xmath30 , @xmath31 that satisfies the conditions ` cond_1 ` , @xmath30 , ` cond_n ` .",
    "picat adopts the following simple scoping rule : _ variables that occur only in a loop , but do not occur before the loop in the outer scope , are local to each iteration of the loop_. for example ,    ....      p(a ) = >                                              q(x ) ,          foreach ( i in 1 .. a.length )                          a[i ] = ( x , y )                                end .",
    "....    the loop unifies each element a[i ] of array a with a tuple ( x , y ) , where x is global and is the same for every iteration , and y is local and is new to each iteration .",
    "a list comprehension , which takes the following form , is a special functional notation for creating lists :    aa = aaa = aaa = aaa = aaa = aaa = aaa ` [ t : e_1 in d_1 , cond_1 , \\ldots , e_n in d_n , cond_n ] `    where @xmath32 is an expression .",
    "this list comprehension means that for every tuple of values @xmath29 , @xmath30 , @xmath31 , if the conditions are true , then the value of @xmath32 is added into the list .",
    "picat supports the assignment operator : = .",
    "the assignment @xmath0 : = @xmath18 , where @xmath0 is a variable , does not actually assign the value of @xmath18 to @xmath0 .",
    "it creates a new variable for @xmath0 to hold the value of @xmath18 . after the assignment , whenever @xmath0 is accessed in the body , the new variable is accessed . with assignments",
    ", a list comprehension can be easily compiled into a foreach loop that uses an assignment to accumulate the list .",
    "loops are convenient for scripting and modeling purposes .",
    "figure [ fig : loops ] gives three example functions that would be difficult to write without using loops or list comprehension .    ....",
    "power_set ( [ ] ) = [ [ ] ] .",
    "power_set([h|t ] ) = p1++p2 = >              p1 = power_set(t ) ,              p2 = [ [ h|s ] : s in p1 ] .",
    "perm ( [ ] ) = [ [ ] ] .",
    "perm(lst ) = [ [ e|p ] : e in lst , p in perm(lst.delete(e ) ) ] .",
    "matrix_multi(a , b ) = c = >              c = new_array(a.length , b[1].length ) ,              foreach ( i in 1 .. a.length , j in 1 .. b[1].length )                  c[i , j ] = sum([a[i , k]*b[k , j ] : k in 1 .. a[1].length ] )              end . ....",
    "picat provides three solver modules , including ` cp ` , ` sat ` and ` mip ` .",
    "each of the three solver types has its strengths and weaknesses . in reality ,",
    "extensive experimentation is required in order to determine a proper model and to find a suitable solver .",
    "all of the three modules implement the same interface , which makes it seamless to switch from one solver to another .",
    "the common interface consists of built - ins for creating decision variables , specifying constraints , and invoking the imported solver . in order to use a solver",
    ", users must first import the module .",
    "a decision variable is a logic variable with a domain .",
    "the domain constraint @xmath33 : : @xmath34 narrows the domains of the variables @xmath33 to @xmath34 .",
    "@xmath33 is a variable , a list of variables , or an array of variables .",
    "@xmath34 is an expression that gives a list of integers .",
    "an arithmetic constraint takes the form of @xmath35 , where @xmath36 and @xmath37 are two arithmetic expressions , and @xmath38 is one of the following constraint operators : ` # = ` ( equal ) , ` # ! = ` ( not equal ) , ` # > = ` , ` # > ` , ` # = < ` ( ` # < = ` ) , and ` # < ` .",
    "an arithmetic expression is made from integers , domain variables , and built - in arithmetic functions .",
    "a basic boolean expression is made from constants ( 0 and 1 ) , boolean variables , and the following operators : ` # /\\ ` ( and ) , ` # \\/ ` ( or ) , ` # ~ ` ( not ) , ` # ^ ` ( xor ) , ` #",
    "< = > ` ( equivalent ) , and ` # = > ` ( implication ) .",
    "an extended boolean expression can also include arithmetic and domain constraints as operands .",
    "in particular , the constraint ` b # < = > ( e1 # = e2 ) ` is called a _ reification _ constraint , which uses a boolean variable b to indicate the satisfiability of the arithmetic constraint ` e1 # = e2 ` .    a _ table constraint _ , or an _ extensional constraint _ , over a tuple of variables specifies a set of tuples that are allowed ( table_in ) or disallowed ( table_notin ) for the variables .",
    "the interface also contains the commonly used global constraints , such as the all_different , element , circuit , and cumulative constraints .",
    "the built - in predicate ` solve(options , vars ) ` calls the imported solver to label the variables @xmath39 with values , where @xmath40 is a list of options for the solver .",
    "when the option min(@xmath41 ) or max(@xmath41 ) is included , the solver returns an optimal answer .",
    "figure [ fig : queens ] gives a program for the n - queens problem .    ....",
    "import cp .",
    "queens(n , q ) = >              q = new_list(n ) ,              q : : 1 .. n ,              all_different(q ) ,              all_different([$q[i]-i : i in 1 .. n ] ) ,              all_different([$q[i]+i : i in 1 .. n ] ) ,              solve([ff],q ) . ....",
    "an underlying solver is used for each of the solver modules : the cp module uses a solver inherited from b - prolog ; the sat module uses lingeling on linux and minisat on windows ; the mip module uses glpk .    for the cp module , constraints are compiled into propagators that are defined in the ar ( action rules ) language @xcite , which are compiled further into abstract machine instructions .",
    "the abstract machine provides native support for fast propagation .",
    "in particular , it stores propagators on the stack for fast context switching and provides specialized instructions for encoding commonly used propagators @xcite .",
    "the solver , which has competed in numerous solver competitions since 2005 , is robust and efficient .",
    "for example , picat solves the n - queens problem for n=1500 in less than 10 seconds on an intel i5 machine .    for the sat module",
    ", constraints are compiled into a logic formula in the conjunctive normal form ( cnf ) for the underlying sat solver .",
    "picat employs the so called _ log - encoding _ for compiling domain variables and constraints . for a domain variable ,",
    "@xmath42 boolean variables are used , where @xmath12 is the maximum absolute value of the domain .",
    "if the domain contains both negative and positive values , then another boolean variable is used to encode the sign .",
    "each combination of values of these boolean variables represents a valuation for the domain variable .",
    "if there are holes in the domain , then disequality ( @xmath43 ) constraints are generated in order to disallow assignments of those hole values to the variable .",
    "equality and disequality constraints are flattened to two types of primitive constraints in the form of @xmath44 and @xmath45 , which are compiled further into logic comparators and adders in cnf . for other types of constraints ,",
    "clauses are generated in order to disallow conflict values for the variables .",
    "the same log - encoding is used by the flatzinc sat compiler @xcite .",
    "log - encoding has less propagation power than _ direct _ and _ support _",
    "encodings for certain constraints @xcite , but is much more compact than other encodings , including the _ order _ encoding which is adopted by the sugar @xcite and the bee @xcite compilers .",
    "the sat module has solved many problems that are hard to solve with the cp module .",
    "the mip solver is still the first choice for many operations research applications @xcite . for the mip module",
    ", constraints are compiled into inequality ( @xmath46 ) constraints .",
    "the compilation follows the standard textbook recipe .",
    "for example , the constraint ` x # ! = y ` is first translated to ` x # = < y-1 # \\/ x # > = y+1 ` , which is then translated to ` b1 # \\/ b2 ` , where    ....",
    "b1 # < = > ( x # = <",
    "y-1 )      b2 #",
    "< = > ( x # > = y+1 ) ....    the reification constraint ` b #",
    "< = > ( x # = < y ) ` is compiled to ` x - y - m1*(1-b ) # = < 0 ` and ` y - x+1-m2*b # = < 0 ` , where m1 and m2 are constants :    ....      m1 = ubd(x)-lbd(y)+1      m2 = ubd(y)-lbd(x)+2 ....    where lbd(x ) is the lower bound of the domain of x , and ubd(x ) is the upper bound .",
    "the idea of tabling is to store tabled calls and their answers in a table , and to use the answers to resolve subsequent variant calls .",
    "this idea has been used in functional and logic programming for several decades , dating back to @xcite and @xcite .",
    "as computer memory grows and advanced implementation techniques are invented , tabling is becoming increasingly important for offering dynamic programming solutions for many problems .",
    "picat s tabling system is inherited from b - prolog . in order to have all of the calls and answers of a predicate or a function tabled ,",
    "users just need to add the keyword ` table ` before the first rule .",
    "picat supports mode - directed tabling for dynamic programming problems @xcite . for a tabled predicate",
    ", users can give a _ table mode declaration _ in the form table(@xmath47 ) , where each @xmath48 is one of the following : a plus - sign ( + ) indicates input , a minus - sign ( - ) indicates output , ` max ` indicates that the corresponding argument is maximized , and ` min ` indicates that the corresponding argument is minimized .",
    "the last mode , @xmath49 , can be ` nt ` , which indicates that the argument is not tabled .",
    "two types of data can be passed to a tabled predicate as an ` nt ` argument : ( 1 ) global data that are the same to all of the calls of the predicate , and ( 2 ) data that are functionally dependent on the input arguments .",
    "when a table mode declaration is provided , picat only tables the current best answer for each tuple of input arguments .",
    "picat uses linear tabling @xcite to iteratively evaluate looping calls until an optimal answer is found .",
    "mode - directed tabling assumes that the objective function grows or declines monotonically .",
    "for example , the following tabled predicate searches for a path with the maximum total sum from top to bottom in a triangle .    ....",
    "table ( + , + , max , nt )       path(row , col , sum , tri),row==tri.length = > sum = tri[row , col ] .",
    "path(row , col , sum , tri ) ?",
    "= >           path(row+1,col , sum1,tri ) ,          sum = sum1+tri[row , col ] .",
    "path(row , col , sum , tri ) = >           path(row+1,col+1,sum1,tri ) ,          sum = sum1+tri[row , col ] .",
    "....    the triangle , which is represented as an array of arrays , is passed as an nt argument .",
    "if the current row is at the bottom of the triangle ( row==tri.length ) , then the leaf value is returned .",
    "otherwise , it makes a non - deterministic choice between two branches , one going straight down , and the other going down to the adjacent number .",
    "this program is compact , and runs very fast . for the 100-row triangle that is provided by the euler project",
    ", this program finds an answer in only 0.01 second on an intel i5 machine .",
    "the above program can be generalized for classic planning . given an initial state , a set of final states , and a set of possible actions , the classic planning problem is to find a plan that transforms the initial state to a final state .",
    "figure [ fig : plan ] shows the framework of a tabled planner .    ....",
    "table ( + , -,min )          plan(s , plan , cost),final(s ) = > plan=[],cost=0 .",
    "plan(s , plan , cost ) = >              action(s , s1,action , actioncost ) ,              plan(s1,plan1,cost1 ) ,              plan = [ action|plan1 ] ,              cost = cost1+actioncost .",
    "....    the call plan(s , plan , cost ) binds plan to an optimal plan that can transform state s to a final state .",
    "the predicate final(s ) succeeds if s is a final state , and the predicate action encodes the set of actions in the problem .",
    "the tabled program performs a state - space graph search : for a state that occurs in multiple branches in the search tree , the tabled program only expands it once .",
    "this framework demonstrated a surprisingly good performance on the sokoban problem @xcite , which was a benchmark used in the asp and ipc competitions .",
    "the same framework was also used in a program for the petrobras logistic problem @xcite .",
    "the above framework performs depth - unbounded search . for many planning problems , branch and bound",
    "is useful for finding optimal solutions .",
    "another argument can be added to the plan predicate in order to indicate the current resource limit .",
    "if the resource limit is negative , then the current branch can be pruned .",
    "the problem is determining which mode to use for the resource - limit argument .",
    "if it is treated as an input argument with the mode ( + ) , then calls with the same state and different resource limits are no longer variants , and will be resolved separately . if the resource limit is passed as an nt argument",
    ", then the framework no longer guarantees the completeness or soundness , because the nt argument is disregarded in variant checking , and once a call is completed with a failure it will fail forever , no matter how big the resource limit is .",
    "this problem is nicely fixed by the _ resource - bounded tabled search _ technique , which will be described in the next section .",
    "planning has been a target problem for logic programming since its inception . the first logic programming language , planner @xcite ,",
    "was designed as `` a language for proving theorems and manipulating models in a robot '' , and planning has been an important problem domain for prolog @xcite .",
    "nevertheless , prolog is not recognized as an effective tool for planning .",
    "answer set programming ( asp ) , which is based on the satisfiability approach to planning @xcite , has had more successes than prolog in solving planning problems @xcite . other logic - based languages , including action languages @xcite and transaction logic @xcite , have also been designed for planning .",
    "the planner module of picat is based on the framework given in figure [ fig : plan ] . for a planning problem",
    ", users only need to specify conditions on the final states and the set of actions , and call one of the search predicates in the module on an initial state in order to find a plan or an optimal plan .",
    "the module provides predicates for both _ resource - unbounded _ search and _ resource - bounded _ search .",
    "the following two predicates perform resource - bounded search :    * ` plan(s , limit , plan , plancost ) ` : this predicate , if it succeeds , binds @xmath50 to a plan that can transform state @xmath51 to a final state .",
    "@xmath52 is the cost of @xmath50 , which can not exceed @xmath53 , a given non - negative integer . *",
    "` best_plan(s , limit , plan , plancost ) ` : this predicate iteratively uses plan/4 to search for an optimal plan , starting with the resource limit 0 and incrementally increasing the limit until a plan is found , or until the resource limit exceeds @xmath53 , in which case the call fails .",
    "the implementation of plan/4 follows the framework in figure [ fig : plan ] .",
    "the resource limit argument is treated in such a way that it is tabled but not used in variant checking .",
    "this predicate searches for a plan by performing _ resource - bounded _",
    "search , which only expands a state if the state is new and its resource limit is non - negative , or if the state has previously failed but the current occurrence has a higher resource limit than before .",
    "the implementation of best_plan also takes advantage of the tabled states and their tabled resource limits . unlike the ida * search algorithm @xcite , which starts a new round from scratch",
    ", picat reuses the states that were tabled in the previous rounds : when the current state does not have a higher resource limit than the most recent occurrence , picat immediately fails the state .",
    "the planner module also provides a function , named current_resource ( ) , which returns the resource limit of the current call to plan/4 .",
    "this amount can be used to check against a heuristic value .",
    "if the heuristic estimate of the cost to travel from the current state to a final state is greater than the resource limit , then the current state should be failed .",
    "figure [ fig : ricochet ] gives a program for the ricochet robots problem @xcite .",
    "given an @xmath54 grid board with predefined horizontal and vertical barriers between some of the adjacent board positions , a set of robots of distinct colors on different board positions , and a target position , the goal of the game is to guide a robot of a given color to the target position via a sequence of robot moves .",
    "a robot can move horizontally or vertically from its current position .",
    "once a direction is chosen , the robot moves in that direction until encountering an obstacle , i.e. a barrier , another robot , or the edge of the board .",
    "this problem is one of the benchmarks used in the asp13 competition @xcite .",
    "the asp encoding for the potassco solver is given in @xcite .",
    "a state is represented by a structure of the following format :    aa = aaa = aaa = aaa = aaa = aaa = aaa    where the first argument is a cons that holds the current position and the target position of the target robot , and the second argument is a sorted list of positions of the other robots .",
    "a state is final if the current position and the target position are the same .",
    "note that colors of robots are not included in the representation , which makes non - target robots indistinguishable during search .",
    "this representation facilitates sharing , because lists are sorted and their common suffices are only tabled once .",
    "this representation also breaks symmetries .",
    "two configurations of non - target robots are treated as the same if they only differ by robots colors .",
    "this kind of symmetry is not easy to remove when only flat facts are used , as in asp and pddl .",
    "the actions are specified with two rules .",
    "the first rule chooses a stopping position for the target robot , and moves the target robot there . the predicate choose_move_dest",
    "non - deterministically chooses one of the four directions , and returns the position right before the first obstacle in that direction . on backtracking",
    ", it chooses an alternative direction .",
    "the second rule chooses a non - target robot to move .",
    ".... import planner .",
    "main = >      init_state(s0 ) ,      best_plan(s0,plan ) ,      writeln(plan ) .",
    "final(s([loc|loc ] , _ ) ) = > true .",
    "action(s([from|to],orobotlocs),nextstate , action , actioncost ) ?",
    "= >       nextstate = $ s([stop|to],orobotlocs ) ,      action = [ from|stop ] ,      actioncost = 1 ,      choose_move_dest(from , orobotlocs , stop ) .",
    "action(s(fromto@[from|_],orobotlocs),nextstate , action , actioncost ) = >       nextstate = $ s(fromto , orobotlocs2 ) ,      action = [ rfrom|rto ] ,      actioncost = 1 ,      select(rfrom , orobotlocs , orobotlocs1 ) ,      choose_move_dest(rfrom,[from|orobotlocs1],rto ) ,      orobotlocs2 = insert_ordered(orobotlocs1,rto ) .",
    "....    the program can be improved by using a heuristic function . at the end of each rule for action",
    ", the following condition can be added :    ....      current_resource ( ) > heuristic_val(nextstate ) ....",
    "this ensures that the resource limit is greater than the estimated number of steps required to transform nextstate to a final state .",
    "for example , the current state is at least three steps away from the final state if the target robot is not in the same row or the same column , and the target position has no obstacle around it .",
    "picat has demonstrated a surprising performance on many benchmarks .",
    "for the four planning benchmarks used in the asp13 competition ( _ nomystery _ , _ ricochet _ , _ sokoban _ , and _ solitaire _ ) , picat is one to three orders of magnitude faster than potassco , the winner of the competition .",
    "fastdownward , a winner of ipc11 , also competed in the asp11 model&solve competition .",
    "the competition results on the planning benchmarks showed that fastdownward was not as competitive as the best - performing asp solvers . on the ricochet benchmark",
    ", both picat and potassco solved all 30 instances that were used in the asp competition ; on average , potassco took 49.5 seconds per instance , while picat took 9.3 seconds when no heuristic was used , and 2.2 seconds when the above heuristic was used .",
    "this paper has presented the picat language , focusing on its modeling and solving power for combinatorial problems .",
    "lorenz schiffmann wrote the following in his review of an alpha release of picat in june 2013 , which nicely summarizes the features of picat : _ the picat language is really cool ; it s a very usable mix of logic , functional , constraint , and imperative programming .",
    "scripts can be made quite short but also easily readable .",
    "and the built - in tabling is really cool for speeding up recursive programs .",
    "i think picat is like a perfect swiss army knife that you can do anything with .",
    "_    future work includes engineering an optimizing sat compiler ; applying tabled planning to more domains , including model - checking domains ; automatic translation of action languages , such as pddl and htn , to picat ; and program analyzers in picat , both for picat itself , and for other languages .",
    "as acknowledged in the user s guide @xcite , many people have contributed in one form or another to the picat project .",
    "the author thanks jonathan fruhman , hakan kjellerstrand , and yanhong annie liu for reviewing this paper .",
    "this work was supported in part by the nsf under grant number ccf1018006 ."
  ],
  "abstract_text": [
    "<S> picat , a new member of the logic programming family , follows a different doctrine than prolog in offering the core logic programming concepts : arrays and maps as built - in data types ; implicit pattern matching with explicit unification and explicit non - determinism ; functions for deterministic computations ; and loops for convenient scripting and modeling purposes . </S>",
    "<S> picat provides facilities for solving combinatorial search problems , including a common interface with cp , sat , and mip solvers , tabling for dynamic programming , and a module for planning . </S>",
    "<S> picat s planner module , which is implemented by the use of tabling , has produced surprising and encouraging results . </S>",
    "<S> thanks to term - sharing and resource - bounded tabled search , picat overwhelmingly outperforms the cutting - edge asp and pddl planners on the planning benchmarks used in recent asp competitions .    </S>",
    "<S> [ firstpage ] </S>"
  ]
}