{
  "article_text": [
    "form @xcite is a program for symbolic manipulation of algebraic expressions specialized to handle very large expressions of millions of terms in an efficient and reliable way .",
    "that is why it is widely used in quantum field theory , where the calculation of the order of several hundred ( sometimes thousands ) of feynman diagrams is required .    in context",
    "with this goal an improvement in computing efficiency is very important .",
    "parallelization is one of the most efficient way to increase performance .",
    "so the idea to parallelize form is quite natural .",
    "parform is the parallel version of form developed in karlsruhe since 1998 @xcite . at present , a number of real physical applications exist which were performed with the help of parform @xcite .",
    "there are some internal mechanisms of form that makes form very well suited for parallelization @xcite .",
    "the concept of parallelization is indicated in fig .",
    "[ parexample ] :     general conception of parform : a master - slave structure for parallelization . ]    distribute the input terms among available processors , let each of them perform local operations on its input terms , generate and sort the arising output terms . at the end of a module the sorted streams of terms from all processors have to be merged to one final output stream again .    a _ master _ process initializes the distribution of terms and finally collects the results the real and time consuming calculations however are performed by _",
    "slaves_. each process is an independent stream of commands operating on independent data .",
    "the master communicates with slaves by means of different message passing libraries and we use mpi .",
    "the master simply distributes and collects data , i.e with a lower number of processors , the master becomes almost idle . for",
    "that case one can try to force the master to participate in real calculations , too .",
    "on the other hand , with an increasing number of slaves , the master spends more and more time to control slaves , which may lead to early speedup saturation .",
    "our estimations show that for more than four processors our master - slave model is adequate . since almost all real calculations are performed by slaves we calculate speedups normalized to the time spent by program running on two processors , one master and one slave .    using the message passing library permits to parallelize form on computer architectures , i.e. with shared ( smp ) and distributed ( clusters ) memories .",
    "the results for the program baicer running on the smp sgi altix 3700 server 32x 1.3 ghz/3mb - sc itanium2 cpus are shown in fig .",
    "[ sgi ] .",
    "computing time and speedup for the test program baicer on the sgi altix 3700 server with 32x itanium2 processors ( 1.3 ghz ) , a smp - type machine . ]    the speedup is almost linear up to 12 processors .",
    "afterwards the speedup becomes nonlinear but is still considerable .",
    "the second architecture is a cluster .",
    "the results of running baicer on an iwr xeon cluster @xcite are shown in fig .",
    "[ iwarp ] .     computing time and speedup for the test program baicer on the cluster of dual intel xeon , 2.4 ghz , 4x - infiniband . ]",
    "the speedup curve has a `` positive '' slope even for more than 8 processors , but the absolute value of this slope is rather small , and so the speedup is reasonable only for a few nodes . in case of cluster computers as",
    "@xcite it could be better to involve the master processor in real calculations too , but this should be studied in detail .",
    "the main disadvantage of the message passing approach is a considerable overhead due to huge data transfers .",
    "on smp computers one can attempt to get rid of this overhead using e.g. threads @xcite . but in this concept there are several points which have to be taken into account :    within a typical smp machine , all the memory is uniformly available to each processor , so - called `` uniform memory access '' . all memory accesses are made by the same shared memory bus .",
    "this works quite well for a relatively small number of cpus . increasing the number of cpus",
    ", a problem with the shared bus appears due to the collision rate between multiple cpu requests on the single memory bus .    in order to avoid these scalability limits of smp architectures ,",
    "the `` non - uniform memory access '' ( numa ) architecture was designed .",
    "numa assumes that each processor has its own local memory but it can also access memory owned by other processors .    as a result",
    "the concept of _ memory affinity _ has to be introduced : memory may be situated at different `` distance '' from the processor . on a sgi altix ,",
    "the ratio of remote to local memory access times varies from 1.9 to 3.5 , depending on the relative locations of the processor and the memory .",
    "usually this is not a problem since nearly all cpu architectures use a cache to exploit locality of reference in memory accesses .",
    "because nearly everything is in a cache , often one may safely ignore problems resulting from the difference in memory affinity .",
    "but not in the case of form as discussed below .    as consequence of the frequent `` cache - use",
    "'' - as just described - the new problem of _ cache coherency _ arises : if one of the processors modifies some piece of data ( i.e. , performs a `` write '' operation ) , then the other processors have access only to an out - of - date copy of these data stored in their cache .",
    "normally the cache data have to be _",
    "invalidated_. usually , numa computers use special - purpose hardware to maintain cache coherence .",
    "such systems are called `` cache - coherent numa '' , or ccnuma @xcite .",
    "the worst case for such an approach is mutual cache invalidation , when two ( ore more ) processors are writing to the same memory region .",
    "let us consider now how ccnuma could be used for a good parallelizable problem as the multiplication of two matrices .",
    "let us take the simplest algorithm is well suited for multithreaded process : each thread reads one row of the first matrix , one column of the second matrix and sums up the result of the multiplication in a local- or even register - variable . in this case",
    "the only instruction is `` read from memory '' .",
    "practically all arithmetic operations are performed on the local memory , and only at the end the result is written into the global ( shared ) memory .",
    "possible multithreaded approach of form parallelization . ]    unfortunately , the structure of form is quite different .",
    "indeed , let us suppose that each thread treats one term , fig .",
    "[ parformcc ] . then the thread produces a lot of new terms which should be stored in the shared memory .",
    "this would lead to permanent cache invalidation .",
    "it indicates that the internal form structure is not well suited for multi - threaded parallelization on ccnuma architecture .     master - slave approach on smp without mpi .",
    "]    alternatively , one can exploit the multi - process master - slave structure ,    instead we could try to use the master - slave model discussed above with multiple processes , but now of course without mpi . for communication between the master and slaves we could use shared memory , allocating the shared memory buffers `` close '' to each slave , fig .",
    "[ forksm ] .",
    "we refer to this model as `` shared memory '' ( sm ) . as before , the master splits data into chunks and distributes them among slaves placing data to shared memory buffers .",
    "slaves manipulate these data in their local memory , and the ( pre - sorted ) results are collected by the master .",
    "here we have explicit control on memory affinity , and no message passing bottleneck anymore .    the master - slave model permits to optimize the communication between slaves and the master .",
    "for example , no direct communication between slaves is allowed , so a lot of optimization available at low level provided the structure is restricted by this communication topology .",
    "we implemented the ideas described in the previous section in parform ( we call it parform - sm ) and want to present first results in the following .    in fig .",
    "[ mpi_sm ] one can see the comparison with the results from fig .",
    "we can immediately see about 20% performance improvement compared with the previous mpi version .",
    "but the most important observation is that now the communication overhead is almost negligible as can be seen comparing the first two data points in fig .",
    "[ mpi_sm ] a ) .",
    "results of running the test program on sgi altix 3700 with mpi - based communications ( mpi ) and with shared memory segments ( sm ) normalized to the sequential version . ]    here we normalize the results not to the two - processor time , but to the time spent by the corresponding sequential version of the program . looking at the difference in times between one processor ( sequential program ) and two processors for mpi variant ( solid line ) , we may see about 20% of performance reduction .",
    "the reason is due to the communication overhead .",
    "indeed , in a two - processor mode the single slave is doing almost all the job ( except the final sorting ) and the program spends some extra time for communication between the master and the slave .",
    "for the shared memory based program , the difference in one- and two - processor regimes is unobservable .",
    "this indicates that the communication overhead has no real significance in this sm model .",
    "increasing the number of processors , an other bottleneck arises : the time for final sorting becomes more and more essential . since this sorting",
    "is performed only by the master , all the slaves are idle during this stage .",
    "this explains the speedup saturation around 30 nodes both for mpi and sm approaches .",
    "we shortly want to discuss the various aspects of the models and architectures described before .    on ccnuma computers , instead of mpi , we should use the multiprocessed model ( see sect .",
    "[ pfonsmp ] ) with multiple shared memory segments .",
    "the corresponding shared memory approach was developed , tested and demonstrates stable performance improvement around 20% .",
    "the communication overhead is negligible and the main bottleneck is the final sorting stage , so it seems to be reasonable to parallelize in future the final sorting process first .      in the present cluster version of parform",
    "the communication overhead is quite big and thus it can only be used for a relatively small number of nodes . in particular , it seems that it would be advantageous if also the master participates in real calculations .      9 j.a.m .",
    "vermaseren , symbolic manipulation with form , can ( computer algebra nederland ) , kruislaan 413 , 1098 sj amsterdam ( 1991 ) ; j.a.m .",
    "vermaseren , math - ph/0010025 d.  fliegner , a.  retey and j.a.m .",
    "vermaseren , hep - ph/9906426 ; d.  fliegner , a.  retey and j.a.m .",
    "vermaseren , hep - ph/0007221 a.  retey and j.a.m .",
    "vermaseren , nucl . phys .",
    "* b604 * ( 2001 ) 281 - 311 ; p.a .  baikov , k.g .",
    "chetyrkin and j.h .",
    "kuhn , phys .",
    "* 88 * ( 2002 ) 012001 ; p.a .",
    "baikov , k.g .",
    "chetyrkin and j.h .",
    "kuhn , phys .",
    "* b559 * ( 2003 ) 245 - 251 ; p.a .",
    "baikov , k.g .",
    "chetyrkin and j.h .",
    "kuhn , phys . rev .",
    "* d67 * ( 2003 ) 074026 ; p.a .",
    "baikov , k.g .",
    "chetyrkin and j.h .",
    "kuhn , eur .",
    "j. * c33 * ( 2004 ) 650-s652 ; s.  bekavac , hep - ph/0505174 ; a.  kotikov , j.h .",
    "kuhn and o.  veretin , `` two - loop formfactor in theories with mass gap '' , in preparation m.  tentyukov _ et al _ , `` parallel version of the symbolic manipulation program form '' , in : v.g .",
    "ganzha _ et al _ ( eds . ) , proceedings of the casc 2004 , technische universitt mnchen , garching , germany ; cs.sc/0407066 p.a .",
    "baikov , phys . lett .",
    "* b385 * ( 1996 ) 404 - 410 ; p.a .",
    "baikov , phys . lett .",
    "* b474 * ( 2000 ) 385 - 388 ; hep - ph/0507053 u.  schwickerath and a.  heiss , nucl .",
    "inst . meth . in phys .",
    "research a , 534 ( 2004 ) 130 - 134 ; see also : + http://www.fzk.de/infiniband the textbook : a.  tannenbaum , `` modern operating systems '' , 2nd ed .",
    ", prentice hall , 2001 ; online wikipedia : + http://en.wikipedia.org/wiki/ + thread_(computer_science ) http://en.wikipedia.org/wiki/ + non - uniform_memory_access ; + sgi - specific : j.  laudon and d.  lenoski , `` the sgi origin ccnuma highly scalable server , '' sgi published white paper , march 1997"
  ],
  "abstract_text": [
    "<S> we report on the status of our project of parallelization of the symbolic manipulation program form . </S>",
    "<S> we have now parallel versions of form running on cluster- or smp - architectures . </S>",
    "<S> these versions can be used to run arbitrary form programs in parallel . </S>"
  ]
}