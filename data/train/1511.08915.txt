{
  "article_text": [
    "knowledge graphs ( kgs ) are widely used in industry and academia to represent large collections of structured knowledge . while many types of graphs are in use , they all rely on simple , highly - normalized data models that can be used to uniformly represent information from many diverse sources . on the web ,",
    "the most prominent such format is rdf @xcite , and large kgs such as bio2rdf @xcite , dbpedia @xcite , wikidata @xcite , and yago @xcite are published in this format .",
    "the great potential in kgs is their ability to make connections  in a literal sense  between heterogeneous and often incomplete data sources .",
    "inferring implicit information from kgs is therefore essential in many applications , such as ontological reasoning , data integration , and information extraction .",
    "the rule - based language datalog offers a common foundation for specifying such inferences @xcite .",
    "while datalog rules are rather simple types of _ if - then _ rules , their recursive nature is making them powerful .",
    "many inference tasks can be captured in this framework , including many types of ontological reasoning commonly used with rdf .",
    "datalog thus provides an excellent basis for exploiting kgs to the full .",
    "unfortunately , the implementation of datalog inferencing on large kgs remains very challenging .",
    "the task is worst - case time - polynomial in the size of the kg , and hence tractable in principle , but huge kgs are difficult to manage .",
    "a preferred approach is therefore to _ materialize _",
    "( i.e. , pre - compute ) inferences .",
    "modern dbms such as oracle  11 g and owlim materialize kgs of 100m1b edges in times ranging from half an hour to several days @xcite .",
    "research prototypes such as marvin @xcite , c / mpi @xcite , webpie @xcite , and dynamite @xcite achieve scalability by using parallel or distributed computing , but often require significant hardware resources .",
    "@xcite , e.g. , used up to 64 high - end machines to materialize a kg with 100b edges in 14 hours .",
    "in addition , all the above systems only support ( fragments of ) the owl  rl ontology language , which is subsumed by datalog but significantly simpler .    @xcite have recently presented a completely new approach to this problem .",
    "their system rdfox exploits fast main - memory computation and parallel processing .",
    "a groundbreaking insight of this work is that this approach allows processing mid - sized kgs on commodity machines .",
    "this has opened up a new research field for in - memory datalog systems , and @xcite have presented several advancements .    inspired by this line of research , we present a new approach to in - memory datalog materialization .",
    "our goal is to further reduce memory consumption to enable even larger kgs to be processed on even simpler computers .",
    "to do so , we propose to maintain inferences in an ad - hoc column - based storage layout .",
    "in contrast to traditional row - based layouts , where a data table is represented as a list of tuples ( rows ) , column - based approaches use a tuple of columns ( value lists ) instead .",
    "this enables more efficient joins  @xcite and effective , yet simple data compression schemes  @xcite .",
    "however , these advantages are set off by the comparatively high cost of updating column - based data structures @xcite .",
    "this is a key challenge for using this technology during datalog materialization , where frequent insertions of large numbers of newly derived inferences need to be processed .",
    "indeed , to the best of our knowledge , no materialization approach has yet made use of columnar data structures .",
    "our main contributions are as follows :    * we design novel column - based data structures for in - memory datalog materialization .",
    "our memory - efficient design organizes inferences by rule and inference step .",
    "* we develop novel optimization techniques that reduce the amount of data that is considered during materialization . *",
    "we introduce a new _ memoization _",
    "method  @xcite that caches results of selected subqueries proactively , improving the performance of our procedure and optimizations . *",
    "we evaluate a prototype implementation or our approach .",
    "evaluation results show that our approach can significantly reduce the amount of main memory needed for materialization , while maintaining competitive runtimes .",
    "this allowed us to materialize fairly large graphs on commodity hardware .",
    "evaluations also show that our optimizations contribute significantly to this result .",
    "proofs for the claims in this paper can be found in an extended technical report @xcite .",
    "proofs for the claims in this paper can be found in the appendix .",
    "we define datalog in the usual way ; details can be found in the textbook by @xcite . we assume a fixed signature consisting of an infinite set @xmath0of _ constant symbols _ , an infinite set @xmath1of _ predicate symbols _ , and an infinite set @xmath2of",
    "_ variable symbols_. each predicate @xmath3 is associated with an _ arity _ @xmath4 .",
    "a _ term _ is a variable @xmath5 or a constant @xmath6 .",
    "we use symbols @xmath7 , @xmath8 for terms ; @xmath9 , @xmath10 , @xmath11 , @xmath12 , @xmath13 for variables ; and @xmath14 , @xmath15 , @xmath16 for constants .",
    "expressions like @xmath17 , @xmath18 , and @xmath19 denote finite lists of such entities .",
    "an _ atom _ is an expression @xmath20 with @xmath3 and @xmath21 .",
    "a _ fact _ is a variable - free atom .",
    "database instance _ is a finite set @xmath22 of facts .",
    "@xmath23 is an expression of the form @xmath24 where @xmath25 and @xmath26 , ",
    ", @xmath27 are _ head _ and _ body _ atoms , respectively .",
    "we assume rules to be _ safe _ : every variable in @xmath25 must also occur in some @xmath28 .",
    "a _ program _ is a finite set @xmath29 of rules .",
    "predicates that occur in the head of a rule are called _ intensional ( idb ) predicates _ ; all other predicates are _ extensional ( edb)_. idb predicates must not appear in databases .",
    "rules with at most one idb predicate in their body are _",
    "linear_. a _ substitution _",
    "@xmath30 is a partial mapping @xmath31 .",
    "its application to atoms and rules is defined as usual . for a set of facts @xmath22 and a rule @xmath23 as in , we define @xmath32 . for a program @xmath29 , we define @xmath33 , and shortcuts @xmath34 and @xmath35 . the set @xmath36 is the _ materialization of @xmath22 with @xmath29_. this materialization is finite , and contains all facts that are logical consequences of @xmath37 .",
    "knowledge graphs are often encoded in the rdf data model  @xcite , which represents labelled graphs as sets of triples of the form @xmath38 .",
    "technical details are not relevant here .",
    "schema information for rdf graphs can be expressed using the w3c owl web ontology language . since",
    "owl reasoning is complex in general , the standard offers three lightweight profiles that simplify this task . in particular ,",
    "owl reasoning can be captured with datalog in all three cases , as shown by @xcite and ( implicitly by translation to path queries ) by @xcite .",
    "the simplest encoding of rdf data for datalog is to use a ternary edb predicate @xmath39 to represent triples .",
    "we use a simple datalog program as a running example : @xmath40 { \\textsf{inverse}}(v , w ) \\leftarrow { }      & { \\textsf{t}}(v,\\textsf{{\\textsf{owl : inverseof}}},w ) \\label{eq : ruleinv } \\\\\\displaybreak[0 ] { \\textsf{t}}(y , w , x ) \\leftarrow { }      & { \\textsf{inverse}}(v , w),{\\textsf{t}}(x , v , y ) \\label{eq : ruleinvone } \\\\\\displaybreak[0 ] { \\textsf{t}}(y , v , x ) \\leftarrow { }      & { \\textsf{inverse}}(v , w),{\\textsf{t}}(x , w , y ) \\label{eq : ruleinvtwo } \\\\\\displaybreak[0 ] { \\textsf{t}}(x,{\\textsf{haspart}},z ) \\leftarrow { }      & { \\textsf{t}}(x,{\\textsf{haspart}},y),{\\textsf{t}}(y,{\\textsf{haspart}},z ) \\label{eq : ruletrans}\\end{aligned}\\]]to infer new triples , we need an idb predicate @xmath41 , initialised in rule . rule `` extracts '' an rdf - encoded owl statement that declares a property to be the inverse of another . rules and apply this information to derive inverted triples . finally , rule is a typical transitivity rule for the rdf property @xmath42 .",
    "we abbreviate @xmath42 , @xmath43 and @xmath44 by @xmath45 , @xmath46 and @xmath47 , respectively . now consider a database @xmath48 .",
    "iteratively applying rules  to @xmath22 , we obtain the following new derivations in each step , where superscripts indicate the rule used to produce each fact :    [ cols= \" < , < , < , < \" , ]     no further facts can be inferred .",
    "for example , applying rule to @xmath49 only yields duplicates of previous inferences .",
    "our goal is to compute the materialization @xmath50 . for this",
    "we use a variant of the well - known technique of _ semi - naive evaluation _ ( sne )  @xcite that is based on a more fine - grained notion of derivation step .    in each step of the algorithm",
    ", we apply one rule @xmath51 to the facts derived so far .",
    "we do this fairly , so that each rule will be applied arbitrarily often .",
    "this differs from standard sne where all rules are applied in parallel in each step .",
    "we write @xmath52}$ ] for the rule applied in step @xmath53 , and @xmath54 for the set of new facts with predicate @xmath55 derived in step @xmath53 .",
    "note that @xmath56 if @xmath55 is not the head predicate of @xmath52}$ ] .",
    "moreover , for numbers @xmath57 , we define the set @xmath58}_p{\\coloneqq}\\bigcup_{k = i}^j \\delta_p^k$ ] of all @xmath55-facts derived between steps @xmath53 and @xmath59 .",
    "consider a rule @xmath60 where @xmath61 are idb predicates and @xmath62 are edb predicates .",
    "the naive way to apply @xmath23 in step @xmath63 to compute @xmath64 is to evaluate the following `` rule '' @xmath65}_{q_1}({\\boldsymbol{s_1}}),\\ldots,\\delta^{[0,i]}_{q_m}({\\boldsymbol{s_m}})\\label{eq : naiverule}\\end{aligned}\\ ] ] and to set @xmath66}_p$ ] .",
    "however , this would recompute all previous inferences of @xmath23 in each step where @xmath23 is applied .",
    "assume that rule @xmath23 has last been evaluated in step @xmath67 .",
    "we can restrict to evaluating the following rules : @xmath68}_{q_1}({\\boldsymbol{s_1}}),\\ldots,\\delta^{[0,i]}_{q_{\\ell-1}}({\\boldsymbol{s_{\\ell-1}}}),\\\\   & \\delta^{[j , i]}_{q_\\ell}({\\boldsymbol{s_{\\ell}}}),\\delta^{[0,j-1]}_{q_{\\ell+1}}({\\boldsymbol{s_{\\ell+1}}}),\\ldots , \\delta^{[0,j-1]}_{q_m}({\\boldsymbol{s_m } } ) \\end{split}\\label{eq : snerule}\\end{aligned}\\ ] ] for all @xmath69 . with @xmath70 the union of all sets of facts derived from these @xmath71 rules",
    ", we can define @xmath66}_p$ ] as before .",
    "it is not hard to see that the rules of form consider all combinations of facts that are considered in rule .",
    "we call this procedure the _ one - rule - per - step _ variant of sne .",
    "the procedure terminates if all rules in @xmath29 have been applied in the last @xmath72 steps without deriving any new facts .",
    "[ theo_seminaive ] for every input database instance @xmath22 , and for every fair application strategy of rules , the one - rule - per - step variant of sne terminates in some step @xmath53 with the result @xmath73 } = { \\mathbb{p}}^\\infty({\\mathcal{i}})$ ] .",
    "sne is still far from avoiding all redundant computations .",
    "for example , any strategy of applying rules  above will lead to @xmath74 being derived by rule .",
    "this new inference will be considered in the next application of the second sne variant @xmath75}(v , w),\\delta_{{\\textsf{t}}}^{[j , i]}(x , w , y)$ ] of rule , leading to the derivation of @xmath76 .",
    "however , this fact must be a duplicate since it is necessary to derive @xmath74 in the first place .",
    "our variant of sne provides us with a high - level materialization procedure . to turn this into an efficient algorithm",
    ", we use a column - based storage layout described next .",
    "our algorithms distinguish the data structures used for storing the initial knowledge graph ( edb layer ) from those used to store derivations ( idb layer ) , as illustrated in fig .",
    "[ fig : storage ] .",
    "the materialization process accesses the kg by asking conjunctive queries to the edb layer .",
    "there are well - known ways to implement this efficiently , such as @xcite , and hence we focus on the idb layer here .",
    "our work is inspired by column - based databases  @xcite , an alternative to traditional row - based databases for efficiently storing large data volumes .",
    "their superior performance on analytical queries is compensated for by lower performance for data updates .",
    "hence , we structure the idb layer using a column - based layout in a way that avoids the need for frequent updates . to achieve this , we store each of the sets of inferences @xmath54 that are produced during the derivation in a separate column - oriented table . the table for @xmath54 is created when applying @xmath52}$ ] in step @xmath53 and never modified thereafter .",
    "we store the data for each rule application ( step number , rule , and table ) in one _ block _ , and keep a separate list of blocks for each idb predicate .",
    "the set of facts derived for one idb predicate @xmath55 is the union of the contents of all tables in the list of blocks for @xmath55 .",
    "figure  [ fig : storage ] illustrates this scheme , and shows the data computed for the running example .",
    "the columnar tables for @xmath54 are sorted by extending the order of integer indices used for constants to tuples of integers in the natural way ( lexicographic order of tuples ) .",
    "therefore , the first column is fully sorted , the second column is a concatenation of sorted lists for each interval of tuples that agree on the first component , and so on .",
    "each column is compressed using run - length encoding ( rle ) , where maximal sequences of @xmath77 repeated constants @xmath16 are represented by pairs @xmath78 @xcite .",
    "our approach enables valuable space savings for in - memory computation .",
    "ordering tables improves compression rates , and rules with constants in their heads ( e.g. , ) lead to constant columns , which occupy almost no memory .",
    "furthermore , columns of edb relations can be represented by queries that retrieve their values from the edb layer , rather than by a copy of these values .",
    "finally , many inference rules simply `` copy '' data from one predicate to another , e.g. , to define a subclass relationship , so we can often share column - objects in memory rather than allocating new space .",
    "we also obtain valuable time savings .",
    "sorting tables means they can be used in _",
    "merge joins _ , the most efficient type of join , where two sorted relations are compared in a single pass .",
    "this also enables efficient , set - at - a - time duplicate elimination , which we implement by performing outer merge joins between a newly derived result @xmath79 and all previously derived tables @xmath54 .",
    "the use of separate tables for each @xmath54 eliminates the cost of insertions , and at the same time enables efficient _ bookkeeping _ to record the derivation step and rule used to produce each inference .",
    "step information is needed to implement sne , but the separation of inferences by rule enables further optimizations ( see next section ) .",
    "there is also an obvious difficulty for using our approach . to evaluate a sne rule",
    ", we need to find all answers to the rule s body , viewed as a conjunctive query .",
    "this can be achieved by computing the following join : @xmath80}_{q_1}({\\boldsymbol{s_1}})\\bowtie\\ldots\\bowtie\\delta^{[0,i]}_{q_{\\ell-1}}({\\boldsymbol{s_{\\ell-1}}})\\\\   { } \\bowtie\\delta^{[j , i]}_{q_\\ell}({\\boldsymbol{s_{\\ell}}})\\bowtie\\delta^{[0,j-1]}_{q_{\\ell+1}}({\\boldsymbol{s_{\\ell+1}}})\\bowtie\\ldots\\bowtie \\delta^{[0,j-1]}_{q_m}({\\boldsymbol{s_m } } )   \\end{split}\\label{eq : snejoin}\\ ] ] the join of the edb predicates @xmath81 can be computed efficiently by the edb layer ; let @xmath82 denote the resulting relation . proceeding from left to right , we now need to compute @xmath83}_{q_1}({\\boldsymbol{s_1}})$ ] .",
    "however , our storage scheme stores the second relation in many blocks , so that we actually must compute @xmath84 , which could be expensive if there are many non - empty @xmath85 blocks in the range @xmath86 $ ] .",
    "we reduce this cost by performing _ on - demand concatenation _ of tables : before computing the join , we consolidate @xmath87 ( @xmath88 ) in a single data structure . this structure is either a hash table or a fully sorted table ",
    "the rule engine decides heuristically to use a hash or a merge join . in either case",
    ", we take advantage of our columnar layout and concatenate only columns needed in the join , often just a single column .",
    "the join performance gained with such a tailor - made data structure justifies the cost of on - demand concatenation .",
    "we delete the auxiliary structures after the join .",
    "this approach is used whenever the union of many idb tables is needed in a join . however , especially the expression @xmath89}_{q_\\ell}$ ] may often refer to only one ( non - empty ) block , in which case we can work directly on its data .",
    "we use several optimizations that aim to exclude some non - empty blocks from a join so as to make this more likely , as described next .",
    "our storage layout is most effective when only a few blocks of fact tables @xmath90 must be considered for applying a rule , as this will make on - demand concatenation simpler or completely obsolete .",
    "an important advantage of our approach is that we can exclude individual blocks when applying a rule , based on any information that is available at this time .",
    "we now present three different optimization techniques whose goal is precisely this . in each case , assume that we have performed @xmath53 derivation steps and want to apply rule @xmath23 of the form in step @xmath63 , and that @xmath67 was the last step in which @xmath23 has been applied .",
    "we consider each of the @xmath71 versions of the sne rule in separation .",
    "we start by gathering , for each idb atom @xmath91 in the body of @xmath23 , the relevant range of non - empty tables @xmath92 .",
    "we also record which rule @xmath93}$ ] was used to create this table in step @xmath94 .",
    "an immediate reason for excluding @xmath92 from the join is that the head of @xmath93}$ ] does not unify with @xmath91 .",
    "this occurs when there are distinct constant symbols in the two atoms .",
    "in such a case , it is clear that none of the idb facts in @xmath92 can contribute to matches of @xmath91 , so we can safely remove @xmath94 from the list of blocks considered for this body atom .",
    "for example , rule can always ignore inferences of rule , since the constants @xmath42 and @xmath44 do not match .",
    "we can even apply this optimization if the head of @xmath93}$ ] unifies with the body atom @xmath91 , by exploiting the information contained in partial results obtained when computing the join from left to right . simplifying notation ,",
    "we can write as follows : @xmath95}\\bowtie\\ldots\\bowtie\\delta_{q_m}^{[l_m , u_m]}\\ ] ] where @xmath82 denotes the relation obtained by joining the edb atoms .",
    "we compute this @xmath71-ary join by applying @xmath71 binary joins from left to right .",
    "thus , the decision about the blocks to include for @xmath96}$ ] only needs to be made when we have already computed the relation @xmath97}\\bowtie\\ldots\\bowtie\\delta_{q_{k-1}}^{[l_{k-1},u_{k-1}]}$ ] .",
    "this relation yields all possible instantiations for the variables that occur in the terms @xmath98 , and we can thus view @xmath99 as a set of possible partial substitutions that may lead to a match of the rule . using this notation , we obtain the following result .",
    "[ theo_rulemismatch ] if , for all @xmath100 , the atom @xmath101 does _ not _ unify with the head of @xmath93}$ ] , then the result of remains the same when replacing the relation @xmath96}$ ] by @xmath102}\\setminus \\delta_{q_k}^o)$ ] .",
    "this turns a static optimization technique into a dynamic , data - driven optimization .",
    "while the static approach required a mismatch of rules under all possible instantiations , the dynamic version considers only a subset of those , which is guaranteed to contain all actual matches .",
    "this idea can be applied to other optimizations as well . in any case",
    ", implementations must decide if the cost of checking a potentially large number of partial instantiations in @xmath99 is worth paying in the light of the potential savings .",
    "a rule is _ trivially redundant _ if its head atom occurs in its body .",
    "such rules do not need to be applied , as they can only produce duplicate inferences . while trivially redundant rules are unlikely to occur in practice , the combination of two rules frequently has this form .",
    "namely , if the head of @xmath93}$ ] unifies with @xmath91 , then we can resolve rule @xmath23 with @xmath93}$ ] , i.e. , apply backward chaining , to obtain a rule of the form : @xmath103}},q_{k+1}({\\boldsymbol{s_{k+1}}}),\\ldots , q_m({\\boldsymbol{s_m } } ) .",
    "\\end{split } \\label{eq : aruleresolved}\\end{aligned}\\ ] ] where @xmath104}}$ ] is a variant of the body of @xmath93}$ ] to which a most general unifier has been applied .",
    "if rule @xmath105 is trivially redundant , we can again ignore @xmath92 .",
    "moreover , we can again turn this into a dynamic optimization method by using partially computed joins as above .",
    "[ theo_ruleredundant ] if , for all @xmath100 , the rule @xmath106 is trivially redundant , then the result of remains the same when replacing the relation @xmath96}$ ] by @xmath102}\\setminus \\delta_{q_k}^o)$ ] .    for example , assume we want to apply rule of our initial example , and @xmath107 was derived by rule . using backward chaining , we obtain @xmath108 , which is not trivially redundant .",
    "however , evaluating the first part of the body @xmath109 for our initial example data , we obtain just a single substitution @xmath110 .",
    "now @xmath111 is trivially redundant .",
    "this optimization depends on the data , and can not be found by considering rules alone .",
    "many further optimizations can be realized using our novel storage layout . as a final example , we present an optimization that we have not implemented yet , but which we think is worth mentioning as it is theoretically sound and may show a promising direction for future works .",
    "namely , we consider the case where some of the inferences of rule @xmath23 were already produced by another rule since the last application of @xmath23 in step @xmath59 .",
    "we say that rule @xmath112 is _ subsumed _ by rule @xmath113",
    "if , for all sets of facts @xmath22 , @xmath114 .",
    "it is easy to compute this , based on the well - known method of checking subsumption of conjunctive queries @xcite .",
    "if this case is detected , @xmath112 can be ignored during materialization , leading to another form of static optimization .",
    "however , this is rare in practice .",
    "a more common case is that one specific way of applying @xmath112 is subsumed by @xmath113 .",
    "namely , when considering whether to use @xmath92 when applying rule @xmath23 , we can check if the resolved rule @xmath105 shown in is subsumed by a rule @xmath115 that has already been applied after step @xmath94 .",
    "if yes , then @xmath92 can again be ignored . for example , consider the rules  and an additional rule @xmath116 which is a typical way to declare the domain of a property .",
    "then we never need to apply rule to inferences of rule , since the combination of these rules @xmath117 is subsumed by rule",
    ".    one can pre - compute these relationships statically , resulting in statements of the form `` @xmath112 does not need to be applied to inferences produced by @xmath113 in step @xmath94 if @xmath118 has already been applied to all facts up until step @xmath94 . ''",
    "this information can then be used dynamically during materialization to eliminate further blocks .",
    "the special case @xmath119 was illustrated in the example .",
    "it is safe for a rule to subsume part of its own application in this way .",
    "the application of a rule with @xmath71 idb body atoms requires the evaluation of @xmath71 sne rules of the form .",
    "most of the joined relations @xmath96}$ ] range over ( almost ) all inferences of the respective idb atom , starting from @xmath120 .",
    "even if optimizations can eliminate many blocks in this range , the algorithm may spend considerable resources on computing these optimizations and the remaining on - demand concatenations , which may still be required .",
    "this cost occurs for each application of the rule , even if there were no new inferences for @xmath121 since the last computation .",
    "therefore , rules with fewer idb body atoms can be evaluated faster .",
    "especially rules with only one idb body atom require only a single sne rule using the limited range of blocks @xmath122}$ ] . to make this favorable situation more common",
    ", we can pre - compute the extensions of selected idb atoms , and then treat these atoms as part of the edb layer .",
    "we say that the pre - computed idb atom is _",
    "memoized_. for example , we could memoize the atom @xmath123 in . note that we might memoize an atom without pre - computing all instantiations of its predicate .",
    "a similar approach was used for owl  rl reasoning by @xcite , who proved the correctness of this transformation .",
    "sne is not efficient for selective pre - computations , since it would compute large parts of the materialization .",
    "goal - directed methods , such as qsq - r or magic sets , focus on inferences needed to answer a given query and hence are more suitable @xcite .",
    "we found qsq - r to perform best in our setting .",
    "which idb atoms should be memoized ?",
    "for specific inferencing tasks , this choice is often fixed .",
    "for example , it is very common to pre - compute the sub - property hierarchy .",
    "we can not rely on such prior domain knowledge for general datalog , and we therefore apply a heuristic : we attempt pre - computation for all most general body atoms with qsq - r , but set a timeout ( default 1 sec ) .",
    "memoization is only performed for atoms where pre - computation completes before this time .",
    "this turns out to be highly effective in some cases .",
    "l | r | r | r |r |r & * # triples * & * vlog & + * dataset * & * ( edb facts ) * & * db size * & * l * & * u * & * le * + *    ' '' ''    lubm1k & 133 m & 5.5 gb & 170 & 202 & 182 + lubm5k & 691 m & 28 gb & `` & '' & `` + dbpedia & 112 m & 4.8 gb & 9396 &  &  + claros & 19 m & 980 mb & 2689 & 3229 & 2749 + claros - s & 500k & 41 mb & '' & `` & '' +    in this section , we evaluate our approach based on a prototype implementation called _ vlog_. as our main goal is to support kg materialization under limited resources , we perform all evaluations on a laptop computer .",
    "our source code and a short tutorial is found at https://github.com/jrbn/vlog .",
    "* experimental setup *   the computer used in all experiments is a macbook pro with a 2.2ghz intel core i7 processor , 512 gb sdd , and 16 gb ram running on macos yosemite os v10.10.5 .",
    "all software ( ours and competitors ) was compiled from c++ sources using apple clang / llvm v6.1.0 .",
    "we used largely the same data that was also used to evaluate rdfox @xcite .",
    "datasets and datalog programs are available online .",
    "the datasets we used are the cultural - heritage ontology claros @xcite , the dbpedia kg extracted from wikipedia @xcite , and two differently sized graphs generated with the lubm benchmark  @xcite . in addition , we created a random sample of claros that we call claros - s .",
    "statistics on these datasets are given in table  [ tab : info ] .",
    "all of these datasets come with owl ontologies that can be used for inferencing .",
    "@xcite used a custom translation of these ontologies into datalog .",
    "there are several types of rule sets : `` l '' denotes the custom translation of the original ontology ; `` u '' is an ( upper ) approximation of owl ontologies that can not be fully captured in datalog ; `` le '' is an extension of the `` l '' version with additional rules to make inferencing harder .",
    "all of these rules operate on a datalog translation of the input graph , e.g. , a triple @xmath124 might be represented by a fact @xmath125 .",
    "we added rules to translate edb triples to idb atoms .",
    "the w3c standard also defines another set of derivation rules for owl  rl that can work directly on triples @xcite .",
    "we use `` o '' to refer to 66 of those rules , where we omitted the rules for datatypes and equality reasoning ( * ? ? ?",
    "* tables 4 and 8) .",
    "vlogcombines an on - disk edb layer with an in - memory columnar idb layer to achieve a good memory / runtime balance on limited hardware .",
    "the specifically developed on - disk database uses six permutation indexes , following standard practice in the field  @xcite .",
    "no other tool is specifically optimized for our setting , but the leading in - memory system rdfox is most similar , and we therefore use it for comparison . as our current prototype does not use parallelism , we compared it to the sequential version of the original version of rdfox @xcite .",
    "we recompiled it with the `` release '' configuration and the sequential storage variant .",
    "later rdfox versions perform equality reasoning , which would lead to some input data being interpreted differently .",
    "we were unable to deactivate this feature , and hence did not use these versions .",
    "if not stated otherwise , vlogwas always used with dynamic optimizations activated but without memoization .",
    "@l | r | r | r |",
    "r| r@ * data / rules & & + & time & mem & time & mem & idbs + *    ' '' ''    lubm1k / l & 82 & 11884 & 38 & 2198 & 172 m + lubm1k / u & 148 & 14593 & 80 & 2418 & 197 m + lubm1k / le & & & 2175 & 9818 & 322 m + lubm5k / l & & & 196 & 8280 & 815 m + lubm5k / u & & & 434 & 7997 & 994 m + lubm5k / le & & & & &  + dbpedia / l & 177 & 7917 & 91 & 532 & 33 m + claros / l & 2418 & 5696 & 644 & 2406 & 89 m + claros / le & & & & &  + claros - s / le & 8.5 & 271 & 2.5 & 127 & 3.7 m +    * runtime and memory usage *   table  [ tab : overviewperf ] reports the runtime and memory usage for materialization on our test data , and the total number of inferences computed by vlog . not all operations could be completed on our hardware : denotes an out - of - memory error , while denotes a timeout after 3h .",
    "memory denotes the peak ram usage as measured using os apis .    the number of idb facts inferred by vlogis based on a strict separation of idb and edb predicates , using rules like to import facts used in rules .",
    "this is different from the figure reported for rdfox , which corresponds to unique triples ( inferred or given ) .",
    "we have compared the output of both tools to ensure correctness .",
    "rdfox has been shown to achieve excellent speedups using multiple cpus , so our sequential runtime measurements are not rdfox s best performance but a baseline for fast in - memory computation in a single thread . memory usage can be compared more directly , since the parallel version of rdfox uses only slightly more memory @xcite . as we can see , vlogrequires only 6%46% of the working memory used by rdfox .",
    "as we keep edb data on disk , the comparison with a pure in - memory system like rdfox should take the on - disk file sizes into account ( table  [ tab : info ] ) ; even when we add these , vloguses less memory in all cases where rdfox terminates . in spite of these memory savings ,",
    "vlogshows comparable runtimes , even when considering an ( at most linear ) speedup when parallelizing rdfox .",
    "l | r | r | r | r * data / rules & * mr+rr & * mr & * rr & * no opt . + * * * * *    ' '' ''",
    "lubm1k / l & 38 & 39 & 38 & 40 + lubm5k / l & 196 & 197 & 202 & 206 + dbpedia / l & 91 & 92 & 93 & 88 + claros / l & 644 & 3130 & 684 & 3169 +    * dynamic optimization *   our prototype supports the optimizations `` mismatching rules '' ( mr ) and `` redundant rules '' ( rr ) discussed earlier .",
    "table  [ tab : bpstrat ] shows the runtimes obtained by enabling both , one , or none of them .",
    "both mr and rr have little effect on lubm and dbpedia .",
    "we attribute this to the rather `` shallow '' rules used in both cases . in constrast ,",
    "both optimizations are very effective on claros , reducing runtime by a factor of almost five .",
    "this is because sne leads to some expensive joins that produce only duplicates and that the optimizations can avoid .",
    "r | r | r | r | r | r * data / rules & * no mem . & + & * @xmath126 & # atoms & * @xmath127 & * @xmath128 & * @xmath126 + * * * * * *    ' '' ''    lubm1k / l & 38 & 39 & 1.4 & 40.4 & 41.5 + lubm1k / o & 1514 & 41 & 6.5 & 230 & 236.5 +    * memoization *   to evaluate the impact of memoization , we materialized lubm1k with and without this feature , using the l and o rules .",
    "table  [ tab : memo ] shows total runtimes with and without memoization , the number of idb atoms memoized , and the time used to compute their memoization .    for the l rules",
    ", memoization has no effect on materialization runtime despite the fact that 39 idb atoms were memoized .",
    "for the o rules , in contrast , memoization decreases materialization runtime by a factor of six , at an initial cost of 6.5 seconds .",
    "we conclude that this procedure is indeed beneficial , but only if we use the standard owl  rl rules .",
    "indeed , rules such as , which we used to motivate memoization , do not occur in the l rules . in a sense ,",
    "the construction of l rules internalizes certain edb facts and thus pre - computes their effect before materialization .",
    "we have introduced a new column - oriented approach to perform datalog in - memory materialization over large kgs .",
    "our goal was to perform this task in an efficient manner , minimizing memory consumption and cpu power .",
    "our evaluation indicates that it is a viable alternative to existing datalog engines , leading to competitive runtimes at a significantly reduced memory consumption .",
    "our evaluation has also highlighted some challenges to address in future work .",
    "first , we observed that the execution of large joins can become problematic when many tables must be scanned for removing duplicates .",
    "this was the primary reason why the computation did not finish in time on some large datasets .",
    "second , our implementation does not currently exploit multiple processors , and it will be interesting to see to how techniques of intra / inter query parallelism can be applied in this setting .",
    "third , we plan to study mechanisms for efficiently merging inferences back into the input kg , which is not part of datalog but useful in practice .",
    "finally , we would also like to continue extending our dynamic optimizations to more complex cases , and to develop further optimizations that take advantage of our design .",
    "many further continuations of this research come to mind . to the best of our knowledge ,",
    "this is the first work to exploit a column - based approach for datalog inferencing , and it does indeed seem as if the research on large - scale in - memory datalog computation has only just begun .",
    "* acknowledgments *   this work was partially funded by commit , the nwo veni project 639.021.335 , and the dfg in emmy noether grant kr  4381/1 - 1 and in crc  912 _ haec _ within the _ cfaed _ cluster of excellence .",
    "abadi , d.  j. ; marcus , a. ; madden , s. ; and hollenbach , k. 2009 .",
    "a vertically partitioned dbms for semantic web data management .",
    "18(2):385406 .",
    "abadi , d. ; madden , s. ; and ferreira , m. 2006 . integrating compression and execution in column - oriented database systems . in _ proceedings of sigmod _",
    ", 671682 .",
    "abiteboul , s. ; hull , r. ; and vianu , v. 1995 . .",
    "addison wesley .",
    "bischoff , s. ; krtzsch , m. ; polleres , a. ; and rudolph , s. 2014 .",
    "schema - agnostic query rewriting for sparql  1.1 . in _ proc .",
    ".  semantic web conf .",
    "( iswc14 ) _ , volume 8796 of _ lncs _ , 584600 . springer .",
    "bishop , b. ; kiryakov , a. ; ognyanoff , d. ; peikov , i. ; tashev , z. ; and velkov , r. 2011 . a family of scalable semantic repositories .",
    "2(1):3342 .",
    "bizer , c. ; lehmann , j. ; kobilarov , g. ; auer , s. ; becker , c. ; cyganiak , r. ; and hellmann , s. 2009 .",
    " a crystallization point for the web of data",
    ". 7(3):154165 .",
    "bonet , b. , and koenig , s. , eds .",
    "aaai press .",
    "callahan , a. ; cruz - toledo , j. ; and dumontier , m. 2013 .",
    "ontology - based querying with bio2rdf s linked open data .",
    "4(s-1 ) .",
    "cyganiak , r. ; wood , d. ; and lanthaler , m. , eds .",
    "w3c recommendation .",
    "available at .",
    "guo , y. ; pan , z. ; and heflin , j. 2005 . : a benchmark for owl knowledge base systems .",
    "3:158182 .",
    "hoffart , j. ; suchanek , f.  m. ; berberich , k. ; and weikum , g. 2013 .",
    "spatially and temporally enhanced knowledge base from wikipedia .",
    "194:2861 .",
    "idreos , s. ; groffen , f. ; nes , n. ; manegold , s. ; mullender , k.  s. ; and kersten , m.  l. 2012 .",
    "two decades of research in column - oriented database architectures . 35(1):4045 .",
    "kolovski , v. ; wu , z. ; and eadon , g. 2010 . optimizing enterprise - scale owl  2 rl reasoning in a relational database system . in _ proc .",
    ".  semantic web conf .",
    "( iswc10 ) _ , volume 6496 of _ lncs _ , 436452 . springer .",
    "krtzsch , m. 2011 .",
    "efficient rule - based inferencing for owl el . in walsh ,",
    ", _ proc .",
    "22nd int .",
    "joint conf .  on artificial intelligence ( ijcai11 ) _ ,",
    "aaai press / ijcai .",
    "krtzsch , m. 2012 .",
    "the not - so - easy task of computing class subsumptions in owl rl . in _ proc .",
    ".  semantic web conf .",
    "( iswc12 ) _ , volume 7649 of _ lncs _ , 279294 . springer .",
    "motik , b. ; cuenca grau , b. ; horrocks , i. ; wu , z. ; fokoue , a. ; and lutz , c. , eds .",
    "w3c recommendation .",
    "available at http://www.w3.org / tr / owl2-profiles/.    motik , b. ; nenov , y. ; piro , r. ; horrocks , i. ; and olteanu , d. 2014 .",
    "parallel materialisation of datalog programs in centralised , main - memory rdf systems . in _ proc .",
    "aaai14 _ , 129137 .",
    "aaai press .",
    "motik , b. ; nenov , y. ; piro , r. ; and horrocks , i. 2015a . combining rewriting and incremental materialisation maintenance for datalog programs with equality . in _ proc .",
    "24th int .",
    "joint conf .  on artificial intelligence ( ijcai15 ) _ ,",
    "aaai press .",
    "motik , b. ; nenov , y. ; piro , r. ; and horrocks , i. 2015b .",
    "handling owl : sameas via rewriting . in bonet and koenig , 231237 .",
    "motik , b. ; nenov , y. ; piro , r. ; and horrocks , i. 2015c",
    ". incremental update of datalog materialisation : the backward / forward algorithm . in bonet and koenig , 15601568 .",
    "neumann , t. , and weikum , g. 2010 . the rdf-3x engine for scalable management of rdf data . 19(1):91113 .",
    "oren , e. ; kotoulas , s. ; anadiotis , g. ; siebes , r. ; ten teije , a. ; and van harmelen , f. 2009 .",
    "marvin : distributed reasoning over large - scale semantic web data .",
    "7(4):305316 .",
    "russell , s. , and norvig , p. 2003 . .",
    "prentice hall , second edition .",
    "urbani , j. ; kotoulas , s. ; maassen , j. ; van  harmelen , f. ; and bal , h. 2012 . : a web - scale parallel inference engine using mapreduce .",
    "10:5975 .",
    "urbani , j. ; margara , a. ; jacobs , c. ; van harmelen , f. ; and bal , h. 2013 .",
    "dynamite : parallel materialization of dynamic rdf data . in _ the semantic web ",
    "iswc 2013_. springer .",
    "657672 .",
    "urbani , j. ; piro , r. ; van harmelen , f. ; and bal , h. 2014 .",
    "hybrid reasoning on owl rl .",
    "5(6):423447 .",
    "urbani , j. ; jacobs , c. ; and krtzsch , m. 2016 .",
    "column - oriented datalog materialization for large knowledge graphs . in _ proc .  aaai16_. aaai press .",
    "vrandei , d. , and krtzsch , m. 2014 .",
    "wikidata : a free collaborative knowledge base .",
    "57(10 ) .",
    "weaver , j. , and hendler , j.  a. 2009 .",
    "parallel materialization of the finite rdfs closure for hundreds of millions of triples . in _ proc .",
    ".  semantic web conf .",
    "( iswc09 ) _ , volume 5823 of _ lncs _ , 682697 . springer .",
    "we first observe that the naive approach terminates and leads to a unique least model @xmath50 .",
    "recall that the latter was defined by applying all rules in parallel in each step . now consider an arbitrary , fair sequence of individual applications of rules @xmath129},{\\text{\\sf{rule}}[2]},\\ldots$ ] , each applied naively as in .",
    "let @xmath130 denote the set of all facts derived in this way up until step @xmath131 .",
    "clearly , the rule - by - rule inference is sound , i.e. , @xmath132 for all derivation steps @xmath131 .",
    "it remains to show that it is also complete in the sense that @xmath133 for some @xmath131 .",
    "since we apply rules fairly , there is a sequence of derivation step indices @xmath134 such that every rule has been applied in each interval of the form @xmath135 .",
    "formally , for every @xmath136 in the sequence , and for every rule @xmath23 , there is @xmath137 such that @xmath138}$ ] .",
    "it follows that @xmath139 ( in words : the sequential application of rules derives at least the inferences that a parallel application of rules would derive ) . therefore , by a simple induction , @xmath140 for every @xmath141 . since @xmath142 for some finite @xmath71 @xcite",
    ", we have @xmath143 . together with soundness",
    ", this implies that @xmath144 , as required .    now to show that the semi - naive application strategy based on rules of the form is also sound , we merely need to show that it produces the same inferences as the naive rule - by - rule application would produce ( based on the same , fair sequence of rules ) .",
    "let @xmath54 refer to the facts derived for @xmath55 in step @xmath53 using the semi - naive procedure , and let @xmath145 denote the set of facts produced for @xmath55 in step @xmath53 by the naive procedure .",
    "we show by induction that @xmath146}_p=\\hat{\\delta}^{[0,i]}_p$ ] holds for ever predicate @xmath55 and every step @xmath53 .",
    "the induction base is trivial , since @xmath147 . for the induction step ,",
    "assume that the claim holds for all @xmath148 .",
    "let @xmath23 of form be the rule applied in step @xmath63 , and assume that @xmath23 was last applied in step @xmath59 ( set to @xmath149 if it was never applied ) .",
    "@xmath64 is computed by evaluating for every @xmath150 , while @xmath151 is obtained by evaluating .    for every inference @xmath152 obtained from ,",
    "there is a ground substitution @xmath30 such that the rule @xmath153}_{q_1}({\\boldsymbol{s_1}})\\sigma,\\ldots,\\delta^{[0,i]}_{q_m}({\\boldsymbol{s_m}})\\sigma\\end{aligned}\\ ] ] is applicable and @xmath154 .",
    "being applicable here means that @xmath155}_{q_a}$ ] for every @xmath156 ( and likewise for expressions @xmath157 ) .",
    "now whenever @xmath155}_{q_a}$ ] , there is an index @xmath158 such that @xmath159 .    given an inference @xmath152 and ground substitution @xmath30 as above , @xmath152 is also inferred by a rule of the form .",
    "indeed , let @xmath131 be the largest index from the range @xmath160 such that @xmath161 .",
    "then the following ground instantiation of is applicable : @xmath162}_{q_1}({\\boldsymbol{s_1}})\\sigma,\\ldots,\\delta^{[0,i]}_{q_{\\ell-1}}({\\boldsymbol{s_{\\ell-1}}})\\sigma,\\\\   & \\delta^{[j , i]}_{q_\\ell}({\\boldsymbol{s_{\\ell}}})\\sigma,\\delta^{[0,j-1]}_{q_{\\ell+1}}({\\boldsymbol{s_{\\ell+1}}})\\sigma,\\ldots , \\delta^{[0,j-1]}_{q_m}({\\boldsymbol{s_m}})\\sigma .",
    "\\end{split}\\end{aligned}\\ ] ] this follows from the induction hypothesis and the definition of @xmath131 .",
    "note that the case where @xmath163 for all @xmath156 can be disregarded , since it follows by the induction hypothesis that such inferences have already been produced when applying rule @xmath23 in step @xmath59 .",
    "this completes the induction and the proof.@xmath164      this claim is immediate from the definitions . in detail , consider @xmath99 and @xmath93}$ ] as in the claim of the theorem",
    ". moreover , let @xmath165 be the set of all complete rule body matches that could be computed without taking any optimization into account .",
    "clearly , @xmath166 , i.e. , @xmath165 contains only tuples compatible with @xmath99 . by the assumption in the theorem , for all @xmath100 ,",
    "the atom @xmath101 does _ not _ unify with the head of @xmath93}$ ] .",
    "therefore , @xmath92 does not contain any fact that is compatible with @xmath99 , i.e. , @xmath167 ( where the join here is meant to join the positions in accordance with the terms used in @xmath91 ) .",
    "this implies that @xmath168 , and thus @xmath92 does not need to be considered for finding matches of @xmath91 when computing @xmath165 . @xmath164",
    "the claim is again rather immediate , but we spell it out in detail for completeness .",
    "assume we apply a rule @xmath23 of the form in step @xmath63 , after it was last applied in step @xmath59 .",
    "we use similar notation for ( partial ) joins as in the proof of theorem  [ theo_rulemismatch ] in the previous section .",
    "in addition , let @xmath93}$ ] be of the following form : @xmath169}= q_k({\\boldsymbol{t'}})\\leftarrow e'_1({\\boldsymbol{t'_1}}),\\ldots , e'_{n'}({\\boldsymbol{t'_{n ' } } } ) , q'_1({\\boldsymbol{s'_1}}),\\ldots , q'_{m'}({\\boldsymbol{s'_{m'}}}).\\end{aligned}\\ ] ] as shown in theorem  [ theo_seminaive ] , @xmath170}_{q_k}$ ] is the same set of facts that would be produced by evaluating a naive version of @xmath93}$ ] in step @xmath94 , i.e. , by using a computation of the form @xmath171}_{q'_1}({\\boldsymbol{s'_1}}),\\ldots,\\delta^{[0,o]}_{q'_{m'}}({\\boldsymbol{s'_{m'}}}).\\end{aligned}\\ ] ] note that @xmath172 .",
    "let @xmath173 denote the result of the following join @xmath174}_{q'_1}({\\boldsymbol{s'_1}})\\bowtie\\ldots\\bowtie\\delta^{[0,o]}_{q'_{m'}}({\\boldsymbol{s'_{m'}}}).\\ ] ] we can again consider the element of @xmath173 as substitutions over the variables of @xmath93}$ ] , where we assume without loss of generality that @xmath93}$ ] shares no variables with @xmath23 .",
    "now consider the situation as in the claim where we apply a particular semi - naive rule of the form and have partially evaluated the rule body until @xmath99 .",
    "consider any @xmath175 ( where the join identifies positions / variables as necessary to unify the atoms @xmath176 and @xmath177 ) . by the definition of redundancy , @xmath93}$ ]",
    "contains an atom @xmath178 such that @xmath179 ( in particular @xmath180 ) . as @xmath173 assigns values to all variables in @xmath93}$ ] , we find that @xmath181 is a list of ground terms . by definition of @xmath173 , @xmath182}_{q'_a}=\\delta^{[0,o]}_{p}$ ] . since @xmath183}_p$ ] and @xmath170}_{p}\\subseteq\\delta^{[0,i]}_p$ ] , we get @xmath184 . therefore , applying rule @xmath23 with any substitution that extends @xmath30 in step @xmath63 is redundant . since the argument holds for all assignments in @xmath185 , and",
    "since the projection to of @xmath185 to variables in @xmath23 is a superset of @xmath186 , we find that all tuples from @xmath92 can be ignored when applying @xmath23.@xmath164"
  ],
  "abstract_text": [
    "<S> the evaluation of datalog rules over large knowledge graphs ( kgs ) is essential for many applications . in this paper </S>",
    "<S> , we present a new method of materializing datalog inferences , which combines a column - based memory layout with novel optimization methods that avoid redundant inferences at runtime . </S>",
    "<S> the pro - active caching of certain subqueries further increases efficiency . </S>",
    "<S> our empirical evaluation shows that this approach can often match or even surpass the performance of state - of - the - art systems , especially under restricted resources . </S>"
  ]
}