{
  "article_text": [
    "two graphs @xmath2 and @xmath3 are _ isomorphic _ if there is a bijection @xmath4 from the vertex set of @xmath2 to the vertex set of @xmath3 that satisfies the following condition : for all @xmath5 , @xmath6 is adjacent to @xmath7 in @xmath2 if and only if @xmath8 is adjacent to @xmath9 in @xmath3 .",
    "the _ graph isomorphism problem _ consists of determining whether two input graphs are isomorphic .",
    "the graph isomorphism problem is in @xmath10 , but it is neither known to be np - complete nor known to be in @xmath11 .",
    "however , the restriction of the problem to members of graph classes with certain special topological properties is known to result in polynomial or even linear - time algorithms .",
    "the subject of this paper is the development of such algorithms for a variety of such classes .",
    "we show linear - time isomorphism algorithms for helly circular - arc graphs , @xmath1 circular - arc graphs , proper circular - arc graphs and convex - round graphs .",
    "the common building block for all of these algorithms , is a linear - time isomorphism algorithm for binary matrices that obey the circular - ones property , which we show .    in order to explain our results , we first establish some basic terminology .",
    "a matrix is a _ binary matrix _ if all of its entries are 0 or 1 .",
    "the _ adjacency matrix _ of a simple graph @xmath2 is a binary square matrix @xmath12 that has @xmath13 in row @xmath14 , column @xmath15 , if vertex @xmath14 is adjacent to vertex @xmath15 , and 0 otherwise .",
    "the _ augmented adjacency matrix _ of @xmath2 is the adjacent matrix of the graph with @xmath13 s on the main diagonal .",
    "a _ clique matrix _ of a graph is a binary matrix that has one row for each vertex and one column for each maximal clique , and a 1 in row @xmath14 , column @xmath15 if vertex @xmath14 is a member of maximal clique @xmath15 .    a _ consecutive - ones _ matrix is a binary matrix whose columns can be ordered such that , in every row , the 1 s are consecutive",
    ". such an ordering of the columns is a _ consecutive - ones ordering_. a _ circular - ones _ matrix is a binary matrix whose columns can be ordered such that , in every row , either the 0 s are consecutive or 1 s are consecutive ; equivalently , the 1 s are consecutive modulo the number of columns , and the block of 1 s is allowed to `` wrap around '' from the rightmost to the leftmost column .",
    "such an ordering of the columns is a _ circular - ones ordering_. it is easily seen that the class of consecutive - ones matrices is a proper subclass of the class of circular - ones matrices  @xcite .",
    "if a circular - ones ordering of a matrix with @xmath16 rows is known , then it can be represented in @xmath17 space by recording the number of columns and listing , for each row , the columns of the first and last 1 in the row .",
    "the column of the first 1 is the column where a 1 follows a zero and the column of the last 1 is the one where a 1 is followed by a 0 .",
    "( the column of the last 1 precedes that of the first if the row wraps around the end of the matrix . ) a row that has only 0 s or only 1 s can be represented with a suitable code , such as a single 0 or a single 1 .",
    "let us call this a _",
    "succinct representation _ of a circular - ones matrix",
    ". there may be many succinct representations , since there may be many circular - ones orderings of the matrix .",
    "the _ intersection graph _ of a family of sets has one vertex for each set in the family and an edge between two vertices if the corresponding sets intersect .",
    "a _ circular - arc graph _ is the intersection graph of arcs on a circle .",
    "if we restrict circular - arc graphs to intersection graph of arcs on a circle such that no arc contains another , we get _ proper circular - arc graphs _  @xcite .",
    "another subclass of circular - arc graphs is the _ helly circular - arc graphs _ , sometimes called _",
    "@xmath18 circular - arc graphs_. a circular - arc model has the _ helly property _ if every family of pairwise intersecting arcs has a common intersection point .",
    "such a model is called a _ helly circular - arc model_. a circular - arc graph is a helly circular - arc graph if there exists a helly circular - arc model of it . in  @xcite , it is shown that a graph is a helly circular - arc graph if and only if the clique matrix satisfies the circular - ones property .",
    "the graphs whose augmented adjacency matrices satisfy the circular - ones property are _",
    "@xmath1 circular - arc graphs _ , also called _ concave - round graphs_. this graph class is also a subclass of circular - arc graphs  @xcite .",
    "the _ complement _ @xmath19 of an undirected graph @xmath2 has the same vertex set , and an edge between two vertices if and only if there is no edge between them in @xmath2 .",
    "the complement of a @xmath1 circular - arc graph has the circular - ones property for its adjacency matrix .",
    "this class of graphs is called _ convex - round graphs _",
    "@xcite .",
    "wu  @xcite presented the first polynomial algorithm for circular - arc graph isomorphism , but later eschen  @xcite claimed to find a flaw in it .",
    "hsu  @xcite presented an @xmath20 isomorphism algorithm for circular - arc graphs where @xmath16 denotes the number of vertices and @xmath21 denotes the number of edges in a graph . in section  [",
    "sect : hsu ] we give a counterexample to the correctness of this algorithm .",
    "we also describe there a suggestion given by hsu for a possible fix for the algorithm .",
    "therefore , there are currently no known efficient isomorphism algorithms for circular - arc graphs .",
    "some subclasses of circular - arc graphs do have efficient isomorphism algorithms .",
    "interval graphs  @xcite , co - bipartite circular arc graphs  @xcite , and proper circular - arc graphs  @xcite all have linear - time isomorphism algorithms , while @xmath1 circular - arc graphs have an @xmath22 isomorphism algorithm @xcite .",
    "two binary matrices @xmath23 and @xmath24 are _ isomorphic _ if there exists a permutation @xmath25 of the rows of @xmath23 and a permutation @xmath4 of its columns that makes @xmath23 identical to @xmath24 .",
    "if @xmath4 is known , @xmath25 is trivial to find by matching up identical rows of @xmath23 and @xmath24 . therefore ,",
    "abusing notation somewhat , we will sometimes call @xmath4 an _ isomorphism _ from @xmath23 to @xmath24 , omitting mention of @xmath25 , and treat a matrix as a multiset of row vectors .",
    "the results of the paper are organized as follows . in section  [",
    "sect : preliminaries ] , we give basic definitions and review the _ pc tree _ of a circular - ones matrix  @xcite .",
    "this gives a representation of all circular - ones orderings of a circular - ones matrix .",
    "in section  [ sect : pcquotients ] , we present a notion of _ quotient labels _ on the pc tree , which were developed in  @xcite .",
    "the matrix can be reconstructed from the tree and its labels , establishing the quotient - labeled pc tree as a unique decomposition of a circular - ones matrix .",
    "in section  [ sect : matrixisomorphism ] , we give an algorithm that uses the quotient - labeled pc tree to test isomorphism of circular - ones matrices that was also developed in  @xcite .",
    "we define a notion of isomorphism of quotient - labeled pc trees , show that two circular - ones matrices are isomorphic if and only if their quotient - labeled pc trees are isomorphic , and reduce the problem to testing whether the two matrices pc trees are isomorphic .",
    "the running time is linear in the number of rows , columns and 1 s of the matrix if the circular - ones orderings are not provided , or linear in the number of rows if a succinct representation of circular - ones matrices is provided .    in section  [",
    "sect : helly ] , we reduce the problem of testing whether two helly circular - arc graphs are isomorphic to testing whether two circular - ones matrices are isomorphic .",
    "this gives a bound that is proportional to the number of vertices and edges , or just proportional to the number of vertices , depending on whether the graphs are represented with adjacency lists or with suitable sets of circular arcs .",
    "a preliminary version of part of the results of this section appeared in  @xcite .    in section  [",
    "sect : gamma ] , we use the fact that testing isomorphism of @xmath1 circular - arc graphs and of convex - round graphs reduces to testing isomorphism of circular - ones matrices , giving an @xmath26 or an @xmath17 bound , depending on whether a succinct representation is given .",
    "this leads to a new algorithm for testing the isomorphism of proper circular arc graphs , which can run in @xmath17 time if two circular arc models are given .",
    "in section  [ sect : hsu ] we discuss the circular - arc isomorphism algorithm of @xcite .",
    "we show a counterexample for this algorithm , and give a direction suggested by hsu for a possible fix .",
    "we consider simple undirected graphs @xmath2 and @xmath3 . we denote the number of vertices of @xmath2 by @xmath16 and the number of edges by @xmath21 .",
    "we assume that @xmath3 has the same number of vertices and edges as @xmath2 , since otherwise it is trivial to see that the graphs are not isomorphic .    in this paper",
    ", we also let @xmath16 denote the number of rows of a binary matrix .",
    "( many of the matrices we deal with are derived from graphs , and have one row for each vertex of the graph . )",
    "the _ size _ of a binary matrix @xmath12 , denoted @xmath27 , is the number of rows plus the number of columns plus the number of 1 s ; this is proportional to the number of words required to store the matrix using a standard sparse - matrix representation .",
    "we will say that an algorithm whose inputs are binary matrices runs in _ linear time _ only if it runs in time that is linear in this measure of the size of the matrices .    by @xmath28",
    ", we denote the set of neighbors of a vertex @xmath7 . by @xmath29",
    "$ ] , we denote the _ closed neighborhood _ @xmath30 of @xmath7 .",
    "if @xmath31 is a set of vertices then @xmath32 $ ] is the union of @xmath29 $ ] for all @xmath33 .",
    "an ( unrooted ) tree @xmath34 is an undirected graph that is connected and has no cycles .",
    "_ rooting _ a tree @xmath34 at node @xmath35 consists of orienting all edges so that they are directed from vertices that are farther from @xmath35 to vertices that are closer to @xmath35 , yielding a directed graph .",
    "this gives each vertex @xmath36 a unique outgoing edge @xmath37 .",
    "the neighbors of @xmath6 can be classified as the ( unique ) _ parent _ of @xmath6 ( the unique neighbor that is closer to @xmath35 ) and the _ children _ of @xmath6 .",
    "once a tree has been rooted , we will continue to refer to the parent and children of @xmath6 as its neighbors .",
    "a _ circular - arc model _ of @xmath2 is a mapping from the vertices of @xmath2 to arcs on a circle such that two vertices are adjacent if and only if the corresponding arcs intersect .",
    "we represent a circular - arc model @xmath38 by a cyclic doubly - linked list of the endpoints arcs .",
    "each vertex of @xmath2 has two endpoints in the model , one of them is a clockwise endpoint and the other is a counterclockwise endpoint .    a _ proper circular - arc model _ is a circular - arc model in which no arc contains another .",
    "an _ interval model _ is a circular - arc model whose circle has some point that is not contained in any arc .",
    "let @xmath39 be a list , where each @xmath40 is a tuple of integers . by _ sorting a list of tuples _",
    ", we mean that we rearrange the order of the @xmath40 s so that they are in increasing lexicographic order .",
    "let @xmath41 and @xmath42 be two lists of tuples .",
    "let @xmath14 be the first position in which they differ .",
    "then we say that @xmath41 _ precedes @xmath42 lexicographically _ if the tuple at position @xmath14 of @xmath41 lexicographically precedes the tuple at position @xmath14 of @xmath42 , or else @xmath41 has length @xmath43 .",
    "let a _ bipartitive tree @xmath34 _ on universe @xmath44 be an undirected tree such that its leaves are the elements of @xmath44 , all internal nodes have degree at least three , and each internal node is labeled either _ prime _ or _",
    "degenerate_. let a _",
    "neighbor set _ of a node @xmath6 denote the set of leaves in a tree of the forest that results when @xmath6 is removed from @xmath34 . since all internal nodes of @xmath34 have degree at least three , all members of a neighbor set are leaves of @xmath34 , so each neighbor set is a subset of @xmath44 .",
    "the _ set family @xmath45 represented by @xmath34 _ consists of the following sets :    * a neighbor set of a prime node or the union of all but one of the neighbor sets of a prime node ; * any union of at least one and fewer than all neighbor sets of a degenerate node .",
    "not all set families can be represented by a bipartitive tree .",
    "next , we characterize those that can .",
    "the _ symmetric difference _ @xmath46 of two sets @xmath47 and @xmath48 is the set @xmath49 .",
    "let us say that two subsets @xmath47 and @xmath48 of universe @xmath44 _ strongly overlap _",
    "if @xmath50 , @xmath51 , @xmath52 and @xmath53 are all nonempty .    a _ bipartitive set family on universe @xmath44 _ is a set family @xmath54 with the following properties :    * @xmath55 * @xmath56 for all @xmath57 * @xmath58 for all @xmath59 * whenever @xmath60 strongly overlap , @xmath50 , @xmath61 and @xmath46 are all members of @xmath54 .",
    "[ thm : bipartitivetree ] if @xmath34 is a bipartitive tree on universe @xmath44 , then @xmath45 is a bipartitive set family on universe @xmath44 .",
    "conversely , if @xmath54 is a bipartitive set family , then there exists a unique bipartitive tree @xmath34 such that @xmath62 .",
    "let @xmath12 be a circular - ones matrix .",
    "a row of @xmath12 can be thought of as the bit - vector representation of a set , that is , it is the set @xmath47 of columns of @xmath12 where the row has a 1 .",
    "let @xmath44 denote the columns of @xmath12 and let @xmath63 denote the family of sets represented by the rows .",
    "note that @xmath63 is a set family on universe",
    "let @xmath64 denote the family of subsets of @xmath44 , excluding @xmath65 and @xmath44 itself , that do not strongly overlap any member of @xmath63 .",
    "@xmath64 is a bipartitive set family on universe @xmath44 .",
    "it follows that @xmath64 is represented by a bipartitive tree . for historical reasons ,",
    "the prime nodes are known as _",
    "c nodes _ , the degenerate nodes are known as _ p nodes _ and the bipartitive tree is called a _ pc tree _  @xcite .",
    "figure  [ fig : pcexample ] gives an example .",
    "when drawing a pc tree , we use the convention of representing a c node with a double circle and a p node with a dot . in this figure ,",
    "the neighbor sets of @xmath66 are @xmath67 , @xmath68 , @xmath69 , @xmath70 , and @xmath71 .",
    "each of these sets and the union of all but any one of these sets is a member of @xmath64 .",
    "for example , the neighbor set @xmath71 is a subset of rows @xmath72 , it contains rows @xmath73 , it does not strongly overlap row @xmath74 because the union of row 9 and @xmath71 is the entire column set , and it is disjoint from all other rows . since it does not strongly overlap any row , it is a member of @xmath64 .",
    "similarly , the union of all neighbor sets other than @xmath71 ( the complement of @xmath71 ) , is a member of @xmath64 .",
    "however , because @xmath66 is a c node ( prime ) the union of neighbor set @xmath70 and @xmath71 , which is neither the union of one neighbor set nor the union of all but one , is not a member of @xmath64 .",
    "this is verified by observing that it strongly overlaps row 12 .",
    "the neighbor sets of @xmath75 in the figure are @xmath76 , @xmath77 , @xmath78 , @xmath79 . because it is a p node ( degenerate ) ,",
    "every union of at least one and fewer than all of these sets is a member of @xmath64 , and this is easily verified using similar checks .",
    "only unions of neighbor sets of a single internal node can be members of @xmath64 .",
    "for example , @xmath80 is not a union of neighbor sets of a single node , and it is not a member of @xmath64 because it strongly overlaps rows @xmath81 , @xmath82 , @xmath83 , @xmath84 , @xmath85 , and @xmath86 .",
    "note that @xmath63 has the circular - ones property , and the figure depicts a way to cyclically order the edges incident to each node such that in the resulting tree , every member of @xmath63 is consecutive in the circular ordering of leaves .",
    "this is an example of a general phenomenon :    let @xmath34 be the bipartitive tree for @xmath64 , where @xmath63 is the set family represented by rows of a circular - ones matrix with column set @xmath87 . then :    * the edges incident to internal nodes can be cyclically ordered in such a way that the resulting cyclic order of leaves is a circular - ones ordering of the matrix ; * reversing the cyclic order of edges about a prime node imposes a new circular - ones ordering on the leaves . * arbitrarily permuting the cyclic order of edges about a degenerate node imposes a new circular - ones ordering on the leaves . *",
    "all circular - ones orderings of the leaves are obtainable by a sequence of these two operations .",
    "this gives a convenient data structure , the _ pc tree _",
    ", for representing all circular - ones orderings of a circular - ones matrix .",
    "for example , in figure  [ fig : pcexample ] , permuting the counterclockwise cyclic order of neighbors about @xmath75 so that it is @xmath88 and reversing the cyclic order of neighbors about @xmath89 so that it is @xmath90 imposes a new cyclic leaf order on the tree , @xmath91 , which is easily seen to be a circular - ones ordering .     and @xmath66 are c nodes ( double circles ) and node @xmath75 is a p node . ]    to gain an insight into why this works , consider a circular - ones ordering of columns of a circular - ones matrix , let @xmath47 be a circularly consecutive set of columns , and let @xmath92 be the set represented by some row . if @xmath47 is removed and reinserted in reverse order , it will disrupt the consecutiveness of @xmath92 if and only if it strongly overlaps @xmath92 . since @xmath64 is the family of sets that do nt strongly overlap any column , they are the sets that can be reversed in the cyclic order without disrupting the circular consecutiveness of any row .",
    "each allowed rearrangement of the pc tree corresponds to a sequence of such reversals , and each such reversal is allowed by the pc tree .",
    "the pc tree was first described by shih and hsu  @xcite .",
    "its relationship to bipartitive set families and the circular - ones orderings of matrices was first described in  @xcite .",
    "it takes time linear in the size of a circular - ones matrix to build the pc tree even when a circular - ones ordering is not given as part of the input  @xcite . as part of the output , a circular ordering of the edges incident to each internal node",
    "is given , which imposes a circular - ones ordering on the leaves .",
    "this gives a representation of all circular - ones orderings of the matrix in linear time .",
    "henceforth , we will assume for simplicity that every row of a circular - ones matrix has at least one 1 and one 0 ; any row without this property is irrelevant to the circular - ones arrangements .",
    "in this section , we give a way to label the nodes of the pc tree of a circular - ones matrix with _",
    "quotients _ so that the matrix can be reconstructed from the labeling .",
    "these results were developed in  @xcite , and the scheme is similar to ones developed for pq trees in  @xcite .",
    "recall that we assume that every row of the circular - ones matrix @xmath12 has at least one 1 and at least one 0 , since a row that is all zeros or all ones has no effect on the circular - ones orderings of the matrix .",
    "suppose that @xmath12 has a circular - ones ordering of columns .",
    "consider the ordered tree that results from the pc tree of @xmath12 by the cyclic ordering about each node that is forced by the cyclic leaf order corresponding to the circular - ones ordering . for each row",
    "@xmath92 that has at least two 1 s we perform the following procedure .",
    "root the pc tree at a leaf corresponding to a column with a 0 in @xmath92 .",
    "we maintain the order about each node @xmath6 in the following way .",
    "if @xmath93 is the counterclockwise order about @xmath6 and @xmath94 becomes the parent of @xmath6 , then @xmath95 becomes the linear order of children in the resulting ordered _ rooted _ tree .",
    "let @xmath6 be the least common ancestor of the 1 s in @xmath92 .",
    "let @xmath47 be the leaf descendants of a child of @xmath6 .",
    "since @xmath96 , @xmath47 does not strongly overlap @xmath92 .",
    "therefore , @xmath47 is either a subset of @xmath92 or disjoint from @xmath92 .",
    "it follows that @xmath92 consists of the leaf descendants of two or more children of @xmath6 .",
    "moreover , since the cyclic order of edges about @xmath6 gives the circular - ones orderings of @xmath12 , @xmath92 consists of the neighbor sets of @xmath6 through a consecutive set @xmath97 of children of @xmath6 .",
    "let @xmath97 be the _ projection _ of @xmath92 on @xmath6 .",
    "figure  [ fig : projection ] illustrates the concept .     of a row @xmath92 of a circular - ones matrix .",
    "each element of the row corresponds to a leaf of the pc tree .",
    "rooting the tree at any leaf where the row has a 0 and then finding the least common ancestor of the 1 s gives the node @xmath6 that the row projects to .",
    "the projection makes up a row vector in the quotient matrix at @xmath6 that has one column for each neighbor of @xmath6 , ordered in cyclic order .",
    "because every neighbor set is a member of @xmath64 , the columns where a row has 1 s will always be a union of neighbor sets of @xmath6 . in this case",
    ", @xmath92 has 1 s in @xmath98 , and the neighbor sets of @xmath6 ( dashed arcs ) are @xmath99 , @xmath100 , @xmath101 , @xmath102 , @xmath103 , and @xmath104 .",
    "the ones that are subsets of @xmath92 are reachable through neighbors @xmath105 .",
    "the projection @xmath97 of @xmath92 is a row of @xmath6 s quotient matrix that has 1 s in columns @xmath105 , and 0 s in columns @xmath106 . ]    as a special case , if @xmath92 has only one 1 , let @xmath66 be the column where the 1 occurs , and let @xmath6 be its neighbor .",
    "we consider the projection @xmath97 of @xmath92 to be on @xmath6 , and to consist of @xmath6 s neighbor set @xmath107 .",
    "when this projection has been performed on all rows , each internal node @xmath6 has received the projection of zero or more rows of @xmath12 , and we represent each projection with a _ row vector _ in a _ quotient matrix _ whose columns are neighbors of @xmath6 .",
    "the row has a 1 in column @xmath35 if the leaves reachable through @xmath35 are 1 s of @xmath92 and a 0 if they are 0 s in @xmath92 .",
    "the result is a matrix whose rows are sets of neighbors of @xmath6 .",
    "note that the quotient at a node may be empty .",
    "figure  [ fig : pcquotients ] illustrates the quotients for the example of figure  [ fig : pcexample ] .",
    "( the tree has been rooted at node @xmath66 ; the motivation for this is explained below . )    .",
    "the tree has been rooted at its center .",
    "rows @xmath108 project to node @xmath75 , rows @xmath109 project to node @xmath89 , and rows @xmath110 project to node @xmath66 . ]",
    "[ lem : pquotients ] at a p node @xmath6 with @xmath111 neighbors , each row of the quotient matrix consists of either @xmath112 1 s and one 0 or @xmath112 0 s and one 1 .",
    "let @xmath12 be a circular - ones matrix , and let @xmath63 be the family of sets of columns obtained by considering each row to be the bit - vector representation of a set .    by the definition of a p node ,",
    "every union of neighbor sets of @xmath6 is a member of @xmath64 .",
    "let @xmath97 be the projection of some row @xmath92 to the quotient at @xmath6 .",
    "suppose @xmath97 consists of more than one and fewer than @xmath112 neighbors of @xmath6 .",
    "then @xmath92 consists of more than one and fewer than @xmath112 neighbor sets of @xmath6 .",
    "let @xmath113 and @xmath114 be two neighbors of @xmath6 , one in @xmath97 and one not .",
    "let @xmath47 and @xmath48 be the neighbor sets of @xmath6 reachable through @xmath113 and @xmath114 . then @xmath61 is a union of neighbor sets of @xmath6 that strongly overlaps @xmath92 .",
    "this disqualifies it as a member of @xmath64 , contradicting the fact that every union of at least one and fewer than all neighbor sets of a p node is a member of @xmath64 .",
    "the quotient at node @xmath75 of figure  [ fig : pcquotients ] illustrates the phenomenon .",
    "the projections of rows 2 and 4 exclude only neighbor @xmath66 , the projection of row 5 excludes only neighbor 1 , the projection of row 3 excludes only neighbor 3 , and the projection of row 1 contains only neighbor 1 .",
    "any cyclic ordering of the quotient at a p node is a circular - ones ordering of it .",
    "the quotient at a c node has a unique circular - ones ordering , up to rotation and reversal .",
    "again , let @xmath12 be a circular - ones matrix , and let @xmath63 be the family of sets of columns obtained by considering each row to be the bit - vector representation of a set .",
    "the result follows immediately for p nodes by lemma  [ lem : pquotients ] .",
    "suppose @xmath6 is a q node and let @xmath111 be the number of neighbors of @xmath6 .",
    "let @xmath47 be an arbitrary union of more than one and fewer than @xmath112 neighbor sets of @xmath6 . by the definition of a q node , @xmath115 .",
    "therefore , it strongly overlaps some row @xmath92 of @xmath12 .",
    "let @xmath114 be a column not in @xmath116 .",
    "root the pc tree at @xmath114 .",
    "if @xmath92 projects to a proper descendant of @xmath6 , then @xmath92 is either a subset of @xmath47 or disjoint from @xmath47 , a contradiction to the strong overlap .",
    "if @xmath92 projects to a proper ancestor of @xmath6 , then @xmath117 , also a contradiction . if @xmath92 projects to a node that is neither an ancestor nor a descendant of @xmath6 , then @xmath92 is disjoint from @xmath47 , once again a contradiction",
    ". therefore , @xmath92 projects on @xmath6 , and the projections @xmath118 and @xmath97 of @xmath47 and @xmath92 on @xmath6 are strongly overlapping sets of neighbors of @xmath6 .",
    "we conclude that every set @xmath47 of more than one and fewer than @xmath112 neighbors of @xmath6 strongly overlaps some row @xmath92 of the quotient at @xmath6 .",
    "reversing the order of members of @xmath47 in the cyclic ordering of neighbors about @xmath6 disrupts consecutiveness of @xmath92 .",
    "this implies that the pc tree of the quotient matrix at @xmath6 has a single internal node , a c node .",
    "the circular - ones orderings of this quotient are unique up to rotation and reversal .    as an illustration",
    ", it is easily verified in figure  [ fig : pcquotients ] that every ordering of columns of the quotients at p nodes @xmath75 is a circular - ones ordering , and that the quotient at c nodes @xmath89 and @xmath66 each have only two circular - ones orderings , one of which is depicted and the other of which is its cyclic reversal .",
    "note that the linear - time pc - tree construction algorithm of  @xcite gives a circular - ones arrangement of the leaves , but does not label the nodes with their quotient .",
    "let @xmath6 be the least common ancestor of a row @xmath92 when the tree is rooted at some leaf not in @xmath92 .",
    "let a node be _ black _ if all of its leaf descendants are in @xmath92 . because all neighbor sets of @xmath6 are either subsets of @xmath92 or disjoint from it , the black nodes consist of all ancestors of the leaves in @xmath92 , up to , and possibly including @xmath6 , if all of its children are black .",
    "the black children of @xmath6 are the ones corresponding to the projection of @xmath92 .    to find the projection of @xmath92 , we can therefore blacken the leaves that are members of @xmath92 .",
    "when we blacken a node we increment a counter in the parent , so that it keeps track of how many blackened children it has .",
    "when a node s counter is incremented to a value that equals its number of children , we blacken it , and increment its parent s counter .",
    "it is easily seen by induction on the height of a node that a node is blackened by this procedure if and only if it is black .",
    "the procedure halts when no new vertex can be marked .",
    "the blackened nodes induce a rooted forest , which is a rooted tree if @xmath6 is black .",
    "every internal node of this forest or tree has at least two black children .",
    "therefore , the number of black internal nodes is bounded by the number of black leaves , which is the size of @xmath92 . since the procedure spends @xmath119 time whenever it blackens a node , it takes @xmath120 time to find the least common ancestor @xmath6 and the edges to neighbor sets that make up @xmath92 s projection",
    ".    the procedure can be simulated without actually rooting the tree at @xmath114 ; it suffices to work `` inward '' from the marked leaves that are members of @xmath92 , and mark a node when its counter is equal to one less than its number of neighbors , since one of its neighbors is implicitly the parent . since the entry in the quotient matrix has a 1 for each member of @xmath47 , it takes @xmath120 time to find the quotient representation of each row @xmath92 .",
    "the total time to find all quotients is therefore linear .",
    "we now show that given a succinct representation of a circular - ones matrix , we may obtain the pc tree in @xmath17 time . by _ complementing _ a row of a binary matrix , we mean changing every 1 in the row to a 0 and every 0 to a 1 .",
    "it is obvious that complementing a row of a circular - ones matrix yields a circular - ones matrix  @xcite .",
    "the following is given in  @xcite for the version of the pc tree where the nodes do not have quotient labels .",
    "the pc tree of a circular - ones matrix is invariant under complementing a row of the matrix .",
    "the lemma is obvious from the observation that @xmath64 does not change when a row is complemented .",
    "let @xmath66 be a column of a circular - ones matrix . complementing all of the rows that have a 1 in column @xmath66 turns @xmath66 into a column of zeros . in the succinct representation of the matrix",
    ", it takes @xmath119 time to complement each such row : if @xmath121 represents the columns of the first and last 1 in the block of 1 s in the row , then the @xmath122 , modulo the number of columns , represents the complement of the row .",
    "since now no row contains @xmath66 , a circular - ones ordering where @xmath66 is the last row of the matrix is a _ consecutive - ones _ ordering on the columns of the matrix , excluding @xmath66 .",
    "the _ pq tree _ was developed by booth and lueker to represent all consecutive - ones orderings of the columns of a consecutive - ones matrix  @xcite .",
    "it is a certain rooting of the pc tree .",
    "( the pc tree was originally developed to provide an easier way to compute the pq tree .",
    "@xcite )    [ lem : pcpq ] let @xmath12 be a circular - ones matrix and @xmath66 be a column .",
    "let @xmath123 be the result of complementing all rows of @xmath12 that have a 1 in column @xmath66 , and then removing column @xmath66 . removing leaf @xmath66 from the pc tree of @xmath12 and then rooting it at the neighbor of @xmath87 gives the pq tree for @xmath123 .",
    "[ lem : pcon ] it takes @xmath17 time to compute the pc tree of a circular - ones matrix , given a succinct representation of it .",
    "given a succinct representation of a circular - ones matrix @xmath12 , we may remove all rows that have a single 1 or a single 0 , since these have no effect on the circular - ones orderings of the matrix , hence on the pc tree .",
    "we may then select the last column @xmath66 of @xmath12 , and identify the rows with a 1 in column @xmath66 in @xmath17 time .",
    "we may complement each of them in @xmath119 time , as described above , for a total of @xmath17 time .",
    "we may remove @xmath66 from the resulting matrix by decrementing the record of the number of columns .",
    "this takes @xmath17 time and gives a succinct representation of a consecutive - ones matrix , @xmath123 .    in  @xcite ,",
    "an @xmath17 algorithm is given for finding the pq tree of a consecutive - ones matrix , given a succinct representation . by lemma  [ lem : pcpq ] and the fact that the removed rows , which have all 0 s or all 1 s , have no effect on the pq tree of @xmath123 , we may then add a new leaf corresponding to @xmath66 to the root of the tree produced by this algorithm , and then unroot it to obtain the pc tree of @xmath12 , also in @xmath17 time .",
    "note that since the quotient labels of a pc tree have circular - ones orderings of columns , they can be expressed in the form of succinct representations also .",
    "doing this for all quotient labels causes them to take @xmath17 space , since there is one quotient row for each row of the original matrix .",
    "this raises the question of whether we can find this _",
    "succinct quotient - labeled pc tree _ in @xmath17 time .    given a succinct representation of a circular - ones matrix with @xmath16 rows",
    ", it takes @xmath17 time to find the succinct quotient - labeled pc tree .",
    "the algorithm proceeds as in the proof of lemma  [ lem : pcon ] until the pq tree of the succinct representation of the consecutive - ones matrix @xmath123 has been computed .",
    "we install the succinct quotient labels in this pq tree , as follows .",
    "we use harel and tarjan s least - common ancestor algorithm  @xcite to find the least common ancestor of the endpoints of each interval , and the child that contains the right endpoint of each interval .",
    "reversing the tree and repeating this gives the child containing the left endpoint .",
    "this takes @xmath17 time in total .",
    "these become the beginning and ending points for the representation of the row in the quotient at its least common ancestor .    for every row that was complemented to obtain @xmath123 from @xmath12 ,",
    "we complement the image of the row in the quotient at its least common ancestor , which takes @xmath119 time for each of these rows . note that if the image is all but one neighbor @xmath35 of a node @xmath6 and @xmath35 is not a leaf , then ,",
    "after the complementation , this projection consists only of @xmath35 .",
    "however , the definition of the projection at the beginning of section 3 dictates that in this case the projection be onto the least common ancestor of the row when the tree is rooted at a node that is 0 in the row .",
    "now @xmath35 , not @xmath6 , is this node , so the the projection must be moved to @xmath35 , and be changed to consist of all neighbors of @xmath35 other than @xmath6 .    for each row that was removed",
    "because it has only one 1 or one 0 , let @xmath124 be the leaf of the pc tree ( column of the matrix ) where the 1 or the 0 occurs .",
    "the projection is on the neighbor @xmath35 of @xmath124 , and consists either of @xmath124 or of all neighbors of @xmath35 other than @xmath124 , depending on whether the row had a 1 or a 0 in @xmath124 .",
    "in this section , we give an @xmath125 time algorithm , first developed in  @xcite , to test isomorphism of two circular - ones matrices if no circular - ones ordering of the two matrices is given , and an @xmath17 algorithm if a succinct representation is given .",
    "it is possible to test whether the matrices are both circular - ones matrices in linear time and to find a circular - ones ordering if they are  @xcite . if both of them fail to be circular - ones matrices , the input is rejected for failing to meet the precondition . if exactly one of them fails to be a circular - ones matrix , they are not isomorphic . otherwise ,",
    "from this ordering , we may find a succinct representation of the two matrices in linear time .",
    "we may then produce the quotient - labeled pc trees with a succinct representation of the quotients in @xmath17 time .    if the numbers of rows that are all 0 s in the two matrices differ or the number of rows of all ones differ , the matrices are not isomorphic .",
    "otherwise , the problem reduces to the question of whether the two matrices are isomorphic when these rows are eliminated .",
    "let @xmath23 and @xmath24 be these two matrices .",
    "this allows us to continue under our assumption that every row of the matrices has at least one 0 and at least one 1 .",
    "let us define an _",
    "@xmath4 from one _ quotient - labeled _ pc tree , @xmath34 , to another one , @xmath126 to consist of the following .",
    "it must be that whenever @xmath6 and @xmath7 are nodes of @xmath34 , then @xmath8 and @xmath9 are adjacent in @xmath126 if and only if @xmath6 and @xmath7 are adjacent in @xmath34 .",
    "this is the standard notion of graph isomorphism .",
    "it must also satisfy an additional constraint .",
    "each neighbor @xmath35 of internal node @xmath6 of @xmath34 corresponds to a column of the quotient matrix at @xmath6 .",
    "each neighbor @xmath127 of node @xmath128 of @xmath126 is a column of the quotient matrix at @xmath128 .",
    "if @xmath4 is an isomorphism of the underlying trees , then let @xmath129 denote the bijection it induces from neighbors of @xmath6 to neighbors of @xmath128 .",
    "it must be the case that at each internal node @xmath6 , @xmath129 is an isomorphism from the quotient matrix at @xmath6 to the quotient matrix at @xmath128 .",
    "if such a @xmath4 exists , we say that the trees are _ isomorphic as quotient - labeled pc trees _ ; otherwise we say that they are not .",
    "this definition precludes mapping a p node to a q node , because the quotient label determines whether a node is a p node or a q node .",
    "[ lem : pcisomorphism ] two circular - ones matrices are isomorphic if and only if their quotient - labeled pc trees are isomorphic .",
    "suppose matrices @xmath12 and @xmath123 are circular - ones orderings of isomorphic circular - ones matrices .",
    "let @xmath4 be an isomorphism from @xmath12 to @xmath123 .",
    "after permutation of columns of @xmath12 by @xmath4 , @xmath12 and @xmath123 have identical quotient - labeled pc trees , since they are identical multisets of row vectors .",
    "since @xmath12 and @xmath123 are both circular - ones orderings of @xmath12 , @xmath4 is one of the permutations of columns of @xmath12 permitted by the quotient - labeled pc tree of @xmath12 . in other words ,",
    "the pc tree of @xmath123 can be obtained from the pc tree of @xmath12 by the permitted operations .",
    "these operations define an isomorphism from the quotient - labeled pc tree of @xmath12 to the quotient - labeled pc tree of @xmath123 .",
    "conversely , suppose @xmath12 and @xmath123 are circular - ones orderings of matrices that have isomorphic quotient - labeled pc trees .",
    "use the isomorphism to arrange the pc tree of @xmath12 so that it is identical to that of @xmath123 .",
    "since it now represents @xmath123 instead of @xmath12 , it follows that the permutation of leaves of the pc tree induced by the isomorphism is an isomorphism from @xmath12 to @xmath123 .",
    "lemma  [ lem : pcisomorphism ] is the basis of our algorithm : for two circular - ones matrices , we compute their quotient - labeled pc trees and test whether they are isomorphic . to test whether they are isomorphic , we encode the trees with strings in such a way that they both have the same encoding if and only if they are isomorphic .",
    "our starting point is an algorithm for testing isomorphism of rooted , unordered trees that is given in the textbook  @xcite .",
    "a rooted tree is _ unordered _ if the left - to - right order of children of its nodes is not specified .",
    "two unordered , rooted trees @xmath130 and @xmath131 are isomorphic if they are isomorphic as directed graphs when the edges are oriented from child to parent .",
    "if the trees do not have the same height , they are not isomorphic .",
    "otherwise , the algorithm proceeds by induction by level , from level 0 , which is the level of the deepest leaf , to level @xmath132 , which is the level of the root and the height of the trees . at each level",
    ", it labels each node @xmath6 with an integer _ isomorphism - class label _",
    "@xmath133 such that two nodes at the level have the same label if and only if the subtrees rooted at them are isomorphic . at step @xmath14 ,",
    "we may assume by induction that this has been done for nodes at level @xmath43 .",
    "for all leaves at level @xmath14 , the isomorphism - class label is 0 . for the remaining nodes",
    ", we may apply the following procedure .",
    "let @xmath134 be the tuple of isomorphism - class labels for the children of @xmath6 , sorted in nondecreasing order .",
    "we may then sort the non - leaf nodes at level @xmath14 by lexicographic order of the tuples assigned to them , in order to group identical tuples together .",
    "if there are @xmath111 distinct tuples , among the tuples at level @xmath14 , we then assign isomorphism labels from 1 through @xmath111 to the tuples , and then each node with the number of the tuple it was assigned . by induction , this meets the precondition for induction step @xmath135 .",
    "therefore , two trees are isomorphic if their roots receive the same isomorphism class label .",
    "an additional requirement of an isomorphism @xmath4 on quotient - labeled pc trees is that when a node @xmath6 of @xmath34 maps to a node @xmath8 in @xmath126 , then the neighbors of @xmath6 map to neighbors of @xmath8 in a way that is an isomorphism of the quotient at @xmath6 to the quotient at @xmath8 .",
    "this requires that @xmath6 and @xmath8 have isomorphic quotients . in this subsection",
    ", we give an encoding of the quotient at a node of a quotient - labeled pc tree so that two nodes receive the same encoding if and only if their quotients are isomorphic .",
    "consider the p node @xmath75 of figure  [ fig : pcquotients ] .",
    "an obstacle to an immediate canonical representation is that the quotient can be presented in any column order , since all column orders are circular - ones orderings .    by lemma  [ lem : pquotients ] , every row of the quotient consists either of one of @xmath6 s neighbors , or of all but one of its neighbors .",
    "we can encode the quotient by giving , for each neighbor , an ordered pair of integers .",
    "the first integer is the number of rows that exclude only that neighbor and the second integer is number of rows that contain only that neighbor .",
    "for example , at node @xmath75 in figure  [ fig : pcquotients ] , the tuple generated by neighbor 1 is @xmath136 , since the projection of one row , row 5 , excludes only neighbor 1 , and the projection of one row , row 1 , contains only neighbor 1 .",
    "the tuple generated at neighbor 2 is @xmath137 since no row contains only 2 and no row excludes only 2 .",
    "the tuple generated at neighbor 3 is @xmath138 , since the projection of one row , row 3 , excludes only neighbor 3 and no rows contain only neighbor 3 .",
    "the tuple generated at neighbor @xmath66 is @xmath139 , since the projections of rows 2 and 4 exclude only @xmath66 and no row contains only @xmath66 .",
    "note that the tuple generated at a neighbor is invariant under permutation of the cyclic order of neighbors about the p node .",
    "listing these tuples in the cyclic order of the nodes at which they are generated yields an encoding of the quotient .",
    "the next step of the construction is to sort the generated tuples lexicographically to obtain a tuple of tuples . in the example of node @xmath75 of figure  [ fig : pcquotients ] , this gives @xmath140 .",
    "this encoding is unique , since it is the lexicographic minimum of all tuples whose elements are the generated tuples .    finally , in order to prevent the possibility that a p node and a c node will have the same encoding , we prepend a reserved p - node flag , 0 , to the list of tuples . in the example",
    "if figure  [ fig : pcquotients ] , this gives @xmath141 .",
    "this therefore gives a test of isomorphism of quotients at two p nodes by generating their canonical representations and testing whether they are equal .",
    "in generating a canonical encoding of the quotient at a c node @xmath6 , there are only two cyclic orders of the columns that are circular - ones orderings .",
    "one is the reverse of the other .",
    "this leaves us with two obstacles to a canonical representation : which of these two cyclic orders should we choose , and where in the cyclic ordering should we begin in developing a tuple to represent the quotient ?",
    "we begin by traveling counterclockwise around the cycle , starting at an arbitrary point . at each neighbor @xmath35",
    ", we generate a tuple that lists the lengths of rows whose clockwise - most 1 is at @xmath35 , and list them in nondecreasing order .    for example , consider the c - node @xmath66 depicted in figure  [ fig : pcquotients ] . at neighbor @xmath75",
    ", we see that there are two projections , of rows 11 and 10 , whose clockwise endpoint is at @xmath75 , and they have lengths 2 and 3 , respectively .",
    "therefore , the tuple generated for neighbor @xmath75 is @xmath142 . at neighbor 4",
    ", there is one projection , of row 12 , that has its clockwise endpoint at @xmath82 , and it has length 3 , so the tuple generated for 4 is @xmath143 .",
    "similarly , the tuples generated for neighbors 5 , 6 , and @xmath89 are @xmath144 , @xmath142 , and @xmath144 , respectively .    assembling these tuples in clockwise order",
    ", we get @xmath145",
    ". however , we must consider that we made an arbitrary decision in choosing the point on the circle at which to start generating the tuples .",
    "the effect of different choices is to rotate the resulting tuple of tuples . to choose it in a canonical way",
    ", we choose the rotation of the generated list of tuples that is earliest lexicographically : @xmath146 .",
    "we also made an arbitrary decision in going around the cycle clockwise instead of counterclockwise .",
    "therefore , we repeat the above procedure counterclockwise , generating @xmath147 if starting at @xmath89 , and then choose the rotation of this that is lexicographically minimum , @xmath148 . to choose the direction of travel in a canonical way , we choose , from these two lists of tuples , the one that is earlier in lexicographic order : @xmath146 .    to avoid any possibility that a c node and a p node can get the same encoding , we prepend a reserved c - node flag , 1 , to the list , yielding @xmath149 .    the general algorithm is as follows .",
    "first , we order the neighbors of the node @xmath6 so that the quotient has the circular - ones ordering . for each neighbor @xmath35 in counterclockwise order , list the lengths of the rows of the quotient whose clockwise - most 1 is at @xmath35 , in nondecreasing order .",
    "this gives a tuple @xmath150 for @xmath35 .",
    "the sequence of tuples generated for each neighbor @xmath35 , taken in counterclockwise order , gives a tuple of tuples .",
    "rotate this ordering to get the lexicographic minimum through rotation of the tuples . then repeat the exercise reversing the roles of clockwise and counterclockwise to obtain another such set of tuples . from these ,",
    "select the one that is earlier lexicographically . then prepend the reserved c - node flag 1 to this list .",
    "if @xmath4 is an isomorphism , then the tuples generated at a neighbor @xmath35 of @xmath6 is the same as the one generated at neighbor @xmath151 of @xmath8 .",
    "since the mapping of the cyclic ordering neighbors of @xmath6 to neighbors of @xmath8 is the cyclic ordering of neighbors of @xmath8 or its reverse , the quotient at @xmath6 and @xmath8 are encoded by the same tuple .",
    "conversely , if the quotient at c nodes @xmath6 and @xmath35 have the same tuple , then since each tuple uniquely encodes cyclic rotations of the quotient , @xmath6 and @xmath35 have isomorphic quotients .",
    "therefore , isomorphism of two quotients can be tested by determining whether they are encoded by the same quotient .",
    "we combine elements of the rooted - tree isomorphism test of section  [ sect : ahu74 ] with the test for isomorphism of quotients of section  [ sect : canon ] , in order to obtain an isomorphism test for quotient - labeled pc trees .",
    "the use of elements of section  [ sect : ahu74 ] requires us to root the pc trees .",
    "conceptually , a rooting of a tree may be viewed as an orientation of its edges from child to parent , yielding a directed graph .",
    "an isomorphism @xmath4 from one rooted tree , @xmath34 , to another , @xmath126 , is a bijection from nodes of @xmath34 to nodes of @xmath126 such that for @xmath152 , @xmath153 is a directed edge in @xmath126 if and only if @xmath37 is a directed edge in @xmath34 . once we root two pc trees , we require them to satisfy this condition .",
    "we must therefore be careful to root the two trees in an isomorphic way whenever they are isomorphic .",
    "the _ center _ of a one - vertex tree is its vertex and the center of a one - edge tree is its edge .",
    "otherwise , the center is obtained by deleting its leaves and recursively finding the center of the resulting subtree .",
    "it consists of a single vertex or a single edge .",
    "if the center of a pc tree is node , we root it at that node .",
    "if it is an edge @xmath154 , we subdivide the edge with a pseudo - node @xmath113 and root it at @xmath113 so that the tree has a node as a root , as we did above . in the quotient at @xmath7 ,",
    "replace the name of @xmath35 with @xmath113 and in the quotient at @xmath35 , replace the name of @xmath7 with @xmath113 .",
    "now @xmath113 can be treated as a p node with an empty quotient .",
    "once we have rooted the trees , we proceed by induction on the level @xmath14 , as in the algorithm of section  [ sect : ahu74 ] .",
    "because we are applying a stronger notion of isomorphism , which observes constraints imposed by the quotients , we must redefine what is meant by the isomorphism - class label @xmath133 assigned to a node @xmath6 at level @xmath14 .    for every node @xmath6 in @xmath34",
    "we define a tree @xmath155 , an induced subtree of @xmath34 , as follows .",
    "if @xmath6 is a leaf node in @xmath34 , let @xmath155 be the one - node tree consisting of @xmath6 .",
    "if @xmath6 is an internal node that is not the root of @xmath34 , let @xmath155 be the quotient - labeled subtree induced by @xmath6 , its descendants , and the parent @xmath35 of @xmath6 .",
    "if @xmath6 is an internal node and the root of @xmath34 , then @xmath156 , and @xmath6 is the root of @xmath155 .",
    "two nodes @xmath6 and @xmath128 at level @xmath14 are in the _ same isomorphism class at level @xmath14 _ if and only if @xmath155 and @xmath157 are isomorphic as quotient - labeled rooted pc trees .    because of the inclusion of the parent of @xmath6 , the neighbors of each internal node of @xmath155 are the same in @xmath155 as they are in @xmath34 .",
    "this allows each internal node to retain the same quotient in @xmath155 as it has in @xmath34 .",
    "this tree is rooted at the parent of @xmath6 .    in order to merge the constraints of sections  [ sect : ahu74 ] and  [ sect : canon ] , we prepend the isomorphism class label @xmath158 of a node @xmath35 at level @xmath43 ( section  [ sect : ahu74 ] ) to the tuple generated for the node in the encoding of the quotient ( section  [ sect : canon ] ) .",
    "the preconditions at the beginning of the induction step at level @xmath14 are the following .",
    "leaves at level @xmath14 are labeled with equivalence - class label 0 .",
    "if @xmath6 is a non - leaf at level @xmath14 , then the parent @xmath159 of @xmath6 , if it exists , is a node of @xmath155 and labeled with equivalence class label -1 .",
    "note that @xmath159 is a leaf of @xmath155 , but no automorphism @xmath34 to itself will map @xmath159 to any other leaf of @xmath155 , since they are at different levels of @xmath155 .",
    "therefore , we must give @xmath159 a different isomorphism class label from other leaves of @xmath155 .",
    "for any other neighbor @xmath35 of @xmath6 , @xmath35 lies at level @xmath43 , and , by induction , it is labeled with an integer isomorphism class label for level @xmath43 .",
    "the isomorphism classes reflect the stronger constraints where , if @xmath35 and @xmath127 are two nodes at level @xmath43 that have the same label , @xmath160 and @xmath161 are isomorphic as rooted quotient - labeled pc trees .",
    "if , together in @xmath34 and @xmath126 , there are @xmath111 distinct isomorphism equivalence classes for internal nodes at level @xmath43 , they are labeled with integers between 1 and @xmath111 , where 1 denotes that a vertex is a leaf at level @xmath43 . for each neighbor of @xmath6 , let @xmath158 denote the integer label from @xmath162 assigned to @xmath35 .",
    "we now strengthen the inductive step of section  [ sect : ahu74 ] to make the stronger induction hypothesis go through for level @xmath14 .",
    "the canonical encoding of the quotient at @xmath6 given in section  [ sect : canon ] assigns a unique tuple to each neighbor @xmath35 of @xmath6 ; to this tuple we simply prepend @xmath158 to the tuple generated for @xmath35 .",
    "the @xmath158 labels on neighbors enforce the constraint that @xmath6 and @xmath128 can get the same tuple only if there is a bijection @xmath4 from neighbors of @xmath6 to neighbors of @xmath6 such that @xmath160 and @xmath163 are isomorphic as quotient - labeled trees . the rest of the tuple forces the constraint that they can get the same tuple only if there exists such a @xmath4 that is also an isomorphism from the quotient at @xmath6 to the quotient at @xmath128 , as in section  [ sect : canon ] .",
    "conversely , after ordering the tuples in the canonical way described in section  [ sect : canon ] , it is clearly sufficient for @xmath155 and @xmath157 to be isomorphic as quotient - labeled trees for @xmath6 and @xmath128 to be assigned the same tuple .    replacing the tuples with integer codes from 1 to @xmath111 , where @xmath111 is",
    "is the number of distinct tuples at level @xmath14 completes the induction step .    therefore , @xmath34 and @xmath126 are isomorphic quotient - labeled pc trees if and only if , after rooting them at their centers and performing this algorithm , the roots get assigned the same integer label .",
    "[ thm : circisotime ] given the sparse representations of matrices @xmath12 and @xmath123 , it takes @xmath125 time either to determine that neither is a circular - ones matrix , or else to determine whether they are isomorphic .",
    "given succinct representations of two circular - ones matrices , this problem takes @xmath17 time to solve .",
    "it takes @xmath125 time to determine whether they have the same number of 1 s , by counting 1 s in the two matrices in parallel .",
    "if so , @xmath164 . if the standard sparse representations of the matrices is given , it takes @xmath125 time to determine whether they are circular - ones matrices . if neither is , the claim is satisfied .",
    "if only one is , they are not isomorphic .",
    "otherwise , it takes @xmath125 time to convert them to the succinct representations . from the succinct representations we can compute the two quotient - labeled pc trees , as described above .",
    "therefore , by lemma  [ lem : pcisomorphism ] , it suffices to show that the quotient - labeled pc - tree isomorphism algorithm can be implemented to run in @xmath17 time .",
    "* proposition 1 : * _ summing , for every level @xmath14 , the number of nodes at level @xmath43 plus the number of rows in quotients at level @xmath14 gives a number that is @xmath17 .",
    "_ this just counts the number of nodes in the tree plus the number of rows in the quotients .",
    "each row of a matrix projects to just one row of a quotient .",
    "* proposition 2 : * _ at level @xmath14 , the sum of lengths of the tuples is at most proportional to the number of nodes at level @xmath43 plus the number of rows in quotients at level @xmath14 .",
    "_ this is because one tuple is generated for each neighbor @xmath35 of @xmath6 contains an integer equivalence class label @xmath158 , and an encoding of a set of rows of the quotient at @xmath6 .",
    "the encoding of each row in the quotient only appears in one of the tuples for neighbors .",
    "* proposition 3 : * _ at level @xmath14 , the maximum integer in any tuple is bounded by the number of nodes at level @xmath43 plus the number of rows in quotients at level @xmath14 . _",
    "the integer equivalence classes at level @xmath43 are assigned consecutive numbers , starting at 2 , by sorting the tuples lexicographically , and giving the same integer to two consecutive tuples that are identical , and giving an integer that is one higher than its predecessor s if it differs from its predecessor .",
    "each row of a quotient at level @xmath14 maps to only one element of a tuple generated at level @xmath14 .",
    "* proposition 4 : * a radix sort of a set of tuples of integers takes time proportional to the sum of lengths of the tuples plus the size of the range of integer values occurring in the tuples  @xcite .",
    "the tuples at p nodes must be sorted lexicographically .",
    "number the nodes at level @xmath14 in any order to assign them identification numbers , or _",
    "numbers_. the maximum number label of one of these nodes is at most the number of nodes at level @xmath43 .",
    "to each tuple for a child of a p node , prepend the i.d .",
    "number of the parent .",
    "sort all tuples for p nodes at level @xmath43 in a single lexicographic sort . since the i.d .",
    "number of the parent is the major sort key , this groups all tuples of children of a p node together , in lexicographic order , giving , for each p node , one lexicographically sorted list of tuples for its children . by propositions 2 , 3 , and 4",
    ", the time for sorting all lists of tuples for children of p nodes conforms to the measure given in proposition 1 .",
    "the order of tuples of children of a q node are already given by the canonical procedure for generating them , as described above .",
    "we must also sort the set of lists of tuples at level @xmath14 in order to generate the equivalence class numbers for the nodes at level @xmath14 .",
    "a list of tuples can be represented by a simple tuple of integers by appending a special separator , -2 , to each tuple , and then concatenating them .",
    "this change of representation does not affect the lexicographic order of the lists , but turns them from lists of tuples to lists of integers to make it easier to see that they can be radix sorted .",
    "the addition of the separators increases the range of values by @xmath119 . by propositions 2 , 3 , and 4 , the time for sorting the set of lists of tuples for children of p nodes conforms to the measure given in proposition 1 .",
    "assigning integer equivalence - class labels to the lexicographically sorted set of lists of tuples trivially takes time proportional to the sum of lengths of lists of tuples , which , by proposition 2 , conforms to the measure of proposition 1 .",
    "all of these steps conform to the measure of proposition 1 , so , by proposition 1 , they take @xmath17 time over all iterations of the induction step .",
    "we must also bound the time to choose , from the @xmath165 possible choices of a list of tuples at a c node , one that is earliest in lexicographic order .",
    "generate two lists , one for each cyclic ordering , starting at an arbitrary node for each .",
    "turn each of the lists from a list of tuples to a list of integers , using the separators , as described above .",
    "then apply the linear - time algorithm of  @xcite to find the cyclic rotation of each list that is earliest in lexicographic order .",
    "of these two resulting lists , choose the one that is earlier in lexicographic order .",
    "every interval model has the helly property  @xcite . however , unlike interval models , circular - arc models may fail to have the helly property .",
    "figure  [ fig : nonhca ] gives a circular - arc model of a graph where the arcs that make up a clique , @xmath166 , do not have a common intersection .",
    "a graph is a helly circular - arc graph if it admits at least one circular - arc model that has the helly property .",
    "it is easily verified that there is no circular - arc model of the graph of figure  [ fig : nonhca ] where @xmath167 , @xmath168 , and @xmath87 have a common intersection point .",
    "this illustrates that the helly circular - arc graphs are a proper subset of the circular - arc graphs .",
    "not every circular - arc model of a helly circular - arc graph has the helly property .",
    "removing arcs @xmath169 from the model of figure  [ fig : nonhca ] yields a model for the complete graph on three vertices that does not have the helly property .",
    "however , this graph is a helly circular - arc graph ; it is easy to represent this graph with three copies of the same arc , which has the helly property .",
    "the strategy of our algorithm for finding whether two helly circular - arc graphs are isomorphic is related to that of lueker and booth for finding whether two interval graphs are isomorphic  @xcite ; both algorithms use the clique matrices of the graphs .",
    "the main new challenge involves correctly computing the clique matrix .",
    "we consider adjacency - list representations of two graphs @xmath2 and @xmath3 .",
    "recall that we assume that the numbers of vertices and edges in both graphs are the same . for each graph",
    ", we obtain a helly circular - arc model or determine that none exists , in @xmath26 time , using an existing algorithm for this problem  @xcite . if exactly one of them is a helly circular - arc graph , we determine that they are non - isomorphic .",
    "if both of the input graphs fail to be helly circular - arc graphs , we reject them for failing to meet the precondition , even though they may be isomorphic .",
    "if both graphs are helly circular - arc graphs , we use the helly circular - arc models to find succinct representations of circular - ones orderings of their clique matrices .",
    "this involves some complications not present in the corresponding problem on interval graphs , which we show how to get around in @xmath17 time , below .",
    "once we have succinct representations of the clique matrices , we use the straightforward fact that two graphs are isomorphic if and only if their clique matrices are isomorphic ( lemma  [ lem : cliqueisomorphism ] , below ) .",
    "this reduces the problem to isomorphism of circular - ones matrices , which we have solved in @xmath17 time in section  [ sect : pciso ] .",
    "the total time is @xmath26 .",
    "if the two graphs are circular - arc graphs and the inputs are circular - arc models , we use the @xmath17 algorithm of  @xcite to find a helly circular - arc model for each of them or determine that it is not a helly circular - arc graph .",
    "we then proceed as in the case where adjacency - list representations of two graphs are given , but take a total of @xmath17 time , rather than @xmath26 .    the main result of this section is the following theorem :    [ thm : hcaisomorphism ] given the adjacency - list representations of two graphs",
    ", @xmath2 and @xmath3 , where @xmath2 has @xmath16 vertices and @xmath21 edges , it takes @xmath26 time either to determine that neither is a helly circular - arc graph , or else to determine whether they are isomorphic .",
    "given circular - arc models of two circular - arc graphs , this problem takes @xmath17 time to solve .",
    "if @xmath170 and @xmath171 are the number of vertices and edges of @xmath3 , it takes @xmath26 time to determine whether @xmath172 and @xmath173 , by counting these elements in the two graphs in parallel .",
    "if this is not the case , then they are not isomorphic .",
    "therefore , we may assume henceforth that @xmath172 and @xmath173 .",
    "[ lem : cliqueisomorphism ] two graphs are isomorphic if and only if their clique matrices are isomorphic .",
    "a graph isomorphism maps maximal cliques to maximal cliques , so it defines an isomorphism of their clique matrices .",
    "conversely , since two vertices are adjacent if and only if they are in a common clique , an isomorphism from the clique matrix of one graph to that of another defines a graph isomorphism .    in a circular - arc model of a graph , let an _ intersection segment _ be a place where a counterclockwise endpoint of an arc is followed immediately by a clockwise endpoint of an arc in the model in the clockwise direction ; the intersection segment is the region between the two points . in an interval model ,",
    "a set of arcs corresponds to a maximal clique if and only if it is the set of intervals containing an intersection segment .",
    "each intersection segment can be located and marked by a _",
    "clique point _ lying in the segment .",
    "a clique is a maximal clique if and only if it is the set of arcs that contain a clique point .",
    "a consecutive - ones ordering of the clique matrix can be obtained by making one column for each such maximal clique , and putting a 1 in the column in each row corresponding to an arc that passes through the region .    by analogy , in a helly circular - arc model , we can place a clique point in each intersection segment .",
    "because the model has the helly property , a maximal clique must be the set of arcs containing one of the clique points .",
    "however , in contrast to the case of interval models , not all such sets of arcs must be maximal cliques .",
    "moreover , the same clique may appear multiple times , as the arcs containing two different clique points in widely separated parts of the circle .",
    "figure  [ fig : hellycliques ] gives an example .        to get a clique matrix for the graph",
    ", we must eliminate redundant clique points and clique points that do not represent maximal cliques from this helly circular - arc model .",
    "suppose we accomplish this .",
    "we can obtain a succinct representation of a circular - ones ordering of its clique matrix as follows .",
    "number the arcs and label each arc s two endpoints with its arc number .",
    "create an array of @xmath16 buckets , one for each vertex .",
    "number the cliques by numbering the clique points that have not been eliminated in order around the circle .",
    "this is a circular - ones ordering of the clique matrix .",
    "it suffices , for each bucket @xmath14 , to store the counterclockwise - most and clockwise - most clique number of each arc in order to get the succinct representation of the circular - ones ordering of the clique matrix .",
    "the counterclockwise points that correspond to clique @xmath15 are those in the maximal consecutive block of counterclockwise points that lie immediately counterclockwise from clique point @xmath15 .",
    "the clockwise points that correspond to clique @xmath15 are those in the maximal consecutive block of clockwise endpoints immediately clockwise from clique point @xmath15 .",
    "this can be recorded in each bucket , giving the succinct representation of a circular - ones ordering of the clique matrix .",
    "we now describe how to eliminate redundant clique points and clique points that do not correspond to maximal cliques .",
    "since we have placed one clique point at each intersection segment , and each intersection segment contains the counterclockwise point of an arc and a clockwise point of an arc , we have placed at most @xmath16 clique points . a preliminary version of this procedure appeared in @xcite .    for any point @xmath159 on the circle of a circular - arc model , denote by @xmath174 the family of arcs of the model that contain @xmath159 . given two points @xmath175 and @xmath176 on the circle of a circular - arc model , let us say @xmath175 _",
    "@xmath176 if @xmath177 .",
    "let @xmath178 be a circular - arc model and @xmath179 be a set of points of the circle on which @xmath178 resides , where @xmath180 is the clockwise order in which @xmath11 appears in a traversal of the circle , starting at an arbitrary point on the circle .",
    "let us say that @xmath181 is a _ @xmath11-dominating _ set if every point in @xmath182 is dominated by some point in @xmath183 .",
    "any minimal set of dominating points , with respect to containment , among the set @xmath11 of at most @xmath16 clique points we have placed on the circle , is a non - redundant set of clique points .",
    "we solve the following more general problem in @xmath184 time :    * given a set @xmath11 of points on the circle of a ( not necessarily helly ) circular - arc model , find a minimal @xmath11-dominating set .",
    "if the model is helly and @xmath11 consists of one point per intersection segment , a minimal p - dominating set gives the columns of the clique matrix .",
    "the _ ascending semi - dominating sequence _ of @xmath11 is the subset @xmath185 for all @xmath186 such that @xmath187 in other words , @xmath188 contains the points @xmath189 that are not dominated by any later point in @xmath11 .",
    "similarly , the _ descending semi - dominating sequence _ of @xmath11 is the subset @xmath190 for all @xmath189 such that @xmath191 the following lemma reduces the problem of finding a minimal @xmath11-dominating sequence to that of finding @xmath192 and @xmath193 .",
    "[ thm : sd ] let @xmath178 be a circular - arc model and @xmath11 be a set of points on it .",
    "both @xmath194 and @xmath195 are minimal @xmath11-dominating sequences .",
    "we only prove that @xmath196 is a minimal @xmath11-dominating sequence .",
    "the proof for @xmath194 can be obtained by taking the reverse of @xmath178 .",
    "let @xmath179 be points on the circle where @xmath180 is the order in which @xmath11 appears in a clockwise traversal of the circle .",
    "we first prove that @xmath197 is in fact a @xmath11-dominating sequence .    by definition ,",
    "every point @xmath198 is dominated by some point @xmath189 for some @xmath199 . if @xmath14 is the minimum element in @xmath200 such that @xmath201 dominates @xmath202 , then no point @xmath203 can dominate @xmath201 ; otherwise @xmath159 would dominate @xmath202 , contradicting the minimality of @xmath14 .",
    "therefore , every point in @xmath204 is dominated by some point in @xmath205 .",
    "we can apply a symmetric arguments for @xmath205 and @xmath197 to conclude that every point in @xmath206 is dominated by some point in @xmath197 . since domination is a transitive relation , every point of @xmath11",
    "is also dominated by some point in @xmath197 , i.e. , @xmath197 is a @xmath11-dominating sequence .",
    "we now show that @xmath197 is minimal .",
    "observe that it is enough to show that if a point @xmath201 is dominated by a point @xmath207 , where @xmath208 , then @xmath209 .",
    "this will imply that no point of @xmath197 dominates any other point of @xmath197 , so no point of @xmath197 can be removed from it to yield a smaller dominating set . if @xmath210 then @xmath211 , hence @xmath212 .",
    "if @xmath213 , then since @xmath207 , it follows that @xmath214 , and we obtain again that @xmath215 .    the algorithms for finding @xmath192 and for finding @xmath193 are symmetric .",
    "we describe the one to find @xmath192 .",
    "the algorithm works by induction on @xmath14 to find @xmath216 , where @xmath217 .",
    "that is , we find those points of @xmath218 that are not dominated by any later points of @xmath218 .    by induction ,",
    "assume we have the following partition of @xmath216 at the end of step @xmath14 :    * @xmath219 : points in @xmath216 that are already known to be in @xmath188 . *",
    "@xmath220 : remaining points in @xmath216 ; these are points that are not dominated by any later point in @xmath218 , but that may or may not be dominated by points in @xmath221 .",
    "it is easy to see that it will follow that when @xmath222 , we get that @xmath223 , and this solves the problem .",
    "we begin with @xmath224 , where @xmath225 and @xmath226 .    in step @xmath135 , we obtain @xmath227 and @xmath228 from @xmath220 and @xmath219 as follows .",
    "we remove points from @xmath220 and insert them in @xmath219 if they pass a test that shows that they can not be dominated by any later point in @xmath11 , including @xmath229 .",
    "the addition of these points to @xmath219 gives @xmath228 .",
    "we discard other points from @xmath220 that are dominated by @xmath229 .",
    "we then add @xmath229 to @xmath220 .",
    "this gives @xmath227 .",
    "the test of whether a point @xmath230 moves from @xmath220 to @xmath228 consists of determining whether it is contained in the arc @xmath231 that does not contain @xmath232 , has its clockwise endpoint in @xmath233 , and among all such arcs , extends farthest in the counterclockwise direction .",
    "( see figure  [ fig : francisco ] . )",
    "if @xmath230 is contained in @xmath231 , then , since @xmath231 does not contain any point from @xmath221 , @xmath230 can not be dominated by any point in this set , and since @xmath234 , it it is not dominated by any later point in @xmath218 .",
    "therefore , it is a member of @xmath188 , and can be moved to @xmath228 .     and",
    "@xmath227 from @xmath219 and @xmath220 . out of all arcs that have their clockwise endpoints in @xmath233 and do not contain @xmath232",
    ", @xmath235 is the one that extends farthest counterclockwise .",
    "elements of @xmath220 that are contained in @xmath231 can not be dominated by any point in @xmath221 , hence they are moved to @xmath219 , yielding @xmath228 . out of all arcs that contain @xmath232 but do not contain @xmath229",
    ", @xmath236 is the one that extends farthest clockwise .",
    "elements still in @xmath220 that are not contained in @xmath236 are dominated by @xmath229 , hence discarded from @xmath220 .",
    "then @xmath229 is added to what remains of @xmath220 , yielding @xmath227 . ]",
    "we implement @xmath220 as a stack @xmath237 , where @xmath238 is the top of the stack .",
    "note that the set of points that get moved to @xmath219 are consecutive at the top of the stack . to move them , we pop the stack until we reach an element not in @xmath231 , and move the popped elements to @xmath219 .",
    "a point @xmath239 that is still in @xmath220 fails to be dominated by @xmath229 if and only if it is contained in some arc that does not contain @xmath229 .",
    "all arcs in this set contain @xmath232 , since otherwise , @xmath239 would already be identified as a member of @xmath240 for some @xmath241",
    ".    of all arcs that exclude @xmath229 but contain @xmath232 , let @xmath236 be the one whose clockwise endpoint extends farthest clockwise from @xmath232 .",
    "( see figure  [ fig : francisco ] . )",
    "since @xmath236 is the arc in this set that covers the most members of @xmath242 , it follows that the points of @xmath220 that are dominated by @xmath229 are those that are not contained in @xmath236 .",
    "note that the ones that are dominated by @xmath229 are again consecutive at the top of the stack , so we pop the stack until we reach an element that is contained in @xmath236 , and discard the popped elements .",
    "since @xmath229 belongs in @xmath227 , we obtain our stack for @xmath227 by pushing @xmath229 to what remains of the stack for @xmath220 .    for the time bound , note that we may find @xmath231 for each @xmath243 by traversing @xmath233 comparing the counterclockwise endpoints of arcs whose clockwise endpoints are in this interval and do not contain @xmath232 . over all @xmath14 ,",
    "this expends @xmath119 time on each arc , so it takes @xmath17 time .    to find @xmath236 for all @xmath244 , we start just counterclockwise from @xmath232 and traverse the circle counterclockwise , keeping track of the _ best _ arc so far .",
    "the best arc is initially null .",
    "when we reach an arc @xmath167 , we check whether @xmath167 contains @xmath232 , and , if so , whether it extends farther clockwise than the best arc so far .",
    "if so , @xmath167 becomes the best arc so far .",
    "each time we reach a point @xmath201 , we record the best arc so far as @xmath236 . over all @xmath14 ,",
    "this also expends @xmath119 time on each arc , for a total of @xmath17 time .",
    "the management of the stack implementing @xmath220 takes @xmath17 time over all steps , since each point is pushed once , and when points are popped , they are consecutive at the top of the stack .",
    "in this section we show that the circular - ones matrix isomorphism test of section  [ sect : matrixisomorphism ] can be used to test isomorphism of @xmath1 circular - arc graphs and convex - round graphs , using results of chen  @xcite . from this",
    "we get a new algorithm for isomorphism of proper circular - arc graphs .    given adjacency lists of two graphs , it takes @xmath26 time to either determine that the graph are not @xmath1 circular - arc graphs or to determine whether they are isomorphic .",
    "given adjacency lists of two graphs , it takes @xmath26 time to either determine that the graph are not convex - round graphs or to determine whether they are isomorphic .",
    "a graph is a @xmath1 circular - arc graphs if its augmented adjacency matrix has the circular - ones property .",
    "chen  @xcite showed that two @xmath1 circular - arc graphs are isomorphic if and only if their augmented adjacency matrices are isomorphic .",
    "given adjacency - list representations of two graphs , it takes @xmath26 time to determine whether their augmented adjacency matrices have the circular - ones property  @xcite .",
    "if they both do , then it takes @xmath26 time , using the isomorphism test of section  [ sect : matrixisomorphism ] to determine whether they are isomorphic .",
    "if a circular - one ordering of the adjacency matrices of the two graphs are given using succinct representations , the test takes @xmath17 time .",
    "convex - round graphs are complements of @xmath1 circular - arc graphs  @xcite .",
    "the adjacency matrix of a convex - round graph has the circular - ones property .",
    "chen  @xcite showed that two convex - round graph are isomorphic if and only if their adjacency matrices are isomorphic .",
    "therefore , we use the same technique to get the same bounds for testing isomorphism of convex - round graphs as we do for testing isomorphism of @xmath1 circular - arc graphs .    since every proper circular - arc graph is a @xmath1 circular - arc graph  @xcite",
    ", we can use the same algorithm also for an isomorphism test of proper circular - arc graphs .",
    "this gives a new @xmath26 isomorphism algorithm for proper circular - arc graph .",
    "the @xmath26 time bound is optimal if the input graphs are given by adjacency lists , but it is not optimal if they are given by proper circular - arc models .",
    "the algorithm of lin et al .  @xcite for the problem solves it in @xmath17 time if the circular - arc models are given .",
    "we show how to achieve an algorithm with the same time bound .",
    "we need to find succinct representations of circular - one arrangements of the augmented adjacency matrix of the given proper circular - arc models .",
    "let @xmath178 be a circular - arc model of @xmath2 .",
    "if @xmath178 is not a proper circular - arc model , then we can convert it in @xmath17 time to such a model @xcite .",
    "the model @xmath178 can be changed in @xmath17 time , such that no two arcs cover the circle together  @xcite , and the model remains proper . after changing the model this way , we index the vertices of @xmath2 according to the clockwise order of their counterclockwise endpoints , starting at an arbitrary endpoint . since there are no arc containment or pair of arcs that cover the circle in @xmath178 , this indexing gives a circular - ones arrangement of the augmented adjacency matrix of @xmath2 .    to find the last 1 entry in the row of each vertex of @xmath2 according to this indexing , in @xmath17 time , we go clockwise around the circle once , starting at an arbitrary counterclockwise endpoint , which belongs to a vertex @xmath7 .",
    "if the next endpoint we encounter is a clockwise endpoint of a vertex @xmath6 , then the last 1 in the row of @xmath6 is in the column of @xmath7 . if the next endpoint we encounter is a counterclockwise endpoint of a vertex @xmath6 , we set @xmath245 .",
    "we end this traversal when we get back to the start point .",
    "the first 1 of every row of a vertex in @xmath2 is found symmetrically .",
    "we conclude that it takes @xmath17 time to find a succinct representation of a circular - ones ordering of the augmented adjacency matrix of a graph from a proper circular - arc model of the same graph .",
    "once we have succinct representation of the augmented adjacency matrices of @xmath2 and @xmath3 we can test them for isomorphism in @xmath17 time .",
    "given adjacency lists of two graphs , it takes @xmath26 time to either determine that the graph are not proper circular - arc graphs or to determine whether they are isomorphic .",
    "given two circular - arc models of circular - arc graphs , the same task takes @xmath17 time .",
    "in this section we give an example of two circular - arc graphs that are not isomorphic , but the algorithm of hsu @xcite determines that they are .",
    "we begin with few definitions from this paper .",
    "let @xmath2 be a circular - arc graph , without universal vertices , and without any pair of vertices @xmath7 and @xmath6 such that @xmath29=n[u]$ ] .",
    "a _ normalized model _ of @xmath2 is a circular - arc model of the graph , such that for every two arcs @xmath7 and @xmath6 : ( 1 ) if @xmath246 \\subseteq n[v]$ ] then the arc of @xmath7 contains the arc of @xmath6 ; ( 2 ) if every @xmath247 $ ] satisfies @xmath248 \\subseteq n[u]$ ] and every @xmath249 $ ] satisfies @xmath250 \\subseteq n[v]$ ] then the arcs of @xmath6 and @xmath7 cover the circle together .",
    "every circular graph without universal arcs and without any pair of vertices with the same neighborhood has a normalized model @xcite .",
    "let @xmath38 be a normalized model of @xmath2 .",
    "we get the _ associated chord model _ of @xmath38 by replacing the arcs of @xmath38 with chords .",
    "let @xmath251 be an associated chord model of @xmath2 .",
    "the chord model @xmath251 represents a _ circle graph _ @xmath252 , whose vertex set is the same vertex set as of @xmath2 , and two vertices are adjacent if and only if their chords in @xmath251 intersect .",
    "although there might be more than one unique associated chord model for @xmath2 , the graph @xmath252 is unique .",
    "hsu @xcite defined a type of chord model called _ conformal model _ for @xmath252 .",
    "the chord model @xmath251 is a _",
    "conformal model _ of @xmath252 .",
    "note that we do not repeat the definition of conformal model here , we just give an example for one such model .",
    "we do not require the definition for our purposes .",
    "the origin of the mistake in hsu s algorithm is the statement _ `` to test the isomorphism between two such circular - arc graphs @xmath2 and @xmath3 , it suffices to test whether there exist isomorphic conformal models for @xmath252 and @xmath253 '' _ ( * ? ? ?",
    "* section 9 ) , where `` such circular - arc graphs '' refer to circular - arc graphs for which both @xmath252 and its complement are connected .",
    "consider the graphs @xmath2 and @xmath3 in figure [ fig : hsugraphs ] .",
    "it is easy to see that @xmath2 and @xmath3 are not isomorphic , since they have different number of edges .",
    "normalized circular - arc models of both graphs are given in figure [ fig : hsumodels ] . from the circular - arc models",
    ", we can see that the chord model in figure [ fig : hsuchords ] is an associated chord model for both graphs , and hence a conformal model of both @xmath252 and @xmath253 .",
    "the graphs @xmath254 are connected and so are their complements .",
    "we conclude that the statement above is wrong , and the algorithm of @xcite falsely finds that @xmath2 and @xmath3 are isomorphic .     and @xmath3 .",
    "it is easy to see that the two graphs are not isomorphic to each other , since they have different number of edges.,title=\"fig : \" ]   and @xmath3 .",
    "it is easy to see that the two graphs are not isomorphic to each other , since they have different number of edges.,title=\"fig : \" ]     and @xmath3 .",
    "the two models share seven arcs in common , and the eighth arc ( _ bold _ ) is flipped between the two models.,title=\"fig : \" ]   and @xmath3 .",
    "the two models share seven arcs in common , and the eighth arc ( _ bold _ ) is flipped between the two models.,title=\"fig : \" ]      hsu @xcite noted that the isomorphism of conformal models of @xmath252 and @xmath253 , which the algorithm of @xcite produces , does give a mapping between vertices of @xmath2 and @xmath3 , if @xmath252 is inseparable with respect to modular decomposition .",
    "however , we do not know how to handle the case when this condition is not satisfied .",
    "we note that the algorithm of @xcite works correctly for isomorphism of circle graphs . with the @xmath22 time recognition algorithm for circle graphs",
    "@xcite , the isomorphism test takes @xmath22 time if the graphs are given as adjacency matrices . the recent @xmath255 circle - graph recognition algorithm @xcite leads to the same running time for circle - graph isomorphism , where @xmath256 is the inverse ackermann function .",
    "if chord models are given as an input , then the running time of the isomorphism test can be reduced to @xmath26 using techniques similar to those used in @xcite and in our paper ."
  ],
  "abstract_text": [
    "<S> we give a linear - time algorithm that checks for isomorphism between two @xmath0 matrices that obey the circular - ones property . </S>",
    "<S> this algorithm leads to linear - time isomorphism algorithms for related graph classes , including helly circular - arc graphs , @xmath1 circular - arc graphs , proper circular - arc graphs and convex - round graphs . </S>"
  ]
}