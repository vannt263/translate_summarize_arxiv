{
  "article_text": [
    "networked control systems ( ncss ) are spatially distributed systems in which the communication between sensors , actuators and controllers occurs through a shared band - limited digital communication network , as shown in fig .  [",
    "fig : ncs ] .",
    "such structures bring many advantages , for instance reduced wiring and maintenance costs as well as an increased flexibility and reconfigurability .",
    "ncss occur in numerous applications , including power systems @xcite , aircrafts and automobiles @xcite , and process control @xcite .",
    "notice that ncss are implemented over shared communication resources , most often over digital channels .",
    "the impact of such communication infrastructures on control systems has been studied in the last decade @xcite .",
    "in particular the applicability of wireless communications in ncss has been discussed in @xcite among others .",
    "the delays introduced by these shared resources on the feedback loops are critical to guarantee stability and performance .",
    "furthermore , when several control loops are implemented over a shared communication channel , bandwidth becomes a scarce resource , the usage of which needs to be minimized by each controller .    for these reasons , the traditional time - triggered controller implementations ,",
    "i.e.  based on periodic sampling , are not suitable anymore . with the objective of minimizing the bandwidth usage , event - based approaches resulting in aperiodic controller updates",
    "have been proposed in @xcite .",
    "these aperiodic paradigms introduce a new challenge in the design : the scheduling of transmissions .",
    "a communication network has finitely many channels .",
    "the number of channels represents the maximum number of messages that can be sent simultaneously over the network .",
    "if the number of channels equals the number of control loops , we do not need any scheduler because every control loop has its own communication channel .",
    "however in practice , the number of channels is smaller than the number of control loops",
    ". thus we need a scheduler to decide which control loop has access to the network at any time instant while guaranteeing stability of all control loops .",
    "additionally the scheduler can optimize a certain combination of control performance and bandwidth usage . in the context of periodic traffic sources , or aperiodic with known deadlines a - priori ,",
    "there are well - studied scheduling techniques that are capable of guaranteeing certain delay bounds for the traffic @xcite . in the event - based context ,",
    "i.e.  sporadic traffic with unknown deadlines , the problem has been less studied and becomes more challenging @xcite . in @xcite ,",
    "the authors propose a joint design ( codesign ) of a control law and a scheduling law for several types of ncss .",
    "although the co - design strategy can improve the control performance significantly , if a new control loop is introduced to the ncss , the whole co - design procedure has to be executed again , which can be extremely time consuming . in order to mitigate this issue , we propose an approach that separates the design of controllers and schedulers .    in this paper",
    ", we design a scheduler for a set of ncss over a shared communication network ( cf .",
    "[ fig : ncs ] ) .",
    "our objective is avoiding communication conflict while guaranteeing stability of all ncss .",
    "each ncs is a linear - time - invariant ( lti ) system .",
    "the controllers are implemented in an event - triggered fashion where the delays between reading the state and updating the actuators are ignored @xcite . with respect to the shared communication network ,",
    "we assume it has a single communication channel . furthermore after each controller update , a pre - defined channel occupancy time elapses before the network is available .",
    "we consider schedulers that after each transmission of measurements , decide the policy for the next update .",
    "these policies can be to either let the next update be decided based on a triggering mechanism ( to be chosen among a set of them guaranteeing different performances ) or forced to be at an earlier pre - defined time .",
    "if we do not allow the scheduler to force earlier controller updates , the bandwidth usage is decreased at the cost of worse control performance ( or slower convergence ) . on the other hand",
    "if we allow the scheduler to force earlier controller updates , we obtain a better control performance ( or faster convergence ) at the cost of increased bandwidth usage . in this case",
    ", nothing prevents the scheduler from always using earlier updates and never use the event - triggering mechanism .",
    "this may result in an undesired over - use of the communication channel , and could be prevented by introducing costs to the model , which would result in priced timed game automata ( ptga ) .",
    "unfortunately to the best of our knowledge , no results are available in the literature allowing the synthesis of strategies over ptga with safety objectives .",
    "only the synthesis of strategies over ptga with a reachability objective are available @xcite .",
    "thus we propose an alternative approach to prevent the undesired schedule by limiting the consecutive earlier updates .",
    "the scheduling problem can be formulated as a timed safety game : given a model and a set of bad states , we seek to construct a strategy such that the model supervised by the strategy constantly avoids the bad states . in our problem ,",
    "the safety problem at hand is to avoid that update requests from a control loop happen while the network is in use by another task .",
    "we focus our attention to the design of a scheduler by leveraging techniques originally developed for network of timed game automata ( ntga ) @xcite .",
    "an ntga is the parallel composition of timed game automata ( tga ) , which are timed safety automata ( tsa ) in with the set of actions is partitioned into controllable and uncontrollable actions .",
    "we choose ntga modeling framework because of the following two reasons .",
    "first of all , it allows us to extend the methods in @xcite .",
    "the authors of @xcite discuss formal abstraction of the timing behavior of lti systems with event - triggered implementation as tsa .",
    "the second reason is that the solution of timed safety game over ntga can be computed by using backward algorithms @xcite or on - the - fly algorithms @xcite .",
    "moreover the algorithms have been implemented in some freely available software tools @xcite . the procedure to generate the scheduler ( or the strategy ) is as follows .",
    "first , we construct an ntga from a set of ncss .",
    "the ntga is obtained by taking the parallel composition of the tga associated with the network and with all control loops .",
    "then we characterize the bad states , i.e.  states corresponding to a communication conflict .",
    "finally the scheduler is defined as the solution of timed safety game over the ntga .    timed automata ( ta ) @xcite are a general modeling framework for a wide range of real - time systems , such as in web services @xcite , audio / video protocols @xcite , bounded retransmission protocols @xcite , collision avoidance protocols @xcite and commercial field bus protocols @xcite .",
    "timed safety automata ( tsa ) @xcite are a simplified version of ta . in order to enforce progress properties , tsa use local invariant conditions whereas ta use bchi or muller accepting conditions .",
    "the scheduling problem over ta and its variants has been already studied in the literature e.g.  applied to the scheduling of a steel plant , a job shop and a task graph in @xcite , @xcite , and @xcite , respectively .",
    "furthermore the optimal scheduling of a production w.r.t .  a predefined cost for a finite time horizon has been investigated in @xcite . in this case , the models are ta with weights ( or costs ) on both locations and edges , so called priced timed automata in @xcite and weighted timed automata in @xcite .",
    "finally the optimal scheduling for infinite time horizon is discussed in @xcite .",
    "the rest of this manuscript is structured as follows .",
    "section [ sec : modelprel ] recalls some modeling frameworks and preliminaries .",
    "section [ sec : scheduling ] proposes a procedure to synthesize a conflict - free scheduler .",
    "two experimental results are discussed in section [ sec : case ] .",
    "the first experiment allows the scheduler to force earlier controller updates where the number of consecutive earlier updates is limited to 4 .",
    "the second experiment does not allow the scheduler to force earlier controller updates .",
    "in this experiment , the scheduler can choose the triggering coefficient among three choices .",
    "finally the conclusions and possible future research directions are summarized in section [ sec : concl ] .",
    "a timed automaton ( ta ) @xcite is a finite automaton ( namely , a directed graph containing finitely many nodes and finitely many labeled edges ) extended with real - valued variables , which is usually employed to model real - time systems .",
    "the real - valued variables model logical clocks , that are initialized to zero when the system is started and thereafter increase synchronously at the same rate .",
    "we shall refer to these variables as simply  clocks \" .",
    "clock constraints are used to restrict the behavior of the automaton .",
    "an edge transition can be taken when the edge is enabled .",
    "edges are enabled if the values of the clocks satisfy the guard conditions associated with the edge . additionally , some clocks may be reset to zero when an edge is taken .",
    "originally , bchi and muller accepting conditions are used to enforce progress properties @xcite . a simplified version called timed safety automata @xcite uses local invariant conditions to specify progress properties .",
    "in this work , we focus on timed safety automata and refer them as timed automata for simplicity .    we define @xmath0 as the set of finitely many clocks , @xmath1 as the set of finitely many actions and @xmath2 as the set of natural numbers including zero @xmath3 .",
    "a clock constraint is a conjunctive formula of atomic constraints of the form @xmath4 or @xmath5 for @xmath6 , @xmath7 and @xmath8 .",
    "clock constraints will be used as guards on edges and location invariants .",
    "we use @xmath9 to denote the set of clock constraints .",
    "[ def : ta ] a timed automaton @xmath10 is a sextuple + @xmath11 where    * @xmath12 is a set of finitely many locations ( or nodes ) ; * @xmath13 is an initial location ; * @xmath1 is a set of finitely many actions ; * @xmath0 is a set of finitely many real - valued clocks ; * @xmath14 is a set of edges ; * @xmath15 assigns invariants to locations . denotes the power set of @xmath0",
    "]    location invariants are restricted to constraints that are downwards closed , in the form : @xmath16 or @xmath17 where @xmath18 is a clock and @xmath8 .",
    "sometimes we write @xmath19 when @xmath20 . furthermore we write @xmath21 to denote the existence of an edge from @xmath22 to @xmath23 with arbitrary labels .",
    "the semantics of a ta are defined as a transition system where a state consists of the current location and the current value of clocks .",
    "there are two types of transitions between states depending on whether the automaton : delays for some time ( a delay transition ) , or takes an enabled edge ( a discrete transition ) .",
    "to keep track of clock values , we use functions known as clock assignments @xmath24 and we employ @xmath25 ( @xmath26 satisfies @xmath27 ) to denote that the clock values of @xmath26 satisfy the guard @xmath27 . for @xmath28 , let @xmath29 denote the clock assignment that maps all @xmath30 to @xmath31 . for a set of clocks @xmath32 , let @xmath33 $ ] denote the clock assignment that maps all clocks in @xmath34 to 0 and agrees with @xmath26 for the rest of clocks in @xmath35 .",
    "the semantics of a timed automaton is a transition system ( also known as a timed transition system ) in which states are pairs of location @xmath22 and clock assignment @xmath26 , and transitions are defined by the rules :    * delay transition : @xmath36 if @xmath37 and @xmath38 for a non - negative real number @xmath39 ; * discrete transition : @xmath40 if @xmath19 , @xmath25 , @xmath41 $ ] and @xmath42 .",
    "a run of a timed automaton is a sequence of alternating delay and discrete transitions in the transition system .",
    "we denote by @xmath43 the set of runs of timed automaton @xmath10 starting from the initial state @xmath44 where @xmath45 is a clock assignment that maps all @xmath30 to 0 . additionally , if @xmath46 is a finite run , the last state of the run is denoted by @xmath47 .",
    "the set of actions ( cf",
    ".  definition [ def : ta ] ) is assumed to consists of symbols for input actions @xmath48 , output actions @xmath49 and internal actions @xmath50",
    ". synchronous communication between different ta is done by hand - shake synchronization using input and output actions .",
    "to model concurrent systems , several tas can be extended with parallel composition that takes into account the synchronous communication .",
    "parallel composition of tas is also called network of timed automata ( nta ) .",
    "essentially the parallel composition of a set of tas is the product of the tas .",
    "building the product timed automaton is an entirely syntactical but computationally expensive operation .",
    "the reader is referred to ( * ? ? ?",
    "5 ) for an example on the composition of two tas .",
    "the semantics of an nta are defined as a transition system where a state consists of a vector of current locations and the current value of clocks in all tas @xcite .",
    "a timed game automaton is a timed automaton in which the set of actions is partitioned into controllable and uncontrollable actions .",
    "the former are actions that can be triggered by the controller , whereas the latter only by the environment / opponent .",
    "[ def : tga ] a timed game automaton @xmath51 is a septuple @xmath52 where    * @xmath53 is a timed automaton ; * @xmath54 is a set of controllable actions ; * @xmath55 is a set of uncontrollable actions ; * @xmath56 .",
    "similar to ta , tga can also be extended with parallel composition ( essentially the synchronized cartesian product of tga ) .",
    "the parallel composition of tgas is called a  network of timed game automata \" ( ntga ) which is formally defined as :    [ def : tga - composition ] let @xmath57 @xmath58 be a timed game automaton for @xmath59 .",
    "the parallel composition of @xmath60 , @xmath61 , @xmath62 denoted by @xmath63 is a timed game automaton @xmath64 where    * @xmath65 ; * @xmath66 ; * @xmath67 ; * @xmath68 ; * @xmath69 ; * @xmath70 is defined according to the following two rules : * * a ta makes a move on its own via its internal action : the edge is controllable iff the internal action is controllable ; * * two tas move simultaneously via a synchronizing action : the edge is controllable iff both input and output actions are controllable ( i.e.  the environment has priority over the controller ) ; * @xmath71 .    in the parallel composition of tgas",
    ", a pair of input and output actions is denoted as a single action .",
    "thus the sets @xmath54 and @xmath55 do not contain any input and output actions . a synchronizing action",
    "should be defined as an element of @xmath54 if it is controllable and an element of @xmath55 if it is not controllable . in definition",
    "[ def : tga - composition ] , let us remark that both @xmath54 and @xmath55 do not contain synchronizing actions for simplicity .",
    "any controllable synchronizing action is denoted by @xmath50 , whereas any uncontrollable synchronizing action is denoted by @xmath72 .",
    "given an ntga , we are interested in solving the following safety objective : is it possible to find a strategy for the triggering of controllable actions guaranteeing that a set of pre - specified bad states are never reached regardless of what and when uncontrollable actions take place ?",
    "more formally given an ntga and a set of bad states @xmath73 , we seek to construct a strategy @xmath74 such that the ntga supervised by @xmath74 constantly avoids @xmath73 .",
    "a strategy @xcite is a function that during the course of a game constantly gives information about what the controller should do in order to win the game . at any given situation",
    ", the strategy could suggest the controller to either `` take a particular controllable action '' or `` do nothing at this point in time '' , i.e. delay , which will be denoted by the symbol ( controllable action ) @xmath75 .    [",
    "def : strategy ] let @xmath76 @xmath77 be a timed game automaton . we define @xmath78 as the timed automaton derived from the timed game automaton .",
    "a strategy @xmath74 over @xmath51 is a partial function from @xmath43 to @xmath79 s.t .",
    "for every finite run @xmath46 , if @xmath80 then @xmath81 for some @xmath82 .    a strategy @xmath74 over @xmath51",
    "is called state - based or memoryless whenever @xmath83 implies @xmath84 , for each @xmath85 .",
    "the restricted behavior of an ntga controlled with some strategy @xmath74 is defined by the notion of outcome @xcite .",
    "a strategy @xmath74 is winning from a state if all maximal runs @xcite in the outcome originated from that state are winning .",
    "a state is winning if there exists a winning strategy @xmath74 from that state .",
    "the winning states can be computed by using backward algorithms @xcite or on - the - fly algorithms @xcite .",
    "software tools are also available that solve safety control problems , e.g.  the implementation from verimag @xcite or uppaal - tiga @xcite , which implement the backward and on - the - fly algorithms respectively .",
    "we consider linear - time - invariant ( lti ) systems of the form @xmath86 where @xmath87 and @xmath88 are matrices of appropriate dimensions .",
    "we assume the existence of linear state - feedback laws @xmath89 rendering the closed - loop system globally asymptotically stable , where @xmath90 is a matrix of appropriate dimensions . assume a sample - and - hold implementation of the control law is in place keeping the input signal constant between update times , i.e. @xmath91 where @xmath92 is a divergent sequence of update times .",
    "for simplicity of presentation , we ignore the presence of delays between reading the state and updating the actuators .",
    "the interested reader is referred to @xcite for more details , including accounting for delays .    in event - triggered implementations ,",
    "the sequence of update times is decided on run - time based on the state of the plant @xcite .",
    "let @xmath93 represent the solution of - .",
    "we define an auxiliary variable @xmath94 representing the difference between the sampled state @xmath95 and the current state @xmath93 of the system : @xmath96 the event - triggering approach in @xcite , proposes the following sampling triggering law : @xmath97 where @xmath980 , \\bar\\sigma [ \\subset \\mathbb{r}^+$ ] is the triggering coefficient , which establishes a trade off between quality of control ( convergence rate to the equilibrium ) and the amount of transmissions triggered .",
    "the inter - sample time of the state @xmath99 , denoted by @xmath100 , is defined as the time between consecutive updates when the sampled state is @xmath99 : @xmath101      in @xcite , the authors propose an approach to characterize the sampling behavior of lti systems with event - triggered implementation as tas .",
    "the approach abstracts the spatial and temporal dependencies of the original system .",
    "the following definitions summarize the approach .",
    "the set of reachable states or the flow pipe at the time interval @xmath102 $ ] from a set of initial states @xmath103 is denoted by @xmath104}(x_0 ) = \\bigcup_{t \\in [ t_1,t_2 ] } \\ { \\xi(t )",
    "\\mid \\xi(0 ) \\in x_0 \\}.\\ ] ]    [ def : lti2ta - arman ] a timed automaton abstracting the triggering timing behavior of system - with triggering coefficient @xmath105 is given by + @xmath106 where    * @xmath107 ; * @xmath108 such that @xmath109 ; * @xmath110 ; * @xmath111 ; * @xmath112 if @xmath113}(\\mathcal r_s^{\\sigma } ) \\cap \\mathcal r_t^{\\sigma } \\neq \\emptyset$ ] ; * @xmath114 for all @xmath115 .",
    "each location @xmath116 of this ta , is associated with a set of possible states @xmath99 of the system .",
    "we abuse slightly notation denoting both the location and the associated region with the same symbol @xmath117 .",
    "the suggestion in @xcite is to partition the state space of the control system in conic regions pointed at the origin , each of which would be associated to a location of the ta .",
    "the ta has one clock variable @xmath18 that represents the time elapsed since the last update .",
    "according to @xcite , given a fixed sampled state , the inter - sample time is uniquely defined , i.e.  it is deterministic . in general ,",
    "when the sampled state is different , the inter - sample time is also different .",
    "the notation @xmath118 and @xmath119 represents the lower and upper bounds of the inter - sample time for sampled states in @xmath116 . in @xcite",
    "it is shown formally that the ta abstracts the timing behavior of the event - triggered system , implying that : @xmath120.\\ ] ]    in principle it could happen that @xmath121 for some states @xmath99 of the system . in practice , one would always impose a maximum time between transmissions to maintain a minimum level of feedback .",
    "this practical solution is suggested in @xcite to guarantee having always @xmath122 , as otherwise the ta model would become useless for scheduling purposes .    from definition [ def : lti2ta - arman ]",
    "it is also trivial to see that if @xmath123 then @xmath124 , with @xmath125 being one of the end locations in the set of edges with starting location @xmath116 .",
    "the outgoing edges of @xmath116 are enabled if the time elapsed since the last update is between @xmath118 and @xmath119 .",
    "only one action denoted by @xmath50 is present in this model , and since taking any edge is interpreted as updating the input value , all edges are labeled with action @xmath50 and reset the clock variable .",
    "note that the system may remain in location @xmath116 for at most @xmath119 time units , as a triggering event is guaranteed to happen before that instant . a graphical representation of a simple ta of the form of those from definition [ def : lti2ta - arman ] is shown in fig .  [ fig : ta - lti - arman ] .",
    "is omitted in the figure . ]",
    "consider a set of event - triggered networked control systems ( ncss ) sharing a common communication channel ( cf .",
    "[ fig : ncs ] ) .",
    "each control loop consists of a sensor , a plant , an actuator , and a controller , interconnected through the shared communication network .",
    "assume that the network can be used by at most one control loop at any time instant .",
    "if several control loops request access to the channel while the network is in use a conflict arises , and at most one control loop will be chosen nondeterministically to access the network .",
    "while in time - triggered control systems these type of problems can be prevented by appropriate scheduling , when one or several control - loops are event - triggered a - priori scheduling is a much more challenging task because of the unknown update times .    in this section , we propose an approach based on ntga to avoid such conflicts .",
    "we consider schedulers that after each update of a control loop ( transmission of measurements , computation of control and transmission of actuation signal to actuators ) decide whether the next update time of each control loop should :    * be based on a triggering mechanism selected from a set of finitely many triggering coefficients @xmath126 ; or * forced to be at a pre - defined time ( earlier than the minimum expected inter - sample time ) .",
    "we synthesize scheduling strategies by : constructing an ntga from a set of ncss ( cf .",
    "section [ sec : scheduling - model ] ) , characterizing the bad states , i.e.  states corresponding to a communication conflict ( cf .",
    "section [ sec : scheduling - spec ] ) , and finally synthesizing a supervising strategy ensuring that the ntga avoids the bad states .      in",
    "what follows , we describe the procedure employed to construct an ntga from a given set of event - based ncss .",
    "we start constructing a tga associated with the shared communication network .",
    "next , for each event - triggered control loop , we generate a tga as a modification of the ta described in section [ sec : modelprel - abs ] .",
    "finally , the ntga is obtained by taking the parallel composition of the tga associated with the network and with all control loops .",
    "denote the tga corresponding to the shared communication network by @xmath127 ( cf .",
    "definition [ def : tga - net ] ) .",
    "@xmath127 has three locations @xmath128 , @xmath129 and @xmath130 , where the initial location is @xmath128 ( cf .",
    "[ fig : tga - cu ] ) .",
    "the location @xmath128 represents the network being available , @xmath129 represents the network being used by a control loop and @xmath130 represents a conflict occured . the active location changes from @xmath128 to @xmath129 when a control loop requests access to the channel to perform an update , which also forces the reset of the clock variable @xmath18 . the channel is occupied for @xmath131 time units before the network is freed again to service the control tasks .",
    "during this time , the active location is @xmath129 , and after that time the active location changes to @xmath128 .",
    "when the active location is @xmath129 and another control loop requests access then the active location changes to @xmath130 .",
    "once the network enters the location @xmath130 , the network can not leave the location , i.e.  @xmath130 is an absorbing location . notice that this is a somewhat conservative model , as we consider every control loop occupies the channel the whole time @xmath131 .",
    "one could trivially adjust this simple model , and the subsequent work , to associate different occupancy times to different control loops .",
    "[ def : tga - net ] let @xmath131 represent the maximum channel occupancy time , a timed game automaton associated with the communication network is given by @xmath132 @xmath133 where    * @xmath134 ; * @xmath135 ; * @xmath136 ; * @xmath137 ; * @xmath138 ; * @xmath139 + @xmath140 ; * @xmath141 , + @xmath142 , @xmath143 .",
    "the guard @xmath144 represents a condition that is always satisfied , for example @xmath145 .",
    "given a control loop , we construct the timed game automata @xmath146 allowing a supervisor ( scheduler ) to either : force earlier controller updates than those dictated by the event - triggering mechanism , or choose a triggering coefficient for the event - triggering mechanism .",
    "[ def : lti2ta - cl ] consider a set of timed automata @xmath147 generated from an event - triggered control loop with triggering coefficient @xmath1480,\\bar\\sigma[$ ] for @xmath149 and assume that @xmath150 for all @xmath115 .",
    "+ consider also a set of earlier update time parameters @xmath151 , such that @xmath152 then , the timed game automata @xmath153 is given by + @xmath154 where    * @xmath155 ; * @xmath156 such that @xmath157 ; * @xmath158 ; * @xmath159 ; * @xmath160 ; * @xmath161 + @xmath162 ; * @xmath163 , + @xmath164    in model just introduced , we use separate locations associated to each triggering coefficient and introduce the additional locations @xmath165 and @xmath166 for @xmath115 .",
    "both the locations @xmath165 and @xmath167 represent that the sampled state is in @xmath168 . in location",
    "@xmath165 the scheduler has not chosen the triggering coefficient , whereas in location @xmath167 the scheduler has chosen triggering coefficient @xmath169 .",
    "since the scheduler can choose the triggering coefficient , the edges from @xmath170 to @xmath171 are labeled with the controllable action @xmath172 . after choosing the triggering coefficient ,",
    "the scheduler is allowed to either : force earlier controller updates , or use the event - triggering mechanism ( based on the chosen triggering coefficient ) .",
    "if the scheduler decides to use the event - triggering mechanism , while staying in location @xmath167 , the strategy is `` do nothing '' .",
    "this ensures that the outgoing edge to @xmath166 is not taken .",
    "when the value of @xmath18 is between @xmath173 and @xmath174 , the event - triggering mechanism is activated . in this case , the edges from @xmath171 to @xmath175 labeled with the uncontrollable action @xmath176 are enabled .",
    "recall that the scheduler can not choose the exact update time when using the event - triggering mechanism .",
    "this also implies that the scheduler can not choose the region containing the next sampled state .",
    "if the scheduler decides to force earlier controller updates , the scheduler will take the edge to @xmath166 when that edge is enabled . in this case",
    ", the scheduler is able to choose the exact update time .",
    "thus , the edges from @xmath171 to @xmath166 are labeled with the controllable action @xmath50 . in location @xmath166 ,",
    "the time can not elapse and one of the outgoing edges has to be taken immediately . since the scheduler can not choose the region containing the next sampled state , the outgoing edges of @xmath166 are labeled with the uncontrollable action @xmath176 .",
    "the outgoing edges are defined as follows : there exists an edge from @xmath166 to @xmath177",
    "if @xmath178}(\\mathcal r_s^{\\sigma_1 } ) \\cap \\mathcal r_t^{\\sigma_1 } \\neq \\emptyset \\}$ ] . a graphical representation of a tga generated by definition [ def : lti2ta - cl ] is shown in fig .  [ fig : tga - cl - ex ] .        in this subsection",
    ", we assume the initial conditions of the lti system are a subset of a region .",
    "if the initial conditions are intersected with a set of regions @xmath179 , we can modify the tga generated by definition [ def : lti2ta - cl ] as follows .",
    "introduce a new location called @xmath180 with invariant @xmath181 and define @xmath180 as the initial location . then , define edges from @xmath180 to every location in @xmath182 with guard @xmath183 , action @xmath72 and without resetting the clock .",
    "finally , action @xmath72 is defined as an uncontrollable action . in the above modification",
    ", the environment has to choose one of the locations corresponding to initial conditions when the system is started .",
    "a graphical representation of the tga representing this situation is depicted in fig .",
    "[ fig : tga - cl - r0-ex ] .        switching between different",
    "triggering coefficients or triggering earlier does not hinder stability .",
    "consider lyapunov function @xmath184 satisfying @xmath185 , with @xmath186 for the system ( [ eqn : lti - system ] ) with continuous feedback @xmath187 .",
    "it has been shown in @xcite that selecting a triggering coefficient @xmath188 , with @xmath189 an appropriate constant depending on the lti dynamics and the state - feedback gain , the event - triggered controller implementation ( [ eqn : lti - sample - hold])-([eqn : tabtrig ] ) satisfies @xmath190 , with @xmath191 for @xmath192 .",
    "in fact , the triggering mechanism guarantees that @xmath193 in the interval @xmath194 $ ] , for all @xmath195 . since @xmath196 for all @xmath149 , switching between different triggering coefficients guarantees that @xmath197 , with @xmath198 .    finally ,",
    "if the system is forced to employ earlier triggering the assumption : @xmath199 guarantees that the update occurs in the interval @xmath200 $ ] , and thus @xmath197 , which concludes the proof .    as it was mentioned in the beginning of section [ sec : scheduling - model ] ,",
    "the ntga associated with a set of ncss , denoted by @xmath201 , is obtained by taking the parallel composition of the tga associated with the network and with all control loops . in other words , @xmath202 where @xmath203 , @xmath204 , represents the tga associated with the @xmath205-th control loop .",
    "the state of @xmath201 is described by a @xmath206-tuple @xmath207 where @xmath208 is the location of @xmath127 , @xmath209 is the location of @xmath203 , @xmath210 is the clock assignment of @xmath127 and @xmath211 is the clock assignment of @xmath203 , for @xmath204 .",
    "we are interested in finding a strategy such that the trajectories of the ntga never enter the states corresponding to a conflict .",
    "recall that a conflict corresponds to the following situation : a control loop is requesting updates when the communication network is busy . in our ntga model ,",
    "conflicts are captured by the active location of @xmath127 becoming @xmath130 .",
    "thus the set of states we aim at avoiding @xmath73 contains all states such that the location of @xmath127 is @xmath130 , i.e. @xmath212      if we allow the scheduler to force earlier controller updates , nothing prevents the scheduler from always using such type of updates and never employ the event - triggering mechanism . in this section",
    ", we discuss an approach to prevent the undesired schedule by limiting the consecutive earlier updates .",
    "in this approach , once a pre - specified limit has been reached , the scheduler is forced to use an event - triggering mechanism .    for this purpose",
    "we employ global integer variables , which are an extended feature of uppaal - tiga modeling language to ease the modeling task but not part of the standard definition of tga ( cf .  definition [ def : tga ] ) .",
    "we define a global integer constant @xmath213 representing the maximum consecutive earlier updates , and a global integer variable @xmath214 to be used as a counter of consecutive earlier updates .",
    "a variable is global if it can be accessed by all tgas .",
    "finally , the resulting tga is defined as follows .",
    "[ def : lti2ta - cl - max ] consider a set of timed automata @xmath147 generated from an event - triggered control loop with triggering coefficient @xmath1480,\\bar\\sigma[$ ] for @xmath149 and assume that @xmath150 for all @xmath115 .",
    "+ consider also some constant @xmath213 and a set of earlier update time parameters @xmath151 , such that @xmath152 then , the timed game automata with options for earlier update , choice of triggering coefficients and limiting the consecutive earlier updates is given by @xmath215 where    * @xmath216 ; * @xmath217 such that @xmath157 ; * @xmath218 ; * @xmath219 ; * @xmath220 ; * @xmath221 + @xmath222 + @xmath223 + @xmath224 + @xmath225 ; * @xmath226 .",
    "there are two differences between definition [ def : lti2ta - cl - max ] and definition [ def : lti2ta - cl ] .",
    "first , in the edges from @xmath167 to @xmath166 , we add condition @xmath227 to the guard and add statement @xmath228 to the reset .",
    "the additional condition is used to guarantee that the counter of consecutive earlier updates is always smaller than or equal to its maximum .",
    "the statement on the reset is used to increase the counter variable by one , once an earlier update happens . recall that an earlier update happens when one of these edges is taken ( cf .",
    "section [ sec : scheduling - model - lti ] ) .",
    "second , in the edges from @xmath167 to @xmath175 , we add the statement @xmath229 to the reset .",
    "recall that taking these edges represents the event - triggering mechanism is used ( cf .  section [ sec : scheduling - model - lti ] ) .",
    "thus the counter of consecutive earlier updates is reset to zero .",
    "notice that the variable @xmath214 takes values in @xmath230 .    note that with the presented implementation , either of the control loops may exhibit an arbitrary number of consecutive earlier triggerings .",
    "this is because the maximum number of consecutive earlier triggerings being a global counter .",
    "the counter is reset to zero whenever any of the control loops runs in event - triggered fashion . by employing more counters",
    ", one could easily generalize this idea to limit the number of consecutive earlier triggerings for each loop .",
    "after these modifications , the ntga associated to the set of ncss becomes @xmath231 where @xmath232 represents the tga associated with the @xmath205-th control loop for @xmath204 . in this new ntga",
    ", the state of @xmath201 is described by a @xmath233-tuple @xmath234 which includes the additional counter @xmath214 .",
    "it follows that the bad states @xmath73 are now given by @xmath235      formally , a scheduler implements a strategy @xmath74 , see definition [ def : strategy ] , for the ntga @xmath201 . the strategy @xmath74 is applied to @xmath201 providing , based on the run @xmath46 of @xmath201 up to that time instant the controllable action @xmath236 that guarantees the satisfaction of the desired specification .",
    "this means in practice that after each discrete transition of the ntga , i.e. every time a transmission is placed on the network , first the strategy chooses a triggering coefficient .",
    "then the strategy decides which control loop is updated and also its update mechanism : early or event triggered .",
    "after such a transition , and possibly after some time elapses , the environment chooses the conic region containing the next sampled state , which results in a discrete transition of the ntga , and the procedure is repeated .",
    "let us illustrate the use of strategies on an example consisting of two control loops , two triggering coefficients @xmath237 and an option for earlier updates .",
    "the initial location of the first and second control loop is @xmath238 and @xmath239 , respectively .",
    "initially the run of @xmath201 is @xmath240 after each update , the scheduler selects a triggering coefficient , according to the strategy @xmath74 .",
    "suppose that the scheduler chooses @xmath241 for the first control loop , i.e.  @xmath242 .",
    "the resulting run is @xmath243 if the scheduler chooses @xmath244 for the second control loop , i.e.  @xmath245 , the run becomes @xmath246 then the scheduler follows the strategy to decide which control loop is updated and also its update mechanism : early or event triggered .",
    "suppose that the strategy decides to update the first control loop earlier at time @xmath247 .",
    "first , the scheduler delays the system @xmath248 then an earlier update is performed , i.e.  @xmath249 .",
    "notice that action @xmath50 is the internal action associated with the first control loop .",
    "we have run @xmath250 since time can not elapse in @xmath251 , the environment has to choose the conic region containing the next sampled state immediately . if the environment chooses @xmath252 , the result is run @xmath253 notice that @xmath127 and the tga associated with the first control loop move simultaneously via synchronizing action @xmath254 .",
    "input action @xmath255 belongs to @xmath127 , whereas output action @xmath176 belongs to the tga corresponding to the first control loop .",
    "then the scheduler follows the strategy to select a triggering coefficient for the first control loop , for example @xmath244 ,",
    "i.e.  @xmath256 .",
    "the network is available again after @xmath131 time units , resulting in the runs : @xmath257 while the network is being used , and @xmath258 once the network is released .",
    "notice that action @xmath50 is the internal action associated with @xmath127 .",
    "note that this kind of scheduler is a centralized scheduler that needs to have a perfect overview of the transmissions placed on the network , and the control loop responsible for it .",
    "furthermore , given that the locations of @xmath201 are related to the actual sampled states transmitted through the network , the scheduler also needs to be able to read the content of the transmitted data .",
    "we showcase the results in an example comprising two event - triggered ncss sharing the same communication network .",
    "the first control loop is given by @xcite @xmath259 & \\upsilon = \\begin{bmatrix } 1 & -4 \\end{bmatrix } \\xi .",
    "\\end{array } \\label{eqn : lti - ex-1}\\ ] ] the second control loop is given by @xcite @xmath260 & \\upsilon = \\begin{bmatrix } 1.02 & -5.62 \\end{bmatrix } \\xi .",
    "\\end{array } \\label{eqn : lti - ex-2}\\ ] ]    in the sequel , we discuss two experimental results for the above example .",
    "each experiment is characterized by four parameters : the number of conic regions @xmath261 , the set of triggering coefficients @xmath262 , the set of earlier update parameters @xmath263 and maximum consecutive earlier triggering @xmath213 .",
    "axis represent the network is being used by and , respectively .",
    "the top and bottom plots represent the result of experiments discussed in sections [ sec : case-1 ] and [ sec : case-2 ] , respectively.,title=\"fig : \" ] +   axis represent the network is being used by and , respectively .",
    "the top and bottom plots represent the result of experiments discussed in sections [ sec : case-1 ] and [ sec : case-2 ] , respectively.,title=\"fig : \" ]      in this experiment , the minimum channel occupancy time is @xmath264 , the number of conic regions is @xmath265 and there is one triggering coefficient @xmath266 .",
    "the input value can be updated 0.005 time units before the lower bound in all regions , i.e.  @xmath267 and @xmath268 for all @xmath115 .",
    "the maximum consecutive earlier triggering is @xmath269 .",
    "we create a model in uppaal - tiga according to definition [ def : lti2ta - cl - max ] : the tga for , and the shared communication network are denoted @xmath270 , @xmath271 and @xmath272 , respectively .",
    "the specification is given by    .... control : a [ ] not ( net.bad ) ....    a strategy is generated with uppaal - tiga to satisfy this specification .",
    "to illustrate the type of strategies synthesized , we show in the following a fragment of the strategy generated by uppaal - tiga for the situation in which the locations of @xmath270 , @xmath271 and @xmath272 are @xmath273 , @xmath273 and @xmath128 , respectively .",
    ".... state : ( tgat.r1a1 tgah.r1a1 net.idle )    earnum=3 when you are in ( 25<=tgah.c & & tgat.c<65 & & tgah.c - tgat.c<=-35 )    || ( 85<tgat.c & & 25<=tgah.c & & tgat.c<105 & & tgah.c<=30 )    || ( 38<tgat.c & & 25<=tgah.c & & tgat.c - tgah.c<=30 & & tgah.c<=30 )    || ( 25<=tgah.c & & tgat.c<31 & & tgah.c - tgat.c<=-5 )    || ( 25<=tgah.c & & tgat.c - tgah.c<=-5 & & tgah.c<=30 ) , take transition tgah.r1a1->tgah.ear1    { c > = 25 & & c < = 30 & & earnum < earmax , up ! , 1 }    net.idle->net.inuse { 1 , up ? , c : = 0 } when you are in ( 105<=tgat.c & & tgat.c < = 111 & & tgah.c<25 ) , take transition tgat.r1a1->tgat.ear1    { c > = 105 & & c < = 111 & & earnum < earmax , up ! , 1 }    net.idle->net.inuse { 1 , up ? , c : = 0 } ....    as shown above , two different conditions , based on the clock values of @xmath270 , clock values of @xmath271 and the difference of clock values in @xmath270 and @xmath271 , can be appreciated : if the first one is satisfied , an early update is forced for @xmath271 where the inter - sample time is between 25 and 30 ; if the second condition is satisfied , an early update is forced for @xmath270 where the inter - sample time is between 105 and 111 .",
    "if none of the conditions are satisfied , no early update is forced , i.e.  the strategy is to let time elapses for both loops .",
    "the strategy generated by uppaal - tiga was applied to the two ncss - , with both systems initialized at the state @xmath274^t$ ] , corresponding to @xmath275 in both of the timing abstractions for the systems .",
    "the network status is shown in fig .  [ fig : sim - tab - het - etc - trig ] ( top ) , where long and short bars represent event - triggered and earlier update mechanisms , respectively . note that while either of the control loops may exhibit an arbitrary number of consecutive triggerings , the maximum number of consecutive earlier triggerings is respected to be below 4 as this counter is a shared ( global ) one that is reset to zero whenever any of the two loops run in event - triggered fashion . during the time horizon of 10 , the input of is updated 63 times consisting of 50 earlier updates and 13 event - triggering mechanisms . for",
    ", the input is updated 152 times consisting of 121 earlier updates and 31 event - triggering mechanisms . the state and input trajectories",
    "are shown in fig .",
    "[ fig : sim - tab - het - etc - early - v2a ] .    .",
    "the solid and dashed lines are the trajectories of and , respectively.,title=\"fig : \" ] + .",
    "the solid and dashed lines are the trajectories of and , respectively.,title=\"fig : \" ] + .",
    "the solid and dashed lines are the trajectories of and , respectively.,title=\"fig : \" ]      in this experiment , the minimum channel occupancy time is @xmath264 , the number of conic regions is @xmath265 and there are three triggering coefficients @xmath276 , @xmath277 and @xmath278 .    we create again a model in uppaal - tiga according to definition [ def : lti2ta - cl ] : the tga for , and the shared communication network are denoted @xmath270 , @xmath271 and @xmath272 , respectively .",
    "the specification is the same as in section [ sec : case-1 ] and again we generate a strategy using uppaal - tiga .",
    "the following is a fragment of the strategy generated by uppaal - tiga when the location of @xmath270 , @xmath271 and @xmath272 is @xmath279 , @xmath280 and @xmath128 , respectively .",
    ".... state : ( tgat.r37 tgah.r38a1 net.idle ) when you are in ( tgat.c==0 & & 145<tgah.c & & tgah.c<=154 ) , take transition tgat.r37->tgat.r37a1 { c = = 0 , tau , 1 } when you are in ( tgat.c==0 & & 65<=tgah.c & & tgah.c<=102 ) , take transition tgat.r37->tgat.r37a2 { c = = 0 , tau , 1 } when you are in ( tgat.c==0 & & 102<tgah.c & & tgah.c<=145 )     || ( tgat.c==0 & & 5<=tgah.c & & tgah.c<65 ) , take transition tgat.r37->tgat.r37a3 { c = = 0 , tau , 1 } ....    notice that now there are three conditions : if the @xmath205-th condition is satisfied , the location of @xmath270 is forced to transit to @xmath281 for @xmath282 .    the strategy generated by uppaal - tiga",
    "is applied to the ncss - , both with the state initialized at @xmath274^t$ ] , corresponding in both cases with the initial location is @xmath275 . the network status is shown in fig .  [ fig : sim - tab - het - etc - trig ] ( bottom ) .",
    "short , medium and long bars represent event - triggered with triggering coefficient equals @xmath244 , @xmath241 and @xmath283 , respectively . during the first 10 time units , the input of is updated 84 times consisting of 56 updates using @xmath244 , 6 updates using @xmath241 and 22 updates using @xmath283 . for , the input is updated 182 times consisting of 106 updates using @xmath244 , 26 updates using @xmath241 and 50 updates using @xmath283 . the state and input trajectories",
    "are shown in fig .",
    "[ fig : sim - tab - het - etc - const ] .    .",
    "the solid and dashed lines are the trajectories of and , respectively.,title=\"fig : \" ] + .",
    "the solid and dashed lines are the trajectories of and , respectively.,title=\"fig : \" ] + .",
    "the solid and dashed lines are the trajectories of and , respectively.,title=\"fig : \" ]",
    "we have provided an approach to synthesize conflict - free scheduling policies for sets of networked control systems ( ncss ) with the possibilities of updating the input value according to an event - triggering mechanism , selectable from a set of them , or earlier than the time dictated by such an event - triggering rule . as indicated in section [",
    "sec : scheduling - limit ] the main limitations of this proposed scheduling scheme is its centralized nature , and the fact that the scheduler needs to be able to read the content of the messages sent through the network .",
    "the approach is nonetheless applicable to many setups encountered in practice in which different control systems are interconnected through a bus , e.g.  can , ethercat or flexray . in such systems , every element connected to the bus can see the traffic flowing through the network . while it may be the case that the precise content of messages is not available ( e.g.  for potential security reasons ) , it is worth noting that for the scheduler only the abstracted state , i.e. the region @xmath170 , is relevant",
    ". therefore we can envisage implementations or practical applications in which this sort of scheduling could be easily adopted .    in wireless settings ,",
    "the event - triggered paradigm offers great benefits for energy consumption reduction , but network topologies can be in general more complex than a simple bus type of configuration .",
    "therefore , interesting extensions of this work to allow decentralized scheduling , possibly including network topological constraints , would enable broader applicability of these techniques .",
    "current and future work is focusing on these issues , extensions of the abstraction of the timing of event - triggered systems beyond lti systems with state - feedback , and on the implementation of a tool - box automating the whole timing abstraction and scheduler synthesis proposed in @xcite and the current paper respectively .",
    "j.  liu , a.  gusrialdi , d.  obradovic , and s.  hirche , `` study on the effect of time delay on the performance of distributed power grids with networked cooperative control , '' in _ proceedings of the 1st ifac workshop on estimation and control of networked systems _",
    ", 2009 , pp . 168173 .",
    "rzn , a.  bicchi , s.  hailes , k.  johansson , and j.  lygeros , `` on the design and control of wireless networked embedded systems , '' in _ ieee computer aided control system design , _ , oct .",
    "2006 , pp . 440445 .",
    "m.  rabi and k.  h. johansson , `` event - triggered strategies for industrial control over wireless networks , '' in _ proc .",
    "4th annual int .",
    "wireless internet_.1em plus 0.5em minus 0.4emicst ( institute for computer sciences , social - informatics and telecommunications engineering ) , 2008 , p.  34",
    ".    m.  mazo  jr . and",
    "p.  tabuada , `` decentralized event - triggered control over wireless sensor / actuator networks . ''",
    "_ ieee transactions on automatic control , special issue on wireless sensor actuator networks _ , vol .",
    "56 , no .",
    "24562461 , oct .",
    "k.  strm and b.  bernhardsson , `` comparison of riemann and lebesgue sampling for first order stochastic systems , '' in _ proceedings of the 41th ieee conference on decision and control ( cdc02 ) _ , vol .  2 , dec .",
    "2002 , pp . 20112016 .",
    "m.  velasco , j.  fuertes , and p.  marti , `` the self triggered task model for real - time control systems , '' in _ proceedings of the 24th ieee real - time systems symposium ( work in progress ) _",
    ", 2003 , pp . 6770 .",
    "a.  cervin and t.  henningsson , `` scheduling of event - triggered controllers on a shared network , '' in _ proceedings of the 47th ieee conference on decision and control ( cdc08 ) _ , dec .",
    "2008 , pp . 36013606 .",
    "s.  al - areqi , d.  gorges , s.  reimann , and s.  liu , `` event - based control and scheduling codesign of networked embedded control systems , '' in _ proceedings of the 32nd american control conference ( acc13 ) _ , jun .",
    "2013 , pp . 52995304 .",
    "s.  al - areqi , d.  gorges , and s.  liu , `` stochastic event - based control and scheduling of large - scale networked control systems , '' in _ proceedings of the european control conference _ , jun .",
    "2014 , pp . 23162321 .",
    "s.  reimann , s.  al - areqi , and s.  liu , `` an event - based online scheduling approach for networked embedded control systems , '' in _ proceedings of the 32nd american control conference ( acc13 ) _ , jun .",
    "2013 , pp . 53265331 .",
    "bouyer , f.  cassez , e.  fleury , and k.  larsen , `` optimal strategies in priced timed game automata , '' in _ foundations of software technology and theoretical computer science ( fsttcs04 ) _ , ser .",
    "lecture notes in computer science , k.  lodaya and m.  mahajan , eds.1em plus 0.5em minus 0.4emspringer , heidelberg , 2005 , vol .",
    "3328 , pp . 148160 .",
    "l.  de  alfaro , t.  henzinger , and r.  majumdar , `` symbolic algorithms for infinite - state games , '' in _ concurrency theory ( concur01 ) _ , ser .",
    "lecture notes in computer science , k.  larsen and m.  nielsen , eds.1em plus 0.5em minus 0.4emspringer , heidelberg , 2001 , vol . 2154 , pp .",
    "536550 .",
    "f.  cassez , a.  david , e.  fleury , k.  larsen , and d.  lime , `` efficient on - the - fly algorithms for the analysis of timed games , '' in _ concurrency theory ( concur05 ) _ , ser .",
    "lecture notes in computer science , m.  abadi and l.  de  alfaro , eds.1em plus 0.5em minus 0.4emspringer , heidelberg , 2005 , vol . 3653 , pp .",
    "6680 .",
    "a.  ravn , j.  srba , and s.  vighio , `` modelling and verification of web services business activity protocol , '' in _ tools and algorithms for the construction and analysis of systems ( tacas11 ) _ , ser .",
    "lecture notes in computer science , p.  abdulla and k.  leino , eds.1em plus 0.5em minus 0.4emspringer , heidelberg , 2011 , vol .",
    "6605 , pp . 357371 .",
    "k.  havelund , a.  skou , k.  larsen , and k.  lund , `` formal modeling and analysis of an audio / video protocol : an industrial case study using uppaal , '' in _ proceedings of the 18th ieee real - time systems symposium ( rtss97 ) _ , dec .",
    "1997 , pp . 213 .",
    "p.  dargenio , j .-",
    "katoen , t.  ruys , and j.  tretmans , `` the bounded retransmission protocol must be on time ! '' in _ tools and algorithms for the construction and analysis of systems ( tacas97 ) _ , ser .",
    "lecture notes in computer science , e.  brinksma , ed.1em plus 0.5em minus 0.4em springer , heidelberg , 1997 , vol .",
    "1217 , pp .",
    "416431 .",
    "y.  abdeddam and o.  maler , `` job - shop scheduling using timed automata ? '' in _ computer aided verification ( cav01 ) _ , ser .",
    "lecture notes in computer science , g.  berry , h.  comon , and a.  finkel , eds.1em plus 0.5em minus 0.4emspringer , heidelberg , 2001 , vol .",
    "2102 , pp . 478492 .",
    "g.  behrmann , e.  brinksma , m.  hendriks , and a.  mader , `` scheduling lacquer production by reachability analysis  a case study , '' in _ proceedings of the 16th ifac world congress_.1em plus 0.5em minus 0.4emelsevier , 2005 .",
    "g.  behrmann , a.  fehnker , t.  hune , k.  larsen , p.  pettersson , j.  romijn , and f.  vaandrager , `` minimum - cost reachability for priced time automata , '' in _ hybrid systems : computation and control ( hscc01 ) _ , ser .",
    "lecture notes in computer science , m.  di  benedetto and a.  sangiovanni - vincentelli , eds.1em plus 0.5em minus 0.4emspringer , heidelberg , 2001 , vol . 2034 , pp .",
    "147161 .",
    "r.  alur , s.  la  torre , and g.  pappas , `` optimal paths in weighted timed automata , '' in _ hybrid systems : computation and control ( hscc01 ) _ , ser .",
    "lecture notes in computer science , m.  di  benedetto and a.  sangiovanni - vincentelli , eds.1em plus 0.5em minus 0.4em springer , heidelberg , 2001 , vol .",
    "2034 , pp .",
    "4962 .",
    "j.  bengtsson and w.  yi , `` timed automata : semantics , algorithms and tools , '' in _ lectures on concurrency and petri nets _ , ser .",
    "lecture notes in computer science , j.  desel , w.  reisig , and g.  rozenberg , eds.1em plus 0.5em minus 0.4emspringer , heidelberg , 2004 , vol . 3098 , pp .",
    "87124 .",
    "g.  behrmann , a.  david , and k.  larsen , `` a tutorial on uppaal , '' in _ formal methods for the design of real - time systems ( sfm - rt04 ) _ , ser .",
    "lecture notes in computer science , m.  bernardo and f.  corradini , eds .",
    ", vol . 3185.1em plus 0.5em minus 0.4emspringer , heidelberg , sep .",
    "2004 , pp .",
    "200236 .",
    "l.  hetel , a.  kruszewski , w.  perruquetti , and j .-",
    "richard , `` discrete and intersample analysis of systems with aperiodic sampling , '' _ ieee transactions on automatic control _",
    "56 , no .  7 , pp . 16961701 , jul ."
  ],
  "abstract_text": [
    "<S> we discuss the scheduling of a set of networked control systems implemented over a shared communication network . </S>",
    "<S> each control loop is described by a linear - time - invariant ( lti ) system with an event - triggered implementation . </S>",
    "<S> we assume the network can be used by at most one control loop at any time instant and after each controller update , a pre - defined channel occupancy time elapses before the network is available . in our framework </S>",
    "<S> we offer the scheduler two options to avoid conflicts : using the event - triggering mechanism , where the scheduler can choose the triggering coefficient ; or forcing controller updates at an earlier pre - defined time . </S>",
    "<S> our objective is avoiding communication conflict while guaranteeing stability of all control loops . </S>",
    "<S> we formulate the original scheduling problem as a control synthesis problem over a network of timed game automata ( ntga ) with a safety objective . </S>",
    "<S> the ntga is obtained by taking the parallel composition of the timed game automata ( tga ) associated with the network and with all control loops . </S>",
    "<S> the construction of tga associated with control loops leverages recent results on the abstraction of timing models of event - triggered lti systems . in our problem , the safety objective is to avoid that update requests from a control loop happen while the network is in use by another task . </S>",
    "<S> we showcase the results in some examples . </S>"
  ]
}