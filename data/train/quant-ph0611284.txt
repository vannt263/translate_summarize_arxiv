{
  "article_text": [
    "the one - way measurement model is a framework for quantum computation , first presented in  @xcite .",
    "transformations of quantum states in the one - way measurement model are essentially described by a sequence of single - qubit measurements ( where the choice of measurement may depend on earlier measurement results in a straightforward way ) performed on a many - qubit entangled state .",
    "the many - qubit system includes some number of _ input qubits _",
    "@xmath3 in an unknown initial state , and a collection of auxiliary qubits prepared in the @xmath4 state .",
    "these are operated on by a collection of entangling operations , described by a graph @xmath0 whose edges @xmath5 are pairs of qubits operated on by two - qubit controlled-@xmath6 operations .",
    "after the sequence of measurements , any qubits left unmeasured still support a quantum state , and are interpreted as an _ output system _ @xmath7 .",
    "algorithms in the one - way model may be obtained by translating from the circuit model : we may decompose a unitary operation @xmath8 into one- and two - qubit unitaries which have known implementations in the one - way model ( e.g. hadamards , @xmath9 gates , and controlled-@xmath6 gates ) , and compose the operations for these unitaries to find an algorithm for the composite unitary @xmath8 .",
    "we may then transform the measurement algorithm so that all of the entangling operations are performed first .",
    "is it possible to develop measurement algorithms without reference to the circuit model ?",
    "one proposal  @xcite reduces the problem of implementing a unitary in the one - way model to a problem of expressing the complex coefficients of the unitary operator to be implemented in terms of sums of roots of unity , which define an entanglement graph through their ratios . doing this",
    "requires that one determine the order in which the measurements are to be made .",
    "this may be done by making use of a _ flow _ in the sense introduced in  @xcite , which is a property of just the entanglement graph and the vertex sets @xmath1 .    in this article ,",
    "i describe how to efficiently determine whether a graph @xmath0 ( together with input / output vertices @xmath3 and @xmath7 ) has a flow in the sense of  @xcite , for the special case @xmath2 corresponding to algorithms performing unitary transformations ( as opposed to general unitary embeddings ) .",
    "this is done by characterizing flows in terms of a families of vertex - disjoint paths , and proving that these are unique ( when they exist ) in the case of @xmath2 .",
    "this allows flows to be constructed efficiently , when they exist , by reduction to solved problems on directed graphs .",
    "in this section , we will review the one - way measurement model , and the concept of a flow which pertains to it . for basic definitions in graph theory",
    ", readers may refer to diestel s excellent text  @xcite .      for a graph @xmath0",
    ", we write @xmath10 for the set of vertices and @xmath11 for the set of edges of @xmath0 . similarly , for a directed graph ( or _ digraph _ ) @xmath12 , we write @xmath13 for the set of vertices and @xmath14 for the set of directed edges ( or _ arcs _ ) of @xmath12 . if @xmath15 and @xmath16 are adjacent , we let @xmath17 denote the edge between them in a graph , and @xmath18 denote an arc from @xmath15 to @xmath16 in a digraph .",
    "when a graph @xmath0 is clear from context , we will write @xmath19 for the adjacency relation in @xmath0 . we will use the convention that digraphs may contain loops on a single vertex and multiple edges between two vertices , but that undirected graphs have neither ; and @xmath20 will denote the non - negative integers .",
    "computations in the one - way measurement model are described by a sequence of primitive operations on a set of qubits @xmath21 . using the notation of  @xcite , the permitted operations are :    * _ preparation maps _",
    "@xmath22 , which perpare a qubit @xmath23 in the @xmath4 state ; * _ entangling operations _",
    "@xmath24 , which perform a controlled-@xmath6 operation on qubits @xmath25 ; * _ correction operations _ consisting of @xmath26 or @xmath6 operations on single qubits ; * _ measurement operations _",
    "@xmath27 , which perform a measurement of a single qubit @xmath28 in an orthonormal basis of states in the equator of the bloch sphere .",
    "the measurements @xmath29 may be described by observables of the form @xmath30 ; this operator has eigenvectors @xmath31 , with @xmath32 having eigenvalue @xmath33 and @xmath34 having eigenvalue @xmath35 .",
    "the operator @xmath36 represents measuring the qubit @xmath28 using the projector @xmath37 , and recording the eigenvalue of the result as a bit @xmath38 ( referred to as the _ measurement signal _ )   exists after measurement , and so it is generally ignored as a part of any output state ; however , if it does exist , complete information about its state is provided by the values of @xmath39 and @xmath38 . ] .",
    "later correction or measurement operations can depend on the value of @xmath38 , which is referred to as _ classical feed - forward _ of measurement results .    when using the measurement - based quantum computation to perform `` quantum - to - quantum '' operations ( i.e. to transform quantum states ) , we identify two special sets of qubits : the set of _ input qubits _",
    "@xmath3 , which are not operated on by a preparation map , and the set of _ output qubits _",
    "@xmath7 , which are not measured .",
    "the initial state of the qubits in @xmath3 may be arbitrary , and represents the input of the measurement algorithm ; and the qubits of @xmath7 retain a final quantum state , which represents the output of the algorithm .",
    "a valid algorithm is any sequence of the above operations with the following properties :    each qubit is prepared  at most once and measured at most once ;    no operation may depend on a measurement signal @xmath38 before the qubit @xmath28 has been measured ;    the first operation performed on a qubit @xmath40 is a preparation map ;    the last operation performed on a qubit @xmath41 is a measurement .",
    "algorithms can be condensed by allowing the measurement operations to depend on the results of previous measurements , and by performing all entanglement operations towards the beginning of the algorithm .",
    "let @xmath42 be a boolean expression : then , using the equalities    [ eqn : correctioncommute ] @xmath43    we may postpone all correction operations until the end of the algorithm , and perform all preparation / entangling operations at the beginning .",
    "this allows us to describe measurement algorithms in the usual way with the preparation of an entangled resource ( an _ open graph state _ , depending on the initial state of the input qubits @xmath3 ) , with measurement and correction operations performed on it ; and where the angles of measurements may depend on the signals produced by earlier measurements .",
    "note that measurements of the form @xmath44 are performed with respect to the same basis as @xmath29 , but with the two basis elements @xmath45 interchanged whenever @xmath46 .",
    "rather than changing the angle of measurement by @xmath47 depending on the value of @xmath42 , we may add the value of the expression @xmath42 to the measurement result @xmath38 to obtain a modified result @xmath48 .",
    "equivalently , in the algebraic representation of the measurement algorithm , we may substitute @xmath38 wherever it occurs in a correction of measurement dependency with the expression @xmath49 : this substitution is called _ signal shifting _ in  @xcite .",
    "thus , without loss of generality , we may describe unitary transformations using measurement - based algorithms where , if all measurement results are @xmath33 , no adaptation of the measurement angles is required , nor are corrections on the final output system .",
    "this prompts the question of whether we can design algorithms _ in terms of _ the behaviour when all the measurement results are @xmath33 .",
    "considering the outward differences between the one - way measurement model and the circuit model could lead to new techniques for developing quantum algorithms , as proposed by  @xcite .",
    "however , an apparent obstacle to directly devising algorithms in the one - way model is that measurements bases and final corrections on the output qubits may depend on many measurement signals .",
    "these details are essential , and raises the questions of the order in which measurements are to be performed , and what measurement dependencies are required .",
    "unfortunately , this complicates any direct understanding of how to perform operations in the one - way measurement model , without e.g.  translating from the circuit model .",
    "given a graph , and a collection of measurements which yield a particular operation in the special case where all measurement results come out @xmath33 , the problem described above can be solved if we can determine a measurement sequence and signal dependencies from the entanglement graph itself , along with the sets of input and output vertices .",
    "[ discn : inferbyproduct ] in such a sequence of operations , we may treat each measurement @xmath36 as post - selecting the state of the whole system so that @xmath28 is in the state @xmath32 ; should the opposite result occur , the final corrections and the intermediate changes in measurement angles are equivalent to performing a correction immediately after the measurement on @xmath28 to bring about the state that would have arisen had @xmath32 been the result .",
    "we may do this if we can infer suitable by - product operations for each measurement : this can be done if the entanglement graph has a flow property introduced in  @xcite .",
    "[ dfn : causalflow ] a _ geometry _",
    "@xmath50 is an entanglement graph @xmath0 , together with subsets @xmath1 representing the sets of input and output vertices of a measurement algorithm .",
    "a _ flow _ on @xmath51 is an ordered pair @xmath52 , with a function @xmath53 and a partial order   for all @xmath15 ) , transitive ( @xmath54 and @xmath55 imply @xmath56 ) , and anti - symmetric ( @xmath54 and @xmath57 only if @xmath58 ) . ]",
    "@xmath59 on @xmath10 , such that the conditions    @xmath60    hold for all vertices @xmath61 and @xmath62 .",
    "we will refer to @xmath63 as the _ successor function _ of the flow , and @xmath59 as the _ causal order _ of the flow .",
    "examples of geometries with flows .",
    "arrows indicate the action of a successor function @xmath53 , along _ undirected _ edges .",
    "causal orders @xmath59 for each example are given by hasse diagrams ( read from left to right ) . in the right - most example , the two vertices @xmath64 and @xmath65 are _ incomparable _ , i.e. there is no order relation between them . ]",
    "[ fig : examplesflow ] and  [ fig : examplenoflow ] illustrate examples of geometries with and without flows .",
    "the conditions ( [ flow : i ] )    ( [ flow : iii ] )  are meant to capture a simple set of conditions , independent of the angles of the measurements , which are sufficient to determine how to adapt measurement angles and perform corrections to perform unitary transformations .",
    "specifically , it captures when the by - product operations for each measurement @xmath66 can be considered to consist of a single @xmath26 operation on some qubit @xmath67 , and @xmath6 operations on each qubit @xmath68 .",
    "the above is not a _ necessary _ condition for a geometry @xmath51 to permit unitary evolution independently of the measurements performed ( see  @xcite for a generalization ) , but it is sufficient .",
    "the partial order @xmath54 then represents when such a byproduct operation @xmath69 for the measurement on @xmath15 acts non - trivially on @xmath16 . if we insert the operation @xmath69 after the measurement on @xmath15 ( deleting the pauli operation on @xmath15 itself ) in a measurement algorithm consisting only of preparation maps , entanglers , and measurements , these corrections will be absorbed into the measurements on the qubit @xmath67 and each of the qubits @xmath68 . performing such substitutions / absorptions for all of the qubits to be measured , the order @xmath59 then describes chains of measurement dependencies   and a qubit @xmath68 , the by - product operation for the measurement on @xmath15 does not change the basis of measurement for @xmath16 , but it does change the significance of a @xmath32 or @xmath34 at @xmath16 for future measurements or corrections , as a @xmath6 correction on @xmath16 interchanges these two states .",
    "so , more precisely , we have @xmath54 if the either measurement angle for @xmath70 may change sign depending on the signal @xmath71 , or if @xmath72 and there is an @xmath26 or @xmath6 correction on @xmath16 which depends on @xmath15 . ] .",
    "thus , having a flow allows us to infer a sequence of measurements , and suitable dependencies for those measurements , providing a solution to the problem described towards the beginning of this section .",
    "this makes it easier to design quantum algorithms directly in the one - way measurement model , by obtaining complete sequencess of measurement operations from only partial information .",
    "this motivates the problem of efficiently determining when a geometry has a flow .     a geometry with no flow .",
    "also shown is a particular injection @xmath53 , and the coarsest pre - order satisfying conditions ( [ flow : ii ] )  and ( [ flow : iii ] )   see the discussion on page   preceding definition  [ dfn : viciouscircuit ] . ]",
    "in order to determine whether a geometry @xmath51 has a flow , it is useful to understand the sorts of structures which are induced or forbidden in @xmath0 by the presence of a flow .",
    "we begin with a restriction of the concept of a _ path cover _ to geometries :    [ dfn : pathcover ] let @xmath51 be a geometry .",
    "a collection @xmath73 of ( possibly trivial ) directed paths in @xmath0 is a _ path cover _ of @xmath51 if    each @xmath74 is contained in exactly one path ( i.e. the paths cover @xmath0 and are vertex - disjoint ) ;    each path in @xmath73 is either disjoint from @xmath3 , or intersects @xmath3 only at its initial point ;    each path in @xmath73 intersects @xmath7 only at its final point .    in the case",
    "@xmath2 , a path cover of @xmath51 will just be a collection of vertex - disjoint paths from @xmath3 to @xmath7 which covers all the vertices of @xmath0 .    for a flow @xmath75 ,",
    "there is a natural connection between the successor function @xmath63 and path covers for the geometry @xmath51 , which we capture in the following lemma :    [ lemma : orbitpathcover ] let @xmath52 be a flow on a geometry @xmath51 .",
    "then there is a path cover @xmath76 of @xmath51 , where @xmath18 is an arc in some path of @xmath76 if and only if @xmath77 .",
    "let @xmath75 be a flow on @xmath51 .",
    "suppose that @xmath78 for some @xmath79 . by condition  ( [ flow : i ] ) , we have @xmath80 ; and by condition  ( [ flow : iii ] ) , we have @xmath54 .",
    "similarly , we have @xmath57 , so @xmath58 .",
    "thus @xmath63 is an injective function .",
    "define a digraph @xmath81 on the vertices of @xmath0 , and with arcs @xmath82 for @xmath61 . because @xmath63 is both a function and injective ,",
    "every vertex in @xmath81 has maximal out - degree and maximal in - degree @xmath83 .",
    "thus , @xmath81 is a collection of vertex - disjoint dipaths , dicycles , and closed walks of length @xmath84 .",
    "as well , for every arc @xmath85 , we have @xmath54 ; by induction ,",
    "@xmath56 whenever there is a dipath from @xmath15 to @xmath86 in @xmath81",
    ". then if @xmath15 and @xmath86 are such that there are dipaths from @xmath15 to @xmath86 and from @xmath86 to @xmath15 , then @xmath56 and @xmath87 , in which case @xmath88 and the dipaths are trivial .",
    "thus , @xmath81 is acyclic , so @xmath81 consists entirely of vertex - disjoint dipaths .",
    "let @xmath76 be the collection of maximal dipaths in @xmath81 .",
    "we show that @xmath76 satisfies each of the criteria of definition  [ dfn : pathcover ] :    any vertex @xmath28 which is neither in @xmath89 nor @xmath90 will be isolated in @xmath81 : then , the trivial path on @xmath28 is an element of @xmath76 .",
    "all other vertices are in either @xmath89 or @xmath90 , and so are contained in a non - trivial path of @xmath76 .",
    "as these paths are vertex - disjoint , each vertex is contained in exactly one path .",
    "each vertex in @xmath3 has in - degree @xmath33 , and so may only occur at the beginning of any path in @xmath76 .",
    "the vertices in @xmath81 which have out - degree @xmath33 are precisely the output vertices @xmath7 : therefore one must occur at the end of every path , and they may only occur at the end of paths in @xmath76 .",
    "then @xmath76 is a path cover , whose paths contain only arcs @xmath82 , as required",
    ".    it will prove useful to discuss functions @xmath63 which are not necessarily the successor function of a flow @xmath52 , but which nonetheless are related to a path cover in the sense of lemma  [ lemma : orbitpathcover ] .",
    "thus , we will extend our usage of the term _ successor function _ to include the following definition :    [ dfn : successorfn ] let @xmath73 be a path cover for a geometry @xmath51 .",
    "then the _ successor function of @xmath73 _ is the unique @xmath53 such that @xmath77 if and only if @xmath18 is an arc in some path of @xmath73 .",
    "if a function @xmath53 is a successor function of _ some _ path - cover of @xmath51 , we may call @xmath63 a _ successor function of @xmath51_.    in the case where @xmath2 , the successor function of a geometry @xmath51 is bijective .",
    "this allows us to define the additional useful terminology :    let @xmath73 be a path cover for a geometry @xmath51 with @xmath2 .",
    "predecessor function _ of @xmath73 is the unique @xmath91 such that @xmath92 if and only if @xmath18 is an arc in some path of @xmath73 .",
    "given that the successor function of a flow for @xmath51 induces a path cover , one might think of also trying to obtain a flow from a path cover .",
    "there is an obvious choice of binary relation which we would like to consider , which satisfies conditions  ( [ flow : ii ] )  and  ( [ flow : iii ] ) :    [ dfn : naturalpreorder ] let @xmath63 be a successor function for @xmath51 .",
    "the _ natural pre - order   @xmath59 for @xmath63 _ is the transitive closure on @xmath10 of the conditions    @xmath93    for all @xmath94 .",
    "recall from section  [ sec : flowsmeasmodel ] the description of causal orders @xmath59 for flows in terms of chains of measurement dependencies arising from byproduct operations : we have @xmath54 if there is a sequence of vertices @xmath95 such that the byproduct operator for the measurement on @xmath96 acts non - trivially on @xmath97 for each @xmath98 .",
    "we are then interested in when a natural pre - order @xmath59 is antisymmetric , in which case it provides a well - defined order for measurements .",
    "it is easy to show that the natural pre - order @xmath59 for @xmath63 is a partial order if and only if @xmath63 is the successor function of a flow .",
    "if @xmath59 is a partial order , it will be the coarsest partial order such that @xmath52 is a flow .",
    "however , it is easy to construct geometries and successor functions @xmath63 for which the natural pre - order @xmath59 is not a partial order .",
    "one example [ discn : cyclegeometry ] is the geometry @xmath51 illustrated in fig .",
    "[ fig : examplenoflow ] on page  , with @xmath0 equal to the cycle @xmath99 , @xmath100 , and @xmath101 .",
    "for any successor function @xmath63 on this geometry , condition  ( [ naturaliii ] )  forces either @xmath102 or @xmath103 to hold . because @xmath104 , @xmath105 , and @xmath106 are distinct , such a relation @xmath59 is not antisymmetric , so it is not a partial order . in this case , we have not only a cyclic graph , but a cycle of relationships induced by condition  ( [ naturaliii ] ) .",
    "the following definitions are aimed to characterize these cyclic relations in terms of closed walks .",
    "[ dfn : viciouscircuit ] let @xmath51 be a geometry , and @xmath107 a family of directed paths in @xmath0 .",
    "a walk @xmath108 is an _ influencing walk _  _ as defined in section  3.3 of  @xcite .",
    "the term `` influencing walk '' is due to broadbent and kashefi , who examine their role in the depth complexity of unitaries in the one - way measurement model  @xcite , and identified them as objects of interest after reading an earlier draft of this article . ] for @xmath107 if it is a concatenation of zero or more paths ( called _ segments _ of the influencing walk ) of the following two types :    * @xmath18 , where this is an arc in some path of @xmath107 ; * @xmath109 , where @xmath110 is an arc in some path of @xmath107 and @xmath111 is not covered by @xmath107 .",
    "a _ vicious circuit _ for @xmath107 is a closed influencing walk for @xmath107 with at least one segment .",
    "a non - trivial influencing walk @xmath112 of @xmath107 must start with an arc in some path of @xmath107 ; and that of any two consecutive edges of @xmath112 , at least one is an arc in some path of @xmath107 .",
    "then , it is easy to see that the decomposition of @xmath112 into its segments is unique : the initial segment is of the first type if and only if the first two edges are arcs of @xmath107 , is of the second type otherwise .",
    "the entire walk can be decomposed recursively in this fashion .",
    "[ dfn : causalpathcover ] let @xmath51 be a geometry . a path cover @xmath73 for @xmath51 is a _ causal path cover _ if @xmath73 does not have any vicious circuits in @xmath0 .",
    "the two types of segments which build an influencing walk correspond to the flow conditions  ( [ flow : ii ] )  and  ( [ flow : iii ] ) : influencing walks again represent chains of dependencies induced by byproduct operations .",
    "specifically :    [ lemma : influencingnatlpreorder ] let @xmath73 be a path cover for @xmath51 with successor function @xmath63 , and let @xmath59 be the natural pre - order of @xmath63",
    ". then @xmath54 if and only if there is an influencing walk for @xmath73 from @xmath15 to @xmath16 .    to show that @xmath54 if there is an influencing walk from @xmath15 to @xmath16 , we proceed by induction on the number of segments of the influencing walk .",
    "if the number of segments of the influencing walk is zero , then @xmath58 , in which case @xmath54 .",
    "otherwise , suppose the proposition holds for all influencing walks for @xmath73 with fewer than @xmath113 segments for some @xmath114 , and that there is an influencing walk @xmath115 from @xmath15 to @xmath16 ( for some vertex - sequence @xmath116 ) which has @xmath113 segments .",
    "* if the final segment of @xmath112 is @xmath117 , then @xmath118 is an influencing walk of @xmath119 segments , so @xmath120 . because we also have @xmath121 , from the definition of the natural pre - order we have @xmath122 . *",
    "if the final segment of @xmath112 is @xmath123 , then @xmath124 is an influencing walk of @xmath119 segments , so @xmath125 . because we also have @xmath126 , from the definition of the natural pre - order we have @xmath54 .",
    "conversely : from the definition of @xmath59 as a transitive closure , if @xmath54 for some @xmath127 , there is a sequence of vertices @xmath128 for some @xmath129 such that @xmath130 , @xmath131 , and either @xmath132 or @xmath133 holds for each @xmath98 .",
    "then , define the paths @xmath134 for each @xmath98 : the walk @xmath135 obtained from concatenating these paths is a walk from @xmath15 to @xmath16 , and in particular an influencing walk .",
    "this equivalence allows us to characterize flows in terms of paths and circuits in the graph :    [ thm : graphth - charn ] let @xmath51 be a geometry with path cover @xmath73 , @xmath63 be the successor function of @xmath73 , and @xmath59 be the natural pre - order for @xmath63 .",
    "then the following are equivalent :    [ graph - charn - i ] @xmath73 has no vicious circuits ;    [ graph - charn - ii ] @xmath59 is a partial order ;    [ graph - charn - iii ] @xmath75 is a flow .    in particular , a geometry has a flow iff it has a causal path cover .    by construction",
    ", @xmath75 fails to be a flow if and only if @xmath59 is not a partial order ( i.e. if and only if it is not anti - symmetric ) .",
    "thus @xmath136 .",
    "if @xmath59 is not anti - symmetric , then there are distinct @xmath94 such that @xmath54 and @xmath57 : by lemma  [ lemma : influencingnatlpreorder ] , there is then an influencing walk @xmath112 with at least one segment from @xmath15 to @xmath16 , and also an influencing walk @xmath137 with at least one segment from @xmath16 to @xmath15 .",
    "then @xmath138 is an influencing walk with at least two segments from @xmath15 to itself , and is therefore a vicious circuit for @xmath73 ; then @xmath73 is not a causal path cover .",
    "conversely , if @xmath73 is not a causal path cover , then there is a vicious circuit @xmath139 for @xmath73 : if @xmath140 , then @xmath141 and @xmath142 are both influencing walks , in which case @xmath143 ; otherwise , @xmath144 and @xmath145 are both influencing walks for @xmath73 , in which case @xmath146 .",
    "thus @xmath147 .",
    "characterizing flows in terms of causal path covers allows us to shift the emphasis from the constructibility of a causal order @xmath59 to the absence of vicious circuits . by using successor and predecessor functions",
    ", we may show that requiring vicious circuits to be absent for a path cover yields a strong uniqueness result :    [ thm : uniquefamilypaths ] let @xmath51 be a geometry such that @xmath2 .",
    "if @xmath51 has a causal path cover @xmath73 , then @xmath73 is also the only maximum collection of vertex - disjoint dipaths from @xmath3 to @xmath7 .",
    "suppose that @xmath73 is a path cover for @xmath51 with successor function @xmath53 , and suppose there is a maximum - size collection @xmath107 of vertex - disjoint @xmath3  @xmath7 dipaths which differs from @xmath73 .",
    "let @xmath148 be the set of vertices not covered by @xmath107 : because @xmath149 , we have @xmath150 and @xmath151 , in which case @xmath107 is a path cover for the geometry @xmath152",
    ". then , let @xmath153 be the predecessor function of @xmath107 as a path cover of @xmath152 .    because @xmath73 and @xmath107 differ , there must exist a vertex @xmath61 such that @xmath82 is not an arc in some path of @xmath107 .",
    "note also that for @xmath154 , @xmath155 holds only if @xmath156 ; that is , @xmath157 .",
    "then , define a vertex sequence @xmath158 in @xmath0 by setting @xmath130 , @xmath159 , and @xmath160                  \\ ; g'(u_j )   \\ ; , & \\!\\ !    \\text{$u_j",
    "\\notin s$ and $ u_j = f(u_{j-1})$ }              \\end{cases }      \\end{aligned}\\ ] ] for all @xmath161 .",
    "[ fig : exampleinflconstr ] illustrates this construction .",
    "an influencing walk for a path cover @xmath73 ( solid arrows ) induced by another maximum collection @xmath107 of vertex - disjoint paths from @xmath3 to @xmath7 ( hollow arrows ) .",
    "the shaded area is a subset of the set @xmath148 not covered by @xmath107 . ]    clearly @xmath162 for all @xmath163 .",
    "we also have @xmath164 an arc in some path of @xmath73 , and for any @xmath161 such that @xmath165 is not an arc of @xmath73 , it follows that @xmath166 , in which case we have @xmath132 , which implies @xmath165 is an arc in some path of @xmath73 .",
    "then for any @xmath167 , the walk @xmath168 is an influencing walk in @xmath0 .",
    "because @xmath0 is a finite graph , the pigeon hole principle implies that there must be integers @xmath169 with @xmath170 , @xmath171 , and @xmath172 .",
    "because @xmath173 is an influencing walk , at least one of @xmath174 or @xmath175 is an arc in some path of @xmath73 . in the former case ,",
    "the closed walk @xmath176 is an influencing walk , and thus a vicious circuit ; otherwise , @xmath177 is an influencing walk , and thus a vicious circuit . in either case",
    ", there exists a vicious circuit for @xmath73 , in which case @xmath73 is not a causal path cover .",
    "thus , if @xmath73 is a causal path cover , there can be no such vertex sequence @xmath158 as defined above , and so there can be no maximum family of vertex - disjoint @xmath3 ",
    "@xmath7 paths @xmath107 which differs from @xmath73 .",
    "note that for @xmath2 , because a causal path cover of @xmath51 is unique if it exists , and the successor function of any flow will also be the successor function of a causal path cover , there is at most one successor function @xmath63 which yields a flow for @xmath51 .",
    "because the natural pre - order @xmath59 for @xmath63 is coarser than any other valid causal order for @xmath63 , it too is unique .",
    "then , a `` mimumum - depth '' flow for a geometry @xmath51 is unique in the case @xmath2 .",
    "theorem  [ thm : uniquefamilypaths ] allows us to reduce the problem of finding a flow for @xmath51 when @xmath2 to finding a maximal collection @xmath73 of vertex - disjoint @xmath3 ",
    "@xmath7 paths , and then determining whether or not @xmath73 has vicious cycles .",
    "both steps can be expressed in terms of solved problems in directed graphs , and both can be solved in time @xmath178 , where @xmath179 , and @xmath180 .",
    "an upper bound on the number of edges that a geometry may have if it has a flow  @xcite allows us to further bound this by @xmath181 , where @xmath182 . in this section ,",
    "i give an outline for the solution of these results to show that a flow can be found efficiently when @xmath2 .",
    "finding a path cover for @xmath51 can be reduced to an instance of _ network flows_. a _ network _ is a directed graph @xmath183 with a designated _ source vertex _ @xmath184 and _ sink vertex _",
    "@xmath42 , and a capacity function @xmath185 representing the maximum rate at which some substance can pass through each arc . an _",
    "integral @xmath184 ",
    "@xmath42 network flow _ is a function @xmath186 such that @xmath187 for all @xmath188 , and where the `` net flow '' into a vertex @xmath189 , @xmath190 }      -          { \\left [ \\sum_{\\substack{\\scriptscriptstyle ( x { \\smallto}v ) \\\\\\scriptscriptstyle   \\in a(n ) } } \\phi(x { \\smallto}v ) \\right]}\\end{aligned}\\ ] ] is zero for @xmath191 .",
    "the _ value _ of the network flow @xmath192 is @xmath193 .",
    "we may start the reduction to network flows by augmenting the entanglement graph @xmath0 to a graph @xmath194 , adding a vertex @xmath184 which is adjacent to every vertex of @xmath3 , and a vertex @xmath42 which is adjacent to every vertex of @xmath7 .",
    "any collection of vertex - disjoint @xmath3@xmath7 paths then corresponds naturally to a collection of `` internally disjoint '' paths from @xmath184 to @xmath42 of the same size . by a construction presented in section  8.3 of  @xcite",
    ", we can then efficiently construct from @xmath194 a network @xmath183 with source @xmath184 and sink @xmath42 , such that every integral @xmath184 ",
    "@xmath42 network flow @xmath192 can be used to construct a collection of @xmath193 internally disjoint paths from @xmath184 to @xmath42 in @xmath194 .",
    "it then suffices to find a maximum integral network flow for @xmath183 .",
    "this is a well - studied problem : in the case where all edges have capacity @xmath83 , the ford - fulkerson algorithm ( see e.g.  @xcite , section  26.2 ) runs in time @xmath195 , where @xmath196 is the value of the maximum network flow , and where @xmath197 is the number of arcs in the network @xmath183 .",
    "having found a maximum - size collection @xmath107 of vertex - disjoint paths , we may determine if @xmath107 is a path cover simply by verifying that it covers all vertices : this may be done in time @xmath198 . if @xmath107 is not a path cover , @xmath51 has no flow by theorems  [ thm : graphth - charn ] and  [ thm : uniquefamilypaths ] .      to determine whether or not a path cover @xmath73 ( with successor function @xmath63 ) for @xmath51 has vicious circuits",
    ", we may create the digraph @xmath199 whose vertices are those of @xmath0 , and where @xmath200 iff there is an influencing walk for @xmath73 of at most one segment from @xmath15 to @xmath16 .",
    "then , @xmath73 has vicious circuits iff @xmath199 contains a directed cycle .",
    "tarjan s algorithm ( see e.g.  @xcite , section 3.1 ) is a simple algorithm for determining the _ strongly connected components _ of a directed graph @xmath12 : the equivalence classes of vertices which are mutually reachable by directed walks . in any circuit of @xmath199 ,",
    "all of the vertices are mutually reachable ; then , we can use tarjan s algorithm on @xmath199 to determine whether @xmath73 is a causal path cover . if @xmath199 contains two mutually reachable vertices",
    ", @xmath51 has no flows by theorems  [ thm : graphth - charn ] and  [ thm : uniquefamilypaths ] .",
    "because the natural pre - order @xmath59 for @xmath63 is characterized by influencing walks for @xmath73 , we have @xmath54 iff there is a directed path from @xmath15 to @xmath16 in @xmath199 . then , the problem of computing @xmath59 is equivalent to the problem of computing the _ transitive closure _ of @xmath199 : the directed graph @xmath201 in which there is an arc from @xmath15 to @xmath16 iff there is a non - trivial directed walk in @xmath199 from @xmath15 to @xmath16 .",
    "the transitive closure can also be computed by a modification of tarjan s algorithm : then , @xmath59 can computed at the same time as we are determining whether @xmath199 contains directed cycles ( i.e. whether or not @xmath59 is anti - symmetric ) .",
    "each path of @xmath73 is totally ordered by the pre - order @xmath59 : then , we can represent the relation @xmath59 efficiently through a _ chain decomposition _",
    " for each @xmath202 , we store the minimal element @xmath203 in each path @xmath204 such that @xmath205 . from theorem  3.11 of  @xcite , we can compute @xmath59 in time @xmath178 , where @xmath206 and @xmath180 . as remarked in the previous paragraph , we may determine whether @xmath59 is a partial order at the same time : if it is , @xmath75 is a flow for @xmath51 ; otherwise , @xmath51 has no flows .      for @xmath182 and @xmath207 ( but without requiring that @xmath3 and @xmath7 have the same number of elements ) ,",
    "an extremal result  @xcite shows that any geometry @xmath51 which has a flow has at most @xmath208 edges .",
    "thus , if @xmath0 has more than this number of edges , it can not have a flow .",
    "we can use this as a preliminary test for any geometry when deciding if it has a flow , aborting if @xmath0 has too many edges : if a geometry passes this test , the subroutines for finding the successor function @xmath63 and the partial order @xmath59 described above run in time @xmath181 .",
    "flows are a tool for analyzing the underlying geometry of measurement algorithms , which may make it feasible to develop algorithms in the one - way model without direct reference to the circuit model .",
    "we have seen how they can be characterized and efficiently found using tools of graph theory , in the special case where the input and output systems have the same number of qubits .",
    "one direction in which this work could be generalized is by considering the generalization of flows ( called `` gflows '' ) presented by browne , kashefi , mhalla , and perdrix  @xcite describe a which accommodate more complex byproduct operations for measurements .",
    "an efficient algorithm for finding such gflows would be a substantial advance in the line of investigation of finding appropriate byproduct operations .",
    "another question is whether similar work can be done in `` classical - to - classical '' measurement - based quantum computing , wherein all qubits are prepared and measured .",
    "is it possible to find sequences for measurement , and appropriate measurement dependencies , so that complete algorithms for universal quantum computation ( including the final measurements , and without initial states other than @xmath209 ) can be obtained in the one - way measurement model only from partial information ( the entanglement graph and the observables to be measured ) ?",
    "i would like to thank elham kashefi , who interested me in the problem of efficiently finding flows for geometries and for helpful discussions ; donny cheung and anne broadbent , who provided useful insights ; and rob raussendorf and lana sheridan , for their feedback on the presentation of the results of this paper .",
    "e.  nuutila .",
    "_ efficient transitive closure computation in large digraphs .",
    "_ acta polytechnica scandinavica , mathematics and computing in engineering series # 74 , helsinki ( 1995 ) .",
    "see also ` www.cs.hut.fi/~enu/thesis.html ` ."
  ],
  "abstract_text": [
    "<S> the one - way measurement model is a framework for universal quantum computation , in which algorithms are partially described by a graph @xmath0 of entanglement relations on a collection of qubits . a sufficient condition for an algorithm to perform a unitary embedding between two hilbert spaces is for the graph @xmath0 , together with input / output vertices @xmath1 , to have a _ flow _ in the sense introduced by danos and kashefi  @xcite . </S>",
    "<S> for the special case of @xmath2 , using a graph - theoretic characterization , i show that such flows are unique when they exist . </S>",
    "<S> this leads to an efficient algorithm for finding flows , by a reduction to solved problems in graph theory . </S>"
  ]
}