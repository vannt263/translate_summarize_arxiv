{
  "article_text": [
    "to protect digital content from unauthorized redistribution , distributors embed watermarks in the content such that , if a customer distributes his copy of the content , the distributor can see this copy , extract the watermark and see which user it belongs to . by embedding a unique watermark for each different user , the distributor can always determine from the detected watermark which of the customers is guilty .",
    "however , several users could cooperate to form a coalition , and compare their differently watermarked copies to look for the watermark .",
    "assuming that the original data is the same for all users , the differences they detect are differences in their watermarks .",
    "the colluders can then distort this watermark , and distribute a copy which matches all their copies on the positions where they detected no differences , and has some possibly non - deterministic output on the detected watermark positions . since the watermark does not match any user s watermark exactly ,",
    "finding the guilty users is non - trivial .",
    "in this paper we focus on the problem of constructing efficient collusion - resistant schemes for tracing pirates , which involves finding a way to choose watermark symbols for each user ( the traitor tracing code ) and a way to trace a detected copy back to the guilty users ( an accusation algorithm ) .",
    "in particular , we will focus on the application of such schemes in the dynamic setting , where the pirate output is detected in real - time , before the next watermark symbols are embedded in consecutive segments of the content .",
    "we will show that by building upon the ( static ) tardos scheme @xcite , we can construct efficient and flexible dynamic traitor tracing schemes .",
    "the number of watermark symbols needed in our schemes is a significant improvement compared to the scheme of tassa @xcite , and our schemes can be easily adjusted when the model is slightly different from the standard dynamic traitor tracing model @xcite .",
    "let us first formally describe the mathematical model for the problem discussed in this paper .",
    "first , some entity called the distributor controls the database of watermarks and distributes the content . the recipients , each receiving a watermarked copy of the content , are referred to as users .",
    "we write @xmath0 for the set of all users , and we commonly use the symbol @xmath1 for indexing these users . for the watermarks , we refer to the sequence of watermarking symbols assigned to a user @xmath1 by the vector @xmath2 , which is also called a codeword .",
    "we write @xmath3 for the total number of watermark symbols in a codeword , so that each codeword @xmath2 has length @xmath3 , and we commonly use the symbol @xmath4 to index the watermark positions .",
    "we write @xmath5 for the algorithm used to generate the codewords @xmath2 . in this paper",
    "we only focus on watermark symbols from a binary alphabet , so that @xmath6 for all @xmath7 . a common way to represent the traitor tracing code is by putting all codewords @xmath2 as rows in a matrix @xmath8 , so that @xmath9 is the symbol on position @xmath4 of user @xmath1 .    after assigning a codeword to each user ,",
    "the codewords are embedded in the data as watermarks .",
    "the watermarked copies are sent to the users , and some of the users ( called the pirates or colluders ) collude to create a pirate copy .",
    "the pirates form a subset @xmath10 , and we use @xmath11 for the number of pirates in the coalition .",
    "the pirate copy has some distorted watermark , denoted by @xmath12 .",
    "we assume that if on some position @xmath4 all pirates see the same symbol , they output this symbol .",
    "this assumption is known in the literature as the marking assumption . on other positions we assume pirates simply choose one of the two symbols to output .",
    "this choice of pirate symbols can be formalized by denoting a pirate strategy by a ( probabilistic ) function @xmath13 , which maps a code matrix @xmath8 ( or the part of the matrix visible to them ) to a forgery @xmath12 .",
    "after the coalition generates a pirate copy , we assume the distributor detects it and uses some accusation algorithm @xmath14 to map the forgery @xmath12 to some subset @xmath15 of accused users .",
    "these users are then disconnected from the system .",
    "ideally @xmath16 , but this may not always be achievable .    [ [ static - schemes . ] ] static schemes .",
    "+ + + + + + + + + + + + + + +    we distinguish between two types of schemes .",
    "in static schemes , the process ends after one run of the above algorithm with a fixed codelength @xmath3 , and the set @xmath17 is the final set of accused users .",
    "so the complete codewords are generated and distributed , the pirates generate and distribute a pirate copy , and the distributor detects this output and calculates the set of accused users . in this case",
    "an elementary result is that one can never have any certainty of catching all pirates .",
    "after all , the coalition could decide to sacrifice one of its members , so that @xmath18 for some @xmath19 .",
    "then it is impossible to distinguish between other pirates @xmath20 and innocent users @xmath21 .",
    "however , static schemes do exist that achieve catching at least one guilty user and not accusing any innocent users with high probability .",
    "the original tardos scheme @xcite belongs to this class of schemes .",
    "[ [ dynamic - schemes . ] ] dynamic schemes .",
    "+ + + + + + + + + + + + + + + +    the other type of scheme is the class of dynamic schemes , where the process of sending out symbols , detecting pirate output and running an accusation algorithm is repeated multiple times . in this case , if a user is caught , he is immediately cut off from the system and can no longer access the content .",
    "these dynamic scenarios for example apply to live broadcasts , such as pay - tv .",
    "the distributor broadcasts the content , while the pirates directly output a pirate copy of the content .",
    "the distributor then listens in on this pirate broadcast , extracts the watermarks , and uses this information for the choice of watermarks for the next segment of the content .",
    "we assume that the pirates always try to keep their broadcast running , so that if one of the pirates is disconnected , the other pirates will take over .",
    "ideally one demands that the set of accused users always matches the exact coalition , i.e.  @xmath16 , and with dynamic schemes we can also achieve this with high probability , as we will see later .",
    "the new schemes we present in this paper belong to this class of schemes .",
    "as mentioned earlier , we call static schemes successful if with high probability , at least one guilty user is caught , and no innocent users are accused . with dynamic schemes one can catch all pirates ,",
    "so we only call such schemes successful if with high probability , all pirates are caught and no innocent users are accused .",
    "this leads to the following definitions of soundness and static / dynamic completeness .",
    "[ def : secureness ] let @xmath22 be a traitor tracing scheme , let @xmath23 and let @xmath24 . then this scheme is called @xmath25-sound , if for all coalitions @xmath10 and pirate strategies @xmath13 , the probability of accusing one or more innocent users is bounded from above by @xmath26 a static traitor tracing scheme @xmath22 is called static @xmath27-complete , if for all coalitions @xmath10 of size at most @xmath28 and for all pirate strategies @xmath13 , the probability of not catching _ any _ pirates is bounded from above by @xmath29 finally , a dynamic traitor tracing scheme @xmath22 is called dynamic @xmath27-complete , if for all coalitions @xmath10 of size at most @xmath28 and for all pirate strategies @xmath13 , the probability of not catching _ all _ pirates is bounded from above by @xmath30    note that we distinguish between @xmath31 , the _ actual _ collusion size , and @xmath28 , the _ estimated _ collusion size used by the distributor to build the traitor tracing scheme . since @xmath31 is usually unknown , the distributor has to make a guess @xmath32 , which has to be sufficiently large to guarantee security , and sufficiently small to guarantee efficiency .    in the following sections we will omit the @xmath28 in the completeness property if the parameter is implicit .",
    "similarly , when @xmath25 or @xmath33 is implicit , we simply call a scheme sound or complete . as we will see later , in the schemes discussed in this paper , @xmath34 and @xmath33",
    "are closely related .",
    "we will use the notation @xmath35 to denote the log ratio of these error probabilities . in most practical scenarios we have @xmath36 ,",
    "so usually @xmath37 .      the schemes in this paper all build upon the tardos scheme @xcite , introduced in 2003",
    "this is an efficient static traitor tracing scheme , and it was the first scheme to achieve @xmath25-soundness and @xmath27-completeness with a codelength of @xmath38 . in the same paper it was proved that this order codelength is asymptotically optimal for large @xmath31 .",
    "the original tardos scheme had a codelength of @xmath39 , and several improvements of the tardos scheme have been suggested to reduce the constant before the @xmath40 .",
    "we mention two in particular : the improved analysis done by blayer and tassa @xcite ; and the introduction of a symmetric score function by kori et al .",
    "laarhoven and de weger combined these improvements @xcite to get even shorter codelength constants . for @xmath23 and @xmath41 , this construction gives codelengths of @xmath42 , with the constant further decreasing as @xmath28 increases or @xmath43 decreases .",
    "for asymptotically large @xmath28 , this construction leads to codelengths satisfying @xmath44 c_0 ^ 2 \\ln(n/{\\epsilon}_1)$ ] . the symmetric tardos scheme and its properties",
    "are discussed in section  [ sec : preliminaries ] .    for the dynamic setting , we mention four papers . in 2001 ,",
    "fiat and tassa  @xcite constructed a deterministic scheme , i.e. , a scheme with @xmath45 .",
    "the number of symbols needed to catch pirates in that scheme is only @xmath46 , but the alphabet size required is @xmath47 .",
    "in the same year , berkman et al .",
    "@xcite proposed several deterministic schemes using a smaller alphabet of size @xmath48 , with codelengths ranging from @xmath49 to @xmath50 . in 2005 , tassa  @xcite combined the dynamic scheme of fiat and tassa  @xcite with the static scheme of boneh and shaw  @xcite , to get a dynamic scheme using a binary alphabet , with a codelength of @xmath51 .",
    "in the same paper it was suggested that using the tardos scheme instead of the scheme of boneh and shaw as a building block may decrease the codelength by a factor @xmath31 , thus possibly giving a codelength of @xmath52 . in 2011 , roelse  @xcite presented another deterministic scheme .",
    "as in the generalization of the scheme of fiat and tassa presented by berkman et al .",
    "@xcite , in the scheme of roelse the alphabet size equals @xmath53 with @xmath54 and for a fixed value of @xmath55 , the codelength is @xmath56",
    ". moreover , the real - time computational cost and the bandwidth usage are logarithmic in @xmath57 , instead of linear in @xmath57 as in the scheme of fiat and tassa and its generalization of berkman et al .",
    "@xcite .",
    "first we show that the static tardos scheme can be extended to a dynamic traitor tracing scheme in an efficient way , allowing us to catch the whole coalition instead of at least one colluder .",
    "this dynamic scheme has a codelength of @xmath58 , where the constants only slightly increase compared to the constants of laarhoven and de weger  @xcite .",
    "the adjustments do not influence the method of generating codewords , so these can still be generated in advance .    to avoid the loss of efficiency caused by having to choose a value @xmath28 ,",
    "we then show how to create a @xmath28-independent  universal \" dynamic scheme that does not require a sharp estimate of @xmath31 as input .",
    "the property that the codewords can be generated in advance is left unchanged , while the scheme also has several advantages with respect to flexibility , detailed in section  [ sec : discussion ] .",
    "the codelength of this scheme is also @xmath59 , thus improving upon the results of tassa  @xcite by roughly a factor @xmath60 and upon the suggested improvement of tassa by a factor @xmath61 .",
    "the paper is organized as follows .",
    "first , we recall the construction of the static symmetric tardos scheme and its properties in section  [ sec : preliminaries ] .",
    "this scheme and its results will be used as the foundation for the dynamic tardos scheme , which we present in section  [ sec : dynamictardos ] .",
    "then , in section  [ sec : semidynamictardos ] we present a modification of the dynamic tardos scheme when the setting is not fully dynamic . in section  [ sec : universaltardos ] we then present the universal tardos scheme , which is an extension of the dynamic tardos scheme that does not require a sharp bound on @xmath31 as input . in section  [ sec : discussion ] , we discuss the results and argue that our schemes have several advantages with respect to flexibility as well . finally , in section  [ sec : openproblems ] we list some open problems raised by our work .",
    "this paper is mainly based on results from the first author s master s thesis @xcite .",
    "the results in the next sections all build upon results from the ( static ) symmetric tardos scheme , so we first discuss this scheme here . since the codeword generation of the schemes discussed in this paper all use ( a variant of ) the arcsine distribution , we also explicitly mention this distribution below .",
    "the standard arcsine distribution function @xmath62 on @xmath63 $ ] , and its associated probability density function @xmath64 , are given by : @xmath65 this distribution function will be used in section  [ sec : universaltardos ] . in sections  [ sec : preliminaries ] , [ sec : dynamictardos ] and [ sec : semidynamictardos ] we will use a variant of this distribution function , where the values of @xmath66 can not be arbitrarily close to @xmath67 and @xmath68 , as this generally leads to a high probability of accusing innocent users .",
    "tardos  @xcite therefore used the arcsine distribution with a certain small cutoff parameter @xmath69 , such that @xmath66 is always between @xmath70 and @xmath71 . by scaling @xmath72 and @xmath73 appropriately on this interval ,",
    "this leads to the following distribution functions @xmath74 and associated probability density functions @xmath75 : @xmath76 note that taking @xmath77 ( i.e. , using no cutoff ) leads to @xmath78 .      the tardos scheme , with parameters @xmath79 as used by blayer and tassa @xcite and laarhoven and de weger @xcite , and with the symmetric score function introduced by kori et al .",
    "@xcite , is described below .    1",
    ".   * initialization phase * 1 .",
    "take the codelength as @xmath80 .",
    "2 .   take the threshold as @xmath81 .",
    "3 .   take the cutoff parameter as @xmath82 . as @xmath83",
    ". however , laarhoven and de weger @xcite showed that to get an optimal codelength , @xmath70 should scale as @xmath84 rather than @xmath85 .",
    "therefore we now use @xmath82 , with @xmath86 converging to a non - zero constant for asymptotically large @xmath28 . ] 2 .",
    "* codeword generation * + for each position @xmath87 : 1 .",
    "select @xmath88 $ ] from the distribution function @xmath89 defined in .",
    "2 .   for each user @xmath90 , generate the @xmath4th entry of the codeword of user @xmath1 according to @xmath91 and @xmath92 .",
    "* distribution of codewords * + send to each user @xmath90 their codeword @xmath93 , embedded as a watermark in the content .",
    "* detection of pirate output * + detect the pirate output , and extract the watermark @xmath94 .",
    "* accusation phase * + for each user @xmath90 : 1 .   for each position @xmath87 ,",
    "calculate the user s score @xmath95 for this position according to : @xmath96 2 .",
    "calculate the user s total score @xmath97 .",
    "3 .   user @xmath1 is accused ( i.e.  @xmath98 ) iff @xmath99 .      for the above construction",
    ", one can prove soundness and static completeness , provided the constants @xmath79 satisfy certain requirements .",
    "for soundness , laarhoven and de weger  @xcite proved the following lemma .",
    "here @xmath100 , which is a strictly increasing function from @xmath101 to @xmath102 .",
    "* lemma 1 ) [ lem : soundness ] let the tardos scheme be constructed as in section  [ sub : preliminaries - construction ] .",
    "let @xmath1 be some arbitrary innocent user , and let @xmath103 .",
    "then @xmath104 where @xmath105 .",
    "now if the following condition of soundness is satisfied , @xmath106 then using the markov inequality and lemma  [ lem : soundness ] with this @xmath107 , for innocent users @xmath1 we get @xmath108 so the probability that no innocent user is accused is at least @xmath109 , as was also shown by laarhoven and de weger  ( * ? ? ?",
    "* theorem 3 ) .      to prove static completeness , laarhoven and de weger  @xcite used the following lemma .",
    "below , and throughout the rest of this paper , @xmath110 represents the total coalition score , i.e. , the sum of the scores of all pirates @xmath19 .",
    "* lemma 2 ) [ lem : completeness ] let the tardos scheme be constructed as in section  [ sub : preliminaries - construction ] , and let @xmath111 .",
    "then @xmath112 where @xmath113 .",
    "if the following condition of completeness is satisfied , @xmath114 then using the pigeonhole principle , the markov inequality and lemma  [ lem : completeness ] with this @xmath115 we get @xmath116 so static completeness follows from lemma  [ lem : completeness ] and condition  , as was also shown by laarhoven and de weger  ( * ? ? ?",
    "* theorem 4 ) .",
    "blayer and tassa  @xcite , and subsequently laarhoven and de weger  @xcite , gave a detailed analysis to go from requirements and to the optimal set of parameters that satisfies the constraints and minimizes @xmath117 .",
    "recall that @xmath80 , so a smaller @xmath117 gives shorter codelengths , whereas the parameters @xmath118 and @xmath86 affect only @xmath119 and @xmath70 , which have no influence on the efficiency of the scheme . in the end , the following result was obtained .",
    "* theorem 6 ) [ lem : firstorder ] let @xmath120 .",
    "the asymptotically optimal value for @xmath117 is @xmath121 the associated values for @xmath118 and @xmath86 are @xmath122 and the corresponding values for @xmath123 are @xmath124    a direct consequence of lemma  [ lem : firstorder ] is the following , which gives the asymptotically optimal scheme parameters for @xmath125 .",
    "* corollary 1 ) [ cor : asymptotics ] the construction from section [ sub : preliminaries - construction ] gives an @xmath25-sound and static @xmath126-complete scheme with asymptotic scheme parameters @xmath127    for further details on the optimal first order constants , see laarhoven and de weger  @xcite .      for the next few sections , we will use a running example to compare the codelengths of the several schemes . let the scheme parameters be given by @xmath128 pirates , @xmath129 users , and error probabilities @xmath130 .",
    "then @xmath131 , and the optimal values of @xmath79 can be calculated numerically as @xmath132 this leads to the scheme parameters @xmath133 so using these scheme parameters , we know that after @xmath134 symbols , with probability at least @xmath135 there are no false accusations ( regardless of the actual coalition size @xmath31 ) , and with probability at least @xmath135 at least one pirate is accused if the actual coalition size @xmath31 does not exceed the bound on the coalition size @xmath128 . in fig .  [ fig : fig1 ] we show simulation results for these parameters , with @xmath136 .",
    "the curves in the figure are the pirate scores @xmath137 for each pirate @xmath19 , while the shaded area is bounded from above by the highest score of an innocent user , and bounded from below by the lowest score of an innocent user in this simulation . in fig .",
    "[ fig : fig1a ] we simulated pirates using the interleaving attack ( i.e.  for each position , they choose a random pirate and output his symbol ) , and in fig .",
    "[ fig : fig1b ] they used the scapegoat strategy ( i.e.  one pirate , the scapegoat , always outputs his symbol , until he is caught and another pirate is picked as the scapegoat ) . with the scapegoat strategy , only one pirate is caught , while using the interleaving attack leads to many accused pirates .",
    "let us now explain how we create a dynamic scheme from the static tardos scheme , such that with high probability we catch all colluders , instead of at least one colluder .",
    "the change we make is the following . instead of only comparing the cumulative user scores to @xmath119 after @xmath3 symbols",
    ", we now compare the scores to @xmath119 after every single position @xmath4 .",
    "if a user s score exceeds @xmath119 at any point in time , he is disconnected immediately and can no longer access the content .",
    "his score is then necessarily between @xmath119 and @xmath138 .",
    "the other parts of the construction remain the same , except for the values of @xmath79 , which now have to be chosen differently .",
    "the scheme again depends on three constants @xmath79 .",
    "we will show in sections  [ sub : dynamictardos - soundness ] and [ sub : dynamictardos - completeness ] that if certain requirements on these constants are satisfied , we can prove soundness and dynamic completeness .",
    "below we say a user is active if he has not yet been disconnected from the scheme . as mentioned before , we assume that the pirates always output some watermarked data , unless all of the pirates are disconnected . in that case",
    ", the traitor tracing scheme terminates .    1 .   * initialization phase * 1 .",
    "take the codelength as @xmath80 .",
    "2 .   take the threshold as @xmath81 .",
    "3 .   take the cutoff parameter as @xmath82 .",
    "4 .   set initial user scores at @xmath139 .",
    "* codeword generation * + for each position @xmath87 : 1 .",
    "select @xmath88 $ ] from @xmath89 defined in .",
    "generate @xmath140 using @xmath91 .",
    "* distribution / detection / accusation * + for each position @xmath87 : 1 .",
    "send to each active user @xmath1 symbol @xmath141 .",
    "2 .   detect the pirate output @xmath142 .",
    "+ ( if there is no pirate output , terminate . )",
    "calculate scores @xmath95 using .",
    "4 .   for active users @xmath1 ,",
    "set @xmath143 .",
    "+ ( for inactive users @xmath1 , set @xmath144 . )",
    "disconnect all active users @xmath1 with @xmath145 .    in the construction",
    "above , we separated the codeword generation from the distribution , detection and accusation .",
    "these phases can also be merged by generating @xmath146 and @xmath141 once we need them .",
    "however , we present the scheme as above to emphasize the fact that these phases can indeed be executed sequentially instead of simultaneously , and that the codeword generation can thus be done before the traitor tracing process begins .      for the dynamic tardos scheme",
    "as given above , we can prove the following result regarding soundness .",
    "[ thm : pds - dt - soundness ] consider the dynamic tardos scheme in section  [ sub : dynamictardos - construction ] .",
    "if the following condition is satisfied , @xmath147 then the scheme is @xmath25-sound .    to prove the theorem , we first prove a relative upper bound on the probability that a single innocent user is accused and disconnected .",
    "this bound relates the error probability in the dynamic tardos scheme to the probability that the user score at time @xmath3 is above @xmath119 .",
    "we then use the proof of the original tardos scheme to get an absolute upper bound on the soundness error probability , and to prove theorem  [ thm : pds - dt - soundness ] . since the relative upper bound gives us an extra factor @xmath148 , and since the terms in appear as exponents in the proof , we get an additional term @xmath149 compared to .",
    "note that this term is small for reasonable values of @xmath57 and @xmath25 , so this only has a small impact on the right hand side of , compared to .    in the following we write @xmath150 for the _ extended _ user score .",
    "if user @xmath1 is still active at time @xmath4 , then @xmath151 .",
    "but whereas @xmath137 does not change anymore once user @xmath1 is disconnected , the score @xmath152 does change on every position , even if the user has already been disconnected .",
    "the score @xmath153 then calculates the user s score as if he had not been disconnected .",
    "similarly , we write @xmath154 for coalitions @xmath155 . note that if the last pirate is disconnected at position @xmath156 , then @xmath95 and @xmath137 are not defined for @xmath157 .",
    "[ lem : dt1 ] let @xmath90 be an arbitrary innocent user , let @xmath158 be a pirate coalition and let @xmath13 be some pirate strategy employed by this coalition .",
    "then @xmath159    let us define events @xmath160 and @xmath161 as @xmath162 we trivially have @xmath163 .",
    "for @xmath164 , note that under the assumption that @xmath160 holds , the process @xmath165 starting at position @xmath166 describes a symmetric random walk with no drift .",
    "so we then have @xmath167 , and since @xmath168 it follows that @xmath169 .",
    "finally we apply bayes theorem to @xmath160 and @xmath161 to get @xmath170 this completes the proof .",
    "first , we remark that the distribution of @xmath171 is the same as the distribution of the scores @xmath172 in the original tardos scheme , for the same parameters @xmath173 . from the markov inequality , lemma  [ lem : soundness ] and condition",
    "it thus follows that @xmath174 using lemma  [ lem : dt1 ] the result follows .      with the dynamic tardos scheme ,",
    "we get the following result regarding dynamic completeness . recall that here we require that _ all _ pirates are caught , instead of at least one , as was the case in the original tardos scheme .",
    "[ thm : pds - dt - completeness ] consider the dynamic tardos scheme in section  [ sub : dynamictardos - construction ] . if the following condition is satisfied , @xmath175 then the scheme is dynamic @xmath126-complete .",
    "similar to the proof of soundness , we prove dynamic completeness by relating the error probability to the static completeness error probability of the static tardos scheme described in section  [ sec : preliminaries ]",
    ". then we use the results from the static scheme to complete the proof .",
    "we again see a factor @xmath148 in the relative upper bound in lemma  [ lem : dt - comp ] , which again comes from a random walk argument , and which explains the additional term @xmath149 in  .",
    "the other term @xmath176 is a consequence of using @xmath177 instead of @xmath119 in the proofs .",
    "note that these two terms are generally small , compared to the term @xmath43 .",
    "[ lem : dt - comp ] let @xmath155 be a coalition of size at most @xmath28 , and let @xmath13 be any pirate strategy employed by this coalition .",
    "then @xmath178    first we remark that @xmath179 . in other words ,",
    "if not all pirates are caught by the end , the total extended coalition score will be below @xmath180 with probability at least @xmath181 .",
    "this is because if @xmath182 , then @xmath183 , and since @xmath184 is a symmetric , unbiased random walk , with probability at least @xmath181 we have @xmath185 and as a consequence @xmath186 .",
    "next , we use the definition of conditional probabilities to get @xmath187 this proves the result .",
    "first , note that in the dynamic tardos scheme , the only extra information pirates receive compared to the static tardos scheme is the fact whether some of them are disconnected .",
    "this information is certainly covered by the information contained in the previous values of @xmath146 ; if pirates receive @xmath188 , then they can calculate their current scores themselves and calculate whether they would have been disconnected or not . also note that @xmath189 behaves the same as @xmath190 in the static tardos scheme , where the total coalition score is calculated for all pirates and all positions , regardless of whether they contributed on that position or not .",
    "so if we can prove that even in the static tardos scheme , and even if coalitions get information about the previous values of @xmath146 ( for which @xmath142 was already determined ) , the probability of keeping the coalition score @xmath190 below @xmath191 is bounded by @xmath192 , then it follows that also @xmath193 .",
    "for the static tardos scheme , note that the proof method for the completeness property does not rely on the other values of @xmath146 being secret .",
    "in fact , @xmath146 and @xmath194 are independent for @xmath195 .",
    "the only assumption that is used in that proof is that the marking assumption applies , which does apply here , and that the _ current _ value @xmath146 is hidden before @xmath142 is generated .",
    "so here we can also use the proof method of the static tardos scheme . from the markov inequality , lemma  [ lem : completeness ] and condition",
    ", it thus follows that @xmath196 using lemma  [ lem : dt - comp ] the result then follows .",
    "the requirements and are only slightly different from requirements and . for asymptotically large @xmath28 ,",
    "these differences even disappear , and the optimal asymptotic codelength is the same as in the static tardos scheme . in fig .",
    "[ fig : fig2 ] we show the optimal values of @xmath117 in the dynamic tardos scheme for @xmath197 and @xmath198 .",
    "the different curves correspond to different values of @xmath199 , ranging from @xmath200 ( the highest values of @xmath117 ) to @xmath201 ( the lowest values of @xmath117 ) .     in the dynamic tardos scheme .",
    "the dotted line corresponds to the asymptotic optimal value @xmath202 .",
    "the bold curves show the values of @xmath117 in the static tardos scheme for @xmath197 ( top ) and @xmath198 ( bottom ) respectively .",
    "the five curves slightly above each of the bold curves show the optimal values of @xmath117 in the dynamic tardos scheme for @xmath203 , for @xmath204 up to @xmath205 .",
    "higher values of @xmath55 correspond to lower values of @xmath117 . ]",
    "note that these values of @xmath117 correspond to the theoretical codelengths such that with probability at least @xmath206 , by time @xmath3 all of the pirates have been disconnected .",
    "this does not mean that the last pirate is likely to be caught _ exactly at _",
    "time @xmath3 ; this means that he is likely to be caught _ before or at _",
    "time @xmath3 .",
    "so in practice the number of symbols needed to disconnect all traitors may very well be below this theoretical codelength @xmath3 , and may even decrease compared to the static tardos scheme .    furthermore , if the coalition size is not known , then one generally uses a traitor tracing scheme that is resistant against up to @xmath207 colluders .",
    "kori et al .",
    "@xcite showed that in the tardos scheme , the total coalition score @xmath208 always increases linearly in @xmath4 with approximately the same slope , regardless of the actual coalition size @xmath31 or the employed pirate strategy @xmath13 .",
    "more precisely , the score @xmath209 behaves as @xmath210 , with @xmath211 only slightly depending on the coalition size @xmath31 and the pirate strategy @xmath13 .",
    "since one chooses @xmath3 and @xmath119 such that @xmath212 , it follows that @xmath213 . in other words , to catch a coalition of size @xmath214 , the expected number of symbols needed is approximately @xmath215 .",
    "so compared to the static tardos scheme , where the codelength is fixed in advance at @xmath216 , the codelength is reduced by a factor @xmath217 .",
    "in particular , small coalitions of few pirates are generally caught up to @xmath218 times faster , for @xmath219 .",
    "let the scheme parameters be the same as in section  [ sub : preliminaries - example ] , i.e. , @xmath128 , @xmath129 and @xmath130 , so that @xmath131 .",
    "the optimal values of @xmath79 satisfying and can be calculated numerically as @xmath220 this leads to the scheme parameters @xmath221 in fig .",
    "[ fig : fig3 ] we show some simulation results for these parameters , with the actual coalition also consisting of @xmath136 colluders . in fig .",
    "[ fig : fig3a ] the pirates used the interleaving attack , and in fig .  [ fig : fig3b ] they used the scapegoat strategy . in both cases , the whole coalition is caught well before we reach @xmath3 symbols .",
    "in the dynamic tardos scheme , we need to disconnect users as soon as their scores exceed the threshold @xmath119 . in some scenarios this may not be possible .",
    "for example , the pirates may transmit each symbol with a delay .",
    "we call a traitor tracing scheme weakly dynamic if @xmath161 ( @xmath222 ) symbols are distributed during the delay between the original broadcast and the corresponding pirate output .",
    "observe that the dynamic schemes presented in @xcite are not weakly dynamic schemes , as these schemes use the value of each symbol to adapt the distribution of the next symbols ( i.e. @xmath223 for these schemes ) .",
    "in this section we present two weakly dynamic schemes based on the dynamic tardos scheme .",
    "first , in section  [ sub : semidynamictardos - first ] we present a scheme that achieves a codelength of at most @xmath224 , where @xmath117 is the same as in the dynamic tardos scheme for the same parameters . for small values of @xmath161",
    ", this means that with codelength which is only slightly higher than in the dynamic tardos scheme , we can also catch all pirates in a weakly dynamic setting .",
    "then , in section  [ sub : semidynamictardos - second ] we present a scheme that achieves a codelength of @xmath225 , where @xmath226 increases with @xmath161 .",
    "since a small increase in @xmath117 can already lead to a big increase in the codelength , the second scheme generally has a larger codelength than the first scheme .",
    "the first scheme is based on the following modification to the accusation algorithm of the dynamic tardos scheme .",
    "suppose a user s score exceeds @xmath119",
    "after @xmath227 positions . at position",
    "@xmath227 we now disconnect this user . since this user may have contributed to the next @xmath161 symbols of the pirate output @xmath12 , we disregard the following @xmath161 ` contaminated ' positions of the watermark , and do not update the scores for positions @xmath228 . after those positions we continue the traitor tracing process as in the dynamic tardos scheme , and we repeat the above procedure each time a user s score exceeds @xmath119 .    with this modification , the traitor tracing process on those positions that were used for calculating scores is identical to the traitor tracing process of the dynamic tardos scheme .",
    "we can therefore use the analysis from section  [ sec : dynamictardos ] and conclude that with at most @xmath229 positions for which we calculate scores , we can catch any coalition of size @xmath214 . since we disregarded at most @xmath230 positions , the pirate broadcast will not last longer than @xmath224 positions in total , where @xmath117 , @xmath118 and @xmath86 are as in the dynamic tardos scheme for the same parameters .",
    "this means that with at most @xmath230 more symbols than in the dynamic tardos scheme , we can also catch coalitions in this weakly dynamic traitor tracing setting .      instead of using @xmath230 more symbols , we can also try to adjust the analysis of the dynamic tardos scheme to the weakly dynamic traitor tracing scenario .",
    "we can do this by following the proof methods of the dynamic tardos scheme , and by making one small adjustment .",
    "the change we make in the analysis is to use @xmath231 instead of @xmath232 as our new upper bound for the scores of users in the proofs .",
    "this results in the following , slightly different condition for dynamic completeness : @xmath233 if some parameters @xmath226 , @xmath234 , @xmath235 satisfy and , then using these constants as our scheme parameters , we obtain a @xmath25-sound and dynamic @xmath27-complete scheme with a codelength of @xmath225 . in fig .  [ fig : fig4 ] we show the values of @xmath226 for the parameters @xmath129 , @xmath130 , and @xmath131 , for several values of @xmath161 . as the value of @xmath161 increases , the values of @xmath226 increase",
    "as well .     in the weakly dynamic tardos scheme from section  [ sub : semidynamictardos - second ] , for the parameters @xmath129 , @xmath130 , and @xmath131 .",
    "the bold curve corresponds to the values of @xmath117 in the static tardos scheme with the same parameters , while the six curves above this curve correspond to the optimal values of @xmath226 for @xmath236 respectively .",
    "the dotted line corresponds to the asymptotic optimal value @xmath202 . for @xmath237",
    "we get exactly the codelengths of the dynamic tardos scheme . ]      as before , let the scheme parameters be given by @xmath128 , @xmath129 and @xmath130 , so that @xmath131 , and let us use @xmath238 . with the first proposed scheme ,",
    "the codelength increases by @xmath239 symbols compared to the dynamic tardos scheme , giving scheme parameters : @xmath240 using the second scheme , the optimal values of @xmath241 satisfying and for @xmath238 can be calculated numerically as @xmath242 this leads to the scheme parameters @xmath243 so in this case , using the first scheme leads to the shortest code .",
    "in this section we present a dynamic scheme that does not require a sharp upper bound @xmath28 on @xmath31 as input to guarantee quick detection of pirates .",
    "this means that even if we set @xmath244 , coalitions of any size are caught quickly .",
    "we use the word `` universal '' to indicate this universality with respect to the coalition size : coalitions of any size can be caught efficiently with this scheme .",
    "note that in the ( dynamic ) tardos scheme , we used the distribution function @xmath74 where @xmath245 depends on @xmath28 .",
    "instead , we will use a distribution function @xmath72 that can be used for all values of @xmath31 , so that we can use the same codewords to catch coalitions of any size .",
    "in particular , we will use the first @xmath246 symbols to catch coalitions of size @xmath31 , for each @xmath31 between @xmath148 and @xmath28 .",
    "we do this in such a way that if a coalition has some unknown size @xmath31 , then after @xmath247 symbols , the probability of not having caught all members of this coalition is at most @xmath33 . since we do this for each value of @xmath31 , we now only need @xmath248 symbols to catch a coalition of a priori unknown size @xmath31 , compared to the @xmath216 worst - case codelength of the static and dynamic tardos schemes , and the @xmath249 practical codelength of the dynamic tardos scheme .",
    "the only drawback of this new codeword generation method is that a completely universal distribution function , which is completely efficient for all values of @xmath31 , does not seem to exist .",
    "more precisely , the proof of soundness of the tardos scheme requires the cutoff parameter @xmath70 to be sufficiently large in terms of @xmath31 , whereas for completeness we need that @xmath70 approaches @xmath67 as @xmath250 .",
    "our solution to this problem is the following . for generating the values of @xmath146",
    ", we use the standard arcsine distribution function @xmath72 from eq .  , with no cutoffs .",
    "then , for each value of @xmath31 , we simply disregard those values @xmath146 that are not between the corresponding cutoff @xmath251 and @xmath252 .",
    "the fraction of values of @xmath146 that is disregarded can be estimated as follows : @xmath253 so the fraction of disregarded positions is very small and decreases when @xmath31 increases .",
    "the construction now basically consists of running several dynamic tardos schemes simultaneously with shared codewords .",
    "so scheme parameters and scores now have to be calculated for each of these schemes , i.e. , for each of the values of @xmath31 .",
    "we introduce counters @xmath254 to keep track of the number of positions that have not been disregarded . for each @xmath31",
    ", we then run a dynamic tardos scheme using the same code @xmath8 until @xmath255 .    1 .",
    "* initialization phase * + for each @xmath256 : 1 .",
    "take the codelength as @xmath257 .",
    "2 .   take the threshold as @xmath258 .",
    "3 .   take the cutoff parameter as @xmath259 .",
    "4 .   initialize the user scores at @xmath260 .",
    "initialize the counters @xmath254 at @xmath261 .",
    "* codeword generation * + for each position @xmath262 : 1 .",
    "select @xmath263 $ ] from @xmath62 as defined in .",
    "generate @xmath264 using @xmath91 .",
    "* distribution / detection / accusation * + for each position @xmath262 : 1 .",
    "send to each active user @xmath1 symbol @xmath141 .",
    "2 .   detect the pirate output @xmath142 .",
    "+ ( if there is no pirate output , terminate . )",
    "calculate scores @xmath95 using .",
    "4 .   for active users @xmath1 and values @xmath31 such that @xmath265 $ ] , set @xmath266 .",
    "+ ( otherwise set @xmath267 . ) 5 .   for values of @xmath31 such that @xmath265 $ ] , set @xmath268 .",
    "+ ( otherwise set @xmath269 . ) 6 .",
    "disconnect all active users @xmath1 with @xmath270 and @xmath271 for some @xmath31 .    as was already mentioned in section  [ sub : dynamictardos - construction ] ,",
    "if desired the codeword generation can be merged with the distribution / detection / accusation phase .",
    "this depends on the scenario and the exact implementation of the scheme .",
    "also note that several variations can be made to the above construction , to deal with specific situations .",
    "one could easily replace @xmath244 by a smaller value of @xmath28 to restrict the amount of memory needed , if a sharper upper bound on @xmath31 is known . and",
    "of course , we may also choose to draw values @xmath146 from @xmath272 , as values @xmath273 \\setminus [ \\delta^{(c_0 ) } , 1 - \\delta^{(c_0)}]$ ] are disregarded for all @xmath31 .",
    "a less obvious optimization would be to use a geometric progression of values @xmath31 , e.g. , @xmath274 and maintain the user scores only for this set of coalition sizes , rather than for all values of @xmath275 .",
    "this significantly reduces the space requirement per user from @xmath218 to @xmath276 .",
    "however , if the actual coalition size is , say , @xmath277 , then the coalition may not be caught until we reach @xmath278 .",
    "since the codelength scales quadratically in @xmath31 , this means that the codelength increases by a worst - case factor of @xmath279 .",
    "in general , using any geometric progression with geometric factor @xmath280 possibly loses a factor @xmath281 in the codelengths .",
    "we have chosen to give the construction with many scores per user , to show that we then still obtain the same asymptotic codelengths .",
    "but the above construction is just one of the many alternatives to catch coalitions of any size efficiently .      for the universal tardos scheme we get the following result regarding soundness .",
    "[ thm : pds - ut - soundness ] consider the universal tardos scheme in section  [ sub : universaltardos - construction ] . if is satisfied for each set of parameters @xmath282 , and if the @xmath283 satisfy the following requirement : @xmath284 then the scheme is @xmath25-sound .    for each @xmath275 ,",
    "let @xmath285 be the set of users that are accused because their scores @xmath286 exceeded @xmath287 before @xmath288 .",
    "then @xmath289 .",
    "for any @xmath31 , we can apply theorem  [ thm : pds - dt - soundness ] to the parameters @xmath290 and @xmath283 so that we know that the probability that @xmath291 for innocent users @xmath1 is at most @xmath292 .",
    "so the overall probability that an innocent user is disconnected is bounded from above by @xmath293 this completes the proof .    note that one can choose values @xmath283 satisfying such that @xmath294 , e.g. , by taking @xmath295 . if furthermore @xmath296 is subpolynomial in @xmath57 , then asymptotically @xmath297 and we achieve the same asymptotic codelength as in the static and dynamic tardos schemes .",
    "the main advantage of the universal tardos scheme is that we can now prove dynamic completeness for all values of @xmath31 .",
    "[ thm : pds - ut - completeness ] consider the universal tardos scheme in section  [ sub : universaltardos - construction ] . if is satisfied for each set of parameters @xmath298 , where @xmath299 , then for each @xmath275 the scheme is dynamic @xmath300-complete .",
    "this follows directly from applying theorem  [ thm : pds - dt - completeness ] to @xmath290 and @xmath283 , where @xmath31 is the actual ( unknown ) coalition size .    to prove that the scheme catches a coalition of size @xmath31",
    ", we only argued that the coalition s score @xmath301 will exceed @xmath302 before we have seen @xmath303 positions @xmath4 with @xmath265 $ ] .",
    "in reality , the probability of catching the coalition is much larger than this , since for instance with high probability the coalition score @xmath304 will also exceed @xmath305 before we have seen @xmath306 positions with @xmath307 $ ] . and",
    "if a pirate is disconnected because for some @xmath55 his score @xmath308 exceeded the threshold @xmath309 , then we do not have to wait until @xmath310 but only until @xmath311 . and",
    "since @xmath209 has a constant slope , as soon as a pirate is caught , the other pirates scores will increase even faster . in practice",
    "we therefore also see that we usually need fewer than @xmath303 positions to catch @xmath31 colluders .",
    "the theoretical results from the previous subsections are not for exactly @xmath303 watermark positions , but for some number of symbols @xmath312 such that there are @xmath303 positions @xmath4 between @xmath68 and @xmath312 with @xmath265 $ ] .",
    "the difference @xmath313 is a random variable , and is distributed according to a negative binomial distribution with parameters @xmath314 ( the number of successes we are waiting for ) and @xmath315 ) = \\frac{4}{\\pi } \\arcsin(\\sqrt{\\delta^{(c)}})$ ] ( the probability of a success ) . because the parameter @xmath316 is very small for large @xmath31 , the difference between @xmath312 and @xmath303 will also be small .",
    "more precisely , @xmath312 has mean @xmath317 and variance @xmath318 , and the probability that @xmath312 exceeds its mean by @xmath319 decreases exponentially in @xmath320 .",
    "also note that if some upper bound @xmath321 is used for constructing the scheme as described earlier , and if the values of @xmath146 are drawn from @xmath272 instead of @xmath72 , then we have @xmath322 , as no values of @xmath146 are disregarded for @xmath323 .",
    "so then the maximum codelength is fixed in advance , at the cost of possibly not catching coalitions of size @xmath324 .",
    "finally , note that this scheme is constructed in such a way that coalitions of any ( small ) size can be caught more efficiently . to catch a coalition of size @xmath31 we now only use @xmath248 symbols .",
    "this in comparison to the static and dynamic tardos scheme , where we need @xmath216 and @xmath249 symbols respectively , where @xmath28 is again some upper bound on the coalition size used to construct the schemes .",
    "so while using the dynamic tardos scheme already reduces the codelength by a factor @xmath217 , the universal tardos scheme shaves off another factor @xmath217 .      as before , let the scheme parameters be given by @xmath129 and @xmath130 .",
    "let us use @xmath295 , so that @xmath325 .",
    "let us assume the coalition again has an actual size of @xmath326 .",
    "the optimal values of @xmath327 satisfying and can be calculated numerically as @xmath328 this leads to the corresponding scheme parameters @xmath329 in fig .",
    "[ fig : fig5 ] we show some simulation results for these parameters , where we only show the thresholds @xmath330 . in fig .",
    "[ fig : fig5a ] we simulated pirates using the interleaving attack , and in fig .",
    "[ fig : fig5b ] the pirates used the scapegoat strategy .",
    "as one can see , in the universal tardos scheme the scapegoat strategy is not a good strategy , as the whole coalition is caught very soon .",
    "this is because the scapegoat strategy basically divides the coalition in @xmath331 coalitions of size @xmath68 , and as mentioned before , small coalitions are caught much sooner in the universal tardos scheme .",
    "comparing the universal tardos scheme to the static tardos scheme , we see that the main advantages are that ( a ) we now have certainty about catching the whole coalition ( instead of at least one pirate ) , and ( b ) we no longer need the coalition size , or a sharp upper bound on the coalition size , as input",
    ". we do need to calculate multiple scores per user , namely one for each possible coalition size @xmath31 .",
    "but since the only disadvantage of a large @xmath28 is this larger number of scores per user and thus a larger offline space requirement ( which may not be a big issue ) , @xmath28 can easily be much higher than the expected coalition size @xmath31 .",
    "this in contrast to the static and dynamic tardos schemes , where an increase in @xmath28 means an increase in the theoretical and practical codelengths as well .    in table",
    "[ tab1 ] we list some of the differences between the static , dynamic , weakly dynamic and universal tardos schemes . here",
    "we assume that the upper bound @xmath28 on the number of colluders is the same for each scheme .",
    "the actual coalition size is denoted by @xmath31 .",
    "the example referred to in the table is the example used throughout this paper , with @xmath136 , @xmath129 , and @xmath130 .",
    "the practical codelengths are based on @xmath332 simulations for each scheme , where the pirates used the interleaving attack in all cases . for the weakly dynamic tardos scheme we used @xmath238 in our example .    [ cols=\"<,^,^,^,^,^ \" , ]     since our schemes are dynamic traitor tracing schemes , it makes sense to also compare them to other dynamic schemes from the literature .",
    "recall from section  [ sub : introduction - relatedwork ] that the scheme of fiat and tassa  @xcite , the schemes of berkman et al .",
    "@xcite and the scheme of roelse  @xcite are deterministic schemes .",
    "that is , each of these schemes always catches all pirates and no user is ever falsely accused , which are advantages compared to probabilistic schemes such as our schemes .",
    "an additional advantage of these schemes is that they have very short codelengths . on the other hand ,",
    "it was shown by fiat and tassa  @xcite that @xmath333 for any deterministic scheme , so these schemes can not be used in scenarios in which a small alphabet size is required .    as is the case with our schemes , the dynamic scheme of tassa  @xcite is probabilistic and uses a binary alphabet ( i.e. , @xmath334 ) .",
    "the codelengths of these schemes can therefore be compared directly . in particular , the codelength of the scheme of tassa is @xmath335 , which is more than a factor @xmath336 larger than the codelengths of our schemes .",
    "in fact , to the best of our knowledge our schemes have the shortest order codelengths of all known binary dynamic traitor tracing schemes .",
    "below we list some other nice properties of the universal tardos scheme , which are not related to the codelength or the alphabet size .",
    "most of these properties are inherited from the static tardos scheme .",
    "[ [ codewords - of - users - are - independent . ] ] codewords of users are independent",
    ". + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    this means that framing a specific innocent user is basically impossible , as the codewords of the pirates and the pirate output are independent of the innocent users codewords .",
    "also , a new user can be added to the system easily after the codewords of other users have already been generated , since the codewords of other users do not have to be updated .    [ [ codeword - positions - are - independent . ] ] codeword positions are independent .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in other words , the scheme does not need the information obtained from the previous pirate output to generate new symbols for each user .",
    "therefore the codewords can even be generated in advance .",
    "this also allows us to effectively tackle weakly dynamic traitor tracing scenarios , as described in section  [ sec : semidynamictardos ] .",
    "in particular , the total tracing times of the dynamic schemes presented in @xcite are bounded from below by the total delay , defined as the codelength of the scheme times the delay of the pirates transmission . by comparison ,",
    "the total tracing times of our weakly dynamic schemes only increase marginally if @xmath161 increases . as a result , for a large delay ( i.e. for a large value of @xmath161 ) , our weakly dynamic schemes have the shortest total tracing times of all known dynamic schemes .",
    "[ [ the - distribution - of - watermark - symbols - is - identical - for - each - position . ] ] the distribution of watermark symbols is identical for each position .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    this property offers new options , like tracing several coalitions simultaneously , using the same traitor tracing code .",
    "this also means that multiple watermarks from several broadcasts can be concatenated and viewed as one long watermark from one longer broadcast , allowing one to catch large coalitions with multiple watermarked broadcasts .",
    "[ [ the - codeword - generation - and - accusation - algorithm - are - computationally - and - memory - wise - efficient . ] ] the codeword generation and accusation algorithm are computationally and memory - wise efficient .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the schemes do not require any complicated data structures and computations , and the only memory needed during the broadcast is the scores for each user at that time , and the counters @xmath254 . during the broadcast",
    "only simple calculations are needed : computing @xmath95 ( which has to be calculated only once ) , adding @xmath95 to those scores @xmath286 where @xmath31 satisfies a certain condition , and comparing the scores @xmath286 to the thresholds @xmath287 .",
    "[ [ several - instances - of - the - scheme - can - be - run - simultaneously . ] ] several instances of the scheme can be run simultaneously .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for example , by using parameters @xmath337 with @xmath338 and @xmath339 with @xmath340 for two different instances of the universal tardos scheme ( using the same codewords ) , a pirate will first cross one of the thresholds associated to @xmath341 , and only later cross one of the thresholds associated to the @xmath342 .",
    "if we use the @xmath342 for disconnecting users , then even before a user is disconnected , we can give some sort of statistic to indicate the ` suspiciousness ' of this user .",
    "if a user then does not cross the highest thresholds , one could still decide whether to disconnect him or not .",
    "after all , the choice of @xmath25 may be arbitrary , and a user that almost crosses the thresholds @xmath287 is likely to be guilty as well .",
    "let us conclude with mentioning some open problems for future research .",
    "although we argued that the universal tardos scheme has several advantages over other binary schemes , it has a minor drawback : we have to keep multiple scores for each user , namely for each possible coalition size @xmath31 . to address this issue",
    ", one could try making small adjustments to the universal tardos scheme , or start from the dynamic tardos scheme and build a different , @xmath28-independent traitor tracing scheme .",
    "for instance , would it be possible to change the process of generating the @xmath146 s such that no positions are ever disregarded ?",
    "then all scores for one user would be the same , and we would only have to keep one score for each user .      looking at fig .  [",
    "fig : fig5 ] suggests that a continuous threshold function @xmath343 might also be an option , with @xmath119 depending on the position @xmath4 instead of on the coalition size @xmath31 .",
    "however , for the proof of soundness of the universal tardos scheme , we simply added up the error probabilities for each threshold and showed that this sum is still less than @xmath25 .",
    "if we use a continuous function @xmath343 and use this same proof method , this would lead to even smaller values of @xmath344 and longer codelengths .",
    "still , theoretically it would be interesting to see if such a continuous threshold function can be constructed .",
    "most dynamic schemes find their strength in being able to adjust the next codeword symbols to the previous pirate output . in the dynamic tardos scheme , we do not use this ability at all , and only use the dynamic setting to disconnect users inbetween .",
    "it is an open problem whether better results can be obtained with a fully dynamic tardos scheme , that does use this extra power given to the distributor .",
    "the deterministic dynamic schemes in @xcite are not designed for the weakly dynamic setting , and it is not obvious how to adapt these schemes to this setting . the design and analysis of efficient weakly dynamic deterministic schemes is therefore an open problem .      on the other hand ,",
    "it is also very well possible that no fully dynamic tardos scheme exists that achieves significantly better codelengths . for the static setting",
    ", it is known that the order codelength of the tardos scheme ( quadratic in @xmath28 , logarithmic in @xmath57 ) is optimal .",
    "but what about the dynamic setting ? what is the optimal order codelength required to catch all colluders ?",
    "our results show that the optimal order codelength is at most quadratic in @xmath31 , but this may not be optimal .      in this paper we discussed several probabilistic dynamic schemes , taking the static binary tardos scheme and the results of laarhoven and de weger  @xcite as starting points .",
    "the design and analysis of @xmath345-ary probabilistic dynamic traitor tracing schemes is still an open problem .",
    "a possible approach for solving this problem is to take the @xmath345-ary tardos scheme of kori et al .",
    "@xcite as a starting point .    in a recent paper , laarhoven et al .",
    "@xcite presented another approach to solve this problem .",
    "it was shown that with a divide - and - conquer construction , any binary dynamic traitor tracing scheme can be turned into a @xmath345-ary dynamic traitor tracing scheme with a codelength that is roughly a factor @xmath346 smaller than the codelength of the underlying binary scheme . applying this to the constructions described in this paper , this leads to @xmath345-ary dynamic tardos schemes with codelengths of the order @xmath347 . moreover , for fixed @xmath345 and large @xmath31 , this leads to an asymptotic codelength of @xmath348 , compared to the @xmath349 of the binary schemes presented in this paper . for details , see @xcite .",
    "the authors are grateful to the anonymous reviewers for their valuable comments ."
  ],
  "abstract_text": [
    "<S> we construct binary dynamic traitor tracing schemes , where the number of watermark bits needed to trace and disconnect any coalition of pirates is quadratic in the number of pirates , and logarithmic in the total number of users and the error probability . </S>",
    "<S> our results improve upon results of tassa , and our schemes have several other advantages , such as being able to generate all codewords in advance , a simple accusation method , and flexibility when the feedback from the pirate network is delayed . </S>"
  ]
}