{
  "article_text": [
    "trees arise everywhere in computer science , and there are numerous formalisms in the literature for describing and manipulating trees",
    ". some of these formalisms are declarative and based on logical specifications : for example , first - order logic , monadic second - order logic , and various temporal and fixed - point logics over trees .",
    "others are procedural formalisms such as various flavors of tree automata , or tree transducers , or tree grammars .",
    "all these formalisms have found numerous applications in verification , program analysis , logic programming , constraint programming , linguistics , and databases .    until recently , most logical formalisms for trees dealt with _ ranked _",
    "trees @xcite : in such trees , all nodes have the same fixed number of children ( or , a bit more generally , the number of children of a node is determined by the label of that node ) . over the past several years , however , the focus has shifted towards _",
    "trees , in which there are no restrictions on the number of children a node can have . for example",
    ", the left tree in figure [ fig : example ] is a binary tree in which every non - leaf node has two children . in the second tree in figure [ fig : example ] , however , different nodes have a different number of children . although unranked trees have been considered in the 60s and 70s  @xcite , and are related to feature trees over an infinite set of features @xcite which are a particular kind of feature structures that have been investigated by computational linguists @xcite , their systematic study was initiated by the development of xml ( extensible markup language ) .",
    "xml is a data format which has become the lingua franca for information exchange on the world wide web . in particular , xml data is typically modeled as labeled unranked trees @xcite .    this connection has led to a renewed interest in logical and procedural formalisms for unranked trees .",
    "since xml trees are used to exchange _ data _ , the usual database query language paradigms apply : one uses logical formalisms for expressing declarative queries , and procedural formalisms for evaluating those declarative queries .",
    "logics over unranked trees defining a variety of query languages for them appeared in large numbers over the past 78 years , and they come in many flavors and shapes . what is common to them , however , is a close connection to automata models , and quite often to temporal and modal logics , especially when one describes properties of paths through a document .",
    "let us now review some of the parameters according to which logics for unranked trees can be classified .",
    "the yardstick logic : :    most formalisms are `` inspired '' by one of the two logics often used    in the context of trees : _ first - order logic _ ( fo ) , and _",
    "monadic    second - order logic _",
    "( mso ) that extends foby quantification over sets    of nodes .",
    "query languages and schema formalisms for xml tend to use    mso  as the yardstick : for example , xml document type definition ( dtds ,    or , more precisely , xsd  xml schema definition ) are essentially    equivalent to mso  sentences , and various languages for extraction of    data from xml documents , although being syntactically very different ,    have the power of mso  unary queries . on the other hand , navigational    aspects of xml , in particular , logics capturing various fragments of    xpath , are usually closely related to fo  and its fragments .",
    "arity of queries : :    most commonly one considers boolean or unary queries .",
    "boolean queries    are logical sentences and thus evaluate to _ true _ or _",
    "false_. for    example , checking if an xml document conforms to a schema    specification is represented by a boolean query .",
    "unary queries    correspond to formulae in one free variable , and thus produce a set of    nodes .",
    "for example , extracting sets of nodes , or evaluating xpath    expressions relative to the root naturally give rise to unary queries .",
    "complexity of model - checking / query - evaluation : :    the model - checking problem asks whether a tree @xmath0    satisfies a logical sentence @xmath1 , written    @xmath2 .",
    "if @xmath1 is an    msosentence @xmath1 , it can be evaluated in linear    time in the size of @xmath0 , by converting    @xmath1 to a tree automaton .",
    "but there is a price to    pay : in terms of the size of @xmath1 , the complexity    becomes non - elementary .",
    "this type of trade - off is one of the central    issues in dealing with logics over trees .",
    "similar issues arise with    evaluating formulae @xmath3 in trees , that is ,    finding tuples @xmath4 of nodes such that    @xmath5 .",
    "ordered vs.  unordered trees : :    in the standard definition of unranked trees in the xml context ,    children of the same node are ordered by a _",
    "sibling ordering_. if such    an order is present , we speak of ordered unranked trees . in many    cases , however , this ordering is irrelevant , and some unranked tree    models , such as feature trees , do not impose any ordering on siblings .",
    "there is considerable difference between the expressiveness of logics    and automata models depending on the availability of sibling ordering .",
    "the presence of ordering also affects the yardstick logic , since    without order often counting is needed to match the power of automata    models @xcite .",
    "the paper is organized as follows .",
    "after we give basic definitions in section [ notations - sec ] , we move to logics for ordered trees . in section [ ordered - sec ]",
    "we deal with mso - related logics , including syntactic restrictions of mso , a datalog - based logic , and the @xmath6-calculus . in section [ ordered - fo - sec ]",
    "we turn to fo - related logics , present analogs of ltl and @xmath7 that have been studied for expressing navigational properties , and also look at conjunctive queries over trees . in section [ unordered - sec ]",
    "we turn to trees that lack the sibling ordering , and show that in many logics some form of counting needs to be added to compensate for the missing ordering .",
    "we also review ambient and feature logics over edge - labeled trees . in section",
    "[ automatic - sec ] we look at the model - theoretic approach .",
    "we consider an infinite first - order structure whose universe is the set of all unranked trees and obtain some well - known classes of trees by studying first - order definability ( in the classic model - theoretic sense ) over that structure .",
    "nodes in unranked trees are elements of @xmath8  that is , finite strings whose letters are natural numbers .",
    "a string @xmath9 defines a path from the root to a give node : one goes to the @xmath10th child of the root , then to the @xmath11th child of that element , etc .",
    "we shall write @xmath12 for the concatenation of strings @xmath13 and @xmath14 , and @xmath15 for the empty string .",
    "we now define some basic binary relations on @xmath8 .",
    "the _ child relation _ is @xmath16 the _ next - sibling _ relation is given by : @xmath17 that is , @xmath18 and @xmath19 are both children of the same @xmath20 , and @xmath19 is next after @xmath18 in the natural ordering of siblings .",
    "we also use the _ first child relation _ : @xmath21 .",
    "these are shown in figure [ basic - rel - fig ] .    #",
    "1#2#3#4#5 @font    ( 6478,2110)(0,-10 ) ( 3450,1933)(1050,1333 ) ( 1159.141,1391.209)(1050.000,1333.000)(1173.693,1333.000)(1159.141,1391.209 ) ( 3450,1933)(1950,1333 ) ( 2050.275,1405.421)(1950.000,1333.000)(2072.559,1349.713)(2050.275,1405.421 ) ( 3450,1933)(2850,1333 ) ( 2913.640,1439.066)(2850.000,1333.000)(2956.066,1396.640)(2913.640,1439.066 ) ( 3450,1933)(3900,1333 ) ( 3804.000,1411.000)(3900.000,1333.000)(3852.000,1447.000)(3804.000,1411.000 ) ( 3450,1933)(4650,1333 ) ( 4529.252,1359.833)(4650.000,1333.000)(4556.085,1413.498)(4529.252,1359.833 ) ( 3450,1933)(5550,1333 ) ( 5426.375,1337.121)(5550.000,1333.000)(5442.859,1394.812)(5426.375,1337.121 ) ( 1050,1333)(1950,1333 ) ( 1830.000,1303.000)(1950.000,1333.000)(1830.000,1363.000 ) ( 1950,1333)(2850,1333 ) ( 2730.000,1303.000)(2850.000,1333.000)(2730.000,1363.000 ) ( 2850,1333)(3900,1333 ) ( 3780.000,1303.000)(3900.000,1333.000)(3780.000,1363.000 ) ( 3900,1333)(4650,1333 ) ( 4530.000,1303.000)(4650.000,1333.000)(4530.000,1363.000 ) ( 4650,1333)(5550,1333 ) ( 5430.000,1303.000)(5550.000,1333.000)(5430.000,1363.000 ) ( 6000,2083)(5999,2081)(5996,2078 ) ( 5991,2072)(5984,2062)(5974,2050 ) ( 5961,2034)(5945,2016)(5928,1996 ) ( 5909,1974)(5887,1952)(5865,1929 ) ( 5841,1907)(5817,1886)(5790,1866 ) ( 5762,1847)(5733,1830)(5701,1815 ) ( 5667,1802)(5630,1792)(5591,1785 ) ( 5550,1783)(5510,1785)(5472,1792 ) ( 5438,1802)(5409,1814)(5386,1829 ) ( 5367,1845)(5353,1862)(5343,1879 ) ( 5335,1897)(5330,1915)(5325,1933 ) ( 5320,1951)(5315,1969)(5307,1987 ) ( 5297,2004)(5283,2021)(5264,2037 ) ( 5241,2052)(5212,2064)(5178,2074 ) ( 5140,2081)(5100,2083)(5059,2081 ) ( 5020,2074)(4983,2064)(4949,2051 ) ( 4917,2036)(4888,2019)(4860,2000 ) ( 4833,1980)(4809,1959)(4785,1937 ) ( 4762,1914)(4741,1892)(4722,1870 ) ( 4705,1850)(4689,1832)(4676,1816 ) ( 4666,1804)(4650,1783 ) ( 4698.862,1896.633)(4650.000,1783.000)(4746.588,1860.271)(4700.908,1849.816)(4698.862,1896.633 ) ( 300,2083)(301,2081)(304,2078 ) ( 309,2072)(316,2062)(326,2050 ) ( 339,2034)(355,2016)(372,1996 ) ( 391,1974)(413,1952)(435,1929 ) ( 459,1907)(483,1886)(510,1866 ) ( 538,1847)(567,1830)(599,1815 ) ( 633,1802)(670,1792)(709,1785 ) ( 750,1783)(790,1785)(828,1792 ) ( 862,1802)(891,1814)(914,1829 ) ( 933,1845)(947,1862)(957,1879 ) ( 965,1897)(970,1915)(975,1933 ) ( 980,1951)(985,1969)(993,1987 ) ( 1003,2004)(1017,2021)(1036,2037 ) ( 1059,2052)(1088,2064)(1122,2074 ) ( 1160,2081)(1200,2083)(1241,2081 ) ( 1280,2074)(1317,2064)(1351,2051 ) ( 1383,2036)(1412,2019)(1440,2000 ) ( 1467,1980)(1491,1959)(1515,1937 ) ( 1538,1914)(1559,1892)(1578,1870 ) ( 1595,1850)(1611,1832)(1624,1816 ) ( 1634,1804)(1650,1783 ) ( 1553.412,1860.271)(1650.000,1783.000)(1601.138,1896.633)(1599.092,1849.816)(1553.412,1860.271 ) ( 3600,283)(3598,284)(3592,286 ) ( 3583,289)(3569,294)(3550,301 ) ( 3526,309)(3499,319)(3469,331 ) ( 3436,344)(3403,358)(3370,373 ) ( 3337,389)(3305,405)(3275,423 ) ( 3246,441)(3221,461)(3198,482 ) ( 3178,505)(3163,530)(3154,556 ) ( 3150,583)(3154,610)(3163,635 ) ( 3178,658)(3196,677)(3217,693 ) ( 3239,705)(3263,714)(3287,721 ) ( 3312,726)(3337,730)(3363,733 ) ( 3388,736)(3413,740)(3439,745 ) ( 3464,752)(3489,761)(3513,773 ) ( 3536,789)(3557,808)(3576,831 ) ( 3590,856)(3600,883)(3604,910 ) ( 3602,936)(3596,961)(3585,984 ) ( 3572,1005)(3555,1025)(3536,1043 ) ( 3515,1061)(3493,1077)(3470,1093 ) ( 3445,1108)(3421,1122)(3397,1135 ) ( 3375,1147)(3355,1157)(3337,1165 ) ( 3323,1172)(3300,1183 ) ( 3421.200,1158.289)(3300.000,1183.000)(3395.312,1104.161)(3375.779,1146.758)(3421.200,1158.289 ) ( 5925,1708)(0,0)[lb ] ( 3075,58)(0,0)[lb ] ( 0,1558)(0,0)[lb ]    we shall use @xmath22 to denote the reflexive - transitive closure of a relation .",
    "thus , @xmath23 is the _ descendant _ relation ( including self ) : @xmath24 iff @xmath18 is a prefix of @xmath19 or @xmath25 .",
    "the transitive closure of the next - sibling relation , @xmath26 is a linear ordering on siblings : @xmath27 iff @xmath28 .",
    "we shall be referring to younger / older siblings with respect to this ordering ( the one of the form @xmath29 is the oldest ) .",
    "a set @xmath30 is called _ prefix - closed _ if whenever @xmath31 and @xmath19 is a prefix of @xmath18 ( that is , @xmath32 ) , then @xmath33 .    a _ tree domain",
    "@xmath34 is a finite prefix - closed subset of @xmath8 such that @xmath35 implies @xmath36 for all @xmath37 .",
    "let @xmath38 be a finite alphabet .",
    "we define trees as _ structures _ that consist of a universe and a number of predicates on the universe .",
    "an _ ordered unranked tree _",
    "@xmath0 is a structure @xmath39 where @xmath34 is a tree domain , @xmath23 and @xmath26 are the descendant relation and the sibling ordering , and the @xmath40 s are interpreted as disjoint sets whose union is the entire domain @xmath34 .",
    "an _ unordered _ unranked tree is defined as a structure @xmath41 , where @xmath42 , and @xmath40 s are as above .",
    "thus , a tree consists of a tree domain together with a _ labeling _ on its nodes , which is captured by the @xmath40 predicates : if @xmath43 , then the label of @xmath18 is @xmath44 . in this case",
    "we write @xmath45 .",
    "notice that when dealing with unranked trees we assume that each node has one label .",
    "later we shall see a connection with temporal logics , where such a restriction on labeling is normally not imposed .",
    "however , one could always assume unique labeling in that case too , simply by collecting the set of all labels of a node ( in this case the labeling alphabet becomes @xmath46 ) .",
    "we shall only consider relational vocabularies , that is , finite lists @xmath47 of relation symbols , each @xmath48 with an associated arity @xmath49 .",
    "over trees , relation symbols will be either binary ( e.g. , @xmath50 ) or unary ( the @xmath40 s for @xmath51 ) .    formulae of _ first - order _ logic ( fo ) are built from atomic formulae @xmath52 , and @xmath53 , where @xmath54 are variables , and @xmath55 is a tuple of variables whose length equals the arity of @xmath56 , using the boolean connectives @xmath57 and quantifiers @xmath58 and @xmath59 . if a formula @xmath1 has free variables @xmath60 , we shall write @xmath3 .",
    "formulae are evaluated on a structure , which consists of a universe and interpretations for relations .",
    "quantifiers @xmath58 and @xmath59 range over the universe of the structure .",
    "for example , an fo  formula @xmath61 is true for nodes @xmath18 in a tree @xmath0 that are labeled @xmath44 , have a descendant labeled @xmath62 , which in turn has a younger sibling labeled @xmath63",
    ".    formulae of _",
    "monadic second - order _ logic ( mso ) in addition allow quantification over sets .",
    "we shall normally denote sets of nodes by upper case letters .",
    "thus , mso  formulae have the usual first - order quantifiers @xmath64 and @xmath65 as well as second - order quantifiers @xmath66 and @xmath67 , and new atomic formulae @xmath68 , where @xmath69 is a second - order variable and @xmath70 is a first - order variable .",
    "an mso  formula may have both free first - order and second - order variables .",
    "if it only has free first - order variables , then it defines a relation on the universe of the structure . as an example",
    ", an mso  formula @xmath71 given by the conjunction of @xmath72 and @xmath73 says that @xmath74 is a descendant of @xmath70 and the path between them is of odd length .",
    "it says that there exist two sets , @xmath69 and @xmath75 , that partition the path from @xmath70 to @xmath74 , such that @xmath76 , @xmath77 , and the successor of each element in @xmath69 is in @xmath75 , and the successor of each element in @xmath75 is in @xmath69 . in the formula above , @xmath78 is of course an abbreviation for @xmath79 and likewise for @xmath80 .",
    "note that the relations @xmath81 and @xmath82 are definable , even in fo , from @xmath23 and @xmath26 : for example , @xmath83 defines the child relation from @xmath23 . in mso",
    "one can define @xmath23 from @xmath81 by stating the existence of a path between two nodes ( and likewise @xmath26 from @xmath82 ) . however , it is well - known that in foone _ can not _",
    "define @xmath23 from @xmath81 ( cf .",
    "@xcite ) and this is why we chose @xmath23 and @xmath26 , rather than @xmath81 and @xmath82 , as our basic relations .",
    "however , in all the results about mso , we may assume that the basic relations are @xmath81 and @xmath82 .    in the introduction",
    ", we mentioned that we are mostly interested ( in this survey ) in boolean and unary queries .",
    "a boolean query over trees is just a set of trees closed under isomorphism ( that is , a query can not distinguish between two isomorphic trees ) .",
    "a unary query @xmath84 is a mapping that associates with each tree @xmath0 a subset @xmath85 of its domain .",
    "again , a query is required to be closed under isomorphism .",
    "given a logic @xmath86 , we say that a boolean query ( that is , a set @xmath87 of trees ) is definable in @xmath86 if there is a sentence @xmath1 of @xmath86 such that @xmath88 iff @xmath89 .",
    "we say that a unary query @xmath84 is definable in @xmath86 if there is a formula @xmath90 of @xmath86 such that @xmath91 iff @xmath92 , for every tree @xmath0 and a node @xmath18 in @xmath0 .",
    "a _ nondeterministic unranked tree automaton , nuta _ @xcite , over @xmath38-labeled trees is a triple @xmath93 where @xmath94 is a finite set of states , @xmath95 is the set of final states , and @xmath96 is a mapping @xmath97 such that @xmath98 is a regular language over @xmath94 ( normally represented by a regular expression over @xmath94 ) . a",
    "_ run _ of @xmath99 on a tree @xmath0 with domain @xmath34 is a function @xmath100 such that :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ if @xmath18 is a node with @xmath101 children , and it is labeled @xmath44 , then the string + @xmath102 is in @xmath103 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    this is illustrated in figure [ aut - run - fig ] . in particular ,",
    "if @xmath18 is a leaf labeled @xmath44 , then @xmath104 implies that @xmath105 .",
    "a run is _ accepting _ if @xmath106 , that is , the root is in an accepting state .",
    "a tree @xmath0 is _ accepted _ by @xmath99 if there exists an accepting run .",
    "we let @xmath107 denote the set of all trees accepted by @xmath99 .",
    "such sets of trees will be called _",
    "regular_.    # 1#2#3#4#5 @font    ( 4652,1693)(0,-10 ) ( 2412,1483)(12,883 ) ( 121.141,941.209)(12.000,883.000)(135.693,883.000)(121.141,941.209 ) ( 2412,1483)(912,883 ) ( 1012.275,955.421)(912.000,883.000)(1034.559,899.713)(1012.275,955.421 ) ( 2412,1483)(1812,883 ) ( 1875.640,989.066)(1812.000,883.000)(1918.066,946.640)(1875.640,989.066 ) ( 2412,1483)(2862,883 ) ( 2766.000,961.000)(2862.000,883.000)(2814.000,997.000)(2766.000,961.000 ) ( 2412,1483)(3612,883 ) ( 3491.252,909.833)(3612.000,883.000)(3518.085,963.498)(3491.252,909.833 ) ( 2412,1483)(4512,883 ) ( 4388.375,887.121)(4512.000,883.000)(4404.859,944.812)(4388.375,887.121 ) ( 12,883)(912,883 ) ( 792.000,853.000)(912.000,883.000)(792.000,913.000 ) ( 912,883)(1812,883 ) ( 1692.000,853.000)(1812.000,883.000)(1692.000,913.000 ) ( 1812,883)(2862,883 ) ( 2742.000,853.000)(2862.000,883.000)(2742.000,913.000 ) ( 2862,883)(3612,883 ) ( 3492.000,853.000)(3612.000,883.000)(3492.000,913.000 ) ( 3612,883)(4512,883 ) ( 4392.000,853.000)(4512.000,883.000)(4392.000,913.000 )    ( 12,583)(0,0)[lb ] ( 987,583)(0,0)[lb ] ( 2112,583)(0,0)[lb ] ( 3462,583)(0,0)[lb ] ( 4437,583)(0,0)[lb ]    ( 2462,1558)(0,0)[lb ]    ( 1000,58)(0,0)[lb ]",
    "there could be different representations of nutas , depending on how regular expressions over @xmath94 are represented .",
    "these issues are discussed in @xcite .",
    "a _ binary tree domain _ is a prefix - closed subset @xmath34 of @xmath108 such that if @xmath35 , then @xmath109 ( that is , a node is either a leaf , or both its children are in @xmath34 ) .",
    "it is common to define ( binary ) tree automata with both initial and final states , using the initial states to avoid conditions @xmath105 imposed in the runs of nutas .",
    "that is , a ( binary ) _ nondeterministic tree automaton , nta _ , is a quadruple @xmath110 where @xmath94 and @xmath111 are as before , @xmath112 is the initial state , and @xmath96 is a function @xmath113 . in this case",
    "a run @xmath114 on a binary tree @xmath0 with domain @xmath34 is a function from @xmath34 to @xmath94 such that if @xmath18 is a leaf labeled @xmath44 , then @xmath115 , and if @xmath116 belong to @xmath34 , and @xmath18 is labeled @xmath44 , then @xmath117 .",
    "as before , a run is accepting if @xmath118 , and @xmath119 is the set of all binary trees for which there exists an accepting run of @xmath120 .",
    "sets of trees of this form are regular sets ( of binary trees ) .",
    "there is a well - known regularity - preserving translation between unranked and ranked trees .",
    "it was first used in @xcite to show decidability of @xmath121 ( but here we shall apply it only to finite tree domains ) .",
    "the idea of the translation is that the first successor in the binary tree corresponds to the first child , and the second successor to the next sibling .",
    "more precisely , we define a mapping @xmath122 such that @xmath123 , and if @xmath124 , where @xmath125 , then @xmath126 and @xmath127 . or , equivalently , @xmath123 , and if @xmath124 , then @xmath128 .",
    "if @xmath34 is an unranked tree domain , we let @xmath129 be @xmath130 together with @xmath131 if @xmath18 is a non - leaf last child , and @xmath132 if @xmath18 a leaf , other than the last sibling ( these additions ensure that @xmath129 is a binary tree domain ) . we define @xmath133 to be a tree with domain @xmath129 , where @xmath134 has the same label as @xmath18 , and",
    "the added nodes are labeled by a symbol @xmath135 .",
    "an example is shown in figure [ fig : rabin - ex ] .",
    "the following is a folklore result .",
    "[ nuta - nta - lemma ] for every nuta @xmath99 , there is an nta @xmath120 such that @xmath136 , and conversely , for every nta @xmath120 there is an nuta @xmath99 such that the above holds .",
    "moreover , @xmath120 can be constructed from @xmath99 very fast , in dlogspace@xcite .",
    "other regularity - preserving translations from unranked trees to binary trees exist .",
    "for example , @xcite views unranked trees as built from labeled nodes by means of a binary operation @xmath137 that attaches @xmath138 at the new youngest child of the root of @xmath0 .",
    "this immediately yields a binary tree representation and an automaton construction , and of course an analog of lemma [ nuta - nta - lemma ] holds .",
    "in the next two sections we only deal with ordered unranked trees .    as we mentioned already , mso  is often used as a yardstick logic for trees , because of its close connection to regular languages .",
    "the following result belonged to folklore , and was explicitly stated in @xcite .",
    "[ mso - thm ] a set of unranked trees is regular iff it is definable in mso .",
    "when restricted to strings and binary trees , this corresponds to well - known results by bchi @xcite saying that mso  equals regular languages over strings , and by thatcher , wright @xcite , and doner @xcite , saying that mso  equals regular ( binary ) tree languages .",
    "there is also a close connection between automata , mso , and the common formalism for describing schemas for xml documents called dtds , which are essentially extended context - free grammars .",
    "a dtd @xmath139 over an alphabet @xmath38 is a collection of rules @xmath140 , where @xmath141 and @xmath142 is a regular expression over @xmath38 .",
    "we shall assume there is at most one such rule for each @xmath51 .",
    "a @xmath38-labeled tree @xmath0 satisfies @xmath139 , if for each node @xmath18 of @xmath0 with @xmath101 children , and @xmath45 , the string @xmath143 is in the language denoted by @xmath142 .",
    "we write @xmath144 for the set of trees that satisfy @xmath139 .",
    "each dtd is easily definable by an unranked tree automaton : in fact its states just correspond to labels of nodes .",
    "this , however , is too restrictive to capture full definability in mso .",
    "in fact , dtds ( that is , sets of the form @xmath144 ) are closed under neither unions nor complement , which makes dtds unsuitable for capturing a logic with disjunction and negation .",
    "however , a slight extension of dtds does capture mso .",
    "an _ extended dtd _ over @xmath38 is a triple @xmath145 where @xmath146 , with @xmath147 being a mapping @xmath148 , and @xmath149 is a dtd over @xmath150 .",
    "we say that a @xmath38-labeled tree @xmath0 satisfies @xmath145 if there is a @xmath151-labeled tree @xmath138 that satisfies @xmath149 such that @xmath152 ( more formally , @xmath0 is obtained by replacing each label @xmath44 in @xmath138 by @xmath153 ) .",
    "we write @xmath154 for the set of trees that satisfy @xmath145 .",
    "the following was established in @xcite and then restated using the dtd terminology in @xcite .",
    "a set of unranked trees is mso  definable iff it is of the form @xmath154 for some extended dtd @xmath145 .",
    "theorem [ mso - thm ] talks about mso  sentences , but it can be extended to unary mso  queries using the concept of _ query automata _ @xcite . a ( nondeterministic ) _ query automaton _ over unranked @xmath38-labeled trees is a quadruple @xmath155 where @xmath93 is an unta , and @xmath156 is a subset of @xmath157 .",
    "such a query automaton defines two unary queries @xmath158 and @xmath159 on unranked trees :    _ existential semantics query _ : :    :    @xmath160    iff @xmath161 for some accepting run @xmath162 .",
    "_ universal semantics query _ : :    :    @xmath163    iff @xmath161 for every accepting run @xmath162 .",
    "[ qa - thm ] ( see @xcite)for a unary query @xmath84 on unranked trees , the following are equivalent :    1 .   @xmath84 is definable in mso ; 2 .",
    "@xmath84 is of the form @xmath164 for some query automaton @xmath165 ; 3 .",
    "@xmath84 is of the form @xmath166 for some query automaton @xmath165 .",
    "query automata , just as usual tree automata , have a deterministic counterpart ; however , in the deterministic version , two passes over the tree are required .",
    "see @xcite for details .",
    "theorems [ mso - thm ] and [ qa - thm ] are constructive . in particular , every mso  sentence @xmath1 can be effectively transformed into an automaton @xmath167 that accepts a tree @xmath0 iff @xmath168 .",
    "since tree automata can be determinized , this gives us a @xmath169 algorithm to check whether @xmath168 , if @xmath1 is fixed . to denote the sizes of natural encodings of trees and formulae .",
    "] however , it is well - known that the size of @xmath167 ( even for string automata ) can not be bounded by an elementary function in @xmath170 @xcite . an even stronger result of @xcite says that there could be no algorithm for checking whether @xmath2 that runs in time @xmath171 , where @xmath172 is an elementary function , unless ptime = np .",
    "nonetheless , these results do not rule out the existence of a logic @xmath86 that has the same power as mso  and yet permits faster model - checking algorithms .",
    "even looking at a simpler case of fo  on strings , where results of @xcite also rule out @xmath173 algorithms for checking if a string @xmath18 satisfies @xmath1 , with @xmath172 being an elementary function , the logic ltl ( linear - time temporal logic ) has the same expressiveness as fo@xcite and admits a model - checking algorithm with running time @xmath174 .",
    "the first logic for unranked trees that has the power of mso  and model - checking complexity matching that of ltl appeared in @xcite and was called etl ( _ efficient tree logic _ ) .",
    "it was obtained by putting syntactic restrictions on mso  formulae , and at the same time adding new constructors for formulae , which are not present in mso , but are mso - definable .",
    "the atomic formulae of etl are the same as for mso , except that we are allowed to use both @xmath81 and @xmath23 and are _ not _ allowed to use the next - sibling relation @xmath26 .",
    "the formulae of etl are then closed under boolean combinations , _ guarded quantification _ , and _",
    "path formulae_. the rules for guarded quantification are as follows :    * if @xmath175 is an etl formula , then @xmath176 and @xmath177 are etl formulae ; * if @xmath178 is an etl formula , then @xmath179 is an etl formula . here",
    "@xmath180 means that @xmath69 only contains descendants of @xmath70 . in this case",
    "@xmath1 can not contain vertical path formulae ( defined below ) .",
    "path formulae are defined below , and illustrated in figure [ etl - fig ] .    *",
    "if @xmath181 is a regular expression over etl formulae of the form @xmath182 , then @xmath183 is a ( vertical path ) etl formula .",
    "the semantics is as follows : @xmath184 if there is a child - relation path @xmath185 in @xmath0 and a sequence of etl formulae @xmath186 , @xmath187 , such that @xmath188 for each @xmath187 , and the sequence @xmath189 matches @xmath181 . *",
    "if @xmath181 is a regular expression over etl formulae of the form @xmath190 , then @xmath191 is a ( horizontal path ) etl formula .",
    "then @xmath192 if children @xmath193 of @xmath18 can be labeled with etl formulae @xmath194 such that @xmath195 for all @xmath196 , and the sequence @xmath197 matches @xmath181 .    # 1#2#3#4#5 @font    ( 5337,3703)(0,-10 ) ( 2925,3676)(525,676)(5325,676)(2925,3676 ) ( 3675,1876)(2775,1576 ) ( 3675,1876)(3075,1576 ) ( 3675,1876)(3375,1576 ) ( 3675,1876)(3675,1576 ) ( 3675,1876)(4275,1576 ) ( 2625,2926)(2475,2626)(2175,2326)(2325,2026 ) ( 1875,1576)(1725,1276)(1875,976 ) ( 3825,1576)(0,0)[lb ] ( 2250,1876)(0,0)[lb ] ( 2175,1726)(0,0)[lb ] ( 2025,1651)(0,0)[lb ] ( 1875,1576)(0,0)[lb ] ( 2700,2851)(0,0)[lb ] ( 2550,2551)(0,0)[lb ] ( 1950,2251)(0,0)[lb ] ( 2400,1951)(0,0)[lb ] ( 1300,1201)(0,0)[lb ] ( 2740,1351)(0,0)[lb ] ( 3075,1351)(0,0)[lb ] ( 3300,1351)(0,0)[lb ] ( 3675,1351)(0,0)[lb ] ( 4200,1351)(0,0)[lb ] ( 2475,2851)(0,0)[lb ] ( 1975,950)(0,0)[lb ] ( 3675,1951)(0,0)[lb ] ( 500,76)(0,0)[lb ] ( 3525,76)(0,0)[lb ]    we also define a slight syntactic modification @xmath198 of etl , in which the closure under boolean connectives is replaced by a rule that formulae are closed under taking boolean combinations which are in dnf : that is , if @xmath199 s are @xmath198 formulae , then @xmath200 is an @xmath198 formula , where each @xmath201 is either @xmath199 or @xmath202",
    ". clearly the expressiveness of @xmath198 is exactly the same as the expressiveness of etl .",
    "[ etl - thm ] ( see @xcite )   with respect to boolean and unary queries , etl and mso  are equally expressive . furthermore , each @xmath198 formula @xmath1 can be evaluated on a tree @xmath0 in time @xmath203 .",
    "etl formulae can thus be evaluated in linear time in the size of the tree , and double exponential time in @xmath170 , by converting boolean combinations into dnf .",
    "it is not known if etl itself admits a @xmath203 model - checking algorithm .",
    "another approach to obtaining the full power of mso  while keeping the complexity low is based on the database query language _ datalog _ ( cf .",
    "@xcite ) ; it was proposed in @xcite .",
    "a datalog program can be viewed as a prolog program without function symbols .",
    "datalog is often used to extend expressiveness of database queries beyond fo .",
    "a datalog program consists of a sequence of rules @xmath204 where @xmath205 and all @xmath206 s are atoms : that is , atomic formulae of the form @xmath207 .",
    "the predicate @xmath205 is called the head of the rule , and @xmath208 are called its body .",
    "every variable that appears in the head is required to appear in the body . given a datalog program @xmath209 , predicates which appear as a head of some rule are called intensional , and other predicates are called extensional .",
    "if all intensional predicates are monadic ( that is , of the form @xmath210 ) , then @xmath209 is a _",
    "monadic _ datalog program .    given a datalog program @xmath209 with extensional predicates @xmath211 and intensional predicates @xmath212 , and a structure @xmath213 that interprets each @xmath214-ary predicate @xmath206 as @xmath215",
    ", we define @xmath216 as the least fixed point of the _ immediate consequence _ operator .",
    "this operator takes a structure @xmath217 and produces another structure @xmath218 such that a tuple @xmath219 is in @xmath220 if it is in @xmath221 or there is a rule @xmath222 and a tuple @xmath223 such that for each extensional predicate @xmath48 , the fact @xmath224 is true in @xmath225 , and for each intensional predicate @xmath48 , the fact @xmath224 is true in @xmath226 .",
    "a monadic datalog query is a pair @xmath227 where @xmath209 is a monadic datalog program , and @xmath205 is an intensional predicate .",
    "the value of @xmath205 in @xmath216 is the output of this program on @xmath225 .",
    "we consider three unary predicates on unranked tree domains : @xmath228 , @xmath229 , and @xmath230 . given a tree domain @xmath34 , they are interpreted as @xmath231    [ gk - thm ] ( see @xcite )   a unary query over unranked trees is definable in mso  iff it is definable in monadic datalog over extensional predicates @xmath232 ,",
    "@xmath82 , @xmath228 , @xmath229 , @xmath230 , and @xmath233 .",
    "furthermore , each monadic datalog query @xmath227 can be evaluated on a tree @xmath0 in time @xmath234 .    there are two proofs of this result in @xcite : one codes query automata in monadic datalog , and the other one uses the standard reduction to ranked trees and the composition method ( cf .",
    "@xcite ) for mso  games .",
    "yet another way of getting a logic equivalent to mso  is suggested by a close connection between mso  and the modal @xmath6-calculus @xmath235 on ranked trees , which can easily be extended to the unranked case by using the connection between ranked and unranked trees .",
    "it was shown in @xcite that every property of infinite binary trees definable in mso  is also definable in @xmath235 . to deal with unranked trees",
    ", we shall define @xmath235 over @xmath38-labeled structures that have several binary relations @xmath236 , cf .",
    "formulae of @xmath237 are given by @xmath238 where in @xmath239 , the variable @xmath69 must occur positively in @xmath1 .",
    "given a structure @xmath0 with domain @xmath34 , @xmath31 , and a valuation @xmath240 for free variables ( such that each @xmath241 is a subset of @xmath34 ) , we define the semantics by    * @xmath242 iff @xmath18 is labeled @xmath44 . *",
    "@xmath243 iff @xmath244 or @xmath245 .",
    "* @xmath246 iff @xmath247 is false . *",
    "@xmath248 iff @xmath249 . *",
    "@xmath250 iff @xmath251 for some @xmath19 with @xmath252 . *",
    "@xmath253 iff @xmath18 is in the least fixed point of the operator defined by @xmath1 ; in other words , if @xmath254,s ' ) \\models    { \\varphi}\\ } \\subseteq p\\},\\ ] ] where @xmath255 $ ] extends the valuation @xmath240 by @xmath256 .    we shall list explicitly binary relations @xmath257 , writing @xmath258 $ ] to refer @xmath237 formulae that only use those relations .",
    "an @xmath235 formula @xmath1 without free variables naturally defines a unary query on trees ( @xmath259 ) and a boolean query on trees ( by checking if @xmath260 ) .    using the translation into ranked trees ( or direct coding of automata ) , it is easy to show the following ( see @xcite ) :    [ bl - prop ] the class of boolean mso  queries on unranked trees is precisely the class of boolean queries defined by @xmath261 $ ] .",
    "if we consider unranked trees as structures with relations @xmath232 and @xmath82 , then they are acyclic , and hence the complexity of model checking is @xmath262 @xcite .",
    "furthermore , results of @xcite tell us that one can strengthen proposition [ bl - prop ] : mso  equals alternation - free @xmath235 over @xmath263 . for alternation - free @xmath235 formulae over unranked trees the complexity of model - checking further reduces to @xmath264 , matching the complexity of monadic datalog .",
    "it is also possible to characterize unary mso  queries over unranked trees in terms of the _ full _",
    "@xmath6-calculus @xmath265 ( cf .",
    "@xcite ) which adds backward modalities @xmath266 with the semantics    * @xmath267 iff @xmath268 for some @xmath19 such that @xmath269 .",
    "[ bl - thm ] ( see @xcite )   the class of unary mso  queries on unranked trees is precisely the class of queries defined by @xmath270 $ ] .",
    "there are other fixed - point constructions that have been shown to capture the power of automata and mso  over unranked trees ; see , e.g. @xcite .",
    "we continue dealing with ordered trees , but now we move to logics closely related to first - order , as opposed to monadic second - order .",
    "while a lot is known about fo  on both finite and infinite strings , it has not been nearly as extensively studied for trees until very recently .",
    "recall that over strings  which we can view as trees with only unary branching ",
    "fo  defines precisely the star - free languages ( cf .",
    "@xcite ) , and over both finite and infinite strings fo  has exactly the power of ltl @xcite .",
    "it can further be characterized by aperiodicity of the syntactic monoid ( cf .",
    "@xcite ) .",
    "in contrast , the natural analog of star - free expressions over binary trees captures not fo  but mso  @xcite .",
    "algebraic characterizations of fo - definable classes of binary trees have been obtained very recently @xcite , with @xcite showing that fo - definability ( without the descendant relation ) is decidable for regular tree languages .",
    "one well - known equivalent logical description of fo  on binary trees is hafer - thomas s theorem @xcite stating that over finite binary trees , @xmath271 ( @xmath7 is a branching time temporal logic widely used in verification , cf .",
    "@xcite , and it will be defined shortly ) .",
    "actually , the result of @xcite shows that @xmath7 is equivalent to mso  with second - order quantification over paths only , but over finite trees this fragment of mso  is equivalent to fo .",
    "the interest in logics over unranked trees whose power is equal to or subsumed by that of fo  stems from the fact that navigational features of xpath can be described in fo .",
    "xpath @xcite is a w3c standard for describing paths in xml documents .",
    "for example , an xpath expression @xmath272/c\\ ] ] produces the @xmath63-labeled children of @xmath44-labeled nodes having a @xmath62-labeled descendant . here",
    "@xmath273 denotes descendant , @xmath274 denotes child , and @xmath275 $ ] is a node test .",
    "the expression above looks for @xmath44-nodes ( descendants of the root ) in which the test @xmath276 $ ] is true ( the existence of a node labeled @xmath62 ) and from there it proceeds to children of such nodes labeled @xmath63 .",
    "while this is the syntax one typically finds in the literature on xpath , here we shall use a different syntax , highlighting connections with temporal logics .    in this section",
    "we shall look for connections between xpath , foon trees , and temporal logics , which are designed to talk about properties of paths .",
    "logics introduced in the context of studying xpath , and more generally , navigational properties of xml documents , can be roughly subdivided into two groups .",
    "firstly , one may try to establish analogs of kamp s theorem ( stating that @xmath277 over strings ) for trees .",
    "secondly , one can try to extend hafer - thomas s theorem ( the equivalence @xmath271 ) from binary to unranked trees .",
    "both ways are possible , and in both cases we get fo completeness results , stating that some temporal logics have precisely the power of unary fo queries .",
    "we start with ltl - like logics .",
    "first , recall the syntax of ltl over alphabet @xmath38 : @xmath278 formulae of ltl are interpreted over finite or infinite strings over @xmath38 : a formula is evaluated in a position in a string . given a string @xmath279 ,",
    "we define the semantics as follows :    * @xmath280 iff @xmath281 ; * @xmath282 ( `` next '' @xmath1 ) iff @xmath283 ; * @xmath284 iff @xmath285 ; * @xmath286 ( @xmath1 `` until '' @xmath287 ) if there exists @xmath288 such that @xmath289 and @xmath290 for all @xmath291 ; * the semantics of the dual @xmath292 ( @xmath1 `` since '' @xmath287 ) is that there exists @xmath293 such that @xmath289 and @xmath290 for all @xmath294 .",
    "note that it is possible to avoid @xmath295 and @xmath296 by defining a strict semantics for @xmath297 and @xmath298 , without requiring @xmath1 to be true in @xmath299 .",
    "we now consider a logic @xmath300 ( _ tree temporal logic _ , cf .",
    "@xcite ) defined as follows : @xmath301 where @xmath302 is either ch ( child ) or ns ( next sibling ) .",
    "we define the semantics with respect to a tree @xmath0 and a node @xmath18 in @xmath0 :    * @xmath303 iff @xmath45 ; * @xmath304 if @xmath305 for some @xmath196 ; * @xmath306 if @xmath307 for the node @xmath19 such that @xmath308 ; * @xmath309 if there is a node @xmath19 such that @xmath310 , @xmath311 , and for all @xmath312 satisfying @xmath313 we have @xmath314 .",
    "the semantics of @xmath315 is defined by reversing the order in the semantics of @xmath316 , and the semantics of @xmath317 , and @xmath318 is the same by replacing the child relation with the next sibling relation .",
    "@xmath300 naturally defines unary queries on trees , and it also defines boolean queries : we say that @xmath2 if @xmath260 .",
    "[ marx - tl - thm ] ( see @xcite)a unary or boolean query over unranked trees is definable in fo  iff it is definable in @xmath300 .    in @xmath7-like logics",
    ", there are two kinds of formulae : those evaluated in nodes of trees , and those evaluated on paths in trees .",
    "this is similar to the situation with xpath , which has filter expressions evaluated on nodes , and location path expressions , which are evaluated on paths in xml trees .",
    "we shall now present two logics : @xmath7 with the past , in the spirit of @xcite , and a @xmath319-like reformulation of xpath , as presented in @xcite .",
    "we start with xpath - inspired logics , and present them using a slight modification of the syntax that keeps all the main xpath constructions and yet makes the connection with temporal logics more visible .",
    "the language @xmath320 @xcite ( conditional xpath ) is defined to have _ node formulae _",
    "@xmath321 and _ path formulae _",
    "@xmath322 given by : @xmath323 where @xmath324 is one of the following : @xmath81 , @xmath325 , @xmath82 , or @xmath326 .",
    "intuitively @xmath327 states the existence of a path starting in a given node and satisfying @xmath322 , @xmath328 tests if @xmath321 is true in the initial node of a path , and @xmath274 is the composition of paths .    formally , given a tree @xmath0 , we evaluate each node formula in a node ( that is , we define @xmath329 ) , and each path formula in two nodes ( that is , @xmath330 ) .",
    "the semantics is then as follows ( we omit the rules for boolean connectives ) :    * @xmath303 iff @xmath45 ; * @xmath331 iff there is @xmath19 such that @xmath330 ; * @xmath332 iff @xmath25 and @xmath329 ; * @xmath333 iff @xmath334 ; * @xmath335 iff for some @xmath336 we have @xmath337 and @xmath338 ; * @xmath339 if there exists a sequence of nodes @xmath340 , @xmath341 , such that each @xmath342 is in @xmath324 , and @xmath343 for each @xmath344 .",
    "the language @xmath345 @xcite is obtained by only allowing @xmath346 as opposed to @xmath347 in the definition of path formulae . notice that since @xmath348 , where @xmath349 , we have @xmath350 .",
    "the earlier example of an xpath expression ( @xmath351/c$ ] ) can be represented in this syntax by a node formula @xmath352 saying that a node is labeled @xmath63 , and there is a path that starts by going to its parent , finding @xmath44 there , and then going to a descendant of that @xmath44 and finding a @xmath62 .",
    "@xmath345 corresponds to xpath as defined by the w3c @xcite , while @xmath320 represents an addition to xpath proposed by @xcite .",
    "this addition is essentially the `` until '' operator of temporal logic : for example , to represent the strict version of until ( that is , to say that in the next element of a path @xmath353 holds ) , one could write @xmath354 .    node formulae of either @xmath320 or @xmath345 naturally define unary queries on trees .",
    "these can be characterized as follows .",
    "[ marx - thm ] a ) ( see @xcite )  the node formulae of @xmath320 have precisely the power of fo  unary queries .",
    "\\b ) ( see @xcite )  the node formulae of @xmath345 have precisely the power of unary @xmath355 queries ( that is , @xmath356 with two variables ) in the vocabulary @xmath357 .",
    "part a ) of theorem [ marx - thm ] can also be extended to formulae in two free variables , see @xcite .",
    "the logics @xmath319 ( computation tree logic ) and @xmath7 are branching time temporal logics used in verification of reactive systems .",
    "they are normally defined without past connectives , but here we use the syntax close to that of @xcite to make it possible to reason about the past . in these logics , one also has node ( usually called state ) formulae and path formulae , but path formulae are evaluated on paths , not on arbitrary pairs of nodes .",
    "we define @xmath358 node formulae @xmath321 , and child and sibling path formulae @xmath359 and @xmath360 , as follows : @xmath361 given a tree , a child - path @xmath362 is a sequence of nodes on a path from the root to a leaf , and a sibling - path is a sequence @xmath363 of nodes of the form @xmath364 for a node @xmath18 with @xmath101 children .",
    "we define the semantics of node formulae with respect to a node in a tree , and of path formulae with respect to a path and a node on the path ( i.e. , we define the notion of @xmath365 , for @xmath302 being @xmath366 or @xmath367 ) .",
    "* @xmath368 if there exists a path @xmath369 such that @xmath370 and @xmath365 ; * @xmath371 if @xmath372 , where @xmath19 is the child of @xmath18 on path @xmath373 ; * @xmath374 if @xmath372 where @xmath19 is the parent of @xmath18 on @xmath373 ; * @xmath375 if for some @xmath376 such that @xmath377 and @xmath24 , we have @xmath378 , and for all @xmath379 , we have @xmath380 .",
    "the definitions for @xmath315 and for sibling - paths are analogous .",
    "the following can be seen as an analog of the equivalence @xmath271 for finite binary trees @xcite . while the proof the connection between ranked and unranked tree ,",
    "the straightforward translation from the binary tree fails because paths over translations of unranked trees may change direction between child and sibling - paths arbitrarily many times .",
    "[ ctlpast - thm ] ( see @xcite )   a unary or boolean query over unranked trees is definable in fo  iff it is definable in @xmath358 .      over strings ,",
    "fo  falls short of all regular languages , as it defines precisely the star - free ones .",
    "however , using arbitrary regular expressions is often convenient in the context of navigating in xml documents .    given a class @xmath381 of regular expressions ,",
    "define @xmath382 as an extension of fo  with the rules : ( i )",
    "if @xmath181 is a regular expression in @xmath381 over @xmath382 formulae @xmath182 , then @xmath183 is a formula , and ( ii ) if @xmath181 is a regular in @xmath381 over @xmath382 formulae @xmath383 , then @xmath384 is a formula .",
    "the semantics is the same as for the case of etl .",
    "if formulae @xmath385 are restricted to be boolean combinations of atomic formulae @xmath40 , @xmath141 , we obtain the logic @xmath386 .",
    "let starfree be the class of star - free expressions , and reg the class of all regular expressions .",
    "[ foreg - thm ] ( see @xcite )   a ) @xmath387 .",
    "\\b ) @xmath388 .    for more on @xmath389 and @xmath390 and their connections with fragments of mso  such as the path logic @xcite ,",
    "see @xcite .",
    "conjunctive queries are a very important class of database queries : they correspond to the @xmath391-fragment of fo .",
    "these are the same queries that can be expressed by selection , projection , and join in relational algebra , and thus they form the core of database queries . their complexity had been studied extensively . in general , the complexity of evaluating a conjunctive query @xmath1 over a database @xmath225 is in np , in terms of both the size of @xmath1 and the size of @xmath225 .",
    "in fact , the problem is np - hard , and there has been a large body of work on classifying tractable cases ( see , e.g. , @xcite ) .    in the case of unranked trees ,",
    "conjunctive queries are formulae of the form @xmath392 where each @xmath48 is either @xmath393 or @xmath394 , where @xmath395 are variables among @xmath396 , and @xmath397 is one of @xmath398 , @xmath82 , or @xmath26 .",
    "we write @xmath399 to denote the class of conjunctive queries over unranked trees in which only unary predicates @xmath40 and binary predicates among @xmath400 can be used .",
    "if we restrict ourselves to classes of conjunctive queries that use at most two binary predicates , then there is a complete classification for the complexity of query evaluation on unranked trees .",
    "[ gk - conj - thm ] ( see @xcite ) the maximal tractable classes of queries @xmath399 , where all @xmath400 s are among @xmath401 , @xmath402 , are @xmath403 and @xmath404 ; all others are np - hard .",
    "in fact , @xcite provided a more general ( but rather technical ) criterion for checking when evaluation is in ptime , and that condition can be used for other relations present in a query .",
    "conjunctive queries can also be used to capture all fo  over unranked tree , even if more than one free variable is used , assuming path formulae of @xmath320 can be used as atomic predicates .",
    "more precisely , every fo  formula @xmath3 over unranked trees is equivalent to a union of conjunctive queries whose atomic predicates are @xmath405 , where @xmath322 ranges over path formulae of @xmath320 @xcite .",
    "in unordered trees , nodes can still have arbitrarily many children , but the sibling ordering @xmath82 is no longer available .",
    "that is , we view trees as structures @xmath406 where @xmath34 is a tree domain , @xmath23 is the descendant relation , and @xmath40 s define the labels on @xmath34 .",
    "logics considered for unordered unranked trees typically introduce some form of _ counting _ , see @xcite .",
    "a simple explanation for this comes from a modified notion of unranked tree automata and query automata for unordered unranked trees .",
    "a _ counting nondeterministic unranked tree automaton _ is a tuple @xmath407 , where , as before , @xmath94 is a set of states , and @xmath95 is a set of final states . let @xmath408 be the set of variables @xmath409",
    ". then the transition function @xmath96 maps each pair @xmath410 , for @xmath411 and @xmath51 , into a boolean function over @xmath408 .",
    "a _ run _ of @xmath99 on an unordered tree @xmath0 with domain @xmath34 is then a mapping @xmath412 such that if @xmath413 for a node @xmath18 labeled @xmath44 , then the value of @xmath98 is @xmath414 , where each variable @xmath415 is set to @xmath414 if @xmath18 has at least @xmath416 children @xmath19 with @xmath417 , and to @xmath418 otherwise .",
    "a run is accepting if @xmath419 , and the set of unordered trees accepted by @xmath420 ( that is , trees for which there is an accepting run ) is denoted by @xmath421 .    a _ counting query automaton _ @xmath422 is defined as @xmath423 where @xmath424 ; it selects nodes @xmath18 in a run @xmath425 where @xmath426 . as before ,",
    "it can be given both existential and universal semantics .",
    "the following appears not to have been stated explicitly , although it follows easily from results in @xcite .    [ unordered - mso - thm ] a ) a set of unordered unranked trees is mso - definable iff it is of the form @xmath421 for a counting nondeterministic unranked tree automaton @xmath420 .",
    "\\b ) a unary query over unordered unranked trees is mso - definable iff it is definable by a counting query automaton @xmath422 under either existential or universal semantics",
    ".      now we look at several alternative characterizations of mso  and foover unordered unranked trees that exploit the counting connection .",
    "define the _",
    "counting @xmath6-calculus _ @xmath427 ( cf .",
    "@xcite ) as an extension of @xmath235 with formulae @xmath428 .",
    "the semantics of @xmath429 is as follows : there exist distinct elements @xmath430 such that @xmath431 and @xmath432 for every @xmath433 .",
    "the next result follows from @xcite , as was noticed in @xcite :    [ mso - child - thm ] over unordered unranked trees , @xmath434 and @xmath435 $ ] have precisely the same power with respect to boolean queries .",
    "in fact , it is not hard to show that @xmath434 can be translated into alternation - free @xmath427 , and thus evaluated with complexity @xmath436 , where @xmath1 is an alternation - free @xmath427 formula .    for first - order logic ,",
    "counting extensions of both the temporal logic @xmath300 and @xmath7 give us analogs of kamp s and hafer - thomas s theorems .",
    "we define @xmath437 as a version of @xmath300 in which only modalities for the child relation are used , but in addition we have formulae @xmath438 , with the semantics that @xmath439 iff there are at least @xmath416 children @xmath19 of @xmath18 such that @xmath307 .",
    "we also extend @xmath7 with counting . in this counting extension @xmath440",
    ", we have new state formulae @xmath441 , where @xmath321 is a state formula , with the same semantics as above .    [ fo - count - thm ] ( see @xcite )  over unordered unranked trees , the classes of boolean queries expressed in fo , @xmath437 , and @xmath440 over binary relation @xmath81 , are the same .    for unary queries ,",
    "the equivalence @xmath442 still holds @xcite , and @xmath356 can be shown to be equivalent to an extension of @xmath7 with both counting and the past @xcite .",
    "adding counting does not increase the complexity of model - checking in temporal logics , which is @xmath203 , cf .",
    "@xcite .",
    "unordered fragments of xpath have also been looked at in the literature .",
    "for example , @xcite showed that the restriction of positive ( no negation ) @xmath345 that only uses @xmath81 and @xmath23 is equivalent to existential positive fo  formulae over the vocabulary that includes both @xmath81 and @xmath23 .",
    "consider now a scenario in which we deal with unordered trees , but in our formulae we can refer to some arbitrary ordering on siblings : after all , in any encoding of a tree , siblings will come in some order .",
    "of course we do not want any particular order to affect the truth value , so we want our formulae , even if they use an ordering , to be independent of a particular ordering that was used .",
    "this is the standard setting of _ order - invariance _ , a very important concept in finite model theory , cf .",
    "we say that an mso  sentence @xmath1 over vocabulary including @xmath23 and @xmath26 is _ @xmath82-invariant _",
    "if for any unordered tree @xmath0 and any two expansions @xmath443 and @xmath444 with sibling - orderings @xmath445 and @xmath446 we have @xmath447 .",
    "any @xmath82-invariant sentence defines a boolean query on unordered trees .",
    "we now define @xmath448 @xcite as an extension of @xmath434 with _ modulo quantifiers _ : for each set variable @xmath69 , and @xmath449 , we have set new formulae @xmath450 which are true iff the cardinality of @xmath69 is congruent to @xmath418 modulo @xmath416 .",
    "[ cmso - thm ] ( see @xcite)over unordered unranked trees , @xmath82-invariant boolean queries are precisely the boolean queries definable in @xmath448 .    further extensions in terms of arithmetic power have been considered in @xcite .",
    "recall that presburger arithmetic refers to the fo   theory of the structure @xmath451 , and it is known that this structure admits quantifier elimination in the vocabulary @xmath452 where @xmath453 iff @xmath454 .",
    "we next define _ presburger mso _ , called pmso , as an extension of mso  over unordered trees with the following rule : if @xmath455 is a pmso  formula and @xmath456 a presburger arithmetic formula with @xmath457 , then @xmath458(\\bar x , y,\\bar x)$ ] is a pmso  formula . given valuation @xmath459 for free variables , with @xmath460 , let @xmath461 be the number of children of @xmath462 that belong to @xmath463 , that is , the cardinality of the set @xmath464 .",
    "then @xmath458(\\bar s , s_0,\\bar s)$ ] is true iff @xmath465 is true .",
    "it is easy to see that @xmath466 over unordered trees .",
    "still , pmso  is captured by a decidable automaton model .",
    "define presburger unordered tree automata just as counting automata except that @xmath96 maps pairs from @xmath467 into presburger formulae over @xmath468 , for @xmath469 .",
    "we interpret @xmath468 as the number of children in state @xmath470 , and a transition is enabled if the corresponding presburger formula is true in this interpretation .",
    "that is , in a run @xmath425 of such an automaton , if @xmath471 , the label of @xmath18 is @xmath44 and @xmath472 , then @xmath473 is true , where @xmath49 is the number of children @xmath19 of @xmath18 such that @xmath474 .",
    "[ pmso - thm ] ( see @xcite)presburger unordered tree automata and pmso  are equivalent",
    ". furthermore , both emptiness and universality are decidable for presburger unordered tree automata .",
    "further extensions with counting have been considered for fixed - point logics @xcite and the @xmath6-calculus with modulo - quantifiers @xcite .      while in the early days of tree - based data models",
    "there was some debate as to whether labels should be on edges or nodes , the arrival of xml seems to have settled that dispute .",
    "nonetheless , there are several areas where edge - labeled trees play a prominent and role , and traditionally logical formalisms have been designed for such data .",
    "first , there are logics for _ feature trees _ , which are a special case of feature structures used extensively in computational linguistics @xcite .",
    "second , in recent work on spatial logics , used for describing networks and mobile agents @xcite , one looks at modal logics over unordered edge - labeled trees .    in the setting of feature trees",
    ", one has an infinite set of features @xmath475 , and in an unordered unranked tree every edge is labeled by an element @xmath476 such that each node @xmath18 has at most one outgoing edge labeled @xmath172 for each @xmath476 .",
    "furthermore , nodes may be labeled by elements of some alphabet @xmath38 , as before .",
    "it is thus natural to model feature trees as structures @xmath477 such that the union of all @xmath478 s forms the child relation of a tree , and no node has two outgoing @xmath478-edges .    in the context of computational linguistics , one",
    "commonly used logic for feature trees @xcite is the propositional modal logic that , in the context of feature structures ( not necessarily trees ) , is also often supplemented with path - equivalence , stating that from a certain node , one can reach another node following two different paths .",
    "this is the setting of the kasper - rounds logic @xcite . over trees , however , path - equivalence is the same as equality of paths .",
    "a more powerful logic proposed in @xcite combined the kasper - rounds logic with the propositional dynamic logic .",
    "its formulae are defined by @xmath479 where @xmath480 are regular expressions over @xmath475 .",
    "formulae are evaluated in nodes of a feature tree @xmath0 .",
    "we have @xmath481 if there is a path @xmath482 such that @xmath483 and @xmath484 is a word in the language denoted by @xmath181 . furthermore , @xmath485 if there is a node @xmath19 that can be reached from @xmath18 by a word in @xmath181 as well as a word in @xmath486 .",
    "this semantics is normally considered over graphs , but over trees this is equivalent to saying that there is a node reachable by an expression in the language denoted by @xmath487 .",
    "that is , @xmath488 is equivalent to @xmath489 , and thus the kasper - rounds logic is effectively a reachability logic over trees .",
    "the reader is referred to @xcite for computational linguistics applications of this logic . in terms of expressiveness",
    "it is clearly contained in mso , and if all expressions @xmath480 are star - free , then in fo  as well , as long as we have the descendant relation .",
    "automata for feature trees , based on the algebraic approach to recognizability @xcite , were considered in @xcite ( which also showed that over flat feature trees the automaton model coincides with a simple counting logic ) .",
    "ambient logics are modal logics for trees that have been proposed in the context of mobile computation @xcite and later adapted for tree - represented data @xcite .",
    "one views trees as edge - labeled and defines them by the grammar @xmath490 , \\",
    "a\\in\\sigma,\\ ] ] with the equivalences that @xmath491 is commutative and associative , and that @xmath492 . here",
    "@xmath493 is the empty tree , @xmath491 is the parallel composition , and @xmath494 $ ] adds an @xmath44-labeled edge on top of @xmath0 .",
    "if we extend @xmath495 to a congruence in the natural way , then every tree is equivalent to one of the form @xmath496|\\ldots|a_m[t_m]$ ] , which is viewed as a tree whose root has @xmath497 outgoing edges labeled @xmath498 , with subtrees rooted at its children being @xmath499 .",
    "there were several similar logics proposed in @xcite .",
    "here we consider the logic from @xcite whose formulae are given by @xmath500\\ \\mid\\   { \\varphi}@a,\\ \\ \\ \\ a \\in \\sigma.\\ ] ] the semantics is as follows :    * @xmath501 is _ false _ ; * @xmath493 is only true in a tree equivalent to @xmath493 ; * @xmath502 iff @xmath503 with @xmath504 , @xmath505 ; * @xmath506 if for every @xmath138 with @xmath507 we have @xmath508 ; * @xmath509 $ ] iff @xmath510 $ ] with @xmath507 ; * @xmath511 iff @xmath494\\models{\\varphi}$ ] .",
    "variations appear in the literature , e.g. with the kleene star in @xcite and recursion in @xcite .",
    "the study of ambient logics for trees took a very different path compared to other logics seen in this survey ; in particular , the focus was on type systems for tree languages and thus on proof systems for logics , rather than model - checking , its complexity , automata models , and comparison with other logics .",
    "several lines of work closely resemble those for node - labeled trees : e.g. , @xcite introduced presburger conditions on children , defined an automaton model , and proved decidability , similarly to @xcite",
    ".    however , the ambient logic does not take us outside of the msoexpressiveness : this can be seen by going from edge - labeled trees to node - labeled ones .",
    "the translation is simple : the label of each edge @xmath512 becomes the label of @xmath74 .",
    "the root will have a special label @xmath230 that can not occur as a label of any other node .",
    "the only modification in the logic is that now we have formulae @xmath513 for @xmath51 , which are true in a singleton - tree labeled @xmath44 .",
    "the resulting logic is easily translated into mso . for example , @xmath514 states that the children of the root can be partitioned into two sets , @xmath69 and @xmath515 , such that the subtree that contains all the @xmath69-children satisfies @xmath1 and the subtree that contains all the @xmath515-children satisfies @xmath287 . for @xmath516",
    ", one can consider @xmath517 saying that there exists a tree @xmath138 such that @xmath507 and @xmath518 , and use nondeterministic counting automata to guess this tree @xmath138 .",
    "since moving labels from edges to nodes and back can be defined in mso , we see that the ambient logic is embedded into mso",
    ". however , to the best of the author s knowledge , this direction has never been seriously pursued , and the exact relationship between ambient logics and other logics described in this survey is still not well understood .",
    "in this section we look at a different kind of logics for unranked trees , using the standard approach of model theory .",
    "so far we represented each tree as a structure and looked at definability over that structure .",
    "now we want to consider structures whose universe is the set of _ all _ trees .",
    "definability over such structures allows us to describe sets of trees and , more generally , relations over trees . choosing the right operations on trees",
    ", we shall find structures where definable sets are precisely the regular languages .",
    "such structures are very convenient for proving that certain properties of trees are regular , as it is sometimes easier to define properties logically than to construct automata for them .",
    "let @xmath519 be the set of all @xmath38-labeled unranked trees .",
    "we consider structures of the form @xmath520 where @xmath521 is a set of relation , constant , and function symbols , interpreted over @xmath519 .",
    "let @xmath522 be the family of _ @xmath101-dimensional definable sets _ over @xmath523 : that is , sets of the form @xmath524 where @xmath525 is a first - order formula in the vocabulary @xmath521 .",
    "we shall be looking at structures @xmath523 so that definable sets would be relations definable in mso  or other logics .",
    "in particular , such relations will be given by automata , and thus structures @xmath523 of this kind are called _",
    "automatic structures_.      before we move to trees , we first survey automatic structures over strings , cf .  @xcite . in this case",
    "we consider structures of the form @xmath526 .",
    "our first example has the following relations in @xmath521 :    * @xmath397 is a binary relation ; @xmath527 is true iff @xmath18 is a prefix of @xmath19 ; * @xmath528 , @xmath141 , is a unary relation ; @xmath529 is true iff the last symbol of @xmath18 is @xmath44 ; * @xmath530 is a binary relation ; @xmath531 is true iff @xmath532 .",
    "let @xmath533 be the structure @xmath534 .",
    "then @xmath533 is the _",
    "universal automatic structure _ : that is , relations @xmath535 are precisely the regular relations . following a standard definition  see , e.g. , @xcite  we say that a relation @xmath536 is _ regular _ iff there is an automaton @xmath99 over alphabet @xmath537 that accepts precisely the strings @xmath538 $ ] , for @xmath539 .",
    "the length of @xmath538 $ ] is @xmath540 , and the @xmath541th symbol of @xmath538 $ ] is a tuple @xmath542 , where @xmath543 is the @xmath541th symbol of @xmath544 if @xmath545 , and @xmath546 otherwise .",
    "thus , @xmath547 contains exactly the regular languages over @xmath38 .",
    "furthermore , the conversion of formulae over @xmath533 to automata is effective @xcite and the theory of @xmath533 is decidable .",
    "in fact the theory of every structure that is interpretable in @xmath533 is thus decidable .    as an example , consider the structure @xmath548 . since it is isomorphic to @xmath549 , where @xmath550 is the lexicographic ordering ( which is easily definable in @xmath533 ) , we obtain the well - known decidability of @xmath548 .    a restriction of @xmath533 that does not have the equal length predicate , that is , @xmath551 is known to be strictly weaker that @xmath533 in every dimension :",
    "in particular , @xmath530 is not in @xmath552 , and @xmath553 is precisely the class of star - free languages @xcite .",
    "notice that both the empty string @xmath15 and functions @xmath554 are definable in @xmath555 , and hence another well - known theory interpretable in @xmath555 and @xmath533 is that of unary term algebras .",
    "however , it is known that for binary term algebras , adding relations like @xmath397 results in undecidable theories @xcite .",
    "in particular , if we want to keep an analog of the @xmath397-relation ( which is mso - definable ) , we can not introduce an operation like the @xmath491 operation in the ambient logic , and still have a decidable theory .      to get structures over @xmath519 that define regular languages and relations",
    ", we find natural analogs of @xmath397 , @xmath528 , and @xmath530 for trees . for two trees @xmath556 and @xmath557 with domains @xmath558 and @xmath559 , we say that @xmath557 is an _ extension _ of @xmath556 , written @xmath560 , if @xmath561 , and the labeling function of @xmath557 agrees with the labeling function of @xmath556 on @xmath558 .",
    "it will actually be more convenient to work with two extension relations :    extension on the right @xmath562 : :    : for @xmath563 , we require that    every @xmath564 be of the form @xmath565 when @xmath566 for some @xmath37 .",
    "extension down @xmath567 : :    : for @xmath568 , we require that    every @xmath564 have a prefix @xmath19    which is a leaf of @xmath556 .",
    "clearly @xmath569 iff there is @xmath138 such that @xmath570 and @xmath571 , so in terms of definability we do not lose anything by using @xmath562 and @xmath567 instead of @xmath572 .",
    "we define @xmath528 to be true in a tree @xmath0 if the rightmost node is labeled @xmath44 .",
    "that is , the node @xmath31 which is the largest with respect to @xmath550 is labeled @xmath44 . for the analog of @xmath530 , recall that in the standard representation of strings as first - order structures , the domain is an initial segment of @xmath573 , corresponding to the length of the string .",
    "hence , @xmath574 means that if strings are represented as structures , their domains are the same .",
    "we thus introduce a predicate @xmath575 such that @xmath576 iff @xmath577 ( there @xmath578 is the domain of @xmath579 ) .",
    "now we define analogs of @xmath533 and @xmath555 : @xmath580    [ unr - aut - thm ] ( see @xcite )   a ) for every @xmath581 , @xmath582 is precisely the class of regular @xmath101-ary relations over @xmath519 .",
    "\\b ) @xmath583 is the class of regular unranked tree languages , but for every @xmath584 , @xmath585 .",
    "notice the difference with the string case , where removing @xmath530 ( domain equality ) resulting in a smaller class of one - dimensional definable sets : star - free languages .",
    "on the other hand , even over binary trees , the notions of star - free and regular coincide @xcite .",
    "working with @xmath586 makes it easy to write rather complicated properties of tree languages , and then theorem [ unr - aut - thm ] implies that those languages are regular .",
    "for example , if @xmath587 is regular , then the set of trees @xmath0 such that all their extensions can be extended on the right to a tree in @xmath69 is regular .",
    "indeed , this is defined as @xmath588 , where @xmath589 defines @xmath69 ( by theorem [ unr - aut - thm ] , we know such @xmath589 exists )",
    ". then theorem [ unr - aut - thm ] again tells us that @xmath1 defines a regular language .",
    "furthermore , the conversions from formulae to automata are effective for both @xmath590 and @xmath586 , which implies decidability of their theories .",
    "other logics over unranked trees can be naturally represented over these structures .",
    "consider , for example , a restriction of first - order logic over @xmath590 or @xmath586 in which all quantification is over _ branches_. a branch is a tree @xmath0 such that the set @xmath591 is linearly ordered by @xmath572 .",
    "let @xmath592 be the class of sets of trees ( equivalently , boolean queries over trees ) definable in this restriction .",
    "[ eta - prop ] ( see @xcite )   @xmath593 is precisely the class of fo - definable boolean queries over unranked trees , and @xmath594 is the class of boolean queries definable in a restriction of mso  in which quantification is allowed only over sets linearly ordered by @xmath23 or by @xmath26 .    for more results of this type ,",
    "see @xcite .",
    "we conclude by presenting a different view of unranked trees and a different structure for them that makes it easy to talk about about their extensions in which new children may be inserted between existing ones .",
    "for example , if we have a tree @xmath0 with domain @xmath595 , and we want to add more children of the root , they would have to be added on the right , e.g , we may have an extension with domain @xmath596 . but",
    "what if we want to add a child on the left of @xmath418 , and two children between @xmath414 and @xmath597 ? intuitively , we need a new tree domain @xmath598 then .",
    "we now capture this situation and present a different automatic structure that makes it easy to derive that certain relations on trees are regular .",
    "a _ rational unranked tree domain _ is a finite prefix - closed subset of @xmath599 .",
    "relation @xmath23 is defined for rational domains just as before , and relation @xmath26 is now given by @xmath600 iff @xmath601 .",
    "then an unranked tree @xmath0 over a rational unranked tree domain is , as before , a structure @xmath602 .",
    "let @xmath603 be the set of all unranked trees with rational unranked tree domains .",
    "note that different trees in @xmath603 may be isomorphic ; we denote this isomorphism relation by @xmath604 .",
    "there is a natural one - to - one correspondence between @xmath605 and @xmath519 .",
    "we define the extension relation @xmath572 over trees in @xmath603 as before . a _ branch _ , again , is a tree @xmath606 such that the set @xmath607 is linearly ordered by @xmath572 .",
    "it follows from the definition of rational unranked tree domains that the domain of a branch consists of all the prefixes of some string @xmath608 ; i.e. , it is completely determined by @xmath18 , which is its unique leaf .",
    "let @xmath609 be true iff @xmath0 is a branch whose leaf is labeled @xmath44 , and let @xmath610 be true iff @xmath556 and @xmath557 are branches with leaves @xmath13 and @xmath14 , and @xmath611 .",
    "we then define the structure @xmath612 in this structure it is much easier to reason about tree extensions that allow one to insert nodes between existing ones , and not only on the right or under the leaves .",
    "but what about definable sets and relations over @xmath613 ?",
    "it turns out that they are all regular .",
    "more precisely , we can interpret @xmath613 in @xmath586 : that is , find a set @xmath614 , binary relations @xmath615 and sets @xmath616 , @xmath51 , such that @xmath617 is isomorphic to @xmath613 .",
    "that is , we have :    [ rational - prop ] the structure @xmath613 is interpretable in @xmath586 .",
    "furthermore , there is a definable subset of the image of @xmath603 that contains exactly one representative of each @xmath604-equivalence class .    that is , under the mapping @xmath618 , definable sets and relations over @xmath613 become precisely the regular tree languages ( and relations ) .",
    "hence , expressing properties of unranked trees in first - order logic over @xmath613 allows us to conclude easily that certain tree languages are regular , and thus mso - definable .",
    "we present here a somewhat random sample of other directions that work on logics for unranked trees has taken or may take in the future .",
    "we concentrate on streaming applications , and then briefly describe other directions .",
    "# 1#2#3#4#5 @font    ( 1698,1500)(0,500 ) ( 975,1275)(375,675 ) ( 975,1275)(375,675 ) ( 438.640,781.066)(375.000,675.000)(481.066,738.640)(438.640,781.066 ) ( 975,1275)(1425,675 ) ( 975,1275)(1425,675 ) ( 1329.000,753.000)(1425.000,675.000)(1377.000,789.000)(1329.000,753.000 ) ( 375,675)(75,225 ) ( 375,675)(75,225 ) ( 116.603,341.487)(75.000,225.000)(166.526,308.205)(116.603,341.487 ) ( 375,675)(375,225 ) ( 375,675)(375,225 ) ( 345.000,345.000)(375.000,225.000)(405.000,345.000)(345.000,345.000 ) ( 375,675)(675,225 ) ( 375,675)(675,225 ) ( 583.474,308.205)(675.000,225.000)(633.397,341.487)(583.474,308.205 ) ( 1425,675)(1275,225 ) ( 1425,675)(1275,225 ) ( 1284.487,348.329)(1275.000,225.000)(1341.408,329.355)(1284.487,348.329 ) ( 1425,675)(1575,225 ) ( 1425,675)(1575,225 ) ( 1508.592,329.355)(1575.000,225.000)(1565.513,348.329)(1508.592,329.355 ) ( 975,1350)(0,0)[lb ] ( 225,675)(0,0)[lb ] ( 300,0)(0,0)[lb ] ( 675,0)(0,0)[lb ] ( 1500,600)(0,0)[lb ] ( 1275,0)(0,0)[lb ] ( 1575,0)(0,0)[lb ] ( 0,0)(0,0)[lb ]    [ [ streaming - xml - documents ] ] streaming xml documents + + + + + + + + + + + + + + + + + + + + + + +    a typical xml document is a sequence of matching opening and closing tags , with some data between then .",
    "for example , the sequence of opening and closing tags corresponding to a tree is shown in figure [ fig - stream ] .",
    "thus , an xml tree naturally has a string representation .",
    "for example , for the tree in figure [ fig - stream ] , such a representation is @xmath619 where we use a label , say @xmath44 , for the opening tag ` < a > ` , and @xmath620 for the closing tag ` < /a > ` . more generally , for an ordered unranked tree @xmath0 we define inductively its string representation @xmath621 :    * if @xmath0 is a single node labeled @xmath44 , then @xmath622 * if @xmath0 has a root labeled @xmath44 , with @xmath101 children @xmath623 , such that @xmath579 is the subtree rooted at @xmath544 , @xmath624 , then @xmath625 .",
    "if an xml document @xmath0 is transmitted as a stream , then the object we work with is precisely @xmath621 .",
    "furthermore , we may not have the whole string @xmath621 available , or may need to compute some of its properties without looking at the whole string ( for instance , a device receiving the stream may have memory limitations and can not store the entire stream ) .",
    "one possible model for this scenario was proposed in @xcite : in this model , one processes the stream @xmath621 by using a finite _ string _ automaton .",
    "it is natural to ask then what kinds of properties of trees can be recognized by finite automata that run on their streamed representations .",
    "more precisely , one is interested in tree languages of the form @xmath626 where @xmath99 is a string automaton .",
    "this question has been primarily addressed in the context of dtd validation .",
    "namely , given a dtd @xmath139 , is it possible to find an automaton @xmath627 such that @xmath628 in general , the answer is negative , as was shown in @xcite .",
    "we now sketch a very simple proof of this .",
    "consider the following dtd @xmath629 : @xmath630 suppose @xmath631 for some @xmath99 .",
    "the regular language given by @xmath99 is definable in mso , say by a sentence of quantifier rank @xmath632 .",
    "choose numbers @xmath101 and @xmath416 so that @xmath633 and @xmath634 can not be distinguished by mso sentences of quantifier rank @xmath632 , and consider two strings : @xmath635 which in turn ( by a standard composition argument , see , e.g. , @xcite ) can not be distinguished by @xmath99 .",
    "one clearly has @xmath636 for some @xmath637 , and @xmath638 for a tree @xmath639 , where @xmath640 is @xmath641 which contradicts the assumption @xmath631 .",
    "while @xcite provides many results on streamed validation of dtds , the problem of characterizing dtds that can be checked by finite automata over streamed representations remains open .",
    "such a characterization can be found for mso - definable properties as follows .",
    "given an mso  sentence @xmath1 over ordered unranked trees , we say that @xmath1 is streamable if @xmath642 is of the form @xmath643 for some finite string automaton @xmath99 .",
    "let @xmath18 be a node in a tree @xmath0 ; define @xmath644 ( the right - most ancestor ) to be the smallest prefix of @xmath18 such that each node @xmath19 with @xmath645 is the largest in the @xmath26 ordering .",
    "this naturally defines a string of labels , by collecting all labels of nodes between @xmath644 and @xmath18 .",
    "we denote this string by @xmath646 .",
    "for example , if @xmath18 is the rightmost node in the tree shown in fig .",
    "[ fig - stream ] , then @xmath647 .",
    "finally , for each regular language @xmath648 over strings , we write @xmath649 iff @xmath650 .",
    "the following is due to segoufin and the author .",
    "[ luc - prop ] an @xmath434 sentence @xmath1 over ordered unranked trees is streamable iff it is expressible in mso  over the vocabulary that includes @xmath232 , @xmath651 , and @xmath652 , where @xmath648 ranges over regular languages .",
    "however , the decidability of checking whether an mso  sentence belongs to the fragment of proposition [ luc - prop ] remains open .",
    "some recent results on processing queries over streaming data ( especially xpath queries ) can be found in @xcite .",
    "this survey has concentrated primarily on boolean and unary queries .",
    "while these are sufficient in many applications , there are formalisms that require more general @xmath101-ary queries . for example , the core expressions of xquery can be seen as rearranging arbitrary @xmath101-tuples of nodes selected from a tree as another tree .",
    "the logical study of xquery is just beginning @xcite , and there are several papers that show how to extend results from logics that define boolean and unary queries to arbitrary @xmath101-ary queries . for example , @xcite does it for queries definable in @xmath389-like logics . using a similar approach ,",
    "@xcite shows how to combine temporal logics over trees to define @xmath101-ary queries .",
    "an extension of unranked tree automata to @xmath101-ary queries is presented in @xcite .",
    "2 .   while we have a number of logics that provide a declarative approach to expressing properties of trees and yet match ( or are close to ) the complexity of the procedural automata formalism , it is not really understood what causes certain logics to have such a nice behavior .",
    "there must be some intrinsic properties of logics that lead to good model - checking algorithms ( in a way similar to , say , finite- or tree - model properties being an explanation for decidability ) .",
    "3 .   closely related to the first item",
    "is the issue of succinctness of logics , measured as the size of formulae needed to express certain properties",
    ". initial investigation on the issue of succinctness for logics on ranked trees was done in @xcite and some logics have been shown to be much more succinct than others , but more needs to be done . in view of the standard translation between ranked and unranked trees , it is likely that results for binary trees will be sufficient .",
    "4 .   the connection between fo , mso , temporal logics and logics used in the programming languages and computational linguistics communities must be understood .",
    "the focus was quite different , as we mentioned earlier : for example , many questions about the complexity and expressiveness of ambient logics are unresolved .",
    "some very recent results in this direction are reported in @xcite .",
    "xml trees in addition to labels have data values associated with some nodes ( typically attribute values or pcdata values ) .",
    "adding values from a potentially infinite set and just equality over them immediately leads to undecidable formalisms .",
    "this is observed , in particular , in the study of xml constraints .",
    "some typically considered constraints include keys and foreign keys , that arise naturally when relational data is converted into xml .",
    "keys say that a certain sequence of attributes identifies a node uniquely .",
    "a key is unary if it consists of one attribute ( for example , a unique i d would be a unary key , while a pair ( firstname , lastname ) can be a key consisting of two attributes ) .",
    "a foreign key states that a sequence of attributes of each node labeled by @xmath653 should also occur as a sequence of attributes of some other node labeled @xmath654 .",
    "+ xml specifications may consist of dtds together with constraints .",
    "however , their interaction could be quite complicated .",
    "in fact , @xcite showed that it is undecidable whether a specification that consists of a dtd and a set of keys and foreign keys is consistent .",
    "however , if all keys and foreign keys are unary , then consistency checking is np - complete .",
    "+ it would be nice to find a purely logical explanation for this type of results .",
    "decidability restrictions studied in @xcite are very weak for this purpose .",
    "however , a recent line of results shows much more promise .",
    "consider trees that can carry data values , and assume that we can test them for equality , that is , we have a binary relation @xmath655 that is true if two nodes in a tree have the same data values .",
    "then @xmath355 over such trees with the @xmath655 relation and the successor relation is decidable @xcite . here",
    "@xmath355 refers to fo  with two variables .",
    "notice that for expressing unary constraints two variables suffice .",
    "it is open whether the descendant can be added while preserving decidability ; the only resolved case is that of strings , where indeed @xmath355 over the successor relation , the linear ordering , and the @xmath655 relation is decidable @xcite .",
    "i am grateful to cristiana chitic , christoph koch , maarten marx , frank neven , joachim niehren , gerald penn , thomas schwentick , luc segoufin , anthony widjaja to , and the referees for their comments on the paper .",
    "i also thank luc segoufin for his permission to include proposition [ luc - prop ] in the survey .",
    "this work was supported by grants from nserc and cito .",
    "p.  blackburn .",
    "structures , languages and translations : the structural approach to feature logic . in _",
    "constraints , language and computation _ , edited by c. rupp , m. rosner and r. johnson , academic press , 1994 , pages 127 .",
    "a.  brggemann - klein , m.  murata , and d.  wood .",
    "regular tree and regular hedge languages over unranked alphabets : version 1 , 2001 .",
    "technical report hkust - tcsc-2001 - 0 , the hongkong university of science and technology , 2001 ."
  ],
  "abstract_text": [
    "<S> labeled unranked trees are used as a model of xml documents , and logical languages for them have been studied actively over the past several years . </S>",
    "<S> such logics have different purposes : some are better suited for extracting data , some for expressing navigational properties , and some make it easy to relate complex properties of trees to the existence of tree automata for those properties . </S>",
    "<S> furthermore , logics differ significantly in their model - checking properties , their automata models , and their behavior on ordered and unordered trees . in this paper </S>",
    "<S> we present a survey of logics for unranked trees .    </S>",
    "<S> [ thm]example [ thm]lemma [ thm]proposition [ thm]corollary    = 0.27 cm </S>"
  ]
}