{
  "article_text": [
    "in this paper , we introduce top trees as a new simpler interface for data structures maintaining information in a fully - dynamic forest . here",
    "fully - dynamic means that edges may be both inserted and deleted .",
    "the information could be , say , the diameter of each tree in the forest .",
    "however , if the tree is a minimum spanning tree of a dynamic graph , the information could help changing the minimum spanning tree as the graph changes",
    ".    technically speaking , top trees are easily implemented either with frederickson s topology trees @xcite or with sleator and tarjan s dynamic trees @xcite .",
    "the contribution of top trees is the _ design _ of an interface providing users with easier access to the full power of these advanced techniques .",
    "targeting a broad audience of potential users , the bulk of this paper is like a tutorial where we demonstrate the flexibility of top trees in different types of applications :    * we re - derive some of the classic applications from @xcite , e.g. , finding the maximum weight of a given path . *",
    "we improve some previous bounds .",
    "more specifically , we show how to maintain the centers and medians of trees in a dynamic forest in @xmath0 time per updates .",
    "the previous bounds were @xmath3 time @xcite .",
    "* we consider problems that appear not to have been studied before for a dynamic forest .",
    "for example , we show how to maintain the diameters of trees in a dynamic forest .",
    "we also show how to answer level ancestor and nearest common ancestor queries with respect to arbitrary roots . finally , with marked and unmarked vertices , we show how to compute distances to a nearest marked vertex . in all of these cases",
    ", we support both updates and queries in logarithmic time .",
    "the marking result has applications to approximate nearest marked vertex in general graphs , and thereby to static optimization problems over shortest path metrics .",
    "we note that finding medians and centers is more difficult than , e.g. , finding the minimum edge on a given path because they are `` non - local '' properties . here , by a _ local property _ we mean that if an edge or a vertex has the property in a tree , then it has the property in all subtrees it appears in .",
    "local properties lend themselves nicely to bottom - up computations , whereas non - local properties tend to be more challenging . building on top of our top trees ,",
    "we present here a quite general technique for dealing with non - local properties .",
    "we implement our top trees with frederickson s topology trees  @xcite , which we in turn implement with sleator and tarjan s _ st - trees _  @xcite .",
    "the implementation of topology trees with st - trees was not known .",
    "it has the interesting consequence that the simple amortized version of st - trees gives a simple amortized version of topology trees .",
    "we note that since top trees were originally announced @xcite , they have found applications in other works  @xcite .",
    "all these applications rely on results presented in this paper .",
    "also , our specific result for dynamic tree diameters has found its own application in @xcite .",
    "most of this paper concerns a forest of trees , which means that if vertices @xmath4 and @xmath5 are connected , they are connected by a unique path , which we shall denote @xmath6 .",
    "when we talk about an edge @xmath7 , on an implementation level , we often really think of an identifier @xmath8 of the undirected edge with end - points @xmath4 and @xmath5 . via arrays",
    ", the end - points can be found from the identifier @xmath8 in constant time .",
    "however , other information can also be associated with @xmath8 such as its successor and predecessor in the incidence lists around @xmath4 and @xmath5 .",
    "the paper is organized as follows . in ",
    "[ sec : toptrees ] we introduce top trees and solve the diameter problem . in   [ secfind ]",
    "we present our technique for non - local problems , and solve the center and median problems . in   [",
    "lem : method ] we discuss the advantages and limitations of using top trees relative to other data structures for dynamic trees . in   [ gen ] we mention some generalizations of top trees used in later papers .",
    "finally , in   [ sec : implement ] we implement top trees with topology trees and topology trees with st - trees .",
    "finally , we have some concluding remarks in   [ sec : conclussion ] .",
    "a top tree is defined based on a pair consisting of a tree @xmath9 and a set @xmath10 of at most 2 vertices from @xmath9 , called _ external boundary vertices_. given @xmath11 , any subtree @xmath12 of @xmath9 has a set @xmath13 of _ boundary vertices _ which are the vertices of @xmath12 that are either in @xmath10 or incident to an edge in @xmath9 leaving @xmath12 . here , by a _ subtree _ of an undirected tree , we mean any connected subgraph .",
    "the subtree @xmath12 is called a _ cluster _ of @xmath11 if it has at least one edge and at most two boundary vertices .",
    "then @xmath9 is itself a cluster with @xmath14 . also , if @xmath15 is a subtree of @xmath12 , @xmath16 , so @xmath15 is a cluster of @xmath17 if and only if @xmath15 is a cluster of @xmath11 .",
    "since @xmath18 is a canonical generalization of @xmath19 from @xmath9 to all subtrees of @xmath9 , we will use @xmath19 as a shorthand for @xmath18 in the rest of the paper .",
    "a _ top tree _ @xmath20 over @xmath11 is a binary tree such that :    1 .",
    "the nodes of @xmath20 are clusters of @xmath11 .",
    "the leaves of @xmath20 are the edges of @xmath9 .",
    "sibling clusters are _ neighbors _ in the sense that they intersect in a single vertex , and then their parent cluster is their union ( see fig .",
    "[ fig : top ] ) .",
    "the root of @xmath20 is @xmath9 itself .",
    "a tree with a single vertex has an empty top tree .",
    "the basic philosophy is that clusters are induced by their edges , the vertices only being included as their end - points .",
    "this is why clusters need at least one edge , and we note that neighboring clusters are induced by disjoint edge sets inducing a common vertex .",
    "we will sometimes refer to the tree @xmath9 as the _ underlying _ tree to differentiate it from the _ top _ tree @xmath21 .",
    "the top trees over the trees in our underlying forest are maintained under the following _ forest updates _ :    where @xmath4 and @xmath5 are in different trees , links these trees by adding the edge @xmath7 to our dynamic forest .",
    "removes the edge @xmath8 from our dynamic forest .",
    "where @xmath4 and @xmath5 are in the same tree @xmath9 , makes @xmath4 and @xmath5 the external boundary vertices of @xmath9 .",
    "moreover , @xmath22 returns the new root cluster of the top tree over @xmath9 .",
    "@xmath22 can also be called with zero or one vertices as argument if we want less than two external boundary vertices .",
    "if @xmath22 is called with zero arguments , as @xmath23 , it does not return a root cluster .",
    "this is because there may be multiple trees , and without an argument , @xmath22 can not know what tree we are interested in .",
    "finally , it is guaranteed that @xmath23 does not change the structure of the top trees .",
    "it only affects some of the boundaries of the clusters in the top trees .",
    "in general , @xmath24 and @xmath25 make the set of external boundary vertices for the resulting trees empty . to accommodate these forest updates ,",
    "the top trees are changed by a sequence of local _ top tree modifications _ described below . during these modifications , we will temporarily accept a _ partial _ top tree whose root cluster may not be a whole underlying tree @xmath9 but just a cluster of @xmath9 .    creates a top tree with a single cluster @xmath8 which is just an edge .    where @xmath15 and @xmath26 are neighboring root clusters of two top trees @xmath27 and @xmath28 .",
    "creates a new cluster @xmath29 and makes it the common root of @xmath15 and @xmath26 , thus turning @xmath27 and @xmath28 into a single new top tree @xmath30 . finally , the new root cluster @xmath12 is returned .    where @xmath12 is the root cluster of a top tree @xmath30 and has children @xmath15 and @xmath26 .",
    "deletes @xmath12 , thus turning @xmath30 into the two top trees @xmath31 and @xmath32 .",
    "finally , the root clusters of @xmath31 and @xmath32 are returned .",
    "eliminates the top tree consisting of edge @xmath8 .",
    "top tree modifications have to be applied in the following order :    1 .",
    "[ st : split ] first , top - down , we perform a sequence of @xmath33s .",
    "[ st : destroy ] then we @xmath34 the clusters of some edges . 3 .",
    "[ st : update ] then we update the forest .",
    "[ st : create ] then we @xmath35s clusters of some edges",
    "[ st : join ] finally , with @xmath36s , we recreate the top tree bottom - up .",
    "the above order implies that when we do a @xmath33 or @xmath36 , we know that all parts of the underlying forest is partitioned into base clusters .",
    "it is an important rule that _ a forest update may not change any current cluster_. here , a cluster is changed by a forest update if the update changes its set of edges or its set of boundary vertices . to appreciate the latter ,",
    "consider an update @xmath37 .",
    "this update only changes clusters with @xmath4 an interior vertex . a cluster in which @xmath4 is already a boundary vertex is not changed .",
    "satisfying the rule means that when we get to the update in step [ st : update ] , the previous steps [ st : split][st : destroy ] should have eliminated all clusters that would be changed by the update .",
    "it is often natural to perform a _ composite sequence of updates _ in step [ st : update ] .",
    "for example , if dealing with a spanning tree @xmath9 , we might want to swap one tree edge @xmath38 with another edge @xmath39 .",
    "if we do @xmath40 as a composite update rather than as two separate updates , we avoid dealing with a temporary forest when we do the top tree modifications in steps [ st : split][st : destroy ] and [ st : create][st : join ] .    in this paper",
    ", we are going to show the following result :    [ thm : top - maintain ] for a dynamic forest we can maintain top trees of height @xmath0 supporting each @xmath24 , @xmath25 , or @xmath22 with a sequence of @xmath41 @xmath35 and @xmath34 , and @xmath0 @xmath36 and @xmath33 .",
    "these top tree modifications are identified in @xmath0 time .",
    "the space usage of the top trees is linear in the size of the dynamic forest . for a composite sequence of @xmath2 updates ,",
    "each of the above bounds are multiplied by @xmath2 .",
    "the proof of theorem  [ thm : top - maintain ] is deferred to ",
    "[ sec : implement ] . until then",
    ", the focus will be on applications of top trees .",
    "put in perspective , our top trees are natural generalizations of standard balanced binary trees over dynamic collections of lists that may be concatenated and split . in the balanced binary trees ,",
    "each node represents a segment of a list , which in top terminology is just a special case of a cluster .",
    "standard implementations for balanced binary trees also ascertain that the height is @xmath0 , and that each concatenation and split can be done by @xmath0 local modifications .",
    "if a vertex in a cluster is not a boundary vertex , it is _ internal _ to that cluster . if a cluster @xmath12 has two boundary vertices @xmath42 and @xmath43 , we call @xmath12 a _ path cluster _ and @xmath44 the _ cluster path _ of @xmath12 , denoted @xmath45 . if @xmath12 has only one boundary vertex @xmath42 , @xmath12 is called a _ point cluster _",
    "and then @xmath46 .",
    "note that if @xmath15 is a child cluster of @xmath12 and @xmath15 shares an edge with @xmath45 , then @xmath47 , and then we call @xmath15 a _ path child _ of @xmath12 . in terms of boundary vertices , if @xmath12 has children @xmath15 and @xmath26 , @xmath15 is a path child of @xmath12 if and only if @xmath48 and either @xmath49 ( fig .",
    "[ fig : top](2 ) ) or @xmath50 ( fig .",
    "[ fig : top](1 ) ) .",
    "a top tree is represented as a standard binary rooted tree with parent and children pointers .",
    "the nodes used to represent the top tree are denoted _",
    "top nodes_. the top nodes of the binary tree represent the clusters , and with each top node is associated the set of at most two boundary vertices of the represented cluster . with a top leaf we store the corresponding edge .",
    "with an internal top node is stored how it is decomposed into its children ( c.f .",
    "[ fig : top ] ) .",
    "thus , considering the information descending from a top node , we can construct the cluster it represents .",
    "finally , from each vertex @xmath4 , there is a pointer to the smallest cluster @xmath51 that @xmath4 is internal to , or to the root cluster containing @xmath4 if @xmath4 is an external boundary vertex .    following parent pointers from @xmath51",
    ", we can find the root , @xmath52 , of the top tree over the underlying tree @xmath9 containing @xmath4 . in the case of a forest , two vertices @xmath4 and @xmath5",
    "are in the same underlying tree if and only if @xmath53 . with top trees of logarithmic height as in theorem",
    "[ thm : top - maintain ] , we identify @xmath52 in @xmath0 time .",
    "an _ application _ of the top tree data structure , such as maintaining diameters , centers , or medians , has direct access to the above representation , and will typically associate some extra information with the top nodes .",
    "the application employs an _ implementation _ of top trees , which is an algorithm like the one described in theorem  [ thm : top - maintain ] , converting each @xmath24 , @xmath25 , or @xmath22 into a sequence of @xmath33s and @xmath36s on the top trees . in connection with each @xmath36 and",
    "@xmath33 the application is notified and given pointers to the top nodes representing the involved clusters .",
    "the application can then update its information associated with these top nodes .",
    "we note that a top tree may only be modified with @xmath33 and @xmath36 .",
    "this discipline is important if we have several applications running over the same top trees , each maintaining its own information as @xmath33s and @xmath36s are performed .",
    "typically , @xmath24 and @xmath25 are operations imposed from the outside whereas @xmath22 typically is used internally by an application .      as a first example , we can now easily derive a main result from  @xcite .",
    "[ cor : path - query ] we can maintain a dynamic collection of weighted trees in @xmath54 time per @xmath24 and @xmath25 , supporting queries about the maximum weight between any two vertices in @xmath0 time .    for this application , with each ( top node representing a ) cluster @xmath12 , we store as extra information the maximum weight @xmath55 on the cluster path @xmath45 . for a point - cluster @xmath12 ,",
    "if a path cluster consists of a single edge @xmath8 , @xmath57 is just the weight of the edge .",
    "when a path cluster @xmath12 is created by a @xmath36 , @xmath55 is the maximum weight stored at its path children .",
    "when @xmath12 is @xmath33 or @xmath34ed , we just discard the information stored with @xmath12 .",
    "now , to find the maximum weight between @xmath4 and @xmath5 , we set @xmath58 @xmath59 .",
    "then @xmath60 , and we return @xmath55 . since @xmath36 and @xmath33 are supported in constant time , the theorem now follows from theorem  [ thm : top - maintain ] .    in the above example",
    ", @xmath33 is trivial . to see the relevance of @xmath33",
    ", we consider an extension from  @xcite .",
    "[ cor : path - update ] in theorem  [ cor : path - query ] , we can also add a common weight @xmath61 to all edges on a given path @xmath6 in @xmath0 time .",
    "for this extension , for each cluster @xmath12 , we introduce a `` lazy '' weight @xmath62 which is to be added to all edges in @xmath45 in all clusters properly descending from @xmath12 .",
    "we note that if @xmath12 is a root cluster , @xmath55 is not affected by these @xmath63-values , so @xmath55 is the correct maximal weight on @xmath45 . in particular , we can still find the maximal weight between @xmath4 and @xmath5 as @xmath64 .",
    "the addition of @xmath61 to @xmath6 is now done by calling @xmath65 and adding @xmath61 to @xmath55 and to @xmath62 .",
    "then @xmath66 requires that for each path child @xmath15 of @xmath12 , we set @xmath67 and @xmath68 . for @xmath69",
    ", we set @xmath70 and @xmath71 . finally , to find the maximum weight on the path @xmath6 , we set @xmath65 and return @xmath55",
    ".    we will now go beyond @xcite with a further extension needed in @xcite .",
    "[ cor : tree - weight ] in theorem  [ cor : path - update ] , we can also ask for the maximum weight of the underlying tree containing a vertex @xmath4 in @xmath0 time .    elaborating on the information from the previous two proofs , for each cluster @xmath12",
    ", we will maintain a variable @xmath72 denoting the maximal weight on an edge in @xmath12 which is not on the cluster path .",
    "assuming this variable , we can find the maximal weight of the underlying tree containing @xmath4 , setting @xmath73 and returning @xmath74 .",
    "we maintain the @xmath75 variables as follows .",
    "when the cluster of an edge @xmath8 is @xmath35d , if @xmath8 has two boundary vertices , we set @xmath76 . otherwise , @xmath77 is set to the weight of @xmath8 .",
    "when a cluster is joined as @xmath69 , we first set @xmath78 . if @xmath12 is not a path cluster but one of its children , say @xmath15 , is a path cluster ( c.f .",
    "[ fig : top](3 ) ) , then we further have consider weights from the cluster path of @xmath15 , setting @xmath79 .",
    "we note here that because @xmath15 was a root cluster , @xmath80 has its correct value , not missing any @xmath63-values from at ascending clusters .",
    "when clusters are @xmath33 or @xmath34ed , this has no impact on the @xmath81-variables .    in the rest of this paper , we are more interested in distances than in maximum weights . modifying the proof of theorem [ cor : path - query ] , for each cluster @xmath12",
    ", we will maintain the length @xmath82 of the cluster path .",
    "the length is maintained as the maximum weight except that if @xmath12 is created by a @xmath36 , @xmath82 is the sum of lengths stored with its path children .",
    "thus we have    [ lem : dist ] in top trees , for each cluster @xmath12 , we can maintain the length , denoted @xmath82 , of the cluster path in constant time per local top update , hence in @xmath0 time per @xmath24 or @xmath25 .",
    "then the distance between two vertices @xmath4 and @xmath5 can be found in @xmath54 time as @xmath83 .    ' '' ''    as an interesting new application of top trees , we get the claimed result for dynamic diameters .",
    "[ cor : diameter ] we can maintain a dynamic collection of weighted trees in @xmath54 time per @xmath24 and @xmath25 , supporting queries about the diameter of the tree containing any vertex in @xmath0 time .    for each cluster @xmath12 , we store its diameter @xmath84 .",
    "moreover , for each of its boundary vertices @xmath85 , we store the maximal distance @xmath86 from @xmath42 to any vertex in @xmath12 .",
    "finally , we maintain the cluster length from lemma [ lem : dist ] .",
    "the variables @xmath87 and @xmath88 are auxiliary fields , needed for a fast @xmath36 .",
    "such carefully chosen extra information is often crucial in top tree applications .    when the cluster of an edge @xmath8 is @xmath35d , @xmath89 , and for each boundary vertex @xmath4 of @xmath8 , @xmath90 . now , suppose @xmath69 , and that @xmath91 is the common boundary vertex of @xmath15 and @xmath26 .",
    "then we set @xmath92 now consider any boundary vertex @xmath42 of @xmath12 . by symmetry , we may assume that if @xmath42 is not in one of @xmath15 and @xmath26 , it is not in @xmath26 .",
    "let @xmath91 be the intersection vertex of @xmath15 and @xmath26 .",
    "then , if @xmath93 , @xmath94 if @xmath95 then @xmath96 thus , @xmath35 and @xmath36 are implemented in constant time . as in the proof of theorem  [ cor : path - query ] , @xmath33 and @xmath34 do not require any action .",
    "hence theorem  [ thm : top - maintain ] implies that we can maintain the above information in @xmath0 time per @xmath24 or @xmath25 . to answer a diameter query for a vertex @xmath4 , we set @xmath97 and return @xmath84 .    another illustrative application is the maintenance of nearest marked neighbors .",
    "[ thm : nearest - marked ] we can maintain a dynamic collection of trees in @xmath54 time per @xmath24 and @xmath25 , or marking and unmarking of a vertex , supporting queries about the ( distance to ) the nearest marked vertex of any given vertex in @xmath0 time .",
    "below , we just focus on finding the distance to the nearest marked vertex .",
    "this is easily extended to also providing the vertex .    for each boundary vertex @xmath42 of a cluster @xmath12",
    ", we maintain the distance @xmath98 from @xmath42 to the nearest marked vertex in @xmath99 .",
    "the reason that why exclude the boundary of @xmath12 from consideration is that a vertex @xmath4 may appear as boundary vertex of @xmath100 clusters , and all these would be affected , if @xmath4 was ( un)marked . from @xmath98 we can easily compute the distance @xmath101 from @xmath42 to the nearest marked vertex in @xmath12 excluding only boundary vertices different from @xmath42 . then @xmath102 if @xmath42 is marked , and @xmath103 if @xmath42 is unmarked .",
    "we also maintain the cluster path length , @xmath82 , as in lemma  [ lem : dist ] .",
    "given a vertex @xmath104 , to find the distance to the nearest marked vertex , we simply set @xmath105 , and return @xmath106 .    to (",
    "un)mark a vertex @xmath4 , we first @xmath22 @xmath4 . as an external boundary vertex",
    ", @xmath4 has no impact on any @xmath107-value , so we can freely ( un)mark it .",
    "suppose the cluster @xmath12 is @xmath35d as an edge @xmath7 .",
    "then @xmath108 is the weight of @xmath7 if @xmath5 is marked and not in the boundary ; otherwise , we it to infinity .    finally , consider @xmath69 with @xmath109 .",
    "let @xmath42 be a boundary vertex of @xmath12 . by symmetry",
    ", we can assume that @xmath42 is in @xmath15 .",
    "we now have @xmath110 @xmath111 thus , we can support both @xmath36 and @xmath35 in constant time , and @xmath33 and @xmath34 do not require any action . by theorem  [ thm : top - maintain ] , this completes the proof of theorem [ thm : nearest - marked ]    for any positive integer parameter @xmath2 , in a fixed undirected graph on @xmath1 vertices and @xmath112 edges , in @xmath113 expected time we can build an @xmath114 space data structure , supporting ( un)marking of vertices and queries about stretch @xmath115 distances to a nearest marked vertex . here",
    "stretch @xmath115 means that the reported distance may be up to a factor @xmath115 too long .",
    "both queries and updates take @xmath116 time .    in @xcite , it is shown how to generate a cover of edge - induced trees within the above preprocessing bounds so that each vertex @xmath4 is in @xmath117 trees , and if the distance from @xmath4 to @xmath5 is @xmath118 , there is a tree in which the distance is at most @xmath119 . now ,",
    "if a vertex is marked , it is marked in all the trees containing it , and to find a stretch @xmath115 distance to a nearest marked vertex , we find the shortest distance to a marked vertex over all the trees .    the above corollary is interesting because it in @xcite is shown that several combinatorial optimization problems can be approximated efficiently on metrics with dynamic nearest neighbor .",
    "for example , in the bottle - neck matching problem , where we wish to minimize the furthest distance between a pair in the matching , we now get a @xmath120 approximation in @xmath121 expected time .",
    "an exact solution currently requires @xmath122 time @xcite .",
    "we are now going to build a black box on top of our top trees for maintenance of centers and medians .",
    "as discussed in the introduction , the common feature of centers and medians is that they represent non - local properties . here",
    "a vertex / edge property is local if it being satisfied by a vertex / edge in a tree implies that the vertex / edge satisfies the property in all subtrees containing it .",
    "for example , being the minimum edge on a given path is a local property .",
    "local properties lend themselves nicely to bottom - up computations whereas non - local properties appear to be more challenging .    for our general non - local",
    "searching , the application should supply a function @xmath123 that given the root cluster of a top tree , selects one of the two children .",
    "recall here that a root cluster represents the whole underlying tree , which is important when dealing with non - local properties . our black box will use @xmath123 to guide a binary search after a desired edge .",
    "more precisely , the first time @xmath123 is called , it is just given the root of an original top tree @xmath124 .",
    "it then @xmath123s one of the two children . in subsequent iterations",
    ", there will be some cluster @xmath12 in the original top tree which is the intersection of all clusters @xmath123ed so far . if @xmath12 has children @xmath15 and @xmath26 , the black box modifies the top tree so that @xmath15 and @xmath26 are subsumed by different children @xmath125 and @xmath126 of the root .",
    "then @xmath123 is called on the root @xmath127 .",
    "if @xmath125 is @xmath123ed , @xmath15 is the new intersection of all @xmath123ed clusters . likewise ,",
    "if @xmath126 is @xmath123ed , @xmath26 is the new intersection of all @xmath123ed clusters . this way ,",
    "@xmath123 is used to guide a binary search down through the original top tree @xmath124 .",
    "the formal statement of the result is as follows .",
    "[ non - local search][thm : non - localsearch ] starting with the root cluster of a top tree of height @xmath128 and at most one external boundary vertex , after @xmath129 calls to @xmath123 , @xmath36 , and @xmath33 , there is a unique edge @xmath7 contained in all clusters chosen by @xmath123 , and then @xmath7 is returned .",
    "subsequently , the top tree is returned to its previous state with @xmath129 calls to @xmath36 , and @xmath33 .",
    "if there are two external boundary vertices @xmath61 and @xmath130 , the above selection process will stop with a unique @xmath7 edge on the path from @xmath61 to @xmath130 .    as stipulated in the general interface to top trees",
    ", the implementation behind theorem  [ thm : non - localsearch ] will only manipulate the top tree with @xmath36 and @xmath33 operations . in our applications",
    ", we will apply theorem  [ thm : non - localsearch ] to a top tree from theorem  [ thm : top - maintain ] with height @xmath131 .",
    "then the number of calls to @xmath36 and @xmath33 in theorem  [ thm : non - localsearch ] is @xmath132 .",
    "theorem  [ thm : non - localsearch ] will not be proved till   [ sec : search - impl ] . before",
    "that we demonstrate applications of theorem  [ thm : non - localsearch ] in the dynamic center , median , and ancestor problems . in these applications ,",
    "our general approach is to first decide the information needed for @xmath123 , second show how to make the information available .",
    "the external boundary vertices will only play a role in the ancestor application in  [ sec : ancestor ] .      for any tree @xmath9 and",
    "vertex @xmath4 let @xmath133 denote the maximal distance from @xmath4 in @xmath9 .",
    "a _ center _ is a vertex @xmath4 minimizing @xmath133 .",
    "[ 1centerlem ] let @xmath9 be a tree , and let @xmath15 and @xmath26 be neighboring clusters with @xmath134 and @xmath135 .",
    "if @xmath136 , @xmath15 contains all centers .",
    "let @xmath5 be a vertex in @xmath15 of maximal distance to @xmath91",
    ". then @xmath137 .",
    "now , for any @xmath138 , @xmath139 .",
    "since the edge weights are positive , , thus @xmath140 and @xmath4 can not be a center .    in the dynamic center problem",
    ", we maintain a forest under @xmath24 and @xmath25 interspersed with queries @xmath141 requesting the center of the current tree containing the vertex @xmath104 .",
    "we use the top trees from theorem [ thm : top - maintain ] . for each boundary vertex @xmath42 of a cluster @xmath12",
    ", we maintain the maximal distance @xmath86 from @xmath42 in @xmath12 as described in the proof of theorem  [ cor : diameter ] .",
    "then @xmath24 and @xmath25 take @xmath0 time .    to find @xmath141 , we first set @xmath142 so that @xmath143 becomes the current root cluster over the tree containing @xmath104 .",
    "the non - local search of theorem  [ thm : non - localsearch ] will start in @xmath143 , but we need to define @xmath123 given an arbitrary root cluster @xmath12 with children @xmath15 and @xmath26 , @xmath134 . if @xmath144 , @xmath123 picks @xmath15 , otherwise it picks @xmath26 . by lemma  [ 1centerlem ]",
    ", any cluster picked contains all centers , so , following theorem  [ thm : non - localsearch ] , the returned edge @xmath7 contains all centers .",
    "moreover , @xmath123 takes constant time , so @xmath7 is found in @xmath0 time . to find out if @xmath4 or @xmath5 is a center , we compute @xmath145 in @xmath0 time .",
    "since @xmath143 coincides with @xmath9 , we can return @xmath4 if @xmath146 ; @xmath5 otherwise .",
    "hence we can answer @xmath141 in @xmath0 time .",
    "thus we conclude    [ thm : center ] the center can be maintained dynamically under , and @xmath141 queries in @xmath0 worst case time per operation .",
    "let @xmath9 be a tree with positive vertex and edge weights .",
    "median _ is a vertex @xmath147 minimizing @xmath148 where @xmath149 is the distance from @xmath4 to @xmath147 in the tree . for any tree @xmath9 ,",
    "let @xmath150 denote the sum of the vertex weights of @xmath9 .",
    "our approach to finding medians is similar to that for centers , but for the median , it is natural to allow the application to change vertex weights , and this requires a simple trick .",
    "the simple lemma below is implicit in goldman  @xcite .",
    "[ 1medianlem ] let @xmath7 be an edge in the weighted tree @xmath9 , and let @xmath151 and @xmath152 be the trees from @xmath153 containing @xmath4 and @xmath5 , respectively . if  , @xmath4 and @xmath5 are the only medians in @xmath9 , and if @xmath154 , all medians in @xmath9 are in @xmath151 .",
    "[ 1mediancor ] let @xmath9 be a tree , and let @xmath15 and @xmath26 be neighboring clusters with @xmath134 and @xmath135 .",
    "then @xmath155 implies that @xmath15 contains a median of @xmath9 .",
    "assume that @xmath156 .",
    "if there exists an edge @xmath157 in @xmath26 such that @xmath158 , then by lemma  [ 1medianlem ] , @xmath91 and @xmath5 are ( the only ) medians in @xmath9 and since @xmath91 is in @xmath15 we are done .",
    "otherwise for any edge @xmath157 in @xmath26 , @xmath159 . by assumption , @xmath160 , and thus @xmath161",
    ". then lemma  [ 1medianlem ] states that all medians of @xmath9 are in @xmath162 , and since this is true for any edge @xmath157 , there must be a median in @xmath15 .",
    "the above corollary suggests that we should maintain the vertex weight of each cluster , but this gives rise to a problem ; namely that a single vertex can be contained in arbitrarily many clusters , and a change in its weight would affect all these clusters .",
    "recall that we faced a very similar problem for the @xmath107-values in the proof of theorem [ thm : nearest - marked ] , and again we will resort to ignoring the boundary .    for each cluster @xmath12 , we only maintain their `` internal weight '' @xmath163 .",
    "we can still derive the real weight @xmath164 as @xmath165 in constant time .",
    "to @xmath36 two clusters @xmath15 and @xmath26 , @xmath134 into @xmath12 , we add their internal weights plus the weight of @xmath91 if @xmath166 . to change the weight of a vertex @xmath4 , we first call @xmath37",
    ". then @xmath4 is not internal to any cluster , and hence no cluster information has to be updated when we change the weight of @xmath4 .",
    "we can now implement @xmath123 as suggested by corollary [ 1mediancor ] , choosing the child cluster minimizing @xmath167 in constant time .",
    "thus we get an edge @xmath7 which contains all medians in @xmath0 time .    to find a median among @xmath4 and @xmath5",
    ", we apply lemma  [ 1medianlem ] .",
    "we @xmath25 the edge @xmath7 , and return @xmath4 if the ( root cluster of the ) tree @xmath151 containing @xmath4 is heavier ; otherwise we return @xmath5 . before returning @xmath4 or @xmath5 , we @xmath24 @xmath7 back in @xmath9 .",
    "the @xmath24 and @xmath25 take @xmath0 time , so we conclude :    [ thm : median ] the median can be maintained dynamically under , and change of vertex weights in @xmath0 worst case time per operation .    ' '' ''      we will now show how to implement nearest common ancestors and level ancestors with respect to arbitrary roots . in the context of unrooted trees , this is done via the two functions @xmath168 , returning the vertex @xmath118 hops from @xmath61 on the path from @xmath61 to @xmath130 , and @xmath169 returning the intersection point between the three paths connecting @xmath61 , @xmath130 , and @xmath170 . with root @xmath171 , the level @xmath172 ancestor of @xmath4 is @xmath173 , and the nearest common ancestor of @xmath104 and @xmath4 is @xmath174 .    to implement @xmath175 and @xmath176 , from lemma [ lem : dist ]",
    "we will use the cluster path length @xmath177 as well as the general distances between vertices . to implement @xmath168 we first @xmath22 @xmath61 and @xmath130 .",
    "we now implement @xmath123 as follows .",
    "let @xmath15 and @xmath26 be the children of the root cluster @xmath12 with @xmath178 and @xmath179 . if @xmath180 , we select @xmath15 ; otherwise we select @xmath26 . at the end , we get an edge , and then we return the end - point whose distance to @xmath61 is @xmath118 .    having implemented @xmath175 , we compute @xmath169 as @xmath181 .",
    "thus we conclude    [ cor : jump - meet ] we can maintain a dynamic collection of weighted trees in @xmath54 time per @xmath24 and @xmath25 , supporting @xmath175 and @xmath176 queries in @xmath0 time .    ' '' ''      we will now first prove theorem  [ thm : non - localsearch ] when there are no boundary vertices .",
    "first we will assume that there are no external boundary vertices .",
    "essentially our search will follow a path down the given top tree @xmath124 . as we search down",
    ", we will modify the top tree so as to facilitate calls to @xmath123 , but we will end up restoring it in its original form .",
    "all modifications for the search are done via @xmath33 and @xmath36 , as stipulated in the general interface to top trees .",
    "our search consists of @xmath0 iterations @xmath182 . at the beginning of iteration @xmath183",
    ", there will be a `` current '' cluster @xmath184 on depth @xmath183 in the original top tree @xmath124 which contains exactly the edges that have been in all clusters selected so far .",
    "thus @xmath185 is the original root cluster representing an underlying tree @xmath9 .",
    "if @xmath184 is a single edge @xmath7 , we return @xmath7 .",
    "otherwise @xmath184 has children @xmath186 and @xmath187 in the original top tree .",
    "then @xmath123 will be presented a root cluster joining @xmath188 and @xmath189 such that @xmath190 , @xmath191 , and @xmath192 .",
    "that is , the application - defined @xmath123 will be called as @xmath193 .",
    "if the application selects @xmath188 , we have @xmath194 for the next iteration .",
    "otherwise @xmath195 .",
    "at the beginning of iteration @xmath183 , we have @xmath184 the root of a top tree which was the subtree of the original top tree @xmath124 descending from @xmath184 . besides , for each boundary vertex @xmath42 of @xmath184 , we have an `` outside '' root cluster @xmath196 with everything from the underlying tree @xmath9 that is separated from @xmath184 by @xmath42 .",
    "also , @xmath196 includes @xmath42 .",
    "together with @xmath184 , the outside root clusters @xmath196 partition the edges of @xmath9 . for @xmath197 , we do not have any outside root clusters .",
    "we are done when @xmath184 is a top leaf consisting of a single edge .",
    "otherwise , we @xmath33 @xmath184 into two children @xmath186 and @xmath187 .    to create @xmath198 , we take all outside root clusters intersecting @xmath186 and @xmath36 them with @xmath186 .",
    "if an outside root cluster does not intersect @xmath186 , it intersects @xmath187 , and is @xmath36ed with @xmath187 to create @xmath199 .",
    "we then call the application - defined @xmath123 on @xmath200 .",
    "we now @xmath33 all the newly @xmath36ed clusters so that the root clusters become @xmath186 , @xmath187 , and the outside root cluster for each boundary vertex of @xmath184 from the beginning of the iteration . by symmetry",
    ", we may assume that @xmath123 picked @xmath186 .",
    "we then set @xmath201 , and we @xmath36 @xmath187 with all outside root clusters intersecting @xmath187 in a new maximal outside root cluster .",
    "finally , we recurse on @xmath202 .    as mentioned , the iterations stop as soon as we arrive at a @xmath184 which is just a single edge @xmath7 .",
    "since each iteration only involves a constant number of @xmath36s and @xmath33s , we conclude that the total number of @xmath36s and @xmath33s is @xmath129 where @xmath128 is the initial height of the top tree . in the end when we have found @xmath203 , we just reverse all @xmath36s and @xmath33s to restore the top tree in its original form , and return the edge @xmath7 .    with a minor modification",
    ", the above construction also works in the presence of a single external boundary vertex .",
    "the modification is in the case where a boundary vertex @xmath42 of @xmath184 is the external boundary vertex and where @xmath42 does not separate @xmath184 from any part of the underlying tree . in that case",
    "no outside cluster @xmath196 is associated with @xmath42 .",
    "this completes our implementation of theorem [ thm : non - localsearch ] when there are less than two external boundary vertices .",
    "the non - local search described above works fine with less than two boundary vertices .",
    "however , when we have two external boundary vertices @xmath61 and @xmath130 in the underlying tree @xmath9 , the goal of the non - local search is to select an edge on @xmath204 . in the above selection process",
    ", this means that the currently selected cluster @xmath184 should always have an edge @xmath8 from @xmath205",
    ". then @xmath206 .",
    "thus it follows that if a child of @xmath184 is not a path child , then that child can not be @xmath123ed . in that case , the only path child is automatically made the next current cluster @xmath202 .",
    "the process stops when @xmath207 consists of a single edge , which is then returned .    in the actual implementation ,",
    "since @xmath184 has an edge in its cluster path , @xmath184 has two distinct boundary vertices @xmath42 and @xmath43 with disjoint outside root clusters @xmath196 and @xmath208 .",
    "each of these outside root clusters contain one of the two external boundary vertices .",
    "let @xmath186 and @xmath187 be the children of @xmath184 with @xmath209 and @xmath210 . if @xmath186 is not a path child , we simply set @xmath211 and @xmath195 .",
    "similarly , if @xmath187 is not a path child , we set @xmath212 and @xmath194 .",
    "it is only if both @xmath186 and @xmath187 are path children that we call the application - defined @xmath123 on @xmath200 where @xmath213 and @xmath214 .",
    "we note that with two external boundary vertices @xmath61 and @xmath130 , it is necessary that we restrict @xmath123 to pick edges from @xmath215 as above .",
    "otherwise , above we could end up with @xmath186 and @xmath187 intersecting in a vertex @xmath91 outside @xmath215 . since @xmath198 and @xmath199 intersect in @xmath91 and partition the underlying tree ,",
    "one of them would contain both @xmath61 and @xmath130 , hence have three boundary vertices @xmath61 , @xmath130 , and @xmath91 .",
    "this completes our implementation of theorem [ thm : non - localsearch ] .",
    "our results on diameters , centers , and medians could also have been achieved based on either sleator and tarjan s dynamic trees  @xcite , or frederickson s topology trees  @xcite .",
    "however , we claim that the derivation from these more classical data structures would have been more technical .",
    "top trees are very similar to frederickson s topology trees  @xcite , from which they are derived .",
    "the essential difference is that the clusters of topology trees are not connected via vertices , but via edges .",
    "since frederickson s boundary consists of edges , he can not limit the boundaries for unlimited degree trees .",
    "thus , in applications for unbounded degrees one has to code these with ternary trees , inserting some extra edges and vertices that typically require special handling . even if we assume we are dealing with ternary trees , topology trees still have clusters with up to three boundary edges instead of just two boundary vertices .",
    "also topology @xmath36 combines two clusters _ plus _ the edge between them whereas a top @xmath36 just unites two neighboring clusters .",
    "neither of these issues lead to fundamental difficulties , but , in our experience , they lead to significantly more cases .",
    "we note that frederickson @xcite has already shown how sleator and tarjan s @xcite axiomatic interface to dynamic trees can be implemented with topology trees .",
    "our corresponding implementation with top trees from ",
    "[ sec : toptrees ] is inspired by that of frederickson .",
    "sleator and tarjan provide an axiomatic interface for their dynamic trees  @xcite where an application can choose a root with a so - called @xmath216 operation , and then , for any specific vertex , add weights to all edges on the path to the root , or ask for the minimum of all weights on this path .",
    "this is basically the interface we implemented with top trees at the end of   [ sec : toptrees ] , assuming that we expose both the desired root and the specified vertex .    before discussing limitations to the above interface",
    ", we first illustrate its generality by viewing the min - query as representing an arbitrary associative operator @xmath217 .",
    "for example , suppose as in  @xcite that we want to implement parent pointers to the current root .",
    "we then let the weight of an edge be its pair of end - points and define @xmath218 .",
    "then the `` min''-query returns the end - points of the first edge on the path to the root , from which we immediately get a parent pointer .",
    "similarly , adding @xmath61 to all weights on a path could be done with any associative operator @xmath219 that distribute over @xmath217 , that is , @xmath220 . instead of having @xmath221",
    ", we could have e.g.   @xmath222 .    despite these generalizations ,",
    "the axiomatic interface is still centered around paths , and it has been found too limited for many applications of dynamic trees .",
    "instead authors have had to work directly with sleator and tarjan s underlying representation  @xcite .",
    "in particular , this is the case for the previous solutions to the dynamic center  @xcite and median problems  @xcite , and we believe part of the reason for their worse bounds and more complex solutions is difficulties in working directly with sleator and tarjan s underlying representation",
    ".    of course , one may try to increase the applicability of the axiomatic interface by augmenting it with further operations .",
    "for example ,  @xcite shows how to find a minimum weight vertex in a subtree . however , dealing with non - local properties is not so immediate , and we find it unlikely that we will ever converge to a set of operations so big that we can forget about the underlying representation .",
    "for contrast , with top or topology trees it is easy to deal directly with the representation .",
    "for example , to compute the minimum vertex of a given subtree as in  @xcite ; since we can insert and delete edges , this is equivalent to maintaining the minimum vertex of each tree in a dynamic forest . with top trees this",
    "is done by maintaining , for each cluster , the minimum weight over its non - boundary vertices . since",
    "each vertex is only non - boundary in @xmath0 clusters , weight changes of vertices are trivially supported .",
    "if we do not expose any external boundary vertices , the root cluster will store the desired minimum .      for completeness",
    ", we also mention henzinger and king s et - trees  @xcite .",
    "this is a standard binary trees over the euler tour of a tree .",
    "this technique is much simpler to implement than those mentioned above , and it can be used whenever we are interested in maintaining a minimum over the edges or vertices of a tree , where the minimum may be interpreted as any associative and commutative operation .",
    "the above mentioned result from  @xcite on maintaining the minimum weight vertex of a tree is immediate , and in fact , this was pointed out before  @xcite in  @xcite .",
    "however , the et - trees can not be used to maintain any of the path information discussed so far .",
    "also , they can not be used to maintain medians and centers .",
    "in the following , to avoid confusion with leaves in the underlying trees , we refer to the leaves of a top tree as _ base clusters_. at present the base clusters are just the edges of the underlying tree , but it is sometimes important to deal with fewer but larger base clusters . for example",
    ", this is needed in classical topology tree applications such as maintaining the minimum spanning tree of a fully - dynamic graph  @xcite .",
    "also , it is needed for a recent application of top trees maintaining minimum cuts  @xcite . for these applications",
    ", we allow the user to distribute _ labels _ on the vertices of the underlying tree .",
    "these labels represent application - specific information associated with the vertices .",
    "for example , if we are maintaining a minimum spanning tree , the labels represent incident ends of non - tree edges .",
    "we note that frederickson s topology trees @xcite do not support labels .",
    "his underlying trees have to be ternary so each application has to decide how to code high degree vertices and other information in ternary trees .",
    "thus our top trees are now dealing with a labeled tree @xmath9 .",
    "each label is attached to a unique vertex , but the same vertex may have many labels attached . in many regards ,",
    "the labels can be thought of as edges with a single end - point .    in a subtree @xmath223 of a labeled tree @xmath9",
    ", each vertex may have attached any subset of its labels in @xmath9 .",
    "we extend the notion of boundary vertices to include vertices in @xmath223 that have fewer labels attached in @xmath223 than in @xmath9 .",
    "that is , @xmath224 is now the set of vertices in @xmath223 that are either external boundary vertices of @xmath9 or vertices with an incident edge or attached label that is included in @xmath9 but not in @xmath223 .",
    "a cluster @xmath223 of @xmath9 is a subtree with at most two boundary vertices containing at least an edge or a label .",
    "thus , we now accept a single vertex as a cluster if it has an associated label in the cluster .",
    "two clusters are neighbors if their intersection is a single vertex .",
    "they can not have any labels or edges in common .",
    "it follows that the base clusters of a top tree form a partitioning of the edges and labels of the underlying tree .",
    "similarly , it follows that labels , like edges , appear in exactly one cluster on each level in a top tree .",
    "one conceptual advantage to labels is that any cluster can be be reduced to an edge or a label .",
    "more precisely , we get a new labeled tree if we replace a point cluster with a label at its boundary vertex , or if we replace a path cluster with an edge between its boundary vertices",
    ".    a simple application of labels would be to attach a label @xmath225 $ ] to a vertex @xmath4 . on each level of a top tree",
    ", the label @xmath225 $ ] will only appear once whereas the vertex @xmath4 can participate in arbitrarily many clusters . this way , @xmath225 $ ] can be used as a distinguished representative for @xmath4 in a top tree .",
    "in addition to the original @xmath24 , @xmath25 , and @xmath22 operations , we have the two new operations :    attaches a label @xmath42 to the vertex @xmath4 .",
    "detaches the label @xmath42 from whatever vertex it was attached to .    to get the full power of the generalized top trees , we allow top nodes",
    "@xmath12 with a single child @xmath143 , created by @xmath226",
    ". then @xmath12 and @xmath143 represent exactly the same cluster .",
    "we can then get _ leveled top trees _ where all base clusters are on level @xmath227 , and where the parent of a level @xmath183 top node is on level @xmath228 .",
    "we define the _ size of a cluster or labeled tree _ to be the total number of its edges and labels .",
    "we now have the following generalization of theorem [ thm : top - maintain ] :    [ thm : weighted - top - maintain ] consider a fully - dynamic forest and let @xmath229 be a positive integer parameter . for the trees in the forest",
    ", we can maintain a leveled top trees whose base clusters are of size at most @xmath229 and such that if a tree has size @xmath230 , it has height @xmath231 and @xmath232 clusters on level @xmath233 . here",
    "@xmath234 is a positive constant .",
    "each @xmath24 , @xmath25 , @xmath235 , @xmath236 , or @xmath22 operation is supported with @xmath41 @xmath35s and @xmath34s , and @xmath41 @xmath36s and @xmath33s on each positive level .",
    "if the involved trees have total size @xmath230 , this involves @xmath237 top tree modifications , all of which are identified in @xmath238 time . for a composite sequence of @xmath2 updates ,",
    "each of the above bounds are multiplied by @xmath2 . as a variant ,",
    "if we have parameter @xmath239 bounding the size of each underlying tree , then we can choose to let all top roots be on the same level @xmath240 .",
    "we note that theorem  [ thm : weighted - top - maintain ] implies theorem  [ thm : top - maintain ] .",
    "more precisely , to get theorem  [ thm : top - maintain ] from theorem  [ thm : weighted - top - maintain ] , we set @xmath241 , use no labels , and skip all top nodes that are single children .    to appreciate theorem  [ thm : weighted - top - maintain ] , we briefly sketch frederickson s algorithm for maintaining a minimum spanning tree of a fully - dynamic graph  @xcite , but using top trees instead of topology trees",
    ".    we can maintain a minimum spanning tree of a fully dynamic connected graph in @xmath242 time per edge insertion or deletion bound to @xmath243 using their general sparsification technique . ] .",
    "if an edge @xmath7 is inserted in the graph , it should be added to the minimum spanning tree @xmath9 if it is lighter than the maximum weight on the path from @xmath4 to @xmath5 in @xmath9 . from theorem  [ cor : path - query ] , we already know how to support such path queries in @xmath0 time .",
    "our challenge is to deal with the deletion of a tree edge .",
    "our task is to find a lightest replacement edge reconnecting the tree , and we will show how to do this in @xmath242 time .",
    "we will employ leveled top trees @xmath124 from theorem  [ thm : weighted - top - maintain ] where the labels attached to a vertex are ends of incident non - tree edges .",
    "more precisely , for each non - tree edge @xmath7 , we have a label @xmath244 $ ] attached to @xmath4 and a symmetric label @xmath245 $ ] attached @xmath5 .",
    "these two labels are always attached or detached as a composite update ( c.f . ",
    "[ top - dicipline ] ) so that we never have one but not the other present in our top trees .",
    "the total size of our labeled forest is then the number @xmath112 of edges in the graph .",
    "we will use the variant of top trees in the end of theorem  [ thm : weighted - top - maintain ] with @xmath239 an upper bound on the total size @xmath112 . using standard back - ground rebuilding",
    ", we can ensure @xmath246 .",
    "more precisely , we can divide updates into epochs that first initiate new top trees @xmath247 with this @xmath248 instead of the current @xmath239 . during",
    "the next @xmath249 updates we copy the current data from @xmath124 to @xmath247 , and switch to @xmath247 when done .",
    "now that @xmath239 is fixed for the current top tree @xmath124 , we set @xmath250 . since we have at most two trees at any time , the number of clusters on level @xmath251 is @xmath252 .    for each pair @xmath253 of clusters on the same level , we will store the lightest non - tree edge @xmath254 between them .",
    "here @xmath7 goes between @xmath12 and @xmath143 if @xmath244 $ ] is a label in @xmath12 and @xmath245 $ ] is a label in @xmath143 , or vice versa . assuming that the clusters are enumerated with numbers up to @xmath255",
    ", we can implement @xmath256 as a simple two dimensional array over all cluster pairs .",
    "we can just ignoring entries with cluster pairs on different levels .",
    "also , since @xmath256 is symmetric , we identify @xmath254 with @xmath257 .",
    "assuming that the array @xmath258 is properly maintained , if a tree edge @xmath7 is deleted , we @xmath25 it , and then the desired minimum replacement edge is the minimum edge between the root clusters .",
    "more precisely , we perform the following sequence of operations : @xmath259);\\ { { \\textnormal{\\textsf{detach}}}}([y , x]);\\rangle \\ ; { { \\textnormal{\\textsf{link}}}}((x , y));\\end{aligned}\\ ] ] we now have to show how to maintain @xmath258 .",
    "suppose a base cluster @xmath26 is @xmath35d .",
    "since it has only @xmath260 incident non - tree edges , each going to a base cluster on the same level , we can easily find @xmath261 for all the @xmath242 base clusters @xmath262 in @xmath242 time .",
    "now suppose a level @xmath263 cluster @xmath12 is @xmath36ed .",
    "for each of the @xmath264 other level @xmath183 clusters @xmath262 , we set @xmath254 to be the lightest of @xmath265 where @xmath15 is a child of @xmath12 and @xmath26 is a child of @xmath143 . thus we compute @xmath254 in constant time .",
    "finally , we note that @xmath33 and @xmath34 require no action .",
    "it follows from theorem  [ thm : weighted - top - maintain ] that each @xmath24 , @xmath25 , @xmath22 , @xmath235 , or @xmath236 operation is supported in @xmath266 time , which is then also the time bound for finding a replacement edge .",
    "a much more involved application using the generalized top trees from theorem  [ thm : weighted - top - maintain ] is the fully - dynamic algorithm for maintaining minimum cuts  @xcite .",
    "we note that  @xcite assumes theorem  [ thm : weighted - top - maintain ] which is proved below in this paper by reduction to frederickson s topology trees @xcite .",
    "we will now first implement the top trees of theorem  [ thm : weighted - top - maintain ] via frederickson s topology trees  @xcite , and thereby establish theorem  [ thm : weighted - top - maintain ] and theorem  [ thm : top - maintain ] .",
    "next , we implement the topology trees with sleator and tarjan s st - trees  @xcite .",
    "the connection is interesting because topology trees and st - trees so far have been implemented with very different techniques .",
    "a nice consequence is that the simple amortized implementation of st - trees implies a simple amortized implementation of topology trees , and of top trees .",
    "previously , no simple amortized implementation of topology trees was known .",
    "we note that for a practical implementation , one should not follow all our reductions rigorously , but rather go for a more direct implementation .",
    "we hope to address these practical issues in future work .      as a very first step in our reduction ,",
    "we note that if we first have an implementation of top trees without @xmath22 , then later , we can easily add @xmath22 .",
    "the simple point is that in a top tree of height @xmath128 , each vertex is included in at most @xmath128 clusters . to @xmath22 @xmath42 and @xmath43",
    ", we simply @xmath33 all the clusters having them as non - boundary vertices .",
    "we now have a set of @xmath129 root clusters to be @xmath36ed into one cluster .",
    "clearly , this can require at most @xmath129 @xmath36s , so we do not need to worry about the height .",
    "first , as long as there is a point cluster , we @xmath36 it with an arbitrary neighbor . if @xmath267 , this process ends with a single point cluster , as desired .",
    "otherwise , we end with a string of path clusters @xmath268 with boundaries @xmath269 , @xmath270 , ... ,",
    "@xmath271 where @xmath272 and @xmath273 .",
    "we can then repeatedly @xmath36 neighbors in this string until a single path cluster with boundary @xmath274 remains . before supporting any new @xmath24 or @xmath25",
    ", we simply revert all the above @xmath36s and @xmath33s , restoring the previous un - exposed top tree .",
    "thus , in the remaining implementation , we may consider @xmath22 done , and focus on maintaining top trees of height @xmath0 under @xmath24 and @xmath25 as in theorem  [ thm : weighted - top - maintain ] but without @xmath22 .",
    "theorem  [ thm : weighted - top - maintain ] without @xmath22 is proved in  @xcite in the context of topology trees with their different definition of clusters .",
    "the topology clusters are subtrees like top clusters , but in a topology tree , independent clusters are vertex - disjoint . in particular , the topology base clusters are disjoint .",
    "they partition the vertices and are connected via edges .",
    "the topology trees are only defined for ternary trees .",
    "a cluster may have at most 3 edges leaving it , called boundary edges , and if it has three edges leaving it , it may only consist of a single vertex .",
    "the topology tree is binary like a top tree .",
    "a parent cluster is the union of the two child clusters plus the edge connecting them .",
    "now , implementing top trees with topology trees is easy .",
    "we ternarize each vertex as follows : while there is a vertex @xmath4 with degree @xmath275 , we turn @xmath4 into a path with the incident edges branching off .",
    "more precisely , if @xmath4 is incident to @xmath276 , @xmath277 , we may replace @xmath4 by a path @xmath278 with incident edges @xmath279 , @xmath280 , @xmath281 , and @xmath282 .",
    "the edge @xmath283 remembers that it originated from @xmath284 . in frederickson",
    "s topology trees the base clusters are all disjoint . to represent labels associated with a vertex @xmath4",
    ", we just add them to the above path representing @xmath4 as extra vertices .    to transform a topology tree into a top tree",
    ", we essentially just take each topology cluster @xmath12 and transform it into the top cluster @xmath285 induced by the vertices , edges , and labels contained in @xmath12 .",
    "we note that @xmath285 has at most two boundary vertices .",
    "clearly this is the case if @xmath12 has at most two boundary edges , but if @xmath12 has three boundary edges , @xmath12 consists of a single vertex , which is hence the only boundary vertex . as an exception ,",
    "if a topology cluster has no labels or edges from the original tree , there is no corresponding top cluster is considered empty and has no representative in the top tree .",
    "the base top clusters are those derived from the base topology clusters , plus a base cluster for each edge not in a derived base cluster .",
    "now , a topology @xmath36 in converts into two top @xmath36s , where first one of the topology children @xmath36 with the edge between them .",
    "next the resulting top cluster @xmath36s with the other topology child",
    ". here a @xmath36 with an empty top cluster is just skipped .",
    "since a topology @xmath36 may requires two top @xmath36s , each level in a topology tree translates into two levels in a top tree . given the proofs for topology trees in  @xcite , we conclude that theorem  [ thm : top - maintain ] and  [ thm : weighted - top - maintain ] hold true .",
    "the achievement with top trees is a simpler interface for high - degree trees where the ternarization is not done by each application but by the implementation via the above reduction . also , the @xmath36 has slightly fewer cases and is slightly simpler because we do not have to incorporate an edge between the clusters",
    ".      we will now demonstrate how sleator and tarjan s st - trees  @xcite can be used to implement topology trees whose base clusters are the vertices .",
    "together with the previous reduction from top trees to topology trees , this provides us with a very different implementation of theorem  [ thm : top - maintain ] . here by st - trees , we do not refer to the nice path - oriented axiomatic interface from  @xcite , but to the underlying implementation .",
    "first , we note that the st - trees are presented for rooted trees , but on the other hand , they have an @xmath286 operation , making @xmath4 the root of its tree .",
    "hence , to perform an arbitrary @xmath287 , we can first @xmath288 , making it root of its tree , and then @xmath287 , making @xmath289 a parent pointer .    since our starting point is an unrooted ternary tree ,",
    "a rooted version of it is a binary tree .",
    "an exception is the root , which in principle could be have three children .",
    "however , this is easily avoided .",
    "first of all , we could pick the root as a a leaf in the unrooted tree with degree one .",
    "also , consider the situation above where we want to @xmath287 and first make @xmath104 the root with @xmath288 .",
    "since the result is ternary , @xmath104 had degree at most two before @xmath287 , so @xmath104 does not get three children .",
    "the @xmath287 operation is just adding a parent pointer to @xmath104 .",
    "sleator and tarjan define a set of disjoint solid paths down from a vertex in @xmath9 to a leaf providing a partitioning of the vertices .",
    "they then form an st - tree @xmath290 as follows .",
    "they take each solid path @xmath291 with @xmath292 closest to the root and @xmath293 the parent of @xmath292 , and remove all parent pointers of the vertices in the path .",
    "then they make a binary tree @xmath294 with @xmath295 as leaves appearing in this order , and make @xmath293 the parent of the root .",
    "if @xmath292 was the root of the whole tree , the root of @xmath294 becomes the root of @xmath290 , which in  @xcite ends up with logarithmic height .",
    "now each vertex @xmath4 in @xmath290 represents the cluster @xmath51 induced by the vertices from @xmath9 descending from it in @xmath290 . to see that these are clusters we just note that if @xmath296 above , the descendants of @xmath4 from @xmath297 form a segment @xmath239 of @xmath297 .",
    "the only edges incident to @xmath51 are then the parent pointer from the first vertex in @xmath239 and the children pointer from the last vertex in @xmath239 to its child in @xmath297 , if any .",
    "we can now construct the topology tree as follows .",
    "the base clusters are the vertices of @xmath9 .",
    "the rest of the top tree is constructed by following @xmath290 bottom - up . when we meet a vertex @xmath4 from @xmath9 , it has only one child @xmath5 in @xmath290 , which was its non - solid child in @xmath9",
    ". then @xmath298 .",
    "when we meet a vertex @xmath299 not from @xmath9 , it has two children @xmath104 and @xmath5 in @xmath290 , and then @xmath300 .",
    "thus we have established a mapping from the st - tree @xmath290 to a topology tree @xmath124 whose base clusters are the vertices .",
    "since the st - tree has height @xmath0 so does the topology tree . also , the main technical result from  @xcite is that each @xmath24 , @xmath25 , and @xmath216 , only affects @xmath0 vertices in the st - trees , including their parents , and hence this gets translated into @xmath0 @xmath33s and @xmath36s .",
    "thus , we can derive frederickson s topology trees  @xcite , and hence top trees , from sleator and tarjan s st - trees  @xcite .",
    "in particular this implies that the simple amortized version of st - trees  @xcite provides a simple amortized version of top trees .",
    "when using the amortized version of top trees , there is no guarantee of the height of the top tree .",
    "however , if we precede each query with an @xmath22 we will meet the amortized bounds .",
    "the advantage of top trees and topology trees over st - trees is a nice , easy to apply , interpretation of the system of solid paths replaced by binary trees in st - trees .",
    "this point is illustrated with our top tree solutions to the diameter , center , and median problems for dynamic trees , improving over previous solutions based on st - trees  @xcite .",
    "we have introduced top trees as a _ design _ of an interface providing users with easier access to the power of previous techniques for maintaining information in a fully - dynamic forest .",
    "conceptually , top trees are very similar to frederickson s topology trees @xcite , the subtle difference being that top clusters are @xmath36ed by vertices whereas topology trees are @xmath36ed via edges .",
    "this small difference has the immediate advantage that top trees work directly for trees of unbounded degrees , which with topology trees would first have to be coded as ternary trees .",
    "it also makes @xmath36s of two clusters a bit simpler in that they do not involve an intermediate edge .    using top trees , we dealt with a variety of different applications including non - local search problems like maintaining the center or median of trees in a dynamic forest .",
    "for these two problems , we provided quadratic improvements over previous bounds .",
    "we also showed how top trees , in theory , could be implemented both with frederickson s topology trees @xcite , and with sleator and tarjan s st - trees  @xcite .",
    "a main practical challenge is now to make a good library implementation of top trees for use in different applications .",
    "we could have different implementations , e.g. , a worst - case implementation based on the ideas in topology trees @xcite , and a faster amortized implementation based on st - trees  @xcite .",
    "for speed , the implementations should be tuned directly for top trees and not just use our general reductions .",
    "ideally , applications and implementations should only communicate with each other via the top tree interface , so that one can replace one implementation with another in a plug - and - play manner without a change to the applications .",
    "it is not trivial to make such generic interfaces efficient , but c++ solutions have been reported in by austern et al .",
    "@xcite for the simpler case of balanced binary search trees .",
    "we do hope to address such practical library implementations of top trees in future work .",
    "we would like to thank renato werneck for many very helpful comments to an earlier version of this paper ."
  ],
  "abstract_text": [
    "<S> we introduce top trees as a design of a new simpler interface for data structures maintaining information in a fully - dynamic forest . </S>",
    "<S> we demonstrate how easy and versatile they are to use on a host of different applications . </S>",
    "<S> for example , we show how to maintain the diameter , center , and median of each tree in the forest . </S>",
    "<S> the forest can be updated by insertion and deletion of edges and by changes to vertex and edge weights . </S>",
    "<S> each update is supported in @xmath0 time , where @xmath1 is the size of the tree(s ) involved in the update . </S>",
    "<S> also , we show how to support nearest common ancestor queries and level ancestor queries with respect to arbitrary roots in @xmath0 time . </S>",
    "<S> finally , with marked and unmarked vertices , we show how to compute distances to a nearest marked vertex . </S>",
    "<S> the later has applications to approximate nearest marked vertex in general graphs , and thereby to static optimization problems over shortest path metrics .    technically speaking , top trees are easily implemented either with frederickson s topology trees [ ambivalent data structures for dynamic 2-edge - connectivity and @xmath2 smallest spanning trees , _ siam j. comput . </S>",
    "<S> _ 26 ( 2 ) pp .  484538 , 1997 ] or with sleator and tarjan s dynamic trees </S>",
    "<S> [ a data structure for dynamic trees . </S>",
    "<S> _ j. comput . </S>",
    "<S> syst . </S>",
    "<S> sc . </S>",
    "<S> _ 26 ( 3 ) pp .  </S>",
    "<S> 362391 , 1983 ] . </S>",
    "<S> however , we claim that the interface is simpler for many applications , and indeed our new bounds are quadratic improvements over previous bounds where they exist . </S>"
  ]
}