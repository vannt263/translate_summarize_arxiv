{
  "article_text": [
    "since the inception of quantum computing @xcite , a large effort has been devoted to making quantum computers function in a noisy environment and securing them against imperfections in the physical setup itself .",
    "the theoretical literature offers several ways to cope with such errors .",
    "the leading idea is to encode quantum states into a larger system @xcite such that noise hits can be recognized and subsequently corrected . a quantum computation",
    "can then be performed in a fault - tolerant way directly on these encoding systems @xcite , and nested levels of error - correction can make the computation error - free .",
    "the last statement assumes that the initial error rate is not too high and that the error hits are not too correlated , e.g.  occur locally . beyond these assumptions ,",
    "quantum error - correction schemes require significant resources in terms of circuit size and experimental control @xcite .",
    "other approaches use decoherence - free subspaces , employing for the quantum computation those parts of a system s hilbert space which are relatively unaffected by the noise @xcite .",
    "the latter approach works only in more limited circumstances and requires detailed knowledge of the noise .    here ,",
    "we follow a different idea which tries to avoid the disadvantages just mentioned . rather than devoting large efforts to eliminating the errors at all costs ,",
    "we accept them in the computation and try to design algorithms that eventually still find the desired result .",
    "the spatial size of the quantum circuit should however not be enlarged much beyond the noiseless version of the algorithm ; one may e.g.  allow only a number of extra qubits that remains bounded by a constant as the problem size becomes large @xcite ( whereas it seems reasonable to allow for an exponentially large noiseless classical memory ) .",
    "furthermore , the algorithms should find the desired result under any level of background noise  this level may actually be unknown to the algorithm , hence the term _ fault - ignorant computation_. the algorithm is , however , allowed to take more time the larger the actual noise gets . in this sense , we are trading spatial resources ( circuit size ) for temporal resources ( runtime ) .",
    "still , when the actual noise level is low ( but constant in the problem size ) , we want our algorithms to produce the desired result faster than any classical algorithm even in a noiseless environment  this indeed will be the case for the explicit algorithms we present .",
    "we describe the fault - ignorant approach and these desiderata in more detail in section [ moreformaldescription ] .    while under noise the resulting fault - ignorant algorithms may not give the full quantum speedup for large problem sizes",
    ", they may still be useful for initial and medium - term realizations of quantum computers , in particular in the non - scalable low - qubit number regime which does not allow for full - blown quantum error correction schemes .    in this paper",
    ", we analyze the above _ fault - ignorant idea _ for the example of quantum search on a noisy quantum computer .",
    "the unstructured search problem , i.e.  the search for a marked item in an unordered list with oracle access , can be solved on a noiseless quantum computer by grover s algorithm quadratically faster than by any classical algorithm @xcite .",
    "this quantum speedup is optimal @xcite .",
    "good algorithms or optimality issues for the noisy case are however much less clear .",
    "many studies in this direction investigate how ( different models of ) background noise or a faulty oracle affect specifically grover s algorithm",
    "( e.g.  @xcite ) , and it is often found that the quadratic speedup persists as long as the noise stays below a certain threshold depending on the database size",
    ". only the paper @xcite by regev and schiff gives , for a specific model of a faulty oracle , a general lower bound on the number of oracle invocations necessary to find the marked item by _ any _ quantum algorithm ; ref .",
    "@xcite proves the analogous result for any continuous - time implementation of oracle search .",
    "a concrete algorithm that functions under a faulty oracle is briefly suggested in @xcite , advocating the avoidance of active error correction as well , as we do .    in the quantum search part of this paper ,",
    "we address the strengths and weaknesses of general oracular search algorithms under noise in more detail .",
    "notably , we state all our upper and lower runtime bounds with explicit prefactors as e.g.  in theorems [ thmsymmalgomemoryless][thmlowerboundwithmemory ] , which in particular allows a comparison with the performance of classical search algorithms already for `` small '' ( i.e.  non - asymptotic ) database sizes @xmath0 . on the one hand",
    "we give fault - ignorant algorithms , on the other we investigate their optimality .",
    "more detailed comparisons to the works @xcite are made in section [ moregeneralmemoryalgos ] .",
    "the hilbert space in our setup consists of a search space , possibly supplemented by an ancillary quantum system and both suffering from noise ; our constructive algorithms will actually not use ancillary systems , but we allow for them in the proofs of our lower runtime bounds , which strengthens these . additionally , the algorithms may have access to a noiseless classical memory , which is a technologically realistic assumption .",
    "the noise itself is modelled as discrete hits of some noise channel that is to be applied between any two oracle invocations .",
    "the problem of fault - ignorant quantum search is then as follows :  devise a quantum algorithm that , except for some specified maximal failure probability @xmath1 , returns the marked item under any decoherence rate @xmath2 , using as few oracle calls as possible .",
    "the fastest ( noiseless ) classical algorithm needs @xmath3 table lookups for this task , examining the database entries one by one .",
    "we exhibit quantum algorithms which , under low but constant depolarizing level @xmath2 , require fewer oracle calls than this classical algorithm , see e.g.  theorem [ thmunknownpwithoutexcluding ] .",
    "the paper is organized as follows .",
    "we give a more detailed description of the fault - ignorant idea in sec .",
    "[ moreformaldescription ] , while referring to appendix [ sec : faultignorance ] for a general and precise mathematical definition of _ fault - ignorant algorithms_. those readers interested mainly in the problem of quantum search on a noisy quantum computer are directed to the remaining sections . in sec .",
    "[ sec : memoryless ] we introduce quantum search in the presence of decoherence , and develop a fault - ignorant algorithm ( algorithm [ algounknownpnotexcluding ] ) that consists of `` quantum building blocks '' and uses the noiseless classical memory merely to store the marked item in case of a previous successful round .",
    "a matching lower bound on the runtime of such algorithms is given by theorem [ thmsymmalgomemoryless ] .",
    "we expand this analysis in sec .",
    "[ sec : withmemory ] and allow for a noiseless classical memory that can store all previously falsified items , which enhances search efficiency ( algorithm [ algounknownpexcluding ] ) . in appendix",
    "[ sec : noisemodels ] we discuss in more detail the noise models for which our results from the main text apply .",
    "here we describe the main desiderata on fault - ignorant algorithms , with particular emphasis on oracular algorithms that are the main topic of the following sections . for a precise mathematical formalization of fault - ignorance , which also includes algorithms computing probabilistic functions as in sampling problems and computational algorithms such as factoring ,",
    "we refer the reader to appendix [ sec : faultignorance ] ( in particular , definitions [ definitionnoisytask ] and [ definefaultignorantalgo ] there ) .",
    "the tasks we consider consist in the computation of a classical output @xmath4 as a function of an oracle index @xmath5 and an input @xmath6 , which we assume is given via a specified encoding @xmath7 in the quantum register at the start of the algorithm .",
    "the specification of the task contains already the available size of the quantum register , i.e.  the hilbert space @xmath8 on which the @xmath7 act and which is assumed to be fixed throughout the computation ; in early implementations of quantum computers this size may be severely limited and is thus assumed to be part of the problem specification . besides the quantum register , we allow for a classical register that may serve several purposes :  _ ( i ) _ to be used during the computation , _",
    "( ii ) _ to store the output , _ ( iii ) _ to hold a binary flag indicating whether the output has already been written into the register , such that it can be read out by an outside agent without disturbing the ( quantum ) computation that may still be ongoing ( such an indication is necessary since the noise level and the algorithm runtime may not be known in advance , see below ) .    for the task of oracle search among @xmath0 items",
    ", we thus have @xmath9 and would like to produce the output @xmath10 , whereas the quantum register can be initialized in any fixed state @xmath11 as there is no other input to the task , i.e.  @xmath12 .",
    "we can allow for any quantum register @xmath13 ; @xmath14 would for example enable to perform grover s algorithm using the oracle eq .",
    "( [ oracleaction ] ) ( see section [ setupnoiselessandmodels ] ) , but we may also allow for additional quantum registers such that e.g.  @xmath15 .",
    "we have not yet specified in what way fault - ignorant algorithms should behave with respect to noise . for this",
    "we need two more ingredients .",
    "the first is a family of noise channels , denoted by @xmath16 and acting only on the quantum register , that should model the effect of the noise per unit time ( see also appendix [ sec : noisemodels ] ) , and we think of the index @xmath17 $ ] as a noise strength parameter that is _ not _ known to the agent executing the algorithm .",
    "classical registers are assumed noise - free .",
    "for our results on noisy quantum seach in the following sections , we will for example choose the noise models in eqs .",
    "( [ partiallydepolnoise ] ) or ( [ mostgeneralnoisemodel ] ) .",
    "the second ingredient is the specification of the set @xmath18 of operations that an algorithm can perform per unit time .",
    "@xmath18 may be any subset of all quantum channels acting jointly on the quantum and classical register .",
    "actually , for oracular algorithms , each element @xmath19 also depends on the oracle index @xmath20 that is not directly accessible to the algorithm ; rather , when an algorithm `` calls '' the operation @xmath21 , then the quantum channel @xmath22 is executed .",
    "again for the oracular search case below , we allow any @xmath23 that calls the oracle @xmath24 from eq .",
    "( [ oracleaction ] ) once , possibly preceded and followed by any quantum channels @xmath25 acting on the quantum and classical registers ( and not depending on @xmath20 ) . for oracular problems ,",
    "such a specification of the allowed operations per unit time is quite natural , but other choices are possible ; for computational problems one can for example impose locality restrictions on the operations per time step , such as in example [ binaryadditionexample ] in appendix [ sec : faultignorance ] .",
    "the specification of what constitutes one time step will be implicit in eq .",
    "( [ algorithmicsequenceia ] ) below , saying that the noise channel @xmath16 is to be applied once between any two operations from @xmath18 .",
    "an _ algorithm _ is now simply a sequence @xmath26 of operations @xmath27 . algorithms may depend on an accuracy parameter @xmath28 , denoting the maximum probability with which we allow a wrong answer to be output .",
    "crucially however , for a _ fault - ignorant algorithm _",
    "@xmath29 , we _ do not _ allow the operations @xmath30 to depend on the above noise level @xmath2 , but still require that , for _ each _ noise level @xmath17 $ ] , after the execution of any number @xmath31 of time steps @xmath32 the classical output register holds the correct output @xmath33 , up to failure probability @xmath1 ( see also fig .  [",
    "fig : ignorance ] in appendix [ sec : faultignorance ] for illustration ) .",
    "we call an algorithm @xmath29 _ fault - ignorant _ if @xmath34 can be chosen finite for all @xmath17 $ ] , and we will actually denote by @xmath34 the smallest time such that the previous requirement is satisfied for all @xmath31 ( see definition [ definefaultignorantalgo ] in appendix [ sec : faultignorance ] for an exact statement ) .",
    "in other words , a fault - ignorant algorithm is ignorant of the noise level @xmath2 , but should nevertheless output the correct answer @xmath33 irrespective of the noise @xmath2 , within a time @xmath35 that may depend on the unknown noise level @xmath2 .",
    "note that any computation which can be performed in a noiseless classical register of sufficient size alone constitutes a fault - ignorant algorithm , as we assume classical memory to be unaffected by the noise .    as a further instructive example of a fault - ignorant algorithm ,",
    "assume the following :  _ ( a ) _",
    "@xmath36 is a finite - step algorithm such that , after executing the sequence ( [ algorithmicsequenceia ] ) for @xmath37 time steps , there is for _ any _ noise level @xmath17 $ ] a nonzero success probability @xmath38 of obtaining the correct output @xmath33 in the classical register , _ ( b ) _ the set @xmath18 contains operations that allow to check whether a tentative result @xmath39 in the classical register is correct , _ ( c ) _ the input encoding @xmath7 is `` classical '' in the sense that there are operations in @xmath18 which can extract from @xmath7 the index @xmath40 onto a classical register , and conversely allow to prepare the quantum state @xmath7 given the classical value of @xmath40 ( requirement _ ( c ) _ is easy when @xmath41 , as in the search task ) .",
    "if these three conditions hold , one can construct a fault - ignorant algorithm that solves the task for any fixed accuracy parameter @xmath42 , as follows :    * repeatedly run the @xmath37-step sequence @xmath36 with noise interspersed as in ( [ algorithmicsequenceia ] ) on the initial state @xmath43 ( note that , after the value @xmath40 has been saved in a classical register at the start , this initial state can be reproduced before each iteration due to condition _ ( c ) _ ) , * after each iteration check for the correctness of the answer proposed in this iteration according to _ ( b ) _ , and store the correct result in an overall output register once it has been found .    if the actual noise level is @xmath2 , then after @xmath44 iterations of @xmath36 , the failure probability equals @xmath45 , which will become smaller than any specified @xmath28 if only @xmath46 is large enough .",
    "more precisely , since each round including verification consumes @xmath47 time steps , the composite check - and - repeat algorithm has a runtime @xmath48    for example , in searches using the quantum oracle ( [ oracleaction ] ) , one can satisfy the above conditions _ ( a)__(c ) _ by randomly selecting in each iteration an index @xmath49 ( see also the beginning of section [ firstsearchwithexclusionsubsection ] ) and then using the oracle @xmath24 once to check whether @xmath50 . in this example , @xmath51 and @xmath52 for all @xmath2 . for another similar example , see the beginning of section [ subsectionmemorylessunknown ] .",
    "in fact , all the constructive algorithms we present in this paper will be variations of the above check - and - repeat algorithm , with possibly varying numbers @xmath53 of oracle uses in each round @xmath54 ( section [ subsectionmemorylessunknown ] , see fig .",
    "[ fig : alg1 ] for illustration ) and possibly leaving out previously falsified items in future rounds ( section [ sec : withmemory ] , see also fig .",
    "[ fig : alg2 ] ) .    due to",
    "this simple way of constructing fault - ignorant algorithms , the meaningful question , which we investigate in the following sections for noisy quantum search , is about the efficiency of fault - ignorant algorithms .",
    "notice for example that the first algorithm proposed in the previous paragraph has a runtime of @xmath55 , proportional to the problem size @xmath0 and _ independent _ of @xmath17 $ ] .",
    "however , one might hope that there exist fault - ignorant algorithms which for small actual noise level @xmath2 need fewer oracle calls , because at least when the noise is _ known _ to vanish ( i.e.  @xmath56 ) then grover s algorithm solves the problem with at most roughly @xmath57 oracle calls ( see section [ setupnoiselessandmodels ] ) .",
    "furthermore , both these runtimes diverge in the limit of perfect accuracy , i.e.  @xmath58 , whereas the classical algorithm checking the @xmath0 items one after another needs only a finite number @xmath0 of steps for perfect accuracy .",
    "in fact , in the following sections we will develop a fault - ignorant quantum search algorithm which , under the noise models ( [ mostgeneralnoisemodel ] ) and up to a constant overall factor , for any @xmath0 , @xmath2 , @xmath1 requires fewer oracle calls than the ones just mentioned ( see theorem [ thmknownpwithoutexcluding ] ) .    when given a fault - ignorant algorithm solving one specific task ( e.g.  one specified problem of size @xmath0 , of specified quantum register size @xmath59 , noise model @xmath60 , and accuracy goal @xmath1 ) , one can compare its runtime @xmath34 to the runtime of other algorithms that can be implemented ( e.g.  to the classical search algorithm above , or to any algorithm that `` knows '' the noise level @xmath2 as one of its inputs , or to any algorithm that may use a quantum register of some larger size , etc . ) . on the basis of this comparison one",
    "can then decide whether to consider this fault - ignorant algorithm useful w.r.t .",
    "the competitor . instead of",
    "solely the runtime , one may take into account also other factors in this comparison , such as the size of the quantum register used by either algorithm .",
    "it does not seem possible to give general criteria for such a decision .",
    "however , due to the prefactors given in the runtime bounds for our concrete algorithms , one can for example use our theorems [ thmunknownpwithoutexcluding ] and [ thmknownpwithoutexcluding ] to compare these fault - ignorant algorithms in such a way to other algorithms ( which we for example do below theorem [ thmunknownpwithoutexcluding ] and in section [ moregeneralmemoryalgos ] ) .    instead of performing such a comparison for one specific task , one may consider a whole family of tasks ( e.g.  one for each problem size @xmath61 and accuracy @xmath28 , possibly also allowing the size of the quantum register to vary independently of @xmath0 , etc . ) and",
    "fault - ignorant algorithms solving them .",
    "in this situation one can then investigate the _ scaling _ of the runtime @xmath34 with these parameters @xmath0 , @xmath1 , etc .",
    ", as is usual in complexity theory , and investigate various tradeoffs , e.g.  between the runtime and the size of the quantum register .",
    "again , the concrete questions seem to depend highly on the tasks at hand .    nevertheless , since the main feature of fault - ignorant algorithms is to find the correct answer _",
    "without knowing _ the noise level @xmath2 in advance , we can introduce a distinguished notion of _ efficient fault - ignorant algorithm _ :",
    "a family of fault - ignorant algorithms ( each solving a task from a given family of tasks ) is called _ efficient _ if there exists a constant @xmath62 such that for each fixed @xmath17 $ ] the runtime @xmath34 ( which depends on the member of the family ) is at most a factor of @xmath63 larger than the runtime of any algorithm that solves the same task while _ knowing _ the noise value @xmath2 as one of its inputs ( i.e.  need _ not _ be fault - ignorant ) . in other words , we call a fault - ignorant algorithm _ efficient _ if knowing the actual noise level @xmath2 would shorten its runtime by at most an overall factor @xmath64 . our theorem [ thmlowerboundwithmemory ]",
    "can thus be seen as a statement that algorithm [ algounknownpexcluding ] is efficient w.r.t .  to the class of algorithms considered and , furthermore , an upper bound on",
    "the constant @xmath63 is apparent together with theorem [ thmknownpwithoutexcluding ] .",
    "independently of this efficiency notion , for low enough ( but unknown ) noise level @xmath2 , the runtime of algorithm [ algounknownpexcluding ] compares favorably with noiseless classical search ( see section [ moregeneralmemoryalgos ] ) .",
    "the quantum search problem @xcite asks for an algorithm of short runtime to identify ( up to some small error probability @xmath1 ) one out of @xmath0 oracles , i.e.  to return the index @xmath20 of the `` black box '' implementing the unitary transformation @xmath65 where @xmath9 and @xmath66 denotes addition modulo 2 . here , we assume the oracle @xmath20 to have been chosen uniformly at random ( often referred to as unstructured database ) .",
    "it is customary to take the input of the oracle @xmath67 at each step to be of the product form @xmath68 so that the output is also of this form with the _ sign _ of the coefficient of @xmath69 flipped in the first tensor factor @xmath70 . in this case",
    "one can neglect the second subsystem and concentrate on the effective unitary transformation @xmath71 as usual , we measure the runtime of an oracular algorithm by counting the number of queries ( oracle uses ) , which are viewed as the expensive or time - consuming operations , and disregard all the other quantum channels which are independent of the oracle .",
    "grover @xcite found a solution to this problem which makes use of the equal superposition state @xmath72  this state reflects the initial lack of knowledge about the oracle and will be used frequently in the following . at the beginning of the algorithm the state @xmath73",
    "is prepared and then the oracle black box @xmath24 and the unitary @xmath74 are applied alternately .",
    "( in this description , and in our whole paper , we disregard any subsystem structure of @xmath75 ; if , for example , @xmath76 , then the `` inversion about the mean '' @xmath74 can be implemented efficiently in the number @xmath77 of qubits @xcite ) .",
    "after @xmath37 applications of both operators , a von neumann measurement is performed in the standard basis . the outcome of this measurement will give the correct index @xmath20 of the oracle with probability @xcite @xmath78 independently of which oracle @xmath9 was implemented by the black box . in particular ,",
    "if we choose @xmath79 , the success probability is @xmath80 .",
    "alternatively , if we fix some small maximal error probability @xmath81 , with which the algorithm may return an incorrect oracle index , then we may stop after @xmath82 iterations .",
    "in fact , it can be shown , for any @xmath83 , that grover s algorithm yields the highest probability of success which can be achieved by any quantum algorithm using the oracle @xmath37 times @xcite .",
    "the above analysis is valid when the unitaries and measurements etc .",
    "can be implemented perfectly and the quantum computer is not subject to noise . in more realistic settings , however , these idealizations have to be lifted , and some such extensions have been considered in the literature before , cf",
    ".  section [ sec : intro ] . in this work",
    ", we consider the specific case where the quantum computer is continually affected by noise , e.g.  coming from the environment .",
    "our aim is not to approach this problem by implementing quantum error correction , which may be expensive in terms of the required control and size of the quantum computer .",
    "rather , we aim to find ( optimal ) algorithms which succeed even under the influence of  known , or ideally even _ unknown _  noise , in such a way that their runtime may depend on the noise level ; see sec .  [",
    "sec : intro ] .    throughout this paper",
    "the term `` noise '' will mean the application of a certain quantum channel to the state of the quantum register in discrete time steps .",
    "this is supposed to model , within the discrete - time setting of oracle algorithms , that the quantum computer is continually affected by noise .",
    "more precisely , we will impose that the noise channel has to act _ once between any two invocations of the oracle_.    our paradigmatic example of noise will be the family of _ partial depolarizing _ channels @xmath84 acting on states @xmath85 on a @xmath86-dimensional hilbert space .",
    "we can interpret these channels as acting on the system in a completely depolarizing way if a biased coin toss yields heads , which happens with probability @xmath17 $ ] , and otherwise leaving the quantum computer undisturbed .",
    "intuitively speaking , the partially depolarizing noise ( [ partiallydepolnoise ] ) discards the whole quantum register with probability @xmath2 between any two successive oracle invocations .",
    "in particular , quantum error correction can not be applied to this noise model ( cf .",
    "appendix [ sec : noisemodels ] ) ; but so it serves to illustrate our idea of _ fault - ignorant computing _ , one of whose rationales actually is to avoid costly error correction procedures . in appendix",
    "[ sec : noisemodels ] we will further introduce partially dephasing noise ( [ definepartialdephasing ] ) , which has an additional interpretation as modelling the transitioning from quantum to classical algorithms , and we relate the different noise models .",
    "the lower bounds on the runtime of noisy quantum search algorithms which we prove ( theorems [ thmsymmalgomemoryless ] and [ thmlowerboundwithmemory ] ) rely on partial depolarizing ( [ partiallydepolnoise ] ) , which is a very drastic and in some implementations quite pessimistic noise model , as it acts in a strongly correlated way across the whole quantum register ( somewhat similar to a noisy oracle @xcite , see also sec .  [ moregeneralmemoryalgos ] ) . for initial implementations of quantum computing",
    "this may in some cases indeed be a reasonable assumption , e.g.  when @xmath2 denotes the occurrence probability of a noise event requiring the restarting of the whole quantum computer .",
    "the noise strength @xmath2 could for example be related to the timescale of a drifting laser or of collective hits by external stray magnetic fields .",
    "nevertheless , it would be desirable to prove similar lower runtime bounds for weaker noise models , in particular incorporating some kind of locality , but for now our bounds provide at least a ( pessimistic ) point of comparison .",
    "on the other hand , the concrete algorithms we provide will function with the guaranteed upper runtime bounds given in theorems [ thmunknownpwithoutexcluding ] and [ thmknownpwithoutexcluding ] even under any more general noise of the form @xmath87 with @xmath21 being an arbitrary quantum channel .",
    "i.e.  it is necessary only that with probability @xmath88 at each step no fatal noise event occurs .",
    "partial depolarizing and partial dephasing are special cases of this .",
    "let us see how the probability of a successful measurement , i.e.  returning the correct oracle index @xmath20 , looks when we include an application of the noise channel after each query . as a preparation ,",
    "we first consider grover s algorithm under noise . introducing the channel @xmath89 , the final state can be written as @xmath90 , so that the success probability is then @xmath91 where we took an average over the @xmath0 possible oracles , since the search is unstructured and we assume equal a priori probabilities . in this paper",
    ", we choose to consider the _ average success probability _ of algorithms , i.e.  averaged over all possible oracles with equal weight ( see e.g.  @xcite ) , as opposed to the minimal success probability , i.e.  minimized over all oracles ( e.g.  @xcite )",
    ". both figures of merit agree for `` symmetric algorithms '' , e.g.  for grover s algorithm @xcite and for the constructive algorithms we propose in this paper .",
    "but our choice strengthens the lower bounds derived in the following on the required number of oracle invocations .",
    "now , for all above noise models @xmath92 ( see eq .",
    "( [ mostgeneralnoisemodel ] ) ) , the evolution @xmath93 can be written as a sum of @xmath94 histories . since each term",
    "gives a nonnegative contribution to the sum , we can find a lower bound by keeping only the noise - free term @xmath95 in each factor : @xmath96 which is quite sharp unless @xmath97 , cf .",
    "appendix [ sec : noisemodels ] ; compare this also to noiseless case , eq .",
    "( [ noiselesssuccessprobab ] ) .",
    "( the convention @xmath98 is understood throughout this paper . )",
    "we are now interested in how well this simple algorithm , and other algorithms that we shall consider below ( i.e.  not necessarily consisting of grover steps ) , perform .",
    "that is , we would now like to derive _ upper _ bounds on the success probability @xmath99 depending on @xmath0 , @xmath37 , and @xmath2 .",
    "as the starting point we use the implicit bound on @xmath99 derived by zalka @xcite for the average success probability @xmath99 after @xmath37 oracle calls : @xmath100 this bound has been established in @xcite for the following situation :  we start from any pure state @xmath101 ; the oracle @xmath24 ( @xmath102 ) inverts the coefficients of the basis states within a subset @xmath103 where @xmath104 for @xmath105 ; we let arbitrary unitaries @xmath106 act after each oracle use ; in the end we perform a von neumann measurement in some basis , and our guess for @xmath20 is an arbitrary function of the measurement outcome .",
    "the same bound ( [ zalkaimplicit ] ) holds thus when we start from any mixed state over @xmath107 ( @xmath108 ) , apply arbitrary channels between the oracle uses , and our guess for @xmath20 comes from measuring a povm @xmath109 .",
    "this holds because mixed states , quantum channels and povm measurements can be dilated to pure states , unitary evolutions and von neumann measurements on a larger system @xcite , and the oracles ( [ oracleaction ] ) tensored by the identity on all other subsystems still invert coefficients of disjoint sets of basis states .    even for the more general algorithms described above",
    ", we can thus use inequality ( [ zalkaimplicit ] ) together with lemma [ lemmaxyineq ] ( see appendix [ app : technical ] ) , to prove the following _ explicit upper bound _ on the average success probability @xmath99 of any quantum algorithm using @xmath37 oracle calls ( with or without noise ) : @xmath110    this bound does not depend on the noise strength @xmath2 , and thus gives no further restrictions on _ noisy _ search compared to the noiseless case .",
    "but it does enable us to prove a result on the limitations of algorithms employing a noisy quantum register @xmath111 for computation , with the oracle acting on the first subsystem .",
    "note that the computational steps @xmath112 , @xmath113 in any algorithm covered by the following upper bounds on the success probability are nowhere assumed to be necessarily unital .",
    "if they all were unital , then after the occurrence of a noise hit of partial depolarizing ( corresponding to the term @xmath114 in ( [ partiallydepolnoise ] ) ) the success probability of finding the marked item would be fixed at @xmath115 , whereas non - unital actions might try to correct a partial depolarizing error and increase the success probability ( we will comment on a particular non - unital error - detection - and - correction strategy below eq .",
    "( [ eq : firstbound ] ) ) . and , actually , the following result holds even for noise channels @xmath116 that may be somewhat more general than the partial depolarizing given in eq .",
    "( [ partiallydepolnoise ] ) :    [ thm8kplus1overp ] let @xmath117 be the initial state of the algorithm , @xmath118 defined by @xmath119 be the quantum channels implementing the oracles on the first subsystem , and @xmath120 the noise channel that is to be applied between any two oracle calls , with @xmath17 $ ] and @xmath121 any quantum state .",
    "let @xmath122 denote steps in the algorithm , such that the state after @xmath37 uses of the oracle @xmath123 is @xmath124 and let the final measurement be given by the povm @xmath125 .",
    "then the average success probability of this algorithm is upper bounded as follows : @xmath126~\\leq~\\frac{1}{n}+\\frac{8}{np^2}~,\\label{moretrivialimplication}\\ ] ] and @xmath127    introduce the following states : @xmath128 for @xmath129 , and @xmath130 . with these we can write @xmath131 and hence @xmath132~=~\\sum_{i=1}^{k}p(1-p)^{i-1}\\sum_x\\operatorname{tr}[\\sigma_i^xe_x]\\,+\\,(1-p)^k\\sum_x\\operatorname{tr}[\\sigma_k^xe_x]~.\\ ] ] as the `` computation '' of @xmath133 involved @xmath40 oracle calls , from ( [ psboundfromzalka ] ) we have @xmath134\\le ( 2i+1)^2 $ ] , and thus @xmath135 which trivially leads to ( [ moretrivialimplication ] ) .",
    "furthermore , we can use @xmath136 by the bernoulli inequality to obtain ( [ 8kplus1overp ] ) : @xmath137    algorithm 0 , performing @xmath37 steps of quantum search .",
    "noise is acting between any two oracle invocations @xmath24 ( see eq .",
    "( [ oracleaction ] ) ) , before and after which one may however apply arbitrary channels @xmath112 , @xmath138 .",
    "the computation uses a quantum register of dimension @xmath0 , on which the oracle acts , and an ancillary ( quantum ) register @xmath139 , both noisy .",
    "a measurement , described by some povm @xmath140 , is applied to the final state @xmath141 to guess the marked element @xmath20 . ]    in the following text we shall address a sequence of operations as in ( [ statefrombasicbuildingblock ] ) acting on an initial state @xmath142 as * algorithm 0 * ( or @xmath143 ) , which is also depicted in fig .",
    "[ fig : alg0 ] .",
    "it is worthwhile to mention two ways of using bounds as in theorem [ thm8kplus1overp ] :    1 .",
    "one can consider the noise level @xmath2 to be fixed and examine the scaling behaviour ( e.g.  of the algorithm runtime ) with respect to the number @xmath0 of search items , or 2 .",
    "one can consider @xmath2 to scale in some way with @xmath0 .",
    "point ( ii ) provides a way to compare the results with other works ( e.g.  @xcite ) where this kind of scaling was analyzed .",
    "our results , however , apply to any values of @xmath0 and @xmath2 ( and later , of @xmath1 ) in the stated ranges , but we are implicitly often imagining the case @xmath144 , @xmath145 ( and @xmath146 ) , which is a sensible limit as explained in appendix [ sec : noisemodels ] .",
    "theorem [ thm8kplus1overp ] has two important implications .",
    "the first is that , for any fixed @xmath147 , the growth of the success probability is at most _ linear _ in the number @xmath37 of queries , as opposed to the quadratic growth in the noiseless case ( cf .",
    "( [ noiselesssuccessprobab ] ) for @xmath148 ) .",
    "this may come as a surprise as one might have guessed that the quadratic speedup of grover s algorithm may persist for small enough noise levels @xmath147",
    "( i.e.  fixed @xmath2 and @xmath144 ) . in other words ,",
    "theorem [ thm8kplus1overp ] says that there exists _ no _ algorithm with success probability @xmath149 whenever partial depolarizing acts .",
    "the inequality ( [ 8kplus1overp ] ) in particular implies that quantum error correction _ can not _ be done for partially depolarizing noise @xmath16 with @xmath147 .",
    "the second implication is that the success probability is bounded by @xmath150 _ independently of @xmath37 _ , cf .",
    "( [ moretrivialimplication ] ) . for growing @xmath144 , this goes to @xmath151 unless @xmath152 ; in general we can not reach a prescribed success probabilty @xmath153 with an algorithm as described in theorem [ thm8kplus1overp ] .",
    "the straightforward solution to this problem is that we repeat the algorithm ( including the final measurement ) until the probability of failure in all the repetitions combined drops below @xmath1 .",
    "this strategy is detailed in the following subsection and shows the basic structure for all further algorithms .",
    "now we consider algorithms that consist of a number of repetitions ( rounds ) of the basic building block described in the previous subsection :  repeatedly preparing states like ( [ statefrombasicbuildingblock ] ) , using the oracle @xmath24 a number of times , and trying to infer the oracle index @xmath20 by a measurement . in our concrete constructions",
    "we shall , as in grover s algorithm @xcite , specify the channels @xmath138 in ( [ statefrombasicbuildingblock ] ) to perform unitary inversions ( @xmath74 ) about the mean , and @xmath112 to equal the identity channel ( whereas for our lower bounds @xmath112 , @xmath138 remain arbitrary ) .",
    "note that these repetitions require a _ noiseless _ classical memory in order to reliably store the correct result @xmath20 after one of the rounds has been successful ( any noisy classical register may be part of the subsystem @xmath139 in theorem [ thm8kplus1overp ] and is subject to noise @xmath16 ) .",
    "furthermore , in order to test whether the measurement after any one of the repetitions has returned the correct index @xmath20 and in order not to overwrite the correct result in subsequent rounds , one needs to perform a verification of the measurement outcome  using _ one _ oracle call or classical table look - up  immediately after each measurement .    in this subsection",
    "we will first develop and analyze an algorithm that finds , except for some specified failure probability @xmath42 , the marked element @xmath20 among @xmath0 elements , on a noisy quantum computer .",
    "secondly , we will prove ( theorem [ thmsymmalgomemoryless ] ) that , up to a constant , the runtime of this algorithm is optimal among a certain class of algorithms , when the noise level @xmath2 is known in advance .",
    "our algorithm will consist of @xmath154 rounds of the procedure described in theorem [ thm8kplus1overp ] , each time checking whether the concluding measurement gave the correct @xmath20 and , if so , storing the result in a noiseless classical register .",
    "specifically , in each round we perform grover s algorithm for some number @xmath37 ( to be determined ) of steps  this has been described at the beginning of subsection [ basicbuildingblocksubsection ] .",
    "we now first give a motivating `` derivation '' of the algorithm .",
    "clearly , the events `` the noise did not hit and the measurement was unsuccessful in the @xmath40th round '' and `` the noise did not hit and the measurement was unsuccessful in the @xmath155th round '' are independent for @xmath156 when we use grover iterations , and similarly for more than two rounds , since grover s algorithm is symmetric with respect to permutation of the oracles ( the probability for the complement of each such event is given by ( [ lowerboundprobs ] ) , which we will substitute below for @xmath157 ) .",
    "this means that if we perform @xmath154 rounds with @xmath37 grover iterations in each round , then the probability of failure and the total number of queries will be @xmath158 and @xmath159 , respectively ( including the verification step after each of the @xmath154 measurements ) .",
    "if we are to reach the target error bound @xmath1 in the least number of steps , we need to minimize @xmath159 subject to the condition @xmath160 .",
    "the latter gives a lower bound on @xmath154 depending on @xmath0 , @xmath37 and @xmath2 , namely @xmath161 this means that for given values of @xmath0 and @xmath2 one needs to minimize @xmath162 i.e.  the number of queries per decrease of error probability by a factor of @xmath163 , where the factor @xmath164 is included for normalization .",
    "let the optimal @xmath37 be denoted by @xmath165 .",
    "note that minimizing the rate function @xmath166 from ( [ definitionf ] ) originates from minimizing the number of oracle calls from independent rounds to get the failure probability below @xmath1 .",
    "this is different than optimizing the _ expected _ number of oracle calls , cf .",
    "@xcite for a comparison .",
    "then our new algorithm consists of @xmath167 repetitions of rounds with @xmath165 grover steps each , measurement in the standard basis plus verification step and storing the result in the classical output register when successful .",
    "the discussion in the following example will motivate an easy - to - compute quantity to be used instead of @xmath165 .",
    "[ examplewherenequalsinfty ] if we are interested in large databases , we can simplify by taking @xmath144 , yielding , with ( [ lowerboundprobs ] ) instead of ( [ exactsuccessprobabfordepol ] ) ( giving virtually identical results ) : @xmath168 to find the optimal @xmath169 , we compare ( @xmath170 ) : @xmath171 this is a decreasing function of @xmath2 , so @xmath172 and @xmath173 intersect at @xmath174 which is appropriate for large @xmath37 , and we have @xmath175 whenever @xmath176 with the convention @xmath177 . by inverting the series expansion around @xmath178 one",
    "can get an _",
    "explicit _ approximate expression for @xmath179 :  the inverse is @xmath180 , and thus @xmath181 is a good approximation especially for small @xmath2 .    intuitively , this behaviour of the optimal length @xmath182 of a quantum round can be understood by noting that the quantum register remains undisturbed with reasonably high probability ( of order @xmath183 ) for time @xmath184 , whereas with a probability approaching @xmath185 exponentially the quantum register will be disturbed by noise when @xmath186 .",
    "this is because the noise will hit at each step independently with probablity @xmath2 ( see eq .",
    "( [ partiallydepolnoise ] ) ) .",
    "thus , roughly @xmath184 grover steps provide an advantage ( see also , e.g. , @xcite ) . plugging @xmath187 into @xmath173 and considering small noise level @xmath188",
    ", we see @xmath189 so @xmath190 vanishes linearly in @xmath2 around @xmath56 . the fact that this is non - zero and finite for @xmath147 , means that the normalization by @xmath115 in ( [ definitionf ] ) was the `` correct '' one .",
    "this suggests that the number of steps @xmath191 necessary is proportional to @xmath192 , i.e.  linear in @xmath0 for any fixed @xmath147 and @xmath28 , meaning that the quadratic speedup is lost under depolarizing noise ( [ partiallydepolnoise ] ) ; see theorem [ thmsymmalgomemoryless ] for a more rigorous and general lower bound on the runtime .",
    "example [ examplewherenequalsinfty ] motivates a more rigorous analysis of the case of finite @xmath193 . in this finite case",
    ", one has to be careful for small values of @xmath2 , since it is clearly not a good idea to do more than @xmath194 grover iterations in one round .",
    "let us first assume that @xmath195 , and suppose we perform @xmath196 rounds with @xmath197 grover steps in each round , for some @xmath198 ( this ansatz is motivated by example [ examplewherenequalsinfty ] , and will below turn out to be good ) .",
    "then the probability of failing in all rounds can be bounded as ( see [ lowerboundprobs ] ) @xmath199^{\\lceil cnp^2\\log\\frac{1}{\\varepsilon}\\rceil}~   & \\le~ \\left[1-(1-p)^{\\left\\lfloor\\frac{1}{p}\\right\\rfloor}\\sin^2\\left(\\left(2\\left\\lfloor\\frac{1}{p}\\right\\rfloor+1\\right)\\arcsin\\frac{1}{\\sqrt{n}}\\right)\\right]^{\\lceil cnp^2\\log\\frac{1}{\\varepsilon}\\rceil } \\nonumber \\\\   & \\le~ \\left[1-(1-p)^{\\frac{1}{p}}\\sin^2\\left(\\left(\\frac{2}{p}-1\\right)\\arcsin\\frac{1}{\\sqrt{n}}\\right)\\right]^{\\lceil cnp^2\\log\\frac{1}{\\varepsilon}\\rceil }   \\nonumber\\\\   & \\le~\\left[1-(1-p)^{\\frac{1}{p}}(1-\\delta)\\left(\\frac{2}{p}-1\\right)^2\\frac{1}{n}\\right]^{\\lceil cnp^2\\log\\frac{1}{\\varepsilon}\\rceil } \\nonumber \\\\   & \\le~\\exp\\left\\{-c(1-p)^\\frac{1}{p}(1-\\delta)\\left(\\frac{2}{p}-1\\right)^2p^2\\log\\frac{1}{\\varepsilon}\\right\\}\\nonumber\\\\ & = ~ \\varepsilon^{c(1-\\delta)(1-p)^{\\frac{1}{p}}(2-p)^2}\\label{boundfailingforknownp}\\end{aligned}\\ ] ] for some @xmath200 depending on @xmath0 and @xmath2 .    as we want to guarantee a failing probability of at most @xmath1 , we need to choose @xmath201 such that the exponent in the final expression ( [ boundfailingforknownp ] ) is at least @xmath185  independently of @xmath2 for the following statements to be valid .",
    "however , for large values of @xmath2 the exponent goes to @xmath151 , which is a consequence of vanishing ( [ lowerboundprobs ] ) for large @xmath2 and @xmath202 grover steps ; this can be avoided by introducing a cutoff @xmath203 into the specification of the algorithm , such that for @xmath204 we use @xmath51 iterations in each round , i.e.  only perform verification steps on randomly chosen elements .",
    "the failure probability in this range is @xmath205    numerically one finds that viable values for @xmath201 and @xmath206 in the specification of a concrete algorithm , i.e.  such that both ( [ boundfailingforknownp ] ) and ( [ failureproblargep ] ) do not exceed @xmath1 , are , for example , @xmath207 and @xmath208 ( even when setting @xmath209 ) .",
    "we have not optimized these constants , as our main interest for now is in the scaling for large @xmath0 , small @xmath1 , and all noise levels @xmath2 .",
    "the number of oracle invocations during such an algorithm is upper bounded by @xmath210 where we used @xmath195 .    for small noise levels @xmath211 ( where @xmath212 )",
    ", one can do @xmath213 grover iterations in each of the @xmath154 rounds , i.e.  before each measurement , which gives a success probability of at least roughly @xmath214 by the lower bound ( [ lowerboundprobs ] ) ; therefore , @xmath215 rounds are sufficient to get the failure probability below @xmath1 , putting an upper bound on the number of oracle calls similar to ( [ upperboundnumsteps ] ) with a term proportional to @xmath216 instead of the term @xmath217 .    summing up",
    ", our algorithm finds the marked element @xmath20 , except with probability @xmath218 $ ] , on a quantum computer with noise level @xmath17 $ ] using the oracle at most @xmath219 times , e.g.  for ( non - optimal ) constants @xmath220 .",
    "we omit here a formal statement of the algorithm , which should have become resonably clear from the description above , but will remedy this in subsection [ subsectionmemorylessunknown ] for the more general case of unknown noise level .",
    "the algorithm just described performs a number @xmath154 of quantum rounds , each of identical length @xmath37 given by an ansatz that is based on example [ examplewherenequalsinfty ] .",
    "a cleverer algorithm might try to detect when a noise event has happened and then immediately abort the present round in such a case and start a fresh round in order not to `` waste '' oracle uses .",
    "one way to accomplish this would be to adjoin to the quantum register @xmath75 used above another quantum register @xmath221 of @xmath44 qubits that is initialized to @xmath222 at the beginning of each round and is left untouched by the above algorithm . in case of a partial depolarizing noise event , given by the term @xmath223 in ( [ partiallydepolnoise ] ) , the @xmath44-qubit register will then be reset to a computational basis state other than @xmath222 which can be detected by a projective measurement on this auxilliary system with probability @xmath224 .",
    "thus , by expending a small number @xmath44 of extra qubits ( e.g.  a number @xmath44 that is constant in the problem size @xmath0 , or chosen as @xmath225 ) one can detect a noise hit with high probability and abort the present round to gain a saving in the number of oracle calls compared to the algorithm outlined above .    while this is a viable strategy in the noise model used above",
    ", it is actually extremely dependent on the noise model ( [ partiallydepolnoise ] ) .",
    "if , for example , the noise would replace the whole quantum state with probability @xmath2 by @xmath226 ( instead of @xmath227 ) , then the exact strategy would not work anymore .",
    "in particular , any such strategy relies strongly on the fact that the noise is correlated across the whole quantum register .",
    "while we allow such strongly correlated noise as a pessimistic assumption from the outset , in particular to prove our _ lower _ runtime bounds , one would probably not want the actual _ constructive _ algorithms to rely on this assumption .",
    "in contrast , our algorithm developed below example [ examplewherenequalsinfty ] as well as the upper runtime bound ( [ eq : firstbound ] ) work for any noise model @xmath228 with @xmath21 _ any _ quantum channel @xmath21 ( see app .  [",
    "sec : noisemodels ] ) .",
    "this is because we only use eq .",
    "( [ lowerboundprobs ] ) , which merely relies on the fact that with probability @xmath229 the quantum register remains undisturbed . furthermore ,",
    "even when relying on an exactly known noise model as e.g.  in eq .",
    "( [ partiallydepolnoise ] ) , one would at most save a constant factor of order @xmath185 by the error - detection - strategy compared to the runtime ( [ eq : firstbound ] ) of the algorithm outlined above .",
    "this is due to the exponential first factor in ( [ lowerboundprobs ] ) , which implies that only with small probability @xmath230 will the noise hit occur before executing @xmath231 steps in one round ( where @xmath232 here , such that there would be a saving ) .",
    "we would like to point out that there are at least two different interpretations of runtime complexity results like eq .",
    "( [ eq : firstbound ] ) .",
    "firstly , one can run the algorithm indefinitely long ( i.e.  without any a priori bound on the number of rounds ) until the marked element is found .",
    "then we can guarantee that the algorithm gives the correct result with probability @xmath185 , and the number of oracle calls required is at most @xmath233 except with probability @xmath1 .",
    "alternatively , one can decide in advance to use the oracle @xmath233 times before terminating the above algorithm , and after any successful measurement store the result in a classical memory ; then , in the end , the marked element will have been found with probability at least @xmath153 .    with the runtime bound ( [ eq : firstbound ] ) at hand , one can look at the case where @xmath2 is fixed and independent of @xmath0 .",
    "then we see that , unless @xmath56 , the leading term is @xmath234 , i.e.  proportional to @xmath0 . on the other hand ,",
    "if one supposes that @xmath2 scales decreasingly with @xmath0 , the other terms may dominate .",
    "in particular , if @xmath235 , the leading term is @xmath236 .    next we show that our algorithm presented above is essentially optimal within a certain class of algorithms ( a wider class of algorithms will be considered in section [ sec : withmemory ] ) .",
    "namely , we assume that the algorithms employ a quantum register @xmath111 ( as above in theorem [ thm8kplus1overp ] ) , consist of several `` rounds '' where in each round we prepare some state , apply arbitrary channels and use the oracle an arbitrary number of times ( possibly different for each round , but applying the noise channel between any two consecutive queries ) , do any measurement yielding an element of @xmath237 , and verify the result with one oracle use , writing it into a ( noiseless ) classical register reserved for storing the output if correct .",
    "crucially , we assume that the events of success in each round are independent of each other .",
    "this assumption is valid in particular if the noise is symmetric ( under permutations of the basis vectors @xmath69 of @xmath75 , which partial depolarizing from eq .",
    "( [ partiallydepolnoise ] ) satisfies ) and if the steps between measurements are grover iterations ( as for example in our algorithm above ) .",
    "[ thmsymmalgomemoryless ] consider a sequence of algorithms , one for each size of the search space @xmath238 , satisfying the assumptions just stated and subject to partial depolarizing noise ( eq .  ( [ partiallydepolnoise ] ) ) .",
    "if the success probabilities are @xmath239 , then , asymptotically , the number of queries @xmath240 in the @xmath0th algorithm is lower bounded by the level @xmath17 $ ] of depolarizing noise : @xmath241 more precisely , for any @xmath242 $ ] and any finite @xmath243 , the number of queries @xmath240 satisfies : @xmath244^{-1}~.\\ ] ]    suppose that the @xmath0th algorithm consists of @xmath245 rounds with @xmath246 queries in each round ( abbreviating @xmath247 ) , with failure probability @xmath248 in the @xmath40th round .",
    "then @xmath249 , and by the independence condition @xmath250 which is a weighted average of expressions of type @xmath251 .",
    "lower - bounding this expression thus automatically lower - bounds ( [ weightedaverageinproof ] ) , and therefore it is enough to consider the @xmath252 case only .",
    "since , by ( [ moretrivialimplication ] ) , @xmath253 as @xmath144 ( for any @xmath147 ) , one has @xmath254 for some positive sequence @xmath255 . using that , by ( [ 8kplus1overp ] ) ,",
    "also @xmath256 we get @xmath257    the finite-@xmath0 bound follows from @xmath258 and setting @xmath259 equal to the quantity inside the square brackets in ( [ finitenbound ] ) .",
    "theorem [ thmsymmalgomemoryless ] shows that , under any nonzero noise @xmath147 ( and @xmath28 ) , our algorithm from above has asymptotically optimal runtime , up to a constant factor :  in our algorithm , @xmath260 was chosen independent of @xmath0 and ( [ eq : firstbound ] ) shows that asymptotically @xmath261 , which matches ( [ eq : asymptotics ] ) up to a factor of @xmath262 . in the noiseless case @xmath56 , our algorithm reduces to repeated grover searches , whose optimality for @xmath56 was shown in @xcite .",
    "one other implication is noteworthy : on the one hand , theorem [ thmsymmalgomemoryless ] says that , at fixed positive noise @xmath147 and asymptotically for @xmath144 , the number of oracle queries @xmath263 _ has _ to grow at least linearly in @xmath0 , so that the quadratic speed of noiseless grover search is lost ( at least for the class of algorithms considered above , and for the depolarizing noise model , eq .",
    "[ partiallydepolnoise ] ) . on the other hand , however , the prefactor in this linear growth is @xmath264 , which is actually achieved by the explicit algorithm above , see eq .",
    "( [ eq : firstbound ] ) ; thus , for small enough noise @xmath2 , the number of oracle calls to solve the search task by a quantum algorithm is _ much less _ than the minimal number @xmath265 of oracle calls required by any classical algorithm , even in a noiseless environment .",
    "in the following subsection , we will extend the above algorithm so that it works in a noisy environment even when its noise level @xmath2 is _ not _ known beforehand ( algorithm [ algounknownpnotexcluding ] and theorem [ thmunknownpwithoutexcluding ] ) .",
    "we are now ready to turn to the _ `` fault - ignorant '' setting _  the algorithm should be ignorant of the actual noise level under which the quantum computer operates . more precisely , the goal is to find an algorithm for which not the ability to give the correct result depends on the level of noise , but rather only its runtime may depend on the actual noise level .",
    "actually , the algorithm described in the previous subsection has this property for any fixed number @xmath37 of oracle calls per round ; however , the runtime can then become large unless @xmath266 .",
    "for example , if we choose @xmath267 in order to get a quadratic speedup for @xmath56 , then for @xmath268 the number of oracle calls grows as fast as @xmath269 , which is clearly unsatisfactory .    in order to overcome this problem",
    "we allow the number of queries to change from round to round .",
    "thus , for each @xmath0 and @xmath1 , we need to find a sequence @xmath270 , where @xmath271 denotes the number of grover iterations performed in the @xmath40th round . again , for our constructive algorithm , we employ the usual grover iterations ; and again , theorem [ thmsymmalgomemoryless ] will later show that this algorithm is nearly optimal .",
    "one idea can be as follows . in the first round",
    ", we do a grover search with @xmath272 oracle calls ( for the definition of @xmath182 see below ( [ definitionf ] ) ) . for @xmath273 this is enough to get the error probability below @xmath1 as long as @xmath56 ; the set @xmath274\\,\\big|\\,p_s(n , k_{opt}(n,0),p)>1-\\varepsilon\\right\\}$ ] is open and therefore @xmath275\\,\\big|\\,1-p_s(n , k_1,p)\\geq\\varepsilon\\right\\}~\\ ] ] exists and is larger than @xmath151 ( if the set is empty , e.g.  when @xmath276 , we set the infimum to @xmath277 ) .",
    "suppose that the measurement after the first round fails to find the marked element @xmath20 .",
    "there are now two possibilities :  either the actual noise level was below @xmath278 , in which case the probability of this failure was at most @xmath1 ( i.e.  as required ) ; or the actual noise level exceeded @xmath278 , in which case the function @xmath182 gives an upper bound on the optimal number of grover iterations to perform in the next round , so we set @xmath279 .",
    "we then proceed similarly by iteratively setting @xmath280\\,\\big|\\,\\prod_{j=1}^{i-1}\\left(1-p_s(n , k_j , p)\\right)\\ge\\varepsilon\\right\\}$ ] and @xmath281 , giving the number of grover iterations to be performed in the @xmath40th round .",
    "the fault - ignorant algorithm [ algounknownpnotexcluding ] searches the marked element @xmath20 in consecutive rounds of @xmath282 grover steps plus one verification step each .",
    "each round starts by preparing the equal superposition state @xmath283 , which is follwed by grover steps ( a special case of algorithm @xmath151 , see fig .",
    "[ fig : alg0 ] ) , and a measurement in the computational basis ; finally , the output is checked against the oracle ( possibly by list look - up ) and , in case of success , stored ( by @xmath284 ) in a noiseless classical register with @xmath0 states , so that the result is ready for readout by an external agent ( the algorithm may however continue ) .",
    "no ancillary system @xmath139 is used by the algorithm ( @xmath285 ) . ]",
    "the sequences @xmath286 obtained this way are difficult to analyze , but by examining the results of numerical simulations for various values of @xmath0 and @xmath1 one can get an idea about their behaviour .",
    "this turns out to be enough to get an approximation which still achieves the asymptotically optimal performance , up to a multiplicative factor in the runtime ( see below ) . specifically , we arrive at the following algorithm ( see also fig .",
    "[ fig : alg1 ] ) for _ fault - ignorant quantum search _ :    [ algounknownpnotexcluding ] for suitably chosen @xmath198 , define @xmath287 repeat the following steps for @xmath288 :    1 .",
    "prepare the equal superposition state @xmath289 on a quantum register @xmath75 , 2 .",
    "perform @xmath290 grover iterations , 3 .",
    "measure in the standard basis , verify the result using one oracle invocation ; if correct then store in classical output register .",
    "the following theorem proves that algorithm  [ algounknownpnotexcluding ] is fault - ignorant , i.e.  finds the marked element independently of the actual noise level ( in particular , the algorithm does not need @xmath2 as an input ) , and gives a bound on its runtime which , however , depends on the actual noise level .",
    "[ thmunknownpwithoutexcluding ] let @xmath17 $ ] be the actual noise level ( i.e.  noise @xmath291 with any quantum channel @xmath21 ) acting on the quantum register when executing algorithm  [ algounknownpnotexcluding ] , and let @xmath292 and @xmath293 $ ] .",
    "then algorithm  [ algounknownpnotexcluding ] , with @xmath294 , finds the marked element after at most @xmath295 oracle queries except with probability at most @xmath1 .",
    "if one wants algorithm [ algounknownpnotexcluding ] to be fault - ignorant only for noise levels @xmath296 $ ] , and if one presupposes reasonable values @xmath297 and @xmath298 $ ] , then one can guarantee the constant prefactor to be @xmath299 instead of @xmath300 as in ( [ stepsinfirstfaulttolerantalgo ] ) , when using @xmath301 ; cf .",
    "appendix [ mainthm ] .",
    "as the proof of theorem [ thmunknownpwithoutexcluding ] is rather technical , we present here only a sketch ; for details , see appendix [ mainthm ] .",
    "as the noise acts symmetrically with respect to the different oracles and since the grover steps of algorithm  [ algounknownpnotexcluding ] are symmetric as well , the success events for different rounds @xmath302 are independent , so that we will be able to upper bound the failure probability after round @xmath303 : @xmath304 when the sum @xmath305 in the last expression is greater than @xmath306 then we can guarantee the failure probability to be at most @xmath1 , as desired . to get the statement about the number of oracle calls",
    ", we upper bound it by @xmath307    the proof of theorem [ thmunknownpwithoutexcluding ] now consists in showing that there exists a number @xmath303 ( of rounds ) such that the failure probability ( [ failprobabinfirstlowerbound ] ) is at most @xmath1 , while the number of oracle calls ( [ numoforaclecallsfirstlowerbound ] ) is at most ( [ stepsinfirstfaulttolerantalgo ] ) . similar to our analysis leading up to ( [ eq : firstbound ] ) , this argument will be split into three different cases : for @xmath308 the first few rounds ( @xmath288 ) are the important ones ; for @xmath309 we take into account only the rounds with @xmath310 ( i.e.  large @xmath302 ) ; and for @xmath311 our proof relies on an intermediate regime of @xmath302 .",
    "details are given in appendix [ mainthm ] .",
    "theorem [ thmsymmalgomemoryless ] actually shows that the runtime of algorithm [ algounknownpnotexcluding ] ( which we just proved to be at most eq .",
    "( [ stepsinfirstfaulttolerantalgo ] ) ) is _ optimal up to a constant _ : to see this , note that algorithm [ algounknownpnotexcluding ] is contained in the class of algorithms to which the bound from theorem [ thmsymmalgomemoryless ] on the number of oracle queries @xmath312 applies . for any fixed noise level @xmath147 and up to a constant factor",
    ", this equals the upper bound ( [ stepsinfirstfaulttolerantalgo ] ) on the number of queries needed by algorithm [ algounknownpnotexcluding ] .",
    "in particular , even if one does _ not _ know the actual noise level in advance , one only loses a constant factor in the number of queries , compared to the runtime in case of known @xmath2 ( given in eq .",
    "( [ eq : firstbound ] ) ) .",
    "we re - emphasize here the last point from subsection [ subsectrepeatbuildingblockknownp ] , that for small enough but constant noise levels @xmath2 and in the limit @xmath144 , the quantum algorithm [ algounknownpnotexcluding ] needs _ fewer _ oracle calls than even the best classical algorithm in a noiseless environment .",
    "as the runtime depends on an unknown parameter , it is necessary to have the ability to stop the algorithm as soon as the result is found .",
    "theorem [ thmunknownpwithoutexcluding ] then states a `` probabilistic bound '' on the number of oracle uses up to the point when the element is found ; this bound is probabilistic in the sense that in a fraction of at most @xmath1 of all runs of algorithm [ algounknownpnotexcluding ] , the actual runtime may exceed this bound .    when considering more general algorithms , namely for which the events of failure in different rounds are not independent , the derivation of the lower bound on the necessary number of queries from theorem [ thmsymmalgomemoryless ] is no longer valid .",
    "this dependency can arise either from asymmetric noise or from an asymmetry in the algorithm itself .",
    "indeed , it is useful to consider such `` asymmetric algorithms '' :  already classically one can find the marked element using @xmath313 queries , except with error probability @xmath1 , by simply testing a subset of @xmath313 elements using one oracle call each .",
    "this feature of not considering previously falsified items again is absent from algorithm [ algounknownpnotexcluding ] whose runtime may therefore exceed that of classical search , through the factor @xmath306 in theorem [ thmsymmalgomemoryless ] .",
    "the algorithms considered in section [ sec : withmemory ] will make use of this asymmetry , which can also be conceived of as conditioning the actions in future rounds on previous measurement outcomes that are being stored in a classical memory .",
    "this will be done by incorporating a noiseless classical memory which we will allow the algorithms to use in a limited way , namely by excluding oracle indices that have been falsified in previous rounds .",
    "classical search algorithms can find the marked element with maximal failure probability @xmath1 using at most @xmath313 steps , by excluding falsified oracle indices .",
    "here we aim to achieve an upper bound of @xmath0 on the runtime  independently of @xmath1 and of @xmath2  for our quantum algorithms as well , whereas in section [ sec : memoryless ] we have only presented algorithms whose runtime may exceed @xmath0 parametrically due to the factor @xmath306 , e.g.  in ( [ stepsinfirstfaulttolerantalgo ] ) .    on a quantum computer a random choice may be implemented by preparing the equal superposition state @xmath73 over a subset of basis states followed by a measurement in that basis .",
    "this in turn can be viewed as a grover search with zero iterations ( cf .",
    "subsection [ setupnoiselessandmodels ] ) .",
    "this leads to the idea of replacing the uniform random choices by proper grover searches ( each including several grover steps plus a concluding measurement ) over decreasing subsets , i.e.  @xmath314 after round @xmath315 . for this",
    ", the classical noiseless memory that previously stored only the correct search outcome , will be exanded by a register of @xmath316 states ( @xmath0 bits ) to mark the previously excluded items",
    ".    we shall now develop and sketch a search algorithm based on this idea of excluding previously tested elements ; the following procedure is applicable if the noise level @xmath2 is known beforehand .",
    "if one fixes the number @xmath0 of database entries , the noise parameter @xmath2 and the target error bound @xmath1 , then the question is how to choose the number of iterations in each round in order to consume the least number of queries .",
    "suppose that in the @xmath40th round we perform @xmath317 queries and we do @xmath154 rounds in total .",
    "then the number of queries is @xmath318 , while the probability of not finding the marked element is at most @xmath319 ; thus , the minimal number of queries for which one can guarantee success ( up to failure probability @xmath1 ) in the general noise model is @xmath320 e.g.  letting @xmath321 equal the lower bound in ( [ lowerboundprobs ] ) ( alternatively , ( [ exactsuccessprobabfordepol ] ) ) . for given @xmath322 , the minimum ( [ mindynprogramming ] ) and the corresponding sequence @xmath323 of grover steps can be found by dynamic programming .",
    "clearly , @xmath313 is an upper bound on the number of oracle calls and for any fixed @xmath324 we can bound this as @xmath325 for all @xmath326 .",
    "similarly , by ( [ eq : firstbound ] ) or theorem [ thmunknownpwithoutexcluding ] , for @xmath327 there is also an upper bound of the form @xmath328 , since @xmath329 where @xmath201 is determined by @xmath330 .",
    "hence , an upper bound on the runtime of the form @xmath331 holds for the complement of any neighbourhood of @xmath332 ^ 2 $ ] , at least asymptotically for @xmath144 .    in following subsection",
    "we simplify the above algorithm , based on typical behaviour of the sequences @xmath286 found in numerical experiments .",
    "in this subsection we present a more explicit algorithm to solve the search problem in the _ fault - ignorant setting _ , i.e.  an algorithm which can be specified and works even for _ unknown _ noise level @xmath2 , using the exclusion described above to obtain faster runtime ( cf .",
    "also fig .",
    "[ fig : alg2 ] ) :    [ algounknownpexcluding ] for suitably chosen @xmath198 , define @xmath333 and @xmath334 repeat the following steps for @xmath288 :    1 .",
    "prepare the equal superposition state @xmath335 over the set @xmath336 , 2 .",
    "perform @xmath53 grover iterations ( with @xmath337 as reflection ) , where @xmath338 3 .",
    "measure in the standard basis , verify the result @xmath339 using one oracle invocation , store if correct , 4 .",
    "let @xmath340 .",
    "algorithm [ algounknownpexcluding ] uses exclusion in searching for an element in consecutive rounds of @xmath282 grover steps each , supplemented by one verification query .",
    "each round starts by preparing the equal superposition state @xmath335 of the previously not excluded elements , noted in the classical memory @xmath341 $ ] , and is concluded by a measurement in the computational basis .",
    "the output is then verified against the oracle ( list look - up ) and stored in the classical noiseless memory @xmath342 $ ] if the element is found and marked in the memory @xmath341 $ ] if the round was unsuccessful ( @xmath343 ) . ]",
    "similarly as theorem [ thmunknownpwithoutexcluding ] for algorithm [ algounknownpnotexcluding ] , the following theorem proves fault - ignorance of algorithm [ algounknownpexcluding ] and provides a bound on its runtime :    [ thmknownpwithoutexcluding ] let @xmath17 $ ] be the actual noise level ( i.e.  noise @xmath291 with any quantum channel @xmath21 ) acting on the quantum register when executing algorithm [ algounknownpexcluding ] , and let @xmath344 and @xmath293 $ ] .",
    "then algorithm [ algounknownpexcluding ] , with @xmath294 , finds the marked element after at most @xmath345 oracle queries except with probability at most @xmath1 .",
    "the success probability in each round of algorithm [ algounknownpexcluding ] is at least as large as in algorithm [ algounknownpnotexcluding ] because we are excluding elements ; thus , the runtime of algorithm [ algounknownpnotexcluding ] puts an upper bound on the runtime by ( [ stepsinfirstfaulttolerantalgo ] ) . before that , however , algorithm [ thmunknownpwithoutexcluding ] may switch to testing ( and excluding ) elements in random order ( the second selector in ( [ selectstep2ofalgo2 ] ) ) ; this switch happens after at most @xmath346 oracle calls , and after the switch algorithm [ algounknownpexcluding ] needs at most @xmath347 additional calls to find the marked element except with probability @xmath1 .",
    "the constant @xmath300 in ( [ faultignorantbound ] ) can be improved to @xmath299 for a restricted range of parameters , following the remark below theorem [ thmunknownpwithoutexcluding ] .",
    "again , similar to theorem [ thmsymmalgomemoryless ] , we can show that , despite restricting to grover s specific steps , algorithm [ algounknownpexcluding ] is essentially optimal within a wider class of algorithms .",
    "namely , we extend the class of algorithms considered in and before theorem [ thmsymmalgomemoryless ] in such a way that , instead of requiring independence of the failure probabilites in different rounds , we assume that after each unsuccesful round we exclude the tested element and thereby reduce the search space as well as the state space of the computation .",
    "we also need to ensure that failure probabilities are multiplicative , which is the case e.g.  if both the noise and the algorithm treat the search elements uniformly ( this in particular applies to grover iterations and partial depolarizing noise , see eq .",
    "[ partiallydepolnoise ] ) .    this wider class of algorithms is qualitatively different from the algorithms considered in theorem [ thmsymmalgomemoryless ] , as it now contains algorithms succeeding with @xmath348 oracle calls , _ independently _ of @xmath2 , for example the classical verification - and - exclusion algorithm described at the beginning of sec .",
    "[ firstsearchwithexclusionsubsection ] .",
    "this is reflected in the fact that the lower bound in the following theorem never exceeds @xmath0 , unlike the bounds on @xmath240 in the memoryless setting from theorem [ thmsymmalgomemoryless ] .",
    "[ thmlowerboundwithmemory]for any quantum search algorithm ( that may or may not have the noise level @xmath2 as an input ) satisfying the above constraints and whose quantum register is subject to depolarizing noise ( see eq .",
    "( [ partiallydepolnoise ] ) ) with fixed strength @xmath349 , the number @xmath240 of queries to find the marked element up to fixed failure probability @xmath28 is lower bounded as @xmath350 for some sequence @xmath351 with @xmath352 .",
    "we can assume that @xmath353 , because there does exist an algorithm with this limit being @xmath153 ( see above ) .",
    "for now , fix @xmath0 , and by letting @xmath144 later we will make sure that all following expressions are well - defined ( e.g.  no logarithms of negative arguments occur , etc . ) .",
    "let the number of queries in round @xmath302 ( @xmath354 ) be @xmath355 ( i.e.  including the verification - exclusion step ) , so @xmath356 . for the success probabilty in round @xmath302 we have by ( [ moretrivialimplication ] ) and ( [ 8kplus1overp ] ) @xmath357 where the latter inequality implies that @xmath358 is bounded independently of @xmath37 ( and of @xmath0 ) , since @xmath2 is given .",
    "thus we can lower bound the failure probability ( using @xmath359 ) : @xmath360^{-1}\\right\\}~\\ge~\\exp\\left\\{-\\frac{8}{p}\\frac{q_n}{n - q_n}c_n\\right\\}~,\\label{longchaininmemoryopimalthem}\\end{aligned}\\ ] ] where we used @xmath361 from above and defined @xmath362^{-1}$ ] , which converges to @xmath185 as @xmath144 . inverting ( [ longchaininmemoryopimalthem ] ) to get an explicit bound on @xmath240 finally gives ( [ eqninmemorythmlowerbound ] ) .    with the usual conventions in treating @xmath363 and @xmath364 , theorem [ thmlowerboundwithmemory ] is valid for all",
    "@xmath365 $ ] .",
    "similar to eq .",
    "( [ finitenbound ] ) in theorem [ thmsymmalgomemoryless ] , one could explicitly specify a sequence @xmath366 in the bound ( [ eqninmemorythmlowerbound ] ) which would however complicate the expression .    in summary , algorithm [ algounknownpexcluding ] , which uses the exclusion strategy and grover iterations , is _ fault - ignorant _ and theorem [ thmknownpwithoutexcluding ] provides an upper bound on its runtime .",
    "conversely , theorem [ thmlowerboundwithmemory ] provides a lower bound on the number of oracle calls for any symmetric fault - ignorant algorithm using the exclusion strategy . and",
    "the inequalities from lemma [ memoryoptimaliylemma ] ( see appendix [ app : technical ] ) show that algorithm [ algounknownpexcluding ] is basically optimal within this class of algorithms , in the sense that for any @xmath367 its runtime is at most a constant factor ( independent of @xmath2 and @xmath1 ) above the lower bound from theorem [ thmlowerboundwithmemory ] .",
    "and even stronger , the lower bound on the runtime in theorem [ thmlowerboundwithmemory ] is proven for algorithms that may `` know '' the noise level @xmath2 as one of their inputs ( such as the algorithm resulting from ( [ mindynprogramming ] ) ) , whereas our algorithm [ algounknownpexcluding ] basically saturates this lower bound _ without _ actually being dependent on the actual noise level @xmath2 ; the latter feature is the characteristic of _ fault - ignorant algorithms_. thus , not knowing the noise level inflicting upon the quantum computation extends the runtime at most by a constant factor , which was observed in the memoryless setting following theorem [ thmunknownpwithoutexcluding ] as well .      in section [ sec : memoryless ]",
    "we did not allow for a classical memory ( except to store the correct output ) , whereas in section [ sec : withmemory ] we allowed a noiseless classical register in order to exclude falsified items from future search rounds .",
    "this is obviously not the most general class of algorithms .",
    "one may for example perform non - projective measurements which could result in a non - uniform distribution over oracles ( cf .",
    "@xcite ) after the measurement . or one may abandon the division into `` rounds '' altogether , and rather use the noisy quantum register and noiseless classical memory in a more general way ( cf .",
    "appendix [ sec : faultignorance ] ) .",
    "while these possibilities are rather vague , at least in the noiseless case ( @xmath56 ) grover s algorithm is exactly optimal @xcite .",
    "a similar general proof eludes us in the noisy case considered in this paper ; theorems [ thmsymmalgomemoryless ] and [ thmlowerboundwithmemory ] give such a bound under more restrictive qualifications .",
    "nevertheless , the results obtained here may suggest that any nonzero noise level @xmath147 ( in our noise models , cf .",
    "appendix [ sec : noisemodels ] ) prolongs the runtime beyond the noiseless lower bound ( in @xcite ) , necessitating it to be proportional to the number of search items as @xmath144 .",
    "however , for small but constant noise level @xmath147 , the runtime bound @xmath368 on our algorithms ( cf .",
    "theorems [ thmunknownpwithoutexcluding ] and [ thmknownpwithoutexcluding ] ) can be far below the @xmath369 oracle calls required by the best noiseless classical algorithm . in this regard ,",
    "see @xcite for a treatment of _ locally _ acting noise and questions about optimality in this case .",
    "similar in spirit to our theorems [ thm8kplus1overp ] , [ thmsymmalgomemoryless ] and [ thmlowerboundwithmemory ] , a lower bound of @xmath370 on the runtime of general noisy quantum search algorithms was obtained in @xcite , whose faulty oracle model is somewhat similar to our partial depolarizing noise ( [ partiallydepolnoise ] ) ( with roughly the same noise parameter @xmath2 ; they fixed @xmath371 ) ; see also @xcite for a continuous - time analogue of this result .",
    "one difference is that , in theorems [ thmsymmalgomemoryless ] and [ thmlowerboundwithmemory ] , we allow error - free ( e.g.  classical ) verification steps , whereas every oracle use in @xcite is potentially faulty , leading to a diverging bound as @xmath372 . also , @xcite does not include a noiseless classical memory . due to these extensions ,",
    "our lower bounds are restricted to `` symmetric '' algorithms consisting of `` rounds '' , whereas @xcite applies to _ all _ algorithms within their memoryless setting .",
    "these works do not consider achievability of the bound .",
    "the work @xcite specifically investigated grover s algorithm under phase noise ( see also @xcite ) , again somewhat analogous to our noise model ( [ partiallydepolnoise ] ) .",
    "it was observed that grover s algorithm gives an advantage only if it runs for @xmath373 steps , and it was hinted that at this time one may perform a measurement and start a new grover round . in sections",
    "[ basicbuildingblocksubsection ] and [ subsectrepeatbuildingblockknownp ] , we give more rigorous arguments ( and prefactors ) for the scaling @xmath374 , also for algorithms not necessarily consisting of grover steps . our algorithms [ algounknownpnotexcluding ] and [ algounknownpexcluding ] do indeed use the division into grover rounds , but they even function _ fault - ignorantly_. the avoidance of active error correction @xcite is advocated by @xcite as well .",
    "a more technical difference of our work to most of the literature is that we consider the _ average _ success probability of an algorithm , i.e.  averaged over all @xmath0 oracles with equal weight , whereas the literature most often only investigates the _ minimum _ success probability of any of the @xmath0 oracles .",
    "this makes our lower bounds stronger than the ones obtained in the literature .",
    "( as our constructive algorithms are symmetric , the minimum and average success probabilities coincide for those . )",
    "in this paper we have investigated the idea of _ fault - ignorant quantum algorithms_. such algorithms should output the correct result even in the presence of noise of potentially unknown strength , in such a way that the actual noise level @xmath2 may affect the runtime it takes to arrive at the correct answer ( up to some specified failure probability @xmath1 ) , but should not affect that fact that the correct answer is found eventually .",
    "this approach allows to reduce the required spatial circuit sizes , for example in comparison to using full - scale quantum error correction , however at the expense of increased runtime .    following this general idea ,",
    "we have provided fault - ignorant algorithms for quantum searching that function under depolarizing or dephasing noise of unknown strength @xmath2 .",
    "we find the `` quadratic speedup '' to be achievable only for low decoherence rates @xmath375 .",
    "otherwise , our best algorithm s runtime scales asymptotically like @xmath376 as @xmath144 .",
    "this is linear in @xmath0 , but for low enough noise levels @xmath2 it nevertheless outperforms the optimal classical search algorithm .",
    "our algorithms may thus be useful for initial uses of quantum computing , when unlimited scalability of the size of quantum computers is not yet be achievable due to technological limitations .",
    "we moreover proved that , up to a constant factor , our algorithms runtimes are optimal within wide classes of noisy quantum search algorithms .",
    "remarkably , for the searching task , it turned out that ignorance of the actual noise level will extend the runtime by only a constant factor compared to the case of known noise level @xmath2 .",
    "due to the novelty of the approach , our algorithms and lower bounds leave questions for further research . on the side of concrete algorithms , one may ask for them to be independent not only of the noise level @xmath2 but also of the desired accuracy @xmath1 ; then one could continue running the algorithm for longer time to increase the success probability or accuracy .    concerning lower bounds on the complexity of noisy quantum search , it would be worthwhile to establish an analogue of theorem [ thm8kplus1overp ] for the case of local noise models or even partial dephasing or general partial entanglement - breaking noise .",
    "the latter would immediately extend the validity of our lower bound in theorem [ thmlowerboundwithmemory ] to the class of quantum algorithms that use a noiseless classical register in an arbitrary way and need not be divided into `` quantum rounds '' . in a similar vein , it may also be possible to prove that the essentially optimal runtime for quantum searching under partial depolarizing noise , which we mainly investigated , can always be achieved by an algorithm divided into such rounds ( see sec .  [ moregeneralmemoryalgos ] ) . if not , it would be very interesting to find fault - ignorant algorithms that are not of this simple check - and - repeat form .",
    "finally , it would be desirable to investigate whether and how the fault - ignorant idea could possibly be applied to computational models other than the quantum circuit model .",
    "this would in particular be desirable in computational models for which quantum error correction techniques are less developed , such as adiabatic quantum computing , and where other methods to achieve fault tolerance are needed .",
    "generally , we hope that , beyond unstructured search , the fault - ignorant idea will be fruitfully applied to algorithmic tasks , such as sampling algorithms .",
    "* acknowledgments : * we thank the two anonymous referees for their insightful comments which helped to improve the paper .",
    "this research was initiated at a workshop of the fp7 project coquit , which also supported p.  vrana and d.  reitzner .",
    "d.  reeb was supported by the marie curie intra - european fellowship quintyl .",
    "m.  wolf acknowledges support from the chist - era / bmbf project cqc and the alfried krupp von bohlen und halbach - stiftung .",
    "the aim of this appendix is to provide a rigorous mathematical definition of fault - ignorant computing ( see section [ moreformaldescription ] for a less formal discussion ) .",
    "we do this in a way which enables to include a fairly broad class of algorithmic problems into this framework in a unified manner , while keeping the definition reasonably simple .",
    "the definitions are supposed formalize algorithms that do not need to know the actual noise level in order to accomplish their task  they should be _ ignorant _ of the noise .",
    "a fault - ignorant algorithm should be robust enough to provide the answer ( up to some specified failure probability ) under any level of noise , the latter affecting only its runtime .    in our formalization , we want to allow the desired and the actual output of the algorithm to be probabilistic ( as is usual in sampling and quantum simulation problems ) , and to depend on an input ( as for example in computational problems ) and on an oracle ( as in search problems ) .",
    "given the discrete - time nature of the computation as well as of our noise models ( cf .",
    "appendix [ sec : noisemodels ] ) , it is necessary to explicitly refer to an allowed class of quantum operations ( the set @xmath18 in the following definition ) .",
    "this can be done most conveniently if one also specifies the ( spatial ) resources available for performing the computation , i.e.  the size of the quantum computer available or of any accompanying classical register .",
    "we thus view the specification of the size of the available quantum register as part of the task to be solved ; and indeed , since early realizations of quantum computers will be limited in the number of qubits , it will be a part of the challenge to solve a desired task on the _ available _ hardware , esp .  under noise influence because full - scale quantum error correction may be prohibited .",
    "further , we consider only the quantum register to be noisy , whereas noiseless classical memory is today a reasonable technological assumption .    in light of this",
    ", we propose the following definitions , which we explain and supplement by examples afterwards .",
    "[ definitionnoisytask ] a _ noisy quantum computational task _ is a tuple @xmath377 where    * @xmath378 , @xmath379 , @xmath380 are sets , * @xmath381 is a stochastic matrix , i.e.  has nonnegative entries and for any @xmath5 and @xmath6 we have @xmath382 , * @xmath8 is a hilbert space , * @xmath383 is a function with density operators as values , * @xmath384\\to\\operatorname{cpt}(\\operatorname{\\mathcal{b}}(\\mathcal{h}))$ ] is a function with quantum channels on @xmath385 as values , * @xmath386 , * @xmath387 .    a fault - ignorant algorithm ( definition [ definefaultignorantalgo ] ) , specified to solve a noisy quantum computational task ( definition [ definitionnoisytask ] ) : an input state @xmath388 is affected in turn by devised operations @xmath389 ( which may include an oracle indexed by @xmath20 , or other coherent operations , or measurement / verification procedures that store information in noiseless classical registers @xmath390 , @xmath391 , @xmath392 ) and noise @xmath16 acting on the quantum register . after some number of steps",
    ", the probability distribution of the output @xmath4 should approximate the desired distribution @xmath393 , up to error @xmath1 . ]",
    "we interpret @xmath378 as the set labelling the different oracles , @xmath379 and @xmath380 as the sets of possible inputs and outputs , respectively ( see also fig .  [",
    "fig : ignorance ] ) . for a task which does not make use of an oracle ,",
    "we let @xmath378 be any singleton set , and similarly , if the computation does not need an input , we let @xmath41 .",
    "the stochastic matrix @xmath394 describes the desired distribution on the output set depending on the input and the oracle .",
    "the computation is performed using the hilbert space @xmath8 and a classical memory of @xmath395 states , with the output being written into an additional classical register with @xmath396 states , corresponding to the possible output states in @xmath380 .",
    "the additional classical bit @xmath397 is to have value @xmath185 iff the algorithm wants to signal that the result is available in the register @xmath398 .",
    "the reason for this is that in the fault - ignorant setting the runtime depends on an unknown parameter ( namely @xmath2 , see below ) , and therefore the algorithm needs a way to tell whether the computation is already done , without destroying the quantum state .    the map @xmath383 plays the role of input encoding in the sense that the physical initial state @xmath388 on the register @xmath385 represents the abstract input value @xmath6 .",
    "the quantum register @xmath8 is subject to noise modeled by the quantum channels @xmath16 ( as specified in eq .",
    "( [ defineoutputstate ] ) below ) depending on a parameter @xmath17 $ ] , which we think of as a strength parameter .",
    "finally , the set @xmath399 represents the set of allowed elementary steps .",
    "an element in this subset is understood as a quantum channel depending on the oracle @xmath5 , whereby the quantum channel acts on the quantum register @xmath385 as well as on the classical ( diagonal ) registers @xmath390 , @xmath400 and @xmath392 described above ( our specification below will be such that all these classical registers are initialized in the state @xmath401 at the start of an algorithm ) .",
    "this gives a way to impose conditions on how `` complicated '' the elementary operations are , e.g.  in terms of oracle use or locality requirements ( see examples below ) , and at the same time it maps the abstract oracle @xmath5 to actual physical transformations @xmath22 it may perform .",
    "[ definefaultignorantalgo ] a _ fault - ignorant algorithm _ solving the noisy quantum computational task @xmath377 is a family @xmath402 of finite or infinite sequences with @xmath403 such that for all @xmath28 and for all @xmath17 $ ] the value @xmath404 is finite , where @xmath405 is defined by @xmath406 and @xmath407 for @xmath5 , @xmath6 , @xmath4 , and @xmath408\\label{defineoutputstate}\\ ] ] is a probability distribution on @xmath409 .",
    "thus , the sequence of operations in ( [ defineoutputstate ] ) models a @xmath410-step noisy quantum computation , in the sense that between any two elementary operations from @xmath18 a noise channel @xmath16 is to be applied on the quantum register @xmath385 ( fig .",
    "[ fig : ignorance ] ) .",
    "the sequence @xmath411 itself describes the algorithmic operations , which may depend on the required accuracy @xmath1 , i.e.  on the maximally tolerable distance from the desired output distribution @xmath412 , cf .",
    "( [ defineminimalsteps ] ) .",
    "the requirement for @xmath413 to be finite for _ any _ @xmath2 , even though the algorithm @xmath402 does _ not _ depend on @xmath2 , justifies the term _ fault - ignorant algorithm_. the condition `` @xmath414 '' in ( [ defineminimalsteps ] ) requires the result to be available in the classical memory at any later time when the outside agent , ignorant of the noise level @xmath2 and thus of the necessary computation time @xmath413 , may check the @xmath397 flag to see whether the computation has already finished and want to read out the result .",
    "note that definition [ definefaultignorantalgo ] does _ not _ put any requirements on the efficiency of the algorithm , which however in some circumstances may be quantified by @xmath413 , i.e.  the minimal number of invocations of @xmath415 ( e.g.  oracle calls ) ; see section [ moreformaldescription ] .",
    "we now illustrate the definitions above by two examples .    as an example",
    "we now show how the noisy quantum search problem considered in sections [ sec : memoryless ] and [ sec : withmemory ] fits into this framework . in this case",
    "we have a set of @xmath0 oracles @xmath416 , and the algorithm is required to identify the oracle , so @xmath417 . since no input is needed , we set @xmath12 .",
    "now the function to be computed is deterministic , so @xmath394 will be a @xmath151-@xmath185 matrix , more specifically @xmath418 .",
    "the hilbert space we use is @xmath419 for some @xmath420 setting the size of the ancillary quantum system and @xmath392 standing for the ancillary system used by the oracle , cf .",
    "eq .  ( [ oraclebasic ] ) .",
    "the noise acting on it is for example partial depolarizing , @xmath421 .",
    "since there is no input , @xmath142 is just any fixed initial state , e.g.  we may take @xmath422 . in the version without classical memory we set @xmath423 ( section [ sec : memoryless ] ) , while if we are to exclude previously tested elements , we may set @xmath424 corresponding to an @xmath0-bit classical memory ( section [ sec : withmemory ] ) .",
    "the set of allowed elementary operations to be applied between two noise hits is @xmath425 where @xmath123 first prepares the pure state @xmath426 on the @xmath392-subsystem of @xmath8 , and then acts as @xmath427 on @xmath8 ( cf .",
    "( [ oraclebasic ] ) and ( [ oracleaction ] ) ) and as the identity on the classical registers .",
    "this choice of @xmath18 means that an elementary step consists of a single use of the oracle , possibly applying an arbitrary ( but oracle - independent ! ) channel before and afterwards .",
    "finally , half of the trace - distance in ( [ defineminimalsteps ] ) gives , when the ready - flag @xmath392 has been set to @xmath185 , exactly the probability of not outputting the correct oracle index in the classical output register , and it is this failure probability which we wanted to be smaller than @xmath1 in sections [ sec : memoryless ] and [ sec : withmemory ] .",
    "[ binaryadditionexample]this example illustrates the possibility to introduce some kind of `` locality structure '' .",
    "the task is the addition of two @xmath77-bit numbers given their binary representation using local gates on a @xmath428-bit quantum register with local dephasing noise .",
    "such a task is given by @xmath429 , @xmath430 , @xmath431 , @xmath432 , the hilbert space is @xmath433 , @xmath434 ( with @xmath435 considered as a @xmath428-bit string ) , @xmath436 with @xmath437 the partial dephasing with strength @xmath2 , @xmath423 , and @xmath438 consisting of @xmath185- and @xmath439-(qu)bit gates , i.e.  channels which act as the identity on all but at most two bits ( quantum or classical ) , remembering the subsystem structure of @xmath440 .",
    "an algorithm that works only for _ known _ noise level @xmath2 is _ not _ fault - ignorant ; such algorithms may be formalized by assuming a @xmath2-dependence @xmath441 in the family of sequences in definition [ definefaultignorantalgo ] . on the other hand ,",
    "if these sequences do _ not _ depend on the desired accuracy @xmath1 , i.e.  @xmath442 , then the algorithm does have another feature :  the level of accuracy @xmath1 need not be specified before starting the algorithm ; when higher accuracy is desired ( i.e.  smaller @xmath1 ) , one only needs to continue running the algorithm for longer time .",
    "returning to efficiency questions , one may call a fault - ignorant algorithm ( or rather , a family of fault - ignorant algorithms , parametrized by some `` problem size '' @xmath0 ) _ efficient _ if , for any @xmath2 , any @xmath1 and any @xmath0 , its runtime is within a constant factor times the runtime of the best algorithm that may depend on @xmath1 _ and _ on @xmath2 ( see section [ moreformaldescription ] ) . in this sense ,",
    "our theorems [ thmsymmalgomemoryless ] and [ thmlowerboundwithmemory ] can be seen as statements that algorithms [ algounknownpnotexcluding ] and [ algounknownpexcluding ] are efficient ( within restricted classes of algorithms ) .",
    "it should be clear that there is nothing special about the set @xmath443 $ ] parametrizing the noise channels apart from the possibility to interpret it as `` strength '' or to use it directly as a coefficient in a convex combination .",
    "one could instead consider a family @xmath444 of noise channels indexed by an arbitrary set @xmath445 parametrizing wider classes of noise , and so allowing for `` more '' ignorance about the faults .",
    "another obvious extension of definition [ definitionnoisytask ] would be to allow for time - dependent noise .",
    "here we elaborate on different kinds of noise which may be acting on the quantum computer during its runtime , and in particular on the noise models to which our results apply .    _",
    "partial depolarizing _ , @xmath446 for noise level @xmath17 $ ] , has been defined in eq .",
    "( [ partiallydepolnoise ] ) , and corresponds to erasing the state of the quantum register with probability @xmath2 ( between any two oracle calls ) .",
    "somewhat similar is _ partial dephasing _ , @xmath447 acting on states @xmath85 on a @xmath86-dimensional hilbert space equipped with a distinguished orthonormal basis @xmath448 ( for these , we imagine the basis states with respect to which the oracles ( [ oraclebasic ] ) act ) . for @xmath449",
    ", all quantum coherence is lost between any two oracle calls , but one can still perform a classical algorithm ( on the basis states @xmath69 ) ; in this sense , the noise level @xmath2 of partial dephasing parametrizes how `` quantum '' a search algorithm may be .",
    "our constructive algorithms also work with the runtimes guaranteed by theorems [ thmunknownpwithoutexcluding ] and [ thmknownpwithoutexcluding ] under the more general noise model @xmath450 where @xmath21 may be any quantum channel , see discussion below eq .",
    "( [ partiallydepolnoise ] ) .",
    "our formalization of noisy search algorithms ( sections [ sec : memoryless ] and [ sec : withmemory ] ) does allow to _ noiselessly check _ whether a given index @xmath451 equals the marked element @xmath20 , since immediately before and after an oracle call one may perform any quantum operation without noise ( cf .",
    "( [ statefrombasicbuildingblock ] ) ) and thus one action of @xmath67 from ( [ oraclebasic ] ) on a suitably prepared quantum register can accomplish this check and write the result into the ( noiseless ) classical memory .",
    "this fact is important , as it allows the verification / falsification step at the conclusion of each round ( cf .",
    "algorithms [ algounknownpnotexcluding ] and [ algounknownpexcluding ] ) .",
    "alternatively , such a noiseless check may be implemented by a classical table lookup .",
    "the above noise models are formulated in discrete time , but our prescription for the noise @xmath16 to act between any two oracle calls is supposed to model the continuous action of noise in a real - world situation .",
    "for example , since in ( [ partialdepolsecond ] ) the probability to `` lose '' the quantum computer between any two consecutive oracle calls is @xmath2 , its lifetime is roughly @xmath452 ( measured in the time between two oracle calls ) ; and indeed , the time scale @xmath374 appeared often in the analysis in subsection [ subsectrepeatbuildingblockknownp ] .",
    "note that quantum error correction @xcite does not work for partial depolarizing ( [ partialdepolsecond ] ) or dephasing ( [ definepartialdephasing ] ) , as these noises affect the whole quantum computer `` collectively '' .",
    "this means that the whole quantum computer is subjected to a `` flash '' of noise , such as drifting lasers or an external hit by a magnetic field .",
    "these may be reasonable noise models for not - too - large quantum computers .",
    "discussing the noise models more quantitatively , we first notice that the lower bound ( [ lowerboundprobs ] ) on the success probability after @xmath37 steps of grover s algorithm under noise applies to all three noise models ( [ partialdepolsecond])([gentnoise ] ) . for partial depolarizing ( [ partialdepolsecond ] ) one can compute the success probability in ( [ lowerboundprobs ] ) exactly : the @xmath453 omitted terms are of the form @xmath454 where @xmath154 is the number of noise hits .",
    "these terms correspond to events when the maximally mixed state is prepared at some point due to noise acting and since both @xmath16 and @xmath455 ( see before eq .",
    "( [ firststatementsofpsinmaintext ] ) ) are unital .",
    "as the coefficients of these terms sum up to @xmath456 , the exact success probability for this model is @xmath457 using this exact success probability for partial depolarizing improves the runtime bounds for this specific noise model ( e.g.  theorem [ thmunknownpwithoutexcluding ] for large noise level @xmath2 ) , but the lower bound ( [ lowerboundprobs ] ) is quite tight unless @xmath458 .",
    "the drawbacks of relying on a too specific noise model are furthermore discussed below eq .",
    "( [ eq : firstbound ] ) .",
    "an exact computation of the success probability can also be done for partial dephasing ( [ definepartialdephasing ] ) , but is much more involved .",
    "furthermore , one can prove that the success probability for partial dephasing is not smaller than for depolarizing at the _ same _ noise level :  @xmath459 .",
    "this inequality is , however , not immediate , as for identical noise parameters @xmath349 , partial depolarizing @xmath460 _ can not _ be obtained by post - processing @xmath461 , i.e.  @xmath462 for all quantum channels @xmath445 .",
    "our proofs of the general lower bounds on the number of oracle calls ( theorems [ thmsymmalgomemoryless ] and [ thmlowerboundwithmemory ] ) require partial depolarizing ( [ partialdepolsecond ] ) , as theorem [ thm8kplus1overp ] was proved only for generalized partial depolarizing noise @xmath463 and the proofs ( and presuppositions ) of theorems [ thmsymmalgomemoryless ] and [ thmlowerboundwithmemory ] require furthermore a symmetry between the oracle indices , limiting further to @xmath464 .",
    "finally , we argue that it makes sense in sections [ sec : memoryless ] and [ sec : withmemory ] to perform efficiency analyses by keeping the noise parameter @xmath2 fixed while the size of the quantum register @xmath0 ( or @xmath465 ) varies , possibly even tending to infinity . phrased another way",
    ", we ask whether , for example , the strength of partial depolarizing ( [ partialdepolsecond ] ) with parameter @xmath2 on an @xmath86-dimensional quantum system is comparable to the strength of partial depolarizing with the same parameter @xmath2 in @xmath466 dimensions , even if @xmath86 and @xmath466 are widely different .",
    "first , both partial depolarizing ( [ partialdepolsecond ] ) and partial dephasing ( [ definepartialdephasing ] ) ( the latter with respect to a tensor product of bases ) are compatible under tracing out subsystems when the _ same _ parameter @xmath2 is used on the tensor product system and on the subsystem : @xmath467~=~d^{i,\\varphi}_p\\left({\\rm tr}_b[\\varrho_{ab}]\\right)\\qquad\\forall p\\in[0,1]~.\\ ] ] with this parametrization of the noise , it does therefore not help for algorithm performance to introduce larger and larger ancillary systems or `` innocent bystanders '' :  the noise on the `` grover part '' of the algorithm can not be made small in this way , which is a reasonable requirement .    secondly , both for partial depolarizing and dephasing , one can obtain the noise in @xmath468 dimensions by post - processing the noise on a @xmath86-dimensional system : @xmath469\\,\\forall\\varrho\\in\\operatorname{\\mathcal{b}}(\\mathbb{c}^{d-1})~,\\ ] ] where @xmath470 for dephasing noise ( and the additional dimension @xmath471 has to correspond to one of the basis vectors in ( [ definepartialdephasing ] ) ) , and @xmath472 for depolarizing .",
    "this compatibility under restrictions of the hilbert space to subspaces is important and sensible in the context of exclusion algorithms ( algorithm [ algounknownpexcluding ] , and proof of theorem [ thmknownpwithoutexcluding ] ) , where the effective dimension of the quantum register is reduced by @xmath185 in each round .",
    "as we assume the noise to act symmetrically with respect to the different oracles ( which both partial depolarizing and dephasing do ) and since the grover steps of algorithm  [ algounknownpnotexcluding ] are symmetric as well , the success events in different rounds @xmath302 are independent . thus , with ( [ lowerboundprobs ] ) , we can upper bound the failure probability after round @xmath303 by @xmath473 to show that the failure probability is at most @xmath1 , as desired , below we will lower bound the sum @xmath305 and adjust parameters such that it is at least @xmath306 .",
    "the sum can be further bounded by assuming it to start at some @xmath474 with @xmath475 : @xmath476    the number of oracle calls can be upper bounded as follows : @xmath477    the proof of the theorem now consists in showing that there exists a number @xmath303 ( of rounds ) such that the failure probability ( [ repeatfailureprobabinappendix ] ) is at most @xmath1 , while the number of oracle calls ( [ repeatupperboundonoraclecallsinappendix ] ) does not exceed the value given in ( [ stepsinfirstfaulttolerantalgo ] ) .",
    "this argument will be split into three cases , as sketched in the main text .",
    "we make abundant use of the fact that @xmath478 , since @xmath479 and @xmath294 .",
    "we also define @xmath480 and assume @xmath481 throughout , in accord with the statement of theorem [ thmunknownpwithoutexcluding ] .",
    "* case 1 : * @xmath482 . in this case , the actual decoherence rate @xmath2 is small , and we take only the first few rounds @xmath302 into account to obtain an upper bound on @xmath483 . by using @xmath484 , @xmath485 for @xmath486 , and setting @xmath487}{\\left[\\left(\\frac{\\pi}{2}\\sqrt{n_0}+1\\right)\\arcsin(1/\\sqrt{n_0})\\right]^2}~,\\ ] ]",
    "we continue in bounding ( [ eq : sumfail ] ) : @xmath488 where we used @xmath489 for @xmath490 .",
    "choosing @xmath491 and @xmath492 , we evaluate the integral in ( [ eq : sumfailadvanced ] ) to find @xmath493 where we used @xmath494 .",
    "when the prefactor of @xmath306 is at least @xmath185 , then the failure probability @xmath483 will be at most @xmath1 by eq .",
    "( [ repeatfailureprobabinappendix ] ) ; this happens e.g.  for the choice @xmath495 .",
    "the number of oracle calls from ( [ repeatupperboundonoraclecallsinappendix ] ) is then @xmath496 which is less than @xmath497 due to @xmath498 .",
    "we notice that the term linear in @xmath0 ( cf .",
    "( [ stepsinfirstfaulttolerantalgo ] ) ) is absent from the runtime ( [ upperboundonruntimeincase1 ] ) in case 1 ; intuitively speaking , such small noise levels @xmath2 still allow for quadratic speedup in the quantum search .",
    "* case 2 : * @xmath499 , where we define @xmath500 . in this intermediate region of the actual decoherence rate ( the need for",
    "@xmath501 will become evident later ) , we define @xmath502 and @xmath503 with @xmath504 to be determined later .",
    "our choice @xmath505 will in particular imply @xmath506 , so that we can continue lower - bounding ( [ eq : sumfailadvanced ] ) by bounding the integrand , @xmath507 where we used @xmath508 ( due to @xmath204 ) and @xmath509 ( due to @xmath510 ) .",
    "again , the prefactor of @xmath306 can be made larger than @xmath185 by choosing @xmath511 and @xmath512 .",
    "the number of oracle calls from ( [ repeatupperboundonoraclecallsinappendix ] ) is then @xmath513 which again is less than @xmath514 .",
    "* case 3 : * @xmath204 . for large actual noise levels",
    "@xmath2 , it is enough to consider only those rounds @xmath302 for which @xmath515 ; in each such round , a measurement is performed on the equal superposition state , leading to a success probability of exactly @xmath115 .",
    "this leads to the choice @xmath516 and @xmath517 , and we can lower - bound ( [ eq : sumfail ] ) : @xmath518 by choosing @xmath519 , the prefactor of @xmath306 exceeds @xmath185 .",
    "the number of oracle calls from ( [ repeatupperboundonoraclecallsinappendix ] ) is then @xmath520 which is again less than @xmath514 .",
    "so far we have proved that the algorithm is fault - tolerant with runtime at most @xmath514 .",
    "due to @xmath521 , ( [ stepsinfirstfaulttolerantalgo ] ) is an upper bound on the runtime .    for the proof of the prefactor",
    "@xmath299 mentioned below theorem [ thmunknownpwithoutexcluding ] , the case 3 in the proof above can be neglected , and we set @xmath522 , and alter the lower bound ( [ eq : sumfailadvanced ] ) a bit , such that constants @xmath523 , @xmath524 , @xmath525 etc .  can be found to yield the lower guaranteed runtime .",
    "by the following lemma , we convert zalka s implicit bound , eq .  ( [ zalkaimplicit ] ) , into an explicit one ( see after the proof below ) :      the left hand side is a concave function of @xmath530 ^ 2 $ ] , smooth in the interior , and hence its graph stays under its tangent plane drawn at any point @xmath531 for @xmath532 and @xmath533 .",
    "the partial derivatives of @xmath534 at @xmath535 are @xmath536 writing @xmath537 for @xmath528 , we have @xmath538 now taking the limit @xmath539 yields ( [ lemmaxyineqeqn ] ) .",
    "we apply this lemma to zalka s bound @xcite ( eq .",
    "( [ zalkaimplicit ] ) above ) with @xmath540 and @xmath541 : @xmath542   \\\\    & \\ge~2n\\left[1-\\left(1+\\frac{1}{2}(\\alpha-1 ) p_s+\\frac{1}{2}\\left(\\frac{1}{\\alpha}-1\\right)\\frac{1}{n}\\right)\\right ]   \\\\    & = ~(1-\\alpha)np_s-\\left(\\frac{1}{\\alpha}-1\\right)~. \\end{split}\\ ] ] one can easily see that the sharpest bound on @xmath99 is obtained for @xmath543 , yielding @xmath544 .",
    "the following lemma shows that algorithm [ algounknownpexcluding ] in section [ sec : withmemory ] is optimal within the class of algorithms considered in theorem [ thmlowerboundwithmemory ] , up to a constant factor in the runtime :        now let @xmath550 for @xmath551 . then @xmath552 and @xmath553 , so @xmath554 is concave , and the tangent at @xmath555 is @xmath556 .",
    "this gives @xmath557 , which implies @xmath558 concluding the left inequality .",
    "for the right inequality , if @xmath559 , then @xmath560",
    "lastly , if @xmath561 then in particular @xmath562 . thus , finally , @xmath563    99 m.a .",
    "nielsen , i.l .",
    "chuang , _ quantum computation and quantum information , _ cambridge university press , cambridge ( 2000 ) .",
    "p.  shor , _ scheme for reducing decoherence in quantum memory , _ phys .",
    "rev .  a * 52 , * 2493 ( 1995 ) .",
    "a.m.  steane , _ error correcting codes in quantum theory , _ phys .",
    "* 77 , * 793 ( 1996 ) .",
    "p.  shor , _ fault - tolerant quantum computation , _ proc .  of the 37th annual symposium on fundamentals of computer science , ieee press , los alamitos , ca ( 1996 ) .",
    "e.  knill , r.  laflamme , w.h .",
    "zurek , _ resilient quantum computation :  error models and thresholds , _ proc .",
    "r.  soc .",
    "a * 454 , * 365 ( 1998 ) .",
    "j.  preskill , _ reliable quantum computers , _ proc .",
    "r.  soc .",
    "a * 454 , * 385 ( 1998 ) .",
    "d.  gottesman , _ fault - tolerant quantum computation with constant overhead , _",
    "[ quant - ph ] ( 2013 ) .",
    "zanardi , _ dissipative dynamics in a quantum register , _ phys .",
    "a * 56 , * 4445 ( 1997 ) .",
    "lidar , i.l .",
    "chuang , k.b .",
    "whaley , _ decoherence - free subspaces for quantum computation , _ phys .  rev .",
    "* 81 , * 2594 ( 1998 ) .",
    "grover , _ quantum mechanics helps in searching for a needle in a haystack , _ phys .",
    "* 79 , * 325 ( 1997 ) .",
    "bennett , e.  bernstein , g.  brassard , u.  vazirani , _ strengths and weaknesses of quantum computing , _ siam j.  comput .",
    "* 26 , * 1510 ( 1997 ) .",
    "m.  boyer , g.  brassard , p.  hoyer , a.  tapp , _ tight bounds on quantum searching , _ fortsch .",
    "* 46 , * 493 ( 1998 ) . c.  zalka , _",
    "grover s quantum searching algorithm is optimal , _ phys .",
    "rev .  a * 60 , * 2746 ( 1999 ) .",
    "b.  pablo - norman , m.  ruiz - altaba , _ noise in grover s quantum search algorithm , _ phys .",
    "rev .  a * 61 , * 012301 ( 1999 ) .",
    "long , y.s .",
    "li , w.l .",
    "zhang , c.c .",
    "tu , _ dominant gate imperfection in grover s quantum search algorithm , _ phys .",
    "rev .  a * 61 , * 042305 ( 2000 ) .",
    "h.  azuma , _ decoherence in grover s quantum algorithm :  perturbative approach , _ phys .",
    "a * 65 , * 042311 ( 2002 ) .",
    "d.  shapira , s.  mozes , o.  biham , _ effect of unitary noise on grover s quantum search algorithm , _ phys .",
    "rev .  a * 67 , * 042301 ( 2003 ) .",
    "j.  hsieh , c.  li , d.  chuu , _ an improved phase error tolerance in quantum search algorithm , _ chin .",
    "j.  phys .",
    "* 42 , * 585 ( 2004 ) .",
    "n.  shenvi , k.r .",
    "brown , k.b .",
    "whaley , _ effects of a random noisy oracle on search algorithm complexity , _ phys .",
    "a * 68 , * 052313 ( 2003 ) .",
    "o.  regev , l.  schiff , _ impossibility of a quantum speed - up with a faulty oracle , _ proc .  of the 35th international colloquium on automata , languages and programming * 1 , * 773 ( 2008 ) .",
    "k.  temme , _ a note on the runtime of a faulty hamiltonian oracle ,",
    "_ arxiv:1404.1977 [ quant - ph ] ( 2014 ) .",
    "a.  montanaro , _ quantum search with advice , _ proc .  of the 5th conference on theory of quantum computation ,",
    "communication and cryptography , pg .",
    "77 , springer , berlin ( 2010 ) .",
    "m.  ben - or , d.  gottesman , a.  hassidim , _ quantum refrigerator , _",
    "arxiv:1301.1995 [ quant - ph ] ( 2013 ) ."
  ],
  "abstract_text": [
    "<S> we investigate the problem of quantum searching on a noisy quantum computer . taking a _ fault - ignorant _ approach , </S>",
    "<S> we analyze quantum algorithms that solve the task for various different noise strengths , which are possibly unknown beforehand . </S>",
    "<S> we prove lower bounds on the runtime of such algorithms and thereby find that the quadratic speedup is necessarily lost ( in our noise models ) . </S>",
    "<S> however , for low but constant noise levels the algorithms we provide ( based on grover s algorithm ) still outperform the best noiseless classical search algorithm . </S>"
  ]
}