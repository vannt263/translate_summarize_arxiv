{
  "article_text": [
    "in data access with ontologies , the premier aim is to answer queries over incomplete and heterogeneous data while taking advantage of the domain knowledge provided by an ontology @xcite . since traditional database systems are often unaware of ontologies , it is common to rewrite the emerging ontology - mediated queries ( omqs ) into more standard database query languages .",
    "in fact , the dl - lite family of description logics ( dls ) was designed specifically so that any omq @xmath1 where is a dl - lite ontology , @xmath2 a data signature , and @xmath3 a conjunctive query , can be rewritten into an equivalent first - order ( fo ) query that can then be executed using a standard sql database system @xcite . in more expressive ontology languages",
    ", it is not guaranteed that for every omq there is an equivalent fo query .",
    "for example , this is the case for dls of the @xmath4and horn - families @xcite , and for dls of the expressive family . in many members of the @xmath4and horn - families , however",
    ", rewritability into monadic datalog ( mdlog ) is guaranteed , thus enabling the use of datalog engines for query answering . in and above , not even datalog - rewritability is generally ensured .",
    "since ontologies emerging from practical applications tend to be structurally simple , though , there is reason to hope that ( fo- , mdlog- , and datalog- ) rewritings do exist in many practically relevant cases even when the ontology is formulated in an expressive language .",
    "this has in fact been experimentally confirmed for fo - rewritability in the @xmath4family of dls @xcite , and it has led to the implementation of rewriting tools that , although incomplete , are able to compute rewritings in many practical cases @xcite .",
    "fundamental problems that emerge from this situation are to understand the exact limits of rewritability and to provide ( complete ) algorithms that decide the rewritability of a given omq and that compute a rewriting when it exists .",
    "these problems have been adressed in @xcite for dls from the @xmath4and horn - families .",
    "for dls from the family , first results were obtained in @xcite where a connection between omqs and constraint satisfaction problems ( csps ) was established that was then used to transfer decidability results from csps to omqs . in fact , rewritability is an important topic in csp ( where it would be called definability ) as it constitutes a central tool for analyzing the complexity of csps @xcite .",
    "in particular , rewritability of ( the complement of ) csps into fo and into datalog is np - complete @xcite , and rewritability into mdlog is np - hard and in @xcite . in @xcite ,",
    "these results were used to show that fo- and datalog - rewritability of omqs @xmath5 where is formulated in or a moderate extension thereof and @xmath3 is an atomic query ( aq ) of the form @xmath6 is decidable and , in fact , nexptime - complete . for mdlog - rewritability",
    ", one can show nexptime - hardness and containment in 2exptime .",
    "the aim of this paper is to study the above questions for omqs where the ontology is formulated in an expressive dl from the family and where the actual query is a conjunctive query ( cq ) or a union of conjunctive queries ( ucq ) . as observed in @xcite ,",
    "transitioning in omqs from aqs to ucqs corresponds to the transition from csp to its logical generalization mmsnp introduced by feder and vardi @xcite and studied , for example , in @xcite .",
    "more precisely , while the omq language @xmath7 that consists of all omqs @xmath5 where is formulated in and @xmath3 is an aq has the same expressive power as the complement of csp ( with multiple templates and a single constant ) , the omq language @xmath8 has the same expressive power as the complement of mmsnp ( with free variables)which in turn is a notational variant of monadic disjunctive datalog ( mddlog )",
    ". it should be noted , however , that while all these formalisms are equivalent in expressive power , they differ significantly in succinctness @xcite ; in particular , the best known translation of omqs into mmsnp / mddlog involves a double exponential blowup .",
    "in contrast to the csp case , fo- , mdlog- , and datalog - rewritability of ( the complement of ) mmsnp sentences was not known to be decidable . in this paper , we establish decidability of fo- and mdlog - rewritability in @xmath8 and related omq languages , in mddlog , and the complement of mmsnp .",
    "we show that fo - rewritability is 2nexptime - complete in all three cases , and that mdlog - rewritability is in 3exptime ; a 2nexptime lower bound was established in @xcite .",
    "let us discuss our results on fo - rewritability from three different perspectives . from the omq perspective , the transition from aqs to ucqs results in an increase of complexity from nexptime to 2nexptime . from the monadic datalog perspective ,",
    "adding disjunction ( transitioning from monadic datalog to mddlog ) results in a moderate increase of complexity from 2exptime @xcite to 2nexptime . and from the csp perspective , the transition from csps to mmsnp results in a rather dramatic complexity jump from np to 2nexptime .    for datalog - rewritability",
    ", we obtain only partial results .",
    "in particular , we show that datalog - rewritability is decidable and 2nexptime - complete for mddlog programs that , in a certain technical sense made precise in the paper , _ have equality_. for the general case , we only obtain a potentially incomplete procedure .",
    "it is well possible that the procedure is in fact complete , but proving this remains an open issue for now .",
    "these results also apply to analogously defined classes of mmsnp sentences and omqs that have equality .",
    "while we mainly focus on deciding whether a rewriting exists rather than actually computing it , we also analyze the shape that rewritings can take .",
    "since the shape turns out to be rather restricted , this is important information for algorithms ( complete or incomplete ) that seek to compute rewritings . in the csp",
    "/ mmsnp world , this corresponds to analyzing obstruction sets for mmsnp , in the style of csp obstructions @xcite and not to be confused with colored forbidden patterns sometimes used to characterize mmsnp @xcite .",
    "more precisely , we show that an omq @xmath5 is fo - rewritable if and only if it is rewritable into a ucq in which each cq has treewidth @xmath9 , @xmath10 the size of @xmath3 ; has a tree decomposition in which every bag has at most @xmath11 elements and in which neighboring bag overlap in at most one element . ]",
    "equivalently , the complement of an mmsnp sentence @xmath12 is fo - definable if and only if it admits a finite set of finite obstructions of treewidth @xmath13 where @xmath14 is the diameter of @xmath12 ( the maximum size of a negated conjunction in its body , in feder and vardi s terminology ) .",
    "we also show that an omq @xmath5 is mdlog - rewritable if and only if it is rewritable into an mdlog program of diameter @xmath9 ; equivalently , the complement of an mmsnp sentence @xmath12 is mdlog - definable if and only if it admits a ( potentially infinite ) set of finite obstructions of treewidth @xmath13 where @xmath14 is the diameter of @xmath12 . for the datalog case",
    ", we give a new and direct construction of canonical datalog - rewritings .",
    "it has been observed in @xcite that for every csp and all @xmath15 , it is possible to construct a canonical datalog program @xmath16 of width @xmath17 and diameter @xmath14 in the sense that if any such program is a rewriting of the csp , then so is @xmath16 ; moreover , even when there is no @xmath18-datalog rewriting , then @xmath16 is the best possible approximation of such a rewriting .",
    "the existence of canonical datalog - rewritings for ( the complement of ) mmsnp sentences was already known from @xcite . however , the construction given there is quite intricate , proceeding via an infinite template that is obtained by applying an intricate construction due to cherlin , shelah , and shi @xcite , which makes them rather hard to analyze .",
    "in contrast , our construction is elementary and essentially parallels the csp case ; it also applies to mmsnp formulas with free variables , where the canonical program takes a rather special form that involves _ parameters _ , similar in spirit to the parameters to least fixed - point operators in fo(lfp ) @xcite .",
    "our main technical tool is the translation of an mmsnp sentence into a csp exhibited by feder and vardi @xcite ; actually , the target of the translation is a generalized csp , meaning that there are multiple templates .",
    "the translation is not equivalence preserving and involves a double exponential blowup , but was designed so as to preserve complexity up to polynomial time reductions . here , we are not so much interested in the complexity aspect , but rather in the semantic relationship between the original mmsnp sentence and the constructed csp .",
    "it turns out that the translation does not quite preserve rewritability .",
    "in particular , when the original mmsnp sentence has a rewriting , then the natural way of constructing from it a rewriting for the csp is sound only on instances of high girth .",
    "however , fo- and mdlog - rewritings that are sound on high girth ( and unconditionally complete ) can be converted into rewritings that are unconditionally sound ( and complete ) .",
    "the same is true for datalog - rewritings when the mmsnp sentence has equality , but it remains open whether it is true in the general case .",
    "the structure of this paper is as follows . in section  [ sec : prelim ] , we introduce the essentials of disjunctive datalog and its relevant fragments as well as csp and mmsnp ; in fact , we shall always work with boolean mddlog rather than with the complement of mmsnp . in section  [ sec : shape ] , we summarize the main properties of feder and vardi s translation of mmsnp into csp .",
    "we use this in section  [ sec : dec ] to show that fo- and mdlog - rewritability of boolean mddlog programs and of the complement of mmsnp sentences is decidable , also establishing the announced complexity results . in section  [",
    "sect : shapeobstrexplosion ] , we analyze the shape of fo- and mdlog - rewritings and of obstructions for mmsnp sentences .",
    "we also establish an mmsnp analogue of an essential combinatorial lemma for csps that allows to replace a structure by a structure of high girth while preserving certain homomorphisms ( in the csp case ) respectively the truth of certain mmsnp sentences ( in the mmsnp case ) . in section  [",
    "sect : dlog - rewr ] , we study datalog - rewritability of mddlog programs that have equality and construct canonical datalog programs . section  [ sec : answer ] is concerned with lifting our results from the boolean case to the general case , concerning the complexity of deciding rewritability , the shape of rewritings , and the construction of canonical datalog programs . in this section ,",
    "datalog programs with parameters play a central role . in section  [",
    "sect : omqs ] , we introduce omqs and further lift our results to this setting . we conclude in section  [ sec : concl ] .",
    "a _ schema _ is a finite collection @xmath19 of relation symbols with associated arity",
    "-fact _ is an expression of the form @xmath20 where @xmath21 is an @xmath22-ary relation symbol , and @xmath23 are elements of some fixed , countably infinite set @xmath24 of _",
    "constants_. for an @xmath22-ary relation symbol @xmath25 , @xmath26 is @xmath27 .",
    "an _ -instance _",
    "@xmath28 is a finite set of -facts .",
    "the _ active domain _",
    "@xmath29 of  @xmath28 is the set of all constants that occur in a fact in  @xmath28 .",
    "for an instance @xmath28 and a schema , we write @xmath30 to denote the restriction of @xmath28 to the relations in .    a _ tree decomposition _ of an instance @xmath28 is a pair @xmath31 , where @xmath32 is an undirected tree and @xmath33 is a family of subsets of @xmath29 such that the following conditions are satisfied :    1 .   for all @xmath34 , @xmath35 is nonempty and connected in  @xmath36 ; 2 .   for every fact @xmath37 in @xmath28 ,",
    "there is a @xmath38 such that @xmath39 .    unlike in the traditional setup @xcite , we are interested in two parameters of tree decompositions instead of only one .",
    "we call @xmath31 an _ @xmath18-tree decomposition _ if for all @xmath40 , @xmath41 and @xmath42 .",
    "an instance @xmath28 _ has treewidth _ @xmath18 if it admits an @xmath18-tree decomposition .",
    "we now define the notion of girth .",
    "a finite structure @xmath28 has a _ cycle _ of length  @xmath22 if it contains distinct facts @xmath43 , @xmath44 , and there are positions @xmath45 , @xmath46 such that :    * @xmath47 for @xmath48 ; * @xmath49 for @xmath46 , where @xmath50 denotes addition modulo @xmath22 .",
    "the _ girth _ of @xmath28 is the length of the shortest cycle in it and @xmath51 if @xmath28 has no cycle ( in which case we say that @xmath28 is a _ tree _ ) .    a _ constraint satisfaction problem ( csp ) _ is defined by an instance @xmath36 over a schema @xmath52 , called _",
    "template_. the problem associated with @xmath36 , denoted @xmath53 , is to decide whether an input instance @xmath28 over @xmath52 admits a homomorphism to  @xmath36 , denoted @xmath54 .",
    "we use cocsp@xmath55 to denote the complement problem , that is , deciding whether @xmath56 .",
    "generalized csp _ is defined by a set of templates @xmath25 over the same schema @xmath52 and asks for a homomorphism from the input @xmath28 to at least one templates @xmath57 , denoted @xmath58 .    an _ mmsnp sentence _ @xmath59 over schema @xmath52 has the form @xmath60 with @xmath61 monadic second - order variables , @xmath62 first - order variables , and @xmath63 a conjunction of quantifier - free formulas of the form @xmath64 where each @xmath65 takes the form @xmath66 or @xmath67 with @xmath68 , and each @xmath69 takes the form @xmath66 .",
    "the _ diameter _ of @xmath59 is the maximum number of variables in some implication in @xmath63 .",
    "this presentation is syntactically different from , but semantically equivalent to the original definition from @xcite , which does not use the implication symbol and instead restricts the allowed polarities of atoms .",
    "both forms can be interconverted in polynomial time , see @xcite .",
    "more information on mmsnp can be found , e.g. , in @xcite .",
    "a _ conjunctive query ( cq ) _ takes the form @xmath70 where @xmath63 is a conjunction of relational atoms and , denote tuples of variables ; the equality relation may be used .",
    "whenever convenient , we will confuse a cq @xmath70 with the set of atoms in @xmath12 .",
    "a _ union of conjunctive queries ( ucq ) _ is a disjunction of cqs with the same free variables .",
    "a _ disjunctive datalog rule _ @xmath71 has the form @xmath72 where @xmath73 and @xmath74 .",
    "we refer to @xmath75 as the _ head _ of @xmath71 , and to @xmath76 as the _ body_. every variable that occurs in the head of a rule @xmath71 is required to also occur in the body of @xmath71 .",
    "a _ disjunctive datalog ( ddlog ) program _",
    "@xmath16 is a finite set of disjunctive datalog rules with a selected _ goal relation _ that does not occur in rule bodies and appears only in non - disjunctive _ goal rules _ @xmath77 .",
    "the _ arity of @xmath16 _ is the arity of the relation ; we say that @xmath16 is _ boolean _ if it has arity zero .",
    "relation symbols that occur in the head of at least one rule of @xmath16 are _ intensional ( idb ) relations _ , and all remaining relation symbols in @xmath16 are _ extensional ( edb ) relations_. note that , by definition , is an idb relation .",
    "we will sometimes use body atoms of the form @xmath78 that are vacuously true for all elements of the active domain .",
    "this is just syntactic sugar since any rule with body atom @xmath78 can equivalently be replaced by a set of rules obtained by replacing @xmath78 in all possible ways with an atom @xmath79 where @xmath80 is an edb relation and where @xmath81 for some @xmath82 and all other @xmath83 are fresh variables .",
    "a ddlog program is called _ monadic _ or an _ mddlog program _ if all its idb relations with the possivle exception of have arity at most one .",
    "the _ size _ of a ddlog program @xmath16 is the number of symbols needed to write it ( where relation symbols and variables names count one ) , its _ width _ is the maximum arity of non- idb relations used in it , and its _ diameter _ is the maximum number of variables that occur in a rule in @xmath16 .",
    "a _ datalog rule _ is a disjunctive datalog rule in which the rule head contains exactly one disjunct .",
    "datalog ( dlog ) programs and monadic datalog ( mdlog ) programs are then defined in the expected way .",
    "we call a datalog program an",
    "_ @xmath18-datalog program _ if its width is @xmath17 and its diameter is @xmath14 .",
    "for @xmath16 an @xmath22-ary mddlog program over schema @xmath52 , an @xmath52-instance @xmath28 , and @xmath84 , we write @xmath85 if @xmath86 where the variables in all rules of @xmath16 are universally quantified and thus @xmath16 is a set of first - order ( fo ) sentences .",
    "a query @xmath3 over @xmath52 of arity @xmath22 is    * _ sound for _",
    "@xmath16 if for all @xmath52-instances @xmath28 and @xmath87 , @xmath88 implies @xmath89 ; * _ complete for _ @xmath16 if for all @xmath52-instances @xmath28 and @xmath87 , @xmath90 implies @xmath91 ; * a _ rewriting of _ @xmath16 if it is sound for @xmath16 and complete for @xmath16 .    to additionally specify the syntactic shape of @xmath3",
    ", we speak of a ucq - rewriting , an mdlog - rewriting , and so on",
    "fo - rewriting _ takes the form of an fo - query that uses only relations from the relevant edb schema and possibly equality , but neither constants nor function symbols .",
    "we say that @xmath16 is _ fo - rewritable _ if there is an fo - rewriting of @xmath16 , and likewise for _ ucq - rewritability _ and _ mdlog - rewritability_.    it was shown in @xcite that the complement of an mmsnp sentence can be translated into an equivalent boolean mddlog program in polynomial time and vice versa ; moreover , the transformations preserve diameter and all other parameters relevant for this paper . from now on",
    ", we will thus not explicitly distinguish between boolean mddlog and ( the complement of ) mmsnp .",
    "feder and vardi show how to translate an mmsnp sentence into a generalized csp that has the same complexity up to polynomial time reductions @xcite .",
    "the resulting csp has a different schema than the original mmsnp sentence and is thus not equivalent to it .",
    "we are going to make use of this translation to reduce rewritability problems for mddlog to the corresponding problems for csps .",
    "consequently , our main interest is in the precise semantic relationship between the mmsnp sentence and the constructed csp , rather than in their complexity . in this section ,",
    "we sum up the properties of the results obtained in @xcite that are relevant for us .",
    "these properties are all we need in later sections , that is , we do not need to go further into the details of the translation .",
    "for the reader s convenience and information , we still give full details in appendix  [ app : translate ] ; these are based on the presentation given in @xcite , which is more detailed than the original presentation in @xcite .",
    "let @xmath52 be a schema .",
    "a schema @xmath92 is a _ @xmath14-aggregation schema _ for @xmath52 if its relations have the form @xmath93 where @xmath94 is a cq over @xmath52 and the arity of @xmath93 is identical to the number of free variables of @xmath94 , which is at most @xmath14 .",
    "the generalized csp to be constructed later makes use of a schema of this form .",
    "what is important at this point is that there are natural translations of instances between the two schemas . to make this precise ,",
    "let @xmath28 be an @xmath52-instance .",
    "the _ corresponding @xmath92-instance _ @xmath95 consists of all facts @xmath96 such that @xmath97 .",
    "conversely , let @xmath95 be an @xmath92-instance .",
    "the _ corresponding @xmath52-instance _ @xmath28 consists of all facts @xmath98 such that @xmath99 and @xmath98 is a conjunct of @xmath100 .",
    "cc|cc|cc    @xmath92-instance @xmath95 & & @xmath52-instance @xmath28 & & @xmath52-instance @xmath101 +    ( la1 ) at ( 0 , 0 ) @xmath102 ; ( ma1 ) at ( -0.5 , 1 ) @xmath103 ; ( ma2 ) at ( 0.5 , 1 ) @xmath104 ; ( ha3 ) at ( 1 , 2 ) @xmath105 ; ( ha2 ) at ( 0 , 2 ) @xmath106 ; ( ha1 ) at ( -1 , 2 ) @xmath107 ;    ( hl1 ) at ( -0.5 , 1.5 ) @xmath108 ; ( hl2 ) at ( 0.5 , 1.5 ) @xmath108 ; ( ml1 ) at ( 0 , 0.5 ) @xmath108 ;    ( la1 ) to ( ma2 ) ; ( ma2 ) to ( ma1 ) ; ( ma1 ) to ( la1 ) ; ( ma1 ) to ( ha2 ) ; ( ha2 ) to ( ha1 ) ; ( ha1 ) to ( ma1 ) ; ( ma2 ) to ( ha3 ) ; ( ha3 ) to ( ha2 ) ; ( ha2 ) to ( ma2 ) ;    & &    ( la1 ) at ( 0 , 0 ) @xmath102 ; ( ma1 ) at ( -0.5 , 1 ) @xmath103 ; ( ma2 ) at ( 0.5 , 1 ) @xmath104 ; ( ha3 ) at ( 1 , 2 ) @xmath105 ; ( ha2 ) at ( 0 , 2 ) @xmath106 ; ( ha1 ) at ( -1 , 2 ) @xmath107 ;    ( hl1 ) at ( -0.5 , 2.15 ) @xmath109 ; ( hl2 ) at ( 0.5 , 2.15 ) @xmath109 ; ( ml1 ) at ( -0.9 , 1.5 ) @xmath109 ; ( ml2 ) at ( -0.4 , 1.5 ) @xmath109 ; ( ml3 ) at ( 0.15 , 1.5 ) @xmath109 ; ( ml4 ) at ( 0.7 , 1.65 ) @xmath109 ; ( ll1 ) at ( -0.4 , 0.5 ) @xmath109 ; ( ll2 ) at ( 0.4 , 0.5 ) @xmath109 ; ( ll2 ) at ( 0 , 1.15 ) @xmath109 ;    ( la1 ) to ( ma2 ) ; ( ma2 ) to ( ma1 ) ; ( ma1 ) to ( la1 ) ; ( ma1 ) to ( ha2 ) ; ( ha2 ) to ( ha1 ) ; ( ha1 ) to ( ma1 ) ; ( ma2 ) to ( ha3 ) ; ( ha3 ) to ( ha2 ) ; ( ha2 ) to ( ma2 ) ;    & &    ( la1 ) at ( 0 , 0 ) @xmath102 ; ( ma1 ) at ( -0.5 , 1 ) @xmath103 ; ( ma2 ) at ( 0.5 , 1 ) @xmath104 ; ( ha3 ) at ( 1 , 2 ) @xmath105 ; ( ha2 ) at ( 0 , 2 ) @xmath106 ; ( ha1 ) at ( -1 , 2 ) @xmath107 ;    ( hl1 ) at ( -0.5 , 1.5 ) @xmath108 ; ( hl2 ) at ( 0.5 , 1.5 ) @xmath108 ; ( ml1 ) at ( 0 , 0.5 ) @xmath108 ; ( bla ) at ( 0 , 1.3 ) @xmath108 ;    ( la1 ) to ( ma2 ) ; ( ma2 ) to ( ma1 ) ; ( ma1 ) to ( la1 ) ; ( ma1 ) to ( ha2 ) ; ( ha2 ) to ( ha1 ) ; ( ha1 ) to ( ma1 ) ; ( ma2 ) to ( ha3 ) ; ( ha3 ) to ( ha2 ) ; ( ha2 ) to ( ma2 ) ;    [ ex : veryfirst ] assume that @xmath52 consists of the binary relation @xmath109 .",
    "let @xmath110 where @xmath111 and let @xmath92 consist of @xmath93 .",
    "take the @xmath92-instance @xmath95 defined by@xmath112 the corresponding @xmath52-instance @xmath28 is @xmath113 note that , when we take the @xmath92-instance @xmath101 corresponding to @xmath28 , we do _ not _ obtain @xmath95 , but rather a strict superset that contains additional facts such as @xmath114 .",
    "the instances @xmath28 , @xmath95 , and ( a subset of ) @xmath101 are depicted in figure [ fig : transl ] .",
    "the translation in @xcite consists of two steps .",
    "we describe them here using boolean mddlog instead of ( the complement of ) mmsnp .",
    "the first step is to transform the given boolean mddlog program @xmath16 into a boolean mddlog program @xmath115 over a suitable aggregation schema @xmath92 such that @xmath115 is of a restricted syntactic form . in the second step ,",
    "one transforms @xmath115 into a generalized csp whose complement is equivalent to  @xmath115 .",
    "we start with summing up the important aspects of the first step .",
    "a boolean mddlog program @xmath115 is _ simple _ if it satisfies the following conditions :    1 .",
    "every rule in @xmath115 contains at most one edb atom and this atom contains all variables of the rule body , each variable exactly once ; 2 .",
    "rules without an edb atom contain at most a single variable .",
    "now , the first step achieves the following .",
    "[ th : mmsnptosimple ] given a boolean mddlog program @xmath16 over edb schema @xmath52 of diameter @xmath14 , one can construct a simple boolean mddlog program @xmath115 over a @xmath14-aggregation schema @xmath92 for @xmath52 such that    1 .   if @xmath28 is an @xmath52-instance and @xmath95 the corresponding @xmath92-instance , then @xmath116 iff @xmath117 ; 2 .   if @xmath95 is an @xmath92-instance and @xmath28 the corresponding @xmath52-instance , then 1 .",
    "@xmath117 implies @xmath116 ; 2 .",
    "@xmath116 implies @xmath117 if the girth of @xmath95 exceeds @xmath14 .",
    "if @xmath16 is of size @xmath22 , then the size of @xmath118 and the cardinality of @xmath92 are bounded by @xmath119 , @xmath120 a polynomial , and the arity of relations in @xmath92 is bounded by @xmath14 .",
    "the construction takes time polynomial in the size of  @xmath115 .",
    "the translation underlying theorem  [ th : mmsnptosimple ] consists of three steps itself : first saturate @xmath16 by adding all rules that can be obtained from a rule in @xmath16 by identifying variables ; then rewrite @xmath16 in an equivalence - preserving way so that all rule bodies are biconnected , introducing fresh unary and nullary idbs as needed . and finally replace the conjunction @xmath94 of all edb atoms in each rule body with a single edb atom @xmath121 , additionally taking care of interactions between the new edb relations that arise e.g.  when we have two relations @xmath93 and @xmath122 such that @xmath94 is contained in @xmath123 ( in the sense of query containment ) .",
    "the following theorem summarizes the second step of the translation of boolean mddlog into generalized cocsp .",
    "[ th : simpletocsp ] let @xmath16 be a simple boolean mddlog program over edb schema @xmath52 and with idb schema @xmath124 , @xmath125 the maximum arity of relations in @xmath52 . then there exists a set of templates @xmath126 over @xmath52 such that    1 .",
    "@xmath16 is equivalent to cocsp@xmath127 ; 2 .",
    "@xmath128 and @xmath129 for each @xmath130 ;    the construction takes time polynomial in @xmath131 .",
    "we again sketch the idea underlying the proof of the theorem .",
    "the desired set of templates @xmath126 contains one template for every 0-type , that is , for every set of nullary idb relations in @xmath16 that does not contain @xmath132 and that satisfies all rules in @xmath16 which use only nullary idbs .",
    "each templates contains one constant @xmath133 for every 1-type @xmath134 , that is , for every set @xmath134 of unary idbs that agrees on nullary idbs with the 0-type for which the template was constructed and that satisfy all rules in @xmath16 which use only idbs that are at most unary .",
    "one then interprets all edb relations in a maximal way so that all rules in @xmath16 are satisfied .",
    "the fact that @xmath16 is simple implies that there are no choices , that is , there is only one maximal interpretation of each edb relation and the interpretations of different such relations do not interact .",
    "details are given in the appendix .",
    "we exploit the translations described in the previous section and the known results that fo - rewritability of csps and mdlog - rewritability of cocsps are decidable to obtain analogous results for boolean mddlog , and thus also for mmsnp . in the case of fo",
    ", we obtain tight 2 nexptime complexity bounds . for mdlog ,",
    "the exact complexity remains open ( as in the csp case ) , between 2nexptime and 3exptime .",
    "we start with observing that fo - rewritability and mdlog - rewritability are more closely related than one might think at first glance .",
    "in fact , every mdlog - rewriting can be viewed as an infinitary ucq - rewriting and , by rossman s homomorphism preservation theorem @xcite , fo - rewritability of a boolean mddlog program coincides with ( finitary ) ucq - rewritability .",
    "the latter is true also in the non - boolean case .",
    "[ prop : ross ] let @xmath16 be an mddlog program",
    ". then @xmath16 is fo - rewritable iff @xmath16 is ucq - rewritable .",
    "it is well known and easy to show that truth of disjunctive datalog programs is preserved under homomorphisms .",
    "thus , the proposition immediately follows from rossman s theorem in the boolean case . for the non - boolean case",
    ", we observe that rossman establishes his result also in the presence of constants .",
    "let @xmath16 be an mddlog program and @xmath135 a rewriting of @xmath16 .",
    "we can apply rossman s result to @xmath136 , where is a vector of constants of the same length as , obtaining a ucq @xmath100 equivalent to @xmath136 .",
    "let @xmath94 be obtained from @xmath100 be replacing the constants in with the variables from @xmath137 .",
    "it can be verified that @xmath94 is a rewriting of @xmath16 .    for utilizing the translation of boolean mddlog programs to generalized csps in the intended way ,",
    "the interesting aspect is to deal with the translation of a boolean mddlog program @xmath16 into a simple program @xmath115 stated in theorem  [ th : mmsnptosimple ] , since it is not equivalence preserving .",
    "the following proposition relates rewritings of @xmath16 to rewritings of @xmath115 .",
    "[ prop : rewrcorresp ] let @xmath16 be a boolean mddlog program of diameter @xmath14 , @xmath115 as in theorem  [ th : mmsnptosimple ] , and @xmath138",
    ". then    1 .   every -rewriting of @xmath115 can effectively be converted into a -rewriting of  @xmath16 ; 2 .",
    "every -rewriting of @xmath16 can effectively be converted into a -rewriting of @xmath115 that is ( i )  sound on instances of girth exceeding @xmath14 and ( ii )  complete .",
    "let @xmath52 and @xmath92 be the edb schema of @xmath16 and of @xmath115 , respectively .",
    "we start with the case @xmath139 .    for point  1 ,",
    "let @xmath140 be a ucq - rewriting of @xmath115 .",
    "let @xmath141 be the ucq obtained from @xmath140 by replacing every atom @xmath142 with @xmath143 $ ] , that is , with the result of replacing the variables in @xmath94 with the variables  @xmath144 ( which may lead to identifications ) .",
    "we show that @xmath141 is as required .",
    "let @xmath28 be an @xmath52-instance and @xmath95 the corresponding @xmath92-instance .",
    "then we have @xmath116 iff @xmath117 ( by point  1 of theorem  [ th : mmsnptosimple ] ) iff @xmath145 ( by choice of @xmath140 ) iff @xmath146 ( by construction of @xmath95 and of @xmath141 ) .",
    "let us expand on the latter .",
    "first assume that @xmath145 .",
    "then there is a cq @xmath3 in @xmath140 and a homomorphism @xmath147 from @xmath3 to @xmath95 . by construction",
    ", @xmath141 contains a cq @xmath148 that is obtained from @xmath3 by replacing every atom @xmath149 with @xmath143 $ ] .",
    "clearly , for every atom @xmath149 , we must have @xmath150 . the construction of @xmath95 yields @xmath151 .",
    "consequently , @xmath147 is also a homomorphism from @xmath148 to @xmath28 .",
    "conversely , assume that there is a cq @xmath148 in @xmath152 and a homomorphism @xmath147 from @xmath148 to @xmath28 . then there is a cq @xmath3 in @xmath140 from which @xmath148 was obtained by the described replacement operation . for every atom @xmath149",
    ", we must have @xmath151 .",
    "we obtain @xmath153 and thus @xmath147 is a homomorphism from @xmath3 to @xmath95 .    for point  2 ,",
    "let @xmath141 be a ucq - rewriting of @xmath16 .",
    "the ucq @xmath140 consists of all cqs that can be obtained as follows :    1 .",
    "choose a cq @xmath94 from @xmath141 , identify variables in @xmath3 to obtain a cq  @xmath154 , and choose a partition @xmath155 of @xmath154 ; 2 .",
    "for each @xmath156 , choose a relation @xmath157 from @xmath92 and a vector @xmath144 of @xmath158 variables ( repeated occurrences allowed ) that are either from @xmath159 or do not occur in @xmath160 such that @xmath161 $ ] ; then replace @xmath162 in @xmath154 with the single atom @xmath163 .    to establish that @xmath140 is",
    "as desired , we show that for every @xmath92-instance @xmath95    1 .",
    "@xmath145 implies @xmath117 if @xmath95 is of girth exceeding @xmath14 ( soundness ) and 2 .",
    "@xmath117 implies @xmath145 ( completeness ) .",
    "let @xmath28 be the @xmath52-instance corresponding to @xmath95 .    for point  ( i ) , we observe that @xmath145 implies @xmath164 ( by construction of @xmath140 and of @xmath95 ) implies @xmath116 ( by choice of @xmath141 ) implies @xmath117 ( by point  2b of theorem  [ th : mmsnptosimple ] and if @xmath95 is of girth exceeding @xmath14 ) .",
    "let us zoom into the first implication .",
    "assume that @xmath145 .",
    "then there is a cq @xmath165 in @xmath140 and a homomorphism @xmath147 from @xmath165 to @xmath95 .",
    "there must be some cq @xmath94 in @xmath141 from which @xmath165 has been constructed in steps  1 and  2 above .",
    "let @xmath155 be as in this construction .",
    "it suffices to show that @xmath147 is a homomorphism from @xmath162 to @xmath28 , for each  @xmath82 .",
    "thus fix a @xmath162 .",
    "then there is a relation @xmath166 and a vector of variables that are either from @xmath159 or do not occur in @xmath160 such that @xmath161 $ ] and @xmath167 .",
    "thus @xmath168 .",
    "by construction of @xmath95 , this yields @xmath169 and thus we are done .    for point",
    "( ii ) , we have that @xmath117 implies @xmath116 ( by point  2a of theorem  [ th : mmsnptosimple ] ) implies @xmath146 ( by choice of @xmath141 ) .",
    "it thus remains to show that @xmath146 implies @xmath145 .",
    "thus assume that there is a cq @xmath94 in @xmath141 and a homomorphism @xmath147 from @xmath94 to @xmath28 .",
    "we use @xmath94 and @xmath147 to guide the choices in step  1 and step  2 of the construction of cqs in @xmath140 to exhibit a cq @xmath170 in @xmath140 such that @xmath171 .",
    "we start with step  1 . as @xmath154",
    ", we use the query obtained from @xmath94 by identifying variables @xmath172 and @xmath173 whenever @xmath174 .",
    "thus , @xmath147 is an injective homomorphism from @xmath154 to @xmath28 .",
    "we next need to choose a partition of @xmath154 .",
    "for every fact @xmath175 , choose a fact @xmath176 that @xmath177 was obtained from during the construction of @xmath28 and denote this fact with @xmath178 .",
    "now let @xmath155 be the partition of @xmath154 obtained by grouping together two atoms @xmath179 and @xmath180 if and only if @xmath181 .",
    "let @xmath182 denote the ( unique ) value of @xmath183 for all the atoms in  @xmath162 .",
    "step  2 deals with each query @xmath162 separately .",
    "we choose the relation @xmath157 from @xmath184 , which clearly is in @xmath92 .",
    "we choose the vector @xmath144 of variables based on the vector of individuals .",
    "let @xmath185 .",
    "then the @xmath17-th variable in @xmath144 is @xmath173 if @xmath186 ( which is well - defined since @xmath147 is injective ) and a fresh variable if there is no such @xmath173 .",
    "this finishes the guiding process and thus gives raise to a query @xmath165 in @xmath140 .",
    "it remains to argue that @xmath147 can be extended to a homomorphism @xmath187 from @xmath188 to @xmath95 .",
    "take a  @xmath162 and consider the corresponding atom @xmath163 in @xmath170 .",
    "then all the facts in @xmath189 were obtained from the fact @xmath190 during the construction of @xmath28 . by construction of @xmath144 from",
    ", we can extend @xmath147 to the fresh variables in so that @xmath191 and thus @xmath168 . doing this for all @xmath192 yields the desired @xmath187 .",
    "now for the cases @xmath193 .",
    "we treat these cases in one since our construction preserves the width of datalog - rewritings .",
    "in fact , this construction is very similar to the case @xmath139 , so we only give a sketch .    for point  1 ,",
    "let @xmath194 be a datalog - rewriting of @xmath115 .",
    "we construct a datalog program @xmath195 of the same width over edb schema @xmath52 by modifying the edb part of each rule body in the same way in which we had modified the ucq - rewriting @xmath140 in the case @xmath139 : replace every edb - atom @xmath142 with @xmath143 $ ] .",
    "we then have @xmath196 iff @xmath117 ( by point  1 of theorem  [ th : mmsnptosimple ] ) iff @xmath197 ( by choice of @xmath194 ) iff @xmath198 .",
    "the latter is by construction of @xmath95 and of @xmath195 . to prove it in more detail",
    ", it suffices to show that for every extension @xmath199 of @xmath28 to the idb relations in @xmath194 with corresponding extension @xmath200 of @xmath95 , and every rule body @xmath3 in @xmath194 which was translated into a rule body @xmath148 in @xmath195 , we have @xmath201 iff @xmath202 .",
    "the arguments needed are as in the case @xmath139 .",
    "the proof of point  2 can be adapted from ucqs to datalog in an analogous way .",
    "let @xmath195 be a datalog - rewriting of @xmath16 .",
    "we construct a datalog program @xmath194 of the same width over edb schema @xmath203 .",
    "the rules in @xmath194 are obtained by taking a rule @xmath204 from @xmath195 , where the @xmath205 are idb and @xmath206 is a cq over schema @xmath52 , converting @xmath206 into a cq @xmath207 over schema @xmath92 in two steps , in the same way in which a cq over @xmath52 was converted into a cq over @xmath92 in the case @xmath139 , and then including in @xmath194 the rule @xmath208 the crucial step in the correctness proof is to show that @xmath209 implies @xmath197 for any @xmath92-instance @xmath95 and corresponding @xmath52-instance @xmath28 .",
    "the arguments are again the same as in the case @xmath210 , the main difference being that we need to consider extensions of @xmath28 and @xmath95 to idb relations from @xmath195 instead of working with @xmath28 and @xmath95 themselves .",
    "point  2 of lemma  [ prop : rewrcorresp ] only yields a rewriting of @xmath115 on @xmath92-instances of high girth .",
    "we next show that , for @xmath211 , the existence of a -rewriting on high girth implies the existence of a -rewriting that works on instances of unrestricted girth .",
    "whether the same is true for @xmath212 remains as an open problem .",
    "we need the following well - known lemma that goes back to erds and was adapted to csps by feder and vardi .",
    "informally , it says that every instance can be ` exploded ' into an instance of high girth that behaves similarly regarding homomorphisms .",
    "[ lem : erdoes ] for every instance @xmath28 and @xmath213 , there is an instance @xmath95 ( over the same schema ) such that @xmath214 , @xmath95 has girth exceeding @xmath215 , and for every instance @xmath36 of size at most @xmath216 , we have @xmath54 iff @xmath217 .",
    "feder and vardi additionally show that @xmath95 can be constructed by a randomized polynomial time reduction that was later derandomized by kun @xcite , but here we do not rely on such computational properties .",
    "every cq @xmath3 can be viewed as an instance @xmath218 by using the variables as constants and the atoms as facts .",
    "it thus makes sense to speak about tree decompositions of cqs and about their treewidth , and it is clear what we mean by saying that a cq is a tree ( that is , has tree width @xmath219 ) .    [",
    "lem : fogirthdontcare ] let @xmath25 be a set of templates over schema @xmath52 ,",
    "@xmath220 , and @xmath221 .",
    "if cocsp(@xmath25 ) is -rewritable on instances of girth exceeding  @xmath215 , then it is -rewritable .",
    "we start with @xmath139 .",
    "let @xmath222 be a ucq that defines cocsp@xmath223 on instances of girth exceeding  @xmath215 , and let @xmath3 be the ucq that consists of all tree cqs which can be obtained from a cq in @xmath222 by identifying variables .",
    "we show that @xmath3 defines cocsp@xmath223 on unrestricted @xmath52-instances .",
    "let @xmath28 be an @xmath52-instance .",
    "first assume that @xmath224 .",
    "by lemma  [ lem : erdoes ] , there is an @xmath52-instance @xmath95 of girth exceeding @xmath215 and also exceeding the number of variables in each cq in @xmath222 and satisfying @xmath225 and @xmath226 .",
    "thus @xmath227 , that is , there is a cq @xmath148 in @xmath222 and a homomorphism @xmath147 from @xmath148 to @xmath95 .",
    "let @xmath228 be obtained from @xmath148 by identifying variables @xmath172 and @xmath173 if @xmath174 .",
    "thus , @xmath147 is an injective homomorphism from @xmath228 to @xmath95 .",
    "since the girth of @xmath95 exceeds the number of variables in @xmath228 , @xmath228 must be a tree .",
    "consequently , @xmath228 is a cq in @xmath3 and we have @xmath229 . from @xmath214 , we obtain @xmath230 .    now assume that @xmath231 . then , there is a tree cq @xmath148 in @xmath232 such that @xmath233 .",
    "when we view @xmath148 as an @xmath52-instance @xmath234 , then clearly @xmath235 and @xmath234 has girth exceeding @xmath14 .",
    "thus , @xmath236 , and from @xmath233 we obtain @xmath237 .",
    "now for the case @xmath238 .",
    "let @xmath239 be an mdlog program that defines cocsp@xmath223 on instances of girth exceeding @xmath215 .",
    "let @xmath240 be the program obtained from @xmath239 by replacing every rule @xmath241 with all rules @xmath242 such that @xmath154 is a tree cq that can be obtained from @xmath94 by identifying variables .",
    "we show that @xmath240 is an mdlog - definition of cocsp@xmath223 on instances of unrestricted girth .",
    "let @xmath28 be an @xmath52-instance .",
    "first assume that @xmath224 .",
    "by lemma  [ lem : erdoes ] , there is an @xmath52-instance @xmath95 whose girth exceeds @xmath215 and also exceeds the diameter of @xmath239 and that satisfies @xmath214 and @xmath243 .",
    "the latter yields @xmath244 .",
    "it remains to show that this implies @xmath245 since with @xmath246 , this yields @xmath247 as required .    to show that @xmath245 follows from @xmath244",
    ", it suffices to show that all idb facts derived by @xmath239 starting from @xmath95 are also derived by @xmath240 .",
    "thus let @xmath200 be an extension of @xmath95 to the idbs in @xmath239 .",
    "it is enough to show that when a single application of a rule from @xmath239 in @xmath200 yields an idb atom @xmath248 , then @xmath240 can derive the same atom .",
    "the former is the case only if @xmath239 contains a rule @xmath249 such that there is a homomorphism @xmath147 from @xmath94 to @xmath200 with @xmath250 .",
    "let @xmath154 be the cq obtained from @xmath94 be identifying variables @xmath172 and @xmath173 when @xmath174 .",
    "since the girth of @xmath95 exceeds the diameter of @xmath239 , @xmath154 is a tree .",
    "thus , @xmath240 contains the rule @xmath251 and the application of this rule in @xmath200 enabled by @xmath147 yields @xmath248 .",
    "we have thus shown @xmath245 and are done .",
    "now assume that @xmath252 .",
    "then there is a proof tree for @xmath132 from @xmath28 and  @xmath239 , see @xcite for details . from that tree",
    ", we can read off an @xmath52-instance @xmath253 such that @xmath254 , @xmath255 , and , since @xmath239 is monadic and only comprises rules with tree - shaped bodies , @xmath253 is tree - shaped .",
    "thus , @xmath253 has girth exceeding @xmath215 and from @xmath256 we get @xmath257 . but",
    "with @xmath254 , this yields @xmath237 as required .",
    "putting together theorem  [ th : mmsnptosimple ] and  [ th : simpletocsp ] , proposition  [ prop : ross ] , and lemmas  [ prop : rewrcorresp ] and  [ lem : fogirthdontcare ] , we obtain the following reductions of rewritability of boolean mddlog programs to csp rewritability .    [ prop : rewrcorrespargh ] every boolean mddlog program @xmath16 can be converted into a set of templates @xmath126 such that    1 .",
    "@xmath16 is -rewritable iff @xmath126 is -rewritable for every @xmath258 ; 2 .",
    "every -rewriting of @xmath16 can be effectively translated into a -rewriting of @xmath126 and vice versa , for every @xmath221 .",
    "@xmath259 and @xmath260 for each @xmath130 , @xmath22 the size of @xmath16 and @xmath120 a polynomial .",
    "the construction takes time polynomial in @xmath131 .",
    "fo - rewritability of csps is np - complete @xcite and it was observed in @xcite that the upper bound lifts to generalized csps .",
    "mdlog - rewritability of cocsps is np - hard and in @xcite .",
    "we show in appendix  [ app : mdlogexp ] that also this upper bound lifts to generalized cocsps . together with proposition  [ prop : rewrcorrespargh ] , this yields the upper bounds in the following theorem .",
    "the lower bounds are from @xcite .",
    "[ th : decidboolean ] for boolean mddlog programs and the complement of mmsnp sentences ,    1 .",
    "fo - rewritability ( equivalently : ucq - rewritability ) is 2-complete ; 2 .",
    "mdlog - rewritability is in 3(and 2-hard ) .",
    "in the fo case , it is possible to extract from the approach in the previous section an algorithm that computes actual rewritings , if they exist . however , that algorithms is hardly practical .",
    "an important first step towards the design of more practical algorithms that compute rewritings ( in an exact or in an approximative way ) is to analyze the shape of rewritings .",
    "in fact , both fo- and mdlog - rewritings of csps are known to be of a rather restricted shape , far from exploiting the full expressive power of the target languages . in this section ,",
    "we establish corresponding results for boolean mddlog .",
    "this topic is closely related to the theory of obstructions , so we also establish connections between the rewritability of mmsnp sentences and natural obstruction sets . finally , we observe an mmsnp counterpart of the fundamental ` explosion ' lemma for csps ( lemma  [ lem : erdoes ] ) .    the following summarizes our results regarding the shape of rewritings .",
    "[ th : rewrshape ] let @xmath16 be a boolean mddlog program of diameter @xmath14",
    ". then    1 .",
    "if @xmath16 is fo - rewritable , then it has a ucq - rewriting in which each cq has treewidth @xmath13 ; 2 .",
    "if @xmath16 is mdlog - rewritable , then it has an mdlog - rewriting of diameter @xmath14 .",
    "we analyze the proof of lemma  [ prop : ross ] and use known results from csp .",
    "in fact , any fo - rewritable csp has a ucq - rewriting that consists of tree cqs , and thus the same holds for simple boolean mddlog programs .",
    "if we convert such a rewriting of @xmath115 into a rewriting of @xmath16 as in the proof of lemma  [ prop : rewrcorresp ] , we obtain a ucq - rewriting in which each cq has treewidth @xmath13 . for point  2 of theorem  [ th : rewrshape ] , one uses the known fact that every mdlog - rewritable csp has an mdlog - rewriting in which every rule body comprises at most one edb atom , see e.g.  proof of theorem  19 in @xcite .    in a sense , the concrete bound @xmath14 in points  1 and  2 of theorem  [ th : rewrshape ] is quite remarkable .",
    "point  2 says , for example , that when eliminating disjunction from a boolean mddlog program , it never pays off to increase the diameter .",
    "we now consider obstructions .",
    "obstruction set _",
    "@xmath261 for a csp template @xmath36 over schema @xmath52 is a set of instances over the same schema such that for any @xmath52-instance @xmath28 , we have @xmath262 iff @xmath254 for some @xmath263 .",
    "the elements of are called _",
    "obstructions_. a lot is known about csp obstructions .",
    "for example , @xmath36 is fo - rewritable if and only if it has a finite obstruction set @xcite if and only if it has a finite obstruction set that consists of finite trees @xcite , and @xmath36 is mdlog - rewritable if and only if it has a ( potentially infinite ) obstruction set that consists of finite trees @xcite . here",
    "we consider obstruction sets for mmsnp , defined in the obvious way : an _ obstruction set _ @xmath261 for an mmsnp sentence @xmath59 over schema @xmath52 is a set of instances over the same schema such that for any @xmath52-instance @xmath28 , we have @xmath264 iff @xmath254 for some @xmath263 .",
    "this should not be confused with colored forbidden patterns used to characterize mmsnp in @xcite .",
    "the following characterizes fo - rewritability of mmsnp sentences in terms of obstruction sets .",
    "[ cor : fo ] for every mmsnp sentence @xmath59 , the following are equivalent :    1 .",
    "@xmath59 is fo - rewritable ; 2 .",
    "@xmath59 has a finite obstruction set ; 3 .",
    "@xmath59 has a finite set of finite obstructions of treewidth @xmath13 .",
    "corollary  [ cor : fo ] follows from point  1 of theorem  [ th : rewrshape ] and the straightfoward observations that an mmsnp sentence @xmath59 is fo - rewritable iff @xmath265 is ( which is equivalent to a boolean mddlog program ) and that every finite obstruction set for @xmath59 gives raise to a ucq - rewriting @xmath266 of @xmath265 and vice versa .",
    "we now turn to mdlog - rewritability .    [",
    "prop : mdlogob ] let @xmath59 be an mmsnp sentence of diameter @xmath14 . then @xmath265 is mdlog - rewritable iff @xmath59 has a set of obstructions ( equivalently : finite obstructions ) that are of treewidth @xmath13 .",
    "the `` only if '' direction is a consequence of point  2 of theorem  [ th : rewrshape ] and the fact that , for any boolean monadic datalog program @xmath267 of diameter @xmath14 over edb schema @xmath52 , a proof tree for @xmath132 from an @xmath52-instance @xmath28 and  @xmath16 gives rise to a finite @xmath52-instance @xmath199 of treewidth @xmath13 with @xmath268 . the desired obstruction set for @xmath265 is then the set of all these @xmath199 .",
    "the `` if '' direction is a consequence of theorem  5 in @xcite .",
    "we remark the results in @xcite almost give proposition  [ prop : mdlogob ] , but do not seem to deliverany concrete bound on the parameter @xmath14 of the treewidth of obstruction sets .",
    "we close with observing an mmsnp counterpart of lemma  [ lem : erdoes ] , first giving a preliminary .",
    "let @xmath28 be an instance over some schema @xmath52 .",
    "a _ @xmath13-decomposition _ of @xmath28 is a pair @xmath269 where @xmath270 is a set of indices and @xmath271 is a partition of @xmath28 such that for all @xmath272 , @xmath273 and @xmath274 .",
    "thus , a @xmath13-decomposition @xmath275 decomposes @xmath28 into parts of size at most @xmath14 and with little overlap .",
    "these parts can be viewed as the facts of an instance @xmath276 over an aggregation schema @xmath92 defined by the relations @xmath277 where @xmath278 is @xmath279 viewed as a cq , that is , @xmath280 where we assume some fixed ( but otherwise irrelevant ) order on the elements of each @xmath281 .",
    "now , we say that @xmath28 has _",
    "@xmath13-decomposition girth _",
    "@xmath215 if @xmath215 is the maximum girth of @xmath276 for any @xmath13-decomposition @xmath282 of @xmath28 . it can be shown that the @xmath13-decomposition girth of @xmath28 is undefined ( which intuitively corresponds to @xmath28 having infinite @xmath13-decomposition girth ) if and only if it has treewidth @xmath13 . here comes the announced mmsnp counterpart of lemma  [ lem : erdoes ] .",
    "[ lem : erdoesdlog ] for every instance @xmath28 and @xmath283 , and every mddlog program @xmath16 of diameter at most @xmath216 , there is an instance @xmath199 ( over the same schema ) such that @xmath268 , @xmath199 has @xmath284-decomposition girth exceeding @xmath215 , and @xmath116 iff @xmath285 .",
    "let @xmath16 be a boolean mddlog program of diameter @xmath286 over edb schema @xmath52 . by theorems  [ th : mmsnptosimple ] and",
    "[ th : simpletocsp ] , there is a @xmath14-aggregation schema @xmath92 and a set of templates @xmath126 over @xmath92 such that    1 .   for any @xmath52-instance @xmath28 with corresponding @xmath92-instance @xmath95 , @xmath116 iff @xmath287",
    "; 2 .   for any @xmath92-instance @xmath95",
    "whose girth exceeds @xmath14 with corresponding @xmath52-instance @xmath28 , @xmath288 iff @xmath116 .",
    "let @xmath28 and @xmath95 be an @xmath52-instance and its corresponding @xmath92-instance .",
    "furthermore , let @xmath200 be the @xmath92-instance obtained from @xmath95 by applying lemma  [ lem : erdoes ] with @xmath289 and @xmath215 as given",
    ". then @xmath290 , @xmath200 has girth exceeding @xmath215 , and @xmath291 iff @xmath292 iff @xmath293 .",
    "let @xmath199 be the @xmath52-instance corresponding to @xmath200 . as @xmath200 has girth exceeding @xmath14 , @xmath285 iff @xmath294 iff @xmath116 .",
    "it remains to show that @xmath199 has @xmath284-decomposition girth exceeding @xmath215 and that @xmath268 .",
    "the former is witnessed by the @xmath13-decomposition @xmath295 of @xmath199 obtained by using as @xmath270 the facts of @xmath200 and as @xmath279 the set of facts obtained from @xmath296 during the construction of @xmath199 . as the last step",
    ", we argue that @xmath268 follows from @xmath297 , and that in fact any homomorphism @xmath147 from @xmath200 to @xmath95 is also a homomorphism from @xmath199 to @xmath28 .",
    "thus let @xmath147 be such a homomorphism .",
    "for any fact @xmath298 in @xmath199 , there is a fact @xmath299 in @xmath200 such that @xmath300 .",
    "we have @xmath301 . by definition of @xmath95 , this means @xmath302 and we are done .",
    "we believe that lemma  [ lem : erdoesdlog ] can be useful in many contexts , saving a detour via csps .",
    "for example , it enables an alternative proof of theorem  [ th : rewrshape ] .",
    "we illustrate this for point  1",
    ". we can start with a ucq - rewriting @xmath3 of an mddlog program @xmath16 of diameter @xmath14 and show that the ucq @xmath303 that consists of all cqs of treewidth @xmath13 that can be obtained from a cq in @xmath3 by identifying variables must also be a rewriting of @xmath16 : take an instance @xmath28 that makes @xmath16 true , use lemma  [ lem : erdoesdlog ] to transform @xmath28 to an @xmath95 of girth exceeding @xmath14 and also exceeding the size of any cq in @xmath3 such that @xmath304 and @xmath214 , observe that @xmath229 and that a homomorphism from any cq @xmath120 in @xmath3 to @xmath95 gives rise to a homomorphism from a cq @xmath305 in @xmath303 to @xmath95 , and derive @xmath306 from @xmath214 .",
    "we consider the rewritability of boolean mddlog programs into datalog programs .",
    "in contrast to the case of rewriting into fo or into monadic datalog , here we only obtain a procedure that is sound , but whose completeness remains an open problem . however , the procedure is complete for the class of mddlog programs that have equality , a condition that is defined in detail below .",
    "we also give a new and direct construction of canonical datalog - rewritings of boolean mddlog programs ( equivalently : the complements of mmsnp sentences ) , bypassing the construction of infinite templates which involves the application of a non - trivial construction due to cherlin , shelah , and shi @xcite .",
    "we say that an mddlog program @xmath16 _ has equality _ if its edb schema includes the distinguished binary relation , @xmath16 contains the rules @xmath307 for each idb relation @xmath308 , and these are the only rules that mention . for an mddlog program @xmath16 that does not have equality , we use @xmath309 to denote the extension of @xmath16 with the fresh edb relation and the above rules",
    ". if @xmath16 has equality , then @xmath309 simply denotes  @xmath16 .    [",
    "lem : trivial ] for any mddlog program @xmath16 , dlog - rewitability of @xmath309 implies dlog - rewritability of @xmath16 .",
    "lemma  [ lem : trivial ] follows from the trivial observation that any dlog - rewriting of @xmath309 can be converted into a dlog - rewriting of @xmath16 by dropping all rules that use the relation @xmath310 .",
    "it remains an interesting open question whether the converse of lemma  [ lem : trivial ] holds .",
    "we shall also need a notion of a csp to have equality , which is actually more natural than in the mmsnp case .",
    "a csp template @xmath36 _ has equality _ if its edb schema includes the distinguished binary relation and @xmath36 interprets as the relation @xmath311 .",
    "it can be verified that when an mddlog program that has equality is converted into a generalized csp based on a set of templates @xmath126 according to theorems  [ th : mmsnptosimple ] and  [ th : simpletocsp ] ( using the concrete constructions in the appendix ) , then all templates in @xmath126 have equality .",
    "the interesting aspect of having equality is that it allows us to establish a counterpart of lemma  [ lem : fogirthdontcare ] also for datalog - rewritability .",
    "[ lem : girthlemfordlog ] let @xmath25 be a set of templates over schema @xmath52 that have equality , and let @xmath220",
    ". if cocsp(@xmath25 ) is dlog - rewritable on instances of girth exceeding @xmath215 , then it is dlog - rewritable .    with every @xmath52-instance @xmath28 and @xmath220 , we associate an @xmath52-instance @xmath312 of girth exceeding @xmath215 such that for any template @xmath36 over @xmath52 that has equality , @xmath313 iff @xmath54 .",
    "thus , let @xmath28 be an @xmath52-instance and @xmath220 .",
    "let @xmath314 be the set of pairs @xmath315 such that @xmath316 and @xmath317 .",
    "reserve fresh constants as follows :    * a constant @xmath318 , for all @xmath319 ; * constants @xmath320 , for all @xmath321 with @xmath322 .",
    "the instance @xmath312 then consists of the following facts :    1 .   for every @xmath175 with @xmath80 of arity @xmath22 , the fact @xmath323 where @xmath324 ; 2 .   for all distinct @xmath321 with @xmath322 , the facts @xmath325    the resulting @xmath326-instance @xmath312 clearly has girth exceeding @xmath215 .",
    "moreover , for any template @xmath36 over @xmath52 that has equality , there is a homomorphism @xmath147 from @xmath28 to @xmath36 iff there is a homomorphism @xmath327 from @xmath312 to @xmath36 .",
    "in fact , @xmath327 can be obtained from @xmath147 by setting @xmath328 when @xmath329 ; conversely , @xmath147 can be obtained from @xmath327 by setting @xmath330 when @xmath329the latter is well - defined by construction of @xmath312 and since @xmath310 is interpreted as the reflexive relation in @xmath36 .",
    "now assume that cocsp@xmath223 is dlog - rewritable on instances of girth exceeding  @xmath215 and let @xmath240 be a concrete rewriting .",
    "we construct a datalog program @xmath331 such that for any @xmath52-instance @xmath28 , @xmath332 iff @xmath333 .",
    "clearly , @xmath331 is then a rewriting of cocsp@xmath223 on instances of unrestricted girth .",
    "we aim to construct @xmath331 such that it mimics the execution of @xmath240 on @xmath312 , despite being executed on @xmath28 .",
    "one challenge is that the domains of @xmath28 and @xmath312 are not identical . in @xmath331 ,",
    "the idb relations of @xmath240 need to be adapted to reflect this change of domain , and so do the rules .",
    "let @xmath125 be the maximum arity of any relation in @xmath52 .",
    "every idb relation @xmath308 of @xmath240 gives rise to a _ set _ of idb relations in @xmath331 .",
    "in fact , every position of @xmath308 can be replaced either with    1 .",
    "@xmath17 positions , for some @xmath334 , reflecting the case that the position is filled with a constant @xmath318 ; or with 2 .",
    "@xmath335 positions , for some @xmath336 , reflecting the case that the position is filled with a constant @xmath337 .    in case  1",
    ", the @xmath17 positions identify the constants in the fact @xmath177 in @xmath120 .",
    "the symbol @xmath80 and the number @xmath82 from @xmath120 also need to be stored , which is done as an annotation to the idb relation . in case  2 , the first @xmath338 positions identify the constants in the fact @xmath177 in @xmath120 while the latter @xmath339 positions identify the constants in the fact @xmath340 in @xmath305 ; we additionally need to store the symbols @xmath80 and @xmath341 , the numbers @xmath82 and @xmath342 from @xmath120 and @xmath305 , and the number @xmath343 , which is again done by annotation of the idb relation .",
    "let us make this formal .",
    "the idb relations of @xmath331 take the form @xmath344 where @xmath308 is an idb relation of @xmath240 and @xmath183 is a function from @xmath345 to @xmath346 such that if @xmath347 , then @xmath317 and if @xmath348 , then @xmath317 and @xmath349 .",
    "the arity of @xmath350 is @xmath351 where @xmath352 is the arity of @xmath80 if @xmath347 and @xmath352 is the sum of the arities of @xmath80 and @xmath341 if @xmath348 . in the construction of  @xmath331",
    ", we manipulate the rules of @xmath240 to account for this change in the idb schema .",
    "we can assume w.l.o.g .",
    "that @xmath240 is closed under identifying variables in rules .",
    "let @xmath353       & & r_1(\\ybf_1 ) \\wedge \\cdots \\wedge        r_{\\ell_2}(\\ybf_{\\ell_2 } )   \\ ,       \\wedge \\\\[1 mm ]       & &       \\mn{eq}(z_{1,1},z_{1,2 } ) \\wedge \\cdots \\wedge        \\mn{eq}(z_{\\ell_3,1},z_{\\ell_3,2 } )    \\end{array}\\ ] ] be a rule in @xmath240 where @xmath354 are idb and @xmath355 are edb ( possibly the distinguished relation ) , such that    * every variable occurs at most once in @xmath356 .",
    "note that it might be possible to write a single rule from @xmath240 in the above form in more than one way ; we then consider all possible ways . also note that rules that do not satisfy ( @xmath357 ) can be ignored since they never apply in @xmath312 .",
    "let @xmath137 be the variables in the rule , and let @xmath358 be such that the following conditions are satisfied :    1 .   for each @xmath359 with @xmath360",
    ", we have @xmath361 for all @xmath343 ; 2 .   for each @xmath362 ,",
    "one of the following is true for some @xmath363 : 1 .   @xmath364 and @xmath365 ; 2 .",
    "@xmath366 and @xmath367 ; 3 .",
    "@xmath368 and @xmath369 ; 4 .",
    "@xmath368 and @xmath370 .    with each variable @xmath172 in , we associate a vector @xmath371 of distinct variables",
    ". if @xmath372 is of the form @xmath373 , then the length of @xmath371 matches the arity of @xmath80 and @xmath371 is called a _ variable block_. if @xmath372 is of the form @xmath374 , then the length of @xmath371 is the sum of the arities @xmath22 and @xmath375 of @xmath80 and @xmath341 ; the first @xmath22 variables in @xmath371 are then also called a _ variable block _ , and so are the last @xmath375 variables .",
    "variable blocks will either be disjoint or identical .",
    "identities are minimized such that the following conditions are satisfied :    1 .",
    "if @xmath172 occurs in some @xmath376 , then @xmath377 ; 2 .",
    "if case  2a applies to @xmath362 , then @xmath378 is identical to the first variable block in  @xmath379 ; 3 .",
    "if case  2b applies to @xmath362 , then @xmath379 is identical to the second variable block in  @xmath378 ; 4 .",
    "if case  2c or  2d applies to @xmath362 , then the first variable blocks of @xmath378 and @xmath379 are identical , and so are the second variable blocks .    regarding ( i1 ) , note that @xmath172 can not occur in more than one @xmath376 because of ( @xmath357 ) , thus the condition can always be satisfied ` without conflicts ' . then include in @xmath331 the rule @xmath380       & & r_1(\\ybf_1 ) \\wedge \\cdots \\wedge        r_{\\ell_2}(\\ybf_{\\ell_2 } ) \\",
    ",       \\wedge \\\\[1 mm ]       & &       w    \\end{array}\\ ] ] such that    1 .",
    "if the @xmath14-th component in @xmath159 is @xmath172 , then @xmath381 ; 2 .",
    "@xmath382 is obtained from @xmath159 by replacing each variable @xmath172 with @xmath371 ; 3 .",
    "@xmath383 contains the following atoms : * for each variable @xmath384 with @xmath372 of the form @xmath373 , an atom @xmath385 where the @xmath82-th component of @xmath386 is @xmath172 and all other variables are distinct and fresh ; * for each variable @xmath384 with @xmath372 of the form @xmath374 , atoms @xmath387 where the @xmath82-th component of @xmath386 and the @xmath343-th component of @xmath388 is @xmath172 and all other variables are distinct and fresh .",
    "as an example , consider the following rule in @xmath240 : @xmath389 where @xmath80 is edb and @xmath308 idb , and let @xmath390 , @xmath391 , and @xmath392 .",
    "note that case  2a applies to @xmath393 .",
    "we have @xmath394 and @xmath395 and thus obtain the following rule in @xmath331 : @xmath396      & & r(x_1,w_1 ) \\wedge r(x_2,w_2 ) \\wedge",
    "r(z_3,x_3 ) \\wedge r(x_3,z_4 )    \\end{array}\\ ] ] where the last line corresponds to @xmath383 above , and where @xmath397 and @xmath398 .",
    "we have have to show that @xmath332 iff @xmath333 for any @xmath52-instance @xmath28 .",
    "there is a correspondence between extensions of @xmath312 to the idb relations in @xmath240 and extensions of @xmath28 to the idb relations in @xmath331 .",
    "more precisely , a fact @xmath399 in an extension of @xmath28 represents a fact @xmath400 in an extension of @xmath312 as follows ( and vice versa ) : for each @xmath401 , let @xmath402 be the subvector of @xmath403 that starts at position @xmath404 and is of length @xmath192 ( where , as before , @xmath352 is the arity of @xmath80 if @xmath347 and @xmath352 is the sum of the arities of @xmath80 and @xmath341 if @xmath348 ) ; the @xmath82-th constant in is @xmath405 if @xmath406 and @xmath407 if @xmath408 and @xmath409 .",
    "one essentially has to show that every application of a rule from @xmath331 in an extension of @xmath28 can be reproduced by an application of a rule from @xmath240 in the corresponding extension of @xmath312 , and vice versa .",
    "we only sketch the details .",
    "first let @xmath410 be an extension of @xmath312 to the idb relations in @xmath240 and let @xmath411 be a rule in @xmath240 applicable in @xmath410 , and @xmath147 a homomorphism from @xmath94 to @xmath410 such that @xmath412 .",
    "since @xmath240 is closed under identifying variables in rules , we can assume that @xmath147 is injective .",
    "let @xmath413       & & r_1(\\ybf_1 ) \\wedge \\cdots \\wedge        r_{\\ell_2}(\\ybf_{\\ell_2 } )   \\ ,       \\wedge \\\\[1 mm ]       & &       \\mn{eq}(z_{1,1},z_{1,2 } ) \\wedge \\cdots \\wedge        \\mn{eq}(z_{\\ell_3,1},z_{\\ell_3,2 } )    \\end{array}\\ ] ] such that all @xmath205 are idb , all @xmath414 edb , and an equality atom @xmath415 is included in the third line if and only if at least one of @xmath416 and @xmath417 is not of the form @xmath318 .",
    "consequently , for all variables @xmath172 that occur in the second line , @xmath416 is of the form @xmath318 .",
    "one can now verify that condition  ( @xmath357 ) is satisfied . assume that this is not the case .",
    "the first case is that that there are distinct atoms @xmath359 and @xmath418 that share a variable @xmath172 . in @xmath312 ,",
    "every constant of the form @xmath318 occurs in exactly one fact that only contains constants of the form @xmath318 .",
    "thus , @xmath147 must take @xmath359 and @xmath418 to the same fact in @xmath410 .",
    "since @xmath147 is injective , @xmath359 and @xmath418 must be identical which is a contradiction .",
    "the second case is that there is an atom @xmath359 in which a variable occurs more than once .",
    "this is in contradiction to @xmath147 being a homomorphism to @xmath410 .",
    "now define a map @xmath419 by putting @xmath420 if @xmath421 and @xmath422 if @xmath423 .",
    "it can be verified that the two conditions required of @xmath424 are satisfied .",
    "we thus obtain a corresponding rule in @xmath331 .",
    "it can be verified that applying this rule in the extension @xmath199 of @xmath28 corresponding to @xmath410 adds the fact that corresponds to @xmath425 .",
    "conversely , let @xmath199 be an extension of @xmath28 to the idb relations in @xmath331 and let @xmath380       & & r_1(\\ybf_1 ) \\wedge \\cdots \\wedge        r_{\\ell_2}(\\ybf_{\\ell_2 } ) \\ ,       \\wedge \\\\[1 mm ]       & &       w    \\end{array}\\ ] ] be a rule in @xmath331 and @xmath147 a homomorphism from the rule body to @xmath199 such that @xmath426 is not in @xmath199 .",
    "this rule was derived from a rule @xmath353       & & r_1(\\ybf_1 ) \\wedge \\cdots \\wedge        r_{\\ell_2}(\\ybf_{\\ell_2 } )   \\ ,       \\wedge \\\\[1 mm ]       & &       \\mn{eq}(z_{1,1},z_{1,2 } ) \\wedge \\cdots \\wedge        \\mn{eq}(z_{\\ell_3,1},z_{\\ell_3,2 } )    \\end{array}\\ ] ] in @xmath240 and a map @xmath427 , @xmath137 the variables in the latter rule .",
    "we define a map @xmath187 from @xmath137 to @xmath428 , where @xmath410 is the extension of @xmath312 that corresponds to @xmath199 .",
    "let @xmath384 . if @xmath429 and @xmath430 , then set @xmath431 .",
    "if @xmath432 and @xmath433 , then set @xmath434 .",
    "we argue that @xmath187 is a homomorphism from the body of the latter rule to @xmath410 .",
    "there are three cases :    * consider an atom @xmath435 .",
    "let @xmath436 .",
    "then there is a corresponding atom @xmath437 in the former rule and thus @xmath438 . for each @xmath439 ,",
    "let @xmath440 be the subvector of @xmath441 that starts at position @xmath442 and is of length @xmath443 .",
    "define the vector by letting the @xmath343-th constant be @xmath444 if @xmath445 and @xmath446 if @xmath447 and @xmath409 . by ( r3 ) , all constants in occur in the domain of @xmath410 .",
    "moreover , @xmath448 .",
    "it thus remains to observe that @xmath449 , which follows from ( r1 ) and ( r2 ) and the definition of @xmath187 .",
    "+ implies @xmath450 . by condition  1 imposed on @xmath424",
    ", we have @xmath451 for each @xmath343 .",
    "moreover , by ( i1 ) we must have @xmath452 for each @xmath343 .",
    "thus , the definition of @xmath187 yields @xmath453 and we are done .",
    "* consider an atom @xmath359 .",
    ". then the atom @xmath359 must also be in the former rule and thus @xmath455 , from which we obtain @xmath456 . by condition  1 imposed on @xmath424",
    ", we have @xmath451 for each @xmath343 .",
    "moreover , by ( i1 ) we must have @xmath452 for each @xmath343 .",
    "thus , the definition of @xmath187 yields @xmath453 and we are done . * consider an atom @xmath362 .",
    "we know that one of the cases  2a to 2d apply to @xmath362 .",
    "we only treat the first case explicitly .",
    "thus assume that @xmath457 and @xmath458 . by definition , @xmath459 and @xmath460 where @xmath461 . by ( i2 )",
    ", @xmath378 is identical to the first variable block in  @xmath379 and thus @xmath462 . by definition if @xmath312 , @xmath410 contains @xmath463 and we are done .",
    "it can now be verified that the application of the latter rule adds to @xmath410 the fact that corresponds to @xmath426 .",
    "dlog - rewritability of csps is np - complete @xcite and it was observed in @xcite that this result lifts to generalized csps .",
    "it thus follows from theorems  [ th : mmsnptosimple ] and  [ th : simpletocsp ] and lemma  [ lem : girthlemfordlog ] that dlog - rewritability of boolean mddlog programs that have equality is decidable in 2 .",
    "it is straightforward to verify that the 2lower bound for datalog - rewritability of mddlog programs from @xcite applies also to programs that have equality .",
    "[ thm : dlogboolwitheq ] for boolean mddlog programs that have equality , datalog - rewritability is 2-complete .",
    "mddlog programs obtained from omqs typically do not have equality . by lemma  [ lem : trivial ] , though , we also obtain a sound but possibly incomplete algorithm for deciding dlog - rewritability of unrestricted mddlog programs .",
    "we conjecture that this algorithm is actually complete .",
    "note that for csps , it is known that adding equality preseves datalog - rewritability @xcite .",
    "completeness of our algorithm is equivalent to an analogous result holding for mddlog .      for constructing actual dlog - rewritings instead of only deciding their existence ,",
    "_ canonical datalog programs _ play an important role .",
    "feder and vardi show that for every csp template @xmath36 and all @xmath464 , it is straightforward to construct an @xmath18-datalog program that is canonical for @xmath36 in the sense that if there is any @xmath18-datalog program which is equivalent to the complement of @xmath36 , then the canonical one is @xcite . in this section ,",
    "we show that there are similarly simple canonical datalog programs for mddlog .",
    "note that the existence of canonical datalog programs for mmsnp ( and thus for boolean mddlog ) is already known from @xcite .",
    "however , the construction given there is more general and rather complex , proceeding via an infinite template and exploiting that it is @xmath465-categorial .",
    "this makes it hard to analyze the exact structure and size of the resulting canonical programs . here , we define canonical datalog programs for boolean mddlog programs in a more elementary way .",
    "let @xmath466 , and let @xmath16 be a boolean mddlog program over edb schema @xmath52 and with idb relations from @xmath124 .",
    "we first convert @xmath16 into a ddlog program @xmath467 that is equivalent to @xmath16 on instances of treewidth @xmath18 .",
    "unlike  @xmath16 , the new program @xmath467 is no longer monadic .",
    "the construction of @xmath467 is similar in spirit to the first step of converting an mddlog program into simple form , c.f.appendix  [ app : step1tosimple ] . to describe it",
    ", we need a preliminary .    with every ddlog rule @xmath468 where @xmath94 is of treewidth @xmath18 and every @xmath18-tree decomposition @xmath469 of @xmath94 ,",
    "we associate a set of _ rewritten rules _ constructed as follows .",
    "choose a root @xmath470 of @xmath36 , thus inducing a direction on the undirected tree @xmath36 .",
    "we write @xmath471 if @xmath472 is a successor of @xmath296 in @xmath36 and use @xmath473 to denote @xmath474 . for all @xmath475 such that @xmath476 , introduce a fresh @xmath125-ary idb relation @xmath477 ; note that @xmath478 . now",
    ", the set of rewritten rules contains one rule for each @xmath38 . for @xmath479 ,",
    "the rule is @xmath480 where @xmath481 is the sub - disjunction of @xmath482 that contains all disjuncts @xmath483 with @xmath484 . for @xmath470 ,",
    "we include the same rule , but use only @xmath481 as the head .",
    "the set of rewritten rules associated with @xmath468 is obtained by taking the union of the rewritten rules associated with @xmath468 and any @xmath485 .    the ddlog program @xmath467 is constructed from @xmath16 as follows :    1 .",
    "first extend @xmath16 with all rules that can be obtained from a rule in @xmath16 by identifying variables ; 2 .   then delete all rules with @xmath94 not of treewidth @xmath18 and replace every rule @xmath468 with @xmath94 of treewidth @xmath18 with the rewritten rules associated with it .",
    "it can be verified that @xmath467 satisfies the following conditions :    1 .",
    "@xmath467 is sound for @xmath16 , that is , for all @xmath52-instances @xmath28 , @xmath486 implies @xmath196 ; 2 .",
    "@xmath467 is complete for @xmath16 on @xmath52-instances of treewidth @xmath18 , that is , for all such instances @xmath28 , @xmath116 implies @xmath486 .",
    "note that @xmath467 is not unconditionally complete for @xmath16 .",
    "for example , if @xmath16 consists of only a goal rule whose rule body is a @xmath487-clique ( without reflexive loops ) , then @xmath467 will return false on the instance that consists of the same clique .",
    "let @xmath488 denote the additional idb relations in @xmath467 .",
    "we now construct the canonical @xmath18-dlog program @xmath489 for @xmath16 .",
    "fix constants @xmath490 . for @xmath491",
    ", we use @xmath492 to denote the set of all @xmath493-instances with domain @xmath494 .",
    "the program uses @xmath495-ary idb relations @xmath496 , for all @xmath497 and all @xmath498 .",
    "it contains all rules @xmath499 , @xmath498 , that satisfy the following conditions :    1 .",
    "@xmath94 contains at most @xmath14 variables ; 2 .   for every extension @xmath199 of the @xmath52-instance @xmath500 with @xmath501-facts such that 1 .",
    "@xmath199 satisfies all rules of @xmath467 and does not contain @xmath132 and 2 .   for each @xmath502 , @xmath503 , there is an @xmath504 such that @xmath505=j|_{\\sbf_i \\cup        \\sbf'_i},\\zbf$ ] + there is an @xmath506 such that @xmath507=j|_{\\sbf_i \\cup      \\sbf'_i},\\ybf$ ]    where @xmath508 $ ] denotes the result of replacing the constants in with the variables in  ( possibly resulting in identifications ) and where @xmath509 denotes the simultaneous restriction of @xmath199 to schema @xmath501 and constants @xmath137 .",
    "is minimal so that condition  2 is satisfied , but this is not strictly required .",
    "] we also include all rules of the form @xmath510 , @xmath511 of any arity from @xmath512 to @xmath17 .",
    "the following are central properties of canonical dlog programs .",
    "[ lem : cancompllk ]   +    1 .",
    "@xmath489 is sound for @xmath16 ; 2 .",
    "@xmath489 is complete for @xmath16 on instances of treewidth @xmath18 .    for point  1",
    ", let @xmath28 be an @xmath52-instance with @xmath513 . it suffices to show that @xmath486",
    "let @xmath514 be the sequence of @xmath515-instances obtained by chasing @xmath28 with @xmath489 , that is , by applying the rules in @xmath489 in a fair but otherwise unspecified order .",
    "we first note that the following can be proved by induction on @xmath82 ( and using the definition of @xmath516 ) : + * claim . *",
    "if @xmath517 , @xmath498 , then for every extension @xmath199 of @xmath28 to the relations in @xmath518 that satisfies all rules of @xmath467 and does not contain @xmath132 , there is an @xmath506 such that @xmath519   =   j|_{\\sbf_i\\cup\\sbf'_i,\\bbf}$ ] .",
    "+ since @xmath520 , there are @xmath521 and @xmath522 such that @xmath523 . by the claim ,",
    "there is thus no extension @xmath199 of @xmath28 to the relations in @xmath524 that satisfies all rules of @xmath16 and does not contain @xmath132 . consequently , @xmath486 .",
    "for point  2 , assume that @xmath525 and let @xmath526 be an @xmath18-tree decomposition of  @xmath28 , @xmath527 .",
    "then there is an extension @xmath199 of @xmath28 to the idb relations in @xmath489 such that all rules in @xmath489 are satisfied and @xmath199 contains no atom of the form @xmath528 .",
    "we use @xmath199 to construct an extension @xmath200 of @xmath28 to the relations in @xmath501 . choose a root @xmath470 of @xmath36 , thus inducing a direction on the undirected tree @xmath36 . for all @xmath38 and successors  @xmath472 of @xmath296 , choose an ordering @xmath529 of the constants in @xmath474 and let @xmath530 denote the number of these constants .",
    "let @xmath531 be all facts of this form in @xmath199 . by construction of @xmath489",
    ", there must be at least one such fact , and the fact @xmath532 must also be in @xmath199 .",
    "thus , we can associate with @xmath533 a unique minimal set @xmath534 so that @xmath535 .",
    "the construction of @xmath200 proceeds top down over @xmath36 . at all points",
    ", we will maintain the invariant that    * for all nodes @xmath38 and successors @xmath472 of @xmath296 , there is an @xmath536 such that @xmath537 = j'|_{\\sbf_i \\cup        \\sbf'_i,\\cbf_{v , v'}}$ ] .",
    "the construction of @xmath200 starts at the root @xmath470 of @xmath36 .",
    "there must be an extension @xmath538 of @xmath539 with @xmath540-facts such that    1 .",
    "@xmath538 satisfies all rules of @xmath16 and does not contain @xmath132 2 .   for each @xmath541 , @xmath542",
    ", there is an @xmath506 such that @xmath519 = j_{v_0}|_{s_i \\cup s'_i,\\bbf}$ ]    as , otherwise , a rule of @xmath489 would create an atom of the form @xmath543 in @xmath199 . start with putting @xmath544 .",
    "note that for each successor @xmath296 of @xmath470 , ( @xmath357 ) is satisfied because of point  ( ii ) and since @xmath545 .",
    "we proceed top - down over @xmath36 .",
    "assume that @xmath472 is a successor of @xmath296 and @xmath546 has already been treated .",
    "there must be an extension @xmath547 of @xmath548 with @xmath540-facts such that    1 .",
    "@xmath547 satisfies all rules of @xmath16 and does not contain @xmath132 , 2 .",
    "@xmath549 , and 3 .   for each @xmath550 , @xmath542",
    ", there is an @xmath506 such that @xmath519 = j_{v'}|_{s_i \\cup s'_i,\\bbf}$ ]    as , otherwise , because of ( @xmath357 ) a rule of @xmath489 would create an atom of the form @xmath551 in @xmath199 with @xmath552 , in contradiction to @xmath534 being minimal with @xmath535 . put @xmath553 .",
    "it can again be verified that ( @xmath357 ) is satisfied .    by construction",
    ", the instance @xmath200 does not contain @xmath132 and @xmath469 is also a tree decomposition of @xmath200 , that is , each edb atom _ and each idb atom _ of @xmath200 falls within some bag @xmath546 .",
    "we aim to show that @xmath200 satisfies all rules of @xmath16 , thus @xmath554 as required .",
    "let @xmath555 be the result of identifying variables in rules of @xmath16 and recall that @xmath467 is obtained from @xmath555 by dropping and rewriting rules .",
    "let @xmath71 be a rule in @xmath16 and let @xmath147 be a homomorphism from its body to @xmath200 .",
    "we have to show that one of the disjuncts in the head of @xmath71 is satisfied under @xmath147 .",
    "@xmath555 contains the rule @xmath556 obtained from @xmath71 by identifying all variables @xmath557 such that @xmath174 .",
    "it clearly suffices to show that one of the disjuncts in the head of @xmath556 is satisfied under @xmath147 .",
    "note that @xmath147 is an injective homomorphism from the body @xmath94 of @xmath556 to @xmath200 which implies that @xmath94 is of treewidth @xmath18 .",
    "moreover , we can read off an @xmath18-tree decomposition @xmath558 of @xmath94 from @xmath147 and @xmath485 .    in  @xmath467 , @xmath556 and @xmath558",
    "are rewritten into rules @xmath559 such that no @xmath560 uses a fresh idb relation from the head of any @xmath561 with @xmath562 ( that is , an idb relation that does not occur in @xmath555 , of arity at most @xmath17 ) .",
    "let @xmath560 be @xmath563 where @xmath564 are disjuncts that also occur in the head of @xmath556 and @xmath565 is a fresh idb relation introduced by the rewriting in the case that @xmath566 and @xmath567 if @xmath568 ( by which we mean : there is no @xmath569 disjunct in the latter case ) .",
    "one can show by induction on @xmath82 that for @xmath570 ,    1 .",
    "@xmath571 for some @xmath572 and @xmath573 or 2 .",
    "@xmath574 .    to see this ,",
    "assume that point  1 is not satisfied for some @xmath82 .",
    "then point  2 holds for all @xmath575 . by choice of @xmath560",
    ", there is a @xmath38 such that @xmath576 .",
    "thus @xmath147 is a homomorphism from @xmath162 to @xmath577 , and consequently there is a disjunct @xmath578 in the head of @xmath560 such that @xmath579 .",
    "this implies that one of points  1 or  2 is satisfied for @xmath82 .",
    "note that point  2 can not hold for @xmath568 because the @xmath580 disjunct is not present in @xmath581 .",
    "thus there is an @xmath582 such that @xmath583 for some @xmath343 .",
    "since @xmath584 occurs in the head of @xmath556 , we are done .",
    "we are now ready to show that the canonical program is indeed canonical , as detailed by the following theorem . for two boolean dlog programs @xmath585 over the same edb schema @xmath52 ,",
    "we write @xmath586 if for every @xmath52-instance @xmath28 , @xmath587 implies @xmath588 .",
    "[ thm : canonical ] let @xmath16 be a boolean mddlog program , @xmath589 , and @xmath489 the canonical @xmath18-dlog program for @xmath16",
    ". then    1 .",
    "@xmath590 for every @xmath18-dlog program @xmath240 that is sound for @xmath16 ; 2 .",
    "@xmath16 is @xmath18-dlog - rewritable iff @xmath489 is a dlog - rewriting of  @xmath16 .",
    "let @xmath52 be the edb schema of @xmath16 .    for point  1 ,",
    "let @xmath240 be an @xmath18-dlog program that is sound for @xmath16 and let @xmath28 be an @xmath52-instance with @xmath591 . from the proof tree for @xmath132 from @xmath28 and @xmath240 , we can construct an @xmath52-instance @xmath199 of treewidth @xmath18 such that @xmath592 and @xmath268 .",
    "it suffices to show that @xmath593 , which is easy : from @xmath594 , we obtain @xmath285 and point  2 of lemma  [ lem : cancompllk ] yields @xmath595 .",
    "the `` if '' direction of point  2 is trivial . for",
    "the `` only if '' direction , assume that @xmath16 is @xmath18-dlog - rewritable and let @xmath240 be a concrete rewriting .",
    "we have to show that @xmath489 is sound and complete for @xmath16 .",
    "the former is point  1 of lemma  [ lem : cancompllk ] . for the latter ,",
    "we get @xmath596 since @xmath240 is a rewriting of @xmath16 and @xmath597 from point  1 , thus @xmath598 as required",
    ".    note that by point  2 of theorem  [ thm : canonical ] , the canonical @xmath18-dlog program for an mddlog program @xmath16 is interesting even if @xmath16 is not rewritable into an @xmath18-dlog program as it is the strongest sound @xmath18-dlog approximation of @xmath16 .",
    "we lift the results about the complexity of rewritability , about canonical dlog programs , and about the shape of rewritings and obstructions from the case of boolean mddlog programs to the non - boolean case . for all of this ,",
    "a certain extension of @xmath18-datalog programs with parameters plays a central role .",
    "we thus begin by introducing these extended programs .",
    "an _ @xmath18-datalog program with @xmath22 parameters _ is an @xmath22-ary @xmath599-datalog program in which all idbs have arity at least @xmath22 and where in every rule , all idb atoms agree on the variables used in the last @xmath22 positions ( both in rule bodies and heads and including the idb ) .",
    "the last @xmath22 positions of idbs are called _",
    "parameter positions_. to visually separate the parameter positions from the non - distinguished positions , we use `` @xmath600 '' as a delimiter to replace the usual comma , writing e.g.@xmath601 where @xmath602 are idb , @xmath80 is edb , and there are three parameter positions .",
    "note that , by definition , all variable positions in atoms are parameter positions .",
    "[ ex : par ] the following is an mdlog program with one parameter that returns all constants which are on an @xmath80-cycle , @xmath80 a binary edb relation : @xmath603       p(z \\,|\\ , x ) & \\leftarrow & p(y \\,|\\ , x ) \\wedge r(y , z )       \\\\[{0.5 mm } ]       \\mn{goal}(x ) & \\leftarrow & p(x \\,|\\ , x ) \\end{array}\\ ] ]    parameters in datalog programs play a similar role as parameters to least fixed - point operators in fo(lfp ) , see for example @xcite and references therein .",
    "the program in example  [ ex : par ] is not definable in mdlog without parameters , which shows that adding parameters increases expressive power .",
    "although @xmath18-dlog programs with @xmath22 parameters are @xmath599-dlog programs , one should think of them as a mild generalization of @xmath18-programs .",
    "a dlog program is an _",
    "@xmath17-dlog program _ if it is an @xmath18-dlog program for some @xmath14 . to lift decidability and complexity results from the boolean to the non - boolean case",
    ", we show that rewritability of an @xmath22-ary mddlog program into @xmath17-dlog with @xmath22 parameters can be reduced to rewritability of a boolean mddlog program into @xmath17-dlog ( without parameters ) .",
    "note that the case @xmath604 is about ucq - rewritability because @xmath512-dlog programs ( with and without parameters ) are an alternative presentation of ucqs .",
    "the reduction proceeds in two steps , described by subsequent lemmas  [ lem : nonboolred1 ] and  [ lem : nonboolred2 ] .",
    "[ ex : avar2 ] the following mddlog program is rewritable into the mdlog program with parameters from example  [ ex : par ] , but not into an mdlog program without parameters : @xmath605 \\mn{goal}(x ) & \\leftarrow & p_0(x ) \\\\[{0.5 mm } ] p_{1}(y ) & \\leftarrow & p_1(x ) \\wedge r(x , y )   \\\\[{0.5 mm } ] \\mn{goal}(x ) & \\leftarrow & p_1(x )   \\end{array}\\ ] ]    the following lemma shows that , by introducing constants , we can reduce the rewritability of mddlog programs with non - zero arity to the rewritability of boolean mddlog programs . note that the presence of constants in an @xmath18-dlog program is not reflected in the values of @xmath17 and @xmath14 .",
    "the _ rule size _ of an mddlog program is the maximum number of variable _ occurrences _ in any rule in the program .",
    "[ lem : nonboolred1 ] given an @xmath22-ary mddlog program @xmath16 , one can construct boolean mddlog programs with constants @xmath606 over the same edb schema such that for all @xmath15 ,    1 .",
    "@xmath16 is rewritable into an @xmath18-dlog program with @xmath22 parameters iff each of @xmath606 is rewritable into an @xmath18-dlog program with constants ; 2 .   @xmath607 and the size ( resp .",
    "diameter , rule size ) of each program @xmath608 is bounded by the size ( resp .",
    "diameter , rule size ) of @xmath16 .",
    "the construction takes time polynomial in the size of @xmath609 .",
    "let @xmath16 be an @xmath22-ary mddlog program over edb schema @xmath52 .",
    "fix a set @xmath610 of @xmath22 constants . for each @xmath611",
    ", we construct from @xmath16 a boolean mddlog program @xmath612 such that for any @xmath613 , @xmath16 is @xmath18-dlog rewritable iff all programs @xmath612 are .",
    "let @xmath614 . given two @xmath22-tuples of terms ( constants or variables ) @xmath615 and @xmath616",
    ", we write @xmath617 if @xmath618 implies @xmath619 for @xmath620 .",
    "we write @xmath621 when @xmath622 .",
    "the program @xmath612 is obtained from @xmath16 as follows :    * replace every rule @xmath623 with @xmath624 by @xmath625 ; * drop every rule @xmath623 with @xmath626 .",
    "note that the non - goal rules in @xmath612 are identical to those in @xmath16 . by converting proof trees for @xmath16 into proof trees for @xmath612 and vice versa",
    ", one can show the following .",
    "+ * claim . * for all @xmath52-instances @xmath28 and @xmath627 with @xmath628 , @xmath629 \\models \\pi_{{\\mathbf{c}}}$ ] .",
    "+ we show that @xmath16 is rewritable into an @xmath18-dlog program with @xmath22 parameters iff all of the constructed programs @xmath630 are rewritable into an @xmath18-dlog program with constants .",
    "let @xmath240 be an @xmath18-dlog program with @xmath22 parameters that is a rewriting of  @xmath16 . for each @xmath611 ,",
    "let @xmath631 be the boolean @xmath18-dlog program with constants obtained from @xmath240 as follows :    * replace every rule @xmath632 with @xmath633 ( and where @xmath308 might be @xmath634 ) by @xmath635 , where @xmath636 is the result of replacing in each variable @xmath637 with @xmath638 ; * drop every rule @xmath632 with @xmath639 .    by translating proof trees",
    ", it can be shown that ( @xmath357 ) @xmath640 iff @xmath641 .",
    "it is now easy to show that @xmath631 is a rewriting of @xmath630 : for every @xmath52-instance @xmath28 , @xmath642 iff @xmath643 ( by the claim ) iff @xmath640 ( since @xmath240 is a rewriting of @xmath16 ) iff @xmath644 ( by ( @xmath357 ) ) .",
    "conversely , let @xmath645 be a boolean @xmath18-dlog program with constants that is a rewriting of  @xmath612 , for all @xmath646 .",
    "we construct an @xmath18-dlog program with @xmath22 parameters @xmath240 as follows .",
    "for each @xmath646 , fix a tuple @xmath647 of fresh variables such that @xmath648 .",
    "let @xmath649 be the @xmath18-dlog program with @xmath22 parameters obtained from @xmath631 as follows :    1 .   replace each @xmath638 with @xmath650 ; 2 .   replace each non - goal idb atom @xmath651 with the atom @xmath652 ( both in rule bodies and heads ) , @xmath653 a fresh idb relation ; 3 .",
    "replace @xmath132 with @xmath654 .",
    "then @xmath240 is defined as the union of all programs @xmath649 .",
    "we first argue that for every @xmath614 , @xmath52-instance @xmath28 , and @xmath655 with @xmath656 ,    1 .",
    "@xmath641 implies @xmath657 \\models    \\gamma^v_{{\\mathbf{c } } } ( { \\mathbf{a}})$ ] and 2 .",
    "@xmath658 , with @xmath659 , implies @xmath660 \\models \\gamma_{{\\mathbf{c}}}$ ] .",
    "point  1 can be proved by showing that , from a proof tree of @xmath132 from @xmath28 and @xmath645 , one can construct a proof tree of @xmath661 from @xmath657 $ ] and @xmath662 . for point  2 ,",
    "assume @xmath663 with @xmath664 .",
    "then @xmath660 \\models ( \\gamma_{{\\mathbf{c'}}})[{\\mathbf{c}}/{\\mathbf{c'}}]$ ] can again be shown by manipulating proof trees .",
    "it can be verified that , by construction , @xmath665 \\subseteq \\pi_{{\\mathbf{c}}}$ ] . consequently and since @xmath666 is a rewriting of @xmath667 , @xmath668 $ ] implies @xmath669 for all @xmath199 , that is , @xmath670 $ ] is contained in @xmath631 in the sense of query containment .",
    "thus in particular @xmath660 \\models \\gamma_\\cbf$ ] , as required .    it remains to show that @xmath240 is a rewriting for @xmath16 .",
    "first assume that @xmath671 .",
    "choose some @xmath614 with @xmath628 .",
    "then @xmath660 \\models \\pi_{{\\mathbf{c}}}$ ] by the claim and thus @xmath660 \\models \\gamma_{{\\mathbf{c}}}$ ] since @xmath645 is a rewriting of @xmath612 .",
    "point  1 above yields @xmath660[\\abf/\\cbf]=i \\models \\gamma(\\abf)$ ] .",
    "now assume that @xmath672 . by construction of @xmath240 , then there is a @xmath673 such that @xmath674 and @xmath658 . to see this , note in particular that the different programs @xmath662 do not share any idbs and thus do not interact in @xmath240 .",
    "choose a @xmath675 with @xmath628 . from point  2 above",
    ", we obtain @xmath660 \\models \\gamma_{{\\mathbf{c}}}$ ] which yields @xmath660 \\models \\pi_{{\\mathbf{c}}}$ ] .",
    "this implies @xmath671 by the claim .",
    "we next show that constants can be eliminated from boolean programs .",
    "[ lem : nonboolred2 ] given a boolean mddlog program @xmath676 with constants over edb schema @xmath52 , one can construct a boolean mddlog program @xmath16 over an edb schema @xmath677 such that    1 .",
    "@xmath676 is rewritable into @xmath17-dlog with constants iff @xmath16 is rewritable into @xmath17-dlog , for any  @xmath17 ; 2 .",
    "if @xmath676 is of size @xmath22 and diameter @xmath14 , then the size of @xmath16 is @xmath119 ; moreover , the diameter of @xmath16 is bounded by the rule size of @xmath676 .    the construction takes time polynomial in the size of @xmath678 .    let @xmath676 be a boolean mddlog program over edb schema @xmath52 that contains constants @xmath679 .",
    "the program @xmath16 will be over edb schema @xmath680 where @xmath681 are fresh monadic relation symbols .",
    "@xmath16 contains all rules that can be obtained from a rule @xmath71 in  @xmath16 by choosing a partial function @xmath424 that maps each term ( variable or constant ) in @xmath71 to an element of @xmath682 such that @xmath683 for each constant @xmath638 and then , for each term @xmath684 with @xmath685 ,    1 .   replacing each occurrence of @xmath684 in the body of @xmath71 with a fresh variable @xmath172 and adding @xmath686 , and 2 .",
    "replacing each occurrence of @xmath684 in the head of @xmath71 with some fresh variable introduced for @xmath684 in step  1 .    additionally , @xmath16 contains the rule @xmath687 , for @xmath620 .",
    "note that the rewriting presented above , which we call _ dejoining _ , can be applied not only to mddlog programs , but also to mdlog programs .",
    "before we proceed , we make a basic observation about dejoining and its connection to a certain quotient construction .",
    "let @xmath16 be an mddlog program or an mdlog program , with constants @xmath688 , and let @xmath689 be the result of dejoining @xmath16 .",
    "let @xmath28 be an @xmath92-instance such that @xmath690 are disjoint whenever @xmath691 and which does not contain the constants @xmath688 .",
    "the _ quotient _ of @xmath28 is the @xmath52-instance @xmath95 obtained from @xmath28 by replacing every @xmath692 with @xmath693 by the constant @xmath638 ( which also results in the identification of elements in the active domain ) and removing all atoms involving one of the @xmath414 relations . by converting proof trees of @xmath132 from @xmath16 into proof trees of @xmath132 from @xmath676 and vice versa , one can show the following .",
    "+ * claim*. @xmath116 iff @xmath694 .",
    "+ we now show that @xmath676 is writable into @xmath17-dlog iff @xmath16 is .",
    "first let @xmath516 be an @xmath17-dlog rewriting of @xmath676 .",
    "let @xmath240 be obtained from @xmath516 by dejoining all rules and adding the rule @xmath695 for @xmath696 .",
    "clearly , @xmath240 is an @xmath17-dlog program .",
    "we argue that @xmath240 is a rewriting of @xmath16 .",
    "let @xmath28 be an @xmath92-instance . w.l.o.g . , we can assume that @xmath28 does not contain @xmath688 .",
    "if @xmath690 are not disjoint for some @xmath691 , then @xmath116 and @xmath247 .",
    "otherwise , let @xmath95 be the quotient of  @xmath28 .",
    "we have @xmath116 iff @xmath697 ( by the claim ) iff @xmath698 ( @xmath516 is rewriting of @xmath676 ) iff @xmath247 ( again by the claim ) .",
    "let @xmath240 be an @xmath17-dlog rewriting of @xmath16 .",
    "let @xmath516 be the program constructed from @xmath240 by removing all rules that contain atoms of the form @xmath686 and @xmath699 with @xmath691 and replacing all variables @xmath172 that occur in a rule body in atoms of the form @xmath686 with @xmath638 and removing all @xmath414-atoms from such rules . clearly , @xmath516 is an @xmath17-dlog program ( with constants @xmath688 ) .",
    "we argue that @xmath516 is a rewriting of @xmath676 .",
    "let @xmath28 be an @xmath52-instance that w.l.o.g",
    ". does not contain @xmath688 and let @xmath700 .",
    "note that @xmath28 is the quotient of @xmath95 .",
    "then @xmath701 iff @xmath304 ( by the claim ) iff @xmath245 ( @xmath240 is rewriting of @xmath16 ) iff @xmath702 ( by construction of @xmath516 ) .",
    "we are now ready to lift the complexity results from theorems  [ th : decidboolean ] and  [ thm : dlogboolwitheq ] to the non - boolean case .    [ th : general ] in mddlog ,    1 .",
    "fo - rewritability ( equivalently : ucq - rewritability ) is 2-complete ; 2 .",
    "rewritability into mdlog with parameters is in 3(and 2-hard ) ; 3 .",
    "dlog - rewritability is 2-complete for programs that have equality .",
    "regarding point  1 , we recall that proposition  [ prop : ross ] also covers non - boolean mddlog programs and thus it suffices to consider ucq - rewritability .",
    "regarding point  2 , we remark that rewritability of the original mddlog program into mdlog with parameters is equivalent to mdlog - rewritability of the csps ultimately constructed from it . regarding point  3 , it can be verified that the constructions in the proofs of lemmas  [ lem : nonboolred1 ] and  [ lem : nonboolred2 ] preserve the property of having equality .",
    "one can trace the blowups stated in lemmas  [ lem : nonboolred1 ] and  [ lem : nonboolred2 ] as well as in theorems  [ th : mmsnptosimple ] and  [ th : simpletocsp ] to verify that the constructed csp templates do not become significantly larger in the non - boolean case , that is , they still satisfy the bounds stated in point  3 of proposition  [ th : mmsnptosimple ] .",
    "thus , we obtain the same upper bounds as in the boolean case .    in view of point  2 , we remark that for non - boolean mddlog programs @xmath16 , mdlog with parameters is in a sense a more natural target for rewriting than mdlog without parameters .",
    "the intuitive reason is that positions in the answer to @xmath16 can be thought of as constants , and constants correspond to parameters . to make this a bit more precise ,",
    "consider the grounding @xmath467 of @xmath16 obtained by replacing , in every goal rule , each variable that occurs in the head by a constant .",
    "in contrast to the standard database setup ( and in contrast to the proof of lemma  [ lem : nonboolred1 ] ) , we mean here constants that are interpreted according to the standard fo semantics , that is , different constants can denote the same element of an instance .",
    "when looking for an mdlog - rewriting of @xmath467 , it is clearly very natural to admit the constants from @xmath467 also in the rewriting .",
    "now , one can verify that any such rewriting can be translated in a straightforward way into a rewriting of @xmath16 into mdlog with parameters , and vice versa .",
    "we further note that mdlog with parameters enjoys similarly nice properties as standard mdlog .",
    "for example , containment is decidable .",
    "this follows from @xcite where generalizations of mdlog with parameters are studied , the actual parameters being represented by constants .",
    "we also remark that theorem  [ th : general ] remains true when we admit constants in mddlog programs .",
    "in fact , the proof of lemma  [ lem : nonboolred1 ] goes through also when the original mddlog program contains constants , and both the original and the newly introduced constants can then be removed by lemma  [ lem : nonboolred2 ] .",
    "we now turn our attention to canonical dlog - rewritings for non - boolean mddlog programs .",
    "let @xmath16 be an @xmath22-ary mddlog program .",
    "we associate with @xmath16 a _",
    "canonical @xmath18-dlog program with @xmath22 parameters _",
    ", for any @xmath703 .",
    "the construction is a refinement of the one from the boolean case .",
    "we start with some preliminaries .",
    "@xmath22-marked instance _ is an instance @xmath28 endowed with @xmath22 ( not necessarily distinct ) distinguished elements @xmath704 .",
    "@xmath18-tree decomposition with @xmath22 parameters _ of an @xmath22-marked instance @xmath705 is an @xmath706-tree decomposition of @xmath28 , @xmath125 the number of distinct constants in , in which every bag @xmath546 contains all constants from .",
    "an @xmath22-marked instance _ has treewidth @xmath18 with @xmath22 parameters _ if it admits an @xmath18-tree decomposition with @xmath22 parameters .",
    "we first convert @xmath16 into a ddlog program @xmath467 that is equivalent to @xmath16 on instances of bounded treewidth .",
    "the construction is identical to the boolean case ( first variable identification , then rewriting ) except that , in the rewriting step ,    1 .",
    "we use treewidth @xmath599 in place of treewidth @xmath18 ; consequently , the arity of the freshly introduced idb relations may also be up to @xmath707 ; 2 .   for @xmath634 rules",
    ", all head variables must occur in the root bag of the tree decomposition ( they can then be treated in the same way as a boolean rule despite the @xmath22-ary head relation ) .",
    "it can be verified that @xmath467 is sound for @xmath16 and that it is complete for @xmath16 on @xmath22-marked instances of treewidth @xmath18 with @xmath22 parameters in the sense that , for all such instances @xmath705 , @xmath708 $ ] implies @xmath709 $ ] .",
    "@xmath467 is not guaranteed to be complete for answers other than because of the way we treat goal rules in point  2 above , for example when @xmath16 contains a rule of the form @xmath710 .",
    "let @xmath488 denote the additional idb relations in the resulting program @xmath467 .",
    "we now construct the canonical @xmath18-dlog program with @xmath22 parameters @xmath489 .",
    "fix constants @xmath711 @xmath712 and let @xmath713 denote the set of all @xmath714-instances with domain @xmath715 @xmath712 .",
    "the program uses @xmath716-ary idb relations @xmath496 , for all @xmath491 and all @xmath717 .",
    "it contains all rules @xmath718 , @xmath717 , that satisfy the following conditions :    1 .",
    "@xmath94 contains at most @xmath719 variables ; 2 .   in every extension @xmath199 of the @xmath52-instance @xmath500 with @xmath501-facts such that 1 .",
    "@xmath199 satisfies all rules of @xmath467 and does not contain @xmath720 and 2 .   for each @xmath721 , @xmath722 , there is an @xmath504 such that @xmath723=j|_{\\sbf_i \\cup   \\sbf'_i},\\zbf$ ] + there is an @xmath506 such that @xmath724=j|_{\\sbf_i \\cup      \\sbf'_i},\\ybf$ ]    we also include all rules of the form @xmath725 .",
    "this finishes the construction of  @xmath489 .",
    "it is straightforward to verify that @xmath489 is sound for @xmath16 .",
    "it is complete in the same sense as @xmath467 .",
    "[ lem : cancompllk2 ] @xmath489 is sound for @xmath16 .",
    "it is complete for @xmath16 on @xmath22-marked instances of treewidth @xmath18 with @xmath22 parameters in the sense that for any such instance @xmath705 , @xmath726 implies @xmath727 .",
    "the proof of lemma  [ lem : cancompllk2 ] is similar to that of lemma  [ lem : cancompllk ] , details are omitted . in analogy with theorem  [ thm : canonical ] , we can then obtain the following result about canonical dlog programs .",
    "[ thm : canonical2 ] let @xmath16 be an @xmath22-ary mddlog program , @xmath728 , and @xmath489 the canonical @xmath18-dlog program with @xmath22 parameters associated with @xmath16",
    ". then    1 .",
    "@xmath590 for every @xmath18-dlog program @xmath240 that is sound for @xmath16 ; 2 .",
    "@xmath16 is rewritable into @xmath18-dlog with @xmath22 parameters iff @xmath489 is a rewriting of  @xmath16 .",
    "note that , as a consequence of theorem  [ thm : canonical2 ] , an @xmath22-ary mddlog program @xmath16 is dlog - rewritable ( in the standard sense , without parameters ) iff the canonical @xmath18-dlog program with @xmath22 parameters is a rewriting , for some @xmath15 .",
    "when one is interested in dlog - rewritability without caring for the exact @xmath15-parameterization , canonical programs for the non - boolean case thus behave exactly as canonical programs in the boolean case .",
    "in particular , the reductions presented in lemmas  [ lem : nonboolred1 ] and  [ lem : nonboolred2 ] show that if dlog - rewritability of boolean programs turns out to be decidable ( without assuming equality ) , then the same is true for dlog - rewritability of non - boolean programs .",
    "we now analyze the shape of rewritings of non - boolean mddlog programs .",
    "@xmath18-tree decomposition with @xmath22 parameters _ of an @xmath22-ary cq @xmath3 is an @xmath599-tree decomposition of @xmath3 in which every bag @xmath546 contains all answer variables of  @xmath3 .",
    "the treewidth with parameters of an @xmath22-ary cq is now defined in the expected way .",
    "[ th : rewrshape2 ] let @xmath16 be an @xmath22-ary mddlog program of diameter @xmath14",
    ". then    1 .",
    "if @xmath16 is fo - rewritable , then it has a ucq - rewriting in which each cq has treewidth @xmath13 with @xmath22 parameters ; 2 .",
    "if @xmath16 is rewritable into mdlog with @xmath22 parameters , then it has an mdlog - rewriting with @xmath22 parameters of diameter @xmath14 .",
    "note that theorem  [ th : rewrshape2 ] is immediate from theorem  [ th : rewrshape ] and lemmas  [ lem : nonboolred1 ] and  [ lem : nonboolred2 ] when @xmath14 denotes the rule size of @xmath16 instead of its diameter . to get the improved version",
    ", one needs to carefully trace the construction of rewritings , starting with rewritings for the csps ultimately constructed and then through the proofs of lemmas  [ prop : rewrcorresp ] ,  [ lem : nonboolred2 ] , and  [ lem : nonboolred1 ] . in particular , the constructions in lemmas  [ prop : rewrcorresp ] and  [ lem : nonboolred2 ] interplay in a subtle way that can be exploited to improve the bound .",
    "details are in the appendix .    as in the boolean case , rewritings are closely related to obstructions .",
    "we define obstruction sets for mmsnp formulas with free variables and summarize the results that we obtain for them .",
    "a _ set of marked obstructions _",
    "@xmath261 for an mmsnp formula @xmath59 with @xmath22 free variables over schema @xmath52 is a set of @xmath22-marked instances over the same schema such that for any @xmath52-instance @xmath28 , we have @xmath729 $ ] iff for some @xmath730 , there is a homomorphism @xmath147 from @xmath253 to @xmath28 with @xmath731 .",
    "we obtain the following corollary from point  1 of theorem  [ th : rewrshape2 ] in exactly the same way in which corollary  [ cor : fo ] is obtained from point  1 of theorem  [ th : rewrshape ] .    for every mmsnp formula @xmath59 with @xmath22 free variables ,",
    "the following are equivalent :    1 .",
    "@xmath59 is fo - rewritable ; 2 .",
    "@xmath59 has a finite marked obstruction set ; 3 .",
    "@xmath59 has a finite set of finite marked obstructions of treewidth @xmath13 with @xmath22 parameters .",
    "it is interesting to note that this result can be viewed as a generalization of the characterization of obstruction sets for csp templates with constants in terms of ` c - acyclicity ' in @xcite ; our parameters correspond to constants in that paper .",
    "we now turn to mdlog - rewritability .",
    "let @xmath59 be an mmsnp formula of diameter @xmath14 with @xmath22 free variables .",
    "then @xmath265 is rewritable into an mdlog program with @xmath22 parameters iff @xmath59 has a set of marked obstructions ( equivalently : finite marked obstructions ) that are of treewidth  @xmath13 with @xmath22 parameters .",
    "the `` only if '' direction is a consequence of point  2 of theorem  [ th : rewrshape2 ] and the fact that , for any mdlog program @xmath267 with @xmath22 parameters of diameter @xmath14 over edb schema @xmath52 , a proof tree for @xmath732 from an @xmath52-instance @xmath28 and  @xmath16 gives rise to a finite @xmath22-marked @xmath52-instance @xmath733 of treewidth @xmath13 with @xmath22 parameters that satisfies @xmath268 .",
    "the `` if '' direction is a consequence of the fact that the canonical @xmath13-dlog program with parameters associated with @xmath265 viewed as an mddlog program is complete on inputs of treewidth @xmath734 with @xmath22 parameters in the sense of lemma  [ lem : cancompllk2 ] .    as an illustration , it might be interesting to reconsider example  [ ex : avar2 ] .",
    "the unary mddlog program shown there is the negation of a unary mmsnp formula that has as a set of marked obstructions the set of all @xmath80-cycles on which one element is the marked element .",
    "each of these obstructions has treewidth @xmath735 with @xmath22 parameters , but not treewidth @xmath735 in the strict sense .",
    "we study rewritability of ontology - mediated queries , covering several standard description logics as the ontology language . we start with introducing the relevant classes of queries .",
    "an _ ontology - mediated query ( omq ) _ over a schema @xmath52 is a triple @xmath736 where is a tbox formulated in a description logic and @xmath3 is a query over the schema @xmath737 , @xmath738 the set of relation symbols used in .",
    "the tbox can introduce symbols that are not in @xmath52 , which allows it to enrich the schema of the query  @xmath3 .",
    "as the tbox language , we use the description logic , its extension @xmath739 with inverse roles , and the further extension @xmath740 of @xmath739 with transitive roles and role hierarchies .",
    "since all these logics admit only unary and binary relations , we assume that these are the only allowed arities in schemas throughout the section . as the actual query language",
    ", we use ucqs and cqs .",
    "the omq languages that these choices give rise to are denoted with @xmath741 , @xmath742 , and so on . in omqs @xmath736 from @xmath742",
    ", we disallow superroles of transitive roles in @xmath3 ; it is known that allowing such roles in the query poses serious additional complications , which are outside the scope of this paper , see e.g.@xcite .",
    "the semantics of an omq is given in terms of _ certain answers_. we refer to the appendix for further details and only give an example here .",
    "let @xmath743 be the following omq , formulated in @xmath8 : @xmath744       \\sbf_e & = & \\ { \\ ; a , c , r \\ ; \\ } \\\\[{0.5 mm } ]    q(x ) & = & r(x , y ) \\wedge c(y ) \\end{array}\\ ] ] on the @xmath52-instance @xmath745 the only certain answer to @xmath746 is @xmath747 .    an omq @xmath743 is _ fo - rewritable _ if there is an fo query @xmath748 over schema  @xmath52 ( and possibly involving equality ) , called an _ fo - rewriting _ of @xmath746 , such that for all @xmath52-instances @xmath28 and @xmath749 , we have @xmath750 iff @xmath751 . other notions of rewritability such as ucq - rewritability are defined accordingly .",
    "note that the tbox can be inconsistent with the input instance @xmath28 , that is , there could be no model of and  @xmath28 .",
    "it can thus be a sensible alternative to work with _ consistent fo - rewritability _ , considering only @xmath52-instances @xmath28 that are consistent w.r.t .  .",
    "this can then be complemented with rewritability of inconsistency for @xmath752 , that is , rewritability of the boolean omq @xmath753 , @xmath6 a fresh concept name , which is true on an @xmath52-instance @xmath28 iff @xmath28 is inconsistent with .",
    "it is not hard to prove , though , that consistent -rewritability can be reduced to -rewritability in polynomial time for all omq languages condidered in this paper and all @xmath754 ; see the corresponding proof for query containment in @xcite .",
    "moreover , rewritability of consistency was studied in @xcite and shown to be -complete for all omq languages considered in this paper .",
    "the following is our main result on omqs .",
    "[ thm : alcicompl ] in all omq languages between @xmath8 and @xmath742 , as well as between @xmath755 and @xmath756 ,    1 .",
    "fo - rewritability ( equivalently : ucq - rewritability ) is 2-complete ; in fact , there is an algorithm which , given an omq @xmath743 , decides in time @xmath757 whether @xmath746 is fo - rewritable ; 2 .   mdlog - rewritability is in 3(and 2-hard ) ; in fact , there is an algorithm which , given an omq @xmath743 , decides in time @xmath758 whether @xmath746 is mdlog - rewritable    where @xmath10 and @xmath759 are the size of @xmath3 and and @xmath120 is a polynomial .",
    "note that the runtime for deciding fo - rewritability stated in in theorem  [ thm : alcicompl ] is double exponential only in the size of the actual query @xmath3 ( which tends to be very small ) while it is only single exponential in the size of the tbox ( which can become large ) and similarly for mdlog - rewritability , only one exponential higher .",
    "the lower bounds in theorem  [ thm : alcicompl ] are from @xcite .",
    "we obtain the upper bounds by translating the omq into an equivalent mddlog program and then applying the constructions that we have already established .",
    "in fact , it was shown in @xcite that every omq from the languages mentioned in theorem  [ thm : alcicompl ] can be converted into an equivalent mddlog program at the expense of a single or even double exponential blowup , depending on the omq language .",
    "a slightly refined construction was presented in @xcite ; it yields the following result .",
    "[ thm : alci ] for every omq @xmath743 from @xmath742 , one can construct an equivalent mddlog program @xmath16 such that    1 .",
    "the size of @xmath16 is bounded by @xmath760 ; 2 .",
    "the idb schema of @xmath16 is of size at most @xmath761 ; 3 .",
    "the rule size of @xmath16 is bounded by @xmath10    where @xmath10 and @xmath759 are the size of @xmath3 and and @xmath120 is a polynomial .",
    "the construction takes time polynomial in the size of @xmath16 .",
    "let @xmath746 be an omq from @xmath742 . instead of deciding fo- or mdlog - rewritability of @xmath746 , we can decide the same problem for the mddlog program delivered by theorem  [ thm : alci ] .",
    "the bounds stated in theorem  [ thm : alci ] , lemmas  [ lem : nonboolred1 ] and  [ lem : nonboolred2 ] , and theorems  [ th : mmsnptosimple ] and  [ th : simpletocsp ] , though , only guarantee that we obtain a csp template with 3-exponentially many elements , which does not yields 2nexptime upper bounds .",
    "however , it is possible to combine the construction underlying theorem  [ thm : alci ] with those underlying lemmas  [ lem : nonboolred1 ] and  [ lem : nonboolred2 ] and theorem  [ th : mmsnptosimple ] to construct from @xmath746 a simple mddlog program @xmath762 such that    1 .",
    "the size of @xmath762 and the cardinality of @xmath92 are bounded by @xmath760 and the arity of relations in @xmath92 is bounded by @xmath763 ; 2 .",
    "the idb schema of @xmath762 is of size @xmath761    where @xmath120 is a polynomial .",
    "in fact , this was already observed in @xcite where exactly the same constructions that are also used in lemmas  [ lem : nonboolred1 ] and  [ lem : nonboolred2 ] and theorem  [ th : mmsnptosimple ] are considered , see the proof of theorem  20 therein .",
    "constructing a csp template from this refined simple program and applying the decision procedures for rewritability of csp templates , we obtain the upper bounds stated in theorem  [ th : simpletocsp ] .",
    "we remark that it is not possible to extend theorem  [ thm : alcicompl ] to description logics with functional roles or number restrictions since , in such dls , fo - rewritability of omqs is undecidable @xcite ( the proof can be adapted to mdlog - rewritability ) .",
    "the results about the shape of rewritings stated in theorem  [ th : rewrshape2 ] ( of course ) also apply to the omq case .",
    "note that , in points  1 and  2 of that theorem , we can then replace @xmath14 with @xmath763 .",
    "moreover , the canonical dlog programs introduced for mddlog in section  [ sec : answer ] can also be utilized for omqs via the translation underlying theorem  [ thm : alci ] .",
    "regarding datalog - rewritability of omqs , we obtain a potentially incomplete decision procedure by combining theorem  [ thm : alci ] with lemmas  [ lem : nonboolred1 ] and  [ lem : nonboolred2 ] and the algorithm from section  [ sect : dlog - rewr ] .",
    "it is possible to define a class of omqs @xmath736 that _ have equality _ and for which this procedure is complete .",
    "roughly , @xmath52 needs to contain a relation @xmath310 and @xmath752 enforces that for all models @xmath764 of and all @xmath765 , @xmath766 and @xmath767 satisfy exactly the same subconcepts of and exactly the same tree - shaped queries that can be obtained from @xmath3 by identifying variables and then taking a subquery .",
    "we refrain from working out the details .",
    "we have clarified the decidability status and computational complexity of fo- and mdlog - rewritability in mmsnp , mddlog , and various omq languages based on expressive description logics and conjunctive queries . for datalog - rewritability , we were only able to obtain partial results , namely a sound algorithm that is complete only on a certain class of inputs and potentially incomplete in general .",
    "this raises several natural questions : is our algorithm actually complete in general ? does an analogue of lemma  [ lem : fogirthdontcare ] ( that is , rewritability on high girth implies rewritability ) hold for datalog as a target language ?",
    "what is the complexity of deciding datalog - rewritability in the afore - mentioned languages ? from an omq perspective , it would also be important to work towards more practical approaches for computing ( fo- , mdlog- , and dlog- ) rewritings .",
    "given the high computational complexities involved , such approaches might have to be incomplete to be practically feasible .",
    "however , the degree / nature of incompleteness should then be characterized , and we expect the results in this paper to be helpful in such an endeavour .",
    "* acknowledgement . *",
    "we thank libor barto , manuel bodirsky , and florent madeleine for helpful discussions .",
    "the authors were funded by erc grant 647289 .    10    serge abiteboul , richard hull , and victor vianu , editors . .",
    "addison - wesley longman publishing co. , inc . ,",
    "boston , ma , usa , 1st edition , 1995 .",
    "bogdan alexe , balder ten cate , phokion  g. kolaitis , and wang  chiew tan .",
    "characterizing schema mappings via data examples .",
    ", 36(4):23 , 2011 .",
    "alessandro artale , diego calvanese , roman kontchakov , and michael zakharyaschev .",
    "the dl - lite family and relations . , 36:169 , 2009",
    ".    albert atserias . on digraph coloring problems and treewidth duality . , 29(4):796820 , 2008 .",
    "franz baader , diego calvanese , deborah  l. mcguinness , daniele nardi , and peter  f. patel - schneider , editors . .",
    "cambridge university press , 2003 .",
    "libor barto .",
    "the collapse of the bounded width hierarchy .",
    ", 26(3):923943 , 2016 .",
    "michael benedikt , pierre bourhis , and michael vanden boom .",
    "a step up in expressiveness of decidable fixpoint logics . in _ proc .  of lics_. ieee computer society , 2016 .",
    "michael benedikt , balder ten cate , thomas colcombet , and michael vanden boom .",
    "the complexity of boundedness for guarded logics . in _ proc .  of lics _ , pages 293304 .",
    "ieee computer society , 2015 .",
    "meghyn bienvenu , thomas eiter , carsten lutz , magdalena ortiz , and mantas simkus .",
    "query answering in the description logic @xmath768 . in _ proc .  of dl2010",
    "_ , volume 573 of _ ceur workshop proceedings_. ceur-ws.org , 2010 .",
    "meghyn bienvenu , peter hansen , carsten lutz , and frank wolter .",
    "first order - rewritability and containment of conjunctive queries in horn description logics . in _ proc .  of ijcai _ , 2016 .",
    "meghyn bienvenu , carsten lutz , and frank wolter .",
    "first - order rewritability of atomic queries in horn description logics . in _ proc .  of ijcai _",
    ", 2013 .",
    "meghyn bienvenu and magdalena ortiz .",
    "ontology - mediated query answering with data - tractable description logics . in _ proc .  of reasoning web",
    "_ , volume 9203 of _ lncs _ , pages 218307 .",
    "springer , 2015 .",
    "meghyn bienvenu , balder ten cate , carsten lutz , and frank wolter .",
    "ontology - based data access : a study through disjunctive datalog , csp , and mmsnp .",
    ", 39(4):33:133:44 , 2014 .",
    "manuel bodirsky , hubie chen , and toms feder . on the complexity of mmsnp .",
    ", 26(1):404414 , 2012 .",
    "manuel bodirsky and vctor dalmau .",
    "datalog and constraint satisfaction with infinite templates .",
    ", 79(1):79100 , 2013 .",
    "pierre bourhis , markus krtzsch , and sebastian rudolph .",
    "reasonable highly expressive query languages . in _ proc .  of ijcai2015",
    "_ , pages 28262832 .",
    "aaai press , 2015 .",
    "pierre bourhis and carsten lutz .",
    "containment in monadic disjunctive datalog , mmsnp , and expressive description logics . in _ proc .  of kr _ , 2016 .",
    "andrei  a. bulatov , andrei  a. krokhin , and benoit larose .",
    "dualities for constraint satisfaction problems . in _ complexity of constraints - an overview of current research themes",
    "_ , volume 5250 of _ lncs _ , pages 93124 .",
    "springer , 2008 .",
    "diego calvanese , giuseppe de giacomo , domenico lembo , maurizio lenzerini , antonella poggi , mariano rodriguez - muro , and riccardo rosati .",
    "ontologies and databases : the dl - lite approach . in _ proc .  of reasoning web",
    "2009 _ , volume 5689 of _ lncs _ , pages 255356 .",
    "springer , 2009 .",
    "diego calvanese , giuseppe  de giacomo , domenico lembo , maurizio lenzerini , and riccardo rosati .",
    "tractable reasoning and efficient query answering in description logics : the dl - lite family .",
    ", 39(3):385429 , 2007 .",
    "hubie chen and benoit larose . asking the metaquestions in constraint tractability .",
    ", abs/1604.00932 , 2016 .",
    "gregory  l. cherlin , saharon shelah , and niandong shi .",
    "universal graphs with forbidden subgraphs and algebraic closure . , 22:454491 , 1999 .",
    "vctor dalmau and benoit larose .",
    "maltsev + datalog  > symmetric datalog . in _ proc .  of lics _ , pages 297306 .",
    "ieee computer society , 2008 .",
    "lszl egri , benoit larose , and pascal tesson .",
    "symmetric datalog and constraint satisfaction problems in logspace . in _ proc .  of lics _ ,",
    "pages 193202 .",
    "ieee computer society , 2007 .",
    "thomas eiter , magdalena ortiz , mantas simkus , trung - kien tran , and guohui xiao .",
    "query rewriting for horn - shiq plus rules .",
    "in _ proc .  of aaai_. aaai press , 2012 .",
    "toms feder and moshe  y. vardi .",
    "the computational structure of monotone monadic snp and constraint satisfaction : a study through datalog and group theory .",
    ", 28(1):57104 , 1998 .",
    "jrg flum and martin grohe . .",
    "texts in theoretical computer science . an eatcs series .",
    "springer , 2006 .",
    "georg gottlob , andreas pieris , and lidia tendera . querying the guarded fragment with transitivity . in _ proc .  of icalp2013",
    "_ , volume 7966 of _ lncs _ , pages 287298 .",
    "springer , 2013 .",
    "peter hansen , carsten lutz , inan seylan , and frank wolter .",
    "efficient query rewriting in the description logic el and beyond . in _ proc .",
    "of ijcai _ , 2015 .",
    "mark kaminski , yavor nenov , and bernardo  cuenca grau .",
    "computing datalog rewritings for disjunctive datalog programs and description logic ontologies . in _ proc .  of rr _ ,",
    "pages 7691 , 2014 .",
    "gbor kun .",
    "constraints , mmsnp and expander relational structures . , 33(3):335347 , 2013 .",
    "benoit larose , cynthia loten , and claude tardif .",
    "a characterisation of first - order constraint satisfaction problems . , 3(4 ) , 2007 .",
    "benoit larose and lszl zdori . bounded width problems and algebras .",
    ", 56(3):439466 , 2007 .",
    "florent  r. madelaine .",
    "universal structures and the logic of forbidden patterns . , 5(2 ) , 2009 .",
    "florent  r. madelaine . on the containment of forbidden patterns problems . in _ proc .",
    "of cp2010 _ , volume 6308 of _ lncs _ , pages 345359 .",
    "springer , 2010 .",
    "florent  r. madelaine and iain  a. stewart .",
    "constraint satisfaction , logic and forbidden patterns .",
    ", 37(1):132163 , 2007 .    jaroslav nesetril .",
    "many facets of dualities . in _ proc .  of workshop on combinatorial optimization _ , pages 285302 .",
    "springer , 2008 .",
    "jaroslav neetil and claude tardif .",
    "duality theorems for finite structures ( characterising gaps and good characterisations ) . , 80(1):8097 , 2000 .",
    "hctor prez - urbina , boris motik , and ian horrocks .",
    "tractable query answering and rewriting under description logic constraints .",
    ", 8(2):186209 , 2010 .",
    "riccardo rosati . on conjunctive query answering in @xmath4 . in _ proc .  of dl _ , pages 451458 , 2007 .",
    "benjamin rossman .",
    "homomorphism preservation theorems . , 55(3):15:115:53 , 2008 .",
    "sebastian rudolph and markus krtzsch . flag & check : data access with monadically defined queries . in _ proc .  of pods _ ,",
    "pages 151162 .",
    "acm , 2013 .",
    "despoina trivela , giorgos stoilos , alexandros chortaras , and giorgos  b. stamou .",
    "optimising resolution - based rewriting algorithms for owl ontologies . , 33:3049 , 2015 .",
    "let @xmath16 be a boolean mddlog program over schema @xmath52 and of diameter @xmath14 .",
    "we first construct from @xmath16 an equivalent boolean mddlog program @xmath769 such that the following conditions are satisfied :    1 .",
    "all rule bodies are biconnected , that is , when any single variable is removed from the body ( by deleting all atoms that contain it ) , then the resulting rule body is still connected ; 2 .",
    "if @xmath770 occurs in a rule body with @xmath80 edb , then the body contains no other edb atoms .    to construct @xmath769 , we first extend @xmath16 with all rules that can be obtained from a rule in @xmath16 by identifying variables",
    "; we will refer to this step as the _ collapsing step_. we then split up rules that are not biconnected into multiple rules by exhaustively executing the following rewriting steps :    * replace every rule @xmath771 where @xmath772 and @xmath773 share exactly one variable @xmath172 but both contain also other variables with the rules @xmath774 and @xmath775 , where @xmath746 is a fresh monadic idb relation and @xmath776 is the restriction of @xmath777 to atoms that are nullary or contain a variable from @xmath192 , @xmath778 ; * replace every rule @xmath771 where @xmath772 and @xmath773 share no variables and are both non - empty with the rules @xmath779 and @xmath780 , where @xmath781 is a fresh nullary idb relation and the @xmath776 are as above ; * replace every rule @xmath782 where @xmath80 is an edb relation and @xmath3 contains at least one edb atom and the variable @xmath172 , with the rules @xmath783 and @xmath784 , where @xmath746 is a fresh monadic idb relation .",
    "it is easy to see that the program @xmath769 is equivalent to the original program  @xmath16 .",
    "we next construct from @xmath769 the desired simplification @xmath115 of @xmath16 by replacing , in every rule , the edb atoms in the rule body with a single edb atom that represents the conjunction of all atoms replaced .",
    "we thus introduce fresh edb relations that represent conjunctions of old edb relations .",
    "note that there can be implications between the new edb relations that we will have to take care of in the construction of @xmath769 .",
    "let @xmath785 denote the set of cqs that can be obtained from a rule body in @xmath769 by consistently renaming variables , using only variables that occur in @xmath769 .",
    "let @xmath124 be the idb schema of @xmath769 .",
    "for every @xmath786 , we write @xmath787 to denote the restriction of @xmath788 to @xmath52-atoms , and likewise for @xmath789 and idb atoms .",
    "the edb schema @xmath92 of @xmath115 consists of the relations @xmath790 , @xmath786 , whose arity is the number of variables in @xmath788 ( which , by construction of @xmath769 , is identical to the number of variables in @xmath787 ) . the program @xmath115 consists of the following rules :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "whenever @xmath791 is a rule in @xmath769 , @xmath792 , and @xmath793 , then @xmath115 contains the rule @xmath794 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the case where @xmath795 is identical to @xmath796 corresponds to adapting rules in @xmath769 to the new edb signature and the other cases take care of implications between edb relations .",
    "[ ex : trans ] assume that @xmath769 contains the following rules , where @xmath797 and @xmath109 are edb relations : @xmath798 \\mn{goal } ( ) & \\leftarrow &     r(x_1,x_2 ) \\wedge r(x_2,x_3 ) \\wedge r(x_3,x_1 )    \\ , \\wedge \\\\[{0.5 mm } ]    & & p(x_1 )    \\wedge p(x_2 )    \\wedge p(x_3 ) \\end{array}\\ ] ] a new ternary edb relation @xmath799 is introduced for the edb body atoms of the lower rule , where @xmath800 , and a new ternary edb relation @xmath801 is introduced for the upper rule , @xmath802 .",
    "then the rules are replaced with @xmath803 \\mn{goal } ( )   & \\leftarrow &     r_{q_2}(x_1,x_2,x_3 )     \\wedge p(x_1 )    \\wedge p(x_2 )    \\wedge    p(x_3 )   \\\\[{0.5 mm } ] \\mn{goal } ( )   & \\leftarrow &     r_{q_1}(x_1,x_2,x_3 )     \\wedge",
    "p(x_1 )    \\wedge p(x_2 )    \\wedge    p(x_3 ) \\end{array}\\ ] ] note that @xmath804 implies @xmath805 , which results in two copies of the goal rule to be generated .",
    "proof details for the following lemma can be found in @xcite .",
    "recall that @xmath14 is the diameter of the original mddlog program @xmath16 .",
    "[ lem : instancesbackforth ]   +    1 .",
    "if @xmath28 is an @xmath52-instance and @xmath95 the corresponding @xmath92-instance , then @xmath116 iff @xmath117 ; 2 .   if @xmath95 is an @xmath92-instance and @xmath28 the corresponding @xmath52-instance , then 1 .",
    "@xmath117 implies @xmath116 ; 2 .",
    "@xmath116 implies @xmath117 if the girth of @xmath95 exceeds @xmath14 .",
    "[ ex2 ] consider the fragments of @xmath806 and @xmath115 from example  [ ex : trans ] . to understand the restriction to high girth instances in point  2b of lemma  [ lem : instancesbackforth ] , take the @xmath92-instance @xmath95 defined by @xmath807 the goal rules from the simplified program do not apply .",
    "but the corresponding @xmath52-instance contains the facts @xmath808 which are not covered by any edb atom in @xmath95 .",
    "clearly , the goal rule of @xmath16 applies .",
    "let @xmath16 be a simple mddlog program over edb schema @xmath52 and with idb schema  @xmath124 . for @xmath809 , an _",
    "i - type _ is a set @xmath684 of relation symbols from @xmath124 of arity at most @xmath82 that does not contain @xmath132 and that satisfies all rules in @xmath16 which use only idb relations of arity at most @xmath82 and do not involve any edb relations .",
    "we build a template @xmath810 for each 0-type @xmath59 .",
    "the elements of @xmath810 are exactly the 1-types that agree with @xmath59 on nullary idb relations .",
    "@xmath810 consists of the following facts :    1 .",
    "@xmath811 for each nullary @xmath812 .",
    "2 .   @xmath813 for each 1-type @xmath684 and each monadic @xmath814 ; 3 .",
    "@xmath815 for each relation @xmath68 and all 1-types @xmath816 such that @xmath16 does not contain a rule @xmath817 such that @xmath818 for @xmath819 , and @xmath820 .",
    "let @xmath821 .",
    "proof details for the following lemma can be found in @xcite .    for any @xmath52-instance @xmath28",
    ", we have @xmath116 iff @xmath822 .",
    "given a finite set of templates @xmath25 , it can be decided in whether cocsp@xmath223 is mdlog - rewritable .",
    "we first observe that it is possible to convert a generalised cocsp into an equivalent generalised cocsp whose templates are mutually homomorphically incomparable .",
    "this is done by first replacing the original templates by their cores and then getting rid of some of the cores in the case some of them map to others .",
    "this can easily be done in .    since mdlog - rewritability of cocsps is in @xcite and conjunctions of mdlog - queries",
    "are known to be mdlog - expressible , it now suffices to show that if a generalized cocsp with homomorphically incomparable templates is mdlog - rewritable , then each of the related templates is as well .",
    "assume that the generalized cocsp for a set @xmath823 of homomorphically incomparable templates is mdlog - rewritable , and let @xmath240 denote the mdlog - rewriting of cocsp(@xmath25 ) .",
    "consider a template @xmath824 .",
    "we will show that @xmath824 has a possibly infinite obstruction set consisting of finite instances of treewidth @xmath13 for some fixed @xmath14 .",
    "it then follows from theorem 23 of @xcite that the cocsp for @xmath824 is mdlog - rewritable .",
    "let @xmath14 be the maximum number of variables that occur in a single rule of @xmath240 .",
    "therefore , by the following standard argument from @xcite , we see that cocsp(@xmath25 ) has a possibly infinite obstruction set @xmath825 of instances of treewidth @xmath13 .",
    "indeed , let @xmath826 cocsp(@xmath25 ) , i.e. , @xmath827 holds for all templates @xmath28 of @xmath25 .",
    "thus @xmath828 , and therefore , by the semantics of datalog , there exists a finite derivation that corresponds to a finite instance @xmath829 of treewidth @xmath13 such that @xmath830 and @xmath831 .",
    "let @xmath832 .",
    "let @xmath833 denote the set of exactly all finite instances of treewidth @xmath13 that do not homomorphically map to @xmath824 .",
    "we will show that @xmath833 is an obstruction set for @xmath824 . as argued above",
    ", this suffices for concluding the proof .",
    "assume this is not the case .",
    "therefore there exists an instance @xmath282 such that one of the following conditions hold .",
    "* @xmath834 for some instance @xmath797 in @xmath833 . * @xmath835 for each instance @xmath797 in @xmath833 .",
    "we can immediately rule out the first condition above , because by definition the structures in @xmath833 should not map homomorphically to @xmath824 .",
    "thus there exists an instance @xmath836 such that @xmath837 for each @xmath838 .",
    "we will next argue that therefore the following conditionto be called _ condition _ ( @xmath839 ) belowholds .",
    "( @xmath839 )  for all instances @xmath840 of treewidth @xmath13 , if @xmath841 , then @xmath842 .",
    "assume for contradiction that there exists an instance @xmath840 of treewidth @xmath13 such that @xmath841 and @xmath843 .",
    "thus @xmath844 .",
    "therefore , since @xmath837 for each @xmath838 , we have @xmath845 , which is a contradiction . thus ( @xmath839 ) holds .    now consider the disjoint union @xmath846 .",
    "we have @xmath847 , and furthermore , we have @xmath848 for all templates",
    "@xmath849 of @xmath25 .",
    "therefore @xmath846 does not map homomorphically to any of the templates of @xmath25 , and thus there exists an instance @xmath850 of treewidth @xmath13 in the obstruction set @xmath825 of @xmath25 . since @xmath610 has treewidth @xmath13 , the condition ( @xmath839 ) tells us that the connected components of @xmath610 that map to @xmath282 must also map to @xmath824 . therefore @xmath851 .",
    "however , we have @xmath852 for each @xmath853 in @xmath25 ( including @xmath824 ) simply because @xmath610 belongs to the obstruction set @xmath825 of @xmath25",
    ". thus @xmath854 and @xmath851 , a contradiction .",
    "we restate the theorem for convenience .",
    "* theorem  [ th : rewrshape2 ] . *",
    "let @xmath16 be an @xmath22-ary mddlog program of diameter @xmath14",
    ". then    1 .",
    "if @xmath16 is fo - rewritable , then it has a ucq - rewriting in which each cq has treewidth @xmath13 with @xmath22 parameters ; 2 .",
    "if @xmath16 is rewritable into mdlog with parameters , then it has an mdlog - rewriting with @xmath22 parameters of diameter @xmath14 .",
    "we treat the two cases , fo - rewritability and mdlog - rewritability with parameters , in parallel in a uniform way . to achieve uniformity , recall that fo - rewritability coincides with ucq - rewritability by proposition  [ prop : ross ] and observe that a ucq - rewriting of relaxed treewidth @xmath13 can be converted into a non - recursive mdlog - rewriting with @xmath22 parameters of diameter @xmath14 and vice versa .",
    "we work with the latter .",
    "assume that an @xmath22-ary mddlog program @xmath16 over edb schema @xmath52 is rewritable into ( non - recursive ) mdlog with @xmath22 parameters .",
    "we can convert    1 .",
    "@xmath16 into a boolean mddlog programs @xmath855 with constants ( lemma  [ lem : nonboolred1 ] ) , 2 .",
    "@xmath855 into boolean mddlog programs @xmath856 without constants ( lemma  [ lem : nonboolred2 ] ) , 3 .",
    "@xmath856 into simple boolean mddlog programs @xmath857 ( theorem  [ th : mmsnptosimple ] and lemma  [ th : mmsnptosimple ] ) , and 4 .",
    "@xmath857 into csp templates @xmath858 ( theorem  [ th : simpletocsp ] )    such that all these programs and ( complements of ) templates are rewritable into ( non - recursive ) mdlog .",
    "moreover , in the proofs of the mentioned lemmas and theorems , it is shown how to construct ( non - recursive ) mdlog - rewritings of @xmath857 from given ones of @xmath858 , for @xmath856 from given ones of @xmath857 , and so on .",
    "we are going to analyze these constructions in more detail .",
    "we first note that for any ( non - recursive ) mdlog - rewritable csp , there is a ( non - recursive ) mdlog - rewriting where every rule body has at most one edb atom that contains all variables which occur in the rule body .",
    "since each program @xmath859 is actually _ equivalent _ to the complement of the csp template @xmath860 in step  4 , the same is true for the programs @xmath859 .",
    "thus , there is a ( non - recursive ) mdlog - rewriting @xmath861 of @xmath859 in which    * each rule body has at most one edb atom that contains all variables .    the translation of @xmath862 into @xmath859 in step  3 involves replacing the edb schema @xmath52 with an aggregation schema @xmath92 .",
    "more precisely , @xmath92 consists of relations @xmath863 where @xmath864 is obtained from a rule body in @xmath862 by first identifying variables , then splitting up the body into biconnected components , and finally dropping all idb relations . when translating the rewriting @xmath861 of @xmath859 into a rewriting @xmath865 of @xmath862 , this change in schema",
    "is reverted . by ( @xmath866 ) , the diameter of @xmath865",
    "is thus bounded by the arity of relations in @xmath861 and that arity , in turn , is bounded by the diameter of  @xmath862 .",
    "what s more important , though , is that we actually know what the rule bodies in @xmath865 look like :    * every rule body in @xmath865 is obtained from a rule body in @xmath862 by first identifying variables , then splitting up the body into biconnected components , then dropping all idb relations , and finally decorating with some fresh idb relations without introducing fresh variables .",
    "now consider the translation of @xmath608 into @xmath862 in step  2 and the corresponding translation of @xmath865 into a rewriting @xmath867 of @xmath608 . in the former , we dejoin rule bodies by ( sometimes ) replacing different occurrences of the same variable @xmath172 with different variables @xmath868 and adding the atoms @xmath869 and @xmath870 for some @xmath343 , thus increasing the diameter . in the latter , we rejoin the dejoined rules in @xmath865 in the sense that we replace variables @xmath557 with the same constant @xmath871 whenever the rule body contains the ( edb ) atoms @xmath699 and @xmath872 .",
    "it can be verified that rejoining any rule body of the form ( @xmath873 ) results in a rule body whose diameter is bounded by the diameter of @xmath862 .",
    "this gives the desired result since step  1 preserves diameter .",
    "a _ @xmath739-concept _ is formed according to the syntax rule @xmath874 where @xmath797 ranges over a fixed countably infinite set of _ concept names _ and @xmath109 over a fixed countably infinite set of _ role names_. an _",
    "-concept _ is an @xmath739-concept in which the constructors @xmath875 and @xmath876 are not used .",
    "an -tbox ( resp .",
    "-tbox ) is a finite set of concept inclusions @xmath877 , @xmath610 and @xmath282 @xmath878-concepts ( resp .- concepts ) .",
    "@xmath740-tbox _ is a finite set of    * _ concept inclusions _ @xmath877 , @xmath610 and @xmath282 @xmath740-concepts , * _ role inclusion _",
    "@xmath879 , @xmath109 and @xmath216 role names , and * _ transitivity statements _",
    "@xmath880 , @xmath109 a role name .",
    "dl semantics is given in terms of interpretations .",
    "an _ interpretation _ takes that form @xmath881 where @xmath882 is a non - empty set called the _ domain _ and @xmath883 is the _ interpretation function _ which maps each concept name @xmath797 to a subset @xmath884 and each role name @xmath109 to a binary relation @xmath885 .",
    "the interpretation functions is extended to concepts in the standard way , for example @xmath886     ( \\exists r^- .",
    "c)^\\imc & = & \\ { d \\in \\delta^\\imc \\mid \\exists",
    "e \\in                              c^\\imc : ( e , d ) \\in r^\\imc \\}. \\end{array}\\ ] ] we refer to standard references such as @xcite for full details .",
    "an intepretation is a _ model _ of a tbox if it _",
    "satisfies _ all statements in , that is ,      in description logic , data is typically stored in so - called aboxes . for uniformity with mddlog , we use instances instead , identifying unary relations with concept names , binary relations with role names , and disallowing relations of any other arity .",
    "an interpretation is a _ model _ of an instance @xmath28 if @xmath893 implies @xmath894 and @xmath895 implies @xmath896 .",
    "we say that an instance @xmath28 is _ consistent _ with a tbox if @xmath28 and have a joint model .",
    "we write @xmath897 if every model of satisfies @xmath890 .",
    "an _ ontology - mediated query ( omq ) _ takes the form @xmath743 with a tbox , @xmath52 a set of concept and role names , and @xmath3 a ucq .",
    "we use @xmath898 to refer to the set of all omqs whose tbox is formulated in the language and where the actual queries are from the language . for example , @xmath8 refers to the set of all omqs that consist of an -tbox and a ucq . for omqs @xmath899 from @xmath900 , we adopt the following additional restriction : when contains a transitivity @xmath880 and @xmath897 , we disallow the use of @xmath216 in the query @xmath3 .",
    "let @xmath28 be an @xmath52-instance and @xmath901 a tuple of constants from @xmath28 .",
    "we write @xmath902 and call @xmath901 a _ certain answer to @xmath746 on _ @xmath28 if for all models of @xmath28 and  , we have @xmath903 ( defined in the usual way ) ."
  ],
  "abstract_text": [
    "<S> we study rewritability of monadic disjunctive datalog programs , ( the complements of ) mmsnp sentences , and ontology - mediated queries ( omqs ) based on expressive description logics of the family and on conjunctive queries . </S>",
    "<S> we show that rewritability into fo and into monadic datalog ( mdlog ) are decidable , and that rewritability into datalog is decidable when the original query satisfies a certain condition related to equality . </S>",
    "<S> we establish @xmath0-completeness for all studied problems except rewritability into mdlog for which there remains a gap between @xmath0 and 3exptime . </S>",
    "<S> we also analyze the shape of rewritings , which in the mmsnp case correspond to obstructions , and give a new construction of canonical datalog programs that is more elementary than existing ones and also applies to formulas with free variables . </S>"
  ]
}