{
  "article_text": [
    "the first part of the document describes the reasoning which led us to the construction of the current form of the qspn v2 . if you are just interested in the description of the qspn v1 and v2 and you already know the concept of the tracer packet , you can directly skip to section [ sec : ctp ] .",
    "the aim of netsukuku is to be a ( physical ) scalable mesh network , completely distributed and decentralised , anonymous and autonomous .",
    "the software , which must be executed by every node of the net , has to be unobtrusive .",
    "it has to use very few cpu and memory resources , in this way it will be possible to run it inside low - performance computers , like access points , embedded devices and old computers .",
    "if this requirements are met , netsukuku can be easily used to build a worldwide distributed , anonymous and not controlled network , separated from the internet , without the support of any servers , isps or control authorities .",
    "netsukuku prioritises the stability and the scalability of net : the network has to be able to grow to even @xmath2 nodes .",
    "a completely dynamic network would requires rapid and frequent updates of the routes and this is in contrast with the stability and the scalability requirements of netsukuku . for this reason ,",
    "we restrict netsukuku to the case where a node wo nt change its physical location quickly or often .",
    "this assumption is licit , because the location of a wifi node mounted on top of a building wo nt change and its only dynamic actions would be the joining and the disconnection to and from the network and the changes of the quality of its wifi links .",
    "however , there are some consequences of this assumption :    1 .",
    "mobiles node are nt supported by netsukuku algorithms . ) . ] 2 .",
    "the network is nt updated quickly : several minutes may be required before all the nodes become aware of a change of the network ( new nodes have joined , more efficient routes have become available ,  ) . however ,",
    "when a node joins the network , it can reach all the other nodes from the first instant , using the routes of its neighbours .",
    "one of the most important parts of netsukuku , is the routing discovery algorithm , which is responsible to find all the most efficient routes of the network .",
    "these routes will permit to each node to reach any other node .",
    "the routing algorithm must be capable to find the routes without overloading the network or the nodes cpu and memory resources .",
    "netsukuku implements its own algorithm , the _ qspn _ ( * * q**uantum * * s**hortest * * p**ath * * n**etsukuku ) .",
    "the name derives from the way of working of its principal component : the _ tp _ ( tracer packet ) , a packet which gains a `` quantum '' of information at each hop .",
    "the qspn is based on the assumptions described in section [ sec : net_model ] .",
    "the qspn alone would nt be capable of handling the whole network , because it would still require too much memory .",
    "for example , even if we store just one route to reach one node and even if this route costs one byte , we would need 1 gb of memory for a network composed by @xmath3 nodes ( the current internet ) .",
    "for this reason , it s necessary to structure the network in a convenient topology .",
    "netsukuku , adopts a fractal like structure : 256 nodes are grouped inside a _ group node _ ( gnode ) , 256 group nodes are grouped in a single _ group of group nodes _ ( ggnode ) , 256 group of group nodes are grouped in a gggnode , and so on .",
    "( we wo nt analyse the topology of netsukuku .",
    "you can find more information about it in the proper document : @xcite ) .",
    "since each gnode acts as a single real node , the qspn is able to operate independently on each level of the fractal .    since in each level",
    "there are a maximum of 256 ( g)nodes , the qspn will always operate on a maximum of 256 ( g)nodes , therefore we would need just to be sure that it works as expected on every cases of a graph composed by @xmath4 nodes . by the way , we ll directly analyse the general case .    for the sake of simplicity , in this paper , we will assume to operate on level 0 ( the level formed by 256 single nodes ) .",
    "a _ tp _ ( tracer packet ) is the fundamental concept on which the qspn is based : it is a packet which stores in its body the ids of the traversed hops .",
    "a tp is nt sent to a specific destination but instead , it is used to flood the network . by saying `` the node a sends a tp '' we mean that `` the node a is starting a tp flood '' .",
    "a tp flood passes only once through each node of the net : a node which receives a tp will forward it to all its neighbours , except the one from which it received the tp .",
    "once a node has forwarded a tp , it will not forward any other tps of the same flood .      1 .",
    "a node @xmath5 which received a tp , can know the exact route covered by the tp .",
    "therefore , @xmath5 can know the route to reach the source node @xmath6 , which sent the tp , and the routes to reach the nodes standing in the middle of the route .",
    "+ for example , suppose that the tp received by @xmath5 is : @xmath7 . by looking at the packet @xmath5",
    "will know that the route to reach @xmath8 is @xmath9 , to reach @xmath10 is @xmath11 , and finally to reach @xmath6 is @xmath12 .",
    "the same also applies for all the other nodes which received the tp , f.e , @xmath8 knows that its route to reach @xmath6 is @xmath13 .",
    "the _ bouquet of @xmath6 _ is the set of all the tps which will be forwarded or sent by the node @xmath6 during the flood .",
    "the first tp of this bouquet received by a generic node @xmath5 , will be the tp which covered the fastest route which connects @xmath6 to @xmath5 .",
    "the fastest @xmath14 route is the route with the minimum _ rtt _ ( round - trip time ) between @xmath6 and @xmath5 .",
    "this property is also valid if @xmath6 is the node which started the tp flood , i.e. the first node which sent the first bouquet of the tp flood .",
    "suppose that @xmath5 sends a tp .",
    "the tp will cover this routes : @xmath15 and @xmath16 .",
    "when the tp reaches the node @xmath17 and the node @xmath10 , the flood will stop , because either @xmath10 and @xmath17 wo nt be able to forward the tp to any other node .    at the end , @xmath10 will know the route @xmath18 and @xmath17 will know the route @xmath19 .",
    "given a graph @xmath20 we want to find all the existing routes between a node and all the other nodes .",
    "let @xmath21 be a generic node .",
    "starting from @xmath21 we explore the entire graph until we re - enter in a cycle already visited or we can not proceed any further . this approach is similar to the depth - first search@xcite algorithm , but instead of searching for a specific goal , we just traverse the entire graph .",
    "note that a cycle is traversed only once , because we need non redundant routes .",
    "in other words , if we already know the @xmath22 route , it s useless to known that we can reach @xmath5 with the @xmath23 route .",
    "this is the pseudo code of the algorithm :    .... generate_routes(g ) {          forall node in g                  / * starts the exploration of the graph from the `` node '' of the                     graph `` g '' and print all its routes * /                  walk(node , node ) }    / * print all the routes which start from the node ` n ' * / walk(n , branch ) {          deepened=0            forall l in n.links                  / * l is a neighbour of n * /                    if(l in branch )                          / * if `` l '' is already contained in the explored                             branch , we 've found a cycle .",
    "since we just need to                             traverse only once a cycle , we skip this `` l '' node                             and continue to consider the other neighbours                             of n * /                          continue ;                    newbranch = branch + l     / * append in the explored branch the                                             `` l '' node . *",
    "/                    walk(l , newbranch )       / * recursively   explore the new                                             branch * /                                   / * indicate that we 've deepened in the graph at least once * /                  deepened=1            if(!deepened )                  / * we haven't deepened in the above for , this means that the                     current branch ca n't be explored anymore , therefore it is a                     valid route",
    ". print it * /                  print branch } ....    a proof of concept of the above algorithm has been implemented in awk @xcite .",
    "consider this graph :        given this graph as input the algorithm will output : [ sec : genroute_output ] @xmath24",
    "we can consider each route given by the output of the above algorithm as a single tracer packet .",
    "in fact , it is possible to implement the same algorithm using a slightly modified version of the tp flood , called the acyclic tp flood :    the flood is not restricted like in a normal tp flood : one or more atp can pass from the same node .",
    "the end of the flood is given by this rule : a node will not forward to any of its neighbours the atp if its node i d is already present in the route contained in the body of the packet . with this rule",
    "an atp can walk in a cycle only once , hence the name .",
    "finally , like in the normal tp , a node does nt forward the atp to the neighbour from which it has received the packet itself .",
    "if every node of the network sends an atp flood , then every node will get all the possible routes to reach any other node .",
    "as you can see , the atp flood performs a `` live '' version of the algorithm described in section [ sec : gen_routes ] .",
    "obviously this is far from an efficient routing discovery algorithm , but it represents a good start .",
    "looking carefully at the example output ( [ sec : genroute_output ] ) of the generate route algorithm , we can notice that many routes are higly redundant , in other words , some routes are almost the same .",
    "consider for example the following four routes : @xmath25    as we ve seen in the previous section [ sec : acyclic_tp_flood ] , we can consider these routes as effective tracer packets . in this example , the tp ( 1 ) cover the same route of the tp ( 2 ) .",
    "therefore we can save one tp by just sending the tp ( 1 ) , which will traverse the route ( 2 ) too .",
    "the tp ( 3 ) covers part of the tp ( 4 ) , thus we can simplify the two of them by just sending a tp which cover this route : @xmath26 .    continuing in this process",
    "we can further simplify the two tp : @xmath27    thus , from the initial four tps we ve found a unique tp which gives the same routes of the original ones .",
    "we can derive some rules to simplify routes .    since we can represent a route as a string where each symbol is a node",
    ", we can also describe the routes simplification as a series of operations on strings .    in the following rules , each letter found in an expression represents a generic string , which may be also the null string , f.e .",
    "the `` @xmath28 '' string can be anything like @xmath29 or @xmath30 .",
    "+ the @xmath31 expression represents a cycle , where the @xmath32 character refers to just one node , and not to an entire string .",
    "xy+yz @xmath33 xyz : :    if two routes share respectively the ending and the starting part ,    they can be merged into a unique route .",
    "example :    @xmath34 yxz + x @xmath33 yxz : :    example : @xmath35 xc ",
    "c + xcy @xmath33 xc  cy : :    example : @xmath36 c  cz + ycz @xmath33 yc  cz : :    example : @xmath37 c  c + ycz @xmath33 yc  cz : :    example : @xmath38 invalid route : :    [ sec : simroute_invalid ] a route must not be in the form of :    @xmath39 where @xmath40 and @xmath32 are    two nodes . a simplification , which gives a route of this form , is not    considered valid . this is because a tp must not change its verse while    traversing a network .    all these rules can be applied recursively to the routes of a graph , until they can not be simplified anymore .",
    "a proof of concept of the above algorithm has been implemented in awk @xcite .      simplifying all the routes of the example [ sec : genroute_output ] ,",
    "we obtain just these two tps : @xmath41    you can verify that all the routes listed in [ sec : genroute_output ] are contained in these two simplified tps .      by looking at many different simplifications , we can recognize some general rules :    1 .   for each tp",
    "there has to be its inverse .",
    "for example , if there s a tp which covered the route @xmath42 , then there has to be at least the tp which covers the inverse route @xmath43 .",
    "2 .   in a segment , to give all the routes to all the nodes , it is sufficient that the two extremes sends a tp .",
    "example : +    + in this case , if @xmath10 and @xmath17 send a tp , all the routes will be generated , since the two tp would be : @xmath44 and @xmath45 .",
    "you can verify that in these two tp , there are contained all the routes of the segment .",
    "3 .   in a cycle ,",
    "just two tp are needed , and one is the reverse of the other .",
    "the first can be constructed in this way : * choose a node of the cycle , this will be the pivot node . *",
    "start from one neighbour of the pivot and write sequencially all the other nodes until you return to the pivot ( but do not include it ) .",
    "call this string @xmath46 .",
    "* the tp will be : @xmath47 where @xmath48 is the pivot node .",
    "+ example : +    + if we choose the node @xmath5 as the pivot , we can write the tp as : @xmath49 and its reverse : @xmath50 these two tps will give all the routes to all the nodes of the cycle .",
    "can we implement a `` live '' version of the simplify route algorithm like we did with the generate route one ? +",
    "the reply is ahead .",
    "a continuous tracer packet ( ctp ) is an extension of the tp flood : a node will always forward a tp to all its neighbours , excepting the one from which it has received the tp .",
    "if a node is an extreme of a segment , i.e. a node with just one link , it will erase the route stored in the body of the tp and will forward back the tp .    in short ,",
    "a ctp is a tp flood which will never end , thus it will continue to explore all the infinite combination of routes .      consider this graph .",
    "if @xmath10 sends a ctp flood , there will be two ctps that will explore respectively these routes : @xmath51 @xmath52      suppose that the node @xmath21 has just one link .",
    "@xmath21 , before back forwarding the received ctp , erases the route contained in the body , because the nodes preceding it , already know this same route .",
    "+ for example , consider this segment : @xmath53 if @xmath21 had nt erased the route received in the ctp , @xmath10 would have received the following ctp : @xmath54 this packet contains the route @xmath55 , which is invalid , as explained in section [ sec : simroute_invalid ] .",
    "the valid parts of the packet are : @xmath56 and @xmath57 .",
    "for this reason , when @xmath21 receives the first part , it will send a new , empty ctp .",
    "the second version of the qspn ] can be described in a single phrase :    _ a continuous tracer packet will continue to roam inside _    _ the network until it carries interesting information .",
    "_      a node considers a received ctp interesting when its body contains at least a new route , i.e. a route that the node did nt previously know . in other words , if a ctp contains routes already known by the node , it is considered uninteresting .",
    "when a node receives an interesting ctp , it forwards the packet to all its neighbours , excepting the one from which it has received the ctp .",
    "if , instead , the ctp is uninteresting , it will drop the packet .    note that if a ctp is uninteresting for the node @xmath21 , then it is also uninteresting for all the other nodes .",
    "this is because an uninteresting ctp contains routes which has been previously received , memorised and forwarded by the node @xmath21 .",
    "therefore all the other nodes already know the same routes too .",
    "consider this graph .",
    "suppose that @xmath10 sends a ctp .",
    "the two ctps , after having covered the following two paths will stop : @xmath58 @xmath59 let s analyze the first ctp step by step , considering that before @xmath10 sent the ctp , none knew any route .",
    "a @xmath60 b : :    at this point @xmath8 does nt know any route to reach    @xmath10 , therefore it considers this ctp as interesting and    forwards it to @xmath46 .",
    "a @xmath60 b @xmath60 c : :    by looking at this packet @xmath46 learns a route to reach    @xmath8 and @xmath10 .",
    "a @xmath60 b @xmath60 c @xmath60 a : :    the node @xmath10 learns a route to reach @xmath46 .",
    "a @xmath60 b @xmath60 c @xmath60 a @xmath60 b : :    the node @xmath8 learns a route to reach @xmath46 .",
    "a @xmath60 b @xmath60 c @xmath60 a @xmath60 b @xmath60 c : :    finally , @xmath46 drops the packet , because it already knows    all the routes contained in it .    from this example we can derive a general result : a ctp will always terminate in a cycle .",
    "the qspn v2 is the `` live '' version of the simplify route algorithm ( section [ sec : simplify_routes ] ) .",
    "the ctp flood of the qspn v2 explores the entire graph , but unlike the atp ( section [ sec : acyclic_tp_flood ] ) , it drops the tps which contains redundant routes , thus only the simplified , non redundant routes survives and continue to explore the graph .",
    "when a ctp reaches the extremity of a segment , it is back forwarded , thus it s as if the extreme nodes had a link with themselves .        from the point of view of a ctp ,",
    "even a segment is a cycle , therefore , for a ctp , any connected graph is formed just by cycles .",
    "for this reason , a ctp will explore any combination of cycles of the graph .",
    "these examples highlights some subcycles of a simple graph .",
    "a ctp would explore all these cycles .",
    "@xmath61 will finish the exploration of the graph in a finite amount of time , i.e. the flood will terminate .    as we ve seen in the example [ sec : cycle_qv2_example ]",
    ", a ctp flood of a cycle will always terminate .",
    "moreover in section [ sec : ctp_ciclicity ] we ve noticed that , from the point of view of a ctp , any connected graph is formed by a combination of cycles .",
    "therefore , a ctp flood of a graph will always terminate in a finite amount of time .",
    "even if @xmath61 is finite , it still generates too many routes and packets .",
    "therefore we need to limit the exploration of the graph . +",
    "an efficient and elegant solution is to further define what the `` interesting information '' is :    let each node of the network keep a maximum of _ maxroutes _ routes in its memory .",
    "a node considers a received ctp interesting when its body contains at least a route which is more efficient than the previously memorised routes .",
    "the efficiency of a route can be quantified with a convenient parameter , f.e .",
    "the rtt or the bandwidth capacity .",
    "if the node has reached the _ maxroutes _ limit , it will substitute the old route with the more efficient one .",
    "note that this definition is more general than the previous . indeed ,",
    "if the node @xmath6 does nt know the route to reach @xmath5 , the efficiency of the route @xmath62 is equal to @xmath63 .",
    "a node can also keep in memory more than _ maxroutes _ routes , because this limit applies only to the number of routes which will be used to evaluate the received ctp .",
    "we will now exploit the bouquet property of the tracer packets , which has been described in section [ sec : proprieties_tp ] .",
    "suppose that in our network every link has the same bandwidth capacity and that the generic node @xmath5 does nt know any route to reach the node @xmath64 .",
    "if a tp , received by the node @xmath5 , contains a new route @xmath65 that connects @xmath66 , then we can deduce , by the bouquet property , that @xmath65 is the fastest route between @xmath5 and @xmath64 .",
    "the immediate consequence is that @xmath5 will receive all the other @xmath67 routes in order of efficiency : the first is , as we ve seen , the best route , the second one will be slower than the first but surely better than any other , and so on .",
    "two different routes can be very similar , because they can differ only in a small part .",
    "two routes which differs of just one hop , are almost identical . for this reason , other than the best @xmath68 route , the ctp will also explore all the other routes which are almost identical to it .    we can thus order all the tps which @xmath5 will receive into classes .",
    "the first class , denoted with @xmath69 $ ] , contains the tp which have covered the best route and all the others similar to it , i.e. all the other routes with the same number of hop and a similar trtt ( total round trip time ) .",
    "the second class @xmath70 $ ] , contains the tp which have covered routes which are less efficient than those contained in @xmath69 $ ] but are more efficient than those of class @xmath71 $ ] .",
    "more generally we can say that the @xmath72 $ ] class contains the routes that , if included in a list of all the routes of the graph , ordered in decrescent order of efficiency , will be listed starting from the position @xmath73 . where @xmath32 is the numbers of routes contained in each class .    in the classes we are including _ routes _ and not _",
    "tracer packets _ , because a tp may contain more than one route .",
    "each node of the graph acts as a filter for all the subcycles containing it .",
    "suppose the node @xmath5 is contained in the subcycle @xmath74 and that a ctp @xmath65 enters in it ( through another node ) . if the node @xmath5 has the _ maxroutes _ limit set , it will memorise , for each node of the network , only the first _ maxroutes _ received routes , while the rest will be disregarded , and * not * forwarded .",
    "+ the ctp @xmath65 wo nt be forwarded by the node @xmath5 , if it contains routes which exceed the _ maxroutes _ limit , but this is true for all the nodes of @xmath74 , therefore @xmath65 wo nt even be able to escape from the subcycle @xmath74 . however , this also means that all the ctps , which are in a higher class than that of @xmath65 , wo nt be allowed to pass from @xmath74 .",
    "+ since this happens for all the subcycles of the graph , we can conclude that at worst , the number of ctps increases in polynomial time with the increase of subcycles .",
    "consider this graph .",
    "let s analyse the difference between a ctp without limits and the same ctp with _",
    "maxroutes _ set .",
    "unlimited ctp : :    @xmath10 sends a ctp .",
    "suppose for simplicity that this ctp    wo nt loop inside a cycle .",
    "+    @xmath5 receives @xmath75 packets from @xmath10 ,    @xmath76 @xmath77 from @xmath5 and finally    @xmath78 @xmath79 from @xmath5 .",
    "+    @xmath78 sends back all the received ctps , thus @xmath76    gets @xmath80 ctps from @xmath78 , @xmath5 gets    @xmath81 and finally @xmath10 receives    @xmath82 packets .",
    "obviously this is too much for this    simple graph .",
    "limited ctp : :    let s use @xmath83 and suppose that    the ctp wo nt loop inside a cycle .",
    "we ll write @xmath84    to indicate that @xmath5 received @xmath85 ctps from    the node @xmath10 but has kept and forwarded only    @xmath86 packets .",
    "+    @xmath10 sends a ctp .",
    "+    @xmath87 at the end , a gets @xmath88    packets .",
    "+    each node forwards @xmath89 packets , where @xmath48    is the number of received ctps .",
    "this is because the first two packets    give to the node a new route , while the other two , and the successive    ones , cover a superflous route .",
    "for example , consider    @xmath90 the underlined routes are the new route for    @xmath76 .",
    "as you can see , in the ctp ( 10 ) g does nt find any    new route , so it drops the packet and does nt forward it .",
    "we ve noted in section [ sec : scalability ] that any node will receive the ctps in order of efficiency , thus we are sure that only the first _ maxroutes _ received routes ( which point to a specific node ) are meaningfull , while all the successive ones are uninteresting and should be dropped .",
    "this is important , because each node will first receive _ maxroutes _ interesting routes and * then * the uninteresting ones , that will be dropped .",
    "doing so , an uninteresting route wo nt be forwarded before its interesting correspondent , and as soon it is recognised it will be dropped .    to clarify this concept",
    "suppose that the routes are nt received in order of efficiency and that @xmath91 .",
    "then suppose that node @xmath5 does nt have any route yet and receives a ctp of class @xmath92 $ ] .",
    "@xmath5 will consider this ctp as interesting and forward it , because it s the first one it receives .",
    "+ in conclusion , the ctp of class @xmath92 $ ] would be allowed to be propagated among the network even if the _ maxroutes _ has been set to @xmath75 routes . instead",
    ", if @xmath5 receives the packet in an ordered manner , it will first get the ctps of class @xmath69 $ ] , then those of class @xmath70 $ ] and so on .",
    "for this reason the ctp of class @xmath92 $ ] . and all the other which exceed the _ maxroutes _ limit , wo nt be allowed to pass from @xmath5 .",
    "until now we ve supposed that every link of the network has the same bandwidth capacity .",
    "however , we ll see in section [ sec : bandwidth_q1q2 ] that the qspn can be used in the general case .",
    "the graph , formed by @xmath85 nodes , which has the maximum number of cycles is the worst case for @xmath61 , because , if not limited , it will have to explore any combination of cycles .",
    "such graph is the _ complete graph _",
    "@xcite , and the total number of its subcycles is : @xmath93",
    "the qspn v1 is a restricted case of @xmath61 .",
    "it is divided in two phases .",
    "the first one is called qspn_close : a node sends a qtp ( qspn tracer packet ) called qclose , this node becomes a qspn starter .",
    "a qclose is a modified form of tracer packet . a node @xmath21 , which receives a qclose from the link @xmath94 , marks as `` closed '' the same link @xmath94 and forwards the packet to all its other neighbours .",
    "all the following qclose packets received by the same node @xmath21 , will be forwarded only to the links which have not been already closed .",
    "+ during the graph exploration , some nodes will close all their links .",
    "these nodes are called _",
    "extreme nodes_. when a node becomes an extreme node , it will send another type of tracer packet , called qspn_open ( which is also the name of the second phase ) to all its neighbours , except the one from which it received the last qclose packet ( let s call this neighbour @xmath78 ) .",
    "the qopen packet sent to @xmath78 is empty , while those sent to the other neighbours contains the body of the last received qclose packet . + the qopen behaves as the qclose : it `` opens '' the links , however the nodes which have all their links opened wo nt forward any other packets .",
    "+ * example : *        consider figure [ fig : q1ex ] .",
    "* the node @xmath95 sends a qclose .",
    "it is now a qspn starter . *",
    "suppose that the node a receives the qclose before @xmath46 .",
    "@xmath10 closes the link @xmath96 and forwards the qclose to @xmath8 , @xmath46 and @xmath5 .",
    "* @xmath46 receives the qclose from @xmath95 , closes the link @xmath97 and forwards it to a and @xmath5 .",
    "* @xmath46 receives the qclose from @xmath10 and closes the link . * @xmath8 and",
    "@xmath5 have received from @xmath10 the qclose and close the respective links . *",
    "suppose that @xmath8 is the first to forwards the qclose to @xmath17 .",
    "* @xmath5 forwards the qclose to @xmath17 , but at the same time @xmath17 forwards it to @xmath5 .",
    "* @xmath5 receives the qclose from @xmath8 , too .",
    "* @xmath5 and @xmath17 have all the links closed .",
    "they send a qopen . *",
    "the qopen propagates itself in the opposite sense . *",
    "the qopen ends .",
    "each node has the routes to reach all the other nodes .",
    "the qspn_close phase can be seen as a ctp with the added rule that when two ctps collide , they will be converted to two normal tps ( the qopen phase ) .",
    "these are the substantial differences between q ( qspn v1 ) and @xmath61 ( qspn v2 ) :    1 .",
    "q generates less packets than @xmath61 , because in the qopen phase it uses normal tps which expires quickly .",
    "the side effect of this behaviour is that q may not discover all the best routes .",
    "however q gives at least one route to reach each node of the graph .",
    "q uses less memory than @xmath61 , because it just keeps a forwarding table , instead , @xmath61 needs to memorize @xmath100 complete routes to evaluate the successive ctps . by the way",
    ", this difference is minimal .",
    "3 .   @xmath61 does nt need synchronization .",
    "the ctps does nt need to have an i d , thus many nodes can send simultaneously or asynchronously a ctp without creating any problem . +",
    "this is nt the same in q , which requires a strict synchronization between the nodes : two nodes can send a qclose only at the same time .",
    "this is a consequence of the propriety described above : every time a node joins the net or dies or its rtt / bw capacity changes , it is possible to immediately send a ctp . indeed ,",
    "if the changes in the local gnode regard that node only , the ctp will be like a normal tracer packet ( see [ sec : tp_flood ] ) .",
    "@xmath61 is easier and simpler than q to be implemented . in general",
    "this means that the code of @xmath61 will have less bugs .    from this comparison",
    "we can conclude that @xmath61 is preferable over q.",
    "the qspn v2 defined until now is not suitable for dynamic networks .",
    "as example , consider this problem :    suppose that the whole graph has been already explored , and thus every node has at least one route to reach all the other nodes .",
    "consider the case when the efficiency of a link , f.e .",
    "@xmath101 , worsens .",
    "@xmath21 , in order to update the maps of the other nodes , sends a ctp to its neighbour @xmath102 , and @xmath102 forwards it to its neighbours . however this ctp will be immediately dropped !",
    "indeed , the nodes will consider this ctp not interesting , because the contained @xmath103 route is less efficient than the old one , which has been saved during the last graph exploration .",
    "the etp solves the problem of how the graph should be re - explored to update the maps of the nodes interested to a network change .",
    "its way of working is based on a simple observation :    the first qspn exploration distributes , among the nodes , information describing the network topology .",
    "when a change in the network occurs , only the information stored in the nodes affected by the change must be updated .",
    "the unaffected nodes will still have up to date information that they can simply redistribute with the use of the extended tracer packets .",
    "an etp is an acyclic tracer packet , ) is a normal tp with the following rule : a node drops the received atp if its node i d is already present in the route contained in the body of the packet .",
    "note also , that since it is a normal tp , it is not reflected back , when it reaches the end of a segment . ] which contains a portion of a map .",
    "since a map is a set of routes and a route can be described by a tp , the etp can be considered as different tps packed togheter .",
    "each tp of the etp is then subjected to the rules of the qspn v2 .    in order to give an exact definition of an etp , we must examine each case of network change .",
    "worsened link : :    [ wlink ] suppose that the link @xmath104 worsens .",
    "+    let s analyse what @xmath8 will do ( the situation is symmetric    for @xmath10 ) .",
    "+    @xmath8 , if interested in the change , will create an etp    containing all its old routes , affected by the change , and all the    backup routes used as substitute for the old ones .",
    "the etp will be    sent to all its neighbours , except @xmath10 .",
    "in detail ,    @xmath8 will use the following algorithm :    +    1 .",
    "if at least one of the primary routes is called primary if it is among the    first maxroutes routes of type src@xmath105 saved    in the map of @xmath8 and different from the route    @xmath106 , uses the link @xmath94 , then    @xmath8 creates an empty etp , otherwise the algorithm halts ,    i.e. @xmath8 wo nt do anything .    2 .   [ upmap ]",
    "if the empty etp has been created , @xmath8 updates    its maps : suppose that the route @xmath107 , passing through the    link @xmath94 , had a total rtt @xmath108 .",
    "if the rtt    of the link @xmath94 before the change was @xmath109    and now is @xmath110 , where @xmath111 ,    then @xmath112 .",
    "+    for the bandwidth we have : @xmath113 the routes are then sorted .    3 .   [ stepr ]",
    "@xmath8 creates the temporary set @xmath114 ,    containing all the primary routes passing through the link    @xmath94 . from @xmath114",
    "it creates the set    @xmath115 , where    @xmath116    where @xmath117 is the set of all the primary routes of the map ,    and @xmath118 is the destination of the route    @xmath107 .",
    "in other words , @xmath115 is the set of primary    routes having the same destination of at least one route of    @xmath114 . note that @xmath119 .",
    "each route    @xmath120 is saved as    @xmath121 ,    where @xmath122 is the route efficiency measure ,    and @xmath123 is a bitmask of 256 bits , where    the bit at the i - th position indicates if the node i is an hop of the    route @xmath107 .",
    "@xmath8 fills the etp :    1 .",
    "it adds in it the set @xmath115    2 .",
    "it appends the i d of @xmath10 , along with the efficiency    value of the link @xmath94 , and , as usual , its i d .    3 .",
    "it sets to 1 the _ flag of interest_.    5 .",
    "finally , @xmath8 sends the etp to all its neighbours ,    except @xmath10 .",
    "+    [ etprule1 ] suppose that the neighbor @xmath46 of    @xmath8 has received the etp .",
    "@xmath46 will examine the    etp and , if considered interesting , it will update its map and forward    the etp to the other neighbours , as follow :    +    1 .",
    "if the i d of the node @xmath46 is already present in the    received etp , then @xmath46 immediately drops the etp , and    skips all the following steps .    2 .",
    "let @xmath115 be the set of routes contained in the etp    received by @xmath46 .",
    "+    let @xmath117 be the set of all primary routes contained in the    map of @xmath46 .",
    "+    for each route @xmath120 , the node @xmath46 looks    for a route @xmath124 such that    @xmath125    if @xmath126 exists , then @xmath46 sets    @xmath127 . with    @xmath107 , in the map @xmath117 ] otherwise ,    @xmath107 is copied in the temporary set @xmath129 .",
    "+    @xmath117 is sorted , i.e. the routes of the map of    @xmath46 are sorted in order of efficiency .    3 .   for all @xmath130 ,    1 .",
    "if @xmath131 is a better alternative to at least one    primary route @xmath132 such that    @xmath133 , then    @xmath131 is saved in the map of @xmath46    ( note of the etp in the    map , we must consider the hops covered by the etp , so the real saved    route is    @xmath134 .",
    "in this case we ll    have @xmath135 . ] ) ,    2 .",
    "otherwise , @xmath131 is removed from @xmath115 .",
    "+    note    4 .",
    "if @xmath115 is now empty , i.e. all its routes have been    removed , then @xmath46 considers the etp as uninteresting .",
    "let s suppose for now that it is interesting : the _ flag of interest _    remains set to 1 .",
    "@xmath46 packs the etp with the previously modified set    @xmath115 , and adds its i d .",
    "the etp is sent to all its    neighbours , except @xmath8    +    the rnodes of @xmath46 will use this same procedure . in this    way , the etp will continue to be propagated until it is considered    interesting .",
    "+    let s suppose now that a node @xmath21 receives the etp and    considers it uninteresting .",
    "@xmath21 wo nt just drop the etp ,    but will also send back another etp containing its own routes .",
    "the    reason is simple : @xmath21 considers the received etp    uninteresting , this means that @xmath21 is nt affected by the    change of the link @xmath94 , i.e. all its primary routes do nt    pass through @xmath94 and thus are still optimal .",
    "therefore ,    @xmath21 will send back its routes , hoping that they will be    useful to the nodes affected by the change . in detail , this is what    will happen when @xmath21 receives the etp :    +    1 .",
    "@xmath21 receives the etp from the node @xmath78 ,    and considers it uninteresting .    2 .",
    "let @xmath115 be the set of routes contained in the etp .",
    "+    let @xmath117 be the set of all primary routes contained in the    map of @xmath21 .",
    "+    @xmath21 creates the following set :    @xmath136    3 .",
    "@xmath21 creates the new etp , appending in it the set    @xmath6 and its i d .",
    "the _ flag of interest _ of this etp is set    to 0 .",
    "the etp is sent to @xmath78 .",
    "+    at this point , the new etp created by @xmath21 , will propagate    back in the same fashion of the previous etp ( see page ) , i.e. until    considered interesting .",
    "the only difference is that when a node    considers it uninteresting , it is just dropped .",
    "a node dies : :    suppose the node @xmath10 dies .",
    "each neighbour @xmath8    of @xmath10 will send an etp .",
    "the etps are generated and    propagated with the algorithms described in the * worsened link * case    ( page ) , the differences are :    +    1 .   instead of considering the routes passing through the worsened    link we consider the routes passing from the dead node .",
    "suppose that the node @xmath21 receives the etp from its    neighbour @xmath78 and considers it uninteresting .",
    "@xmath21 sends back to @xmath78 the new etp to share its    routes among the interested node .",
    "however , unlike the case for the    worsened link , @xmath21 creates also a new simple tp , where it    writes only the information of the death of @xmath10 .",
    "@xmath21 sends this tp to all its neighbours , except    @xmath78 .",
    "+    this simple tp will be propagated with the rules of the qspn v2 . for    this reason and",
    "since it carries only one useful information ( the    death of @xmath10 ) , each node will receive it just once ( the    second time it will be dropped ) .",
    "this simple tp serves to inform the    nodes , unaffected by the network change , of the death of    @xmath10 .",
    "improved link : :    [ ilink ] suppose that the link @xmath104 improves .",
    "+    let s examine the events , starting from @xmath10 , keeping in    mind that the situation is symmetric for @xmath8 .",
    "+    since the link @xmath94 improved , it may be possible for    @xmath8 to use it to improve some of its routes .",
    "for this    reason , @xmath10 will send to it an etp with all the routes of    its map , except those of the form    @xmath137 .",
    "if    @xmath8 finds something of interest , it will forwards the etp .    in detail",
    ":    +    1 .",
    "let @xmath117 be the set of all primary routes contained in    the map of @xmath10 .",
    "+    @xmath10 creates the following set :    @xmath138 where    @xmath139 is the first hop of the route    @xmath126 .",
    "each route @xmath120 is saved as    @xmath140 .",
    "@xmath10 creates the etp :    1 .",
    "it writes in it the set @xmath115    2 .",
    "it appends the its node i d , along with the efficiency value of the    link @xmath94 .    3 .",
    "it sets to 1 the _ flag of interest_.    3 .",
    "it sends the etp to @xmath8    +    at this point , the etp is propagated exactly in the same way of the    * worsened link * case ( see page ) .",
    "a new node joins : :    suppose the node @xmath10 is joining the network .",
    "its    neighbours are @xmath141 , which are all    already hooked , i.e. they are nt joining . then ,    +    1 .",
    "each neighbour @xmath142 sends its whole map to    @xmath10    2 .",
    "@xmath10 waits until the maps of all its neighbours are    received .",
    "the maps are `` merged '' into a single map , which becomes the map    of @xmath10 . in simple words ,",
    "the merge of two maps result in a    map having only the best routes of the two .",
    "if the neighbours of @xmath10 are more than one , i.e.    @xmath143 , then @xmath10 sends , to each of them , an etp    containing all the primary routes of its map .    5 .",
    "the etps are propagated exactly in the same way of the * worsened    link * case ( see page ) .    +    note",
    "that this case extends the hooking procedure . broken link : :    the case where the link @xmath104 becomes invalid , is handled    in the same way of the * worsened link * case ( see page ) , because we    can consider @xmath94 as infinitely worsened .",
    "new link : :    the case where a new link    @xmath144 is established    between , is handled in the same way of the * improved link * case ( see    page ) , because we can consider @xmath94 as infinitely    improved .",
    "the bandwith capacity of a route can be used as a parameter of its efficiency . in this section",
    "we ll analyse the implications for the qspn . for more information about the bandwidth management in netsukuku you can read the ntk_rfc 002 @xcite .",
    "each node of the network will delay the forwarding of a received ctp by a time inversely proportional to its upload bandwidth . in this way",
    "the ctps will continue to be received in order of efficiency ( see section [ sec : eff_order ] ) .",
    "the side effect of this rule is that the extreme cases will be ignored , i.e. a route with a very low rtt but with a very poor bw , or a route with an optimal bw but with a very high rtt .",
    "however , in the `` real world '' these extreme cases are rare , because the rtt and the bw are often related .",
    "the qspn v2 is a very flexible algorithm that can be adapted to a large range of cases . indeed , with a minimal added overhead , it is possible to achieve asymmetric routing discovery , i.e. a discovery that discerns the upload bandwidth of a route from its download one .",
    "+ we call this extension the _ asymmetric qspn v2 _ , while we refer to the old one as _",
    "symmetric @xmath61_.    1 .   first of all",
    ", it is necessary to define further the `` interesting information '' .",
    "a ctp will be considered interesting , not only when it contains interesting ( see [ sec : interesting_info ] ) download routes , but also upload ones . in other words",
    ", we consider the upload sense of a route too .",
    "+ for example , suppose that the node @xmath10 received the ctp @xmath145 .",
    "in this case @xmath10 will know two dinstinct upload routes : @xmath146 and @xmath147 . instead , in the classic ctp",
    ", @xmath10 would have known only @xmath148 and @xmath149 .",
    "2 .   secondly",
    ", since we are considering the reverse ( upload ) routes too , we have to remove the restriction imposed on the ctp , which has been described in section [ sec : reflected_ctp ] .",
    "the body of the ctp reflected from the extreme of a segment wo nt be erased , thus it will contain the old routes too .",
    "this is because the old routes can contain interesting information about upload routes .",
    "for example , consider this segment : @xmath53 if @xmath21 does nt erase the route received in the ctp , @xmath10 will receive the following ctp : @xmath54 in this case @xmath10 will know the following upload route : @xmath150 when parsing a ctp , a node will recognize the part of the routes which are in the form of @xmath151 , where @xmath40 , @xmath32 are two nodes and @xmath152 and @xmath153 are two generic routes .",
    "the packet will then be split in @xmath154 and @xmath155 .    at this point",
    "we ve finished .",
    "in fact , we are sure to receive at least one upload route per node because a ctp traverses each path first in one sense and then in the opposite . the ctp information filter , will allow us to receive only the best routes .",
    "however , since the rtt delay ( [ sec : rtt_delay ] ) is tuned for download routes only , it is possible that some upload paths will be ignored . + it is interesting to note that in the majority of cases , the number of ctps will remain equal to that of the symmetric @xmath61 .",
    "the routing table of each node should be differentiated , i.e. it should not contain redundant routes .",
    "for example , consider these @xmath14 routes : @xmath156 the first two are almost identical , indeed they differ only in the first three hops .",
    "the last two are , instead , totally different from all the others .",
    "+ since the first two routes are redundant , the node @xmath6 should keep in memory only one of them , saving up space for the others non - redundant routes .",
    "keeping redundant routes in the routing table is nt optimal , because if one of the routes fails , then there s a high probability that all the other redundant routes will fail too .",
    "moreover when implementing the multipath routing to load balance the traffic there wo nt be any significative improvements .",
    "@xmath61 itself should avoid to spread redundant routes . in order to achieve this result",
    ", we refine the efficiency value associated to a route .",
    "suppose we want to affect the efficiency value @xmath157 assigned to the route @xmath115 :    1 .",
    "let @xmath158 be the similarity level of the route @xmath115 with @xmath6 .",
    "2 .   for each memorised route",
    "@xmath6 we compute @xmath159 and if we find a route @xmath6 such that @xmath160 we go to step 3 .",
    "we set @xmath161 where @xmath162 is an appropriate coefficient .    as explained in section [ sec : routes_limit ] the efficiency of a route is used as a parameter to evaluate its interest , therefore the more a route is similar to a memorised route the more its efficiency will decrease . hence it will be considered less interesting .",
    "+ note that this is a generalization of concept of interesting route defined in section [ sec : routes_limit ] , in fact , when @xmath115 and @xmath6 are equal , we ll have @xmath163 so the @xmath157 value will be equal to @xmath63 .",
    "a node could easily forge a tp , injecting in the network false routes and links information .",
    "the attack would just create a temporary local damage , thanks to the distributed nature of the qspn .",
    "however the optimal solution is to prevent these attacks . + a node , whenever joins netsukuku , generates a new rsa key pair .",
    "the continuous generation of keys prevents the leakage of the node s anonymity .",
    "the node shares its public key to all the other nodes of its group node .",
    "+ each entry appended in a tp is then signed with its private key , doing so the other nodes will be able to prove its authenticity and validate the path covered by the tp . + the size required to store the signatures in the tp can be kept costant using the aggregate signature system @xcite @xcite .",
    "as a proof of concept , we ve a written the q2sim.py@xcite , a simulator implementing the core of the qspn v2 . +",
    "the q2sim is an event - oriented discrete event simulator .",
    "each ( event , time ) pair is pushed in a priority queue .",
    "the main loop of the program retrieves from the queue the event having the lowest ` time ' value .",
    "this `` popped '' event is executed . in this case , the events are the packets sent on the network .",
    "in this paragraph we ll analyze the results of various simulations .",
    "tp flux : :    the _ tp flux _ of a node @xmath85 , is the number of    distinct has @xmath164 neighbours , it receives    only two tps and sends only a new one , then    @xmath165 , but @xmath166 . ]",
    "tp    packets which have been forwarded by @xmath85 during the entire    qspn exploration",
    ". it is indicated with @xmath167 .",
    "mean tp flux : :    given @xmath162 nodes @xmath168 , their mean    tp flux is :    @xmath169 starter node : :    a starter node is a node which sends the first tp in a graph , not yet    explored by the @xmath61 .",
    "there can be more than one    simultaneous starter node .",
    "in all the following tests the _ maxroutes _ limit has been set to 1 .",
    "+ as a general result , the mean tp flux is proportional to the number of subcycles present in the graph .",
    "thus the maximum mean tp flux is reached in a complete graph , where each node is connected to all the others . in a complete graph of @xmath162 nodes the mean",
    "tp flux is approximately : @xmath170 the figure below shows this result . in the @xmath171 axis",
    ", an integer point corresponds to the number of nodes of the complete graph .",
    "the adjacent points of the graph have been connected with straight line segments .",
    "[ fig : k_one_starter ]     by increasing the number of starter nodes the mean tp flux increases slightly until it reaches @xmath172 . indeed ,",
    "if all the nodes of the graph are starters , then each of them will send a tp to all the other nodes .",
    "the increasing of the number of starter nodes decreases the time required to complete the exploration of the graph .",
    "the figure below shows this result . in the @xmath171 axis",
    ", an integer point corresponds to the number of starter nodes .",
    "each plotted line corresponds to a complete graph with different number of nodes .",
    "the first bisector has been plotted to facilitate the reading of the graph .",
    "[ fig : k_starters ]     the complete graph is the worst case for the @xmath61 , therefore in the general case the mean tp flux will be : @xmath173 where @xmath85 is the number of nodes of the graph .",
    "for example , in random graphs with increasing number of nodes , the mean tp flux will assume the distribution shown in the figure below :    [ fig : rone_starter ]     the same happens for a mesh graph . the mesh graph used in the simulations is a square grid where every intersection represents a node .",
    "+ if the graph is uniformly connected , as in the case of a mesh graph , then the distribution of single tp fluxes is uniform too .",
    "the majority of single tp fluxes are near to the mean tp flux , while the highest tp fluxes are shared between different nodes , i.e. there are nt few unlucky nodes which have to bear a high tp flux . in the following figure , we can observe the tp flux distribution of two different qspn exploration of a mesh graph with @xmath174 nodes . in the @xmath171 axis",
    ", an integer point corresponds to a single node of the graph .",
    "adjacent points are connected by a straight line .",
    "+    [ fig : c - dist ]     in the first exploration , plotted in red , the starter node ( node 40 ) and the eight nodes surrounding him ( node 50,51,52,28,29,30,39,41 ) have the highest tp flux .",
    "the tp flux decreases with the increase of the distance from the starter node . since the graph is a @xmath174 grid ,",
    "there are @xmath175 classes where the tp flux falls and for this reason in the graph there are exactly @xmath175 slopes .",
    "the nodes with lower tp fluxes are those with the least number of links , i.e. the nodes on the edge of the mesh , which have only 3 links ( and not 4 ) .",
    "the four nodes at the vertices of the grid ( node 0,10,110,120 ) , which have just 2 links , register the lowest tp flux .",
    "+ the second exploration , plotted in blue , simulates the scenario where 32 links of the graph change and consequently the interested nodes send a new ctp to inform the other nodes and update their maps .",
    "as supposed , the mean tp flux ( 26.80 ) is heavily lower than that of the initial exploration ( 82.90 ) , because the majority of routes are already known by the nodes .",
    "even the execution time is lower ( 2.6s vs 3.5s ) .",
    "note that this scenario is the most common in real world , because in general , the nodes wo nt join or die at once , but progressively .",
    "1 .   the @xmath61 must be implemented in the ntkd daemon .",
    "2 .   improve , test and implement the caustic routing : http://lab.dyne.org/ntk_caustic_routing[rfc 0013 ] 3 .",
    "research a `` mobile qspn ''",
    "* ` april 2007 ` * * new section : `` network dynamics '' ( [ sec : netdyn ] ) * * description of the etp ( sec .",
    "[ sec : etp ] ) * * link i d section remove . with the etp they are no more necessary . *",
    "* more detailed description of the qspn v1 ( sec .",
    "[ sec : qspnv1 ] ) * * subsection `` qspn v2 - high levels '' removed .",
    "it was redundant with the topology document@xcite * ` october 2006 ` + initial release",
    ".    99 netsukuku website : http://netsukuku.freaknet.org/ netsukuku topology document : http://netsukuku.freaknet.org/doc/main_doc/topology.pdf[topology.pdf ] depth - first search : http://en.wikipedia.org/wiki/depth-first_search generate routes in awk : + http://cvs.hinezumi.org/viewcvs/netsukuku/proto/doc/qspn/generate_routes.awk[generate_routes.awk ] simplify routes in awk : + http://cvs.hinezumi.org/viewcvs/netsukuku/proto/doc/qspn/simplify_routes.awk[simplify_routes.awk ] qspn v2 simulator : + http://cvs.hinezumi.org/viewcvs/netsukuku/proto/doc/qspn/q2sim.py[q2sim.py ] complete graph : + http://mathworld.wolfram.com/completegraph.html[http://mathworld.wolfram.com/ ] network simulator : + http://www-mash.cs.berkeley.edu/ns/ ntk_rfc 002 : http://lab.dyne.org/ntk_bandwidth_measurement[bandwidth measurement ] a survey of two signature aggregation techniques : + http://crypto.stanford.edu/~dabo/abstracts/aggsurvey.html[http://crypto.stanford.edu/  dabo / abstracts / aggsurvey.html ] aggregate and verifiably encrypted signatures from bilinear maps : + http://crypto.stanford.edu/~dabo/abstracts/aggreg.html[http://crypto.stanford.edu/  dabo / abstracts / aggreg.html ]"
  ],
  "abstract_text": [
    "<S> this document describes the qspn , the routing discovery algorithm used by netsukuku . through a deductive analysis the main proprieties of the qspn </S>",
    "<S> are shown . moreover , </S>",
    "<S> a second version of the algorithm , is presented .    </S>",
    "<S> this document is part of netsukuku . </S>",
    "<S> + copyright 2007 andrea lo pumo aka alpt @xmath0alpt@freaknet.org@xmath1 . </S>",
    "<S> all rights reserved .    </S>",
    "<S> this document is free ; you can redistribute it and/or modify it under the terms of the gnu general public license as published by the free software foundation ; either version 2 of the license , or ( at your option ) any later version .    </S>",
    "<S> this document is distributed in the hope that it will be useful , but without any warranty ; without even the implied warranty of merchantability or fitness for a particular purpose . </S>",
    "<S> see the gnu general public license for more details .    </S>",
    "<S> you should have received a copy of the gnu general public license along with this document ; if not , write to the free software foundation , inc . , 675 mass ave , cambridge , ma 02139 , usa . </S>"
  ]
}