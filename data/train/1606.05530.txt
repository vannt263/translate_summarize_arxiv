{
  "article_text": [
    "fining @xcite is a new share package for gap @xcite .",
    "it is designed to provide an environment to explore various finite geometrical structures , such as projective spaces , affine spaces , classical polar spaces , coset geometries and their diagrams and generalised polygons ; allowing an integrated use of the automorphism groups and exploring geometrical relations between different geometries via incidence preserving morphisms .",
    "the use of automorphism groups is connected with the existing primary functionality of gap as a computer algebra package chiefly concerned with computing with groups .",
    "the algebraic power of gap is especially exploited when finite fields are involved , and when considering affine and projective algebraic varieties .",
    "our package interfaces with the packages grape @xcite and design @xcite which is especially useful when working with generalised polygons and purely combinatorial incidence structures .",
    "the representation of an automorphism group of a projective space relies on an implementation of collineations of a projective space as semilinear maps of the underlying vector space , and this is done in conjunction with the packages genss and orb @xcite that provide sophisticated algorithms for enumeration of orbits , stabilisers , and stabiliser chains .",
    "finally the package forms @xcite enables us to provide the user with the possibility to construct classical polar spaces from a user - defined sesquilinear or quadratic form , computing the necessary coordinate transformations on the fly .",
    "this approach results in a user - friendly and intuitive package providing generic functionality for exploring the most commonly studied finite incidence structures and their automorphism groups .",
    "other good systems are available for incidence geometry but often focus on the efficient handling of particular cases , rather than on the generic approach which is central in fining .",
    "the system magma @xcite , for example , is renown as a system for computational group theory .",
    "it contains an implementation of projective planes , some substructures , coset geometries and related functionality .",
    "the computation of the automorphism group of a projective plane is done very efficiently , however , it is always returned as a permutation group on the points of the plane .",
    "the creation of a coset geometry is based on a given permutation group , which is very efficient , but which makes it more difficult for the user to use , for example , matrix groups occurring from ( say ) the automorphism group of a classical polar space . for the student starting with finite incidence geometry , or the ( experienced ) researcher interested in exploring a particular incidence structure using a computer",
    ", this approach might be a hurdle .",
    "this explains the basic philosophy of fining : to construct an incidence structure ( together with an automorphism group ) in its natural representation , where the user decides what _ natural _ actually means ! for example , a conic with a particular equation can easily be constructed , or a coset geometry arising from a matrix group or finitely presented group instead of a permutation group .",
    "once objects in a certain category have been constructed , their behaviour is independent of their representation .",
    "furthermore , many well studied geometries are considered in their standard representation , together with straight - forward methods for switching from one representation to another .",
    "[ source , gap ] ---- gap > map : = kleincorrespondence(7 ) ; < geometry morphism from < lines of projectivespace(3 , 7 ) > to   < points of q+(5 , 7 ) : x_1*x_6+x_2*x_5+x_3*x_4=0 > > gap > r : = range(map ) ; < points of q+(5 , 7 ) : x_1*x_6+x_2*x_5+x_3*x_4=0 > gap > hyp : = ambientgeometry(r ) ; q+(5 , 7 ) : x_1*x_6+x_2*x_5+x_3*x_4=0 gap > klein : = hyperbolicquadric(5,7 ) ; q+(5 , 7 ) gap > equationforpolarspace(klein ) ; x_1*x_2+x_3*x_4+x_5*x_6 gap > map : = kleincorrespondence(klein ) ; < geometry morphism from < lines of projectivespace(3 , 7 ) > to < points of q+(5 , 7 ) > > gap > morphism : = isomorphismpolarspaces(hyp , klein ) ; < geometry morphism from < elements of q+(5 , 7 ) : x_1*x_6+x_2*x_5+x_3*x_4=0 > to   < elements of q+(5 , 7 ) > > ----    [ source , gap ] ---- gap >",
    "l : = simpleliealgebra(\"e\",6,rationals ) ; < lie algebra of dimension 78 over rationals > gap > rs : = rootsystem(l ) ; < root system of rank 6 > gap > w : = weylgroup(rs ) ; < matrix group with 6 generators > gap > gens : = generatorsofgroup(w ) ; ; gap > parabolics : = list(gens , x - > group(difference(gens , [ x ] ) ) ) ; [ < matrix group with 5 generators > , < matrix group with 5 generators > ,     < matrix group with 5 generators > , < matrix group with 5 generators > ,     < matrix group with 5 generators > , < matrix group with 5 generators > ] gap > g : = group(gens ) ; < matrix group with 6 generators > gap > cg : = cosetgeometry(g , parabolics ) ; cosetgeometry ( group ( [ [ [ -1 , 0 , 1 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 0 , 0 , 0 ] ,         [ 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 ] ] ,     [ [ 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , -1 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 1 , 0 , 0 , 0 ] ,         [ 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 ] ] ,     [ [ 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 0 , 0 ] , [ 1 , 0 , -1 , 1 , 0 , 0 ] ,         [ 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 ] ] ,     [ [ 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 0 , 0 , 0 ] ,         [ 0 , 1 , 1 , -1 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 1 ] ] ,     [ [ 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 0 , 0 , 0 ] ,         [ 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 1 , -1 , 1 ] , [ 0 , 0 , 0 , 0 , 0 , 1 ] ] ,     [ [ 1 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 0 , 0 , 0 ] ,         [ 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 1 , -1 ] ] ] ) ) ----    example  [ ex : klein ] illustrates the klein correspondence ( between the lines of a @xmath0-dimensional projective space and the points of a hyperbolic quadric in @xmath1 dimensions ) .",
    "the example shows the default behaviour and the possibility to employ a user - defined form for the klein quadric .",
    "example  [ ex : e6 ] , illustrates the construction of an apartment in a building of type @xmath2 , based on existing gap functionality of root systems and lie algebras .",
    "first of all , a set of new data structures , which are type in gap by the so - called _ categories _ , is provided in fining , summarized as follows .    * fining incidence geometries have their category , together with elementary operations . * finite projective spaces , classical finite polar spaces , and some classical generalized polygons are incidence geometries whose elements are represented by sub spaces of a vector space over a finite field .",
    "they are called lie geometries in fining .",
    "more particular operations are applicable on such geometries .",
    "as explained in the introduction , the user is free to choose a representation for a lie geometry .",
    "* generalised polygons are particular examples of point - line incidence geometries .",
    "many examples in many different representations exist .",
    "fining provides a generic category , together with some particular operations , allowing the user to construct in a very natural way their desired geometry . *",
    "coset geometries can be constructed from any group in their own category . * finally affine spaces",
    "can also be constructed as objects in their dedicated category .",
    "the automorphism groups of lie geometries are naturally represented by semi - linear maps on the underlying vector space .",
    "fining provides category for such maps acting on the projective space .",
    "groups generated by such maps can be constructed , functions representing the action on elements of a lie geometry are provided , and actions can be computed , including nice monomorphisms . this part of fining is the direct link between the automorphism groups of lie geometries and the available gap operations for permutation groups .",
    "secondly fining provides efficient operations to compute orbits and ( setwise ) stabilisers of projective semilinear groups .",
    "these operations are based on the use of the packages orb , genss and cvec . also from the algorithmic point of view",
    ", fining provides efficient methods to enumerate the the elements of finite classical polar spaces .",
    "geometry morphisms can be constructed .",
    "this is especially powerfull combined with field reduction .",
    "we follow @xcite for the definitions of incidence structure and incidence geometry . an _ incidence structure _ @xmath3 consists of a set of elements , a reflexive and symmetric relation @xmath4 on the elements and a type function from the set of elements to an index set ( i.e. , every element has a `` type '' ) .",
    "it satisfies the following axiom :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \\(i ) no two different elements of the same type are incident . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    if we forget the type function , an incidence structure is just a multipartite graph where adjacency is incidence . note that every element is incident with itself , so there is a loop on each vertex .",
    "the type function turns the graph into a coloured graph .",
    "assume that @xmath3 is an incidence structure with type function @xmath5 with range @xmath6 .",
    "then we say that @xmath3 has rank @xmath7 .",
    "flag _ is a set @xmath8 of elements of @xmath3 such that every two elements contained in @xmath8 are incident .",
    "necessarily , @xmath8 can not contain two elements of the same type , so @xmath8 contains at most @xmath7 elements .",
    "we call a flag _ maximal _ when no element of @xmath3 is incident with all elements of @xmath8 , unless it is already contained in @xmath8 .",
    "the term geometry , or incidence geometry , is interpreted broadly in this package .",
    "particularly , an _ incidence geometry _ is an incidence structure satisfying the following axiom :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \\(ii ) every maximal flag contains an element of each type . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in graph terminology , this means that every maximal clique contains an element of each colour .",
    "let @xmath3 be an incidence structure of rank @xmath7 , and let @xmath9 be an element of type @xmath10 .",
    "let @xmath11 .",
    "then the _ @xmath12-shadow of @xmath9 _ is the set of elements of type @xmath12 incident with @xmath9 .",
    "let @xmath8 be a flag of @xmath3 then the _ @xmath12-shadow of @xmath8 _ is the set of elements of type @xmath12 incident with all elements in @xmath8 .",
    "the _ residue of @xmath8 _ is the set of all elements of @xmath3 not in @xmath8 but incident with all elements of @xmath8 , together with the induced geometrical structure .",
    "hence , the residue of a maximal flag of an incidence geometry is empty .",
    "all geometries that can be constructed in fining are incidence structures .",
    "this terminology is consistently used , as illustrated in example  [ ex : cosetelements ] for an `` abstract '' coset geometry and example  [ ex : elements_proj ] for a projective space .",
    "[ source , gap ] ---- gap >",
    "involset:=[(1,2 ) , ( 1,3 ) , ( 3,4 ) , ( 4,5 ) , ( 4,6 ) , ( 6,9 ) , ( 6,10 ) , ( 7,10 ) , ( 8,10 ) ] ; ; gap >",
    "g:=group(involset ) ; ; gap > parabolics : = list(involset , i - > subgroup(g , difference(involset , [ i ] ) ) ) ; ; gap > img:=cosetgeometry(g , parabolics ) ; cosetgeometry ( group ( [ ( 1,2 ) , ( 1,3 ) , ( 3,4 ) , ( 4,5 ) , ( 4,6 ) , ( 6,9 ) , ( 6,10 ) , ( 7,10 ) , ( 8,10 ) ] ) ) gap > elements_type_2",
    ": = elementsofincidencestructure(img,2 ) ;   < elements of type 2 of cosetgeometry ( group (   [ ( 1,2 ) , ( 1,3 ) , ( 3,4 ) , ( 4,5 ) , ( 4,6 ) , ( 6,9 ) , ( 6,10 ) , ( 7,10 ) , ( 8,10 ) ] ) ) > gap > el2 : = random(elements_type_2 ) ; < element of type 2 of cosetgeometry ( group (   [ ( 1,2 ) , ( 1,3 ) , ( 3,4 ) , ( 4,5 ) , ( 4,6 ) , ( 6,9 ) , ( 6,10 ) , ( 7,10 ) , ( 8,10 ) ] ) ) > gap > shad : = shadowofelement(img , el2,3 ) ; < shadow elements of type 3 in cosetgeometry ( group (   [ ( 1,2 ) , ( 1,3 ) , ( 3,4 ) , ( 4,5 ) , ( 4,6 ) , ( 6,9 ) , ( 6,10 ) , ( 7,10 ) , ( 8,10 ) ] ) ) > gap > el3 : = random(shad ) ;",
    "< element of type 3 of cosetgeometry ( group (   [ ( 1,2 ) , ( 1,3 ) , ( 3,4 ) , ( 4,5 ) , ( 4,6 ) , ( 6,9 ) , ( 6,10 ) , ( 7,10 ) , ( 8,10 ) ] ) ) > gap > isincident(el2,el3 ) ; true gap > flag : = flagofincidencestructure(img,[el2,el3 ] ) ; ; gap > shad : = shadowofflag(img , flag,4 ) ; < shadow elements of type 4 in cosetgeometry ( group (   [ ( 1,2 ) , ( 1,3 ) , ( 3,4 ) , ( 4,5 ) , ( 4,6 ) , ( 6,9 ) , ( 6,10 ) , ( 7,10 ) , ( 8,10 ) ] ) ) > ----    [ source , gap ] ---- gap > pg : = pg(5,7 ) ; projectivespace(5 , 7 ) gap >",
    "rank(pg ) ; 5 gap > line : = random(lines(pg ) ) ; < a line in projectivespace(5 , 7 ) > gap > shadowplanes : = shadowofelement(pg , line,3 ) ; # planes are type 3 <",
    "shadow planes in projectivespace(5 , 7 ) > gap > plane : = random(shadowplanes ) ; < a plane in projectivespace(5 , 7 ) > gap > planepoints : = shadowofelement(pg , plane,1 ) ; # planes are type 1 < shadow points in projectivespace(5 , 7 ) > gap > p : = random(planepoints ) ; < a point in projectivespace(5 , 7 ) > gap > flag : = flagofincidencestructure(pg,[p , plane ] ) ; < a flag of projectivespace(5 , 7 ) > gap > shadowlines : = shadowofflag(pg , flag,2 ) ; < shadow lines in projectivespace(5 , 7 ) > ----",
    "example  [ ex : elements_proj ] brings us to the lie geometries . a _",
    "lie geometry _",
    ", is an incidence geometry whose automorphism group is a ( subgroup of ) a group of lie type in its natural representation .",
    "one common fact about lie geometries is that their elements are represented by subspaces of a vector space .",
    "all the collineations are induced by semilinear maps of the underlying vector space .",
    "so a finite lie geometry is a geometry for which the elements are subspaces of some projective space over a finite field , and with symmetrised set - theoretic containment as incidence .",
    "hence , a lie geometry is naturally embedded in a projective space .",
    "these principles are used in fining to implement lie geometries .",
    "currently the following lie geometries are readily implemented in fining :    * projective spaces , * classical polar spaces , and , * the so - called classical generalised hexagons and octagons .    elements of lie geometries are also called _",
    "subspaces_. subspaces have a ( projective ) dimension , and subspaces of projective dimension @xmath13 are called points , lines , planes , solids , respectively . in fining the default type set",
    "is @xmath14 and the type of an element is its projective dimension plus one .",
    "some handy shortcuts for the operation ` shadowofelements ` are implemented , so that given a point @xmath15 , ` lines(p ) ` is equivalent with ` shadowofelement(pg , p,2 ) ` .",
    "basic operations such as ` meet ` and ` span ` , illustrated in example  [ ex : proj_els ] , rely on operations to deal with subspaces of the underlying vector space of the lie geometry .",
    "[ source , gap ] ---- gap > pg : = pg(8,9 ) ; projectivespace(8 , 9 ) gap > elementsofincidencestructure(pg,1 ) ; < points of projectivespace(8 , 9 ) > gap >",
    "points(pg ) ; < points of projectivespace(8 , 9 ) > gap > lines(pg ) ; < lines of projectivespace(8 , 9 ) > gap > planes(pg ) ; < planes of projectivespace(8 , 9 ) > gap > solids(pg ) ; < solids of projectivespace(8 , 9 ) > gap > elementsofincidencestructure(pg,5 ) ; < proj .",
    "4-subspaces of projectivespace(8 , 9 ) > gap > plane : = random(planes(pg ) ) ; < a plane in projectivespace(8 , 9 ) > gap > solids(plane ) ; < shadow solids in projectivespace(8 , 9 ) > gap > line : = random(lines(pg ) ) ; < a line in projectivespace(8 , 9 ) > gap > span(line , plane ) ; < a proj .",
    "4-space in projectivespace(8 , 9 ) > gap > meet(line , plane ) ; < empty subspace > gap > hyperplane : = random(hyperplanes(pg ) ) ;       < a proj .",
    "7-space in projectivespace(8 , 9 ) > gap > meet(line , hyperplane ) ; < a point in projectivespace(8 , 9 ) > gap > span(line , hyperplane ) ; projectivespace(8 , 9 ) ----    a _ polar space _ is a partial linear space satisfying the so - called one - or - all axiom : given a point @xmath16 and a line @xmath17 , @xmath16 not incident with @xmath17 , there is either exactly one line incident with @xmath16 meeting @xmath17 in a point , or points of @xmath17 span with @xmath16 a line of the polar space .",
    "the _ classical polar spaces _ are constructed from vector spaces equipped with a form as follows .",
    "consider a vector space @xmath18 equipped with a non - degenerate sesquilinear form @xmath19 , respectively non - singular quadratic form @xmath19 .",
    "the polar space @xmath3 associated to the form @xmath19 is the geometry of which the elements are represented by the totally isotropic , respectively totally singular , subspaces with respect to the form @xmath19 .",
    "the rank of @xmath3 equals the witt index of the form @xmath19 .",
    "so we see that @xmath3 is embedded in the projective space @xmath20 .",
    "sesquilinear and quadratic forms on a finite vector space have been classified . up to coordinate transformation , they fall into three main classes .    1 .   orthogonal polar spaces , associated with a quadratic form ( which in odd characteristic is equivalent with a symmetric bilinear form ) ; 2 .",
    "symplectic polar spaces , associated with an alternating bilinear form ; 3 .",
    "hermitian polar spaces , associated with a unitary form .    the orthogonal polar spaces separate into three classes : parabolic quadrics ( in even projective dimension ) , and elliptic and hyperbolic quadrics ( in odd projective dimension ) .",
    "classical polar spaces can be constructed in several ways in fining .",
    "a user - defined sesquilinear or quadratic form can be used , but fining also provides shortcuts to classical polar spaces defined by a `` standard form '' .",
    "the following example illustrates this possibility .",
    "when appropriate , the connection with polarities of projective spaces can be explored .",
    "example  [ ex : polar ] illustrates some basic functionality for polar spaces as well .",
    "[ source , gap ] ---- gap > mat : = [ [ 0,0,0,1],[0,0,-2,0],[0,2,0,0],[-1,0,0,0]]*z(5)^0 ; [ [ 0*z(5 ) , 0*z(5 ) , 0*z(5 ) , z(5)^0 ] , [ 0*z(5 ) , 0*z(5 ) , z(5)^3 , 0*z(5 ) ] ,     [ 0*z(5 ) , z(5 ) , 0*z(5 ) , 0*z(5 ) ] , [ z(5)^2 , 0*z(5 ) , 0*z(5 ) , 0*z(5 ) ] ] gap > form : = bilinearformbymatrix(mat , gf(25 ) ) ; < bilinear form > gap >",
    "ps : = polarspace(form ) ; < polar space in projectivespace ( 3,gf(5 ^ 2 ) ) : x1*y4+z(5)^3*x2*y3+z(5)*x3*y2-x4*y1=0 > gap >",
    "rank(ps ) ; 2 gap > ps ; w(3 , 25 ) : x1*y4+z(5)^3*x2*y3+z(5)*x3*y2-x4*y1=0 gap > ps : = ellipticquadric(5,7 ) ; q-(5 , 7 ) gap >",
    "rank(ps ) ; 2 gap > phi : = polarityofprojectivespace(ps ) ; < polarity of pg(5 , gf(7 ) ) > gap > ps",
    ": = parabolicquadric(4,4 ) ; q(4 , 4 ) gap > phi : = polarityofprojectivespace(ps ) ; error , no polarity of the ambient projective space can be associated to < ps > ----    lie geometries are _ naturally _ embedded in projective spaces . in fining this",
    "means that an element of a polar space , for example , is automatically an element of the ambient projective space .",
    "example  [ ex : lie_embedded ] demonstrates the philosophy of lie geometries in fining .",
    "[ source , gap ] ---- gap > hexagon : = splitcayleyhexagon(3 ) ; h(3 ) gap > p : = random(points(hexagon ) ) ; # i   for split cayley hexagon # i   computing nice monomorphism ... # i   found permutation domain ... < a point in h(3 ) > gap > lines : = lines(p ) ; < shadow lines in h(3 ) > gap > size(lines ) ;     4 gap > polarspace : = ambientpolarspace(hexagon ) ; q(6 , 3 ) : -x_1*x_5-x_2*x_6-x_3*x_7+x_4 ^ 2=0 gap > p2 : = elementtoelement(polarspace , p ) ; < a point in q(6 , 3 ) : -x_1*x_5-x_2*x_6-x_3*x_7+x_4 ^ 2=0 > gap > p2 in hexagon ; true gap > lines2 : = lines(p2 ) ; < shadow lines in q(6 , 3 ) : -x_1*x_5-x_2*x_6-x_3*x_7+x_4 ^ 2=0 > gap > size(lines2 ) ; 40 gap > collected(list(lines2,x->x in hexagon ) ) ; [ [ true , 4 ] , [ false , 36 ] ] gap > pg : = ambientspace(hexagon ) ; projectivespace(6 , 3 ) gap > p3 : = elementtoelement(pg , p ) ;          < a point in projectivespace(6 , 3 ) > gap > p3 in polarspace ; true gap > p3 in hexagon ; true gap > lines3 : = lines(p3 ) ; < shadow lines in projectivespace(6 , 3 ) > gap > collected(list(lines3,x->x in hexagon ) ) ; [ [ true , 4 ] , [ false , 360 ] ] gap > collected(list(lines3,x->x in polarspace ) ) ; [ [ true , 40 ] , [ false , 324 ] ] ----",
    "a _ collineation _ of an incidence geometry @xmath3 is a type preserving map from @xmath3 to itself that preserves the incidence .",
    "let @xmath20 denote a @xmath21-dimensional projective space over the finite field @xmath22 .",
    "as we have seen in the previous section , the elements of @xmath20 are represented by the subspaces of the @xmath23-dimensional vector space @xmath18 . by the fundamental theorem of projective geometry ,",
    "each collineation of a projective space @xmath20 is induced by a semilinear automorphism of @xmath18 .",
    "the group of semilinear automorphisms of @xmath18 is denoted by @xmath24 , and an element of this group is completely determined by a non - singular matrix and an automorphism of the underlying field .",
    "the scalar matrices form a subgroup @xmath25 of the group @xmath24 that acts trivially on the subspaces of @xmath18 .",
    "the permutation group induced on the subspaces is the _ projective general semilinear group _ : @xmath26 the group @xmath27 is the subgroup of @xmath24 induced by the linear automorphisms of @xmath28 .",
    "this group is called the _ projectivity group _ or _ homography group _ of @xmath20 .",
    "the projectivity groups are already implemented in gap , but only as permutation groups.without the underlying geometry .",
    "w provide the implementation of collineation groups of projective spaces as groups induced by semilinear transformations of vector spaces . note that an element of a lie geometry is represented by a subspace of a vector space , which in fining is inturn represented as the row - space of a matrix .",
    "let @xmath29 be an @xmath30-matrix over @xmath22 of rank @xmath31 .",
    "the row - space of @xmath29 represents a subspace @xmath32 of @xmath20 of projective dimension @xmath33 .",
    "let @xmath34 be a semilinear automorphism of @xmath18 represented by the matrix @xmath35 and the field automorphism @xmath36",
    ". in fining , the image of @xmath32 under @xmath34 is the projective subspace represented by the matrix @xmath37 , with @xmath38    the first example below shows the difference between the projectivity group that was already implemented in gap and the projectivity group implemented in fining .",
    "the example also illustrates that accessing the collineation groups implemented in fining is naturally associated to the underlying incidence geometry .",
    "[ source , gap ] ---- gap > g1 : = pgl(5,27 ) ; < permutation group of size 22496309500661613496614846025474560 with 2 generators > gap > g2 : = projectivitygroup(pg(4,27 ) ) ; the fining projectivity group pgl(5,27 ) gap >",
    "order(g2 ) ; 22496309500661613496614846025474560 gap > g3 : = collineationgroup(pg(4,27 ) ) ;   the fining collineation group pgammal(5,27 ) gap > order(g3 ) ; 67488928501984840489844538076423680 gap > generatorsofgroup(g1)[1 ] ; ( 20442,20467,20466,20465,20464,20463,20462,20461,20460,20459,20458,20457 , 20456,20443,20455,20454,20453,20452,20451,20450,20449,20448,20447,20446,20445 , 20444)(20468,21143,21116,21089,21062,21035,21008,20981,20954,20927,20900 , 20873,20846,20495,20819,20792,20765,20738,20711,20684,20657,20630,20603,20576 , 20549,20522)(20469,21169,21141,21113,21085,21057,21029,21001,20973,20945 , 20917,20889,20861,20497,20833,20805,20777,20749,20721,20693,20665,20637,20609 , 20581,20553,20525)(20470,21157,21129,21101,21073,21045,21017,20989,20961 , 20933,20905,20877,20849,20496,20845,20817,20789,20761,20733,20705,20677,20649 , 20621,20593,20565,20537)(20471,21144,21142,21114,21086,21058,21030,21002 , 20974,20946,20918,20890,20862,20510,20821,20806,20778,20750,20722,20694,20666 , 20638,20610,20582,20554,20526)(20472,21146,21117,21115,21087,21059,21031 , 21003,20975,20947,20919,20891,20863,20511,20834,20794,20779,20751,20723,20695 , 20667,20639,20611,20583,20555,20527)(20473,21147,21119,21090,21088,21060 , 21032,21004,20976,20948,20920,20892,20864,20512,20835,20807,20767,20752,20724 , 20696,20668,20640,20612,20584,20556,20528)(20474,21148,21120,21092,21063 , 21061,21033,21005,20977,20949,20921,20893,20865,20513,20836,20808,20780,20740 , 20725,20697,20669,20641,20613,20585,20557,20529 ) ( [ ... ] ) gap > generatorsofgroup(g2)[1 ] ; < a collineation : < cmat 5x5 over gf(3,3 ) > , f^0 > gap > generatorsofgroup(g3)[1 ] ; < a collineation : < cmat 5x5 over gf(3,3 ) > , f^0 > ----    the next example shows how to construct a collineation of a projective space , and how to get the underlying matrix and field automorphism of a collineation .",
    "[ source , gap ] ---- gap > mat : = [ [ z(7 ^ 3)^115 , z(7 ^ 3)^164 , z(7 ^ 3)^189 ] ,   >    [ z(7 ^ 3)^146 , z(7 ^ 3)^279 , z(7 ^ 3)^215 ] ,   >    [ z(7 ^ 3)^58 , z(7 ^ 3)^322 , z(7 ^ 3)^260 ] ] ; [ [ z(7 ^ 3)^115 , z(7 ^ 3)^164 , z(7 ^ 3)^189 ] ,     [ z(7 ^ 3)^146 , z(7 ^ 3)^279 , z(7 ^ 3)^215 ] ,     [ z(7 ^ 3)^58 , z(7 ^ 3)^322 , z(7 ^ 3)^260 ] ] gap > theta : = frobeniusautomorphism(gf(7 ^ 3))^2 ; frobeniusautomorphism ( gf(7 ^ 3 ) ) ^2 gap > phi : = projectivesemilinearmap(mat , theta , gf(7 ^ 3 ) ) ; < a collineation : < cmat 3x3 over gf(7,3 ) > , f^49 > gap > psi : = random(collineationgroup(pg(2,2 ^ 3 ) ) ) ; < a collineation : < cmat 3x3 over gf(2,3 ) > , f^4 > gap >",
    "underlyingmatrix(psi ) ; < cmat 3x3 over gf(2,3 ) > gap > unpack(last ) ; # to get actual matrix from cvec [ [ z(2 ^ 3)^6 , z(2 ^ 3 ) , z(2)^0 ] , [ z(2 ^ 3)^2 , z(2 ^ 3)^4 , z(2 ^ 3)^2 ] ,     [ z(2 ^ 3)^5 , z(2 ^ 3)^3 , z(2 ^ 3)^4 ] ] gap > fieldautomorphism(psi ) ; frobeniusautomorphism ( gf(2 ^ 3 ) ) ^2 ----    note that also the projective special homography groups are implemented in gap as permutation groups , these are the groups of homographies where the underlying matrix has determinant one .",
    "[ source , gap ] ---- gap > psl(3,49 ) ; < permutation group of size 11072935641600 with 2 generators > gap > specialhomographygroup(pg(2,49 ) ) ; the fining psl group psl(3,49 ) gap > order(last ) ; 11072935641600 ----    let @xmath3 be a polar space defined by the sesquilinear form @xmath19 on the vector space @xmath18 .",
    "let @xmath39 be a semilinear automorphism of @xmath18 .",
    "if @xmath39 preserves the zeroes of the form @xmath19 , that is , @xmath40 then @xmath39 induces a collineation of @xmath3 , and all collineations of @xmath3 are induced by such automorphisms of @xmath18 .",
    "if @xmath39 preserves the values of the form @xmath19 , i.e. , @xmath41 , then the induced collineation is called an _ isometry _ of @xmath3 .",
    "if @xmath39 preserves the form @xmath19 up to a scalar , i.e. , @xmath42 and @xmath43 is fixed , then the induced collineation is called a _ similarity_. finally , the _ special isometries _ are the isometries induced by a linear automorphism with determinant @xmath44 , i.e. , an element of @xmath45 .",
    "if @xmath3 is a polar space with special isometry group @xmath46 , isometry group @xmath47 , similarity group @xmath48 and collineation group @xmath49 , respectively , then @xmath50 .",
    "equalities can occur depending on the type of @xmath3 .",
    "table  [ groups ] provides an overview .",
    ".collineation groups of finite classical polar spaces [ cols=\"^,^,^,^,^,^\",options=\"header \" , ]     all groups from table  [ groups ] are constructed in fining as a collineation group of a finite classical polar space .",
    "consistent with the basic philosophy of fining , such a geometry is determined by a user chosen sesquilinear / quadratic form . to compute the groups",
    ", we use the generators from @xcite , which are given with relation to a fixed sesquilinear / quadratic form , and apply the necessary coordinate transformations on the fly , using the package forms .",
    "[ source , gap ] ---- gap > ps : = hermitianpolarspace(2,4 ) ; h(2 , 2 ^ 2 ) gap >",
    "collineationgroup(ps ) ; pgammau(3,2 ^ 2 ) gap > specialisometrygroup(ps ) ; psu(3,2 ^ 2 ) gap > mat : = identitymat(3,gf(9 ) ) ; [ [ z(3)^0 , 0*z(3 ) , 0*z(3 ) ] , [ 0*z(3 ) , z(3)^0 , 0*z(3 ) ] ,     [ 0*z(3 ) , 0*z(3 ) , z(3)^0 ] ] gap > form : = quadraticformbymatrix(mat , gf(9 ) ) ; < quadratic form > gap > ps : = polarspace(form ) ; < polar space in projectivespace(2,gf(3 ^ 2 ) ) : x_1 ^ 2+x_2 ^ 2+x_3 ^ 2=0 > gap > g : = similaritygroup(ps ) ; # i   computing collineation group of canonical polar space ...",
    "< projective collineation group of size 720 with 2 generators > gap > h : = similaritygroup(parabolicquadric(2,9 ) ) ; pgo(0,3,9 ) ----",
    "the general mechanism in gap to describe the action of the elements of a group @xmath48 on the elements of a set @xmath35 is through so - called _",
    "action functions_. an action function for the group @xmath48 and the set @xmath35 is a gap function that takes two arguments , @xmath51 and @xmath52 , and returns the image of @xmath53 under @xmath54 ( usually denoted as @xmath55 or @xmath56 ) . to explore group theoretical properties of the action of the group @xmath48 on the elements of a set @xmath35",
    ", some generic gap functions will compute a permutation representation of this action , which necessarily uses the action function .",
    "so for a given incidence geometry @xmath3 , with a group of collineations @xmath48 , fining usually provides an action function for the group @xmath48 and the set of elements ( of a given type ) of @xmath3 . for lie geometries",
    ", fining provides the action function ` onprojsubspaces ` .",
    "the following example illustrates its use .",
    "[ source , gap ] ---- gap > ps",
    ": = parabolicquadric(4,3 ) ; q(4 , 3 ) gap > group : = isometrygroup(ps ) ; pgo(0,5,3 ) gap > hom : = actionhomomorphism(group , lines(ps),onprojsubspaces ) ; < action homomorphism > gap > act : = image(hom ) ; group ( [ ( 1,2)(3,5)(4,7)(6,10)(9,14)(11,17)(12,18)(15,21)(16,23)(19,22)(20,24 ) ( 25,29)(27,28)(30,34)(33,38)(36,39 ) , ( 1,3,6,11)(2,4,8,13,19,14,20,25,30,35,40 , 18)(5,9,15,22,27,32,37,38,34,39,29,17)(7,12)(10,16)(21,26,31,36)(23,28,33 ) ] ) ----    in gap , a _ nice monomorphism _ of an ( abstract ) group @xmath48 is a permutation representation of @xmath48 on a suitable action domain .",
    "such a permutation representation makes it possible to use permutation group algorithms to explore properties of @xmath48 . if a nice monomorphism is available for an abstract group , a complete set of gap functions will perform much better than their generic counterparts for abstract groups .",
    "a typical example is the gap command ` sylowsubgroup ` . in the following example the nice monomorphism of the collineation group",
    "is only computed when it becomes useful .",
    "[ source , gap ] ---- gap > ps : = collineationgroup(pg(3,4 ) ) ; the fining collineation group pgammal(4,4 ) gap > hasnicemonomorphism(ps ) ; false gap > sylowsubgroup(ps,7 ) ; < projective collineation group of size 7 > gap > hasnicemonomorphism(ps ) ; true ----    if a collineation group @xmath48 is known to be a subgroup of a finite classical group , then the permutation representation of smallest degree will be computed automatically when needed by fining .",
    "constructing a particular group of collineations as a subgroup of a collineation group of a polar space makes this permutation representation available automatically for the constructed subgroup .",
    "the following example nicely illustrates this behaviour .",
    "[ source , gap ] ---- gap >",
    "ps : = hermitianpolarspace(3,81 ) ; h(3 , 9 ^ 2 ) gap > group : = collineationgroup(ps ) ; pgammau(4,9 ^ 2 ) gap > time ; 2219 gap > g : = random(group ) ; < a collineation : < cmat 4x4 over gf(3,4 ) > , f^27 > gap > h : = random(group ) ; < a collineation : < cmat 4x4 over gf(3,4 ) > , f^3 > gap > group2 : = group([g , h ] ) ; < projective collineation group with 2 generators > gap > hasnicemonomorphism(group2 ) ; false gap > order(group2 ) ; 407194345728000 gap > time ; 371559 gap >",
    "hasnicemonomorphism(group2 ) ; true gap > nrmovedpoints(niceobject(group2 ) ) ; 538084 gap > size(points(pg(3,81 ) ) ) ; 538084 gap > group2 : = subgroup(group , [ g , h ] ) ; < projective collineation group with 2 generators > gap > hasnicemonomorphism(group2 ) ; true gap > hasniceobject(group2 ) ; false gap > order(group2 ) ; 407194345728000 gap > time ; 888 gap > hasniceobject(group2 ) ; true gap > nrmovedpoints(niceobject(group2 ) ) ; 7300 gap > size(lines(ps ) ) ; 7300 ----    we remark that there is a byproduct of our package that would be useful to the general group theory community .",
    "the affine groups @xmath57 and @xmath58 , in their natural action on subspaces , are readily computable using fining , and so too are correlation groups of projective spaces ( i.e. , the automorphism groups of projective special linear groups ) .",
    "it is now a simple exercise to have the exceptional groups @xmath59 and @xmath60 acting on the subspaces in their natural linear representations .",
    "the efficient computation of orbits and stabilisers is done through the packages orb @xcite and genss @xcite .",
    "orb is used for efficient orbit enumeration and the most important algorithms rely fundamentally on code for producing hash tables .",
    "the basic idea is to enumerate an orbit by `` suborbits '' with respect to one or more subgroups , and usually requires the user to give specific details about the putative orbit to obtain dividends in using this package over the standard method given in the gap library .",
    "for instance the isometry group of a polar space , acts transitively on totally isotropic subspaces of a fixed dimension , and we know in advance how large this orbit will be .",
    "so orb is ideally suited for quickly enumerating the set of elements of a finite polar space .",
    "we also use orb to efficiently construct _ nice monomorphisms _ ( see section [ sect : group_actions ] ) .",
    "the genss package stands for ` generic schreier - sims ' and is essentially a suite of algorithms for stabiliser chains , bases , and strong generating sets for finite groups , that are not necessarily permutation groups .",
    "again , this removes the need for us to implement stabiliser chains for the collineation groups in our package .",
    "the package orb takes advantage of the use of the package cvec @xcite which implements vectors and matrices over finite fields , replacing the existing gap implementations .",
    "the use of cvec is clear when asking for underlying objects of subspaces of projective spaces , as the following example illustrates .",
    "[ source , gap ] ---- gap > pg : = pg(4,5 ) ; projectivespace(4 , 5 ) gap > p : = random(points(pg ) ) ; < a point in projectivespace(4 , 5 ) > gap > underlyingobject(p ) ; < cvec over gf(5,1 ) of length 5 > gap >",
    "l : = random(lines(pg ) ) ; < a line in projectivespace(4 , 5 ) > gap > underlyingobject(l ) ; < cmat 2x5 over gf(5,1 ) > gap > unpack(last ) ; [ [ z(5)^0 , 0*z(5 ) , z(5)^2 , z(5)^3 , 0*z(5 ) ] ,     [ 0*z(5 ) , z(5)^0 , z(5)^2 , z(5)^2 , z(5)^2 ] ] ----    part of the generic gap functionality is to compute orbits and stabilisers using generic algorithms .",
    "however , fining implements its own versions for lie geometries , based on the functions in the packages orb and genss .",
    "the following example shows the difference in computation time between the generic gap function ` orbit ` , ` stabilizer ` and the fining function ` finingorbit ` , ` finingstabiliser ` , and ` finingsetwisestabiliser ` .",
    "note the rather big difference in computation time between the use of the generic function ` stabilizer ` ( combined with ` onsets ` ) and ` finingsetwisestabiliser ` .",
    "[ source , gap ] ---- gap > ps",
    ": = parabolicquadric(6,5 ) ; q(6 , 5 ) gap > line : = random(lines(ps ) ) ; < a line in q(6 , 5 ) > gap > group : = collineationgroup(ps ) ; pgammao(7,5 ) gap > orb1 : = finingorbit(group , line , onprojsubspaces ) ;   < closed orbit , 101556 points > gap > time ; 7956 gap > orb2 : = orbit(group , line , onprojsubspaces ) ; ; gap > time ; 13075 gap > stabilizer(group , line , onprojsubspaces ) ; < projective collineation group of size 4500000000 with 5 generators > gap > time ; 152627 gap > finingstabiliser(group , line ) ; < projective collineation group of size 4500000000 with 3 generators > gap > time ; 2070 gap > ps : = parabolicquadric(4,5 ) ; q(4 , 5 ) gap > p1 : = random(points(ps ) ) ; < a point in q(4 , 5 ) > gap > p2",
    ": = random(points(ps ) ) ; < a point in q(4 , 5 ) > gap > p3 : = random(points(ps ) ) ; < a point in q(4 , 5 ) > gap > group : = collineationgroup(ps ) ; pgammao(5,5 ) gap > stabilizer(group , set([p1,p2,p3]),onsets ) ; < projective collineation group of size 72 with 4 generators > gap > time ; 113330 gap > finingsetwisestabiliser(group , set([p1,p2,p3 ] ) ) ; # i   computing adjusted stabilizer chain ...",
    "< projective collineation group with 4 generators > gap > time ; 18 ----",
    "let @xmath3 and @xmath61 be two incidence geometries .",
    "let @xmath62 be a subset of the elements of @xmath3 , and let @xmath63 be a subset of the elements of @xmath61 .",
    "a map @xmath64 is called a geometry morphism from @xmath3 to @xmath61 if it preserves incidence : @xmath65 note that @xmath66 , @xmath67 respectively , might be any subset of the elements of @xmath3 , @xmath61 respectively .",
    "let @xmath48 , respectively @xmath68 be the automorphism group of @xmath3 , respectively @xmath61 .",
    "a map @xmath69 is an _ intertwiner _ for the geometry morphism @xmath39 if @xmath70 the definition of a geometry morphism is very general .",
    "a geometry morphism might have the complete set of elements of an incidence geometry as domain and might be type preserving .",
    "geometry morphisms with particular properties occur frequently in incidence geometry .",
    "typical geometry morphisms are embeddings , dualities , the klein correspondence , morphisms induced by field reduction , etc .",
    "all geometry morphisms currently available in fining are geometry morphisms of lie geometries .",
    "we give some particular examples .",
    "we ve seen that classical polar spaces can be constructed through a user - defined form .",
    "the isomorphism between two polar spaces defined from a similar but different form is present as a geometry morphism .",
    "clearly this morphism has the complete set of elements of the polar spaces as domain / co - domain , and is type preserving .",
    "[ source , gap ] ---- gap > mat1 : = [ [ 1,0,0],[0,0,1],[0,0,0]]*z(5)^0 ; [ [ z(5)^0 , 0*z(5 ) , 0*z(5 ) ] , [ 0*z(5 ) , 0*z(5 ) , z(5)^0 ] ,     [ 0*z(5 ) , 0*z(5 ) , 0*z(5 ) ] ] gap > form1 : = quadraticformbymatrix(mat1,gf(5 ) ) ; < quadratic form > gap > conic1 : = polarspace(form1 ) ; gap > mat2 : = [ [ 0,0,-1],[0,1,0],[0,0,0]]*z(5)^0 ;   [ [ 0*z(5 ) , 0*z(5 ) , z(5)^2 ] , [ 0*z(5 ) , z(5)^0 , 0*z(5 ) ] ,     [ 0*z(5 ) , 0*z(5 ) , 0*z(5 ) ] ] gap > form2 : = quadraticformbymatrix(mat2,gf(5 ) ) ; < quadratic form > gap > conic2 : = polarspace(form2 ) ; < polar space in projectivespace(2,gf(5 ) ) : -x_1*x_3+x_2 ^ 2=0 > gap > iso : = isomorphismpolarspaces(conic1,conic2 ) ; # i   no intertwiner computed .",
    "one of the polar spaces must   have a collineation group computed < geometry morphism from < elements of q(2 , 5 ) : x_1 ^ 2+x_2*x_3=0 >   to < elements of q(2 ,",
    "5 ) : -x_1*x_3+x_2 ^ 2=0 > > ----    example  [ ex : subspace_embedding ] , dealing with subpace embeddings , is also among the most obvious ones . it is demonstrated how to embed a projective plane in a projective space as a user chosen plane of the projective space , and similarly , how to embed a conic in an elliptic quadric as a user chosen plane section .",
    "[ source , gap ] ---- gap > mat : = [ [ z(5)^0 , 0*z(5 ) , z(5 ) , 0*z(5 ) , 0*z(5 ) ] ,   >    [ 0*z(5 ) , z(5)^0 , z(5)^3 , 0*z(5 ) , 0*z(5 ) ] ,   >    [ 0*z(5 ) , 0*z(5 ) , 0*z(5 ) , z(5)^0 , z(5)^2 ] ] ; ; gap > plane : = vectorspacetoelement(pg(4,5),mat ) ; < a plane in projectivespace(4 , 5 ) > gap > em : = naturalembeddingbysubspace(pg(2,5),pg(4,5),plane ) ; < geometry morphism from < all elements of projectivespace(2 ,   5 ) > to < all elements of projectivespace(4 , 5 ) > > gap >",
    "ps : = ellipticquadric(5,11 ) ; q-(5 , 11 ) gap > mat : = [ [ z(11)^0 , 0*z(11 ) , 0*z(11 ) , 0*z(11 ) , 0*z(11 ) , 0*z(11 ) ] ,   >    [ 0*z(11 ) , z(11)^0 , 0*z(11 ) , 0*z(11 ) , 0*z(11 ) , 0*z(11 ) ] ,   >    [ 0*z(11 ) , 0*z(11 ) , z(11)^0 , 0*z(11 ) , z(11)^0 , z(11)^0 ] ] ; ; gap > plane : = vectorspacetoelement(pg(5,11),mat ) ; < a plane in projectivespace(5 , 11 ) > gap > typeofsubspace(ps , plane ) ; \" parabolic \" gap > conic : = parabolicquadric(2,11 ) ; q(2 , 11 ) gap > em : = naturalembeddingbysubspace(conic , ps , plane ) ; < geometry morphism from < elements of q(2 , 11 ) > to < elements of q-(5 , 11 ) > > ----    the klein correspondence is a geometry morphism that has the set of lines of @xmath71 as domain and the set of points of @xmath72 as co - domain .",
    "this morphism is clearly not type preserving .",
    "example  [ ex : klein_dualities ] also shows some of the derived dualites of the particular finite generalised quadrangles .",
    "[ source , gap ] ---- gap > map : = kleincorrespondence(7 ) ; < geometry morphism from < lines of projectivespace(3 , 7 ) >   to < points of q+(5 , 7 ) : x_1*x_6+x_2*x_5+x_3*x_4=0 > > gap",
    "> p : = random(lines(pg(3,7 ) ) ) ; < a line in projectivespace(3 , 7 ) > gap > p^map ; < a point in q+(5 , 7 ) : x_1*x_6+x_2*x_5+x_3*x_4=0 > gap > duality : = naturalduality(parabolicquadric(4,3),symplecticspace(3,3 ) ) ; < geometry morphism from < elements of q(4 , 3 ) > to < elements of w(3 , 3 ) > > gap > w : = ambientgeometry(range(duality ) ) ; w(3 , 3 ) gap > l : = random(points(w ) ) ; < a point in w(3 , 3 ) > gap > preimageelm(duality , l ) ; < a line in q(4 , 3 ) > ----    field extensions are the basic ingredient for some important embeddings .",
    "typically the associated geometry morphism has the complete set of elements of a geometry as domain , and a subset of the elements of a geometry as co - domain .",
    "we give some examples : the embedding of @xmath73 in @xmath74 ( illustrated using @xmath75 embedded in @xmath76 ) , and the embedding of @xmath77 in @xmath78 ( illustrated using @xmath79 embedded in @xmath80 ) .",
    "note that the second example requires the use of coordinate transformations , since considering the form of the standard elliptic quadric @xmath77 over @xmath81 is not necessarily the form used for the standard hyperbolic quadric @xmath78 , but this calculation is done on the fly .",
    "afterwards , we compute the klein correspondence from @xmath82 to @xmath80 , compute the lines of @xmath82 corresponding with the points of @xmath79 embedded in @xmath80 , compute the set of points on at least one of the lines of this line set , and then the intersection numbers of the lines of @xmath82 with this point set .",
    "the intersection numbers are sufficient to conclude that the point set is the set of points of a hermitian polar space @xmath83 , ( by a result of @xcite ) , and illustrate nicely how the duality between the @xmath77 and @xmath84 is obtained through the klein correspondence .",
    "[ source , gap ] ---- gap > em : = naturalembeddingbysubfield(pg(2,3),pg(2,3 ^ 3 ) ) ; < geometry morphism from < all elements of projectivespace(2 , 3 ) >   to < all elements of projectivespace(2 , 27 ) > > gap > collected(list(lines(pg(2,3 ^ 3)),x->number(points(pg(2,3)),y->y^em in x ) ) ) ; [ [ 0 , 432 ] , [ 1 , 312 ] , [ 4 , 13 ] ] gap > em : = naturalembeddingbysubfield(pg(2,3),pg(2,3 ^ 2 ) ) ; < geometry morphism from < all elements of projectivespace(2 , 3 ) >   to < all elements of projectivespace(2 , 9 ) > > gap > collected(list(lines(pg(2,3 ^ 2)),x->number(points(pg(2,3)),y->y^em in x ) ) ) ; [ [ 1 , 78 ] , [ 4 , 13 ] ] gap > e : = ellipticquadric(5,2 ) ; q-(5 , 2 ) gap > h : = hyperbolicquadric(5,4 ) ; q+(5 , 4 ) gap > em : = naturalembeddingbysubfield(e , h ) ; # i   no intertwiner computed .",
    "< geom1 > must have a collineation group computed < geometry morphism from < elements of q-(5 , 2 ) > to < elements of q+(5 , 4 ) > > gap > klein : = kleincorrespondence(h ) ; < geometry morphism from < lines of projectivespace(3 , 4 ) > to < points of q+(5 ,   4 ) > > gap > lines : = list(points(e),x->preimageelm(klein , x^em ) ) ; ; gap > pointset : = union(list(lines , x->list(points(x ) ) ) ) ; ; gap > collected(list(lines(pg(3,4)),x->number(pointset , y->y in x ) ) ) ; [ [ 1 , 90 ] , [ 3 , 240 ] , [ 5 , 27 ] ] gap > collected(list(planes(pg(3,4)),x->number(pointset , y->y in x ) ) ) ; [ [ 9 , 40 ] , [ 13 , 45 ] ] ----    field reduction is a way to embed low rank lie geometries over a large field into high rank lie geometries over a subfield .",
    "an obvious example is the embedding of , for example , @xmath85 into @xmath86 .",
    "the corresponding geometry morphism will have the points and lines of @xmath85 as domain , and a subset of the lines and @xmath0-dimensional subspaces of @xmath86 as co - domain .",
    "similarly , embeddings of polar spaces are possible .",
    "let @xmath3 be a classical polar space with associated form @xmath19 acting on the vector space @xmath87 .",
    "let @xmath88 be the trace map from @xmath89 to @xmath22 .",
    "note that choosing a basis for @xmath89 as a @xmath5-dimensional vector space over @xmath22 , induces a bijection @xmath90 between the vectors of @xmath87 and the vectors of @xmath91 .",
    "define , for a chosen @xmath92 , the map @xmath93 : @xmath94 .",
    "then clearly @xmath95 is a form on @xmath91 , defining a classical polar space @xmath61 .",
    "an element of @xmath3 is embedded in @xmath61 by blowing up the underlying vector space .",
    "depending on the choice of @xmath43 , some conditions on @xmath96 and the type of the form @xmath19 , several embeddings are possible . a complete overview ( including all proofs ) , is found in @xcite .",
    "note that these embeddings are very useful in constructing particular substructures of polar spaces over small fields , as the examples below shows by constructing a so - called hermitian @xmath44-system of @xmath97 .",
    "[ source , gap ] ---- gap > h : = hermitianpolarspace(2,4 ) ; h(2 , 2 ^ 2 ) gap > w : = symplecticspace(5,2 ) ; w(5 , 2 ) gap > em : = naturalembeddingbyfieldreduction(h , w ) ; # i   these polar spaces are suitable for field reduction < geometry morphism from < elements of h(2 , 2 ^ 2 ) > to < elements of w(5 , 2 ) > > gap > list(points(h),x->x^em ) ; [ < a line in w(5 , 2 ) > , < a line in w(5 , 2 ) > , < a line in w(5 , 2 ) > ,     < a line in w(5 , 2 ) > , < a line in w(5 , 2 ) > , < a line in w(5 , 2 ) > ,     < a line in w(5 , 2 ) > , < a line in w(5 , 2 ) > , < a line in w(5 , 2 ) > ] ----",
    "let @xmath98 be the collection ( in the gap sense ) of elements of a classical polar space @xmath3 . note that a collection in the gap sense is an abstract object , which just _ represents _ all elements ( of a given type ) rather than contains them . at creation , there is no computation needed .",
    "an enumerator for a collection is a gap - object that allows one to compute the @xmath99th element of the collection @xmath98 without computing any other element of @xmath98 and vice versa , i.e. , given an element @xmath100 , the enumerator is able to compute its position in the list @xmath98 without enumerating any of the elements of @xmath98 .",
    "given a collection @xmath98 for which the number of elements is known , an enumerator enables us to efficiently compute random elements of @xmath98 if no other information is known .",
    "the algorithms used for this part of fining were developed specifically for this purpose .",
    "[ source , gap ] ---- gap > lines : = lines ( parabolicquadric(6,3 ) ) ; < lines of q(6 , 3 ) > gap > enum : = enumerator ( lines ) ; enumeratorofsubspacesofclassicalpolarspace ( < lines of q(6 , 3 ) > ) gap > s : = size(enum ) ; 3640 gap > n : = random([1 .. s ] ) ; 3081 gap > l : = enum[n ] ; < a line in q(6 , 3 ) > gap > position(enum , l ) ; 3081 ----    [ source , gap ] ---- gap > ps : = parabolicquadric(16,7 ^ 4 ) ; q(16 , 2401 ) gap > pts : = points(ps ) ; < points of q(16 , 2401 ) > gap > size(pts ) ; 508233536514931541724405776067904925314839705888016 gap > random(pts ) ; < a point in q(16 , 2401 ) > gap > time ; 565 ----",
    "consider an incidence geometry @xmath101 together with a group @xmath48 of automorphisms which is transitive on the set of maximal flags .",
    "for such a maximal flag @xmath102 we write @xmath103 for the stabiliser of the element @xmath104 in @xmath48 where @xmath105 .",
    "we will assume that the index @xmath99 corresponds to the type of @xmath104 in @xmath106 .",
    "it is then straightforward to see that the elements of type @xmath99 in @xmath101 can be identified with the ( left ) cosets of @xmath103 in @xmath48 . in this representation",
    ", the incidence relation of @xmath101 is translated to nonempty intersection of cosets , i.e. , two elements identified with @xmath107 and @xmath108 respectively are incident if and only if @xmath109 . the action of @xmath48 on @xmath101 is carried to left multiplication : an element identified with @xmath110 is mapped by @xmath111 to @xmath112 .",
    "we can now reverse this construction and start with a group @xmath48 together with a set @xmath113 of subgroups of @xmath48 . from this",
    "we define an incidence structure whose elements are simply the cosets of the given subgroups and incidence is given by nonempty intersection of cosets .",
    "the group @xmath48 acts by left multiplication . in general",
    "this structure is not an incidence geometry but one can provide necessary conditions for this ( see  @xcite ) .",
    "once an incidence geometry is represented as a coset geometry , gap s built - in machinery for ( permutation ) groups can be used to analyse this geometry .",
    "[ source , gap ] ---- gap > g:=symmetricgroup(8 ) ; ; gap > parabolics:= [ ] ; ; gap >",
    "parabolics[1]:=stabilizer(g,1 ) ; ; parabolics[2]:=stabilizer(g,2 ) ; ; gap >",
    "parabolics[3]:=stabilizer(g,3 ) ; ; gap > parabolics[4]:=stabilizer(g,[1,2,3,4],onsets ) ; ; gap > parabolics[5]:=stabilizer(g,[1,2,3,4,5],onsets ) ; ; gap >",
    "parabolics[6]:=stabilizer(g,6 ) ; ; parabolics[7]:=stabilizer(g,7 ) ; ; gap > cg:=cosetgeometry(g , parabolics ) ; cosetgeometry ( symmetricgroup ( [ 1 .. 8 ] ) ) gap > isfirmgeometry(cg ) ; true gap > isthingeometry(cg ) ; true gap >",
    "isthickgeometry(cg ) ; false gap > truncation:=cosetgeometry(g , parabolics{[1 .. 5 ] } ) ; cosetgeometry ( symmetricgroup ( [ 1 .. 8 ] ) ) gap > isfirmgeometry(truncation ) ; true gap > isthingeometry(truncation ) ; false gap > isthickgeometry(truncation ) ; false gap > truncation2:=cosetgeometry(g , parabolics{[4,5 ] } ) ; cosetgeometry ( symmetricgroup ( [ 1 .. 8 ] ) ) gap > isfirmgeometry(truncation2 ) ; true gap >",
    "isthingeometry(truncation2 ) ; false gap >",
    "isthickgeometry(truncation2 ) ; true ----    one of the concepts summarizing the properties of an incidence geometry ( on which a group acts flag - transitively ) is that of a _",
    "diagram_. we provide functionality to compute the diagram of a coset geometry and also to actually draw the diagram .",
    "since a diagram is in fact a labeled graph , drawing is done by producing some code which can be processed by the open source package ` graphviz ` @xcite .",
    "if the package ( which is not a gap package ) is installed on your computer , it will be invoked automatically and the result will be a postscript file with a picture of the diagram .",
    "[ source , gap ] ---- gap > diag:=diagramofgeometry(truncation ) ; gap > drawdiagram(diag , \" truncimg \" ) ; gap > exec(\"gv truncimg.ps \" ) ; ----    ]    interaction is also provided with the package which is very useful in studying a geometry as a ( coloured ) graph . using the ` incidencegraph ` command one obtains the incidence graph of an incidence structure @xmath101 .",
    "this can then be used , for example , to obtain the full automorphism group of the structure , using the very fast ` nauty ` package included with .",
    "some shortcut commands have been included for that .",
    "[ source , gap ] ---- gap > g : = psl(2,11 ) ; ; gap > g1 : = group ( [ ( 1,2,3)(4,8,12)(5,10,9)(6,11,7 ) ,   ( 1,2)(3,4)(5,12)(6,11)(7,10)(8,9 ) ] ) ; ; gap > g2 : = group ( [ ( 1,2,7)(3,9,4)(5,11,10)(6,8,12 ) ,   ( 1,2)(3,4)(5,12)(6,11)(7,10)(8,9 ) ] ) ; ; gap > g3 : = group ( [ ( 1,2,11)(3,8,7)(4,9,5)(6,10,12 ) ,   ( 1,2)(3,12)(4,11)(5,10)(6,9)(7,8 ) ] ) ; ; gap > g4 : = group ( [ ( 1,2,11)(3,8,7)(4,9,5)(6,10,12 ) ,   ( 1,2)(3,10)(4,9)(5,8)(6,7)(11,12 ) ] ) ; ; gap > cg:=cosetgeometry(g,[g1,g2,g3,g4 ] ) ; cosetgeometry ( group ( [ ( 3,11 , 9 , 7 , 5 ) ( 4,12,10 , 8 , 6 ) ,    ( 1 , 2 , 8) ( 3 , 7 , 9 ) ( 4,10 , 5 ) ( 6,12,11 ) ] ) ) gap >",
    "aut:=autgroupincidencestructurewithnauty(cg ) ; < permutation group with 4 generators > gap >",
    "structuredescription(aut ) ; \" psl(2,11 ) \" gap > cor:=corgroupincidencestructurewithnauty(cg ) ; < permutation group with 5 generators > gap >",
    "structuredescription(cor ) ; \" c2 x psl(2,11 ) \" ----",
    "a generalised @xmath7-gon is a point / line geometry whose incidence graph is bipartite of diameter @xmath7 and girth @xmath114 .",
    "generalised polygons were introduced by j. tits in @xcite .",
    "are examples of generalised @xmath0-gons and classical polar spaces of rank 2 are examples of generalised @xmath115-gons , also called generalised quadrangles . non - classical examples of projective planes and generalised quadrangles are well - known . by the famous theorem of feit and higman , a generalised @xmath7-gon which has at least three points on every line ,",
    "must have @xmath116 .",
    "two classes of examples of generalised hexagons are the so - called split cayley hexagons and the twisted triality hexagons , which are both derived from a triality of the lie geometries of type @xmath117 , which are in the finite case subgeometries of the hyperbolic quadric @xmath118 .",
    "generalised octagons seem to be rare . in the finite case ,",
    "only the so - called ree - tits octagon ( together with its dual ) is known .",
    "generalised polygons occur in several ways and one particular generalised polygon can often be represented in different ways .",
    "the framework for generalised polygons in fining is generic .",
    "it provides the user with a set of operations that are always applicable to any generalised polygon ( and its elements ) , independent of its representation .",
    "the classical examples such as classical projective planes , classical generalised quadrangles and the classical generalised hexagons are represented as lie geometries , but are also generalised polygons in fining and as such all generic operations for generalised polygons can be used .",
    "this generic framework also includes operations that deal with the incidence graph of the generalised polygon .",
    "we give some examples of the different possibilities to construct generalised polygons in fining .",
    "in example  [ ex : gp_blocks ] a projective plane of order @xmath115 is constructed by representing every line as a set of points .",
    "the points may be any set of objects , as long as the set of blocks is a set of subsets of the point set .",
    "in example  [ ex : tits ] the construction of the generalised quadrangle @xmath119 by using elements of a suitable projective space , is demonstrated .",
    "finally , example  [ ex : splitcayley ] demonstrates the construction of the split cayley hexagon .",
    "note that the construction operations used in the first two examples ` generalisedpolygonbyblocks ` and ` generalisedpolygonbyelements ` check whether the input really yields a generalised polygon .",
    "[ source , gap ] ---- gap > blocks : = [   >    [ 1 , 2 , 3 , 4 , 5 ] , [ 1 , 6 , 7 , 8 , 9 ] , [ 1 , 10 , 11 , 12 , 13 ] , >    [ 1 , 14 , 15 , 16 , 17 ] , [ 1 , 18 , 19 , 20 , 21 ] , [ 2 , 6 , 10 , 14 , 18 ] ,   >    [ 2 , 7 , 11 , 15 , 19 ] , [ 2 , 8 , 12 , 16 , 20 ] , [ 2 , 9 , 13 , 17 , 21 ] ,   >    [ 3 , 6 , 11 , 16 , 21 ] , [ 3 , 7 , 10 , 17 , 20 ] , [ 3 , 8 , 13 , 14 , 19 ] ,   >    [ 3 , 9 , 12 , 15 , 18 ] , [ 4 , 6 , 12 , 17 , 19 ] , [ 4 , 7 , 13 , 16 , 18 ] ,   >    [ 4 , 8 , 10 , 15 , 21 ] , [ 4 , 9 , 11 , 14 , 20 ] , [ 5 , 6 , 13 , 15 , 20 ] ,   >    [ 5 , 7 , 12 , 14 , 21 ] , [ 5 , 8 , 11 , 17 , 18 ] , [ 5 , 9 , 10 , 16 , 19 ] ] ; ; gap > gp : = generalisedpolygonbyblocks ( blocks ) ; < projective plane order 4 > ----    [ source , gap ] ---- gap > conic : = set(points(parabolicquadric(2,4 ) ) ) ; [ < a point in q(2 , 4 ) > , < a point in q(2 , 4 ) > , < a point in q(2 , 4 ) > ,     < a point in q(2 , 4 ) > , < a point in q(2 , 4 ) > ] gap > pg : = pg(3,4 ) ; projectivespace(3 , 4 ) gap > hyp : =   hyperplanebydualcoordinates(pg,[1,0,0,0]*z(q)^0 ) ; < a plane in projectivespace(3 , 4 ) > gap > em : = naturalembeddingbysubspace(pg(2,4),pg , hyp ) ; < geometry morphism from < all elements of projectivespace(2 , 4 ) >   to < all elements of projectivespace(3 , 4 ) > > gap > conic_at_infinity : = list(conic , x->x^em ) ; ; gap > group : = collineationgroup(pg ) ; the fining collineation group pgammal(4,4 ) gap > stab : = finingsetwisestabiliser(group , conic_at_infinity ) ; # i   computing adjusted stabilizer chain ...",
    "< projective collineation group with 6 generators > gap > points1 : = set(filtered(points(pg),x->not x in hyp ) ) ; ; gap > tangents : = list(conic , x->tangentspace(x)^em ) ; [ < a line in projectivespace(3 , 4 ) > ,",
    "< a line in projectivespace(3 , 4 ) > ,     < a line in projectivespace(3 , 4 ) > , < a line in projectivespace(3 , 4 ) > ,     < a line in projectivespace(3 , 4 ) > ] gap > planes : = list(tangents , x->filtered(planes(x),y->not y in hyp ) ) ; ; gap > points2 : = union(planes ) ; ; gap > points3 : = [ hyp ] ; [ < a plane in projectivespace(3 , 4 ) > ] gap > linesa : = union(list(conic_at_infinity , x->filtered(lines(x),y->not y in hyp ) ) ) ; ; gap > linesb : = set(conic_at_infinity ) ; ; gap > pts : = union(points1,points2,points3 ) ; ; gap > lns : = union(linesa , linesb ) ; ; gap > inc : = \\ * ; < operation \" * \" > gap > gp",
    ": = generalisedpolygonbyelements(pts , lns , inc , stab,\\^ ) ; < generalised quadrangle of order [ 4 , 4 ] > ----    [ source , gap ] ---- gap > gp : = splitcayleyhexagon(3 ) ; h(3 ) ----    example  [ ex : ree_tits_elemenst ] shows some particular operations on ( the elements of ) generalised polygons .",
    "we use the ree - tits octagon as example . note that the construction of this octagon is done by ` generalisedpolygonbyelements ` based on the construction as a coset geometry , also demonstrating that the construction operations for generalised polygons are generic .",
    "[ source , gap ] ---- gap > loadpackage ( \" atlasrep \" ) ; true gap > titsgroup:=atlasgroup(\"2f4(2 ) ' \" ) ; < permutation group of size 17971200 with 2 generators > gap > g1:=atlassubgroup(titsgroup,3 ) ; < permutation group of size 10240 with 2 generators > gap >",
    "g2:=atlassubgroup(titsgroup,5 ) ; < permutation group of size 6144 with 2 generators > gap > conj:=conjugacyclasssubgroups(titsgroup , g1 ) ; ; gap > # now look for the conjugate of g1 with maximal intersection gap > g1:=first(conj , sg - > size(intersection(sg , g2))=2048 ) ; < permutation group of size 10240 with 2 generators > gap > cg:=cosetgeometry(titsgroup,[g1,g2 ] ) ; ; gap > pts : = set(elementsofincidencestructure(cg,1 ) ) ; ; gap > lines : = set(elementsofincidencestructure(cg,2 ) ) ; ; gap > gp : = generalisedpolygonbyelements(pts , lines,\\*,titsgroup , oncosetgeometryelement ) ; < generalised octagon of order [ 2 , 4 ] > gap > order(gp ) ; [ 2 , 4 ] gap > p : = random(points(gp ) ) ; < a point in < generalised octagon of order [ 2 , 4 ] > > gap > lines : = lines(p ) ; < shadow lines in < generalised octagon of order [ 2 , 4 ] > > gap >",
    "l : = random(lines ) ; < a line in < generalised octagon of order [ 2 , 4 ] > > gap > distancebetweenelements(p , l ) ; 1 gap > m : = random(lines(gp ) ) ; < a line in < generalised octagon of order [ 2 , 4 ] > > gap > distancebetweenelements(m , l ) ; 8 ----    the third example shows these particular examples on the classical generalised polygons .",
    "[ source , gap ] ---- gap > h : = twistedtrialityhexagon(2 ^ 3 ) ; t(8 , 2 ) gap > p : = random(points(h ) ) ; # i   computing nice monomorphism ... # i   found permutation domain ... < a point in t(8 , 2 ) > gap > lines : = lines(p ) ; < shadow lines in t(8 , 2 ) > gap > l : = random(lines ) ; < a line in t(8 , 2 ) > gap > distancebetweenelements(p , l ) ; 1 gap > m : = random(lines(h ) ) ; < a line in t(8 , 2 ) > gap > distancebetweenelements(m , l ) ; 6 ----",
    "in fining some basic functionality for algebraic varieties defined over finite fields is implemented .",
    "the algebraic varieties in fining are defined by a list of multivariate polynomials over a finite field , and an ambient geometry .",
    "this ambient geometry is either a projective space , in which case the algebraic variety is called a projective variety , or an affine geometry , in which case the algebraic variety is called an affine variety .",
    "there is an iterator for the set of points that lie on the variety and the user is enabled to randomly choose one of these points .",
    "[ source , gap ] ---- gap > r:=polynomialring(gf(5),6 ) ; gf(5)[x_1,x_2,x_3,x_4,x_5,x_6 ] gap > f1:=sum(list(indeterminatesofpolynomialring(r),x->x^2 ) ) ; x_1 ^ 2+x_2 ^ 2+x_3 ^ 2+x_4 ^ 2+x_5 ^ 2+x_6 ^ 2 gap > f2:=r.1*r.2+r.3*r.4+r.5*r.6 ; x_1*x_2+x_3*x_4+x_5*x_6 gap > var:=algebraicvariety(pg(5,5),[f1,f2 ] ) ; projective variety in projectivespace(5 , 5 ) gap > points(var ) ;          < points of projective variety in projectivespace(5 , 5 ) > gap > size(points(var ) ) ;                       156 gap > random(points(var ) ) ;                                      < a point in projectivespace(5 , 5 ) > ----    specific methods are available for hermitian varieties and quadrics , as well as a method ` polarspace ` which returns the associated polar space consistent with the other functionality for polar spaces defined from forms .",
    "[ source , gap ] ---- gap > hv:=hermitianvariety(3,9 ) ;                            hermitian variety in projectivespace(3 , 9 ) gap > hp:=polarspace(hv ) ; < polar space in projectivespace(3,gf(3 ^ 2 ) ) : x_1 ^ 4+x_2 ^ 4+x_3 ^ 4+x_4 ^ 4=0 > gap > defininglistofpolynomials(hv ) ; [ x_1 ^ 4+x_2 ^ 4+x_3 ^",
    "4+x_4 ^ 4 ] gap > hv:=hermitianvariety(3,9 ) ;                hermitian variety in projectivespace(3 , 9 ) gap > defininglistofpolynomials(hv ) ; [ x_1 ^ 4+x_2 ^ 4+x_3 ^ 4+x_4 ^ 4 ] gap >",
    "hp:=polarspace(hv ) ; < polar space in projectivespace(3,gf(3 ^ 2 ) ) : x_1 ^ 4+x_2 ^ 4+x_3 ^ 4+x_4 ^ 4=0 > gap >",
    "polarspacetype(hp ) ; \" hermitian \" gap > isgeneralisedquadrangle(hp ) ;    true gap > order(hp ) ; [ 9 , 3 ] ----    the package fining also contains the veronese varieties , the segre varieties and the grassmann varieties ; three classical projective varieties .",
    "these varieties have an associated geometry morphism ( veronesemap , segremap , and grassmannmap ) and fining also provides some general functionality for these .",
    "example  [ ex : veronese ] shows this for the veronese variety in a five - dimensional projective space , by constructing the set of planes intersecting the variety in a conic .",
    "[ source , gap ] ---- gap > vv:=veronesevariety(pg(2,3 ) ) ;   veronese variety in projectivespace(5 , 3 ) gap > defininglistofpolynomials(vv ) ; [ -x_1*x_4+x_2 ^ 2 , -x_1*x_6+x_3 ^ 2 , -x_4*x_6+x_5 ^ 2 , x_1*x_5-x_2*x_3 ] gap > vm:=veronesemap(vv ) ; veronese map of < points of projectivespace(2 , 3 ) > gap > range(vm ) ; < points of veronese variety in projectivespace(5 , 3 ) > gap > vvpts:=set(points(vv ) ) ; ; gap > linesets:=list(lines(pg(2,3)),l->list(points(l ) ) ) ; ; gap > image_list:=list(linesets , list->span(imagesset(vm , list ) ) ) ; [ < a plane in projectivespace(5 , 3 ) > , < a plane in projectivespace(5 , 3 ) > ,     < a plane in projectivespace(5 , 3 ) > , < a plane in projectivespace(5 , 3 ) > ,     < a plane in projectivespace(5 , 3 ) > , < a plane in projectivespace(5 , 3 ) > ,     < a plane in projectivespace(5 , 3 ) > , < a plane in projectivespace(5 , 3 ) > ,     < a plane in projectivespace(5 , 3 ) > , < a plane in projectivespace(5 , 3 ) > ,     < a plane in projectivespace(5 , 3 ) > , < a plane in projectivespace(5 , 3 ) > ,     < a plane in projectivespace(5 , 3 ) > ] gap > list(image_list , plane->number(points(plane),x->x in vvpts ) ) ; [ 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 ] gap >",
    "vvstab:=finingsetwisestabiliser(homographygroup(pg(5,3)),vvpts ) ; # i   computing adjusted stabilizer chain ...",
    "< projective collineation group with 9 generators > gap > plane_orbs:=finingorbits(vvstab , planes(pg(5,3 ) ) ) ; 1% .. 3% .. 4% .. 5% .. 6% .. 7% .. 12% .. 14% .. 23% .. 28% .. 29% .. 38% .. 39% .. 43% .. 52% .. 60% .. 61% .. 63% .. 66% .. 68% .. 77% .. 82% .. 90% .. 99% .. 100% .. [ < closed orbit , 13 points > , < closed orbit , 13 points > ,     < closed orbit , 104 points > , < closed orbit , 468 points > ,     < closed orbit , 468 points > , < closed orbit , 468 points > ,     < closed orbit , 468 points > , < closed orbit , 234 points > ,     < closed orbit , 468 points > , < closed orbit , 1404 points > ,     < closed orbit , 936 points > , < closed orbit , 2808 points > ,     < closed orbit , 1872 points > , < closed orbit , 351 points > ,     < closed orbit , 2808 points > , < closed orbit , 234 points > ,     < closed orbit , 351 points > , < closed orbit , 1404 points > ,     < closed orbit , 2808 points > , < closed orbit , 2808 points > ,     < closed orbit , 468 points > , < closed orbit , 702 points > ,     < closed orbit , 936 points > , < closed orbit , 702 points > ,     < closed orbit , 2808 points > , < closed orbit , 1872 points > ,     < closed orbit , 2808 points > , < closed orbit , 2808 points > ,     < closed orbit , 144 points > , < closed orbit , 144 points > ] gap > filtered(plane_orbs , o->number(points(o[1]),x->x in vvpts)=4 ) ; [ < closed orbit , 13 points > ] gap > conicplanes:=last[1 ] ; < closed orbit , 13 points > gap > forall(image_list , plane->plane in conicplanes ) ; true ----            , _ diagram geometry _ , vol .",
    "57 of ergebnisse der mathematik und ihrer grenzgebiete .",
    "3 . folge . a series of modern surveys in mathematics [ results in mathematics and related areas .",
    "3rd series . a series of modern surveys in mathematics ] , springer , heidelberg , 2013 .",
    "related to classical groups and buildings ."
  ],
  "abstract_text": [
    "<S> fining is a package for computation in finite incidence geometry . </S>",
    "<S> it provides users with the basic tools to work in various areas of finite geometry from the realms of projective spaces to the flat lands of generalised polygons . </S>",
    "<S> the algebraic power of gap is exploited , particularly in its facility with matrix and permutation groups .    * keywords * : finite classical groups , finite projective spaces , finite classical polar spaces , coset geometries , finite generalised polygons , algebraic varieties , finite affine spaces , morphisms . </S>"
  ]
}