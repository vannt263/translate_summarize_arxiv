{
  "article_text": [
    "the source of this document is a .nw file ( for ` noweb , ' an implementation of knuth s literate programming technique : see ` literate programming with noweb , ' by andrew l. johnson and brad c. johnson , _ linux journal , _ october 1st 1997 ) .",
    "noweb allows one to mix latex with c ( or pretty well any programming language ) , allowing a well - annotated program .",
    "one can extract ` chunks ' from it .",
    "you need the noweb system , of course ( that is , notangle to extract the c part and noweave to typeset the full document ) .",
    "this document includes a makefile . to start the ball rolling ,",
    "you can extract it as follows :    notangle -t8 -rwagener.makefile wagener.nw > wagener.makefile    with it , you can make a cuda source file ( wagener.cu ) or a dvi copy of this document ( make dvi produces wagener.dvi )    there is one problem with wagener.cu . the construct",
    "< < <  > > > is a necessary part of the cuda source code , and it conflicts with noweb s construct < < ",
    "therefore wagener.cu contains    match_and_merge  lll  range ,  block  rrr  (  hood ,  newhood ,  scratch  ) ;    and it must be edited , changing lll to < <",
    "< and rrr to > > > .    / * * copyright ( c ) 2010 - 12 colm o dunlaing ( odunlain@maths.tcd.ie ) * * this file is free software : you can redistribute it and/or modify * it under the terms of the gnu general public license as published * by the free software foundation , either version 3 of the license , or * ( at your option ) any later version . * * this program is distributed in the hope that it will be useful , * but without any warranty ; without even the implied warranty of * merchantability or fitness for a particular purpose . see the * gnu general public license for more details .",
    "* * you should have received a copy of the gnu general public license * along with this program .",
    "if not , see < http://www.gnu.org / licenses/>. * /",
    "the present goal is to make a working cuda version of wagener s pram algorithm for computing an upper hood for a set of @xmath1 points presented in left - to - right order .",
    "we have not considered the memory access patterns which may seriously degrade performance .",
    "again , thread divergence may degrade performance  it is an interesting exercise to write ` non - divergent ' code .",
    "this has been done in some places and not in others .",
    "this program assumes that    * @xmath1 ( the number of points ) is a power of 2 . *",
    "no three points are collinear . *",
    "all @xmath2-coordinates are between 0 and 1 .",
    "we shall use the point remote , @xmath3 , for padding .",
    "any point whose @xmath2-coordinate is @xmath4 is assumed to be ` remote , ' used for padding .",
    "* there are no floating - point errors ( i.e. , it s a problem , but it s not our problem . )    also , three shared device arrays , one short and two float2 are used , of size @xmath1 .",
    "their total size is @xmath5 bytes .",
    "this puts inessential limitations on @xmath1  there would be no difficulty , and little overhead , in slicing the data into manipulable chunks for larger @xmath1 .",
    "copyright globals match and merge main    # include < stdio.h > # include < stdlib.h > # include < cuda.h >    float2 * point ; int count ; float2 * host_hood ; / * the following are device variables * / float2 * hood , * newhood ; short * scratch ;    float2 remote = \\ { 10.0f , 0.0f } ;    / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * make_remote ( ) without memcopy * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /    _ _ device _ _ void make_remote ( float2 * p ) \\ { p->x = 10.0f ; p->y = 0.0f ; }    points are stored in the array point , and initially copied to host_hood .",
    "the main program launches the global routine match_and_merge repeatedly to merge adjacent hoods from intervals of size @xmath6 to hoods of size @xmath7 .",
    "the algorithm repeatedly copies host_hood [ ] to device array hood [ ] , launchesmatch_and_merge ( ) , and copies the device array newhood [ ] to host_hood [ ] .    let @xmath8 ; @xmath9 is a positive integer .",
    "the hood is built in @xmath10 stages ( there is nothing to do if @xmath11 ) . at the @xmath12-th stage",
    ", let @xmath13 : host_hood defines @xmath14 hoods . for @xmath15 , let @xmath16 be the @xmath17-th block of @xmath6 points from point ( indexed from @xmath18 to @xmath19 ) .",
    "the @xmath17-th hood is @xmath20 .",
    "the corners of @xmath20 are stored in the corresponding block of host_hood , shifted left and padded with copies of remote ( figure [ fig : host_hood ] ) .",
    "-coordinates have been distorted in the depiction of host_hood.,height=192 ]    next , @xmath21 match_and_merge threads are launched in @xmath22 blocks of dimension @xmath23 , where @xmath24 and @xmath25 , so @xmath26 . the @xmath17-th block of threads cooperate to compute @xmath27 , where @xmath16 and @xmath28 are the @xmath29-th and @xmath30-st interval of @xmath6 points , locating the common tangent of @xmath20 and @xmath31 and replacing these separate hoods by @xmath27 , shifted and padded in a block of @xmath7 entries in hood .    the routine make_remote(float2 * p ) is used to set a point to remote values ( i m not sure how to assign a constant float2 value in device code ) .",
    "int pos_power_of_2 ( int x ) \\ { if ( x < 2 ) return 0 ;    while ( x > 1 ) if ( x return 0 ; else if ( x = = 2 ) return 1 ; else x /= 2 ; }    void show_current_hoods ( file * outfile , int d ) \\ { int i , j , hoodsize ; fprintf(outfile , `` for ( i=0 ; i < count / d ; + + i ) \\ { hoodsize = 0 ; for ( j=0 ; j < d ; + + j ) if ( host_hood[i*d+j].x < = 1.0 ) + + hoodsize ; fprintf(outfile , '' for ( j=0 ; j < d ; + + j ) if ( host_hood[i*d+j].x < = 1.0 ) fprintf(outfile , `` host_hood[i*d+j].y ) ; } fprintf(outfile , '' + n \" ) ; }    main ( int argc , char * argv [ ] ) \\ { int i ; int d , d1 , d2 ; file * file ; file * trace ; short * h_scratch ;    count = 0 ;    if ( argc ! = 2 & & argc ! = 3 ) \\ { fprintf(stderr , \" usage : argv[0 ] ) ; exit(-1 ) ; }    the program copies the points to standard output , computes the hood and writes the hood points to standard output",
    ". it may write comment lines beginning # .",
    "if the trace file is used , it prints the intermediate hood sequences to this file .",
    "the program output is intended to be sent to a companion program * hood2ps * which generates postscript .",
    "file = fopen ( argv[1 ] , `` r '' ) ; if ( file = = null ) \\",
    "{ fprintf(stderr , \" exit(-1 ) ; }    trace = null ; if ( argc = = 3 ) \\ { trace = fopen ( argv[2 ] , `` w '' ) ; if ( trace = = null ) fprintf(stderr,\"cant write to }    fscanf(file , `` if ( ! pos_power_of_2 ( count ) ) \\ { fprintf(stderr , ' ' count exit(-1 ) ; }    printf ( \" point = ( float2 * ) malloc ( count * sizeof(float2 ) ) ; host_hood = ( float2 * ) malloc ( count * sizeof(float2 ) ) ; h_scratch = ( short * ) malloc ( count * sizeof ( short ) ) ;    for ( i=0 ; i < count ; + + i ) \\ { fscanf(file , `` printf",
    "( '' host_hood[i ] = point[i ] ; } printf ( `` + n '' ) ;    d1 = 2 ; d2 = 1 ; d = d1 * d2 ;    hood = newhood = null ; scratch = null ;    data points , and host_hood will contain the intermediate hoods as illustrated in figure [ fig : host_hood ] .",
    "h_scratch is to hold a copy , on the host , of the device array scratch , for debugging .",
    "the shared device arrays hood , newhood , scratch are allocated at every thread launch .",
    "also , host_hood needs to be copied to hood before the thread launch .    while ( d < count ) \\ { if ( trace ! = null ) show_current_hoods ( trace , d ) ; if ( hood !",
    "{ cudafree ( hood ) ; cudafree ( newhood ) ; cudafree ( scratch ) ; }    cudamalloc ( ( void * * ) & hood , count * sizeof ( float2 ) ) ; cudamemcpy ( hood , host_hood , count * sizeof(float2 ) , cudamemcpyhosttodevice ) ;    cudamalloc ( ( void * * ) & newhood , sizeof ( float2 ) * count ) ; cudamalloc ( ( void * * ) & scratch , count * sizeof(short ) ) ;    now the thread launch : @xmath1 threads in @xmath22 blocks of dimension @xmath23 .    / * * lll and rrr need to be replaced * by triple < and > : double < and > * have a special meaning in noweb , * the literate programming system * we use .",
    "* /    dim3 range ( count / ( 2*d ) ) ; dim3 block ( d1 , d2 ) ; match_and_merge lll range , block rrr ( hood , newhood , scratch ) ;    when all threads have terminated , copy the revised array newhood to host_hood , and print various debugging items .",
    "cudamemcpy(host_hood , newhood , count * sizeof(float2 ) , cudamemcpydevicetohost ) ;    printf(\"#returned from match_and_merge , d1= d1 , d2 , d ) ;    cudamemcpy(h_scratch , scratch , count * sizeof ( short ) , cudamemcpydevicetohost ) ;    printf(``#scratch : + n # '' ) ; for(i=0 ; i < count ; + + i ) \\ { printf ( `` if ( i > 0 & & i printf ( '' + n # `` ) ; } printf ( '' + n \" ) ;    if ( d1 > d2 ) d2 * = 2 ; else d1 * = 2 ; d = d1 * d2 ; }    the following is for debugging .",
    "cudamemcpy(host_hood , newhood , count * sizeof(float2 ) , cudamemcpydevicetohost ) ;    printf(``#newhood contents + n '' ) ; for ( i=0 ; i < count ; + + i ) printf ( `` # if ( trace ! = null ) \\ { fprintf(trace,''0 + n \" ) ; fclose ( trace ) ; }    show_current_hoods ( stdout , count ) ;    return 0 ; }    the remaining functions are on the device . the function left_of ( ) returns 1 if @xmath12 is left of the directed line - segment @xmath32 , + ( i.e. , @xmath33 ) , 0 otherwise .",
    "/ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * left_of ( ) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /    _ _ device _",
    "_ int left_of ( float2 r , float2 p , float2 q ) \\ { float value ;    value = ( q.x - p.x ) * ( r.y - p.y ) - ( q.y - p.y ) * ( r.x - p.x ) ;    return ( value > 0 ) ; }    suppose @xmath16 and @xmath28 are adjacent intervals of points processed by a thread block in match_and_merge .",
    "given two points @xmath34 and @xmath35 @xmath35 is either a corner of @xmath31 or is remote , and @xmath34 is to the left of @xmath28 , there is a unique tangent to @xmath31 from @xmath16 : suppose @xmath36 is the corner of @xmath31 which supports the tangent .",
    "let @xmath37 be low , equal , or high according as @xmath35 is left of , at , or right of @xmath36 ( high if @xmath35 is remote ) .",
    "similarly if @xmath34 is remote or on @xmath20 and @xmath35 is to the right of @xmath16 , a function @xmath37 indicates whether @xmath34 is left of , at , or right of the point supporting the tangent to @xmath20 from @xmath35 ( or remote ) .",
    "these functions are implemented ( on the device ) by g and f below , where @xmath34 = hood[i ] and @xmath35 = hood[j ] and @xmath16 is defined by the range start ..",
    "start+d-1 , @xmath28 by start+d .. start+2*d-1 .",
    "# define low -1 # define equal 0 # define high 1    _ _ device _ _ short g ( float2 * hood , short i , short j , short start , short d ) \\ { float2 p , q , q_next , q_prev ; int atstart , atend ; int isleft ;    if ( hood [ j ] . x >",
    "1 ) / * remote * / return high ;    p = hood[i ] ; q = hood[j ] ;    atend = ( j = = start + 2*d - 1 || hood[j+1].x > 1.0 ) ;    atend signals the condition that @xmath35 is the rightmost corner of @xmath31 . as written , it might cause thread divergence , which could be remedied by adding an extra slot in hood and making it remote . using atend",
    ", we can ( without divergence ) make q_next default to a point directly underneath the righmost corner in @xmath31 , in the case where @xmath35 is the last corner in @xmath31 .",
    "if q_next is left of @xmath38 , then @xmath35 is low .",
    "q_next = hood [ j+1-atend ] ; q_next.y -= ( float ) atend ;    if ( left_of ( q_next , p , q ) ) / * * avoidable divergence ? * / return low ;    similarly atstart indicates whether @xmath35 is leftmost in @xmath31 , in which case q_prev is directly below it ; otherwise it is the corner of @xmath31 to its left ; @xmath35 is high iff q_prev is left of the directed line - segment @xmath38 .",
    "atstart = ( j = = start + d ) ; q_prev = hood [ j + atstart - 1 ] ; q_prev.y -= ( float ) atstart ;    isleft = left_of ( q_prev , p , q ) ;    return high * isleft + equal * ( 1-isleft ) ; }    / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * f ( i , j , start , d ) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /    _ _ device _ _ short f ( float2 * hood , short i , short j , short start , short d ) \\ { float2 p , q , p_next , p_prev ; int atstart , atend ; int isleft ;    if ( hood [ i ] . x >",
    "1 ) / * remote * / return high ;    p = hood[i ] ; q = hood[j ] ;    atend = ( i = = start + d - 1 || hood[i+1].x > 1 ) ;    p_next = hood [ i+1-atend ] ; p_next.y -= ( float ) atend ;    if ( left_of ( p_next , p , q ) ) return low ;    atstart = ( i = = start ) ; p_prev = hood [ i + atstart - 1 ] ; p_prev.y -= ( float ) atstart ;    isleft = left_of ( p_prev , p , q ) ;    return high * isleft + equal * ( 1-isleft ) ; }    r2.7 in        the workhorse of wagener s algorithm is the match_and_merge procedure below .",
    "recall that @xmath22 threads are launched in blocks of dimension @xmath23 .",
    "the @xmath17-th block is to calculate @xmath27 , where @xmath16 and @xmath28 are intervals of @xmath6 points in hood beginning at @xmath39 ( this offset is computed and stored in start ) .",
    "first start and other parameters are computed , and the scratch array is set to a recognisably ` uninitialised ' value .",
    "( scratch[start .. start+2*d-1 ] is shared by the threads in the same block ) .",
    "the main effort is calculating the corners of @xmath20 and @xmath31 supporting the common tangent .",
    "their indices will be placed in pindex and qindex , initially @xmath40 to show uninitialised .",
    "there are @xmath41 sample points along @xmath20 and @xmath42 along @xmath31 , but some of them will be remote .",
    "match_and_merge begins by setting the variables @xmath43 start , @xmath44 , indx to mirror the construction of its thread blocks . also , pindex , qindex , scratch are set to negative values , meaning not initialised .",
    "also @xmath45 and @xmath46 are set to sample corners ( indices ) in @xmath20 and @xmath31 .",
    "there are @xmath41 sample indices @xmath45 and @xmath42 sample indices @xmath46 .",
    "if @xmath47 is the set of sample indices @xmath45 , namely , @xmath48 , and correspondingly @xmath49 , then the procedure is outlined as follows .    for @xmath50 ,",
    "let @xmath51 , so @xmath52 .",
    "also , for @xmath53 , let @xmath54 , so @xmath55 .",
    "mam 0 : intialisations mam 1 : 0 = xd1 scratch[start+x]=max jy g(ix , jy ) = eq mam 2 : 0 = xd1 scratch[start+d+x]=j1(x)=unique j g(ix , j ) = eq mam 3 : scratch[start]=k0=max ix f(ix , j1(x ) ) = eq mam 4 : 0 = yd2 scratch[start+d+y]=ly = max jx , 0 = xd2 , g(k0+y , jx) = eq mam 5 : scratch[start .. ]= unique p = k0+y , q = ly+x , g(p , q)=f(p , q)=eq mam 6 : newhood[start .. ]= hood[start .. p ] catenated hood[q .. start+d-1 ]    / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * match_and_merge ( ) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /    _ _ global _ _ void match_and_merge ( float2 * hood , float2 * newhood , short * scratch ) \\",
    "{ int i , j , pindex , qindex , shift ; int d1 , d2 , d , start , x , y , indx ;    d1 = blockdim.x ; d2 = blockdim.y ; d = d1 * d2 ; start = blockidx.x * 2 * d ;    x = threadidx.x ; y = threadidx.y ; indx = x + d1 * y ;    pindex = qindex = -1 ;    scratch [ start + indx ] = -1 ; scratch [ start + indx + d ] = -1 ;    _ _ syncthreads ( ) ;    i = start + d2 * x ;    if ( hood[i].x < = 1.0 ) / * not remote * / \\ { j = start + d + d1 * y ;    / * * the condition below should identify the * unique interval of h(q ) touching the * tangent from hood[i ] . * /    if ( g(hood , i , j , start , d ) < = equal & & ( y = = d2 - 1 || hood[j+d1].x > 1.0     _ _ syncthreads ( ) ;    if ( hood[i].x < = 1.0 ) \\ { j = scratch[start + x ] + y ;",
    "if ( g(hood , i , j , start , d ) = = equal ) scratch[start + d + x ] = j ; else if ( d2 < d1 & & g(hood , i , j+d2,start , d ) = = equal ) scratch[start + d + x ] = j+d2 ; }    _ _ syncthreads ( ) ; @xmath34 and @xmath35 are the actual corners to be calculated , supporting the common tangent to @xmath20 and @xmath31 . for each sample point",
    "@xmath56 a corresponding tangent corner @xmath57 on @xmath31 has been calculated .",
    "the tangent corners @xmath57 occur in nondecreasing left - to - right order , and @xmath56 is left of , equal to , or right of @xmath34 according as @xmath58 is low , equal , or high",
    ".    * sketch proof .",
    "* parametrise the tangents to @xmath31 by the angle @xmath59 they make with the @xmath2-axis : @xmath59 varies over the clockwise interval from @xmath60 ( yielding the left vertical tangent ) to @xmath61 .",
    "r2.7 in        for each @xmath59 , let @xmath62 be the half - plane left of the tangent line at angle @xmath59 ( except at @xmath63 , this means above the tangent line ) .",
    "the map @xmath64 is , loosely speaking , continuous , and @xmath65 contracts with @xmath59 .",
    "the point of contact between @xmath62 and @xmath31 shifts discontinuously from corner to corner , but always rightward . at a unique angle , @xmath66",
    ", say , the intersection contains a single point , and that point is @xmath34 .",
    "the points @xmath56 under consideration are left and right endpoints of various sets @xmath65 , the points @xmath67 are points of contact between various @xmath62 and @xmath31 , and the points @xmath56 are left of , at , or right of @xmath34 according to the values of @xmath68 .",
    "j = scratch[start+d+x ] ; if ( hood[i].x < = 1.0 & & f(hood , i , j , start , d ) < = equal & & ( x = = d1 - 1 || hood[i+d2].x > 1.0 || f(hood , i+d2,scratch[start + d + x + 1],start , d ) = = high ) ) scratch[start ] = i ;    _ _ syncthreads ( ) ;    i = scratch[start ] + y ;    if ( hood[i].x < = 1.0 ) / * not remote * / \\ { j = start + d + x * d2 ; if ( g(hood , i , j , start , d ) < = equal & & ( x = = d1 - 1 || hood[j+d2].x > 1.0 || g(hood , i , j+d2,start , d ) = = high ) ) scratch[start + d + y ] = j ; }    _ _ syncthreads ( ) ;    j = scratch [ start + d + y ] + x ;    if ( x < d2 & & g(hood , i , j , start , d ) = = equal & & f(hood , i , j , start , d ) = = equal ) \\ { scratch [ start ] = i ; scratch [ start + 1 ] = j ; }    _ _ syncthreads ( ) ;    pindex = scratch [ start ] ; qindex = scratch [ start + 1 ] ;    newhood [ start + indx ] = hood [ start + indx ] ; make_remote ( & ( newhood [ start + d + indx ] ) ) ; _ _ syncthreads ( ) ;    let @xmath9 be the shift , qindex-pindex-1.then hood[qindex  start+2*d-1 ] is copied , shifted left by @xmath9 , to .",
    "shift = qindex - pindex - 1 ;    if ( start + d + indx > = qindex ) newhood [ start + d + indx - shift ] = hood [ start + d + indx ] ;    _ _ syncthreads ( ) ;    final closing brace in match and merge . }",
    ".suffixes : .nw .tex .c",
    "wagener : wagener.nw /usr / bin / notangle -rwagener -l wagener.nw > wagener.cu    dvi : wagener.nw /usr / bin / noweave -delay wagener.nw > wagener.tex latex wagener latex wagener rm wagener.out wagener.aux    clean : rm * .c * .dvi * .log",
    "wagener s pram algorithm , published only as a manuscript , is very clean and simple in comparison , for example , with another @xmath69 algorithm in [ [ acgoy ] ] .",
    "our program illustrates how wagener s pram algorithm might be realised on a cuda chip : the organisation , at any rate , is faithful to the model .",
    "however , it is insensitive to the memory bank conflicts which make the chip , although robust enough to tolerate these conflicts , so slow that the parallel program is slow by comparison with another serial program ( not described here ) .    on the other hand , we tried to avoid branching , another reason for serialisation , and the writing of branch - free code is an interesting challenge .",
    "another possible innovation was our usage of padding , rather than compression , which we felt too cumbersome .",
    "that is , data would be in blocks , with ` live ' data to the left of the block padded with ` remote ' values on the right .",
    "this left some threads with nothing to do , but it avoided allocation tasks .",
    "a few last words about optimal speedup .",
    "our algorithm gets the data points in sorted order , and in principle should use @xmath70 work ( runtime @xmath71 processor count ) : but it uses @xmath72 .",
    "we indicate how wagener s algorithm can achieve optimal speedup : @xmath69 time and @xmath70 work .",
    "so we suppose we have @xmath1 data points and @xmath73 processors .",
    "* separate the data into @xmath74 strips , 1 per processor , and compute the convex hood in each strip , @xmath69 time serially . *",
    "store the hood corners in each strip ( in left - to - right order ) in balanced trees of size @xmath75 . *",
    "overmars and van leeuwen devised a logarithmic time procedure , a balanced search , for locating common tangents : see [ [ acgoy],[od ] ] . applying their procedure to convex hoods stored in balanced trees , convex hoods can be merged in logarithmic time . *",
    "this means that with @xmath76 passes using @xmath77 processors per pass , convex hoods can be calculated for @xmath78 strips each containing @xmath79 points , each in time @xmath80 , hence @xmath81 overall , which is of course @xmath69 .",
    "* under the pram model , these trees can be flattened into arrays using @xmath82 processors per tree .",
    "now we have the same organisation as in our cuda algorithm , with strips of @xmath79 points each stored in an array . *",
    "our implementation involved finding the common tangent between adjacent hoods using @xmath83 processors for hoods of size ( at most ) @xmath83 , in @xmath84 time .",
    "+ given @xmath85 , this can be done with @xmath86 processors . in this case",
    "there are at least @xmath87 processors available .",
    "let @xmath88{k}$ ] , and let @xmath16 be the points in the left - hand strip and @xmath28 the points on the right .",
    "subdivide @xmath20 into @xmath89 intervals of length @xmath90 .",
    "for each interval endpoint @xmath34 , allocate @xmath90 processors which first inspect intervals in @xmath31 of length @xmath89 , bracketing the tangent from @xmath34 to one of these intervals ; next they bracket the tangent to an interval of length @xmath91 , then @xmath92 , and finally return the tangent from @xmath34 to @xmath31 .",
    "this brackets the common tangent endpoint in @xmath20 to an interval of length @xmath89 ; repeat the process to bracket to intervals of length @xmath91 and @xmath92 , and finally compute the common tangent .",
    "when run on the dataset illustrated , our cuda algorithm is perceptibly slower by comparison with a serial algorithm ( which is not described here ) .",
    "this is not surprising considering the serialisation of conflicting memory accesses . to attempt optimal speedup as described here",
    "would demand a great deal of effort .",
    "our cuda program is a specimen implementation of a pram algorithm which can not claim much speed advantage .",
    "1 .   [ acgoy ] ` parallel computational geometry , ' with alok aggarwal , bernard chazelle , leo guibas , and chee - keng yap ( 1988 ) .",
    "_ algorithmica * 3 * _ , 293 - 327 ( special issue on parallel processing ) .",
    "2 .   [ od ] some parallel geometric algorithms ( 1993 ) , in _ lectures on parallel computation , _ ed .",
    "alan gibbons and paul spirakis , cambridge university press , 77108 .",
    "3 .   [ wagener ] h. wagener ( 1985 ) .",
    "optimally parallel algorithms for convex hull determination .",
    "manuscript , technical university of berlin ."
  ],
  "abstract_text": [
    "<S> this paper describes a cuda implementation of wagener s pram convex hull algorithm in @xmath0 [ [ wagener],[od ] ] . </S>",
    "<S> it is presented in knuth s literate programming style . </S>"
  ]
}