{
  "article_text": [
    "many computer communications networks require nodes to broadcast information to other nodes for network control purposes ; this is done efficiently by sending messages over a spanning tree of the network . distributed minimum weight spanning",
    "tree algorithms are useful in communication networks when one wishes to broadcast information from one node to all other nodes and there with one cost assigned to each channel in the network .",
    "if in such a minimum weight spanning tree the degree of a node is large , it might cause an undesirable communication load in that node .",
    "therefore , the construction of minimum weight spanning trees in which the degree of a node is the lowest possible is needed . while it is easy enough to optimize the weight of a spanning tree , it is often more difficult to satisfy constraints which also involve the degrees of the nodes .",
    "the problem of minimizing the maximum degree of a spanning tree is known to be np - hard , as the hamiltonian path problem is merely a special case of this problem @xcite . in this paper , we consider the problem of finding a distributed approximation algorithm for finding a minimum weight spanning tree whose maximum degree is as low as possible",
    ". + _ previous and related work .",
    "_ let @xmath3 be the degree of an optimal solution .",
    "when edge weights are not considered , or assumed uniform , a @xmath7 approximation algorithm for minimizing the degree of spanning trees has been obtained by frer and raghavachari @xcite .",
    "a distributed version of the algorithm of frer an raghavachari which maintains the same performance approximation guarantee is proposed by blin and butelle @xcite . for the weighted case",
    ", fischer @xcite gives an approximation algorithm that computes a minimum weight spanning tree of degree at most @xmath8 in time @xmath1 for any constant @xmath9 , which is the best - known algorithm for this problem up to now .",
    "his algorithm is an adaptation of a local search algorithm of frer and raghavachari @xcite to the weighted case .",
    "recently , neumann and laumanns in @xcite extend fischer s algorithm to spanning forests .",
    "+ _ our results . _ in this paper , we propose a distributed version of fischer s approximation algorithm that computes a minimum weight spanning tree of degree at most @xmath10 , for any constant @xmath2 , where @xmath4 is the number of nodes of the network and @xmath3 is the maximum degree value of an optimal solution .",
    "our distributed algorithm requires @xmath5 messages and ( virtual ) time , and @xmath6 space per node . from the complexity analysis of our distributed algorithm , we are able to derive that fischer s sequential algorithm can be performed in @xmath11 time , which improves on fischer s upper bound on the time complexity .    the paper is organized as follows . in section 2 , we introduce the model of computation and we present fischer s sequential algorithm to compute a minimum degree minimum weight spanning tree . in section 3",
    "we describe our distributed algorithm and in section 4 we prove its correctness and complexity .",
    "finally , section 5 provides some concluding remarks .",
    "_ the model .",
    "_ we consider the standard model of asynchronous static distributed system .",
    "the point - to - point communication network is associated a weighted undirected graph @xmath12 .",
    "the set of nodes @xmath13 represents the processors of the network , the set of edges @xmath14 represents bidirectional non - interfering communication channels operating between neighboring nodes , and @xmath15 is a real - valued function defined on @xmath14 , which represents a cost assigned to each channel of the network .",
    "no common memory is shared by the nodes ( processes ) .",
    "in such networks , any process can generate one single message at a time and can send it to all its neighbors in one time step .",
    "every process owns one distinct identity from @xmath16 . however , no node has a global knowledge of the network topology , except of its own incident edges ( e.g. , every node is unaware of its neighbors identities ) .",
    "the distributed algorithm is event - driven and does not use time - outs , i.e. nodes can not access a global clock in order to decide what to do .",
    "moreover , each node runs the algorithm , determining its response according to every type of message received .",
    "namely , the algorithm specifies for any one node which computation is to be performed and/or which message be sent .",
    "the algorithm is started independently by all nodes , perhaps at different times . when the algorithm starts , each node is unaware of the global network topology but of its own edges . upon termination ,",
    "every node knows its neighbors identities within an approximated minimum degree minimum weight spanning tree .",
    "the efficiency of a distributed algorithm is evaluated in terms of _ message _ , _ time _ and _ space _ complexity as follows ( see @xcite ) .",
    "the _ message complexity _ of a distributed algorithm is the total number of messages sent over the edges .",
    "we also assume that each message contains @xmath17 bits , where @xmath18 and @xmath19 is the number of bits required to represent any real edge weight . in practical applications , messages of such a kind",
    "are considered of  constant \" size .",
    "the _ time complexity _ is the total ( normalized ) time elapsed from a change .",
    "the _ space complexity _ is the space usage per node .    _",
    "the problem .",
    "_ let @xmath20 be a real - weighted graph modeling the communication network .",
    "a spanning tree @xmath21 of @xmath22 is a tree such that @xmath23 and @xmath24 .",
    "the weight of a spanning tree @xmath25 of @xmath22 equals the sum of the weights of the @xmath26 edges contained in @xmath25 , and @xmath25 is called a _ minimum weight spanning tree _ , or mwst , if no tree has a smaller ( minimum ) weight that @xmath25 .",
    "our goal is to find a distributed polynomial algorithm to compute a mwst such that its maximum degree is as low as possible .",
    "we denote by @xmath27 and @xmath28 the set of neighbors of node @xmath29 in @xmath22 and in @xmath25 , respectively .    _ fischer s sequential algorithm .",
    "_ let @xmath25 be a tree on @xmath4 nodes .",
    "define the * rank * of @xmath25 to be the ordered @xmath4-tuple @xmath30 where @xmath31 denotes the number of nodes of degree @xmath32 in @xmath25 .",
    "define a lexicographical order on these ranks ; a tree @xmath33 on @xmath4 nodes is of lower rank that @xmath25 if @xmath34 for some @xmath35 and @xmath36 for @xmath37 .",
    "clearly , when an edge is added to a spanning tree , it creates a cycle .",
    "conversely , removing any edge from the induced cycle results again in a spanning tree .",
    "is defined to be any such exchange of edges ; a swap is said _ cost - neutral _ if the edges exchanged are of equal weight .",
    "consider a swap between the edges @xmath38 and @xmath39 , with @xmath40 .",
    "such a swap may increase by one the degree of both @xmath29 and @xmath41 in @xmath25 , but it also reduces the degree of @xmath42 .",
    "so , the rank of @xmath25 is decreasing if the degree of @xmath42 in @xmath25 is at least the maximal degree of @xmath29 and @xmath41 plus 2 . a * locally optimal * minimum weight spanning tree is a mwst in which no cost - neutral swap can decrease the rank of the tree .",
    "( fischer @xcite ) [ tf1 ] if @xmath25 is a locally optimal mwst , and @xmath43 is the maximum degree in @xmath25 , then @xmath44 for any constant @xmath2 , where @xmath3 is the maximum degree of an optimal solution .    as can be deduced from the proof of theorem [ tf1 ] in fischer s paper @xcite , in order to construct a locally optimal spanning tree",
    ", it is sufficient to consider those nodes with degree at least equal to @xmath45 among high - degree nodes .",
    "fischer s polynomial algorithm to compute a locally optimal spanning tree can be described as follows .",
    "+ * fischer s algorithm :*    1 .",
    "start with any mwst @xmath25 .",
    "let @xmath46 be the desired approximation parameter .",
    "let @xmath47 be the number of distinct edge weights , @xmath48 , in @xmath25 .",
    "2 .   let @xmath43 be the current maximum degree in @xmath25 .",
    "3 .   for every node @xmath49 , check for appropriate improvements .",
    "conduct a depth first traversal of @xmath25 starting from @xmath41 .",
    "1 .   let @xmath15 be the current vertex on the traversal of @xmath25 , and @xmath50 be the @xmath51-path in @xmath25 .",
    "2 .   assign variables @xmath52 such that @xmath53 denotes the maximum degree of those nodes adjacent to edges of weight @xmath54 in @xmath50 .",
    "3 .   if there is an edge @xmath55 , let @xmath54 be its weight .",
    "if @xmath53 is at least two greater that the degree of @xmath41 and @xmath15 in @xmath25 , and @xmath56 , the the edge @xmath57 can be used to reduce the high - degree rank of @xmath25 . conduct the appropriate swap on @xmath25 , and repeat to step ( 1 ) for the next round .",
    "4 .   if no appropriate cost - neutral swap was found in any of the traversals , terminate .",
    "fischer proves in @xcite that each round of his previous algorithm takes @xmath58 time and that the number of rounds can be bounded by @xmath59 .",
    "therefore , fischer s algorithm computes a locally optimal minimum weight spanning tree in time @xmath60 .",
    "in section  [ highlevel ] , a high - level description of our distributed algorithm is given , and in section  [ detail ] , we detail the description of the algorithm .",
    "every process is running the following procedure , which consists of a list of the responses to each type of messages generated .",
    "each node is assumed to queue the incoming messages and to reply them in first - come , first - served order ( fifo ) .",
    "any reply sent is completed before the next is started and all incoming messages are also delivered to each node via an initially empty first - come first - served queue .",
    "let @xmath22 be a connected graph modeling an interconnection network .",
    "we now describe the general method used to construct a locally optimal minimum weight spanning tree @xmath25 of @xmath22 .",
    "first , we assume that some current minimum weight spanning tree @xmath25 of @xmath22 is already constructed .",
    "( various mwst distributed algorithms are @xmath61 message optimal , e.g.  @xcite , while the best time complexity achieved is @xmath6 in  @xcite . )",
    "next , for each edge @xmath62 , let @xmath63 ( resp .",
    "@xmath64 ) be the subtree of @xmath65 containing the node @xmath66 ( resp .",
    "@xmath67 ) ( see fig .",
    "[ fig1 ] ) .",
    "= 0.5    the algorithm is divided into rounds , and each round is consisting of the following four phases .",
    "+ @xmath68 * initialization phase .",
    "* let @xmath43 be the maximum current degree of the mwst @xmath25 .",
    "first , each node of @xmath25 must know @xmath43 .",
    "this can be done by starting an election on @xmath25 , where all nodes broadcast their degree in @xmath25 .",
    "before checking an edge to find an appropriate cost - neutral swap ( see fig .  [ fig1 ] ) , we need to do the following . for each edge",
    "@xmath69 in @xmath25 and for each node @xmath70 , we determine , which of the nodes @xmath67 or @xmath66 is the closer to @xmath42 ( in terms of distance in @xmath25 ) .",
    "for the purpose , the node @xmath67 initiates a broadcast by forwarding the token @xmath71 to all nodes in @xmath64 .",
    "when a node @xmath72 receives the token @xmath73 , @xmath42 knows that for any appropriate swap involving the edge @xmath69 , it needs to find a neighbor @xmath74 in @xmath22 such that @xmath75 . in an analogous way",
    ", node @xmath66 initiates a similar broadcast in @xmath63 .",
    "@xmath68 * search - edge phase .",
    "* whenever an edge @xmath69 in the current mwst @xmath25 ends the initialization phase , it begins searching for an edge @xmath76 to perform an appropriate swap .",
    "thus , node @xmath67 starts a search for a node @xmath72 with a neighbor @xmath75 , for which @xmath77 and such that the maximal value of the degrees of @xmath67 and @xmath66 in @xmath25 is at least two greater than the degree of @xmath42 and @xmath74 .",
    "if such a node @xmath42 is found , it sends a message to @xmath67 ( via edges in @xmath64 ) to announce success .",
    "if there is no node in @xmath64 meeting the previous conditions then @xmath67 is informed that edge @xmath69 can not be used to an appropriate swap on @xmath25 .",
    "similarly , node @xmath66 starts such a search in @xmath63 .",
    "if no appropriate cost - neutral swap is found in this phase , the algorithm terminates .",
    "@xmath68 * edge - election phase . *",
    "if a node @xmath67 enters this phase then , there exists a pair of edges @xmath78 and @xmath79 which can execute an appropriate swap on @xmath25 .",
    "however , @xmath67 must ensure that it belongs to the one only pair of edges that can achieve such a swap .",
    "so , @xmath67 starts an election procedure and it chooses among the possible initiators ( i.e. the nodes that reached this phase ) one node to perform the swap .",
    "so , each initiator @xmath67 forwards its identity to all other nodes in @xmath25 .",
    "the elected node is the one with the minimal identity .",
    "@xmath68 * edge - exchange phase . *",
    "if node @xmath67 wins the edge - election phase , then there exists again at least one pair of edges @xmath78 and @xmath76 that can be used to complete the appropriate swap on @xmath25 ( reducing the high - degree rank of @xmath25 ) .",
    "thus , @xmath67 informs @xmath66 that they are not connected in @xmath25 anymore and starts a search in @xmath64 for the node @xmath42 ( assuming @xmath72 ) .",
    "when @xmath42 is found , it informs @xmath74 that they are now connected within @xmath25 .",
    "finally , @xmath42 sends a message to all other nodes in the current tree to inform that a new round can initiate .",
    "the algorithm is described for a node @xmath67 in the network .",
    "we begin by describing the variables maintained by @xmath67 . + * local variables of @xmath67 : * ( let @xmath25 denote the current minimum weight spanning tree . )    * _ @xmath80:\\ { \\left\\ { \\mbox{branch , unbranch } \\right\\}}$ ] . _ node @xmath67 maintains the variable for each @xmath81 .",
    "an edge @xmath69 belongs to @xmath25 if and only if @xmath82 = \\mbox{\\it branch}$ ] . *",
    "_ @xmath83 : \\mbox{integer};\\ w_p[r ] : \\mbox{real}$ ] . _",
    "the variables @xmath84 and @xmath43 denote the degree of @xmath67 and the maximal degree of @xmath25 , respectively . for each @xmath81 ,",
    "the variables @xmath85 $ ] and @xmath86 $ ] denote the degree of the neighbor @xmath66 of @xmath67 in @xmath25 and the weight of the edge @xmath69 in @xmath22 , respectively . * _ @xmath87 : \\mbox{integer}$ ] .",
    "_ for each edge @xmath88 , the variable @xmath89 $ ] denotes the neighbor of @xmath67 closer to node @xmath66 in @xmath63 ( if @xmath90 ) .",
    "_ default value : _ @xmath89 = p$ ] , for each @xmath91 . *",
    "_ @xmath92 : \\mbox{integer}$ ] .",
    "_ for each edge @xmath93 , the variable @xmath94 $ ] denotes the node @xmath95 closer to @xmath67 in @xmath25 . _ default value : _",
    "@xmath94 = \\mbox{\\it udef}$ ] , for each edge @xmath93 . * _",
    "@xmath96 , \\mbox{countfail}_p[uv ] : \\mbox{integer}$ ] .",
    "_ for each edge @xmath93 , the variables @xmath97 $ ] and @xmath98 $ ] maintain the number of neighbors of @xmath67 which already instanced the variable @xmath99 $ ] .",
    "moreover , the variable @xmath98 $ ] counts the number of neighbors of @xmath67 which find no edge to replace @xmath57 .",
    "_ default values : _ @xmath97 = \\mbox{\\it countfail}_p[uv ] = 0 $ ] , for each edge @xmath93 . *",
    "_ @xmath100 : { \\left\\ { 0,1,2 \\right\\}}$ ] .",
    "_ for each @xmath101 , the variable maintains the state of the initialization phase of the edge @xmath78 .",
    "_ default value : _ @xmath102 = 0 $ ] , for each @xmath101 .",
    "* _ @xmath103 : { \\left\\ { 0,1 \\right\\}}$ ] .",
    "_ for each edge @xmath93 , the boolean variable is used to check whether an edge @xmath76 is found in @xmath22 which replaces @xmath57 .",
    "_ default value : _",
    "@xmath104 = 0 $ ] , for each edge @xmath93 . *",
    "_ @xmath105 . _",
    "the variable @xmath106 maintains the number of neighbors of @xmath67 in @xmath25 s.t .",
    "the associated edge in @xmath25 is useless to any edge - exchange in a current round .",
    "if @xmath107 , it means that no edge incident to @xmath67 can be used in view of an exchange in a current round . the variable @xmath108 maintains the number of nodes in @xmath25 for which there is no edge incident to the ones that can be used in an exchange .",
    "if in a round , @xmath109 , it means that the algorithm is terminated .",
    "_ default values : _ @xmath110 . *",
    "_ @xmath111 .",
    "_ if during a search - edge phase a subset of edges in @xmath25 finds an edge appropriate to an exchange , all corresponding edges - incident nodes begin an election to decide on the edge to be exchanged . if @xmath67 knows that an election phase is running , _",
    "@xmath112_. _ default value : _ @xmath113 . * _ @xmath114 . _",
    "the variable maintains the state of @xmath67 during an edge - election phase ( _ winner or loser _ ) .",
    "@xmath115 _ , it means that @xmath67 does not know if an edge - election phase is taking place in a current round .",
    "_ default value : _ @xmath116 . * _ @xmath117 .",
    "_ during an edge - election phase , the variable maintains the number of nodes that lost the election w.r.t .",
    "node @xmath67 .",
    "clearly , if @xmath118 , node @xmath67 wins the election , i.e. an edge incident to @xmath67 becomes elected .",
    "_ default value : _ @xmath119 . * _ @xmath120 . _",
    "the variable maintains the identity of the winning node during an edge - election phase . _",
    "default value : _ @xmath121 . * _ @xmath122 . _",
    "the variable maintains the pair of elected edges ( if any ) in view of an appropriate exchange in a current round . if @xmath123 , then a pair of edges @xmath69 and @xmath124 is found in @xmath22 , s.t .",
    "@xmath78 , @xmath76 , @xmath125 = p$ ] , @xmath126 = r$ ] , @xmath127 =    w_p[r]$ ] , and where @xmath128\\}$ ] .",
    "_ default value : _ @xmath129 .",
    "now , each node @xmath67 executes the following steps .",
    "+ * initial assumptions : * assume that the algorithm starts with any mwst @xmath25 of @xmath22 already given .",
    "we need the algorithm constructing @xmath25 to be `` process terminating '' ( i.e. every node knows that the mwst algorithm is terminated ; however , no distributed termination detection is available ) .",
    "so , we can assume that @xmath67 knows its degree @xmath84 in @xmath25 , and for each @xmath81 , the variables @xmath130 $ ] , @xmath85 $ ] and @xmath86 $ ] are correctly computed .",
    "let @xmath131 be the desired approximation parameter . +",
    "* initialization phase :*    1 .",
    "in order to determine the maximum degree @xmath43 in the current tree @xmath25 , @xmath67 initiates an election ( all nodes in @xmath25 are initiators ) by sending the token @xmath132 to all its neighbors in @xmath25 .",
    "node @xmath67 wins the election if the token @xmath132 is maximal w.r.t . the lexicographic order . as",
    "all vertices are initiators , we also use this step to initialize the remaining local variables of @xmath67 with their default values ( see the definition of local variables of @xmath67 above ) .",
    "2 .   for each edge",
    "@xmath93 and for each node @xmath91 , we need to compute the values of variables @xmath94 $ ] and @xmath89 $ ] .",
    "this is done as follows . 1 .",
    "* for * each @xmath133 * do * 1 .",
    "@xmath134 \\textbf{${\\leftarrow}$ } p$ ] ; 2 .",
    "send @xmath135 to each node @xmath101 s.t .",
    "@xmath136 ; 2 .   upon receipt of @xmath137 1 .",
    "@xmath94 \\textbf{${\\leftarrow}$ } u$ ] ; 2 .",
    "@xmath138 \\textbf{${\\leftarrow}$ } q$ ] ; 3 .",
    "* if * @xmath67 is not a leaf * then * send @xmath139 to each node @xmath101 s.t .",
    "@xmath140 ; 4 .   *",
    "if * @xmath67 is a leaf * then * send @xmath141 to node @xmath138 $ ] ; 3 .   upon receipt of @xmath141 1 .",
    "@xmath97 \\textbf{${\\leftarrow}$ } \\mbox{\\it countside}_p[uv ] + 1 $ ] ; 2 .",
    "* if * @xmath142 * and * @xmath97 = |n_t(p)| - 1 $ ] * then * send @xmath143 to node @xmath138 $ ] ; 3 .   *",
    "if * @xmath144 * and * @xmath97 = |n_t(p)| - 1 $ ] * then * + -  send @xmath145 to node @xmath41 ; + -  @xmath146 \\textbf{${\\leftarrow}$ } \\mbox{\\it endinit}_p[v ] + 1 $ ] ; + -  * if * @xmath146 = 2 $ ] * then * edge @xmath147 finishes the initialization phase and can * go to * step 3 .",
    "4 .   upon receipt of @xmath148 1 .",
    "@xmath149 \\textbf{${\\leftarrow}$ } \\mbox{\\it endinit}_p[q ] + 1 $ ] ; 2 .",
    "* if * @xmath149 = 2 $ ] * then * edge @xmath150 finishes the initialization phase and can * go to * step 3 .",
    "* search - edge phase : *    1 .",
    "if there is some neighbor @xmath151 of @xmath67 in @xmath25 for which @xmath149 = 2 $ ] , it means that the edge @xmath150 is ready to initiate a search for some possible unused edge @xmath124 of @xmath22 in view of an appropriate exchange . for our purpose , the edge @xmath150 must meet the condition @xmath152\\ }",
    "\\geq    \\delta_t - \\lceil \\log_bn\\rceil$ ] .",
    "otherwise , @xmath153 can not be considered in this phase .",
    "this is done as follows . 1 .   * if * @xmath154 s.t .",
    "@xmath155 = 2 $ ] * and * @xmath152\\ } \\geq    \\delta_t - \\lceil \\log_bn\\rceil$ ] * then * send @xmath156{\\rangle}$ ] to each node @xmath101 , with @xmath140 , and where @xmath157\\}$ ] .",
    "2 .   upon receipt of @xmath158{\\rangle}$ ] 1 .   *",
    "if * @xmath159 s.t .",
    "@xmath82 = \\mbox{\\it unbranch } , \\mbox{\\it side}_r[uv ] = v ,        w_p[r ] = w_u[v ] , \\mbox { and } d_{uv } \\geq \\max\\{d^t_p , d_p[r]\\ } + 2 $ ] * then * send @xmath160 to node @xmath138 $ ] ; + * else * + -  * if * @xmath67 is a leaf * then * send @xmath161 to node @xmath138 $ ] ; + -  * if * @xmath67 is not a leaf * then * send @xmath158{\\rangle}$ ] to each node @xmath101 s.t . @xmath162 $ ]",
    "; 3 .   upon receipt of @xmath163 1 .",
    "@xmath104 \\textbf{${\\leftarrow}$ } 1 $ ] ; 2 .",
    "* if * @xmath142 * then * send @xmath163 to node @xmath138 $ ] ; 3 .",
    "* if * @xmath144 * then * @xmath67 is ready to begin the edge - election phase and can * go to * step 4 .",
    "4 .   upon receipt of @xmath161 1 .",
    "@xmath98 \\textbf{${\\leftarrow}$ } \\mbox{\\it countfail}_p[uv ] +       1 $ ] ; 2 .",
    "* if * @xmath104 \\neq 1 $ ] * then * + -  * if * @xmath142 * and * @xmath98 = |n_t(p)| - 1 $ ] * then * send @xmath161 to node @xmath138 $ ] ; + -  * if * @xmath144 * and * @xmath98 = |n_t(p)| - 1 $ ] * then * 1 .",
    "@xmath164 ; 2 .",
    "send @xmath165 to node @xmath41 ; 3 .   *",
    "if * @xmath107 * then * send @xmath166 to each node @xmath101 in order to check whether the algorithm is terminated ; 5 .",
    "upon receipt of @xmath167 or @xmath168 1 .",
    "@xmath169 ; 2 .   *",
    "if * @xmath109 * then * the algorithm terminates .",
    "* edge - election phase : *    1 .",
    "this phase begins when @xmath67 receives a message @xmath170 , which means that the edge @xmath78 can be exchanged for an unused edge @xmath171 . before the change , @xmath67",
    "must ensure that it is the only node in @xmath25 that performs this operation . to this end , @xmath67 initiates an election procedure in @xmath25 and it picks among the possible initiators ( i.e. the nodes that reached this phase ) the one that makes the edge exchange .",
    "note that from this step till the end of the current round , any message of type @xmath172 , @xmath173 , @xmath174 , @xmath175 , @xmath176 , @xmath177 , @xmath178 , and @xmath179 received by @xmath67 is ignored .",
    "let @xmath180\\}$ ] .",
    "if * @xmath113 * then * 1 .   @xmath181 ; @xmath182 ; @xmath183 ; 2 .",
    "send @xmath184 to each node @xmath185 ; + * else * ( @xmath186 ) 1 .   *",
    "if * @xmath187 * and * @xmath116 * then * +  let @xmath188 ; * if * @xmath189 * then * @xmath190 ; 2 .   upon receipt of @xmath191 1 .   *",
    "if * @xmath113 * then * + - @xmath192 ; @xmath183 ; @xmath193 ; + - send @xmath194 to each node @xmath101 ; + - * if * @xmath67 is not a leaf * then * send @xmath195 to each node @xmath101 s.t @xmath136 ; + * else * ( @xmath186 ) + - * if * @xmath196 * then * 1 .   * if * @xmath197 and @xmath187 then +  @xmath193 ; +  send @xmath194 to each node @xmath101 ; 2 .",
    "* if * @xmath67 is not a leaf * then * send @xmath195 to each node @xmath101 s.t .",
    "@xmath136 ; 3 .",
    "@xmath192 ; 3 .   upon receipt of @xmath198 1 .   * if * @xmath186 * and * @xmath116 * then * + - * if * @xmath199 * then * @xmath200 .",
    "+ moreover , if @xmath118 * then * @xmath201 ; * go to * step 5 . + - * if * @xmath202 * then * @xmath193 ; 2 .   *",
    "if * @xmath203 * and * @xmath67 is not a leaf * then * send @xmath204 to each node @xmath101 s.t . @xmath205 .",
    "* edge - exchange phase : *    1 .",
    "if @xmath67 wins the edge - election phase , i.e. @xmath206 , with @xmath207 . then the edge @xmath78 is ready to be exchanged for the unused edge @xmath171 . note that from this step till the end of the current round , any message received by @xmath67 which is distinct from types @xmath208 , @xmath209 , @xmath210 , and @xmath211 is ignored .",
    "so , during this phase the following is done . 1 .   @xmath68",
    "send @xmath212 to node @xmath66 ; + @xmath68 @xmath82 \\textbf{${\\leftarrow}$ } \\mbox{\\it unbranch}$ ] ; @xmath85 \\textbf{${\\leftarrow}$ } d_p[r ] - 1 $ ] ; @xmath213 ; + @xmath68 send @xmath214 to each node @xmath215 ; 2 .   upon receipt of @xmath216 + @xmath68 @xmath217 \\textbf{${\\leftarrow}$ } \\mbox{\\it unbranch}$ ] ; @xmath218 \\textbf{${\\leftarrow}$ } d_p[q ] - 1 $ ] ; @xmath213 ; 3 .   upon receipt of @xmath219 1 .   *",
    "if * @xmath220 and @xmath67 is not a leaf * then * send @xmath219 to each node @xmath221 $ ] ; 2 .   *",
    "if * @xmath222 * then * + -  send @xmath223 to node @xmath74 ( via the unused edge @xmath224 ) ; + -  @xmath225 \\textbf{${\\leftarrow}$ } \\mbox{\\it branch}$ ] ; @xmath226 \\textbf{${\\leftarrow}$ } d_p[y ] + 1 $ ] ; @xmath227 ; 4 .   upon receipt of @xmath228 + @xmath68 @xmath217 \\textbf{${\\leftarrow}$ } \\mbox{\\it branch}$ ] ; @xmath218 \\textbf{${\\leftarrow}$ } d_p[q ] + 1 $ ] ; @xmath227 ; + @xmath68 send @xmath229 to each node @xmath230 ; 5 .",
    "upon receipt of @xmath231 + @xmath68 * if * @xmath67 is not a leaf * then * send @xmath229 to each node @xmath232 s.t . @xmath233 ; + @xmath68 * go to * step 1 .",
    "( this round is ended and @xmath67 executes a new round . )",
    "[ tcor ] the distributed algorithm described in section 3 for computing a locally optimal minimum weight spanning tree is correct and deadlock - free .",
    "let @xmath25 be the mwst computed in a current round of the algorithm .",
    "if any node @xmath67 of @xmath25 meets the condition @xmath234 ( the number of nodes in @xmath25 ) , it means that no edge in @xmath25 can find another edge outside @xmath25 in view of a cost - neutral swap to reduce the rank of @xmath25 .",
    "in such a situation , the algorithm terminates . by definition",
    ", @xmath25 is indeed a locally optimal minimum weight spanning tree and the algorithm is correct .",
    "moreover , by construction , when a node of @xmath25 generates a message to send through the edges in @xmath25 , it uses each edge of @xmath25 at most once ; and it is removed ( i.e. disappears ) either by reaching its destination or whenever it arrives to a leaf of @xmath25 . upon receipt of a message ,",
    "any node @xmath67 executes some instructions if @xmath67 and the information within the message meet specific properties .",
    "otherwise , the message is ignored by the node . finally , when a cost - neutral swap reducing the rank of @xmath25 is found , all nodes in @xmath25 are informed and initiate a new round ( see steps 5.4 and 5.5 ) .",
    "otherwise , all nodes in @xmath25 are informed that the algorithm is terminated ( see steps 3.5 and 3.6 ) .",
    "consequently , we may conclude that the algorithm is also deadlock - free .",
    "[ lcom ] each round of the distributed algorithm in section 3 requires @xmath6 messages and time @xmath6 .",
    "we assume that the algorithm starts with any mwst @xmath25 of @xmath22 available beforehand ( @xmath235 ) . in order to compute the maximum degree of the current tree @xmath25 ,",
    "an election is triggered in step  ( 1 ) .",
    "the time and message complexity of such a tree election is @xmath6 ( see @xcite ) .",
    "now , consider any edge @xmath93 . by construction , both nodes @xmath29 and @xmath41 generate one single message of each type @xmath172 , @xmath175 and @xmath209 ( see steps 2.1 , 3.1 and 5.1 , resp . ) , which traverses only once each edge in @xmath236 and @xmath237 , respectively .",
    "these messages disappear whenever they reach a leaf node .",
    "therefore , the number of such messages sent over @xmath25 is at most equal to @xmath238 .",
    "next , consider the edges of @xmath25 that are incident to nodes in @xmath236 .",
    "one of the nodes incident to such edges generates one message of each type @xmath173 , @xmath239 and @xmath177 ( see steps 2.2 and 3.2 , resp . ) , which is sent to node @xmath29 .",
    "thus , these messages traverse each edge in @xmath236 only once and the same property holds in the subtree @xmath237 .",
    "therefore , the number of such messages sent over @xmath25 is at most equal to @xmath238 .",
    "further , each node in @xmath25 can generate one message of each type @xmath240 , @xmath241 and @xmath211 ( see steps 4.1 , 4.2 and 5.4 , resp . ) , which is broadcast through the tree @xmath25 .",
    "therefore , the number of such messages sent over @xmath25 is at most equal to @xmath242 .",
    "finally , the remaining messages are exchanged once between neighbors .",
    "therefore , the number of messages sent over @xmath25 within a current round is @xmath6 .",
    "the time complexity of the algorithm during a round can be derived from the above analysis by observing that a node @xmath29 can broadcast a message to all its neighbors in one time step and the distance in @xmath25 from @xmath29 to any destination node is at most @xmath243 .",
    "[ lround ] for any constant @xmath46 , the number of rounds used by the distributed algorithm in section 3 can be bounded from above by @xmath244 .",
    "we use a potential function similar to fischer s , with the difference that only high - degree nodes have a potential value greater or equal to one .",
    "a similar potential function is also used in  @xcite .",
    "let @xmath43 be the maximum degree of the current mwst @xmath25 on @xmath4 nodes during a round of the algorithm .",
    "let @xmath245 and let @xmath246 be the degree of a node @xmath41 in @xmath25 .",
    "the _ potential _ of the node @xmath41 is define as follows , @xmath247 denote @xmath248 .",
    "since @xmath2 , @xmath249 .",
    "let us now compute the change in potential , @xmath250 , when the algorithm performs a local improvement involving a node of degree at least @xmath251 in @xmath25 .",
    "assume edge @xmath124 is added to @xmath25 and edge @xmath57 is removed from @xmath25 ; also assume w.l.o.g .",
    "that @xmath252 .",
    "since the algorithm only performs swaps which reduce the degree of some high - degree node , we have that @xmath253 and @xmath254 . by a simple case analysis , it is easy to check that , in a local improvement , the potential decreases of the smallest amount possible if @xmath255 and @xmath256 .",
    "in such a case , any local improvement reduces the potential by @xmath257 .",
    "therefore , in any local improvement , @xmath258 .",
    "this implies that after at most two local improvements ( i.e. rounds ) , @xmath259 decreases of at least one unit .",
    "hence , the algorithm finds a locally optimal mwst in @xmath260 rounds .    for any constant @xmath2 ,",
    "the distributed algorithm in section 3 requires @xmath5 message and time , and @xmath6 space per node to compute a minimum weight spanning tree of maximum degree at most @xmath0 , where @xmath4 is the number of nodes of the network and @xmath3 is the maximum degree value of an optimal solution .",
    "the algorithm is assumed to start with any mwst @xmath25 of @xmath22 ( e.g. by using the algorithm in @xcite beforehand ) .",
    "now , for each edge @xmath93 , each node @xmath67 maintains the variables @xmath261 $ ] , @xmath97 $ ] , @xmath262 $ ] and @xmath104 $ ] in particular ( see section  [ detail ] ) . since @xmath25 is a tree on @xmath4 nodes , its number of edges is @xmath243 , and so the algorithm requires @xmath6 space per node .",
    "finally , by theorems  [ tf1 ] and [ tcor ] , and lemmas  [ lcom ] and [ lround ] , the theorem follows .",
    "note that the proof of lemma [ lround ] works also in the sequential case .",
    "therefore , we obtain the following corollary , which improves on fischer s time complexity .    for any constant @xmath2 ,",
    "fischer s sequential algorithm in  @xcite ( section 2 ) finds a minimum weight spanning tree of maximum degree at most @xmath0 in @xmath263 time .",
    "in the paper , we present a distributed approximation algorithm which computes a minimum weight spanning tree of degree at most @xmath264 , for any constant @xmath2 .",
    "the message and time complexity of the algorithm is @xmath5 and it requires @xmath6 space per node . to our knowledge , this is the first distributed approximation algorithm for the minimum degree minimum weight spanning tree problem .",
    "99 b. awerbuch .",
    "optimal distributed algorithms for minimum weight spanning tree , counting , leader election and related problems , _ in proc . symp . on theory of computing _ , 230 - 240 , 1987 .",
    "l. blin , f. butelle .",
    "the first approximated distributed algorithm for the minimum degree spanning tree problem on general graphs , _ int .",
    "j. on fond . in comput .",
    "_ , * 15*(3 ) : 507 - 516 , 2004 .",
    "t. fischer . optimizing the degree of minimum weight spanning trees ,",
    "_ technical report 93 - 1338 _ , department of computer science , cornell university , ithaca , ny , usa , 1993 .",
    "m. frer , b. raghavachari . approximating the minimum degree spanning tree to within one from the optimal degree , _ journal of algorithms _ , * 17*:409 - 423 , 1994 ( a preliminary version appeared in soda92 ) .",
    "r. g. gallager , p. a. humblet , p. m. spira . a distributed algorithm for minimum weight spanning trees , _",
    "acm trans .",
    "_ , * 5*:67 - 77 ( 1983 ) .",
    "m. r. garey , d. s. johnson . _ computers and intractability : a guide to the theory of np - completeness _ , w. h. freeman eds .",
    ", san francisco , 1979 .",
    "f. neumann , m. laumanns .",
    "speeding up approximation algorithms for np - hard spanning forest problems by multi - objective optimization , _ electronic coll .",
    "on comput . complexity _",
    ", report no 29 , 2005 .",
    "_ introduction to distributed algorithms _ , cambridge university press , 1994 .",
    "in order to facilitate the reading of our paper , we give the proof of fischer s theorem [ tf1 ] in section 2 as follows .",
    "+ * proof of theorem [ tf1 ] ( fischer  @xcite ) .",
    "* let @xmath2 be any constant and let @xmath22 be a connected graph on @xmath4 nodes .",
    "consider a locally optimal mwst t of @xmath22 with maximum degree @xmath43 .",
    "let @xmath265 denote the set of nodes of degree at least @xmath32 in @xmath25 .",
    "clearly , @xmath266 .",
    "since @xmath267 for all @xmath32 , the ratio @xmath268 can not be greater that @xmath269 for @xmath270 consecutive values of @xmath32 .",
    "therefore , for any constant @xmath9 , there exists some integer @xmath271 in the range @xmath272 such that @xmath273 .",
    "suppose we choose an integer @xmath271 to satisfy this property , and remove from @xmath25 the edges adjacent to nodes in @xmath274 .",
    "let @xmath275 denote the remaining edges of @xmath25 .",
    "as @xmath25 is initially connected , then there are at least @xmath276 or @xmath277 connected components in @xmath275 .",
    "consider the graph @xmath278 formed by contracting every component of @xmath275 .",
    "since any mwst of @xmath22 must contain a mwst of @xmath278 , any mwst must include at least @xmath279 edges from @xmath278 .",
    "consider an edge @xmath55 not in @xmath25 between two components of @xmath275 .",
    "let @xmath280 denote the @xmath51-path in @xmath25 , and @xmath281 denote those edges of @xmath280 which appear in @xmath278 , the edges on the path which are adjacent to any node in @xmath274 .",
    "suppose neither @xmath41 nor @xmath15 is in @xmath282 .",
    "since @xmath25 is locally optimal , no cost - neutral swap can reduce the rank of @xmath25 , so @xmath51 must be more expensive that any edge in @xmath281 .",
    "since @xmath51 and @xmath281 form a cycle in @xmath278 , this implies that @xmath51 may not participate in a mwst of @xmath278 .",
    "therefore , only edges which are adjacent to nodes in @xmath282 may participate in a mwst of @xmath278 , and any mwst of @xmath22 must contain at least @xmath283 edges that are adjacent to @xmath282 .",
    "earlier we chose @xmath271 to satisfy the inequality @xmath284 . substituting , we see there must be at least @xmath285 edges adjacent to nodes in @xmath286",
    "therefore , the average degree of a node in @xmath286 must be at least @xmath287 , and so , @xmath288 ."
  ],
  "abstract_text": [
    "<S> fischer @xcite has shown how to compute a minimum weight spanning tree of degree at most @xmath0 in time @xmath1 for any constant @xmath2 , where @xmath3 is the value of an optimal solution and @xmath4 is the number of nodes in the network . in this paper , we propose a distributed version of fischer s algorithm that requires messages and time complexity @xmath5 , and @xmath6 space per node . </S>",
    "<S> + _ keywords _ : distributed algorithms , approximation algorithms , minimum degree minimum weight spanning trees . </S>"
  ]
}