{
  "article_text": [
    "functional programming is based on the lambda - calculus , with its main principle developed in 1930 , by alonzo church and stephen cole kleene . with lambda - calculus",
    "we can define the notion of computable function , and using the rules defined by lambda - calculus we can express and evaluate any computable function .",
    "but in the early development stage of computer science the computer calculating mechanisms were based on another calculating model , such as a turing machine s .",
    "the turing machine functioning mechanism was described in 1936 by the mathematician alan turing , in the same time as lambda calculus .",
    "the turing machine was the base of neumann s architecture computer model and determined the developmental direction of programming language . in consequence",
    "most of the real - world applications was based on imperative programming language .    only with the development of software technologies it became possible to design programming languages based on stable mathematics like functional programming language and declarative programming language : lisp ( 1958 ) , prolog ( 1970 ) , haskell ( 1990 ) , clean ( 1995 ) and so on .",
    "but the usage of these languages in the real - world applications is still very little .",
    "some well - known applications of functional languages are the yahoo shopping engine and the telecommunication software design by ericsson .",
    "a program in a functional programming language consists of a collection of function definition and an initial expression .",
    "so the basic method of computation is the application of functions to arguments with the goal to evaluate the initial expression .",
    "the basic concepts and the basic elements of a functional programming language can be defined as follows :    * persistent data structures : data once built never changes * recursion : primary control structure * high - order functions : functions that take functions as argument and in case return function as result .    by contrary to functional programming in the imperative programming style",
    "the main goal is to follow the changes of the states .",
    "the basic concepts of an imperative language are :    * mutable data structures : with assignment statement we can change the value of some data * looping : the primary control structure * first - order programming : we can not operate with function as first - class entities .",
    "the clean programming language , that we are use for implementing the rsa file encryption scheme is a pure and lazy functional language , with a fast compiler . was developed on the university of nijmegen , netherlands .",
    "the first version was released in 1995 .",
    "this language has most of the characteristic that a functional language must to have , some of them : is nt allowed the destructive updates ; has the referential transparency property ; the basic computation form is the recursion ; we can use high order functions ; it is strongly typed ; list comprehension is allowed ; polymorphism is allowed too and so on .    in the real world one of the most known software for cryptography , writing in functional programming language",
    "is cryptol @xcite .",
    "it was designed by galois connections inc . in consultation with expert cryptographers between 2003 - 2008 .",
    "as developers say cryptol is a high - level specification language for cryptography that means programmers who use cryptol can focus on the cryptography itself , and are not attended by machine - level details . in the same time they can deal with low - level problems , namely it can work with low level data , such as array of bits .",
    "the code written in cryptol can be converted to other languages such as haskell , vhdl and c. it can use with various platform such as embedded systems , smart cards and fpgas .",
    "another well - known software package in this field is the rsa - haskell , @xcite , which was published in 2007 , by david sankel .",
    "it is written in haskell and as the author says it is a `` collection of command - line cryptography tools and a cryptography library '' . with rsa - haskell using command - line tools",
    "users can do secure communication : encrypt / decrypt some message , can identify the sender and authenticate the message .",
    "the crypto library is licensed under the gpl ( general public license ) , and allowed for users to access some cryptography algorithms to incorporate these in their application .",
    "the size of the rsa - key is 2048 bit , and sha512 hash algorithm is used in conjunction with oaep ( optimal asymmetric encryption padding ) , @xcite .",
    "in the past cryptography was the science of secret codes . today due to the electronic world the data security is in the center of the attention .",
    "this means that it became more than producing secrete code .",
    "the topmost tasks are privacy , integrity , authentication , and nonrepudiation",
    ".    cryptography algorithms can be classified in two groups such as symmetric - key cryptography and public - key cryptography according to what kind of keys are in use in the system : secret or public keys . in the case of symmetric - key cryptography",
    "the processes of encrypting and decrypting are coming to pass with the same secret key , in contrast to public - key cryptography where the encrypting are coming to pass with public key , and the decrypting with an other key , with private key .",
    "besides encryption schemes more other schemes belong to the public - key cryptography such as digital signatures schemes , authentications schemes , and so on @xcite . but on backwards our attention will focus only on public - key encryption schemes .",
    "so , now we will give the formal definition of the public - key encryption scheme , @xcite :    a public - key encryption scheme with message space @xmath0 can be define with three algorithms : @xmath1 , where    * @xmath2 is the key generation algorithm , which determines in a random way the public and secret key - pairs : @xmath3 , where @xmath4 is the public key and @xmath5 is the secret key , * @xmath6 is the encryption algorithm , which encrypts a message @xmath7 , producing the ciphertext : @xmath8 , where @xmath9 , * @xmath10 is the decryption algorithm , which decrypts the ciphertext @xmath11 , @xmath12 .    for the correctness of the system we require that @xmath13 . for the security of the system the corresponding requirements can not be claim so easy .",
    "one of them is that the public key inversion problem ( finding the secret key for a given public key ) must be based on a hard mathematical problem , in average case of the problem instances .",
    "another requirement is that the ciphertext inversion problem ( finding the encrypted @xmath7 message for a given @xmath11 ciphertext and @xmath4 public key ) must be hard .",
    "but very few problems we are known that achieves these requirements , thus not surprising that in a real word application the most of the cryptography systems are based on the following mathematical problems :    * factoring large integers , for instance the rsa cryptosystem * computing discrete logarithms , for instance the elgamal cryptosystem .    for these problems no one knows polynomial time algorithms , moreover these problems are those scarce problems that are not classify between the p and np - complete classes , @xcite .",
    "because in our implementation we concern on rsa file encryption scheme , first we will present the basic rsa encryption scheme , @xcite .",
    "this scheme consists in three steps , corresponding to the 3 algorithms specified in the formal definition of public - key encryption scheme : key generation , encryption , decryption .",
    "the message space is the @xmath14 , where @xmath15 is an integer number , calculated in the key generation step .",
    "the value of @xmath15 determines the order of magnitude of the rsa - key .    *",
    "generating the rsa keys consists on the following steps , where @xmath16 is the euler function , and @xmath17 is the greatest common divisor of the arguments , @xcite : * * generating two big random prime numbers : @xmath18 , * * calculates the product @xmath19 , henceforth @xmath15 we will call modulus , * * selects randomly @xmath20 , where @xmath21 and @xmath22 , henceforth @xmath20 we will call encryption exponent , * * computes @xmath23 , where : @xmath24 , @xmath25 , henceforth @xmath23 we will call decryption exponent , * * the public key consist : @xmath26 , * * the private key consist : @xmath27 . * for encryption of @xmath28 we do : @xmath29 . * for decryption of @xmath30",
    "we do : @xmath31 .",
    "now we shall present the implementation details of the rsa file encryption .",
    "firstly we mention that arithmetic with large numbers is quite easy in clean , through importing the bigint library , @xcite .",
    "henceforth we give the definition of this importing as well as the definitions of constants , are used several times in the system to be realized .    ....",
    "import bigint my_one : = = tobigint 1 my_two : = = tobigint 2 my_zero:== tobigint 0 alph : = = tobigint 256 ....    by the way of implementing rsa file encryption system , several questions are coming up : to find the modular multiplicative inverse ; to perform the modular exponentiation ; to generate big ( more than 100 digit ) random prime number ; to convert the number from the base @xmath32 in the base @xmath33 and inverse ; to perform the rsa encryption on numbers ; do the file i / o task ; create a graphical interface .    in the following sections , one after another we will briefly present how we are resolved this questions in the clean programming language .",
    "in order to find the multiplicative inverse of an integer @xmath34 @xmath35 we need to resolve the congruence : @xmath36 with the unknown coefficient @xmath37 . this congruence can be solved by using the extended euclid s algorithm , @xcite .",
    "for this we write two functions :    * an auxiliary function : @xmath38 , with the role of doing the proper computation , namely to calculate the coefficient of a , * the main function @xmath39 doing the necessary initialization and the first call of @xmath38 .",
    "the clean code that do this is the following :    .... seuclid : : bigint bigint bigint bigint->bigint seuclid a b x1 x2      |b==my_zero = x2      |otherwise = seuclid b ( a rem b ) ( x2-(a / b)*x1 ) x1    meuclid : : bigint bigint - > bigint meuclid a b      # res = seuclid a b my_zero my_one      |res < my_zero = ( res+b ) rem b      |otherwise = res rem b ....      the modular exponentiation calculates the value of @xmath40 using the fast exponentiation technique , @xcite . for this purpose",
    "we write the function , @xmath41 .",
    "the clean code that do this is the following :    .... mexp : : bigint bigint bigint- > bigint mexp x n m      |n = = my_zero = my_one      # x1 = ( x*x ) rem m      |isodd n = ( x * mexp x1 ( n / my_two ) m ) rem",
    "m      = mexp x1 ( n / my_two ) m ....      to set the rsa - key we need prime random numbers . for testing if a random number with the right size is prime or not we use probabilistic primality test which quickly eliminates the composite numbers . for this test",
    "we use the miller - rabin primality test @xcite .",
    "the formal definition of this test is the following :    let the odd number @xmath42 and @xmath43 such that @xmath44 . if the odd number @xmath45 is prime , then for all numbers @xmath46 , where @xmath47 one of the following statements is true :    * @xmath48 , * for one of the @xmath49 : @xmath50 , where @xmath51 .",
    "for that in the clean programming language we write the function @xmath52 which determines the value @xmath43 and @xmath42 in the exponent @xmath53 by calling the @xmath54 function . to test the second statement of the above definition",
    "we write the @xmath55 function .",
    "the validity of the first statement is tested by the main function @xmath56 . for this purpose",
    "we calculate the value @xmath57 with the modular exponentiation algorithm .",
    "the clean code that do this is the following :    .... millerrabin : : bigint bigint - > bool millerrabin n x      # ( q , j ) = mfind",
    "n      # y = mexp x q n      |y = = my_one = true      = subtest n y j    mfind : : bigint - > ( bigint , bigint ) mfind n = sfind ( n - my_one)my_zero    sfind : : bigint bigint - > ( bigint , bigint ) sfind q k      |iseven q = sfind ( q / my_two ) ( k + my_one )      = ( q , k )    subtest : : bigint bigint bigint - > bool subtest n y j",
    "|j < my_one = false      |y = = ( n - my_one ) = true      |y = = my_one = false      = subtest n ( ( y * y ) rem n ) ( j - my_one ) ....    for generating random number we use the algorithm of linear congruential generator @xcite .    to be certain of that an odd number @xmath45 is prime , we must have the result true in the @xmath56 function , for more , different @xmath46 random numbers .",
    "for that we examine the number @xmath45 if it is odd or it is even , and in the case it is odd we generate @xmath58 bit random number and test @xmath58 times for these @xmath46 , if the @xmath59 function is true or not .      in the rsa encryption scheme we can encrypt only a single large number . in rsa file encryption",
    "we must to encrypt many bytes . to achieve this we do a pre - processing on bytes that we want to encrypt .",
    "we choose @xmath60 bytes , that corresponds to the size of the block that we are encrypt all at once .",
    "we see these bytes as digits in base 256 and we make a conversion from 256 to base @xmath61 @xcite .",
    "after that we have a single big number which we encrypt corresponding the scheme presented in section 2 . the clean function which resolves this conversion is @xmath62 by the help of auxiliary function @xmath63 .",
    "the clean code that do this is the following :    .... myconvert1 : : bigint bigint bigint- > [ char ] myconvert1 nr p pk = subconvert1 nr p pk my_one [ ]    subconvert1 : : bigint bigint bigint bigint [ char ] - > [ char ] subconvert1 nr p pk nr1 tomb      | nr1 > = pk = tomb      | otherwise = [ ( tochar ( toint ( nr rem p ) ) ) :                      ( subconvert1 ( nr / p ) p pk ( nr1+my_one ) tomb ) ] ....    after encryption in the process of decryption we must do the inverse conversion , so we need an algorithm that makes the conversion from @xmath33 to @xmath32 .",
    "the clean code that do this is the following :    .... myconvert : : [ char ] bigint bigint - > bigint myconvert n p pk = subconvert n p pk my_zero my_one    subconvert : : [ char ] bigint bigint bigint bigint - > bigint subconvert [ ] p pk nr exp   = my_zero subconvert [ kezd : veg ] p pk nr exp",
    "| pk = = nr = my_zero       = ( tobigint ( toint kezd ) ) * exp +              ( subconvert veg p pk ( nr+my_one ) ( exp*p ) ) ....      to attain the rsa encryption first we generate the private , secret key - pairs , after that we perform encryption / decryption with this keys . for efficiency reason , but without loss of security we have choose @xmath20 as a constant : @xmath64 to be encryption exponent in the public key pair .",
    "this choice is commonly used in practice to speed up encryption .",
    "in contrast , for security issues , to avoid the small decryption exponent attack , decryption exponent can not be too small .",
    "@xmath23 must have approximately the same size as modulus @xmath15 , @xcite .",
    "these choices determine the encryption and decryption time , so decryption time always will be much longer than encryption time .",
    "several technics were developed to shorten the decryption time , one of them is using the chinese remainder theorem .",
    "but even with these technics rsa encryption / decryption is much slower than the commonly used symmetric - key encryptions methods .",
    "after that we generate two big prime numbers and calculate their product @xmath15 . now using the multiplicative inverse function we can calculate the private key @xmath23 as an inverse of integer @xmath20 modulo @xmath65 .",
    "the clean code that do this is the following :    .... privatk : : bigint bigint bigint - > bigint privatk e p q      # pq = ( p - my_one)*(q - my_one )      |gcd e pq < > my_one = abort \" not relative prime \"      = meuclid e pq ....    to encrypt a number @xmath46 , where @xmath66 and @xmath67 we can do one modular exponentiation : @xmath68 .",
    "so the magnitude of the modulus @xmath15 determines the magnitude of the number that we can encrypt at one go , and in the same time basically determines the running time of the application .",
    "the clean code that do this is the following :    .... rsacrypt : : bigint bigint bigint - > bigint rsacrypt x e m = mexp x e m ....    for decryption",
    "we do the same computation , the differences consist in the value of actual parameter , we use the decryption exponent @xmath23 instead of @xmath20 .      because the clean is a pure functional language the destructive updates are not admissible , but when we dealt with a file i / o we must to have the possibility to destructively update the file . in clean",
    "this situation was resolved by introducing a new type , for which we use the * notation in the type name . with this type",
    "we can restrict the references of some date structure , and when the reference is unique , the update of date structure is allowed @xcite .",
    "using this technics the file i / o is quite simple in clean .    to obtain more security in file encryption , several block cipher technics can be use .",
    "the most common block ciphers are the ecb ( electronic codebook ) , cbc ( cipher - block chaining ) , cfb ( cipher feedback ) and ofb ( output feedback ) modes . in our implementation",
    "we use the ecb mode , and we use the same key for every block encryption / decryption .    as long as we want to use the rsa file encryption as a block cipher we must set @xmath60 , the size of the blocks .",
    "we assume that the plain text is a binary file so the alphabet size that we are using is 256 , corresponding to possible byte values , thus the size of a block is @xmath69 , where @xmath15 is the rsa modulus .",
    "now we present the function @xmath70 which has the role : testing if we are at the end of the plain text file ; reading @xmath71 bytes from this file ; calculating @xmath72 , the number of bytes that were effectively read ; converting these bytes from base @xmath33 to base @xmath32 ; encrypting the result ; converting the result to base @xmath73 ; writing in an encrypted file the number @xmath72 ; writing the @xmath74 bytes in an output file , that will be the encrypted file .",
    "the clean code that do this is the following :    .... filecrypt : : * file * file ( bigint , bigint ) - > ( * file , * file ) filecrypt inf outf ( e , n )      # !",
    "( atend , inf ) = fend inf      |atend = ( inf , outf )      # k = nrblok",
    "n alph      # ( inf , res ) = mread ( k - my_one ) inf      # ( k2 , cr ) = filecrypt ` res k e n      # outf = fwritec ( tochar k2 ) outf      # outf = mwrite cr outf      = filecrypt inf outf ( e , n )    filecrypt ` : : [ char ] bigint bigint bigint - > ( int , [ char ] ) filecrypt ` res k e n      # k2 = length res      # nr = myconvert res alph ( tobigint k2 )      # scr = rsacrypt nr e n      # cr = myconvert1 scr alph ( k+my_one )      = ( k2 , cr ) ....    the function @xmath75 used in above code has the role to read a given number of bytes from a file while the function @xmath76 has the role to write a list of bytes in a file .          in clean",
    "using the object i / o library we can write flexible , platform independent programs , with a well designed graphical user interface , @xcite . for obtaining an easy method to manipulate our input / output , such as generating public / secret key ; showing the key generation time ; selecting input / output file ; doing the encryption / decryption ; showing the encryption / decrytion time we design a graphical interface with different dialog items such as button controls , edit controls , text controls .",
    "our application graphical interface , for a certain jpg files with 48.9 kb size , and for 1024 bit key size have the following appearance , where we made out the value of public , secret keys ( do this only for testing case ) , the key generation time for these values in seconds , and the encryption / decryption times in seconds are given in fig .",
    "1 .    to measure the running time of certain function we got the computer tick , and determined the difference between two ticks",
    "we have the following built in functions :    .... getcurrenttick : : !",
    "* env - > ( ! tick , !",
    "* env ) tickdifference : : ! tick !",
    "tick - > int ....    to measure the performance of an application we have another possibility that clean offers : we can enable time profiling option insight in the clean environment , which means that after the execution the program will write a profile file .",
    "for our application the generated profile file is given in fig .",
    "this profile file is overwritten after every program execution and will consist the real time measurements of each function in seconds , the number of bytes allocated in the heap by the function an so on .",
    "most of cryptography applications assure security on hardware and software level too . the main disadvantage using functional programming in cryptography",
    "is that applications written in functional programming language can guarantee security principally on software level .",
    "this fact constrains the applicability of functional programming language in area of cryptography .",
    "another reason withdrawal in usage of functional programming in range of security is that the community of programmers who use functional programming language for building their cryptography s software is relatively small , and the available documentation is still very scarce .",
    "our program vulnerability is the usage of linear congruential generator for generating random number , which is known as not very safe .",
    "but our purpose not was to study the complex area of pseudorandom number generator algorithms .",
    "our experience shows that cryptography algorithms coded in a functional programming language are much shorter than those coded in c , java , maple .",
    "it is relatively easy to test the functional programming function independently from the entire program .",
    "the syntax `` forces '' the programmer to write more modular codes , so it is simple to locate and correct errors in these modules .",
    "type errors are much easier to prevent and in case , to correct .",
    "we can easy issue efficiency in time and space .",
    "the process of the file i / o are relatively simple .",
    "it has a built - in library for large numbers , which means that working with large numbers becomes quite simple .",
    "the concept and syntax are permitting the correct use of necessary mathematics , so the programmer can focus on these , and not loosing time on circumstance of implementations . for those who know functional language",
    "it is easy to read and understand clean code .    taking account of our algorithms time consuming and correctness , and considered the capacity of software package presented in the first section we can establish that the usage of functional programming language ca nt be considered inconvenient .",
    "so we can conclude that functional programming is a very useful tool to write stable an efficient cryptography applications .",
    "99 p. http://www.cs.ru.nl/~peter88/[achten ] , m. wierichurl , ftp://ftp.cs.kun.nl/pub/clean/supported/objectio.1.2/doc/tutorial.pdf[_a tutorial to the clean object i / o library _ ] , technical report csi - r0003 , february 2000 , university of nijmegen , 294 pag .",
    "a. http://math.ubbcluj.ro/~bege/pages/cv_hu.html[bege ] , z. http://www.ms.sapientia.ro/~kasa/[ksa ] , _ algoritmikus kombinatorika s szmelmlet _",
    "( algorithmic combinatorics and number theory ) , http://www.editura.ubbcluj.ro/index_en.php[presa universitar clujean ] ( cluj university press ) , 2006 .        p. http://www.ece.cmu.edu/~koopman[koopman ] , r. http://www.cs.ru.nl/~rinus/[plasmeijer ] , m. van http://www.cs.ru.nl/~marko[eekelen ] , s. smetsers , _ functional programming in clean , _ + http://clean.cs.ru.nl/contents/clean_book/clean_book.html      a. j. http://www.cacr.math.uwaterloo.ca/~ajmeneze/[menezes ] , p. c. van http://people.scs.carleton.ca/~paulv/[oorschot ] , s. a. http://www.cacr.math.uwaterloo.ca/people/faculty/vanstone.html[vanstone ] , _ handbook of applied cryptography _ , crc press , boca raton , florida , 1997 .    r. l. http://people.csail.mit.edu/rivest/[rivest ] , a. http://www.faculty.idc.ac.il/arik/site/index.asp[shamir ] , l. http://www.usc.edu/dept/molecular-science/fm-adleman.htm[adleman ] , a method for obtaining digital signatures and public key cryptosystems , http://cacm.acm.org/[_comm .",
    "acm _ ] , * 21 , * 2 ( 1978 ) 120126 ."
  ],
  "abstract_text": [
    "<S> cryptography is the science of information and communication security . up to now , for efficiency reasons </S>",
    "<S> cryptographic algorithm has been written in an imperative language . but </S>",
    "<S> to get acquaintance with a functional programming language a question arises : functional programming offers some new for secure communication or not ? </S>",
    "<S> this article investigates this question giving an overview on some cryptography algorithms and presents how the rsa encryption in the functional language clean can be implemented and how can be measured the efficiency of a certain application . </S>"
  ]
}