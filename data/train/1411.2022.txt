{
  "article_text": [
    "the study of algorithms for analysis of different kinds of periodicities in strings constitutes an important branch in stringology and squares often play a central role in such researches .",
    "recall that a string @xmath3 is a _ square _ if @xmath4 for some nonempty string @xmath5 .",
    "a string is _ squarefree _ if it does not have a substring that is a square .",
    "we consider algorithms recognizing squarefree strings . to be more precise , let @xmath6 be a positive function of integer domain ; we say that an algorithm _ detects _ squares in @xmath7 time if for any integer @xmath8 and any string of length @xmath8 , the algorithm decides whether the string is squarefree in @xmath7 operations .",
    "we say that an algorithm detects squares _ online _ if the algorithm processes the input string sequentially from left to right and decides whether each prefix is squarefree after reading the rightmost letter of that prefix .    in this paper",
    "we give two algorithms for online square detection .",
    "the first one works on ordered alphabet and requires @xmath0 time and linear space , where @xmath1 is the number of different letters in the input string . though the proposed result is not new ( see  @xcite ) , it is rather less complicated than the previously known solution and",
    "can be used in practice .",
    "the second algorithm works on unordered alphabet and takes @xmath2 time and linear space .",
    "this algorithm is substantially different from the algorithm of  @xcite having with the same time and space bound .",
    "these two algorithms are equally applicable for practical use .",
    "let us point out some previous results on the problem of square detection .",
    "one can easily show that on a two - letter alphabet any string of length at least four is not squarefree . a classical result of thue @xcite states that on a three - letter alphabet there are infinitely many squarefree strings . main and lorentz @xcite presented an algorithm that detects squares in @xmath2 time and linear space for unordered alphabet .",
    "they proved an @xmath9 lower bound for the problem of square detection on unordered alphabets , so their result is the best possible in this case . for ordered alphabets , crochemore @xcite described an algorithm that detects squares in @xmath10 time and linear space .",
    "the interest in algorithms for online square detection was initially motivated by problems in the artificial intelligence research ( see  @xcite ) .",
    "leung , peng , and ting @xcite obtained an online algorithm that detects squares in @xmath11 time and linear space on unordered alphabet .",
    "jansson and peng @xcite found an online algorithm that detects squares in @xmath12 time ; for ordered alphabets , their algorithm requires @xmath2 time .",
    "hong and chen @xcite presented an online algorithm that detects squares in @xmath0 time and linear space on ordered alphabet .",
    "their algorithm heavily relies on the amount of space consumed by string indexing structures and hence is rather impractical ; it seems that even the most careful implementations of the algorithm use at least @xmath13 bytes in the worst case .",
    "apostolico and breslauer @xcite as a byproduct of their parallel algorithm for square detection obtained an online algorithm that detects squares in @xmath2 time and linear space on unordered alphabet ( apparently , the authors of  @xcite and  @xcite did not know about this result ) .",
    "the present paper is inspired by shur s work @xcite on random generation of square - free strings .",
    "the paper is organized as follows . in section  [ sectcatcher ]",
    "we present some basic definitions and the key data structure called catcher , which helps to detect squares .",
    "section  [ sectunord ] contains an online solution for the case of unordered alphabet . in section  [ sectord ]",
    "we describe an online algorithm for ordered alphabet .",
    "a _ string of length @xmath8 _ over an alphabet @xmath14 is a map @xmath15 .",
    "the length of @xmath16 is denoted by @xmath17 . we write",
    "@xmath18 $ ] for the @xmath19th letter of @xmath16 and @xmath20 $ ] for @xmath18w[i{+}1]\\ldots w[j]$ ] .",
    "let @xmath21 $ ] be the empty string for any  @xmath19 .",
    "a string @xmath22 is a _ substring _ of @xmath16 if @xmath23 $ ] for some @xmath19 and @xmath24 .",
    "the pair @xmath25 is not necessarily unique ; we say that @xmath19 specifies an _ occurrence _ of @xmath22 in @xmath16 .",
    "a string can have many occurrences in another string . a substring @xmath26 $ ] ( resp .",
    ", @xmath27 $ ] ) is a _ prefix _ [ resp . _ suffix _ ] of @xmath16 . a string which is both a proper prefix and",
    "a suffix of @xmath16 is a _ boundary _ of @xmath16 .",
    "square suffix _ is a suffix that is a square . for any integers @xmath28 , the set @xmath29 ( possibly empty )",
    "is denoted by @xmath30 .",
    "suppose @xmath31 is a string , @xmath32 .",
    "to detect squares , we use an auxiliary data structure , called _",
    "the catcher works with the string @xmath31 . for correct work ,",
    "the string @xmath33 $ ] must be squarefree .",
    "the catcher contains integer variables @xmath19 , @xmath24 such that @xmath34 and @xmath35 and once a letter is appended to the right of @xmath31 , the catcher detects square suffixes beginning inside @xmath36 , i.e. , if for some @xmath37 , @xmath38 $ ] is a square , the catcher detects this square .",
    "the segment @xmath36 is called the _",
    "trap_.    suppose @xmath38 = xx$ ] for some nonempty string @xmath5 and @xmath37 ( see  fig .  [",
    "fig : square ] ) . since @xmath35",
    ", we have @xmath39 for some strings @xmath40 and @xmath41 such that @xmath42 = x''x'x''$ ] .     with the leftmost position lying in @xmath36 ;",
    "@xmath35 . ]    if @xmath33 $ ] is squarefree , then @xmath41 is the longest boundary of @xmath42 $ ] .",
    "[ maxboundary ]    suppose @xmath43 is the longest boundary of @xmath42 $ ] and @xmath44 ; then @xmath43 is a suffix of @xmath5 and the occurrence of @xmath43 that starts at position @xmath45 overlaps the occurrence of @xmath43 that starts at position @xmath46 . thus , @xmath33 $ ] is not squarefree .",
    "this is a contradiction .",
    "denote @xmath47 . to obtain the longest boundary of @xmath42 $ ]",
    ", the catcher maintains an integer array @xmath48 $ ] ( for convenience , we use indices @xmath49 ) such that for any @xmath50 , @xmath51 $ ] is equal to the length of the longest boundary of @xmath52 $ ] .",
    "further , the catcher contains a variable @xmath3 such that if @xmath53 + t \\ge n - j$ ] , @xmath3 equals the length of the longest suffix of @xmath54 $ ] that is a suffix of @xmath55 $ ] and otherwise , @xmath3 equals zero .",
    "thus by lemma  [ maxboundary ] , the catcher detects a square iff @xmath53 + s \\ge n - j$ ] .",
    "let us describe how to compute @xmath56 and @xmath3 .",
    "there is a well - known algorithm that efficiently calculates @xmath57 $ ] ( see @xcite ) .",
    "once @xmath57 $ ] is found , we process @xmath3 . if @xmath57",
    "= b[n{-}1]+1 $ ] , then @xmath3 remains unchanged ( see the definition ) ; otherwise we put @xmath58 . next , if @xmath53 + t \\ge n - j$ ] and @xmath58 , we compute @xmath3 by a naive algorithm .",
    "the following pseudo - code summarizes the description ( for convenience , we define @xmath59 = -1 $ ] ) .",
    "read a letter and append it to @xmath31 ( thereby incrementing @xmath8 ) @xmath57 \\gets b[n{-}1 ] + 1 $ ] @xmath57 \\gets b[j{+}b[n]{-}1 ] + 1 $ ] @xmath60 [ lst : naivescond ] @xmath61 the square suffix of the length @xmath62)$ ] is detected    the catcher requires @xmath63 time and space .",
    "[ catchertime ]    the algorithm that fills @xmath56 takes @xmath63 time ( see  @xcite ) .",
    "suppose there exists a positive integer @xmath64 such that our algorithm computed a nonzero value of @xmath3 when @xmath31 had the length @xmath64 .",
    "let @xmath65 be the set of all such integers .",
    "for each @xmath66 , denote by @xmath67 the value of @xmath3 that was computed when @xmath31 had the length @xmath68 .",
    "it suffices to prove that @xmath69 .",
    "recall that the string @xmath33 $ ] is squarefree .",
    "therefore by lemma  [ maxboundary ] , the condition in line  [ lst : naivescond ] implies @xmath70 for all @xmath71 .",
    "denote @xmath72 $ ] for @xmath66 .",
    "it is straightforward that @xmath73 is an increasing sequence .",
    "let @xmath74 be the maximal integer such that @xmath75 and @xmath76 .",
    "let us first prove that @xmath77 .",
    "it follows from the definition of catcher that for any @xmath66 , @xmath78 .",
    "therefore for each @xmath79 , @xmath80 $ ] is a boundary of @xmath81 $ ] .",
    "let us show that @xmath82 for all @xmath83 .",
    "suppose @xmath84 for some @xmath83 ( see fig .  [",
    "fig : catcher1 ] ) . denote @xmath85 . then @xmath86 = text[j{-}r{+}1 .. j]$ ] by definition of @xmath67 . but @xmath86 $ ] is a prefix of @xmath81 $ ] because @xmath87 $ ] is a boundary of @xmath81 $ ] .",
    "so , we obtain a square @xmath88 $ ] and this is a contradiction .",
    "thus , @xmath89 .    , @xmath84",
    ", then we have a square of the length @xmath90 . ]    to estimate the sum @xmath91 , we first prove the following statement .",
    "@xmath92 suppose , to the contrary , for some @xmath93 , @xmath84 and there are @xmath94 such that @xmath95 and @xmath96 ( see fig .  [ fig : catcher2 ] ) .",
    "denote @xmath85 . by definition of @xmath67",
    ", we have @xmath86 = text[j{-}r{+}1 .. j]$ ] .",
    "now it is easy to see that @xmath97 . indeed ,",
    "if @xmath98 , then @xmath86 = text[j{+}1 .. j{+}r]$ ] because @xmath99 $ ] is a boundary of @xmath100 $ ] ; but this implies that @xmath88 $ ] is a square . thus @xmath101 < r$ ] .",
    "since , by definition of @xmath102 and @xmath103 , @xmath104 = text[a_{l_2}{-}r{+}1 .. a_{l_2}]$ ] and @xmath33 $ ] is squarefree , we have @xmath105 .",
    "recall that @xmath106 by definition of @xmath74 .",
    "finally , we obtain @xmath107 > t + r + b[n_{l-1 } ] > t + 2b[n_{l-1}]$ ] .",
    "but the condition in line  [ lst : naivescond ] suggests that @xmath108 $ ] .",
    "this is a contradiction .",
    ", @xmath109 $ ] , and @xmath110 , we have @xmath111 $ ] . ]",
    "now we can estimate the sum @xmath91 . if for each @xmath93 , @xmath82 , then @xmath112 .",
    "let @xmath113 be the set of all @xmath114 such that @xmath115 .",
    "denote @xmath116 .",
    "it follows from   that for at most one @xmath117 , @xmath118 .",
    "so , @xmath119 . in the same way we obtain that for at most one @xmath120 , @xmath121",
    "so , @xmath122 .",
    "further , for at most one @xmath123 , @xmath124 .",
    "so , @xmath125 . this process leads to the inequality @xmath126 .",
    "finally , we have @xmath127 .",
    "for unordered alphabet , there exists an online algorithm that detects squares in @xmath2 time and linear space .",
    "[ unorderedsquares ]    our algorithm maintains @xmath128 catchers and traps of these catchers cover the string @xmath33 $ ] .",
    "let @xmath129 and @xmath130 be the maximal integer such that @xmath131 .",
    "we have one or two traps of the length @xmath132 : the first trap is equal to @xmath133 and if @xmath130 is even , we have another trap that is equal to @xmath134 ( see fig .  [",
    "fig : systraps ] ) .",
    "if @xmath8 has became a multiple of @xmath132 after extension of @xmath31 , we add a new trap of the length @xmath132 and destroy two previous traps of the length @xmath132 if the new @xmath130 is odd and these traps exist . in the following pseudo - code",
    "we use the three - operand @xmath135 loop like in the c language .    read a letter and",
    "append it to @xmath31 ( thereby incrementing @xmath8 ) @xmath136 create a catcher with the trap @xmath133 remove two previous catchers with the traps of the length @xmath132    $ ] , where @xmath137 . ]    to prove that the described system of traps covers the string @xmath33 $ ] , it suffices to note that if some iteration of the loop removes two catchers with the traps of the length @xmath132 , then the next iteration creates a catcher with the trap of the length @xmath138 on their place .",
    "it is easy to see that if for some @xmath129 , the proposed algorithm maintains a trap @xmath36 of length @xmath132 , then @xmath139 .",
    "hence it follows from lemma  [ catchertime ] that all catchers of the algorithm use @xmath140 space . since traps of the same length do not intersect , to maintain traps of the length @xmath132 , the algorithm takes , by lemma  [ catchertime ] , @xmath141 time",
    "thus , the algorithm requires @xmath2 overall time .",
    "in the case of ordered alphabet the following lemma narrows the area of square suffix search .",
    "let @xmath31 be a string of length @xmath8 . denote by @xmath142 the length of the longest suffix of @xmath31 that occurs at least twice in @xmath31 .",
    "if @xmath33 $ ] is squarefree and for some positive @xmath143 , @xmath144 $ ] is a square , then @xmath145 .",
    "[ squarelocation ]    suppose @xmath146 . since @xmath147 $ ] has two occurrences in @xmath31 , the square @xmath144 $ ] occurs twice and the string @xmath33 $ ] is not squarefree .",
    "this is a contradiction .",
    "suppose @xmath148 .",
    "note that @xmath143 is even .",
    "then the suffix @xmath149 $ ] has at least two occurrences in @xmath31 .",
    "this contradicts to the definition of @xmath142",
    ".    for each integer @xmath150 , denote by @xmath151 the length of the longest suffix of @xmath152 $ ] that has at least two occurrences in @xmath152 $ ] .",
    "we say that there is an online access to the sequence @xmath153 if any algorithm that reads the string @xmath31 sequentially from left to right can read @xmath151 immediately after reading @xmath154 $ ] .",
    "the following lemma describes an online algorithm for square detection based on an online access to @xmath153 .",
    "note that the alphabet is not necessarily ordered .",
    "if there is an online access to the sequence @xmath153 , then there exists an algorithm that online detects squares in linear time and space .",
    "[ orderedlemma ]    our algorithm online reads the string @xmath31 ( as above , @xmath8 denotes the number of letters read ) and maintains an integer variable @xmath3 such that @xmath155 ( initially @xmath58 ) . to detect a square",
    ", we use three catchers ; the traps of these catchers are denoted by @xmath156 , @xmath157 , and @xmath158 .",
    "the traps satisfy the following conditions ( any of these traps can be empty ; see fig .  [",
    "fig : threetraps ] ) : @xmath159    , @xmath157 , and @xmath158 just after update ; @xmath160 . ]",
    "thus , the traps cover the block @xmath161 and therefore , by lemma  [ squarelocation ] , the algorithm detects squares .",
    "consider the following pseudo - code that maintains the catchers and the variable @xmath3 ( `` update '' command replaces the corresponding catcher with a new one ) :    read a letter and append it to @xmath31 ( thereby we increment @xmath8 and read @xmath162 ) @xmath61 @xmath163 [ lst : updateall ] @xmath164 , @xmath165 [ lst : recalc12 ] update the 1st catcher @xmath166 , @xmath167 update the 2nd catcher @xmath168 , @xmath169 [ lst : recalc3 ] update the 3rd catcher @xmath170 , @xmath171 [ lst : catcher3 ]    clearly , the proposed algorithm preserves   and thus by lemma  [ squarelocation ] , works correctly .",
    "further , it follows from lemma  [ catchertime ] that the algorithm uses linear space . to end the proof",
    ", it suffices to estimate the working time .",
    "suppose the algorithm processed a string of length @xmath8 .",
    "let for any @xmath172 , the term _",
    "@xmath64th step _ refers to the set of instructions performed by the algorithm when it read and processed the letter @xmath173 $ ] . for any @xmath174 , denote by @xmath175 the value of @xmath3 that was calculated on @xmath64th step .",
    "let @xmath176 be the set of all steps on that the algorithm performed the line  [ lst : updateall ] .",
    "at first we estimate the time required by steps @xmath177 ; then we estimate the time required by other steps : the updates of the first and second catchers and finally the updates of the third catcher .",
    "consider the steps @xmath177 .",
    "it follows from lemma  [ catchertime ] that for any @xmath178 , the updates of the first , second , and third catchers on @xmath179th step require @xmath180 , @xmath181 , and @xmath182 time respectively . since @xmath183 , we have @xmath184 .",
    "therefore , the steps @xmath177 require @xmath185 time .    let @xmath186 .",
    "consider the steps @xmath187 .",
    "let @xmath188 be the set of all steps @xmath189 on that the algorithm updated the first and second catchers .",
    "clearly @xmath190 .",
    "for any @xmath191 , the recalculation of the first and second catchers on @xmath192th step takes @xmath193 time . the condition in line  [ lst : recalc12 ] implies that for any @xmath194 , @xmath195 .",
    "hence the recalculation is performed in @xmath196 time .",
    "let @xmath197 be the set of all steps @xmath198 on that the algorithm updated the third catcher .",
    "clearly @xmath199 .",
    "for any @xmath200 , this recalculation takes @xmath201 time on @xmath202th step .",
    "it follows from the lines  [ lst : recalc3][lst : catcher3 ] that for any @xmath203 , @xmath204 .",
    "then the recalculation takes @xmath205 time .",
    "thus , all recalculations of the catchers are performed in @xmath206 time and this result ends the proof .    for ordered alphabet , there exists an algorithm that online detects squares in @xmath0 time and linear space , where @xmath1 is the number of different letters in the input string .    to compute the sequence @xmath153",
    ", we can use the standard ukkonen s online algorithm @xcite , which works in @xmath0 time and linear space , or some more space efficient and practical algorithm ( see @xcite for example ) .",
    "thus , the theorem follows from lemma  [ orderedlemma ] .",
    "for constant alphabet , there exists an algorithm that online detects squares in linear time and space .",
    "some important problems still remain open . to date , there is no nontrivial lower bound for the problem of square detection in the case of ordered alphabet .",
    "it follows from @xcite that such lower bound immediately implies the same lower bound for the problem of lempel - ziv factorization ( the later is a widely used tool in stringology and data compression ) .",
    "it is also interesting to construct an efficient online algorithm for square detection that allows a `` rollback '' operation , i.e. , the operation that cuts off a suffix of arbitrary length from the read string .",
    "one such algorithm is presented in  @xcite .",
    "99 a. apostolico , d. breslauer . an optimal @xmath207-time parallel algorithm for detecting all squares in a string , siam journal on computing 25 6 . ",
    "( 1996 ) 13181331 .",
    "m. crochemore .",
    "transducers and repetitions , theoretical computer science 45 ( 1986 ) 6386 .",
    "m. crochemore , w. rytter .",
    "jewels of stringology , world scientific publ .",
    "hong , g - h .",
    "efficient on - line repetition detection , theoretical computer science 407 ( 2008 ) 554563 .",
    "j. jansson , z. peng .",
    "online and dynamic recognition of squarefree strings , mfcs ( 2005 ) 520531 .",
    "r. kolpakov , g. kucherov .",
    "finding maximal repetitions in a word in linear time , focs 40 ( 1999 ) 596604 .",
    "leung , z. peng , h. f. ting .",
    "an efficient online algorithm for square detection , computing and combinatorics ( 2004 ) 432439 .",
    "main , r.j .",
    "linear time recognition of squarefree strings , combinatorial algorithms on words ( 1985 ) 271278 .",
    "d. okanohara , k. sadakane .",
    "an online algorithm for finding the longest previous factors , algorithms - esa 2008 .",
    "springer berlin heidelberg ( 2008 ) 696707 .",
    "a.m. shur . generating square - free words efficiently , words2013 special issue of theoret .",
    "( submitted , 2014 ) .",
    "ber unendliche zeichenreihen , norske videnskabers selskabs skrifter , mat .-",
    "( 1906 ) 122 .",
    "e. ukkonen . on - line suffix tree construction .",
    "algorithmica 14.3 ( 1995 ) 249260 ."
  ],
  "abstract_text": [
    "<S> the online square detection problem is to detect the first occurrence of a square in a string whose characters are provided as input one at a time . recall that a square is a string that is a concatenation of two identical strings . in this paper </S>",
    "<S> we present an algorithm solving this problem in @xmath0 time and linear space on ordered alphabet , where @xmath1 is the number of different letters in the input string . </S>",
    "<S> our solution is relatively simple and does not require much memory unlike the previously known online algorithm with the same working time . </S>",
    "<S> also we present an algorithm working in @xmath2 time and linear space on unordered alphabet , though this solution does not outperform the previously known result with the same time bound . </S>"
  ]
}