{
  "article_text": [
    "one main feature of constructive type theory , through the well - known curry - howard isomorphism , is the equivalence between proving and programming .",
    "this is clearly one of the advantages of coq  @xcite with respect to other proof assistants , like isabelle / hol  @xcite .",
    "this characteristic is the base of reflective tactics , pioneered by s. boutin  @xcite , and successfully used , for instance , in  @xcite .",
    "computing can play another role when formalizing a proof .",
    "it can be useful , for example , to check some conjecture over concrete cases .",
    "when dealing with standard data structures ( as lists , trees , and the like ) , these experiments can be done in a parallel line by programming the tests in java , c , or any other programming language . if infinite data structures occur , programming them is a more delicate task , and it can be rewarding to keep a tighter link among programs and specifications .    infinite data structures , presented as coinductive objets as streams , have been dealt with in the theorem proving literature ( see  @xcite for instance ) . in this work ,",
    "we undertake another via to manage the infinity , working with algebraic structures of infinite type ( that is to say , generated by infinite sets )  @xcite .",
    "we report in this paper on an experiment of this nature , in the area of homological algebra .",
    "it is well - known that homological information is not computable over general ( infinite type ) chain complexes ( see  @xcite ) .",
    "for instance , if @xmath0 is an _",
    "acyclic _ chain complex , and @xmath1 is a _ cycle _",
    "( this means @xmath2 ) , then _",
    "there exists _",
    "such that @xmath4 ( that is , @xmath5 is a _ boundary _ ) .",
    "but if @xmath6 is a free module of infinite type , and no other information is available , there is no general algorithm computing a pre - image @xmath7 of @xmath5 .",
    "sergeraert s effective homology  @xcite is a theory allowing solving large classes of problems of this sort , even in the infinite dimensional case .",
    "this paper continues our previous work in translating sergeraert s ideas to theorem provers  @xcite , with the aim of formalizing this part of algorithmic mathematics and , more importantly , of applying formal methods to the study of the kenzo system  @xcite ( a common lisp program developed by sergeraert to implement effective homology algorithms ) .",
    "the first important milestone in this area was the mechanized proof in the isabelle / hol proof assistant of the basic perturbation lemma ( bpl ) , published in  @xcite .",
    "this formal proof was carried out in the higher order logic ( hol ) built on top of isabelle , and therefore extracting programs from it was not a simple task .",
    "the findings on this topic were reported in  @xcite .",
    "a different approach is being carried out by t. coquand and a. spiwack @xcite who are using coq to model a part of category theory , and then trying to obtain a bpl proof in this larger context .",
    "the data structures of effective homology are organized in two layers ( as algebraically modeled in  @xcite ) : the first layer is composed of algebraic data structures ( chain complexes , simplicial sets ,  ) and the second one of standard data structures ( lists , trees ,  ) which are representing _ elements _ of data from the first layer .",
    "infinite type data structures appear only in the first layer . computing in this first layer",
    "can be done in an abstract way , and it is equivalent in coq to proving theorems .",
    "for example , a theorem stating `` the direct sum of two chain complexes is a chain complex '' contains an algorithm constructing the mentioned direct sum .",
    "coq can deal with this structure , no matter whether it is of finite or infinite type .",
    "but actual computations really take place _ within _ algebraic structures of the first layer . to compute with coq in this sense",
    "has no advantage of being any more direct .",
    "it is needed to construct concrete instances of chain complexes and other possibly infinite algebraic data structures",
    ". then we must build concrete elements ( second layer ) of these particular structures , and finally put to work the algorithms abstractly described in the first layer .    in this paper",
    "we discuss this procedure in a case related to the effective homology of the cone of a chain complex morphism .",
    "this formalization was part of the implementation in coq of the algorithm computing the effective homology of a bicomplex ( see  @xcite ) .",
    "now , we use the computing capabilities of coq to explore whether some concrete cones are acyclic or not , as a previous step to proving a general property .    the paper is organized as follows .",
    "section 2 contains some preliminaries on algebraic structures , both in mathematics and in coq .",
    "section 3 describes the formalization in coq of the algorithm computing the effective homology of a cone , in a way that slightly generalizes our previous work in  @xcite .",
    "concrete coq instances of chain complexes of infinite type are introduced in section 4",
    ". then explicit calculations with elements are presented in section 5 , using coq as a computing tool to check some conjectures .",
    "the paper ends with conclusions , future work , and the bibliography .",
    "the coq source files are available at + ` https://esus.unirioja.es/psycotrip/archivos_documentos/cciads.zip ` .",
    "in this section we introduce the algebraic structures which support our constructions .",
    "they include chain complexes , chain complex morphisms , and reductions and effective homologies of chain complexes .",
    "the formalization in coq of these structures are also described .",
    "we assume as known the notions of _ ring _ , _ module _ over a ring and _ module morphism _ ( see  @xcite for instance ) .",
    "a ring @xmath8 commutative and with unity is fixed all through the paper , and modules are supposed to be _ left _ @xmath8-modules .",
    "we have built these basic structures in coq using records called ` ring ` , ` module ` and ` modhom ` , respectively .",
    "they are based on the ones included in corn  @xcite ( but simplifying them : basically eliminating the apartness relation included in setoids which is not used by us , since we are working in a _",
    "discrete _ mathematics setting ) . besides",
    ", further constructions as for instance the addition or the composition of module morphisms are defined , and are represented using the infix notation ` [ + h ] ` or ` [ oh ] ` , respectively .",
    "a _ free @xmath8-module generated over a set @xmath9 _ is the module @xmath10 $ ] whose elements are linear combinations with elements of @xmath9 as generators .",
    "the addition and the external product by elements of @xmath8 are defined in the natural way . since we are planning to work in a constructive logic setting , it is convenient to define a _ free _ module as one module @xmath11 where an explicit isomorphism is known between @xmath11 and @xmath10 $ ] ( the set of generators @xmath9",
    "must also be explicitly given ) .",
    "if @xmath9 is finite , the free module is said _ of finite type_.    the formalization of free modules in coq follows the ideas given by l. pottier in the coq contributions web page  @xcite .",
    "there , a definition can be found of a module built by freely generation from a basis , which is given by a _",
    "( _ i.e. _ a set with an equality , usually denoted by ` [ = ] ` ) , using the module operations",
    ". if we call @xmath9 the basis setoid , this is representing the mathematical structure @xmath10 $ ] introduced above .",
    "then , our formalization of free modules consists of a record with a module and an explicit isomorphism to such a freely generated module . in order to deal with finite sets in a constructive type theory ,",
    "more care is needed .",
    "for instance , several alternatives for defining finite sets in a constructive logic are included in  @xcite .",
    "finite algebraic structures have also been implemented in coq in  @xcite as a first milestone of a long - term effort to formalize the feit - thompson theorem .",
    "our formalization is the following . given a natural number @xmath12 , let us denote @xmath13 the ( finite ) setoid @xmath14 ( with the leibniz equality ) .",
    "we consider a setoid @xmath9 as _ finite _ if it is endowed with a natural number @xmath12 and an explicit bijection to @xmath13 .",
    "then , a free module of finite type is a free module , but we impose that the generator set is _ equal _ ( in the coq internal sense ) to @xmath13 .",
    "we concentrate ourselves in the sequel on _ free _ modules , since it is the unique kind of modules dealt with in the kenzo system @xcite .",
    "we are ready to introduce the first _ graded _",
    "concept , needed in homological algebra and algebraic topology .",
    "[ d : graded_module ] a _ graded module _",
    "@xmath11 is a family of @xmath8-modules indexed by the integer numbers @xmath15 .",
    "a graded module is _ free _ ( or _ free of finite type _ ) if @xmath16 is free ( free of finite type , respectively ) for all @xmath17 . if @xmath18 , the index @xmath19 is called _ degree _ of the element @xmath5 .",
    "[ d : differential ] given a graded module @xmath11 a _ differential operator _",
    "@xmath20 on @xmath11 is a family of module morphisms @xmath21 such that @xmath22 for all @xmath17 .",
    "[ d : chain_complex ] a _ chain complex _ is a pair @xmath23 where @xmath11 is a graded module and @xmath20 a differential operator on @xmath11 .",
    "a chain complex is called _ free _ ( or _ free of finite type _ ) when its underlying graded module is free ( free of finite type , respectively ) .",
    "chain complexes have a corresponding notion of morphism .    a _ chain complex morphism _ ( or , simply , a _ chain morphism _ ) @xmath24 between two chain complexes @xmath25 and",
    "@xmath26 is a family of module morphisms @xmath27 such that @xmath28 for all @xmath29 .",
    "given a ring ` r : ring ` , a graded module can be formalized in coq with the following _ dependent _ type : ` z - > module r ` , which accurately represents a family of modules indexed by the integer numbers . then , a ( free ) chain complex can be formalized in coq using the following record structure :    ....   record chaincomplex : type:=    { grdmod : > z - > freemodule r ;     diff : forall i : z , modhom ( r:=r ) ( grdmod",
    "( i + 1 ) ) ( grdmod i ) ;     nilpotencydiff : forall i : z , ( nilpotency ( diff i)(diff ( i + 1))}.   ....    where the nilpotency property is defined by ` nilpotency(g : modhom b c ) ( f : modhom a b):= forall a : a , ( ( g[oh]f)a)[=]zero ` .    in a similar way , given two chain complexes ` cc1 cc2 :",
    "chaincomplex r ` , a chain complex morphism ` chaincomplexhom ` is represented as a record with a family of module morphisms ` grdmodhom:>forall i : z , modhom(cc1 i)(cc2 i ) ` which commutes with the chain complex differentials .",
    "now , the central definition in effective homology theory : _ reduction_. a reduction establishes a link between a `` big '' chain complex , called _ top complex _ , and a smaller one , called _ bottom complex _ , in such a way that if all the homological problems are solved in the bottom complex , then it is the same in the top one .",
    "[ d : reduction ] a _ reduction _ is a 5-tuple @xmath30 @xmath31^{f}\\ar@/4pc/@(ul , dl)_{h } & \\ar@/^/[l]^{g}bcc    } \\ ] ] where @xmath32 and @xmath33 are chain complexes ( named _ top _ and _ bottom _ chain complex ) , @xmath34 and @xmath35 are chain morphisms , @xmath36 is a family of module morphisms ( called _ homotopy operator _ ) , which satisfy the following properties for all @xmath29 :    1 .",
    "@xmath37 2 .",
    "@xmath38 3 .",
    "@xmath39 4 .",
    "@xmath40 5 .",
    "@xmath41    and now , the relevant case . in a free chain complex _ of finite type _",
    "the homological problems can be solved algorithmically in a simple way ( at least in cases where the ring @xmath8 allows one to diagonalize matrices over @xmath8 ; this includes the case @xmath42 , the most important one in algebraic topology ; see  @xcite ) .",
    "thus , if from a chain complex ( possibly of infinite type ) we can get a reduction to a chain complex of finite type , the homological problem is solved for the initial complex .",
    "this is the strategy followed in the kenzo system . and",
    "it is the very notion of chain complex with _ effective homology_.    a chain complex @xmath43 is with _ effective homology _ if it is free and it is endowed with a reduction where @xmath43 itself is the top chain complex and the bottom chain complex is free of finite type .    given a chain complex ` cc1 : chaincomplex r ` ,",
    "a homotopy operator is represented in coq as a family of module morphisms ` homotopyoperator:= forall i : z , modhom(c1 i)(c1(i + 1 ) ) ` .",
    "the reduction notion is then formalized as a record ` reduction ` with two chain complexes ` topcc : chaincomplex r ` , ` bottomcc : chaincomplex r ` and three morphisms ` f_t_b : chaincomplexhom topcc bottomcc ` , ` g_b_t : chaincomplexhom bottomcc topcc ` , ` h_t_t : homotopyoperator topcc ` . besides , five fields representing the five reduction properties are included .",
    "for instance , the field which corresponds to the second property is : ` rp2 : homotopy_operator_property f_t_b g_b_t h_t_t ` with :    ....   definition homotopy_operator_property:= forall(i : z)(a : c1(i+1 ) ) ,    ( ( ( diff c1(i+1))[oh]h(i+1))[+h](h i[oh](diff c1 i))[+h ]         ( g(i+1)[oh]f(i+1 ) ) ) a [ = ] a.   ....    some comments on these coq definitions are needed .",
    "why are the elements in this definition considered to be on the ` i+1`-th degree and not on the ` i`-th degree , as it is the usual definition of reduction ?",
    "the same decision was previously taken when the definition of differential was introduced .",
    "it is clear that as we are considering the definition for all the integers , both definitions are equivalent .",
    "but , a coq technical problem is easily avoided thanks to our definition .",
    "we are going to focus our attention on the component of the definition .",
    "the differential takes an element in degree ` i+1 ` and obtains an element in degree ` i ` which is translated to a component in degree ` i+1 ` by the homotopy operator .",
    "if we consider the _ mathematically equivalent _ definition , considering the differential defined from degree ` i ` to ` i-1 ` , then the corresponding component would be ` ( h(i-1)[oh](diff c1 i ) ) ` . in this composition",
    ", the differential takes an element in degree ` i ` and returns an element in degree ` i-1 ` , which is now translated to a component in degree ` i-1 + 1 ` . in coq",
    "this element is _ equal _ but is not _",
    "convertible _ to ` i ` .",
    "so , we will obtain a coq type error from this sum of morphisms .",
    "a _ transition _",
    "function between equal but not directly convertible types ( which it is essentially an identity between types ) can be introduced allowing us to overcome this drawback .",
    "the concept of _ free of finite type chain complex _ is then obtained in coq as a specialization of the _ chain complex _ structure : simply adding that the family of modules are free modules of finite type . in a similar way it is formalized the concept of _",
    "effective homology _ as a specialization of the _ reduction _ structure by declaring the _ bottomcc _ is of finite type .",
    "in this section we first define the notion of the cone of a chain complex morphism .",
    "then , the main result that we are going to deal with is stated : the effective homology of a cone .",
    "we also show how this theorem can be proved in coq .",
    "[ d : cone ] given a pair of chain complexes @xmath44 and @xmath45 and a chain complex morphism @xmath46 , the _ cone _ of @xmath47 , denoted by @xmath48 , is a chain complex @xmath49 such that , for each @xmath50 , @xmath51 and @xmath52 for any @xmath53 and @xmath54 .",
    "now , the theorem which determines the effective homology of a cone can be stated .",
    "[ t : conereduction ] given two reductions @xmath55 and @xmath56 and a chain morphism @xmath57 between their top chain complexes , it is possible to define a reduction @xmath58 with @xmath48 as top chain complex and :    * @xmath59 with @xmath60 defined by @xmath61 * @xmath62 , @xmath63 , @xmath64    @xmath65^f\\ar@/4pc/@(r , u)_h \\ar[d]_{\\alpha } & & bcc \\ar@/^/[ll]^g \\ar@{-->}[d]_{\\alpha'}\\\\    tcc'\\ar@/^/[rr]^{f'}\\ar@/4pc/@(r , d)^{h ' } & & bcc ' \\ar@/^/[ll]^{g'}\\\\      } \\ ] ] besides , if @xmath66 and @xmath67 are objects with effective homology through the reductions @xmath68 and @xmath69 , then @xmath48 is an object with effective homology through @xmath70 .    in",
    "@xcite we formalized in coq the effective homology of a bicomplex .",
    "that result can be considered as a generalization of the previous theorem to an infinite ( indexed by the natural numbers ) family of reductions . nevertheless , in order to obtain it",
    ", the chain complexes must be positive , _",
    "i.e. _ , with null components in the negative indexes ( or , in other equivalent presentation , indexed by the natural numbers ) . in this paper",
    ", we have not this constraint since we work with a general definition of chain complex , with modules indexed by integer numbers .",
    "the formalization of theorem  [ t : conereduction ] in coq is obtained as follows .",
    "given two chain complexes ` cc0 cc1 : chaincomplex r ` and a chain complex morphism ` f : chaincomplexhom cc1 cc0 ` , the cone of this morphism is a chain complex with family of modules ` conegrdmod:= fun i : z = > sum_freemodule ( cc1 i ) ( cc0(i+1 ) ) ` ( with the direct sum of free modules ` sum_freemodule ` defined in a natural way ) and with differential operator defined as follows :    ....   definition conediffground:= fun ( i : z)(ab:(coneground ( i+1 ) ) ) = >    ( [ --](diff cc1 i(fst ab ) ) , ( ( diff cc0(i+1))(snd ab)[+]f(i+1)(fst ab ) ) ) . ....",
    "it is not difficult to prove that these functions define a module morphism which satisfies the differential condition .",
    "this last property allows one to build the cone chain complex associated to a chain complex morphism : ` cone(f ) ` .",
    "given now two reductions ` r1 r2 : reduction r ` and a chain complex morphism between their top chain complexes ` alpha : chaincomplexhom(topcc r1 ) ( topcc r2 ) ` , it is possible to define a chain complex morphism ` alpha ` between the bottom chain complexes through the function ` alpha:= fun n : z = > ( f_t_b r2 i)[oh](alpha i)[oh](g_b_t r1 i ) . `",
    "the first part of theorem  [ t : conereduction ] is proved if we build a reduction between ` cone(alpha ) ` and ` cone(alpha ) ` .",
    "the first chain complex morphism of the reduction is defined in the following way :    ....   definition f_cone_reductionground :    forall i : z , ( cone alpha ) i - > ( cone alpha ' ) i:=     fun ( i : z)(ab : ( cone alpha ) i ) = > ( ( f_t_b r1 i ) ( fst ab ) ,      ( ( ( f_t_b r2 ( i+1 ) ) [ oh ] ( alpha ( i+1 ) ) [ oh ] ( h_t_t r1 i ) ) ( fst ab ) ) [ + ]        ( f_t_b r2 ( i+1 ) ) ( snd ab ) ) .   ....    analogous definitions are provided for the two other morphisms of the reduction",
    ". then we state coq lemmas for the reduction properties on these morphisms .",
    "the proof of these lemmas consists in applying mainly equational reasoning over setoid equalities , following closely the _ paper and pencil _ proof .",
    "it allows building the reduction of a cone : ` conereduction(alpha ) ` .    finally , given two effective homologies ` r1 r2 : effectivehomology r ` and a chain complex morphism ` alpha ` between their top chain complexes , ` conereduction(alpha )",
    "` is directly a reduction of the cone .",
    "then , in order to define an effective homology for the cone it remains to prove that the bottom free chain complex of this reduction is free of finite type .",
    "it is easily obtained in coq since the direct sum of free chain complex of finite type is free of finite type .",
    "a working representation in a proof assistant of the concepts included in previous sections has to be sound , but also needs to be useful .",
    "the second feature can be shown by formally proving some results .",
    "this was the purpose of the previous section .",
    "the first feature can be illustrated by providing instances of the representations , that accurately reflect usual mathematical entities .",
    "this is the aim of this section which includes different instances of all the previous structures .",
    "first , we define some elementary instances which will act as building blocks for more elaborated constructions .",
    "the first example is the null free module @xmath71 ( _ i.e. _ , a module with the unit as unique element ) .",
    "this is indeed a free module of finite type , generated by the setoid with zero elements .",
    "then , a null free chain complex can be defined @xmath72 ( _ i.e. _ , with the previous module in each degree and the null differential ) .",
    "this chain complex can be also built as a free chain complex of finite type @xmath73 , defined from the corresponding free module of finite type .",
    "obviously , a trivial effective homology for this chain complex can be defined .",
    "another basic example is the free module of the integers @xmath74 ( over the ring of integers ) which we denote in coq by ` zfreemodule ` .",
    "this module can be also implemented as a module of finite type , ` zfinfreemodule ` , generated by the setoid with only one element .",
    "then , an example of free chain complex is with @xmath75 , @xmath76 , and @xmath77 such as @xmath78 if @xmath19 is even and @xmath79 otherwise : @xmath80_{0 } & \\mathds{z}\\ar[l]_{\\times 2 } & \\mathds{z}\\ar[l]_{0 } & \\mathds{z}\\ar[l]_{\\times 2 } & \\mathds{z}\\ar[l]_{0 } & \\ar[l]_{\\times 2}\\dots\\\\ \\txt{\\small{degree } } & \\txt{\\small{-2 } } & \\txt{\\small{-1 } } & \\txt{\\small{0 } } & \\txt{\\small{1 } } & \\txt{\\small{2 } } & \\\\ } \\ ] ] the coq formalization of the required differential is obtained through the functional type ` fun i : z = > if ( zeven_bool i ) then x2_modhom else ( modhom_zero zfreemodule zfreemodule ) ` . it is easy to prove that this morphism satisfies the nilpotency condition .",
    "a similar free chain complex of finite type @xmath81 can be defined using the corresponding family of free modules of finite type . besides",
    ", we can define a trivial effective homology between both complexes that we name ` id_z_2x_0_effectivehomology ` : @xmath82^{id}\\ar@/4pc/@(r , u)_{0 } & & fcc^{(1 ) } \\ar@/^/[ll]^{id }    } \\ ] ]    the previous examples are chain complexes of _ finite type _ , since the modules are free of finite type ( in that case with zero or one generator ) .",
    "an example of a free module of _ infinite type _ is @xmath83 $ ] , the free module generated by the natural numbers ( over the ring of integer numbers ) which we denote in coq by ` z_nat_freemodule ` .",
    "it is defined by taking as free module the one freely generated from the setoid denoted in coq by ` nat_as_setoid ` ( that is to say , the setoid of natural numbers with the leibniz equality ) . the definition",
    "is then completed with the same module as module representation and the identity as isomorphism between them . to keep notations clear , the generator @xmath19 of @xmath83 $ ]",
    "will be denoted by @xmath84 , @xmath85 .",
    "now , a chain complex of infinite type @xmath86 is built where @xmath87}$ ] , @xmath88 , and @xmath89\\to \\mathds{z}[\\mathds{n}]$ ] defined on generators ( and then extended to all elements by freely generation ) in the following way : if @xmath19 is even , @xmath90 if @xmath91 is even and @xmath92 otherwise ; and if @xmath19 is odd , @xmath92 if @xmath91 is even and @xmath90 otherwise .",
    "this differential on generators can be illustrated with the following diagram :    @xmath93 & \\mathds{z}[\\mathds{n}]\\ar[l]^{(d^{(2)})_i}_{\\txt{\\scriptsize{i even } } } &   \\mathds{z}[\\mathds{n } ] & \\mathds{z}[\\mathds{n}]\\ar[l]^{(d^{(2)})_i}_{\\txt{\\scriptsize{i odd}}}\\\\   x_0 &   x_0\\ar@{|->}[l ] & 0 &   x_0\\ar@{|->}[l]\\\\   0 & x_1 \\ar@{|->}[l ] & x_1 & x_1 \\ar@{|->}[l]\\\\   x_2 & x_2 \\ar@{|->}[l ] & 0 & x_2 \\ar@{|->}[l]\\\\   0 & x_3 \\ar@{|->}[l ] &   x_3 & x_3 \\ar@{|->}[l]\\\\ \\dots & \\dots & \\dots & \\dots \\\\ } \\ ] ] this chain complex is named in our representation ` z_nat_chaincomplex ` . its differential can be easily defined using auxiliary functions as ` fun n : nat_as_setoid = > if even_bool",
    "_ n else unit _ _ ` . here , we are using the ` unit ` notation for the null element as in l. pottier s development .",
    "it is not difficult to prove that this morphism satisfies the nilpotency condition ( in other words , it is really a differential ) .",
    "now , it is possible to define a homotopy operator @xmath94 on @xmath95 built on generators in the same way as the previous differential ( but , defined from an element in the module at degree @xmath19 to an element in the module at degree @xmath96 ) .",
    "obvious morphisms allow us to complete an effective homology from this last free chain complex to the null free chain complex of finite type @xmath73 .",
    "this last effective homology proves that @xmath95 is acyclic .    in order to define a more interesting effective homology we define the free chain complex @xmath97 obtained from the direct sum of the two previous chain complexes",
    "then , it is easy to define an effective homology ` z_x_z_nat_effectivehomology ` : @xmath98^{\\pi_1}\\ar@/4pc/@(r , u)_{(0,h^{(2 ) } ) } & & \\ar@/^/[ll]^{(id , 0)}fcc^{(1 ) }    } \\ ] ] where @xmath99 is the canonical projection in the first component .",
    "finally , we consider a free chain morphism between the top chain complexes of ` z_x_z_nat_effectivehomology ` and ` id_z_2x_0_effectivehomology ` again through the canonical projection in the first component : @xmath100^{\\pi_1}\\ar@/4pc/@(r , u)_{(0,h^{(2 ) } ) } \\ar[d]_{\\pi_1 } & & \\ar@/^/[ll]^{(id , 0)}fcc^{(1)}\\ar[d]_{\\alpha'}\\\\    cc^{(1)}\\ar@/^/[rr]^{id}\\ar@/4pc/@(r , d)^{0 } & & fcc^{(1 ) } \\ar@/^/[ll]^{id }      } \\ ] ]    then , we can obtain in coq the cone of this morphism and the effective homology associated to it , named ` example_cone_effectivehomology ` , as a particular instance of our general result developed in the previous section : @xmath101^{f^{ex}}\\ar@/4pc/@(r , u)_{h^{ex } } & & cone(\\alpha ' ) \\ar@/^/[ll]^{g^{ex } }    } \\ ] ] we will use this effective homology instance to make concrete computations in coq in the following section .",
    "working in the coq constructive type theoretic setting allows us to obtain from proofs directly computable terms . in the previous section we obtained instances of meaningful examples of all our data structures , so we can now make calculations with them through the associated algorithms ( which have been proved correct in coq ) . in particular we can make computations within instances of chain complexes of infinite type .",
    "we will use the ` vm_compute ` coq tactic for evaluating terms .",
    "it computes the goal using the optimized call - by - value evaluation bytecode - based virtual machine  @xcite .",
    "another option consists in using the coq extracting code mechanism .",
    "nowadays , the functional languages available as output in coq are ocaml , haskell and scheme  @xcite .",
    "this extracted code should be , in principle , efficient but the presence of dependent types makes it complicated , at least in the haskell case .",
    "being scheme a kind of lisp , its dynamical typing style should be more convenient from this point of view in order to be our target language in which extracts our code .",
    "nevertheless it seems to be the least developed frame ( see  @xcite again ) .",
    "since kenzo is implemented in common lisp it is clear that the problems encountered with scheme are important for us if we want to extract code which was directly comparable with the kenzo code .",
    "we do not follow this line in this paper .",
    "we explore rather the possibilities of the _ internal _ execution of coq terms .",
    "we are going to choose as an example the top chain complex of ` example_cone_effectivehomology ` , _",
    "i.e. _ @xmath102 .",
    "this is an example of chain complex of _ infinite type_. for instance , we want to compute its differential applied to the element @xmath103 at degree @xmath104 .",
    "since the module at degree @xmath104 of the cone ( and , in fact , at _ any _ degree ) is @xmath105 \\oplus \\mathds{z}$ ] , the element @xmath103 has a component in each module .",
    "the first and third components appear simply as integers , because @xmath74 is considered a free module over a singleton which is skipped . on the contrary",
    ", elements in the second component are true combinations in @xmath83 $ ] with generator @xmath84 ( recall our convention of naming @xmath84 the element @xmath19 of @xmath106 ) .",
    "thus the modules of the cone are not presented as _ free _ modules , but they are isomorphic to modules freely generated , as it is inferred from the results of section 3 .",
    "the second element of the tuple @xmath103 is represented in coq by ` e:= law ( op ( r:= z_as_ring ) 7 ( var _ ( 4%nat : nat_as_setoid ) ) ) ( op ( r:= z_as_ring ) 8 ( var _ ( 0%nat : nat_as_setoid ) ) ) . `    the required coq code is then the following :    ....   eval vm_compute in    ( ( diff(topcc example_cone_effectivehomology ) 2 ) ( 5 , e , 3 ) ) . ....    and the result returned by coq",
    "is :    ....   = ( -10 , inv e , 5 ) : topcc example_cone_effectivehomology 2   ....    _ i.e. _ , @xmath107 .",
    "if we apply now the ( degree @xmath108 ) differential to this element we obtain :    ....   = ( 0 , inv ( inv ( law ( op 7 ( unit z_as_ring nat_as_setoid ) )                   ( op 8 ( unit z_as_ring nat_as_setoid ) ) ) ) , 0 )       : topcc example_cone_effectivehomology 1   ....    or , in plain notation , @xmath109 which it is equal ( in the setoid ) to the null element .",
    "it should be recalled that our formalization of the free module generated by the natural numbers directly use the l. pottier definition for free modules , and , as a consequence , we are not working with canonical elements on the free modules or with structures which allow a reduction to them .",
    "now , we focus our attention on homotopy operators , that is to say on morphisms which increase in one unity the degree into the graded module .",
    "we use as ambient structures the chain complexes @xmath102 and @xmath110 introduced in the previous section .    some examples of homotopy operators for @xmath110 , @xmath111 , are the following :    * @xmath112 , such that @xmath113 , @xmath114 for all @xmath29 * @xmath115 , such that @xmath116 , @xmath114 for all @xmath29    both can be easily implemented in coq .",
    "for example , the first one is represented through :    ....   definition h1 ' : forall i : z , bottomcc example_cone_effectivehomology i - >    bottomcc example_cone_effectivehomology(i + 1):=     fun ( i : z)(c : bottomcc example_cone_effectivehomology i ) = > ( 0 , fst c ) .",
    "there exist special homotopy operators called _ contracting homotopies _ which express algorithmically that the chain complex is _ acyclic _  @xcite .",
    "a chain complex is _ acyclic _ if it is possible to define an effective homology from it to the null chain complex .",
    "[ acyclic - corollary ] let @xmath117 be a chain complex , @xmath43 is acyclic if and only if there exists a homotopy operator @xmath118 defined on @xmath43 such that @xmath119 .",
    "such an operator is called _ contracting homotopy_.    we can test if the previous homotopy operators define a contracting homotopy .",
    "for instance , the corresponding tactic at degree ` i=1 ` choosing as element for the first candidate is :    ....   eval vm_compute in   ( ( ( diff ( bottomcc example_cone_effectivehomology ) 2)[oh](h1 2))[+h ]    ( ( h1 1)[oh](diff(bottomcc example_cone_effectivehomology ) 1)))(5 , 7 ) .   ....    resulting in : ` = ( 0 , 0 ) : bottomcc example_cone_effectivehomology 2 ` .    for the second homotopy operator over the same element",
    "we obtain :    ....   eval vm_compute in   ( ( ( diff ( bottomcc example_cone_effectivehomology ) 2)[oh](h2 2))[+h ]    ( ( h2 1)[oh](diff(bottomcc example_cone_effectivehomology ) 1)))(5 , 7 ) .   ....",
    "resulting in : ` = ( 5 , 7 ) : bottomcc example_cone_effectivehomology 2 ` .",
    "this means that @xmath120 is not a contracting homotopy for @xmath110 .",
    "it could be , anyway , acyclic .",
    "the homotopy operator @xmath121 could be a candidate for contracting homotopy and , in fact , if we test other elements in other dimensions we always obtain the identity .",
    "moreover , using the homotopy operator @xmath121 and the one @xmath122 in the effective homology at the end of the previous section , we can define a new homotopy operator over @xmath102 with the formula @xmath123 .",
    "graphically : @xmath101^{f^{ex}}\\ar@/4pc/@(r , u)_{h^{ex}}\\ar@(l , d)_{h = h^{ex}+\\ g^{ex}\\circ\\   h2\\ \\circ   f^{ex } } & & cone(\\alpha ' ) \\ar@/^/[ll]^{g^{ex}}\\ar@/4pc/@(l , u)^{h2 }    } \\ ] ] this homotopy operator can be easily defined in coq in the following way :    ....   definition h_topcone :   ( homotopyoperator(topcc example_cone_effectivehomology)):=    fun n : z = > ( h_t_t example_cone_effectivehomology )",
    "n [ + h ]     ( ( ( g_b_t example_cone_effectivehomology ) n ) [ oh ] ( h2 n ) [ oh ]     ( ( f_t_b example_cone_effectivehomology ) n ) ) .",
    "....    we can test if it is a candidate to be a contracting homotopy :    ....   eval vm_compute in   ( ( ( diff(topcc example_cone_effectivehomology ) 2)[oh](h_topcone 2 ) )     [ + h]((h_topcone 1)[oh ]      ( ( diff(topcc example_cone_effectivehomology ) 1))))(5 , e , 3 ) .   ....",
    "whose result is an element equal ( in the setoid ) to ` ( 5 , e , 3 ) ` .",
    "the testing with other elements and at other degrees is always successful and this allows us to conjecture that it is really a contracting homotopy .",
    "if that is the case , it could be used to solve a problem that , in general , is undecidable when working with chain complexes of infinite type .",
    "if an element @xmath5 is a cycle ( that is to say , @xmath2 ) and the chain complex is acyclic , then there exists an element @xmath7 such that @xmath124 . or , in other words",
    ", @xmath7 is a pre - image of @xmath5 for the differential .",
    "let us compute such a pre - image in our example . to this aim ,",
    "we choose again @xmath125 as an element at degree 2 .",
    "we know already it is a cycle , because it has been previously computed",
    ". then , if our homotopy operator @xmath118 is actually a contracting homotopy , the image @xmath126 must be a pre - image of @xmath5 for @xmath20 ( since @xmath127 , but @xmath128 ) .",
    "we can test in coq this fact as follows .",
    "first we apply the homotopy operator on the element :    ....   eval vm_compute in ( h_topcone 2)(-10 , inv e , 5 ) . ....    obtaining an element equal to ` ( 5 , e , 0 ) ` . and due to our previous computations we know that this element is indeed in the right pre - image because    ....   eval vm_compute in   ( ( diff(topcc example_cone_effectivehomology ) 2))(5 , e , 0 ) .   ....",
    "gives the required element ` ( -10 , inv e , 5 ) ` .",
    "this behaviour is not accidental .",
    "the testing is reflecting a general result relating cones and reductions .",
    "namely :    [ acyclic - proposition ] let @xmath129 be a reduction .",
    "then @xmath130 is an acyclic chain complex .",
    "the constructive proof of this proposition gives exactly the formula we were testing before .",
    "finally , we could proof in coq that @xmath121 and @xmath118 are indeed contracting homotopies which is now an easy exercise .",
    "also corollary  [ acyclic - corollary ] and proposition  [ acyclic - proposition ] could be formalized in coq , although more effort is required . both tasks are proposed as future work .",
    "in this paper we have presented some examples relating deduction and computing in the coq proof assistant .",
    "even if constructive type theory always allows , in principle , the modeler to execute terms ( by reducing them ) this is rarely used in development ( or , at least , it is rarely documented ) . in our case , testing has been worked out in an infinite dimensional setting .",
    "concretely , we have constructed concrete instances of chain complexes of infinite type , we have computed in coq with their elements , and we have checked some formula producing a contracting homotopy on one of the chain complexes .",
    "this testing corresponds to a general theorem that could be , later on , proved in coq , too .",
    "the chain complexes of infinite type used as examples in this paper are , in some sense , artificial .",
    "it can be considered as a demonstration of feasibility . in a future step",
    ", we will undertake the implementation in coq of more meaningful infinite dimensional spaces .",
    "our first candidates will be _ loop spaces_. the chain complex associated to a combinatorial loop space ( see kan s @xmath131 construction in @xcite ) is of infinite type .",
    "under good conditions , its homology groups are , however , of finite type .",
    "computing these homology groups was one of the first challenges solved by kenzo ( see @xcite ) , and working with them in coq would be an interesting issue .",
    "one unpleasant aspect of our work is that we are working in a context where combinations are not in normal form .",
    "this implies that , once a function has been applied , some work is needed to prove the result is equal to some assumed test value .",
    "several approaches are known to tackle this reduction to canonical form , and we should systematically explore some of them to propose a more comfortable way of doing testing in coq .",
    "another via to avoid this difficulty could be to give setoids up and work inside the _ ssreflect _ framework  @xcite .",
    "another related line is that of code extraction .",
    "we should retake the works on going from coq to scheme  @xcite , and adapt them to common lisp .",
    "since that we have a model ( kenzo @xcite ) of the programs we would like to extract , the challenge would be to devise coq statements and proofs in such a way that the extracted programs would be as close as possible to the selected kenzo fragment .",
    "finally we could study the possibilities of tools like quickcheck  @xcite in our setting .",
    "this system allows to test properties of programs automatically by generating a large number of cases ( although , up to our knowledge , there is no direct application to coq code ) .",
    "claessen , k. , hughes , j. : quickcheck : a lightweight tool for random testing of haskell programs . in",
    "_ proceedings of the fifth acm sigplan international conference on functional programming ( 2000 ) _ , sigplan notices 35(9 ) ( 2000 ) 268 - 279 ."
  ],
  "abstract_text": [
    "<S> computational content encoded into constructive type theory proofs can be used to make computing experiments over concrete data structures . in this paper </S>",
    "<S> , we explore this possibility when working in coq with chain complexes of infinite type ( that is to say , generated by infinite sets ) as a part of the formalization of a hierarchy of homological algebra structures .    </S>",
    "<S> theorem proving , formal methods , computer algebra , program verification . </S>"
  ]
}