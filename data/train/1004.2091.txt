{
  "article_text": [
    "we want to compute the jacobi symbol , since this is easier to typeset and less ambiguous than the more usual @xmath3 .",
    "@xmath4 is the time to multiply @xmath0-bit numbers .",
    "@xmath5 means @xmath6 for some constant @xmath7 . ]",
    "@xmath8 for @xmath0-bit integers @xmath9 and @xmath10 , where @xmath9 is odd positive .",
    "we give three algorithms based on the @xmath11-adic gcd from stehl and zimmermann  @xcite .",
    "first we give an algorithm whose worst - case time bound is @xmath12 ; we call this the _ cubic _ algorithm although this is pessimistic since the algorithm is quadratic on average as shown in @xcite , and probably also in the worst case .",
    "we then show how to reduce the worst - case to @xmath13 by combining sequences of `` ugly '' iterations ( defined in section  [ sec : cubic ] ) into one `` harmless '' iteration .",
    "finally , we obtain an algorithm with worst - case time @xmath1 .",
    "this is , up to a constant factor , the same as the time bound for the best known algorithm , apparently never published in full , but sketched in bach  @xcite and in more detail in bach and shallit  @xcite ( with credit to bachmann  @xcite ) .",
    "the latter algorithm makes use of the knuth - schnhage fast continued fraction algorithm  @xcite and an identity of gauss  @xcite .",
    "although this algorithm has been attributed to schnhage , schnhage himself gives a different @xmath1 algorithm  @xcite which does not depend on the identity of gauss .",
    "the algorithm is mentioned in schnhage s book  @xcite , but no details are given there .    with our algorithm",
    "it is not necessary to compute the full continued fraction or to use the identity of gauss for the jacobi symbol .",
    "thus , it provides an alternative that may be easier to implement .",
    "it is possible to modify some of the other fast gcd algorithms considered by mller  @xcite to compute the jacobi symbol , but we do not consider such possibilities here . at best",
    "they give a small constant factor speedup over our algorithm .",
    "we recall the main identities satisfied by the jacobi symbol : @xmath14 ; @xmath15 ; @xmath16 for @xmath17 odd ; and @xmath18 if @xmath19 .",
    "note that all our algorithms compute @xmath8 with @xmath10 even positive and @xmath9 odd positive .",
    "for the more general case where @xmath10 is any integer , we can reduce to @xmath10 even and positive using @xmath20 if @xmath10 is negative , and @xmath21 if @xmath10 is odd .",
    "we first describe a cubic algorithm to compute the jacobi symbol .",
    "the quadratic algorithm in section  [ sec : harmless - iterations ] is based on this cubic algorithm , and the subquadratic algorithm in section  [ sec : sub - quadratic ] uses the same ideas as the quadratic algorithm but with an asymptotically fast recursive implementation .    for @xmath22 , the notation @xmath23 denotes the @xmath11-adic valuation @xmath24 of @xmath9 , that is the maximum @xmath25 such that @xmath26 , or @xmath27 if @xmath28 .      throughout the paper we use the binary division with positive quotient defined by algorithm  [ binarydividepos ] .",
    "compared to the `` centered division '' of  @xcite , it returns a quotient in @xmath29 $ ] instead of in @xmath30 $ ] . note that the quotient @xmath31 is always odd .",
    "@xmath32 with @xmath33 @xmath31 and @xmath34 such that @xmath35 , @xmath36 @xmath37 [ bdp : step1 ] * return * @xmath38 .    with this binary division ,",
    "we define algorithm cubicbinaryjacobi , where the fact that the quotient @xmath31 is positive ensures that all @xmath39 terms computed remain positive , and @xmath9 remains odd , thus @xmath8 remains well - defined . , the _ _ [ binary gcd ] _ algorithm no longer terminates _ ''",
    ". however , with a modified stopping criterion as in algorithm cubicbinaryjacobi , the algorithm terminates ( we prove this below ) . ]    @xmath32 with @xmath40 jacobi symbol @xmath8 @xmath41 , @xmath42 @xmath43 @xmath44 [ cbj : step5 ] @xmath45 [ cbj : step6 ] @xmath46 , @xmath42 @xmath47 * then * return @xmath48 * else * return @xmath49    algorithm cubicbinaryjacobi is correct ( assuming it terminates ) .    proof .",
    "we prove that the following invariant holds during the algorithm , if @xmath50 are the initial values of @xmath17 : @xmath51 this is true before we enter the while - loop , since @xmath52 , @xmath53 , and @xmath54 . for each step in the while loop ,",
    "we divide @xmath10 by @xmath55 , swap @xmath9 and @xmath56 , replace @xmath9 by @xmath57 , and divide @xmath58 by @xmath55 .",
    "the jacobi symbol is modified by a factor @xmath59 for the division of @xmath10 by @xmath55 , by a factor @xmath60 for the interchange of @xmath9 and @xmath61 , and by a factor @xmath62 for the division of @xmath58 by @xmath55 . at the end of the loop ,",
    "we have @xmath63 ; if @xmath64 , since @xmath65 , we have @xmath66 , otherwise @xmath67 .",
    "the quantity @xmath68 is non - increasing in algorithm cubicbinaryjacobi .    proof . at each iteration of the `` while '' loop",
    ", @xmath9 becomes @xmath69 , and @xmath10 becomes @xmath70 . in matrix notation @xmath71",
    "therefore @xmath72 becomes @xmath73 since @xmath74 , the first term is bounded by @xmath9 . in the second term , @xmath75 , thus the second term is bounded by @xmath76 , which is bounded by @xmath77 for @xmath78 , and equals @xmath79 for @xmath80 .",
    "if @xmath78 , then @xmath72 is multiplied by a factor at most @xmath81 . if @xmath82 then @xmath72 decreases , but by a factor which could be arbitrarily close to  @xmath83 .",
    "the only case where @xmath72 does not decrease is when @xmath80 and @xmath84 ; in this case @xmath72 is unchanged .",
    "this motivates us to define three classes of iterations : _ good _ , _ bad _ , and _",
    "ugly_. let us say that we have a _ good _ iteration when @xmath78 , a _",
    "iteration when @xmath82 , and an _ ugly _ iteration when @xmath80 and @xmath84 .",
    "since @xmath31 is odd and @xmath85 , this covers all possibilities . for a bad iteration ,",
    "@xmath86 becomes @xmath87 , and for an ugly iteration , @xmath86 becomes @xmath88 .",
    "we denote the matrices corresponding to good , bad and ugly iterations by @xmath89 , @xmath90 and @xmath91 respectively .",
    "thus    @xmath92 the effect of @xmath93 successive ugly iterations is easily seen to be given by the matrix @xmath94                          2 - 2(-1/4)^m & \\ ; 4 + ( -1/4)^m   \\end{array } \\right ) .",
    "\\label{eq : um}\\ ] ] assume we start from @xmath95 , and after @xmath96 successive ugly iterations we get values @xmath97 .",
    "then , from equation  ( [ eq : um ] ) , @xmath98 we can not have @xmath99 or the algorithm would have terminated .",
    "however , @xmath100 must be an integer .",
    "this gives an upper bound on @xmath93 . for @xmath101 of @xmath0 bits ,",
    "the number of successive ugly iterations is bounded by @xmath102 ( a precise statement is made in lemma  [ lemma2 ] ) .",
    "if there were no bad iterations , this would prove that for @xmath0-bit inputs the number of iterations is @xmath103 , since each sequence of ugly iterations would be followed by at least one good iteration .",
    "bad iterations can be handled by a more complicated argument which we omit , since they will be considered in detail in ",
    "[ sec : harmless - iterations ] when we discuss the complexity of the quadratic algorithm ( see the proof of theorem  [ thm : qbj ] ) .",
    "since the number of iterations is @xmath103 from theorem  [ thm : qbj ] , and each iteration costs time @xmath104 , the overall time for algorithm cubicbinaryjacobi is @xmath105 . note that this worst - case bound is almost certainly too pessimistic ( see [ results ] ) .",
    "suppose we have a sequence of @xmath106 ugly iterations .",
    "it is possible to combine the @xmath93 ugly iterations into one _ harmless _ iteration which is not much more expensive than a normal ( good or bad ) iteration .",
    "also , it is possible to predict the maximal such @xmath93 in advance . using this trick , we reduce the number of iterations ( good , bad and harmless ) to @xmath107 and their cost to @xmath13 .    without loss of generality ,",
    "suppose that we start from @xmath108 = @xmath86 .",
    "since @xmath9 is odd , we never have @xmath109 .",
    "[ lemma2 ] if @xmath110 , then we have exactly @xmath111 ugly iterations starting from @xmath112 , followed by a good iteration if @xmath113 is even , and by a bad iteration if @xmath113 is odd .",
    "we prove the lemma by induction on @xmath113 . if @xmath114 , @xmath115 is odd , but @xmath9 is odd , so @xmath116 is even , which yields @xmath78 in binarydividepos , thus @xmath39 yield a good iteration . if @xmath117",
    ", @xmath115 is even , which implies that @xmath116 is odd , thus we have @xmath80 .",
    "if we had @xmath84 in binarydividepos , this would mean that @xmath118 , or equivalently @xmath119 , which is incompatible with @xmath117 .",
    "thus we have @xmath120 , and a bad iteration .",
    "now assume @xmath121 .",
    "the first iteration is ugly since @xmath122 divides @xmath115 , which implies that @xmath116 is odd .",
    "thus @xmath80 , and implies that @xmath84 .",
    "after one ugly iteration @xmath86 becomes @xmath123 , thus @xmath115 becomes @xmath124 , and the @xmath11-valuation of @xmath115 decreases by @xmath11 .    from the above",
    ", we see that , for a sequence of @xmath93 ugly iterations , @xmath125 satisfy the three - term recurrence @xmath126 and similarly for @xmath127 .",
    "it follows that @xmath128 , and similarly @xmath129 , for @xmath130 .",
    "we can modify algorithm cubicbinaryjacobi to consolidate @xmath93 consecutive ugly iterations into one harmless iteration , using the expressions ( [ eq : am])([eq : bm ] ) for @xmath100 and @xmath131 ( we give an optimised evaluation below ) .",
    "it remains to modify step  [ cbj : step6 ] of cubicbinaryjacobi to take account of the @xmath93 updates to @xmath132 .",
    "since @xmath80 for each ugly iteration , we have to increment @xmath132 by an amount @xmath133 where we write @xmath134 for @xmath135 .",
    "however , @xmath136 for @xmath137 , so the terms involving division by @xmath138 `` collapse '' mod  @xmath11 , leaving just the first and last terms .",
    "the terms involving two divisions by @xmath11 are all equal to @xmath139 mod  @xmath11 , using the observation that @xmath140 mod  @xmath122 is constant for @xmath141 .",
    "thus @xmath142 one further simplification is possible .",
    "since @xmath143 , and @xmath144 is odd , we can replace @xmath145 by @xmath144 in the last term , and use the fact that @xmath146 to obtain @xmath147 we can economise the computation of @xmath100 and @xmath131 from ( [ eq : am])([eq : bm ] ) by first computing @xmath148 where the divisions by @xmath149 and by @xmath150 are exact ; then @xmath151 , @xmath152 .    from these observations , it is easy to modify algorithm cubicbinaryjacobi to obtain algorithm quadraticbinaryjacobi . in this algorithm , steps [ qbj : step8][qbj : step12 ] implement a harmless iteration equivalent to @xmath106 consecutive ugly iterations ; steps [ qbj : step14][qbj : step15 ] implement bad and good iterations , and the remaining steps are common to both .",
    "step  [ cbj : step6 ] of algorithm cubicbinaryjacobi is split into three steps [ qbj : step5 ] , [ qbj : step14 ] and [ qbj : step16 ] . in the case of a harmless iteration ,",
    "the computation of @xmath153 satisfying  ( [ eq : delta ] ) is implicit in steps [ qbj : step5 ] , [ qbj : step11 ] and [ qbj : step16 ] .",
    "@xmath32 with @xmath40 jacobi symbol @xmath8 @xmath41 , @xmath42 [ qbj : step3 ] @xmath43 @xmath154 [ qbj : step5 ] @xmath44 @xmath155 [ qbj : step8 ] @xmath156 @xmath157 @xmath158 [ qbj : step11 ] @xmath159 [ qbj : step12 ] @xmath160 [ qbj : step14 ] @xmath46 [ qbj : step15 ] @xmath154 , [ qbj : step16 ] @xmath42 [ qbj : step17 ] @xmath47 * then * return @xmath48 * else * return @xmath49    [ thm : qbj ] algorithm quadraticbinaryjacobi is correct and terminates after @xmath107 iterations of the `` while '' loop ( steps [ qbj : step3][qbj : step17 ] ) if the inputs are positive integers of at most @xmath0 bits , with @xmath161 .",
    "correctness follows from the equivalence to algorithm cubicbinaryjacobi . to prove that convergence takes @xmath107 iterations ,",
    "we show that @xmath72 is multiplied by a factor at most @xmath162 in each block of three iterations .",
    "this is true if the block includes at least one good iteration , so we need only consider harmless and bad iterations .",
    "two harmless iterations do not occur in succession , so the block must include either ( harmless , bad ) or ( bad , bad ) . in the first case , the corresponding matrix is @xmath163 for some @xmath96 .",
    "we saw in ",
    "[ sec : cubic ] that the matrix @xmath91 leaves @xmath72 unchanged , so @xmath164 also leaves @xmath72 unchanged , and we need only consider the effect of @xmath165 .",
    "suppose that @xmath112 is transformed into @xmath166 by @xmath165 .",
    "thus @xmath167 we see that @xmath168 the case of two successive bad iterations is similar   just replace @xmath165 by @xmath169 in the above , and deduce that @xmath170 .",
    "we conclude that the number of iterations of the while loop is at most @xmath171 , where @xmath172 .",
    "_ remarks _ + 1 .",
    "a more complicated argument along similar lines can reduce the constant @xmath173 to @xmath174 . here",
    "@xmath175 denotes the spectral radius : @xmath176 .",
    "+ 2 . in practice quadraticbinaryjacobi is not much ( if any ) faster than cubicbinaryjacobi .",
    "its advantage is simply the better worst - case time bound .",
    "a heuristic argument suggests that on average only @xmath177 of the iterations of cubicbinaryjacobi are ugly .",
    "our implementations of cubicbinaryjacobi and quadraticbinaryjacobi are slower than gmp s @xmath103 algorithm ( which is based on stein s binary gcd , as in shallit and sorenson  @xcite ) . however , in the next section we use the ideas of our quadraticbinaryjacobi algorithm to get an @xmath1 algorithm .",
    "we do not see how to modify the algorithm of shallit and sorenson to do this .",
    "( @xmath178 in our notation ) to decide whether to perform an interchange .",
    "this makes it difficult to construct a recursive @xmath1 algorithm like algorithm halfbinaryjacobi . ]",
    "algorithm halfbinaryjacobi is a modification of algorithm half - gb - gcd from @xcite .",
    "the main differences are the following :    1 .",
    "binary division with positive ( not centered ) quotient is used ; 2 .",
    "the algorithm returns an integer @xmath132 such that if @xmath17 are the inputs , @xmath180 the output values defined by theorem  [ theorem2 ] , then @xmath181 3 .   at steps  [ hbgcd : step4 ] and",
    "[ hbgcd : step27 ] , we reduce mod @xmath182 ( resp .",
    "@xmath183 ) instead of mod @xmath184 ( resp .",
    "@xmath185 ) , so that we have enough information to correctly update @xmath186 at steps [ hbgcd : step10 ] , [ hbgcd : step17 ] , [ hbgcd : step21 ] and [ hbgcd : step25 ] ; 4 .",
    "we have to `` cut '' some harmless iterations in two ( step  [ hbgcd : stepm ] ) .",
    "@xmath187 with @xmath161 , and @xmath188 two integers @xmath189 and a @xmath190 matrix @xmath191 return @xmath192 [ hbgcd : step2 ] @xmath193 @xmath194 , @xmath195 [ hbgcd : step4 ] @xmath196 [ hbgcd : step5 ] @xmath197 , @xmath198 [ hbgcd : step6 ] @xmath199 return @xmath200 [ hbgcd : step9 ] @xmath201 [ hbgcd : step10 ] @xmath202 @xmath203 [ hbgcd : step12 ] [ hbgcd : step13 ] @xmath204 @xmath205 [ hbgcd : stepm ] @xmath157 @xmath206 [ hbgcd : step17 ] @xmath207 [ hbgcd : stepa2 ] @xmath208 [ hbgcd : step19 ] [ hbgcd : step20 ] @xmath209 [ hbgcd : step21 ] @xmath210 @xmath211 [ hbgcd : step23 ] @xmath212 @xmath213 [ hbgcd : step25 ] @xmath214 [ hbgcd : step11 ] @xmath215 [ hbgcd : step27 ] return @xmath216 , @xmath217    [ [ remarks . ] ] remarks .",
    "+ + + + + + + +    the matrix @xmath218 occurring at step  [ hbgcd : step19 ] is just @xmath219 , where @xmath220 is given by equation  ( [ eq : um ] ) .",
    "similarly , the matrix @xmath218 occurring at step  [ hbgcd : step23 ] is @xmath221 . in practice ,",
    "steps [ hbgcd : step13][hbgcd : step20 ] can be omitted ( so the algorithm becomes a fast version of cubicbinaryjacobi )   this variant is simpler and slightly faster on average .",
    "[ theorem2 ] let @xmath222 be the inputs of algorithm halfbinaryjacobi , and @xmath223 the corresponding outputs . if @xmath224 , then : @xmath225    proof ( outline ) .",
    "we prove the theorem by induction on the parameter @xmath25 .",
    "the key ingredient is that if we reduce @xmath17 mod @xmath184 in step  [ hbgcd : step4 ] , then the gb sequence of @xmath226 matches that of @xmath17 , for the terms computed by the recursive call at step  [ hbgcd : step5 ] .",
    "this is a consequence of  ( * ? ? ?",
    "* lemma  7 ) ( which also holds for binary division with positive quotient ) .",
    "it follows that in all the binary divisions with inputs @xmath227 in that recursive call , @xmath140 and @xmath228 match modulo @xmath229 the corresponding values that would be obtained from the full inputs @xmath17 ( otherwise the corresponding binary quotient @xmath230 would be wrong ) . since here we reduce @xmath17 mod @xmath182 instead of mod @xmath184 , @xmath140 and @xmath228 now match modulo @xmath231  instead of modulo @xmath229  the values that would be obtained from the full inputs @xmath17 , where @xmath232 since @xmath233 .    at step  [ hbgcd : step10 ]",
    ", @xmath186 depends only on @xmath234 and @xmath235 , at step  [ hbgcd : step17 ] it depends on @xmath236 and @xmath237 , and at step  [ hbgcd : step21 ] on @xmath237 and @xmath238 . since @xmath239 and @xmath240 at step  [ hbgcd : step21 ]",
    "correspond to some @xmath140 and @xmath228 , it follows that @xmath239 and @xmath240 agree mod @xmath138 with the values that would be computed from the full inputs , and thus the correction @xmath186 is correct .",
    "this proves by induction that @xmath241 .",
    "now we prove that @xmath242 .",
    "if there is no harmless iteration , @xmath242 is a consequence of the proof of theorem  1 in @xcite . in case",
    "there is a harmless iteration , first assume that @xmath243 at step  [ hbgcd : stepm ] .",
    "the new values @xmath244 at step  [ hbgcd : stepa2 ] correspond to @xmath93 successive ugly iterations , which yield @xmath245 .",
    "thus @xmath246 : we did not go too far , and since we are computing the same sequence of quotients as algorithm quadraticbinaryjacobi , the result follows .",
    "now if @xmath247 , we would go too far if we performed @xmath248 ugly iterations , since it would give @xmath249 , thus @xmath250 , and @xmath251 would exceed @xmath25 .",
    "this is the reason why we `` cut '' the harmless iteration at @xmath252 ( step  [ hbgcd : stepm ] ) .",
    "the other invariants are unchanged",
    ".    finally we can present our @xmath1 algorithm fastbinaryjacobi , which computes the jacobi symbol by calling algorithm halfbinaryjacobi .",
    "the general structure is similar to that described in  @xcite for several asymptotically fast gcd algorithms .",
    "@xmath32 with @xmath161 jacobi symbol @xmath8 @xmath41 , @xmath42 @xmath253 @xmath254 @xmath255 @xmath256 , @xmath42 @xmath47 * then * return @xmath48 * else * return @xmath49    daireaux , maume - deschamps and valle  @xcite prove that , for the positive binary division , the average increase of the most significant bits is @xmath257 bits / iteration ( which partly cancels an average decrease of two least significant bits per iteration ) ; compare this with only @xmath258 bits / iteration on average for the centered division . and",
    "@xmath259 respectively . ]",
    "we have implemented the different algorithms in c ( using @xmath260-bit integers ) and in gmp ( using multiple - precision integers ) , as well as in maple / magma ( for testing purposes ) .",
    "for @xmath261 the maximum number of iterations of algorithm cubicbinaryjacobi is @xmath260 , with @xmath262 and @xmath263 .",
    "the number of iterations seems to be @xmath107 for @xmath264 : see table  1 .",
    "this is plausible because , from heuristic probabilistic arguments , we expect about half of the iterations to be good , and experiments confirm this .",
    "for example , if we consider all admissible @xmath265 , the cumulated number of iterations is @xmath266 for @xmath267 calls , i.e. , an average of @xmath268 iterations per call ( max @xmath269 ) ; the cumulated number of good , bad and ugly iterations is @xmath270% , @xmath271% , and @xmath272% respectively .",
    "for @xmath273 , a random sample of @xmath274 pairs @xmath86 gave @xmath275 iterations per call ( max @xmath276 ) , with @xmath277 , @xmath278% , and @xmath279 for good , bad and ugly respectively .",
    "these ratios seem to be converging to the heuristically expected @xmath280 , @xmath281 , and @xmath281 .",
    "when we consider all admissible @xmath265 , the maximum number of iterations of quadraticbinaryjacobi is @xmath282 when @xmath283 , @xmath284 , the cumulated number of iterations is @xmath285 ( @xmath286 per call ) , the cumulated number of good , bad and harmless iterations is @xmath287% , @xmath288% , and @xmath289% respectively . for @xmath273 , a random sample of @xmath274 pairs @xmath86 gave @xmath290 iterations per call ( max @xmath291 ) , with @xmath292 , @xmath293% , and @xmath294 for good , bad and harmless respectively .",
    "these ratios seem to be converging to the heuristically expected @xmath295 , @xmath296 , and @xmath297 .",
    "we have also compared the time and average number of iterations for huge numbers , using the fast gcd algorithm in gmp , say ` gcd `  which implements the algorithm from @xcite  and an implementation of the algorithm from @xcite , say ` bgcd ` . for inputs of one million @xmath260-bit words , ` gcd ` takes about 45.8s on a 2.83ghz core 2 , while ` bgcd ` takes about 48.3s and 32,800,000 iterations : this is in accordance with the fact proven in @xcite that each step of the binary gcd discards on average two least significant bits , and adds on average about 0.05 most significant bits .",
    "our algorithm ` bjacobi ` ( based on algorithms 3.13.2 ) takes about 83.1s and 47,500,000 iterations ( for a version with steps [ hbgcd : step13][hbgcd : step20 ] of algorithm 3.1 omitted in the basecase routine ) , which agrees with the theoretical drift of @xmath298 bits per iteration . the break - even point between the @xmath103 implementation of the jacobi symbol in gmp 4.3.1 and",
    "our @xmath179 implementation is about @xmath299 words , that is about @xmath300 bits or about @xmath301 decimal digits ( see fig .",
    "[ fig1 ] ) .",
    "weilert  @xcite says : `` _ _ we are not able to use a gcd calculation in @xmath302 $ ] similar to the binary gcd algorithm @xmath303 because we do not get a corresponding quotient sequence in an obvious manner _ _ '' . in a sense we filled that gap for the computation of the jacobi symbol , because we showed how it can be computed using a binary gcd algorithm without the need for a quotient sequence .",
    "we showed how to compute the jacobi symbol with an asymptotically fast time bound , using a binary gcd algorithm without the need for a quotient sequence .",
    "our implementation is faster than a good @xmath103 implementation for numbers with bitsize @xmath304 .",
    "our subquadratic implementation is available from http://www.loria.fr/~zimmerma/software/#jacobi .",
    "binary division with a centered quotient does not seem to give a subquadratic algorithm ; however we can use it with the `` cubic '' algorithm ( which then becomes provably quadratic ) since then we control the sign of @xmath17 . for a better quadratic algorithm",
    ", we can choose the quotient @xmath31 so that @xmath305 , by replacing @xmath31 by @xmath306 if necessary : experimentally , this gains on average @xmath307 bits per iteration , compared to @xmath308 for the centered quotient , and @xmath309 for the positive quotient . in comparison ,",
    "stein s `` binary '' algorithm gains on average @xmath310 bits per iteration @xcite@xcite .",
    "the authors thank steven galbraith who asked them about the existence of an @xmath179 algorithm for the jacobi symbol , arnold schnhage for his comments and a pointer to the work of his former student andr weilert , damien stehl who suggested adapting the binary gcd algorithm , and marco bodrato and niels mller for testing our implementation .",
    "we also thank inria for its support of the anc `` quipe associe '' .",
    "the first author acknowledges the support of the australian research council .",
    "richard p. brent , twenty years analysis of the binary euclidean algorithm , in _ millennial perspectives in computer science : proceedings of the 1999 oxford   microsoft symposium in honour of professor sir antony hoare _",
    "( edited by j.  davies , a.  w.  roscoe and j.  woodcock ) , palgrave , new york , 2000 , 4153 .",
    "http://wwwmaths.anu.edu.au/~brent/pub/pub183.html    benot daireaux , vronique maume - deschamps and brigitte valle , the lyapunov tortoise and the dyadic hare , _ proceedings of the 2005 international conference on analysis of algorithms _ , dmtcs proc .",
    "ad ( 2005 ) , 7194 ."
  ],
  "abstract_text": [
    "<S> the best known algorithm to compute the jacobi symbol of two @xmath0-bit integers runs in time @xmath1 , using schnhage s fast continued fraction algorithm combined with an identity due to gauss . </S>",
    "<S> we give a different @xmath1 algorithm based on the binary recursive gcd algorithm of stehl and zimmermann . our implementation  which to our knowledge is the first to run in time @xmath1 </S>",
    "<S>  is faster than gmp s quadratic implementation for inputs larger than about @xmath2 decimal digits . </S>"
  ]
}