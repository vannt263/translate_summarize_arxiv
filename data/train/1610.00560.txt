{
  "article_text": [
    "networks of processor - sharing queues with state - dependent service rates have been extensively used to model a large variety of communication and computation systems like content delivery systems @xcite , computer clusters @xcite and data networks @xcite .",
    "they are natural models for such systems as they capture the complex interactions between different jobs and also have a promise of analytical tractability of user performance when subject to stochastic loads .",
    "indeed , in the past two decades researchers have been able to obtain explicit performance expressions and bounds for several such systems , see @xcite .    however , few performance results scale well with the system size . those that do rely on restrictive assumptions related to the topology or the symmetry of the system @xcite",
    ". one of the main goals of this paper is to provide scalable performance results for a class of processor - sharing systems which find applications in bandwidth - sharing networks and computer clusters .",
    "one of the key features of processor - sharing networks is the allocation of the service rates per queue in each state .",
    "a particular class of resource allocations which is more tractable for performance analysis is characterized by the balance property which constraints the relative gain in the service rate at one queue when we remove a job from another queue .",
    "processor - sharing networks where the resource allocation satisfies this property are called whittle networks @xcite . in particular ,",
    "if the service rates are constrained by some capacity set , corresponding to the resources of the system considered , then there exists a unique policy which satisfies the balance property while being efficient , namely balanced fairness @xcite . in this paper",
    "we focus on networks which are constrained by a polymatroid capacity set @xcite and operate under balanced fair resource allocation policy .",
    "it was proved in @xcite that balanced fairness is pareto - efficient when it is applied in polymatroid capacity sets , which in practice yields explicit recursion formulas . however , if no further assumptions are made on the structure of the system , the complexity of these formulas is exponential with the number of queues .",
    "it was proved in @xcite that it can be made linear at the cost of strict assumptions on the overall symmetry of the capacity set and the traffic intensity at each queue . under symmetry in interaction across queues , it was shown in @xcite that the performance is robust to heterogeneity in loads and system configuration under an appropriate scaling regime . however , there is little understanding of performance for scenarios where queues themselves interact in heterogeneous fashion .    in this paper",
    ", we consider a scenario where the network is divided into a finite number of parts , so that queues are exchangeable within each part and asymmetric across different parts .",
    "for such systems , that we call poly - symmetric , we obtain a performance expression with computational complexity which is polynomial in the number of queues .",
    "we demonstrate the usefulness of these bounds by applying them to tree data networks , which are representative of backhaul networks , and to randomly configured heterogeneous computer clusters .",
    "in addition , we provide a monotonicity bound which allows us to bound performance of systems with capacity regions which are ` closely ' poly - symmetric .",
    "the paper is organized as follows .",
    "section [ sec : model ] introduces the model and shows that it applies to systems as varied as tree data networks and computer clusters .",
    "we also recall known facts about balanced fairness . in section [ sec : polysymmetry ] ,",
    "we introduce the notion of poly - symmetry and show that it yields explicit recursion formulas for the performance metrics which have a complexity that is polynomial in the number of queues in the network .",
    "finally , section [ sec : bounds ] gives stochastic bounds to compare the performance of different systems .",
    "we conclude in section [ sec : ccl ] .",
    "we consider a network of @xmath0 processor - sharing queues with coupled service rates and we denote by @xmath1 the set of queue indices . for each @xmath2",
    ", jobs enter the network at queue @xmath3 according to some poisson process with intensity @xmath4 and have i.i.d .",
    "exponential service requirements with mean @xmath5 , resulting in a traffic intensity @xmath6 at queue @xmath3 . jobs leave the network immediately after service completion .",
    "the network state is described by the vector @xmath7 , where @xmath8 is the number of jobs at queue @xmath3 for each @xmath2 . for each @xmath9",
    ", @xmath10 denotes the set of active queues in state @xmath11 .",
    "queues have state - dependent service rates . for each @xmath9",
    ", @xmath12 denotes the vector of service rates per queue when the network is in state @xmath11 .",
    "the network is characterized by a _ capacity set _ , which is defined as the set of all feasible resource allocations @xmath13 .",
    "this capacity set may be specified by practical constraints like the capacities of the links in a data network or the service rates of the servers in a computer cluster .",
    "we are interested in queueing networks whose capacity set is a particular type of polytope called a _ polymatroid _ @xcite .",
    "[ def : polymatroid ] a polytope @xmath14 in @xmath15 is a _ polymatroid _ if there exists a non - negative function @xmath16 defined on the power set of @xmath17 such that @xmath18 and @xmath16 satisfies the following properties :    normalization : @xmath19 ,    monotonicity : for all @xmath20 , if @xmath21 , then @xmath22 ,    submodularity : for all @xmath20 , @xmath23 .",
    "@xmath16 is called the _",
    "rank function _ of the polymatroid @xmath14",
    ".    .45    ( c1 ) ; at ( @xmath24 ) ( c2 ) ; at ( @xmath25 ) ( c ) ;    at ( c1 ) ; at ( c2 ) ; at ( c ) ;    at ( @xmath26 ) @xmath27 ; ( @xmath28 )  ( @xmath29 ) ( @xmath30 )  ( @xmath31 ) ( @xmath32 )  ( @xmath33 ) ;    at ( @xmath34 ) @xmath35 ; ( @xmath36 )  ( @xmath37 ) ( @xmath38 )  ( @xmath39 ) ( @xmath40 )  ( @xmath41 ) ;       .45    ( server1 ) 1 ; at ( @xmath42 ) ( server2 ) 2 ; at ( @xmath43 ) ( server3 ) 3 ;    at ( @xmath44 ) ( class1 ) 1 ; at ( @xmath45 ) ( class2 ) 2 ;    ( class1 )  ( server1 ) ; ( class1 )  ( server2 ) ; ( class2 )  ( server2 ) ; ( class2 ) ",
    "( server3 ) ;     +    .45    ( server1 ) ; at ( server1 ) @xmath46 ; at ( @xmath47 ) ( server2 ) ; at ( server2 ) @xmath48 ;    ( queue1 ) at ( @xmath49 ) ; ( [ xshift=--1pt , yshift=-+1pt ] queue1.north west ) rectangle ( [ xshift=+4pt , yshift=-1pt ] queue1.south west ) ; ( [ xshift=--1pt , yshift=- ] queue1.north west ) rectangle ( [ xshift=15pt , yshift= ] queue1.south west ) ; ( [ xshift=15pt ] queue1.north west )  ( [ xshift=15pt ] queue1.south west ) ;    ( queue2 ) at ( @xmath50 ) ; ( [ xshift=--1pt , yshift=-+1pt ] queue2.north west ) rectangle ( [ xshift=+4pt , yshift=-1pt ] queue2.south west ) ; ( [ xshift=--1pt , yshift=- ] queue2.north west ) rectangle ( [ xshift=15pt , yshift= ] queue2.south west ) ; ( [ xshift=15pt ] queue2.north west )  ( [ xshift=15pt ] queue2.south west ) ;    ( @xmath51 )  node[midway , above ] @xmath52 ( @xmath53 ) ; ( @xmath54 )  node[midway , above ] @xmath55 ( @xmath56 ) ;       .45   queues , title=\"fig : \" ]    before we specify the resource allocation , we give two examples of systems that fit into this model .",
    "the first example is a data network with a tree topology @xcite , representative of backhaul networks .",
    "there are @xmath0 users that can generate flows in parallel and we denote by @xmath1 the set of user indices . for any @xmath2 , user @xmath3 generates data flows according to some poisson process with intensity @xmath4 that is independent of the other users .",
    "all flows generated by user @xmath3 follow the same route in the network and have i.i.d .",
    "exponentially distributed sizes with mean @xmath5 in bits , resulting in a traffic intensity @xmath6 in bit / s .",
    "the state of the network is described by the vector @xmath7 , where @xmath8 is the number of ongoing flows of user @xmath3 , for each @xmath2 .",
    "we make the following assumptions on the allocation of the resources . the capacity of each link can be divided continually among the flows that cross it . also , the resource allocation per flow only depends on the number of flows of each user in progress .",
    "in particular , it is entirely defined in any state @xmath9 by the total capacity @xmath57 allocated to flows of user @xmath3 , for any @xmath2 .    under these assumptions",
    ", we can represent the data network by a processor - sharing network with @xmath0 queues , one per user . for each @xmath2 , queue @xmath3",
    "contains the ongoing flows of user @xmath3 and its service rate in state @xmath11 is the total capacity @xmath57 allocated to the flows of user @xmath3 .",
    "we will now describe the corresponding capacity set .",
    "each link can be identified by the set of users that cross it .",
    "specifically , we can describe the network by a family @xmath58 of subsets of @xmath17 , where a set @xmath59 is in @xmath58 if and only if there is a link crossed by the flows of all users @xmath60 .",
    "we assume that the network is a tree in the following way .",
    "the network is called a _ tree _ if for all @xmath61 , @xmath62 implies that @xmath63 or @xmath64 .",
    "there is no loss of generality in assuming that @xmath65 , for if not , the network is a forest where each subtree can be considered independently . for each @xmath66 , we denote by @xmath67 the capacity in bit / s of link @xmath68 .",
    "we assume that all links are constraining since otherwise we can simply ignore the non - constraining ones .",
    "the resource allocation must then satisfy the capacity constraints @xmath69 so that the capacity set is given by @xmath70    figure [ fig : exmodel ] gives the example of a tree data network with @xmath71 users .",
    "the routes of the users are given in figure [ fig : extree ] .",
    "the flows of each user cross one link that is individual and another that is shared by both users .",
    "the representation of this data network as a processor - sharing network is given in figure [ fig : expsnet ] and the corresponding capacity set is given in figure [ fig : expolymatroid ] .",
    "it is easy to see that it is a polymatroid for any value of the link capacities .",
    "the following theorem generalizes this last remark to any tree data network .",
    "[ theo : tree ] the capacity set of a tree data network is a polymatroid with rank function @xmath16 defined by @xmath72 in addition , we have @xmath73 for each @xmath66 .",
    "we can certainly assume that @xmath58 contains all the singletons since letting @xmath74 for each @xmath2 does not modify the capacity set @xmath14 .",
    "we can easily see that the result remains true if we do not make this assumption .",
    "we apply the following lemma which is a direct consequence of theorems 2.5 and 2.6 of @xcite about intersecting - submodular functions on intersecting families .",
    "let @xmath58 be a family of subsets of @xmath17 and @xmath75 such that , for all @xmath61 with @xmath62 , we have @xmath76 , @xmath77 and @xmath78 .",
    "further assume that @xmath79 , @xmath80 and @xmath58 contains all the singletons of @xmath17 .",
    "then the set of solutions in @xmath81 of the equations @xmath82 is given by @xmath83 where @xmath84 is the normalized , submodular function defined by @xmath85    the definition of a tree ensures that @xmath58 satisfies the assumptions of the lemma , with the function @xmath86 defined on @xmath58 by @xmath87 for any @xmath66 .",
    "hence , the set of solutions of the capacity constraints in @xmath81 is @xmath88 where @xmath89 is the normalized , submodular function given by @xmath90 note that no claim about the monotonicity of @xmath89 is made above .",
    "the capacity set @xmath14 of the data network is then given by @xmath91 .",
    "we will deduce from this that @xmath14 is equal to the polymatroid @xmath92 with rank function @xmath16 given by @xmath93 an illustration of this is given in figure [ fig : treeset ] .",
    "one can check that this function @xmath16 coincides with the one given in the theorem statement .",
    "we first show that @xmath16 is indeed a rank function and in a second time we will prove that @xmath14 is equal to @xmath92 .",
    "the normalization of @xmath16 follows from that of @xmath89 .",
    "also @xmath16 is non - decreasing by construction . finally , for each @xmath20 , we have @xmath94 for some @xmath95 such that @xmath96 and @xmath97 , and also @xmath98 where the first inequality holds by submodularity of @xmath89 and the second by definition of @xmath16 , since @xmath99 and @xmath100 .",
    "hence @xmath16 is submodular .",
    "we finally prove that @xmath101 .",
    "it is clear that any vector in @xmath92 is also in @xmath91 since @xmath102 for all @xmath103 .",
    "conversely , consider @xmath104 .",
    "if @xmath105 is not in @xmath92 , then there is @xmath103 so that @xmath106 , which implies that @xmath107 . by definition of @xmath16",
    ", it follows that there is @xmath108 so that @xmath109 is a strict subset of @xmath110 and @xmath111 .",
    "but then @xmath112 so that at least one component of @xmath105 is negative .",
    "this is a contradiction .",
    "[ ex : tree ] figure [ fig : extreegeneral ] gives the example of a tree data network with its capacity set .",
    "the routes of the users are given in figure [ fig : extreegeneralgraph ] .",
    "each link is labeled with the set of user indices whose flows cross this link .",
    "the capacity constraints are @xmath113 the rank function @xmath16 of the capacity set is given by @xmath114    .48    ( c1 ) ; at ( @xmath24 ) ( c2 ) ; at ( @xmath115 ) ( c12 ) ; at ( @xmath116 ) ( c3 ) ; at ( @xmath117 ) ( c ) ;    at ( c1 ) ; at ( c2 ) ; at ( c3 ) ; at ( c12 ) ; at ( c ) ;    at ( @xmath118 ) @xmath27 ; ( @xmath119 )  ( @xmath29 ) ( @xmath30 )  ( @xmath120 ) ( @xmath121 )  ( @xmath122 ) ( @xmath123 )  ( @xmath124 ) ;    at ( @xmath125 ) @xmath35 ; ( @xmath126 )  ( @xmath37 ) ( @xmath38 )  ( @xmath127 ) ( @xmath128 )  ( @xmath129 ) ( @xmath130 )  ( @xmath131 ) ;    at ( @xmath132 ) @xmath133 ; ( @xmath134 )  ( @xmath135 ) ( @xmath136 ) ",
    "( @xmath137 ) ( @xmath138 )  ( @xmath139 ) ;    .4       we consider a cluster of @xmath140 servers which can be pooled to process jobs in parallel .",
    "the set of servers is denoted by @xmath141 .",
    "there are @xmath0 classes of jobs and we denote by @xmath1 the set of class indices . for any @xmath2 , class-@xmath3 jobs enter the cluster as a poisson process with intensity @xmath4 and have i.i.d .  exponential service requirements , resulting in a traffic intensity @xmath6 for class @xmath3 .",
    "jobs leave the cluster immediately after service completion .",
    "the state of the cluster is described by the vector @xmath7 , where @xmath8 is the number of jobs of class @xmath3 , for each @xmath2 .",
    "the class of a job defines the set of servers that can process it .",
    "the server assignment is given by a family @xmath142 of subsets of @xmath143 , where @xmath144 denotes the set of servers that can serve class-@xmath3 jobs , for each @xmath2 .",
    "equivalently , the server assignment can be described by a bipartite graph @xmath145 called the _ graph of assignment _ of the computer cluster .",
    "the service capacity of server @xmath146 is @xmath147 for each @xmath148 . for any set @xmath103 of job classes ,",
    "we let @xmath149 denote the aggregate capacity available for the classes in @xmath109 .",
    "we make the following assumptions on the allocation of the server capacities .",
    "servers can be pooled to process jobs in parallel .",
    "when a job is in service on several servers , its service rate is the sum of the rates allocated by each server to this job .",
    "we also assume that the capacity of each server can be divided continually among the jobs it can serve .",
    "finally , the allocation of the service rates per job only depends on the number of jobs of each class in the cluster .    in particular , it is entirely defined in any state @xmath150 by the total capacity @xmath57 allocated to class-@xmath3 jobs , for each @xmath2 . under these assumptions , we can describe the evolution of the cluster with a processor - sharing network with @xmath0 queues , one per class . for each @xmath2",
    ", queue @xmath3 contains class-@xmath3 jobs and its service rate in state @xmath11 is the total capacity @xmath57 allocated to class-@xmath3 jobs collectively . it was proved in @xcite that the capacity set of such a cluster is a polymatroid and that the function @xmath16 defined by is its rank function .",
    "figure [ fig : exmodel ] gives the example of a computer cluster .",
    "the graph of assignment is given in figure [ fig : exmgraph ] which depicts the job classes on the left and the servers on the right .",
    "server @xmath35 can serve both classes whereas servers @xmath27 and @xmath133 are specialized .",
    "the corresponding processor - sharing network with @xmath71 queues is showed in figure [ fig : expsnet ] .",
    "the capacity set of this computer cluster is a polymatroid in @xmath151 drawn in figure [ fig : expolymatroid ] .",
    "the vertical and horizontal sides correspond to the individual constraints of classes @xmath27 and @xmath35 , with @xmath152 and @xmath153 . the diagonal side corresponds to the joint constraint on classes @xmath27 and @xmath35 , with @xmath154 .",
    "the service rates are allocated by applying balanced fairness @xcite in the polymatroid capacity set @xmath14 introduced in section [ subsec : capacityset ] .    for each @xmath2 ,",
    "let @xmath155 denote the @xmath0-dimensional vector with @xmath27 in position @xmath3 and @xmath156 elsewhere .",
    "balanced fairness is defined as the only resource allocation that both satisfies the _ balance property _ @xmath157 and maximizes the resource utilization in the following sense : in any state @xmath9 , @xmath158 and there exists @xmath159 such that @xmath160 the balance property ensures that there exists a balance function @xmath161 on @xmath162 such that @xmath163 and @xmath164 the second condition implies that @xmath161 satisfies the recursion @xmath165 in @xcite it is proved that balanced fairness is pareto - efficient in polymatroid capacity sets , which means that this maximum is always achieved by the set @xmath166 of active queues : @xmath167    since the balance property is satisfied , the processor - sharing network defined in section [ subsec : capacityset ] is a whittle network @xcite .",
    "a stationary measure of the network state @xmath168 is @xmath169 where we use the notation @xmath170 for any @xmath9 . substituting ( [ eq : recphi ] ) into this expression yields @xmath171 it is proved in @xcite that the system is stable , in the sense that the underlying markov process is ergodic , if and only if @xmath172 which means that the vector of traffic intensities belongs to the interior of the capacity set . in the rest of the paper , we assume that this condition is satisfied and we denote by @xmath173 the stationary distribution of the network state .      by abuse of notation , for each @xmath103 , we denote by @xmath174 the probability that the set of active queues is @xmath109 : @xmath175 for each @xmath2 , let @xmath176 $ ] denote the mean number of jobs at queue @xmath3 and , for each @xmath103 , let @xmath177 $ ] denote the mean number of jobs at queue @xmath3 given that the set of active queues is @xmath109 . by the law of total expectation",
    ", we have @xmath178 the following theorem gives a recursive formula for @xmath174 and @xmath179 for any @xmath103 and @xmath2 .",
    "it is a restatement of ( * ? ? ?",
    "* theorem 4 ) using the same idea as in ( * ? ? ?",
    "* proposition 4 and theorem 1 ) .",
    "[ theo : recsets ] for each non - empty set @xmath103 , we have @xmath180 let @xmath2 . for each set @xmath103 , we have @xmath181 if @xmath182 , and otherwise @xmath183    observe that allows one to evaluate recursively @xmath184 for each @xmath103 , from which @xmath185 can be computed .",
    "similarly , for each @xmath2 , allows one to evaluate recursively @xmath186 for each @xmath103 and each @xmath2 , from which the value of @xmath187 can be deduced .",
    "one could then compute performance metrics like the mean delay or the mean service rate per queue from @xmath187 by applying little s law .",
    "note that the complexity is exponential in the number of queues .",
    "the exponential complexity of the formulas of theorem [ theo : recsets ] is limiting when we want to predict the performance of large - scale systems . to cope with this ,",
    "we introduce the notion of poly - symmetry , which allows us to obtain formulas with a complexity that is polynomial in the number of queues at the cost of some regularity assumptions on the capacity set and the traffic intensity at each queue .",
    "poly - symmetry is a generalization of the notion of symmetry which was considered in @xcite .",
    "the following definition will be used subsequently to introduce poly - symmetry .",
    "it is easy to check that it defines an equivalence relation on the set @xmath17 of indices .",
    "[ def : exch ] let @xmath14 be a polymatroid on @xmath81 and denote its rank function by @xmath16 .",
    "let @xmath188 with @xmath189 .",
    "we say that indices @xmath3 and @xmath190 are _ exchangeable _ in @xmath14 if @xmath191    like the name suggests , two indices are exchangeable if and only if exchanging these indices does not modify the capacity set .",
    "note that the exchangeability of two indices @xmath3 and @xmath190 implies that they have the same individual constraints @xmath192 .",
    "the reverse implication is not true when @xmath193 , as we will see in the following example .    .23    ( server1 ) ; at ( @xmath194 ) ( server2 ) ; at ( @xmath195 ) ( server3 ) ; at ( @xmath196 ) ( server4 ) ;    at ( @xmath44 ) ( class1 ) 1 ; at ( @xmath45 ) ( class2 ) 2 ; at ( @xmath197 ) ( class3 ) 3 ;    ( class1 ) ",
    "( server1 ) ; ( class1 )  ( server2 ) ; ( class2 )  ( server2 ) ; ( class2 )  ( server3 ) ; ( class3 )  ( server3 ) ; ( class3 )  ( server4 ) ;    .5     [ ex : exchindices ] consider the computer cluster with the graph of assignment depicted in figure [ fig : exexchgraph ] , where all servers have the same unit capacity .",
    "the corresponding polymatroid capacity set is illustrated in figure [ fig : exexchset ] .",
    "we have @xmath198 and @xmath199 , so that indices @xmath27 and @xmath133 are exchangeable .",
    "index @xmath35 is not exchangeable with any of the two other indices because @xmath199 while @xmath200 .",
    "let us now define poly - symmetry .",
    "let @xmath201 and consider a partition @xmath202 of @xmath17 in @xmath203 parts .",
    "[ def : poly ] let @xmath14 be a polymatroid in @xmath81 and denote its rank function by @xmath16 .",
    "@xmath14 is called _ poly - symmetric _ with respect to partition @xmath204 if for any @xmath205 , all indices in @xmath206 are pairwise exchangeable in @xmath14 .",
    "equivalently , a polymatroid @xmath14 is poly - symmetric with respect to a partition @xmath204 if and only if @xmath204 is a refinement of the quotient set of @xmath17 by the exchangeability relation in @xmath14 .",
    "it follows directly from the definition that the polymatroid of example [ ex : tree ] is poly - symmetric with respect to partition @xmath207 as soon as @xmath208 , as we can see in figure [ fig : extreegeneralregion ] .",
    "also in example [ ex : exchindices ] , the polymatroid is poly - symmetric with respect to partition @xmath209 .    for each @xmath205 ,",
    "let @xmath210 denote the size of part @xmath211 .",
    "for any @xmath103 , let @xmath212 denote the vector of sizes of each part of @xmath109 in the partition .",
    "the set of these vectors is denoted by @xmath213 we will now give an alternative definition of poly - symmetry which is equivalent to definition [ def : poly ] .",
    "it is a generalization of the definition of symmetry given in @xcite .",
    "we will use it to express and prove theorem [ theo : recpoly ] .",
    "[ def : poly2 ] let @xmath14 be a polymatroid in @xmath81 and denote its rank function by @xmath16 .",
    "@xmath14 is called _ poly - symmetric _ with respect to partition @xmath204 if for any @xmath103 , @xmath214 depends on @xmath109 only through the size of @xmath215 for each @xmath205 .",
    "equivalently , there exists a componentwise non - decreasing function @xmath216 such that @xmath217 for all @xmath103 .",
    "we call @xmath218 the _ cardinality rank function _ of @xmath14 with respect to partition @xmath204",
    ".    _ proof of the equivalence._we only prove that definition [ def : poly ] implies definition [ def : poly2 ] ; the reverse implication is clear . for any @xmath20 with @xmath219",
    ", we can write @xmath220 and @xmath221 and we have @xmath222 .",
    "we are thus reduced to proving that @xmath223 for all disjoint sets @xmath224 such that @xmath219 .",
    "this can be done by descending induction on the cardinality of @xmath225 .    .23    ( server1 ) ; at ( @xmath42 ) ( server2 ) ; at ( @xmath43 ) ( server3 ) ;    at ( @xmath226 ) ( class1 ) 1 ; at ( @xmath227 ) ( class2 ) 2 ; at ( @xmath228 ) ( class3 ) 3 ;    ( class1 )  ( server1 ) ; ( class1 )  ( server2 ) ; ( class2 )  ( server1 ) ;",
    "( class2 )  ( server2 ) ; ( class2 )  ( server3 ) ; ( class3 )  ( server2 ) ; ( class3 )  ( server3 ) ;    .5 , title=\"fig : \" ]    [ ex : poly ] consider the computer cluster with the graph of assignment depicted in figure [ fig : expolysym ] , where all servers have the same unit capacity .",
    "the corresponding capacity set is illustrated in figure [ fig : expolysymregion ] .",
    "it is poly - symmetric with respect to partition @xmath229 and the corresponding cardinal rank function @xmath218 is given by @xmath230 , @xmath231 and @xmath232 .",
    "let @xmath202 be a partition of @xmath17 .",
    "we consider a processor - sharing network with a polymatroid capacity set which is poly - symmetric with respect to @xmath204 . for each @xmath103 ,",
    "the vector @xmath212 gives the number of active queues in each part of the partition when the set of active queues is @xmath109 .",
    "by abuse of notation , for each @xmath205 , we denote by @xmath233 the vector of @xmath234 with @xmath27 in component @xmath211 and @xmath156 elsewhere .    like in section [ subsec : bf ] , the resources are allocated by applying balanced fairness in this capacity set under some vector of traffic intensity @xmath235 which satisfies the stability constraints . for simplicity of notation , for each @xmath236 , we denote by @xmath237 the probability that the number of active queues in part @xmath211 is @xmath238 for each @xmath205 : @xmath239 for each @xmath205 , let @xmath240 $ ] denote the mean number of jobs in the queues of part @xmath211 and , for each @xmath236 , let @xmath241 $ ] denote the mean number of jobs in the queues of part @xmath211 given that there are @xmath242 active queues in part @xmath243 for each @xmath244 .",
    "the regularity assumptions ensure that , for each @xmath205 , @xmath245 and @xmath246 for each @xmath236 also give the mean numbers of jobs at queue @xmath3 for any @xmath247 . by the law of total expectation",
    ", we have @xmath248 the following theorem gives a recursive formula for @xmath237 and @xmath249 that allows one to compute recursively these quantities with a complexity @xmath250 . the proof is given in appendix [ app : recpoly ] .",
    "[ theo : recpoly ] consider a network of @xmath0 processor - sharing queues with state - dependent service rates allocated according to balanced fairness in a polymatroid capacity set @xmath14 .",
    "assume that @xmath14 is poly - symmetric with respect to partition @xmath204 and denote by @xmath218 the corresponding cardinality rank function .",
    "further assume that for each @xmath205 , all queues of @xmath206 receive jobs with the same traffic intensity @xmath251 , i.e.  @xmath252 for all @xmath247 .",
    "for each @xmath253 , we have @xmath254 let @xmath205 .",
    "for each @xmath236 , we have @xmath255 if @xmath256 , and otherwise @xmath257    this result applies to example [ ex : poly ] with the partition @xmath229 as soon as classes @xmath27 and @xmath133 have the same traffic intensity .",
    "the set of suitable vectors of traffic intensities appears in figure [ fig : expolysymregion ] .    in this theorem ,",
    "we have assumed that the cardinality rank function @xmath218 was given .",
    "given a system like the ones of sections [ subsec : modeltree ] and [ subsec : modelcluster ] which is known to be poly - symmetric with regard to some partition @xmath258 , one could ask if it is also possible to build @xmath218 with a complexity @xmath250 . this is straightforward for a computer cluster . concerning the tree data networks",
    ", we can actually apply a method similar to that of the proof of theorem [ theo : tree ] . specifically , we first define recursively a concave function @xmath89 on @xmath259 by @xmath260 , @xmath261 if there is @xmath66 so that @xmath262 , and otherwise @xmath263 from which we can construct @xmath218 by letting @xmath264    we will now see two examples of systems where this result applies .",
    "we consider the simple example of a tree data network where each user has an individual access line and all users share a backhaul link which a capacity @xmath225 in bit / s .",
    "the user access lines can have @xmath203 different capacities @xmath265 in bit / s .",
    "this corresponds to the model introduced in @xcite to predict some performance metrics in internet service provider networks .",
    "( c1 ) ; at ( @xmath266 ) ( c2 ) ; at ( @xmath267 ) ( c3 ) ; at ( @xmath268 ) ( c4 ) ; at ( @xmath269 ) ( c5 ) ; at ( @xmath270 ) ( c ) ;    at ( c1 ) ; at ( c2 ) ; at ( c3 ) ; at ( c4 ) ; at ( c5 ) ; at ( c ) ;    at ( @xmath26 ) ; ( @xmath118 )  ( @xmath29 ) ( @xmath30 )  ( @xmath271 ) ( @xmath272 )  ( @xmath273 ) ;    at ( @xmath34 ) ; ( @xmath125 )  ( @xmath37 ) ( @xmath38 )  ( @xmath274 ) ( @xmath275 )  ( @xmath276 ) ;    at ( @xmath277 ) ; ( @xmath132 )  ( @xmath135 ) ( @xmath136 )  ( @xmath278 ) ( @xmath279 )  ( @xmath280 ) ;    at ( @xmath281 ) ; ( @xmath282 )  ( @xmath283 ) ( @xmath284 )  ( @xmath285 ) ( @xmath286 )  ( @xmath287 ) ;    at ( @xmath288 ) ; ( @xmath289 )  ( @xmath290 ) ( @xmath291 )  ( @xmath292 ) ( @xmath293 )  ( @xmath294 ) ;    ( @xmath295 )  ( @xmath296 ) node[align = center ] [ black , midway , xshift=-1.4 cm ] access lines + with capacity @xmath297 ;    ( @xmath298 )  ( @xmath299 ) node[align = center ] [ black , midway , xshift=-1.4 cm ] access lines + with capacity @xmath300 ;    at ( @xmath301 ) backhaul link + with capacity @xmath225 ;    figure [ fig : multisource ] gives a toy example with @xmath302 possible access rates @xmath297 and @xmath300 .",
    "there are three users with access rate @xmath297 and two users with access rate @xmath300 .",
    "all users are constrained by the backhaul link with capacity @xmath225 .    for each @xmath205",
    "we denote by @xmath206 the set of users with access rate @xmath303 . these form a partition of the set @xmath304 of users .",
    "theorem [ theo : tree ] ensures that the capacity set of this data network is a polymatroid with rank function @xmath16 given by @xmath305 it is poly - symmetric with respect to partition @xmath202 .",
    "the corresponding cardinality rank function @xmath218 is given by @xmath306 we further assume that for each @xmath205 , all users with access line @xmath303 have the same traffic intensity @xmath307 . then the network is stable whenever @xmath308 , and the system meets the conditions of theorem [ theo : recpoly ] .",
    "a metric of interest is the mean throughput per user . for each @xmath2 , we denote by @xmath309 and @xmath310 the probability measure and expectation corresponding to the biased stationary distribution @xmath311 . for each @xmath205 and each @xmath247 , the mean throughput perceived by user @xmath3",
    "is then given by @xmath312 = \\frac{\\mathbb{e}[\\phi_i({\\bf x})]}{\\mathbb{p}\\ { { \\bf x}_i > 0 \\ } } = \\frac{\\varrho_k}{\\mathbb{p}\\ { { \\bf x}_i > 0 \\}},\\ ] ] where the second equality holds by the conservation equation @xmath313 $ ] for all @xmath247 .",
    "using the notations of section [ subsec : recpoly ] , the mean throughput of the users with access rate @xmath303 is given by @xmath314 where @xmath237 for each @xmath236 can be computed with a complexity @xmath250 by .",
    "other performance metrics like the mean congestion rate per user can be computed similarly .",
    "let @xmath315 .",
    "we consider a computer cluster with @xmath316 servers and @xmath317 classes .",
    "all servers have the same unit capacity and all jobs have a unit mean size .",
    "the set @xmath17 of classes is partitioned into two subsets @xmath318 and @xmath319 .",
    "@xmath318 contains @xmath320 classes that can each be served by @xmath321 servers and @xmath319 contains @xmath321 classes that can each be served by @xmath320 servers .",
    "for any @xmath322 , the @xmath3-th class of @xmath318 can be served by the servers @xmath323 for @xmath324 . for any @xmath325",
    ", the @xmath3-th class of @xmath319 can be served by the servers @xmath326 for @xmath327 .",
    "figure [ fig : polycluster ] gives a toy example with @xmath328 and @xmath329 .",
    "( server1 ) 1 ; at ( @xmath330 ) ( server2 ) 2 ; at ( @xmath331 ) ( server3 ) 3 ; at ( @xmath332 ) ( server4 ) 4 ; at ( @xmath333 ) ( server5 ) 5 ; at ( @xmath334 ) ( server6 ) 6 ;    at ( @xmath335 ) ( class1 ) 1 ; at ( @xmath336 ) ( class2 ) 2 ; at ( @xmath337 ) ( class3 ) 3 ; at ( @xmath338 ) ( class4 ) 4 ; at ( @xmath339 ) ( class5 ) 5 ;    ( class1 )  ( server1 ) ; ( class1 ) ",
    "( server2 ) ; ( class2 )  ( server3 ) ; ( class2 )  ( server4 ) ; ( class3 ) ",
    "( server5 ) ; ( class3 )  ( server6 ) ; ( class4 )  ( server1 ) ; ( class4 )  ( server3 ) ; ( class4 )  ( server5 ) ; ( class5 )  ( server2 ) ; ( class5 )  ( server4 ) ; ( class5 )  ( server6 ) ;    any class of @xmath318 shares exactly one server with any class of @xmath319 , and this server is dedicated to these two classes .",
    "the rank function of this cluster is thus given by @xmath340 the polymatroid capacity set defined by this rank function is poly - symmetric with respect to partition @xmath341 and the corresponding cardinality rank function is given by @xmath342    for each @xmath343 , assume that all classes in @xmath206 have the same traffic intensity @xmath251 .",
    "further assume that the vector of traffic intensities @xmath344 stabilizes the system , that is @xmath345 we can then apply theorem [ theo : recpoly ] with partition @xmath204 to compute the mean number of job of each class with a complexity @xmath346 .",
    "we deduce the mean delay @xmath347 of class-@xmath3 jobs for each @xmath2 by little s law : @xmath348",
    "while the property of poly - symmetry is not often satisfied in practice , except in specific cases like the examples of sections 3.3 and 3.4 , it can be used to derive stochastic bounds on most systems , as shown below . the following result will allow us to control the impact of the capacity set on performance .",
    "[ theo : mono ] let @xmath349 and @xmath350 .",
    "consider two polymatroids @xmath351 and @xmath14 in @xmath81 such that @xmath351 is a subset of @xmath352 and a superset of @xmath353 .",
    "let @xmath235 be an element in the interior of @xmath353 and denote respectively by @xmath173 , @xmath354 and @xmath355 the steady state distributions of the processor - sharing networks with capacity sets @xmath351 , @xmath356 and @xmath357 under traffic intensity @xmath235 . then @xmath358 specifically , for each @xmath2 , we have @xmath359 where @xmath187 , @xmath360 and @xmath361 are the mean number of job at queue @xmath3 under distributions @xmath173 , @xmath354 and @xmath355 respectively .",
    "denote by @xmath362 and @xmath16 the rank functions of @xmath351 and @xmath14 respectively .",
    "let @xmath161 , @xmath363 and @xmath364 denote the balance functions of the resource allocations defined by balanced fairness in the capacity sets @xmath351 , @xmath356 and @xmath357 respectively .",
    "we first prove by induction on @xmath365 that @xmath366 the property holds for @xmath367 .",
    "let @xmath368 and assume the inequality is valid for any @xmath369 such that @xmath370 .",
    "then we have by : @xmath371 where the first inequality holds by the induction assumption and the second holds by the inclusion of @xmath353 into @xmath351 .",
    "we prove the other side of the inequality by using the inclusion of @xmath351 into @xmath352 .",
    "this completes the proof by induction .",
    "it follows that @xmath372 thus for each @xmath9 , we obtain @xmath373 the proof for the other part of the inequality is similar . the second inequality about the mean number of jobs follows by summation .",
    "the following sections illustrate how we can apply this result to the models of tree data networks and computer clusters .",
    "we first use this result to relax some assumptions of section [ subsec : multisource ] .",
    "we still consider @xmath203 groups @xmath374 of users which form a partition of the set @xmath17 . for each @xmath205",
    ", the access rates of the users in @xmath206 may be different but we assume that they are all between @xmath375 and @xmath376 for some @xmath377 . similarly , the capacity of the backhaul link is between @xmath378 and @xmath379 .",
    "the corresponding polymatroid capacity set @xmath351 is not poly - symmetric with respect to partition @xmath258 any more but its rank function @xmath362 satisfies : @xmath380 where @xmath16 is the rank function defined by . denoting by @xmath14 the polymatroid defined by @xmath16",
    ", it follows that @xmath351 is a superset of @xmath357 and a subset of @xmath356",
    ". we can thus apply theorem [ theo : mono ] . in the special case where for each @xmath205 , all users of @xmath206 have the same traffic intensity @xmath381 , with @xmath382",
    ", we can use theorem [ theo : recpoly ] to compute the bounds .    specifically , let @xmath354 and @xmath355 denote the steady state distributions of the processor - sharing networks with capacity sets @xmath356 and @xmath357 respectively under traffic intensity @xmath235 . for each @xmath205 and each @xmath247 , the mean throughput @xmath383 of user",
    "@xmath3 satisfies @xmath384 where @xmath385 and @xmath386 are the mean throughputs under distributions @xmath354 and @xmath355 respectively .",
    "we have @xmath387 and by @xmath388      [ [ random - assignment . ] ] random assignment .",
    "+ + + + + + + + + + + + + + + + + +    we consider a cluster with @xmath140 servers and @xmath389 job classes .",
    "let @xmath201 and consider a partition @xmath258 of @xmath17 in @xmath203 parts .",
    "we use the same notations as in section [ subsec : recpoly ] .",
    "let @xmath390 be a vector of positive integers .",
    "we randomly assign the servers to the job classes as follows .",
    "for any @xmath205 and @xmath247 , the set @xmath391 of servers that can process class-@xmath3 jobs is chosen uniformly and independently at random among the subsets of @xmath141 of cardinality @xmath392 . like in section",
    "[ subsec : modelcluster ] , the random assignment is described by the family @xmath393 which defines a random bipartite graph @xmath394 with a deterministic sets of vertices @xmath17 and @xmath143 and a random set of edges .",
    "each realization @xmath142 of the random assignment defines a polymatroid capacity set with a rank function given by .",
    "this allows us to define a random rank function associated with the random assignment by @xmath395 now let @xmath16 denote the corresponding mean rank function : @xmath396 , \\quad \\forall a \\subset i.\\ ] ] the following lemma proves that the polymatroid defined by @xmath16 is poly - symmetric with respect to @xmath204 .",
    "[ lem : meanrank ] for each @xmath103 , we have @xmath397 with @xmath398 , @xmath399 and @xmath400    let @xmath236 and consider any set @xmath103 with @xmath401 .",
    "we just need to observe that @xmath402 for each @xmath205 such that @xmath403 , the probability that a server can not serve a specific class of @xmath215 is @xmath404 .",
    "since the assignments of the classes are independent , it follows that the probability that this server can serve at least one class in @xmath109 is given by @xmath405 .",
    "let @xmath406 be a vector of traffic intensities .",
    "for any realization @xmath407 of the random assignment which defines a capacity set in the interior of which @xmath235 is , we can study the steady state behavior of the cluster when we apply balanced fairness .",
    "the system is stable and the mean number of jobs per queue is given by @xmath408 , \\quad \\forall",
    "i \\in i.\\ ] ]    [ [ asymptotic - poly - symmetry . ] ] asymptotic poly - symmetry .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + +    we consider a sequence of computer clusters with random assignment as defined in the previous section .",
    "let @xmath201 and @xmath409 .    for each @xmath349 ,",
    "the @xmath0-th random cluster of the sequence contains @xmath410 servers and @xmath389 job classes .",
    "we denote the set of servers by @xmath411 and the set of job classes by @xmath412 .",
    "the service rate of server @xmath146 is @xmath413 for each @xmath414 . for simplicity",
    ", we consider a partition @xmath415 of @xmath416 in @xmath203 parts of size @xmath0 .",
    "we can generalize the result to @xmath203 parts of different sizes as long as the size of each part is linear in @xmath0 . for each @xmath205 and @xmath417 ,",
    "the set @xmath418 of servers that can process class-@xmath3 jobs is chosen uniformly and independently at random among the subsets of @xmath419 of cardinality @xmath420 .",
    "let @xmath421 denote the random graph defined by this random assignment , @xmath422 the corresponding random rank function and @xmath423 its expectation .    by lemma [ lem : meanrank ] , for any @xmath349 and @xmath424 , we have @xmath425 = \\xi^{(n ) } m^{(n ) } p_a^{(n ) } \\quad \\text{with } \\quad p_a^{(n ) } = 1 - \\prod_{k=1}^k \\left ( 1 - \\frac{d_k^{(n)}}m \\right)^{a_k}\\ ] ] for all set @xmath426 with @xmath427 , where @xmath428 is the mean server capacity .",
    "theorem [ theo : concentration ] below shows that , under the following two assumptions on the server capacities and the degrees of parallelism , the probability that the random rank function is uniformly close to its mean is @xmath429 . the proof is given in appendix [ app : concentration ] .    [ ass : servers ] for each @xmath349",
    ", @xmath419 is partitioned into a constant number of groups .",
    "each group contains @xmath430 servers which have the same capacity .",
    "[ ass : degrees ] for each @xmath205 , the sequence @xmath431 satisfies @xmath432 .",
    "[ theo : concentration ] let @xmath350 . under assumptions",
    "[ ass : servers ] and [ ass : degrees ] , there exists a sequence @xmath433 such that @xmath434 and for any @xmath349 , @xmath435 and @xmath436    corollary [ coro : concentration ] follows from theorem [ theo : concentration ] . for any @xmath349 ,",
    "let @xmath437 denote the polymatroid defined by the rank function @xmath423 .",
    "@xmath437 is poly - symmetric with respect to the partition @xmath438 .",
    "[ coro : concentration ] let @xmath350 . under assumptions",
    "[ ass : servers ] and [ ass : degrees ] , the random capacity set resulting from the random assignment is a subset of @xmath439 and a superset of @xmath440 with probability @xmath429 .    [",
    "[ performance - metrics . ] ] performance metrics .",
    "+ + + + + + + + + + + + + + + + + + + +    for each @xmath349 , we consider a vector @xmath441 of traffic intensities per part which stabilizes the processor - sharing network with @xmath0 queues and capacity set @xmath440 under balanced fairness , that is , @xmath442 where @xmath443 is the cardinality rank function of the mean capacity set with respect to partition @xmath438 : @xmath444 let @xmath445 denote the state in the @xmath0-th randomized computer cluster when we allocate the resources according to balanced fairness . given a realization @xmath446 which is stabilized by @xmath447 , the mean numbers of jobs per class are given by @xmath448 , \\quad \\forall",
    "i \\in i^{(n)}.\\ ] ] for each realization @xmath446 which is not stabilized by @xmath447 , we let @xmath449 .",
    "this allows us to define the random variables @xmath450    associating theorem [ theo : mono ] with theorem [ theo : concentration ] yields the following result .",
    "[ theo : boundcluster ] let @xmath350 . for",
    "any @xmath349 , denote by @xmath451 and @xmath452 the stationary distributions of the processor - sharing networks with @xmath0 queues and capacity sets @xmath453 and @xmath454 respectively , when the traffic intensity of the classes in @xmath455 is @xmath456 , for any @xmath205 .",
    "let @xmath457 and @xmath458 denote the corresponding mean number of jobs per queue in part @xmath211 , for each @xmath205 .    under assumptions [ ass : servers ] and",
    "[ ass : degrees ] , we have @xmath459    for each @xmath349 , theorem [ theo : recpoly ] gives formulas to compute @xmath460 and @xmath461 for each @xmath205 with a complexity @xmath462 . using little s law , we can deduce bounds on the mean delay per class .    , @xmath463 , @xmath464 , @xmath465    we omit to write the exponents for short .",
    "consider a randomized cluster with @xmath466 servers with unit capacity .",
    "the set of classes is partitioned into two parts @xmath318 and @xmath319 with @xmath463 classes each .",
    "the classes of @xmath318 have a degree @xmath464 and the ones of @xmath319 have a degree @xmath467 .",
    "all jobs have a mean size @xmath27 and the arrival rates are proportional to the degrees .",
    "the traffic intensity of any class in @xmath319 is thus twice that of any class in @xmath318 .",
    "let @xmath468 so that @xmath469 where @xmath218 is the cardinality rank function of the mean capacity set with respect to partition @xmath341 : @xmath470 we can prove that the vector of traffic intensities @xmath471 with @xmath472 for all @xmath473 and @xmath474 for all @xmath475 is on the boundary of the mean capacity set .",
    "let @xmath350 .",
    "for each @xmath476 , @xmath477 stabilizes the processor - sharing networks with capacity sets @xmath356 and @xmath357 . the bounds on the mean delay that follow from theorem [ theo : boundcluster ] by applying little s law are given by @xmath478 where @xmath479 and @xmath480 are computed with the recursion expressions of theorem [ theo : recpoly ] as follows . for each @xmath481 , @xmath482 for any @xmath343 and @xmath236 , we have @xmath483 if @xmath256 , and otherwise @xmath484 figure [ fig : boundscluster ] gives the bounds obtained as a function of @xmath485 , for different values of @xmath486 . for practicality ,",
    "we draw the mean service rate per job , which is simply the inverse of the mean delay since all jobs have a unit mean size .",
    "in this paper , we consider processor - sharing networks and introduce a poly - symmetry criterion on the structure of the capacity set which ensures that the performance metrics can be computed with a complexity which is polynomial in the number of queues if the traffic intensities per queue are adjusted accordingly .",
    "we showed that these formulas can also be used to bound the performance of a system when its capacity set is closely poly - symmetric .",
    "we applied these results to tree data networks and computer clusters .",
    "we believe there is further scope of enhancing the stochastic bounds by expanding their scope as well as obtaining tighter bounds in some specific scaling regimes .",
    "let @xmath253 . by , we have @xmath487 the regularity assumptions ensure that @xmath488 for any @xmath103 with @xmath401 .",
    "thus we obtain @xmath489 for any @xmath205 and any @xmath247 , we do the substitution @xmath490 and thus we obtain for any @xmath205 , @xmath491 this proves .",
    "let @xmath205 and @xmath253 . by definition of @xmath249 ,",
    "we have @xmath492 = \\sum_{i \\in i_k } \\mathbb{e}\\left [ { \\bf x}_i | |i({\\bf x})|_\\sigma = a \\right].\\ ] ] it follows that @xmath493 and by , we obtain @xmath494 using the regularity assumptions , this can be rewritten as @xmath495 the first term is given by .",
    "the second term is simply @xmath496 finally , for any @xmath247 , we have @xmath497 doing the same substitution as in , we have for any @xmath244 , @xmath498 hence the third term of the sum is equal to @xmath499 where the second equality holds by . when we substitute the three terms by their expressions , we obtain .",
    "we give the proof only for the case @xmath302 for ease of notation ; the other cases follow analogously . for now , we assume that for all @xmath349 , all servers have the same capacity @xmath500 for any @xmath414 .",
    "let @xmath350 .",
    "we will show that there exists a sequence @xmath433 such that @xmath434 and for any @xmath349 , @xmath501 let us first give the main ideas of the proof . like in @xcite",
    ", it is divided in three steps .",
    "we first provide a bound for @xmath502 for each @xmath426 for @xmath0 large enough .",
    "then , for each @xmath503 , we use the union bound to obtain a uniform bound over all sets @xmath103 with @xmath427 . finally , another use of the union bound over all @xmath504 permits to conclude .",
    "let @xmath349 , @xmath504 and @xmath426 so that @xmath427 . recall that @xmath505 $ ] with @xmath506 the variables @xmath507 for @xmath414 are negatively associated bernoulli random variables with parameter @xmath508 hence",
    ", the following chernoff bounds @xcite apply : @xmath509},\\end{aligned}\\ ] ] where for any @xmath510 , @xmath511 $ ] is the kl divergence between two bernoulli random variables with parameters @xmath512 and @xmath513 respectively , given by @xmath514 = p \\log\\left ( \\frac{p}{q } \\right ) + ( 1-p ) \\log\\left ( \\frac{1-p}{1-q } \\right).\\ ] ]    we also use the following lemmas which will be proved later in appendix [ app : techlemmas ] :    [ lem : smallminor ] let @xmath515 .",
    "consider a sequence @xmath433 such that @xmath516 and @xmath517 .",
    "for large enough @xmath0 , we have @xmath518    [ lem : bigminor ] there exists a positive constant @xmath519 such that @xmath520 \\ge -\\delta + \\epsilon \\frac{a_1 d_1^{(n ) } + a_2 d_2^{(n)}}{m^{(n ) } } ,    \\quad \\forall n \\ge 1 ,    \\quad \\forall a \\in { \\cal n}^{(n)}.\\ ] ]    consider the sequence @xmath433 given by @xmath521 observe that @xmath434 , @xmath516 and @xmath517 .",
    "now let @xmath349 and @xmath504 .",
    "we distinguish two cases depending on the value of @xmath522 .",
    "by lemma [ lem : smallminor ] , there is a positive constant @xmath525 such that , for large enough @xmath0 , @xmath526 using ( [ eq : smallchernoff ] ) , we deduce that @xmath527 for any @xmath426 such that @xmath427 .",
    "the union bound yields @xmath528 since @xmath434 , we obtain for large enough @xmath0 @xmath529 with @xmath530 .",
    "combining lemma [ lem : bigminor ] with ( [ eq : bigchernoff ] ) , we deduce that there is a positive constant @xmath533 such that @xmath534 for any @xmath426 such that @xmath427 .",
    "since @xmath535 and @xmath516 , we have @xmath536 when @xmath0 is large enough .",
    "if @xmath531 , we also have that @xmath537 so that @xmath538 for large enough @xmath0 .",
    "the same argument holds by inverting @xmath539 and @xmath540 when @xmath532 , so we conclude that there is a positive constant @xmath541 such that for large enough @xmath0 , we have @xmath542 for any @xmath426 such that @xmath427 .",
    "the union bound yields @xmath543 since @xmath544 and @xmath545 , for large enough @xmath0 , we have @xmath546 for some positive constant @xmath547 .      combining cases [ subapp : case1 ] and [ subapp : case2 ] , we deduce that there exists a positive constant @xmath548 such that @xmath549 when @xmath0 is large enough . using",
    "the union bound again , we obtain @xmath550 since @xmath434 , we conclude that for a constant @xmath551 , we have for large enough @xmath0 @xmath552    finally , when servers are in groups as in assumption [ ass : servers ] , we can break down @xmath422 into a sum of random rank functions , one for each groups .",
    "the result follows by showing the concentration in each group as above , and then using the union bound again .",
    "let @xmath515 . consider a sequence @xmath433 such that @xmath516 and @xmath517 . for large enough @xmath0 , we have @xmath518    consider the sequence @xmath553 of functions defined on @xmath151 by @xmath554 we have @xmath555 ^ 2 \\xrightarrow[n \\to \\infty ] { } 1      \\quad \\text{and } \\quad      f_n\\left ( 0 , \\frac{2n}{g_n } \\right ) = 1 - \\left [ \\left ( 1 - \\frac{d_2^{(n)}}{bn } \\right)^\\frac{n}{g_n } \\right]^2 \\xrightarrow[n \\to \\infty ] { } 1 .",
    "\\end{aligned}\\ ] ] thus , there is @xmath556 so that @xmath557 and @xmath558 for all @xmath559",
    ". then , for any @xmath559 and any @xmath560 , we have @xmath561 where the first two inequalities hold by concavity of @xmath562 .      by definition of @xmath563 , @xmath564      { } = { } & ( 1 - \\epsilon ) p_a^{(n ) } \\log(1 - \\epsilon )      + \\left ( 1 - ( 1 - \\epsilon ) p_a^{(n ) } \\right ) \\log\\left ( 1 - ( 1 - \\epsilon ) p_a^{(n ) } \\right ) \\\\      & { } - { } \\left ( 1 - ( 1 - \\epsilon ) p_a^{(n ) } \\right ) \\log\\left ( 1 - p_a^{(n ) } \\right ) .    \\end{aligned}\\ ] ] the first and the second terms are greater than @xmath565 and @xmath566 respectively . with @xmath567",
    ", we obtain @xmath564      \\ge - \\delta - \\left ( 1 - ( 1 - \\epsilon ) p_a^{(n ) } \\right ) \\log\\left ( 1 - p_a^{(n ) } \\right )      \\ge - \\delta - \\epsilon \\log\\left ( 1 - p_a^{(n ) } \\right ) .",
    "\\end{aligned}\\ ] ] finally , observe that @xmath568 where in the inequality we used the fact that @xmath569 for @xmath343 .",
    "hence , we obtain the expected result .                  t.  bonald and a.  proutire . a queueing analysis of data networks . in j.",
    "r. boucherie and m.  n. van dijk , editors , _ queueing networks : a fundamental approach _ , pages 729765 .",
    "springer us , boston , ma , 2011 .",
    "t.  bonald , a.  proutire , j.  roberts , and j.  virtamo .",
    "computational aspects of balanced fairness . in r.",
    "l. j.  charzinski and p.  tran - gia , editors , _ providing quality of service in heterogeneous environmentsproceedings of the 18th international teletraffic congress - itc-18 _ , volume  5 of _ teletraffic science and engineering _ , pages 801  810 .",
    "elsevier , 2003 .                v.",
    "joseph and g.  de  veciana .",
    "stochastic networks with multipath flow control : impact of resource pools on flow - level performance and network congestion . in _ proceedings of the acm sigmetrics _ , pages 6172 , 2011"
  ],
  "abstract_text": [
    "<S> we consider a network of processor - sharing queues with state - dependent service rates . these are allocated according to balanced fairness within a polymatroid capacity set . </S>",
    "<S> balanced fairness is known to be both insensitive and pareto - efficient in such networks , which ensures that the performance metrics , when computable , will provide robust insights into the real performance of the system considered . </S>",
    "<S> we first show that these performance metrics can be evaluated with a complexity that is polynomial in the system size when we allow for some controlled asymmetry , in the sense that the network contains a fixed number of parts wherein all queues are ` exchangeable ' . </S>",
    "<S> this in turn allows us to derive stochastic bounds for a larger class of networks which satisfy less restrictive symmetry assumptions . </S>",
    "<S> these results are applied to practical examples of tree data networks and computer clusters . + * keyworkds : * processor - sharing networks , performance , balanced fairness , poly - symmetry </S>"
  ]
}