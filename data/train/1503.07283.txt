{
  "article_text": [
    "morphological analysis is an analysis of internal structure of words . for languages with rich morphology like russian or ukrainian using the morphological analysis it is possible to figure out if a word can be a noun or a verb , or if it can be singular or plural .",
    "morphological analysis is in an important step of natural language processing pipelines for such languages .",
    "morphological generation is a process of building a word given its grammatical representation ; this includes lemmatization , inflection and finding word lexemes .",
    "pymorphy2 is a morphological analyzer and generator for russian and ukrainian language widely used in industry and in academia .",
    "it is being developed since 2012 ; ukrainian support is a recent addition .",
    "the development of its predecessor , pymorphy started in 2009 .",
    "the package is available under a permissive license ( mit ) , and it uses open source permissively licensed dictionary data .    the rest of this paper is organized as follows . in section 2 pymorphy2 software architecture and design principles are described .",
    "section 3 explains how pymorphy2 uses lexicons and how analysis and morphological generation work for vocabulary words . in section 4 methods used for out - of - vocabulary words are explained and compared with approaches used by other morphological analyzers .",
    "section 5 is dedicated to a problem of selecting correct analysis from all possible analyses , and a role of morphological analyzer in this task . in section 6",
    "evaluation results are presented .",
    "section 7 outlines a roadmap for future pymorphy2 improvements .",
    "pymorphy2 is implemented as a cross - platform python library , with a command - line utility and optional c++ extensions for faster analysis . both python 2.x and python 3.x are supported .",
    "an extensive testing suite ( 600 + unit tests ) ensures the code quality ; test coverage is kept above 90% .",
    "there is online documentation available .",
    "when optional c++ extension is used ( or when pymorphy2 is executed using pypy python interpreter ) the parsing speed is usually in tens of thousands of words per second ; in some specific cases in can exceed 100000 words per second in a single thread . without the extension parsing speed",
    "is in thousands of words per second .",
    "the memory consumption is about 15 mb , or about 30 mb if we account for python interpreter itself .",
    "users are provided with a simple api for working with words , their analyses and grammatical tags .",
    "there are methods to analyze words , inflect and lemmatize them , build word lexemes , make words agree with a number , methods for working with tags , grammemes and dictionaries",
    ". inherent complexity of working with natural languages is not hidden from the user .",
    "for example , to lemmatize the word correctly it is necessary to choose the correct analysis from a list of possible analyses ; pymorphy2 provides @xmath0 estimates and sorts the results accordingly , but requires user to choose the analysis explicitly before normalizing the word .",
    "analysis of vocabulary words and out - of - vocabulary words is unified .",
    "there is a configurable pipeline of `` analyzer units '' ; it contains a unit for vocabulary words analysis and units ( rules ) for out - of - vocabulary words handling .",
    "individual units can be customized or turned off ; some rules are parametrized with language - specific data .",
    "users can create their own analyzer units ( rules ) .",
    "this all makes it possible to perform morphological analysis experiments without changing pymorphy2 source code , develop domain - specific morphology analysis pipelines and adapt pymorphy2 to work with languages other than russian .",
    "the latter point is validated by introducing an experimental support for ukrainian language .",
    "pymorphy2 relies on large lexicons for analysis of common words . for russian it uses opencorpora @xcite dictionary ( @xmath1 word forms , @xmath2 lemmas ) converted from opencorpora xml format to a compact representation optimized for morphological analysis and generation tasks .",
    "end users do nt have to compile the dictionaries themselves ; pymorphy2 ships with prebuilt periodically updated dictionaries .",
    "any dictionary in opencorpora xml format can be used by pymorphy2 . for ukrainian",
    "there is such experimental dictionary ( @xmath3 word forms ) being developed by andriy rysin , dmitry chaplinsky , mariana romanyshyn and other contributors ; it is based on languagetool data .",
    "source dictionary contains word forms with their tags , grouped by lexemes .",
    "for example , a lexeme for lemma ``  '' ( a hedgehog ) looks like this :    ....        noun , anim , masc sing , nomn       noun , anim , masc sing , gent       noun , anim , masc sing , datv ...     noun , anim , masc plur , ablt      noun , anim , masc plur , loct ....    in source dictionaries there could also be links between lexemes .",
    "for example , lexemes for infinitive , verb , gerund and participle forms of the same lemma may be connected .",
    "currently pymorphy2 joins connected lexemes into a single lexeme for most link types .      given a dictionary , to analyze a word means to find all possible grammatical tags for a word .",
    "obtaining of a normal form ( lemmatization ) is finding the first word form in the lexeme . to inflect a word",
    "is to find another word form in the same lexeme with the requested grammemes .",
    "as can be seen , all these tasks are simple . with an xml dictionary analysis of known words",
    "can be performed just by running queries on xml file .",
    "the problem is that querying xml is o(n ) with large constant factors , raw data takes quite a lot of memory , and the source dictionary is not well suited for morphological analysis and generation of out - of - vocabulary words .    to create a compact representation and enable fast access pymorphy2 encodes lexeme information : all words are stored in a dafsa @xcite using the dawgdic c++ library @xcite via python wrapper ; information about word tags and lexemes is encoded as numbers .",
    "storage scheme is close to the scheme described in aot.ru @xcite , but it is not quite the same",
    ".      paradigm in pymorphy2 is an inflection pattern of a lexeme .",
    "it consists of @xmath4 triples , one for each word form in a lexeme , such as that each word form @xmath5 can be represented as @xmath6 where @xmath7 is the same for all words in a lexeme .",
    "this representation allows us to factorize a lexeme into a stem and a paradigm .",
    "paradigm prefixes , suffixes and tags are encoded as numbers by pymorphy2 ; lexeme stems are discarded .",
    "it means that a paradigm is stored as an array of numbers ( prefixes , suffixes and tags ids ) , and lexemes are not stored explicitly - they are reconstructed on demand from word and paradigm information .",
    "there are no paradigms provided in the source dictionary ; pymorphy2 infers them from the lexemes .",
    "for russian there are about 3200 paradigms inferred from 390000 lexemes .",
    "word forms with their analysis information are stored in a dafsa .",
    "other storage schemes were tried , including two tries scheme similar to described in @xcite ( but using double - array tries ) , and succinct ( marisa ) tries . for pymorphy2 data dafsa provided the most compact representation , and at the same time it was the fastest and had the most flexible iteration support .        for each word form pymorphy2 stores ( word , paradigmid , formindex )",
    "triples :    * word form , as text ; * i d of its paradigm ; * word form index in the lexeme .",
    "dafsa does nt support attaching values to leaves ; the information is encoded like the following : @xmath8 ( see an example on fig .",
    "[ fig : dafsa ] ) .",
    "it is an implementation detail . ] .",
    "the storage is especially efficient because words with similar endings often have the same analyses , i.e. the same @xmath9 pairs ; this allows dafsa to use fewer nodes / transitions to represent the data .",
    "dafsa for russian opencorpora dictionary ( @xmath10 analyses , about @xmath11 unique word forms ) enables fast lookups ( hundreds thousand lookups / sec from python ) and takes less than 7 mb of ram ; source xml file is about 400 mb on disk .    to get all analyses of a @xmath12 ,",
    "dafsa transitions for @xmath12 are followed , then a separator @xmath13 is followed , and then the remaining subtree is traversed to get all possible @xmath9 pairs .    given @xmath9 pair one can find the grammatical tag of a word : find a paradigm in paradigms array by @xmath14 , get @xmath15 triple from a paradigm by using @xmath16 .",
    "given @xmath9 pair and the @xmath12 itself it is possible to restore the lexeme and lemmatize or inflect the @xmath12 - from @xmath12 , @xmath17 and @xmath18 we can get the stem , and given a stem and @xmath19 it is possible to restore a full word for k - th word form .      the usage of ``  '' letter is optional in russian ; in real texts it is often replaced with ``  '' letter .",
    "there rules for ``  '' / ``  '' substitutions are different in ukrainian , but in practice there are real - world texts with ``  '' letters replaced with ``  '' .",
    "the simplest way to handle it is to replace ``  '' / ``  '' with ``  '' / ``  '' both in the input text and in the dictionary .",
    "however , this is suboptimal because it discards useful information , makes the text less correct ( in ukrainian ``  '' instead of ``  '' can be seen as a spelling error ) and increases the ambiguity : there are words which analysis should depend on / and /. for example , the word ``  '' should be parsed as plural , but the word ``  '' should nt .",
    "pymorphy2 assumes that ``  '' / ``  '' usage in dictionary is mandatory , but in the input text it is optional .",
    "for example , if a russian input word contains ``  '' letter then only analyses with this letter are returned ; if there are ``  '' letters in the input word then possible analyses both for ``  '' and ``  '' are returned .",
    "an easy way to implement this would be to check each combination of / and / replacement for the input word .",
    "it is not how pymorphy2 works .",
    "to do the task efficiently , pymorphy2 exploits dafsa @xcite dictionary structure : the result is built by traversing the word character graph and trying to follow ``  '' transitions in addition to ``  '' transitions ( for russian ) and ``  '' transitions in addition to ``  '' transitions ( for ukrainian ) .",
    "it is not practical to try incorporate all the words in a lexicon - there is a long tail of rarely used words , new words appear ; there is morphological derivation , loanwords , it is challenging to add all names , locations and special terms to the dictionary .",
    "empirically , zipf s law seems to hold for natural languages @xcite ; one of the consequences is that even doubling the size of a lexicon could increase the coverage only slightly @xcite .    for languages without rich morphology it may be practical to assume that if word is not in a dictionary then it can be of any class from the open word classes , and then disambiguate the results on later processing stages , using e.g. a contextual pos tagger or a syntactic parser . for slavic languages doing this on later stages",
    "is challenging because of large tagsets - for example , opencorpora @xcite words have more than 4500 different tags .",
    "morphological analyzer solves it by limiting the number of possible analyses based on word shape .",
    "pymorphy2 uses a set of rules ( analyzer units ) to handle unknown words .",
    "some of the rules are described in literature @xcite ; the resulting combination is novel .",
    "the order of in which the rules are applied is language - specific .",
    "there is a set of immutable prefixes which can be attached to words of open classes ( nouns , verbs , adjectives , adverbs , participles , gerunds ) without affecting the word grammatical properties .",
    "examples of such prefixes for russian : ``  '' , ``  '' , ``  '' ; pymorphy2 provides language - specific lists of these prefixes .",
    "when a words starts with one of these prefixes , pymorphy2 removes the prefix , parses the reminder and re - attaches the prefix .",
    "a similar rule is described in @xcite .",
    "note that full analysis is performed on the reminder , so the reminder can be an out - of - vocabulary word itself .",
    "to speedup prefix matching built - in lists of prefixes are encoded to dafsas .",
    "when all the following apply pymorphy2 assumes the whole word can be parsed the same way as the `` suffix '' word :    * a word being analyzed has another word from a dictionary as a suffix ; * the length of this `` suffix '' word is greater than 3 ; * the length of the word without the `` suffix '' is no greater than 5 ; * `` suffix '' word is of an open class ( noun , verb , adjective , participle , gerund )    to search for suffixes pymorphy2 tries to consider 1st letter as a prefix , then two first letters as a prefix , etc . , and lookups the reminder in a dictionary .",
    "this rule is the same as described in @xcite .",
    "a similar rule is described in @xcite , though its induction for concrete prefixes is different .      in many languages , including russian and ukrainian , words with common endings often have the same grammatical form .    to exploit this , pymorphy2 first collects the information from the dictionary : for each word all endings of length 1 to 5 are extracted , and all possible analyses for these endings are stored",
    ". then this @xmath20 mapping is cleaned up :    * only the most frequent analyses for each pos tag are kept ; * analyses from non - productive paradigms ( currently these are paradigms which produced less than 3 lexemes in a dictionary ) are discarded ; * rare endings ( currently the ones which occur once ) are also discarded .",
    "the resulting mapping is encoded to dafsa for fast lookups .",
    "storage scheme is the following : @xmath21 , where @xmath22 consists of three 2-byte numbers : @xmath23 - analysis frequency ( a number of times a word with this ending had this analysis ) , i d of analysis paradigm and the form index inside the paradigm .    at prediction time",
    "pymorphy2 checks word endings from length 5 to 1 , stopping at the first ending with some analyses found . to get possible analyses for a given ending",
    "pymorphy2 first follows all dafsa transitions for the ending , then follows a separator , and then traverses the remaining subtree to get possible @xmath22 triples .",
    "the result is then sorted by analyses frequencies .",
    "recall that a @xmath12 and a @xmath9 pair is all what is needed to restore the lexeme and inflect the @xmath12 .",
    "lexemes are created on fly , so it does nt matter @xmath12 is not from the vocabulary as soon as we have @xmath9 pair .",
    "it means morphological generation ( lemmatization , inflection ) works here .    only analyses with open - class parts of speech ( noun , verb , adjective , participle , gerund ) are produced",
    "special care is taken to handle ``  '' letter properly .",
    "also , special care is required to handle paradigm prefixes properly - in fact , there are several @xmath20 dafsas built , one per each paradigm prefix .",
    "this rule is based on @xcite ; similar approaches are also used in @xcite and @xcite .",
    "@xcite uses similar rules , but derives them differently .      unlike some other morphological analyzers",
    ", pymorphy2 opts to handle words with a hyphen .",
    "in @xcite it is argued that in most cases the parts of compound words should be handled as separate words if they are joined using a hyphen .",
    "a similar decision is made in opencorpora tokenization module @xcite ; it considers words like `` - '' as three tokens which should be analyzed separately and joined back at later processing stages . in both cases",
    "the decisions are not motivated by linguistic considerations ; it is the technical difficulty which prevents analyzing and processing such words as single entities .",
    "currently pymorphy2 handles adverbs with a hyphen , particles separated by a hyphen and compound words with left and right parts separated by a hyphen .",
    "russian words are parsed as adverbs if they    * start with a `` - '' prefix ; * have total length greater than 5 ; * can be parsed as a full singular adjective in dative case when `` - '' is removed    examples : `` - '' , `` - '' .      though it is not clear if words with a particle separated by a hyphen ( e.g. `` - '' or `` - '' ) should be handled as a single word or as two words , pymorphy2 supports parsing of such words",
    "there are language - specific lists of common particles which can be attached , and if a word ends with one of these particles then it is parsed without the particle , and then the particle is re - attached to the result .      the main challenge in analysis of the compound words which parts are separated by a hyphen ( like `` - '' and `` - '' ) is to figure out if the left part should be inflected together with the right part , or if it is a fixed prefix .    to do this , pymorphy2 parses left and right parts separately ( they do nt have to be dictionary words ) .",
    "then it tries to find matching analyses .",
    "if there is a `` left '' analysis compatible with one of the `` right '' analyses then the resulting analysis is built where both word parts are inflected .",
    "after that , an analysis with a fixed left part is added to the result , regardless of whether a compatible `` left '' analysis was found or not .",
    "a similar method was used in @xcite",
    ".    only words with a single hyphen are handled using heuristics described above .",
    "words with multiple hyphens are likely represent different phenomena in russian and ukrainian languages ; they could be interjections or phrases @xcite .",
    "initial is an abbreviation of person s first or patronymic name . in most cases",
    "an initial is a single upper - cased character ( language - specific ) .",
    "pymorphy2 parses such characters as fixed singular nouns , with variants for all possible gender and case combinations . for person",
    "first names ( @xmath24 ) two different lexemes are built for male and female names . for patronymic names ( @xmath25 ) a single lexeme is returned .",
    "unlike all other analyzer rules , detection of initials is case - sensitive .",
    "it is a way to decrease ambiguity .",
    "the following tags are assigned to non - lexical tokens : @xmath26 for punctuation , @xmath27 for tokens written in latin alphabet , @xmath28 for integer numbers , @xmath29 for floating - point numbers , @xmath30 for roman numbers .",
    "when analyzing the text , it is common to classify tokens during the tokenization step .",
    "the reason pymorphy2 handles non - lexical tokens during the morphological analysis step is that this allows users to use a simpler tokenizer when classifying tokenizer is not available ; also , it means that information about all tokens is available in a common format .",
    "inflection is fully supported for out of vocabulary words .",
    "to achieve this pymorphy2 keeps track of the analyzer units ( rules and their parameters ) used to parse the word , requires each analyzer unit to provide a method for getting a lexeme , and calls this method for the last analyzer unit . to compute",
    "the lexeme analyzer unit can look at the analysis result , and it can ask previous analyzer units for the lexeme .    for example , common prefixes removal analyzer removes the prefix from a word , then gets a lexeme from the previous analyzer , and then attaches the prefix to each word form in a lexeme to build a resulting lexeme .",
    "morphological analyzer may return multiple possible word parses .",
    "the problem of choosing the right analysis from a list of possible options is called disambiguation . generally , to select the correct analysis it is required to take word context in account .",
    "morphological analyzer takes individual words as an input , so it ca nt disambiguate the result robustly .",
    "however , it can provide an estimation for @xmath31 conditional probability .",
    "such probability estimations can be used in absence of a dedicated disambiguator to select the more probable analysis .",
    "in addition to that , these probabilities can be used on later stages of text analysis , for example by a disambiguator .    to estimate @xmath31 conditional probability for russian words",
    "pymorphy2 uses partially disambiguated opencorpora corpus @xcite and assumes that @xmath32 .",
    "the conditional probability is estimated for words which have multiple analysis according to pymorphy2 , but have occurrences with a single remaining analysis in the opencorpora corpus ; the estimation is a maximum - likelihood estimation with laplace ( add - one ) smoothing .",
    "@xmath33 @xmath34 @xmath35    @xmath36 @xmath37 @xmath38    counts are computed based on opencorpora corpus data ; all words with a single remaining analysis are taken in account .",
    "once estimated , the result is stored on disk as a dafsa ; keys are @xmath39    for words without @xmath40 estimates the probabilities are assigned uniformly during the parsing .    for ukrainian language probabilities are assigned uniformly because at the moment of writing there is no a freely available ukrainian corpus similar to opencorpora .",
    "evaluating analysis quality of different morphological analyzers for russian is not straightforward because most analyzers ( as well as annotated corpora ) use their own incompatible tagsets . and",
    "when a corpus and a dictionary have a compatible tagset it usually means that the dictionary was enhanced from the corpus , and it is a problem because quality numbers obtained on a corpus the dictionary was enhanced from should nt be relied on - they are too optimistic .",
    "pymorphy2 analysis quality was compared to an analysis quality of a well - known morphological analyzer , mystem 3.0 @xcite .",
    "testing corpus consists of 100 randomly selected sentences ( 1405 tokens ) from opencorpora ( microcorpus ) and 100 randomly selected sentences ( 1093 tokens ) from ruscorpora.ru - 2498 manually disambiguated tokens in total .",
    "full details for this evaluation can be found online .",
    "opencorpora ( pymorphy2 ) tagset is not the same as ruscorpora.ru tagset , and ruscorpora.ru tagset differs from mystem tagset . for evaluation purposes",
    "all tags were converted to mystem format using a set of automatic rules .",
    "quality was evaluated on full morphological tags , i.e. tags must match exactly to be considered correct , with a few exceptions related to tags conversion problems .",
    "all reported errors were checked manually to filter out false positives .",
    "[ tab : representation ]    .errors [ cols=\">,<,<\",options=\"header \" , ]     both pymorphy2 and mystem made less than 1% errors ( without disambiguation , i.e. in less than 1% cases the correct analysis was not in a set of analyses returned by an analyzer ) .",
    "it should be noted that 9 out of 19 pymorphy2 errors and 14 out of 23 mystem errors were related to abbreviation handling .",
    "mystem handled first and last names better ( 1 mistake versus 4 for pymorphy2 ) ; pymorphy2 made less mistakes for `` regular '' words ( 4 versus 6 for mystem ) .",
    "mystem ca nt parse many hyphenated words as a single token ; such words were not considered .",
    "punctuation , numbers and non - russian words were also removed from the input .",
    "it is hard to draw a quantitative conclusion because the corpus size is small .",
    "both analyzers has a similar analysis quality , and the resulting numbers depend on evaluation minutiae : whether abbreviations are considered or not , should we require hyphenated words to be parsed , do we require verb transitivity to be predicted correctly , is it important to distinguish adverbs from parenthesis , etc .",
    "several human annotation errors were found by parsing opencorpora data with mystem ( 1 error ) and ruscorpora data with pymorphy2 ( 6 errors ) .",
    "opencorpora shares a dictionary with pymorphy2 , and ruscorpora annotation is related to mystem ; this shows an utility of using cross - corpora tools to check the annotations .",
    "the most sophisticated russian morphological parser evaluation so far is @xcite ; it happened in 2010 .",
    "previous version of pymorphy2 ( pymorphy ) participated in tracks without disambiguation ; it finished 1st on full morphology analysis , 3rd on lemmatization , 3rd on pos tagging and 5th on the rare words track .",
    "pymorphy havent participated in disambiguation tracks .",
    "pymorphy used some pymorphy2 rules ( not all ) and a different dictionary ( extracted from @xcite instead of @xcite ) .",
    "generally , pymorphy2 should work better than pymorphy because of an improved dictionary and rules , but this has not been not measured quantitatively yet .",
    "permissive open - source license ( mit ) is used for pymorphy2 . all the dictionaries and",
    "corpora pymorphy2 depends on are also available under permissive open - source licenses .",
    "this encourages usage and contributions .",
    "there are volunteers working on russian and ukrainian dictionaries and corpora , related tools and pymorphy2 itself .",
    "development of pymorphy2 is by no means finished .",
    "there are word classes for which pymorphy2 analysis can be improved . some of them : people last and patronymic names , foreign people names , diminutive first names , locations , uppercase and other abbreviations , some classes of hyphenated words , ordinal numbers ( including ordinal numbers written in digit notation like `` 22- '' ) . according to @xcite ,",
    "similar issues are common for russian morphological analyzers .",
    "the support for ukrainian is experimental .",
    "the dictionary requires work , pymorphy2 needs more ukrainian - specific rules for handling of out of vocabulary words , and for better @xmath41 estimates an annotated ukrainian corpus is needed : even a small corpus ( or even a manually crafted frequency list ) should fix a substantial amount of `` obvious '' errors .",
    "nlp evaluation : russian morphological parsers . in : kibrik a. ( ed . ) .",
    "computational linguistics and intellectual technologies . papers from the annual international conference `` dialogue '' .",
    "( 2010 )    probabilistic tokenization model in the opencorpora project [ veroyatnastnaya model tokenizacii v proekte otkritiy korpus ] . in : new information technology in automated systems : proceedings of the 15th seminar [ noviye informacionnie tehnologii v avtomatizirovannih sistemah : materiali pyatnadcatogo nauchno - prakticheskogo seminara ] . m. , 2012 .",
    "an automatic morphological classifier of noun phrases in russian . in : kibrik a. ( ed . ) computational linguistics and intellectual technologies .",
    "papers from the annual international conference `` dialogue '' volume 1 .",
    "( 2012 ) .",
    "current morphological analysis and synthesis challanges in the starling system [ aktualniye zadachi morfologicheskogo analiza i sinteza v integrirovannoy informacionnoy srede starling ] . in : proceedings of the international conference `` dialog 2003 '' ( 2003 )        morphological modules on the web - site www.aot.ru [ morphologicheskie moduli na saite www.aot.ru ] .",
    "computational linguistics and intelligent technologies : proceedings of the international conference `` dialog 2004 '' ( 2004 ) .",
    "improvised - temporary - compounds as a new expressive mean in russian . in : kibrik a. ( ed . ) computational linguistics and intellectual technologies .",
    "papers from the annual international conference `` dialogue '' volume 1 ."
  ],
  "abstract_text": [
    "<S> pymorphy2 is a morphological analyzer and generator for russian and ukrainian languages . </S>",
    "<S> it uses large efficiently encoded lexicons built from opencorpora and languagetool data . </S>",
    "<S> a set of linguistically motivated rules is developed to enable morphological analysis and generation of out - of - vocabulary words observed in real - world documents . </S>",
    "<S> for russian pymorphy2 provides state - of - the - arts morphological analysis quality . </S>",
    "<S> the analyzer is implemented in python programming language with optional c++ extensions . </S>",
    "<S> emphasis is put on ease of use , documentation and extensibility . </S>",
    "<S> the package is distributed under a permissive open - source license , encouraging its use in both academic and commercial setting . </S>"
  ]
}