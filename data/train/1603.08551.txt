{
  "article_text": [
    "the most obvious way to generate a three - dimensional mesh in a mutateable way would be to simply take a representation of the shape , and directly mutate it .",
    "if the shape was the level set of a sum of spherical harmonics , then you could just mutate the proportions of each spherical harmonic , and the shape would change correspondingly . in a shape represented by a mesh , the mesh vertices could be mutated directly .",
    "in biology , the way that morphologies can be mutated seems richer than in either of these examples .",
    "for instance , in both of the examples above , a child organism would be unlikely to be just a scaled version of its parent , because too many mutations would have to coincide .",
    "it would be unlikely to find left - right symmetry evolving in either of the above methods unless the morphology was explicitly constrained . in nature",
    ", the link between morphology and the organism s genome is much more complicated than for the examples above .",
    "modeling the chemical processes behind the development of an organism is an active field , which is described in detail in _ _ on growth , form and computers__@xcite .",
    "a widely used model that describes organism development has been presented by kumar and bentley  @xcite .    in this work , the same philosophy is adopted , that an emergent system needs to be parameterised by a genome , and the morphology needs to be a result of the system s dynamics . however , the emergent system used here is a network of identical neural networks , or cellular neural network .",
    "these were described by chua and yang  @xcite and a well - known review of work on cellular neural networks was written by cimagalli and balsi  @xcite .",
    "a paper by wilfried elmenreich and istvn fehrvri  @xcite uses a cellular neural network to reconstruct images , and the architecture of their cellular neural network appears similar to the method in this paper . here",
    ", though , the output of the network is information that is used to grow a mesh , and the top - level topology of the cellular neural network here has to be flexible enough to allow for differing numbers of neighbours for each cell .",
    "cellular neural networks are capable of simulating a large variety of systems , and have been demonstrated to be able to model conway s game of life @xcite , which is known to be turing complete , and so it is at least plausible that they could generate complicated structured patterns that resemble biological morphologies .",
    "the calculation presented here takes place on a network of vertices .",
    "there are a certain number of discrete timesteps .",
    "each vertex , @xmath0 , at each time , @xmath1 , has a real - valued output vector , @xmath2 .",
    "each vertex has a number of neighboring vertices .",
    "each vertex , at each timestep has an input vector , @xmath3 , such that @xmath3 is a function of neighboring vertices outputs in the previous timestep :    @xmath4    where @xmath5,@xmath6,@xmath7 is the set of neighbours of vertex @xmath0 .",
    "the function that maps from neighboring outputs to inputs , @xmath8 , is given the superscript , @xmath0 , to denote that it can vary from vertex to vertex .",
    "this is simply to allow for slightly different processing when the vertex might have different numbers of neighbours or have a slightly different geometry .",
    "the mapping from input , @xmath3 , to output , @xmath2 is calculated using a feed - forward neural network with a sigmoid activation function .",
    "the neural network is described in c - like pseudocode :    .... double [ ] evaluate(double [ ] input ) {      for ( int j = 0 ; j < input.length ; j++ ) neuron[0][j].value = input[j ] ;      for ( int i = 1 ; i < nlayers ; i++ ) //",
    "the zero - th layer is skipped .",
    "{          for ( int j = 0 ; j < number of neurons in layer i ; j++ )          {              double a = -neuron[i][j].threshold ;              for ( int k = 0 ; k < number of neurons in layer ( i-1 ) ; k++ )                  a + = ( neuron[i - 1][k].value - 0.5 ) * neuron[i][j].weights[k ] ;              neuron[i][j].value = 1.0 / ( 1.0 + exp(-a ) ) ;          }      }      for ( int j = 0 ; j < number of neurons in final layer ; j++ )           output[j ] = neuron[last][j].value ;      return output ; } ....    the neural network is parameterised by each neuron s weights vector and threshold .",
    "these form the mesh s genetic code - any mutation or crossover or other operation on the mesh s genetic code simply varies these weights and thresholds .",
    "the vertex network here is a three dimensional mesh - consisting of vertices with a three dimensional position , and faces with three vertices .",
    "each vertex s neighbours are any vertex with which it shares a face .",
    "the input function , @xmath9 , that gives each vertex s input vector as a function of its neighbours output vectors , does the following :    * if the output vector is length @xmath10 , then the input vector is length @xmath11 : each output number becomes three input numbers regardless of the mesh topology .",
    "* the first input number to this vertex is its own output from the previous timestep . *",
    "the second input number is the average output from all its neighbours from the previous timestep . *",
    "the third input number is a measure of the dispersion of its neighbours . *",
    "some inputs are reserved for things like the orientation of the vertex or its adjacent faces .    in this way , each vertex can communicate with its neighbours , but in a symmetry preserving way .",
    "the architecture of this network and how it relates to the neural networks on each vertex is shown in figure  [ archnet ]          the timestep has one final component : the mesh updates according to the vertex output vector .",
    "each vertex has a normalised three - dimensional vector , @xmath12 , describing the direction that it s position , @xmath13 can grow .",
    "it then grows according to the following :    @xmath14    where @xmath15 is a normalization factor so that the mesh as a whole can only grow so fast , and @xmath16 is the zero - th element of the output of vertex @xmath0 at this time .",
    "the mesh then checks to see if any face has an area that is above a threshold ( which in some cases can be altered by a different one of the output elements of its vertices ) , and if so , places a new vertex in the middle of the face , and replaces itself with three new faces that integrate the new central vertex . the growing direction , @xmath17 , for the new vertex depends on both the normal of the original face , and a weighted sum of the growing directions of the three parent vertices , the weighting being determined by a vertex output element .",
    "finally , if any faces share two vertices , adjacent faces are checked to see if it they would be improved by switching the common edge : faces @xmath18 and @xmath19 might be rearranged as @xmath20 , @xmath21 , depending on their relative orientation , the length @xmath22 compared to @xmath23 , and whether vertices @xmath24 or @xmath25 have already got too few adjacent faces ( since this operation would reduce that number ) .",
    "start with a simple three - dimensional mesh with vertices and triangular faces .",
    "assign each vertex an output vector of length @xmath10 , and a growing direction , @xmath17 .    for each timestep ,",
    "* calculate a length @xmath11 input vector for each vertex based on the outputs of its neighbours .",
    "* calculate each vertex s output vector using a neural network  each vertex has an identical neural network to the others .",
    "* update the mesh according to the vertex output : move the vertices , check to see if any new vertices should be added , and adjust the mesh accordingly , and consider switching a few edges .    in the examples shown below , there are fifteen outputs , forty - five inputs and thirty neurons in the hidden layer . of the forty - five inputs ,",
    "four are overridden with the vertex growth direction ( three inputs ) , the height of the vertex ( one input ) .",
    "three outputs are used to guide mesh growth : one moves the vertex along its growth direction , one influences the area required for a face split , and the last influences the growth direction of any vertices that are placed as a result of a face splitting that this vertex is part of .",
    "it is outside the scope of this document to discuss how to implement a genetic algorithm , but the basic idea is that you have a population of genomes , each specifying the free parameters of a neural network that generates the 3d mesh .",
    "the population gradually replaces worse genomes with better ones , and generates new genomes from old ones , allowing for mutation and optionally crossover .",
    "if the genomes are chosen completely randomly , with each weight or threshold chosen to be evenly distributed between -2 and + 2 , and run the algorithm for 200 timesteps , then the shapes generated look like those shown in figure  [ unselected ] .",
    "note that even without selection , the shapes are quite diverse and already slightly interesting .",
    "not many genomes have simply failed to produce any mesh other than the initial .",
    "an example is given here to demonstrate that this is suitable for use in genetic algorithms , where meshes are chosen to maximise the heuristic    @xmath26    where @xmath27 is the maximum z - height of the mesh at that x , y position .",
    "this has been chosen to roughly mimic the selection pressure on trees  the larger the horizontal surface area , the more light the organism will receive , but only if high enough to escape the shade of competitors .",
    "this heuristic encourages the formation of a canopy above ten units of height , and the mesh will necessarily have a trunk in order to reach that height .",
    "an example after several generations of selection is show in figure  [ over10area ] .",
    "it is apparent that the shape look somewhat like a tree .",
    "a fairly simple algorithm is presented that can generate interesting shapes according to a genetic code that is suitable for use in a genetic algorithm .",
    "an example heuristic was given which demonstrated its suitability for use in a genetic algorithm .",
    "the neural networks here are meant to be an analogy to the process that forms morphology in nature : the outputs of the neural network are meant to be analogous to the state of the cells in this region of the organism , including any chemical markers or hormones that might influence the organism s local growth .",
    "neural network were chosen to be the equivalent process in these simulations because the implementation is simple .",
    "this technique might find applications in reconstructing asteroid shapes from light curves , or in biomedical imaging , or in computer graphics .",
    "the method outlined here was developed in a non - academic setting , and published because it appears to be novel .",
    "however , the author acknowledges that there may be relevant papers that should have been cited but were neglected .",
    "any comments or suggestions would be gratefully received .",
    "eduardo gomez - ramirez and giovanni  egidio pazienza .",
    ", chapter the game of life using polynomial discrete time cellular neural networks , pages 719726 .",
    "springer berlin heidelberg , berlin , heidelberg , 2007"
  ],
  "abstract_text": [
    "<S> there are a number of ways to procedurally generate interesting three - dimensional shapes , and a method where a cellular neural network is combined with a mesh growth algorithm is presented here . the aim is to create a shape from a genetic code in such a way that a crude search can find interesting shapes .    </S>",
    "<S> identical neural networks are placed at each vertex of a mesh which can communicate with neural networks on neighboring vertices . </S>",
    "<S> the output of the neural networks determine how the mesh grows , allowing interesting shapes to be produced emergently , mimicking some of the complexity of biological organism development . </S>",
    "<S> since the neural networks parameters can be freely mutated , the approach is amenable for use in a genetic algorithm . </S>"
  ]
}