{
  "article_text": [
    "to utilize the full power of quantum computation , one needs a scalable quantum computer with a sufficient number of qubits .",
    "unfortunately , the first practical quantum computers are likely to have only small qubit capacity . one way to overcome this difficulty is by using the distributed computing paradigm . by a distributed quantum computer , we mean a network of limited capacity quantum computers connected via classical and quantum channels .",
    "quantum entangled states , in particular generalized ghz states , provide an effective way of implementing non - local operations , such as , non - local cnots and teleportation  @xcite .",
    "we use distributed quantum computing techniques to construct a distributed quantum circuit for the shor factoring algorithm .",
    "let @xmath2 , where @xmath1 is the number to be factored .",
    "the gate complexity of this particular distributed implementation of shor s algorithm is @xmath3 with @xmath4 communication overhead . and space complexity @xmath5 . ]    in section [ sec : distqc ] ,",
    "the general principles of distributed quantum computing are outlined , and two primitive distributed computing operators , * cat - entangler * and * cat - disentangler * , are introduced .",
    "we use these two primitive operators to implement non - local operations , such as non - local cnots and teleportation .",
    "then we discuss how to share the cost of implementing a non - local controlled @xmath6 , where @xmath6 can be decomposed into a number of gates .",
    "the section ends with an distributed implementation of the fourier transform .    in section [ sec : factoring ] , we give a detailed description of an implementation of shor s non - distributed factoring algorithm .",
    "this implementation is based on the phase estimation and order finding algorithms .",
    "we discuss in detail how to implement `` modular exponentiation , '' which implementation will be used later in this paper as a blueprint for creating a distributed quantum algorithm .    in section [ sec : distshor ] , we implement a distributed factoring algorithm by partitioning the qubits into groups in such a way that each group fits on one of the computers making up the network .",
    "we then proceed to replace controlled gates with non - local controlled gates whenever necessary .",
    "by a distributed quantum computer ( dqc ) , we mean a network of limited capacity quantum computers connected via classical and quantum channels .",
    "each computer ( or node ) possesses a quantum register that can hold only a fixed limited number of qubits .",
    "each node also possesses a small fixed number of channel qubits which can be sent back and forth over the network .",
    "each register qubit can freely interact with any other qubit within the same register .",
    "each such qubit can also freely interact with channel qubits that are in the same computer .",
    "in particular , each such qubit can interact with other qubits on a remote computer by two methods : 1 ) the qubit can interact via non - local operations , or 2 ) the qubit can be teleported or physically transported to a remote computer in order to locally interact with a qubit on that remote computer .",
    "indeed , distributed quantum computing can be implemented by only teleporting or physically transporting qubits back and forth .",
    "however , a more efficient implementation of dqc has been proposed by eisert et al  @xcite using non - local cnot gates .",
    "since the controlled - not gate together with all one - qubit gates is universal set of gates  @xcite , a distributed implementation of any unitary transformation reduces to the implementation of non - local cnot gates .",
    "eisert et al also prove that one shared entangled pair and two classical bits are necessary and sufficient to implement a non - local cnot gate .",
    "yimsiriwattana and lomonaco @xcite have identified two primitive operations , * cat - entangler * and * cat - disentangler * , which can be used to implement non - local operations , e.g. , non - local cnots , non - local controlled gates , and teleportation .",
    "figure  [ fig : entdis ] illustrates cat - entangler and cat - disentangler operations .",
    "the cat - entangler and cat - disentangler operations for a 5-qubit system are shown in figure [ fig : entdis]-a and figure [ fig : entdis]-b , respectively .",
    "a dotted - line represents a measurement result , which is classical and is used to control @xmath7 gates . the @xmath8 gate in circuit [ fig : entdis]-b is controlled by the exclusive - or @xmath9 of the three classical bits resulting from the measurement of qubits three to five .",
    "a qubit is reset to @xmath10 by a control-@xmath7 gate .",
    "this control-@xmath7 gate is controlled by a classical bit arising from the measurement on the qubit . ]    for the implementation of a non - local cnot gate , an entangled pair must first be established between two computers .",
    "then , the cat - entangler is used to transform a control qubit @xmath11 and an entangled pair @xmath12 into the state @xmath13 , called a `` * cat - like * '' state .",
    "this state permits two computers to share the control qubit . as a result ,",
    "each computer now can use a qubit shared within the cat - like state as a local control qubit .",
    "after completion of the control operation , the cat - disentangler is then applied to disentangle and restore the control qubit from the cat - like state . finally , channel qubits are reset by using the classical information resulting from measurement to control @xmath7 gates . in this way",
    ", channel qubits can be reused and entangled pairs can be re - established . a non - local cnot circuit is illustrated in figure  [ fig : cnotteleport]-a .    to teleport an unknown qubit from computer a to b",
    ", we begin by establishing an entangled pair between two computers .",
    "then , we apply the cat - entangler operation to create a cat - like state from an unknown qubit and the entangled pair . after that",
    ", we apply a cat - disentangler operation to disentangle and restore the unknown qubit from the cat - like state into the computer b. finally , we reset the channel qubits by swapping the unknown qubit with @xmath10 .",
    "the teleportation circuit is shown in figure [ fig : cnotteleport]-b .",
    "this figure shows both the non - local cnot ( a ) and the teleportation circuits ( b ) . in both circuits ,",
    "the cat - entangler creates a cat - like state , which is shared between the first and the third qubits . in the non - local cnot circuit ( a ) , the third line shares with the first line the same control qubit via the cat - like state .",
    "it is used as a local control qubit to control the target qubit .",
    "finally the cat - disentangler is applied to disentangle the control qubit from the cat - like state and return the control qubit back to the first line . in the teleportation circuit , the cat - disentangler disentangles the unknown qubit from the cat - like state , and transfers the unknown state to the third qubit . ]    because a cat - like state permits two computers to share a control qubit , the cost of implementing a non - local controlled @xmath6 , where @xmath6 is a unitary transformation composed of a number of basic gates , can be shared among these basic gates .",
    "for example , let us assume that a unitary transformation has the form @xmath14 , where @xmath15 .",
    "since the control qubit is reused , each non - locally controlled @xmath16 gate can be implemented using asymptotically only @xmath17 entangled pair and @xmath18 classical bit , as demonstrated in figure  [ fig : nonlocal - cu ] .    before the execution of a non - local operation",
    ", an entangled pair must first be established between channel computers .",
    "if each machine possesses two channel qubits , then two entangled pairs can be established by sending two qubits . to do so , each computer begins by entangling its own channel qubits , then exchanging one qubit of the pair with the other computer . as a result ,",
    "one entangled pair is established at the asymptotically cost of sending one qubit . to refresh the entanglement , the procedure is simply repeated after the channel qubits are reset to the state @xmath10 .",
    "assume @xmath19 .",
    "then a controlled @xmath6 can be distributed as shown .",
    "the control line needs to be distributed only once , because it can be reused .",
    "this implementation allows the cost of distributing the control qubit to be shared among the elementary gates . ]",
    "the quantum fourier transform is a unitary transformation defined on standard basis states as follows , @xmath20 where @xmath21 is the number of qubits .",
    "an efficient circuit for the quantum fourier transformation can be found in nielsen and chuang s book  @xcite and also in cleve et al .",
    "paper @xcite .",
    "we implement a distributed version of the fourier transformation by replacing a controlled @xmath22 with non - local controlled @xmath22 , when necessary .",
    "the distributed swap gate can be implemented by teleporting qubits back and forth between two computers .",
    "an implementation of the distributed fourier transformation of @xmath23 qubits is shown in figure  [ fig : dist - fourier ] , where the gate @xmath22 is defined as : @xmath24 for @xmath25 .    for a more detailed discussion on distributed quantum computing",
    ", please consult yimsiriwattana and lomonaco @xcite .",
    "* the prime factorization problem * is defined as follows : _ given a composite odd positive number @xmath1 , find its prime factors _ @xcite .",
    "it is well known that factoring a composite number @xmath1 reduces to the task of choosing a random integer @xmath26 relatively prime to @xmath1 , and then determining its multiplicative order @xmath27 modulo @xmath1 , i.e. , to find the smallest positive integer @xmath27 such that @xmath28 .",
    "this problem is known as the `` order finding problem . ''",
    "cleve et al  @xcite have shown that the order finding problem reduces to the phase estimation problem , a problem which can be solved efficiently by a quantum computer .",
    "we briefly review these problems in this section .      *",
    "the phase estimation problem * is defined as follows : _ let @xmath6 be an @xmath21-qubit unitary transformation having eigenvalues @xmath29 with corresponding eigenkets @xmath30 where @xmath31",
    ". given one of the eigenket @xmath32 , estimates the value of @xmath33 . _",
    "cleve et al solve this problem as follows : construct two quantum registers , the first an @xmath34-qubit register , and the second an @xmath21-qubit register . then construct a unitary transformation @xmath35 which acts on both registers as follows : @xmath36 where @xmath37 and @xmath38 denotes respectively the state of the first and second register .",
    "the phase estimation algorithm can be described as follows :    * phase estimation algorithm : * + * input * : @xmath6 and @xmath32 , : an estimate of @xmath33 .",
    "+ note : @xmath39 ( @xmath40 ) is the state of the first register ( second register , respectively ) .",
    "+ ( 1 ) let @xmath41 . + ( 2 ) @xmath42",
    ". + ( 3 ) @xmath43",
    ". + ( 4 ) @xmath44 .",
    "+ ( 5 ) @xmath45 = the result of measuring @xmath39 + ( 6 ) output @xmath46 .",
    "step ( 1 ) is an initialization of the registers into the state @xmath47 with input @xmath32 .",
    "step ( 2 ) applies the hadamard transformation to the first register , leaving the registers in the state @xmath48 as a result of applying @xmath35 in step ( 3 ) , the registers are in the state @xmath49 to understand the workings of step ( 4 ) , let us assume that @xmath50 , for some @xmath51 .",
    "therefore , the equation ( [ eqn : ctrlstep ] ) can be rewritten as : @xmath52 by applying the inverse quantum fourier transform in step ( 4 ) , the registers are in the state @xmath53 by making a measurement on the first register in step ( 5 ) , we obtain @xmath45 , where @xmath54 .    in general , @xmath33 may not be of the form of @xmath46 .",
    "however , the result of applying the inverse qft in step ( 4 ) results in @xmath46 being the best @xmath34-bit estimation of @xmath33 with a probability of at least @xmath55 . for more details ,",
    "please consult cleve et al  @xcite .",
    "a quantum circuit of the phase estimation algorithm is shown in figure [ fig : phaseest ] .",
    "this figure shows the construction of a phase estimation circuit .",
    "the @xmath34-control @xmath6 , @xmath35 , is not shown in detail .",
    "however , if we have access to @xmath56 , where @xmath57 , then @xmath35 can be implemented using the method of repeated squaring . as a result ,",
    "@xmath46 is the best @xmath34-bit estimation of @xmath33 . ]",
    "* the order finding problem * is defined as follows : _ given a positive integer @xmath1 and an integer @xmath26 relatively prime to @xmath1 , find the smallest positive integer @xmath27 such that _ @xmath58 first of all , we want a unitary transformation to use in the phase estimation algorithm .",
    "we call that unitary transformation @xmath59 , which is defined as follows : @xmath60 where @xmath61 is an @xmath21-qubit register ( the second register ) .",
    "let @xmath62 , and for each @xmath63 , define @xmath64 then , for each @xmath65 , @xmath66 in other words , @xmath67 is an eigenvalue of @xmath59 with respect to eigenvector @xmath32 .",
    "furthermore , @xmath68 , for each @xmath65 . therefore",
    ", if we have given an eigenvector @xmath69 , and we know how to construct @xmath70 , then we can find @xmath27 ( which is the period of @xmath26 ) by using the phase estimation algorithm .",
    "unfortunately , it is not trivial to construct @xmath32 for every @xmath65 . instead of using @xmath32",
    ", we use @xmath71 which is effectively equivalent to selecting @xmath32 , where @xmath65 is randomly selected from @xmath72 .",
    "then , we use the phase estimation algorithm to compute the value of @xmath46 which is the best @xmath34-bit estimate value of @xmath73 .",
    "we extract the value of @xmath73 by using the continued fraction algorithm .",
    "if @xmath65 and @xmath27 are relatively prime , then we get @xmath27 , which is the period of @xmath26",
    ". the output @xmath27 of the phase estimation algorithm can be tested by checking that @xmath74 .",
    "if @xmath27 is not the period of @xmath26 , then we can re - execute this algorithm until @xmath65 is coprime to @xmath27 , which occurs with high probability in @xmath75 rounds  @xcite .    in the next section",
    ", we describe an implementation of @xmath35 .",
    "this calculation is equivalent to the calculation that shor uses in his factoring algorithm , known as `` modular exponentiation . ''",
    "another detailed implementation of the modular exponentiation can be found in beckman et al @xcite .      to complete the implementation of the order finding algorithm",
    ", we need to construct the unitary transformation @xmath70 .",
    "we accomplish this by using the method of repeated squaring .",
    "let @xmath76 , be the binary expansion of the contents of the first register , @xmath37 .",
    "it now follows that @xmath77 then , for each @xmath78 , we can implement the term @xmath79 as a controlled @xmath80 , where the control qubit is @xmath81 .",
    "please note that @xmath26 is a constant integer , and that @xmath82 for all @xmath83 .",
    "therefore , we can precompute the value of @xmath84 by classical computers .",
    "then we can apply the same technique used to implement @xmath59 , to implement @xmath85 .",
    "figure [ fig : ctrl - mu ] shows an implementation of @xmath70 .",
    "let @xmath86 be a binary representation of @xmath87 .",
    "then @xmath88 .",
    "the term @xmath89 is implemented as a control-@xmath80 circuit , where the control qubit is @xmath81 . ]      for a given polynomial - time function @xmath90 , we can construct a unitary transformation @xmath91 which maps @xmath92 to @xmath93 .",
    "however , the complete definition of @xmath91 also includes ancillary qubits which contain information necessary for @xmath91 to be reversed .",
    "let @xmath94 be a function that computes the additional information , called `` garbage '' .",
    "the complete definition of @xmath91 is , @xmath95    the garbage needs to be reset , or erased , to state @xmath10 before we make a measurement .",
    "otherwise , the result of the measurement could be affected by the garbage . to erase the garbage ,",
    "shor uses bennett s technique which we review in this section .",
    "first we compute @xmath96 .",
    "once we have the output @xmath97 , we copy @xmath97 into the extra register which has been preset to state @xmath10 .",
    "then we erase the output and the garbage of @xmath91 by reverse computing @xmath96 .",
    "in particular , this procedure is described as follows : @xmath98 where @xmath99 is the reverse computation of @xmath91 .",
    "we copy @xmath97 to the extra register bit by bit by applying a @xmath100 gate on each qubit .",
    "we define @xmath101 .",
    "if @xmath90 is a polynomial - time invertible function , we can create a unitary transformation @xmath102 which overwrites an input @xmath61 with the output @xmath97 .",
    "we start from the construction of a unitary transformation @xmath103 as follows : @xmath104 where @xmath105 is a polynomial - time inverse function of @xmath90 .",
    "the transformation @xmath103 may generate garbage , but it can be erased by using the technique mentioned above . finally , we implement @xmath102 as follows : @xmath106 where @xmath107 is the reverse computation of @xmath103 .",
    "the @xmath108 is a swap gate that swaps the content of the input and the output registers .",
    "we continue our construction of @xmath59 by first implementing `` binary adders . ''",
    "there are two types of binary adders , `` binary full adder '' and `` binary half adder , '' denoted by @xmath109 and @xmath110 , respectively .",
    "the @xmath109 and @xmath110 are defined as follows : @xmath111 where @xmath26 is a classical bit , and @xmath112 and @xmath113 are input and output carries , respectively .",
    "the circuits for @xmath109 and @xmath110 are shown in figure  [ fig : bfabha ] .",
    "the dotted - line represents the classical bit @xmath26 which is used to control the quantum gates .",
    "the @xmath109 computes an additional output carry qubit , while the @xmath110 does not . ]",
    "the dotted - line represents a classical bit @xmath26 which is used to control the quantum gates . if the classical bit is @xmath114 , the quantum gate is not applied .",
    "if the classical bit is @xmath115 , then the quantum gate is applied .",
    "the binary full adder adds a classical bit @xmath26 to the carry @xmath112 first , then adds a qubit @xmath116 to the sum . because the carry is not computed by @xmath110 , we remove two gates ( the first gate , and the toffoli gate ) from @xmath109 in order to implement @xmath110 .      for each classical @xmath21-bit integer @xmath26 ,",
    "an @xmath21-qubit full adder @xmath117 is the unitary transformation defined by @xmath118 where @xmath119 is an @xmath21-qubit register , @xmath120 , and @xmath121 and @xmath122 are an input and output carries , respectively .",
    "a quantum circuit for @xmath117 is shown in figure  [ fig : adders ] , where @xmath123 , @xmath124 , and @xmath125 are @xmath21-bit binary representations of @xmath126 and @xmath121 , respectively .     by applying the @xmath127s bit by bit , as shown in the above circuit",
    ", we effectively add an @xmath21-bit number @xmath26 to the @xmath21-qubit number @xmath116 and the carry @xmath112 .",
    "the outputs are registers @xmath116 , @xmath119 , and a new carry @xmath113 , where @xmath128 .",
    "the thick lines represent an @xmath21-qubit register . ]",
    "we replace the last @xmath129 with a @xmath130 to construct @xmath131 . as a result",
    ", we need only @xmath132 input ancillary qubits with initial state @xmath10 to implement @xmath133 . by including an input carry qubit @xmath112 ,",
    "the @xmath133 is a @xmath134-qubit unitary transformation .",
    "we use @xmath117 and @xmath133 to implement the @xmath21-qubit adder modulo @xmath1 , @xmath135 .",
    "we observe that if @xmath136 , then @xmath137 ; otherwise @xmath138 .",
    "we implement @xmath139 as follows : first we compute the sum of @xmath116 with a classical number @xmath140 in modulo @xmath141 .",
    "if the carry is not set , then we subtract @xmath142 from the sum .",
    "hence , we have a transformation @xmath139 , given by @xmath143 where @xmath144 , and @xmath121 is the carry . the circuit that implements @xmath139 is shown in figure  [ fig : addmodn ] .",
    "first , we add a number @xmath140 to ket @xmath116 .",
    "if the carry bit is not set , then we subtract @xmath142 from the sum . as a result , we compute @xmath145 . ]",
    "we use the technique described in section @xmath146 to reset @xmath119 and @xmath112 back to state @xmath10 . as a result",
    ", we obtain a transformation @xmath147 which acts as follows : @xmath148 in other words , @xmath149 is a @xmath134-qubit transformation ( with @xmath150 ancillary qubits ) which sends @xmath151 to @xmath152 .",
    "the wiring diagram for @xmath149 is shown in figure [ fig : xaddmodn ] .     using a @xmath100 gate to copy bit by bit from the output register of @xmath139 to an @xmath21-qubit ancillary register",
    ", we can apply @xmath153 so that @xmath119 and @xmath112 are set to state @xmath10 . ]",
    "because the inverse transformation of @xmath149 is @xmath154 , the input of @xmath149 can be overwritten by the output of @xmath149 by using the technique described in section @xmath146 .",
    "we now define the adder @xmath155 as follows : @xmath156 as a result , the transformation @xmath155 is an @xmath21-qubit transformation ( with @xmath157 ancillary qubits ) which maps @xmath116 to @xmath158 .",
    "now we are ready to describe the construction of @xmath59 , which maps @xmath61 to @xmath159 , where @xmath160 .",
    "we define an @xmath134-qubit unitary transformation @xmath161 as follows : @xmath162 assuming @xmath163 is the binary representation of @xmath164 , we have @xmath165 for each @xmath166 , the term @xmath167 can be implemented by the control-@xmath168 , where @xmath169 is a control qubit , and @xmath170 since for each @xmath78 , @xmath171 is constant , we can compute each @xmath171 by using a classical computer .",
    "then we use the result and the same technique for implementing @xmath155 , as described in section [ sec : adder ] , to construct @xmath168 .",
    "therefore , the transformation @xmath161 can be implemented using the method of repeated squaring with a circuit similar to the circuit shown in figure  [ fig : ctrl - mu ] .",
    "hence , @xmath161 is a @xmath134-qubit transformation sending @xmath92 to @xmath172 , using of @xmath157 ancillary qubits .",
    "finally , with the overwriting output technique described in section [ sec : revcomp ] , the transformation @xmath59 can be implemented as @xmath173 .",
    "( note that , because @xmath26 and @xmath1 are relatively prime , @xmath174 always exists in @xmath175 . ) in other words , @xmath59 is an @xmath21-qubit transformation with @xmath176 ancillary qubits .",
    "thus , the so constructed @xmath59 can be plugged into the transformation @xmath70 , as described earlier in section [ sec : modexp ] .",
    "we analyze the complexity of our implementation of shor s algorithm for two parameters , i.e . , the number of gates and the number of qubits .      to count the number of gates , we define a function @xmath177 to be the number of gates used to implement the transformation @xmath91 .",
    "we recursively compute the number of gates as follows : @xmath178 since @xmath179 , @xmath180 , and @xmath181 , it follows that the gate complexity of this implementation is @xmath182 . in general , @xmath183 .",
    "therefore , the complexity is @xmath3 .",
    "however , we count a control - gate with multiple control - qubits as one gate .",
    "in fact , a control gate with multiple control qubit can be broken down into a sequence of toffoli gates using the techniques described by beranco et al  @xcite . moreover",
    ", the number of needed toffoli gates grows exponentially with respect to the number of control qubits in the control - gate .",
    "fortunately , the number of control qubits in the shor s algorithm is at most @xmath184 : one control qubit for @xmath70 , one control qubit for @xmath59 , one control qubit for control-@xmath117 in the implementation of @xmath139 , and two control qubits in the implementation of @xmath117 .",
    "moreover , the number of control qubits does not depend on the input number @xmath1 .",
    "therefore , there is constant overhead from breaking down a control gate with multiple control qubits into a sequence of toffoli gates .",
    "this overhead does not have affect the gate complexity .",
    "first of all , @xmath149 is a @xmath134-qubit transformation with @xmath150 ancillary qubits .",
    "so , we need @xmath21 qubits to control the transformation @xmath155 in the implementation of @xmath59 , and @xmath34 more qubits to control the transformation @xmath59 in the implementation of @xmath70 . therefore , the number of qubits needed in this implementation is @xmath185 .",
    "we implement a distributed quantum factoring algorithm as briefly described as follows : first , we partition @xmath185 qubits into groups in such a way that each group fits on one of the quantum computers making up a network .",
    "then , we implement a distributed quantum factoring algorithm on this quantum network by replacing a control gate with a non - local control gate , whenever necessary .    in this paper , we will describe a distributed quantum factoring algorithm to factor a number @xmath1 within specific parameters .",
    "we assume that we have a network of @xmath186-qubit quantum computers , where @xmath2 .",
    "the @xmath121 extra qubits for each computer can be used as either channel qubits or ancillary qubits .",
    "we will show that @xmath121 is a constant which does not depend on the input number @xmath1 . to be more specific ,",
    "we choose @xmath183 .",
    "therefore , the number of qubits needed in this implementation is @xmath187 qubits .",
    "although , this particular implementation is specific to certain parameters , its implementation can easily be generalized .",
    "first we divide the control register of @xmath70 , @xmath37 , into two @xmath21-qubits groups",
    ". then we place these two groups on two different computers .",
    "each qubit @xmath81 of these two groups remotely controls the transformation @xmath80 .",
    "another computer is assigned to hold the control register of @xmath161 , i.e. , @xmath61 .",
    "each qubit @xmath188 remotely controls the transformation @xmath155 .",
    "next , we implement the transformation @xmath149 , which is a component of @xmath139",
    ". the transformation @xmath149 has two registers , one @xmath21-qubit input register @xmath116 , and one @xmath21-qubit output register @xmath189 .",
    "however , @xmath149 also requires @xmath150 ancillary qubits , i.e. , one carry bit , @xmath21 qubits for the intermediate sum @xmath119 , and @xmath21 qubits for the intermediate output register @xmath189 .",
    "therefore , it takes four computers to compute @xmath149 .",
    "each computer computes @xmath190 of each register , as shown in figure [ fig : distadder ] .",
    "each computer holds @xmath191 qubits from the input registers @xmath116 , @xmath191 qubits from the intermediate sum register @xmath119 , @xmath191 qubits from the intermediate output register , and @xmath191 qubits from the output register @xmath189 ( represented by thick lines ) .",
    "each computer also has two extra carries qubits , which are used in computing of @xmath192 and @xmath193 .",
    "this figure shows how to compute @xmath139 followed by @xmath194 transformations .",
    "each computer holds @xmath191 qubit from each register .",
    "each computer also has two carry qubits which have been set to @xmath10 .",
    "the arrow line represents teleportation of the output carry qubit to the next computer .",
    "each transformation is remotely controlled by two qubits , one from register @xmath37 , and the other from the register @xmath61 . ]",
    "the first four @xmath192 transformations compute @xmath195 with the input carry @xmath196 .",
    "these @xmath192s are remotely controlled by two control qubits , one from the register @xmath37 , and the other from the register @xmath61 .",
    "a distributed control @xmath192 with two control qubits is implemented by distributing two control qubits onto the computer that holds the target qubits , and then implementing the double control locally , as shown in figure  [ fig : mctrl - fa ] . after completing each @xmath192 computation , the output carry bit is teleported to the next @xmath192 on another computer .",
    "the teleportations are represented by arrow lines .",
    "a distributed multi - control gate can be implemented by distributing all control qubits to the computer that hold the target qubits , then implementing the multi - control gate locally .",
    "this figure shows how to implement an distributed control - control - fa gate . ]",
    "the transformation @xmath197 is computed by the next three full adders @xmath193 , and a half adder @xmath198 .",
    "the integer @xmath199 is precomputed by a classical computer , and then used to implement @xmath193 and @xmath198 .",
    "similarly , the carry qubit is teleported from one computer to another .",
    "the last carry qubit is teleported into the first qubit of the intermediate output register @xmath200 .",
    "each @xmath193 and the single @xmath198 are each controlled by three qubits : one from the first register @xmath37 , one from the register @xmath61 , and the last from the output carry bit of @xmath201 .",
    "a non - local three - control gate can implemented by distributing all three - control qubits onto the target computer , and locally implementing the control gate with three control qubits .",
    "the @xmath194 transformation is a bitwise copy implemented in terms of cnot gates .",
    "because each computer possesses @xmath191 of intermediate output register and the final output register itself , the distributed @xmath194 can be easily implement by locally applying cnot gates , as shown in figure [ fig : distadder ] .",
    "however , @xmath194 still needs to be remotely controlled by two qubits from register @xmath37 and register @xmath61 .",
    "similarly , each machine possesses @xmath191 qubits of both input register and output register .",
    "the distributed @xmath108 can be locally implement on each machine , remotely controlled by two qubits from register @xmath37 and register @xmath61 .",
    "the number of extra qubits @xmath121 depends on two factors : the number of channel qubits , and the number of extra carry qubits needed in the implementation .",
    "the number of channel qubits depends on how many non - local control qubits are needed . in this implementation , at most three non - local control qubits",
    "are implemented .",
    "therefore , at most @xmath202 channel qubits are required at one time .",
    "furthermore , there are only two extra carry qubits ( one carry qubit for transformation @xmath192 and another carry qubit for transformation @xmath193 ) needed in this implementation .",
    "therefore , @xmath203 , and does not depend on the input @xmath1 .      by communication complexity , we means the number of entangled pairs needed to be established , and the number of classical bits needed to be transmitted in each direction .",
    "the optimum cost of implementing a non - local operation is one epr pair and two classical bits ( one in each direction ) .",
    "therefore , if we can count the number of non - local control gates and teleportation circuits , we can estimate the communication overhead .",
    "the communication overhead of a control gate with multiple control qubits ( such as control - fa with two control qubits ) is equal to the overhead for a single non - local cnot gate multiplied by the number of control qubits .",
    "fortunately , the maximum number of non - local control qubits is at most @xmath202 .",
    "therefore , we can count every gate as one control gate .    if we simply count every gate as a non - local gate , the communication overhead is @xmath182 .",
    "this number is an over estimation because the cost of each non - local control-@xmath6 gate , where @xmath6 can be decomposed into a number of elementary gates , can be shared among these elementary gates .    to be more precise",
    ", we define a function @xmath204 to be the number of non - local control gates implemented in the distributed implementation of circuit @xmath91 .",
    "we compute @xmath205 as follows : @xmath206    as shown in figure  [ fig : distadder ] , there are @xmath207 non - local control gates per @xmath139 , i.e. , @xmath208 .",
    "( the non - local control not gate in the middle can be included in the implementation of the last non - local control @xmath192 . )",
    "four non - local control circuits are sufficient to implement @xmath194 .",
    "similarly , another four non - local control circuits are sufficient to implement @xmath108 . therefore , @xmath209 .",
    "since @xmath210 , then @xmath211 .",
    "similarly , we define a function @xmath212 to be the number of teleportation circuits implemented in the distributed implementation of circuit @xmath91",
    ". then , six teleportation circuits are sufficient to implement @xmath139 .",
    "there is no need for a teleportation circuit in @xmath194 , @xmath108 , and @xmath213 .",
    "therefore , @xmath214 .    as a result ,",
    "the communication complexity of shor is @xmath215 . in this particular implementation , @xmath183 .",
    "hence , the communication over is @xmath4 .",
    "this effort is partially supported by the defense advanced research projects agency ( darpa ) and air force research laboratory , air force materiel command , usaf , under agreement number f30602 - 01 - 2 - 0522 , the national institute for standards and technology ( nist ) .",
    "government is authorized to reproduce and distribute reprints for government purposes notwithstanding any copyright annotations thereon .",
    "the views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements , either expressed or implied , of the defense advanced research projects agency , the air force research laboratory , or the u.s .",
    "government .",
    "99 j. eisert , k. jacobs , p. papadopoulos , and m.b .",
    "plenio , `` optimal local implementation of non - local quantum gates '' , phys .",
    "rev . a , * 62 * , 052317 - 1 ( 2000 ) , _ quant - ph/0005101 . _",
    "a. yimsiriwattana , s. j. lomonaco , `` generalized ghz states and distributed quantum computing '' , _ quant - ph/0402148 .",
    "_ peter w. shor , `` polynomial - time algorithms for prime factorization and discrete logarithms on a quantum computer '' , proceeding of the 35th annual symposium of foundations of computer science , ieee computer society press pp .",
    "124 - 134 , 1994 , _ quant - ph/9508027 .",
    "_ daniel collins , noah linden and sandu popescu , `` the non - local content of quantum operations '' , phys . rev . a , * 64 * , 032302 - 1 ( 2001 ) , _ quant - ph/0005102 .",
    "_ r. cleve , a. ekert , c. macchiavello , m. mosca , `` quantum algorithms revisited '' , phil .",
    ". a , 1996 , _ quant - ph/9708016 .",
    "_ samuel j. lomonaco jr .",
    ", `` shor s quantum factoring algorithm '' , proceedings of symposium in applied mathematics , vol 58 , pp 161 - 180 , ams .",
    "d. beckman , a. n. chari , s. devabhaktuni , j. preskill , `` efficient networks for quantum factoring '' , phys .",
    "rev . a , * 54 * , 1034 ( 1006 ) , _ quant - ph/9602016 .",
    "_ a. beranco , c. h. bennett , r. cleve , d. p. divincenzo , n. margolus , p. shor , t. sleator , j. smolin , h. weinfurter , `` elementary gate for quantum computing '' , physical review a , vol52 ( 1995 ) , pp3457 .",
    "micheal a. nielsen and isaac l. chuang , `` quantum computation and quantum information '' , 2000 , cambridge university press , isbn 0 521 63503 ."
  ],
  "abstract_text": [
    "<S> we present a distributed implementation of shor s quantum factoring algorithm on a distributed quantum network model . </S>",
    "<S> this model provides a means for small capacity quantum computers to work together in such a way as to simulate a large capacity quantum computer . in this paper , </S>",
    "<S> entanglement is used as a resource for implementing non - local operations between two or more quantum computers . </S>",
    "<S> these non - local operations are used to implement a distributed factoring circuit with polynomially many gates . </S>",
    "<S> this distributed version of shor s algorithm requires an additional overhead of @xmath0 communication complexity , where @xmath1 denotes the integer to be factored . </S>"
  ]
}