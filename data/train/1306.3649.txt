{
  "article_text": [
    "a business process is a collection of interrelated tasks that are performed by users in order to achieve some objective . in many situations , we wish to restrict the users that can perform certain tasks . in particular , we may wish to specify lists of users who are authorized to perform each of the workflow tasks .",
    "additionally , we may wish  either because of the particular requirements of the business logic or security requirements  to prevent certain combinations of users from performing particular combinations of tasks  @xcite .",
    "such constraints include _ separation - of - duty _ ( also known as the `` two - man '' rule ) , which may be used to prevent sensitive combinations of tasks being performed by a single user , and _ binding - of - duty _ , which requires that a particular combination of tasks is executed by the same user .",
    "the use of constraints in workflow management systems to enforce security policies has been studied extensively in the last fifteen years ; see  @xcite , for example .",
    "it is possible that the combination of constraints and authorization lists is `` unsatisfiable '' , in the sense that there does not exist an assignment of users to tasks such that all contraints are satisfied and every task is performed by an authorized user ; perhaps the minimal example being a requirement that two tasks are performed by the same user but the intersection of the authorization lists for these tasks is empty . a plan that satisfies all constraints and allocates an authorized user to each task",
    "is said to be `` valid '' .",
    "the _ workflow satisfiability problem ( wsp ) _ takes a workflow specification as input and returns a valid plan if one exists and a null value otherwise .",
    "it is important to determine whether a business process is satisfiable or not , since an unsatisfiable one can never be completed without violating the security policy encoded by the constraints and authorization lists .",
    "wang and li  @xcite have shown , by a reduction from graph coloring , that wsp is an np - hard subclass of csp , even when we only consider binary separation - of - duty constraints .",
    "so it is important that an algorithm that solves wsp is as efficient as possible  @xcite .",
    "* many hard problems become less complex if some natural parameter of the instance is bounded .",
    "hence , we say a problem with input size @xmath3 and parameter @xmath1 is _ fixed - parameter tractable _",
    "( fpt ) if it admits an algorithm with running time @xmath4 , where @xmath5 is a constant independent of @xmath3 and @xmath1 , and @xmath6 is a computable function depending only on @xmath1 . *",
    "wang and li @xcite were the first to observe that fixed - parameter algorithmics is an appropriate way to study wsp , because the number of tasks is usually small and often much smaller than the number of users .",
    "it is appropriate therefore to consider fixed parameter algorithms for solving the wsp parameterized by the number of tasks , and to ask which constraint languages are fixed parameter tractable . [ line - through]*this paper begins a general theory of fixed parameter tractability of constraint languages for the wsp . *",
    "wang and li @xcite proved that , in general , wsp is w[1]-hard and thus is highly unlikely to admit a fixed - parameter algorithm .",
    "however , wsp is fpt if we consider only separation - of - duty and binding - of - duty constraints @xcite .",
    "crampton et al .",
    "@xcite obtained significantly faster fixed - parameter algorithms that were applicable to `` regular '' constraints , thereby including the cases shown to be fpt by wang and li .",
    "subsequent research has demonstrated the existence of fixed - parameter algorithms for wsp in the presence of other constraint types  @xcite .",
    "we define wsp formally and introduce a number of different constraint types , including regular constraints , in section  [ sec : background ] .",
    "we will use the @xmath7 notation , which suppresses polynomial factors .",
    "that is , @xmath8 if there exists a polynomial @xmath9 such that @xmath10 . in particular ,",
    "an fpt algorithm is one that runs in time @xmath11 for some computable function @xmath6 depending only on @xmath1 .",
    "the _ constraint satisfaction problem ( csp ) _ is a general paradigm for expressing , in a declarative format , problems where variables are to be assigned values from some domain .",
    "the assignments are constrained by restricting the allowed simultaneous assignments to some sets of variables .",
    "this model is useful in many application areas including planning , scheduling , frequency assignment and circuit verification  @xcite .",
    "the csp community is a well - established research community dedicated to finding effective solution techniques for the csp  @xcite .",
    "the csp is np - hard , even when only binary not - equals constraints are allowed and the domain has three elements , as we can reduce graph 3-coloring to the csp .",
    "hence , a considerable effort has been made to understand the effect of restricting the type of allowed constraints .",
    "this research program is nearing completion and there is now strong evidence to support the algebraic dichotomy conjecture of krokhin , bulatov and jeavons characterising precisely which kinds of constraint language lead to polynomial solvability  @xcite .",
    "it is natural to see the wsp as a subclass of the csp in which the variables are tasks and the domain is the set of users . * in the language of csp , we may view authorization lists as arbitrary unary constraints .",
    "thus , wsp is a restriction of csp in which the only constraint languages considered are those that allow all unary constraints . *",
    "what makes the wsp distinctive as a csp is that we can assume the number of tasks is very small compared to the number of users @xcite .",
    "this is in sharp contrast with traditional csp models where the domain is small and the number of variables is very large .",
    "so it is natural to ask what the complexity of solving the wsp is when the number of tasks is a parameter @xmath1 of the problem , * and we place restrictions on the allowed types of non - unary constraints . *      our novel approach to the wsp using techniques for csp",
    ", characterising types of constraints as constraint languages with particular characteristics , enables us to generalise and unify existing algorithms .",
    "so , in this paper , for the first time , rather than considering algorithms for specific constraints , we design a generic algorithm which is a fixed - parameter algorithm for several families of workflow constraints considered in the literature . *",
    "in particular we introduce the notion of _ user - independent constraints _ , which subsume a number of well - studied constraint types from the wsp literature , including the regular constraints studied by crampton et al .",
    "@xcite . *",
    "our generic algorithm builds plans incrementally , discarding plans that can never satisfy the constraints .",
    "it is based on a naive algorithm , presented in section  [ sec : naive - solwsp ] .",
    "this naive algorithm stores far more information than is required to solve wsp , so its running time is no better than exhaustively searching for a valid plan .",
    "our generic algorithm uses a general and classic paradigm : retain as little information as possible in every step of the algorithm .",
    "this paradigm is used in such classical polynomial - time algorithms as gaussian elimination for solving systems of linear equations and constraint propagation algorithms ( used , for example , to solve 2sat in polynomial time ) .",
    "our generic algorithm uses this paradigm in a problem - specific way , based on the concepts of extension - equivalence , plan - indistinguishability and patterns , enabling us to retain a single pattern for each equivalence class of indistinguishable plans .",
    "extension - equivalence and plan encodings are described in section  [ sec : ext - equiv ] . in section  [ sec : solwsp ] , we describe our pattern - based algorithm and demonstrate that it is a fixed - parameter algorithm for wsp with user - independent constraints .",
    "we show the running time of our algorithm is @xmath0 for wsp with user - independent constraints and that there is no algorithm of running time @xmath2 for wsp with user - independent constraints unless the exponential time hypothesis for 3sat on @xmath3 variables @xcite . ] ( eth ) fails .",
    "thus , unlike wsp with regular constraints ( and problems studied in @xcite ) , wsp with user - independent constraints is highly unlikely to admit an algorithm of running time @xmath12 to show that our generic algorithm is of interest for constraints other than user - independent , we prove that the generic algorithm is a single - exponential algorithm for a constraint language obtained by an equivalence relation on the set of users . in section [ sec5 ]",
    "we show how our generic algorithm can deal with unions of constraint languages .",
    "this leads to a generalisation of our result for user - independent constraints .",
    "we conclude with discussions in section [ sec6 ] .",
    "we define a _ workflow schema _ to be a tuple @xmath13 , where @xmath14 is the set of tasks in the workflow , @xmath15 is the set of users , @xmath16 where @xmath17 is the _ authorization list _ for task @xmath18 , and @xmath19 is a set of workflow constraints .",
    "workflow constraint _ is a pair @xmath20 , where @xmath21 and @xmath22 is a set of functions from @xmath23 to @xmath15 : @xmath23 is the _",
    "scope _ of the constraint ; @xmath22 specifies those assignments of elements of @xmath15 to elements of @xmath23 that _ satisfy _ the constraint @xmath24 . given @xmath25 and @xmath26 , a _ plan _",
    "is a function @xmath27 . given a workflow constraint @xmath28 , @xmath25 and @xmath26 , a plan @xmath27 _ satisfies _",
    "@xmath28 if either @xmath29 or @xmath30 for some @xmath31 .",
    "a plan @xmath27 is _ eligible _ if @xmath32 satisfies every constraint in @xmath19 .",
    "a plan @xmath27 is _ authorized _ if @xmath33 for all @xmath34 .",
    "a plan is _ valid _ if it is both authorized and eligible .",
    "a plan @xmath35 is called a _",
    "complete plan_. an algorithm to solve wsp takes a workflow schema @xmath13 as input and outputs a valid , complete plan , if one exists ( and null , otherwise ) .    * as a running example , consider the following instance of wsp . *",
    "[ inst : mainexample ] the task set @xmath36 and the user set @xmath37 .",
    "the authorization lists are as follows ( here a tick indicates that the given user is authorized for the given task ) :    [ cols=\"^,<,<,<,<,<,<\",options=\"header \" , ]     @xmath38 is a complete plan which is authorized but not eligible , as @xmath39 and @xmath40 are assigned to different users .",
    "@xmath41 is a complete plan which is eligible but not authorized , as @xmath42 is not authorized for @xmath40 .",
    "@xmath43 is a plan which is authorized and eligible , and therefore valid .",
    "however , @xmath43 is not a complete plan as there is no assignment for @xmath40 .",
    "@xmath44 is a complete plan which is eligible and authorized .",
    "thus @xmath44 is a valid complete plan , and is therefore a solution to instance [ inst : mainexample ] .    for an algorithm that runs on an instance @xmath13 of wsp , we will measure the running time in terms of @xmath45 , and @xmath46 .",
    "( the set @xmath47 of authorization lists consists of @xmath1 lists each of size at most @xmath3 , so we do not need to consider the size of @xmath47 separately when measuring the running time . )",
    "we will say an algorithm runs in polynomial time if it has running time at most @xmath48 , where @xmath48 is polynomial in @xmath49 and @xmath50 .",
    "in this paper we are interested in the complexity of the wsp when the workflow constraint language ( the set of permissible workflow constraints ) is restricted . in this section",
    "we introduce the constraint types of interest .",
    "all of them have practical applications in the workflow problem .",
    "we assume that all constraints ( including the unary authorization constraints ) can be checked in polynomial time .",
    "this means that it takes polynomial time to check whether any plan is authorized and whether it is valid .",
    "the correctness of our algorithm is unaffected by this assumption , but choosing constraints not checkable in polynomial time would naturally affect the running time . [",
    "line - through]*all the constraints types we define and use in this paper can be checked in polynomial time . *",
    "* constraints defined by a binary relation : * constraints on two tasks , @xmath18 and @xmath51 , can be represented in the form @xmath52 , where @xmath53 is a binary relation on @xmath15 @xcite . a plan @xmath32 satisfies such a constraint if .",
    "writing @xmath54 to denote the relation @xmath55 and @xmath56 to denote the relation @xmath57 , separation - of - duty and binding - of - duty constraints may be represented in the form @xmath58 and @xmath59 , respectively .",
    "crampton et al .",
    "@xcite considered constraints for which @xmath53 is @xmath60 or @xmath61 , where @xmath60 is an _ equivalence relation _ defined on @xmath15 .",
    "a practical example of such workflow constraints is when the equivalence relation partitions the users into different departments : constraints could then enforce that two tasks be performed by members of the same department .",
    "constraints that are not restricted to singleton tasks have also been considered  @xcite : a plan @xmath32 satisfies a constraint of the form @xmath62 if there are tasks @xmath63 and @xmath64 such that .",
    "* cardinality constraints : * a _ tasks - per - user counting constraint _ has the form @xmath65 , where @xmath66 and @xmath67 . a plan @xmath32 satisfies @xmath65 if a user performs either no tasks in @xmath68 or between @xmath69 and @xmath70 tasks .",
    "steps - per - user counting constraints generalize the cardinality constraints which have been widely adopted by the wsp community  @xcite .",
    "* regular constraints : * we say that @xmath19 is _ regular _ if it satisfies the following condition : if a partition @xmath71 of @xmath14 is such that for every @xmath72 $ ] there exists an eligible complete plan @xmath32 and user @xmath73 such that @xmath74 , then the plan @xmath75 , where all @xmath76 s are distinct , is eligible . *",
    "regular constraints extend the set of constraints considered by wang and li @xcite .",
    "* crampton et al .",
    "@xcite show that the following constraints are regular : @xmath77 ; @xmath78 , where at least one of the sets @xmath79 is a singleton ; tasks - per - user counting constraints of the form @xmath65 , where @xmath80 .",
    "* user - independent constraints : * a constraint @xmath28 is user - independent if whenever @xmath81 and @xmath82 is a permutation then @xmath83 . in other words ,",
    "user - independent constraints do not distinguish between users .",
    "* many business rules are indifferent to the identities of the users that complete a set of steps ; they are only concerned with the relationships between those users .",
    "( per - user authorization lists are the main exception to such rules . )",
    "the most obvious example of a user - independent constraint is the requirement that two steps are performed by different users .",
    "a more complex example might require that at least three users are required to complete some sensitive set of steps .",
    "*    every regular constraint is user - independent , but many user - independent constraints are not regular .",
    "indeed , constraints of the type @xmath78 are user - independent , but not necessarily regular @xcite .",
    "many counting constraints in the global constraint catalogue @xcite are user - independent , but not regular .",
    "in particular , the constraint nvalue , which bounds from above the number of users performing a set of tasks , is user - independent but not regular .",
    "note , however , that constraints of the form @xmath84 and @xmath85 , are not user - independent , in general .",
    "* authorization lists , when viewed as unary constraints , are not user - independent .",
    "thus for wsp with user - independent constraints , users are still distinguished due to the authorization lists . *",
    "the main aim of this section is to present a simple algorithm ( algorithm [ alg : naive ] ) which will solve any instance of wsp .",
    "the running time of the algorithm is slightly worse than a brute - force algorithm , but the algorithm s basic structure provides a starting point from which to develop a more efficient algorithm .    before proceeding further , we introduce some additional notation and terminology .",
    "let @xmath27 be a plan for some @xmath86 .",
    "then let @xmath87 and @xmath88 .",
    "it is important for our generic algorithm that @xmath89 and @xmath90 are given as explicit parts of @xmath32 . in particular , the set @xmath90",
    "may be different from the set of users assigned to a task by @xmath32 .",
    "that is , a user @xmath73 can be in @xmath90 without there being a task @xmath18 such that @xmath91 .",
    "it is worth observing that @xmath89 may be empty ( because @xmath32 may not allocate any tasks to users in @xmath92 ) .",
    "for any @xmath25 and @xmath93 , @xmath94 denotes the plan @xmath95 such that @xmath96 for all @xmath34 .    two functions @xmath97 and @xmath98 are _ disjoint _ if @xmath99 .",
    "the _ union _ of two disjoint functions @xmath100 is a function @xmath101 such that @xmath102 and @xmath103 for each @xmath104 where @xmath105 .",
    "let @xmath106 and @xmath107 be functions . then @xmath108 denotes the composite function from @xmath109 to @xmath110 such that @xmath111 for each @xmath112 for an integer @xmath113 , the set @xmath114 = \\{1,2 , \\dots , p\\}$ ] .",
    "[ line - through]*a pseudocode listing is presented in algorithm  [ alg : naive ] : given an ordering @xmath115 of @xmath15 , we construct , in order , sets @xmath116 for each @xmath117 $ ] , where @xmath116 is the set of all valid plans @xmath32 with @xmath118 .",
    "the correctness of the algorithm is easy to establish , as is its run - time ( see the appendix ) .",
    "*    construct an ordering @xmath119 of @xmath15    set @xmath120 set @xmath121    [ prop : naive ] let @xmath13 be an instance of wsp , with @xmath122 , @xmath123 and @xmath46 .",
    "then @xmath13 can be solved in time @xmath124 by algorithm [ alg : naive ] .",
    "let @xmath119 be an ordering of @xmath15 , and let @xmath125 for each @xmath117 $ ] .",
    "for each @xmath117 $ ] in turn , we will construct the set @xmath116 of all plans @xmath32 such that @xmath126 and @xmath32 is valid .",
    "if the set @xmath127 contains no plan @xmath32 with @xmath128 then @xmath13 has no solution ; otherwise , any such plan is a solution for @xmath13 .",
    "algorithm [ alg : naive ] shows how to construct the sets @xmath116 .",
    "it is not hard to verify that @xmath116 contains exactly every valid plan @xmath32 with @xmath126 , for each @xmath129 .",
    "this implies the correctness of our algorithm .",
    "it remains to analyse the running time .    for each @xmath117 $ ] and each @xmath25",
    ", there are at most @xmath130 valid plans @xmath32 with @xmath131 .",
    "to construct @xmath132 , we need to consider all plans @xmath32 with @xmath133 , and there are exactly @xmath134 such plans .",
    "for each plan we can decide in polynomial time whether to add it to @xmath132 .",
    "to construct @xmath135 for each @xmath136 $ ] , we need to consider every pair @xmath137 where @xmath138 and @xmath139 .",
    "consider the pair @xmath140 , where @xmath141 is an @xmath142-plan for some @xmath143 , and @xmath144 .",
    "thus there are @xmath145 possibilities for @xmath141 , and there are @xmath146 choices for @xmath68 .",
    "thus , the total number of pairs is given by @xmath147 .",
    "for each pair @xmath137 we can decide whether to add @xmath148 to @xmath135 in polynomial time .",
    "thus , to construct all @xmath116 takes time @xmath149 .",
    "algorithm [ alg : naive ] is inefficient even for small @xmath1 , [ line - through]*in constructing @xmath135 , for each valid plan @xmath138 we consider every possible extension of @xmath141 to user @xmath150 in algorithm [ alg : naive ] , * * due to the fact that * each @xmath116 contains all valid plans @xmath141 with @xmath151 .",
    "we show in the next section that it is not necessary to store so much information to solve the wsp .",
    "we first introduce the notion of extension - equivalence , defined by an equivalence relation on the set of all plans .",
    "informally , the relation enables us to keep a single member of each equivalence class when building plans incrementally .",
    "[ def : ee ] given an instance @xmath13 of wsp , and two eligible plans @xmath38 and @xmath41 , define @xmath152 if the following conditions hold .    1 .   @xmath153 and @xmath154 ; 2 .",
    "@xmath155 is eligible if and only if @xmath156 is eligible , for any plan @xmath141 disjoint from @xmath38 and @xmath41 .",
    "then @xmath157 is an equivalence relation on the set of eligible plans and we say @xmath38 and @xmath41 are _ extension - equivalent _ if @xmath152 .    * *    [ ex : extequiv ] consider instance [ inst : mainexample ] .",
    "let @xmath158 be the function such that @xmath159 and @xmath160 .",
    "let @xmath161 be the function such that @xmath162 and @xmath163",
    ".    then @xmath38 and @xmath41 are both eligible , and @xmath153 and @xmath154 . for any plan",
    "@xmath141 disjoint from @xmath38 and @xmath41 , the plan @xmath155 will satisfy the constraints @xmath164 . thus @xmath155 is eligible if and only if @xmath141 is eligible .",
    "similarly @xmath156 is eligible if and only if @xmath141 is eligible .",
    "thus @xmath155 is eligible if and only if @xmath156 is eligible , and so @xmath38 and @xmath41 are extension - equivalent .",
    "suppose that we had a polynomial time algorithm to check whether two eligible plans are extension - equivalent .",
    "then in algorithm [ alg : naive ] , we could keep track of just one plan from each equivalence class : when constructing @xmath116 , we will only add @xmath41 to @xmath116 if there is no @xmath38 extension - equivalent to @xmath41 already in @xmath116 ; when we construct @xmath135 , we may use @xmath38 as a `` proxy '' for @xmath41 .",
    "if the number of extension - equivalent classes is small compared to the number of plans , then the worst - case running time of the algorithm may be substantially lower than that of algorithm  [ alg : naive ] .",
    "unfortunately , it is not necessarily easy to decide if two eligible plans are extension - equivalent , so this approach is not practical .",
    "however , we can always refine is a _ refinement _ of an equivalence relation @xmath165 if every equivalence class of @xmath166 is a subset of some equivalence class of @xmath167 extension equivalence to an equivalence relation for which equivalence _ is _ easy to determine .",
    "for example , the identity equivalence relation where each plan is only equivalent to itself is such a refinement .",
    "this refined equivalence relation may well have more equivalence classes than extension - equivalence , but substantially fewer than the identity relation , so we may obtain a better running time than the naive algorithm .",
    "[ def : similarity ] given an instance @xmath13 of wsp , let @xmath168 be the set of all eligible plans and let @xmath157 be an equivalence relation refining extension equivalence on @xmath168 .",
    "we say @xmath157 is a _ plan - indistinguishability relation _",
    "( with respect to @xmath19 ) if , for all eligible @xmath169 such that @xmath152 , and for any plan @xmath141 disjoint from @xmath38 and @xmath41 such that @xmath170 is eligible , we have that @xmath171 .     [ line - through]*as already observed , the identity relation is a trivial example of a plan - indistinguishability relation . for regular constraints , the relation @xmath157 such that @xmath152 if and only if @xmath172 and @xmath173 is a plan - indistinguishability relation . *    * *    let @xmath157 be the identity relation on plans .",
    "that is , @xmath152 if and only if @xmath172 , @xmath154 , and @xmath174 for all @xmath175 .",
    "then @xmath157 is a plan - indistinguishability relation .",
    "this shows that not every plan - indistinguishability relation is the extension - equivalence relation .",
    "indeed , the plans given in example [ ex : extequiv ] are extension - equivalent but not identical .",
    "recall that we refined extension equivalence since it may be hard to determine if two eligible plans are extension equivalent .",
    "it is therefore natural to assume the following :    [ ass : polycheckequiv ] given a plan - indistinguishability relation @xmath157 , it takes polynomial time to check whether two eligible plans are equivalent under  @xmath157 .",
    "the correctness of our algorithms does not depend on this assumption .",
    "however , a poor choice of the plan - indistinguishability relation could affect the running times .",
    "we now describe appropriate plan - indistinguishability relations for the constraints that we will be using . in each case",
    "determining if two eligible plans are equivalent under  @xmath157 will take polynomial time .",
    "[ lem : uirelation ] suppose all constraints are user - independent , and let @xmath176 be a relation such that @xmath177 if and only if    1 .",
    "@xmath153 and @xmath154 ; 2 .   for all @xmath178 , @xmath179 if and only if @xmath180 .",
    "then @xmath176 is a plan - indistinguishability relation on the set of eligible plans .    by definition of user - independent constraints ,",
    "if @xmath32 is an eligible plan and @xmath82 is a permutation , then @xmath181 is also eligible .",
    "suppose that @xmath177 and let @xmath182 and @xmath183 .",
    "let @xmath184 be a function such that @xmath185 for any task  @xmath186 .",
    "let @xmath187 be an arbitrary bijection ( note that @xmath188 by condition 2 of @xmath176 ) .",
    "let @xmath189 .",
    "then @xmath190 is a permutation such that @xmath191 .",
    "thus @xmath38 is eligible if and only if @xmath41 is eligible .    now consider two eligible plans @xmath169 such that @xmath177 , and a plan @xmath141 disjoint from @xmath38 and @xmath41 .",
    "first we show that @xmath192 .",
    "it is clear that @xmath193 and @xmath194 .",
    "now for any @xmath195 , if @xmath196 , then either @xmath197 are both in @xmath198 , in which case @xmath199 trivially , or @xmath197 are both in @xmath200 , in which case @xmath180 since @xmath177 , and hence @xmath199 .",
    "thus if @xmath196 then @xmath199 , and by a similar argument the converse holds .",
    "thus @xmath192 .",
    "furthermore , it follows by the argument in the first paragraph that @xmath155 is eligible if and only if @xmath156 is eligible .",
    "thus , the condition of definition [ def : similarity ] and the second condition of definition [ def : ee ] hold .",
    "the first condition of @xmath176 trivially satisfies the first condition of definition [ def : ee ] .",
    "thus , @xmath176 satisfies all the conditions of a plan - indistinguishability relation .    * *    [ ex : uiexample ] consider an instance of wsp with users @xmath201 and tasks @xmath202 in which all constraints are user - independent .",
    "let @xmath176 be the plan - indistinguishability relation given by lemma [ lem : uirelation ] .",
    "let @xmath203 be the constraint with scope @xmath204 such that @xmath203 is satisfied if and only if an even number of users are assigned to tasks in @xmath204 .",
    "let @xmath205 be the constraint with scope @xmath206 such that @xmath205 is satisfied if and only if either @xmath39 and @xmath207 are assigned to different users , or @xmath208 and @xmath209 are assigned to different users .",
    "suppose that @xmath203 and @xmath205 are the only constraints whose scope contains tasks from both @xmath210 and @xmath211 .",
    "now consider the plans @xmath212 such that @xmath213 , and @xmath214 , and suppose that @xmath215 are both eligible . then @xmath38 and @xmath41 are equivalent under @xmath176 .",
    "observe that for any plan @xmath141 disjoint from @xmath38 and @xmath41 , @xmath155 is eligible if and only if @xmath156 is eligible .",
    "as @xmath38 and @xmath41 both assign two users to @xmath216 , @xmath141 must assign two users to @xmath217 in order to satisfy @xmath203 .",
    "as @xmath38 and @xmath41 both assign @xmath39 and @xmath207 to the same user , @xmath141 must assign @xmath208 and @xmath218 to different users in order to satisfy @xmath205 .",
    "as long as these conditions are satisfied , and @xmath141 satisfies all constraints with scope in @xmath211 , then @xmath155 and @xmath156 will both be eligible .",
    "recall that given a binary relation @xmath53 on @xmath15 , a constraint of the form @xmath219 is satisfied by a plan @xmath32 if @xmath220 .",
    "recall that such constraints are not user - independent in general .",
    "[ lem : equivrelation ] suppose @xmath60 is an equivalence relation on @xmath15 .",
    "let @xmath221 be the equivalence classes of @xmath60 over @xmath15 .",
    "suppose all constraints are of the form @xmath222 or @xmath223 .",
    "let @xmath224 be a relation such that @xmath225 if and only if    1 .",
    "@xmath153 and @xmath154 ; 2 .   for all equivalence classes @xmath226 such that @xmath227 and @xmath228",
    ", we have that for all @xmath229 , @xmath230 if and only if @xmath231 .",
    "then @xmath224 is a plan - indistinguishability relation .",
    "it is clear that @xmath224 satisfies the first condition of definition [ def : ee ] .",
    "now suppose @xmath169 are eligible plans such that @xmath225 , and let @xmath141 be a plan disjoint from @xmath38 and @xmath41 .",
    "we first show that @xmath155 is eligible if and only if @xmath156 is eligible .",
    "suppose that @xmath155 is eligible .",
    "consider two tasks @xmath232 .",
    "if @xmath233 then @xmath156 will not falsify any constraint on @xmath186 and @xmath234 since it is equal to @xmath155 when restricted to @xmath235 and @xmath155 is eligible .",
    "if @xmath236 , then @xmath156 will not break any constraints since @xmath41 is eligible .",
    "so we may assume that @xmath237 , @xmath238 . by definition",
    ", @xmath239 if and only if there exists @xmath240 $ ] such that @xmath241 . but then @xmath242 and @xmath243 . therefore , by definition of @xmath224 , @xmath230 if and only if @xmath231 , for all @xmath229 . in particular , @xmath244 , and so @xmath245 . by a similar argument , if @xmath245 then @xmath239 . therefore , every constraint is satisfied by @xmath246 if and only if it is satisfied by @xmath247 .",
    "therefore if @xmath155 is eligible then so is @xmath156 , and by a similar argument the converse holds .",
    "it remains to show that @xmath248 .",
    "it is clear that the user and task sets are the same .",
    "as they have the same user set , the sets @xmath249 and @xmath250 are the same .",
    "furthermore , for each @xmath226 in this set and any @xmath251 , if @xmath252 then @xmath253 , as either @xmath229 , in which case @xmath254 and so @xmath231 , or @xmath255 , in which case @xmath256 . by a similar argument , if @xmath253 then @xmath252 . thus @xmath248 .    * *    [ ex : equivexample ] let @xmath60 be an equivalence relation on users with equivalence classes @xmath257 .",
    "consider an instance of wsp with users @xmath258 and tasks @xmath202 in which all constraints are of the form @xmath222 or @xmath223 .",
    "let @xmath224 be the plan - indistinguishability relation given by lemma [ lem : equivrelation ] .",
    "suppose that the only constraints whose scope contains tasks from both @xmath210 and @xmath211 are the constraints @xmath259 , @xmath260 and @xmath261 .",
    "now consider the plans @xmath212 such that @xmath262 , and @xmath263 , and suppose that @xmath215 are both eligible . then @xmath38 and @xmath41 are equivalent under @xmath224 .    observe that for any plan @xmath141 disjoint from @xmath38 and @xmath41 , @xmath155 is eligible if and only if @xmath156 is eligible .",
    "the only @xmath60-equivalence class with members in @xmath264 and members not in @xmath264 is the class @xmath265 .",
    "@xmath38 and @xmath41 both assign members of @xmath266 to exactly the set @xmath216 .",
    "thus for any plan @xmath141 disjoint from @xmath38 and @xmath41 , @xmath155 and @xmath156 will both satisfy the constraint @xmath267 whatever @xmath141 assigns to @xmath218 .",
    "they will both satisfy @xmath260 only if @xmath141 assigns @xmath218 to @xmath268 , and they will both satisfy @xmath269 only if @xmath141 does not assign @xmath209 to @xmath268 .",
    "as long as these conditions are satisfied , and @xmath141 satisfies all constraints with scope in @xmath211 , then @xmath155 and @xmath156 will both be eligible .",
    "in what follows , for each @xmath270 , we let @xmath271 $ ] denote the set of all eligible plans @xmath32 with @xmath272 an @xmath273 . in this section",
    "we will introduce an algorithm that works in a similar way to algorithm [ alg : naive ] , except that instead of storing all valid plans over a particular set of users or tasks , we will construct @xmath271$]-representative sets for each task set @xmath68 and certain user sets @xmath92 .",
    "* by definition , the equivalence classes of any plan - indistinguishability relation necessarily partition @xmath271 $ ] .",
    "hence any such equivalence class has a representation of the form @xmath274 , where @xmath275 is dependent on the constraint language . in the remainder of this section",
    "we describe the algorithm and give examples of these representations . *      * *    in our generic algorithm",
    ", we will construct plans iteratively , using at most one plan from each equivalence class under a plan - indistinguishability relation .",
    "the running time of the algorithm will depend on the number of equivalence classes under this relation , over certain sets of plans . to ensure that sets of equivalence classes can be ordered and therefore searched and sorted efficiently , we introduce the notion of encodings and patterns .",
    "loosely speaking , an _ encoding _ is a function that maps all the plans in a @xmath157-equivalence class to the same element ( the _ pattern _ of those plans ) .",
    "these encodings ensure logarithmic - time access and insertion operations into a representative set of plans , rather than the linear time that a naive method would allow .",
    "note that the use of encodings and patterns is not necessary for any of our fixed - parameter tractability results ; the same problems could be solved without the use of patterns and encodings in fixed - parameter time , but the function in @xmath1 would grow more quickly .",
    "[ line - through]*the time taken for searching a set for an element or inserting an element into a set is polynomial in the size of a set .",
    "therefore , when considering the running - time of fixed - parameter algorithms and using @xmath7 notation , we may ignore the costs of searching in a set and inserting into a set if its cardinality is polynomial in the size of the inputs to the problem . in the case of wsp ,",
    "the size of the sets of users , tasks and constraints are inputs to the problem , but the number of plans is @xmath276 in the worst case .",
    "thus , searching in a set of plans and inserting into a set of plans ( or a representative set ) must be explicitly accounted for in the running time of an algorithm to solve wsp .",
    "*    [ line - through]*for example , we will often want to determine , given a plan @xmath32 and some set of plans @xmath277 , whether @xmath277 contains a plan @xmath141 with @xmath278 .",
    "this can naively be done in time @xmath279 by checking whether @xmath278 for every @xmath280 . however , using the techniques described below , it is possible to do this in time @xmath281 .",
    "this makes a big difference when the size of @xmath277 is , for example , @xmath282 , as will be the case when we consider user - independent constraints . *    [ line - through]*thus to improve the running time of our algorithm ,",
    "we introduce the notion of encodings and patterns . loosely speaking ,",
    "an _ encoding _ is a function that maps all the plans in a @xmath157-equivalence class to the same element ( the _ pattern _ of those plans ) . by identifying all @xmath157-equivalent plans with the same pattern , we allow for some savings in the running time of our set operations . in particular , checking whether a set of plans contains a plan equivalent to a particular plan @xmath32 can be done more efficiently using patterns . *",
    "[ def : pat ] given an instance @xmath13 of wsp and a plan - indistinguishability relation @xmath157 , let @xmath168 be the set of all plans .",
    "let @xmath283 be some set and consider a function @xmath284 .",
    "for any @xmath270 , let @xmath285 = { \\textsc{enc}}(\\pi[x , t])$ ] .",
    "then we say @xmath286 is a _ @xmath157-encoding _ ( or an _ encoding for @xmath157 _ ) if , for any @xmath270 and any @xmath287 $ ] , we have that    1 .   @xmath288 if and only if @xmath152 ; 2 .",
    "@xmath289 can be calculated in time polynomial in @xmath290 ; 3 .",
    "there exists a linear ordering @xmath291 on @xmath285 $ ] such that , for @xmath292 $ ] , we can decide whether @xmath293 in time polynomial in @xmath290 .",
    "the elements of @xmath283 are called _",
    "@xmath157-patterns_. if @xmath294 then we say @xmath295 is the _",
    "@xmath157-pattern of @xmath32_.    the second and third conditions of definition  [ def : pat ] ensure that we may use encodings to organise our plans in a reasonable time . when @xmath157 is clear from the context , we will refer to a @xmath157-encoding as an _ encoding _ and @xmath157-patterns as _",
    "patterns_.    we note some complexity consequences of definition  [ def : pat ] in the following :    [ ass : settimes ] for an encoding of a plan - indistinguishability relation @xmath157 * and a set of patterns @xmath296 * , by assigning patterns in @xmath296 to the nodes of a balanced binary tree , we can perform the following two operations in time @xmath297 : ( i ) check whether @xmath298 , and ( ii ) insert a pattern @xmath299 into @xmath296 .",
    "recall that comparisons are polynomial in @xmath300 .",
    "now our result follows from the well - known properties of balanced binary trees , see , e.g. , @xcite .",
    "we now show that the plan - indistinguishability relations given in the previous section have encodings .",
    "we first need to define a lexicographic ordering .    given a totally ordered set @xmath301 , the ( total ) _ lexicographic order _",
    "@xmath302 on @xmath5-tuples from @xmath303 is defined as follows .",
    "we say that @xmath304 if either @xmath305 for all @xmath306 $ ] or there is an @xmath129 with @xmath307 such that @xmath305 for all @xmath308 .",
    "taking @xmath309 and @xmath310 we obtain the natural lexicographic order on @xmath311 .",
    "we can also lexicographically order the sets of disjoint subsets of an ordered set @xmath312 , where @xmath313 .",
    "we associate a @xmath1-tuple @xmath314 with each set @xmath315 of disjoint subsets @xmath316 of @xmath317 as follows .",
    "we have @xmath318 if @xmath319 . for @xmath320 ,",
    "* if there are @xmath308 and @xmath50 such that @xmath321 then @xmath322 , * otherwise @xmath323 , where @xmath324",
    ".    we will write @xmath325 .",
    "note that @xmath326 can be computed in time @xmath327 .",
    "for example , for @xmath328 and the sets @xmath329 and @xmath330 , we have @xmath331 and @xmath332 . so @xmath333 is lexicographically bigger than @xmath334 .",
    "[ cor : uiencoding ] let @xmath176 be the plan - indistinguishability relation given for a set of user - independent constraints in lemma [ lem : uirelation ] .",
    "then there exists an encoding for @xmath176 .",
    "let @xmath335 be an ordering of @xmath14 and @xmath32 a plan .",
    "let @xmath336 and let @xmath337 for a plan @xmath32 , let @xmath338 be the tuple @xmath339 .",
    "it is clear that @xmath340 if and only if @xmath177 , as @xmath341 if and only if @xmath342 in @xmath343 , for @xmath344 .",
    "furthermore it is clear that @xmath338 can be determined in polynomial time for any @xmath32 .",
    "it remains to define a linear ordering on @xmath285 $ ] for a given @xmath270 . for two patterns",
    "@xmath345 $ ] , we define @xmath293 if @xmath346 .",
    "let @xmath286 be the encoding given in the proof of corollary [ cor : uiencoding ] .",
    "let @xmath215 be the plans given in example [ ex : uiexample ] . then @xmath347 .",
    "[ cor : nestedequivencodingencoding ] let @xmath224 be the plan - indistinguishability relation given for a set of constraints on equivalence relations in lemma [ lem : equivrelation ] .",
    "then there exists an encoding for @xmath224 .",
    "suppose @xmath60 is an equivalence relation on users , and let @xmath348 be the equivalence classes of @xmath60 over @xmath15 .",
    "suppose all constraints are of the form @xmath222 or @xmath223 .",
    "for a plan @xmath32 , define @xmath338 to be @xmath349 where @xmath350    it is clear that @xmath340 if and only if @xmath225 , as @xmath351 if and only if @xmath352 , for @xmath353 .",
    "furthermore it is clear that @xmath338 can be determined in polynomial time for any @xmath32 .",
    "it remains to define a linear ordering on @xmath285 $ ] for a given @xmath270 .",
    "let @xmath354 be a plan .",
    "as @xmath355 is a set of disjoint subsets of @xmath89 , and @xmath68 has a natural order , we can order patterns in @xmath285 $ ] according to the lexicographic order of @xmath355 .",
    "let @xmath286 be the encoding given in the proof of corollary [ cor : nestedequivencodingencoding ] .",
    "let @xmath215 be the plans given in example [ ex : equivexample ]",
    ". then @xmath356 .",
    "we use the notion of _ diversity _ introduced in the next definition to analyse the running time of our generic algorithm .",
    "[ def : width ] let @xmath13 be an instance of wsp , with @xmath45 and @xmath46 , and suppose @xmath157 is a plan - indistinguishability relation with respect to @xmath19 . given an ordering @xmath119 of @xmath15 , let @xmath125 for each @xmath117 $ ] .",
    "let @xmath357 be the number of equivalence classes of @xmath157 over the set @xmath358 $ ] of eligible plans .",
    "then we define the _ diversity of @xmath157 with respect to @xmath119 _ to be @xmath359 } w_i$ ] .",
    "since our generic algorithm only stores one plan from each equivalence class under @xmath157 , we need the notion of a representative set .",
    "given an instance @xmath13 of wsp ,",
    "let @xmath360 be a set of eligible plans and let @xmath157 be a plan - indistinguishability relation .",
    "a set @xmath361 is said to be a _",
    "@xmath360-representative set with respect to @xmath157 _",
    "if the following properties hold :    1 .   @xmath362 ; every plan in @xmath361 is valid ; 2 .   for every valid @xmath363 ,",
    "there exists a @xmath364 such that @xmath365 .",
    "when @xmath157 is clear from context , we will say @xmath361 is a _",
    "@xmath360-representative set _ or a _ representative set for @xmath360_. our generic algorithm is based on finding plan - indistinguishability relations for which there exist small representative sets .    [",
    "thm : linear ]",
    "let @xmath13 be an instance of wsp , with @xmath45 and @xmath46 .",
    "let @xmath119 be an ordering of @xmath15 , and let @xmath125 for each @xmath117 $ ] , and @xmath366 .",
    "suppose @xmath157 has diversity @xmath367 with respect to @xmath119 .",
    "furthermore suppose that there exists a @xmath157-encoding @xmath286 .",
    "then @xmath13 can be solved in time @xmath368 .",
    "set @xmath369^ * = \\{(\\emptyset \\rightarrow \\emptyset)\\}$ ]    set @xmath370    the proof proceeds by proving correctness and bounding the running time of algorithm [ alg : generic1 ] , which solves wsp . to begin the proof , we give an overview of algorithm [ alg : generic1 ] .    * for each @xmath117 $ ] in turn and each @xmath25 , we will construct a representative set for @xmath371 $ ] , denoted by @xmath371^*$ ] .",
    "* as well as constructing the set @xmath371^*$ ] , we also maintain a companion set @xmath372^*$ ] = @xmath373^*)$ ] .",
    "this provides an efficient way of representing the equivalence classes of @xmath371^*$ ] .",
    "in particular , it allows us to check whether a given valid plan @xmath32 should be added to @xmath371^*$ ] , faster than by searching @xmath371^*$ ] linearly . * after @xmath374^*$ ] has been constructed , it remains to check whether @xmath374^*$ ] is non - empty , as if there exists any valid complete plan @xmath32 , there exists a valid complete plan @xmath375^*$ ] with @xmath376 .",
    "algorithm [ alg : generic1 ] gives the details on how to construct @xmath371^*$ ] for each @xmath129 and @xmath68 .",
    "the proof of correctness of algorithm [ alg : generic1 ] proceeds by induction .",
    "observe first that for the case of @xmath377^*$ ] , if @xmath378 then there is no possible plan in @xmath377 $ ] , and so we set @xmath377^ * = \\emptyset$ ] . if @xmath379 then the only possible plan is the empty plan @xmath380 .",
    "this plan is added to @xmath381^*$ ] , as it is trivially valid .",
    "thus @xmath382^*$ ] is a @xmath382$]-representative set for each @xmath68 .",
    "so now assume that for all @xmath25 the set @xmath358^*$ ] has been constructed and is a @xmath358$]-representative set .",
    "now consider the construction of @xmath383^*$ ] for some @xmath25 .",
    "it is clear that for any @xmath32 added to @xmath383^*$ ] , @xmath384 $ ] , and @xmath32 is eligible .",
    "furthermore @xmath32 is authorized , as it is the union of the authorized plans @xmath385 $ ] and @xmath386 .",
    "thus every plan in @xmath383^*$ ] is a valid plan in @xmath383 $ ] .",
    "on the other hand , suppose @xmath32 is a valid plan in @xmath383 $ ] .",
    "then let @xmath387 and @xmath388 , and let @xmath389 , so that @xmath390 . by assumption",
    ", there exists @xmath391^*$ ] such that @xmath392 .",
    "consider the plan @xmath393 .",
    "it is clear that @xmath394 will be considered during the algorithm .",
    "furthermore , as @xmath392 and @xmath390 , we have that @xmath395 . therefore @xmath394 is eligible ( as @xmath32 is eligible ) and also authorized ( as it is the union of two authorized plans ) . therefore @xmath394 is valid and will be added to @xmath383^*$ ] unless @xmath383^*$ ] already contains another plan @xmath157-equivalent to @xmath32 .",
    "thus , @xmath383^*$ ] contains a plan @xmath157-equivalent to @xmath32 , from which it follows that @xmath383^*$ ] is a @xmath383$]-representative set , as required .",
    "it remains to analyse the running time of the algorithm .",
    "by proposition [ ass : settimes ] , testing whether a pattern @xmath295 is in @xmath372^*$ ] and inserting @xmath295 into @xmath372^*$ ] takes @xmath396^*|))$ ] time .",
    "since by assumption [ ass : polycheckequiv ] and our assumption on the time to check constraints and authorizations it takes polynomial time to check eligibility , authorization and @xmath157-equivalence of plans , the running time of the algorithm is @xmath397^ * } \\log(|\\pi[u_{i+1},t]^*|))$ ] .",
    "it is clear by construction that @xmath371^*$ ] contains at most one plan for each @xmath157-equivalence class over @xmath371 $ ] , and so by definition @xmath398^*|\\le w$ ] for all @xmath399 .",
    "it follows that the running time of the algorithm is @xmath400 .    * *    rather than checking whether @xmath374^*$ ] is non - empty at the end of the algorithm , we could instead check whether @xmath401^*$ ] is empty after the construction of @xmath401^*$ ] for each @xmath129 .",
    "that is , we can stop our search as soon as we have a valid plan with task set @xmath14 .",
    "this is likely to lead to saving in the running time of an implementation of the algorithm . as this paper",
    "is concerned with the worst - case running time , which would be unaffected by this change , we perform the check at the end of the algorithm in the interest of clarity .      in this subsection , we show that wsp with user - independent constraints is fpt .",
    "let @xmath402 denote the @xmath1th bell number , the number of partitions of a set with @xmath1 elements .",
    "it is well - known that @xmath403 @xcite .",
    "[ lem : uiwidth ] let @xmath119 be any ordering of @xmath15 , and let @xmath176 be the plan - indistinguishability relation given in lemma [ lem : uirelation ]",
    ". then @xmath176 has diversity @xmath402 with respect to @xmath119 .    for any plan @xmath32 ,",
    "the set @xmath404 is a partition of the tasks in @xmath89 .",
    "furthermore , two plans that generate the same partition are equivalent under @xmath176 .",
    "therefore the number of equivalence classes of @xmath176 over @xmath371 $ ] is exactly the number of possible partitions of @xmath68 , which is @xmath405 .",
    "thus , @xmath402 is the required diversity .",
    "[ thm : ui ] if all constraints are user - independent , then wsp can be solved in time @xmath0 .",
    "let @xmath119 be any ordering of @xmath15 , and let @xmath176 be the plan - indistinguishability relation given in lemma [ lem : uirelation ] .    by lemma [ lem : uiwidth ]",
    ", @xmath176 has diversity @xmath402 with respect to @xmath119 .",
    "furthermore , by corollary [ cor : uiencoding ] , there exists an encoding for @xmath176 .",
    "therefore , we may apply theorem [ thm : linear ] with @xmath406 , to get an algorithm with running time @xmath407 .",
    "the running time @xmath0 obtained is optimal in the sense that no algorithm of running time @xmath2 exists , unless the eth fails . in the proof of the following theorem",
    ", we use a result of lokshtanov et al .",
    "( theorem 2.2 , @xcite ) .",
    "[ thm : lb ] there is no algorithm for wsp with user - independent constraints of running time @xmath408 , unless the eth fails .",
    "we give a reduction from the problem @xmath409 independent set : given an integer parameter @xmath1 and a graph @xmath410 with vertex set @xmath411\\}$ ] , decide whether @xmath410 has an independent set @xmath412 such that @xmath413 and for each @xmath414 $ ] , there exists @xmath129 such that @xmath415 .",
    "informally , @xmath409 independent set gives us a graph on a @xmath416 grid of vertices , and asks whether there is an independent set with one vertex from each row .",
    "lokshtanov et al .",
    "@xcite proved that there is no algorithm to solve @xmath409 independent set in time @xmath417 , unless the eth fails .",
    "consider an instance of @xmath409 independent set with graph @xmath410 .",
    "we will first produce an equivalent instance of wsp in which the constraints are not user - independent .",
    "we will then refine this instance to one with user - independent constraints .",
    "let @xmath418 be a set of @xmath1 users and @xmath419 a set of @xmath1 tasks .",
    "let the authorization lists be @xmath420 for all @xmath421 $ ]",
    ". for @xmath422 $ ] , let @xmath423 denote the constraint with scope @xmath424 , and which is satisfied by any plan @xmath32 unless @xmath425 and @xmath426 . for every pair of vertices @xmath427 which are adjacent in @xmath410 , add the constraint @xmath428 to @xmath19 .    we now show that @xmath13 is a yes - instance of wsp if and only if @xmath410 has an independent set with one vertex from each row .",
    "suppose @xmath13 is a yes - instance of wsp and let @xmath32 be a valid complete plan .",
    "then for each @xmath421 $ ] , let @xmath429 be the unique @xmath430 such that @xmath425 .",
    "then @xmath431\\}$ ] is a set with one vertex from each row in @xmath410 ; furthermore , as @xmath32 satisfies every constraint , no edge in @xmath410 contains more than one element of @xmath412 , and so @xmath412 is an independent set .",
    "conversely , suppose @xmath410 is a yes - instance of @xmath409 independent set .",
    "for each @xmath421 $ ] , let @xmath429 be an integer such that @xmath432 . then observe that @xmath433 is a valid complete plan .",
    "we now show how to reduce @xmath13 to an instance of wsp in which all constraints are user - independent .",
    "the main idea is to introduce some new tasks representing the users , and in the constraints , replace the mention of a particular user with the mention of the user that performs a particular task .",
    "create @xmath1 new tasks @xmath434 and let @xmath435 . let the authorization lists be @xmath436 for each @xmath437 and @xmath438 for each @xmath439.$ ] for each constraint @xmath423 in @xmath19 , let @xmath440 be the constraint with scope @xmath441 , which is satisfied by any plan @xmath32 unless @xmath442 and @xmath443 .",
    "let initially @xmath444 .",
    "now replace , in @xmath445 , every constraint @xmath423 with @xmath446 .",
    "since they are defined by equalities , and no users are mentioned , the constraints in @xmath445 are user - independent .",
    "we now show that @xmath447 is equivalent to @xmath13 .",
    "first , suppose that @xmath32 is a valid complete plan for @xmath13 .",
    "then let @xmath448 be the plan such that @xmath449 for all @xmath421 $ ] , and @xmath450 for all @xmath451 $ ] .",
    "it is easy to check that if @xmath32 satisfies every constraint of @xmath19 then @xmath141 satisfies every constraint of @xmath445 . since @xmath141 is an authorized and eligible plan",
    ", @xmath141 is a valid complete plan for @xmath452    conversely , suppose that @xmath141 is a valid complete plan for @xmath447 .",
    "since @xmath438 for each @xmath439,$ ] @xmath453 for every @xmath439.$ ] for each @xmath421 $ ] , let @xmath429 be the unique integer such that @xmath454 . then define @xmath455 by @xmath456 , and observe that all constraints in @xmath19 are satisfied by @xmath32",
    "so , @xmath32 is a valid complete plan for @xmath13 .",
    "it is known that restricting the wsp to have only equivalence relation constraints is enough to ensure fpt  @xcite .",
    "however , we can derive this result by applying our algorithm directly having shown the appropriate properties of the language of equivalence relation constraints .",
    "this serves to demonstrate the wide applicability of our approach .",
    "[ lem : equivwidth ] let @xmath224 be the plan - indistinguishability relation given for a set of equivalence relation constraints in lemma [ lem : equivrelation ] .",
    "then there exists an ordering @xmath119 of @xmath15 such that @xmath224 has diversity @xmath134 with respect to @xmath15 .",
    "suppose @xmath60 is an equivalence relation on users , and let @xmath348 be the equivalence classes of @xmath60 over @xmath15 .",
    "suppose all constraints are of the form @xmath222 or @xmath223 .",
    "let @xmath119 be an ordering of @xmath15 such that all the elements of @xmath226 appear before all the elements of @xmath457 , for any @xmath458 .",
    "thus , for any @xmath129 and any plan @xmath32 with @xmath459 , there is at most one integer @xmath460 such that @xmath461 .",
    "it follows that any two plans @xmath462 $ ] are @xmath224-equivalent , for any @xmath117 , t \\subseteq s$ ] , provided that @xmath463 if and only if @xmath464 for any @xmath465 . therefore @xmath224 has at most @xmath134 equivalence classes over @xmath371 $ ] , as required .",
    "[ thm : equiv ] suppose @xmath60 is an equivalence relation on @xmath15 .",
    "suppose all constraints are of the form @xmath222 or @xmath223 .",
    "then wsp can be solved in time @xmath466 .",
    "let @xmath119 be the ordering of @xmath15 given by lemma [ lem : equivwidth ] , and let @xmath224 be the plan - indistinguishability relation given in lemma [ lem : equivrelation ] .    by lemma [ lem : equivwidth ]",
    ", @xmath224 has diversity @xmath134 with respect to @xmath119 .",
    "furthermore by corollary [ cor : nestedequivencodingencoding ] , there exists an encoding for @xmath224 .",
    "therefore , we may apply theorem [ thm : linear ] with @xmath467 , to get an algorithm with running time @xmath468 .",
    "in this section we show how our approach allows us easily to combine constraint languages shown to be fpt for the wsp . we do not need to build bespoke algorithms for the new constraint language obtained , only to show that the two languages are in some sense compatible .",
    "this highlights the advantages of our approach over previous methods , which required the development of new algorithms when different constraint languages were combined in an instance of wsp ( see  @xcite , for example ) .",
    "[ thm : compatible ] let @xmath469 be an instance of wsp , and suppose @xmath165 is a plan - indistinguishability relation with respect to @xmath470 and @xmath166 is a plan - indistinguishability relation with respect to @xmath471 . given an ordering @xmath119 of @xmath15 , let @xmath472 be the diversity of @xmath165 with respect to @xmath119 and @xmath473 the diversity of @xmath166 with respect to @xmath119 .",
    "let @xmath157 be the equivalence relation such that @xmath376 if and only if @xmath474 and @xmath475 .",
    "then @xmath157 is a plan - indistinguishability relation with respect to @xmath476 , and @xmath157 has diversity @xmath477 with respect to @xmath119 .",
    "we first show that @xmath157 is a plan - indistinguishability relation with respect to @xmath476 .",
    "let @xmath32 and @xmath141 be eligible plans ( with respect to @xmath476 ) . as @xmath376 implies @xmath474 and @xmath165 satisfies the conditions of a plan - indistinguishability relation , it is clear that if @xmath376 then @xmath478 and @xmath479 .",
    "now consider a plan @xmath480 disjoint from @xmath32 and @xmath141 .",
    "as @xmath165 is a plan - indistinguishability relation with respect to @xmath470 and @xmath474 , we have that @xmath481 is @xmath470-eligible if and only if @xmath482 is .",
    "similarly @xmath481 is @xmath471-eligible if and only if @xmath482 is . observing that a plan is @xmath476-eligible if and only if it is @xmath470-eligible and @xmath471-eligible , this implies that @xmath481 is @xmath476-eligible if and only if @xmath482 is .",
    "thus we have that @xmath32 and @xmath141 are extension equivalent .    as @xmath165 and @xmath166",
    "are plan - indistinguishability relations , we have that @xmath483 and @xmath484 , and therefore @xmath485 .",
    "thus , @xmath157 satisfies all the conditions of a plan - indistinguishability relation .    to bound the diversity of @xmath157 with respect to @xmath119 , consider any @xmath25 and @xmath486 .",
    "it is enough to note that any @xmath157-equivalent plans in @xmath371 $ ] must be in the same @xmath165 and @xmath166-equivalence classes .",
    "as there are at most @xmath472 choices for the @xmath165-equivalence class and at most @xmath473 choices for the @xmath166 equivalence class , @xmath157 has at most @xmath477 equivalence classes over @xmath371 $ ] .",
    "[ rem : composeencodings ] given an encoding @xmath487 for @xmath165 and an encoding @xmath488 for @xmath166 , we may construct an encoding for @xmath157 .",
    "given a plan @xmath32 , let @xmath338 be the ordered pair @xmath489 .",
    "it is clear that @xmath490 if and only if @xmath376 .    given sets @xmath25 and @xmath486 , fix linear orderings of @xmath491)$ ] and @xmath492)$ ] .",
    "then let @xmath291 be the lexicographic ordering of @xmath373 ) = { \\textsc{enc}}_1(\\pi[u_i , t ] ) \\times { \\textsc{enc}}_2(\\pi[u_i , t]).$ ]    * there is nothing to stop us applying theorem [ thm : compatible ] multiple times , in order to get a plan - indistinguishability relation with bounded diversity for a union of several constraint languages .",
    "note that the diversity can be expected to grow exponentially with the number of languages in the union .",
    "thus , it makes sense to only apply theorem [ thm : compatible ] to the union of a small number of languages .",
    "however , as long as there is a fixed number of languages , and each has a plan - indistinguishability relation with fixed - parameter diversity , the resulting union of languages will also have a plan - indistinguishability relation with fixed - parameter diversity .",
    "*    we can now use this result directly to show that if all our constraints are either user independent or equivalence relation constraints , then the wsp is still fpt .",
    "suppose @xmath60 is an equivalence relation on @xmath15 .",
    "let @xmath13 be an instance of wsp , and suppose that all constraints are either of the form , @xmath493 , @xmath494 or user - independent constraints .",
    "then wsp can be solved in time @xmath495 .",
    "let @xmath496 be the set of constraints of the form @xmath493 , @xmath494 , and let @xmath497 be the remaining ( user - independent ) constraints .",
    "let @xmath119 be the ordering of @xmath15 given by lemma [ lem : equivwidth ] .",
    "by lemmas [ lem : equivrelation ] and [ lem : equivwidth ] , there exists a plan - indistinguishability relation @xmath224 for @xmath498 that has diversity @xmath134 with respect to @xmath119 .",
    "furthermore by corollary [ cor : nestedequivencodingencoding ] , @xmath224 has an encoding . by lemmas [ lem : uirelation ] and [ lem : uiwidth ]",
    ", there exists a plan - indistinguishability relation @xmath176 for @xmath497 that has diversity @xmath402 with respect to @xmath119 .",
    "furthermore by corollary [ cor : uiencoding ] , @xmath176 has an encoding .",
    "therefore by theorem [ thm : compatible ] , we may find a plan - indistinguishability relation @xmath157 for @xmath19 , such that @xmath157 has diversity @xmath499 with respect to @xmath119 and @xmath157 has an encoding .",
    "thus we may apply theorem [ thm : linear ] with @xmath500 , to get a running time of @xmath501 .",
    "in this paper we introduced [ line - through]*the first generic algorithm for wsp * * an algorithm applicable to a wide range of wsp problems , based on the notion of plan - indistinguishability , * and showed that our [ line - through]*generic * algorithm is powerful enough to be optimal , in a sense , for the wide class of user - independent constraints .",
    "the generic algorithm is also a fixed - parameter algorithm for equivalence relation constraints , which are not user - independent .",
    "we show how to deal with unions of different types of constraints using our generic algorithm . in particular , we prove that the generic algorithm is a fixed - parameter algorithm for the union of user - independent and equivalence relation constraints .    due to the difficulty of acquiring real - world workflow instances , wang and li @xcite used synthetic data in their experimental study .",
    "wang and li encoded wsp as a pseudo - boolean sat problem in order to use a pseudo - boolean sat solver sat4j to solve several instances of wsp . we have implemented our algorithm and compared its performance to sat4j on another set of synthetic instances of wsp in @xcite .",
    "these instances use @xmath502 , @xmath503 and @xmath504 , @xmath505 and user - independent constraints of three different types : we vary the number of constraints and the proportions of different constraints types ; each user is authorized for between @xmath506 and @xmath507 tasks for @xmath508 , between 1 and 10 tasks for @xmath509 , and between 1 and 12 tasks for @xmath510 .",
    "the algorithm was implemented in c++ and has been enhanced by the inclusion of techniques employed in csp solving , such as propagation .",
    "we also converted wsp instances into pseudo - boolean problems for processing by sat4j .",
    "all experiments were performed on a macbook pro computer having a 2.6 ghz intel core i5 processor and 8 gb 1600 mhz ddr3 ram ( running mac os x 10.9.2 ) .    for lightly - constrained instances ,",
    "sat4j was often faster than our algorithm , largely because the number of patterns considered by our algorithm is large for such instances .",
    "however , for highly - constrained instances , sat4j was unable to compute a decision for a number of instances ( because it was running out of memory ) , in sharp contrast to our algorithm which solved all instances .",
    "overall , on average , our algorithm was faster than sat4j and , in particular , was two orders of magnitude faster for @xmath511 .",
    "moreover , the time taken by our algorithm varies much less than that of sat4j , even for unsatisfiable instances , because the time taken is proportional to the product of the number of patterns and the number of users .",
    "( in particular , it is much less dependent on the number of constraints , a parameter that can cause significant fluctuations in the time taken by sat4j because this leads to a sharp increase in the number of variables in the pseudo - boolean encoding . )",
    "full details of our results may be found in  @xcite .",
    "bodlaender , m. cygan , s. kratsch , and j. nederlof . solving weighted and counting variants of connectivity problems parameterised by treewidth deterministically in single exponential time . in _ icalp _ , 2013 , to appear .",
    "j.  crampton , g.  gutin , and a.  yeo . on the parameterized complexity and kernelization of the workflow satisfiability problem .",
    ", 16(1):4 , 2013 . preliminary version in acm conf .",
    "comput . & communic .",
    "2012 , 857868 .",
    "a.  krokhin , a.  bulatov , and p.  jeavons . the complexity of constraint satisfaction : an algebraic approach . in _ structural theory of automata ,",
    "semigroups , and universal algebra _ ,",
    "volume 207 of _ nato science series ii : mathematics , physics and chemistry _ , pages 181213 .",
    "springer , 2005 ."
  ],
  "abstract_text": [
    "<S> the _ workflow satisfiability problem ( wsp ) _ is a problem of practical interest that arises whenever tasks need to be performed by authorized users , subject to constraints defined by business rules . </S>",
    "<S> we are required to decide whether there exists a _ </S>",
    "<S> plan _  an assignment of tasks to authorized users  such that all constraints are satisfied . </S>",
    "<S> several bespoke algorithms have been constructed for solving the wsp , optimised to deal with constraints ( business rules ) of particular types .     </S>",
    "<S> [ line - through]*the _ constraint satisfaction problem ( csp ) _ is a general paradigm for expressing , in a declarative format , problems where variables are to be assigned values from some domain . </S>",
    "<S> the assignments are constrained by restricting the allowed simultaneous assignments to some sets of variables . </S>",
    "<S> the csp is in general np - hard so there has been a considerable effort made into understanding the effect of restricting the type of allowed constraints . </S>",
    "<S> this research program is nearing completion and we can strongly conjecture precisely which kinds of constraint language lead to polynomial solvability . *    it is natural to see the wsp as a subclass of the _ constraint satisfaction problem ( csp ) _ in which the variables are tasks and the domain is the set of users . </S>",
    "<S> [ line - through]*in this case we have a unary authorization constraint on every task . </S>",
    "<S> * what makes the wsp distinctive as a csp is that we can assume that the number of tasks is very small compared to the number of users . </S>",
    "<S> this is in sharp contrast with traditional csp models where the domain is small and the number of variables is very large . as such , it is appropriate to ask for which constraint languages the wsp is fixed - parameter tractable ( fpt ) , parameterized by the number of tasks . </S>",
    "<S> this novel approach to the wsp , using techniques for csp , has enabled us to generalise and unify existing algorithms . * rather than considering algorithms for specific constraints </S>",
    "<S> , we design a generic algorithm which is a fixed - parameter algorithm for several families of workflow constraints considered in the literature . * </S>",
    "<S> we have identified a new fpt constraint language , user - independent constraint , that includes many of the constraints of interest in business processing systems . </S>",
    "<S> we are also able to prove that the union of fpt languages remains fpt if they satisfy a simple compatibility condition . </S>",
    "<S> [ line - through]*this begins a theory of fixed parameter tractability of constraint languages for the wsp . *    in this paper we present our generic algorithm , in which plans are grouped into equivalence classes , each class being associated with a _ </S>",
    "<S> pattern_. we demonstrate that our generic algorithm has running time @xmath0 , where @xmath1 is the number of tasks , for the language of user - independent constraints . </S>",
    "<S> we also show [ line - through]*that the generic algorithm is optimal for user - independent constraints in the following sense : * there is no algorithm of running time @xmath2 for user - independent constraints unless the exponential time hypothesis fails . </S>"
  ]
}