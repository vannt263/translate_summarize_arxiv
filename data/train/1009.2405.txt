{
  "article_text": [
    "in the realm of sequential programming , semantics , whether operational or denotational , provides a rich understanding of programming constructs and languages , and serves a broad range of purposes .",
    "these include , for instance , the study of verification techniques and the reconciliation of effects with functional programming via monads . with notorious difficulties ,",
    "these two styles of semantics have been explored for concurrent programming , and , by now , a substantial body of work provides various semantic accounts of concurrency .",
    "typically , that work develops semantics for languages with parallel - composition constructs and various communication mechanisms .",
    "surprisingly , however , that work provides only a limited understanding of threads .",
    "it includes several operational semantics of languages with threads , sometimes with operational notions of equivalence , e.g. ,  @xcite ; denotational semantics of those languages seem to be much rarer , and to address message passing rather than shared - memory concurrency , e.g. ,  @xcite . yet",
    "threads are in widespread use , often in the context of elaborate shared - memory systems and languages for which a clear semantics would be beneficial .    in this paper",
    ", we investigate a model of concurrent imperative programming with threads .",
    "we focus on _ cooperative _ threads which execute , without interruption , until they either terminate or else explicitly yield control .",
    "non - cooperative threads , that is , threads with preemptive scheduling , can be seen as threads that yield control at every step . in this sense , they are a special case of the cooperative threads that we study .",
    "cooperative threads appear in several systems , programming models , and languages . often without much linguistic support",
    ", they have a long history in operating systems and databases , e.g. ,  @xcite .",
    "cooperative threads also arise in other contexts , such as internet services and synchronous programming  @xcite .",
    "most recently , cooperative threads are central in two models for programming with transactions , automatic mutual exclusion ( ame ) and transactions with isolation and cooperation ( tic )  @xcite .",
    "ame is one of the main starting points for our research .",
    "the intended implementations of ame rely on software transactional memory  @xcite for executing multiple cooperative threads simultaneously",
    ". however , concurrent transactions do not appear in the high - level operational semantics of the ame constructs  @xcite . thus , cooperative threads and their semantics are of interest independently of the details of possible transactional implementations .",
    "we define and study three semantics for an imperative language with primitives for spawning threads , yielding control , and blocking execution .    1 .",
    "we obtain an operational semantics by a straightforward adaptation of previous work . in this semantics ,",
    "we describe the meaning of a whole program in terms of small - step transitions between states in which spawned threads are kept in a thread pool .",
    "this semantics serves as a reference point .",
    "we also define a more challenging compositional denotational semantics .",
    "the meaning of a command is a prefix - closed set of traces .",
    "prefix - closure arises because we are primarily interested in safety properties , that is , in `` may '' semantics .",
    "each trace is roughly a sequence of transitions , where each transition is a pair of stores , and a store is a mapping from variables to values .",
    "we establish adequacy and full - abstraction theorems with respect to the operational semantics .",
    "these results require several non - trivial choices in the definition of the denotational semantics .",
    "finally , we define a semantics based on the algebraic theory of effects .",
    "more precisely , we give an equational theory for the computational effects that underlie the language , and analyze threads in terms of the free algebra monad for this theory .",
    "this definition is more principled and systematic ; it explains threads with standard semantic structures , in the context of functional programming . as we show , furthermore",
    ", we obtain our denotational semantics as a special case .",
    "section  [ sec : calculus ] introduces our language and section  [ sec : osemantics ] defines its operational semantics .",
    "section  [ sec : dsemantics ] develops its denotational semantics .",
    "section  [ sec : adequacyfull ] presents our adequacy and full - abstraction theorems ( theorems  [ thm : adequacy ] and  [ thm : fullabs ] ) .",
    "section  [ sec : algebra ] concerns the algebraic of effects and the analysis of the denotational semantics in this monadic setting ( theorem  [ thm : view ] ) . section  [ sec : conclusion ] concludes .",
    "our language is an extension of a basic imperative language with assignments , sequencing , conditionals , and while loops ( imp  @xcite ) .",
    "programs are written in terms of a finite set of variables @xmath0 , whose values are natural numbers . in addition to those standard constructs ,",
    "our language includes :    1 .   a construct for executing a command in an asynchronous thread .",
    "informally , @xmath1 forks off the execution of @xmath2 . this execution is asynchronous , and will not happen if the present thread keeps running without ever yielding control , or if the present thread blocks without first yielding control .",
    "2 .   a construct for yielding control . informally",
    ", @xmath3 indicates that any pending thread may execute next , as may the current thread .",
    "3 .   a construct for blocking . informally",
    ", @xmath4 halts the execution of the entire program , even if there are pending threads that could otherwise make progress .",
    "we define the syntax of the language in figure  [ fig : language ] .",
    "we do not detail the constructs on numerical and boolean expressions , which are as usual .",
    "@xmath5{rclrll } b & \\in & { \\mathrm{bexp\\/}}&= & \\ldots \\\\ e & \\in & { \\mathrm{nexp\\/}}&= & \\ldots \\\\ c , d & \\in & { \\mathrm{com\\/}}&= & { \\mbox{\\tt skip}}\\\\          & & & { \\,\\,\\vert\\,\\ , } & { x:=e } \\qquad ( x \\in { \\mathrm{vars}})\\\\          & & & { \\,\\,\\vert\\,\\ , } & { c } ; { d } \\\\          & & & { \\,\\,\\vert\\,\\ , } & { \\mbox{\\tt if\\ } b \\mbox{\\tt \\ then\\ } c \\mbox{\\tt \\ else\\ } d}\\\\          & & & { \\,\\,\\vert\\,\\ , } & { \\mbox{\\tt while\\ } b \\mbox{\\tt \\ do\\ } c}\\\\          & & & { \\,\\,\\vert\\,\\ , } & { { \\mbox{\\tt async}}~c } \\\\          & & & { \\,\\,\\vert\\,\\ , } & { \\mbox{\\tt yield}}\\\\          & & & { \\,\\,\\vert\\,\\ , } & { \\mbox{\\tt block}}\\end{array}\\ ] ]    figure  [ fig : excode ] gives an illustrative example .",
    "it shows a piece of code that spawns the asynchronous execution of @xmath6 , then executes @xmath7 and yields , then resumes but blocks unless the predicate @xmath8 holds , then executes @xmath9 .",
    "@xmath10    the execution of @xmath6 may happen once the @xmath3 statement is reached .",
    "with respect to safety properties , the conditional blocking amounts to waiting for @xmath8 to hold . more generally , ame s @xmath11 can be written @xmath12 .",
    "more elaborate uses of blocking are possible too , and supported by lower - level semantics and actual transactional implementations  @xcite . in those implementations , blocking may cause a roll - back and a later retry at an appropriate time .",
    "we regard roll - back as an interesting aspect of some possible implementations , but not as part of the high - level semantics of our language , which is the subject of this work .",
    "thus , our language is basically a fragment of the ame calculus  @xcite .",
    "it omits higher - order functions and references .",
    "it also omits `` unprotected sections '' for non - cooperative code , particularly legacy code .",
    "non - cooperative code can however be modeled as code with pervasive calls to @xmath3 ( at least with respect to the simple , strong memory models that we use throughout this paper ; cf .",
    "see section  [ sec : conclusion ] for further discussion of possible extensions to our language .",
    "we give an operational semantics for our language . despite some subtleties",
    ", this semantics is not meant to be challenging .",
    "it is given in terms of small - step transitions between states .",
    "accordingly , we define states , evaluation contexts , and the transition relation .      @xmath13    as described in figure  [ fig : machine : a ] , a _ state _",
    "@xmath14 consists of the following components :    1 .   a _ store _",
    "@xmath15 which is a mapping of the given finite set @xmath0 of variables to a set @xmath16 of values , which we take to be the set of natural numbers ; 2 .   a finite sequence of commands @xmath17 which we call the _ thread pool _ ; 3 .   a distinguished _ active _ command @xmath2 .    we write @xmath18 $ ] for the store that agrees with @xmath15 except at @xmath19 , which is mapped to @xmath20 . we write @xmath21 for the boolean denoted by @xmath22 in @xmath15 , and @xmath23 for the natural number denoted by @xmath24 in @xmath15 , similarly",
    "we write @xmath25 for the concatenation of two thread pools @xmath17 and @xmath26 .      as usual ,",
    "a context is an expression with a hole @xmath27}$ ] , and an evaluation context is a context of a particular kind . given a context @xmath28 and an expression @xmath2 , we write @xmath29}$ ] for the result of placing @xmath2 in the hole in @xmath28 .",
    "we use the evaluation contexts defined by the grammar : @xmath30}{\\,\\,\\vert\\,\\,}{{{\\mathcal{e } } } } ; c \\end{array}\\ ] ]      @xmath31 } \\rangle } } & \\!{\\mathbin{\\longrightarrow}}\\ ! & { { \\langle \\sigma[x\\mapsto n],t,{{{\\mathcal{e}}}[{\\mbox{\\tt skip } } ] } \\rangle}}\\qquad \\quad \\ ; \\mbox{(\\rm if \\ } \\sigma(e ) = n ) & \\mbox { } \\\\}\\\\   { { { \\langle \\sigma , t,{{{\\mathcal{e}}}[{\\mbox{\\tt skip } } ; c ] } \\rangle } } & \\!{\\mathbin{\\longrightarrow}}\\ ! & { { \\langle \\sigma , t,{{{\\mathcal{e}}}[c ] } \\rangle } } & \\mbox { } \\\\}\\\\   { { { \\langle \\sigma , t,{{{\\mathcal{e}}}[{\\mbox{\\tt if\\ } \\!b\\ ! \\mbox{\\tt \\ then\\ } \\!c\\ ! \\mbox{\\tt \\ else\\ } \\!d } ] } \\rangle } } & \\!{\\mathbin{\\longrightarrow}}\\ ! & { { \\langle \\sigma , t,{{{\\mathcal{e}}}[c ] } \\rangle}}\\qquad \\qquad \\qquad\\qquad\\mbox{(\\rm if \\ }",
    "\\sigma(b ) = { \\mbox{\\tt true } } ) & \\mbox { } \\\\}\\\\   { { { \\langle \\sigma , t,{{{\\mathcal{e}}}[{\\mbox{\\tt if\\ } \\!b\\ !",
    "then\\ } \\!c\\ !",
    "else\\ } \\!d } ] } \\rangle } } & \\!{\\mathbin{\\longrightarrow}}\\ ! & { { \\langle \\sigma , t,{{{\\mathcal{e}}}[d ] } \\rangle } }         \\qquad \\qquad \\qquad\\qquad \\mbox{(\\rm if \\ }",
    "\\sigma(b ) = { \\mbox{\\tt false } } ) & \\mbox { } \\\\}\\\\   { { { \\langle \\sigma , t,{{{\\mathcal{e}}}[{\\mbox{\\tt while\\ } \\!b\\ ! \\mbox{\\tt \\ do\\ } \\!c } ] } \\rangle } } & \\!{\\mathbin{\\longrightarrow}}\\ ! & { { \\langle \\sigma , t,{{{\\mathcal{e}}}[{\\mbox{\\tt if\\ } \\!b\\ ! \\mbox{\\tt \\",
    "then\\ } \\!\\!(c ; { \\mbox{\\tt while\\ } \\!b\\ !",
    "do\\ } \\!c})\\!\\ ! \\mbox{\\tt \\ else\\ } \\!{\\mbox{\\tt skip } } } ] } \\rangle } } & \\mbox { } \\\\}\\\\   { { { \\langle \\sigma , t,{{{\\mathcal{e}}}[{{\\mbox{\\tt async}}~c } ] } \\rangle } } & \\!{\\mathbin{\\longrightarrow}}\\ ! & { { \\langle \\sigma , t.c,{{{\\mathcal{e}}}[{{\\mbox{\\tt skip } } } ] } \\rangle } } & \\mbox { } \\\\}\\\\   { { { \\langle \\sigma , t,{{{\\mathcal{e}}}[{\\mbox{\\tt yield } } ] } \\rangle } } & \\!{\\mathbin{\\longrightarrow}}\\ ! & { { \\langle \\sigma , t.{{{\\mathcal{e}}}[{\\mbox{\\tt skip}}]},{\\mbox{\\tt skip}}\\rangle } } & \\mbox { } \\\\}\\\\   { { { \\langle \\sigma , t.c.t',{\\mbox{\\tt skip}}\\rangle } } & \\!{\\mathbin{\\longrightarrow}}\\ ! & { { \\langle \\sigma , t.t',c \\rangle } } & \\mbox { } \\\\}\\end{array}\\ ] ]    a transition @xmath32 takes an execution from one state to the next .",
    "figure  [ fig : machinestrong ] gives rules that specify the transition relation .",
    "according to these rules , when the active command is @xmath33 , a command from the pool becomes the active command .",
    "it is then evaluated as such until it produces @xmath33 , yields , or blocks .",
    "no other computation is interleaved with this evaluation .",
    "each evaluation step produces a new state , determined by decomposing the active command into an evaluation context and a subexpression that describes a computation step ( for instance , a yield or a conditional ) .    in all cases at",
    "most one rule applies . in two cases , no rule applies .",
    "the first is when the active command is @xmath33 and the pool is empty ; this situation corresponds to _ normal _ termination .",
    "the second is when the active command is _ blocked _ , in the sense that it has the form @xmath34}$ ] ; this situation is an _",
    "abnormal _ termination .",
    "we write @xmath35 when @xmath32 via the last rule , and call this a _ choice _ transition .",
    "we write @xmath36 when @xmath32 via the other rules , and call this an _ active _ transition .",
    "active transitions are deterministic , i.e. , if @xmath36 and @xmath37 then @xmath38 .",
    "next we give a compositional denotational semantics for the same language . here , the meaning of a command is a prefix - closed set of traces , where each trace is roughly a sequence of transitions , and each transition is a pair of stores .",
    "the use of sequences of transitions goes back at least to abrahamson s work  @xcite and appears in various studies of parallel composition  @xcite .",
    "however , the treatment of threads requires some new non - trivial choices .",
    "for instance , transition sequences , as we define them , include markers to indicate not only normal termination but also the return of the main thread of control .",
    "moreover , although these markers are similar , they are attached to traces in different ways , one inside pairs of stores , the other not .",
    "such details are crucial for adequacy and full abstraction .    also crucial to full abstraction",
    "is minimizing the information that the semantics records .",
    "more explicit semantics will typically be more transparent , for instance , in detailing that a particular step in a computation causes the spawning of a thread , but will consequently fail to be fully abstract .",
    "section  [ sec : informal ] is an informal introduction to some of the details of the semantics .",
    "section  [ sec : trans ] defines transition sequences and establishes some notation .",
    "sections  [ sec : semcommand ] and  [ sec : pool ] define the interpretations of commands and thread pools , respectively .",
    "section  [ sec : eq ] discusses semantic equivalences .",
    "as indicated above , the meaning of a command will be a prefix - closed set of traces , where each trace is roughly a sequence of transitions , and each transition is a pair of stores .",
    "safety properties  which pertain to what `` may '' happen  are closed under prefixing , hence the prefix - closure condition .",
    "intuitively , when the meaning of a command includes a trace @xmath39 , we intend that the command may start executing with store @xmath40 , transform it to @xmath41 , yield , then resume with store @xmath42 , transform it to @xmath43 , yield again , and so on .",
    "in particular , the meaning of @xmath4 will consist of the empty sequence @xmath44 .",
    "the meaning of @xmath45 will consist of the empty sequence @xmath44 plus every sequence of the form @xmath46 , where @xmath15 is any store . here",
    ", the pair @xmath47 is a `` stutter '' that represents immediate yielding .",
    "if the meaning of a command @xmath2 includes @xmath48 and the meaning of a command @xmath49 includes @xmath50 , one might naively expect that the meaning of @xmath51 would contain @xmath52 , which is obtained by concatenation plus a simple local composition between @xmath53 and @xmath54 .",
    "unfortunately , this naive expectation is incorrect . in a trace @xmath39",
    ", some of the pairs may represent steps taken by commands to be executed asynchronously .",
    "those steps need not take place before any further command @xmath49 starts to execute .",
    "accordingly , computing the meaning of @xmath51 requires shuffling suffixes of traces in @xmath2 with traces in @xmath49 .",
    "the shuffling represents the interleaving of @xmath2 s asynchronous work with @xmath49 s work .",
    "we introduce a special return marker `` @xmath55 '' in order to indicate how the traces in @xmath2 should be parsed for this composition . in particular , when @xmath2 is of the form @xmath56 , any occurrence of `` @xmath55 '' in the meaning of @xmath57 will not appear in the meaning of @xmath2 .",
    "the application of @xmath58 erases any occurrence of `` @xmath55 '' from the meaning of @xmath57intuitively , because @xmath57 does not return control to its sequential context .",
    "for example , the meaning of the command @xmath59 will contain the trace @xmath60)(\\sigma',\\sigma'[x\\mapsto n ' ] \\ { \\mathrm{ret}})\\ ] ] for every @xmath15 and @xmath61 . on the other hand ,",
    "the meaning of the command @xmath62 will contain the trace @xmath60 \\ { \\mathrm{ret}})(\\sigma',\\sigma'[x\\mapsto n'])\\ ] ] for every @xmath15 and @xmath61 .",
    "the different positions of the marker @xmath55 correspond to different junction points for any commands to be executed next .",
    "if the meaning of @xmath2 contains @xmath63 and the meaning of @xmath49 contains @xmath64 , then the meaning of @xmath51 contains @xmath65 , where @xmath66 is a shuffle of @xmath67 and @xmath68 .",
    "notice that the marker from @xmath63 disappears in this combination .",
    "the marker in @xmath65 , if present , comes from @xmath64 .",
    "an analogous combination applies when the meaning of @xmath2 contains @xmath63 and the meaning of @xmath49 contains @xmath69 ( a trace that starts with a transition with a marker ) .",
    "moreover , if the meaning of @xmath2 contains a trace without any occurrence of the marker @xmath55 , then this trace is also in the meaning of @xmath51 : the absence of a marker makes it impossible to combine this trace with traces from @xmath49 .",
    "an additional marker , `` @xmath70 '' , ends traces that represent complete normally terminating executions .",
    "thus , the meaning of @xmath33 will consist of the empty sequence @xmath44 and every sequence of the form @xmath71 plus every sequence of the form @xmath72 .",
    "contrast this with the meaning of @xmath45 given above .",
    "it is possible for a trace to contain a @xmath55 marker but not a @xmath70 marker .",
    "thus , the meaning of @xmath73 will contain the empty sequence @xmath44 plus every sequence of the form @xmath71 , but not @xmath74 .",
    "more elaborately , the meaning of the code of figure  [ fig : excode ] will contain all traces of the form @xmath75 ) ( \\sigma[1 ] , \\sigma[0 ] ) ( \\sigma[0 ] , \\sigma[2 ] \\",
    "{ \\mathrm{ret } } ) { \\mathrm{done}}\\ ] ] where we write @xmath76 $ ] as an abbreviation for @xmath77 $ ] .",
    "these traces model normal termination after taking the @xmath78 branch of the conditional @xmath79 .",
    "the meaning will also contain all prefixes of those traces , which model partial executions  including those that take the @xmath80 branch of the conditional and terminate abnormally .",
    "the two markers are somewhat similar . however , note that @xmath81 is a prefix of @xmath82 , but @xmath83 is not a prefix of @xmath81 .",
    "such differences are essential .",
    "a _ plain transition _ is a pair of stores @xmath83 .",
    "a _ return transition _ is a pair of stores @xmath84 in which the second is adorned with the marker @xmath85 .",
    "transition _ is a plain transition or a return transition .",
    "a _ main - thread transition sequence _",
    "( hereunder simply : _ transition sequence _ ) is a finite ( possibly empty ) sequence , beginning with a sequence of transitions , of which at most one ( not necessarily the last ) is a return transition , and optionally followed by the marker @xmath70 if one of the transitions is a return transition .",
    "we write @xmath86 for the set of transition sequences .",
    "a _ pure transition sequence _ is a finite sequence of plain transitions , possibly followed by a marker @xmath70 .",
    "note that such a sequence need not be a transition sequence .",
    "it is _ proper _ if it is not equal to @xmath70 .",
    "we write @xmath87 for the set of pure transition sequences , and @xmath88 for the subset of the proper ones .",
    "we use the following notation :    1 .",
    "we typically let @xmath89 , @xmath68 , and @xmath66 range over transition sequences or pure transition sequences , and let @xmath90 range over non - empty ones .",
    "we write @xmath91 for the prefix relation between sequences @xmath89 and @xmath68 ( for both kinds of sequences , pure or not ) .",
    "for example , as mentioned above , we have that @xmath92 , but @xmath93 .",
    "a set @xmath94 is _ prefix - closed _ if whenever @xmath95 then @xmath96 .",
    "we write @xmath97 for the least prefix - closed set that contains @xmath94 .",
    "4 .   for a non - empty sequence of transitions @xmath90",
    ", we write @xmath98 for the first store of the first transition of @xmath90 . 5 .   for a transition sequence @xmath89 ,",
    "we write @xmath99 for the pure transition sequence obtained by _ cleaning @xmath89 _ , which means removing the @xmath85 marker , if present , from  @xmath89 .",
    "we let @xmath100 range over stores and stores with return markers .",
    "we let @xmath101 be the collection of the non - empty prefix - closed sets of transition sequences , and let @xmath102 be the collection of the non - empty prefix - closed sets of pure transition sequences . under the subset partial ordering , @xmath101 and @xmath102 are both @xmath103-cpos ( i.e. , partial orders with sups of increasing sequences ) with least element @xmath104 .",
    "we interpret commands as elements of @xmath101 .",
    "we use @xmath102 as an auxiliary @xmath103-cpo ; below it also serves for the semantics of thread pools .",
    "we also let @xmath105 be the sub-@xmath103-cpo of @xmath102 of all non - empty prefix - closed sets of proper pure transition sequences .",
    "we think of such sets as modeling asynchronous threads , spawned by an active thread ; the difference from @xmath106 is that the latter also contains an element that models the empty thread pool .",
    "we define a continuous cleaning function @xmath107 by : @xmath108 ( continuous functions are those preserving all sups of increasing sequences . )    we define the set @xmath109 of _ shuffles _ of a pure transition sequence @xmath89 with a sequence @xmath68 , whether a transition sequence or a pure transition sequence , as follows :    1 .",
    "if neither finishes with @xmath70 , their set of shuffles is defined as usual for finite sequences .",
    "if @xmath89 does not finish with @xmath70 , then a shuffle of @xmath89 and @xmath110 is a shuffle of @xmath89 and @xmath68 .",
    "similarly , if @xmath68 does not finish with @xmath70 , then a shuffle of @xmath111 and @xmath68 is a shuffle of @xmath89 and @xmath68 .",
    "a shuffle of @xmath111 and @xmath110 is a shuffle of @xmath89 and @xmath68 followed by @xmath70 .",
    "if both @xmath89 and @xmath68 are pure transition sequences then so is every element of @xmath112 ; if @xmath89 is a pure transition sequence and @xmath68 is a transition sequence , then every element of @xmath112 is a transition sequence .",
    "[ shuffle - assoc ] for any @xmath89,@xmath68 , and @xmath66 where either :    1 .",
    "all three are pure transition sequences , or 2 .",
    "@xmath89 and @xmath68 are pure transition sequences , and @xmath66 is a transition sequence    we have : @xmath113    we define a continuous _ composition _",
    "function @xmath114 by : @xmath115 composition is associative with two - sided unit , given by : @xmath116    we also define a continuous _ delay _ function @xmath117 by : @xmath118 thus , @xmath119 is @xmath94 preceded by all possible stutters ( plus @xmath120 ) .",
    "similarly , we define a continuous function @xmath121 by : @xmath122 thus , for @xmath123 , @xmath124 differs from @xmath119 only in the placement of the marker @xmath55 .      the denotational semantics @xmath125\\!]}{\\!:\\!}{\\mathrm{com\\/}}\\longrightarrow { \\mathrm{proc}}_{}\\ ] ] maps a command to a non - empty prefix - closed set of transition sequences .",
    "we define it in figure  [ fig : den ] . there",
    ", the interpretation of loops relies on the following approximations : @xmath126 the 0-th approximant corresponds to divergence , which here we identify with blocking .",
    "@xmath127\\ ! ]",
    "} & = & { * } \\\\    { [ \\![{{x:=e}}]\\ ! ] } & = & { \\ { ( \\sigma , \\sigma[x\\mapsto n ] \\   { \\mathrm{ret}}){\\mathrm{done}}\\mid   \\sigma \\in { { \\mathrm{store\\/ } } } , \\sigma(e ) = n\\}\\!\\!\\downarrow}\\\\     { [ \\ ! [ { c ; d } ] \\ ! ] } & = &   { [ \\![{c}]\\!]}{\\circ}{[\\![{d}]\\!]}\\\\    { [ \\![{{\\mbox{\\tt if\\ } b \\mbox{\\tt \\ then\\ } c \\mbox{\\tt \\ else\\ } d}}]\\ ! ] } & = &   { \\ { t \\mid t \\in { [ \\![{c}]\\ ! ] } , \\mbox{\\rm non - empty } , { \\mathrm{fst}(t)}(b ) = { \\mbox{\\tt true}}\\}\\!\\!\\downarrow } \\\\   & &   \\cup { \\ { t \\mid t \\in { [ \\![{d}]\\ ! ] } , \\mbox{\\rm non - empty } , { \\mathrm{fst}(t)}(b ) = { \\mbox{\\tt false}}\\}\\!\\!\\downarrow}\\\\    { [ \\![{{\\mbox{\\tt while\\ } b \\mbox{\\tt \\ do\\ } c}}]\\ ! ] } & = & \\cup_i { [ \\![{({\\mbox{\\tt while\\ } b \\mbox{\\tt \\ do\\ } c})_i}]\\!]}\\\\    {",
    "[ \\![{{{\\mbox{\\tt async}}~c}}]\\ ! ] } & = &   { \\mathrm{async}}({{{[\\![{c}]\\!]}}^c})\\\\    { [ \\![{{\\mbox{\\tt yield}}}]\\ ! ] } & = & { \\mathrm{d}}({*})\\\\    { [ \\![{{\\mbox{\\tt block}}}]\\ ! ] } & = & \\{{\\varepsilon}\\ }    \\end{array}\\ ] ]    we straightforwardly extend the semantics to contexts , so that @xmath128\\ ! ] } : { \\mathrm{proc } } _ { } \\rightarrow { \\mathrm{proc}}_{}\\ ] ] is a continuous function on @xmath101 .",
    "this function is defined by induction on the form of @xmath28 , with the usual clauses of the definition of @xmath129\\!]}$ ] plus @xmath130}}]\\!]}(p ) = p$ ] .",
    "[ prop : comp ] @xmath131}}]\\ ! ] }   = { [ \\![{{{\\mathcal{c}}}}]\\!]}({[\\![{c}]\\!]})$ ] . therefore , if @xmath132\\ ! ]",
    "} \\subseteq { [ \\![{d}]\\!]}$ ] then @xmath131}}]\\ ! ] }   \\subseteq { [ \\![{{{{\\mathcal{c}}}[d]}}]\\!]}$ ] .      as an auxiliary definition ,",
    "it is important to have also an interpretation of thread pools as elements of @xmath102 .",
    "we develop one in this section .",
    "we define a continuous shuffle operation @xmath133 at this level by : @xmath134 the shuffle operation is commutative and associative , with unit @xmath135 ; associativity follows from lemma  [ shuffle - assoc ] .",
    "we define the set of right shuffles @xmath136 of a pure transition sequence @xmath89 with a transition sequence @xmath68 by setting @xmath137 and @xmath138 we then define @xmath139 by : @xmath140 the use of the notation @xmath141 for both a unary and a binary operation is a slight abuse , though in line with the algebraic theory of effects : see the discussion in section  [ sec : algebra ] . in this regard",
    "note the equality @xmath142 ( and the equality @xmath143\\!]}{\\circ}p = { \\mathrm{d}}(p)$ ] points to the corresponding relationship between @xmath144 and @xmath143\\!]}$ ] ) .",
    "we define the semantics of thread pools by : @xmath145\\ ! ] } = { { { [ \\![{c_1}]\\!]}}^c}\\bowtie \\ldots \\bowtie { { { [ \\![{c_{n}}]\\!]}}^c } \\quad \\mbox {      ( $ n \\geq 0$)}\\ ] ] intending that @xmath146\\ ! ] } = i$ ] . for any thread pool @xmath17 , @xmath147\\!]}$ ] iff @xmath148 ( because , for all @xmath2 , @xmath149\\!]}^{c}$ ] and , for all @xmath94 and @xmath150 , @xmath151 iff @xmath152 and @xmath153 ) .",
    "further , we set @xmath154\\ ! ] } = { \\mathrm{async}}({[\\![{t}]\\!]},{[\\![{c}]\\!]})$ ] .    for all @xmath155 and @xmath156",
    "we have :    1 .",
    "@xmath157 2 .",
    "@xmath158    for the first part , one shows for all pure transition sequences @xmath89 and @xmath68 and transition sequences @xmath66 that : @xmath159 to this end , one proceeds by cases on @xmath66 , using lemma  [ shuffle - assoc ] .",
    "the second part is obvious .",
    "an attractive application of denotational semantics is in proving equivalences and implementation relations between commands .",
    "such denotational proofs tend to be simple calculations . via adequacy and full - abstraction results ( of the kind established in section  [ sec : adequacyfull ] ) , one then obtains operational results that would typically be much harder to obtain directly by operational arguments .    as an example",
    ", we note that we have the following equivalence : @xmath160\\ ! ] } =   { [ \\![{({{\\mbox{\\tt async}}~(c ; { { \\mbox{\\tt async}}~(d)})}}]\\!]}\\ ] ] this equivalence follows from three facts :    1 .",
    "we have : @xmath161\\!]}}^c } & =   & { { { [ \\![{{{\\mbox{\\tt async}}~(d)}}]\\!]}}^c}\\\\ &   = & { \\ { ( \\sigma , \\sigma ) { { u}^c } \\mid \\sigma \\in { { \\mathrm{store\\/ } } } , u \\in { [ \\![{d}]\\!]}\\}\\!\\!\\downarrow } ; \\end{array}\\ ] ] 2 .   whenever @xmath162\\!]}}^c } = { { { [ \\![{d_2}]\\!]}}^c}$ ] , @xmath163\\!]}}^c } = { { { [ \\![{c ; d_2}]\\!]}}^c}$ ] ; 3 .   whenever @xmath162\\!]}}^c } = { { { [ \\![{d_2}]\\!]}}^c}$ ] , @xmath164\\ ! ] } = { [ \\![{{{\\mbox{\\tt async}}~(d_2)}}]\\!]}$ ] .",
    "this particular equivalence is interesting for two reasons :    1 .",
    "it models an implementation strategy ( in use in ame ) where , when executing @xmath165 , the @xmath3 causes a new asynchronous thread for @xmath49 to be added to the thread pool .",
    "it illustrates one possible , significant pitfall in more explicit semantics .",
    "as discussed above , such a semantics might detail that a particular step in a computation causes the spawning of a thread .",
    "more specifically , it might extend transitions with an extra trace component : a triple @xmath166 might represent a step from @xmath15 to @xmath100 that spawns a thread that contains the trace  @xmath89 .",
    "with such a semantics , the meanings of @xmath167 and @xmath168 would be different , since they have different spawning behavior .",
    "many other useful equivalences hold .",
    "for instance , we have : @xmath169\\ ! ] } =   { [ \\![{{x:=n'}}]\\!]}\\ ] ] trivially . for every @xmath2",
    ", we also have : @xmath170\\ ! ] } =   { [ \\![{{x:=n } ; { { \\mbox{\\tt async}}~(c)}}]\\!]}\\ ] ] and , for every @xmath2 and @xmath49 , we have : @xmath171\\ ! ] } =   { [ \\![{{{\\mbox{\\tt async}}~(d ) } ; { { \\mbox{\\tt async}}~(c)}}]\\!]}\\ ] ] another important equivalence is : @xmath172\\ ! ] } = { [ \\![{{\\mbox{\\tt block}}}]\\!]}\\ ] ] thus , the semantics does not distinguish an infinite loop which never yields from immediate blocking .",
    "on the other hand , we have : @xmath173\\ ! ] } \\neq { [ \\![{{\\mbox{\\tt block}}}]\\!]}\\ ] ] the command @xmath174 generates unbounded sequences of stutters @xmath175 .",
    "similarly , we have : @xmath176\\ ! ] } \\neq { [ \\![{{\\mbox{\\tt yield}}}]\\!]}\\ ] ] alternative semantics that would distinguish @xmath177 from @xmath4 or that would @xmath174 with @xmath4 and @xmath178 with @xmath3 are viable , however .",
    "we briefly discuss those variants and others in section  [ sec : conclusion ] .",
    "we leave as subjects for further research the problems of axiomatizing and of deciding equivalence and implementation relations , and the related problem of program verification , perhaps restricted to subsets of the language  even , for example , to the subset with just composition , spawning , and yielding .",
    "there is a large literature on axiomatization and decidability in concurrency theory ; see , e.g. ,  @xcite for discussion and further references .",
    "also , recent results on the automatic verification of asynchronous programs appear rather encouraging  @xcite ; some of their ideas might be applicable in our setting .",
    "trace - based semantics can also be given for variants and enhancements of our basic imperative language .",
    "here we illustrate this point by considering two such enhancements , which illustrate the use of @xmath55 and @xmath70 .",
    "section  [ sec : conclusion ] briefly considers other possible language features .",
    "while cleaning maps a transition sequence sequence to a proper pure transition sequence , a _ marking _ function maps a proper pure transition sequence to a transition sequence . for a proper pure transition sequence @xmath89 , we define @xmath180 by : @xmath181 thus , @xmath180 includes a marker @xmath55 only if @xmath89 contains a marker @xmath70 ( that is , if @xmath89 corresponds to a terminating execution ) ; the marker @xmath55 is on the last transition of @xmath180 , intuitively indicating that control is returned to the sequential context when execution terminates .    much as for cleaning , we extend marking to non - empty prefix - closed sets of proper pure transition sequences : @xmath182 using this extension , we can define the meaning of a construct @xmath179 , inspired by that of the x10 language  @xcite .",
    "we set : @xmath183\\ ! ] } = { { ( { { { [ \\![{c}]\\!]}}^c})}^m}\\ ] ]    the intent is that @xmath184 executes @xmath2 and returns control when all activities spawned by @xmath2 terminate .",
    "for instance , in @xmath185 , the assignment @xmath7 will execute only after @xmath6 is done .",
    "in contrast , in @xmath186 , the assignments have the opposite ordering .",
    "however , @xmath187 is not equivalent to @xmath6 , but rather to @xmath188 . beyond this simple example , @xmath179 can be applied to more complex commands , possibly with nested forks , and ensures that all the activities forked terminate before returning control .",
    "the definition of parallel composition relies on familiar themes : the use of shuffling , and the decomposition of parallel composition into two cases .",
    "the cases correspond to whether the left or the right argument of parallel composition takes the first step .",
    "we define parallel composition at the level of transition sequences by letting @xmath189 and @xmath190 be the least sets that satisfy prefix - closure and the following clauses :    1 .",
    "@xmath191 and @xmath192 , 2 .",
    "@xmath193 , 3 .   if @xmath194 , then @xmath195 , 4 .   if @xmath196 then @xmath197 .    extending this function to @xmath198",
    "we can define the meaning of a parallel - composition construct : @xmath199\\ ! ] } = { [ \\![{c}]\\ ! ] } { { \\mathrel}{\\mid\\mid}}{[\\![{d}]\\!]}\\ ] ] the reader may verify that parallel composition , as defined here , has the expected properties , for instance that it is commutative and associative with unit @xmath33 .",
    "it is also worth noting that ( under mild assumptions on the available expressions ) the binary nondeterministic choice operator @xmath200 considered in section  [ resumptions ] is definable from parallel composition .",
    "the converse also holds , under restricted circumstances : if all occurrences of @xmath3 in @xmath2 and @xmath49 occur inside an @xmath201 then we have : @xmath202\\ ! ] } = { [ \\![{c ; d}]\\ ! ] } \\cup { [ \\![{d;c}]\\!]}\\ ] ]",
    "in this section we establish that the denotational semantics of section  [ sec : dsemantics ] coincides with the operational semantics of section  [ sec : osemantics ] , and is fully abstract .",
    "the adequacy theorem ( theorem  [ thm : adequacy ] ) , which expresses the coincidence , says that the traces that the denotational semantics predicts are exactly those that can happen operationally .",
    "these traces may in general represent the behavior of a command in a context . as a special case",
    ", the adequacy theorem applies to runs , which are essentially traces that the command can produce on its own , i.e. , with an empty context .",
    "this special case is spelled out in corollary  [ thm : adequacy - runs ] which states that the runs that the denotational semantics predicts are exactly those that can happen operationally    the full - abstraction theorem ( theorem  [ thm : fullabs ] ) states that two commands @xmath2 and @xmath49 have the same set of traces denotationally if , and only if , they produce the same runs in combination with every context . in particular , observing runs , we can not distinguish @xmath2 and @xmath49 in any context .",
    "note that , given corollary  [ thm : adequacy - runs ] , we may equivalently speak of runs denotationally or operationally .",
    "we comment on other possible notions of observation , and the corresponding full - abstraction results , below .",
    "section  [ sec : runs ] defines runs precisely .",
    "sections  [ sec : adequacy ] and  [ sec : fullabstractionii ] present our adequacy and full - abstraction results , respectively .      a pure transition sequence _",
    "generates a run _ if , however it can be written as @xmath203 , we have @xmath204 . if @xmath205 is such a pure transition sequence , we set @xmath206 and @xmath207 .",
    "a transition sequence @xmath89 _ generates a run _ if @xmath99 does , and then we set @xmath208 .",
    "if a pure transition sequence @xmath89 generates a run , then it can be easily be recovered from @xmath209 : the run @xmath210 maps back to @xmath211 and the run @xmath212 maps back to @xmath213 since each non - empty run contains at least two elements , this definition applies when @xmath214 and @xmath215 .",
    "we write @xmath216 for the set of runs generated by ( pure ) transition sequences in @xmath94 .",
    "[ equivalences ] the following equalities hold :    1 .",
    "@xmath217}}]\\ ! ] } = { [ \\![{{\\mbox{\\tt block}}}]\\!]}$ ] 2 .",
    "@xmath218\\ ! ] } = { [ \\![{c}]\\!]}$ ] 3 .",
    "@xmath219}}]\\ ! ] } = { \\mathrm{async}}({{{[\\![{d}]\\!]}}^c},{[\\![{{{{\\mathcal{e}}}[{\\mbox{\\tt skip}}]}}]\\ ! ] } ) $ ] 4",
    ".   @xmath220}}]\\!]}}^c } = { { { \\mathrm{async}}({{{[\\![{{{{\\mathcal{e}}}[{\\mbox{\\tt skip}}]}}]\\!]}}^c},{[\\![{{\\mbox{\\tt skip}}}]\\!]})}^c } $ ] 5 .   for all @xmath221 ( equivalently @xmath222\\!]}$ ] ) , @xmath223\\ !",
    "] } = \\bigcup \\ { { { { [ \\![{t'.t '' , c}]\\!]}}^c } \\mid t = t'.c.t''\\}\\ ] ]    the first part is immediate from the semantics of @xmath4 and the definition of composition .",
    "the second part holds as @xmath224 is a unit for composition .",
    "the third part follows from the facts that @xmath142 and that composition is associative with unit @xmath224 .    for the fourth part , using the third part one sees that it is enough to show that for every @xmath225 we have : @xmath226}}]\\!]}}^c } = { { { [ \\![{{{\\mbox{\\tt async}}~{{{\\mathcal{e}}}[{\\mbox{\\tt skip}}]}}}]\\!]}}^c}\\ ] ] as composition is associative with unit @xmath224 , this is equivalent to showing that , for every @xmath2 we have : @xmath227\\!]}}^c } = { { { \\mathrm{async}}({{{[\\![{c}]\\!]}}^c})}^c}\\ ] ] which follows immediately , expanding the definitions .",
    "the proof of the fifth part is a straightforward verification .",
    "[ immediately_blocked ] if @xmath2 is blocked then , for all @xmath17 , @xmath154\\!]}=\\{{\\varepsilon}\\}$ ] .",
    "we calculate :    @xmath228}}]\\ ! ] } & = & { \\mathrm{async}}({[\\![{t}]\\!]},{[\\![{{{{\\mathcal{e}}}[{\\mbox{\\tt block}}]}}]\\ ! ] } ) & \\\\                                & = & { \\mathrm{async}}({[\\![{t}]\\!]},{[\\![{{\\mbox{\\tt block}}}]\\ ! ] } ) & \\mbox { ( by lemma~\\ref{equivalences})}\\\\                                & = & \\{{\\varepsilon}\\ } &       \\end{array}\\ ] ]    [ skip ] @xmath229\\!]}= { \\{(\\sigma,\\sigma \\ { \\mathrm{ret}})v\\mid v \\in   { [ \\![{t}]\\!]}\\}\\!\\!\\downarrow}$ ] .",
    "immediate from the definition of @xmath141 .",
    "the next lemma applies when @xmath2 is neither @xmath33 nor blocked .",
    "[ neither_skip_or_blocked ] suppose that @xmath230 .",
    "then , for any @xmath231 , @xmath232\\!]}}^c}$ ] iff @xmath233\\!]}}^c}$ ] .",
    "we divide into cases according to the form of @xmath2 . in the case where @xmath2 has the form @xmath234}$ ] we have @xmath235 , @xmath236 and @xmath237}$ ] .",
    "so , by lemma  [ equivalences ] , we have @xmath238\\ ! ] } = { [ \\![{t , c}]\\!]}$ ] , and we are done .    in the case where @xmath2 instead has the form @xmath239}$ ] , we have @xmath235 , @xmath240 and @xmath241}$ ] and we calculate : @xmath242\\ ! ] } } & = & { { [ \\![{t.d,{{{\\mathcal{e}}}[{\\mbox{\\tt skip}}]}}]\\!]}}&\\\\                           & = & { { \\mathrm{async}}({[\\![{t}]\\!]},{\\mathrm{async}}({{{[\\![{d}]\\!]}}^c},{[\\![{{{{\\mathcal{e}}}[{\\mbox{\\tt skip}}]}}]\\ ! ] } ) ) } & \\\\                           & = & { [ \\![{t,{{{\\mathcal{e}}}[{{\\mbox{\\tt async}}~d}]}}]\\ ! ] } & \\mbox { ( by lemma~\\ref{equivalences})}\\\\                           & = & { [ \\![{t , c}]\\ ! ] }           \\end{array}\\ ] ] and we are done .    in the case where @xmath2 instead has the form @xmath243}$ ]",
    ", we have @xmath235 , @xmath244}$ ] , @xmath245 and , again using lemma  [ equivalences ] , we calculate : @xmath246\\!]}}^c } & = & { { { [ \\![{t.{{{\\mathcal{e}}}[{\\mbox{\\tt skip}}]},{\\mbox{\\tt skip}}}]\\!]}}^c}&\\\\                           & = & { { { \\mathrm{async}}({[\\![{t}]\\!]},{\\mathrm{async}}({{{[\\![{{{{\\mathcal{e}}}[{\\mbox{\\tt skip}}]}}]\\!]}}^c},{[\\![{{\\mbox{\\tt skip}}}]\\ ! ] } ) ) } ^c } & \\\\                           & = & { { { [ \\![{t,{{{\\mathcal{e}}}[{\\mbox{\\tt yield}}]}}]\\!]}}^c } & \\\\                           & = & { { { [ \\![{t , c}]\\!]}}^c }               \\end{array}\\ ] ] and we are done .    in the next case , @xmath2 has the form @xmath247}$ ] , and we have @xmath248 $ ] , @xmath236 and @xmath241}$ ] . here",
    "@xmath154\\ ! ] } = { [ \\![{t , { x:=e};{{{\\mathcal{e}}}[{\\mbox{\\tt skip}}]}}]\\!]}$ ] .",
    "so we have that : @xmath249\\ ! ] }      $ ] holds iff @xmath250}}]\\!]}$ ]    otherwise , @xmath2 has one of the forms @xmath251}$ ] or @xmath252}$ ] and we proceed much as in the previous case .    [ soundness ] suppose that @xmath253 with @xmath254\\!]}}^c}$ ]",
    ". then @xmath255\\!]}}^c}$ ] .",
    "this follows from lemmas  [ skip ] and  [ neither_skip_or_blocked ] .    for the proof of the converse of this lemma",
    ", we proceed by an induction on the size of loop - free commands .",
    "we then extend to general commands by expressing their semantics in terms of the semantics of their approximations by loop - free commands .",
    "the _ size _ of a loop - free command is defined by structural recursion : @xmath256 { |{\\mbox{\\tt if\\ } b \\mbox{\\tt \\ then\\ } c \\mbox{\\tt \\ else\\ } d}| } = { |c;d| } = { |c| } + { |d| } \\end{array}\\ ] ] note that if @xmath257 and @xmath2 is loop - free , then so is @xmath258 and , further , @xmath259 .",
    "the _ approximation _ relation @xmath260 between loop - free commands @xmath2 and general commands @xmath49 is defined to be the least such relation closed under all non - looping program constructs and such that , for any @xmath22 , @xmath2 , @xmath49 , and @xmath261 : @xmath262 this relation is extended to thread pools and contexts in the obvious way : we write @xmath263 and @xmath264 for these extensions .",
    "[ approximation1 ] suppose that @xmath265 , @xmath260 , and , further , that @xmath266 . then , for some @xmath267 with @xmath268 and @xmath269 , @xmath270 { { \\langle \\sigma',u',d ' \\rangle}}$ ] .",
    "one first notes that , for any @xmath2 , @xmath49 , if @xmath271 } { \\preceq}d$ ] then @xmath49 has the form @xmath272 $ ] where @xmath273 and @xmath274 .",
    "the proof then divides into cases according to the rule used to show that @xmath266 .",
    "for example , suppose we have @xmath275}$ ] and @xmath276 .",
    "we know that @xmath49 must have the form @xmath272 $ ] where @xmath273 and @xmath277 .",
    "suppose now that @xmath278 has the form @xmath279 .",
    "then we must have , for some @xmath261 that @xmath280 where @xmath281 .",
    "but then we observe that @xmath282 \\rangle } }   { \\mathbin{\\longrightarrow_a}}{{\\langle \\sigma , u,{\\mathcal e}'[d'';d ] \\rangle}}\\ ] ] and the conclusion follows .",
    "the other cases are straightforward .",
    "next we define the _ approximants _ @xmath283 of a command @xmath2 by induction on @xmath284 and structural recursion on @xmath2 , beginning with the case where @xmath2 has one of the forms @xmath33 , @xmath4 , @xmath285 , or @xmath3 , when @xmath286 , and continuing with : @xmath287 for any @xmath2 one shows that @xmath288 .",
    "[ approximation2 ] @xmath289    1 .",
    "if @xmath260 then @xmath132\\ ! ] } \\subseteq { [ \\![{d}]\\!]}$ ] .",
    "2 .   for any command @xmath49 : @xmath290\\ ! ] } = \\bigcup_i { [ \\![{d^{(i)}}]\\!]}\\ ] ]    the first part is evident using the monotonicity of the semantics of the program constructors and the semantic of loops . for the second part",
    ", we proceed by structural induction on @xmath49 .",
    "all cases are straightforward , using the continuity of the program constructors , except for loops where we calculate : @xmath291\\ ! ] } & = & \\bigcup_i { [ \\![{({\\mbox{\\tt while\\ } b \\mbox{\\tt \\ do\\ } d})_i}]\\!]}\\\\                            & = & \\bigcup_i { [ \\![{({\\mbox{\\tt while\\ } b \\mbox{\\tt \\ do\\ } [ \\;]})_i}]\\!]}({[\\![{d}]\\!]})\\\\                            & = & \\bigcup_i{[\\![{({\\mbox{\\tt while\\ } b \\mbox{\\tt",
    "\\ do\\ } [ \\;]})_i}]\\ ! ] }                                     ( \\bigcup_i { [ \\![{d^{(i)}}]\\!]})\\\\                            & = & \\bigcup_i { [ \\![{({\\mbox{\\tt while\\ } b \\mbox{\\tt \\ do\\ } d^{(i)}})_i}]\\!]}\\\\                                        & = &   \\bigcup_i { [ \\![{({\\mbox{\\tt while\\ } b \\mbox{\\tt \\ do\\ } d})^{(i)}}]\\ ! ] } \\rlap{\\hbox to127 pt{\\hfill\\qed } }      \\end{array}\\ ] ]    we can now establish the converse of lemma  [ soundness ] .",
    "[ progress ] suppose that @xmath255\\!]}}^c}$ ] . then @xmath292{\\mathbin{\\longrightarrow_a}}^ *   { { \\langle \\sigma',t',{\\mbox{\\tt skip}}\\rangle}}$ ] for some @xmath26 with @xmath254\\!]}}^c}$ ] .",
    "we begin by proving this for loop - free commands @xmath2 .",
    "the proof is by induction on the size of @xmath2 . if @xmath2 is @xmath33 we have @xmath293 and the conclusion follows , as , by lemma  [ skip ] , @xmath294\\!]}}^c}$ ] iff @xmath235 and @xmath295\\!]}}^c}$ ] .",
    "if @xmath2 is blocked , the conclusion holds trivially , by lemma  [ immediately_blocked ] .    if @xmath2 is neither @xmath33 nor blocked we have @xmath296 ( and then @xmath297 is loop - free and @xmath298 ) .",
    "then , by lemma  [ neither_skip_or_blocked ] , @xmath255\\!]}}^c}$ ] iff @xmath299\\!]}}^c}$ ] which latter , by the induction hypothesis , implies @xmath300 with @xmath254\\!]}}^c}$ ] which , in turn , implies @xmath253 with @xmath254\\!]}}^c}$ ] , as desired .",
    "next suppose that @xmath301\\!]}}^c}$ ] , where now @xmath49 is not loop - free .",
    "by lemma  [ approximation2 ] @xmath255\\!]}}^c}$ ] for some @xmath260 .",
    "so , by the above , @xmath253 with @xmath254\\!]}}^c}$ ] .",
    "the desired conclusion follows immediately , using lemma  [ approximation1 ] .",
    "[ realprogress ] @xmath289    1 .   for any proper non - empty pure transition sequence @xmath89 , @xmath255\\!]}}^c}$ ] iff for some @xmath302 , @xmath292{\\mathbin{\\longrightarrow_a}}^*{\\mathbin{\\longrightarrow_c}}{{\\langle \\sigma',t',c ' \\rangle}}$ ] with @xmath303\\!]}}^c}$ ] .",
    "2 .   for any @xmath15 , @xmath61 , @xmath17 , @xmath2 , @xmath304\\!]}}^c}$ ] iff @xmath305{\\mathbin{\\longrightarrow_a}}^ * { { \\langle \\sigma',{\\varepsilon},{\\mbox{\\tt skip}}\\rangle}}$ ] .    by lemma  [ progress ] , @xmath255\\!]}}^c}$ ] holds iff @xmath306 does , with @xmath307\\!]}$ ] . in the case where @xmath89 is proper the conclusion follows from lemma  [ equivalences ] . in the case where @xmath89 is @xmath70",
    "we see from the definition of @xmath308\\!]}$ ] that @xmath309\\!]}$ ] iff @xmath310 .",
    "the following _ adequacy theorem _ for pure transition sequences is an immediate consequence of lemmas  [ progress ] and  [ realprogress ] :    [ thm : adequacy ] @xmath289    1 .",
    "for @xmath311 , @xmath312\\!]}}^c}$ ] iff there are @xmath313 , ( @xmath314 ) such that @xmath315 , @xmath316 , and @xmath317 , for @xmath318 , and @xmath319 .",
    "2 .   for @xmath311 ,",
    "@xmath320\\!]}}^c}$ ] iff there are @xmath313 , ( @xmath314 ) such that @xmath315 , @xmath316 , and @xmath317 , for @xmath318 , and @xmath321 .    as a corollary",
    "we obtain an adequacy theorem for runs :    [ thm : adequacy - runs ] @xmath289    1 .   for @xmath215 , @xmath322\\!]})}$ ] iff",
    "there are @xmath313 , ( @xmath323 ) such that @xmath315 , @xmath316 , @xmath324 ( @xmath325 ) , and @xmath326 .",
    "2 .   for @xmath327 ,",
    "@xmath328\\!]})}$ ] iff there are @xmath313 , ( @xmath323 ) such that @xmath315 , @xmath316 , and @xmath329{\\mathbin{\\longrightarrow_a}}^*{\\mathbin{\\longrightarrow_c}}{{\\langle \\sigma_{i+1}t_{i+1},c_{i+1 } \\rangle}}$ ] ( @xmath330 ) , and @xmath331{\\mathbin{\\longrightarrow_a}}^ * { { \\langle \\sigma_{n},{\\varepsilon } , { \\mbox{\\tt skip}}\\rangle}}$ ] .",
    "the first lemma in the proof of full abstraction bounds the nondeterminism of commands in semantic terms .",
    "[ lemma : fin ] for all @xmath2 , @xmath89 , and @xmath15 , the set @xmath332\\!]}\\}$ ] is finite .",
    "more generally , we prove that for all @xmath17 , @xmath2 , @xmath333 , and @xmath334 , the set @xmath335\\!]}\\}$ ] is finite , and similarly that the set @xmath336\\!]}\\}$ ] is finite .",
    "the proof is by induction on @xmath20 .",
    "the proof relies on adequacy ; a purely semantic proof might be possible but seems harder .    1 .",
    "if @xmath2 is @xmath33 , then lemma  [ skip ] implies that @xmath337 is @xmath338 , and @xmath339\\!]}$ ] . in case @xmath340 ,",
    "we are done , with a unique choice for @xmath337 . otherwise , we conclude by induction hypothesis .",
    "2 .   if @xmath2 is blocked , then @xmath341 , by lemma  [ immediately_blocked ] , so this case is vacuous .",
    "if @xmath2 is neither @xmath33 nor blocked , then lemma  [ progress ] implies that @xmath337 is unique . in case @xmath340 ,",
    "we are done , with a unique choice for @xmath337 .",
    "otherwise , lemma  [ progress ] also implies that @xmath342\\!]}$ ] for a unique @xmath26 . as in the case of @xmath33 ,",
    "the desired conclusion follows by induction hypothesis .",
    "4 .   finally ,",
    "having established the claim for sequences of length @xmath20 for sets of the form @xmath154\\!]}$ ] , we consider sequences of length @xmath20 in a set of the form @xmath343\\!]}$ ] .",
    "suppose that @xmath17 consists of @xmath344 .",
    "a transition sequence @xmath68 in @xmath343\\!]}$ ] is a shuffle of transition sequences in @xmath345\\!]}$], ",
    ",@xmath346\\!]}$ ] , each of length at most @xmath20 .",
    "the finiteness property for @xmath343\\!]}$ ] follows from the fact that there are only finitely many possible ways of decomposing @xmath68 as a shuffle .",
    "intuitively , lemma  [ lemma : fin ] is useful because it implies that , at any point , there are certain steps that a command can not take , and in proofs those steps can be used as unambiguous , visible markers of activity by the context .",
    "this lemma is somewhat fragile ",
    "it does not hold once one adds to the language either the nondeterministic choice operator considered in section  [ resumptions ] or the parallel composition operator of section  [ parcomp ] .",
    "it follows that neither of these operators is definable in the language .",
    "an alternative argument that does not use the lemma relies on fresh variables instead .",
    "the fresh variables permit an alternative definition of the desired markers .",
    "full - abstraction results invariably require some notion of observation .",
    "let us write @xmath347 for the observations that we make on @xmath123 .",
    "equational full abstraction is that @xmath132\\ ! ] } = { [ \\![{d}]\\!]}$ ] if and only if , for every context @xmath28 , we have @xmath348}}]\\ ! ] } ) } = { \\mathrm{obs}({[\\![{{{{\\mathcal{c}}}[d]}}]\\!]})}$ ] . in other words ,",
    "two commands have the same meaning if and only if they yield the same observations in every context of the language .",
    "the stronger inequational full abstraction is that @xmath132\\ ! ] } \\subseteq { [ \\![{d}]\\!]}$ ] if and only if , for every context @xmath28 , we have @xmath348}}]\\ ! ] } ) } \\subseteq { \\mathrm{obs}({[\\![{{{{\\mathcal{c}}}[d]}}]\\!]})}$ ] .",
    "the difficult part of this equivalence is usually the implication from right to left : that if , for every context @xmath28 , @xmath348}}]\\ ! ] } ) } \\subseteq { \\mathrm{obs}({[\\![{{{{\\mathcal{c}}}[d]}}]\\!]})}$ ] , then @xmath132\\ ! ] } \\subseteq { [ \\![{d}]\\!]}$ ] .",
    "one possible candidate for @xmath347 is @xmath349 .",
    "this notion of observation can be criticized as too fine - grained .",
    "nevertheless , we find it useful to prove full abstraction for this notion of observation , with the following lemma .",
    "we first need some auxiliary definitions for its proof , and the lemma that follows . given two stores @xmath15 and @xmath61 , we define :    1 .   a boolean expression @xmath350 as the conjunction of the formulas @xmath351 for every variable @xmath19 , where @xmath20 is the natural number @xmath352 ( so @xmath350 is true in @xmath15 and false elsewhere ) ; 2 .",
    "a command @xmath353 as the sequence of assignments @xmath354 for every variable @xmath19 , where @xmath20 is the natural number @xmath352 ; 3 .   a command @xmath355 as @xmath356{\\mbox{\\tt block}}}$ ]",
    "a command @xmath357 as @xmath358 .",
    "these definitions exploit the fact that the set of variables is finite . however ,",
    "with more care , analogous definitions could be given otherwise , by focusing on the set of variables relevant to the programs under observation .",
    "[ lemma : clean ] if @xmath359}}]\\!]}}^c }   \\subseteq { { { [ \\![{{{{\\mathcal{c}}}[d]}}]\\!]}}^c}$ ] for every context @xmath28 , then @xmath132\\ ! ] } \\subseteq{[\\![{d}]\\!]}$ ] .    letting @xmath360\\!]}$ ] and @xmath361\\!]}$ ] , we assume that @xmath362 and prove that there exists @xmath28 such that @xmath363\\!]}(p)}^c } \\not\\subseteq { { { [ \\![{{{\\mathcal{c}}}}]\\!]}(q)}^c}$ ] .",
    "for this , choose a sequence @xmath66 in @xmath94 but not in @xmath150 . if @xmath364 , then we can take @xmath28 to be @xmath27}$ ] .",
    "therefore , for the rest of the proof , we consider the case @xmath365 .    if @xmath365 , then @xmath66 is of the form @xmath366 .",
    "we let @xmath367 } ; { ( \\sigma ' \\leadsto \\sigma'')}$ ] where @xmath231 does not appear in @xmath89 or @xmath68 and @xmath368 ( so , by prefix - closure , @xmath369 ) .",
    "such a choice of @xmath231 is always possible by lemma  [ lemma : fin ] .",
    "thus , @xmath370\\!]}(p)$ ] contains @xmath371 , and @xmath363\\!]}(p)}^c}$ ] contains @xmath372 .",
    "suppose that @xmath372 is also in @xmath363\\!]}(q)}^c}$ ] , and that this is because some sequence @xmath373 is in @xmath370\\!]}(q)$ ] and @xmath374 . by the definition of the semantics of sequential composition ,",
    "this could arise in one of the following ways :    1 .",
    "@xmath375 , with @xmath376 .",
    "this contradicts @xmath377 .",
    "2 .   @xmath378 , and @xmath231 occurs as the second store of a return transition in either @xmath67 or @xmath379 .",
    "this contradicts the requirement that @xmath231 does not appear in @xmath89 or @xmath68 .",
    "3 .   @xmath380 , @xmath381 , and @xmath373 does not have a return transition .",
    "this contradicts the requirement that @xmath368 .",
    "another possible candidate for @xmath347 is @xmath216 .",
    "runs record more than mere input - output behavior , but much less than entire execution histories .",
    "we therefore find them attractive for our purposes .",
    "the following lemma connects runs to cleaning .",
    "[ lemma : runs ] if @xmath382}}]\\ ! ] } ) } \\subseteq { \\mathrm{runs}({[\\![{{{{\\mathcal{c}}}[d]}}]\\!]})}$ ] for every context  @xmath28 , then @xmath383\\!]}}^c } \\subseteq { { { [ \\![{d}]\\!]}}^c}$ ] .    letting @xmath360\\!]}$ ] and @xmath361\\!]}$ ] , we assume that @xmath384 and prove that there exists @xmath28 such that @xmath385\\!]}(p ) ) } \\not\\subseteq { \\mathrm{runs}({[\\![{{{\\mathcal{c}}}}]\\!]}(q))}$ ] .    for this ,",
    "choose a sequence @xmath386 but @xmath387 , in order to derive a contradiction .",
    "first , suppose that @xmath66 is of the form @xmath388 , with @xmath311 .",
    "we let @xmath28 be @xmath389 } } ; { \\mathrm{mesh}(w)}$ ] , where @xmath390 is the command @xmath391 where the stores @xmath392 are all different from one another and from all other stores in @xmath66 , and are such that @xmath393 and @xmath394 such a choice of stores @xmath392 is always possible by lemma  [ lemma : fin ] . since @xmath395\\!]}$ ] contains the transition sequence : @xmath396 we obtain that @xmath370\\!]}(p)$ ] contains the transition sequence : @xmath397 which generates the run : @xmath398 suppose that this run is also in @xmath385\\!]}(q))}$ ]",
    ". therefore , there exists @xmath399 such that @xmath400 is a shuffle of @xmath373 with @xmath401 which we call @xmath402 , or with a prefix of @xmath402 .",
    "we analyze the origin of the transitions in the shuffle :    1 .   the transitions @xmath403 must all come from @xmath373 , since each of the transitions in @xmath402 contains one of the stores @xmath404 and , by choice , these are different from @xmath405 and @xmath406 .",
    "2 .   suppose that , up to some @xmath407 , @xmath373 starts like @xmath66 , in other words it starts as @xmath408 .",
    "suppose further that , in the shuffle up to this point , each transition @xmath409 is followed immediately by the corresponding transitions @xmath410 from @xmath402 .",
    "we argue that this remains the case up to @xmath20 . 1",
    ".   we consider @xmath411 , the next possible transition in the shuffle .",
    "this transition can not come from @xmath373 because , by the choice of @xmath412 , we have that @xmath413 so this transition comes from @xmath402 .",
    "2 .   one step further , in order to derive a contradiction , we suppose that the transition @xmath414 comes from @xmath373 .",
    "so @xmath373 starts : @xmath415 and in fact : @xmath416 since , as noted above , the last transition here must come from @xmath373 .",
    "the next transition in the shuffle is @xmath417 . by the choice of @xmath392",
    ", we have that @xmath394 so the transition @xmath417 can not come from @xmath373 .",
    "therefore , it must come from @xmath402 . however , the next available transition in @xmath402 is @xmath418 , and @xmath419 and @xmath418 must be different because @xmath412 and @xmath392 are different , by choice , from @xmath406 and @xmath405 .",
    "+ thus , the assumption that the transition @xmath418 comes from @xmath373 leads to a contradiction .",
    "this transition must come from @xmath402 .",
    "finally , suppose that , up to @xmath20 , @xmath373 starts like @xmath66 , in other words as : @xmath420 and that , in the shuffle , each transition @xmath409 is followed immediately by the corresponding transitions @xmath410 from @xmath402 . by the choice of @xmath421",
    ", we have that @xmath422 so @xmath423 comes from @xmath402 , not from @xmath373 .    in sum ,",
    "@xmath424 , and therefore @xmath425 , contradicting our assumption that @xmath387 .",
    "next , suppose that @xmath66 is of the form @xmath426 .",
    "with the same @xmath28 , we obtain that @xmath370\\!]}(p)$ ] contains the transition sequence : @xmath427 which generates the run : @xmath428 suppose that this run is also in @xmath385\\!]}(q))}$ ] . again , by the choice of @xmath429 ,  , @xmath421 , this can be the case only if @xmath66 is in @xmath430 .",
    "( the argument for the contradiction may actually be simplified in this case , because of the marker @xmath70 . )",
    "we obtain the following _ full - abstraction theorem _ :    [ thm : fullabs ] @xmath132\\ ! ] } \\subseteq { [ \\![{d}]\\!]}$ ] iff , for every context @xmath28 , @xmath382}}]\\ ! ] } ) } \\linebreak[0]\\subseteq    { \\mathrm{runs}({[\\![{{{{\\mathcal{c}}}[d]}}]\\!]})}$ ] .    the implication from @xmath132\\ ! ] } \\subseteq { [ \\![{d}]\\!]}$ ] is an immediate consequence of the compositionality of the semantics ( proposition  [ prop : comp ] ) .",
    "the converse follows from lemmas  [ lemma : clean ] and  [ lemma : runs ] .",
    "coarser - grained definitions of @xmath347 may sometimes be appropriate .",
    "for those , we expect that full abstraction will typically require additional closure conditions on @xmath94 , such as closure under suitable forms of stuttering and mumbling , much as in our work and brookes s on parallel composition  @xcite .",
    "the development of the denotational semantics in section  [ sec : dsemantics ] is ad hoc , in that the semantics is not related to any systematic approach . in this section",
    "we show how it fits in with the algebraic theory of effects  @xcite .    in the functional programming approach",
    "to imperative languages , commands have unit type , @xmath431 .",
    "then , taking the monadic point of view  @xcite , they are modeled as elements of @xmath432 for a suitable monad @xmath17 on , say , the category of @xmath103-cpos and continuous functions . for parallelism one might look for something along the lines of the resumptions monad  @xcite .    in the algebraic approach to computational effects  @xcite ,",
    "one analyses the monads as free algebra monads for a suitable equational or lawvere theory @xmath433 ( here meaning in the enriched sense , so that inequations are allowed , as are families of operations continuously parameterized over an @xmath103-cpo ) .",
    "the operations of the theory ( for example a binary choice operation in the case of nondeterminism ) are thought of as effect constructors in that they create the effects at hand .",
    "as discussed in  @xcite , resumptions are generally not fully abstract when their domain equation is solved in a category of cpos .",
    "if , instead , it is solved in a category of semilattices , increased abstraction may be obtained .",
    "the situation was analyzed from the algebraic point of view in  @xcite .",
    "it was shown there that resumptions arise by combining a theory for stores  @xcite with one for nondeterminism , one for nontermination , and one for a unary operation @xmath144 thought of as suspending computation .",
    "the difference between solving the equation in a category of semilattices or cpos essentially amounts to whether or not one asks that @xmath144 , and the other operations , commute with nondeterminism .    in  @xcite ,",
    "brookes , using an apparently different and mathematically elementary trace - based approach , succeeded in giving a fully abstract semantics for a language of the kind considered in  @xcite .",
    "however , in  @xcite , jeffrey showed that trace - based models of concurrent languages can arise as solutions to domain equations in a category of semilattices , thereby relating the two approaches .",
    "we propose here to identify the suspension operation @xmath144 with the operation of the same name introduced in section  [ sec : semcommand ] ; indeed this identification was the origin of the definition of @xmath3 given there , and it is natural to further identify @xmath3 as the generic effect  @xcite corresponding to the suspension operation .",
    "these identifications are justified by corollary  [ proc - algebra ] , below , and the discussion following  it .    in section  [ resumptions ]",
    "we carry out an algebraic analysis of resumptions .",
    "we show in theorem  [ resumptions ] that , imposing the commutations with nondeterminism just discussed , they do indeed correspond to a traces model , provided one uses the hoare or lower powerdomain .",
    "( this powerdomain is a natural choice as we consider only `` may '' semantics in this paper , and elements of such powerdomains are scott closed , so downwards - closed , a natural generalization of our prefix - closedness condition . )",
    "the proof makes the link between domain equations and traces .",
    "the missing ingredient in an algebraic analysis of @xmath101 is then an account of @xmath58 . in the denotational semantics of any command of the form",
    "@xmath1 , all @xmath85 marking is lost from the meaning of @xmath2 , because of the application of the cleaning function , @xmath434 ; further all the sequences in @xmath132\\!]}^c$ ] are proper .",
    "we propose to treat @xmath58 as a generic effect , parameterized by an element of @xmath105 ( which will be @xmath132\\!]}^c$ ] ) .    in order to give the equations for the @xmath141 operation it will ,",
    "as one may expect , be useful to first have an algebraic analysis of @xmath435 ; we carry out this analysis in section  [ threads ] .",
    "it turns out , as detailed in theorem  [ threads ] , that @xmath435 is similar to , but not quite , a resumptions @xmath103-cpo .",
    "finally , we analyze processes in section  [ processes ] , showing , in theorem  [ processes ] , that a process is a kind of `` double - thread''more precisely , a resumption that returns not only a value but also an element of @xmath435 .",
    "our theory @xmath436 for resumptions follows  @xcite but is somewhat modified , as we are interested only in `` may '' semantics and as we wish to allow infinitely proceeding processes . the theory is a combination of several constituent theories which we now consider successively .    the lawvere theory @xmath437 of stores can be presented via a family of unary operations @xmath438 and a family of `` @xmath439-ary '' operations @xmath440 ( @xmath441 , @xmath442 ) .",
    "( an @xmath439-ary operation is a countably infinitary operation whose arguments are indexed by the natural numbers . ) for any computation @xmath443 , @xmath444 is read as the computation that first updates @xmath19 to @xmath20 and then proceeds as @xmath443 ; for any @xmath439-indexed collection @xmath445 of computations , @xmath446 is read as the computation that proceeds as @xmath447 if @xmath19 has value @xmath20 in the current store .",
    "the lawvere theory @xmath448 for nondeterminism is that of the lower ( aka hoare ) powerdomain , presented using a binary nondeterministic choice operation @xmath200 ; the lawvere theory @xmath449 for nontermination is the theory of a least element , presented using a constant @xmath450 ; and the lawvere theory @xmath451 for suspension is that of a unary operation @xmath144 , with no equations .",
    "see  @xcite for more details of these theories , including an account of the equations for stores and for hoare powerdomains .    for resumptions , continuing to follow  @xcite",
    ", we wish the operations of @xmath437 to commute with those of @xmath448 and @xmath449 ( which automatically commute with each other ) and it is also natural to have @xmath144 commute with nondeterministic choice , but not with the operations of @xmath437 , as we wish to model interruption points , and not with @xmath450 , as we want to be able to model infinitely proceeding processes .",
    "we therefore define : @xmath452 and let @xmath453 be the associated monad .",
    "( for any two theories @xmath433 and @xmath454 presented using disjoint signatures , the theories @xmath455 and @xmath456 can be presented using the union of the signatures of @xmath433 and @xmath454 and , in the former case , by the union of their equations and , in the latter case , by the union of their equations together with additional equations that say that each operation of each theory commutes with each operation of the other . )",
    "we now give an elementary trace - based picture of @xmath457 for sufficiently general @xmath103-cpos @xmath94 .",
    "let @xmath150 be a partial order .",
    "@xmath150-transition _ is a pair of states @xmath458 in which the second is marked with an element @xmath19 of @xmath150 ; we let @xmath100 range over stores and stores marked with an element of @xmath150 . a _",
    "basic @xmath150-transition sequence _ is a non - empty sequence consisting of plain transitions optionally followed by a @xmath150-transition .",
    "let @xmath459 be the least preorder on the set of basic @xmath150-transition sequences which contains the prefix relation @xmath460 and is such that , for any @xmath19 , @xmath461 in @xmath150 , if @xmath462 then @xmath463 .",
    "one has that @xmath459 is a partial order and that @xmath464 holds iff : @xmath465 we need a few notions concerning ideals in partial orders .",
    "an _ ideal _",
    "@xmath466 in a partial order @xmath150 is a downwards - closed subset of @xmath150 ; for any subset @xmath467 of @xmath150 we write @xmath468 for the least ideal including @xmath467 , viz @xmath469 ; and for any @xmath470 we write @xmath471 for @xmath472 .",
    "downwards - closed sets , i.e. , ideals , provide a suitable generalization of prefix - closed sets when passing from sequences to general partial orders .    an ideal @xmath466 is _ directed _ if it is nonempty and any two elements of the ideal have an upper bound in the ideal .",
    "an ideal is _ denumerably generated _ if @xmath473 for some denumerable @xmath474 .",
    "we write @xmath475 , respectively @xmath476 , for the collection of all denumerably generated directed ideals of @xmath150 , respectively all denumerably generated ideals of @xmath150 , and we partially order them by subset ; @xmath477 is an @xmath103-cpo , indeed it is the free such over @xmath150 ; and @xmath478 is the free @xmath103-cpo with all finite sups over @xmath150 : it follows that it is also the free such @xmath103-cpo over @xmath477 .",
    "let @xmath150-@xmath479 be the set of basic @xmath150-transition sequences , partially ordered as above .",
    "one can view @xmath480 as an @xmath436-model with the following definitions of the operations , where now we use @xmath481 to range over @xmath482 :    @xmath483,\\tau)u \\in i \\}\\\\",
    "( { \\mathrm{lookup}}_l)_{{{\\mathcal i}}^{}_{\\omega}(\\mbox{$q$-${\\mathrm{btrans}}$ } ) } ( ( i_{n})_{n } ) & = & \\bigcup_n \\{(\\sigma,\\tau)u \\in i_{n } \\mid \\sigma(l ) = n\\ }   \\\\ i \\cup_{{{\\mathcal i}}^{}_{\\omega}(\\mbox{$q$-${\\mathrm{btrans}}$ } ) } j & = & i \\cup j\\\\ \\omega_{{{\\mathcal i}}^{}_{\\omega}(\\mbox{$q$-${\\mathrm{btrans}}$ } ) } & = & \\emptyset\\\\ { \\mathrm{d}}_{{{\\mathcal i}}^{}_{\\omega}(\\mbox{$q$-${\\mathrm{btrans}}$})}(i ) & = & \\{(\\sigma,\\sigma)u   \\mid   \\sigma \\in { { \\mathrm{store\\/ } } } , u \\in i\\ }                                 \\cup\\ \\{(\\sigma,\\sigma)| \\sigma \\in { { \\mathrm{store\\/}}}\\ } \\end{array}\\ ] ] ( we skip over the small difference between the notion of an @xmath436-model and of an algebra satisfying equations . ) we write @xmath484 and @xmath485 for , respectively , the category of @xmath103-cpos and the category of @xmath103-cpos with all finite sups . for any poset @xmath94 ,",
    "its lifting @xmath486 is the poset obtained from @xmath94 by freely adjoining a least element @xmath487 ; its elements are @xmath488 , for @xmath489 , and @xmath487 , and they are ordered in the evident way . if @xmath94 has all sups of increasing @xmath103-chains , i.e. , is an @xmath103-cpo ( respectively has finite sups ) , so does @xmath486 . for any object @xmath490 of any given category , and any set @xmath467 , we write @xmath491 and @xmath492 for , respectively , the @xmath467-fold sum and product of @xmath490 with itself , assuming they exist .",
    "the category @xmath485 has countable biproducts , given by the usual cartesian product of posets , and it is convenient to identify @xmath493 with @xmath494 , for countable sets @xmath467 .",
    "the next theorem shows that the algebraic notion of resumptions can indeed be characterized in trace - based terms , specifically as ideals of basic @xmath150-transition sequences .",
    "[ resumptions ] viewed as an @xmath436-model , @xmath480 is @xmath495 .",
    "the unit @xmath496 is given by : @xmath497 and , for any continuous @xmath498 , its kleisli extension @xmath499 is given by : @xmath500    models of @xmath436 in @xmath484 correspond to models of @xmath437 in @xmath485 together with a morphism @xmath501 , where @xmath433 is the carrier of the model .",
    "( such morphisms are equivalent to @xmath103-continuous maps on @xmath433 which preserve binary sups , but not necessarily @xmath487 . )",
    "the carrier @xmath433 of the model of @xmath436 is that of the model of @xmath437 in @xmath485 ; it is necessarily an @xmath103-cpo with all finite lubs .",
    "the @xmath502 operations on @xmath433 become those of the model of @xmath437 in @xmath485 , and the map @xmath503 extends uniquely to a morphism on @xmath504 , obtaining the required map @xmath505 .",
    "this correspondence extends straightforwardly to an equivalence of categories .",
    "so , as @xmath506 is the free @xmath103-cpo with finite sups over the @xmath103-cpo @xmath477 , we seek the free structure @xmath507 over @xmath506 , consisting of a model @xmath508 of @xmath437 in @xmath485 and a morphism @xmath501 .    by theorem 1 of  @xcite the free algebra monad for @xmath502 over @xmath485",
    "is @xmath509 , where we abbreviate @xmath510 to @xmath511 ( the theorem depends on the set of variables being finite ) .",
    "the definitions of the operations @xmath512 and @xmath513 of an algebra @xmath514 are given by proposition 1 of  @xcite ; the unit @xmath515 at @xmath433 is the canonical map @xmath516 .",
    "so , by corollary 2 of  @xcite , for any poset @xmath150 , @xmath433 is the solution of the following `` domain equation '' in @xmath485 : @xmath517 by which we mean the initial @xmath103-cpo with finite sups @xmath433 and map @xmath518 ( such a map is necessarily an isomorphism . )    the morphism @xmath519 is @xmath520 the morphism @xmath521 is @xmath522 the morphism @xmath523 is @xmath524 and at @xmath525 the unit @xmath526 is @xmath527 now , since countable copowers and powers coincide in @xmath485 , equation  ( [ * ] ) can be rewritten as :    @xmath528    as @xmath529 is a left adjoint , where @xmath530 is the category of posets , it preserves all colimits ; @xmath531 also commutes with lifting .",
    "so there is an isomorphism : @xmath532 for any poset @xmath533 .",
    "so , again using that @xmath531 preserves all colimits , we can solve equation  ( [ * * ] ) by first solving the equation : @xmath534 in the category @xmath530 , and then applying @xmath531 . to do that",
    ", one takes @xmath533 to be the least set such that @xmath535 and then imposes the evident inductively defined partial order on it .",
    "the solution of equation  ( [ * * ] ) is then given by taking @xmath536 and @xmath537 .",
    "we now have an expression of @xmath433 as @xmath538 , as well as definitions of @xmath539 , @xmath540 , @xmath541 , and the unit .",
    "so , given the initial discussion above , we see that @xmath433 forms the free model of @xmath436 over @xmath542 with unit : @xmath543 and with operations : @xmath544 , ( \\sigma',u ) )   \\in i \\}\\\\",
    "( { \\mathrm{lookup}}_{l})_{l}((i_{n})_{n } )   & = &   \\{(\\sigma , ( \\sigma',u ) ) \\in i_{n}\\mid n \\in \\mathbb{n } , \\sigma(l ) = n \\}\\\\",
    "i \\cup_{l } j & = & i \\cup j\\\\     \\omega_{l } & = & \\emptyset\\\\       { \\mathrm{d}}_l(i )   & = &            \\{(\\sigma , ( \\sigma,\\mathrm{inl}(0,u ) ) ) \\mid \\sigma \\in s ,",
    "u \\in i \\ }             \\ ;   \\cup \\ ;   \\{(\\sigma , ( \\sigma , \\perp ) ) \\mid \\sigma \\in s \\ } )    \\end{array}\\ ] ] there is an evident isomorphism of partial orders @xmath545 , given recursively by : @xmath546 this induces an isomorphism @xmath547 of @xmath103-cpos , and so the free such model is also carried by @xmath480 . using this , and the above definitions of the operations and unit for @xmath548 , one then verifies that the operations and unit for @xmath480 are as required .    as regards the formula for the kleisli extension , that @xmath549 is evident and that the purported extension is a morphism of models of @xmath436 is a calculation .",
    "one can go further and obtain a closely related , if less elementary , picture of @xmath457 for an arbitrary @xmath103-cpo @xmath94 : one needs a notion of ideal that takes the @xmath103-sups of @xmath94 into account .",
    "one might hope that @xmath435 can be understood as an @xmath103-cpo of resumptions , and , indeed , basic @xmath550-transition sequences and proper pure non - empty transition sequences are very similar .",
    "define a map @xmath551 by : @xmath552 unfortunately , while @xmath553 is a monotonic bijection , it is not an isomorphism of partial orders , as @xmath554 but @xmath555 .",
    "there is a related programming language phenomenon .",
    "denotationally , we have the inclusion : @xmath556\\ ! ] } \\subseteq { [ \\![{({{\\mbox{\\tt async}}~{\\mbox{\\tt skip}}});c}]\\!]}\\ ] ] but not the inclusion : @xmath557\\ ! ] } \\subseteq { [ \\![{{\\mbox{\\tt skip}}}]\\!]}\\ ] ] as in the proof of the full - abstraction theorem , one can distinguish @xmath558\\!]}$ ] from @xmath559\\!]}$ ] using a sequential context ; however , this context is not available when the command is within an @xmath58 .    to solve",
    "this difficulty we take the theory of asynchronous threads @xmath560 to be @xmath436 extended by a new constant @xmath561 and the equation : @xmath562 we can turn @xmath105 into a model of @xmath560 by defining operations as follows : @xmath563,\\sigma')u \\in p \\ } } \\cup \\{\\varepsilon\\}\\\\   ( { \\mathrm{lookup}}_l)_{{\\mathrm{aproc } } } ( ( p_{n})_{n } )   & = &   { \\bigcup_n \\{(\\sigma,\\sigma')u \\in p_{n } \\mid   \\sigma(l ) = n\\ } } \\cup \\{\\varepsilon\\}\\\\ p \\cup_{{\\mathrm{aproc } } } q & = & p \\cup q\\\\ \\omega_{{\\mathrm{aproc } } } & = & \\{{\\varepsilon}\\}\\\\ { \\mathrm{d}}_{{\\mathrm{aproc}}}(p ) & = & { \\{(\\sigma,\\sigma)u \\mid \\sigma \\in { { \\mathrm{store\\/ } } } , u \\in p\\ } } \\cup \\{\\varepsilon\\}\\\\ { \\mathrm{halt}}_{{\\mathrm{aproc } } } & = & { \\{(\\sigma,\\sigma ) { \\mathrm{done}}\\mid \\sigma \\in { \\mathrm{store\\/}}\\}\\!\\!\\downarrow } \\end{array}\\ ] ] note that @xmath564\\!]}}^c}$ ] .",
    "we write @xmath565 for the monad associated to the theory @xmath435 .",
    "the next theorem shows that the variant theory @xmath560 indeed captures @xmath435 .",
    "first we need some notation .    1 .",
    "we define a unary derived operation @xmath566 , for @xmath567 and @xmath568 by : @xmath569 where : @xmath570 2 .",
    "we define a unary derived operation @xmath571 , for @xmath572 by : @xmath573 where @xmath574 is an enumeration of @xmath0 .",
    "3 .   for every sequence of plain transitions",
    "@xmath575 we define a unary derived operation @xmath576 by : @xmath577 4 .   for every sequence of plain transitions @xmath89 and @xmath578 , we define two constants @xmath579 and @xmath580 by : @xmath581    note that @xmath582 , where , for example , @xmath583 is the interpretation of @xmath579 in @xmath435 ; further @xmath584 . below",
    "we may confuse a constant or operation with its interpretation in a specific algebra @xmath585 , e.g. , writing @xmath579 or @xmath586 rather than @xmath587 or @xmath588 , provided that the intended algebra can be understood from the context .",
    "[ threads ] @xmath105 is the initial @xmath560-model , i.e. , it is @xmath589 .",
    "we begin by examining the connection between @xmath590 and @xmath435 . by theorem  [ resumptions ]",
    ", @xmath590 is the free model of @xmath436 over @xmath550 .",
    "so @xmath591 has a unique extension to a morphism @xmath592 of @xmath436-models , where @xmath593 .",
    "we now show that : @xmath594 from which it follows that @xmath595 is onto .",
    "it is enough to show that @xmath596 , which holds as , for any @xmath89 not containing @xmath70 , we calculate that @xmath597 and that @xmath598 where , in both cases , the second equality holds as @xmath595 is a morphism of @xmath436-models .",
    "let @xmath433 be a model of @xmath560 .",
    "we have to show there is a unique morphism @xmath599 . for uniqueness ,",
    "let @xmath600 be such morphisms .",
    "then both @xmath601 and @xmath602 are morphisms of @xmath436 models from @xmath590 to @xmath433 , extending the map @xmath603 .",
    "so , as there is only one such map , @xmath604 , and therefore , as @xmath595 is onto , @xmath605 , as required .    for existence , define the map @xmath606 by : @xmath607 .",
    "using the fact that @xmath433 is a model of @xmath435 , particularly the axiom @xmath608 , one has that @xmath609 is monotonic .",
    "one can then define a continuous map @xmath610 by : @xmath611 with the sup on the right existing as @xmath466 is denumerable .",
    "let @xmath612 be the unique morphism of @xmath436 models from @xmath590 to @xmath433 , extending the map @xmath603 .",
    "we have that @xmath613 , as , for any @xmath89 not containing @xmath70 , we may calculate that : @xmath614 and that @xmath615 as @xmath616 , and @xmath595 and @xmath612 are morphisms of @xmath436 models , and @xmath595 is onto , @xmath617 is automatically a morphism of @xmath436 models .",
    "for example , for the preservation of @xmath144 , given @xmath618 , choose @xmath619 such that @xmath620 and calculate that : @xmath621 further , @xmath617 preserves @xmath561 as @xmath622 = @xmath623 .",
    "we therefore have that @xmath617 is a morphism of @xmath560-models , which concludes the proof .",
    "one can go on and obtain a general view of the monad @xmath565 using a suitable notion of ( proper ) pure @xmath150-transition sequences .",
    "however we omit the details as they are not needed for an account of processes .",
    "there is another possible proof of theorem  [ threads ] along the lines of that of theorem  [ resumptions ] .",
    "first one notes that to have a model of @xmath560 in @xmath484 is to have a model of @xmath437 in @xmath485 , with carrier @xmath433 , say , together with a morphism @xmath624 and an element @xmath625 such that @xmath608 .",
    "it is not hard to see that to have such a morphism and element is to have a morphism @xmath626 , where @xmath627 is the one - point partial order .",
    "one then sees that the carrier of the initial such model is given by the solution of the domain equation : @xmath628 and that that can be solved by first solving the corresponding equation @xmath629 in @xmath530 and then setting @xmath536 .",
    "the rest of the proof proceeds as expected .",
    "equally , there should be an elementary proof of theorem  [ resumptions ] , which , like that of theorem  [ threads ] , makes use of definability .",
    "the more conceptual proofs have the advantage of showing , via domain equations , the origins of the two kinds of transition sequences and their ordering .",
    "we turn to our algebraic account of @xmath630 .",
    "the signature of our theory of processes , @xmath631 , is that for @xmath436 together with two families of unary operation symbols @xmath632 and @xmath633 , where @xmath94 is in @xmath435 .",
    "the first of these corresponds to the function of the same name defined above , but restricted to asynchronous threads .",
    "the second corresponds to a slightly different version of @xmath141 in which the first action is that of the thread spun off , rather than that of the active command .",
    "we often find it convenient to write @xmath634 and @xmath635 as , respectively , @xmath636 and @xmath637 , thinking of them as right and left shuffles .",
    "we begin with a theory @xmath638 for @xmath141 and @xmath639 which involves the other operations .",
    "the first group of equations for @xmath638 concerns commutation with @xmath200 : @xmath640    the second group of equations concerns the interaction of @xmath141 with the other operations of @xmath631 ( except for @xmath641 ) : @xmath642 where we write @xmath643 for the `` left action '' @xmath644 .",
    "the first three state that @xmath645 commutes with another operation ; the next concerns the interaction of @xmath141 with suspension and brings in @xmath639 ; the last reduces two occurrences of @xmath141 to one .",
    "the third , and last , group of equations is for the interaction of @xmath639 with the other operations of @xmath560 : @xmath646 the first three assert that @xmath647 acts homomorphically with respect to an operation ; the next concerns the interaction with suspension ; and the last concerns what happens when asynchronous threads halt .",
    "finally we add an inequation : @xmath648 we take the equations of @xmath631 to be those of @xmath638 , i.e. , the equations are the ones just given for @xmath141 and @xmath639 , together with those of @xmath436 .",
    "one would naturally have expected @xmath631 also to have an equation with left - hand side @xmath649 ; indeed , we could have added the equation : @xmath650 however this equation is redundant as it can be proved from the others using the algebraic induction principle of `` computational induction '' described in  @xcite .",
    "( one proceeds by such an induction on @xmath651 , with a subinduction on @xmath94 . )",
    "the inequation is somewhat inelegant : a possible improvement would be to use @xmath106 instead rather than restricting to asynchronous threads",
    ". this would give the possibility of a version of @xmath561 , to denote @xmath652 , such that the equations @xmath653 held , making the inequation redundant .",
    "let @xmath654 be the monad associated to the theory @xmath630 .",
    "we now aim to give a picture of @xmath655 like that we gave of @xmath495 .",
    "take the partial order @xmath656 of the _",
    "@xmath150-transition sequences _ to be that of the basic @xmath657-transition sequences .",
    "note that one can regard @xmath150-transition sequences as elements of a kind of `` double thread '' in which the first thread returns a value together with a second ( asynchronous ) thread .",
    "we show that @xmath658 carries the free model of @xmath631 on @xmath477 .",
    "we view @xmath659 as a @xmath436-model as in section  [ resumptions ] . in order to give @xmath141 and @xmath639 ,",
    "we first mutually recursively define the incomplete right and left shuffles @xmath660 of a proper pure transition sequence @xmath89 with a @xmath150-transition sequence @xmath68 , by : @xmath661 where , for any pure transition sequence @xmath66 , @xmath662 is @xmath66 less any occurrence of @xmath70 , and writing @xmath112 for the incomplete shuffles @xmath663 of @xmath89 and @xmath68 , and : @xmath664 where , in the last line , @xmath89 is required to be proper .",
    "( recall that an incomplete shuffle of two sequences is a shuffle of two of their prefixes , equivalently a prefix of a shuffle of them . )",
    "both @xmath665 and @xmath641 are monotonic operations .",
    "then , for @xmath666 and @xmath667 , we put : @xmath668 @xmath669 if @xmath466 is not empty we have : @xmath670 with these additional operations , @xmath659 is a model of @xmath671 .    in the following we make use of the notation introduced in section  [ threads ] .",
    "[ main_proc_lemma1 ] for any proper pure transition sequence @xmath89 , the equation @xmath672 is provable in @xmath631 .",
    "the proof is by induction on the length of @xmath89 . in the case where @xmath673 , we have @xmath674 , and in the equational theory we have @xmath675 , as required .    in the case where @xmath676 , we have @xmath677 , and in the equational theory , we have : @xmath678    in the case where @xmath679 , we have @xmath680 , and in the equational theory , we have : @xmath681    finally , in the case where @xmath682 , with @xmath68 a proper pure transition sequence , we have @xmath683 , and in the equational theory , we have : @xmath684 using the induction hypothesis in the next - to - last step .",
    "our main algebraic theorem characterizes free models of a natural equational theory for resumptions with thread - spawning in terms of a kind of double - thread .",
    "[ thm : view ] [ processes ] viewed as an @xmath631-model , @xmath685 is the free model over @xmath477 .",
    "the unit @xmath686 is given by : @xmath687 and , for any continuous @xmath688 , its kleisli extension @xmath689 is given by : @xmath690    to show that @xmath685 is the free algebra over @xmath477 with unit as above , we must show that for any @xmath631-model @xmath585 and any continuous function @xmath691 there is a unique morphism @xmath692 of models of @xmath631 such that the following diagram commutes :    i^_(q ) + ^ & _ f + i^ _ ( ) & ^h & a    we begin by showing uniqueness . to that end , fix @xmath585 and @xmath693 , and let @xmath617 be a morphism such that the diagram commutes .",
    "define @xmath694 by putting : @xmath695 this is a good definition , with monotonicity being established using the inequation for @xmath665 .",
    "we have @xmath696 and @xmath697 where @xmath698 is defined by setting @xmath699 .",
    "we then have that the following diagram commutes :    i^_(q ) + ^ ( _ t_)_i^_(q ) & _ g + i^ _ ( ) & ^h & a    as we may we calculate , for @xmath700 , that : @xmath701 and , for @xmath702 , that : @xmath703    this is enough to show uniqueness , as if @xmath704 , for two such morphisms @xmath617 and @xmath705 , then @xmath706 , and so @xmath605 , as @xmath617 and @xmath705 are morphisms of models of @xmath436 ( being morphisms of models of @xmath631 ) .    for existence we are again given @xmath585 and @xmath693 and wish to construct a suitable @xmath617 .",
    "to that end , with @xmath612 and @xmath707 as before , take @xmath617 to be the @xmath453-extension of @xmath612 .",
    "then we have @xmath708 and so it remains to prove that @xmath617 preserves @xmath141 and @xmath639 .",
    "as regards the preservation of @xmath141 , since it is continuous , preserves @xmath200 in each argument , and is strict in its second argument , it suffices to establish preservation for individual transition sequences .",
    "that is , it suffices to show , for all proper pure transition sequences @xmath89 and all @xmath68 in @xmath656 , that : @xmath709 where here , and below , we omit @xmath710 s , writing , e.g. , @xmath89 and @xmath68 rather than @xmath711 and @xmath712 .",
    "as regards the preservation of @xmath639 , since it is continuous and preserves @xmath200 in each argument , it suffices to show , for all proper pure transition sequences @xmath89 and all @xmath68 in @xmath656 that : @xmath713 and : @xmath714    for the last of these three equations , as @xmath715 , using lemma  [ main_proc_lemma1 ] , we see that is enough to show that @xmath716 , and this holds as @xmath617 is a homomorphism of models of @xmath436 .",
    "the proof of the first two equations is a simultaneous induction on the sum of the lengths of @xmath89 and @xmath68 , invoking @xmath631 equations on @xmath585 as necessary .",
    "we begin with the first equation . in the first case",
    ", we consider @xmath717 . here , on the one hand , we have : @xmath718 using the fact that @xmath617 is a homomorphism for the last equality , and , on the other , we have : @xmath719 for the next case we consider @xmath720 . here , on the one hand we have : @xmath721 and , on the other hand , we have : @xmath722 for the last case for the first equation we have @xmath723 , with @xmath379 in @xmath656 , and we calculate : @xmath724 applying the induction hypothesis in the second line .",
    "turning to the second equation , the first case we consider is where @xmath673 , and we have : @xmath725 the second case is where @xmath679 and we have : @xmath726 the last case is where @xmath727 , with @xmath67 a proper pure transition sequence , and we have : @xmath728 applying the induction hypothesis to obtain the fourth equality .    finally , the formula for the kleisli extension follows from the construction of @xmath617 , using the kleisli formula of theorem  [ resumptions ] . as in the case of resumptions , one can go further and obtain a closely related , if less elementary , picture of @xmath729 for arbitrary  @xmath94 .",
    "note that the proof of theorem  [ processes ] is elementary , making use of definability in a similar way to the proof of theorem  [ threads ] .",
    "however , unlike in the cases of theorems  [ resumptions ] and [ threads ] , we do not know any conceptual proof of theorem  [ processes ] .",
    "the difficulty is that the theory of processes @xmath631 , particularly the part concerning @xmath641 and @xmath665 , seems somewhat ad hoc , and is not built up in a standard way from simpler theories .",
    "there is surely more to be understood here .",
    "nonetheless , with theorem  [ processes ] available , we are in a position to give our algebraic account of @xmath630 . there is an isomorphism @xmath730 , where @xmath731 , sending @xmath732 to itself and @xmath733 to @xmath734 .",
    "one then has an isomorphism of @xmath103-cpos @xmath735 given by : @xmath736 .",
    "it follows that @xmath630 can be seen as the free model of @xmath631 over the terminal @xmath103-cpo @xmath737 , as we now spell out .",
    "first , define the set of left shuffles @xmath738 of a pure transition sequence @xmath89 with a transition sequence @xmath68 by setting @xmath739 and @xmath740 then , we have :    [ proc - algebra ] equip @xmath630 with the following operations : @xmath741,\\tau)u \\in p \\ } \\cup \\{\\varepsilon\\}\\\\ ( { \\mathrm{lookup}}_x)_{{\\mathrm{proc } } } ( ( p_{n})_{n } ) & = & \\bigcup_{n } \\{(\\sigma,\\tau)u \\in p_{n } \\mid \\sigma(x ) = n\\ } \\cup \\{\\varepsilon\\ } \\\\ p \\cup_{{\\mathrm{proc } } } q & = & p \\cup q\\\\ \\omega_{{\\mathrm{proc } } } & = & \\{\\varepsilon\\}\\\\ { \\mathrm{d}}_{{\\mathrm{proc}}}(p ) & = & \\{(\\sigma,\\sigma)u   \\mid   \\sigma \\in { { \\mathrm{store\\/ } } } , u \\in p\\ } \\cup \\{\\varepsilon\\}\\\\ p { \\rhd}_{{\\mathrm{proc } } } q & = & { \\mathrm{async}}(p , q)\\\\ p { \\lhd}_{{\\mathrm{proc } } } q & = &   \\bigcup_{u \\in p , v \\in q } u { \\lhd}v \\end{array}\\ ] ] ( where @xmath19 ranges over @xmath482 ) .",
    "then @xmath742 is an isomorphism of @xmath631-models , and @xmath630 is the free model of @xmath631 over @xmath737 , with unit @xmath743 given by : @xmath744 the kleisli extension of a map @xmath745 is given by : @xmath746    the proof is a calculation using theorem  [ thm : view ] .",
    "the following equations are useful : @xmath747 @xmath748 where @xmath89 is a proper pure transition sequence and @xmath68 is a @xmath737-transition sequence .    as we now see , the algebraic view also determines the semantics of our language .",
    "this achieves our aim of placing cooperative threads within the algebraic approach to effects , thereby justifying the previous , more ad hoc , account .",
    "first , we have that @xmath559\\ ! ] } = ( \\eta_{{\\mathrm{proc}}})_{\\{{\\mathrm{ret}}\\}}({\\mathrm{ret}})$ ] and that @xmath749 , so the kleisli structure determines the semantics of @xmath33 and composition , just as one would expect from the monadic point of view .    next , the @xmath750 and @xmath751 operations , together with the assumed primitive natural number and boolean functions , determine the semantics of assignments , conditionals , and while loops .",
    "the operations are equivalent to two generic effects , of assignment and reading : @xmath752 one can use the reading generic effect to give the semantics of numerical expressions as elements of @xmath753 ; with that , one can give the semantics of assignments , using the assignment generic effect , standard monadic means , and @xmath754 .",
    "similarly , one can use the reading generic effect to give the semantics of boolean expressions as elements of @xmath755 , where @xmath756 ; with that one can give the semantics of conditionals and while loops , again using standard monadic means and @xmath754 ( as well as least fixed - points for while loops ) .",
    "continuing , the @xmath144 operation is that of the algebra ; and @xmath4 is modeled by @xmath757 .",
    "finally , the semantics of spawning is determined by @xmath141 together with the cleaning function @xmath758 it turns out that the latter is also determined by algebraic means .",
    "specifically , one can regard @xmath435 as a model of @xmath436 as in section  [ threads ] ( so we ignore @xmath561 ) and then extend it to a model of @xmath631 as follows .",
    "first for any proper pure transition sequences @xmath89 and @xmath68 we define @xmath759 inductively on @xmath68 by : @xmath760 where , in the last line , @xmath68 is required to be proper .",
    "then we put : @xmath761 and @xmath762 . with these definitions , @xmath434 is the extension of the map @xmath763 to @xmath630 .    in the converse direction",
    "one can consider adding missing algebraic operations to the language , for example adding @xmath200 and @xmath639 via constructs @xmath764 and @xmath765 .",
    "the latter construct is to the binary @xmath639 as @xmath58 is to the binary @xmath141 .",
    "it generalizes @xmath3 , which is equivalent to @xmath766 .",
    "its operational semantics is given by the rule : @xmath767 } \\rangle } } & { \\mathbin{\\longrightarrow } } & { { \\langle \\sigma , t.{{{\\mathcal{e}}}[{\\mbox{\\tt skip}}]},c \\rangle } } } \\end{array}\\ ] ]    one may debate the programming usefulness of such additional constructs , but they do allow one to express the equations used for the algebraic characterizations at the level of commands .",
    "for example , the equation @xmath768 becomes : @xmath769      we have found it useful to employ various forms of shuffle : sometimes we shuffle two things of the same kind with each other , e.g. , two pure transition sequences with each other ; and sometimes we shuffle two things of different kinds with each other , e.g. , a pure transition sequence with a transition sequence .",
    "we have further found it useful to break down such shuffles into left and right shuffles , e.g. , in the case of the left and right shuffles of asynchronous processes with processes ; indeed we employ a uniform notation , writing @xmath770 , and @xmath771 for left shuffles , right shuffles , and ( ordinary ) shuffles , respectively .",
    "our algebraic account of threads has further involved a number of equations concerning the interaction of these shuffle operations with each other and with other operations .",
    "shuffle operations and their algebra have been studied in a variety of settings . in particular , loday s dendriform algebras  @xcite provide a wide - ranging general notion of left and right shuffling of two things of the same kind with each other .",
    "dendriform @xmath585-modules  @xcite provide the corresponding notion of action : left or right shuffling a thing of one kind with a thing of another kind .",
    "we next relate our treatment to these general concepts , thereby placing our various shuffle operations and our equations for them in a standard algebraic context .",
    "let @xmath533 be a given commutative semiring ( with no requirement for a @xmath772 or a @xmath431 ) .",
    "then a _ dendriform dialgebra _ is an @xmath533-module @xmath585 equipped with two binary bilinear operations @xmath641 and @xmath665 such that , for all @xmath773 : @xmath774 where @xmath775 ; it is _ commutative _ if @xmath776 always holds . then @xmath777 is a semigroup in the category of @xmath533-modules , equivalently @xmath771 is an associative bilinear operation ; it is commutative if the dialgebra is .    given a dendriform algebra @xmath585 , a _",
    "dendriform @xmath585-module _ is an @xmath533-module @xmath778 equipped with two binary bilinear operations @xmath779 such that , for all @xmath780 and @xmath781 : @xmath782 where @xmath783 is given by : @xmath784 . then @xmath785 is a bilinear action of @xmath786 on @xmath778 .    in all our examples",
    "we take @xmath533 to be the natural two - element semiring over @xmath787 ; join semilattices with a zero form @xmath787-modules ( setting @xmath788 and @xmath789 ) . as a first example , consider the @xmath787-module of the collection of all languages , i.e. , all sets of strings over a given alphabet , not containing @xmath120 .",
    "this is a commutative dialgebra , taking @xmath641 to be the left shuffle operation , and @xmath665 to be the right one ; @xmath771 is then the usual shuffle operation .",
    "the semilattice of asynchronous processes @xmath435 forms a commutative dendriform @xmath787-algebra , setting : @xmath790 one then has that @xmath659 forms a dendriform @xmath435-module , setting : @xmath791 it follows that @xmath630 also forms a dendriform @xmath435-module , using the definitions of the left and right shuffling given in corollary  [ proc - algebra ] .",
    "algebraically , the first group of equations for @xmath638 state the bilinearity of the two module operations .",
    "the second group contains the second of the three module equations .",
    "the equation @xmath792 generalizing one considered above , holds in any module over a commutative dendriform algebra . to account for the other two module equations algebraically",
    "one would need an algebraic treatment of the dendriform algebra operations on @xmath435 .",
    "these operations are effect deconstructors rather than effect constructors .",
    "an account of unary deconstructors has been given in  @xcite , but a satisfactory treatment of binary ones remains to be found ; we therefore leave further algebraic treatment to future work .",
    "a priori , the properties and the semantics of threads in general , and of cooperative threads in particular , may not appear obvious . in our opinion ,",
    "a huge body of incorrect multithreaded software and a relatively small literature both support this point of view . with the belief that mathematical foundations could prove beneficial , the main technical goal of our work is to define and elucidate the semantics of threads .",
    "for instance , semantics can serve for validating reasoning principles ; our work is only a preliminary , but encouraging , step in this respect .",
    "our initial motivation was partly practical  we wanted to understand and further the ame programming model and similar ones .",
    "we also saw an opportunity to leverage developments in trace - based denotational semantics and in the algebraic theory of effects , and to extend their applicability to threads . as our results demonstrate , the convergence of these three lines of work proved interesting and fruitful .",
    "we focus on a particular small language with constructs for threads .",
    "several possible extensions may be considered .",
    "these include constructs for parallel composition , nondeterministic choice , higher - order functions , and thread - joining .",
    "more speculatively , they also include generalized yields , of the kind that arise in the algebraic theory of effects , as discussed in section  [ sec : algebra ] .",
    "importantly , our monadic treatment of threads indicates how to add higher - order functions to the semantics .",
    "our results mostly carry over to these extensions . in some cases , small changes or restrictions",
    "are required .",
    "in particular , the full - abstraction proof with nondeterministic choice would use fresh variables ; the one for higher - order functions might require standard limitations on the order of functions , cf .",
    "thus , our approach seems to be robust , and indeed  as in the case of higher - order functions  helpful in accounting for a range of language features .",
    "further , our algebraic analysis of the thread monad links it to the broader theme of the algebraic treatment of effects . in that regard , as the discussion after theorem  [ processes ] indicates , there is clearly still further understanding to be gained .",
    "another possible direction for further work is the exploration of alternative semantics .",
    "for instance , we could switch from the `` may '' semantics that we study to `` must '' semantics .",
    "we could also define alternative notions of observation . as suggested in section  [ sec : fullabstractionii ] , some of the coarser notions of observation might require closure conditions , such as closure under suitable forms of stuttering and under mumbling .",
    "these may correspond to suitable axioms on the suspension operator @xmath793 , as alluded to in  @xcite : we conjecture that stuttering corresponds to @xmath794 and that mumbling corresponds to @xmath795 .",
    "it would also be interesting to consider finer notions of observation that distinguish blocking from divergence .",
    "to this end we could add constructs such as orelse  @xcite and , in the semantics , treat blocking as a kind of exception .",
    "finally , we could revisit lower - level semantics with explicit optimistic concurrency and roll - backs , of the kind employed in the implementation of ame .",
    "we are grateful to martn escard and martin hyland for their helpful comments and suggestions .",
    "philippe charles , christian grothoff , vijay  a. saraswat , christopher donawa , allan kielstra , kemal ebcioglu , christoph von praun , and vivek sarkar .",
    "x10 : an object - oriented approach to non - uniform cluster computing .",
    "ralph e.  johnson and richard p.  gabriel ) , 519538 , acm press , 2005 .",
    "yannis smaragdakis , anthony kay , reimer behrends , and michal young .",
    "transactions with isolation and cooperation .",
    "richard p.  gabriel , david f.  bacon , cristina videira lopes and guy l.  steele jr . ) , 191210 , acm press , 2007 .",
    "j.  robert von behren , jeremy condit , feng zhou , george  c.  necula , and eric  a. brewer .",
    "capriccio : scalable threads for internet services .",
    "michael l.  scott and larry l.  peterson ) , 268281 , acm press , 2003 ."
  ],
  "abstract_text": [
    "<S> we develop a model of concurrent imperative programming with threads . </S>",
    "<S> we focus on a small imperative language with cooperative threads which execute without interruption until they terminate or explicitly yield control . </S>",
    "<S> we define and study a trace - based denotational semantics for this language ; this semantics is fully abstract but mathematically elementary . </S>",
    "<S> we also give an equational theory for the computational effects that underlie the language , including thread spawning . </S>",
    "<S> we then analyze threads in terms of the free algebra monad for this theory . </S>"
  ]
}