{
  "article_text": [
    "in quantum computing , elementary operations are operations that act on only a few ( usually one or two ) qubits .",
    "for example , cnots and one - qubit rotations are elementary operations .",
    "a quantum compiling algorithm is an algorithm for decomposing (  compiling \" ) an arbitrary unitary matrix into a sequence of elementary operations ( seo ) .",
    "a quantum compiler is a software program that implements a quantum compiling algorithm .",
    "one measure of the inefficiency of a quantum compiler is the number of cnots it uses to express an unstructured unitary matrix ( a unitary matrix with no special symmetries ) .",
    "we will henceforth refer to this number as @xmath4 .",
    "although good quantum compilers will also require optimizations that deal with structured matrices , unstructured matrices are certainly an important case worthy of attention . minimizing the number of cnots is a reasonable goal , since a cnot operation ( or any 2-qubit interaction used as a cnot surrogate ) is expected to take more time to perform and to introduce more environmental noise into the quantum computer than a one - qubit rotation .",
    "ref.@xcite proved that for matrices of dimension @xmath5 ( @xmath6 number of bits ) , @xmath7 .",
    "this lower bound is achieved for @xmath8 by the 3 cnot circuits first proposed in ref.@xcite .",
    "it is not known whether this bound can be achieved for @xmath9 .    [ cols=\">,>,>\",options=\"header \" , ]     suppose @xmath0 is an @xmath1-bit unstructured unitary matrix that we wish to compile . as the above table illustrates , compiling @xmath0 is hopeless for @xmath2 unless we approximate @xmath0 .",
    "we need a method for finding a unitary matrix that : ( 1 ) approximates @xmath0 well , and ( 2 ) is expressible with fewer cnots than @xmath0 .",
    "the purpose of this paper is to propose one such approximation method . the use of approximations in quantum compiling dates back to the earliest papers in the field .",
    "for example , refs.@xcite and @xcite contain discussions on this issue .",
    "as ref.@xcite points out , even when compiling a highly structured matrix like the discrete fourier transform matrix , some gates that contribute negligibly to its exact seo representation can be omitted with impunity .",
    "refs.@xcite@xcite and @xcite discuss a quantum compiling algorithm that decomposes an arbitrary unitary matrix into a sequence of @xmath3-multiplexors , each of which is then decomposed into a seo .",
    "other workers have proposed@xcite@xcite alternative quantum compiling algorithms that also generate @xmath3-multiplexors as an intermediate step .",
    "the strategy proposed in this paper for approximating @xmath0 is to approximate the intermediate @xmath3-multiplexors whose product equals @xmath0 . in this paper",
    ", we will show how one can approximate a @xmath3-multiplexor by another @xmath3-multiplexor ( the  approximant \" ) that has fewer controls , and , therefore , is expressible with fewer cnots .",
    "we will call the reduction in the number of control bits the * bit deficit * @xmath10 .",
    "fig.[fig - approx ] is emblematic of our approach .",
    "it shows a @xmath3-multiplexor with 3 controls being approximated by either a @xmath3-multiplexor with 2 controls or one with 1 control .",
    "in this section , we will define some notation that is used throughout this paper . for additional information about our notation",
    ", we recommend that the reader consult ref.@xcite .",
    "ref.@xcite is a review article , written by the author of this paper , which uses the same notation as this paper .",
    "let @xmath11 . as usual",
    ", let @xmath12 represent the set of integers ( negative and non - negative ) , real numbers , and complex numbers , respectively . for integers",
    "@xmath13 , @xmath14 such that @xmath15 , let @xmath16 . for @xmath17",
    "equal to @xmath18 or @xmath19 , let @xmath20 and @xmath21 represent the set of positive and non - negative @xmath17 numbers , respectively .",
    "for any positive integer @xmath22 and any set @xmath23 , let @xmath24 denote the cartesian product of @xmath22 copies of @xmath23 ; i.e. , the set of all @xmath22-tuples of elements of @xmath23 .",
    "for any ( not necessarily distinct ) objects @xmath25 , let @xmath26 denote an ordered set . for some object @xmath14 , let @xmath27 .",
    "let @xmath28 be the empty set .",
    "for an ordered set @xmath23 , let @xmath29 be @xmath23 in reverse order .",
    "we will use @xmath30 to represent the  truth function \" ; @xmath30 equals 1 if statement @xmath23 is true and 0 if @xmath23 is false .",
    "for example , the kronecker delta function is defined by @xmath31 . for @xmath32 , _ k=0 ^",
    "1(-1)^kx=2 ( x,0 ) . [ eq - bool - delta - fun ]    for any positive integer @xmath33 , we will use @xmath34 where @xmath35 to denote the standard basis vectors in @xmath33 dimensions ; i.e. , @xmath36_j = \\delta(i , j)$ ] for @xmath37 .",
    "@xmath38 and @xmath39 will represent the @xmath22-dimensional unit and zero matrices .    for any matrix @xmath40 and positive integer @xmath22 , let    a^n = _",
    "n a ,    a^n = _ n a .    for any matrix @xmath41 and @xmath42 , @xmath43 will represent the @xmath44-norm of @xmath40 , and @xmath45 its frobenius norm .",
    "see @xcite for a discussion of matrix norms .",
    "let @xmath46 .",
    "as is customary in the physics literature , @xmath47 will also be denoted by @xmath48 and called the magnitude of @xmath49 . for any complex matrix @xmath40",
    ", we will use @xmath50 to denote the matrix that is obtained from @xmath40 by replacing each of its entries by its absolute value .",
    "in other words , @xmath51_{ij}= abs(a_{ij } ) = |a_{ij}|$ ] .",
    "( careful : ref.@xcite and many other mathematical books call @xmath52 what we call @xmath50 ) .",
    "any @xmath53 can be expressed as a doubly infinite power series in powers of a base @xmath54 : @xmath55 .",
    "this expansion can be represented by : @xmath56 , which is called the base @xmath57 representation of @xmath58 .",
    "the plus or minus in these expressions is chosen to agree with the sign of @xmath58 .",
    "it is customary to omit the subscript @xmath59 when @xmath60 .",
    "for example @xmath61    suppose @xmath62 .",
    "note that division by 2 shifts the binary representation of @xmath58 one space to the right : @xmath63 . likewise , multiplication by 2 shifts the binary representation of @xmath58 one space to the left : @xmath64 . in general , for any @xmath65 , @xmath66 .",
    "define the action of an overline placed over an @xmath67 by @xmath68 @xmath69 . call this bit negation .",
    "define the action of an oplus placed between @xmath70 by @xmath71 . call this bit addition .",
    "one can extend the bit negation and bit addition operations so that they can act on non - negative reals .",
    "suppose @xmath72 , and @xmath73 are non - negative real numbers .",
    "then define the action of an overline over @xmath58 so that it acts on each bit individually ; i.e. , so that @xmath74_\\alpha = \\overline{x_\\alpha}$ ] .",
    "this overline operation is sometimes called bitwise negation .",
    "likewise , define the action of an oplus placed between @xmath58 and @xmath75 by @xmath76 .",
    "this oplus operation is sometimes called bitwise addition ( without carry ) .    for any @xmath53 ,",
    "the floor function is defined by @xmath77 , and the ceiling function by @xmath78 .",
    "for example , if @xmath72 , then @xmath79 .",
    "we will often use @xmath1 to denote a number of bits , and @xmath80 to denote the corresponding number of states .",
    "we will use the sets @xmath81 and @xmath82 interchangeably , since any @xmath83 can be identified with its binary representation @xmath84 .    for any @xmath85 ,",
    "define @xmath86 ; i.e. , @xmath87 is the result of reversing the binary representation of @xmath58 .",
    "suppose @xmath88 is a 1 - 1 onto map .",
    "( we use the letter @xmath89 to remind us it is a permutation ; i.e. , a 1 - 1 onto map from a finite set onto itself ) . one can define a permutation matrix @xmath90 with entries given by @xmath91 for all @xmath92 .",
    "( recall that all permutation matrices @xmath90 arise from permuting the columns of the unit matrix , and they satisfy @xmath93 . ) in this paper , we will often represent the map @xmath89 and its corresponding matrix @xmath90 by the same symbol @xmath89 .",
    "whether the function or the matrix is being alluded to will be clear from the context .",
    "for example , suppose @xmath40 is an @xmath94 dimension matrix , and @xmath89 is a permutation on the set @xmath82 .",
    "then , it is easy to check that for all @xmath95 , @xmath96 and @xmath97 .",
    "suppose @xmath98 is a 1 - 1 onto map ( i.e. , a bit permutation ) .",
    "@xmath99 can be extended to a map @xmath100 as follows .",
    "if @xmath101 , then let @xmath102_\\alpha = x_{\\pi_b(\\alpha)}$ ] for all @xmath103 .",
    "the function @xmath100 is 1 - 1 onto , so it can be used to define a permutation matrix of the same name .",
    "thus , the symbol @xmath99 will be used to refer to 3 different objects : a permutation on the set @xmath104 , a permutation on the set @xmath82 , and an @xmath94 dimensional permutation matrix .",
    "all permutations on @xmath104 generate a permutation on @xmath82 , but not all permutations on @xmath82 have an underlying permutation on @xmath104 .",
    "an example of a bit permutation that will arise later is @xmath105 ; it maps @xmath106 for all @xmath107 and @xmath108 for all @xmath109 .",
    "in this section , we will review some well known facts about gray code@xcite .",
    "( gray code was named after a person named gray , not after the color . )    for any positive integer @xmath1 , we define a * grayish code * to be a list of the elements of @xmath81 such that adjacent @xmath1-tuples of the list differ in only one component . in other words ,",
    "a grayish code is a 1 - 1 onto map @xmath110 such that , for all @xmath111 , the binary representations of @xmath112 and @xmath113 differ in only one component . for any @xmath114 , there are many functions @xmath115 that satisfy this definition .",
    "next we will define a particular grayish code that we shall refer to as  the \" gray code and denote by @xmath116 .",
    "the gray code for @xmath117 is :     0&0&0 + 1&1&1 +     0&00&00 + 1&01&01 + 2&10&11 + 3&11&10 +     0&000&000 + 1&001&001 + 2&010&011 + 3&011&010 + 4&100&110 + 5&101&111 + 6&110&101 + 7&111&100 +    .",
    "the * gray code * can be defined recursively as follows .",
    "let @xmath118 .",
    "for @xmath119 , let @xmath120 equal the set @xmath81 ordered in the gray code order .",
    "in other words , @xmath121 . then ,    _ + 1 = \\{0 _ , 1^r_}_ord for @xmath122.(see section [ sec - notation ] for ordered set notation . )    from the recursive definition of the gray code , it is possible to prove that if @xmath123 and @xmath124 are nonnegative integers such that @xmath125 , then    [ eq - gk - comps ] g_= k_k_+1 , [ eq - g - in - k - comps ] for all @xmath126 .",
    "( for all @xmath127 , @xmath128 ) .",
    "eq.([eq - g - in - k - comps ] ) specifies @xmath1 linear equations for the @xmath1 components of @xmath129 expressed in terms of the @xmath1 components of @xmath130 .",
    "these equations can be easily inverted using gauss elimination to get :    k_= g_g_+1 g_+2 g_+3 .",
    "[ eq - k - in - g - comps ]    eqs.([eq - gk - comps ] ) can also be written in terms of the floor function :    [ eq - gk - floor ] g = k ,    k = g .",
    "as in section [ sec - notation ] , suppose @xmath99 represents a permutation on @xmath104 which generates a permutation on @xmath82 of the same name . clearly , @xmath131 is a grayish code .",
    "indeed , @xmath131 is a 1 - 1 onto map , and permuting bits the same way for all elements of a list preserves the property that adjacent @xmath1-tuples differ in only one component .",
    "( note , however , that it is easy to find @xmath99 s such that @xmath132 is not a grayish code .",
    "hence , to preserve grayishness , one must apply the bit permutation after @xmath116 , not before ) .",
    "in this section , we will review some well known facts about the so called hadamard , paley and walsh matrices ( a.k.a .",
    "transforms ) @xcite .    for any positive integer @xmath1",
    ", we define the @xmath1-bit hadamard matrix by    ( h_)_k , r= ( -1)^ _ = 0 ^ -1 k_r _ , the @xmath1-bit paley matrix by    ( p_)_k , r= ( -1)^ _ = 0 ^ -1 _ = 0 ^ -1 k_r__+ ^-1 , and the @xmath1-bit walsh matrix by    ( w_)_k , r= ( -1)^ _ = 0 ^ -1 _ = 0 ^ -1 k_r _ , where @xmath133 , @xmath123 and @xmath134 .",
    "we will often omit the subscript @xmath1 from @xmath135 in contexts where doing this does not lead to confusion .",
    "note that @xmath136 are real symmetric matrices .    for @xmath137 ,",
    "define the  reversal \" function @xmath138 , and the  negation \" function @xmath139 .",
    "the function @xmath140 for @xmath1-bit gray code has been defined previously .",
    "the functions @xmath141 , @xmath142 and @xmath140 are 1 - 1 onto so they can be used to define permutation matrices of the same name ( see section [ sec - notation ] . )",
    "we will often write @xmath105 , @xmath143 and @xmath116 instead of @xmath141 , @xmath142 and @xmath140 in contexts where this does not lead to confusion .",
    "note that @xmath105 and @xmath143 are symmetric matrices but @xmath116 is nt .",
    "next we will show that the @xmath1-bit hadamard , paley and walsh matrices all have the same columns , except in different orders .",
    "more specifically , @xmath144 are related to each other by the following equations :    h_r = p , p_g = w .",
    "[ eq - h - p - w - relations ] a more pictorial way of expressing eqs.([eq - h - p - w - relations ] ) is :    h p w .",
    "taking the transpose of both sides of eqs.([eq - h - p - w - relations ] ) leads to    _ r h = p , _",
    "g^t p = w .",
    "[ eq - h - p - w - transp - relations ] in the last equation , we have used the fact that matrices @xmath145 , @xmath146 are symmetric but @xmath116 is nt .    comparing eqs.([eq - h - p - w - relations ] ) and ( [ eq - h - p - w - transp - relations ] )",
    ", we see that    h_r = _ r h , [ eq - hs - r - sym ] and    p_g = _ g^t p .",
    "[ eq - ps - g - sym ] in fact , eq.([eq - hs - r - sym ] ) can be generalized as follows .",
    "suppose @xmath99 is a bit permutation on @xmath104 .",
    "then    ( _ b^t h _ b)_kr & = & h__b(k),_b(r ) + & = & ( -1)^ _ = 0 ^ -1 [ _ b(k ) ] _ _ + & = & ( -1)^ _ = 0 ^ -1 k _ ( ) r _ ( )   + & = & h_kr , so    h_b = _ b h . [ eq - hs - b - sym ] eq.([eq - hs - b - sym ] ) becomes eq.([eq - hs - r - sym ] ) when @xmath147 .    to prove eqs.([eq - h - p - w - relations ] ) , note that    ( h_r)_ik&= & _ j=0 ^ -1 h_ij(_r)_jk + & = & _ j(-1)^_i_j _ ( j = k^r ) + & = & p_ik . similarly ,    ( p_g)_ik&= & _",
    "j=0 ^ -1 p_ij(_g)_jk + & = & _ j(-1)^ _ , i_j__+^-1 ( j=_g(k ) ) + & = & ( -1)^ _ , i_(k_k_+1 ) _ + ^-1 + & = & ( -1)^ _ i_(k_-1- + k_- ) + & = & w_ik .",
    "the square of @xmath148 and @xmath149 is one . indeed , using eq.([eq - bool - delta - fun ] ) we get    ( h^2)_ik&= & _",
    "j=0 ^ -1 h_ijh_jk + & = & _ j_-1=0 ^ 1 ",
    "_j_1=0 ^ 1 _",
    "j_0=0 ^ 1 ( -1)^ _ = 0 ^ -1 ( i_+k_)j _ + & = & _ _ i_^k _ = _ i^k ,    p^2=(_r h)(h_r)=1 , and    w^2=(_g^t p)(p_g)=1 . since their square equals one , and they are real symmetric matrices , @xmath148 and @xmath149 are also orthogonal matrices .    from the definitions given above for @xmath150",
    ", one can prove by induction on @xmath1 that these matrices obey the following recursive equations :    _ r(0)=1 , _",
    "r(+1)= ,    _",
    "n ( ) , and    _ g(0)=1 , _ g(+1)= .    similarly , from the definitions given above for @xmath136 , one can prove by induction on @xmath1 that these matrices obey the following recursive equations :    h_0 = 1 , h_+1 = h _ ,    p_0 = 1 , p_+1= , and    w_0 = 1 , w_+1= .    by virtue of eqs.([eq - h - p - w - relations ] ) ,    w = h _ r _ g , [ eq - w - fun - h ] eq.([eq - w - fun - h ] ) means that the permutation @xmath151 will permute the columns of @xmath152 to give @xmath149 . expressing eq.([eq - w - fun - h ] ) in component form , we find    w_ij & = & _ r , k h_ir ( _ r)_rk ( _ g)_kj + & = & _ r , k h_ir ( r=_r(k ) ) ( k=_g(j ) ) + & = & h_i,_r_g(j ) .",
    "thus , if we denote the columns of @xmath153 and @xmath154 by @xmath155 and @xmath156 , respectively , then    _ j = _ _ r_g(j ) , [ eq - wi - def ] for @xmath157 .",
    "in this section , we will define a property of vectors called constancy .",
    "the columns of @xmath153 can be conveniently classified according to their constancy .    consider the 3-bit hadamard matrix :    h_3 = h_1 ^ 3=     & & & & & & & + & & & & & & & + & & & & & & & + & & & & & & & + & & & & & & & + & & & & & & & + & & & & & & & + & & & & & & & +    , [ eq - had3 ] where we have labelled the columns of @xmath158 by @xmath155 , where the index @xmath159 is given in its binary representation . according to eq.([eq - wi - def ] ) , to get @xmath160 from eq.([eq - had3 ] ) , one can simply reorder the columns of @xmath158 in bit - reversed gray code . the columns of @xmath158 ( and of @xmath160 )",
    "can be classified according to their constancy .",
    "we define the * constancy * @xmath161 of a vector @xmath162 to be the smallest number of identical adjacent entries of @xmath162 . for example , @xmath163^t)=1 $ ] and @xmath164^t)=2 $ ] .",
    "the next table gives the constancy of the columns of @xmath158 , with the columns listed in the order in which they appear in @xmath160 .",
    "000&000&000&8 + 001&001&100&4 + 010&011&110&2 + 011&010&010&2 + 100&110&011&1 + 101&111&111&1 + 110&101&101&1 + 111&100&001&1 +    .",
    "[ tab - const ] it is clear from eq.([tab - const ] ) that the columns of @xmath160 are listed in order of non - increasing constancy , and that the constancies of the columns of @xmath160 are all powers of 2 .",
    "the literature on walsh matrices often refers to the index that labels the columns of @xmath149 as the * sequency * of that column .",
    "thus , as sequency increases , constancy decreases or stays the same .",
    "sequency and constancy are analogous to frequency and period , respectively , in fourier analysis",
    ".    note that given any matrix @xmath40 , more than one of the columns of @xmath40 may have the same constancy .",
    "we will refer to : the number of columns of @xmath40 with the same constancy @xmath165 , as : the * multiplicity * * of the constancy * @xmath165 * in the matrix * @xmath40 , and denote it by @xmath166 . in this paper , we are only concerned with the case where @xmath40 equals the @xmath1-bit hadamard matrix so we will henceforth omit the subscript @xmath40 from @xmath166 .",
    "sometimes we will also abbreviate @xmath167 by @xmath168 , if doing this does not lead to confusion .",
    "the next table gives the multiplicity of the constancy @xmath165 in the @xmath1-bit hadamard matrix :    l|lllll ( = k)&k=1 & k=2 & k=4 & k=8 & + = 1 & 1 & 1 & 0 & 0 & + = 2 & 2 & 1 & 1 & 0 & + =3 & 4 & 2 & 1 & 1 & + & & & & & +    .",
    "[ tab - multi ] it is also convenient to define    ( )= _ k ( k ) .",
    "[ eq - cum - multi ] we shall call this the * cumulative multiplicity of the constancy*. the next table can be easily obtained from eq.([tab - multi ] ) and eq.([eq - cum - multi ] ) .",
    "it gives @xmath169 for the @xmath1-bit hadamard matrix .",
    "l|lllll ( )&=2 ^ 0 & =2 ^ 1 & =2 ^ 2 & =2 ^ 3 & + = 1 & 2 & 1 & 0 & 0 & + = 2 & 4 & 2 & 1 & 0 & + =3 & 8 & 4 & 2 & 1 & + & & & & & +    .",
    "[ tab - cum - multi ] it is clear from eq.([tab - cum - multi ] ) that @xmath170 , where @xmath171 .",
    "in this section , we discuss some symmetries of exact decompositions of @xmath3-multiplexors .    for simplicity , we will first consider the @xmath172-multiplexors used in ref.@xcite .",
    "ref.@xcite uses @xmath3-multiplexors that are more general than the @xmath172-multiplexors used in ref.@xcite . at the end of the paper",
    ", we will discuss how to generalize our results for @xmath172-multiplexors so that they apply to the more general multiplexors used in ref.@xcite .",
    "below , we will present some quantum circuit diagrams . besides the circuit notational conventions defined in refs.@xcite and @xcite , the circuits below will use the following additional notation . a square gate with an angle @xmath173 below the square will represent @xmath174 applied at that  wire \" . typically , we will consider a seo consisting of alternating one - qubit rotations and cnots .",
    "the seo will always have a one - qubit rotation at one end and a cnot at the other .",
    "the angle for the one - qubit rotation that either begins or ends the seo will be denoted by @xmath175 . given two adjacent angles @xmath176 and @xmath177 in the seo , @xmath178 and @xmath179 will differ only in one component , component @xmath180 , where @xmath180 is the position of the control bit of the cnot that lies between the @xmath176 and @xmath177 gates .",
    "if we take the hermitian conjugate of the multiplexor @xmath181 , and then we replace the angles @xmath182 by their negatives ( and also the angles @xmath176 , hadamard transforms of the @xmath183 , by their negatives ) , we get the same multiplexor back .",
    "henceforth , we will refer to this symmetry transformation as * time reversal*. thus , an @xmath172-multiplexor is invariant under time reversal .",
    "suppose @xmath99 is a bit permutation on @xmath184 bits .",
    "if we replace @xmath182 by @xmath185 ( and also @xmath176 by @xmath186 ) and @xmath187 by @xmath188 in the multiplexor @xmath181 , we get the same multiplexor back .",
    "henceforth , we will refer to this symmetry transformation as * bit permutation*. thus , an @xmath172-multiplexor is also invariant under bit permutation .",
    "fig.[fig - sym - ops ] shows how time reversal and bit permutation act on a sequence of one - qubit rotations and cnots .",
    "more examples of the application of these transformations will be given below .",
    "recall from ref.@xcite our definition of a general multiplexor with @xmath189 control qubits @xmath190 and @xmath191 target qubits @xmath192 : @xmath193 . in a multiplexor",
    "whose matrices @xmath194 are independent of the @xmath180 component @xmath195 of @xmath14 , we can sum @xmath196 over @xmath197 to get 1 .",
    "such a multiplexor acts as the identity on qubit @xmath180 .",
    "when representing such a multiplexor in a circuit diagram ,",
    "we can omit its half - moon node on qubit line @xmath180 .",
    "fig.[fig - free - half - moon ] shows a very special case of this principle , a special case that will be used in the circuit diagrams below .",
    "fig.[fig-1control ] shows two possible ways of decomposing an @xmath172-multiplexor with one control .",
    "the decomposition ( a ) in fig.[fig-1control ] is equivalent to :    ( i_bbool _ bp_b)=",
    "e^i_0(1 ) ( 1)^n(0 ) e^i_1(1 ) ( 1)^n(0 ) .",
    "[ eq - decomp-1control ] let lhs and rhs stand for the left and right hand sides of eq.([eq - decomp-1control ] ) . recall that @xmath198 and @xmath199 .",
    "eq.([eq - decomp-1control ] ) can be proven as follows :    [ eq - decomp-1control - proof ] @xmath200\\}}\\\\ & = & lhs \\label{eq - step - subst - theta } \\;.\\end{aligned}\\ ] ]    to arrive at eq.([eq - step - subst - theta ] ) , we expressed @xmath201 in terms of @xmath202 using    = .    if we take the hermitian conjugate of both sides of eq.([eq - decomp-1control ] ) , and then we replace the angles @xmath182 and @xmath203 by their negatives , we get    ( i_bbool _ bp_b)= ( 1)^n(0 ) e^i_1(1 ) ( 1)^n(0 ) e^i_0(1 ) . [ eq - decomp-1control - rev ] eq.([eq - decomp-1control - rev ] ) is equivalent to decomposition ( b ) in fig.[fig-1control ] .",
    "thus , decompositions ( a ) and ( b ) in fig.[fig-1control ] transform into each other under time reversal .",
    "fig.[fig-2controls ] shows four possible ways of decomposing an @xmath172-multiplexor with two controls .",
    "fig.[fig-2controls ] was obtained by applying the results of figs.[fig - free - half - moon ] and [ fig-1control ] .    in fig.[fig-2controls ] , note that decompositions ( a ) and ( b ) transform into each other under time reversal .",
    "decompositions ( c ) and ( d ) do too .",
    "furthermore , decompositions ( b ) and ( c ) transform into each other under bit permutation .",
    "the decompositions exhibited in fig.[fig-2controls ] can also be expressed analytically .",
    "for example , decomposition ( b ) is equivalent to :    @xmath204    eq.([eq - decomp-2-controls ] ) can be proven using the same techniques that were employed in eqs.([eq - decomp-1control - proof ] ) to prove eq.([eq - decomp-1control ] ) .",
    "the proof requires that we assume :    = .",
    "[ fig-3controls ] ( ditto , [ fig-4controls ] ) shows one of several possible decompositions of an @xmath172-multiplexor with 3 ( ditto , 4 ) controls . in general , decompositions for multiplexors with @xmath189 controls",
    "can be obtained starting from decompositions for multiplexors with @xmath205 controls .",
    "in this section , we finally define our approximation of multiplexors . we give the number of cnots required to express the approximant , and an upper bound to the error incurred by using it .",
    "so far we have used @xmath1 to denote a number of bits , and @xmath206 to denote the corresponding number of states .",
    "below , we will use two other numbers of bits , @xmath207 and @xmath208 , where @xmath209 and @xmath210 .",
    "their corresponding numbers of states will be denoted by @xmath211 and @xmath212 .",
    "define an @xmath213 dimensional matrix @xmath214 by v = h _ b _ g , [ eq - v - fun - h ] where @xmath99 is an arbitrary bit permutation on @xmath207 bits .",
    "eq.([eq - v - fun - h ] ) is a generalization of eq.([eq - w - fun - h ] ) .",
    "both equations define a new matrix ( either @xmath214 or the walsh matrix @xmath149 ) by permuting the columns of the hadamard matrix @xmath152 .",
    "@xmath214 becomes @xmath149 if we specialize the bit permutation @xmath99 to @xmath105 .",
    "if we denote the columns of @xmath214 by @xmath215 for @xmath216 , then    _",
    "j=__b_g(j ) , [ eq - vi - def ] which is the counterpart of eq.([eq - wi - def ] ) .    in ref.@xcite ,",
    "the decomposition of an @xmath172 multiplexor starts by taking the following hadamard transform :    = h _ , [ eq - theta - fun - phi ] where @xmath217 and @xmath218 .",
    "the vectors @xmath219 constitute an orthonormal basis for the space @xmath220 in which @xmath221 lives , so @xmath221 can always be expanded in terms of them :    = _ i=0 ^ -1 _ i ( _ i^ ) .",
    "now suppose that we truncate this expansion , keeping only the first @xmath222 terms , where @xmath223 and @xmath224 .",
    "let us call @xmath225 the resulting approximation to @xmath221 :    = _ i=0^-1 _ i ( _ i^ ) .",
    "[ eq - def - phi - prime ] define @xmath226 , an approximation to @xmath227 , as follows :    = h _ .",
    "[ eq - def - theta - prime ] if we let @xmath228 denote the standard basis vectors , then    h__i= _ _ b_g(i ) = _ _ b_g(i ) .",
    "therefore ,    = _ i=0^-1 _ _ b_g(i ) ( _ i^ ) .",
    "[ eq - theta - prime ]    by virtue of eq.([eq - theta - prime ] ) , if we list the components @xmath229 of @xmath226 in the grayish code order specified by the map @xmath230 , then the items in the list at positions from @xmath222 to the end of the list are zero .",
    "consider , for example , fig.[fig-2controls ] , which gives the exact decompositions for a multiplexor with 2 controls .",
    "suppose that in one of those decompositions , the angles @xmath203 s in the second half ( i.e. , the half that does not contain @xmath231 ) of the decomposition are all zero .",
    "then the one - qubit rotations in the second half of the decomposition become the identity .",
    "then the three cnots in the second half of the decomposition cancel each other in pairs except for one cnot that survives .",
    "the net effect is that the decomposition for a multiplexor with 2 controls degenerates into a decomposition for a multiplexor with only 1 control .",
    "the number of control bits is reduced by one in this example . in general",
    ", we can approximate a @xmath3-multiplexor by another @xmath3-multiplexor ( the  approximant \" ) that has fewer controls , and , therefore , is expressible with fewer cnots .",
    "we will call the reduction in the number of control bits the * bit deficit * @xmath10 . hence , @xmath232 .",
    "if @xmath4 denotes the number of cnots in an approximant with bit deficit @xmath10 , then it is clear from figs.[fig-1control ] , [ fig-2controls ] , [ fig-3controls ] and [ fig-4controls ] that :     n_cnot= & 2 ^ -1 & 2 ^ -2 & 2 ^ -3 & & 2 & 0 +    .",
    "[ eq - n - cnots ] hence , for @xmath233 , @xmath234 , but for @xmath235 , @xmath236 .",
    "the bit permutation @xmath99 on which the approximation of a multiplexor depends can be chosen according to various criteria .",
    "if we choose @xmath237 , then our approximation will keep only the higher constancy components of @xmath221 .",
    "such a smoothing , * high constancies approximation * might be useful for some tasks . similarly ,",
    "if we choose @xmath238 , then our approximation will keep only the lower constancy components of @xmath221 , giving a * low constancies approximation*. alternatively , we could use for @xmath99 a bit permutation , out of all possible bit permutations on @xmath207 bits , that minimizes the distance between the original multiplexor and its approximant .",
    "such a * dominant constancies approximation * is useful if our goal is to minimize the error incurred by the approximation .",
    "the error incurred by approximating a multiplexor can be bounded above as follows .",
    "let @xmath239 denote the @xmath172-subset of an @xmath172-multiplexor @xmath240 and @xmath241 that of its approximant @xmath242 .",
    "call @xmath243 the error of approximating @xmath240 by @xmath242 .",
    "note that    [ eq - error ] @xmath244    to arrive at step eq.([eq - step - ineq ] ) , we used the results of appendix [ ap - ineq ] .",
    "we will sometimes refer to @xmath245 as the linearized error , to distinguish it from the error @xmath243 .",
    "a simple picture emerges from all this .",
    "the error @xmath246 and the number of cnots @xmath4 are two costs that we would like to minimize .",
    "these two costs are fungible to a certain extent . given a multiplexor @xmath240 , and an upper bound @xmath247 on @xmath246 , we can use eqs.([eq - n - cnots ] ) and ( [ eq - error ] ) to find the approximant @xmath242 with the smallest @xmath4 .",
    "similarly , given a multiplexor @xmath240 , and an upper bound @xmath248 on @xmath4 , we can use eqs.([eq - n - cnots ] ) and ( [ eq - error ] ) to find the approximant @xmath242 with the smallest @xmath246 .    at this point",
    "we encourage the reader to read appendix [ ap - computer - results ] .",
    "it discusses the output of a computer program that calculates @xmath225 from @xmath221 via eq.([eq - def - phi - prime ] ) .",
    "next we will show that eq.([eq - def - phi - prime ] ) can be simplified considerably by taking into account the explicit values of the column vectors @xmath215 .    to get a quick glimpse of the simplification we seek ,",
    "consider first the special case @xmath249 .",
    "we have    h_2 =     & & & + & & & + & & & + & & & +    , w_2 =     & & & + & & & + & & & + & & & +    .",
    "define a matrix @xmath250 by    = (    cc 1 & 1 + 1 & 1    ) . for any matrix @xmath40 ,",
    "let @xmath251 be the submatrix of @xmath40 obtained by keeping only its columns from @xmath252 to @xmath159 .",
    "it is easy to check that    w_2(:,0:3 ) w_2(:,0:3)^t = diag(1,1,1,1 ) ,    w_2(:,0:1 ) w_2(:,0:1)^t = (    cc & 0 + 0 &    ) = ( ) , [ eq - w2-two - cols ] and    w_2(:,0:0 ) w_2(:,0:0)^t = (    cc & + &    ) = ( ) . in each case , we formed a  decimated matrix \" @xmath253 from @xmath149 , where @xmath223 .",
    "then we showed that the projection operator @xmath254 onto the column space of the decimated matrix , is a matrix whose entries are all either 0 or @xmath255 , and these entries sum to one along each row ( or column ) .",
    "given a set @xmath23 of real numbers , and given @xmath256 , call the average of the elements of @xmath257 a  partial average \" of the elements of @xmath23 . for example , if @xmath258 and @xmath237 , then @xmath259 and @xmath260 . from eq.([eq - w2-two - cols ] ) , the entries of @xmath225 are partial averages of the entries of @xmath221 .",
    "next we show how to simplify eq.([eq - def - phi - prime ] ) for arbitrary @xmath207 , not just for @xmath249 .",
    "define an @xmath213 dimensional matrix @xmath261 by    ^ ( , )_qs= _ r=0^-1 ( w_)_qr ( w_^t)_rs .",
    "[ eq - gamma - fun - w ] below , we will show that @xmath261 reduces to :    ^ ( , )_qs= ( = ) .",
    "[ eq - gamma - fun - floor ] for example , when @xmath262 , eq.([eq - gamma - fun - floor ] ) becomes    = =    c|cccc & 00&01 & 10&11 + & 1&1&0&0 + 01&1&1&0&0 + 10&0&0&1&1 + 11&0&0&1&1    .",
    "eqs.([eq - gamma - fun - w ] ) and ( [ eq - gamma - fun - floor ] ) are given in component form .",
    "the identical statements written in matrix form are , respectively ,    ^ ( ,  ) & = & w_(:,0:-1 ) w_(:,0:-1)^t + & = & w_w_^t , and    ^ ( ,  ) = ( ^_b)^ .",
    "eq.([eq - gamma - fun - floor ] ) can be proven from eq.([eq - gamma - fun - w ] ) as follows :    ^ ( , )_qs&= & _ r=0^-1 ( -1)^ _ = 0 ^ -1 _ = 0 ^ -1 ( q_r_+ r_s _ ) ( _ + ^ -1 + _",
    "+ ^ )   + & = & ( _ r_-1=0 ^ 1 _ r_1=0 ^ 1 _ r_0=0 ^ 1 ) ( r_-1 = r_-2 = = r_-_b=0 ) + & & ( -1)^ _ = 0 ^ -1 _ = 0 ^ -1 r_t _ ( _ + ^ -1 +",
    "_ + ^ ) ( where t = qs ) + & = & ( _ r_-1=0 ^ 1 _ r_1=0 ^ 1 _ r_0=0 ^",
    "1 ) ( r_-1 = r_-2 = = r_-_b=0 ) + & & ( -1)^ r_-1(t_0 + t_1 ) + r_-2(t_1 + t_2 ) + r_1(t_-2 + t_-1 ) + r_0(t_-1 )   + & = & 2 ^ -_b _ q_-1^s_-1 _ q_-2^s_-2 _ q__b^s__b [ eq - delta - fun - step ] + & = & ( = ) . to arrive at eq.([eq - delta - fun - step ] ) , we used eq.([eq - bool - delta - fun ] ) .",
    "recall that @xmath149 and @xmath214 can both we obtained by permuting the columns of @xmath152 :    w = h _ r _ g , and    v = h _ b _ g . from these two equations and from the fact , proven earlier , that @xmath99 and @xmath105 commute with @xmath152",
    ", we get    v = _ b _ r h _ r _ g = _ b _ r w . thus ,    & = & v_v_^t + & = & _ b _ r w_w_^t _ r _ b^t . hence ,",
    "if we define @xmath263 and @xmath264 by    = _ r _ b^t , = _ r _ b^t , then    = ^ ( ,  ) .",
    "[ eq - phi - pr - fun - phi ]    we see from eq.([eq - phi - pr - fun - phi ] ) that even when @xmath265 , the entries of @xmath264 ( which are the same as the entries of @xmath225 but in a different order ) are partial averages of the entries of @xmath263 ( which are the same as those of @xmath221 but in a different order ) . thus    _",
    "k(_k ) _ j _ k ( _ k ) , for all @xmath216 .",
    "this last equation implies        as we mentioned before , the quantum compiling algorithm of ref.@xcite uses @xmath3-multiplexors that are more general than the @xmath172-multiplexors considered above .",
    "luckily , the above results for @xmath172-multiplexors are still valid , with minor modifications , for the more general ones .",
    "indeed , the @xmath3-subset of the multiplexors used in ref.@xcite is of the form @xmath266 \\sigma_w^{f(b)}\\}_{\\forall b}$ ] .",
    "ref.@xcite defines vectors @xmath267 and @xmath268 from the parameters @xmath269 and @xmath270 , respectively .",
    "it then defines @xmath271 and @xmath272 as hadamard transforms of @xmath273 and @xmath274 , respectively , just as eq.([eq - theta - fun - phi ] ) defines @xmath227 as a hadamard transform of @xmath221 .",
    "we can define approximations @xmath275 and @xmath276 by replacing @xmath221 , @xmath227 , @xmath225 , @xmath226 by @xmath273 , @xmath271 , @xmath275 , @xmath276 , respectively , within eqs.([eq - def - phi - prime ] ) and ( [ eq - def - theta - prime ] ) .",
    "we can define approximations @xmath277 and @xmath278 analogously .",
    "the expansions of @xmath279 and @xmath280 in the @xmath281 basis can be truncated at the same @xmath222 .",
    "the table given in eq.([eq - n - cnots ] ) for the number of cnots still applies , except that @xmath4 may change by 1 if we eliminate the @xmath282 gate as in ref.@xcite .",
    "when a @xmath3-multiplexor @xmath240 with @xmath3-subset @xmath266 \\sigma_w^{f(b)}\\}_{\\forall b}$ ] is approximated by a @xmath3-multiplexor @xmath242 with @xmath3-subset @xmath283 \\sigma_w^{f(b)}\\}_{\\forall b}$ ] , one can show , using the results of appendix [ ap - ineq ] , that    -_2 _ b , which is a generalization of eq.([eq - error ] ) .",
    "in this appendix , we establish a well known(see ref.@xcite , page 574 ) upper bound for the distance ( measured in either the 2-norm or the frobenius norm ) between two @xmath284 matrices .",
    "let @xmath285 be 3d real vectors .",
    "define @xmath286 . if @xmath287 , then    e^i -e^i_2&= & e^i e^-i -1_2 + & & i_2 + & = & || .",
    "next , we will show that this approximation can be turned into an inequality .",
    "consider first the special case where @xmath288 and @xmath289 both point in the y direction .",
    "then    e^i - e^i_2 & = & e^i-1_2 + & = & (    cc ( ) -1 & ( ) + - ( ) & ( ) -1    ) _ 2 + & = & 2 ( ) (    cc - ( ) & ( ) + - ( ) & - ( )    ) _ 2 + & = & 2 |()| + & & || .    to find an upper bound for @xmath290 when either @xmath288 or @xmath289 does not point in the y direction , we will use the following identity . for @xmath291 and @xmath292 ,",
    "e^(a+e)t - e^at = _",
    "0^t ds e^a(t - s ) e e^(a+e)s .",
    "[ eq - diff - eq - sol ] to prove eq.([eq - diff - eq - sol ] ) , let @xmath293 and @xmath294 stand for the left and right hand sides of eq.([eq - diff - eq - sol ] ) .",
    "it is easy to verify that    ( l - r)(0)=0 , = a(l - r ) .",
    "this initial value problem has the unique solution @xmath295 .    in eq.([eq - diff - eq - sol ] ) , set @xmath296 , and @xmath297 , and take the 2-norm of both sides .",
    "this yields    e^i ( + ) - e^i _ 2 & & _ 0 ^ 1 ds e^i ( 1-s)_2 i _ 2 e^i ( + ) s _ 2 + & = & ||",
    ".    one can also find an upper bound for the distance , in the frobenius norm , between two @xmath284 matrices . if @xmath298 and @xmath299 , then the eigenvalues of @xmath300 are @xmath301 , for some real number @xmath173 . likewise , the eigenvalues of @xmath302 are @xmath303 .",
    "thus @xmath304 is real .",
    "if we denote the eigenvalues of @xmath305 by @xmath306 with @xmath307 , then @xmath308 has a single eigenvalue @xmath309 with algebraic multiplicity 2 .",
    "thus    e^i -e^i_f = e^i -e^i_2 .",
    "[ eq-2-f - norms ] but we ve already proven that @xmath290 is bounded above by @xmath310 so    e^i -e^i_f | | .",
    "in this appendix , we discuss a simple computer program that verifies and illustrates many of the results of this paper .",
    "our program is written in the octave language .",
    "octave is a gratis , open - source interpreter that understands a subset of the matlab language .",
    "hence , our program should also run in a matlab environment with few or no modifications .        ....",
    "phi(1)= 0.133765891 phi(2)= 0.270447403 phi(3)= 0.307625920 phi(4)= 0.311291575 phi(5)= 0.452735037 phi(6)= 0.569045961 phi(7)= 0.653136015 phi(8)= 0.867156088 ----------------------- permutation 1 = ( 1,2,3 ) delta_b , phi_prime= 0    0.134    0.270    0.308    0.311    0.453    0.569    0.653    0.867 1    0.293    0.420    0.480    0.589    0.293    0.420    0.480    0.589 2    0.387    0.504    0.387    0.504    0.387    0.504    0.387    0.504 3    0.446    0.446    0.446    0.446    0.446    0.446    0.446    0.446 ----------------------- permutation 2 = ( 1,3,2 ) delta_b , phi_prime= 0    0.134    0.270    0.308    0.311    0.453    0.569    0.653    0.867 1    0.293    0.420    0.480    0.589    0.293    0.420    0.480    0.589 2    0.356    0.356    0.535    0.535    0.356    0.356    0.535    0.535 3    0.446    0.446    0.446    0.446    0.446    0.446    0.446    0.446 ----------------------- permutation 3 = ( 2,1,3 ) delta_b , phi_prime= 0    0.134    0.270    0.308    0.311    0.453    0.569    0.653    0.867 1    0.221    0.291    0.221    0.291    0.553    0.718    0.553    0.718 2    0.387    0.504    0.387    0.504    0.387    0.504    0.387    0.504 3    0.446    0.446    0.446    0.446    0.446    0.446    0.446    0.446 ----------------------- permutation 4 = ( 2,3,1 ) delta_b , phi_prime= 0    0.134    0.270    0.308    0.311    0.453    0.569    0.653    0.867 1    0.202    0.202    0.309    0.309    0.511    0.511    0.760    0.760 2    0.356    0.356    0.535    0.535    0.356    0.356    0.535    0.535 3    0.446    0.446    0.446    0.446    0.446    0.446    0.446    0.446 ----------------------- permutation 5 = ( 3,1,2 ) delta_b , phi_prime= 0    0.134    0.270    0.308    0.311    0.453    0.569    0.653    0.867 1    0.221    0.291    0.221    0.291    0.553    0.718    0.553    0.718 2    0.256    0.256    0.256    0.256    0.636    0.636    0.636    0.636 3    0.446    0.446    0.446    0.446    0.446    0.446    0.446    0.446 ----------------------- permutation 6",
    "= ( 3,2,1 ) delta_b , phi_prime= 0    0.134    0.270    0.308    0.311    0.453    0.569    0.653    0.867 1    0.202    0.202    0.309    0.309    0.511    0.511    0.760    0.760 2    0.256    0.256    0.256    0.256    0.636    0.636    0.636    0.636 3    0.446    0.446    0.446    0.446    0.446    0.446    0.446    0.446 ....      .... error as function of ( permutation\\delta_b )              0            1            2            3     1     1.110e-16    2.779e-01    3.627e-01    4.215e-01     2     1.110e-16    2.779e-01    3.324e-01    4.215e-01     3     1.110e-16    1.491e-01    3.627e-01    4.215e-01     4     1.110e-16    1.070e-01    3.324e-01    4.215e-01     5     5.551e-17    1.491e-01    2.316e-01    4.215e-01     6     5.551e-17    1.070e-01    2.316e-01    4.215e-01 ....    in this example , @xmath311 so @xmath312 and @xmath313 .",
    "the first 8 lines of ` out_phis.txt ` give the components of @xmath221 . in this case , the computer picked 8 independent random numbers from the unit interval , and then it sorted them in non - decreasing order . ` my_moo.m ` can be easily modified so as to allow the user himself to supply the components of @xmath221 .    after listing @xmath221 , ` out_phis.txt ` lists the @xmath314 permutations @xmath99 of @xmath207 bits . for each @xmath99",
    ", it prints the components of @xmath225 , listed as a row , for each value of @xmath10(=row label ) .",
    "note that for @xmath315 , @xmath316 , and for @xmath317 , all @xmath318 are equal to the average of all the components of @xmath221 .",
    "note also that for all values of @xmath10 and @xmath159 , @xmath319 $ ] .",
    "the second output file , ` out_error.txt ` , gives a table of the linearized error @xmath245 as a function of permutation number(=row label ) and @xmath10(=column label ) .",
    "as expected , the error is zero when @xmath10 is zero , and it is independent of the permutation @xmath99 when @xmath10 is maximum ( when the bit deficit @xmath10 is maximum , the approximant has no control bits , so permuting bits at positions @xmath320 does not affect the error . )    note that in the above example , the last permutation minimizes the error for all @xmath10 .",
    "this last permutation is @xmath321 ( bit - reversal ) , and it gives a high constancies expansion . recall that for this example , ` my_moo.m ` generated iid ( independent , identically distributed ) numbers for the components of @xmath221 , and then it rearranged them in monotonic order .",
    "when @xmath221 is chosen in this way , the graph @xmath322 has a high probability of lying close to a straight line , and a high constancy staircase is the best fit for a straight line .",
    "for this reason , almost every time that ` my_moo.m ` is operated in the mode which generates iid numbers for the components of @xmath221 , the high constancies expansion minimizes the error for all @xmath10 .",
    "however , this need not always occur , as the following counterexample shows . try running ` my_moo.m ` for @xmath323 , and for @xmath221 with its first 7 components equal to 0 and its 9 subsequent components equal to 1 . for this @xmath221 , and for @xmath324 , the high constancies expansion yields an error of 7/8 while some of the other expansions yield errors as low as 5/8 .    note that although ` my_moo.m ` visits all @xmath314 permutations of the control bits , visiting all permutations is a very inefficient way of finding the minimum error .",
    "in fact , the @xmath314 control bit permutations can be grouped into equivalence classes , such that all permutations in a class give the same error .",
    "it s clear from fig.[fig - approx ] that we only have to visit @xmath325 ( recall @xmath326 ) equivalence classes of permutations . whereas @xmath327 is exponential in @xmath207 , @xmath328 is polynomial in @xmath207 for two very important extremes .",
    "namely , when @xmath10 or @xmath208 is of order one whereas @xmath207 is very large . indeed , if @xmath329 or @xmath330 , then @xmath331 ; if @xmath332 or @xmath333 , then @xmath334 , etc ."
  ],
  "abstract_text": [
    "<S> a quantum compiling algorithm is an algorithm for decomposing (  compiling \" ) an arbitrary unitary matrix into a sequence of elementary operations ( seo ) . </S>",
    "<S> suppose @xmath0 is an @xmath1-bit unstructured unitary matrix ( a unitary matrix with no special symmetries ) that we wish to compile . for @xmath2 , expressing @xmath0 as a seo requires more than a million cnots . </S>",
    "<S> this calls for a method for finding a unitary matrix that : ( 1)approximates @xmath0 well , and ( 2 is expressible with fewer cnots than @xmath0 . </S>",
    "<S> the purpose of this paper is to propose one such approximation method . </S>",
    "<S> various quantum compiling algorithms have been proposed in the literature that decompose @xmath0 into a sequence of @xmath3-multiplexors , each of which is then decomposed into a seo . </S>",
    "<S> our strategy for approximating @xmath0 is to approximate these intermediate @xmath3-multiplexors . in this paper </S>",
    "<S> , we will show how one can approximate a @xmath3-multiplexor by another @xmath3-multiplexor that is expressible with fewer cnots . </S>"
  ]
}