{
  "article_text": [
    "fpgas combine the performance of an asic implementation with the flexibility of software realizations .",
    "partial runtime reconfiguration is an applicable technique to overcome significant area overhead , monetary cost , higher power consumption , or speed penalties as compared to asics ( see e.g.  @xcite ) . by loading just the required modules to an fpga at runtime , it is possible to build smaller systems and less power - hungry devices .",
    "for instance , an embedded system may start up with some boot - loader and test modules .",
    "these modules may be exchanged by a crypto - accelerator to speed up the authentication process of the user .",
    "later , different modules will be loaded to the fpga by partial runtime reconfiguration with respect to the user demand or the state of the system .",
    "note that many systems provide mutually exclusive functionality ( e.g. , the record or the play mode of a multimedia device ) that is suitable to share some fpga resources at runtime .",
    "furthermore , modules need to communicate with other modules to accomplish their tasks .",
    "therefore , a suitable communication infrastructure must be applied and the implied costs in terms of time and area resources must be respected . this challenge and possible solutions",
    "are discussed in section  2 .",
    "dynamically reconfigurable , tile - oriented system .",
    "the system shares some logic tiles @xmath0 and memory tiles @xmath1 among a set of modules within the dynamic part of the system .",
    "some modules require a memory tile at a fixed offset with respect to the start position within the modules ( e.g. , the third tile of @xmath2 is a memory tile ) . ]",
    "when using such systems , an efficient resource management becomes necessary .",
    "one problem that has to be solved at runtime is the fragmentation of the tiles due to the time - dependent execution of some modules on the same resource area .",
    "it is assumed that for dynamically partially reconfigurable systems , modules are to be vertically aligned column by column , as shown in fig .",
    "[ fig : fpga_system ] .",
    "accordingly , a module requiring multiple tiles to implement its logic will demand a consecutive adjacent set of tiles without any gaps .",
    "this problem is discussed in this paper .",
    "the ever - increasing capabilities of modern reconfigurable devices give rise to a large number of new challenges ; solving one of them in turn gives rise to new possibilities and challenges .",
    "as described above , there are new solutions for dealing with the communication of relocated devices ; this opens up new possibilities for dynamic relocation of modules .",
    "the resulting challenge is the dynamic allocation of module requests to a reconfigurable device : given an array - shaped reconfigurable device and a sequence of module requests of varying resource requirements ( e.g. , logic tiles or memory blocks ) , assign each module to a contiguous set of slots on the device ; see fig .",
    "[ storagealloc : fig](a ) .    at first glance",
    ", this problem has a striking resemblance to one of the classical problems of computing : _ dynamic storage allocation _ considers a memory array and a sequence of storage requests of varying size , looking for an assignment of each request to a contiguous block of memory cells , such that the length of each block corresponds to the size of the request .",
    "once this allocation has been performed , it is static in space : after a block has been occupied , it will remain fixed until the corresponding data is no longer needed and the block is released . as a consequence",
    ", a sequence of allocations and releases can result in fragmentation of the memory array , making it hard or even impossible to store new data .    over the years",
    ", a large variety of methods and results for allocating storage have been proposed .",
    "the classical sequential fit algorithms , first fit , best fit , next fit and worst fit can be found in knuth  @xcite and wilson et al .",
    "@xcite .",
    "buddy systems partition the storage into a number of standard block sizes and allocate a block in a free interval of the smallest standard size sufficient to contain the block .",
    "differing only in the choice of the standard size , various buddy systems have been proposed @xcite .",
    "newer approaches that use cache - oblivious structures for allocating space in memory hierarchies include the works by bender et al .",
    "@xcite .",
    "there are notable differences between the dynamic allocation of modules to a reconfigurable device and dynamic storage allocation .",
    "first of all , all modules on a reconfigurable device may execute in parallel , while on a standalone processor , large blocks in memory are not used simultaneously .",
    "reconfigurable devices do not provide techniques such as paging and virtual memory mapping that allow arranging memory blocks next to each other in a virtual way , while they are physically stored at non - adjacent positions .",
    "the reconfiguration of a module on a reconfigurable device implies delays , and an inter - module communication infrastructure is required , because the functionality of a reconfigurable device may depend on other modules and external periphery .",
    "modules on a reconfigurable device can be relocated to a different location on the reconfigurable device , this can even be done at runtime . however , today s synthesis tools still lack support for placing a module implementation at different positions : these tools often allow placing a module at only one specific position ; thus , we can not use the same implementation binary for different positions on the reconfigurable device .",
    "different techniques have been conceived to tackle this problem .",
    "one solution is to equip the reconfigurable device with a special reconfiguration - management unit that handles the modification of the module implementations at runtime such that they can be placed at the desired position .",
    "moreover , in order to relocate a running module , the module must be paused , the state must be temporarily saved , the module must be reconfigured at the new position , the state must be restored , and the module must get a signal to continue its work .",
    "different techniques have been developed for this task , one of them is presented by koch et al .  @xcite . in the future , reconfigurable devices may have additional support for task preemption .",
    "in contrast to memory and storage devices , reconfigurable devices often contain heterogeneities such as dedicated memories , dsps , or cpus .",
    "these units enable or increase performance in important application fields . but",
    "heterogeneities increase the complexity of defragmentation considerably : a module implementation possibly depends on a specific pattern of heterogeneous resources at the placement location in order to complete its task .",
    "the number of feasible positions of a module on a fpga can be increased by creating different implementations of the same module ( i.e. , with different positions for the heterogeneities ) , but this approach also requires additional storage space for module implementations . having different implementations of a module also increases the number of possibilities when defragmenting the module placements .",
    "thus , the complexity of the defragmentation problem increases .",
    "there is a huge amount of related work also from within the fpga community : becker et al .",
    "@xcite present a method for enhancing the relocatability of partial reconfigurability of partial bitstreams for fpga runtime configuration , with a special focus on heterogeneities .",
    "they study the underlying prerequisites and technical conditions for dynamic relocation . in the process , a method that circumvents the problem of having to find fully identical regions for the modules",
    "is solved by the creation of compatible subsets of resources , enabling a flexible placement of relocatable modules .",
    "gericota et al .",
    "@xcite present a relocation procedure for configurable logic blocks ( clbs ) that is able to carry out online rearrangements , defragmenting the available fpga resources without disturbing functions currently running .",
    "another relevant approach was given by compton et al .",
    "@xcite , who present a new reconfigurable architecture design extension based on the ideas of relocation and defragmentation .",
    "it is shown that with little run - time effort on the part of the cpu and little additional area - increase over a basic partially reconfigurable fpga , the reconfiguration overhead can be reduced tremendously .",
    "koch et al .",
    "@xcite introduce efficient hardware extensions to typical fpga architectures in order to allow hardware task preemption .",
    "furthermore , the technical aspects of applying hardware task preemption to avoid defragmentation are discussed .",
    "these papers do not consider the algorithmic implications and how the relocation capabilities can be exploited to optimize module layout in a fast , practical fashion , which is what we consider in this paper .",
    "koester et al .",
    "@xcite also address the problem of defragmentation .",
    "different defragmentation algorithms that minimize different types of costs are analyzed . with the help of a simulation model and a benchmark ,",
    "simulation results and algorithm comparisons are presented .",
    "however , the problem description differs in some major points ; for example , no heterogeneities in the reconfigurable area are considered .",
    "the general concept of defragmentation is well known , and has been applied to many fields , e.g. , it is typically employed for memory management .",
    "our approach is significantly different from defragmentation techniques which have been conceived so far : these require a freeze of the system , followed by a computation of the new layout and a complete reconfiguration of all modules at once .",
    "instead , we just copy one module at a time , and simply switch the execution to the new module as soon as the move is complete .",
    "this leads to a _",
    "seamless , dynamic defragmentation of the module layout _ , resulting in much better utilization of the available space for modules .",
    "the rest of this paper is organized as follows . in the following section  2 we give a description of the underlying model and assumptions of the reconfigurable device and application , giving rise to the problem description in section  3 .",
    "as it turns out , solving the corresponding optimization problem is np - hard , as shown in section  4 .",
    "however , for moderate module density , it is still possible to compute optimal results , as shown in section  5 . in section  6",
    ", we show that there are instances for which @xmath3 moves are necessary .",
    "this leads to a heuristic optimization method for higher densities , based on tabu search and described in section  7 .",
    "detailed experimental results are presented and discussed in section  8 showing an increase in the maximal free space in average by @xmath4 when applying our defragmentation techniques for fpgas with heterogeneities . on some inputs an increase up to @xmath5 is observed .",
    "concluding thoughts are presented in section  9 .",
    "each partial reconfiguration of a module on a reconfigurable device incurs a certain amount of reconfiguration overhead .",
    "the ratio between the reconfiguration time and the actual running time of the corresponding modules is highly application specific .",
    "we assume in our scenario that the reconfiguration time is sufficiently small compared to the execution times of modules used .",
    "of course , there are applications in which the reconfiguration overheads must be taken into account , because many different modules are loaded on the reconfigurable device and their execution times are not much higher than their reconfiguration times .",
    "however , the possibility of reconfiguring only a part of the reconfigurable device as well as techniques such as prefetching , latency hiding , and bitstream compression can significantly reduce the reconfiguration overheads . furthermore , even today , for many applications a module s reconfiguration time is much less than its execution time even today .",
    "so far , it is not known whether reconfiguration overheads will still play an important role for the performance of many applications in the future or not . in this paper , we assume that there will be also many applications in the future for which the reconfiguration overheads are no big issue .    in order to take more benefit from runtime reconfiguration",
    ", systems should be able to provide the reconfigurable resources in a very flexible way to the modules .",
    "therefore , a communication infrastructure is required , such that modules can communicate with each other , and to peripheral input / output devices . most related work for reconfigurable communication systems is still based on the assumption that the locations allowed for modules in a partially reconfigurable system are all fixed in size ( e.g. , lysaght et al .",
    "@xcite ) . consequently",
    ", such approaches do not allow for exchanging a large module with multiple smaller ones .",
    "this originates from a lack of adequate communication techniques suitable to connect multiple partially reconfigurable modules within the same resource area to the rest of the system",
    ". however , there are notable exceptions : koch et al .  @xcite present a system with a reconfigurable area partitioned into 60 tiles , each capable of connecting a tiny 8-bit module to the system using the so - called recobus .",
    "this allows it to implement larger interfaces or modules by combining multiple adjacent tiles ; e.g. , 4  tiles are required for building a 32-bit interface . in addition , the recobus can link i / o pins to the partially reconfigurable modules . furthermore",
    ", this approach of a reconfigurable bus demonstrates that high placement flexibility , low resource overhead , and high throughput can be achieved at the same time .    in some partially reconfigurable computing systems ,",
    "module communication in a neighbor - to - neighbor - based manner is preferred to using a reconfigurable bus system : for example , fpgas are also used in streaming applications , such as video processing and packet processing , where each module communicates concurrently with the next module in the pipeline such that the communication costs are kept low .",
    "if these systems will also benefit from defragmentation techniques highly depends on the communication constraints of the modules and on the individual reconfigurable computing system . in general , one option is to change the communication infrastructure of the modules to a more flexible system , such as a reconfigurable bus system .",
    "this may lead to increased communication costs , but at the same time , defragmentation techniques can place modules more freely , and thus yield better results .",
    "if the increase in communication costs is clearly amortized by the improvements due to better defragmentation results , then the reconfigurable system will benefit from this option . in a setting in which some modules in a reconfigurable computing system must be placed closely to each other ( e.g.",
    ", they may strongly rely on a fast neighbor - to - neighbor communication for performance reasons ) , these modules can be grouped together such that they are considered by the defragmentation strategy as a single module .",
    "therefore , either all these modules are moved to another position for defragmentation , or no module is touched .",
    "thus , defragmentation techniques for reconfigurable devices are flexible enough to accommodate all important technical aspects concerning module communication on fpgas .",
    "so far , there already exists an enormous and ever - growing number of different reconfigurable devices .",
    "most of their reconfigurable area consists of heterogeneities , special - purpose units such as dsps , cpus , or rams , which offer a considerable performance improvement for target applications .",
    "see , for example , fig .",
    "[ fig : fpga_system ] : this fpga has two different column types , _ logic tiles _ ( @xmath0 ) and",
    "_ memory tiles _ ( @xmath1 ) . the important challenge with heterogeneities",
    "are placement limitations : modules applying special - purpose units may not be freely relocated , but can be placed only at positions offering the same geometry of special purpose units ; the placement of a module within the reconfigurable resource area on the fpga must fit exactly to the particular module .",
    "thus , the number of free tiles is not sufficient to determine whether a module can be placed .",
    "for instance , @xmath2 in fig .",
    "[ fig : fpga_system ] has the resource requirement @xmath6 and can be placed only at the positions , , and , which are currently occupied by @xmath7 and @xmath8 . in the example",
    ", the system has 12 free logic tiles and 2 free memory tiles , but we are currently not able to place @xmath2 on the fpga , which requires just 4 logic tiles and 1 memory tile .",
    "note that our approach does not depend on a specific type of heterogeneity , it can also be applied to future reconfigurable devices with new kinds of heterogeneities .",
    "our approach is targeted at currently available fpgas and future reconfigurable devices . in our problem formulation , we assume a device that is capable of column - wise partial reconfiguration , i.e. , only whole columns of the reconfigurable area are exchanged .",
    "modern reconfigurable devices offer also the flexibility to reconfigure single cells in the reconfigurable area , but this kind of higher flexibility is not assumed in our problem formulation , because the column - wise reconfiguration is considered as an important case for these studies . therefore , one reason may be that the applied device can not provide that kind of higher flexibility , e.g. , in order to save unnecessary costs .",
    "many applications for reconfigurable devices work in a pipeline - based manner and employ modules that span over the whole column .",
    "they use only modules with the same heights , because allowing a greater level of flexibility concerning the placement would also imply higher resource overheads , e.g. , in terms of communication resources .",
    "furthermore , as long as the heights of all modules are equal , our approach can also be applied to cell - based reconfigurable devices using new abstraction layer : we introduce a new type of heterogeneity ( the `` separating heterogeneity '' ) that is not used by any module .",
    "then we simply connect the horizontal lines of cells of the device to form a single row , separated by this new heterogeneity ; see fig .",
    "[ fig:2dto1d ] .",
    "thus , any placement of a module on the abstract device can be mapped to a placement on the original device .",
    "our studies of the important case of column - based reconfiguration can also be applied to scenarios in which a cell - based reconfiguration and modules with differing heights are needed : the local search techniques applied in our approaches can also be used for finding another suitable place for a module in the two - dimensional space . the decision which steps to choose",
    "can also be extended from one to two dimensions .",
    "thus , the proposed approach is not strictly limited to the important case of column - wise reconfiguration .",
    "when modules are relocated for defragmentation , we have to distinguish between moving only the module configuration and the configuration together with the internal state . in the first case",
    ", we just make a copy of the reconfiguration data to the new position and start the next computation on the module at the new position ( e.g. , a discrete cosine transformation on the next frame in a video system ) . in the second case ,",
    "both modules have to be interrupted and the state ( represented by all internal flip - flop and memory values ) will be copied to the target module .",
    "it may not be enough to copy the configuration data to a new position , because the configuration bit files often imply a certain position .",
    "therefore , it is either necessary to alter dynamically the bit files , or to generate statically bit files for all possible positions .",
    "relocation of modules and related problems were already addressed in other works .",
    "furthermore , the communication between modules must be stalled during the relocation of the respective modules .",
    "thus , the communication infrastructure should be flexible enough to meet these requirements .",
    "as compared to the reconfiguration process , copying the state can be performed with short interruption when using hardware checkpointing ( for more details see koch et al .",
    "@xcite ) .",
    "if we allow overlapping regions for the defragmentation , e.g. , the source and the target module may overlap , then the interruption time can be dominated by the relocation process : an overlap prevents the possibility to copy the routing information and logic settings to the destination , while the original module is still running . in this case , the module must be stopped , the reconfiguration data and the state of the module must be copied to some ( external ) memory , and be restored at the destination .",
    "this procedure takes longer if the regions overlap . as a consequence",
    ", we will prevent our defragmentation algorithms from using overlapping regions to place modules .",
    "thus , switching from the original module to the new one can be optimized in such a way , that no input data is lost , and the downtime of the module is minimized .",
    "thus , a copy of module  without the state  can be reconfigured at the destination while the module is still running .",
    "therefore , switching between the two modules is very fast for modules that have only few state data to be copied .",
    "furthermore , our proposed defragmentation strategies move at most one module at a time to another position on the reconfigurable area .",
    "thus , only a single module is affected at a moment by the defragmentation process , while the remaining set of modules remains untouched .",
    "in this paper , we consider a reconfigurable device that allows allocating modules in a contiguous manner on an array @xmath9 of length @xmath10 ; modules will be denoted by @xmath11 .",
    "a module @xmath12 placed in the array occupies a contiguous interval on the reconfigurable device , denoted by @xmath13 .",
    "modules are always placed such that @xmath14 for @xmath15 ; that is , two different modules do not overlap .    modules placed in the array divide @xmath9 into sections that are occupied by a module and sections that are not occupied ; the latter are called _ free intervals _ , denoted by @xmath16 .",
    "partially reconfigurable devices allow us to relocate a module @xmath12 of size @xmath17 from interval @xmath13 to a new position @xmath18 within a free interval @xmath19 of size @xmath20 , provided that the following two conditions are fulfilled :    1 .",
    "no occupied section is chosen ( i.e. , @xmath21 ) .",
    "the size of the free interval is at least as big as the size of the module : ( i.e. , @xmath22 ) .",
    "the _ maximum defragmentation problem _ ( mdp ) asks for a sequence of relocation moves that maximizes the size of the largest free interval on the reconfigurable device .",
    "we distinguish between the _ homogeneous _ mdp , in which every cell in the array is equivalent , and the _ heterogeneous _ mdp , which accounts for heterogeneities in the given fpga . clearly , the heterogeneous mdp is more difficult .",
    "thus , we focus on the homogeneous mdp for our complexity results , as their harndess implies hardness of the more complicated , restricted versions .    the larger free interval after the defragmentation can allow to place and execute a module that could not be placed before .",
    "moreover , defragmentation helps to place modules at an earlier time .",
    "altogether , the _ makespan _ is reduced , i.e. , the total time that is needed to satisfy a sequence of requests ( i.e. , a sequence of modules @xmath23 ) , considering that every module @xmath12 needs a certain time , the _ duration _",
    "@xmath24 , to run on the fpga before it can be removed .",
    "in this section , we state two complexity results for defragmenting modules on a reconfigurable device : one for deciding whether one contiguous free block can be formed , and one for the maximization version of the ( homogeneous ) defragmentation problem .",
    "we show that the decision version is strongly np - complete and that no approximation algorithm with a useful approximation factor exists for the maximization version , unless p = np .",
    "we use a proof technique know as _ proof by reduction_. that is , we take a problem that is known to be hard and show how to transform an instance of the known problem to an instance of our problem .",
    "thus , if we had an efficient method for solving our problem , it could also be used for solving the other , hard problem .",
    "the problem 3-partition is the main ingredient of the reduction .",
    "it belongs to the class of strongly np - complete and can be stated as follows @xcite :    given : : :    a finite set of @xmath25 elements    @xmath26 with sizes    @xmath27 , a bound    @xmath28 such that @xmath29 satisfies    @xmath30 for    @xmath31 and    @xmath32 .",
    "question : : :    can the elements be partitioned into @xmath33 disjoint sets    @xmath34 , such that for    @xmath35 , @xmath36 ?    because the @xmath29 have a lower bound of @xmath37 and an upper bound of @xmath38 , each",
    "set @xmath39 contains exactly three elements .",
    "we state our complexity result :    the maximum defragmentation problem with free intervals @xmath40 is strongly np - complete .",
    "given an instance of the problem 3-partition with input @xmath27 and bound @xmath41 , we construct an instance of the mdp in the following way : we place @xmath42 modules @xmath43 @xmath44 with @xmath45 , @xmath46 , side by side , starting at the left end of @xmath9 .",
    "then starting at the right boundary of @xmath44 , we place @xmath47 modules of size @xmath48 , alternating with @xmath33 free intervals of size @xmath41 .",
    "we denote these modules by @xmath49 to @xmath50 and the free intervals by @xmath51 to @xmath52 .",
    "[ fig : npcomlete ] shows the overall structure of the constructed instance .",
    "now we ask for the construction of a free interval of size @xmath53 . because the size of the total free space is equal to @xmath54 , none of the modules @xmath55 can ever be moved .",
    "hence , the only way to connect the total space is to move the modules @xmath56 to @xmath44 to the free intervals .",
    "but any solution of this kind implies a solution to the given instance of 3-partition , concluding the proof of np - completeness .",
    "proving np - completeness for the decision version of a problem makes it interesting to consider _ approximating _ the size of the maximal constructable free intervals : instead of finding the best possible value @xmath57 , we may be content with an approximate value @xmath58 , as long as it can be found in polynomial time and is within a constant factor of @xmath57 .",
    "the next theorem shows that the existence of any algorithm with a useful approximation factor is unlikely , even if we only require an asymptotic factor .",
    "[ th:2 ] let @xmath59 be a polynomial - time algorithm with @xmath60 .",
    "unless p = np , @xmath61 must be big , i.e. , @xmath62 , for any @xmath63 , where @xmath64 denotes the number of modules , @xmath65 denotes the size of the largest free interval in the input , and @xmath66 the size of the largest module .",
    "refer to fig .",
    "[ fig : nolinapx ] . we will show that if @xmath59 is an @xmath61-approximation algorithm for @xmath67 , it can be used to decide whether a 3-partition instance is solvable . for a given instance with numbers @xmath27 and a bound @xmath28 ( recall that @xmath30 ) , we construct an allocation of modules inside an array , as shown in the figure . starting at the left end of the array we place @xmath42 modules side by side with @xmath68 , for @xmath31 .",
    "then , starting at the right boundary of @xmath44 , we place @xmath47 modules of size @xmath69 ( where @xmath70 is an arbitrary number of sufficient polynomially bounded size ; more details will follow ) , alternating with @xmath33 free spaces of size @xmath41 .",
    "now , for @xmath71 , we proceed with a free space of size @xmath72 , a module of size @xmath73 , a free space of size @xmath72 , and a module of size @xmath74 .",
    "note that the number of modules is @xmath75 and @xmath76 .",
    "we claim that @xmath77 if and only if the answer to the 3-partition instance is `` yes '' .",
    "if @xmath77 , consider the situation in which the first free space of size @xmath54 occurs . because none of the modules @xmath78 could be moved so far , and because the modules @xmath79 are larger than @xmath72 , the only way to create a free space of size @xmath54 is to place the first @xmath42 modules in the @xmath33 free spaces of size @xmath41 .",
    "this implies a solution to the 3-partition instance .",
    "if @xmath80 , we show that the instance of 3-partition can not be solved .",
    "if @xmath80 , then @xmath81 for some constant @xmath82 .",
    "the total free space has size @xmath83 .",
    "because @xmath84 , @xmath85 and @xmath33 , @xmath41 , @xmath82 , and @xmath86 are constant a straightforward computation shows that @xmath87^{1-\\varepsilon } \\hspace{-0.5 cm } + \\beta \\leq kb + \\frac{rb}{2 } = f \\ ; , \\ ] ] for large @xmath70 ( i.e. , we choose @xmath70 such that the second inequality holds ) . hence , a free space of size @xmath88 can not be constructed .",
    "conversely , a solution to the 3-partition instance allows the construction of a free space of size @xmath88 as follows .",
    "the first @xmath42 modules are moved to the @xmath33 free spaces of size @xmath41 .",
    "now , @xmath89 is moved to the free space of size @xmath54 and then , one after the other , @xmath90 is moved between the modules @xmath91 and @xmath92 , for @xmath93 .",
    "thus , we can conclude that the existence of a polynomial - time approximation method for the mdp can be used to decide the feasibility of 3-partition instances , i.e. , implies p = np .",
    "the number of modules , @xmath64 , their sizes , and the amount of free space on the reconfigurable area are highly dependent on the application to be executed and , furthermore , may also vary enormously during the execution of the application on a reconfigurable device . initially or at some later point in time , only a portion of the reconfigurable device may be used . for a rather moderate density",
    ", we conceived an efficient defragmentation routine .",
    "we consider a special case in which the homogeneous mdp can be solved with linear computing time in at most @xmath94 moves .",
    "we define the density of an array , @xmath9 , of length @xmath10 to be @xmath95 .",
    "we show that if the density is bound by @xmath96 the fraction of the total area occupied by the largest module ) , i.e. , @xmath97 the total free space can always be connected with @xmath94 steps by algorithm  1 .",
    "the idea of the algorithm  1 is to start with the leftmost module , and shift all modules as far as possible to the left , one after the other . in the second loop , we start with the rightmost module and shift modules as far as possible to the right , one after the other .",
    "as it turns out , this results in one connected free space .",
    "( note that in some cases , a single round of shifts is sufficient , which can easily be detected ; however , two rounds may be necessary if the initial configuration has small free intervals on the left . )    for proving correctness of algorithm [ alg : leftrightshift ] , we need the following two observations .",
    "both follow immediately from the definition of density and from ( [ eq : lowden2 ] ) ; in the following , @xmath98 denotes the size of free intervals @xmath99 .",
    "@xmath100    @xmath101    [ thm : totfslowden ] algorithm [ alg : leftrightshift ] connects the total free space with at most @xmath94 moves and uses @xmath102 computing time .",
    "the number of shifts and the computing time are obvious .",
    "we will show that at the end of the first loop , the rightmost free interval is greater than any module and therefore _ all _ modules can be shifted to the right in the second loop .",
    "let @xmath103 denote the free intervals in @xmath9 at the end of the first loop .",
    "then every @xmath99 , @xmath104 is bounded to the right by a module @xmath105 with @xmath106 ( otherwise @xmath107 could be shifted ) .",
    "if this holds for @xmath52 as well , we can conclude that @xmath108 , which contradicts ( [ eq : lowden4 ] ) .",
    "hence , there is no module to the right of @xmath52 , and we get with @xmath109    @xmath110    implying @xmath111 .",
    "as a consequence of the hardness and inapproximability results we focus on developing heuristic approaches for the mdp . in this section , we bound the number of steps needed by any algorithm that constructs a maximum free interval , even in the homogeneous version . in the next sections , we state a heuristic and give experimental results .",
    "there is an instance of the maximum defragmentation problem such that any algorithm needs at least @xmath3 steps to solve it .",
    "we construct the instance in the following way . for an even number @xmath64 , we place @xmath64 modules , indexed from left to right by @xmath112",
    ". the sizes of the modules are @xmath113 for @xmath114 .",
    "@xmath56 has a free interval of size @xmath115 to its left and @xmath116 has a free interval of size @xmath115 to its right .",
    "in addition , every pair of consecutive modules is separated by a free interval of size one , except for the pair @xmath117 and @xmath118 , which is separated by a distance of two . in this initial configuration",
    "we denote the free intervals by @xmath119 , and their sizes by @xmath120 .",
    "[ fig : lbnsquare ] shows an example for @xmath121 .",
    "the following properties of this instance are essential for the rest of the proof :    the module sizes @xmath113 , @xmath122 , are even .",
    "@xmath123 holds for any pair @xmath124 , @xmath125 ( i.e. , the total free interval between two modules of equal size is equal to the modules sizes ) .",
    "every module has to be moved at least once ( because of the small free intervals at the left and right end of @xmath9 ) .    for @xmath126",
    ", we have @xmath127 ; in particular , this means that the pair @xmath12 , @xmath128 can be moved only if @xmath124 , @xmath125 can be moved .    in the beginning , only the modules @xmath117 and @xmath118 with @xmath129 can be moved . using three moves ,",
    "a free interval of size four can be constructed .",
    "note that both modules have to be moved and that there can be a free interval of size four only if there is exactly one free interval between @xmath130 and @xmath131 .",
    "now we show by induction for @xmath132 from @xmath133 to @xmath115 that    at least @xmath134 steps are necessary to make a pair @xmath135 , @xmath136 movable after the pair @xmath105 , @xmath125 became movable and    in the situation in which @xmath135 , @xmath136 become movable , there is exactly one free interval between these two modules .",
    "both properties clearly hold for @xmath137 and we assume that @xmath124 and @xmath125 for @xmath138 became movable ( for the first time ) by the last step .    by part ( b ) of the induction hypothesis , the modules and free intervals in the area between @xmath135 and @xmath125 are currently arranged in the following order , described from left to right : a free interval of size one , a sequence of modules , a free interval of size @xmath107 , a sequence of modules , and a free interval of size one ( see fig .  [",
    "fig : lbnsquare2 ] ) .",
    "the modules in the rest of @xmath9 are still in their initial position ( otherwise @xmath124 and @xmath125 could have been moved earlier because of ( iv ) ) .",
    "property ( b ) is a straightforward implication of ( ii ) and we show that ( a ) holds as well .",
    "suppose for a contradiction that @xmath135 and @xmath139 can be made movable without shifting or `` jumping '' a module @xmath140 with @xmath141 , i.e. , without moving a modules that lies between @xmath135 and @xmath139 ) .",
    "we assume w.l.o.g .  that @xmath140 is in the same sequence as @xmath124 .",
    "thus , the distance from @xmath140 s left boundary to the right boundary of @xmath135 can be calculated as the sum of the sizes of modules lying on the left side of @xmath140 plus one . by ( i ) , this is an odd number .",
    "the same holds for the distance from @xmath140 s right boundary to the left boundary of @xmath139 .",
    "again using ( i ) , this implies that none of these intervals can completely be filled with other modules .",
    "hence , by ( ii ) , @xmath135 and @xmath139 can never be moved without moving @xmath140 .",
    "there are @xmath142 modules initially placed between @xmath135 and @xmath139 and each of them has to be moved .",
    "altogether , this implies a lower bound of @xmath143 on the total number of steps .",
    "for runtime defragmentation , we propose a tabu search with a tabu list of length @xmath133 , see algorithm  2 . in every iteration ,",
    "all homogeneous modules @xmath12 are moved to the left end and to the right end of the free intervals that are greater than or equal to @xmath17 .",
    "all inhomogeneous modules are moved to any feasible position .",
    "each move is evaluated by a fitness function that divides the size of the maximal free interval by the number of free slots .",
    "the move yielding the configuration with the highest fitness is chosen .",
    "ties are broken by choosing the first one .",
    "the resulting configuration is added to the tabu list .    if the current solution is the best one found so far , it is stored .",
    "the heuristic ends if either a fitness of @xmath144 ( i.e. , optimality ) is achieved or @xmath145 iterations have been performed .",
    "as seen above , there are instances for which @xmath3 moves are necessary .",
    "moreover , we conjecture that the number of necessary moves is in @xmath146 .",
    "= = = = : = 0 ; + _ tabulist _ : = \\ { } ; + _ maxfitness _ : = 0.0 ; + * while * ( _ counter _",
    "@xmath147 ) and ( _ maxfitness _ @xmath148 ) * do * + module @xmath12 in the array * do * + : = 0.0 + @xmath12 is homogeneous * then * + free interval @xmath19 * do * + move @xmath12 to the left end of @xmath19 + evaluate move + move @xmath12 to the right end of @xmath19 + evaluate move + move @xmath12 back to its original position +   +   + position @xmath149 for @xmath12 that is feasible and not blocked by another module * do * + move @xmath12 to @xmath149 + evaluate move + move @xmath12 back to its original position +   +   + @xmath150 _ maxfitness _ * then * + apply _ storedmove _ + store _ storedmove _ in _ tabulist _ + : = _ storedfitness _ +   +   + + + + * end while * +   + * procedure * evaluate move : + move is not stored in _ tabulist _",
    "+ @xmath151 size of the maximal free interval / number of free slots + @xmath150 _ storedfitness _ * then * + store move in _ storedmove _ + : = _ thisfitness _ +   +",
    "we performed a series of experiments for defragmentation based on scenarios of fpgas with and without heterogeneities and different densities ( i.e. , different ratios of occupied space compared to unoccupied space ) . fig .",
    "[ max : cf1 ] shows the results for two fpgas , both having 94 slots .",
    "the first fpga does not contain any heterogeneities , while the second one is an fpga with heterogeneities at positions 3 , 24 , 45 , 50 , 71 and 82 .",
    "moreover , we compared our heuristic to a simple greedy approach that moves every module to the most promising position ( i.e. , to the position for which the ratio of the size of the maximal free interval and the size of the total free space is maximal ) .",
    "generating the input was done in two steps , depending on the size of the maximal free interval @xmath152 . in the first step",
    "the module size is chosen with equal probability from the set \\{@xmath153}. this ensures that the modules can be inserted .",
    "the exact position is chosen again with equal probability among all feasible positions .",
    "if the interval occupied by the module contains an heterogeneity , this heterogeneity is assigned to the corresponding position of the module .",
    "the size of the first module is shrunk by a factor of @xmath154 in order to ensure that it can be moved .    for the density ranging from @xmath155 to @xmath156 with steps of size @xmath157",
    ", we performed 100 runs of the tabu search and the greedy strategy for each value and took the average value of the _ number of free intervals _ and the _ size of the maximal free interval_. the results are shown in fig .",
    "[ max : cf1 ] .",
    "the diagrams show the size of the maximal free interval ( top row ) of the array and the number of free spaces ( bottom row ) before and after the defragmentation . in the array with no heterogeneities ( left column )",
    ", there is an improvement of up to 40% . on the fpga ( right column )",
    "the size of any maximal free interval is limited to @xmath158 slots due to the heterogeneities . for a density of less than @xmath159",
    ", the tabu search achieves this upper bound for almost all instances . for larger densities",
    ", it achieves an improvement of approximately 35% .",
    "the change in the number of free intervals before and after defragmentation is displayed in the right charts of fig .",
    "[ max : cf1 ] . in the array with no heterogeneities",
    "there is an increase of 50% . for the fpga",
    "there is almost no improvement for low densities ( less than @xmath159 ) and an improvement of approximately 25% for larger ones .",
    "+      in this section , a case study is given that demonstrates the efficiency of the proposed techniques and how they can be applied to a real - world scenario .",
    "we assume a dynamically partially reconfigurable device , whose reconfigurable area is separated into @xmath160 columns , also called _",
    "slots_. modeling typical fpgas , some of these slots contain no logic resources , but a heterogeneities such as blockrams .",
    "this setting is illustrated in figure  [ fig : casestudy_initial1 ] .",
    "furthermore , assume that one or multiple applications with a collection of modules are executed on this device ; e.g. , these could a video processing and a number cruncher application whose current state can rather easily be saved and restored at a different position on the reconfigurable device with moderate costs . during the execution of the applications , different modules finish and",
    "are removed , while new modules need to be placed .",
    "thus , the free space on the reconfigurable device can be scattered over the whole reconfigurable area .",
    "this situation is illustrated in the upper part of figure  [ fig : casestudy_greedy ] .",
    "initial state in example scenario .",
    "the reconfigurable device consists of @xmath160 partially reconfigurable , empty slots .",
    "those containing a heterogeneity , such as blockrams , are marked below with an `` m '' . ]",
    "( top ) fragmented state in example scenario .",
    "free space is scattered over the whole reconfigurable area .",
    "( bottom ) free space after defragmentation with greedy approach.,title=\"fig : \" ]   ( top ) fragmented state in example scenario .",
    "free space is scattered over the whole reconfigurable area .",
    "( bottom ) free space after defragmentation with greedy approach.,title=\"fig : \" ]     tabu - search algorithm : defragmentation in four move steps ( shown from top to bottom).,title=\"fig : \" ]   tabu - search algorithm : defragmentation in four move steps ( shown from top to bottom).,title=\"fig : \" ]   tabu - search algorithm : defragmentation in four move steps ( shown from top to bottom).,title=\"fig : \" ]   tabu - search algorithm : defragmentation in four move steps ( shown from top to bottom).,title=\"fig : \" ]   tabu - search algorithm : defragmentation in four move steps ( shown from top to bottom).,title=\"fig : \" ]    the fragmented free space on the reconfigurable area is a common , unavoidable scenario , for which our proposed defragmentation techniques represent an applicable and efficient solution . our first approach , the greedy algorithm , selects in each setting a step that optimizes the resulting maximal contiguous free space . based on the state of the example in the upper part of figure  [ fig : casestudy_greedy ] , the greedy algorithm moves the module ",
    "g  to position @xmath161 .",
    "thus , a biggest free space is achieved within a single move . the heterogeneity requirements of module ",
    "g  are fulfilled at the time at this position : at position @xmath162 , blockrams are provided for the right part of the module .",
    "afterwards , no single move that provides an improvement on the maximum free contiguous space is possible .",
    "thus , the greedy algorithm terminates .",
    "note that the evaluation of each possible step in the algorithm checks the maximal free space by taking into account all contiguous free slots , no matter if they contain heterogeneities or not .    in our second approach ,",
    "the maximum free contiguous space is optimized using tabu search , see figure  [ fig : casestudy_ts ] . based on the state of the same example ,",
    "h  is relocated to slot position @xmath163 .",
    "this step yields a maximal , contiguous free space of four slots including a single blockram heterogeneity slot . in a second step , module ",
    "d  is moved to slot @xmath164 , where module ",
    "h  was located before .",
    "thus , a new maximal free space is created starting at slot @xmath165 up to @xmath166 .",
    "all other steps would have created a free contiguous space with a size less than @xmath167 slots .",
    "further , this is also the only position to which module ",
    "d  can be moved , due to its heterogeneity constraints . in a third step ,",
    "f  is moved to the single empty slot without blockrams between module ",
    "b  and module  c  . in a next step , module ",
    "g  can be either moved to slot position @xmath165 or to slot position @xmath161 ; both satisfy its heterogeneity demands .",
    "finally , it is moved to the latter position , because this results in a maximal free space of @xmath166 slots .",
    "it is also possible that multiple single steps offer the same increase in contiguous free space ; in our current implementation , one single move is selected randomly .    when the greedy algorithm is applied to the example input , a contiguous free space of four slots",
    "is achieved .",
    "in contrast , the tabu search merges all free space and yields one single contiguous block of free space of size @xmath166 .",
    "this shows the usefulness of defragmentation techniques , and the importance of the corresponding strategy .",
    "similar scenarios of scattered empty space and heterogeneities on the reconfigurable device are common when executing modules .",
    "new modules with big area requirements must unnecessarily be delayed without defragmentation steps , which can be avoided with appropriate defragmentation strategies .",
    "how far different strategies can deviate is shown by comparing the results of the greedy and the tabu - search approach for this example .",
    "we also simulated the impact on the total makespan ( i.e. , the total execution time ) by randomly generating sequences of modules .",
    "a sequence consists of 200 modules , for each module we chose size and duration randomly using different distributions .",
    "[ smalltimes - fig ] and fig .",
    "[ bigtimes - fig ] show examples in which the size was chosen by normal distribution and duration according to an exponential distribution .",
    "we used the exponential distribution for the duration time , because this distribution models typical life times  @xcite .",
    "we normalized the duration times , i.e. , we define the time to write a single fpga column to be 1 time unit .    for each pair of size and duration values",
    ", we shuffled 100 sequences and calculated their makespan by simulating the processing of a sequence using tabu search , greedy , and no defragmentation .",
    "more precisely , we successively place the modules into an array that represents the fpga .",
    "if we can not place a module , because there is no sufficient free space , either the module has to wait ( no defragmentation ) or we perform the tabu search or the greedy strategy to compact the fpga .",
    "after the duration time for a module elapsed , it is removed from the array .",
    "our simulation takes the times needed to place or move a module into account ; the duration time is prolonged accordingly .",
    "it turned out that it pays off to use defragmentation for larger modules or larger duration times .",
    "small modules with small duration time enter and leave the system so quickly that there is no need for defragmentation , see fig .",
    "[ smalltimes - fig](left ) up to an average duration of 50 time units . at smaller module sizes and execution times , greedy",
    "s shorter running time beats the effectiveness of the tabu search ( fig .",
    "[ smalltimes - fig](left ) from 75 to 350 ) . however , as the average module size ( as a fraction of the total area ) or execution length increases , the more compact solution provided by the tabu search provides a better overall execution time , even with increased overhead ( fig .",
    "[ smalltimes - fig](left ) from 350 and fig .  [ bigtimes - fig](left ) ) . for modules of medium size (",
    "compared to the size of the fpga ) , the tabu search decreases the total makespan ( fig .",
    "[ smalltimes - fig](middle ) and fig .  [ bigtimes - fig](middle ) ) .",
    "if the average size of a module approaches or even exceeds half the size of the fpga , the benefit of compaction disappears ( fig .",
    "[ smalltimes - fig](right ) and fig .",
    "[ bigtimes - fig](right ) ) . note that in this case , compaction is often not even possible because the modules are too large to be moved .",
    "in this paper , we presented a new approach for defragmenting the module layout on a dynamically reconfigurable device , for example a fpga , in a seamless fashion .",
    "as the reconfiguration costs continuously decrease with each new generation of reconfigurable devices and a number of techniques for task preemption and relocation at a different positions are conceived ( see koch et al .",
    "@xcite for a comparison ) , task relocation at runtime becomes a new opportunity for improving the performance and efficiency of reconfigurable devices .",
    "however , this also poses new challenges , because defragmentation methods developed so far can not be applied to reconfigurable devices , as they do not take into account their special characteristics .",
    "for example , many reconfigurable devices have heterogeneities on their reconfigurable area , such as memory blocks , dsps , and cpus .",
    "we presented different defragmentation strategies to relocate running modules and achieve a contiguous free space of maximum size .",
    "the presented experiments show in average an increase in the maximal free space by @xmath168 when applying our defragmentation techniques to fpgas with heterogeneities ; on some inputs an increase up to @xmath5 is observed .",
    "this additional free space allows earlier execution of later modules , so the total execution time is reduced .",
    "this shows that it pays off to prefer a sophisticated heuristic for defragmentation ( e.g. , tabu search ) over a simple heuristic ( i.e. , greedy ) , or over no defragmentation at all ; provided that the execution times and module sizes are not too extreme ( i.e. , too large or too small compared to the size of the fpga ) .",
    "obviously , improved algorithmic results can lead to further improvements .",
    "one of the possible extensions considers a more controlled overall placement of modules , instead of simply fixing fragmentation . as",
    "the necessary algorithmic methods are more involved , we leave this to future work .",
    "we like to thank the anonymous referees for many valuable suggestions .",
    "all sections of the paper have been thoroughly revised and updated . in particular , section 1.2 , section 2 ( notably theorem 2 ) , and section 4 are substantially enhanced .",
    "section 6 , section 8.2 , and section 8.3 contain new material ."
  ],
  "abstract_text": [
    "<S> we propose a new method for defragmenting the module layout of a reconfigurable device , enabled by a novel approach for dealing with communication needs between relocated modules and with inhomogeneities found in commonly used fpgas . </S>",
    "<S> our method is based on dynamic relocation of module positions during runtime , with only very little reconfiguration overhead ; the objective is to maximize the length of contiguous free space that is available for new modules . </S>",
    "<S> we describe a number of algorithmic aspects of good defragmentation , and present an optimization method based on tabu search . </S>",
    "<S> experimental results indicate that we can improve the quality of module layout by roughly 50% over static layout . among other benefits , </S>",
    "<S> this improvement avoids unnecessary rejections of modules . </S>"
  ]
}