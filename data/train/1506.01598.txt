{
  "article_text": [
    "in the early stages of computers , storage was scarce . and it was even scarcer in the processor itself .",
    "the first computers supported basic arithmetic operations on small integers ( e.g. , 4 bits ) .",
    "as more memory was needed , the size of the registers in the processor architecture was increased to finally reach the current 64 bits .    while this was mostly driven by the size of the memory , which never failed to exceed the maximum value space at some point",
    ", this also had an impact on the size of integers and decimals processed ( e.g. , von - neumann @xcite ) .",
    "the numbers used in programs are of two main kinds : integers and decimals .",
    "integers are typically bounded to some range . in the case of decimals",
    ", it is a bit more complicated .",
    "they are limited both in their range ( driven by the size of their exponent ) and precision .    for scientists that need to use bigger numbers and/or more precision , special libraries are available , and domain - specific software @xcite @xcite @xcite make it possible to overcome the limitations of processors .    in the modern database era , notably document stores , syntaxes such as xml @xcite and json @xcite , but also their data models and the associated query languages ,",
    "do not impose any limitation on integers or decimals : on the logical level , the entire value space is covered and the limit is only the size of the available storage .    in the context of document stores ,",
    "decimal numbers need to be efficiently stored and retrieved , but they also need to be used as index values .",
    "indexing documents on decimal values is the primary use case for decimalinfinite . for efficiency reasons ,",
    "it is desirable that an index lookup can be done without decoding the decimals stored in a hash index ( point queries ) or a tree index ( range queries ) . in the latter case",
    ", this is possible when the ( lexicographic ) order of encoded values corresponds to the ordering of the corresponding numbers .",
    "then , only the queried decimals need to be encoded once , and the remaining comparisons occur on the binary sequences only .    when decimalinfinite was designed , to the extent of our knowledge and our investigations , state - of - the - art databases did not support yet such an encoding that would cover the entire decimal space ( that is , the entire value space of the xml xs : decimal type , or the entire value space of json numbers ) .",
    "however , many encodings exist that have some of the desired properties .",
    "decimalinfinite unifies the ideas in these encodings in such a way that all these properties apply simultaneously .",
    "in particular , none of the separate schemes used are new : decimalinfinite is only original in the way it puts them all together .",
    "this paper contributes an encoding that solves this problem .",
    "more recently , we became aware of the rishe encoding ( section [ section - rishe ] ) , which solves the same problem .",
    "however , decimalinfinite uses a different approach and does not require any calibration of choice of intervals .",
    "decimalinfinite also improves the asymptotic complexity for large decimals or integers .",
    "the encoding and decoding algorithms have been implemented in c++ and are used on production machines to store decimals as bson binaries @xcite , on a mongodb @xcite data store .",
    "another implementation is available in jsoniq @xcite : the encoding takes only 117 lines of code .",
    "the decimalinfinite encoding relies on decomposing the underlying decimal into a normal form , as is typically done in other encodings .",
    "this decomposition is made of an overall sign , an exponent sign , an exponent and a significand ( also called mantissa by von neumann , although , as is common practice , we prefer to avoid this terminology because of its different meaning for logarithm computation ) .",
    "these four components are encoded in turn and in this order .",
    "section [ section - related - work ] gives an overview of the integer and decimal encoding landscape .",
    "section [ section - ordering ] gives an overview of the main two ways of sorting sequences of bits .",
    "section [ section - encoding ] gives the algorithm for encoding decimals in the decimalinfinite format .",
    "section [ section - decoding ] gives the decoding algorithm .",
    "section [ section - proof ] gives a detailed proof of the main property of decimalinfinite ( that it is order preserving ) .",
    "section [ section - examples ] shows the encoding of the smallest integers .",
    "section [ section - fine - tune ] shows how the core of the encoding can be extended to special numbers ( nan , infinity , etc ) .",
    "section [ section - complexity ] briefly summarizes complexity aspects , including a comparison to the rishe encoding .",
    "section [ section - implementation ] gives a few implementation details .",
    "there are various encodings of integers and decimals commonly used in practice and found in literature . in general , one needs to distinguish between schemes for encoding digits and integers on the one hand ( possibly used to encode decimals with fix - point semantics ) , and schemes based on the former that support floating point encodings on the other hand .",
    "[ section - related - work ]      positive integers have a natural encoding which is simply their representation in base 2 , as shown on figure [ figure - natural - encoding ] .    [ cols=\"<,<,<\",options=\"header \" , ]      to save space , trailing zeros can be removed from the binary encoding and added back while decoding ( to fit the size of the last declet group ) .      in environments",
    "where encoding preserving lexicographic order is not supported across different lengths ( this is the case with mongodb s ordering of binaries ) , this encoding can be adapted to work at the cost of limiting the range .",
    "a prefix of the binary encoding can be taken as an approximation of the encoded decimal , possibly padded with leading 0s if too short .",
    "this works as long as the total stored lengths exceeds the length of the encoding of the sign and exponent , which limits the range .      as suggested by nathan hurst ,",
    "decimalinfinite can be turned into a prefix code ( self - delimiting ) .",
    "this can be achieved by adding a bit after each tetrade and declet in the significand encoding , to indicate whether further bits follow ( 1 ) or not ( 0 ) , as is done in the rishe encoding .",
    "the storage space is linear in the size ( number of digits ) of the significand , and logarithmic in the exponent , that is , double - logarithmic in the decimal .",
    "the encoding size of a decimal can be computed with :    @xmath0    where @xmath1 denotes the number of decimal digits in the significand .",
    "asymptotically , it can be approximated further with @xmath2 that is @xmath3    the encoding of the significand uses a common approach that is very compact in terms of entropy , and making it more compact ( for example , by grouping bits in bigger groups ) would increase computational complexity .",
    "the factor of @xmath4 is slightly better than the factor of 4 specified in @xcite , where 8 bits are on average necessary for each additional two significant digits . for the sake of a fair comparison ,",
    "note that the prefix - code version ( section [ section - prefix - code ] ) of decimalinfinite would increase the factor to @xmath5 . also , the rishe encoding of very small integers is , by design , more compact .",
    "the encoding of the exponent deviates from an optimal size by a constant factor of 2 , which is the cost of using the gamma prefix code . for large decimals",
    ", the rishe encoding contributes a factor of @xmath6 ( logarithmic ) to the exponent part ( semi - progressive intervals require 8 bits for an increase of 10 in the exponent ) , whereas decimalinfinite contributes only @xmath7 ( double - logarithmic ) .    if only non - negative integers ( @xmath8 ) are considered , then @xmath9 is asymptotically more significant than @xmath10 so that the encoding size grows logarithmically in @xmath8 , which is an optimal complexity ( see figure [ figure - size ] ) .",
    "this logarithmic complexity is identical to that of the rishe encoding , except that the constant is slightly lower ( 3.3 vs. 4.8 ) .",
    "[ figure - size ]    the blue lines show the fix - length binary natural representation on 32 , 64 and 128 bits on the range they cover .",
    "table integer_size.dat ; ; ; ;",
    "the encoding and decoding algorithms were successfully implemented in c++ , and are used to store json numbers lossless in bson binaries on an underlying mongodb layer .",
    "the decimals are stored with a special library supporting big numbers , however for efficiency reasons we do use classical limited - range integers when dealing with exponents or the number of digits of the decimal to encode .",
    "this is not a limitation of the decimalinfinite algorithm , but more a pragmatic decision that it is unlikely that decimals on the order of magnitude of @xmath11 , or with a precision of @xmath12 digits would be encountered in a real - life setting .",
    "unfortunately , mongodb does not use a full lexicographic ordering of binaries ( rather , pseudo - lexicographically ) , such that padding to a fixed length was needed for this vendor .",
    "the code has been running with no known issues on production servers since 2012 .",
    "also , an implementation in jsoniq is available on github @xcite , and is exposed publicly via a very basic rest api .",
    "we introduced a binary encoding that supports the entire decimal value space including special numbers , that does not lose precision , and that preserves the order , in the sense that the encoding is a homomorphism between the decimals ( sorted naturally ) and the bit sequences ( sorted fully lexicographically ) .",
    "this encoding is simple to explain : its specification in this paper fits on 2 pages .",
    "it is not parameterized in any way , making it implementable and understandable in a straightforward way .",
    "decimalinfinite was implemented on the 28.io platform with the help of matthias brantner and till westmann .",
    "also , many thanks to nathan hurst for his prompt and useful feedback ."
  ],
  "abstract_text": [
    "<S> this paper introduces a binary encoding that supports arbitrarily large , small and precise decimals . </S>",
    "<S> it completely preserves information and order . </S>",
    "<S> it does not rely on any arbitrary use - case - based choice of calibration and is readily implementable and usable , as is . </S>",
    "<S> finally , it is also simple to explain and understand . </S>"
  ]
}