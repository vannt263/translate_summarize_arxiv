{
  "article_text": [
    "programming language dino has a long history .",
    "originally it was designed , implemented , and used as a simple dynamically typed scripting language in a small computer game company . during its long life ,",
    "the language and its implementation were dramatically changed .",
    "the implementation was changed many times by using new tools , new virtual machines , by adding new optimizations .",
    "therefore its development could be a good case study of dynamic language implementation , simple , portable , and with a performance competitive with jit implementations of other popular dynamic languages .",
    "the first part of the article contains brief overview of the current version of the programming language dino .",
    "we describe the basic design of the language , its type system and particular features such as multithreading , heterogeneous extensible arrays , array slices , associative tables , first - class functions , pattern - matching , as well as dino s unique approach to class inheritance via the ` use ' class composition operator .",
    "the second part of the article describes dino s implementation .",
    "we outline the overall structure of the dino interpreter and just - in - time compiler ( jit ) and the design of the byte code and major optimizations .",
    "we also describe implementation details such as the garbage collection system , the algorithms underlying dino s data structures , dino s built - in profiling system , and the various tools and libraries used in the implementation .",
    "our goal is to give an overview of the major implementation decisions involved in a dynamic language , including how to implement a stable and portable jit .",
    "the third part studies the effect of design choices and major optimizations on dino s performance on x86 - 64 , aarch64 , and powerpc64 .",
    "we examine the choice to use a register - transfer virtual machine instead of a stack - based design and the effects of byte code combining , just - in - time compilation , and type inference with byte code specialization .",
    "the fourth part compares dino s performance with other popular dynamic language implementations , in order to better understand the combined effect of all described optimizations .",
    "performance results are given for the same three platforms as in the previous part .",
    "we conclude by giving possible directions of further research based on dino , whether by testing new optimizations or studying ways to improve the jit .",
    "in this section we describe the current version of the dino programming language .",
    "this section does not aim to give a formal or comprehensive specification , and there is a possibility that the omitted details might raise questions for the reader .",
    "however , our goal is to give a high - level language overview in order to see how the features of the language compare to those of similar dynamic languages and to understand how the implementation methods used for dino are applicable to other languages .",
    "the best way to proceed will be to give a series of small example programs . to start with ,",
    "the following is a dino implementation of the sieve of eratosthenes :    ....   1 .",
    "val sievesize = 8191 ;   2 .",
    "var i , prime , k , count = 0 , flags = [ sievesize : 1 ] ;   3 .   for ( i = 0 ; i < sievesize ; i++ )   4 .     if ( flags[i ] ) {   5 .",
    "prime = i + i + 3 ;   6 .",
    "k = i + prime ;   7 .       for ( ; ; ) {   8 .",
    "if ( k > = sievesize )   9 .",
    "break ; 10 .",
    "flags[k ] = 0 ; 11 .",
    "k + = prime ; 12 .       } 13 .",
    "count++ ; 14 .     } 15 .",
    "putln ( count ) ; ....    an initial design goal was to make dino resemble c whenever reasonable in order to reduce the learning curve for programmers familiar with c. according to a commonly used classification of programming languages , dino can therefore be thought of as a _ curly - bracket language_. variables in dino can hold values of any type , so dino is a _ dynamically typed language_. the scalar value types include _ char _ ( unicode character ) , _ integer _ ( 64-bit signed integers ) , _ long _ ( multi - precision integers ) and _ _ float__. dino types are themselves values .",
    "variables in dino should be declared ( lines 1 and 2 ) .",
    "the declaration scope of a variable starts from the declaration point and finishes at the end of the block containing the declaration .",
    "it can finish earlier if the identifier is redeclared in the block .",
    "the declaration scope includes nested blocks but excludes scopes of other declarations with the same identifier in the nested blocks . if a variable is declared by a _",
    "val _ declaration ( line 1 ) , then it is a constant whose value can not be changed .",
    "the structured value types include _ arrays_. in the above example , the variable flags holds an array of integers of size sievesize .",
    "each element of the array is initialized to integer value 1 ( line 2 ) .",
    "different elements of an array can hold values of different types .",
    "arrays are _ mutable _ by default , i.e. their elements can be modified , removed , and new elements can be inserted .",
    "an array can be transformed to become _ immutable _ by a special operation .",
    "_ slices _ of an array can be referenced and be used as operands of some operations .",
    "for example , the sieve of eratosthenes program from the previous section can be rewritten using slices :    .... 1 .",
    "val flags = [ sievesize : 1 ] ; 2 .",
    "var i , prime , count = 0 , sievesize = 8191 ; 3 .",
    "for ( i = 0 ; i < sievesize ; i++ ) 4 .     if ( flags[i ] ) { 5 .",
    "prime = i + i + 3 ; 6 .",
    "flags[i + prime : sievesize : prime ] = 0 ; 7 .       count++ ; 8 .     } 9",
    ".   putln ( count ) ; ....    line 6 in the above example contains an array slice .",
    "this slice refers to elements at indices starting from i+prime up to sievesize ( exclusive ) with step prime .",
    "while array elements are referenced by integer indices , dino also includes the associative array type _ table _ whose elements are referenced by _ keys _ that can be arbitrary values .",
    "table values can be built using the tab [ ] constructor :    .... 1 . tab [ \" string key \" : 10.0 2 .",
    "[ 1 , 2 ] : 2 , 3 .       tab [ 3 , 4 ] : [ 1 , 2 ] ] ....    the table element with value 10.0 is stored under a string key , while an array and another table are used as keys for the table elements in lines 2 and 3 respectively . as in the case of arrays ,",
    "tables can be mutable or immutable , and elements of mutable tables can be modified , added and removed .",
    "functions in dino are first class values . in other words , they can be assigned to variables , passed as parameters , returned as results from other functions and be stored within data structures . here",
    "are some example function declarations and function calls :    ....   1 .",
    "fun even ;   2 .",
    "fun odd   ( i ) { i = = 0 ? 0 : even ( i - 1 ) ; }   3 .",
    "fun even ( i ) { i = = 0 ? 1 : odd ( i - 1 ) ; }   4    putln ( odd ( 1000000 ) ) ;   5 .   7 .",
    "filter ( fun ( a ) { a > 0 ; } , v ) ;   8 .   fold ( fun ( a , b ) { a * b ; } , v , 1 ) ;   9",
    "fun incr ( base ) { fun ( incr_val ) { base + incr_val ; } } ....    according to dino scope rules , a declaration should be present before any usage of the declared identifier .",
    "thus , in the case of mutually recursive functions , we need to include a forward declaration .",
    "lines 1 - 4 of the above example provide an illustration .",
    "lines 7 and 8 provide an example of the use of _ anonymous _ functions .",
    "we pass the anonymous functions as parameters to the filter and fold functions .",
    "function values in dino always exist within a context , as the functions can refer to outside declarations .",
    "a function value considered along with its context is called a _",
    "closure_. the last line in the above example illustrates the use of closures .",
    "the function incr returns an anonymous function which in turn returns the sum of its parameter incr_val and the parameter base given to the corresponding call of incr .",
    "fiber _ in dino is a function which executes concurrently from its point of invocation .",
    "a fiber call being executed is called a _",
    "thread_. here is an example :    .... 1 .",
    "( n ) { for ( var i = 0 ; i < n ; i++ ) putln ( i ) ; } 2 .",
    "t(100 ) ; // the following code will not wait for t finish 3 . for ( var i = 0 ;",
    "i < 1000 ; i++ ) putln ( \" main \" , i ) ; ....    to synchronize threads , dino provides a basic wait statement :    ....      wait ( cond ) [ stmt ] ; ....    thread is concurrent but not parallel . in other words , the multithreading is implemented by so - called _ green threads _ , with the dino interpreter alternately executing statements from different threads .",
    "simple statements , e.g. statements that do not contain function calls , are atomic , i.e. can not be interrupted by another thread .",
    "some programming languages attempt to unify the functional and object - oriented approaches .",
    "for example , in scala a function is just another kind of object , and a function call invokes the method apply on the corresponding object .",
    "dino takes a bit of a different approach to unifying the two concepts . a class in dino is defined as a special kind of function which returns an entity called a _",
    "_ block instance _ _ representing the created object .",
    "the inner declarations of the block instance are publicly visible by default . here",
    "are some example class declarations :    .... 1 .",
    "class num ( i ) { fun print { put ( i ) ; } } 2 .",
    "class binop ( l , r ) { 3 .     fun print_op ; 4 .",
    "fun print { l.print ( ) ; print_op ( ) ; r.print ( ) ; } 5 .   } ....    line 1 contains the declaration of a class num with one function print and one public variable i whose value is initialized by the call to the class .",
    "lines 2 to 5 contain the declaration of an abstract class binop with two variables l and r , a defined function print and a function print_op which declared but not yet defined .",
    "dino has a powerful class / function composition operator _ use _ which can be used to _",
    "declarations from one class into another .",
    "this operator can be used to emulate _ inheritance _",
    "( including multiple inheritance ) , _ traits _ , and _",
    "dynamic dispatching_.    here is a continuation of the above example :    .... 6 .",
    "class add ( l , r ) { 7 .",
    "use binop former l , r later print_op ; 8 .",
    "fun print_op { put ( \" + \" ) ; } 9 .   } ....    line 7 contains a _ use_-clause which inlays the declarations ( functions and variables ) from class binop , making them available within the scope of add .",
    "the _ former_-clause overrides the l and r variables from binop with the l and r variables defined earlier in the declaration of add .",
    "likewise , the _ later_-clause overrides the print_op function inlaid from binop with the print_op function defined later in the declaration of add .",
    "the _ use_-clause provides a safe and powerful way to support object oriented programming .",
    "it has the following semantics :    1 .",
    "declarations from the class mentioned by the _",
    "use_-clause are inlaid into the current class .",
    "2 .   declarations from the current class that occur before the _",
    "use_-clause override inlaid declarations mentioned in the _ former_-clause .",
    "declarations from the current class that occur after the _ use_-clause override inlaid declarations mentioned in the _ later_-clause .",
    "4 .   declarations in the current class must _ match _ any inlaid declarations that they override .",
    "a declaration from the original class mentioned by the _",
    "use_-clause can be _ renamed _ and thus made available in the current class instead of simply being overridden .    a class that references another class via a _",
    "use_-clause becomes a _",
    "subtype _ of the referenced class .",
    "the subtyping relation is transitive . to test subtyping of a class or object , the standard function _",
    "isa _ can be used :    .... 1 .   isa ( add , binop ) ; 2 .",
    "isa ( add ( num ( 1 ) , num ( 2 ) ) , binop ) ; ....    dino provides syntactic sugar for declaring a singleton , which functions as an abbreviation for declaring an anonymous class , creating an object of the class and assigning it to a variable declared using _",
    "val _ :    .... 1 .",
    "obj coords { 2 .",
    "var x = 450 , y = -200 ; 3 .   }",
    "....      pattern matching is a useful instrument for distinguishing and decomposing values and extracting their parts into variables .",
    "dino s pattern matching mechanism can be used in a variable declaration or in a _ pmatch - statement_.    the following is an example of pattern matching in a declaration :    ....",
    "1 . try { 2 .",
    "var [ a , b , 2 , ... ] = v ; 3 .",
    "catch ( patternmatch ) { 5 .",
    "putln ( \" your assumption is wrong \" ) ; 6 . }",
    "....    the declaration on line 2 checks that the value of v is an array of at least 3 elements and that the third element of v is equal to 2 .",
    "if this is not the case , an exception will occur .",
    "the values of the first and second elements of v will be assigned to newly declared variables a and b respectively .",
    "the following is an example of pattern matching in a pmatch - statement :    .... 1 . pmatch ( v ) { 2 .",
    "case [ ... ] : putln ( \" array \" ) ; continue ; 3 .",
    "case [ a , ... ] : 4 .      if ( a = = 0 ) break ; 5 .",
    "putln ( \" array with non - zero 1st element \" ) ; 6 .",
    "case node ( v ) if v !",
    "= 0 : 7 .",
    "putln ( \" object of class node with nozero value \" ) ; 8 .",
    "case _ : putln ( \" anything else \" ) ; 9 . } ....    the pmatch - statement tries to match a value with the patterns in the case clauses and executes the code corresponding to the first matched pattern .",
    "the scope of variables defined in the pattern extends to statements within the case clause .",
    "continue _ statement within a case clause means that pattern matching should resume and continue to the subsequent case clauses . a _ break _",
    "statement exits the pmatch statement .",
    "there is an implicit break at the end of each case clause .",
    "the above example illustrates the possibilities of the pmatch statement , but the program used for the example is artificial .",
    "the following is a more realistic program using classes and pattern matching :    ....   1 .",
    "class tree { }   2 .",
    "class leaf ( i ) { use tree ; }   3 .",
    "class node ( l , r ) { use tree ; }   4 .",
    "fun exists_leaf ( test , t ) {   5 .",
    "pmatch ( t ) {   6 .      case leaf ( v ) : test ( v ) ;   7",
    ".      case node ( l , r ) :   8 .",
    "exists_leaf ( test , l ) || exists_leaf ( test , r ) ;   9 .    }",
    "10 . } 11 .",
    "fun has_odd_leaf ( t ) { 12 .",
    "exists_leaf ( fun ( n ) { type ( n ) = = int & & n % 2 = = 1 ; } , t ) ; 13 .",
    "} ....      the dino standard environment contains a variety of built - in functions ( input / output , higher order functions , regexp functions , functions for array / table manipulations , etc . ) and classes ( mostly describing various exceptions ) .",
    "this environment is small in comparison with the standard libraries of popular dynamic languages .",
    "the creation of a full set of standard libraries requires a lot of efforts and has not been a priority as dino was more of a research project for a long time . that said , there is one unique feature in the dino standard environment : a predefined class for the creation of parsers for programming languages or natural languages .",
    "the class implements an enhanced _ earley parser _ algorithm with _",
    "simple syntax directed translation_. it can parse according to ambiguous grammars , producing either a compact representation of _ all _ possible parse trees or a _ minimal cost _ parsing tree when costs are assigned to the grammar rules .",
    "the parser can perform syntax recovery , finding the _ minimal _ number of ignored tokens which produces a correct abstract syntax tree ( ast ) .",
    "it is also fairly fast , being capable of parsing about 250,000 lines of c language code per second on modern cpus .",
    "here is an example where the earley s parser built into dino is used to parse a tiny programming language :    .... expose yaep .",
    "* ; val grammar = \" term ident=301 , num=302 , if=303 ,                      then=304 , for=305 , do=307 , var=308 ;    program = program stmt                      # list ( 0 1 )    stmt = ident ' = ' expr ' ; '                   # asgn ( 0 2 )         | if expr then stmt else stmt          # if ( 1 3 5 )         | for ident ' = ' expr expr do stmt      # for ( 1 3 4 6 )         | ' { ' program ' } '                      # block ( 1 )         | var ident ' ; '                        # var ( 1 )         | error    expr = expr ' + ' factor                      # plus ( 0 2 )    factor = factor ' * ' term                    # mult ( 0 2 )    term = ident                                # 0         | ' ( ' expr ' ) '                         # 1 \" ; val p = parser ( ) ;        // create an earley parser p.set_grammar ( grammar ) ; // set grammar fun syntax_error ;         //",
    "forward decl of error reporting func val abstract_tree = p.parse ( token_vector , syntax_error ) ; ....",
    "unfortunately , the article size does not permit a description of all design decisions , algorithms and optimizations in full detail .",
    "only a high level overview is given , and only some important elements of the implementation are described in more detail .",
    "figure [ fig : dino - flow ] represents the general structure of the current dino implementation@xcite and the flow of data through it",
    ".    dino interpreter can be used in one of two modes .",
    "the first mode is a read - eval - print loop ( repl ) where a completed statement undergoes all processing stages including execution .",
    "the second mode is the standard batch mode , where the interpreter first processes all program files to generate byte code of the entire program and then executes the byte code .",
    "program byte code can be saved in a readable form , modified and read back for execution .",
    "the interpreter includes a function - level jit compiler which is implemented with the aid of a c compiler .",
    "the dino program can load and execute pic object files created from c code using a foreign function interface .",
    "the interpreter uses a memory heap with garbage collection .",
    "the heap can be automatically extended by demand .",
    "the interpreter performs a simple escape analysis to transform heap allocations into stack ones .",
    "the garbage collector uses a combination of the mark - and - sweep and the fast mark - and - copy strategies to prevent heap fragmentation and decrease program memory requirements @xcite .",
    "the first implementation of associative tables in dino was based on classical hash tables with buckets .",
    "the implementation was later changed to resizable hash tables without buckets .",
    "conflict resolution is achieved by secondary hashing .",
    "such an approach permits to decrease pointer chasing and results in more compact hash table representations and better data locality . with the right choice of maximal load factor for the hash table ,",
    "the implementation using secondary hashing compared to the implementation using buckets can be 1.5 times faster on modern processors .",
    "the hash table implementation based on secondary hashing was later adapted for use in the gcc compiler .",
    "the dino interpreter employs numerous optimizations to improve performance .",
    "below we discuss optimizations which are important from the performance point of view or widely described in research literature .",
    "although a lot of articles and discussions about dynamic language implementations are focused on _ byte code dispatch _",
    ", in our experience the choice of dispatch method was found to be relatively unimportant for the performance of the dino implementation . in the _ direct threaded code _",
    "method , each byte code instruction contains the address of the code responsible for execution of the next byte code instruction @xcite @xcite .",
    "for example , the ruby vm uses direct threaded code by default @xcite .",
    "although the code required for dispatch is very simple ( read the address and jump to it ) , implementing the direct threaded strategy requires a nonstandard extension to the c language which allows labels to be treated as values @xcite .",
    "the use of this extension prevents the compiler from performing some optimizations on the interpreter code ( e.g. predictive commoning ) .    the _ direct dispatch _",
    "method is based on a standard c switch statement .",
    "each case of the switch statement contains an implementation of a different byte code instruction .",
    "dino implementation experience shows that a _ proper _ direct dispatch implementation is more efficient on modern architectures . by ` proper ' , we mean that the compiler should be forced to generate optimized code for the switch statement if the number of all byte code intructions is less than 256 .",
    "the optimization results in the code for direct dispatch being compiled to a number of machine instructions comparable to that of the machine code for direct threaded dispatch .    to take advantage of hardware branch prediction",
    ", some authors proposed to replicate instructions or to make a direct switch at the end of each code responsible for executing a byte code instruction @xcite .",
    "this might work well when we have a small benchmark that takes advantage of the hot path , but in most real programs the bytecode will generally have different instructions adjacent to one another .",
    "the larger and more complex the benchmarks , and the more different types of byte code instructions the vm provides , the worse this approach will perform .",
    "the performance rapidly becomes worse than that of direct dispatch .",
    "in early dino implementation , the use of a proper direct dispatch implementation improved code performance for a simple loop benchmark up to 3% ( on a modern x86 - 64 architecture ) compared to the next - best direct threaded dispatch method .",
    "unfortunately , the latest dino implementation uses more than 256 byte code instructions .",
    "therefore we started to use the direct threaded code method as the best possible dispatch method for such number of byte code instructions .",
    "a much greater performance improvement can be reached by focusing on other issues than the choice of byte code dispatch .",
    "the most important aspect of the design is choosing the right byte code architecture for efficient execution .      _",
    "stack - based _ ( sb ) virtual machines ( vms ) are a fairly popular design for implementation of dynamic language interpreters .",
    "for example , the ruby vm uses a stack - based architecture @xcite @xcite .",
    "stack based byte code is compact and simple .    the previous implementation of dino vm used a stack - based design as well .",
    "the current implementation is based on a _",
    "register transfer language _ ( rtl ) . changing the virtual machine architecture from",
    "a stack - based to a register - transfer - language vm architecture improved code performance up to * 3 * times , which is bigger than the speedup reported in @xcite .",
    "the main advantage of rtl is a reduced number of instructions , as one rtl instruction can correspond to 3 or more sb byte code instructions . in many cases ,",
    "the reduced number of instructions decreases the overhead of byte code dispatch and reduces the amount of operand shuffling and type checking .",
    "moreover , there is greater scope for applying compiler optimizations to the bytecode interpreter itself if it is based on an rtl rather than an sb design .",
    "the benefit of rtl is even greater when we take into account the ability to perform optimizations on the byte code , including instruction combining , instruction specialization , and colour based variable allocation .",
    "these optimizations are very difficult or even impossible to implement for sb virtual machines .",
    "the current dino byte code format includes multi - operand instructions with 1 - 5 operands ( usually 3 ) , control flow instructions ( blocks , branches , calls , etc . ) , as well as instructions representing declarations such as vdecl ( variable declaration ) and fdecl ( function , class , and fiber declarations ) .",
    "dino byte code has two representations : an in - memory format for execution and a human - readable representation which can be output , modified , and input back by the interpreter for further execution .",
    "the dino code    ....    var i , n = 1000 ;    for ( i = 0 ; i < n ; i++ ) ; ....    is compiled to byte code which includes the following segments ( given in human - readable representation ) :    .... 0 block fn=\"ex.d \" ln=1 pos=1 next=730 vars_num=29 tvars_num=3 ... 372 vdecl ...",
    "ident = i ident_num=268",
    "decl_scope=0 var_num=27 373 vdecl ...",
    "ident = n ident_num=269 decl_scope=0 var_num=28 ... 788 ldi ...",
    "op1=28 op2=1000 //",
    "28 < - i1000 789 ldi ...",
    "next=791 op1=27 op2=0 //",
    "27 < - i0 790 btltinc ...",
    "next=792 op1=27 bcmp_op2=28 bcmp_res=29 pc=790 791 btlt ... op1=27 bcmp_op2=28 bcmp_res=29 pc=790 792 bend ... ....      choosing the right byte code representation is crucial , but there are other techniques which are important for attaining good performance .      reducing the number of executed instructions provides a performance advantage , due to reduced dynamic dispatch overhead and an increased scope for applying compiler optimizations when building the dino bytecode interpreter .",
    "the use of rtl representation is one way of achieving this .",
    "the same result can also be achieved by creating new bytecode instructions and using them to replace frequently executed chains of operations .",
    "such an optimization is performed by the dino interpreter .",
    "an analogous approach can be found in @xcite , where this optimization is called _ concatenation _ , or in @xcite , where it is called _ combining instructions into superinstructions_. the following example illustrates how the dino interpreter transforms byte code corresponding to an empty for loop :    ....    label : addi op1 , op1 , i1 ; lt res , op1 , op2 ; bt res , label = >    label : addi op1 , op1 , i1 ; blt res , op1 , op2 , label = >    label : btltinc op1 , op2 , i1 , res , label ....",
    "byte code combining improves the performance of the model benchmarks described in section [ model_benchmarks ] by about 1.5 times .",
    "a function is called pure if it has no side effects and its result always depends only on its argument values . when a pure function is called many times with the same arguments",
    ", we do nt need to calculate its result again .",
    "dino interpreter can save values of arguments and corresponding results of pure function calls and then reuse the results instead of performing the calculations again .",
    "this optimization can improve the performance of some benchmarks such as factorial or fibonacci by an order of magnitude .",
    "performance of frequently executed code can be improved by just - in - time compilation ( jit ) to machine code .",
    "there are a number of approaches to selecting which unit of code to compile .",
    "the most frequently used approach is _ trace - based _ selection .",
    "examples of trace - based jit implementations include the pypy implementation of python and most widely used javascript implementations .",
    "jit compilation can be implemented through a specialized jit framework ( e.g. jvm ) or by using more general compiler frameworks such as llvm or the gcc jit plugin @xcite @xcite .",
    "the dino interpreter uses function - level jit .",
    "function compilation is triggered by the first call .",
    "the function s byte code is translated into c function code . for each type of byte code instruction",
    "there is a corresponding c inline function . when building the dino interpreter , these functions are copied to a c - preprocessed file , which is included in the generated c code during jit compilation",
    "thus , the c translation of a function s byte code consists mostly of calls to these functions .",
    "a c compiler is called with the generated c code provided through a unix pipe .",
    "the c compiler produces a position independent code ( pic ) object file which is stored in the operating system s standard temporary directory . after successful compilation ,",
    "the interpreter loads the object file and calls the compiled function .",
    "this approach has many advantages .",
    "first of all , it results in a simple and portable jit implementation . in the dino interpreter ,",
    "the jit implementation required less than 100 new lines of c code , and can be used with any native c compiler .",
    "as the c language has a stable and well - defined standard , dino s portable jit implementation will continue to work in the future .",
    "on the other hand , if we had used the special - purpose interfaces provided by llvm and gcc for jit compilation , we would potentially need to update the interpreter in order to be compatible with future compiler versions .",
    "machine code generation by passing a c source file to the gcc frontend gives only a slight performance penalty compared to generation using the gcc jit plugin .",
    "in fact , jit compilation of a small dino function takes only about 50 - 70ms using gcc with -o3 on modern intel cpus .",
    "dino is a dynamically typed programming language .",
    "nevertheless , the types of many expressions and operands can be recognized during compilation time .",
    "unfortunately , even the peak optimization modes of industrial c compilers used for jit are not powerful enough to figure out the types of byte code operands and to remove unnecessary operand type checking .",
    "type recognition ( _ inference _ ) with byte code specialization can help significantly to improve jit performance .",
    "for example , when we know the types of operands , byte code specialization can transform the general add instruction into an integer variant iadd or a floating point variant fadd . on our model benchmark ,",
    "qualitative byte code specialization improves jit performance about 4.5 times . with the addition of combined and specialized instructions , the number of different byte code instructions in dino is 254 .",
    "the type inference algorithm in dino consists of the following major steps :    1 .",
    "building an _ all - program _ control flow graph ( cfg ) consisting of basic blocks and control flow edges connecting them .",
    "2 .   calculating available results of byte code instructions  this is a forward data - flow problem on the cfg .",
    "3 .   using the availability information , building def - use chains connecting possible operands and results of byte code instructions and variables .",
    "4 .   calculating the types of byte code instruction operands and results ",
    "this is a forward data - flow problem on the def - use graph .",
    "this algorithm is capable of recognizing the types of different usages of a variable even if the variable holds values of different types during an execution .",
    "this is a major difference from type inference in statically typed languages .",
    "dino has a number of language features and edge cases ( such as higher order functions , closures , threads and the possibility of accessing an uninitialized variable ) that make comprehensive type inference difficult .",
    "therefore we do not recognize all operand types which it is theoretically possible to recognize .",
    "a naive implementation of the class composition operator use that duplicates declarations can create a lot of additional code . therefore special attention during the implementation of dino and",
    "the design of its byte code was paid to avoiding this problem .",
    "in fact , no code duplication is produced by the current dino implementation of operator use .",
    "byte code corresponding to a function defined in one class and inlaid into another class is always reused .      after analyzing his program s behaviour , the programmer usually has the best knowledge about what should and should not be optimized .",
    "therefore dino allows the programmer to attach optimization hints to functions .",
    "currently , dino defines hints to request _ inlining _ , _ jit compilation _ , or _",
    "pure function optimization_.    let us look at how optimization hints can be used to tune the performance of the ` meteor - contest ' benchmark from the new version of the computer language shootout @xcite . using the built - in dino profiler ( option -p ) , we obtain the following output :    .... * * calls * * * time * * * * name * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *    761087         0.43   --   search1 : \" meteor.d \" : 229    561264         0.07   --   ctz : \" meteor.d \" : 28      1260         0.01   --   goodpiece : \" meteor.d \" : 37       ...                  0.51   --   all program ....    we know that ctz is a small function and by inlining it we can remove significant call overhead .",
    "function search1 is larger , and it may be better to compile it into native code using the jit compiler . after adding hints ! inline and !",
    "jit to the corresponding functions , we obtain the following profiler output :    .... * * calls * * * time * * * * name * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *    761087         0.15   --   search1 : \" meteor.d \" : 229       ...         0         0.00   --   ctz : \" meteor.d \" : 28       ...                  0.17   --   all program ....      the development of dynamic languages is usually an ongoing process .",
    "thus , it is important to develop tools that make it easier to implement and modify the language interpreter .",
    "the cocom toolset provides several tools that are used by the dino implementation .",
    "the most useful one is sprut , a compiler of internal representation ( ir ) descriptions .",
    "the description is given in an object oriented format .",
    "the sprut compiler generates code to create , access , modify , traverse , read and write the described ir format .",
    "additionally , in debug mode sprut can generate code to check constraints and relations given in the ir description .",
    "there are four ir descriptions included in the dino implementation .",
    "the first is a high - level ir used for semantic checking .",
    "the second is the dino bytecode format .",
    "the third format is a part of the foreign function interface and is used to specify run - time data which should be visible to external c functions .",
    "the last format describes all run - time data used by the dino interpreter .",
    "the following are some excerpts from the semantic ir description :    .... ... % abstract ir_node : : % root ; % abstract generic_pos : : ir_node % other    pos : position_t ; % abstract expr : : generic_pos ; % abstract operation : : expr ; % abstract binary_operation : : operation % other    left_operand , right_operand : expr ; % abstract unary_operation : : operation % other    operand : expr ; mult : : binary_operation ; typeof : : unary_operation ; ... ....    the following are excerpts from the bytecode description :    .... ... % abstract icode : : % root ; % abstract bcode : : icode % other    next : bcode    info : % root ; % abstract op1 : : bcode % other    op1 : int_t ; % abstract op2 : : op1 % other    op2 : int_t ; % abstract op3 : : op2 % other    op3 : int_t ; % abstract op3i : : op3 ; add : : op3 ; addi : : op3i ; ....    coding a parser manually can complicate language development . therefore the dino parser is implemented using a parser generator called msta .",
    "msta is a superset of yacc / bison , supporting lalr(k)/lr(k ) grammars with any fixed @xmath0 .",
    "msta also includes more sophisticated error recovery algorithms and implements many useful optimizations .",
    "msta generates about 25% faster parsers than bison .",
    "the third cocom tool used by dino is shilka , a generator of fast keyword recognizers .",
    "there are several components of the dino implementation that need to perform recognition of reserved identifiers , e.g. dino keywords , bytecode instruction names , and bytecode instruction fields .",
    "shilka s functionality is analogous to that of the gnu gperf package but its implementation uses minimal pruned o - tries .",
    "this approach makes shilka up to 40% faster than gperf .",
    "the cocom toolset also includes a library called ammunition .",
    "this library contains different packages useful for compiler / interpreter implementations , such as source position handling , error reporting , memory allocation handling , hash tables , sparse sets , earley parser etc .",
    "the dino implementation actively uses most of these .    additionally , the dino implementation uses the gmp ( multi - precision integer arithmetic ) , iconv ( different encodings support ) , and oniguruma regex libraries .",
    "one of the reasons for wide adoption of dynamic languages is the high - level nature of their operation .",
    "usually , performance of low - level operations is the weak point of dynamic language implementations .",
    "thus , we have chosen a benchmark which allows us to study the performance of low - level operations .",
    "the nested loops benchmark from the old version of the computer language shootout could serve well for this purpose @xcite .",
    "the dino version of this benchmark consists of the following code :    .... fun main {    var n = argv [ 0 ] < 1 ? 1 : int ( argv[0 ] ) ;    var a , b , c , d , e , f , x = 0 ;      for ( a = 0 ; a < n ; a++ )      for ( b = 0 ; b < n ; b++ )        for ( c = 0 ; c < n ; c++ )          for ( d = 0 ; d < n ; d++ )            for ( e = 0 ; e < n ; e++ )              for ( f = 0 ; f < n ; f++ )                x++ ;    putln ( x ) ; } main ( ) ; ....    we ran this benchmark using different dino vms and optimizations on three platforms : x86 - 64 , aarch64 , and powerpc64 .",
    "the machines used for testing were a 4.2ghz intel 4790k , a 2.4ghz applied micro aarch64 x - gene , and a 3.2ghz power8 running linux fedora core 21 .",
    "version 4.9.2 of gcc was used for jit compilation .",
    "each test was run 3 times on an unloaded machine and the minimal time was taken . the same command line argument ( 25 )",
    "was passed to the dino script in all runs .",
    "table [ tab : optimizations ] contains the cpu times of different runs of the benchmark in seconds .",
    ".performance effect of design decisions and optimizations ( cpu time given in seconds ) .",
    "[ cols= \" < , > , > , > \" , ]     this subset includes the following benchmarks :    * loop  execution of empty loop body .",
    "* hash  associative table operations .",
    "* fact  recursive factorial function .",
    "* fib  recursive fibonacci function . * except  exception handling .",
    "* method  object method calls . *",
    "object  object instantiation .",
    "* sieve  sieve of eratosthenes algorithm . *",
    "sort  sorting using the heapsort algorithm .",
    "* stat  calculation of statistical moments .",
    "* random  random number generation .",
    "* thread  passing data from a producer thread to a consumer thread .",
    "* start  an empty program that does nothing . *",
    "compile  a program that consists of a very long series of assignment statements .",
    "test machines used to run the benchmarks were a 3.4ghz i5 - 4670 ( x86 - 64 haswell ) , a 2.4ghz applied micro x - gene ( aarch64 ) , and a 3.5ghz power7 ( powerpc64 ) running linux fedora core 21 .",
    "language implementations used for the comparison include the python-3.3.x interpreter , the ruby-2.0.x interpreter , and the javascript-1.8.x spidermonkey and tracemonkey jits .",
    "results for the pypy-2.2.x trace jit for python and the scala-2.10.x jvm jit are given only for x86 - 64 as these systems are not yet implemented on the aarch64 architecture .",
    "the absence of results for pypy on powerpc64 is due to the same reason . finally ,",
    "although scala and the jvm are implemented on powerpc64 , unavailability of scala on the machine used for testing prevented us from obtaining the corresponding results .",
    "tables [ tab : x86 - 64 ] , [ tab : x - gene ] , and [ tab : power7 ] contain benchmark execution times on x86 - 64 , aarch64 , and powerpc64 platforms respectively .",
    "all times are scaled relative to the execution time of the dino version of the benchmark program .",
    "the best results for the dino version of the factorial and fibonacci benchmarks were achieved by using pure - function optimization .",
    "the best result for the dino version of the random number generator benchmark was achieved by using function inlining .",
    "results for some javascript benchmark programs are absent because the language does not support features needed for their implementation , or because javascript versions of these benchmark programs could not be found .",
    "on aarch64 the result for the javascript ` hash ' benchmark is given with jit disabled , as jit - enabled execution failed .",
    "scala results for the ` compile ' benchmark are absent , as scala failed to compile it .",
    "there are many venues for future research on dino .",
    "the effect of new optimizations ( such as improved type inference or fast variable allocation using a linear scan algorithm @xcite ) can be investigated .",
    "we also have plans to use dino to research various jit approaches .",
    "one way of improving jit can be achieved by maintaining a c compiler process ( or a pool of compiler processes ) on standby in order to avoid the overhead of starting up a compiler during jit compilation of each function .",
    "a very important research goal is to find improved ways of implementing jit based on gcc , as it is the most portable compiler infrastructure currently available .",
    "it is fairly reasonable to doubt that any jit compiler written from scratch can achieve the same level of portability .",
    "a possible way to improve a gcc - based jit compiler is to investigate which gcc optimizations actually improve the performance of the c code generated by the jit compiler . as described earlier , type inference is essential , as gcc is not able to propagate constants which represent operand types in a dynamic language program , nor can it remove code for checking operand types .",
    "some optimizations in gcc , e.g. loop invariant code motion , may also not work as well as expected when applied to c code generated by a jit compiler .",
    "this problem could be solved by improving the optimizations in gcc or by implementing some additional byte code level optimizations in the interpreter .",
    "another way to improve a gcc - based jit compiler could be to find the right combination of gcc optimizations which is fast enough but still considerably improves the performance of the generated c code .",
    "such a combination should aim to balance the time of jit compilation itself against the execution time of the generated code .",
    "some machine learning approaches could be used in order to find the best combination of optimizations depending on features of the generated code @xcite .",
    "still gcc - based jit can be quite expensive for some targets which have memory constraints or do not support files in memory .",
    "one such target is cygwin environment@xcite where using gcc - based jit results in a performance degradation in most cases .",
    "a simple light - weight jit implementation specialized for dino could be a solution .",
    "comparison of gcc - based jit and the light - weight jit with different points of view ( generated code performance , efforts to implement , used resources , startup time etc ) would be quite an interesting topic for research .",
    "there are also plans to develop dino from a research language into a language which could be widely used in practice . features planned for this purpose include type annotation , light - weight specialized jit , native os thread support for parallelism , rewritten standard libraries , and a more convenient foreign function interface .",
    "in addition to native support for parallelism , a more sophisticated model could be provided for synchronization .    during the long history of the dino programming language ,",
    "a lot of research has been done .",
    "part of this research was described in this article , including the effect of major implementation decisions on performance , some tools which can be used to simplify the implementation , and ways to implement a simple , portable , and stable jit .",
    "b. vitale and t.s .",
    "`` catenation and specialization for tcl virtual machine performance '' , _ proc . of the intl workshop on interpreters , virtual machines and emulators _ , pp . 42 - 50 , washington , dc , june 2004 .                                    k. sasada .",
    "`` yarv : yet another rubyvm : innovating the ruby interpreter '' , in _ companion to the 20th annual acm sigplan conference on object - oriented programming , systems , languages , and applications _ , acm , new york , ny , usa , pp . 158 - 159 .",
    "y. shi , k. casey , and m. anton ertl , and d. gregg .",
    "`` virtual machine showdown : stack versus registers '' . _",
    "acm transactions on architecture and code optimization ( taco ) _",
    ", volume 4 issue 4 , january 2008 article no ."
  ],
  "abstract_text": [
    "<S> the article gives a brief overview of the current state of programming language dino in order to see where its stands between other dynamic programming languages . </S>",
    "<S> then it describes the current implementation , used tools and major implementation decisions including how to implement a stable , portable and simple jit compiler .    </S>",
    "<S> we study the effect of major implementation decisions on the performance of dino on x86 - 64 , aarch64 , and powerpc64 . in brief , the performance of some model benchmark on x86 - 64 was improved by * 3.1 * times after moving from a stack based virtual machine to a register - transfer architecture , a further * 1.5 * times by adding byte code combining , a further * 2.3 * times through the use of jit , and a further * 4.4 * times by performing type inference with byte code specialization , with a resulting overall performance improvement of about * 47 * times . to put these results in context , we include performance comparisons of dino with widely used implementations of ruby , python 3 , pypy and javascript on the three platforms mentioned above . the goal of this article is to share the experience of dino implementation with other dynamic language implementors in hope that it can help them to improve implementation of popular dynamic languages to make them probably faster and more portable , using less developer resources , and may be to avoid some mistakes and wrong directions which were experienced during dino development .    </S>",
    "<S> languages , performance , algorithms    dynamic language , language design , interpreters , optimizations , jit </S>"
  ]
}