{
  "article_text": [
    "while congestion - aware routing problems have been studied intensively  @xcite , surprisingly little is known today about how to _ update _ the routes of flows in a capacitated network in a congestion - free manner .",
    "flow _ _ re__routing problems are not only natural and of fundamental theoretical interest , but also practically very relevant , e.g. , in the context of traffic engineering problems . for two reasons : first , we currently witness a renaissance of routing based on _ unsplittable flows _ : traffic engineering mechanisms based on rsvp - te  @xcite or openflow resp .",
    "software - defined networks ( sdns )  @xcite are based on unsplittable flows , to provide a better quality - of - service ( compared to traditional packet - switched networks ) .",
    "second , real networks are dynamic , and the ability to _ update routes _ is essential in a number of scenarios : to account for changes in the security policies , in response to new route advertisements , during maintenance ( e.g. , replacing a router ) , to support the migration of virtual machines , etc . with the advent of more programmable computer networks  @xcite ,",
    "traffic engineering is likely to become even more dynamic and adaptive , entailing more frequent route updates  @xcite .",
    "however , the migration of flows from their old ( simple ) paths to the given new ( simple ) paths can be challenging , due to the asynchrony introduced by imprecisions of clock synchronization protocols as well as by variations in the update times of the internal data structures of the router s forwarding tables  @xcite .",
    "in particular , updates simultaneously sent out by a logically centralized sdn controller or updates scheduled for a certain time at a certain router , can take effect _",
    "asynchronously_. accordingly , to avoid transient inconsistencies , the updates of the different flows at the different routers must be scheduled carefully : potentially conflicting updates should be scheduled at different times or _ rounds_.    figure  [ fig : ex ] presents an example of the congestion - free rerouting problem of unsplittable flows considered in this paper .",
    "\\(o ) [ ] ; ( u ) [ position=270:55 mm from o ] ;    ( c-1 - 1 ) [ position=180:55 mm from o ] ; ( c-1 - 2 ) [ position=0:0 mm from o ] ; ( c-1 - 3 ) [ position=0:55 mm from o ] ; ( c-2 - 1 ) [ position=180:55 mm from u ] ; ( c-2 - 2 ) [ position=0:0 mm from u ] ; ( c-2 - 3 ) [ position=0:55 mm from u ] ;    iin 1, ... ,2    in 1, ... ,3    ( s - i- ) [ fill , inner sep=0pt , minimum size=7pt , draw , circle , thick , scale=0.7,position=162:17 mm from c - i- ] ;    ( s - i--1 ) [ inner sep=0pt , position=330:0.72 mm from s - i- ] ; ( s - i--2 ) [ inner sep=0pt , scale=0.75,position=270:0.72 mm from s - i- ] ; ( s - i--3 ) [ inner sep=0pt , scale=0.75,position=90:0.72 mm from s - i- ] ; ( s - i--4 ) [ inner sep=0pt , scale=0.75,position=30:0.72 mm from s - i- ] ;    ( t - i- ) [ fill , inner sep=0pt , minimum size=7pt , draw , circle , thick , scale=0.7,position=18:17 mm from c - i- ] ;    ( t - i--1 ) [ inner sep=0pt , scale=0.75,position=270:0.72 mm from t - i- ] ; ( t - i--2 ) [ inner sep=0pt , scale=0.75,position=210:0.72 mm from t - i- ] ; ( t - i--3 ) [ inner sep=0pt , scale=0.75,position=160:0.72 mm from t - i- ] ; ( t - i--4 ) [ inner sep=0pt , scale=0.75,position=90:0.72 mm from t - i- ] ;    ( u - i- ) [ fill , inner sep=0pt , minimum size=7pt , draw , circle , thick , scale=0.5,position=224:10 mm from c - i- ] ;    ( u - i--1 ) [ inner sep=0pt , scale=0.75,position=90:0.72 mm from u - i- ] ; ( u - i--2 ) [ inner sep=0pt , scale=0.75,position=180:0.72 mm from u - i- ] ; ( u - i--3 ) [ inner sep=0pt , scale=0.75,position=120:0.72 mm from u - i- ] ; ( u - i--4 ) [ inner sep=0pt , scale=0.75,position=0:0.72 mm from u - i- ] ;    ( v - i- ) [ fill , inner sep=0pt , minimum size=7pt , draw , circle , thick , scale=0.5,position=316:10 mm from c - i- ] ;    ( v - i--1 ) [ inner sep=0pt , scale=0.75,position=90:0.72 mm from v - i- ] ; ( v - i--2 ) [ inner sep=0pt , scale=0.75,position=180:0.72 mm from v - i- ] ; ( v - i--3 ) [ inner sep=0pt , scale=0.75,position=60:0.72 mm from v - i- ] ; ( v - i--4 ) [ inner sep=0pt , scale=0.75,position=0:0.72 mm from v - i- ] ;    ( w - i- ) [ fill , inner sep=0pt , minimum size=7pt , draw , circle , thick , scale=0.5,position=90:15 mm from c - i- ] ;    ( w - i--1 ) [ inner sep=0pt , scale=0.75,position=320:0.72 mm from w - i- ] ; ( w - i--2 ) [ inner sep=0pt , scale=0.75,position=240:0.72 mm from w - i- ] ; ( w - i--3 ) [ inner sep=0pt , scale=0.75,position=180:0.72 mm from w - i- ] ; ( w - i--4 ) [ inner sep=0pt , scale=0.75,position=30:0.72 mm from w - i- ] ; ( w - i--5 ) [ inner sep=0pt , scale=0.75,position=270:0.72 mm from w - i- ] ; ( w - i--6 ) [ inner sep=0pt , scale=0.75,position=270:0.72 mm from w - i- ] ;    ;    ( labels - i- ) [ position=150:4 mm from s - i- ] @xmath3 ; ( labelt - i- ) [ position=30:4 mm from t - i- ] @xmath4 ; ( labelt - i- ) [ position=270:4 mm from u - i- ] @xmath5 ; ( labelt - i- ) [ position=270:4 mm from v - i- ] @xmath6 ; ( labelt - i- ) [ position=90:4 mm from w - i- ] @xmath7 ;    ( labelf-1 - 1 ) [ position=270:25 mm from c-1 - 1 ] initial network @xmath8 ; ( dependency ) [ position=270:19 mm from c-1 - 2 ] @xmath9@xmath9 ; ( labelf-1 - 2 ) [ position=270:25 mm from c-1 - 2 ] block dependency ; ( labelf-1 - 3 ) [ position=270:25 mm from c-1 - 3 ] prepare blocks ; ( labelf-2 - 1 ) [ position=270:19 mm from c-2 - 1 ] update @xmath10 ; ( labelf-2 - 2 ) [ position=270:19 mm from c-2 - 2 ] update @xmath11 ; ( labelf-2 - 3 ) [ position=270:19 mm from c-2 - 3 ] update @xmath12 ;    bg ( s-1 - 1 ) to ( w-1 - 1 ) ; ( w-1 - 1 ) to ( t-1 - 1 ) ;    ( s-1 - 1 ) to ( u-1 - 1 ) ; ( u-1 - 1 ) to ( v-1 - 1 ) ; ( v-1 - 1 ) to ( t-1 - 1 ) ;    ( s-1 - 1 - 4 ) to ( w-1 - 1 - 2 ) ; ( w-1 - 1 - 1 ) to ( t-1 - 1 - 3 ) ;    ( s-1 - 1 - 1 ) to ( u-1 - 1 - 3 ) ; ( u-1 - 1 - 4 ) to ( v-1 - 1 - 2 ) ; ( v-1 - 1 - 3 ) to ( t-1 - 1 - 2 ) ;    ( s-1 - 1 - 2 ) to ( u-1 - 1 - 2 ) ; ( u-1 - 1 - 1 ) to ( w-1 - 1 - 6 ) ; ( w-1 - 1 - 5 ) to ( v-1 - 1 - 1 ) ; ( v-1 - 1 - 4 ) to ( t-1 - 1 - 1 ) ;    ( s-1 - 1 - 3 ) to ( w-1 - 1 - 3 ) ; ( w-1 - 1 - 4 ) to ( t-1 - 1 - 4 ) ;    ( l - sw-1 - 1 ) [ position=130:17.5 mm from c-1 - 1 ] @xmath13 ; ( l - wt-1 - 1 ) [ position=50:17.5 mm from c-1 - 1 ] @xmath14 ; ( l - uw-1 - 1 ) [ position=160:7 mm from c-1 - 1 ] @xmath15 ; ( l - wv-1 - 1 ) [ position=20:7 mm from c-1 - 1 ] @xmath15 ; ( l - uv-1 - 1 ) [ position=270:12 mm from c-1 - 1 ] @xmath13 ; ( l - su-1 - 1 ) [ position=200:15 mm from c-1 - 1 ] @xmath14 ; ( l - vt-1 - 1 ) [ position=340:15 mm from c-1 - 1 ] @xmath13 ;    ( s-1 - 2 ) to ( w-1 - 2 ) ; ( v-1 - 2 ) to ( t-1 - 2 ) ;    ( s-1 - 2 - 4 ) to ( w-1 - 2 - 2 ) ; ( w-1 - 2 - 1 ) to ( t-1 - 2 - 3 ) ;    ( s-1 - 2 - 1 ) to ( u-1 - 2 - 3 ) ; ( u-1 - 2 - 4 ) to ( v-1 - 2 - 2 ) ; ( v-1 - 2 - 3 ) to ( t-1 - 2 - 2 ) ;    ( s-1 - 2 - 2 ) to ( u-1 - 2 - 2 ) ; ( u-1 - 2 - 1 ) to ( w-1 - 2 - 6 ) ; ( w-1 - 2 - 5 ) to ( v-1 - 2 - 1 ) ; ( v-1 - 2 - 4 ) to ( t-1 - 2 - 1 ) ;    ( s-1 - 2 - 3 ) to ( w-1 - 2 - 3 ) ; ( w-1 - 2 - 4 ) to ( t-1 - 2 - 4 ) ;    ( l - sw-1 - 2 ) [ position=130:17.5 mm from c-1 - 2 ] @xmath13 ; ( l - uw-1 - 2 ) [ position=160:8 mm from c-1 - 2 ] @xmath10 ; ( l - wv-1 - 2 ) [ position=20:8 mm from c-1 - 2 ] @xmath12 ; ( l - uv-1 - 2 ) [ position=270:12 mm from c-1 - 2 ] @xmath11 ; ( l - vt-1 - 2 ) [ position=340:15 mm from c-1 - 2 ] @xmath13 ;    ( s-1 - 3 ) to ( w-1 - 3 ) ; ( w-1 - 3 ) to ( t-1 - 3 ) ;    ( s-1 - 3 ) to ( u-1 - 3 ) ; ( u-1 - 3 ) to ( v-1 - 3 ) ; ( v-1 - 3 ) to ( t-1 - 3 ) ;    ( s-1 - 3 - 4 ) to ( w-1 - 3 - 2 ) ; ( w-1 - 3 - 1 ) to ( t-1 - 3 - 3 ) ;    ( s-1 - 3 - 1 ) to ( u-1 - 3 - 3 ) ; ( u-1 - 3 - 4 ) to ( v-1 - 3 - 2 ) ; ( v-1 - 3 - 3 ) to ( t-1 - 3 - 2 ) ;    ( s-1 - 3 - 2 ) to ( u-1 - 3 - 2 ) ; ( u-1 - 3 - 1 ) to ( w-1 - 3 - 6 ) ; ( w-1 - 3 - 5 ) to ( v-1 - 3 - 1 ) ; ( v-1 - 3 - 4 ) to ( t-1 - 3 - 1 ) ;    ( s-1 - 3 - 3 ) to ( w-1 - 3 - 3 ) ; ( w-1 - 3 - 4 ) to ( t-1 - 3 - 4 ) ;    ( l - sw-1 - 3 ) [ position=130:17.5 mm from c-1 - 3 ] @xmath13 ; ( l - wt-1 - 3 ) [ position=50:17.5 mm from c-1 - 3 ] @xmath14 ; ( l - uw-1 - 3 ) [ position=160:7 mm from c-1 - 3 ] @xmath15 ; ( l - wv-1 - 3 ) [ position=20:7 mm from c-1 - 3 ] @xmath15 ; ( l - uv-1 - 3 ) [ position=270:12 mm from c-1 - 3 ] @xmath13 ; ( l - su-1 - 3 ) [ position=200:15 mm from c-1 - 3 ] @xmath14 ; ( l - vt-1 - 3 ) [ position=340:15 mm from c-1 - 3 ] @xmath13 ;    ( s-2 - 1 ) to ( u-2 - 1 ) ; ( u-2 - 1 ) to ( w-2 - 1 ) ; ( w-2 - 1 ) to ( t-2 - 1 ) ;    ( s-2 - 1 ) to ( u-2 - 1 ) ; ( u-2 - 1 ) to ( v-2 - 1 ) ; ( v-2 - 1 ) to ( t-2 - 1 ) ;    ( s-2 - 1 - 4 ) to ( w-2 - 1 - 2 ) ; ( w-2 - 1 - 1 ) to ( t-2 - 1 - 3 ) ;    ( s-2 - 1 - 1 ) to ( u-2 - 1 - 3 ) ; ( u-2 - 1 - 4 ) to ( v-2 - 1 - 2 ) ; ( v-2 - 1 - 3 ) to ( t-2 - 1 - 2 ) ;    ( s-2 - 1 - 2 ) to ( u-2 - 1 - 2 ) ; ( u-2 - 1 - 1 ) to ( w-2 - 1 - 6 ) ; ( w-2 - 1 - 5 ) to ( v-2 - 1 - 1 ) ; ( v-2 - 1 - 4 ) to ( t-2 - 1 - 1 ) ;    ( s-2 - 1 - 3 ) to ( w-2 - 1 - 3 ) ; ( w-2 - 1 - 4 ) to ( t-2 - 1 - 4 ) ;    ( l - sw-2 - 1 ) [ position=130:17.5 mm from c-2 - 1 ] @xmath15 ; ( l - wt-2 - 1 ) [ position=50:17.5 mm from c-2 - 1 ] @xmath14 ; ( l - uw-2 - 1 ) [ position=160:7 mm from c-2 - 1 ] @xmath13 ; ( l - wv-2 - 1 ) [ position=20:7 mm from c-2 - 1 ] @xmath15 ; ( l - uv-2 - 1 ) [ position=270:12 mm from c-2 - 1 ] @xmath13 ; ( l - su-2 - 1 ) [ position=200:15 mm from c-2 - 1 ] @xmath16 ; ( l - vt-2 - 1 ) [ position=340:15 mm from c-2 - 1 ] @xmath13 ;    ( s-2 - 2 ) to ( u-2 - 2 ) ; ( u-2 - 2 ) to ( w-2 - 2 ) ; ( w-2 - 2 ) to ( t-2 - 2 ) ;    ( s-2 - 2 ) to ( w-2 - 2 ) ; ( w-2 - 2 ) to ( t-2 - 2 ) ;    ( s-2 - 2 - 4 ) to ( w-2 - 2 - 2 ) ; ( w-2 - 2 - 1 ) to ( t-2 - 2 - 3 ) ;    ( s-2 - 2 - 1 ) to ( u-2 - 2 - 3 ) ; ( u-2 - 2 - 4 ) to ( v-2 - 2 - 2 ) ; ( v-2 - 2 - 3 ) to ( t-2 - 2 - 2 ) ;    ( s-2 - 2 - 2 ) to ( u-2 - 2 - 2 ) ; ( u-2 - 2 - 1 ) to ( w-2 - 2 - 6 ) ; ( w-2 - 2 - 5 ) to ( v-2 - 2 - 1 ) ; ( v-2 - 2 - 4 ) to ( t-2 - 2 - 1 ) ;    ( s-2 - 2 - 3 ) to ( w-2 - 2 - 3 ) ; ( w-2 - 2 - 4 ) to ( t-2 - 2 - 4 ) ;    ( l - sw-2 - 2 ) [ position=130:17.5 mm from c-2 - 2 ] @xmath13 ; ( l - wt-2 - 2 ) [ position=50:17.5 mm from c-2 - 2 ] @xmath16 ; ( l - uw-2 - 2 ) [ position=160:7 mm from c-2 - 2 ] @xmath13 ; ( l - wv-2 - 2 ) [ position=20:7 mm from c-2 - 2 ] @xmath15 ; ( l - uv-2 - 2 ) [ position=270:12 mm from c-2 - 2 ] @xmath15 ; ( l - su-2 - 2 ) [ position=200:15 mm from c-2 - 2 ] @xmath14 ; ( l - vt-2 - 2 ) [ position=340:15 mm from c-2 - 2 ] @xmath15 ;    ( s-2 - 3 ) to ( u-2 - 3 ) ; ( u-2 - 3 ) to ( w-2 - 3 ) ; ( w-2 - 3 ) to ( v-2 - 3 ) ; ( v-2 - 3 ) to ( t-2 - 3 ) ;    ( s-2 - 3 ) to ( w-2 - 3 ) ; ( w-2 - 3 ) to ( t-2 - 3 ) ;    ( s-2 - 3 - 4 ) to ( w-2 - 3 - 2 ) ; ( w-2 - 3 - 1 ) to ( t-2 - 3 - 3 ) ;    ( s-2 - 3 - 1 ) to ( u-2 - 3 - 3 ) ; ( u-2 - 3 - 4 ) to ( v-2 - 3 - 2 ) ; ( v-2 - 3 - 3 ) to ( t-2 - 3 - 2 ) ;    ( s-2 - 3 - 2 ) to ( u-2 - 3 - 2 ) ; ( u-2 - 3 - 1 ) to ( w-2 - 3 - 6 ) ; ( w-2 - 3 - 5 ) to ( v-2 - 3 - 1 ) ; ( v-2 - 3 - 4 ) to ( t-2 - 3 - 1 ) ;    ( s-2 - 3 - 3 ) to ( w-2 - 3 - 3 ) ; ( w-2 - 3 - 4 ) to ( t-2 - 3 - 4 ) ;    ( l - sw-2 - 3 ) [ position=130:17.5 mm from c-2 - 3 ] @xmath13 ; ( l - wt-2 - 3 ) [ position=50:17.5 mm from c-2 - 3 ] @xmath14 ; ( l - uw-2 - 3 ) [ position=160:7 mm from c-2 - 3 ] @xmath13 ; ( l - wv-2 - 3 ) [ position=20:7 mm from c-2 - 3 ] @xmath13 ; ( l - uv-2 - 3 ) [ position=270:12 mm from c-2 - 3 ] @xmath15 ; ( l - su-2 - 3 ) [ position=200:15 mm from c-2 - 3 ] @xmath14 ; ( l - vt-2 - 3 ) [ position=340:15 mm from c-2 - 3 ] @xmath13 ;    in this paper we present a succinct definition of consistency which generalizes well - studied properties such as congestion - freedom  @xcite and loop - freedom  @xcite .",
    "we make the following technical contributions :    1 .",
    "we present a non - trivial proof that deciding whether a consistent network update schedule exists is np - hard , already for 2 flows .",
    "we prove that the problem is even np - hard on loop - free networks , i.e. , on dags , for general @xmath0 .",
    "3 .   we present a deterministic and polynomial - time algorithm for updating @xmath1 flows on dags , whenever a feasible schedule exists .",
    "the algorithm is based on a decomposition of the flow graph into so - called blocks . using these blocks",
    ", we introduce a dependency graph on which an optimal flow migration schedule can be found efficiently .",
    "4 .   for constant @xmath17 ,",
    "the block decomposition of the flow graph is still useful , however , a weaker dependency graph is described .",
    "based on this dependency graph , we present an elegant linear - time algorithm which solves the problem in time and space @xmath2 .",
    "we assume basic familiarity with directed graphs and we refer the reader to  @xcite for further reading . for a set of integers @xmath18 , we will write @xmath19 $ ] .",
    "we denote a directed edge @xmath20 with head @xmath6 and tail @xmath5 as @xmath21 . for an undirected edge @xmath20 between vertices @xmath22 , we write @xmath23 ; @xmath22 are called endpoints of @xmath20 .",
    "we are given a _ flow network _ : a directed capacitated graph @xmath24 , where @xmath3 is the _ source _ , @xmath4 the terminal , @xmath25 is the set of vertices with @xmath26 , @xmath27 is a set of ordered pairs known as edges , and @xmath28 a capacity function assigning a capacity @xmath29 to every edge @xmath30 .",
    "an _ @xmath31-flow _ @xmath32 of capacity @xmath33 is a directed path from @xmath3 to @xmath4 in a flow network such that @xmath34 for all @xmath35 .",
    "and @xmath4 is for ease of presentation and comes with no loss of generality . ] given a family @xmath36 of @xmath31-flows @xmath37 with demands @xmath38 respectively , we call @xmath36 a _ valid network flow _ , or simply _",
    "valid _ , if @xmath39 .",
    "an _ update flow pair _",
    "@xmath40 consists of two @xmath31-flows @xmath41 , the _ old flow _ , and @xmath42 , the _ update ( or new ) flow _ , each of demand @xmath43 and coming with an _ activation label _",
    "@xmath44 : the label indicates whether a given edge of @xmath45 is active or inactive .    given any update flow pair @xmath46 with activation label @xmath44 and demand @xmath43",
    ", we define the graph @xmath47 .",
    "the flow pair @xmath32 is called _ transient _ , if @xmath48 contains a unique @xmath31-flow @xmath49 .",
    "if there is a family @xmath50 of update flow pairs with demands @xmath38 respectively , we call @xmath36 a _ transient network flow _ , iff .",
    "the family @xmath51 is valid .",
    "an * update flow network * now is a graph @xmath52 , where @xmath53 is a flow network , and @xmath54 with @xmath55 a family of update flow pairs , @xmath56}v(f^o_i\\cup f^u_i)$ ] and @xmath57}e(f^o_i\\cup f^u_i)$ ] .",
    "we call @xmath8 _ initial _ , if all edges of @xmath58 are active and all edges of @xmath59 that do not belong to @xmath60 , are inactive for all @xmath61 $ ] .",
    "similarly an update flow network @xmath8 is called _ complete _ , if all edges of @xmath59 are active , and all edges of @xmath58 that do not belong to @xmath62 , are inactive for all @xmath61 $ ] .",
    "_ updating flows : _ given an update flow network @xmath52 , an _ update _ is a tuple @xmath63 : the update is _ resolved _ by activating all edges @xmath20 of @xmath64 that have @xmath6 as a tail , hence setting @xmath65 to active , and deactivating all @xmath66 that have @xmath6 as a tail . an _ update sequence _",
    "@xmath67 is a partition of @xmath68 into sets @xmath69 , @xmath70 $ ] , such that the graph @xmath71 is an initial update flow network , the graph @xmath72 , @xmath70 $ ] is an update flow network obtained from @xmath71 by resolving all updates in @xmath73 , and @xmath74 is complete .",
    "we call @xmath69 , @xmath70 $ ] , a _",
    "round_. given an update sequence @xmath75 , we denote the round in which some update @xmath76 is resolved by @xmath77 .",
    "since the rounds are totally ordered , we will slightly abuse the notation and refer to rounds by their indices .",
    "an update sequence @xmath75 is _ valid _ , or _ feasible _ , if every round @xmath69 obeys the following consistency rule :    given @xmath78 , let @xmath79 be the family of update flow pairs of the update flow network @xmath80 , which is obtained from @xmath81 by resolving all updates in @xmath82 .",
    "we require that for any @xmath78 , the family @xmath83 is a transient network flow .",
    "note that while succinct , this consistency rule models and consolidates the fundamental properties usually studied in the literature , such as congestion - freedom  @xcite and loop - freedom  @xcite .",
    "note that we do not forbid edges @xmath84 and we never activate or deactivate such an edge .",
    "starting with an initial update flow network these edges will be active and remain so until all updates are resolved .",
    "hence there are vertices @xmath85 with either no outgoing edge for a given flow pair @xmath32 at all , or it has an outgoing edge , but this edge is used by both the old and the update flow of @xmath32 .",
    "we will call such updates @xmath86 _ empty_.",
    "empty updates do not have any impact on the actual problem since they never change any transient flow .",
    "hence they can always be scheduled in the first round and thus w.l.o.g .",
    "we can ignore them in the following",
    ".    we can now define the * @xmath0-network flow update problem * : given an initialized update flow network @xmath8 with @xmath0 update flow pairs , is there a feasible update sequence @xmath75 ?",
    "the corresponding optimization problem is : what is the minimum @xmath87 such that there exists a valid update sequence @xmath75 using exactly @xmath87 rounds ?",
    "we conclude this section by introducing some more * preliminaries*.",
    "let @xmath52 be an acyclic update flow network , i.e. , we assume that the graph @xmath88 is acyclic .",
    "let @xmath89 be a topological order on the vertices @xmath90 .",
    "let @xmath91 be an update flow pair and let @xmath92 be the induced topological order on the vertices of @xmath60 ; analogously , let @xmath93 be the order on @xmath62 . furthermore ,",
    "let @xmath94 be ordered by @xmath89 as well .",
    "the subgraph of @xmath95 induced by the set @xmath96 , @xmath97 $ ] , is called the @xmath98th _ block _ of the update flow pair @xmath99 , or simply the @xmath98th _ @xmath100-block_. we will denote this block by @xmath101 .",
    "for a block @xmath102 , we define @xmath103 to be the _ start of the block _ , i.e. , the smallest vertex w.r.t .",
    "@xmath89 ; similarly , @xmath104 is the _ end of the block _ : the largest vertex w.r.t .",
    "@xmath89 .",
    "let @xmath52 be an update flow network with @xmath105 and let @xmath106 be the set of its blocks .",
    "we define a binary relation @xmath107 between two blocks as follows .",
    "for two blocks @xmath108 , where @xmath10 is an @xmath100-block and @xmath12 a @xmath98-block , @xmath109 $ ] , we say @xmath110 ( @xmath10 _ is smaller than _ @xmath12 ) if one of the following holds .    1 .",
    "@xmath111 , 2 .",
    "if @xmath112 then @xmath110 , if @xmath113 , 3 .   if @xmath112 and @xmath114 then @xmath110 , if @xmath115 .",
    "let @xmath102 be an @xmath100-block and @xmath99 the corresponding update flow pair .",
    "for a feasible update sequence @xmath75 , we will denote the round @xmath116 by @xmath117 .",
    "we say that @xmath100-block @xmath102 is _ updated _ , if all edges in @xmath118 are active and all edges in @xmath119 are inactive .",
    "it is easy to see that for an update flow network with a single flow pair , feasibility is guaranteed .",
    "[ thm : hardness ] the 2-flow network update problem is np - hard .",
    "the proof is by reduction from 3-sat . in what follows",
    "let @xmath120 be any 3-sat formula with @xmath121 variables and @xmath122 clauses .",
    "we will denote the variables as @xmath123 and the clauses as @xmath124 .",
    "the resulting update flow network will be denoted as @xmath125 .",
    "furthermore , we will assume that the variables are ordered by their indices and their appearance in each clause respects this order .",
    "we will create @xmath126 update flow pairs , a blue one @xmath127 and a red one @xmath128 .",
    "the pair @xmath106 will contain gadgets corresponding to the variables .",
    "the order in which the edges of each of those gadgets are updated will correspond to assigning a value to the variable .",
    "the pair @xmath129 on the other hand will contain gadgets representing the clauses : they will have edges that are `` blocked '' by the variable edges of @xmath106 .",
    "therefore , we will need to update @xmath106 to enable the updates of @xmath129 .",
    "we proceed by giving a precise construction of the update flow network @xmath125 . in the following",
    ", the capacities of all edges will be @xmath130 .",
    "since we are working with just two flows and each of those flows contains many gadgets , we give the construction of the two update flow pairs in terms of their gadgets .    1 .",
    "* clause gadgets : * for every @xmath131 $ ] , we introduce eight vertices @xmath132 corresponding to the clause @xmath133 .",
    "the edges @xmath134 with @xmath135 $ ] are added to @xmath136 while the edges @xmath137 for @xmath138 and @xmath139 for @xmath140 are added to @xmath141 .",
    "* variable gadgets : * for every @xmath142 $ ] , we introduce four vertices : @xmath143 .",
    "let @xmath144 denote the set of indices of the clauses containing the literal @xmath145 and @xmath146 the set of indices of the clauses containing the literal @xmath147 .",
    "furthermore , let @xmath148 denote the position of @xmath145 in the clause @xmath133 , @xmath149 .",
    "similarly , @xmath150 denotes the position of @xmath151 in @xmath152 where @xmath153 .",
    "+ to @xmath154 we now add the following edges for every @xmath142 $ ] : a.   @xmath155 , for @xmath149 ( these edges are shared with @xmath141 ) , b.   @xmath156 , for @xmath157 , c.   @xmath158 and @xmath159 , d.   @xmath160 , for @xmath161 , e.   @xmath162 , for @xmath163 $ ] , f.   @xmath164 and @xmath165 , and g.   @xmath166 .",
    "+ on the other hand , @xmath167 will contain the edges @xmath168 , @xmath169 and @xmath170 .",
    "3 .   ( center ) [ ] ; + ( a1 ) [ position=180:3 mm from center ] ; ( a2 ) [ position=0:3 mm from center ] ; + iin 1, ... ,8 ; ( u - i ) [ position=180:mm from a1,circle , draw , scale=0.6,thick ] ; ( u - i - label ) [ position=270:8 mm from u - i ] @xmath171 ; + ( u-1 ) ",
    "( u-2 ) ; ( u-2 )  ( u-3 ) ; ( u-3 )  ( u-4 ) ; ( u-4 )  ( u-5 ) ; ( u-5 )  ( u-6 ) ; ( u-6 ) ",
    "( u-7 ) ; ( u-7 )  ( u-8 ) ; + ( u-1 ) to [ bend left ] ( u-6 ) ; ( u-2 ) to [ bend left ] ( u-7 ) ; ( u-3 ) to [ bend left ] ( u-8 ) ; ( u-6 ) to [ bend left=20 ] ( u-2 ) ; ( u-7 ) to [ bend left=20 ] ( u-3 ) ; + iin 1, ... ,2 in 1, ... ,2 ; ; ( w - i- ) [ position=0:mm from a2,circle , draw , scale=0.8,thick ] ; ( w - i -- label ) [ position=270:6 mm from w - i- ] @xmath172 ; in 1, ... ,4 ; ( v - i- ) [ position=0:mm from a2,circle , draw , scale=0.6,thick ] ; + ( v-1 - 1-label ) [ position=270:8 mm from v-1 - 1 ] @xmath173 ; ( v-1 - 2-label ) [ position=270:8 mm from v-1 - 2 ] @xmath174 ; ( v-1 - 3-label ) [ position=270:8 mm from v-1 - 3 ] @xmath175 ; ( v-1 - 4-label ) [ position=270:8 mm from v-1 - 4 ] @xmath176 ; ( v-2 - 1-label ) [ position=270:8 mm from v-2 - 1 ] @xmath177 ; ( v-2 - 2-label ) [ position=270:8 mm from v-2 - 2 ] @xmath178 ; ( v-2 - 3-label ) [ position=270:8 mm from v-2 - 3 ] @xmath179 ; ( v-2 - 4-label ) [ position=270:8 mm from v-2 - 4 ] @xmath180 ; + ( w-1 - 1 )  ( v-1 - 1 ) ; ( v-1 - 1 )  ( v-1 - 2 ) ; ( v-1 - 2 )  ( v-1 - 3 ) ; ( v-1 - 3 )  ( v-1 - 4 ) ; ( v-1 - 4 ) ",
    "( w-1 - 2 ) ; + ( w-1 - 2 ) ",
    "( w-2 - 1 ) ; ( w-2 - 1 )  ( v-2 - 1 ) ; ( v-2 - 1 )  ( v-2 - 2 ) ; ( v-2 - 2 )  ( v-2 - 3 ) ; ( v-2 - 3 )  ( v-2 - 4 ) ; ( v-2 - 4 )  ( w-2 - 2 ) ; + ( w-1 - 1 ) to [ bend left ] ( w-2 - 1 ) ; ( w-2 - 1 ) to [ bend left ] ( w-1 - 2 ) ; ( w-1 - 2 ) to [ bend left ] ( w-2 - 2 ) ; + ( v4j-1 ) [ draw , circle , thick , position=110:12 mm from w-1 - 1,scale=0.5 ] ; ( labelv4j-1 ) [ position=20:7 mm from v4j-1 ] @xmath181 ; ( v4j-11 ) [ position=180:0.5 mm from v4j-1,scale=0.55 ] ; ( v4j-12 ) [ position=0:0.5 mm from v4j-1,scale=0.55 ] ; ( w111 ) [ position=180:0.5 mm from w-1 - 1,scale=0.9 ] ; ( w112 ) [ position=0:0.5 mm from w-1 - 1,scale=0.9 ] ; ( v4j-11 ) to ( w111 ) ; ( v4j-12 ) to ( w112 ) ; + ( v1j+1 ) [ draw , circle , thick , position=70:12 mm from w-2 - 2,scale=0.5 ] ; ( labelv1j+1 ) [ position=160:7 mm from v1j+1 ] @xmath182 ; ( v1j+11 ) [ position=180:0.5 mm from v1j+1,scale=0.55 ] ; ( v1j+12 ) [ position=0:0.5 mm from v1j+1,scale=0.55 ] ; ( w221 ) [ position=180:0.5 mm from w-2 - 2,scale=0.9 ] ; ( w222 ) [ position=0:0.5 mm from w-2 - 2,scale=0.9 ] ; ( w221 ) to ( v1j+11 ) ; ( w222 ) to ( v1j+12 ) ; + ( u8i-1 ) [ draw , circle , thick , position=110:12 mm from u-1,scale=0.5 ] ; ( labelu8i-1 ) [ position=20:7 mm from u8i-1 ] @xmath183 ; ( u8i-11 ) [ position=180:0.5 mm from u8i-1,scale=0.55 ] ; ( u8i-12 ) [ position=0:0.5 mm from u8i-1,scale=0.55 ] ; ( u11 ) [ position=180:0.5 mm from u-1,scale=0.9 ] ; ( u12 ) [ position=0:0.5 mm from u-1,scale=0.9 ] ; ( u8i-11 ) to ( u11 ) ; ( u8i-12 ) to ( u12 ) ; + ( u1i+1 ) [ draw , circle , thick , position=70:12 mm from u-8,scale=0.5 ] ; ( labelu1i+1 ) [ position=160:7 mm from u1i+1 ] @xmath184 ; ( u1i+11 ) [ position=180:0.5 mm from u1i+1,scale=0.55 ] ; ( u1i+12 ) [ position=0:0.5 mm from u1i+1,scale=0.55 ] ; ( u81 ) [ position=180:0.5 mm from u-8,scale=0.9 ] ; ( u82 ) [ position=0:0.5 mm from u-8,scale=0.9 ] ; ( u81 ) to ( u1i+11 ) ; ( u82 ) to ( u1i+12 ) ; 4 .   * blocking edges : *",
    "the goal is to block the updates @xmath185 for every @xmath142 $ ] until all clauses are satisfied . to do this ,",
    "we introduce @xmath186 additional vertices @xmath187 , @xmath188 , @xmath189 and @xmath190 .",
    "then for @xmath136 , we introduce the following edges : a.   @xmath169 for @xmath142 $ ] , b.   @xmath191 for @xmath192 $ ] , and c.   @xmath193 and @xmath194 , + while @xmath141 contains the edges @xmath195 , @xmath196 and @xmath197 .",
    "+ in a similar fashion , @xmath154 contains the edge @xmath196 . for @xmath167 , we introduce the following edges : a.   @xmath198 for @xmath131 $ ] , b.   @xmath199 for @xmath200 $ ] , and c.   @xmath201 and @xmath202 .",
    "5 .   ( z1 )",
    "[ circle , draw , scale=0.8,thick ] ; ( w1 ) [ circle , draw , scale=0.8,position=15:40 mm from z1,thick ] ; ( w2 ) [ circle , draw , scale=0.8,position=0:40 mm from w1,thick ] ; ( w1b ) [ position=90:0.5 mm from w1 ] ; ( w2b ) [ position=90:0.5 mm from w2 ] ; ( w1r ) [ position=270:0.5 mm from w1 ] ; ( w2r ) [ position=270:0.5 mm from w2 ] ; ( z2 ) [ circle ,",
    "draw , scale=0.8,position=345:40 mm from w2,thick ] ; + \\(s ) [ circle , draw , scale=0.8,thick , position=90:25 mm from z1 ] ; ( s1 ) [ position=0:0.5 mm from s ] ; ( s2 ) [ position=180:0.5 mm from s ] ; ( z11 ) [ position=0:0.5 mm from z1 ] ; ( z12 ) [ position=180:0.5 mm from z1 ] ; ( so )",
    "[ position=90:0.5 mm from s ] ; ( su ) [ position=270:0.5 mm from s ] ; ( w1o ) [ position=90:0.5 mm from w1 ] ; ( w1u ) [ position=270:0.5 mm from w1 ] ; ( labels ) [ position=90:4.5 mm from s ] @xmath3 ; + ( gz1 ) [ position=180:15 mm from z1 ] ; ( gw1 ) [ position=175:15 mm from w1 ] ; ( gw2 ) [ position=7:25 mm from w2 ] ; ( gw2o ) [ position=90:0.5 mm from gw2 ] ; ( gw2u ) [ position=270:0.5 mm from gw2 ] ; ( gz2 ) [ position=0:15 mm from z2 ] ; ( ggz1 ) [ position=160:15 mm from z1 ] ; ( ggz2 ) [ position=20:15 mm from z2 ] ; + ( u41 ) [ circle , draw , scale=0.6,position=125:18 mm from w1,thick ] ; ( u51 ) [ circle , draw , scale=0.6,position=0:9 mm from u41,thick ] ; + ( u41b ) [ position=90:0.5 mm from u41 ] ; ( u51b ) [ position=90:0.5 mm from u51 ] ; ( u41r ) [ position=270:0.5 mm from u41 ] ; ( u51r ) [ position=270:0.5 mm from u51 ] ; + ( u42 ) [ circle , draw , scale=0.6,position=0:12 mm from u51,thick ] ; ( u52 ) [ circle , draw , scale=0.6,position=0:9 mm from u42,thick ] ; + ( u42b ) [ position=90:0.5 mm from u42 ] ; ( u52b ) [ position=90:0.5 mm from u52 ] ; ( u42r ) [ position=270:0.5 mm from u42 ] ; ( u52r ) [ position=270:0.5 mm from u52 ] ; + ( u4 m ) [ circle , draw , scale=0.6,position=0:24 mm from u52,thick ] ; ( u5 m ) [ circle , draw , scale=0.6,position=0:9 mm from u4m , thick ] ; + ( u4 mb ) [ position=90:0.5 mm from u4 m ] ; ( u5 mb ) [ position=90:0.5 mm from u5 m ] ; ( u4mr ) [ position=270:0.5 mm from u4 m ] ; ( u5mr ) [ position=270:0.5 mm from u5 m ] ; + ( gu41 ) [ position=135:10 mm from u41 ] ; ( gu51 ) [ position=45:10 mm from u51 ] ; + ( gu42 ) [ position=135:10 mm from u42 ] ; ( gu52 ) [ position=45:10 mm from u52 ] ; + ( gu4 m ) [ position=135:10 mm from u4 m ] ; ( gu5 m ) [ position=45:10 mm from u5 m ] ; + ( v31 ) [ draw , circle , scale=0.6,position=285:14 mm from z1,thick ] ; ( v21 ) [ draw , circle , scale=0.6,position=0:15 mm from v31,thick ] ; ( gv31 ) [ position=225:10 mm from v31 ] ; ( ggv31 ) [ position=270:10 mm from gv31 ] ; ( gv21 ) [ position=315:10 mm from v21 ] ; ( ggv21 ) [ position=270:10 mm from gv21 ] ; ( v31b ) [ position=90:1 mm from v31 ] ; ( v31r ) [ position=270:1 mm from v31 ] ; ( v21b ) [ position=90:1 mm from v21 ] ; ( v21r ) [ position=270:1 mm from v21 ] ; + ( v32 ) [ draw , circle , scale=0.6,position=0:27 mm from v21,thick ] ; ( v22 ) [ draw , circle , scale=0.6,position=0:15 mm from v32,thick ] ; ( gv32 ) [ position=225:10 mm from v32 ] ; ( ggv32 ) [ position=270:10 mm from gv32 ] ; ( gv22 ) [ position=315:10 mm from v22 ] ; ( ggv22 ) [ position=270:10 mm from gv22 ] ; ( v32b ) [ position=90:1 mm from v32 ] ; ( v32r ) [ position=270:1 mm from v32 ] ; ( v22b ) [ position=90:1 mm from v22 ] ; ( v22r ) [ position=270:1 mm from v22 ] ; + ( v3n ) [ draw , circle , scale=0.6,position=0:38 mm from v22,thick ] ; ( v2n ) [ draw , circle , scale=0.6,position=0:15 mm from v3n , thick ] ; ( gv3n ) [ position=225:10 mm from v3n ] ; ( ggv3n ) [ position=270:10 mm from gv3n ] ; ( gv2n ) [ position=315:10 mm from v2n ] ; ( ggv2n ) [ position=270:10 mm from gv2n ] ; ( v3nb ) [ position=90:1 mm from v3n ] ; ( v3nr ) [ position=270:1 mm from v3n ] ; ( v2nb ) [ position=90:1 mm from v2n ] ; ( v2nr ) [ position=270:1 mm from v2n ] ; + ( labelz1 ) [ position=45:6 mm from z1 ] @xmath189 ; ( labelw1 ) [ position=270:6 mm from w1 ] @xmath187 ; ( labelw2 ) [ position=270:6 mm from w2 ] @xmath188 ; ( labelz2 ) [ position=135:6 mm from z2 ] @xmath190 ; + ( labelz1 ) [ position=180:7 mm from u41 ] @xmath203 ; ( labelz1 ) [ position=270:6 mm from u51 ] @xmath204 ; ( labelz1 ) [ position=270:6 mm from u42 ] @xmath205 ; ( labelz1 ) [ position=270:6 mm from u52 ] @xmath206 ; ( labelz1 ) [ position=270:6 mm from u4 m ] @xmath207 ; ( labelz1 ) [ position=0:7 mm from u5 m ] @xmath208 ; + ( labelz1 ) [ position=80:6 mm from v31 ] @xmath209 ; ( labelz1 ) [ position=90:6 mm from v21 ] @xmath210 ; ( labelz1 ) [ position=90:6 mm from v32 ] @xmath211 ; ( labelz1 ) [ position=90:6 mm from v22 ] @xmath212 ; ( labelz1 ) [ position=90:6 mm from v3n ] @xmath213 ; ( labelz1 ) [ position=100:6 mm from v2n ] @xmath214 ; + bg + ( su ) to ( w1u ) ; ( so ) to ( w1o ) ; ( w1b ) to ( w2b ) ; ( w2r ) to ( gw2u ) ; ( w2b ) to ( gw2o ) ; + ( s1 ) to ( z11 ) ; ( z1 ) to ( w1 ) ; ( w1r ) to ( w2r ) ; ( w2 ) to ( z2 ) ; ( z2 ) to ( gz2 ) ; + ( gu41 ) to ( u41 ) ; ( u41r ) to ( u51r ) ; ( u51 ) to ( gu51 ) ; + ( gu42 ) to ( u42 ) ; ( u42r ) to ( u52r ) ; ( u52 ) to ( gu52 ) ; + ( gu4 m ) to ( u4 m ) ; ( u4mr ) to ( u5mr ) ; ( u5 m ) to ( gu5 m ) ; + ( w1 ) to ( u41 ) ; ( u41b ) to ( u51b ) ; ( u51 ) to ( u42 ) ; ( u42b ) to ( u52b ) ; ( u52 ) to ( u4 m ) ; ( u4 mb ) to ( u5 mb ) ; ( u5 m ) to ( w2 ) ; + ( gv21 ) to ( v21 ) ; ( v21 ) to ( v31 ) ; ( v31 ) to ( gv31 ) ; ( ggv21 ) to ( v31 ) ; ( v31b ) to ( v21b ) ; ( v21 ) to ( ggv31 ) ; ( v31r ) to ( v21r ) ; + ( gv22 ) to ( v22 ) ; ( v22 ) to ( v32 ) ; ( v32 ) to ( gv32 ) ; ( ggv22 ) to ( v32 ) ; ( v32b ) to ( v22b ) ; ( v22 ) to ( ggv32 ) ; ( v32r ) to ( v22r ) ; + ( gv2n ) to ( v2n ) ; ( v2n ) to ( v3n ) ; ( v3n ) to ( gv3n ) ; ( ggv2n ) to ( v3n ) ; ( v3nb ) to ( v2nb ) ; ( v2n ) to ( ggv3n ) ; ( v3nr ) to ( v2nr ) ; + ( z1 ) to ( v31 ) ; ( v2n ) to ( z2 ) ; ( v21 ) to ( v32 ) ; ( v22 ) to ( v3n ) ; ( s2 ) to ( z12 ) ; ( z2 ) to ( ggz2 ) ; 6 .",
    "* source and terminal . * finally , to complete the graph",
    ", we introduce a source @xmath3 and a terminal @xmath4 .",
    "+ for both , @xmath136 and @xmath141 we introduce the following edges : a.   @xmath215 and @xmath216 , b.   @xmath217 for @xmath200 $ ] , and c.   @xmath218 .",
    "+ and for @xmath154 and @xmath167 we complete the flows with the following edges : a.   @xmath219 and @xmath220 , b.   @xmath221 for @xmath192 $ ] , and c.   @xmath222 .    given any valid update sequence @xmath75 for the above constructed update flow network @xmath125 , the following conditions hold for every round @xmath223 .    1",
    ".   @xmath224 [ con : z1notupdated ] 2 .   for any @xmath142 $ ]",
    ", @xmath225 is a vertex of the transient network flow @xmath226 and @xmath227 .",
    "[ con : reachabilityvx1 ] 3 .",
    "let @xmath142 $ ] , then @xmath228 and @xmath229 are the index sets of the clauses containing the corresponding literals @xmath145 and @xmath147",
    ". then @xmath226 contains all edges of the form @xmath230 for @xmath231 , or all the edges @xmath232 for @xmath161 ( or both ) .",
    "[ con : varuseclause ] 4 .",
    "the vertex @xmath189 and the @xmath233 , for all @xmath131 $ ] , are contained in @xmath234 .",
    "[ con : clausereachability ]    [ lem:2flowhardaux ]    1 .",
    "suppose @xmath235 , then there is a set of updates @xmath236 such that @xmath237 is not resolved in @xmath238 , but @xmath239 is .",
    "if @xmath240 , @xmath234 and @xmath226 pass through @xmath196 violating the capacity of @xmath130 , otherwise there is no path @xmath234 in @xmath238 .",
    "the first assertion is trivially true , since the edges @xmath220 and @xmath221 for @xmath192 $ ] belong to both @xmath154 and @xmath167 , hence @xmath226 has to always contain these edges . from property",
    "[ con : z1notupdated ] we know , that @xmath234 has to contain the @xmath189-@xmath190-subpath of @xmath136 and thus @xmath234 fills the capacity of the edges @xmath169 for all @xmath142 $ ] : hence resolving @xmath185 for all @xmath142 $ ] is impossible .",
    "3 .   let @xmath142 $ ] . by property  [ con : reachabilityvx1 ] ,",
    "@xmath241 is contained in @xmath226 , but @xmath242 .",
    "hence , if @xmath243 , then @xmath226 traverses directly from @xmath241 to @xmath244 and then follows along @xmath154 to @xmath245 .",
    "otherwise it follows along @xmath154 from @xmath241 to @xmath244 . in both cases",
    "we are done .",
    "this is again trivially true , since the edges @xmath215 and @xmath217 for @xmath200 $ ] are contained in both @xmath136 and @xmath141 : thus they always have to be part of @xmath234 .",
    "[ proof of theorem  [ thm : hardness ] ] now we are ready to finish the proof of theorem  [ thm : hardness ] . first we will show that if @xmath120 is satisfiable , then there is a feasible order of updates for @xmath125 .",
    "let @xmath246 be an assignment satisfying @xmath120 .",
    "then the update order for @xmath125 is as follows ( each item marks a round ) :    1 .   for each @xmath142 $ ] , if @xmath247 then update @xmath225 .",
    "otherwise update @xmath248 .",
    "each @xmath131 $ ] , at least one of edges @xmath249 is no longer used by @xmath226 .",
    "therefore the corresponding update of @xmath129 can be resolved ( this follows from @xmath246 being a satisfying assignment ) .",
    "each @xmath131 $ ] , @xmath250 is no longer used by @xmath234 .",
    "therefore we can resolve to blue updates along the @xmath187-@xmath188-subpath of @xmath167 excluding @xmath237 .",
    "4 .   resolve @xmath237 .",
    "5 .   resolve @xmath251 and @xmath252 .",
    "( note that now all conflicts between @xmath106 and @xmath129 have been resolved and we can finish the updates .",
    "we will now leave the state described in lemma  [ lem:2flowhardaux ] . )",
    "resolve @xmath239 .",
    "7 .   for each @xmath142",
    "$ ] , @xmath253 has already been updated for exactly one @xmath254 . if @xmath255 , resolve all updates of @xmath106 along the @xmath256-@xmath176-subpath of @xmath154 together with @xmath257 .",
    "otherwise resolve @xmath185 together with all updates of @xmath106 along the @xmath258-@xmath259-subpath of @xmath154 .",
    "resolve the remaining updates of @xmath106 .",
    "resolve all updates of @xmath129 along the @xmath209-@xmath214-subpath of @xmath136 and for each @xmath131 $ ] resolve @xmath260 , @xmath261 and @xmath262 .",
    "resolve the remaining updates of @xmath129 .",
    "now let us assume that there is a feasible update sequence @xmath75 for @xmath125 .",
    "we will show that @xmath120 is satisfiable by constructing assignment @xmath246 .",
    "let us consider the rounds @xmath263 .",
    "then we will use condition  [ con : varuseclause ] of lemma  [ lem:2flowhardaux ] to assign values to variables in the following way .",
    "let @xmath142 $ ] , if @xmath226 does not use the edges @xmath264 for all @xmath265 ( or equivalently if @xmath225 is updated ) we set @xmath266 .",
    "otherwise we set @xmath267 .",
    "now we will show that assignment @xmath246 satisfies @xmath120 .",
    "first let us notice that because we can resolve @xmath237 , none of edges @xmath250 , for any @xmath131 $ ] , can be used by @xmath226 in @xmath268 .",
    "hence , from condition  [ con : clausereachability ] of lemma  [ lem:2flowhardaux ] , we know that all vertices @xmath269 , for any @xmath270 $ ] , and the vertex @xmath189 , are contained in @xmath234 .",
    "let us consider any clause @xmath133 , @xmath131 $ ] .",
    "the transient network flow @xmath234 can not go from @xmath271 to @xmath272 along @xmath136 : this would mean that edge @xmath273 can not be used by @xmath226 .",
    "therefore , for at least one of the edges @xmath274 , @xmath275 and @xmath276 , the corresponding blue update has already been resolved .",
    "this implies that there is some variable @xmath277 , @xmath142 $ ] , that appears in @xmath133 , such that , in the gadget for @xmath277 , @xmath226 skips @xmath278 , for some @xmath279 .",
    "this vertex is between @xmath225 and @xmath248 , if @xmath133 contains literal @xmath145 . in that case , we set @xmath266 , so @xmath133 is satisfied .",
    "otherwise @xmath133 contains literal @xmath280 and we assign @xmath281 , so @xmath133 is also satisfied .",
    "as we have seen in the previous section , even the @xmath126-flow update problem is computationally hard on general graphs .",
    "however , we will now show that an elegant polynomial - time solution exists for the more restricted class of directed acyclic graphs ( dags ) .",
    "our algorithm is based on a dependency - graph approach , and not only finds a feasible , but also a shortest schedule ( minimum number of rounds ) .    in the following ,",
    "let @xmath52 be an update flow network where @xmath88 forms a dag and @xmath282 are the two update flow pairs with @xmath283 and @xmath284 .",
    "as in the previous section , we identify @xmath106 with blue and @xmath129 with red .",
    "we say that an @xmath285-block @xmath10 is _ dependent _ on a @xmath286-block @xmath12 , @xmath287 , @xmath288 , if there is an edge @xmath289 , but @xmath290 .",
    "in fact , to update @xmath10 , we either violate the capacity condition , or we update @xmath12 first in order to prevent congestion . in this case",
    "we write @xmath291 and say that @xmath10 _ requires _ @xmath12 .",
    "we say a block @xmath102 is a _",
    "free block _",
    ", if it is not dependent on any other block .",
    "a _ dependency graph _ of @xmath8 is a graph @xmath292 for which there exists a bijective mapping @xmath293 , and there is an edge @xmath294 in @xmath295 if @xmath296 .",
    "clearly , a block @xmath102 is free if and only if it corresponds to a sink in @xmath295 .",
    "we propose the following algorithm to check the feasibility of the flow rerouting problem .    *",
    "feasible @xmath126-flow dag update*[alg : main ]    1 .   *",
    "input : update flow network @xmath8 * 2 .",
    "compute the dependency graph @xmath295 of @xmath8 .",
    "if there is a cycle in @xmath295 , return _ impossible to update_. 4 .   while @xmath297 repeat : 1 .",
    "[ lbl : step ] update all blocks which correspond to the sink vertices of @xmath295 as in algorithm  [ alg : updatefreeblock ] .",
    "2 .   delete all of the current sink vertices from @xmath295 .",
    "recall that empty updates can always be scheduled in the first round , even if it is not possible to update an update flow network at all .",
    "so for algorithm [ alg : main ] and all following algorithms we simply assume these updates to be scheduled together with the non - empty updates of round @xmath130 .",
    "suppose @xmath75 is a feasible update sequence for @xmath8 .",
    "we say a @xmath298-block @xmath102 w.r.t .",
    "@xmath299 is _ updated in consecutive rounds _ ,",
    "if the following holds : if some of the edges of @xmath102 are activated / deactivated in round @xmath100 and some others in round @xmath98 , then for every @xmath300 , there is an edge of @xmath102 which is activated / deactivated .",
    "we update free blocks as follows :    * update a free @xmath100-block @xmath102*[alg : updatefreeblock ]    1 .",
    "resolve @xmath301 for all @xmath302 .",
    "2 .   resolve @xmath303 .",
    "3 .   resolve @xmath301 for all @xmath304 .",
    "[ lem : updateblockstart ] let @xmath102 be a @xmath298-block . then in a feasible update sequence @xmath75 , all vertices ( resp .",
    "their outgoing @xmath298 flow edges ) in @xmath305 are updated strictly before @xmath103 .",
    "moreover , all vertices in @xmath306 are updated strictly after @xmath103 is updated .    in the following , we will implicitly assume flow @xmath298 , and will not mention it explicitly everywhere",
    ". we will write @xmath307 for @xmath308 and @xmath309 for @xmath310 . for",
    "the sake of contradiction , let @xmath311 .",
    "moreover , let @xmath6 be the vertex of @xmath312 which is updated the latest and @xmath313 . by our condition",
    ", the update of @xmath6 enables a transient flow along edges in @xmath308 .",
    "hence , there now exists an @xmath31-flow through @xmath102 using only update edges .",
    "no vertex in @xmath314 could have been updated before , or simultaneously with @xmath6 : otherwise , between the time @xmath5 has been updated and before the update of @xmath6 , there would not exist a transient flow .",
    "but once we update @xmath6 , there is a @xmath298-flow which traverses the vertices in @xmath315 , and another @xmath298-flow which traverses @xmath316 : a contradiction .",
    "note that @xmath317 .",
    "the other direction is obvious : updating any vertex in @xmath318 inhibits any transient flow .",
    "[ lem : updatewholeblock ] consider @xmath8 and assume a feasible update sequence @xmath75 .",
    "then there exists a feasible update sequence @xmath319 which updates every block in at most @xmath320 consecutive rounds .",
    "let @xmath75 be a feasible update sequence with a minimum number of blocks that are not updated in  @xmath320 consecutive rounds .",
    "furthermore let @xmath102 be such a @xmath298-block .",
    "let @xmath100 be the round in which @xmath103 is updated .",
    "then by lemma  [ lem : updateblockstart ] , all other vertices of @xmath308 have been updated in the previous rounds . moreover , since they do not carry any flow during these rounds , the edges can all be updated in round @xmath321 . by our assumption , we can update @xmath103 in round @xmath100 , and hence now this is still possible .    as @xmath103 is updated in round  @xmath100",
    ", the edges of @xmath310 do not carry any active @xmath298-flow in round  @xmath322 and thus we can deactivate all remaining such edges in this round .",
    "this is a contradiction to the choice of @xmath75 , and hence there is always a feasible sequence @xmath75 satisfying the requirements of the lemma .",
    "in particular , algorithm  [ alg : updatefreeblock ] is correct .    from the above two lemmas",
    ", we immediately derive a corollary regarding the optimality in terms of the number of rounds : the  @xmath320 rounds feasible update sequence .",
    "[ cor : blockroundoptimal ] let @xmath102 be any @xmath298-block with @xmath323 and @xmath324 . then it is not possible to update @xmath102 in less than  @xmath320 rounds : otherwise it is not possible to update  @xmath102 in less than  @xmath126 rounds .",
    "next we show that if there is a cycle in the dependency graph , then it is impossible to update any flow .",
    "[ lem : nocycle ] if there is a cycle in the dependency graph , then there is no feasible update sequence .",
    "a cycle of length  @xmath126 in the dependency graph means that there is a @xmath325-block @xmath10 and a @xmath326-block @xmath12 whose updates mutually depend on each other : if there was a feasible update sequence , then according to lemma  [ lem : updatewholeblock ] there would exist a feasible update sequence which either updates @xmath10 and then @xmath12 ( or vice versa ) , or which updates them simultaneously",
    ". however , this is not possible due to the mutual dependency .",
    "on the other hand , the dependency graph is bipartite .",
    "therefore , every cycle of length more than two has length at least  @xmath186 .",
    "so suppose that there exists a cycle @xmath327 whose vertices correspond to blocks of the corresponding name : blocks of odd indices belong to the @xmath298-flow and blocks of even indices belong to the @xmath328-flow .",
    "suppose that @xmath329 is the smallest block of the @xmath298-flow in @xmath120 .",
    "there are two cases :    1 .",
    "@xmath330 2 .",
    "@xmath331    first suppose @xmath332 , and therefore @xmath333 .",
    "as @xmath12 requires @xmath334 , we have @xmath335 .",
    "however , as @xmath10 was the smallest @xmath298-block in @xmath120 , we have @xmath336 or @xmath337 . on the other hand",
    ", @xmath338 requires @xmath10 , and therefore @xmath339 .",
    "but then @xmath340 : a contradiction to our assumption .    therefore , if there is a feasible update sequence , then @xmath341",
    ". moreover , @xmath342 so @xmath343 and hence @xmath344 . but @xmath291 and therefore @xmath345 : a contradiction .",
    "so there can not be a cycle of length at least  @xmath186 in the dependency graph .",
    "we will now slightly alternate algorithm [ alg : main ] in order to create a new algorithm which will compute a feasible sequence @xmath75 for a given update flow network in polynomial time and which ensures that @xmath75 uses the minimum number of rounds . for",
    "any block @xmath102 let @xmath346 denote its corresponding flow pair .",
    "* optimal @xmath126-flow dag update*[alg : mainopt ]    1 .   * input : update flow network @xmath8 * 2 .",
    "compute the dependency graph @xmath295 of @xmath8 .",
    "if there is a cycle in @xmath295 , return _ impossible to update_. 4 .   if there is any block @xmath102 corresponding to a sink vertex of @xmath295 with @xmath347 set @xmath348 , otherwise set @xmath349 5 .   while @xmath297 repeat : 1 .",
    "[ lbl : stepopt ] schedule the update of all blocks @xmath102 which correspond to the sink vertices of @xmath295 as in algorithm  [ alg : updatefreeblock ] for the rounds @xmath321 , @xmath100 , @xmath322 , such that @xmath103 is updated in round @xmath100 .",
    "2 .   delete all of the current sink vertices from @xmath295 .",
    "3 .   set @xmath350 .",
    "an optimal ( feasible ) update sequence on acyclic update flow networks with exactly @xmath126 update flow pairs can be found in linear time .",
    "let @xmath8 denote the given update flow network . in the following , for ease of presentation , we will slightly abuse terminology and say that `` a block is updated in some round '' , meaning that the block is updated in the corresponding consecutive rounds by algorithm  [ alg : updatefreeblock ] .",
    "we proceed as follows .",
    "first , we find a block decomposition and create the dependency graph of the input instance .",
    "this takes linear time only .",
    "if there is a cycle in that graph , we output _ impossible _",
    "lemma  [ lem : nocycle ] ) .",
    "otherwise , we apply algorithm  [ alg : mainopt ] . as there is no cycle in the dependency graph ( a property that stays invariant ) , in each round , either there exists a free block which is not processed yet , or everything is already updated or is in process of update .",
    "hence , if there is a feasible solution ( it may not be unique ) , we can find one in time @xmath351 .",
    "for the optimality in terms of the number of rounds , consider two feasible update sequences .",
    "let @xmath352 be the update sequence produced by algorithm  [ alg : mainopt ] and let @xmath353 be a feasible update sequence that realizes the minimum number of rounds . according to lemma  [ lem : updateblockstart ] , any block @xmath102 is processed only in round @xmath103 .",
    "suppose there is a block @xmath354 such that @xmath355 .",
    "then let @xmath102 be the block with the smallest such @xmath356 .",
    "hence , for every block @xmath357 with @xmath358 , @xmath359 holds . since @xmath103 is updated in round @xmath356 , there are no dependencies for @xmath102 that are still in place in this round .",
    "thus , according to the sequence @xmath360 , @xmath102 is a sink vertex of the dependency graph after round @xmath361 .",
    "furthermore , by our previous observation , every start of some block that has been updated up to this round in the optimal sequence , and hence it is also already updated in the same round in @xmath352 .",
    "this means that after round @xmath362 , @xmath102 is a sink vertex of the dependency graph of @xmath352 as well .",
    "thus , algorithm  [ alg : mainopt ] would have scheduled the update of block @xmath102 in the rounds @xmath361 , @xmath363 and @xmath364 .",
    "contradiction .",
    "thus @xmath365 for all blocks @xmath102 .",
    "now let @xmath366 be the last blocks whose starts are updated the latest under @xmath352 .",
    "if there is some @xmath70 $ ] such that @xmath367 and @xmath368 , @xmath352 uses exactly @xmath369 rounds ; otherwise it is one round less , by corollary  [ cor : blockroundoptimal ] . by our previous observation ,",
    "none of these blocks can start later than @xmath370 and thus @xmath360 uses at least as many rounds as algorithm  [ alg : mainopt ] .",
    "hence the algorithm is optimal in the number of rounds .",
    "in this section we show that if the number of flows , @xmath0 , is part of the input , the problem remains hard even on dags .",
    "in fact , we prove the following theorem .",
    "[ thm : hardondag ] finding a feasible update sequence for @xmath0-flows is np - complete , even if the update graph @xmath8 is acyclic .",
    "to prove the theorem , we provide a polynomial time reduction from the @xmath320-sat problem .",
    "let @xmath371 be an instance of @xmath320-sat with @xmath121 variables @xmath372 , where each variable @xmath373 appears positive ( @xmath374 ) or negative ( @xmath375 ) in some clause @xmath376 .",
    "we construct an acyclic network update graph @xmath8 such that there is a feasible sequence of updates @xmath75 for @xmath8 , if and only if @xmath120 is satisfiable by some variable assignment @xmath246 . by lemma  [ lem : updatewholeblock ] , we know that if @xmath8 has a feasible update sequence , then there is a feasible update sequence which updates each block in consecutive rounds .    in the following ,",
    "we denote the first vertex of a directed path @xmath377 with @xmath378 and the end vertex with @xmath379 .",
    "furthermore , we number the vertices of a path @xmath377 with numbers @xmath380 , according to their order of appearence in @xmath377 ( @xmath378 is number @xmath130 ) . we will write @xmath381 to denote the @xmath100th vertex in @xmath377 .",
    "we now describe how to construct the initial update flow network @xmath8 .    1 .",
    "@xmath8 has a start vertex @xmath3 and a terminal vertex @xmath4 .",
    "we define @xmath121 variable selector flow pairs @xmath382 , where each @xmath383 defined as follows : 1 .",
    "* variable selector old flows * are @xmath121 @xmath384-flows @xmath385 defined as follows : each consists of a directed path of length  @xmath320 , where every edge in path @xmath386 ( for @xmath387 $ ] ) has capacity  @xmath130 , except for the edge @xmath388 , which has capacity  @xmath126 .",
    "* variable selector update flows * are @xmath121 @xmath384-flows @xmath389 defined as follows : each consists of a directed path of length  @xmath390 , where the edge s capacity of path @xmath391 is set as follows .",
    "@xmath392 has capcity  @xmath126 , @xmath393 has capacity  @xmath122 , and the rest of its edges has capacity  @xmath130 .",
    "we define @xmath122 clause flow pairs @xmath394 , where each @xmath395 is defined as follows . 1 .",
    "* clauses old flows * are @xmath122 @xmath384-flows @xmath396 , each of length  @xmath390 , where for @xmath397 $ ] , @xmath398 and @xmath399",
    ". otherwise they are disjoint from the above defined .",
    "the edge @xmath400 ( for @xmath401 $ ] ) has capacity  @xmath122 , all other edges in @xmath402 have capacity  @xmath130 .",
    "* clauses update flows * are @xmath122 @xmath384-flows @xmath403 , each of length  @xmath320 .",
    "every edge in those paths has capacity  @xmath320 .",
    "we define a clause validator flow pair @xmath404 , defined as follows . 1 .",
    "* clause validator old flow * is an @xmath384-flow @xmath405 whose path consists of edges @xmath406 for @xmath407 $ ] .",
    "note that , the edge @xmath393 ( for @xmath270 $ ] ) also belongs to @xmath391 .",
    "all edges of @xmath25 have capacity  @xmath122 .",
    "* clause validator update flow * is an @xmath384-flow @xmath408 whose path has length  @xmath320 , such that @xmath409 .",
    "all new edges of @xmath408 have capacity  @xmath122 .",
    "we define @xmath410 literal flow pairs @xmath411 .",
    "each @xmath412 is defined as follows : 1 .",
    "* literal s old flows * are @xmath410 @xmath384-flows @xmath413 and @xmath414 .",
    "suppose @xmath374 appears in clauses @xmath415 , then the path @xmath416 is a path of length @xmath417 , where @xmath418 for @xmath419 $ ] and furthermore @xmath420 . on the other hand ,",
    "if @xmath375 appears in clauses @xmath421 , then @xmath422 is a path of length @xmath423 where @xmath424 for @xmath425 $ ] , and furthermore @xmath426 .",
    "all new edges in @xmath416 ( resp .",
    "@xmath422 ) have capacity  @xmath320 .",
    "note that some of @xmath416s may share common edges .",
    "2 .   * literal s update flows * are @xmath410 @xmath384-flows @xmath427 and @xmath428 . for @xmath387 $ ] ,",
    "@xmath429 and @xmath430 are paths of length  @xmath390 such that @xmath431 and @xmath432 .",
    "all new edges in those paths have capacity  @xmath320 .",
    "( s-1 ) [ inner sep=0pt ] ; ( t-1 ) [ inner sep=0pt , position=0:150 mm from s-1 ] ;    iin 2, ... ,13 ; ( s - i ) [ inner sep=0pt , position=270:15 mm from s- ] ; ( t - i ) [ inner sep=0pt , position=270:15 mm from t- ] ;    \\(s ) [ position=260:16 mm from s-6,draw , minimum height=120mm , rounded corners=1.5mm , minimum width=3mm , thick ] ; ( t ) [ position=280:16 mm from t-6,draw , minimum height=120mm , rounded corners=1.5mm , minimum width=3mm , thick ] ;    ( liu-4 ) [ draw , circle , thick , position=180:33 mm from t-1,scale=0.8 ] ; ( liu-5 ) [ draw , circle , thick , position=180:16.5 mm from t-1,scale=0.8 ] ;    ( sio-2 ) [ draw , circle , thick , position=0:49 mm from s-2,scale=0.8 ] ; ( sio-3 ) [ draw , circle , thick , position=180:49 mm from t-2,scale=0.8 ] ; ( sio-2-o ) [ position=90:1.3 mm from sio-2,scale=0.8 ] ; ( sio-3-o ) [ position=90:1.3 mm from sio-3,scale=0.8 ] ; ( sio-2-u ) [ position=270:1.3 mm from sio-2,scale=0.8 ] ; ( sio-3-u ) [ position=270:1.3 mm from sio-3,scale=0.8 ] ;    ( liub-4 ) [ draw , circle , thick , position=180:33 mm from t-3,scale=0.8 ] ; ( liub-5 ) [ draw , circle , thick , position=180:16.5 mm from t-3,scale=0.8 ] ;    ( cko-2 ) [ draw , circle , thick , position=0:26 mm from s-5,scale=0.8 ] ; ( cko-3 ) [ draw , circle , thick , position=0:52.5 mm from s-5,scale=0.8 ] ; ( cko-5 ) [ draw , circle , thick , position=180:26 mm from t-5,scale=0.8 ] ; ( cko-4 ) [ draw , circle , thick , position=180:52 mm from t-5,scale=0.8 ] ; ( cko-3-o ) [ position=90:1.3 mm from cko-3,scale=0.8 ] ; ( cko-4-o ) [ position=90:1.3 mm from cko-4,scale=0.8 ] ; ( cko-3-u ) [ position=270:1.3 mm from cko-3,scale=0.8 ] ; ( cko-4-u ) [ position=270:1.3 mm from cko-4,scale=0.8 ] ;    ( cko-2 ) [ draw , circle , thick , position=0:40 mm from s-6,scale=0.6 ] ; ( cko-5 ) [ draw , circle , thick , position=180:40 mm from t-6,scale=0.6 ] ; ( 6 - 1 ) [ position=205:15 mm from cko-2,inner sep=0 ] ; ( 6 - 2 ) [ position=335:15 mm from cko-5,inner sep=0 ] ;    ( cku-2 ) [ draw , circle , thick , position=0:49 mm from s-7,scale=0.8 ] ; ( cku-3 ) [ draw , circle , thick , position=180:49 mm from t-7,scale=0.8 ] ; ( cku-2-o ) [ position=90:1.3 mm from cku-2,scale=0.8 ] ; ( cku-3-o ) [ position=90:1.3 mm from cku-3,scale=0.8 ] ; ( cku-2-u ) [ position=270:1.3 mm from cku-2,scale=0.8 ] ; ( cku-3-u ) [ position=270:1.3 mm from cku-3,scale=0.8 ] ;    ( chu-3 ) [ draw , circle , thick , position=0:40 mm from s-8,scale=0.8 ] ; ( chu-2 ) [ draw , circle , thick , position=180:40 mm from t-8,scale=0.8 ] ; ( 8 - 1 ) [ position=0:26 mm from s-8,inner sep=0 ] ; ( 8 - 2 ) [ position=315:15 mm from chu-2,inner sep=0 ] ;    ( cpu-3 ) [ draw , circle , thick , position=0:49 mm from s-9,scale=0.6 ] ; ( cpu-2 ) [ draw , circle , thick , position=180:49 mm from t-9,scale=0.6 ] ; ( 9 - 1 ) [ position=225:15 mm from cpu-3,inner sep=0 ] ; ( 9 - 2 ) [ position=315:15 mm from cpu-2,inner sep=0 ] ;    ( lio-2l+2 ) [ draw , circle , thick , position=0:20 mm from s-10,scale=0.8 ] ; ( lio-2l+5 ) [ draw , circle , thick , position=0:55 mm from s-10,scale=0.8 ] ; ( 10 - 1 ) [ position=90:15 mm from lio-2l+2,inner sep=0 ] ;    ( liob-2l+2 ) [ draw , circle , thick , position=0:10 mm from s-11,scale=0.6 ] ; ( liob-2l+5 ) [ draw , circle , thick , position=0:65 mm from s-11,scale=0.6 ] ; ( 11 - 1 ) [ position=90:15 mm from liob-2l+2,inner sep=0 ] ;    ( siu-2 ) [ draw , circle , thick , position=0:26 mm from s-12,scale=0.8 ] ; ( siu-3 ) [ draw , circle , thick , position=0:52.5 mm from s-12,scale=0.8 ] ; ( siu-5 ) [ draw , circle , thick , position=180:26 mm from t-12,scale=0.8 ] ; ( siu-4 ) [ draw , circle , thick , position=180:52 mm from t-12,scale=0.8 ] ; ( siu-2-o ) [ position=90:1.3 mm from siu-2,scale=0.8 ] ; ( siu-3-o ) [ position=90:1.3 mm from siu-3,scale=0.8 ] ; ( siu-2-u ) [ position=270:1.3 mm from siu-2,scale=0.8 ] ; ( siu-3-u ) [ position=270:1.3 mm from siu-3,scale=0.8 ] ; ( siu-4-u ) [ position=270:1.3 mm from siu-4,scale=0.8 ] ; ( siu-5-u ) [ position=270:1.3 mm from siu-5,scale=0.8 ] ;    ( s1u-4 ) [ draw , circle , thick , position=0:15.5 mm from s-13,scale=0.8 ] ; ( si-1u-5 ) [ draw , circle , thick , position=180:60 mm from t-13,scale=0.8 ] ; ( si+1u-4 ) [ draw , circle , thick , position=180:15 mm from t-13,scale=0.8 ] ; ( 13 - 1 ) [ position=0:25.5 mm from s-13,inner sep=0 ] ; ( 13 - 2 ) [ position=0:50 mm from s-13,inner sep=0 ] ; ( 13 - 3 ) [ position=180:8 mm from t-13,inner sep=0 ] ;    ( s-1 ) to ( sio-2 ) ; ( sio-2-o ) to ( sio-3-o ) ; ( sio-3 ) to ( liu-4 ) ; ( liu-4 ) to ( liu-5 ) ; ( liu-5 ) to ( t-1 ) ;    ( s-2 ) to ( sio-2 ) ; ( sio-2 ) to ( sio-3 ) ; ( sio-3 ) to ( t-2 ) ;    ( s-3 ) to ( sio-2 ) ; ( sio-2-u ) to ( sio-3-u ) ; ( sio-3 ) to ( liub-4 ) ; ( liub-4 ) to ( liub-5 ) ; ( liub-5 ) to ( t-3 ) ;    ( s-4 ) to ( cko-3 ) ; ( cko-3-o ) to ( cko-4-o ) ; ( cko-4 ) to ( t-4 ) ;    ( s-5 ) to ( cko-2 ) ; ( cko-2 ) to ( cko-3 ) ; ( cko-3 ) to ( cko-4 ) ; ( cko-4 ) to ( cko-5 ) ; ( cko-5 ) to ( t-5 ) ;    ( 6 - 1 ) to ( cko-2 ) ; ( cko-2 ) to ( cko-3 ) ; ( cko-3-u ) to ( cko-4-u ) ; ( cko-4 ) to ( cko-5 ) ; ( cko-5 ) to ( 6 - 2 ) ;    ( s-7 ) to ( cku-2 ) ; ( cku-2-o ) to ( cku-3-o ) ; ( cku-3 ) to ( t-7 ) ;    ( s-8 ) to ( 8 - 1 ) ; ( 8 - 1 ) to ( chu-3 ) ; ( chu-3 ) to ( cku-2 ) ; ( cku-2 ) to ( cku-3 ) ; ( cku-3 ) to ( chu-2 ) ; ( chu-2 ) to ( 8 - 2 ) ;    ( 9 - 1 ) to ( cpu-3 ) ; ( cpu-3 ) to ( cku-2 ) ; ( cku-2-u ) to ( cku-3-u ) ; ( cku-3 ) to ( cpu-2 ) ; ( cpu-2 ) to ( 9 - 2 ) ;    ( 10 - 1 ) to ( lio-2l+2 ) ; ( lio-2l+2 ) to ( siu-2 ) ; ( siu-2-o ) to ( siu-3-o ) ; ( siu-3 ) to ( lio-2l+5 ) ; ( lio-2l+5 ) to ( t-10 ) ;    ( 11 - 1 ) to ( liob-2l+2 ) ; ( liob-2l+2 ) to ( siu-2 ) ; ( siu-2 ) to ( siu-3 ) ; ( siu-3 ) to ( liob-2l+5 ) ; ( liob-2l+5 ) to ( t-11 ) ;    ( s-12 ) to ( siu-2 ) ; ( siu-2-u ) to ( siu-3-u ) ; ( siu-3 ) to ( siu-4 ) ; ( siu-4 ) to ( siu-5 ) ; ( siu-5 ) to ( t-12 ) ;    ( s-13 ) to ( s1u-4 ) ; ( s1u-4 ) to ( 13 - 1 ) ; ( 13 - 1 ) to ( 13 - 2 ) ; ( 13 - 2 ) to ( si-1u-5 ) ; ( si-1u-5 ) to ( siu-4 ) ; ( siu-4-u ) to ( siu-5-u ) ; ( siu-5 ) to ( si+1u-4 ) ; ( si+1u-4 ) to ( 13 - 3 ) ; ( 13 - 3 ) to ( t-13 ) ;    ( ls ) [ position=180:7 mm from s ] @xmath3 ; ( lt ) [ position=0:7 mm from t ] @xmath4 ;    ( lsio-2 ) [ position=90:7 mm from sio-2 ] @xmath433 ; ( lsio-3 ) [ position=102:7 mm from sio-3 ] @xmath434 ; ( lliu-4 ) [ position=90:7 mm from liu-4 ] @xmath435 ; ( lliu-5 ) [ position=90:7 mm from liu-5 ] @xmath436 ; ( lliub-4 ) [ position=270:7 mm from liub-4 ] @xmath437 ; ( lliub-5 ) [ position=270:7 mm from liub-5 ] @xmath438 ;    ( lcko-2 ) [ position=270:7 mm from cko-2 ] @xmath439 ; ( lcko-2 ) [ position=300:5.5 mm from cko-2 ] @xmath440 ; ( lcko-3 ) [ position=90:7 mm from cko-3 ] @xmath441 ; ( lcko-4 ) [ position=90:7 mm from cko-4 ] @xmath442 ; ( lcko-5 ) [ position=270:5 mm from cko-5 ] @xmath443 ; ( lcko-5 ) [ position=270:7 mm from cko-5 ] @xmath444 ;    ( lchu-3 ) [ position=270:7 mm from chu-3 ] @xmath445 ; ( lcpu-3 ) [ position=0:8 mm from cpu-3 ] @xmath446 ; ( lcku-2 ) [ position=200:13 mm from cku-2 ] @xmath447 ; ( lcku-3 ) [ position=340:12 mm from cku-3 ] @xmath448 ; ( lchu-2 ) [ position=0:11 mm from chu-2 ] @xmath449 ; ( lcpu-2 ) [ position=180:8 mm from cpu-2 ] @xmath450 ;    ( llio-2l+2 ) [ position=0:15 mm from lio-2l+2 ] @xmath451 ; ( lliob-2l+2 ) [ position=270:11 mm from liob-2l+2 ] @xmath452 ; ( lsiu-2 ) [ position=270:7 mm from siu-2 ] @xmath453 ; ( lsiu-3 ) [ position=270:7 mm from siu-3 ] @xmath454 ; ( llio-2l+5 ) [ position=15:15 mm from lio-2l+5 ] @xmath455 ; ( lliob-2l+5 ) [ position=15:12 mm from liob-2l+5 ] @xmath456 ;    ( ls1u-4 ) [ position=270:7 mm from s1u-4 ] @xmath457 ; ( lsi-1u-5 ) [ position=270:7 mm from si-1u-5 ] @xmath458 ; ( lsiu-4 ) [ position=90:7 mm from siu-4 ] @xmath459 ; ( lsiu-5 ) [ position=90:7 mm from siu-5 ] @xmath460 ; ( lsi+1u-4 ) [ position=270:7 mm from si+1u-4 ] @xmath461 ;    ( gl1 ) [ position=0:74 mm from s-2 ] ; ( gl2 ) [ position=0:39 mm from s-12 ] ; ( gl3 ) [ position=0:110.5 mm from s-12 ] ; ( gl4 ) [ position=0:74 mm from s-5 ] ; ( gl5 ) [ position=0:74 mm from s-7 ] ;    ( l1 ) [ position=90:5 mm from gl1 ] @xmath126 ; ( l2 ) [ position=90:5 mm from gl2 ] @xmath126 ; ( l3 ) [ position=90:4 mm from gl3 ] @xmath122 ; ( l4 ) [ position=90:5 mm from gl4 ] @xmath122 ; ( l5 ) [ position=90:5 mm from gl5 ] @xmath320 ;    bg    note that @xmath8 is acyclic and every flow pair in @xmath8 forms a single block .",
    "let @xmath75 be a feasible update sequence of @xmath8 .",
    "we suppose in @xmath75 , every block is updated in consecutive rounds ( lemma  [ lem : updateblockstart ] ) . for a single flow @xmath32 , we write @xmath462 for the round where the last edge of @xmath32 updated .    [ lem : allobservations ] for @xmath75 and @xmath8",
    ", we have the following observations .    a.   [ obs : switchselector ] we either have @xmath463 , or @xmath464 , for all @xmath270 $ ] . b.   [ obs : clausevalidator ] @xmath465 for all @xmath131 $ ] . c.   [ obs : clausevalidatorandswitchs ] @xmath466 for",
    "all @xmath270 $ ] .",
    "d.   [ obs : clausevarselector ] for every @xmath131 $ ] there is some @xmath142 $ ] such that @xmath467 or @xmath468 .",
    "e.   [ obs : clausevar ] we either have @xmath469 , or @xmath470 , for all @xmath131 $ ] and all @xmath142 $ ] .",
    "a.   as the capacity of the edge @xmath471 is  @xmath126 , and both @xmath472 use that edge , before updating both of them , @xmath386 ( resp .",
    "@xmath391 ) should be updated . on the other hand , the edge @xmath473 has capacity  @xmath126 and it is in both @xmath416 and @xmath422 .",
    "so to update @xmath474 , @xmath475 for one of the @xmath476 should be updated .",
    "b.   the edge @xmath477 of @xmath408 also belongs to all @xmath402 ( for @xmath131 $ ] ) and its capacity is @xmath122 .",
    "moreover , the demand of @xmath478 is @xmath122 , so @xmath405 can not be updated unless @xmath402 has been updated for all @xmath131 $ ] . c.   every @xmath391 ( @xmath270 $ ] ) requires the edge @xmath393 , which is also used by @xmath405 , until after round @xmath479 .",
    "d.   this is a consequence of observation  [ obs : clausevalidatorandswitchs ] and observation  [ obs : clausevalidator ] .",
    "e.   this is a consequence of observation  [ obs : clausevarselector ] and observation  [ obs : switchselector ] .    given a sequence of updates , we can check if it is feasible or not .",
    "the length of the update sequence is at most @xmath0 times the size of the graph , hence , the problem clearly is in np .    to show that the problem is complete for np",
    ", we use a reduction from @xmath320-sat .",
    "let @xmath120 be as defined earlier in this section , and in polynomial time we can construct @xmath8 .",
    "by the construction of @xmath8 , if there is a satisfying assignment @xmath246 for @xmath120 , we obtain a sequence @xmath75 to update the flows in @xmath8 as follows . in the first round ,",
    "if in @xmath246 we have @xmath480 for some @xmath270 $ ] , update the literal flow @xmath416 ; otherwise update the literal flow @xmath422 . @xmath246",
    "satisfies @xmath120 , therefore , for every clause @xmath133 there is some literal flow @xmath481 or @xmath482 , which is already updated .",
    "hence , for all @xmath401 $ ] the edge @xmath483 incurs a load of  @xmath126 while its capacity is  @xmath320 .",
    "therefore , we can update all of the clause flows and afterward the clause validator flow @xmath405 .",
    "next , we can update the clause selector flows and at the end , we update the remaining half of the literal flows .    on the other hand , if there is a valid update sequence @xmath75 for flows in @xmath8 , by lemma  [ lem : allobservations ] observation  [ obs : clausevar ] , there are exactly  @xmath121 literal flows that have to be updated , before we can update @xmath484 . to be more precise , for every @xmath142 $ ] , either @xmath485 , or @xmath486 has to be updated , but never both . if @xmath485 is one of those first  @xmath121 literal flows to be updated for some @xmath142 $ ] , we set @xmath487 ; otherwise @xmath486 is to be updated and we set @xmath488 . since these choices are guaranteed to be unique for every @xmath142 $ ] , this gives us an assignment @xmath246 .",
    "after these  @xmath121 literal flows are updated , we are able to update the clause flows , since @xmath75 is a valid update sequence .",
    "this means in particular , that for every clause @xmath133 , @xmath131 $ ] , there is at least one literal which is set to true .",
    "hence @xmath246 satisfies @xmath120 and therefore solving the network update problem on dags , is as hard as solving the @xmath320-sat problem .",
    "we have seen that for an arbitrary number of flows , the problem is hard even on dags . in this section ,",
    "we show that if the number of flows is a constant @xmath0 , then a solution can be computed in linear time .",
    "more precisely , we describe an algorithm to solve the network update problem on dags in time @xmath489 , for arbitrary @xmath0 . in the remainder of this section , we assume that every block has at least  @xmath320 vertices ( otherwise , postponing such block updates will not affect the solution ) .",
    "we say a block @xmath10 _ touches _ a block @xmath12 ( denoted by @xmath490 ) if there is a vertex @xmath491 such that @xmath492 , or there is a vertex @xmath493 such that @xmath494 . if @xmath10 does not touch @xmath12 , we write @xmath495 .",
    "clearly , the relation is symmetric , i.e. , if @xmath490 then @xmath496 .    for some intuition , consider a drawing of @xmath8 which orders vertices w.r.t .",
    "@xmath89 in a line .",
    "project every edge on that line as well .",
    "then two blocks touch each other if they have a common segment on that projection .",
    "* algorithm and proof sketch : * before delving into details , we provide the main ideas behind our algorithm .",
    "we can think about the update problem on dags as follows . our goal is to compute a feasible update order for the ( out-)edges of the graph .",
    "there are at most @xmath0 flows to be updated for each edge , resulting in @xmath497 possible orders and hence a brute force complexity of @xmath498 for the entire problem",
    ". we can reduce this complexity by considering blocks instead of edges .",
    "let @xmath499 contain all feasible update sequences for the blocks that touch @xmath102 : still a ( too ) large number , but let us consider them for now .",
    "for two distinct blocks @xmath500 , we say that two sequences @xmath501 are _ consistent _ , if the order of any common pair of blocks is the same in both @xmath502 .",
    "it is clear that if for some block @xmath102 , @xmath503 , there is no feasible update sequence for @xmath8 : @xmath102 can not be updated .",
    "we now create a graph @xmath504 whose vertices correspond to elements of @xmath499 , for all @xmath505 .",
    "connect all pairs of vertices originating from the same @xmath499 .",
    "connect all pairs of vertices if they correspond to inconsistent elements of different @xmath499 . if ( and only if ) we find an independent set of size @xmath506 in the resulting graph , the update orders corresponding to those vertices are mutually consistent : we can update the entire network according to those orders . in other words ,",
    "the update problem can be reduced to finding an independent set in the graph @xmath504 .    however , there are two main issues with this approach .",
    "first , @xmath504 can be very large .",
    "a single @xmath499 can have exponentially many elements .",
    "accordingly , we observe that we can assume a slightly different perspective on our problem : we linearize the lists @xmath499 and define them sequentially , bounding their size by a function of @xmath0 ( the number of flows ) .",
    "the second issue is that finding a maximum independent set in @xmath504 is hard .",
    "the problem is equivalent to finding a clique in the complement of @xmath504 , a @xmath506-partite graph where every partition has bounded cardinality . we prove that for an @xmath121-partite graph where every partition has bounded cardinality , finding an @xmath121-clique is np - complete .",
    "so , in order to solve the problem , we either should reduce the number of partitions in @xmath504 ( but we can not ) or modify @xmath504 to some other graph , further reducing the complexity of the problem .",
    "we do the latter by trimming @xmath504 and removing some extra edges , turning the graph into a very simple one : a graph of _ bounded path width_. then , by standard dynamic programming , we find the independent set of size @xmath506 in the trimmed version of @xmath504 : this independent set matches the independent set @xmath285 of size @xmath506 in @xmath504 ( if it exists ) . at the end , reconstructing a correct update order sequence from @xmath285 needs some effort . as we have reduced the size of @xmath499 and while not all possible update orders of all blocks occur , we show that they suffice to cover all possible feasible solutions .",
    "we provide a way to construct a valid update order accordingly .",
    "@xmath507    with these intuitions in mind , we now present a rigorous analysis .",
    "let @xmath508 and @xmath509 be permutations of sets @xmath510 and @xmath511 .",
    "we define the _ core _ of @xmath512 and @xmath513 as @xmath514 .",
    "we say that two permutations @xmath515 and @xmath516 are _ consistent _ , @xmath517 , if there is a permutation @xmath518 of symbols of @xmath519 such that @xmath518 is a subsequence of both @xmath515 and @xmath516 .",
    "the * weak dependency graph * , simply called _ dependency graph _ in the following , of a set of permutations is a labeled graph defined recursively as follows .",
    "the dependency graph of a single permutation @xmath520 , denoted by @xmath521 , is a directed path @xmath522 , and the label of the vertex @xmath523 is the element @xmath524 with @xmath525 .",
    "we denote by @xmath526 the set of all labels of @xmath521 .",
    "let @xmath527 be a dependency graph of the set of permutations @xmath528 and @xmath529 the dependency graph of the set @xmath530 .",
    "then , their union ( by identifying the same vertices ) forms the dependency graph @xmath531 of the set @xmath532 .",
    "note that such a dependency graph is not necessarily acyclic .",
    "we call a permutation @xmath518 of blocks of a subset @xmath533 _ congestion free _ , if the following holds : it is possible to update the blocks in @xmath518 in the graph @xmath534 ( the graph on the union of blocks in @xmath106 ) , in order of their appearance in @xmath518 , without violating any edge capacities in @xmath534 .",
    "note that we do not respect all conditions of our _ consistency rule _ here .",
    "( c1 ) [ ] ; ( c2 ) [ position=180:55 mm from c1 ] ;    ( s1 ) [ position=90:5.5 mm from c2 ] @xmath535 ; ( s2 ) [ position=0:0 mm from c2 ] @xmath536 ; ( s3 ) [ position=270:5.5 mm from c2 ] @xmath537 ;    ( graph ) [ position=163:50 mm from c1 ] @xmath538 ;    \\(a ) [ draw , circle , fill , position=330:8 mm from c1,scale=0.5 ] ; ( la ) [ position=75:4.5 mm from a ] @xmath524 ; ( b ) [ draw , circle , fill , position=210:8 mm from c1,scale=0.5 ] ; ( lb ) [ position=100:4.5 mm from b ] @xmath102 ; ( c ) [ draw , circle , fill , position=90:8 mm from c1,scale=0.5 ] ; ( lc ) [ position=90:4.5 mm from c ] @xmath298 ;    ( v1 ) [ draw , circle , fill , position=15:13 mm from c , scale=0.4 ] ; ( lv1 ) [ position=90:4 mm from v1 ] @xmath539 ; ( v2 ) [ draw , circle , fill , position=15:13 mm from a , scale=0.4 ] ; ( lv2 ) [ position=90:4 mm from v2 ] @xmath540 ; ( v4 ) [ draw , circle , fill , position=300:13 mm from a , scale=0.4 ] ; ( lv4 ) [ position=270:4 mm from v4 ] @xmath245 ; ( v3 ) [ draw , circle , fill , position=0:13 mm from v4,scale=0.4 ] ; ( lv3 ) [ position=270:4 mm from v3 ] @xmath541 ; ( v5 ) [ draw , circle , fill , position=230:13 mm from b , scale=0.4 ] ; ( lv5 ) [ position=230:4 mm from v5 ] @xmath542 ; ( v6 ) [ draw , circle , fill , position=180:13 mm from b , scale=0.4 ] ; ( lv6 ) [ position=90:4 mm from v6 ] @xmath543 ; ( v7 ) [ draw , circle , fill , position=180:13 mm from c , scale=0.4 ] ; ( lv7 ) [ position=90:4 mm from v7 ] @xmath544 ;    bg    ( v7 ) to ( c ) ; ( c ) to ( a ) ; ( a ) to ( v2 ) ;    ( v6 ) to ( b ) ; ( b ) to ( c ) ; ( c ) to ( v1 ) ;    ( v3 ) to ( v4 ) ; ( v4 ) to ( a ) ; ( a ) to ( b ) ; ( b ) to ( v5 ) ;    let @xmath518 be a permutation of the set @xmath545 . whether @xmath518 is congestion free can be determined in time @xmath546 .    in the order of @xmath518 , perform algorithm  [ alg : updatefreeblock ] .",
    "if it fails , i.e. , if it violates congestion freedom for some edges , @xmath518 is not a congestion free permutation .",
    "the smaller relation defines a total order on all blocks in @xmath8 .",
    "let @xmath547 and suppose the order is @xmath548 .",
    "* construction of @xmath504 : * we recursively construct a labeled graph @xmath504 from the blocks of @xmath8 as follows .",
    "1 .   set @xmath549 , @xmath550 , @xmath551 .",
    "2 .   for @xmath552 do 1 .",
    "[ def : tislessthank]let @xmath553 be the set of blocks in @xmath554 which touch @xmath555 .",
    "2 .   let @xmath556 be the set of congestion free permutations of @xmath557 .",
    "3 .   set @xmath558 .",
    "4 .   for @xmath70 $ ] create a vertex @xmath559 with @xmath560 and set @xmath561 .",
    "5 .   set @xmath562 .",
    "add edges between all pairs of vertices in @xmath563 $ ] .",
    "add an edge between every pair of vertices @xmath564 $ ] and @xmath565 if the labels of @xmath6 and @xmath5 are inconsistent .",
    "[ def : removeb ] set @xmath566 .",
    "( c1 ) [ ] ;    ( before ) [ position=180:24 mm from c1,inner sep=0pt ] @xmath567 ; ( v1center ) [ position=180:14 mm from c1,inner sep=0pt ] ; ( v2center ) [ position=0:0 mm from c1,inner sep=0pt ] ; ( between ) [ position=0:17 mm from c1,inner sep=0pt ] @xmath567 ; ( v3center ) [ position=0:34 mm from c1,inner sep=0pt ] ; ( after ) [ position=0:44 mm from c1,inner sep=0pt ] @xmath567 ;    ( v1label ) [ position=90:21 mm from v1center , inner sep=0pt ] @xmath568 ; ( v2label ) [ position=90:21 mm from v2center , inner sep=0pt ] @xmath569 ; ( v3label ) [ position=90:21 mm from v3center , inner sep=0pt ] @xmath570 ;    ( v1 ) [ position=0:0 from v1center , draw , line width=1pt , minimum height=70pt , minimum width=21pt ] ; ( v2 ) [ position=0:0 from v2center , draw , line width=1pt , minimum height=70pt , minimum width=21pt ] ; ( v3 ) [ position=0:0 from v3center , draw , line width=1pt , minimum height=70pt , minimum width=21pt ] ;    ( v11 ) [ position=270:12 mm from v1center , inner sep=0pt ] ; ( v12 ) [ position=270:8 mm from v1center , inner sep=0pt ] ; ( v13 ) [ position=270:4 mm from v1center , inner sep=0pt ] ; ( v14 ) [ position=270:0 mm from v1center , inner sep=0pt ] ; ( v15 ) [ position=90:4 mm from v1center , inner sep=0pt ] ; ( v16 ) [ position=90:8 mm from v1center , inner sep=0pt ] ; ( v17 ) [ position=90:12 mm from v1center , inner sep=0pt ] ;    ( v21 ) [ position=270:12 mm from v2center , inner sep=0pt ] ; ( v22 ) [ position=270:8 mm from v2center , inner sep=0pt ] ; ( v23 ) [ position=270:4 mm from v2center , inner sep=0pt ] ; ( v24 ) [ position=270:0 mm from v2center , inner sep=0pt ] ; ( v25 ) [ position=90:4 mm from v2center , inner sep=0pt ] ; ( v26 ) [ position=90:8 mm from v2center , inner sep=0pt ] ; ( v27 ) [ position=90:12 mm from v2center , inner sep=0pt ] ;    ( v17 ) to ( v27 ) ; ( v17 ) to ( v26 ) ; ( v17 ) to ( v24 ) ; ( v14 ) to ( v25 ) ; ( v15 ) to ( v22 ) ; ( v11 ) to ( v23 ) ;    ( v31 ) [ position=270:12 mm from v3center , inner sep=0pt ] ; ( v32 ) [ position=270:8 mm from v3center , inner sep=0pt ] ; ( v33 ) [ position=270:4 mm from v3center , inner sep=0pt ] ; ( v34 ) [ position=270:0 mm from v3center , inner sep=0pt ] ; ( v35 ) [ position=90:4 mm from v3center , inner sep=0pt ] ; ( v36 ) [ position=90:8 mm from v3center , inner sep=0pt ] ; ( v37 ) [ position=90:12 mm from v3center , inner sep=0pt ] ;    ( v17 ) to ( v37 ) ; ( v11 ) to ( v32 ) ;    ( v26 ) to ( v37 ) ; ( v24 ) to ( v35 ) ; ( v22 ) to ( v31 ) ;    ( gs2 ) [ position=292:28 mm from c1,inner sep=0pt ] ; ( gs1 ) [ position=180:36 mm from gs2,inner sep=0pt ] ; ( gs3 ) [ position=0:36 mm from gs2,inner sep=0pt ] ;    ( s2 ) [ position=270:5 mm from gs2,draw , minimum width=70pt , minimum height=10pt , color = blue , line width=0.7pt ] ; ( s1 ) [ position=270:5 mm from gs1,draw , minimum width=70pt , minimum height=10pt , color = blue , line width=0.7pt ] ; ( s3 ) [ position=270:5 mm from gs3,draw , minimum width=70pt , minimum height=10pt , color = blue , line width=0.7pt ] ;",
    "bg    ( b1 ) [ draw , circle , line width=0.9,color = blue , minimum width=6pt , inner sep=3.7pt , position=0:0 mm from v17 ] ; ( b2 ) [ draw , circle , line width=0.9,color = blue , minimum width=6pt , inner sep=3.7pt , position=0:0 mm from v26 ] ; ( b3 ) [ draw , circle , line width=0.9,color = blue , minimum width=6pt , inner sep=3.7pt , position=0:0 mm from v37 ] ;    ( b1 ) to ( gs1 ) ; ( b2 ) to ( gs2 ) ; ( b3 ) to ( gs3 ) ;    ( s1d1 ) [ position=0:0 mm from s1 ] @xmath567 ; ( s2d1 ) [ position=0:0 mm from s2 ] @xmath567 ; ( s3b1 ) [ position=0:0 mm from s3,draw , ellipse , line width=0.5pt , color = red ] @xmath571 ; ( s2b1 ) [ position=180:8.6 mm from s2d1,draw , ellipse , line width=0.5pt , color = red ] @xmath572 ; ( s1b1 ) [ position=180:8.6 mm from s1d1,draw , ellipse , line width=0.5pt , color = red ] @xmath572 ; ( s2b2 ) [ position=0:8.6 mm from s2d1,draw , ellipse , line width=0.5pt ] @xmath573 ; ( s1b2 ) [ position=0:8.6 mm from s1d1,draw , ellipse , line width=0.5pt ] @xmath574 ; ( s1d1 ) [ position=0:0 mm from s1 ] @xmath567 ; ( s2d1 ) [ position=0:0 mm from s2 ] @xmath567 ;    ( s1b1 ) to ( s3b1 ) ; ( s2b1 ) to ( s3b1 ) ;    ( s1b2 ) to ( s2b2 ) ;    [ lem : limitsizeofpermutations ] for item  ( [ def : tislessthank ] ) of the construction of @xmath504 , it holds that @xmath575 .",
    "suppose for the sake of contradiction that @xmath4 is bigger than @xmath0 .",
    "so there are @xmath298-blocks @xmath500 ( where @xmath555 corresponds to a flow pair different from @xmath298 ) that touch @xmath555 .",
    "but then one of @xmath103 or @xmath576 is strictly larger than @xmath577 .",
    "this contradicts our choice of @xmath555 in that we deleted larger blocks from @xmath554 in item  ( [ def : removeb ] ) .",
    "[ lem : touchesomethinginmiddle ] let @xmath578 be three blocks ( w.r.t .",
    "@xmath107 ) where @xmath579 .",
    "let @xmath580 be another block such that @xmath581 .",
    "if in the process of constructing @xmath504 , @xmath580 is in the touch list of both @xmath582 and @xmath583 , then it is also in the touch list of @xmath584 .",
    "let us suppose that @xmath585 .",
    "we know that @xmath586 as otherwise , in the process of creating @xmath504 , we eliminate @xmath580 before we process @xmath582 : it would hence not appear in the touch list of @xmath582 . as @xmath587 , there is a vertex @xmath588 where @xmath589 .",
    "but by our choice of elimination order : @xmath590 , and on the other hand : @xmath591",
    ". thus , @xmath592 , and therefore @xmath580 touches @xmath584 . if some of the start vertices are the same , a similar case distinction applies .",
    "( c1 ) [ ] ;    ( e1center ) [ position=180:20 mm from c1,inner sep=0pt ] ; ( e2center ) [ position=0:0 mm from c1,inner sep=0pt ] ; ( e3center ) [ position=0:20 mm from c1,inner sep=0pt ] ;    ( e1label ) [ position=150:16 mm from e1center , inner sep=0pt ] @xmath593 ; ( e2label ) [ position=90:24 mm from e2center , inner sep=0pt ] @xmath594 ; ( e3label ) [ position=30:16 mm from e3center , inner sep=0pt ] @xmath595 ;    ( e1 ) [ position=0:0 from e1center , draw , line width=1pt , ellipse , minimum height=70pt , minimum width=21pt , color = blue ] ; ( e2 ) [ position=0:0 from e2center , draw , line width=1pt , ellipse , minimum height=70pt , minimum width=21pt , color = junglegreen ] ; ( e3 ) [ position=0:0 from e3center , draw , line width=1pt , ellipse , minimum height=70pt , minimum width=21pt , color = red ] ;    ( t1 ) [ position=240:26 mm from e1center ] ; ( t2 ) [ position=300:26 mm from e3center ] ; ( topo ) [ position=270:28 mm from e2center ] topological order ;    ( bg1 ) [ position=90:7 mm from e1center , inner sep=0pt ] ; ( gg1 ) [ position=90:10 mm from e2center , inner sep=0pt ] ; ( gg2 ) [ position=270:10 mm from e2center , inner sep=0pt ] ; ( rg1 ) [ position=0:0 mm from e3center , inner sep=0pt ] ;    ( ra ) [ position=90:3 mm from rg1,inner sep=0pt ] @xmath596 ; ( rb ) [ position=270:3 mm from rg1 ] @xmath597 ; ( rd1 ) [ position=90:15 mm from rg1 ] @xmath598 ; ( rd2 ) [ position=270:12 mm from rg1 ] @xmath598 ; ( erg1 ) [ position=0:0 mm from rg1,draw , dashed , ellipse , minimum height=30pt , minimum width=8pt ] ;    ( bc ) [ position=90:3 mm from bg1 ] @xmath599 ; ( ba ) [ position=270:3 mm from bg1,inner sep=0pt ] @xmath600 ; ( bd1 ) [ position=270:13 mm from bg1 ] @xmath601 ; ( ebg1 ) [ position=0:0 mm from bg1,draw , dashed , ellipse , minimum height=30pt , minimum width=8pt ] ;    ( ga1 ) [ position=90:3 mm from gg1,inner sep=0pt ] @xmath602 ; ( gb ) [ position=270:3 mm from gg1 ] @xmath603 ; ( egg1 ) [ position=0:0 mm from gg1,draw , dashed , ellipse , minimum height=30pt , minimum width=8pt ] ;    ( gc ) [ position=90:3 mm from gg2 ] @xmath604 ; ( ga2 ) [ position=270:3 mm from gg2,inner sep=0pt ] @xmath602 ; ( egg2 ) [ position=0:0 mm from gg2,draw , dashed , ellipse , minimum height=30pt , minimum width=8pt ] ;    ( ba ) to ( ga2 ) ; ( ra ) to ( ga1 ) ;    bg    ( t1 ) to ( t2 ) ;    for an illustration of the property described in lemma  [ lem : touchesomethinginmiddle ] , see figure  [ fig : extouchingdependency1 ] : it refers to the weak dependency graph of figure [ fig : exdependency1 ] .",
    "this example also points out the problem with directed cycles in the weak dependency graph and the property of lemma  [ lem : touchesomethinginmiddle ] . we will utilize this in the next lemma and it will be key to our algorithm .",
    "[ lem : dependencygraphacyclic ] let @xmath605 be an independent set in @xmath504 . then the dependency graph @xmath606 where @xmath607 , is acyclic .    instead of working on @xmath527 , we can now work on a supergraph @xmath608 of @xmath527 , which is defined as follows . for each sequence @xmath609 , @xmath610 , create a graph @xmath611 which is the transitive closure of @xmath612 .",
    "then we take the union of all @xmath611 s ( for @xmath613 $ ] ) by identifying the vertices of the same label , to obtain @xmath608 .",
    "it is clear that @xmath614 .",
    "we prove that there is no cycle in @xmath615 . by case analysis , it is easy to verify that there is no cycle of length at most  @xmath320 in @xmath615 .",
    "for the sake of contradiction , suppose @xmath608 contains a cycle and let @xmath616 be a shortest cycle .",
    "we know @xmath617 .",
    "the vertices of each edge @xmath618 appear as a subsequence in a label of a vertex @xmath619 , for some @xmath620 , in the same order as induced by the directed edge .",
    "we call a subsequence @xmath621 a _ representation _ of the corresponding @xmath622 .",
    "there are @xmath121 edges in @xmath120 , and therefore there are at most @xmath121 such @xmath623 s .",
    "we denote the union of their corresponding blocks with a set @xmath624 . as @xmath120 is the shortest cycle and @xmath615",
    "is created on the transitive closure of each sequence , @xmath625 holds . in the following",
    "as we consider the cycle @xmath120 , whenever we write any index @xmath100 we consider it w.r.t .",
    "cyclic order ( in fact @xmath626 ) .",
    "suppose @xmath627 , where @xmath621 is a _ representative _ of @xmath628 .",
    "clearly @xmath629 is a representative of @xmath630 for some @xmath142 , j\\neq 1 $ ] .",
    "we claim @xmath631 .",
    "suppose not , then there is a block @xmath632 with @xmath633 and , by lemma  [ lem : touchesomethinginmiddle ] , @xmath634 appears in @xmath632 as well .",
    "but now either @xmath635 is a subsequence of @xmath102 , which would give us a cycle of length  @xmath320 in @xmath608 , a contradiction , or there is a vertex @xmath636 with @xmath637 and @xmath638 .",
    "but then either there is an edge @xmath639 or @xmath640 in @xmath615 ( as both of them will appear in touching blocks of @xmath641 ) : either would give us a shorter cycle .",
    "so @xmath631 . as we continue like this",
    ", @xmath642 must be a representative of some @xmath643 where @xmath644 .",
    "but then considering @xmath645 , with a similar argument , we either have a cycle of length  @xmath320 , or we can find a shorter cycle in @xmath615 as seen before . thus there is no cycle in @xmath615 and hence there is no cycle in @xmath606 , as claimed .",
    "the following lemma establishes the link between independent sets in @xmath504 and feasible update sequences of the corresponding update flow network @xmath8 .",
    "[ lem : blocksandsets ] there is a feasible sequence of updates for an update network @xmath8 on @xmath0 flow pairs , if and only if there is an independent set of size @xmath506 in @xmath504 .",
    "first we prove that if there is a sequence of feasible updates @xmath75 , then there is an independent set of size @xmath506 in @xmath504 .",
    "suppose @xmath75 is a feasible sequence of updates of blocks .",
    "for a block @xmath102 , let @xmath646=\\{b'_1,\\ldots , b'_\\ell\\}$ ] be the set of blocks that touch @xmath102 .",
    "let @xmath647 be the reverse order of updates of blocks in @xmath646 $ ] w.r.t .",
    "in fact , @xmath75 updates @xmath648 first , then @xmath649 , then @xmath650 , then @xmath651 .    for",
    "every two blocks @xmath652 , we have @xmath653 . from every set of vertices @xmath654 , for @xmath505 , let @xmath655 be a vertex such that @xmath656 is a subsequence of @xmath647 .",
    "recall that , for labels of vertices in @xmath657 , we take all possible congestion free permutations of blocks that touch @xmath102 in @xmath554 .",
    "so the vertex @xmath655 exists .",
    "put @xmath655 in @xmath285 .",
    "the label of every pair of vertices in @xmath285 are consistent , as their supersequences were consistent , so @xmath285 is an independent set and furthermore @xmath658 .    for the other direction , suppose there is an independent set of vertices @xmath285 of size @xmath506 in @xmath504 .",
    "it is clear that there is only one vertex from each of the @xmath654 , for @xmath659 , in @xmath285 .",
    "let us define the dependency graph of @xmath660 as the dependency graph _",
    "@xmath661_. by lemma  [ lem : dependencygraphacyclic ] , we know that @xmath295 is a dag , and thus it contains at least one sink vertex .",
    "we update blocks which correspond to sink vertices of @xmath295 in parallel and we remove those vertices from @xmath295 after they are updated",
    ". then we proceed recursively , until there is no vertex in @xmath295 , similarly to algorithm  [ alg : main ] for @xmath126-flows .",
    "we claim that this gives a valid sequence of updates for all blocks .",
    "suppose there is a sink vertex whose corresponding block @xmath102 can not be updated .",
    "then there is an edge @xmath662 ( edges of @xmath102 ) which can not be activated ( updated ) .",
    "edge @xmath20 can not be updated because some other blocks are incident to @xmath20 and route flows : updating @xmath102 would violate a capacity constraint .",
    "these other blocks must have been updated already by our algorithm : otherwise the label corresponding to @xmath102 is an invalid congestion free label .",
    "suppose those other blocks are updated in the order @xmath663 by the above algorithm . among @xmath664 ,",
    "there is a block @xmath354 which is the largest one ( w.r.t .",
    "@xmath107 ) . in the construction of @xmath504 , we know that @xmath665 , as otherwise @xmath285 was not of size @xmath506 .",
    "also suppose @xmath666 , then in the label of @xmath6 , we have a subsequence @xmath667 where @xmath668 : in the iteration where we create @xmath669 , @xmath354 touches all those blocks .",
    "we claim that the permutations @xmath670 and @xmath671 are exactly the same , which would contradict our assumption that @xmath20 can not be updated : @xmath515 is a subsequence of the congestion free permutation @xmath672 .",
    "suppose @xmath673 , then there are two blocks @xmath674 with @xmath675 and @xmath676",
    ". since both , @xmath677 and @xmath678 , will appear in @xmath672 , there is a directed path from @xmath677 to @xmath678 in @xmath295 .",
    "then our algorithm can not choose @xmath677 as a sink vertex before updating @xmath678 : a contradiction .",
    "hence , the sequence of updates we provided by deleting the sink vertices , is a valid sequence of updates if @xmath285 is an independent set of size @xmath506 .    with lemma  [ lem : blocksandsets ] ,",
    "the update problem boils down to finding an independent set of size @xmath506 in @xmath504 .",
    "however , this reduction does not suffice yet to solve our problem in polynomial time , as we will show next .",
    "finding an independent set of size @xmath506 in @xmath504 is equivalent to finding a clique of size @xmath506 in its complement .",
    "the complement of @xmath504 is a @xmath506-partite graph where every partition has cardinality @xmath679 . in general , it is computationally hard to find such a clique .",
    "[ lem : cliqueinnpartitegraphishard ] finding an @xmath122-clique in an @xmath122-partite graph , where every partition has cardinality at most @xmath320 , is hard .",
    "we provide a polynomial time reduction from @xmath320-sat .",
    "let @xmath680 be an instance of @xmath320-sat with  @xmath121 variables @xmath372 .",
    "we denote positive appearances of @xmath373 as a literal @xmath374 and negative appearance as a literal @xmath375 for @xmath401 $ ] .",
    "so we have at most @xmath410 different literals @xmath681 .",
    "create an @xmath122-partite graph @xmath8 as follows .",
    "set @xmath8 to be an empty graph .",
    "let @xmath682 be a clause for @xmath131 $ ] , then add vertices @xmath683 to @xmath8 as partition @xmath684 .",
    "note that @xmath685 or @xmath686 for some @xmath687 $ ] .",
    "add an edge between each pair of vertices @xmath688 for @xmath397 , i\\neq j$ ] if @xmath689 for some @xmath687 $ ] and @xmath690 or if @xmath691 and @xmath692 .",
    "it is clear that @xmath8 now is an @xmath122-partite graph with exactly @xmath320 vertices in each partition .",
    "_ claim : _ there is a satisfying assignment @xmath246 for @xmath120 if , and only if , there is an @xmath122-clique in @xmath8 .",
    "define a vertex set @xmath693 .",
    "let @xmath246 be a satisfying assignment . then from each clause @xmath133 for @xmath401 $ ]",
    ", there is a literal @xmath694 which is set to true in @xmath246 .",
    "we take all vertices of @xmath8 of the form @xmath695 and add it to @xmath696 .",
    "the subgraph @xmath697 $ ] forms a clique of size  @xmath122 . on the other hand",
    "suppose we have an @xmath122-clique @xmath698 as a subgraph of @xmath8 .",
    "then , clearly from each partition @xmath684 , there exists exactly one vertex @xmath695 which is in @xmath698 .",
    "we set the literal @xmath699 to true .",
    "this gives a valid satisfying assignment for @xmath120 .",
    "now we trim @xmath504 to avoid the above problem .",
    "again we will use the special properties of the touching relation of blocks .",
    "we say that some edge @xmath700 is _ long _ , if one end of @xmath20 is in block type @xmath568 , and the other in block type @xmath701 where @xmath702 .",
    "the _ length _ of @xmath20 is @xmath703 . _",
    "delete _ all long edges from @xmath504 to obtain the graph @xmath704 .",
    "@xmath504 has an independent set @xmath285 of size @xmath506 if , and only if , @xmath285 is also an independent set in @xmath704 .",
    "one direction is clear : if @xmath285 is an independent set of size @xmath506 in @xmath504 , then it is an independent set of size @xmath506 in @xmath704 . on the other hand ,",
    "suppose @xmath285 is an independent set of size @xmath506 in @xmath704 .",
    "then for the sake of contradiction , suppose there are vertices @xmath705 and an edge @xmath706 , where @xmath20 has the shortest length among all possible long edges in @xmath707 $ ] .",
    "let us assume that @xmath708 where @xmath702 .",
    "suppose from each @xmath709 for @xmath710 , we have @xmath711 , where @xmath712 .",
    "clearly as @xmath285 is of size @xmath506 there should be exactly one vertex from each @xmath709 .",
    "we know @xmath713 as otherwise the edge @xmath714 . on the other hand , as @xmath20 is the smallest long edge which connects vertices of @xmath285 , then there is no long edge between @xmath715 and @xmath716 in @xmath504 .",
    "that means @xmath717 but then as @xmath718 and by lemma  [ lem : touchesomethinginmiddle ] we know that @xmath719 , so @xmath720 .",
    "therefore , there is an edge between @xmath721 and @xmath716 : a contradiction , by our choice of @xmath285 in @xmath722 .",
    "now we have the following main theorem as a corollary of the previous lemmas .",
    "there is a linear time fpt algorithm which finds a solution for the network update problem , whenever it exists , and otherwise outputs there is no feasible solution for a given instance .",
    "recall that we can resolve all empty updates in the first round , so we ignore them in the following .",
    "first directly construct the graph @xmath704 in time @xmath723\\times v(r_h)\\rightarrow 2^{v(r_h)}$ ] as follows .    1 .",
    "set @xmath724 for all @xmath725,v\\in v(r_h)$ ] .",
    "2 .   set @xmath726 for all @xmath727 .",
    "3 .   for @xmath728 $ ] do 1 .   for all",
    "@xmath729 1 .   if there is a vertex @xmath730 and @xmath731 and @xmath732 then @xmath733 , 2",
    ".   otherwise set @xmath724 4 .   if @xmath734 where @xmath735 then output @xmath736 , 5 .",
    "otherwise output there is no such independent set and output the instance is infeasible .",
    "if the above algorithm finds an independent set of size @xmath506 , then , using the algorithm provided in the proof of lemma  [ lem : blocksandsets ] , find the corresponding update sequence .",
    "the whole algorithm runs in @xmath737 which is @xmath2 .",
    "this paper initiated the study of a natural and fundamental problem : the congestion - free rerouting of unsplittable flows .",
    "the main open question of our work concerns the optimality of our algorithm for fixed @xmath0 .",
    "in particular , it would be interesting to see whether some modifications of our algorithm provides an approximation guarantee in terms of the required number of update rounds .",
    "more generally , it will be interesting to chart a more comprehensive landscape of the computational complexity for the network update problem , also for other graph families and from a randomized algorithm s perspective ."
  ],
  "abstract_text": [
    "<S> we initiate the theoretical study of a fundamental practical problem : how to schedule the congestion - free rerouting of @xmath0 flows ? </S>",
    "<S> the input to our problem are @xmath0 path pairs : for each of the @xmath0 unsplittable flows ( of a certain demand ) , there is an old and a new path along which the flow should be routed . </S>",
    "<S> as different flows can interfere on the physical links , the updates of the different flows at the different nodes must be scheduled such that transient congestion is avoided . </S>",
    "<S> this optimization problem finds immediate applications , e.g. , in traffic engineering in computer networks . </S>",
    "<S> we show that the problem is generally np - hard already for @xmath1 flows . </S>",
    "<S> interestingly , we find that for general @xmath0 , deciding whether an unsplittable multi - commodity flow rerouting schedule exists , is even np - hard on dags . both np - hardness proofs are non - trivial . </S>",
    "<S> we then present two polynomial - time algorithms to solve the route update problem for a constant number of flows on dags . </S>",
    "<S> both algorithms employ a decomposition of the flow graph into smaller parts which we call blocks . based on the given block decomposition , </S>",
    "<S> we define a dependency graph whose properties can be leveraged to compute an optimal solution for @xmath1 flows . for arbitrary but fixed @xmath0 </S>",
    "<S> , we introduce a weaker dependency graph and present our main contribution : an elegant linear - time algorithm which solves the problem in time @xmath2 . </S>"
  ]
}