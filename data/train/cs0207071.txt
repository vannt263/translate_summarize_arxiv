{
  "article_text": [
    "lifschitz , tang , and turner  @xcite recently extended the answer set semantics  @xcite to a class of logic programs in which arbitrarily nested formulas , formed from literals using negation as failure , conjunction , and disjunction , constitute the heads and bodies of rules .",
    "these so - called _ nested logic programs _ generalise the well - known classes of _ normal _ , _ generalised _ , _ extended _ , and _ disjunctive logic programs _ , respectively . despite their syntactically much more restricted format , the latter classes are well recognised as important tools for knowledge representation and reasoning .",
    "this is reflected by the fact that several practicably relevant applications have been developed recently using these types of programs ( cf .",
    ", e.g. ,  @xcite ) , which in turn is largely fostered by the availability of efficient solvers for the answer set semantics , most notably ` dlv `  @xcite and ` smodels `  @xcite .    in this paper",
    ", we are interested in utilising these highly performant solvers for interpreting nested logic programs .",
    "we address this problem by providing a translation of nested logic programs into disjunctive logic programs .",
    "in contrast to previous work , our translation is guaranteed to be polynomial in time and space , as suggested by related complexity results  @xcite .",
    "more specifically , we provide a translation , @xmath0 , from nested logic programs into disjunctive logic programs possessing the following properties :    * @xmath0 maps nested logic programs over an alphabet @xmath1 into disjunctive logic programs over an alphabet @xmath2 , where @xmath3 ; * the size of @xmath4 is polynomial in the size of @xmath5 ; * @xmath0 is _ faithful _ , i.e. ,  for each program @xmath5 over alphabet @xmath1 , there is a one - to - one correspondence between the answer sets of @xmath5 and sets of form @xmath6 , where @xmath7 is an answer set of @xmath4 ; and * @xmath0 is _ modular _ , i.e. ,  @xmath8 , for each program @xmath9",
    ".    moreover , we have implemented translation @xmath0 , serving as a front - end for the logic programming system ` dlv ` .",
    "the construction of @xmath0 relies on the introduction of new _ labels _ , abbreviating subformula occurrences .",
    "this technique is derived from _ structure - preserving normal form translations _",
    "@xcite , frequently employed in the context of automated deduction ( cf .",
    "@xcite for an overview ) .",
    "we use here a method adapted from a structure - preserving translation for intuitionistic logic as described in  @xcite .    regarding the faithfulness of @xmath0 , we actually provide a somewhat stronger condition , referred to as _ strong faithfulness _ , expressing that , for any programs @xmath5 and @xmath10 over alphabet @xmath1 , there is a one - to - one correspondence between the answer sets of @xmath11 and sets of form @xmath6 , where @xmath7 is an answer set of @xmath12 .",
    "this condition means that we can add to a given program @xmath5 _ any nested program _ @xmath10 and still recover the answer sets of the combined program @xmath11 from @xmath12 ; in particular , for any nested logic program @xmath5 , we may choose to translate , in a semantics - preserving way , only an arbitrary _ program part _ @xmath13 and leave the remaining part @xmath14 unchanged .",
    "for instance , if @xmath15 is already a disjunctive logic program , we do not need to translate it again into another ( equivalent ) disjunctive logic program .",
    "strong faithfulness is closely related to the concept of _ strong equivalence _",
    "@xcite ( see below ) .",
    "in order to have a sufficiently general setting for our purposes , we base our investigation on _ equilibrium logic _",
    "@xcite , a generalisation of the answer set semantics for nested logic programs .",
    "equilibrium logic is a form of minimal - model reasoning in the _ logic of here - and - there _ , which is intermediate between classical logic and intuitionistic logic ( the logic of here - and - there is also known as _",
    "gdel s three - valued logic _ in view of  @xcite ) .",
    "as shown in @xcite , logic programs can be viewed as a special class of formulas in the logic of here - and - there such that , for each program @xmath5 , the answer sets of @xmath5 are given by the equilibrium models of @xmath5 , where the latter @xmath5 is viewed as a set of formulas in the logic of here - and - there .",
    "the problem of implementing nested logic programs has already been addressed in  @xcite , where ( linear - time constructible ) encodings of the basic reasoning tasks associated with this language into quantified boolean formulas are described .",
    "these encodings provide a straightforward implementation for nested logic programs by appeal to off - the - shelf solvers for quantified boolean formulas ( like , e.g. ,  the systems proposed in  @xcite ) . besides the encodings into quantified boolean formulas ,",
    "a further result of @xcite is that nested logic programs possess the same worst - case complexity as disjunctive logic programs , i.e. ,  the main reasoning tasks associated with nested logic programs lie at the second level of the polynomial hierarchy . from this result",
    "it follows that nested logic programs can in turn be efficiently reduced to disjunctive logic programs .",
    "hence , given such a reduction , solvers for the latter kinds of programs , like , e.g. ,  ` dlv `  or ` smodels ` , can be used to compute the answer sets of nested logic programs .",
    "the main goal of this paper is to construct a reduction of this type .",
    "although results by lifschitz , tang , and turner  @xcite ( together with transformation rules given in  @xcite ) provide a method to translate nested logic programs into disjunctive ones , that approach suffers from the drawback of an exponential blow - up of the resulting disjunctive logic programs in the worst case .",
    "this is due to the fact that the `` language - preserving '' nature of that translation relies on distributivity laws yielding an exponential increase of program size whenever the given program contains rules whose heads are in disjunctive normal form or whose bodies are in conjunctive normal form , and the respective expressions are not simple disjunctions or conjunctions of literals .",
    "our translation , on the other hand , is always polynomial in the size of its input program .",
    "finally , we mention that structure - preserving normal form translations in the logic of here - and - there are also studied , yet in much more general settings , by baaz and fermller  @xcite as well as by hhnle  @xcite ; there , whole classes of finite - valued gdel logics are investigated .",
    "unfortunately , these normal form translations are not suitable for our purposes , because they do not enjoy the particular form of programs required here .",
    "we deal with propositional languages and use the logical symbols @xmath16 , @xmath17 , @xmath18 , @xmath19 , @xmath20 , and @xmath21 to construct formulas in the standard way .",
    "we write @xmath22 to denote a language over an alphabet @xmath23 of _ propositional variables _ or _",
    "atoms_. formulas are denoted by greek lower - case letters ( possibly with subscripts ) . as usual , _ literals _ are formulas of form @xmath24 or @xmath25 , where @xmath24 is some variable or one of @xmath26 .",
    "besides the semantical concepts introduced below , we also make use of the semantics of classical propositional logic . by a _ @xmath27classical@xmath28 interpretation _ , @xmath7 , we understand a set of variables .",
    "informally , a variable @xmath24 is true under @xmath7 iff @xmath29 .",
    "the truth value of a formula @xmath30 under interpretation @xmath7 , in the sense of classical propositional logic , is determined in the usual way .",
    "the central objects of our investigation are logic programs with nested expressions , introduced by lifschitz _",
    "et al_.  @xcite .",
    "these kinds of programs generalise normal logic programs by allowing bodies and heads of rules to contain arbitrary boolean formulas . for reasons of simplicity",
    ", we deal here only with languages containing one kind of negation , however , corresponding to default negation .",
    "the extension to the general case where strong negation is also permitted is straightforward and proceeds in the usual way .",
    "we start with some basic notation . a formula",
    "whose sentential connectives comprise only @xmath31 , @xmath32 , or @xmath18 is called an _ expression_. a rule , @xmath33 , is an ordered pair of form @xmath34 where @xmath35 and @xmath36 are expressions .",
    "@xmath35 is called the _ body _ of @xmath33 and @xmath36",
    "is the _ head _ of @xmath33 .",
    "we say that @xmath33 is a _ generalised disjunctive rule _ if @xmath35 is a conjunction of literals and @xmath36 is a disjunction of literals ; @xmath33 is a _ disjunctive rule _",
    "iff it is a generalised disjunctive rule containing no negated atom in its head ; finally , if @xmath33 is a rule containing no negation at all , then @xmath33 is called _",
    "basic_. a _ nested logic program _ , or simply a _ program _ , @xmath5 , is a finite set of rules .",
    "@xmath5 is a _ generalised disjunctive logic program _ iff it contains only generalised disjunctive rules .",
    "likewise , @xmath5 is a _ disjunctive logic program _",
    "iff @xmath5 contains only disjunctive rules , and @xmath5 is _ basic _ iff each rule in @xmath5 is basic .",
    "we say that @xmath5 is a program _ over _ alphabet @xmath23 iff all atoms occurring in @xmath5 are from @xmath23 .",
    "the set of all atoms occurring in program @xmath5 is denoted by @xmath37 .",
    "we use @xmath38 to denote the class of all nested logic programs over alphabet @xmath23 ; furthermore , @xmath39 stands for the subclass of @xmath38 containing all disjunctive logic programs over  @xmath23 ; and @xmath40 is the class of all generalised disjunctive logic programs over  @xmath23",
    ". further classes of programs are introduced in section  [ sec : poly ] .    in what follows",
    ", we associate to each rule @xmath33 a corresponding formula @xmath41 and , accordingly , to each program @xmath5 a corresponding set of formulas @xmath42 .",
    "let @xmath5 be a basic program over @xmath23 and @xmath43 a ( classical ) interpretation .",
    "we say that @xmath7 is a _ model _ of @xmath5 iff it is a model of the associated set @xmath44 of formulas .",
    "furthermore , given an ( arbitrary ) program @xmath5 over @xmath23 , the _ reduct _ , @xmath45 , of @xmath5 with respect to @xmath7 is the basic program obtained from @xmath5 by replacing every occurrence of an expression @xmath46 in @xmath5 which is not in the scope of any other negation by @xmath17 if @xmath47 is true under @xmath7 , and by @xmath16 otherwise .",
    "@xmath7 is an _ answer set _ ( or _ stable model _ ) of @xmath5 iff it is a minimal model ( with respect to set inclusion ) of the reduct @xmath45 .",
    "the collection of all answer sets of @xmath5 is denoted by @xmath48 .",
    "two logic programs , @xmath49 and @xmath50 , are _ equivalent _ iff they possess the same answer sets .",
    "following lifschitz _",
    "et al_.  @xcite , we call @xmath49 and @xmath50 _ strongly equivalent _ iff , for every program @xmath5 , @xmath51 and @xmath52 are equivalent .      equilibrium logic is an approach to nonmonotonic reasoning that generalises the answer set semantics for logic programs .",
    "we use this particular formalism because it offers a convenient logical language for dealing with logic programs under the answer set semantics .",
    "it is defined in terms of the logic of here - and - there , which is intermediate between classical logic and intuitionistic logic .",
    "equilibrium logic was introduced in  @xcite and further investigated in @xcite ; proof theoretic studies of the logic can be found in  @xcite",
    ".    generally speaking , the logic of here - and - there is an important tool for analysing various properties of logic programs .",
    "for instance , as shown in @xcite , the problem of checking whether two logic programs are strongly equivalent can be expressed in terms of the logic of here - and - there ( cf .   proposition  [ prop : strong ] below ) .",
    "the semantics of the logic of here - and - there is defined by means of two worlds , @xmath53 and @xmath54 , called `` here '' and `` there '' .",
    "it is assumed that there is a total order , @xmath55 , defined between these worlds such that @xmath55 is reflexive and @xmath56 . as in ordinary kripke semantics for intuitionistic logic",
    ", we can imagine that in each world a set of atoms is verified and that , once verified `` here '' , an atom remains verified `` there '' .",
    "formally , by an _",
    "ht - interpretation _ , @xmath57 , we understand an ordered pair @xmath58 of sets of atoms such that @xmath59 .",
    "we say that @xmath57 is an ht - interpretation _ over _ @xmath23 if @xmath60 .",
    "the set of all ht - interpretations over @xmath23 is denoted by @xmath61 .",
    "an ht - interpretation @xmath58 is _ total _ if @xmath62 .",
    "the truth value , @xmath63 , of a formula @xmath30 at a world @xmath64 in an ht - interpretation @xmath65 is recursively defined as follows :    1 .   if @xmath66 , then @xmath67 ; 2 .   if @xmath68 , then @xmath69 ; 3 .",
    "if @xmath70 is an atom , then @xmath67 if @xmath71 , otherwise @xmath69 ; 4 .   if @xmath72 , then @xmath67 if , for every world @xmath73 with @xmath74 , @xmath75 , otherwise @xmath69 ; 5 .   if @xmath76 , then @xmath77 if @xmath78 and @xmath79 , otherwise @xmath80 ; 6",
    "if @xmath81 , then @xmath77 if @xmath78 or @xmath79 , otherwise @xmath80 ; 7 .",
    "if @xmath82 , then @xmath67 if for every world @xmath73 with @xmath74 , @xmath83 or @xmath84 , otherwise @xmath69 .",
    "we say that @xmath30 is _ true under @xmath57 in @xmath85 _ iff @xmath77 , otherwise @xmath30 is _ false under @xmath57 in @xmath85_. an ht - interpretation @xmath65 _ satisfies _ @xmath30 , or @xmath57 is an _ ht - model _ of @xmath30 , iff @xmath86 . if @xmath30 is true under any ht - interpretation , then @xmath30 is _ valid in the logic of here - and - there _ , or simply _ ht - valid_.    let @xmath87 be a set of formulas .",
    "an ht - interpretation @xmath57 is an ht - model of @xmath87 iff @xmath57 is an ht - model of each element of @xmath87 .",
    "we say that @xmath57 is an ht - model of a _ program _",
    "@xmath5 iff @xmath57 is an ht - model of @xmath88 .",
    "two sets of formulas are _ equivalent in the logic of here - and - there _ , or _",
    "ht - equivalent _ , iff they possess the same ht - models .",
    "two formulas , @xmath30 and @xmath47 , are ht - equivalent iff the sets @xmath89 and @xmath90 are ht - equivalent .",
    "it is easily seen that any ht - valid formula is valid in classical logic , but the converse does not always hold .",
    "for instance , @xmath91 and @xmath92 are valid in classical logic but not in the logic of here - and - there as the pair @xmath93 is not an ht - model for either of these formulas .",
    "_ equilibrium logic _ can be seen as a particular type of reasoning with minimal ht - models .",
    "formally , an _ equilibrium model _ of a formula @xmath30 is a total ht - interpretation @xmath94 such that ( i ) @xmath94 is an ht - model of @xmath30 , and ( ii ) for every proper subset @xmath95 of @xmath7 , @xmath96 is not an ht - model of @xmath30 .",
    "the following result establishes the close connection between equilibrium models and answer sets , showing that answer sets are actually a special case of equilibrium models :    [ prop : eqmsm ] for any program @xmath5 , @xmath7 is an answer set of @xmath5 iff @xmath97 is an equilibrium model of  @xmath44 .",
    "moreover , ht - equivalence was shown to capture the notion of strong equivalence between logic programs :    [ prop : strong ] let @xmath49 and @xmath50 be programs , and let @xmath98 , for @xmath99 .",
    "then , @xmath49 and @xmath50 are strongly equivalent iff @xmath100 and @xmath101 are equivalent in the logic of here - and - there .",
    "recently , de jongh and hendriks  @xcite have extended proposition  [ prop : strong ] by showing that for nested programs strong equivalence is characterised precisely by equivalence in all intermediate logics lying between here - and - there ( upper bound ) and the logic kc of weak excluded middle ( lower bound ) which is axiomatised by intuitionistic logic together with the schema @xmath102 .",
    "we require the following additional concepts . by an _",
    "ht - literal _ , @xmath103",
    ", we understand a formula of form @xmath24 , @xmath25 , or @xmath104 , where @xmath24 is a propositional atom or one of @xmath16 , @xmath17 .",
    "furthermore , a formula is in _ here - and - there negational normal form _ , or _",
    "ht - nnf _ , if it is made up of ht - literals , conjunctions and disjunctions .",
    "likewise , we say that a _ program _ is in ht - nnf iff all heads and bodies of rules in the program are in ht - nnf .",
    "following  @xcite , every expression @xmath30 can effectively be transformed into an expression @xmath47 in ht - nnf possessing the same ht - models as @xmath30 .",
    "in fact , we have the following property :    [ prop : nnf ] every expression @xmath30 is ht - equivalent to an expression @xmath105 in ht - nnf , where @xmath105 is constructible in polynomial time from @xmath30 , satisfying the following conditions , for each expression @xmath106 :    1 .",
    "@xmath107 , if @xmath108 is an ht - literal ; 2 .   @xmath109 ; 3 .",
    "@xmath110 , for @xmath111 ; 4 .",
    "@xmath112 ; 5 .",
    "next , we introduce the general requirements we impose on our desired translation from nested logic programs into disjunctive logic programs .",
    "the following definition is central :    [ def : eq ] let @xmath1 and @xmath2 be two alphabets such that @xmath3 , and , for @xmath99 , let @xmath114 be a class of nested logic programs closed under unions . of sets is closed under unions providing @xmath115 implies @xmath116 .",
    "] then , a function @xmath117 is    1 .",
    "[ def : faithful ] _ polynomial _ iff , for all programs @xmath118 , the time required to compute @xmath119 is polynomial in the size of @xmath5 ; 2 .   _ faithful _ iff , for all programs @xmath118 , @xmath120 3 .",
    "_ strongly faithful _",
    "iff , for all programs @xmath118 and all programs @xmath121 , @xmath122 and 4 .",
    "_ modular _ iff , for all programs @xmath123 , @xmath124    in view of the requirement that @xmath3 , the general functions considered here may introduce new atoms . clearly , if the given function is polynomial , the number of newly introduced atoms is also polynomial .",
    "faithfulness guarantees that we can recover the stable models of the input program from the translated program . strong faithfulness , on the other hand ,",
    "states that we can add to a given program @xmath5 _ any nested logic program _ @xmath10 and still retain , up to the original language , the semantics of the combined program @xmath11 from @xmath125 .",
    "finally , modularity enforces that we can translate programs rule by rule .",
    "it is quite obvious that any strongly faithful function is also faithful .",
    "furthermore , strong faithfulness of function @xmath126 implies that , for a given program @xmath5 , we can translate _ any program part _ @xmath15 of @xmath5 whilst leaving the remaining part @xmath127 unchanged , and determine the semantics of @xmath5 from @xmath128 . as well , for any function of form @xmath129 , strong faithfulness of @xmath126 is equivalent to the condition that @xmath5 and @xmath119 are strongly equivalent , for any @xmath130 .",
    "hence , strong faithfulness generalises strong equivalence .",
    "following  @xcite , we say that a function @xmath126 as in definition  [ def : eq ] is _ pfm _ , or that @xmath126 is a _ pfm - function _ , iff it is polynomial , faithful , and modular .",
    "analogously , we call @xmath126 _ psm _ , or a _ psm - function _ , iff it is polynomial , strongly faithful , and modular .",
    "it is easy to see that the composition of two pfm - functions is again a pfm - function ; and likewise for psm - functions .",
    "furthermore , since any psm - function is also pfm , in the following we focus on psm - functions .",
    "in fact , in the next section , we construct a function @xmath131 ( where @xmath2 is a suitable extension of @xmath1 ) which is psm .",
    "next , we discuss some sufficient conditions guaranteeing that certain classes of functions are strongly faithful .",
    "we start with the following concept .",
    "[ def : mono ] let @xmath132 be a function such that @xmath3 , and let @xmath133 be the class of all ht - interpretations over @xmath134 @xmath135 .",
    "then , the function @xmath136 is called a _ @xmath126-associated ht - embedding _ iff , for each ht - interpretation @xmath65 over @xmath1 , each @xmath137 , and each @xmath64 , @xmath138 and @xmath139 , where @xmath140 .    furthermore ,",
    "for any @xmath141 and any @xmath137 , we define @xmath142 .",
    "intuitively , a @xmath126-associated ht - embedding transforms ht - interpretations over the input alphabet @xmath1 of @xmath126 into ht - interpretations over the output alphabet @xmath2 of @xmath126 such that the truth values of the atoms in @xmath1 are retained .",
    "the following definition strengthens these kinds of mappings :    [ def : htnew ] let @xmath126 be as in definition  [ def : mono ] , and let @xmath143 be a @xmath126-associated ht - embedding .",
    "we say that @xmath143 is a _",
    "@xmath126-associated ht - homomorphism _ if , for any @xmath144 and any @xmath137 , the following conditions hold :    1 .",
    "@xmath57 is an ht - model of @xmath5 iff @xmath145 is an ht - model of @xmath119 ; 2 .",
    "@xmath57 is total iff @xmath145 is total ; 3 .",
    "if @xmath65 and @xmath146 are ht - models of @xmath5 , then @xmath147 and @xmath148 holds precisely if @xmath149 and @xmath150 , for @xmath140 and @xmath151 ; and 4 .",
    "an ht - interpretation @xmath152 over @xmath153 is an ht - model of @xmath119 only if @xmath154 .",
    "roughly speaking , @xmath126-associated ht - homomorphisms retain the relevant properties of ht - interpretations for being equilibrium models with respect to transformation @xmath126 .",
    "more specifically , the first three conditions take semantical and set - theoretical properties into account , respectively , whilst the last one expresses a specific `` closure condition '' .",
    "the inclusion of the latter requirement is explained by observation that the first three conditions alone are not sufficient to exclude the possibility that there may exist some equilibrium model @xmath57 of @xmath5 such that @xmath145 is not an equilibrium model of @xmath119 .",
    "the reason for this is that the set @xmath155 , comprising the images of all ht - interpretations over @xmath1 under @xmath143 with respect to program @xmath5 , does , in general , not cover _ all _ ht - interpretations over @xmath153 .",
    "hence , for a general @xmath126-associated ht - embedding @xmath156 , there may exist some ht - model of @xmath119 which is not included in @xmath155 preventing @xmath145 from being an equilibrium model of @xmath119 albeit @xmath57 is an equilibrium model of @xmath5 .",
    "the addition of the last condition in definition  [ def : htnew ] , however , excludes this possibility , ensuring that all relevant ht - interpretations required for checking whether @xmath145 is an equilibrium model of @xmath119 are indeed considered .",
    "the following result can be shown :    [ lemma : faithfulness ] for any function @xmath132 with @xmath3 , if there is some @xmath126-associated ht - homomorphism , then @xmath126 is faithful .    from this",
    ", we obtain the following property :    [ thm : strong - faithfulness ] under the circumstances of lemma  [ lemma : faithfulness ] , if @xmath126 is modular and there is some @xmath126-associated ht - homomorphism , then @xmath126 is strongly faithful .",
    "we make use of the last result for showing that the translation from nested logic programs into disjunctive logic programs , as discussed next , is psm .",
    "in this section , we show how logic programs with nested expressions can be efficiently mapped to disjunctive logic programs , preserving the semantics of the respective programs . although results by lifschitz  _ et al . _",
    "@xcite already provide a reduction of nested logic programs into disjunctive ones ( by employing additional transformation steps as given in  @xcite ) , that method is exponential in the worst case .",
    "this is due to the fact that the transformation relies on distributive laws , yielding an exponential increase of program size whenever the given program contains rules whose heads are in disjunctive normal form or whose bodies are in conjunctive normal form , and the respective expressions are not simple disjunctions or conjunctions of ht - literals .    to avoid such an exponential blow - up , our technique is based on the introduction of new atoms , called _ labels _ , abbreviating subformula occurrences .",
    "this method is derived from structure - preserving normal form translations  @xcite , which are frequently applied in the context of automated reasoning ( cf .",
    ", e.g. ,   @xcite for general investigations about structure - preserving normal form translation in finite - valued gdel logics , and @xcite for proof - theoretical issues of such translations for classical and intuitionistic logic ) .",
    "in contrast to theorem proving applications , where the main focus is to provide translations which are satisfiability ( or , alternatively , validity ) equivalent , here we are interested in somewhat stronger equivalence properties , viz .  in the _ reconstruction of the answer sets _ of the original programs from the translated ones , which involves also an adequate handling of additional minimality criteria .",
    "the overall structure of our translation can be described as follows .",
    "given a nested logic program @xmath5 , we perform the following steps :    1 .   [ step:1 ] for each @xmath157 , transform @xmath36 and @xmath35 into ht - nnf ; 2 .",
    "[ step:2 ] translate the program into a program containing only rules with conjunctions of ht - literals in their bodies and disjunctions of ht - literals in their heads ; 3 .",
    "[ step:4 ] eliminate double negations in bodies and heads ; and 4 .",
    "[ step:5 ] transform the resulting program into a disjunctive logic program , i.e. ,  make all heads negation free .",
    "steps  [ step:1 ] and [ step:4 ] are realised by using properties of logic programs as described in  @xcite ; step  [ step:2 ] represents the central part of our construction ; and step  [ step:5 ] exploits a procedure due to janhunen  @xcite .    in what follows , for any alphabet @xmath23 , we define the following new and disjoint alphabets :    * a set @xmath158 of labels ; and * a set @xmath159 of atoms representing negated atoms .",
    "furthermore , @xmath160 is the class of all nested logic programs over @xmath23 which are in ht - nnf , and @xmath161 is the class of all programs over @xmath23 which are defined like generalised logic programs , except that ht - literals may occur in rules instead of ordinary literals .",
    "we assume that for each of the above construction stages , step  @xmath162 is realized by a corresponding function @xmath163 ( @xmath164 ) .",
    "the overall transformation is then described by the composed function @xmath165 , which is a mapping from the set @xmath38 of all programs over @xmath23 into the set @xmath166 of all disjunctive logic program over @xmath167 .",
    "more specifically , @xmath168 translates any nested logic program over @xmath23 into a nested program in ht - nnf .",
    "translation @xmath169 takes these programs and transforms their rules into simpler ones as described by step  2 , introducing new labels .",
    "these rules are then fed into mapping @xmath170 yielding generalised disjunctive logic programs . finally , @xmath171 outputs standard disjunctive logic programs .",
    "as argued in the following , each of these functions is psm ; hence , the overall function @xmath165 is psm as well .",
    "we continue with the technical details , starting with @xmath172 .    for the first step , we use the procedure @xmath173 from proposition  [",
    "prop : nnf ] to transform heads and bodies of rules into ht - nnf .",
    "the function @xmath174 is defined by setting @xmath175 for any @xmath130 .    since , for each expression @xmath30 , @xmath105 is constructible in polynomial time and @xmath30 is ht - equivalent to @xmath105 ( cf .",
    "proposition  [ prop : nnf ] ) , the following result is immediate :    [ thm : step1 ] the translation @xmath172 is psm .",
    "the second step is realised as follows :    the function @xmath176 is defined by setting , for any @xmath177 , @xmath178 where @xmath179 is constructed as follows :    1 .   for each ht - literal @xmath103 occurring in @xmath5 , add the two rules @xmath180 2 .   for each expression",
    "@xmath181 occurring in @xmath5 , add the three rules @xmath182 and 3 .",
    "for each expression @xmath183 occurring in @xmath5 , add the three rules @xmath184    this definition is basically an adaption of a structure - preserving normal form translation for intuitionistic logic , as described in @xcite .",
    "it is quite obvious that @xmath185 is modular and , for each @xmath186 , we have that @xmath187 is constructible in polynomial time . in order to show that @xmath185 is strongly faithful",
    ", we define a suitable ht - homomorphism as follows .",
    "[ sublemma : tr2 ] let @xmath185 be the translation defined above , and let @xmath188 result from @xmath185 by setting @xmath189 if @xmath186 and @xmath190 if @xmath191 .",
    "then , the function @xmath192 , defined as @xmath193 is a @xmath194-associated ht - homomorphism , where @xmath195 if @xmath186 , and @xmath196 otherwise , for any @xmath64 and any ht - interpretation @xmath65 over  @xmath23 .",
    "hence , according to theorem  [ thm : strong - faithfulness ] , @xmath194 is strongly faithful . as a consequence",
    ", @xmath185 is strongly faithful as well .",
    "thus , the following holds :    [ thm : delta2 ] the function @xmath185 is psm .    for step  @xmath197",
    ", we use a method due to lifschitz  _ et al_.  @xcite for eliminating double negations in heads and bodies of rules .",
    "the corresponding function @xmath198 is defined as follows :    let @xmath199 be the function obtained by replacing , for each given program @xmath200 , each rule @xmath157 of form @xmath201 as well as each rule of form @xmath202 where @xmath30 and @xmath47 are expressions and @xmath203 .    as shown in @xcite , performing replacements of the above type results in programs which are strongly equivalent to the original programs .",
    "in fact , it is easy to see that such replacements yield transformed programs which are strongly faithful to the original ones .",
    "since these transformations are clearly modular and constructible in polynomial time , we obtain that @xmath198 is psm .",
    "[ thm : delta3 ] the function @xmath198 is psm .    finally , we eliminate remaining negations possibly occurring in the heads of rules . to this end",
    ", we employ a procedure due to janhunen  @xcite .",
    "[ def : jan ] let @xmath204 be the function defined by setting , for any program @xmath205 , @xmath206 where @xmath207 results from @xmath5 by replacing each occurrence of a literal @xmath208 in the head of a rule in @xmath5 by @xmath209 .",
    "janhunen showed that replacements of the above kind lead to a transformation which is pfm .",
    "as a matter of fact , since his notion of faithfulness is somewhat stricter than ours , the results in  @xcite actually imply that , for any @xmath210 , @xmath211 is given by @xmath212 however , we need a stronger condition here , viz .  that the above equation holds for any @xmath205 and any @xmath213 .",
    "we show this by appeal to theorem  [ thm : strong - faithfulness ] .",
    "let @xmath214 be the translation defined above , and let @xmath215 result from @xmath214 by setting @xmath216 if @xmath205 and @xmath217 if @xmath218 .",
    "then , the function @xmath219 , defined as @xmath220 is a @xmath221-associated ht - homomorphism , where @xmath222 if @xmath205 , and @xmath223 otherwise , for any ht - interpretation @xmath65 over @xmath224 .",
    "observe that , in contrast to the definition of function @xmath225 from sublemma  [ sublemma : tr2 ] , here the same set of newly introduced atoms is added to both worlds . as before , we obtain that @xmath221 is strongly faithful , and hence that @xmath214 is strongly faithful as well .",
    "[ thm : delta4 ] the function @xmath214 is psm .",
    "summarising , we obtain our main result , which is as follows :    let @xmath226 be the functions defined above .",
    "then , the composed function @xmath165 , mapping nested logic programs over alphabet @xmath23 into disjunctive logic programs over alphabet @xmath227 , is polynomial , strongly faithful , and modular .",
    "since strong faithfulness implies faithfulness , we get the following corollary :    for any nested logic program @xmath5 over @xmath23 , the answer sets of @xmath5 are in a one - to - one correspondence to the answer sets of @xmath4 , determined by the following equation : @xmath228 where @xmath229 .",
    "we conclude with a remark concerning the construction of function @xmath185 .",
    "as pointed out previously , this mapping is based on a structure - preserving normal form translation for intuitionistic logic , as described in @xcite .",
    "besides the particular type of translation used here , there are also other , slightly improved structure - preserving normal form translations in which fewer rules are introduced , depending on the polarity of the corresponding subformula occurrences . however , although such optimised methods work in monotonic logics , they are not sufficient in the present setting . for instance , in a possible variant of translation @xmath185 based on the polarity of subformula occurrences , instead of introducing all three rules for an expression @xmath30 of form @xmath230 , only @xmath231 is used if @xmath30 occurs in the body of some rule , or both @xmath232 and @xmath233 are used if @xmath30 occurs in the head of some rule , and analogous manipulations are performed for atoms and disjunctions .",
    "applying such an encoding to @xmath234 over @xmath235 yields a translated program possessing two answer sets , say @xmath236 and @xmath237 , such that @xmath238 and @xmath239 , although only @xmath240 is an answer set of @xmath5 .",
    "we have developed a translation of logic programs with nested expressions into disjunctive logic programs .",
    "we have proven that our translation is polynomial , strongly faithful , and modular .",
    "this allows us to utilise off - the - shelf disjunctive logic programming systems for interpreting nested logic programs .",
    "in fact , we have implemented our translation as a front end for the system ` dlv `  @xcite .",
    "the corresponding compiler is implemented in prolog and can be downloaded from the web at url      our technique is based on the introduction of new atoms , abbreviating subformula occurrences .",
    "this method has its roots in structure - preserving normal form translations  @xcite , which are frequently used in automated deduction .",
    "in contrast to theorem proving applications , however , where the main focus is to provide satisfiability ( or , alternatively , validity ) preserving translations , we are concerned with much stronger equivalence properties , involving additional minimality criteria , since our goal is to _ reconstruct _ the answer sets of the original programs from the translated ones .    with the particular labeling technique employed here ,",
    "our translation avoids the risk of an exponential blow - up in the worst - case , faced by a previous approach of lifschitz _ et al .",
    "_  @xcite due to the usage of distributivity laws .",
    "however , this is not to say that our translation is _ always _ the better choice . as in classical theorem proving , it is rather a matter of experimental studies under which circumstances which approach is the more appropriate one . to this end , besides the implementation of our structural translation , we have also implemented the distributive translation into disjunctive logic programs in order to conduct experimental results .",
    "these experiments are subject to current research .",
    "also , we have introduced the concept of _ strong faithfulness _ , as a generalisation of ( standard ) faithfulness and strong equivalence .",
    "this allows us , for instance , to translate , in a semantics - preserving way , arbitrary program parts and leave the remaining program unaffected .          c.  baral and c.  uyan . .",
    "in _ proceedings of the sixth international conference on logic programming and nonmonotonic reasoning ( lpnmr-01 ) _ , volume 2173 of _ lecture notes in artificial intelligence _ , pages 186199 , berlin , 2001 .",
    "springer verlag .",
    "m.  cadoli , a.  giovanardi , and m.  schaerf .",
    "n algorithm to evaluate quantified boolean formulae . in _ proceedings of the fifteenth national conference on artificial intelligence ( aaai-98 ) _ , pages 262267 , menlo park , 1998 .",
    "aaai press .",
    "t.  eiter , n.  leone , c.  mateis , g.  pfeifer , and f.  scarcello . .",
    "in _ proceedings of the fourth international conference on logic programming and nonmonotonic reasoning ( lpnmr-97 ) _ , volume 1265 of _ lecture notes in artificial intelligence _ , pages 363374 , berlin , 1997 .",
    "springer verlag .",
    "t.  eiter , n.  leone , c.  mateis , g.  pfeifer , and f.  scarcello . .",
    "in _ proceedings of the sixth international conference on principles of knowledge representation and reasoning ( kr-98 ) _ , pages 406417 .",
    "morgan kaufmann publishers , 1998 .",
    "r.  feldmann , b.  monien , and s.  schamberger . istributed algorithm to evaluate quantified boolean formulas . in _ proceedings of the seventeenth national conference on artificial intelligence ( aaai-00 )",
    "_ , pages 285290 .",
    "aaai press , 2000 .",
    "m.  gelfond , m.  balduccini , and j.  galloway . .",
    "in _ proceedings of the sixth international conference on logic programming and nonmonotonic reasoning ( lpnmr-01 ) _ , volume 2173 of _ lecture notes in artificial intelligence _ , pages 213225 , berlin , 2001 .",
    "springer verlag .",
    "e.  giunchiglia , m.  narizzano , and a.  tacchella . .",
    "in _ proceedings of the first international joint conference on automated reasoning ( ijcar-01 ) _ , volume 2083 of _ lecture notes in computer science _ , pages 364369 , 2001 .",
    "k.  heljanko and i.  niemel . .",
    "in _ proceedings of the sixth international conference on logic programming and nonmonotonic reasoning ( lpnmr-01 ) _ , volume 2173 of _ lecture notes in artificial intelligence _ , pages 200212 , berlin , 2001 .",
    "springer verlag .",
    "t.  janhunen . .",
    "in _ proceedings of the sixth european workshop on logics in artificial intelligence ( jelia-98 ) _ , volume 1489 of _ lecture notes in artificial intelligence _ , pages 216232 , berlin , 1998 .",
    "springer verlag .",
    "t.  janhunen . .",
    "in _ proceedings of the sixth international conference on logic programming and nonmonotonic reasoning ( lpnmr-01 ) _ , volume 2173 of _ lecture notes in artificial intelligence _ , pages 93106 , berlin , 2001 .",
    "springer verlag .",
    "r.  letz . .",
    "in _ proceedings of the ijcar-01 workshop on theory and applications of quantified boolean formulas _ , technical report dii 12/01 , universit degli studi di siena , dipartimento di ingegneria dellinformazione , pages 5564 , 2001 .    v.  lifschitz . .",
    "in _ proceedings of the sixteenth international conference on logic programming ( iclp-99 ) _ , volume 1730 of _ lecture notes in artificial intelligence _ , pages 2337 , berlin , 1999 .",
    "springer verlag .",
    "i.  niemel and p.  simons .",
    "smodels : an implementation of the stable model and well - founded semantics for normal logic programs . in _ proceedings of the fourth international conference on logic programming and",
    "nonmonotonic reasoning ( lpnmr-97 ) _ , volume 1265 of _ lecture notes in artificial intelligence _ , pages 420429 , berlin , 1997 .",
    "springer verlag .",
    "d.  pearce , i.  de  guzmn , and a.  valverde . .",
    "in _ proceedings of the ninth international conference on automated reasoning with analytic tableaux and related methods ( tableaux-00 ) _ , volume 1847 of _ lecture notes in artificial intelligence _ , pages 352367 , berlin , 2000 .",
    "springer verlag .",
    "d.  pearce , i.  de  guzmn , and a.  valverde . . in _ proceedings of the first international conference on computational logic ( cl-00 )",
    "_ , volume 1861 of _ lecture notes in computer science _ , pages 688702 , berlin , 2000 .",
    "springer verlag .",
    "d.  pearce , h.  tompits , and s.  woltran . .",
    "progress in artificial intelligence : proceedings of the tenth portuguese conference on artificial intelligence ( epia-01 ) _ , volume 2258 of _ lecture notes in artificial intelligence _ , pages 306320 , berlin , 2001 .",
    "springer verlag .",
    "j.  rintanen .",
    "mprovements to the evaluation of quantified boolean formulae . in _ proceedings of the sixteenth international joint conference on artificial intelligence ( ijcai-99 )",
    "_ , pages 11921197 .",
    "morgan kaufmann publishers , 1999 ."
  ],
  "abstract_text": [
    "<S> nested logic programs have recently been introduced in order to allow for arbitrarily nested formulas in the heads and the bodies of logic program rules under the answer sets semantics . nested expressions can be formed using conjunction , disjunction , as well as the negation as failure operator in an unrestricted fashion . </S>",
    "<S> this provides a very flexible and compact framework for knowledge representation and reasoning . </S>",
    "<S> previous results show that nested logic programs can be transformed into standard ( unnested ) disjunctive logic programs in an elementary way , applying the negation as failure operator to body literals only . </S>",
    "<S> this is of great practical relevance since it allows us to evaluate nested logic programs by means of off - the - shelf disjunctive logic programming systems , like ` dlv ` . </S>",
    "<S> however , it turns out that this straightforward transformation results in an exponential blow - up in the worst - case , despite the fact that complexity results indicate that there is a polynomial translation among both formalisms . in this paper </S>",
    "<S> , we take up this challenge and provide a polynomial translation of logic programs with nested expressions into disjunctive logic programs . </S>",
    "<S> moreover , we show that this translation is modular and ( strongly ) faithful . </S>",
    "<S> we have implemented both the straightforward as well as our advanced transformation ; the resulting compiler serves as a front - end to ` dlv `  and is publicly available on the web . </S>"
  ]
}