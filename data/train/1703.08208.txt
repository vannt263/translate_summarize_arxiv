{
  "article_text": [
    "polar codes are the first family of error - correcting codes with provable capacity - achieving property and a low - complexity encoding and decoding process @xcite .",
    "the successive - cancellation ( sc ) decoding is a low - complexity algorithm with which polar codes can achieve the capacity of a memoryless channel .",
    "however , there are two main drawbacks associated with sc .",
    "firstly , sc requires the decoding process to advance bit by bit .",
    "this results in high latency and low throughput when implemented in hardware @xcite .",
    "second , polar codes decoded with sc only achieve the channel capacity when the code length tends toward infinity . for practical polar codes of moderate length , sc falls short in providing a reasonable error - correction performance .",
    "the first issue is a result of the serial nature of sc . in order to address this issue ,",
    "the recursive structure of polar codes construction and the location of information and parity ( frozen ) bits were utilized in @xcite to identify constituent polar codes . in particular , rate zero ( ) codes with all frozen bits , rate one ( ) codes with all information bits , repetition ( rep ) codes , and single parity - check ( spc ) codes",
    "were shown to be capable of being decoded in parallel with low - complexity decoding algorithms .",
    "this in turn increased the throughput and reduced the latency significantly .",
    "moreover , the simplifications in @xcite did not introduce any error - correction performance degradation with respect to conventional sc .",
    "the second issue stems from the fact that sc is suboptimal with respect to maximum - likelihood ( ml ) decoding .",
    "the decoding of each bit is only dependent on the bits already decoded .",
    "sc is unable to use the information about the bits that are not decoded yet . in order to address this issue , sc list ( scl ) decoding advances by estimating each bit as either @xmath1 or @xmath2 .",
    "therefore , the number of candidate codewords doubles at each bit estimation step . in order to limit the exponential increase in the number of candidates , only @xmath3",
    "candidate codewords are allowed to survive by employing a path metric ( @xmath4 ) @xcite .",
    "the @xmath4s were sorted and the @xmath3 best candidates were kept for further processing .",
    "scl reduces the gap between sc and ml and it was shown that when a cyclic redundancy check ( crc ) code is concatenated with polar codes , scl can make polar codes outperform the state - of - the - art codes to the extent that polar codes have been chosen to be adopted in the next generation of mobile broadband standard @xcite .",
    "the good error - correction performance of scl comes at the cost of higher latency , lower throughput , and higher area occupation than sc when implemented on hardware @xcite .",
    "it was identified in @xcite that using the log - likelihood ratio ( llr ) values results in a scl decoder which is more area - efficient than the conventional scl decoder with log - likelihood ( ll ) values . in order to reduce the latency and",
    "increase the throughput associated with scl , a group of @xmath5 bits were allowed to be decoded together in @xcite .",
    "@xcite proposed a high throughput architecture based on a tree - pruning scheme and further extended it to a multimode decoder in @xcite .",
    "the throughput increase in @xcite is based on code - based parameters which could degrade the error - correction performance significantly .",
    "based on the idea in @xcite , a fast list decoder architecture for software implementation was proposed in @xcite which was able to decode constituent codes in a polar code in parallel .",
    "this resulted in fewer number of time - steps to finish the decoding process .",
    "however , the scl decoder in @xcite is based on an empirical approach to decode and spc nodes and can not guarantee the same error - correction performance as the conventional scl decoder .",
    "moreover , all the decoders in @xcite require a large sorter to select the surviving candidate codewords . since the sorter in the hardware implementation of scl decoders has a long and dominant critical path which is dependent on the number of its inputs @xcite , increasing the number of @xmath4s results in a longer critical path and a lower operating frequency .",
    "based on the idea of list sphere decoding in @xcite , a simplified scl ( sscl ) was proposed in @xcite which identified and avoided the redundant calculations in scl .",
    "therefore , it required fewer number of time - steps than scl to decode a polar code .",
    "the advantage of sscl is that it not only guarantees the error - correction performance preservation , but also it uses the same sorter as in the conventional scl algorithm .",
    "to further increase the throughput and reduce the latency of sscl , the matrix reordering idea in @xcite was used to develop the sscl - spc decoder in @xcite .",
    "while sscl - spc uses the same sorter as in the conventional scl , it provides an exact reformulation for @xmath6 and its approximations bring negligible error - correction performance loss with respect to sscl .",
    "while sscl and sscl - spc are algorithms that can work with any list size , they fail to address the redundant bit - estimations associated with a specific list size . in this paper",
    ", we first prove that there is a specific number of bit - estimations required for decoding the nodes in sscl and sscl - spc for every list size to guarantee the error - correction performance preservation .",
    "any bit - estimation after that number is redundant and any bit - estimation before that number can not provably preserve the error - correction performance .",
    "since these decoders require fewer number of time - steps than sscl and sscl - spc , we name them fast - sscl and fast - sscl - spc , respectively .",
    "we further show that in practical polar codes , we can achieve similar error - correction performance to sscl and sscl - spc with even fewer number of bit - estimations .",
    "therefore , we can optimize fast - sscl and fast - sscl - spc for speed .",
    "we propose hardware architectures to implement both new algorithms : implementation results yield the highest throughput in the state - of - the - art with comparable area occupation .",
    "this paper is an extension to our work in @xcite .",
    "section [ sec : prel ] provides a background on polar codes and its decoding algorithms .",
    "section [ sec : fsscl ] introduces the proposed fast - sscl and fast - sscl - spc algorithms and their speed optimization technique .",
    "a decoder architecture is proposed in section [ sec : decarch ] and the implementation results are provided in section [ sec : results ] .",
    "finally , section [ sec : conc ] draws the main conclusions of the paper .",
    "a polar code of length @xmath7 with @xmath8 information bits is represented by @xmath9 and can be constructed recursively with two polar codes of length @xmath10 .",
    "this recursive construction can be denoted as a matrix multiplication as @xmath11 where @xmath12 is the sequence of input bits , @xmath13 is the sequence of coded bits , and @xmath14 is the generator matrix created by the product of @xmath15 which is the bit - reversal permutation matrix , and @xmath16 which is the @xmath17-th kronecker product of the polarizing matrix @xmath18 $ ] .",
    "the encoding process involves the determination of the @xmath8 bit - channels with the best channel characteristics and assigning the information bits to them .",
    "the remaining @xmath19 bit - channels are set to a known value known at the decoder side .",
    "they are thus called frozen bits with set @xmath20 . since the value of these bits does not have an impact on the error - correction performance of polar codes on a symmetric channel , they are usually set to @xmath1 .",
    "the codeword @xmath21 is then modulated and sent through the channel . in this paper , we consider binary phase - shift keying ( bpsk ) modulation which maps @xmath22 to @xmath23 .",
    "the binary tree shown in fig .",
    "[ figscdec ] represents the sc decoding process of @xmath24 . at each stage @xmath25 of the tree , for a node of length @xmath26 , soft logarithmic likelihood ratio ( llr ) values @xmath27 pass from parent to child nodes , while the hard bit estimates @xmath28 follow the opposite direction .",
    "the @xmath29 elements vectors @xmath30 and @xmath31 can be computed as @xmath32 whereas the @xmath33 values of @xmath34 are calculated by means of the left and right messages @xmath35 and @xmath36 as @xmath37 where @xmath38 is the bitwise xor operation . at leaf nodes ,",
    "the @xmath39-th bit @xmath40 can be estimated as @xmath41 equation  ( [ eq1 ] ) can be reformulated in a more hardware - friendly ( hwf ) version that has first been proposed in @xcite : @xmath42      the error - correction performance of sc when applied to codes with short to moderate length can be improved by the use of list - based decoding .",
    "the scl algorithm estimates a bit considering both its possible values @xmath1 and @xmath2 . at every estimation ,",
    "the number of codeword candidates ( paths ) doubles : in order to limit the increase in the complexity of this algorithm , only a set of @xmath3 codeword candidates is memorized at all times .",
    "thus , after every estimation , half of the paths are discarded . to this purpose , a path metric ( @xmath4 ) is associated to each path and updated at every new estimation : it can be considered a cost function , and the @xmath3 paths with the lowest @xmath4s are allowed to survive . in the llr - based scl @xcite , the @xmath4 can be computed as @xmath43 where @xmath44 is the path index and @xmath45 is the estimate of bit @xmath46 at path @xmath44 .",
    "a hwf version of equation  ( [ eq5 ] ) has been proposed in @xcite : @xmath47 which can be rewritten as @xmath48    considering there is no resource limitation , the number of time - steps required to decode a code of length @xmath7 with @xmath8 information bits in scl is @xcite @xmath49        the sscl algorithm in @xcite provides efficient decoders for , rep , and nodes in scl without traversing the decoding tree while guaranteeing the error - correction performance preservation .",
    "for example in fig .",
    "[ figscdec ] , the black circles represent nodes , the white circles represent nodes , and the white triangles represent rep nodes . the pruned decoding tree of sscl for the example in fig .",
    "[ figscdec ] is shown in fig .",
    "[ figsscldec ] which consists of two rep nodes and a node .",
    "let us consider that the vectors @xmath50 and @xmath51 are relative to the top of a node in the decoding tree .",
    "nodes can be decoded as    -2em_n_s-1_l= _ i = 0^n_s-1 ( 1+^-_i_l ) & -1em [ eq : rate0:exact ] + _ i = 0^n_s-1 ( _ i_l)_i_l - _ i_l & -1em [ eq : rate0:hwf ]    rep nodes can be decoded as    -2em_n_s-1_l= _ i = 0^n_s-1 ( 1+^-_n_s-1_l_i_l ) & -1em [ eq : rep : exact ] + _ i = 0^n_s-1 ( _ i_l)_i_l - _ n_s-1_l_i_l & -1em [ eq : rep : hwf ]    where @xmath52 represents the bit estimate of the information bit in the rep node .",
    "finally , nodes can be decoded as    -2em_n_s-1_l= _ i = 0^n_s-1 ( 1+^-_i_l_i_l ) & -1em [ eq : rate1:exact ] + _ i = 0^n_s-1 ( _ i_l)_i_l - _ i_l_i_l & -1em [ eq : rate1:hwf ]    it was shown in @xcite that the time - step requirements of , rep , and nodes of length @xmath33 in sscl decoding can be represented as @xmath53    while the sscl algorithm reduces the number of required time - steps to decode nodes by almost a factor of three , it fails to address the effect of list size on the maximum number of required bit estimations . in section [ sec : fsscl ] , we prove that the number of required time - steps to decode nodes depends on the list size and that the new algorithm is faster than both scl and sscl without incurring any error - correction performance degradation .      in @xcite ,",
    "a low - complexity approach was proposed to decode spc nodes which resulted in exact reformulations for @xmath6 and its approximations for other list sizes brought negligible error - correction performance degradation .",
    "the pruned tree of for the same example as in fig .",
    "[ figscdec ] is shown in fig .",
    "[ figssclspcdec ] which consists of a rep node and a spc node .",
    "the idea is to decode the frozen bit in spc nodes in the first step of the decoding process . in order to do that ,",
    "the @xmath4 calculations in the hwf formulation were carried out by only finding the llr value of the least reliable bit and using the llr values at the top of the polar code tree in the scl decoding algorithm for the rest of the bits .",
    "the least reliable bit in an spc node of length @xmath33 is found as @xmath54 and the parity of it is derived as @xmath55 to satisfy the even - parity constraint , @xmath56 is found for each path based on ( [ eq : spcgamma ] ) .",
    "the @xmath4s are then initialized as @xmath57 in this way , the least reliable bit which corresponds to the even - parity constraint is decoded first . for bits other than the least reliable bit , the @xmath4 is updated as @xmath58 finally , when all the bits are estimated , the least reliable bit is set to preserve the even - parity constraint as @xmath59    in @xcite , the time - step requirements of spc nodes of length @xmath33 in sscl - spc decoding was shown to be @xmath60 which consists of one time - step for ( [ eq : spcpm0 ] ) , @xmath61 time - steps for ( [ eq : spcpm ] ) , and one time - step for ( [ eq : spcbitcorrection ] ) .",
    "the sscl - spc algorithm reduces the number of required time - steps to decode spc nodes by almost a factor of three , but as in the case of nodes , it fails to address the effect of list size on the maximum number of required bit estimations . in section [ sec : fsscl ] , we prove that the number of required time - steps to decode spc nodes depends on the list size and that the new algorithm is faster than sscl - spc without incurring any error - correction performance degradation .",
    "in this section , we propose a fast decoding approach for nodes and use it to develop .",
    "we further propose a fast decoding approach for spc nodes in and use it to develop . to this end",
    ", we provide the exact number of bit estimations in and spc nodes to guarantee error - correction performance preservation . any bit estimation after that number is redundant and any bit estimation less than that number can not guarantee the error - correction performance preservation .",
    "we further show that in practical applications , this number can be reduced with almost no error - correction performance loss .",
    "we use this phenomenon to optimize fast - sscl and fast - sscl - spc for speed .",
    "the and spc decoders in sscl and sscl - spc require the estimation of all the bits at the top of the decoding tree .",
    "we prove that there is only a specific number of bits at the top of the decoder tree that needs to be estimated to preserve the error - correction performance .",
    "this in turn speeds up the decoding process for and spc nodes .",
    "the fast and spc decoders can be summarized by the following theorems .",
    "[ th : maxestimate ] in sscl decoding with list size @xmath3 , the number of bit estimations in a node of length @xmath33 required to get the exact same results as the conventional sscl decoder is @xmath62    the proposed technique results in @xmath63 which improves the required number of time - steps to decode nodes when @xmath64 . every bit after the @xmath65-th can be obtained through hard decision on the llr as @xmath66 without the need for path splitting . on the other hand , in case @xmath67 , all bits of the node need to be estimated and the decoding automatically reverts to the process described in @xcite .",
    "the proof of the theorem is nevertheless valid for both @xmath64 and @xmath68 and is provided in @xcite .",
    "the proposed theorem remains valid also for the hwf formulation that can be written as @xmath69 the proof of the theorem in the hwf formulation case is also presented in @xcite .",
    "the result of theorem  [ th : maxestimate ] provides an exact number of bit - estimations in nodes for each list size in scl decoding in order to guarantee error - correction performance preservation .",
    "the node decoder of @xcite empirically states that two bit - estimations are required to preserve the error - correction performance .",
    "the following remarks are the direct results of theorem  [ th : maxestimate ] .",
    "the node decoder of @xcite for @xmath6 is redundant .",
    "theorem  [ th : maxestimate ] states that for a node of length @xmath33 when @xmath6 , the number of bit - estimations is @xmath70 .",
    "therefore , there is no need to estimate the bits after the least reliable bit is estimated .",
    "@xcite for @xmath6 is thus redundant .",
    "the node decoder of @xcite falls short in preserving the error - correction performance for higher rates and larger list sizes .    for codes of higher rates , the number of nodes of larger length increases @xcite .",
    "therefore , when the list size is also large , @xmath71 .",
    "the gap between the empirical method of @xcite and the result of theorem  [ th : maxestimate ] can introduce significant error - correction performance loss .",
    "[ fig : er1kl128_1024_860 ] provides the frame error rate ( fer ) and bit error rate ( ber ) of decoding a @xmath72 code with sscl of @xcite and the empirical method of @xcite when the list size is @xmath73 .",
    "it can be seen that the error - correction performance loss reaches @xmath74db at fer of @xmath75 . in section  [ sec : fsscl : speed ] , we show that the number of bit - estimations can be tuned for each list size to find a good trade - off between the error - correction performance and the speed of decoding .",
    "+ [ perf - legend1kl128_1024_860 ]    [ th : maxestimatespc ] in decoding with list size @xmath3 , the number of bit estimations in a spc node of length @xmath33 required to get the exact same results as the conventional decoder is @xmath76    following the time - step calculation of sscl - spc , the proposed technique in theorem  [ th : maxestimatespc ] results in @xmath77 which improves the required number of time - steps to decode spc nodes when @xmath78 . every bit after the @xmath3-th can be obtained through hard decision on the llr as in ( [ eq : harddecllr ] ) without the need for path splitting . in case @xmath79 ,",
    "all bits of the node need to be estimated and the decoding automatically reverts to the process described in @xcite .",
    "the proof of the theorem is nevertheless valid for both @xmath78 and @xmath80 .",
    "we defer the proof to appendix  [ sec : app2 ] .",
    "the proposed node decoder is used in and algorithms and the proposed spc node decoder is used in , while the decoders for and rep nodes remain similar to those used in sscl @xcite such that @xmath81    it should be noted that the number of bit estimations is directly related to the number of time - steps required in the decoding process @xcite . therefore , when @xmath82 , the time - step requirement of spc nodes based on theorem [ th : maxestimatespc ] is two time - steps more than the time - step requirement of nodes as in theorem [ th : maxestimate ] . however",
    ", if spc nodes are not taken into account as in fast - sscl decoding , the polar code tree needs to be traversed to find rep nodes and rate-1 nodes as shown in fig .",
    "[ figsscldec ] . for a spc node of length @xmath33",
    ", this will result in additional time - step requirements as @xmath83 for example , for a spc node of length @xmath84 , fast - sscl with @xmath85 results in @xmath86 , while fast - sscl - spc with @xmath85 results in @xmath87 .    in practical polar codes , there are many instances where @xmath64 for nodes and using the algorithm can significantly reduce the number of required decoding time - steps with respect to sscl .",
    "similarly , there are many instances where @xmath78 for nodes and using the algorithm can significantly reduce the number of required decoding time - steps with respect to sscl - spc . fig .",
    "[ figtimereq ] shows the savings in time - step requirements of a polar code with three different rates .",
    "it should be noted that as the rate increases , the number of and spc nodes increases .",
    "this consequently results in more savings by going from sscl ( sscl - spc ) to fast - sscl ( fast - sscl - spc ) .",
    "[ perf - legendtimereq ] +    0.3    0.3    0.3      the analysis in section [ sec : fsscl : theorems ] provides exact reformulations of sscl and sscl - spc decoders without introducing any error - correction performance loss .",
    "however , in practical polar codes , there are fewer number of bit estimations required for fast - sscl and fast - sscl - spc in order to match the error - correction performance of sscl and sscl - spc , respectively .",
    "let us consider @xmath88 be the number of bit estimations in a node of length @xmath33 , and @xmath89 be the number of bit estimations in a spc node of length @xmath33 where @xmath90 and @xmath91 .",
    "it should be noted that @xmath92 and @xmath93 result in optimal number of bit estimations as presented in theorem [ th : maxestimate ] and theorem [ th : maxestimatespc ] , respectively .",
    "the smaller the values of @xmath94 and @xmath95 , the faster the decoders of fast - sscl and fast - sscl - spc .    the definition of the parameters @xmath94 and @xmath95 provides a trade - off between error - correction performance and speed of fast - sscl and fast - sscl - spc .",
    "let us consider crc - aided fast - sscl decoding of @xmath96 with crc length @xmath97 .",
    "[ fig : er1kl2 ] shows that for @xmath6 , choosing @xmath98 results in significant fer and ber error - correction performance degradation . therefore , when @xmath6 , the optimal value of @xmath99 is used for fast - sscl .",
    "the optimal value of @xmath94 for @xmath100 is @xmath101 .",
    "however , as shown in fig .",
    "[ fig : er1kl4 ] , @xmath99 results in almost the same fer and ber performance as the optimal value of @xmath102 . for @xmath103 , the selection of @xmath99 results in @xmath104  db of error - correction performance degradation at fer  @xmath105 as shown in fig .",
    "[ fig : er1kl8 ] .",
    "however , selecting @xmath106 removes the error - correction performance gap to the optimal value of @xmath107 . in the case of crc - aided fast - sscl - spc decoding of @xmath96 with @xmath97 bits of crc , selecting @xmath99 and @xmath108 for @xmath100 results in almost the same fer and ber performance as the optimal values of @xmath102 and @xmath109 as shown in fig .",
    "[ fig : er1kl4spc ] . as illustrated in fig .",
    "[ fig : er1kl8spc ] for @xmath103 , the selection of @xmath106 and @xmath109 provides similar fer and ber performance as the optimal values of @xmath107 and @xmath110 .",
    "+ [ perf - legend1kl2 ]     + [ perf - legend1kl4 ]     + [ perf - legend1kl8 ]     + [ perf - legend1kl4spc ]     + [ perf - legend1kl8spc ]",
    "to evaluate the impact of the proposed techniques on a practical case , a list - based polar code decoder architecture implementing fast - sscl and fast - sscl - spc has been designed .",
    "its basic structure is inspired to the decoders presented in @xcite , and it is portrayed in fig .  [",
    "fig : decarch ] .",
    "the decoding flow follows the one portrayed in section [ sec : prel : scldec ] for a list size @xmath3 .",
    "this means that the majority of the datapath and of the memory are replicated @xmath3 times , and work concurrently on different candidate codewords and the associated llr values .",
    "starting from the tree root , the tree is descended by recursively computing ( [ eq4 ] ) and ( [ eq2 ] ) on left and right branches respectively at each tree stage @xmath25 , with a left - first rule .",
    "the computations are performed by @xmath3 sets of @xmath111 processing elements ( pes ) , where each set can be considered a standalone sc decoder . in case @xmath112 ,",
    "( [ eq4 ] ) and ( [ eq2 ] ) require @xmath113 time - steps to be completed , while otherwise needing a single time - step .",
    "the updated llr values are stored in dedicated memories .",
    "the internal structure of pes is shown in fig .",
    "[ fig : pearch ] .",
    "each pe receives as input two llr values , outputting one .",
    "the computations for both ( [ eq4 ] ) and ( [ eq2 ] ) are performed concurrently , and the output is selected according to the @xmath25-th bit of the index @xmath39 , where @xmath114 .",
    "the index @xmath39 is represented with @xmath25 bits , and identifies the next leaf node to be estimated , and can be composed by observing the path from the root node to the leaf node . from stage @xmath115",
    "down to @xmath1 , for every left branch we set the corresponding bit of @xmath39 to @xmath1 , and to @xmath2 for every right branch .    when a leaf node is reached , the controller checks node sequence , identifying the leaf node as an information bit or a frozen bit . in case of a frozen bit ,",
    "the paths are not split , and the bit is estimated only as @xmath1 .",
    "all the @xmath3 path memories are updated with the same bit value , as are the llr memories and the @xmath116 memories . on the other hand , in case of an information bit , both @xmath1 and @xmath2 are considered .",
    "the paths are duplicated and the @xmath4s are calculated for the @xmath117 candidates according to ( [ eq7_1 ] ) .",
    "they are subsequently filtered through the sorter module , designed for minimum latency .",
    "every path metric is compared to every other in parallel : dedicated control logic uses the resulting signals to return the values of the path metrics of the surviving paths and the newly estimated bits they are associated with .",
    "the latter are used to update the llr memories , the @xmath116 memories and the path memories , while also being sent to the crc calculation module to update the remainder .",
    "the decoding flow described above relies on a number of memories that are shown in fig .",
    "[ fig : memoryarch ] . the channel memory stores the @xmath7 llr values received from the channel at the beginning of the decoding process .",
    "each llr value is quantized with @xmath118 bits , and represented with sign and magnitude .",
    "the high and low stage memories store the intermediate @xmath119 computed in ( [ eq4 ] ) and ( [ eq2 ] ) .",
    "the high stage memory is used to store llr values related to stages with nodes of size greater than @xmath111 .",
    "the number of pes determines the number of concurrent ( [ eq4 ] ) or ( [ eq2 ] ) that can be performed : for a node in stage @xmath25 , where @xmath120 , a total of @xmath113 time - steps are needed to descend to the lower tree level .",
    "the depth of the high stage memory is thus @xmath121 , while its width is @xmath122 .",
    "on the other hand , the low stage memory stores the llr values for stages where @xmath123 : the width of this memory is the same as that of the high stage memory , while its depth is defined as @xmath124 . while high and low stage memories are different for each path , the channel llr values are shared among the @xmath3 datapaths .",
    "table  [ tab : memaccess ] summarizes the memory read and write accesses for the aforementioned llr memories .",
    "when @xmath125 , @xmath126 llr values are read from the high stage memory , and the @xmath111 resulting llr values are written in the low stage memory .",
    "the channel memory is read at @xmath115 only .",
    ".llr memory access .",
    "[ cols=\"^,^,^\",options=\"header \" , ]      + ( lr)1 - 1 ( lr)2 - 2 ( lr)3 - 4 ( lr)5 - 7    & @xmath127 & & & @xmath128 & @xmath129 & @xmath130 + & @xmath131 & & & @xmath132 & @xmath133 & @xmath134 + & @xmath135 & & & @xmath136 & @xmath137 & @xmath138 +    & @xmath127 & & & @xmath139 & @xmath129 & @xmath140 + & @xmath131 & & & @xmath141 & @xmath133 & @xmath142 + & @xmath135 & & & @xmath143 & @xmath137 & @xmath144 +    & @xmath127 & & & @xmath145 & @xmath129 & @xmath146 + & @xmath131 & & & @xmath147 & @xmath133 & @xmath148 + & @xmath135 & & & @xmath149 & @xmath137 & @xmath150 +    & @xmath127 & @xmath2 & & @xmath151 & @xmath152 & @xmath153 + & @xmath131 & @xmath2 & & @xmath154 & @xmath155 & @xmath156 + & @xmath131 & @xmath101 & & @xmath157 & @xmath155 & @xmath158 + & @xmath135 & @xmath127 & & @xmath159 & @xmath137 & @xmath160 + & @xmath135 & @xmath161 & & @xmath162 & @xmath137 & @xmath163 +    & @xmath127 & @xmath2 & @xmath127 & @xmath164&@xmath152 & @xmath165 + & @xmath131 & @xmath2 & @xmath101 & @xmath166 & @xmath155 & @xmath167 + & @xmath131 & @xmath101 & @xmath131 & @xmath168 & @xmath155 & @xmath169 + & @xmath135 & @xmath127 & @xmath131 & @xmath170 & @xmath137 & @xmath171 + & @xmath135 & @xmath161 & @xmath135 & @xmath172 & @xmath137 & @xmath173 +    the architecture designed in section  [ sec : decarch ] has been described in the vhdl language and synthesized in tsmc 65 nm cmos technology .",
    "implementation results are provided in table [ tab : implementations ] for different decoders : along with the fast - sscl and fast - sscl - spc described in this work , the scl , sscl and sscl - spc decoders proposed in @xcite are presented as well . each decoder has been synthesized with three list sizes ( @xmath174 ) , while the fast - sscl and fast - sscl - spc architectures have been synthesized for considering different combinations of @xmath94 and @xmath95 , as portrayed in section [ sec : fsscl : speed ] .",
    "quantization values are the same used in @xcite , i.e. @xmath175 bits for llr values and @xmath135 bits for @xmath4s , with two fractional bits each .",
    "all memory elements have been implemented through registers and the area results include both net area and cell area .",
    "all fast - sscl and fast - sscl - spc , regardless of the value of @xmath94 and @xmath95 , show a substantial increase in area occupation with respect to sscl and sscl - spc .",
    "the main contributing factors to the additional area overhead are three :    * in sscl and sscl - spc , the crc computation needs to be parallelized , since in and nodes multiple bits are updated at the same time .",
    "however , the bit value is known at design time , since they are frozen bits . this , along with the fact that @xmath1 is neutral in the xor operations required by crc calculation , limits the required additional area overhead . on the contrary , in fast - sscl and fast - sscl - spc , and nodes",
    "update multiple bits within the same time - step ( spc2 - 2 and rate1 - 2 stages ) . in these cases , however , they are information bits , whose values can not be known at design time : the resulting parallel crc tree is substantially wider and deeper than the ones for and nodes .",
    "moreover , with increasing number of crc trees , the selection logic becomes more cumbersome . *",
    "a similar situation is encountered for the @xmath116 memory update signal . as described in the previous section ,",
    "the @xmath116 memory update values are computed assuming both estimated values , and the actual value of @xmath176 is used as a selection signal . in sscl and sscl - spc",
    "the multiple - bit update does not constitute a problem since all the estimated bits are @xmath1 and the @xmath116 memory content does not need to be changed .",
    "on the contrary , in fast - sscl and fast - sscl - spc , the value of the estimated information bits might change the content of the @xmath116 memory .",
    "moreover , since @xmath116 is computed as ( [ eq3 ] ) , the update of @xmath116 bits depends on previous bits as well as the newly estimated ones .",
    "thus , an xor tree is necessary to compute the right selection signal for every information bit estimated in spc2 - 2 and rate1 - 2 stages . * the aforementioned modifications",
    "considerably lengthen the system critical path .",
    "thus , pipeline registers have been inserted to lower the impact of critical path , at the cost of additional area occupation .",
    "fast - sscl and fast - sscl - spc implementations show consistent throughput improvements with respect to previously proposed architectures . the gain is lower than what is shown to be theoretically achievable in fig .",
    "[ figtimereq ] .",
    "this is due to the aforementioned pipeline stages , that increase the number of steps needed to complete the decoding of component codes .",
    ".9cyyyyyyyyyyy & & @xcite & @xcite^^ & & @xcite^^ & + ( lr)1 - 1 ( lr)2 - 4 ( lr)5 - 5 ( lr)6 - 6 ( lr)7 - 8 ( lr)9 - 9 ( lr)10 - 12    @xmath3 & @xmath127 & @xmath131 & @xmath135 & @xmath131 & @xmath131 & @xmath127 & @xmath131 & @xmath131 & @xmath127 & @xmath131 & @xmath135 + @xmath111 & @xmath84 & @xmath84 & @xmath84 & @xmath84 & @xmath84 & @xmath84 & @xmath84 & @xmath177 & @xmath84 & @xmath84 & @xmath84 +    area [ mm@xmath178 & @xmath164 & @xmath166 & @xmath170 & @xmath179 & @xmath180 & @xmath181 & @xmath182 & @xmath183 & @xmath184 & @xmath185 & @xmath186 + frequency [ mhz ] & @xmath152 & @xmath155 & @xmath137 & @xmath187 & @xmath188 & @xmath189 & @xmath190 & @xmath191 & @xmath129 & @xmath133 & @xmath137 + throughput [ mb / s ] & @xmath165 & @xmath167 & @xmath171 & @xmath192 & @xmath193 & @xmath194 & @xmath195 & @xmath196 & @xmath146 & @xmath148 & @xmath150 + latency [ @xmath197s ] & @xmath198 & @xmath199 & @xmath200 & @xmath201 & @xmath202 & @xmath203 & @xmath204 & @xmath205 & @xmath206 & @xmath207 & @xmath208 + area efficiency [ mb / s / mm@xmath178 & @xmath209 & @xmath210 & @xmath211 & @xmath212 & @xmath213 & @xmath214 & @xmath215 & @xmath216 & @xmath217 & @xmath218 & @xmath219 +   +    the hardware implementation presented in this paper is compared with the state - of - the - art architectures in @xcite and the results are provided in table  [ tab : compare ] .",
    "the architectures presented in @xcite were synthesized based on 90  nm technology : for a fair comparison , their results have been converted to 65  nm technology using a factor of @xmath220 for the frequency and a factor of @xmath221 for the area .",
    "the synthesis results in @xcite were carried out in 65  nm technology but reported in 90  nm technology .",
    "therefore , a reverse conversion was applied to convert the results back to 65  nm technology .",
    "the architecture in this paper shows @xmath222 higher throughput and @xmath223 lower latency with respect to the multibit decision scl decoder architecture of @xcite for @xmath100 .",
    "however , the area occupation of @xcite is smaller , leading to a higher area efficiency than the design in this paper .",
    "the symbol - decision scl decoder architecture of @xcite shows lower area occupation than the design in this paper for @xmath100 but it comes at the cost of lower throughput and higher latency .",
    "our decoder architecture achieves @xmath224 higher throughput and @xmath225 lower latency than @xcite which resulted in @xmath226 higher area efficiency .",
    "the high throughput scl decoder architecture of @xcite for @xmath6 requires lower area occupation than our design but it comes at the expense of lower throughput and higher latency .",
    "moreover , the design in @xcite relies on parameters that need to be tuned for each code , and it is shown in @xcite that a change of code can result in more than @xmath227  db error - correction performance loss .",
    "for @xmath100 , our decoder not only achieves higher throughput and lower latency than @xcite , but also it occupies a smaller area .",
    "this in turn yields a @xmath228 increase in the area efficiency in comparison with @xcite .",
    "the multimode scl decoder in @xcite relies on a higher number of pes than our design : nevertheless , it yields lower throughput and higher latency than the architecture proposed in this paper for @xmath100 .",
    "it should be noted that @xcite is based on the design presented in @xcite , whose code - specific parameters may lead to substantial error - correction performance degradation . on the contrary ,",
    "the design in this paper is targeted for speed and flexibility and can be used to decode any polar code of any length .",
    "compared to our previous work @xcite , that has the same degree of flexibility of the proposed design , this decoder achieves @xmath229 higher throughput and @xmath230 lower latency for @xmath6 , and @xmath231 higher throughput and @xmath232 lower latency for @xmath100 .",
    "however , the higher area occupation of the new design yields lower area efficiencies than @xcite for @xmath233 . for @xmath103 ,",
    "the proposed design has @xmath234 higher throughput and @xmath235 lower latency than @xcite , which results in @xmath236 increase in area efficiency .",
    "the reason is that for @xmath103 , the sorter is quite large and falls on the critical path .",
    "consequently , the maximum achievable frequency for the proposed design is limited by the sorter and not by and nodes as opposed to the @xmath233 case .",
    "this results in the same maximum achievable frequency for both designs , hence , higher throughput and area efficiency .    fig .",
    "[ fig : all2 ] plots the area occupation against the decoding latency for all the decoders considered in table  [ tab : compare ] . for each value of @xmath3 ,",
    "the design proposed in this work have the shortest latency , shown by their leftmost position on the graph .",
    "in this work , we have proven that the list size in polar decoders sets a limit to the useful number of bit estimations in and nodes .",
    "we thus propose fast - sscl and fast - sscl - spc polar code decoding algorithms that , depending on @xmath3 and the number of performed bit estimations , can reduce the number of required time - steps of more than @xmath237 at no error - correction performance cost .",
    "hardware architectures for the proposed algorithms have been described and implemented in cmos 65  nm technology .",
    "they have a very high degree of flexibility and can decode any polar code , regardless of its rate .",
    "the proposed decoder is the fastest list - based decoder in literature : sized for @xmath238 and @xmath6 , it yields a @xmath239 gb / s throughput with an area occupation of @xmath164  mm@xmath240 .",
    "the same design , sized for @xmath100 and @xmath103 , leads to throughputs of @xmath241 gb / s and @xmath242 gb / s , and areas of @xmath166  mm@xmath240 and @xmath170  mm@xmath240 , respectively .",
    "in order to prove theorem [ th : maxestimatespc ] , we note that the first step is to initialize the @xmath4s based on ( [ eq : spcpm0 ] )",
    ". therefore , the least reliable bit needs to be estimated first . for the bits other than the least reliable bit , the @xmath4s",
    "are updated based on ( [ eq : spcpm ] ) . however , the term @xmath243 is constant for all the bit estimations in the same path .",
    "therefore , we can define a new set of @xmath61 llr values as @xmath244 for @xmath245 and @xmath246 , which results in @xmath247 the problem is now reduced to a node of length @xmath61 which , with the result of theorem [ th : maxestimate ] , can be decoded by considering only @xmath248 bit estimations . adding the bit estimation for @xmath249",
    ", spc nodes can be decoded by estimating @xmath250 bits while guaranteeing the same results as in .",
    "theorem [ th : maxestimatespc ] is consequently proven .",
    "e.  arikan , `` channel polarization : a method for constructing capacity - achieving codes for symmetric binary - input memoryless channels , '' _ ieee trans .",
    "inf . theory _ ,",
    "55 , no .  7 , pp .",
    "30513073 , july 2009 .",
    "a.  balatsoukas - stimming , a.  j. raymond , w.  j. gross , and a.  burg , `` hardware architecture for list successive cancellation decoding of polar codes , '' _ ieee trans .",
    "circuits syst .",
    "ii _ , vol .",
    "61 , no .  8 , pp . 609613 , august 2014 .",
    "a.  balatsoukas - stimming , m.  bastani  parizi , and a.  burg , `` llr - based successive cancellation list decoding of polar codes , '' _ ieee trans . signal process .",
    "_ , vol .",
    "63 , no .",
    "19 , pp . 51655179 , october 2015 .                        c.  condo , m.  martina , g.  piccinini , and g.  masera , `` variable parallelism cyclic redundancy check circuit for 3gpp - lte / lte - advanced , '' _ ieee signal process .",
    "_ , vol .  21 , no .  11 , pp . 13801384 , november 2014"
  ],
  "abstract_text": [
    "<S> polar codes have gained significant amount of attention during the past few years and have been selected as a coding scheme for the next generation of mobile broadband standard . among decoding schemes , successive - cancellation list ( scl ) </S>",
    "<S> decoding provides a reasonable trade - off between the error - correction performance and hardware implementation complexity when used to decode polar codes , at the cost of limited throughput . </S>",
    "<S> the simplified scl ( sscl ) and its extension sscl - spc increase the speed of decoding by removing redundant calculations when encountering particular information and frozen bit patterns ( rate one and single parity check codes ) , while keeping the error - correction performance unaltered . in this paper , we improve sscl and sscl - spc by proving that the list size imposes a specific number of bit estimations required to decode rate one and single parity check codes . thus , the number of estimations can be limited while guaranteeing exactly the same error - correction performance as if all bits of the code were estimated . </S>",
    "<S> we call the new decoding algorithms fast - sscl and fast - sscl - spc . </S>",
    "<S> moreover , we show that the number of bit estimations in a practical application can be tuned to achieve desirable speed , while keeping the error - correction performance almost unchanged . hardware architectures implementing both algorithms are then described and implemented : it is shown that our design can achieve @xmath0 gb / s throughput , higher than the best state - of - the - art decoders .    </S>",
    "<S> polar codes , successive - cancellation decoding , list decoding , hardware implementation . </S>"
  ]
}