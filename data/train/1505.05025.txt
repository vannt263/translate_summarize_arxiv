{
  "article_text": [
    "the asynchronous system model places no assumptions on message propagation delay or relative process speeds .",
    "this makes the model attractive for distributed algorithm research as the results obtained in the model are applicable to an arbitrary network and computer architecture .",
    "however , the fully asynchronous system model is not well suited for fault tolerance studies .",
    "an elementary problem of consensus , where processes have to agree on a single value , is unsolvable even if only one process may crash  @xcite : the asynchrony of the model precludes processes from differentiating a crashed and a slow process .",
    "a failure detector  @xcite is a construct that enables the solution to consensus or related problems in the asynchronous system model .",
    "potentially , a failure detector may be very powerful and , therefore , hide the solution to the problem within its specification .",
    "conversely , the weakest failure detector specifies the least amount of synchrony required to implement consensus  @xcite .",
    "one such detector is omega .",
    "naturally , a failure detector may not be implemented in the asynchronous model itself .",
    "hence , a lot of research is focused on providing the implementation of a detector , especially omega , in the least restrictive communication model .",
    "these restrictions deal with timeliness and reliability of message delivery .",
    "aguilera et al .",
    "@xcite provide a remarkable omega implementation which requires only a single process to have eventually timely channels to the other processes and a single process to have so called fair - lossy channels to and from all other processes .",
    "aguilera et al .",
    "present what they call an efficient implementation where only a single process sends infinitely many messages . in their work ,",
    "aguilera et al .",
    "consider a direct channel as the sole means of message delivery from one process to another . in this paper , we consider a more general setting where a message may arrive to a particular process through several intermediate processes .",
    "otherwise , we preserve model assumptions of aguilera et al .     +",
    "* our contribution .",
    "* we study omega implementation under the assumption that a message may come to its destination through other processes .    to motivate this multi - hop omega implementation approach",
    ", we consider a fixed probability of channel timeliness and study the probability of leader existence in a classic single - hop and in multi - hop implementations .",
    "we prove that the probability of leader existence tends to zero for single - hop implementations and to one for multi - hop ones as network size grows .",
    "moreover , probability of leader persisting while the timeliness of channel changes tends to zero for single - hop and to infinity for multi - hop implementations .",
    "if we consider deterministic algorithms , we study three classes of omega implementations : message efficient , packet efficient and super packet efficient . in a message efficient",
    "implementation all but finitely many messages are sent by a single process . in a packet efficient",
    "implementation , the number of packets in all but finitely many transmitted messages is linear w.r.t . the number of processes in the network .",
    "however , in a ( simple ) packet efficient implementation , packets of different messages may use different channels such that potentially all channels in the system are periodically used . in a super packet efficient",
    "implementation , the number of channels used in all but finitely many messages is also linear w.r.t . to the number of processes .",
    "our major results are as follows . if timeliness of one message does not correlate with the timeliness of another , i.e. , there are no timely channels , we prove that any implementation of omega has to send infinitely many messages whose number of packets is quadratic w.r.t to the number of processes in the network .",
    "this precludes a packet efficient implementation of omega .",
    "if eventually timely and fair - lossy channels are allowed , we establish the necessary and sufficient conditions for the existence of a packet efficient implementation of omega .",
    "we then prove that this eventuality of timely and channels precludes the existence of a super packet efficient implementation of omega .",
    "we present an algorithm that uses these necessary conditions provides a message and packet efficient implementation of omega     + * related work . *",
    "the implementation of failure detectors is a well - researched area  @xcite .",
    "refer to  @xcite for detailed comparisons of work related to the kind of omega implementation we are proposing .",
    "we are limiting our literature review to the most recent and closest to ours studies .",
    "delporte - gallet et al .",
    "@xcite describe algorithms for recognizing timely channel graphs .",
    "their algorithms are super packet efficient and may potentially be used to implement omega . however , their solutions assume non - constant size messages and perpetually reliable channels .",
    "that is delporte - gallet et al .",
    "deviate from the model of aguilera et al . and the algorithms of delporte - gallet et al .",
    "do not operate correctly under fair - lossy and eventually timely channel assumptions .",
    "a number of papers consider omega implementation under various modifications of aguilera et al model .",
    "hutle et al .",
    "@xcite implement omega assuming a send - to - all message transmission primitive where @xmath0 processes are guaranteed to receive the message timely .",
    "fernandez and raynal  @xcite assume a process that is able to timely deliver its message to a quorum of processes over direct channels .",
    "this quorum and channels may change with each message .",
    "a similar rotating set of timely channels is used by malkhi et al .",
    "larrea et al .",
    "@xcite give an efficient implementation of omega but assume that all channels are eventually timely . in their omega implementation ,",
    "mostefaoui et al .",
    "@xcite rely on a particular order of message interleaving rather than on timeliness of messages .",
    "biely and widder  @xcite consider message - driven ( i.e. , non - timer based ) model and provide an efficient omega implementation .",
    "there are several recent papers on timely solutions to problems related to omega implementation .",
    "charron - bost et al .",
    "@xcite use a timely spanning tree to solve approximate consensus .",
    "lafuente et al .",
    "@xcite implement eventually perfect failure detector using a timely cycle of processes .",
    "* model specifics . * to simplify the presentation",
    ", we use an even more general model than what is used in aguilera et al .",
    "the major differences are as follows .",
    "we use infinite capacity non - fifo channels rather than single packet capacity channels .",
    "our channel construct makes us explicitly state the packet fairness propagation assumptions that are somewhat obscured by the single capacity channels .",
    "in addition , we do not differentiate between a slow process and a slow channel since slow channels may simulate both .",
    "omega implementation code is expressed in terms of guarded commands , rather than the usual more procedural description .",
    "the operation of the algorithm is a computation which is a sequence of these command executions .",
    "we express timeouts directly in terms of computation steps rather than abstract or concrete time .",
    "this simplifies reasoning about them .    despite the differences , the models are close enough such that all of the results in this paper are immediately applicable to the traditional omega implementation model .",
    "+ * processes and computations . *",
    "a computer network consists of a set @xmath1 of processes .",
    "the cardinality of this set is @xmath2 .",
    "each process has a unique identifier from @xmath3 to @xmath4 .",
    "processes interact by passing messages through non - fifo unbounded communication channels .",
    "each process has a channel to all other processes .",
    "that is , the network is fully connected .",
    "a message is _ constant size _ if the data it carries is in @xmath5 .",
    "for example , a constant size message may carry several process identifiers but not a complete network spanning tree .",
    "each process has variables and actions .",
    "the action has a _ guard _ : a predicate over the local variables and incoming channels of the process .",
    "an action is enabled if its guard evaluates to * true*. a _ computation _ is a potentially infinite sequence of global network states such that each subsequent state is obtained by executing an action enabled in the previous state .",
    "this execution is a computation _",
    "step_. processes may crash .",
    "_ crashed _ process stops executing its actions . _ correct _ process does not crash .",
    "+ * messages and packets . *",
    "we distinguish between a packet and a message .",
    "_ message _ is particular content to be distributed to processes in the network .",
    "_ origin _ is the process that initiates the message .",
    "the identifier of the origin is included in the message .",
    "messages are sent via packets .",
    "_ packet _ is a portion of data transmitted over a particular channel .",
    "a message is the payload of a packet .",
    "a process may receive a packet and either forward the message it contains or not .",
    "a process may not modify it : if a process needs to send additional information , the process may send a separate message .",
    "a process may forward the same message at most once . in effect , a message is transmitted to processes of the network using packets .",
    "a particular process may receive a message either directly from the origin , or indirectly possibly through multiple hops .",
    "+ * scheduling and fairness .",
    "* we express process synchronization in terms of an adversarial scheduler .",
    "the scheduler restrictions are as follows .",
    "we do not distinguish slow processes and slow packet propagation .",
    "a scheduler may express these phenomena through scheduling process action execution in a particular way .",
    "a packet transmission immediately enables the packet receipt action in the recipient process .",
    "a packet is lost if the receipt action is never executed .",
    "a packet is not lost if it is eventually received .",
    "+ * timers .",
    "* timer is a construct with the following properties .",
    "a timer can be reset , stopped and increased .",
    "it can also be checked whether the timer is on or off .",
    "it has a _ timeout integer _",
    "value and a _ timeout action _ associated with it .",
    "a timer is either a receiver timer or a sender timer .",
    "if a _ sender timer _ is on , timeout action is executed once the computation has at most the timeout integer steps without executing the timer reset .",
    "if a _ receiver timer _ is on , the timeout action is executed once the computation has at least the timeout integer steps without executing the timer reset .",
    "increasing the timer , adds an arbitrary positive integer value to the timeout integer .",
    "an off timer can be set to on by resetting it .",
    "+ * reliable and timely messages and packets . *",
    "a packet is _ reliable _ if it is received .",
    "a message is reliable if it is received by every correct process .",
    "a channel is reliable if every packet transmitted over this channel is reliable .",
    "a channel is _ fair - lossy _ if it has the following properties . if there is an infinite number of packet transmissions over a particular fair - lossy channel of a particular message type and origin , then infinitely many are received .",
    "we assume that a fair - lossy channel is not type discriminating .",
    "that is , if it is fair - lossy for one type and origin , it is also fair - lossy for every pair of message type and origin .    observe that if there is an infinite number of message transmissions of a particular message type and origin over a path that is fair - lossy , then infinitely many succeed .",
    "there converse is true as well : if there is an infinite number of successful message transmissions , there must be a fair - lossy path between the origin an the destination .",
    "a packet is _ timely _ if it is received within a bounded number of computation steps .",
    "specifically , there is a finite integer @xmath6 such that the packet is received within @xmath6 steps . naturally , a timely packet is a reliable packet .",
    "a message is timely if it is received by every process via a path of timely packets .",
    "a channel is timely if every packet transmitted over this channel is timely .",
    "a channel is eventually timely if the number of non - timely packets it transmits is finite .",
    "note that a channel that transmits a finite number of packets is always eventually timely .",
    "the timely channel definition is relatively clear .",
    "the opposite , non - timely channel , is a bit more involved .",
    "a channel that occasionally delays or misses a few packets is not non - timely as the algorithm may just ignore the missed packets with a large enough timeout .",
    "hence , the following definition .",
    "a channel is _ strongly non - timely _ if the following holds .",
    "if there is an infinite number of packet transmissions of a particular type and origin over a particular non - timely channel , then , for any fixed integer , there are infinitely many computation segments of this length such that none of the packets are delivered inside any of the segments .",
    "similarly , the non - timeliness has to be preserved across multiple channels , a message may not gain timeliness by finding a parallel timely path , then , for example , the two paths may alternate delivering timely messages . therefore , we add an additional condition for non - timeliness .",
    "all paths between a pair of processes @xmath7 and @xmath8 are _ strongly non - timely _",
    "if @xmath7 sends an infinite number of messages to @xmath8 , yet regardless of how the message is forwarded or what path it takes , for any fixed integer , there are infinitely many computation segments of this length such that none of the messages are delivered inside any of the segments . unless otherwise noted , when we discuss non - timely channels and paths , we mean strongly non - timely channels and paths",
    ".     + * communication models .",
    "* to make it easier to address the variety of possible communication restrictions , we define several models .",
    "_ the dependable ( channel ) model _ allows eventually or perpetually reliable timely or fair - lossy channels . in the dependable model",
    ", an algorithm may potentially discover the dependable channels by observing packet propagation . _",
    "the general propagation model _ does not allow either reliable or timely channels .",
    "thus , one message propagation is not related to another message propagation .     +",
    "* message propagation graph . *",
    "_ message propagation graph _ is a directed graph over network processes and channels that determines whether packet propagation over a particular channel would be successful .",
    "this graph is connected and has a single source : the origin process .",
    "this concept is a way to reason about scheduling of the packets of a particular message .",
    "each message has two propagation graphs . in",
    "_ reliable propagation graph _ @xmath9 , each edge indicates whether the packet is received if transmitted over this channel . in _ timely propagation graph",
    "@xmath10 each edge indicates whether the packet is timely if transmitted over this channel . since a timely packet is a reliable packet , for the same message , the timely propagation graph is a subgraph of the reliable propagation graph .",
    "in general , a propagation graph for each message is unique .",
    "that is , even for the same source process , the graphs for two messages may differ .",
    "this indicates that different messages may take divergent routes .    if a channel from process @xmath7 to process @xmath8 is reliable , then edge @xmath11 is present in the reliable propagation graph for every message where process @xmath7 is present . in other words ,",
    "if the message reaches @xmath7 and @xmath7 sends it to @xmath8 , then @xmath8 receives it .",
    "a similar discussion applies to a timely channel and corresponding edges in timely propagation graphs .",
    "propagation graphs are determined by the scheduler in advance of the message transmission .",
    "that is , the recipient process , depending on the algorithm , may or may not forward the received message along a particular outgoing channel .",
    "however , if the process forwards the message , the presence of an edge in the propagation graph determines the success of the message transmission .",
    "note that the process forwards a particular message at most once .",
    "hence , the propagation graph captures the complete possible message propagation pattern .",
    "a process may crash during message transmission .",
    "this crash does not alter propagation graphs .",
    "[ proprconnected ] a message is reliable only if its reliable propagation graph @xmath9 is such that every correct process is reachable from the origin through non - crashed processes .",
    "[ proptconnected ] a message is timely only if its timely propagation graph @xmath10 is such that every correct process is reachable from the origin through non - crashed processes .",
    "+ * omega implementation and its efficiency .",
    "* an algorithm that implements the omega failure detector ( or just omega ) is such that in a suffix of every computation , each correct process outputs the identifier of the same correct process .",
    "this process is the _",
    "leader_.    an implementation of omega is _ message efficient _ if the origin of all but finitely many messages is a single correct process and all but finitely many messages are constant size .",
    "an implementation of omega is _",
    "packet efficient _ if all but finitely many messages are transmitted using @xmath12 packets .",
    "an omega implementation is _ super packet efficient _ if it is packet efficient and the packets of all but finitely many messages are using the same channels . in other words ,",
    "if a packet of message @xmath13 is forwarded over some channel , then a packet of another message @xmath14 is also forwarded over this channel .",
    "the intent of a super packet efficient algorithm is to only use a limited number of channels infinitely often . since a packet efficient algorithm uses @xmath12 packets infinitely often , a super packet efficient algorithm uses @xmath12 channels infinitely often .",
    "in this section , we contrast a multi - hop implementation of omega and a classic single - hop , also called direct channel , implementation .",
    "we assume each network channel is timely with probability @xmath15 .",
    "the timeliness probability of one channel is independent of this probability of any other channel .",
    "+ * leader existence probability .",
    "* we assume that the leader may exist only if there is a process that has timely paths to all processes in the network . in case of direct channel implementation",
    ", the length of each such path must be exactly one .",
    "as @xmath2 grows , omega implementations behave radically differently .",
    "theorems  [ trmleaderonehop ] and  [ trmleadermultihop ] state the necessary conditions for leader existence and indicate that the probability of leader existence for direct channel implementation approaches zero exponentially quickly , while this probability for multi - hop implementation approaches one exponentially quickly . in practical terms , a multi - hop omega implementation is far more likely to succeed in establishing the leader .",
    "[ trmleaderonehop ] if the probability of each channel to be timely is @xmath16 , then the probability of leader existence in any direct channel omega implementation approaches zero exponentially fast as @xmath2 grows .",
    "let @xmath17 be the probability that some process @xmath7 does not have direct timely channels to all processes in the network .",
    "this probability is @xmath18 .",
    "for two distinct processes @xmath7 and @xmath8 , @xmath17 and @xmath19 are disjoint since channels are oriented .",
    "thus , if @xmath20 , the probability that no leader exists is @xmath21 .",
    "[ trmleadermultihop ] if the probability of each channel to be timely is @xmath16 , then the probability of leader existence in any multi - hop omega implementation approaches @xmath22 exponentially fast as @xmath2 grows .",
    "a channel is _ bitimely _ if it is timely in both directions .",
    "the probability that there exists at least one process such that there exist timely paths from this process to all other processes is greater than the probability to reach them through bitimely paths .",
    "we use the probability of the latter as a lower bound for our result .",
    "if @xmath15 is the probability of a channel to be timely , @xmath23 is the probability that it is bitimely .",
    "consider graph @xmath24 where the edges represent bitimely channels .",
    "it is an erdos - renyi graph where an edge exists with probability @xmath25 .",
    "it was shown ( see  @xcite ) that @xmath26 .",
    "+ * leader stability . * as in previous subsection , we assume the leader has timely paths to all other processes in the network . if channel timeliness changes , this process may not have timely paths to all other processes anymore .",
    "_ leader stability time _ is the expected number of rounds of such channel timeliness change where a particular process remains the leader .    again",
    ", direct channel and multi - hop implementations of omega behave differently .",
    "direct channel leader stability time approaches zero as @xmath2 increases and can not be limited from below by fixing a particular value of channel timeliness probability .",
    "multi - hop leader stability goes to infinity exponentially quickly . in a practical",
    "setting , a leader is significantly more stable in a multi - hop omega implementation than in a direct channel one .",
    "[ trmstabilitydirect ] in any direct channel omega implementation , if the probability of each channel to be timely is @xmath16 , leader stability time goes exponentially fast to @xmath3 as @xmath2 grows .",
    "if leader stability time is to remain above a fixed constant @xmath27 , then the channel timeliness probability @xmath15 must converge to @xmath22 exponentially fast as @xmath2 grows .    at a given time , a given process has timely channels to all other processes with probability @xmath28 . the number of rounds @xmath29 a given process retains timely paths to all other processes follows a geometric distribution @xmath30 , where @xmath31 .",
    "thus , the expected number of rounds a process retains timely channels to all other processes is @xmath32 , which tends exponentially fast toward @xmath3 if @xmath15 is a constant less than @xmath22 .",
    "assume @xmath33 converges towards a given fixed number @xmath34 as @xmath2 tends towards infinity .",
    "that is , we need @xmath35 .",
    "then , @xmath28 tends to @xmath36 , which implies that @xmath15 converges towards @xmath22 exponentially fast .",
    "[ trmstabilitymultihop ] in any multi - hop omega implementation , if the probability of each channel to be timely is @xmath16 , leader stability time goes to infinity exponentially fast as @xmath2 grows .",
    "if leader stability time is to remain above a fixed constant @xmath27 , then channel timeliness probability may converge to @xmath3 exponentially fast as @xmath2 grows .",
    "if we fix @xmath25 , @xmath37 , we have @xmath38 ( see  @xcite ) .",
    "then , the expected number of rounds a given process retains timely paths to all other processes is asymptotically @xmath39 , which increases exponentially fast .",
    "assume @xmath33 converges towards a given fixed number @xmath34 as @xmath2 tends to infinity .",
    "this means that @xmath40 using well - known results of random graph theory  @xcite , we can take @xmath41",
    "we now explore the properties of deterministic omega implementation .     + * model independent properties . * the below omega implementation properties are applicable to both general propagation and dependable channel model .",
    "[ trmtimely ] in an implementation of omega , at least one correct process needs to send infinitely many timely messages .",
    "assume is an implementation of omega where every correct process sends a finite number of timely messages .",
    "start with a network where all but two processes @xmath7 and @xmath8 crash , wait till all timely messages are sent . since is an implementation of omega , eventually @xmath7 and @xmath8 need to agree on the leader .",
    "let it be @xmath7 .",
    "since all timely messages are sent , the remaining messages may be delayed arbitrarily .",
    "if @xmath7 now crashes , process @xmath8 must eventually elect itself the leader .",
    "instead , we delay messages from @xmath7 to @xmath8 .",
    "the crash and the delay are indistinguishable to @xmath8 so it elects itself the leader .",
    "we now deliver messages in an arbitrary manner . again , since implements omega , @xmath7 and @xmath8 should agree on the leader .",
    "let it be @xmath8 .",
    "the argument for @xmath7 is similar .",
    "we then delay messages from @xmath8 to @xmath7 forcing @xmath7 to select itself the leader .",
    "we continue this procedure indefinitely .",
    "the resultant sequence is a computation of .",
    "however at least one process , either @xmath7 or @xmath8 , oscillates in its leader selection infinitely many times . to put another way",
    ", this process never elects the leader .",
    "this means that , contrary to the initial assumption , is not an implementation of omega .",
    "this proves the theorem .",
    "if single process sends an infinite number of messages in a message efficient implementation of omega , this process must be the leader .",
    "otherwise processes are not able to recognize the crash of the leader .",
    "hence , the corollary of theorem  [ trmtimely ] .    [ corleadersends ] in a message efficient implementation of omega , the leader must send infinitely many timely messages .",
    "+ * general propagation model properties .",
    "*    [ lemneedall ] to timely deliver a message in the general propagation model , each recipient process needs to send it across every outgoing channel , except for possibly the channels leading to the origin and the sender .",
    "assume the opposite .",
    "there exists an algorithm that timely delivers message @xmath42 from the origin @xmath7 to all processes in the network such that some process @xmath8 receives it timely yet does not forward it to some process @xmath43 .",
    "consider the propagation graph @xmath10 for @xmath42 to be as follows .",
    "@xmath44 that is , the timely paths to all processes lead from @xmath7 to @xmath8 then to @xmath45 .",
    "if is such that @xmath7 sends @xmath42 to @xmath8 , then , by assumption , @xmath8 does not forward @xmath42 to @xmath45 .",
    "therefore , no process except for @xmath8 gets @xmath42 through timely packets . by definition of the timely message ,",
    "@xmath42 is not timely received by these processes .",
    "if @xmath7 does not send @xmath42 to @xmath8 , then none of the processes receive a timely message . in either case ,",
    "contrary to the initial assumption , does not timely deliver @xmath42 to all processes in the network .",
    "the below corollary follows from lemma  [ lemneedall ] .",
    "[ corn2 ] it requires @xmath46 packets to timely deliver a message in the general propagation model .    combining corollary  [ corn2 ] and theorem  [ trmtimely ] we obtain corollary  [ cornoeff ] .",
    "[ cornoeff ] in the general propagation model , there does not exist a message and packet efficient implementation of omega .",
    "there exists a message efficient implementation of omega in the general propagation model where each correct process can send reliable messages to the leader .",
    "the algorithm that proves the above proposition is a straightforward extension of the second algorithm in aguilera et al .",
    "@xcite where every process re - sends received messages to every outgoing channel .     + * dependable channel model properties . *    [ lemneedfairlossy ] in any message efficient implementation of omega",
    ", each correct process must have a fair - lossy path to the leader .",
    "assume there is a message - efficient implementation of omega where there is a correct process @xmath7 that does not have a fair - lossy path to the leader . according to corollary  [ corleadersends ] , @xmath7 itself may not be elected the leader .",
    "assume there is a computation @xmath47 of where process @xmath48 is elected the leader .",
    "note that fair - lossy channels are not type discriminating .",
    "that is , if @xmath7 does not have a fair - lossy path to @xmath8 , but has a fair lossy path to some other process @xmath45 , then @xmath45 does not have a fair - lossy path to @xmath8 either .",
    "thus , there must be a set of processes @xmath49 such that @xmath50 and @xmath51 that do not have fair - lossy paths to processes outside @xmath52 .",
    "since is message efficient , processes of @xmath52 only send a finite number of messages to @xmath8 .",
    "consider another computation @xmath53 which shares prefix with @xmath53 up to the point were the last message from processes of @xmath52 is received outside of @xmath52 .",
    "after that , all messages from @xmath8 to processes in @xmath52 and all messages from @xmath52 to outside are lost .",
    "that is in @xmath53 , @xmath8 does not have timely , or every fair - lossy , paths to processes of @xmath52 .",
    "it is possible that some other process @xmath54 is capable of timely communication to all processes in the network .",
    "however , since is efficient , no other processes but @xmath8 is supposed to send infinitely many messages .",
    "since all messages from @xmath52 are lost , @xmath47 and @xmath53 are indistinguishable for the correct processes outside @xmath52 .",
    "therefore , they elect @xmath8 as the leader .",
    "however , processes in @xmath52 receive no messages from @xmath8 .",
    "therefore , they have to elect some other process @xmath55 to be the leader .",
    "this means that allows correct processes to output different leaders .",
    "that is , is not an implementation of omega .",
    "we define a _ source _ to be a process that does not have incoming timely channels .",
    "[ lemneedallsources ] to timely deliver a message in the dependable channel model , each recipient needs to send it across every outgoing channel to a source , except for possibly the channels leading to the origin and the sender .",
    "the proof of the above lemma is similar to the proof of lemma  [ lemneedall ] .",
    "observe that lemma  [ lemneedallsources ] states that the timely delivery of a packet requires @xmath2 messages per source . if the number of sources is proportional to the number of processes in the network , we obtain the following corollary .    [ corn2sources ] it requires @xmath46 packets to timely deliver a message in the dependable channel model where the number of sources is proportional to @xmath2 .",
    "[ trmdependablechannel ] in the dependable channel model , the following conditions are necessary and sufficient for the existence of a packet and message efficient implementation of omega : ( i ) there is at least one process @xmath56 that has an eventually timely path to every correct process ( ii ) every correct process has a fair - lossy path to @xmath56 .",
    "we demonstrate sufficiency by presenting , in the next section , an algorithm that implements omega in the dependable channel model with the conditions of the theorem .",
    "we now focus on proving necessity .",
    "let us address the first condition of the theorem .",
    "assume there is a message and packet efficient implementation of omega in the dependable channel model even though no process has eventually timely paths to every correct process .",
    "let there be a computation of where some process @xmath7 is elected the leader even though @xmath7 does not have a timely path to each correct process . according to corollary  [ corleadersends ]",
    ", @xmath7 needs to send infinitely many timely messages . according to corollary  [ corn2sources ] , each such message requires @xmath46 packets .",
    "that is , may not be message and packet efficient .",
    "this proves the first condition of the theorem .",
    "the second condition immediately follows from lemma  [ lemneedfairlossy ] .",
    "the below theorem shows that ( plain ) efficiency is all that can be achieved with the necessary conditions of theorem  [ trmdependablechannel ] .",
    "that is , even if these conditions are satisfied , supper packet efficiency is not possible .",
    "[ trmnoteventually ] there does not exist a message and super packet efficient implementation of omega in the dependable communication model even if there is a process @xmath56 with an eventually timely path to every correct process and every correct process has a fair - lossy path to @xmath56 .",
    "assume the opposite .",
    "suppose there exists a super packet efficient algorithm that implements omega in the network where some process @xmath56 has an eventually timely path to all correct processes and every correct process has fair - lossy paths to @xmath56 .    without loss of generality ,",
    "assume the number of processes in the network is even .",
    "divide the processes into two sets @xmath57 and @xmath58 such that the cardinality of both sets is @xmath59 .",
    "refer to figure  [ fignoeventual ] for illustration .",
    "@xmath57 is completely connected by timely channels .",
    "similarly , @xmath58 is also completely connected by timely channels .",
    "the dependability of channels between @xmath57 and @xmath58 is immaterial at this point .",
    "computation of theorem  [ trmnoteventually].,width=226 ]    consider a computation @xmath47 of on this network where all processes in @xmath57 are correct and all processes in @xmath58 crashed in the beginning of the computation . since is an implementation of omega , one process @xmath60",
    "is elected the leader . since is message efficient",
    ", only @xmath61 sends messages infinitely often .",
    "since is super packet efficient , only @xmath12 channels carry theses messages infinitely often .",
    "since the network is completely connected , there are @xmath62 channels leading from @xmath57 to @xmath58 .",
    "this is in @xmath63 .",
    "thus , there is least one channel @xmath11 such that @xmath64 and @xmath65 that does not carry messages from @xmath61 infinitely often .",
    "let us consider a computation @xmath53 of where all processes @xmath58 are correct and all processes in @xmath57 crash in the beginning of the computation .",
    "similar to @xmath47 , there is a process @xmath66 that is elected the leader in @xmath53 , and there is a channel @xmath67 such that @xmath68 and @xmath69 that carries only finitely many messages of @xmath70 .",
    "we construct a computation @xmath71 of as follows .",
    "all processes are correct .",
    "channel dependability inside @xmath57 and @xmath58 is as described above .",
    "all channels between @xmath57 and @xmath58 are completely lossy , i.e. , they lose every transmitted message .",
    "an exception is channel @xmath11 that becomes timely as soon as it loses the last message it is supposed to transmit .",
    "similarly , channel @xmath72 becomes reliable as soon as it loses the last message .",
    "to construct @xmath71 , we interleave the actions of @xmath47 and @xmath53 in an arbitrary manner . observe that to processes in @xmath57 computations @xmath47 and @xmath71 are indistinguishable .",
    "similarly , to processes in @xmath58 , the computations @xmath53 and @xmath71 are indistinguishable .",
    "let us examine the constructed computation closely .",
    "sets @xmath57 and @xmath58 are completely connected by timely channels , and @xmath11 , connecting @xmath57 and @xmath58 is eventually timely .",
    "this means that @xmath61 has an eventually timely path to every correct process in the network .",
    "moreover , due to channel @xmath72 , every process has a fair - lossy path to @xmath61 .",
    "that is , the conditions of the theorem are satisfied . however , the processes of @xmath57 elect @xmath61 as their leader while the processes of @xmath58 elect @xmath70 .",
    "this means that the processes do not agree on the single leader .",
    "that is , contrary to the initial assumption , is not an implementation of omega .",
    "the theorem follows .",
    "in this section we present an algorithm we call that implements omega in the fair - lossy channel communication model . as per theorem  [ trmdependablechannel ] , we assume that there is at least one process that has an eventually timely path to every correct process in the network and every correct process has a fair - lossy path to this process .",
    "+ * algorithm outline . *",
    "the code of the algorithm is shown in figure  [ figalg ] .",
    "the main idea of is for processes to attempt to claim the leadership of the network while discovering the reliability of its channels .",
    "each process weighs each channel by the number of messages that fail to come across it .",
    "the lighter channel is considered more reliable .",
    "if a process determines that it has the lightest paths to all processes in the network , the process tries to claim leadership of the network .",
    "the leadership is obtained in phases .",
    "first , the leader candidate sends _ startphase _ message .",
    "then , the candidate periodically sends _ alive _ message . in case",
    "an _ alive _ fails to reach one of the processes on time , the recipient replies with _",
    "the size of _ startphase _ depends on the network size .",
    "the size of the other message types is constant .",
    "the routes of the messages vary .",
    "messages that are only sent finitely many times are _ broadcast _ : sent across every channel in the network .",
    "once one process receives such a message for the first time , the process re - sends it along all of its outgoing channels .",
    "specifically , _ startphase _ , _ stopphase _ and _ failed _ are broadcast .",
    "the leader sends _ alive _ infinitely often . hence , for the algorithm to be packet efficient , _ alive _ has to be sent only along selected channels . message _",
    "alive _ is routed through the channels that the origin believes to be the most reliable .",
    "specifically , _ alive _ is routed along the channels of a minimum weight _ arborescence _ : a directed tree rooted in the origin reaching all other processes .",
    "the arborescence is computed by the origin once it claims leadership .",
    "it is sent in the _ startphase _ that starts a phase . once each process receives the arborescence , the process stores it in the @xmath73 array element for the corresponding origin . after receiving _ alive _ from a particular origin",
    ", the recipient consults the respective arborescence and forwards the message to the channels stated there .",
    "in addition to routing _ alive _ along the arborescence , each process takes turns sending the leader s _ alive _ to all its neighbors .",
    "the reason for this is rather subtle : see theorem  [ trmnoteventually ] for details .",
    "due to crashes and message losses , @xmath73 for the leader at various processes may not reach every correct process .",
    "for example , it may lead to a crashed process .",
    "thus , some processes may potentially not receive _ alive _ and , therefore , not send _",
    "failed_. since _ failed _ are not sent , the leader may not be able to distinguish such a state from a state with correct @xmath73 .    to ensure that every process receives _ alive",
    "_ , each process , in turn , sends _ alive _ to its every neighbor rather than along most reliable channels .",
    "since only a single process sends to all neighbors a particular _ alive _ message , the packet complexity remains @xmath12 .",
    "message _ failed _ is sent if a process does not receive a timely _ alive_. this message carries the parent of the process which was supposed to send the _",
    "alive_. that is , the sender of _ failed _ blames the immediate ancestor in the arborescence .",
    "once the origin of the missing _ alive _ , receives _ failed _ , it increments the weight of the appropriate edge in @xmath74 that stores the weights of all channels . if a process has timely outgoing paths to all processes in the network , its arborescence in @xmath74 convergences to these paths .",
    "+ * action specifics . *",
    "the algorithm is organized in five actions .",
    "the first is a timeout action , the other four are message - receipt actions .",
    "the timeout action handles two types of timers : sender and receiver .",
    "@xmath15 s own timer ( @xmath75 ) is a sender timer .",
    "it is rather involved .",
    "this timer is always on since the process resets it after processing .",
    "first , the process computes the minimum weight of the arborescence for each leader candidate .",
    "a process is considered a leader candidate if its timer is on .",
    "note that since @xmath15 s own timer is always on , it is always considered .",
    "the process with the minimum weight arborescence is the new leader . if the leadership changes ( @xmath76 ) , further selection is made .",
    "if @xmath15 gains leadership ( @xmath77 ) , then @xmath15 starts a new phase by updating its own minimum - weight arborescence and broadcasting _",
    "startphase_. if @xmath15 loses leadership , it increments its phase and broadcasts _ stopphase _ bearing the new phase number .",
    "if the leadership persists ( @xmath78 ) and @xmath15 is the leader , it sends _",
    "alive_. process @xmath15 keeps track of whose turn it is to send _ alive _ to all its neighbors in the _ shout _ variable .",
    "the variable s value rotates among the ids of all processes in the network .",
    "the neighbor timer ( @xmath79 ) is a receiver timer .",
    "if the process does not get _ alive _ on time from @xmath80 , then @xmath15 sends _ failed_. in case the process sends _ failed _ , it also increases the timeout value for the timer of @xmath80 thus attempting to estimate the channel delay .    for our algorithm ,",
    "the timer integers are as follows .",
    "the sender timer is an arbitrary constant integer value @xmath81 .",
    "this value controls how often _ alive _ is sent",
    ". it does not affect the correctness of the algorithm .",
    "receiver timers initially hold an arbitrary value .",
    "the timer integer is increased every time there is a timeout .",
    "thus , for an eventually timely channel , the process is able to estimate the propagation delay and set the timer integer large enough that the timeout does not occur . for untimely channels , the timeout value may increase without bound .",
    "the next four actions are message receipt handling .",
    "note that a single process may receive packets carrying the same message multiple times across different paths .",
    "however , every process handles the message at most once : when it encounters it for the first time .",
    "later duplicate packets are discarded .",
    "the second action is _ startphase _ handling .",
    "the process copies the arborescence and phase carried by the message , rebroadcasts it and then resets the _ alive _ receiver timer associated with the origin process .",
    "the third action is the receipt of _ stopphase _ which causes the recipient to stop the appropriate timer .",
    "the forth action is _ alive _ handling . if _ alive _ is the matching phase , it is further considered .",
    "if _ alive _ comes through the origin s arborescence , the receiver sends _ alive _ to its children in the origin s arborescence or broadcasts it .",
    "the process then resets the timer to wait for the next _",
    "alive_. if _ alive _ comes from elsewhere , that is , it was the sender s turn to send _ alive _ to all its neighbors , then @xmath15 just resets the timeout and waits for an _ alive _ to arrive from the proper channel .",
    "this forces the process to send _ failed _ if _ alive _ does not arrive from the channel of the arborescence .",
    "the last action is _ failed _ handling .",
    "if _ failed _ is in response to an _ alive _ originated by this process ( @xmath82 ) then the origin process increments the weight of the edge from the parent of the reporting process to the process itself according to the message arborescence . if _",
    "failed _ is not destined to this process , @xmath15 rebroadcasts it .",
    "* correctness proof definitions .",
    "* throughout this section , @xmath56 is the identifier of the process that has eventually timely paths to all other processes . for simplicity , we assume that @xmath56 is the single such process .",
    "denote @xmath6 as the maximum number of steps in any timely channel propagation delay .",
    "process @xmath15 is a _",
    "local leader _ if @xmath83 , i.e. , the process elected itself the leader .",
    "a process may be a local leader but not the global leader .",
    "that is , several processes may be local leaders in the same state .",
    "let @xmath84 for the origin process @xmath7 be the relation defined by @xmath85(y.children)$ ] at every process @xmath8 .",
    "that is , @xmath84 is the distributed relation that determines how @xmath86 messages are routed if they are originated by @xmath7 .",
    "[ manyfailed ] for any local leader process @xmath7 and another correct process @xmath8 such that @xmath8 is not reachable from @xmath7 through timely channels over correct processes in @xmath84 , either ( i ) @xmath84 changes or ( ii ) @xmath7 loses leadership , changes phase or receives infinitely many _ failed _ messages .    to prove the lemma ,",
    "it is sufficient to show that if @xmath84 does not change and @xmath7 does not lose the leadership or change phase , then @xmath7 receives infinitely many _",
    "failed_.    let @xmath52 be a set of correct processes that are reachable from @xmath7 through timely channels and through correct processes in @xmath84 . since @xmath8 is not reachable from @xmath7 , @xmath87 . recall that every process has fair - lossy paths to all processes in the network . therefore",
    ", there is such a path from @xmath7 to @xmath8 .",
    "this means that there is a process @xmath88 such that it has a fair - lossy channel to @xmath89 .",
    "let us examine process @xmath54 closer .",
    "the network is completely connected .",
    "therefore , all other processes from @xmath52 have channels to @xmath54 .",
    "note that at least one channel , from @xmath45 is fair - lossy .",
    "moreover , since @xmath54 does not belong to @xmath52 , if @xmath84 reaches @xmath54 , the path to @xmath54 is not timely .",
    "since @xmath7 is a local leader and does not lose its leadership , it sends infinitely many _ alive _ messages .",
    "other processes forward these _ alive _ along @xmath84 .",
    "also , by the design of the algorithm , every process takes turn sending _ alive _ to all of its neighbors rather than forwarding it along @xmath84 .",
    "let us examine the receipt of these messages by @xmath54 .",
    "process @xmath45 belongs to @xmath52 .",
    "that is , the path from @xmath7 to @xmath45 in @xmath84 is timely .",
    "this means that it receives and sends infinitely many _ alive _ originated by @xmath7 .",
    "since the channel from @xmath45 to @xmath54 is fair - lossy , infinitely many of these _ alive _ are delivered to @xmath54 .",
    "in addition , @xmath54 possibly receives _ alive _ from other processes of @xmath52 . since , none of these channels are part of @xmath84 , when @xmath54 receives _ alive _ from processes in @xmath52 , it resets the corresponding receive timer only when the timer is off .",
    "the timer is turned off only when the timeout is executed and _ failed _ is broadcast .    the only possible way this receive timer is reset without the timeout action execution is when @xmath54 receives _ alive _ through @xmath84 .",
    "however , the path from @xmath7 to @xmath54 in @xmath84 is not timely . by the definition of non - timely paths",
    ", there are infinitely many computation segments of arbitrary fixed length where no _ alive _ from @xmath7 is delivered to @xmath54 .",
    "this means that , regardless of the timeout variable value at @xmath54 , the _ alive _ messages generate receiver timeouts .",
    "that is , infinitely many timeouts are executed at @xmath54 .",
    "each timeout generates a _ failed _ message broadcast by @xmath54 . since there are infinitely many broadcasts , infinitely many succeed in reaching @xmath7 .",
    "hence , the lemma .",
    "[ xgetsfailed ] if each process @xmath90 is a local leader in infinitely many states then it receives infinitely many _ failed _ messages .",
    "let @xmath90 be a local leader in infinitely many states of a particular computation of the algorithm .",
    "once a process assumes local leadership , it may lose it either by ( i ) increasing the weight of its minimum weight arborescence ( ii ) by recording an arborescence @xmath91 $ ] for a process @xmath8 with lower weight than @xmath85 $ ] .",
    "a process increases the weight of its arborescence only when it gets a _ failed _ message .",
    "thus , to prove the lemma we need to consider the second case only .    since @xmath7 is a local leader in infinitely many states , it must gain local leadership back after losing it to another process @xmath8 . by the design of the algorithm , the weight of the arborescence of any process in @xmath73 may only increase .",
    "this means that once @xmath7 gains the leadership back from @xmath8 , @xmath7 may not lose it to @xmath8 again without increasing the weight of its own minimum weight arborescence .",
    "thus , either @xmath7 increases the weight of its arborescence or , eventually , it has the lightest arborescence among the leader candidates .    in case @xmath7 has the lightest arborescence , it either becomes heavier than some other leader candidate s or @xmath7 gets infinitely many _",
    "failed_. however , only the latter part of the statement needs to be proven since @xmath7 gains leadership infinitely often .",
    "if @xmath7 is a local leader , it does not send _ startphase _ or _",
    "stopphase_. let us consider the state where all _ startphase _ packets are delivered .",
    "in this case @xmath84 does not change . since @xmath90 ,",
    "even if all correct processes are reachable from @xmath7 in @xmath84 , some links in @xmath84 are not timely .",
    "then , according to lemma  [ manyfailed ] , @xmath7 gets infinitely many _",
    "failed_.    to summarize , if @xmath90 is a local leader in infinitely many states , it receives infinitely many _ failed_.    [ lleaderoften ] process @xmath56 is a local leader in infinitely many states .    according to lemma  [ xgetsfailed ] either each process @xmath92 stops gaining local leadership or the weight of its minimum arborescence grows infinitely high .",
    "if the latter is the case , @xmath7 has to gain and lose local leadership infinitely often . in this case",
    ", it sends _ startphase _ infinitely may times . message _",
    "startphase _ is broadcast . since every process @xmath7 has fair - lossy paths to @xmath56 , by the definition of fair - lossy paths , infinitely many broadcasts succeed .",
    "this means that the weight of @xmath85 $ ] at @xmath56 grows without bound .",
    "therefore , if @xmath56 loses local leadership , it gains it back infinitely often .",
    "the below lemma follows immediately from the operation of the algorithm .",
    "[ timersfixed ] the timer length of @xmath93 $ ] at every process either stops increasing or it reaches @xmath94    and the below lemma follows from the assumption that the leader has an eventually timely path to every correct process .",
    "[ broadcastsok ] in every computation , there is a suffix where each broadcast message sent by @xmath56 is timely delivered to every correct process .",
    "[ timelyok ] an edge leading to process @xmath7 in a timely path in @xmath95 at @xmath56 generates only finitely many _",
    "failed_.    the origin starts every phase with _",
    "startphase _ , then periodically sends zero or more _ alive _ and then possibly ends the phase with a _ stopphase _ that carries the phase number greater than _ alive _ and _",
    "startphase_.    message _ failed _ is generated only when the timer expires at the receiving process .",
    "the timer is reset by _",
    "startphase _ and _ alive_. the timer is stopped by _",
    "we prove the lemma by showing that the timer reset by messages of a particular phase expires only finitely many times .",
    "we start our consideration from the point of the computation where the conditions of lemmas  [ timersfixed ] and  [ broadcastsok ] hold .    only _ alive _ and _ startphase _ may reset the timeout .",
    "since the conditions of lemma  [ broadcastsok ] hold , _ startphase _ is delivered within @xmath96 computation steps to all processes .",
    "alive _ may be received earlier than _",
    "startphase_. however , since such _ alive _ carries a phase number that differs from the number stored at the recipient process , the message is ignored .",
    "if _ alive _ arrives after _ startphase _ , the reasoning is similar to the case where _ alive _ is sent after",
    "_ startphase _ which is to be considered next .",
    "every _ alive _ sent after _",
    "startphase _ delivery , travels over the timely path in @xmath95 . at",
    "most every @xmath81 number of steps , either another _ alive _ or _",
    "stopphase _ is sent .",
    "since the path in @xmath95 is timely , _ alive _ arrives at most after @xmath97 steps . due to lemma  [ broadcastsok ] ,",
    "the same is true of _ stopphase_. that is , after _ alive _ is received , either another _ alive _ or _ stopphase _",
    "is received within @xmath98 steps .",
    "the receipt of _ alive _ resets the timeout .",
    "the receipt of _ stopphase _ stops it .",
    "due to lemma  [ timersfixed ] , the timer does not expire .",
    "moreover , after the receipt of _ stopphase _ , the subsequent _ alive _ messages are ignored since _ stopphase _ carries a greater phase number .",
    "that is , after _ stopphase _ is received , the timer is never reset or expires due to the messages of this phase .",
    "[ untimelygone ] every untimely edge in @xmath95 leading to a correct process either gets removed or @xmath56 gets infinitely many _ failed _ messages .    due to lemma  [ lleaderoften ] , process @xmath56 is a local leader in infinitely many states . through the argument similar to that of lemma  [ xgetsfailed ] , we can show that eventually either @xmath56 gets _ failed _ and increases the weight of its minimum arborescence or its minimum arborescence becomes the lightest among the leader candidates .",
    "then , @xmath56 can lose leadership only if it gets _",
    "failed_.    in this case , according to lemma  [ manyfailed ] , @xmath56 receives infinitely many failed messages or either loses leadership , changes phase or changes @xmath95 .",
    "observe that @xmath56 may change phase only when it receives _",
    "failed_. it loses leadership only if it gets _ failed_. the change of @xmath95 happens only when @xmath56 broadcasts _ startphase _ after changing phase and , therefore , getting _",
    "failed_. due to lemma  [ lleaderoften ] , it gains the leadership back infinitely often .    that is , in any case , as long as @xmath95 contains an untimely edge leading to a correct process , @xmath56 gets infinitely many",
    "_ failed_.    the below lemma follows from lemmas  [ timelyok ] and  [ untimelygone ] .    [ arbstimely ]",
    "every computation of contains a suffix where each channel of @xmath95 is timely .",
    "[ arbssame ] every computation of contains a suffix where @xmath95 is the same as @xmath99 $ ] in process @xmath56 .",
    "we start our consideration from the point where the conditions of lemma  [ arbstimely ] hold .",
    "suppose @xmath95 and @xmath99 $ ] differ for some process @xmath7 . by the design of the algorithm , this may happen only if @xmath99 $ ] in process @xmath7 has an earlier phase than in @xmath56 .",
    "however , since phases differ , _ alive _ sent by @xmath56 are ignored by @xmath7 .",
    "this leads to either @xmath7 sending _ fail _ to @xmath56 or claiming leadership . in either case",
    ", @xmath56 sends _",
    "startphase_. according to lemma  [ broadcastsok ] , this broadcasts succeeds which synchronizes @xmath99 $ ] and @xmath95 .",
    "[ trmmpo ] algorithm is a message and packet efficient implementation of omega in the fair - lossy channel model .",
    "first , we prove that implements omega .",
    "indeed , lemma  [ lleaderoften ] shows that @xmath56 is a local leader in infinitely many states .",
    "lemmas  [ timelyok ] and  [ untimelygone ] show that @xmath56 gets finitely many _",
    "failed_. according to lemma  [ xgetsfailed ] , every process @xmath90 either stops being a local leader or gets infinitely many _ failed_.",
    "this means that at any process the arborescence of @xmath56 will eventually be lighter than any other leader contender .",
    "according to lemma  [ lleaderoften ] , @xmath56 sends infinitely many _ alive _ messages along @xmath95 . due to lemma  [ untimelygone ]",
    ", @xmath95 eventually has no untimely channels .",
    "since @xmath56 , according to lemma  [ untimelygone ] , receives only finitely many _ failed _ , due to lemma  [ manyfailed ] , @xmath95 eventually has timely paths from @xmath56 to every correct process . according to lemma",
    "[ arbssame ] , @xmath95 and @xmath99 $ ] are eventually the same .",
    "this means that @xmath56 will be a leader contender in every correct process .",
    "since it has the lightest arborescence , it becomes the leader at every correct process .",
    "in other words , is a correct implementation of omega .    by the design of the algorithm ,",
    "once @xmath56 has the lightest arborescence and all correct processes drop out of leadership contention , @xmath56 is the only process that sends _ alive _ messages . by definition , is message efficient .",
    "the messages are routed along @xmath99 $ ] .",
    "it is an arborescence .",
    "hence , the number of such messages is in @xmath12 .",
    "in addition , each process takes a turn sending _ alive _ to its neighbors .",
    "this is another @xmath12 packets .",
    "therefore , the packet complexity of is in @xmath12 .",
    "we conclude the paper with several observations about .",
    "the algorithm trivially works in a non - completely connected network provided that the rest of the assumptions used in the algorithm design , such as eventually timely paths from the leader to all correct processes , are satisfied .",
    "similarly , the algorithm works correctly if the channel reliability and timeliness is origin - related .",
    "that is , a channel may be timely for some , not necessarily incident , process @xmath7 , but not for another process @xmath8 .",
    "algorithm may be modified to use only constant - size messages .",
    "the only non - constant size message is _",
    "startphase_. however , the message type is supposed to be timely .",
    "so , instead of sending a single large message , the modified may instead send a sequence of fixed - size messages with the content to be re - assembled by the receivers .",
    "if one of the constituent messages does not arrive on time , the whole large message is considered lost .",
    "carole delporte - gallet , stphane devismes , hugues fauconnier , and mikel larrea .",
    "algorithms for extracting timeliness graphs . in _ structural information and communication complexity , 17th international colloquium , sirocco 2010 , sirince , turkey , june 7 - 11 , 2010 . proceedings _ , pages 127141 , 2010 .",
    "achour mostefaoui , eric mourgaya , and michel raynal .",
    "asynchronous implementation of failure detectors . in _",
    "2013 43rd annual ieee / ifip international conference on dependable systems and networks ( dsn ) _ , pages 351351 .",
    "ieee computer society , 2003 ."
  ],
  "abstract_text": [
    "<S> we assume that a message may be delivered by packets through multiple hops and investigate the feasibility and efficiency of an implementation of the omega failure detector under such an assumption . to motivate the study </S>",
    "<S> , we prove that the existence and sustainability of a leader is exponentially more probable in a multi - hop omega implementation than in a single - hop one .    </S>",
    "<S> an implementation is : _ message efficient _ if all but finitely many messages are sent by a single process ; _ packet efficient _ if the number of packets used to transmit a message in all but finitely many messages is linear w.r.t the number of processes , packets of different messages may potentially use different channels , thus the number of used channels is not limited ; _ super packet efficient _ if the number of channels used by packets to transmit all but finitely many messages is linear .    </S>",
    "<S> we present the following results for deterministic algorithms . if reliability and timeliness of one message does not correlate with another , i.e. , there are no channel reliability properties , then a packet efficient implementation of omega is impossible . </S>",
    "<S> if eventually timely and fair - lossy channels are considered , we establish necessary and sufficient conditions for the existence of a message and packet efficient implementation of omega . </S>",
    "<S> we also prove that the eventuality of timeliness of channels makes a super packet efficient implementation of omega impossible . on the constructive side , </S>",
    "<S> we present and prove correct a deterministic packet efficient implementation of omega that matches the necessary conditions we established . </S>"
  ]
}