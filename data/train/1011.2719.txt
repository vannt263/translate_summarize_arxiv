{
  "article_text": [
    "algorithmic aspects of mobile agents computing have received growing attention in the recent years .",
    "two scenarios are usually studied in this context : mobile entities operate either in the plane , in which case they model , e.g. , physical robots executing such tasks as gathering ( rendezvous ) @xcite or pattern formation @xcite , or they move in a connected graph that models a communication network . in the latter case the mobile entities represent , e.g. , software agents .",
    "computation tasks assigned to mobile agents operating in graphs range from graph exploration @xcite , used , e.g. , in network maintenance , detecting faults , or searching for information in distributed databases , to gathering in one node @xcite , in order to exchange data acquired by agents or to coordinate further actions .",
    "algorithmic problems in mobile agents computing concern both the feasibility of a given task and its efficiency in terms of the time of accomplishing the task or the memory needed by agents to complete it .",
    "feasibility of gathering in the plane was studied , e.g , in @xcite and in graphs in @xcite .",
    "exploration time for mobile agents in graphs was studied , e.g. , in @xcite in the case of one agent and in @xcite for several agents .",
    "the time of deterministic rendezvous was the subject , e.g. , of @xcite , while that of randomized rendezvous was investigated , e.g , in @xcite .",
    "see also the book @xcite partly devoted to the efficiency of randomized rendezvous .",
    "memory needed for graph exploration by a single agent was investigated , e.g. , in @xcite and memory needed for rendezvous was the object of study in @xcite for the deterministic scenario and in @xcite for the randomized scenario .",
    "in this paper we present a different perspective on deterministic mobile agents computing in graphs .",
    "we are interested in decision problems that may be stated in this computing environment .",
    "these problems may concern various properties of the initial configuration of agents in the graph , e.g. , `` is the graph a tree ? '' , `` are there more than three agents in the graph ? '' , `` are the agents located at distance at least @xmath3 ? ''",
    "the decision has to be made collectively by the agents and satisfy the following condition : if the answer is `` yes '' , then all agents must answer `` yes '' , and if the answer is `` no '' , then at least one agent must answer `` no '' .",
    "we require that all agents eventually decide .",
    "( in fact , all our deciding algorithms satisfy a stronger condition : all agents are unanimous also in the negative case . )",
    "note that a major difficulty in making a decision by a team of mobile agents is that none of the agents is _ a priori _ provided with the initial configuration on whose properties they have to decide .",
    "our aim is to classify decision problems with respect to the ability of a team of agents to solve the problem , possibly with the aid of additional information .",
    "we focus on studying differences between the _ decidability _ of a decision problem by agents and its _ verifiability _ when a _ certificate _ for a positive answer is provided to the agents .",
    "we show that the class @xmath0 of _ mobile agents verifiable _ problems is much wider than the class @xmath1 of _ mobile agents decidable _ problems .",
    "in particular , we show that it contains an infinite antichain with respect to the reducibility relation .",
    "our main result shows that @xmath2 contains a natural complete problem : a problem to which all problems in @xmath2 are reducible .",
    "the problem is composed of two `` orthogonal '' parts that are in the core of mobile agents computing : one concerns the number of operating agents and the other concerns the quotient graph for a precise definition of the quotient graph .",
    "] of the initial configuration .",
    "more precisely , our @xmath2-complete problem involves the problems @xmath4 and @xmath5 , where @xmath4 is the problem to decide whether the number of agents is larger than a given positive integer @xmath3 , and @xmath5 is the problem to decide whether the quotient of the graph where the agents operate is different from a given graph @xmath6 .",
    "we also look beyond the class of mobile agents verifiable problems , showing that , for a single agent , three natural oracles ( decision problems whose solution is given as a black box ) yield a strictly increasing chain of relative decidability classes .",
    "agents operate in simple undirected connected graphs without node labels .",
    "agents can not leave any marks at visited nodes .",
    "the first assumption is motivated by the fact that nodes may refuse to reveal their identities , e.g. , for security reasons , or limited sensory capabilities of the agents may prevent them from perceiving these identities .",
    "the reason for the second assumption is that nodes may have no facilities ( whiteboards ) allowing to leave marks , or such marks may be destroyed between visits of the agents and thus are unreliable . by contrast , in order to allow the agents to move in the network , we have to assume that ports at every node are distinguishable for the agents .",
    "if an agent were unable to locally distinguish ports at a node , it may have even been unable to visit all neighbors of a node of degree at least 3 .",
    "indeed , after visiting the second neighbor , the agent can not distinguish the port leading to the first visited neighbor from the port leading to the unvisited one .",
    "thus an adversary may always force an agent to avoid all but two edges incident to such a node , thus effectively precluding exploration .",
    "hence we assume that a node of degree @xmath7 has ports @xmath8 corresponding to the incident edges .",
    "ports at each node can be perceived by an agent visiting this node , but there is no coherence assumed between port labelings at different nodes .",
    "from now on , a graph will always mean a connected graph without node labels but with port labels .",
    "for a graph @xmath9 , we denote by @xmath10 the set of nodes of @xmath9 , and call @xmath11 the _ size _ of @xmath9 .",
    "feasibility of various computing tasks in unlabeled graphs is a classic object of study : see , e.g. , @xcite .",
    "we define below the inputs of the computing tasks that are considered in this paper .",
    "an _ initial configuration _ is a quadruple @xmath12 , where @xmath9 is a graph , @xmath13 is a non - empty multiset , @xmath14 is a one - to - one function from @xmath15 to the set of positive integers , and @xmath16 is a function from @xmath15 to the set @xmath17 of binary strings .",
    "the set @xmath15 is interpreted as the set of nodes hosting agents at the start .",
    "it is actually a multiset since there might be initially more than one agent at a node of @xmath15 , and thus there can be more than one occurrence of a same node in @xmath15 . for @xmath18 ,",
    "the value @xmath19 is the identity of the agent hosted by node @xmath20 , and the value @xmath21 is the input of this agent .",
    "( if there is more than one occurrence of @xmath20 , each of them receives a different identity , and a non - necessarilly different input ) .",
    "initially , an agent does not have any a priori knowledge of the initial configuration apart from its own identity and its own input .",
    "for many problems , the inputs of the agents are all identical , in which case the input @xmath16 is simply denoted by a binary string @xmath22 .",
    "( we denote by @xmath23 the empty binary string ) .",
    "note that although @xmath14 and @xmath16 are defined as `` functions '' , there is no computability issue involved in the definition because one does not ask agents to compute their identities and inputs .",
    "in fact , @xmath14 and @xmath16 can also be viewed as vectors of @xmath24 coordinates .",
    "agents are abstract state machines with distinct identities and unlimited memory .",
    "agents start simultaneously and move in synchronous rounds : in each round an agent can stay in the current node or move to an adjacent node . when coming to a node , an agent recognizes the entry port number , the degree of the node and the identities of all agents currently located at this node ( if any ) .",
    "when two agents meet at the same node in the same round , they can exchange all information they currently have . on this basis , together with the content of its memory , the agent computes the port number by which it leaves the node in the next round , or decides to stay in the current node .",
    "note that the assumption about synchrony is made only to simplify presentation : all our study can be carried out for asynchronous agents that are allowed to meet not only at a node but also inside an edge . in this case , however , there are additional technicalities needed to model an adversary representing asynchrony ( cf .",
    "@xcite ) . also meeting inside an edge is not a natural assumption from the point of view of applications for software agents , hence we restrict attention to the synchronous scenario .",
    "we define decision and verification problems , as well as their relative corresponding classes , in the context of computing with mobile agents .",
    "[ def : decisinpb ] a _ decision problem _ is a set @xmath25 of initial configurations such that    1 .",
    "there exists an algorithm which , given any initial configuration @xmath12 , decides whether + @xmath26 ; 2 .",
    "@xmath25 is closed under automorphisms in the following sense : if @xmath27 is an automorphism of a graph @xmath9 preserving port numbers , then : @xmath28    we denote by @xmath29 the class of all decision problems for mobile agents .",
    "condition  1 expresses the fact that we are interested in decidable problems only , so as to identify decidable problems that can not be decided in the framework of mobile agents computing .",
    "( undecidable problems obviously remain undecidable in this framework ) . condition  2 expresses the fact that , since nodes of the graph are not labeled , no distinction can be made between two configurations that can be carried on each other by a graph automorphism preserving port numbers and agents identities and inputs .",
    "a typical example of decision problems is @xmath30 , where agents are provided with the integer @xmath3 , and must decide whether there are more than @xmath3 agents in the graph .",
    "another example is @xmath31 , where agents are provided with the integer @xmath32 , and must decide whether the size of the graph is @xmath32 .",
    "a third example is the ( input - free ) decision problem @xmath33 .",
    "this latter problem has a natural variant @xmath34 .",
    "finally , the problem @xmath35 , for the agents , each receiving a single bit as input , consists in deciding whether there is a unique agent with input  1 , with all the others having input  0 .",
    "a decision problem @xmath25 is _ mobile agents decidable _ , if there exists a protocol for agents such that any team of agents provided with arbitrary distinct identities @xmath14 , arbitrary input @xmath16 , and executing this protocol in any graph @xmath9 starting from positions @xmath15 satisfies that all agents eventually make a decision `` yes '' or `` no '' according to the following _ decision _ property :    * if @xmath36 , then all agents decide `` yes '' ; * if @xmath37 , then at least one agent decides `` no '' .    note that there is a significant difference between usual decidability of a decision problem ( expressed by condition  1 of definition  [ def : decisinpb ] ) and mobile agents decidability : no agent knows _ a priori _ the initial configuration ( but only its own identity and its input ) , hence it has either to learn it during the execution of the protocol or make its decision without full knowledge of the initial configuration . the class of all mobile agents decidable problems is denoted by @xmath1 .",
    "it may appear at a first glance that @xmath1 is the class of problems that involve some form of `` locality '' , since problems like deciding whether there exists a node @xmath38 satisfying some property @xmath39 , or deciding whether all nodes satisfy some property @xmath40 are usually not in @xmath1 because it is hard for an agent to visit all nodes of an arbitrary graph . nevertheless , the `` global '' problem @xmath41 is obviously in @xmath1 .",
    "a non trivial problem in @xmath1 is @xmath42 with a protocol for each agent that consists in performing a dfs for @xmath43 steps , and to draw a map of the visited graph : if the agent is back at its original position on the map with no edge unvisited on the map , then it decides `` yes '' , otherwise it decides `` no '' . on the other hand",
    ", neither @xmath44 nor @xmath45 belongs to @xmath1 ( even @xmath46 is not in @xmath1 because , informally , a single agent can not distinguish a long path from a cycle be the number of rounds performed by the agent before it decides .",
    "the agent can not distinguish the case in which it is placed at the central node of a ( consistently labeled ) path with @xmath47 nodes from the case in which it is placed in a ( consistently labeled ) cycle . ] ) .",
    "for a decision problem , deciding it is different from _ verifying _ it . in the latter case",
    "agents are presented with a _ certificate _ , if the answer to the problem is `` yes '' , and using a verifying protocol have to decide `` yes '' .",
    "moreover , they have to be immune to `` cheating '' them : no certificate can induce them to decide `` yes '' , if the real answer is `` no '' .",
    "this framework is reminiscent of the distinction between classes @xmath48 and @xmath49 in the theory of complexity @xcite .",
    "the notion of verification is formally defined as follows .",
    "a _ certificate _",
    "@xmath50 is a function from the multiset @xmath15 of initial positions to @xmath17 .",
    "that is , agent @xmath20 receives the `` partial '' certificate @xmath51 .",
    "a _ verification protocol _ is executed by agents provided with certificate @xmath50 .",
    "( in the sequel , most of our protocols will use the same certificate @xmath52 for all agents ) .",
    "a decision problem @xmath25 is _ mobile agents verifiable _",
    ", if there exists a verification protocol for agents such that any team of agents provided with arbitrary distinct identities @xmath14 , arbitrary inputs @xmath16 , and executing this protocol in any graph @xmath9 starting from positions @xmath15 satisfies that all agents eventually make a decision `` yes '' or `` no '' according to the following _ verification _ property :    * if @xmath36 , then there exists a certificate @xmath50 such that all agents decide `` yes '' ; *",
    "if @xmath37 , then , for every certificate @xmath50 , at least one agent decides `` no '' .",
    "the class of all mobile agents verifiable problems is denoted by @xmath2 .    by definition , @xmath53 .",
    "an example of a problem that is not mobile agents decidable but is mobile agents verifiable is @xmath54 .",
    "we have seen that @xmath55 .",
    "however , @xmath56 by using a certificate interpreted as the number of nodes in the path .",
    "similarly , @xmath57 by using the same certificate , and performing a verifying protocol similar to the one used for proving @xmath58 .",
    "the problem @xmath59 is in @xmath2 : for each @xmath60 , provide agent @xmath20 with certificate @xmath51 describing a path from @xmath20 to a leaf ( i.e. , the list of port numbers along a path from @xmath20 to a leaf ) .",
    "we define the relation of reducibility between decision problems in the usual way . for the sake of simplicity ,",
    "we restrict our attention to reductions to a subclass of decision problems .",
    "this will be proved to be sufficient for the purpose of this paper .",
    "we say that a decision problem is _ uniform _ if and only if all its instances are initial configurations @xmath12 such that @xmath61 for every two nodes @xmath62 .",
    "for instance , @xmath44 is uniform .",
    "a problem @xmath25 is _ reducible _ to a uniform problem @xmath63 , denoted @xmath64 , if there exists a protocol for mobile agents to decide @xmath25 , using a black box procedure deciding @xmath63 that can be used an arbitrary finite number of times .    in the above definition ,",
    "using the black box deciding @xmath63 means feeding the black box with arbitrary input binary strings .",
    "in other words , assuming that @xmath12 is the initial configuration , an agent uses the black box deciding @xmath63 by calling the black box with its input @xmath22 , and the black box decides whether @xmath65 . for instance , @xmath66 . to see why ,",
    "consider the protocol consisting in successively calling a black box deciding @xmath44 with input integers @xmath67 .",
    "the black box eventually answers  yes \" when the tested integer @xmath32 is the size of the graph @xmath9 in which the agents are operating .",
    "once the size of the graph @xmath9 is known , deciding whether @xmath9 is a tree is achieved using the aforementioned protocol deciding @xmath42 .",
    "observe that not only do there exist decision problems that are mobile agents verifiable and not mobile agents decidable , but in fact the class @xmath68 is quite large .",
    "this is shown in the following example .",
    "let us consider the following family of ( input - free ) decision problems .",
    "for every @xmath69 , let @xmath70 thus , @xmath71 is the problem of whether the underlying graph contains a node of degree @xmath3 .",
    "all problems @xmath71 are in @xmath2 , using a certificate which is , for each agent , a path leading the agent from its original position to a node of degree @xmath3 .",
    "the problems @xmath71 form an infinite antichain with respect to the reducibility relation . indeed , @xmath72 for all @xmath73 . to see why , consider the graphs of figures  [ fig : proof ]  ( a ) and  ( b ) where the grey node is the starting position of the unique agent .",
    "this agent can not distinguish these two graphs if their diameters are large enough because the two graphs are identical at bounded distance from the starting position : the agent will not visit the nodes whose degrees differ in the two graphs , prior to making its decision , if these nodes are far enough from the starting positions .",
    "our main result is related to the following standard concept : for a class @xmath74 of decision problems , the problem @xmath25 is @xmath74-_complete _ , if it belongs to @xmath74 and if any problem in the class @xmath74 is reducible to @xmath25 .",
    "the main contribution of the paper is to show that there is a natural @xmath2-complete problem , and this is the purpose of the next section .",
    "in this section , we establish our main result , stating that there is a natural @xmath2-complete problem .",
    "this problem , denoted by @xmath75 , involves two main components .",
    "one is @xmath4 , the problem consisting in deciding whether the size of the agents team is larger than a given value , and the other is @xmath5 , the problem consisting in deciding whether the quotient of the graph in which the agents are operating is different from a given graph .",
    "we start the section by defining the problem @xmath5 , which requires defining the notion of the quotient graph .      in order to define the problem @xmath5 , we rely on the following important notion introduced in @xcite .",
    "let @xmath9 be a graph and @xmath76 a node of @xmath9 . the _ view",
    "_ from @xmath76 is the infinite rooted tree @xmath77 with labeled ports , defined recursively as follows .",
    "the truncated view of @xmath76 at depth @xmath78 , @xmath79 , is a single node .",
    "given the truncated views at depth @xmath80 , @xmath81 , of every node @xmath38 , we define @xmath82 .",
    "@xmath82 has its root @xmath83 corresponding to @xmath76 . for every node @xmath84 , @xmath85 , adjacent to @xmath76 in @xmath9 , there is a child @xmath86 in @xmath82 such that the port number at @xmath76 ( resp .",
    ", at @xmath84 ) corresponding to edge @xmath87 is the same as the port number at @xmath83 ( resp .",
    ", at @xmath86 ) corresponding to edge @xmath88 .",
    "node @xmath86 , for @xmath85 , is then set as the root of the truncated view @xmath89 at depth @xmath90 from @xmath84 .",
    "the resulting tree is @xmath82 .",
    "the view @xmath77 from @xmath76 is the infinite tree rooted at a node @xmath83 whose every subtree of depth @xmath80 , rooted at @xmath83 , is isomorphic to @xmath91 .",
    "the following result is proved in @xcite .",
    "[ trunc ] for every @xmath32-node graph , and for every two nodes @xmath38 and @xmath76 of the graph , if @xmath92 then @xmath93 .",
    "the notion of view is used in @xcite to define one of the crucial concepts in computations in unlabeled graphs .",
    "let @xmath9 be a graph .",
    "the _ quotient graph _ of @xmath9 , denoted by @xmath94 , is a ( not necessarily simple ) graph defined as follows .",
    "every node of @xmath94 corresponds to a maximal set of nodes of @xmath9 which have the same view .",
    "for all ( possibly equal ) nodes @xmath95 corresponding to two sets @xmath96 , respectively , there is an edge between @xmath83 and @xmath97 with labels @xmath98 at @xmath83 and @xmath99 at @xmath97 , if there exists an edge @xmath100 in @xmath9 with @xmath101 , @xmath102 and with ports @xmath98 at @xmath38 and @xmath99 at @xmath76 .",
    "it follows from theorem [ trunc ] that , for every node @xmath103 , computing the truncated view of @xmath9 from @xmath76 at depth at least @xmath43 suffices to construct @xmath94 .",
    "note that , as opposed to graphs in which agents operate , a quotient graph can have self - loops ( whose both ports may have the same number ) and multiple edges .",
    "it follows from @xcite that computing truncated views of all nodes of @xmath9 is the maximum information that can be obtained from exploring @xmath9 by a single agent .",
    "this is summarized by the following lemma .",
    "[ lem : idexe ] let @xmath9 and @xmath6 be two graphs , and assume that @xmath104 . consider a single agent performing a protocol starting from node @xmath76 of @xmath9 and from node @xmath105 of @xmath6 , where @xmath76 and @xmath105 correspond to the same node of @xmath106 .",
    "assume that the agent is initially aware only of its identity and of its input string .",
    "then the execution of the protocol is identical in @xmath9 and in @xmath6 .",
    "truncated views being the maximum information that can be obtained from exploring a graph by a single agent , the quotient graph is , intuitively , the ultimate information that can be gained about the graph from its exploration by a single agent .",
    "we are interested in the decision problem @xmath107 thus @xmath5 is the problem to decide whether the quotient graph of the graph from an initial configuration is _ different _ from a given graph .      in order to state our main result",
    "we define the following _ product _ of decision problems .",
    "let @xmath108 , @xmath109 , be @xmath3 decision problems .",
    "we define the decision problem @xmath110 as follows : @xmath111    we are now ready to state our main result :    [ theo : main ] the decision problem @xmath112 is @xmath2-complete .",
    "first , we prove that @xmath113 . to establish this",
    ", we describe a verifying protocol whose certificate @xmath83 is the same for all agents , and is interpreted as the size @xmath32 of the network @xmath9 in which these agents are operating .",
    "let @xmath114 be an initial configuration for @xmath75 , @xmath115 .",
    "that is , for all @xmath20 , @xmath116 if @xmath117 , where @xmath3 is a positive integer , and @xmath118 otherwise , where @xmath6 is a graph , and @xmath119    below is a compact description of the verification protocol performed by each agent .",
    "we now detail the protocol , and prove its correctness .",
    "let us first consider the case where the input to @xmath75 has the first term  1 , i.e. , when the problem to be decided is @xmath4 . in this context , we make use of the following result , which is folklore in the domain of mobile agents computing .    [",
    "claim : rdv ] consider two mobile agents with distinct identities placed initially at arbitrary nodes of a graph unknown to the agents , but whose size @xmath32 is known to the agents .",
    "there exists a computable function , @xmath120 , depending on both the size @xmath32 of the graph and the identity @xmath121 of each agent , and there exists a rendezvous protocol , @xmath122 , which guarantees that , after @xmath123 rounds in an @xmath32-node graph , the agent with identity @xmath121 is back at its starting position , and has met the other agent .",
    "this claim has been implicitly proved in several papers ( see , e.g. , @xcite which is aiming at minimizing @xmath120 , or @xcite which aims at minimizing the memory of the agent ) .",
    "we provide a short explicit proof for further references in the text .",
    "let @xmath124 .",
    "the @xmath122 protocol works as follows .",
    "the agent with identity @xmath121 executes a consecutive series of @xmath121 dfs traversals of the graph , at distance at most @xmath32 , and then stops at its initial position .",
    "every dfs requires at most @xmath125 rounds in a graph of @xmath32 nodes .",
    "thus the series of dfs traversals requires at most @xmath126 rounds in a graph of @xmath32 nodes .",
    "let @xmath121 and @xmath127 be the identities of the two agents , @xmath128 .",
    "agent @xmath127 will meet agent @xmath121 at the starting position of the latter during the @xmath129st dfs of the former .",
    "this completes the proof of the claim .",
    "the protocol @xmath122 is modified to insure gathering of many agents , as follows .",
    "whenever two or more agents meet , they merge and they carry on the execution of the protocol @xmath122 trying to meet the other agents .",
    "( merging means that the agent with the largest label among the merged agents becomes a leader , and the one(s ) with smaller label(s ) follows that leader , performing identical moves ) .",
    "the decision is made by the agent with identity @xmath121 after having performed @xmath130 rounds , where @xmath131 is the maximum of all the identities of the agents with which agent  @xmath121 has already gathered .",
    "if agent @xmath121 ends up in a group of more than @xmath3 agents , it decides `` yes '' , otherwise it decides `` no '' .",
    "we now show that our verification protocol is correct ( still in the case where the input to @xmath75 has the first term  1 , i.e. , when the problem to be decided is @xmath4 ) .",
    "assume that the answer to @xmath75 is `` yes '' , i.e. , there are more than @xmath3 agents in the graph . in this case , by claim  [ claim : rdv ] , for a certificate @xmath83 equal to the true size @xmath32 of the graph , all the agents gather , and thus they are able to count themselves precisely .",
    "hence every agent will decide `` yes '' , as desired . on the other hand , if the answer to @xmath75 is `` no '' , i.e. , there are at most @xmath3 agents in the graph , then , regardless of the certificate @xmath83 , no agent decides `` yes '' because no agent can meet at least @xmath3 other agents .",
    "let us now consider the case where the input to @xmath75 has first term  2 , i.e. , the problem to be decided is @xmath5 . more specifically ,",
    "the agents have to decide , with the help of the certificate @xmath83 , whether the quotient @xmath94 of the graph in which they operate is different from the input graph @xmath6 . for this purpose",
    ", each agent computes the truncated view @xmath132 at depth @xmath133 from its original position  @xmath20 . given @xmath132",
    ", each agent considers all nodes at depth at most @xmath134 in @xmath132 , and computes their truncated views at depth @xmath134 .",
    "that is , for every @xmath135 at depth at most @xmath134 , the agent considers the subtree @xmath136 of height @xmath134 of @xmath132 rooted at @xmath76 .",
    "given all these truncated views @xmath136 , each agent merges the nodes @xmath76 with the same view @xmath136 , from which it computes the quotient graph @xmath106 .",
    "the answer to @xmath5 is given according to whether the resulting graph @xmath106 is isomorphic or not to the input graph @xmath6 .",
    "the correctness of this verification protocol is based on the following fact which may be of independent interest , as it is an improvement of the result from  @xcite ( cf .",
    "theorem  [ trunc ] ) .",
    "[ claim : view ] let @xmath94 be the quotient graph of @xmath9 , and let @xmath137 be the size of @xmath94 .",
    "for every two nodes @xmath38 and @xmath76 of the graph , if @xmath138 then @xmath93 . as a consequence , for every node @xmath103",
    ", computing the truncated view of @xmath9 from @xmath76 at depth at least @xmath139 suffices to construct @xmath94 .",
    "the intuition to establish the claim is that , in view of theorem  [ trunc ] , computing the truncated view of @xmath94 at depth at least @xmath139 from some node @xmath140 suffices to reconstruct @xmath94 .",
    "the claim then follows since , by lemma  [ lem : idexe ] , the behavior and the perception of the agent are identical whether it is placed in @xmath9 or in @xmath94 .",
    "though this intuition is correct , it is not sufficient to prove the claim because , actually , @xmath94 has multiple edges and self - loops , and , more importantly , different edges incident to the same node of @xmath94 may have identical port numbers at that node .",
    "the agent is not designed to operate in such graphs . yet , by the definition of the quotient graph , two edges with identical port numbers incident to a node @xmath141 necessarily lead to the same node @xmath140 .",
    "therefore , an agent enhanced with the ability to navigate in a graph with potentially identical port numbers associated to different edges incident to the same node can compute the view of a node in @xmath94 , truncated at any given depth .",
    "more precisely , let us consider an agent whose perception at a node is the number of incident edges with different port numbers , and assume that whenever the agent has computed an out - going port number @xmath121 , the edge through which it leaves the node is selected arbitrarily among those with port number @xmath121 .",
    "then the behavior and the perception of such an agent are identical whether it is placed in @xmath9 or in @xmath94 .",
    "the claim then follows by application of theorem  [ trunc ] .",
    "we use claim  [ claim : view ] to prove the correctness of the verification .",
    "first , assume that the answer to @xmath75 is `` yes '' , i.e. , @xmath142 .",
    "in this case , for a certificate @xmath83 equal to the true size @xmath32 of the graph , we have @xmath143 .",
    "thus , by theorem  [ trunc ] , each agent has constructed the quotient @xmath144 .",
    "therefore , it can check that @xmath142 , hence it decides `` yes '' , as desired .",
    "now , assume that the answer to @xmath75 is `` no '' , i.e. , the input is a graph @xmath6 and @xmath145 .",
    "regardless of the certificate @xmath83 , each agent computes the view at distance @xmath146 . by claim  [ claim : view ]",
    ", we get that the graph @xmath106 constructed by the algorithm is the graph @xmath94 .",
    "hence every agent detects that @xmath145 , and returns `` no '' , as desired .",
    "this completes the proof that @xmath113 .",
    "it remains to prove that for every problem @xmath147 , we have @xmath148 . deciding @xmath25 using @xmath75 as a black box works as follows .",
    "below is a compact description of the protocol performed by each agent , where @xmath149 is a procedure allowing agents to decide @xmath75 , and @xmath12 is the initial configuration .",
    "more precisely , every agent starts by calling @xmath149 with input @xmath150 for successive values @xmath151 until it gets a `` yes '' answer .",
    "when this occurs , every agent knows the size @xmath3 of the team currently in the graph .",
    "the behavior of the agent(s ) depends on whether @xmath152 or @xmath153 .",
    "first assume that @xmath153 .",
    "in this case , the behavior of the agents is based on the following claim .",
    "[ claim : gather ] consider a team of @xmath153 agents in a graph @xmath9 unknown to these agents .",
    "the agents are placed at arbitrary nodes of @xmath9 .",
    "assume that each agent is aware of the size @xmath3 of the team , but is not aware of the size @xmath32 of the graph @xmath9 .",
    "there exists a protocol @xmath154 that accomplishes gathering of all @xmath3 agents in the same node .    to establish the claim ,",
    "we show how to use the rendezvous protocol @xmath122 of claim  [ claim : rdv ] to perform gathering of @xmath3 agents despite the fact that the agents are not aware of the size @xmath32 of the graph .",
    "this is achieved by trying different values of @xmath32 .",
    "the main difficulty is that testing different @xmath32 may desynchronize the agents , whereas claim  [ claim : rdv ] requires the agents to start at the same time .",
    "this desynchronization is caused by both the structure of the graph and the different identities .",
    "let @xmath155 be the maximum number of rounds of @xmath122 when performed on graphs with @xmath32 nodes by agents with identites on at most @xmath156 bits .",
    "protocol @xmath154 enumerates the pairs @xmath157 , and tests each pair as follows .",
    "each agent performs @xmath122 as in a graph of @xmath32 nodes , but stops after @xmath155 rounds . during the @xmath155 rounds ,",
    "if two or more agents meet , they merge in the sense that the one with the largest label becomes a leader , and the one(s ) with smaller label(s ) follow(s ) that leader",
    ". once the @xmath155 rounds are exhausted , and if the @xmath3 agents have not yet met , the next pair @xmath157 is considered .",
    "eventually , the agents will test a pair @xmath157 where @xmath32 is the size of the graph , and @xmath156 is an upper bound of all agents label sizes . in this context ,",
    "protocol @xmath122 guarantees that all the agents will meet at the same time at the same node .",
    "this completes the proof of the claim .    by claim  [ claim :",
    "gather ] , the agents are now assumed to have gathered together at the same node .",
    "we show how the agents can then compute a map of @xmath9 with @xmath15 identified on the map .",
    "we use the following result :    [ claim : map ] consider an agent equipped with a movable token in a graph @xmath9 unknown to the agent .",
    "there exists a protocol @xmath158 for the agent that allows the agent to draw an isomorphic copy of  @xmath9 .    to establish the claim ,",
    "let @xmath9 be the graph in which the agent operates , and let @xmath38 be the starting node of the agent .",
    "we describe the protocol @xmath158 . for @xmath159 ,",
    "let @xmath160 be the ball centered at @xmath38 , of radius @xmath161 ( i.e. , the graph induced by all nodes at distance at most @xmath161 from @xmath38 ) , and let @xmath162 be the graph induced by all nodes at distance exactly @xmath161 from @xmath38 .",
    "initially , the agent only knows @xmath163 .",
    "assume that the agent has drawn a map of @xmath160 .",
    "note that the agent can navigate in @xmath160 using the map . to get the map of @xmath164 , the agent visits every node @xmath165 , and traverses every edge incident to @xmath76 pending out of @xmath160 , reaching every node @xmath105 at distance exactly @xmath166 from @xmath38 . in order to draw the map of the edges connecting a node in @xmath162 and a node in @xmath167 , as well as the edges connecting two nodes in @xmath167 , the agent proceeds as follows .",
    "it considers every node @xmath105 at distance exactly @xmath166 from @xmath38 , and treats each one iteratively . for each @xmath168 ,",
    "the agent places the token at @xmath105 , and then traverses all edges pending out of @xmath160 to discover other edges incident to the same node @xmath105 .",
    "that is , whenever the agent reaches node @xmath169 , it does the following .",
    "if it finds the token at @xmath170 , then @xmath171 and a new edge incident to @xmath105 has been discovered .",
    "otherwise , @xmath172 , and then the agent traverses all edges incident to @xmath170 to identify possible edges between @xmath170 and @xmath105 . when all nodes @xmath168 have been treated , the agent has a map of @xmath164 .",
    "the protocol @xmath158 is completed when there are no edges pending out from the current ball @xmath160 , in which case the map of @xmath160 is the map of @xmath9 .",
    "this completes the proof of the claim .    by claim  [ claim : map ] ,",
    "once the @xmath153 agents have gathered , they can collectively construct a map of the graph ( the agent with the largest identity acts as the agent in claim  [ claim : map ] , while the others play collectively the role of the token ) .",
    "note that during the execution of all the operations required to gather and to construct a map of the graph , each agent can trace its movements , and thus not only every agent ends up with a map of the graph , but also the agents know the starting position of every agent .",
    "hence , the agents know the initial configuration @xmath12",
    ". since the problem @xmath25 is , by definition , decidable , the agents can decide whether @xmath173 .",
    "this completes the case of a team with more than one agent .",
    "now assume that there is a single agent in the graph ( i.e. , @xmath152 ) .",
    "the agent then enumerates the graphs @xmath6 , and successively calls @xmath149 with input @xmath174 until it gets a `` yes '' answer .",
    "when this occurs , the agent knows the quotient @xmath106 of the graph in which it operates .",
    "the following claim shows that , in the case of a single agent , the class @xmath2 is stable with respect to the quotient operation . for a node @xmath175",
    ", we denote by @xmath176 the equivalence class of @xmath38 in @xmath94 .    [ claim : mav ] let @xmath147 and let @xmath177 be an initial configuration involving a single agent placed at node @xmath178 . if @xmath179 then , for every @xmath6 such that @xmath180 , and for every @xmath181 such that @xmath182 , we have @xmath183 .    to establish the claim , assume for the purpose of contradiction , that there exist two graphs @xmath9 and @xmath6 , and two nodes @xmath178 and @xmath181 such that @xmath180 , @xmath182 , @xmath179 , and @xmath184 for some @xmath185 and some @xmath186 .",
    "let @xmath187 be a protocol verifying @xmath25 .",
    "by lemma  [ lem : idexe ] , given the same certificate @xmath83 , the behavior of an agent starting at @xmath20 in @xmath9 , and that of an agent starting at @xmath90 in @xmath6 are identical .",
    "thus , for a certificate @xmath83 for which the agent decides `` yes '' for @xmath177 , it also decides `` yes '' for @xmath188 , a contradiction .",
    "this completes the proof of the claim .",
    "claim  [ claim : mav ] implies that the answer to the question whether @xmath189 depends on @xmath94 rather than on @xmath9 .",
    "so , to decide whether @xmath173 , the agent has just to compute the quotient graph @xmath94 and the equivalence class @xmath190 of the starting position @xmath20 . by claim  [ claim : view ] , this can be achieved by computing the truncated view from @xmath20 at depth @xmath191 .",
    "once @xmath190 is identified , the agent can decide whether @xmath179 by computing whether @xmath192 , where @xmath6 is an arbitrary graph such that @xmath180 , and @xmath181 is an arbitrary node such that @xmath182 .",
    "this completes the proof of theorem  [ theo : main ] .",
    "in this section we look beyond the class of mobile agents verifiable problems . what is the power of the information about the number of agents ?",
    "we have seen in the proof of theorem  [ theo : main ] that it is very significant , if it is larger than  1 .",
    "indeed , if the agents know their number @xmath3 , and this number is larger than 1 , then they can compute both an isomorphic copy of the graph and the initial positions of all agents , up to automorphisms .",
    "hence they can compute the entire initial configuration and consequently they can solve all decision problems in @xmath29 .",
    "by contrast , if the agent is only one ( and even if it knows it ) , then the only problems it can solve are those from the class @xmath1 .",
    "hence , in order to study the power of additional information that can be provided to the agents , from now on we restrict attention to the case of a single agent . we define the classes @xmath193 , @xmath194 and @xmath195 of decision problems , corresponding to @xmath29 , @xmath1 and @xmath2 , respectively , but concerning a single agent .",
    "if @xmath74 is one of these classes , then @xmath196 is the class of problems @xmath197 whose instances are restricted to initial configurations @xmath12 satisfying @xmath198 . by theorem  [ theo : main ] , we get :    the decision problem @xmath5 is @xmath195-complete .    for each decision problem @xmath199 ,",
    "its complement @xmath200 is the decision problem such that , for every initial configuration @xmath177 , we have @xmath201 if and only if @xmath202 .",
    "we then define @xmath203 in the standard way by : @xmath204 we have seen in the proof of theorem  [ theo : main ] that @xmath195 is stable with respect to the quotient operation , as a direct consequence of lemma  [ lem : idexe ] . by the same lemma , we get that @xmath194 and @xmath203 are also stable with respect to the quotient operation .    by definition",
    ", we have @xmath205 .",
    "in fact , the two classes coincide .",
    "indeed , consider @xmath206 , and any initial configuration . by enumerating all certificates @xmath52 , and , for each of them , using the verifying protocol @xmath207 for the problem @xmath25 and the verifying protocol @xmath208 for its complement , we get a decision protocol for @xmath25 because there is the first @xmath83 for which either @xmath207 or @xmath208 will decide `` yes '' .",
    "more precisely , for each tested certificate @xmath83 , the agent applies @xmath207 with certificate @xmath83 .",
    "if the decision is `` no '' , then the agent returns to its original position , and applies @xmath208 with the same certificate @xmath83 .",
    "if the decision is again `` no '' , then the agent returns to its original position , and picks the next certificate to be tested .",
    "it carries on that way until it gets a `` yes '' decision from @xmath207 or @xmath208 .",
    "if this `` yes '' is from @xmath207 then it decides `` yes '' , otherwise it decides `` no '' .",
    "hence , we get the following :    @xmath209 .",
    "now , we move our concern to the universe beyond @xmath195 and @xmath210 , by considering decidability classes with oracles . given a uniform decision problem @xmath25 , the class @xmath211 is defined as the class of decision problems @xmath63 , such that @xmath212 , i.e. , the class of problems that are mobile agents decidable , when an oracle deciding @xmath25 is available to the agents .",
    "we are focussing attention on the classes @xmath213 , @xmath214 and @xmath215 , where @xmath216 is the problem to decide whether the graph from the initial configuration is isomorphic to @xmath6 , for a given graph @xmath6 ( as usual , an isomorphism has to preserve adjacencies and port numbers ) .",
    "we want to compare these classes and situate them with respect to @xmath194 and @xmath195 .",
    "first notice that @xmath213 is the class of problems for which the decision may depend on the quotient graph @xmath94 of the graph @xmath9 from the initial configuration , but not on the graph @xmath9 itself . indeed ,",
    "having the oracle @xmath5 is equivalent , for a single agent , to having a copy of @xmath94 : the agent can query this oracle with all arbitrarily enumerated graphs , until the answer is `` no '' .",
    "similarly , the oracle @xmath44 is equivalent to having the size of the underlying graph , and the oracle @xmath217 is equivalent to having an isomorphic copy of the underlying graph .",
    "we show that providing a single agent operating in the graph @xmath9 with a copy of the quotient graph @xmath94 , permits it to solve all mobile agents verifiable and co - verifiable problems , as well as some problems outside of these classes .",
    "this is implied by the following theorem .",
    "[ incl1 ] @xmath218 ( all inclusions are strict ) .",
    "the inclusion @xmath219 is by definition .",
    "it is strict , as witnessed , e.g. , by the problem @xmath54 .",
    "@xmath220 by lemma  [ lem : idexe ] .",
    "we show that the inclusion is strict .",
    "let @xmath221 and @xmath222 where figure  [ fig : proof](a ) displays a sun .",
    "( in both cases , we assume that the edges are consistently labeled  1 clockwise , and  2 counterclockwise ) .",
    "we have @xmath223 . indeed , @xmath224 and @xmath225 .",
    "on the other hand , both problems @xmath226 and @xmath227 are in @xmath228 .",
    "indeed , let @xmath229 be the graph consisting of a unique node with a loop labeled  1 and  2 at its two extremities , and let @xmath230 be the graph consisting of two nodes @xmath38 and @xmath76 connected by an edge , with a loop at node @xmath38 labeled  1 and  2 at its two extremities .",
    "we have @xmath231 if and only if @xmath9 is a ( consistently labeled ) cycle , and @xmath232 if and only if @xmath9 is a ( consistently labeled ) sun .    we conclude with the following result that compares classes @xmath213 , @xmath233 and @xmath234 .",
    "it shows that , in the case of a single agent , providing the size of the graph is stronger than providing the quotient graph , and providing an isomorphic copy of the graph is even stronger and permits the agent to reconstruct its initial position ( up to authomorphism ) , i.e. , it is as strong as providing the entire initial configuration .",
    "[ incl2 ] @xmath235 ( all inclusions are strict ) .",
    "the inclusion chain follows from the facts that knowing the size of a graph allows an agent to compute its quotient graph ( by theorem  [ trunc ] ) , and knowing the map of a graph allows an agent to compute its size .",
    "the inclusions are strict .",
    "indeed , @xmath236 , and @xmath237 .",
    "the former holds because there exist graphs of different sizes with the same quotient ( e.g. , cycles ) , and the latter holds because there exist non - isomorphic graphs with the same size and the same quotient ( see , e.g. , the two graphs displayed in figure  [ fig : proof ]  ( c ) and  ( d ) , cf .",
    "finally , the fact that @xmath234 is actually equal to the set @xmath193 of all decidable problems involving configurations with a single agent follows from the fact that if the map @xmath9 is given to the agent then it can compute its starting position @xmath178 ( up to automorphism ) on the map , and thus it can compute the whole initial configuration @xmath177",
    ".    figure  [ fig : summary ] summarizes all the results in this section .     of decision problems for a single agent , width=340 ]",
    "we provided a classification of decision problems that can be solved by mobile agents operating in graphs , possibly with the help of some additional information .",
    "it turns out that knowing the size of the team of agents is very powerful but only if this size is larger than 1 . in this case , knowing the size of the team permits the agents to gather and then reconstruct the underlying graph and the entire initial configuration , i.e. , they can solve all decision problems .",
    "this points to the crucial role of gathering ( or rendezvous ) in mobile agents computing .",
    "it is also an additional justification of the importance of this task which gained growing attention of the algorithmic community in the recent years .",
    "the following question remains open : what is the minimal information about the size of the team of agents ( if there are many of them ) that permits the agents to reconstruct the initial configuration ?    for a single agent , our three classes of relative mobile agents decidability , @xmath213 , @xmath233 and @xmath234 , seem to be fairly natural , as they correspond to types of information that are often given to agents accomplishing some task in a communication network .",
    "the size of the graph or its topology are examples of such information .",
    "the quotient graph is rarely given to the agent but its importance comes from the fact that this is the ultimate information about the underlying graph that the agent can acquire when operating in it",
    ". it would be interesting to have a combinatorial characterization of the classes @xmath213 , @xmath233 , as well as of the class @xmath194 itself , that would permit to decide if a given problem is in a particular class .",
    "it seems particularly intriguing if classes @xmath194 and @xmath233 are decidable . in other words , is it possible to decide if a given decision problem @xmath199 can be solved by a mobile agent operating in this graph ( not having any a priori information ) , or , alternatively , by an agent just knowing the size of the graph ?",
    "a more precise formulation of this open problem is the following .",
    "does there exist a turing machine which , given as input a description of a turing machine deciding if an initial configuration is in @xmath25 , decides whether @xmath25 is in @xmath194 ( respectively in @xmath233 ) .",
    "m. cieliebak , p. flocchini , g. prencipe , n. santoro , solving the robots gathering problem , proc .",
    "30th international colloquium on automata , languages and programming ( icalp 2003 ) , lncs 2719 , 1181 - 1196 .",
    "a. collins , j. czyzowicz , l. gasieniec , a. labourel , tell me where i am so i can meet you sooner , proc .",
    "37th international colloquium on automata , languages and programming ( icalp 2010 ) , lncs 6199 , 502 - 514 .",
    "s. das , p. flocchini , n. santoro , m. yamashita , on the computational power of oblivious robots : forming a series of geometric patterns , proc .",
    "29th annual acm symposium on principles of distributed computing ( podc 2010 ) , 267 - 276        p. flocchini , g. prencipe , n. santoro , p. widmayer , gathering of asynchronous oblivious robots with limited visibility , proc .",
    "18th annual symposium on theoretical aspects of computer science ( stacs 2001 ) , lncs 2010 , 247 - 258 ."
  ],
  "abstract_text": [
    "<S> we establish a classification of decision problems that are to be solved by mobile agents operating in unlabeled graphs , using a deterministic protocol . </S>",
    "<S> the classification is with respect to the ability of a team of agents to solve the problem , possibly with the aid of additional information . in particular , our focus is on studying differences between the _ decidability _ of a decision problem by agents and its _ verifiability _ when a _ certificate _ for a positive answer is provided to the agents . we show that the class @xmath0 of _ mobile agents verifiable _ problems is much wider than the class @xmath1 of _ mobile agents decidable _ problems . </S>",
    "<S> our main result shows that there exist natural @xmath2-complete problems : the most difficult problems in this class , to which all problems in @xmath2 are reducible . </S>",
    "<S> our construction of a @xmath2-complete problem involves two main ingredients in mobile agents computability : the topology of the quotient graph and the number of operating agents . beyond the class @xmath2 </S>",
    "<S> we show that , for a single agent , three natural oracles yield a strictly increasing chain of relative decidability classes .    </S>",
    "<S> * keywords : * decision problem , mobile agent , graph , rendezvous    1ex </S>"
  ]
}