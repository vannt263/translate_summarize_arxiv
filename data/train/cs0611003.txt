{
  "article_text": [
    "many synchronization techniques have been proposed for synchronizing sensor networks  @xcite .",
    "these techniques all rely on nodes exchanging packets with timing information . using the exchanged timing information , each node",
    "can then estimate clock offset and maybe clock skew .",
    "however , all of these traditional synchronization techniques suffer from an inherent scalability problem  synchronization error accumulates over multiple hops . at each hop",
    ", nodes will estimate synchronization parameters , but the estimates will have errors . therefore , when these erroneous parameters are used to communicate timing information to the next hop , errors will further increase .",
    "this accumulation of error over multiple hops poses a problem as sensor networks are deployed over larger and larger areas . the number of hops required to communicate across the network increases and , thus , the synchronization error across the network increases as well .",
    "one possible way to avoid the scalability problem is to use a few nodes with powerful radios to limit the number of hops required to communicate timing information across the network .",
    "however , this technique does not address the fundamental scalability problem of errors accumulating over multiple hops .    in this work , we consider the use of high density networks to mitigate the scalability problem .",
    "recent developments  @xcite , @xcite , @xcite suggest that future networks may have extremely large numbers of nodes deployed over wide areas .",
    "the question we consider is whether or not the density of future networks can be used to address scalability issues that plague existing techniques .      in order to reduce the scalability problem",
    ", we need to find ways to reduce the synchronization error at each hop .",
    "there are two primary ways to accomplish this .",
    "the first is to collect more timing information . with more timing data ,",
    "nodes can generally make a better estimate of clock skew and clock offset .",
    "for example , rbs and ftsp both let nodes collect many timing data points before estimating clock skew and clock offset .",
    "a timing data point provides a node with the time at a reference clock at a specific time in its local time scale . with more data points ,",
    "synchronization error will decrease .",
    "this idea is essentially doing a _ time _",
    "average to estimate clock skew and clock offset .",
    "however , this is not necessarily practical since it would significantly increase the time to synchronize and the amount of network traffic .",
    "the second primary approach is to improve the quality of the timing data point .",
    "for example , tpsn and ftsp use mac layer time stamping techniques that are more accurate . however , we believe that there is a fundamentally new technique for improving data point quality that has not been considered before .",
    "this new idea is to use spatial averaging to improve data point quality . in a high density network",
    ", we have a large number of surrounding nodes . instead of only doing a time average to estimate the clock skew and clock offset ,",
    "perhaps we can also do a _",
    "average to improve these estimates .",
    "we assume the network is setup such that one node , called node @xmath2 , has the reference clock that all other nodes want to synchronize to .",
    "node @xmath2 will communicate timing information to the nodes in its broadcast domain , the @xmath3 nodes .",
    "the @xmath3 nodes will then communicate timing information to the nodes that are another hop out , the @xmath4 nodes .",
    "this process continues until all nodes are synchronized ( fig .",
    "[ fig : nodesets ] ) .",
    "each node in @xmath5 , @xmath6 , will use information from the @xmath7 nodes to estimate its clock skew and clock offset . with these parameters",
    ", the node will be able to send a sequence of @xmath8 pulses that are approximately @xmath9 seconds apart in the reference time scale , where @xmath9 and @xmath8 are pre - specified by the protocol .",
    "all nodes in the @xmath5 set will be attempting to send pulses at the same time .",
    "however , due to synchronization error , the pulses will only be occurring at approximately the same time .",
    "thus , any node in the @xmath10 set of nodes will observe @xmath8 clusters of pulses instead of just @xmath8 individual pulses .",
    "since each pulse in a cluster represents one @xmath5 node s attempt to transmit at some appropriate time in the reference time scale , taking the sample mean of the pulse arrival times in each cluster allows us to average out some of the error made by any one node in @xmath5 .",
    "the process of having each node in @xmath10 use the sample mean of each cluster as a timing data point is the key to spatial averaging .",
    "since each @xmath10 node can use timing information from many surrounding neighbors in @xmath5 , we call our technique _ cooperative time synchronization_. using these timing data points , and some additional information from the @xmath5 set , every node in @xmath10 can estimate its clock skew and offset .",
    "thus , this process can then repeat to synchronize the @xmath11 nodes .",
    "the difficulty in studying this problem is that , generally , the @xmath8 clusters observed by any particular node in @xmath10 will be different from the @xmath8 clusters observed by any other node in @xmath10 .",
    "this is because the clusters observed by a node will depend on where this node is located relative to the @xmath5 set of nodes .",
    "therefore , to study how cooperation can improve synchronization , we approach the problem in two steps .",
    "first , we set up a basic cooperative network ( type i network ) that is a base case for cooperation .",
    "the key assumption in a type i network is that all nodes in @xmath10 are in the broadcast domain of all nodes in @xmath5 .",
    "note that this is a generalization of the non - cooperative situation where timing information is passed from one node to the next .",
    "[ fig : typeicomparison ] compares the basic cooperative network to a non - cooperative network . with the type",
    "i network we analytically quantify how the variance of the skew and offset estimates grow with increasing hop number .",
    "second , we use the theoretical results from the basic cooperative network to understand the behavior of a general type ii network where nodes are uniformly distributed over a circular area .",
    "simulation results are used to illustrate that increasing network density improves synchronization performance .",
    "the traditional synchronization techniques describe in  @xcite all operate fundamentally on the idea of communicating timing information from one set of nodes to the next .",
    "one other approach to synchronization that has recently received much attention is to apply mathematical models of natural phenomena to engineered networks . a model for the emergence of synchrony in pulse - coupled oscillators",
    "was developed in  @xcite for a fully - connected group of identical oscillators . in  @xcite , this convergence to synchrony result was extended to networks that were not fully connected .",
    "the convergence result is clearly desirable for synchronization in networks and in  @xcite theoretical and simulation results suggested that such a technique could be adapted to communication and sensor networks .",
    "experimental validation for the ideas of  @xcite was obtained in  @xcite where the authors implemented the reachback firefly algorithm ( rfa ) on tinyos - based motes .",
    "the problem with these emergent synchronization results is that the fundamental theory assumes all nodes have nearly the same firing period .",
    "results from  @xcite and  @xcite show that the convergence results may hold when nodes have approximately the same firing period , but the authors of  @xcite explain that clock skew will degrade synchronization performance . since we are not aware of any results that provide an extension to deal with networks of nodes with arbitrary firing periods , our work focuses on synchronization algorithms that explicitly estimate clock skew .      in this paper",
    ", we propose a protocol for time synchronization that uses spatial averaging to improve synchronization performance . in this work",
    "we make the following analysis :    1 .   mathematically quantify the synchronization error for the type i basic cooperative network .",
    "2 .   through simulations ,",
    "show that increasing node density can decrease synchronization error in general networks .",
    "the results show that if each node can hear a large number of neighboring nodes , then nodes can cooperatively generate signals that are less noisy and allow for better synchronization performance over multiple hops .",
    "the fact that more cooperating nodes yields better performance means that there exists a new trade - off between network density and synchronization performance where more nodes provide better synchronization .",
    "even though it is possible to achieve better synchronization performance by introducing nodes with powerful radios to synchronize a large - scale network , cooperative time synchronization is an effective alternative technique to reducing synchronization error across the network without requiring special nodes .",
    "the remainder of the paper is organized as follows . in section  [ sec : systemmodel ] we set up the general network assumptions and present the synchronization protocol in section  [ sec : synchronizationprotocol ] .",
    "the analysis and simulations of the protocol for a basic cooperative network are presented in section  [ sec : typei ] while a study of cooperation in general networks is carried out in section  [ sec : typeii ] .",
    "we make concluding remarks in section  [ sec : conclusion ] .",
    "the behavior of each node @xmath12 is governed by a clock @xmath13 that counts up from @xmath14 .",
    "the introduction of @xmath13 is important since it provides a consistent timescale for node @xmath12 .",
    "this is the node s local time scale and in synchronization the node tries to estimate how its local clock is related to the reference clock .",
    "we assume that node @xmath2 contains the reference clock and every node in the network is to be synchronized to this clock .",
    "the clock of node @xmath2 , @xmath15 , will be defined as @xmath16 where @xmath17 .",
    "we now define the clock of any other arbitrary node @xmath12 , @xmath13 , as @xmath18 where    * @xmath19 is an unknown offset between the start times of @xmath13 and @xmath15 .",
    "* @xmath20 is an unknown constant for each @xmath12 .",
    "* @xmath21 is a stochastic process modelling random timing jitter .",
    "@xmath21 is a zero mean gaussian process with independent and identically distributed gaussian samples with mean zero and variance @xmath22 , i.e. @xmath23 .",
    "we assume @xmath24 and note that @xmath25 is defined in terms of the clock of node @xmath12 .",
    "note that this linear relationship is valid for short periods of time since we do not explicitly model clock drift .",
    "each node @xmath12 in the network can transmit short pulses @xmath26 for time synchronization .",
    "these are short duration pulses , i.e. ultra wideband pulses , and for our purposes we consider them to be delta functions @xmath27 .",
    "the particular choice of @xmath26 is not important . for the purposes of studying cooperative time synchronization , we assume a node receiving the pulse can uniquely determine a pulse arrival time , pulses sent from different nodes do not overlap , and a node seeing multiple pulses can identify the different pulse arrival times .",
    "note that only minor modifications of the protocol are needed to accommodate other types of pulse shapes  @xcite .",
    "we assume that each node has a transmission range of @xmath28 .",
    "this means that a node @xmath29 must be within a distance @xmath28 from a transmitting node @xmath12 in order to hear pulses from node @xmath12 .",
    "note that the assumption of a circular transmission region is made only to simplify the illustration of spatial averaging .",
    "the synchronization protocol proposed in section  [ sec : synchronizationprotocol ] does not require this assumption and most of the results in this work will hold under more realistic conditions  @xcite .",
    "since we are dealing with sensor nodes who have short transmission distances , we further assume that propagation delay is negligible .",
    "we make this assumption since from  @xcite we know that propagation delay is less than @xmath30 for distances up to @xmath31 meters .",
    "some results on cooperation and propagation delay are available in  @xcite .",
    "to start synchronization , the reference node , node @xmath2 , will send a sequence of @xmath8 pulses that are @xmath9 seconds apart .",
    "since we assume the nodes have impulse radio transmitters , each pulse is extremely narrow in time .",
    "the values of @xmath9 and @xmath8 are parameters of the protocol that are established before deploying the network so the values are known by all nodes in the network .",
    "therefore , in the time scale of node @xmath2 the pulses are transmitted at times @xmath32 , where @xmath33 is the time at which the synchronization process started .",
    "let node @xmath2 be the only element of the @xmath34 nodes .",
    "the nodes that are in the broadcast domain of node @xmath2 will hear this sequence of @xmath8 pulses .",
    "we call these nodes the @xmath35 nodes and each node @xmath36 , @xmath6 , will be denoted by node @xmath37 . the vector of pulse arrival times observed by node @xmath37 will be denoted @xmath38",
    ". each node @xmath37 will be able to estimate its clock skew since it knows that node @xmath2 transmitted these pulses @xmath9 seconds apart .",
    "each node @xmath37 will also predict , in its own time scale , when times @xmath39 will occur in the time scale of node @xmath2 and transmit @xmath8 pulses , one at each predicted time .",
    "this means that each node @xmath37 will transmit a pulse approximately at times @xmath40 in the time scale of node @xmath2 .",
    "when the @xmath35 nodes each transmit their sequence of @xmath8 pulses , the nodes that can hear a subset of the @xmath35 nodes , the @xmath3 nodes , will observe clusters of pulses around the times @xmath41 since each node @xmath42 can hear many @xmath35 nodes ( fig .  [",
    "fig : pulseclusters ] ) .",
    "in fact , we make sure each node @xmath42 can hear a cluster by requiring the node to observe at least @xmath1 pulses in each cluster .",
    "if a node @xmath42 sees less than @xmath1 pulses in a cluster , then it will not make observations .",
    "each node @xmath42 , a node @xmath43 , will note the arrival time of each pulse in the @xmath44th cluster , @xmath45 , and take the sample mean of these times to be its @xmath44th observation .",
    "node @xmath42 s vector of observations will be denoted as @xmath46 . using these @xmath8 observations",
    ", any node @xmath42 will be able to estimate its clock skew since it knows that these observations should be occurring @xmath9 seconds apart . as well , it will be able to predict in its local time scale when times @xmath47 will occur in the time scale of the reference time .",
    "node @xmath42 will then transmit a pulse at each of those predicted times .",
    "this processes will repeat until all nodes in the network have an estimate of their clock skew .",
    "notice that the @xmath35 nodes are not required to observe @xmath1 pulses in each cluster since they will always only receive a sequence of @xmath8 pulses from node @xmath2 .",
    "node @xmath2 can simply broadcast a special packet to its surrounding nodes to identify the @xmath35 nodes .",
    "an illustration of the process can be found in fig .",
    "[ fig : nodesets ] and note that nodes will remain silent for the remainder of the synchronization process after transmitting their @xmath8 pulses .",
    "the cooperation occurs when a node @xmath48 in @xmath49 , @xmath50 , can take a sample mean of a cluster of pulse arrivals .    to obtain the clock offset , the @xmath49 nodes will broadcast a packet of information to the @xmath51 nodes , @xmath52 .",
    "this packet will contain the value of @xmath33 and a number @xmath53 denoting the number of hops out from node @xmath2 .",
    "for example , node @xmath2 will transmit the value of @xmath33 and @xmath54 to the @xmath35 nodes .",
    "the @xmath35 nodes will then send @xmath33 and @xmath55 to the @xmath3 nodes .",
    "in general , the @xmath49 nodes will send @xmath33 and @xmath56 to the @xmath51 nodes .",
    "any node @xmath48 will then know that its first observation approximately occurred at time @xmath57 in the time scale of the reference time , where the value of @xmath53 is the one received from set @xmath58 .",
    "we now describe how any node @xmath48 can estimate its clock skew , clock offset , and its @xmath8 pulse transmission times .",
    "from ( [ eq : clock ] ) , we know that there is a linear relationship between the reference clock @xmath15 and the clock of node @xmath48 , @xmath59",
    ". node @xmath48 will have a set of @xmath8 observations denoted by the @xmath60 vector @xmath61 , where the elements of the vector are ordered from the earliest observation time to the latest observation time .",
    "node @xmath48 will estimate its clock skew as @xmath62 and clock offset as @xmath63 where @xmath64 $ ] , @xmath65 $ ] and @xmath66^t\\ ] ] note that in the calculation of the clock offset @xmath67 , the term @xmath68 is the time in the time scale of @xmath15 that node @xmath48 should receive its first pulse .",
    "node @xmath48 has used the @xmath33 and @xmath69 parameters sent to it from the @xmath58 nodes .",
    "node @xmath48 will also estimate its own @xmath8 pulse transmission times using @xmath70 where @xmath71 $ ] , for @xmath72 .",
    "@xmath73 is the transmission time of node @xmath48 s @xmath74th pulse .",
    "a pseudo - code description is given in table  [ tab : protocol ] .",
    "note that the protocol described above is a completely new approach to the asymptotic spatial averaging ideas we studied in  @xcite .",
    "[ tab : protocol ]",
    "the most basic and fundamental deployment of nodes that effectively employs cooperative time synchronization is the case where _ all _ @xmath1 nodes at any given hop contribute to the signals observed at the next hop .",
    "this type i deployment is illustrated in the top of fig .",
    "[ fig : typeicomparison ] where each set of nodes @xmath5 , @xmath6 , have @xmath1 nodes .",
    "we see that every node in @xmath5 is in the broadcast domain of every node in @xmath7 .      due to the scalability problem",
    ", we would expect synchronization error to grow as timing information from node @xmath2 ( the @xmath34 node ) is communicated to a node in the @xmath49 set of nodes , @xmath75 .",
    "therefore , it is of particular interest to quantify how the variance of the skew and offset estimates change as a function of the hop number @xmath44 .",
    "looking at the structure of the basic cooperative network in fig .",
    "[ fig : typeicomparison ] , we notice that the skew and offset estimates at a node @xmath48 must be dependent only on the estimates made by the nodes in @xmath58 since all the information at @xmath49 comes from the @xmath58 set of nodes .",
    "therefore , to understand the synchronization error growth over multiple hops , we need the distribution of the estimates made by the nodes in @xmath49 as a function of the distribution of the estimates made by the nodes in @xmath58 .",
    "theorem  [ theorem : main ] , below , provides us with this characterization .    in the statement of the theorem we use @xmath76 to be the column vector of all zeros except for a one in the @xmath77th position and @xmath78,\\end{aligned}\\ ] ] where @xmath79 is from ( [ eq : h ] ) . also , @xmath80 and @xmath81 are the clock model parameters from ( [ eq : clock ] ) for node @xmath48 .    [",
    "theorem : main ] assume a type i basic cooperative network .",
    "\\(1 ) given the distribution of the @xmath82 vector of estimates made by the @xmath58 nodes , @xmath83 the distribution of the @xmath82 vector of estimates made by the @xmath49 nodes , @xmath84 is found as follows : @xmath85 has mean vector @xmath86\\end{aligned}\\ ] ] and covariance matrix @xmath87 for @xmath88 @xmath89 @xmath90\\ ] ] @xmath91 where @xmath92\\end{aligned}\\ ] ] @xmath93\\end{aligned}\\ ] ] @xmath94 - \\left [ \\begin{array}{c } \\alpha_{k1}\\bar{\\delta}_{k1 } \\\\ 0 \\\\ \\vdots \\\\ \\alpha_{k\\bar{n}}\\bar{\\delta}_{k\\bar{n } } \\\\ 0 \\end{array}\\right].\\end{aligned}\\ ] ] the initial conditions are @xmath95\\end{aligned}\\ ] ] and @xmath96 .",
    "( 2 ) the skew estimate and offset estimate for node @xmath48 can be found as @xmath97 @xmath98 for @xmath99 and @xmath100 .",
    "@xmath101    the proof of theorem  [ theorem : main ] is found in the appendix . since the distribution of @xmath85 is available , the distribution of @xmath102 and @xmath67 can be found .",
    "in fact , the variance of @xmath102 can be found in element ( @xmath103 , @xmath103 ) of @xmath104 in ( [ eq : sigmak ] ) and the variance of @xmath67 can be found in element ( @xmath105 , @xmath105 ) .",
    "the mean of @xmath102 is the @xmath106th element of @xmath107 in ( [ eq : muk ] ) and the mean of @xmath67 can be found from the @xmath108th element shifted by @xmath68 .    from the statement of theorem  [ theorem : main ]",
    ", we see that the distribution of the estimates made by the @xmath49 nodes , @xmath85 , is completely determined from the distribution of @xmath109 .",
    "this recursive nature comes from the fact that the parameters estimated by the @xmath49 nodes is only dependent on the estimates made by the @xmath58 nodes .",
    "the relationship between @xmath110 and @xmath85 can be intuitively understood in two steps .",
    "first , @xmath110 is the vector of synchronization parameters estimated by the nodes in @xmath58 .",
    "therefore , these estimates will establish the synchronization parameters for the @xmath49 nodes since the @xmath58 nodes communicate timing information to the @xmath49 nodes .",
    "the synchronization parameters for @xmath49 are found as @xmath111 second , the @xmath49 nodes will use the timing information from the @xmath58 nodes to make an unbiased estimate of the parameters @xmath112 , which gives us @xmath113 .",
    "since any node @xmath48 s skew and offset estimates are found as affine transforms of @xmath114 in ( [ eq : alphahatki ] ) and ( [ eq : deltahatki ] ) , respectively , we see that any estimation errors made by the @xmath58 nodes will be propagated to the @xmath49 nodes estimates of clock skew and clock offset",
    ". however , the intuitive understanding of cooperative time synchronization comes from realizing that the matrix @xmath115 takes an `` average '' over @xmath116 thus mitigating the errors made by any particular node @xmath117 . as a result",
    ", the synchronization parameters communicated to the @xmath49 nodes will be less noisy and , therefore , the skew and offset estimates made by a node @xmath48 will have less error .",
    "we would , thus , expect the variance of the estimates to decrease with increasing @xmath1 .",
    "notice that our type i network analysis does not explicitly utilize the circular transmission region with radius @xmath28 .      in fig .",
    "[ fig : typei_alphaincluded ] we illustrate the matlab simulation results for two @xmath118 hop networks , one with @xmath119 and the other with @xmath120 .",
    "the following parameters were used : @xmath121 for each network , a set of @xmath122 nodes were first placed in a type i network deployment .",
    "each node s skew parameter was then generated using @xmath123 for @xmath124 , independently for each node @xmath12 .",
    "node @xmath2 was assumed to have @xmath125 .",
    "the cooperative time synchronization protocol was then run @xmath126 times using the deployed network . at each hop ,",
    "the @xmath126 skew and offset estimates of one chosen node were used to generate the simulated skew and offset estimate variance curves shown in fig .",
    "[ fig : typei_alphaincluded ] .",
    "the theoretical variance value of the chosen node at each hop was computed using the recursive expression found in ( [ eq : sigmak ] ) .    in fig .",
    "[ fig : typei_alphaincluded ] , we first clearly see that the simulated skew and offset variance values nicely match the predicted theoretical variance values .",
    "as well , the expected decrease in skew and offset variance as @xmath1 increases from @xmath127 to @xmath128 is immediately noticeable .",
    "in fact , in both the skew variance and offset variance curves , we have an approximate halving of the variance values as we double @xmath1 from @xmath127 to @xmath128 .",
    "also expected , is that the variance values at each hop depend on the particular values of @xmath129 , @xmath130 .",
    "this dependence on the @xmath129 values result in the jagged skew and offset variance curves seen in fig .  [",
    "fig : typei_alphaincluded ] .",
    "the @xmath119 network had @xmath129 values ranging from @xmath131 to @xmath132 , while the @xmath120 network had skew values ranging from @xmath133 to @xmath134 .",
    "the problem with having the variance curves depend on the actual skew values is that the exact performance of cooperative time synchronization is dependent on the network realization .",
    "however , we find that for @xmath129 values that are close to and centered around @xmath2 , the variance curves follow the trend established by the theoretical variance curves for @xmath135 , all @xmath12 .",
    "this can be seen in fig .",
    "[ fig : typei_alphaincluded ] where we have also plotted the theoretical curves using @xmath135 for all @xmath12 for @xmath119 and @xmath120 . as a result ,",
    "the situation where @xmath135 , all @xmath12 , can be used to study the the performance improvement of cooperative time synchronization without dealing specifically with the skew values of individual nodes .",
    "therefore , to get a better understanding of how cooperative time synchronization improves synchronization performance , let us simplify the recursive expression in ( [ eq : sigmak ] ) for the special case where @xmath135 for all @xmath12 and find a non - recursive expression for skew and offset variance .",
    "the first thing to note is that under the assumption of @xmath135 for all @xmath12 , @xmath136 and @xmath137 are no longer dependent on @xmath44 .",
    "therefore , writing out the recursive expression for @xmath104 ( [ eq : sigmak ] ) , we have @xmath138 using ( [ eq : noalphaexpression ] ) , corollary  [ corollary : main ] gives us the non - recursive expression for skew and offset variance .",
    "[ corollary : main ] for a basic cooperative network with @xmath135 , all @xmath12 , @xmath102 and @xmath67 have the following mean and variance : @xmath139 @xmath140 @xmath141 @xmath142\\end{aligned}\\ ] ] where @xmath44 is a positive integer . @xmath101",
    "the proof of corollary  [ corollary : main ] is omitted since it is a direct simplification of ( [ eq : noalphaexpression ] ) .",
    "note that the skew and offset variance expressions are only a function of @xmath44 and not @xmath12 .",
    "the theoretical skew and offset variance of the @xmath12th node at the @xmath44th hop ( node @xmath48 ) can be found in elements ( @xmath103 , @xmath103 ) and ( @xmath105 , @xmath105 ) , respectively , of @xmath104 in ( [ eq : noalphaexpression ] ) . however , the skew variance values in elements ( @xmath103 , @xmath103 ) , @xmath143 , are all equal and the offset variance values in elements ( @xmath105 , @xmath105 ) , @xmath143 , are also equal when we assume that @xmath135 for all @xmath12 . as a result",
    ", we can consider the skew and offset variance at a hop @xmath44 without specifying a particular node .",
    "notice also that , besides the sign change in the mean of the offset estimate , the skew and offset estimates are unbiased estimates of the clock parameters of node @xmath48 .",
    "looking at the skew and offset variance curves in ( [ eq : alphahatki_alphaeq1 ] ) and ( [ eq : deltahatki_alphaeq1 ] ) , respectively , we see that the variance growth decreases like @xmath0 .",
    "this @xmath0 factor in both ( [ eq : alphahatki_alphaeq1 ] ) and ( [ eq : deltahatki_alphaeq1 ] ) is expected since every node takes the sample mean of @xmath1 pulses to be an observation .",
    "the variance of the observation decreases like @xmath0 because it is a sample mean and , thus , it is not surprising that the skew and offset variance values also approximately decrease like @xmath0 .",
    "nodes will not generally be clustered together as in a basic cooperative network , but be deployed in a more random manner . as a result , to study general network deployments , we will consider a type ii situation where nodes are uniformly deployed with density @xmath144 over a circular region of radius @xmath145 with node @xmath2 at the center .",
    "in such a setup , at any hop @xmath44 , @xmath146 , a node @xmath48 in the @xmath49 nodes will see _ at least _",
    "@xmath1 nodes from the @xmath58 set of nodes .",
    "however , the exact number of observed nodes will depend on node @xmath48 s location in the region occupied by the @xmath49 nodes .",
    "an illustration of a type ii deployment is shown in fig .",
    "[ fig : type2setup ] .",
    "we note that the @xmath34 node ( node @xmath2 ) is placed at the center of the disk and the @xmath35 nodes occupy a circular region of radius @xmath28",
    ". however , the region occupied by the @xmath49 nodes for @xmath146 is a ring centered around node @xmath2 with a ring thickness of @xmath147 . for increasing @xmath44 , the distance from node @xmath2 to the inner circular boundary of the region occupied by the @xmath49 set of nodes increases .",
    "to study a type ii network , we could carry out an analysis similar to the one we did for the type i basic cooperative network .",
    "assuming we know the location of all nodes for a given network deployment over the circular region of radius @xmath145 , we would be able to determine the neighbors of each node and then readily extend the type i analysis to this type ii network .",
    "the primary change that would occur in the analysis is the determination of the affine transform @xmath148 however , there are two issues that arise in determining the transform matrix @xmath149 and vector @xmath150 .    first , since @xmath49 and @xmath51 will most likely have different numbers of nodes , we immediately see that @xmath149 will be a @xmath151 matrix and @xmath150 will be a @xmath152 vector , where @xmath153 is the cardinality of set @xmath49 .",
    "this means that the length of vector @xmath114 will change with every hop .",
    "second , for any node @xmath154 in @xmath51 , the set of cooperating nodes in @xmath49 will be different .",
    "thus , @xmath115 will also reflect this difference .",
    "therefore , every time we move from hop @xmath44 to @xmath155 , the correlation structure of @xmath114 will change .",
    "together , these two points suggest that even though it is possible to carry out the full analysis , the complexity would make the resulting expressions depend on the particular network realization and not provide significant insight into the problem .",
    "in fact , it would be nearly impossible to visualize the result without carrying out a numerical evaluation . since our goal is to comprehend the impact of spatial averaging on general networks , we choose to proceed directly with simulations and compare the results with our analytical expressions for type i networks .    in the following analysis",
    ", we develop a basic understanding of what we would expect to see in the simulation results that are presented in section  [ sec : typeiiisimulation ] .",
    "we assume that the number of nodes in any given area of the type ii network is proportional to the area .",
    "the reason is that for uniformly deployed nodes with density @xmath144 , the average number of nodes in an area @xmath156 is @xmath157 . note that even though the analysis and simulation results for type ii networks use the assumption of a circular transmission range of @xmath28 , the simulation results in section  [ sec : typeiiisimulation ] still provide valid insight when realistic transmission regions  @xcite are assumed since the figures illustrate synchronization error as a function of _ hop _ number .",
    "therefore , regardless of the shape of the transmission region , a node at hop @xmath44 will have received the appropriate synchronization information and , thus , our simulation results reflect its synchronization performance .",
    "our first consideration is to estimate the number of hops , @xmath158 , required to communicate timing information from node @xmath2 to the edge of the network a distance @xmath145 away . in order to do this",
    ", we need a way to quantify @xmath147 . in fig .",
    "[ fig : type2dmax ] , we illustrate @xmath159 and see that @xmath159 is determined by having the intersection of the two radius @xmath28 circles contain an average of @xmath1 nodes .",
    "this is because if we increase @xmath159 , then nodes at this increased distance will not see @xmath1 nodes on average and , thus , not be considered an @xmath3 node .",
    "however , @xmath160 , for @xmath161 , because the ring occupied by the @xmath49 nodes increases in size for increasing @xmath44 . as a result",
    ", we choose to be conservative and let @xmath162 approximate @xmath147 for all @xmath44 .",
    "this means that our estimate of @xmath158 using @xmath163 will be greater than or equal to the number of hops required to reach a distance of @xmath145 when the differences in @xmath147 are considered .",
    "let @xmath164 be the area of the intersection of the two radius @xmath28 circles in fig .",
    "[ fig : type2dmax ] and we have from  @xcite that @xmath165 since @xmath164 contains @xmath1 nodes , we have that @xmath166 from ( [ eq : circsegarea ] ) and ( [ eq : aexpression ] ) we can numerically determine @xmath167 thus giving us @xmath168 as a result , we need @xmath158 to satisfy @xmath169 which means that @xmath170      we will compare the type ii network simulation results to the type i analytical results",
    ". this comparison will allow us to carry over the intuition regarding spatial averaging that we have developed for the basic cooperative network .",
    "however , type i and type ii networks differ primarily in that type i networks assume that all nodes will observe @xmath1 neighbors from the previous hop while any node in a type ii network will only see _ at least _",
    "@xmath1 nodes .",
    "thus , if we want to compare type i and type ii plots , we need to establish some meaningful choices of the number of cooperating nodes for use with expressions ( [ eq : alphahatki_alphaeq1 ] ) and ( [ eq : deltahatki_alphaeq1 ] ) .    looking at ( a ) of fig .",
    "[ fig : type2nbark ] , we see that if a node @xmath48 in the region occupied by the @xmath49 nodes is at the circular boundary farthest from node @xmath2 ( outer circular boundary ) , then it will likely hear only @xmath1 nodes from @xmath58 .",
    "that is , there are @xmath171 nodes in area @xmath172 .",
    "recall that @xmath1 is the minimum number of @xmath58 nodes any node @xmath48 will hear .",
    "however , looking at ( b ) in fig .",
    "[ fig : type2nbark ] , a node @xmath48 at the circular boundary closest to node @xmath2 ( inner circular boundary ) in the @xmath49 region will hear many more nodes .",
    "in fact , a node @xmath48 at the boundary between @xmath58 and @xmath49 will hear the largest average number of nodes @xmath173 .",
    "since @xmath1 and @xmath174 is the range of the number of cooperating nodes seen by a node in @xmath49 , it would make sense to plot type i expressions ( [ eq : alphahatki_alphaeq1 ] ) and ( [ eq : deltahatki_alphaeq1 ] ) using these two values .",
    "however , @xmath174 varies with @xmath44 . in fig .",
    "[ fig : type2nmax ] we illustrate the regions occupied by the @xmath49 nodes for @xmath175 , @xmath50 , and @xmath176 overlayed on top of each other and in each situation , we see that the set of nodes in @xmath49 seen by a node at the boundary between the @xmath49 nodes and the @xmath51 nodes is different for changing values of @xmath44 .",
    "however , it is clear that the area of intersection always falls inside a semicircle of radius @xmath28 . as a result , we will approximate @xmath177 , by upper bounding the maximum area of intersection with the area of the semicircle .",
    "this means that @xmath178 thus , in comparing type ii and type i results , we will use @xmath1 and @xmath179 in ( [ eq : nbarmax2 ] ) with both ( [ eq : alphahatki_alphaeq1 ] ) and ( [ eq : deltahatki_alphaeq1 ] )    using @xmath1 with ( [ eq : alphahatki_alphaeq1 ] ) and ( [ eq : deltahatki_alphaeq1 ] ) will provide a curve that tends to be higher than the type ii simulated curves for two main reasons .",
    "first , since @xmath1 is the minimum number of nodes in @xmath58 that a node @xmath48 in @xmath49 will hear and we know that a larger number of cooperating nodes will result in decreased estimation variance , the variance values computed using @xmath1 will tend to be higher .",
    "second , even if a node @xmath48 in @xmath49 hears @xmath1 nodes from @xmath58 , each of those @xmath1 nodes did not necessarily only hear @xmath1 nodes from @xmath180 .",
    "thus , the skew and offset estimates made by each of those @xmath1 nodes in @xmath58 whose transmissions are being heard by node @xmath48 may have a variance that is less than predicted by ( [ eq : alphahatki_alphaeq1 ] ) and ( [ eq : deltahatki_alphaeq1 ] ) using @xmath1 .",
    "the improved skew and offset estimates made by the nodes in @xmath58 will thus lead to a lower estimation variance for node @xmath48 even though node @xmath48 hears only @xmath1 from @xmath58 .    using @xmath179 with ( [ eq : alphahatki_alphaeq1 ] ) and ( [ eq : deltahatki_alphaeq1 ] ) will provide a curve that tends to be lower than the type ii simulated curves for two similar reasons .",
    "first , since @xmath179 is the average number of nodes heard by a node at the inner circular boundary of @xmath49 , @xmath181 , and all other nodes in @xmath49 will on average hear fewer nodes , a type i curve using @xmath179 will tend to yield lower values .",
    "second , not all nodes in @xmath58 make their estimates using a signal cooperatively generated by @xmath179 nodes . in fact , most nodes in @xmath58 observe fewer than @xmath179 nodes . as a result , the lower quality estimates made by some of the @xmath58 nodes will cause the estimation variance of the @xmath49 nodes that hear @xmath179 from @xmath58 to be greater than predicted by ( [ eq : alphahatki_alphaeq1 ] ) and ( [ eq : deltahatki_alphaeq1 ] ) using @xmath179 .",
    "the third issue we want to address in analyzing a type ii network deployment is how to decrease synchronization error when we know from section [ sec : estimatebarl ] that the number of hops @xmath158 required to communicate timing information from node @xmath2 to the edge of the network a distance @xmath145 away is determined by @xmath1 . given a fixed @xmath28 , we can start with some @xmath1 and @xmath144 . using ( [ eq : circsegarea ] ) , ( [ eq : aexpression ] ) , and ( [ eq : dmax2 ] )",
    ", we can determine the value of @xmath163 and , hence , from ( [ eq : barl2 ] ) the number of hops @xmath158 required to send timing information from node @xmath2 to the edge of the network . in order to decrease synchronization error at a distance @xmath145 from node @xmath2",
    ", we need to increase @xmath1 .",
    "however , only increasing @xmath1 will decrease @xmath163 and increase @xmath158 .",
    "therefore , we need to increase both @xmath1 and @xmath144 . from ( [ eq : circsegarea ] ) and ( [ eq : aexpression ] )",
    ", we see that if @xmath182 is kept constant , then @xmath167 will be constant .",
    "if @xmath167 is constant , then so is @xmath163 . as a result , by increasing node density , we can increase the minimum number of cooperating nodes @xmath1 and therefore decrease synchronization error .      in the following simulation results , we have assumed that all nodes in the network have no clock skew , i.e. @xmath135 for all @xmath12 . from section  [ sec : typeisimulation ]",
    "we know that general @xmath129 values result in variance curves that follow the trends established by curves generated using @xmath135 . as a result , using @xmath135 for all @xmath12 allows us to study the benefits of spatial averaging without considering effects that are dependent on the particular network realization .",
    "to being the study of cooperative time synchronization in general networks , we deploy a network for simulation @xmath2 with the parameters in table  [ tab : simulation1 ] .",
    ".simulation 1 parameters [ cols=\"^,^ \" , ]     [ tab : simulation3 ]    it is clear that by keeping the ratio @xmath182 constant while increasing @xmath1 and @xmath144 allows us to reduce the synchronization error at each hop while keeping the number of hops required to synchronize the network , @xmath158 , constant .",
    "the variance of the skew and offset estimates is decreased by increasing the minimum number of cooperating nodes .",
    "furthermore , from the simulations in this section , we find that the upper and lower type i comparison curves provide a good reference to the performance of type ii networks .",
    "we have established that the best and worst case variance values for the type ii skew and offset estimates fall between the upper and lower type i comparison curves . as the density of the network and @xmath1",
    "are both increased , the comparison curves will shift downwards and become closer together .",
    "thus , we would expect the variance of the type ii network estimates to change similarly with increasing @xmath1 and @xmath144 .",
    "in this paper we have proposed one technique that uses spatial averaging in dense networks as a means to improving global time synchronization .",
    "spatial averaging is used to improve the timing data points that are used to estimate clock skew and clock offset . by decreasing the error in the timing data points , improved clock skew and clock offset estimates can be made .",
    "our analysis of the technique in a basic cooperative network revealed that the error variance in both the clock skew and clock offset estimates can be significantly decreased as the number of cooperating nodes increases .",
    "simulation results also show that synchronization over large , multi - hop networks can be improved by increasing node density .",
    "further analysis and a comparison between cooperative and non - cooperative techniques can be found in  @xcite .",
    "this scalable protocol provides an alternate way to combat the scalability problem .",
    "it allows us to simply increase the number of nodes in the network to obtain improved synchronization performance .",
    "the new trade - off between network density and synchronization performance provided by spatial averaging will allow for added flexibility in designing future networks .",
    "it is important to note that the concept of spatial averaging is very general and our proposed cooperative technique is but one manner in which to take advantage of it .",
    "our protocol shows that techniques using spatial averaging can be designed .",
    "even though the proposed protocol has certain limitations , such as requiring access to the physical layer , it allows us to successfully illustrate the performance improvement achievable using spatial averaging .",
    "future work will focus on other approaches to spatial averaging .",
    "for example , it would be desirable to develop a cooperative technique using spatial averaging that achieves performance gains while needing only access to the data link or network layer .",
    "* proof of theorem  [ theorem : main ] * node @xmath2 begins the synchronization processes by transmitting a sequence of pulses at times @xmath183 , for @xmath184 . for simplicity , assume that @xmath33 and @xmath9 are integer values",
    ". note that since node @xmath2 transmits these pulses in its own time scale @xmath15 ( the reference time ) , the pulses will occur at integer values of @xmath185 . using the clock model in ( [ eq : clock ] )",
    ", any node @xmath37 , @xmath143 , in the @xmath35 set of nodes will get a vector of observations @xmath186 , where @xmath187 = \\alpha_{1i}(\\tau_{0}-\\bar{\\delta}_{1i})+\\psi_{1i,1}$ ] and the @xmath74th element of @xmath186 is @xmath188=\\alpha_{1i}(\\tau_{0}-\\bar{\\delta}_{1i})+ld\\alpha_{1i}+\\psi_{1i , l+1}$ ] .",
    "this can also be written as @xmath189 where @xmath190 = \\left [ \\begin{array}{c } \\alpha_{1i}(\\tau_{0}-\\bar{\\delta}_{1i})\\\\ \\alpha_{1i } \\end{array } \\right]\\ ] ] with @xmath79 as in ( [ eq : h ] ) and @xmath191^{t}$ ] . since @xmath192 is an independent gaussian random variable for each @xmath77 , @xmath193 with @xmath194 . as mentioned",
    ", this set of observations is for any node @xmath37 in the set of @xmath35 nodes .",
    "since we have @xmath1 @xmath35 nodes , we can write the vector of observations made by all @xmath35 nodes as @xmath195 where @xmath196 , \\quad \\bar{{\\mathbf \\theta}}_{1 } = \\left [ \\begin{array}{c } { \\mathbf \\theta}_{11 } \\\\ \\vdots \\\\ { \\mathbf \\theta}_{1\\bar{n } } \\end{array } \\right ] , \\quad \\bar{{\\mathbf w}}_{1}=\\left [ \\begin{array}{c } { \\mathbf w}_{11 } \\\\ \\vdots \\\\ { \\mathbf w}_{1\\bar{n } } \\end{array } \\right]\\end{aligned}\\ ] ] and @xmath197 is as in ( [ eq : barh ] ) . note that @xmath198 . this way we have @xmath199 as the vector of observations made by all @xmath35 nodes and we can make a umvu ( uniformly minimum variance unbiased ) estimate of @xmath200 by taking @xmath201 where @xmath202 it is easy to see that @xmath203\\end{aligned}\\ ] ] and @xmath204.\\end{aligned}\\ ] ] this establishes the initial conditions for the theorem .",
    "@xmath205 is a @xmath82 column vector where the subvector made up of the ( @xmath105)th and ( @xmath103)th elements , @xmath143 , is @xmath206 .",
    "therefore , any node @xmath37 s skew estimate ( [ eq : alphahat ] ) and offset estimate ( [ eq : deltahat ] ) can be found from @xmath205 as @xmath207 and @xmath208 where @xmath76 is the column vector of all zeros except for a one in the @xmath77th position .",
    "each node @xmath37 can now make an estimate of the next appropriate integer value of @xmath185 , in this case @xmath209 , by making a minimum variance unbiased estimate of @xmath210 .",
    "this can be done with the estimator @xmath211 where @xmath212 $ ] .",
    "this will then be node @xmath37 s estimate of the next appropriate integer value of @xmath185 in its own time scale @xmath213 .",
    "from ( [ eq : pulsetimeestimate ] ) , every node @xmath37 will then transmit a sequence of @xmath8 pulses occurring , in the time scale of @xmath213 , at @xmath214 , for @xmath184 . using the clock model ( [ eq : clock ] )",
    ", we find that in the time scale of @xmath15 these pules occur at @xmath215 any node @xmath216 in the @xmath3 set of nodes that can hear node @xmath37 will thus get a sequence of pulses @xmath217 } \\\\ & = & \\alpha_{2j}\\bigg(\\bigg(\\frac{\\hat{\\tau}_{1i}}{\\alpha_{1i}}+ \\bar{\\delta}_{1i } + ld\\frac{\\hat{\\theta}_{1i,2}}{\\alpha_{1i}}- \\frac{\\psi_{1i , l+1}}{\\alpha_{1i}}\\bigg)-\\bar{\\delta}_{2j}\\bigg ) \\\\ & & \\hspace{2.5cm}+\\psi_{2j , l+1},\\end{aligned}\\ ] ] where @xmath184 .    in this type",
    "i network deployment every node @xmath216 hears the same set of @xmath1 nodes and takes the sample mean of each cluster of pulses for its observation , we can express the actual vector of observations made by node @xmath216 as @xmath218 } \\\\ & = & \\sum_{i=1}^{\\bar{n } } \\frac{\\alpha_{2j}}{\\bar{n}}\\bigg(\\bigg(\\frac{\\hat{\\tau}_{1i}}{\\alpha_{1i}}+ \\bar{\\delta}_{1i } + ld\\frac{\\hat{\\theta}_{1i,2}}{\\alpha_{1i}}- \\frac{\\psi_{1i , l+1}}{\\alpha_{1i}}\\bigg)-\\bar{\\delta}_{2j}\\bigg)\\\\ & & \\hspace{2.5cm}+\\psi_{2j , l+1},\\end{aligned}\\ ] ] where @xmath184 . note",
    "that since these pulse arrivals are clustered , we assume that for a given cluster , each pulse arrival is corrupted by the same jitter .",
    "thus , receiver side jitter @xmath219 is an independent sample for every @xmath77 , but takes the same value for each @xmath12 .",
    "this models the fact that clock errors occurring in a small time window are highly correlated while errors farther apart in time are independent .",
    "we can rewrite this simply as @xmath220 = \\alpha_{2j}((\\tau_{1}+ld\\tilde{\\alpha}_{1}-\\tilde{\\psi}_{1,l+1})-\\bar{\\delta}_{2j})+\\psi_{2j , l+1}$ ] , where @xmath221 since every node @xmath216 will see the same @xmath1 , this means that every node @xmath216 will have the same @xmath222 and @xmath223 .",
    "therefore , @xmath222 and @xmath223 are now fixed , and it can be easily found that @xmath224 \\sim { \\mathcal n}\\bigg(0,\\sigma_{\\tilde{\\psi}_{1}}\\bigg)\\ ] ] where @xmath225    node @xmath216 s vector of observations can also be written in a linear form similar to ( [ eq : linearformcoop ] ) , @xmath226 , where @xmath227 = \\left [ \\begin{array}{c } \\alpha_{2j}(\\tau_{1}-\\bar{\\delta}_{2j})\\\\ \\alpha_{2j}\\tilde{\\alpha}_{1 } \\end{array } \\right]\\ ] ] with @xmath79 as in ( [ eq : h ] ) and @xmath228^{t}$ ] . @xmath229+\\left",
    "[ \\begin{array}{c } \\psi_{2j,1 } \\\\ \\vdots \\\\ \\psi_{2j , m } \\end{array}\\right]\\sim { \\mathcal n}(0,\\sigma_{2j})\\ ] ] with @xmath230 the vector of observations made by all @xmath3 nodes can be written in a manner similar to ( [ eq : r1bigyvec ] ) , @xmath231 where @xmath232 ,",
    "\\quad \\bar{{\\mathbf \\theta}}_{2 } = \\left [ \\begin{array}{c } { \\mathbf \\theta}_{21 } \\\\ \\vdots \\\\ { \\mathbf \\theta}_{2\\bar{n } } \\end{array } \\right ] , \\quad { \\mathbf q}_{2 } = \\left [ \\begin{array}{c } \\alpha_{21}{\\mathbf i}_{m } \\\\ \\vdots \\\\",
    "\\alpha_{2\\bar{n}}{\\mathbf i}_{m } \\end{array } \\right]\\end{aligned}\\ ] ] @xmath233={\\mathbf q}_{2}\\left [ \\begin{array}{c } \\tilde{\\psi}_{1,1 } \\\\ \\vdots \\\\ \\tilde{\\psi}_{1,m } \\end{array}\\right]+\\left [ \\begin{array}{c } \\psi_{21,1 } \\\\ \\vdots \\\\ \\psi_{21,m } \\\\ \\vdots \\\\ \\psi_{2\\bar{n},1 } \\\\ \\vdots \\\\",
    "\\psi_{2\\bar{n},m } \\end{array}\\right]\\ ] ] this means that @xmath234 , where @xmath235    the @xmath3 nodes will estimate @xmath236 as @xmath237 however , for analysis , this does not give us the complete distribution of @xmath238 since @xmath239 is a function of @xmath240 .",
    "therefore , we first consider how @xmath241 is a function of @xmath240 .",
    "we find that @xmath242 \\nonumber \\\\ & = & \\left [ \\begin{array}{c } \\alpha_{2j}(\\frac{1}{\\bar{n}}\\sum_{i=1}^{\\bar{n}}\\frac{\\hat{\\tau}_{1i}}{\\alpha_{1i}}+ \\bar{\\delta}_{1i}-\\bar{\\delta}_{2j})\\\\ \\alpha_{2j}\\frac{1}{\\bar{n}}\\sum_{i=1}^{\\bar{n}}\\frac{\\hat{\\theta}_{1i,2}}{\\alpha_{1i } } \\end{array } \\right ] \\nonumber \\\\ & = & \\left [ \\begin{array}{c } \\alpha_{2j}(\\frac{1}{\\bar{n}}\\sum_{i=1}^{\\bar{n}}\\frac{\\hat{\\theta}_{1i,1}+md\\hat{\\theta}_{1i,2}}{\\alpha_{1i}}+ \\bar{\\delta}_{1i}-\\bar{\\delta}_{2j})\\\\ \\alpha_{2j}\\frac{1}{\\bar{n}}\\sum_{i=1}^{\\bar{n}}\\frac{\\hat{\\theta}_{1i,2}}{\\alpha_{1i } } \\end{array } \\right ] \\nonumber \\\\ & = & \\frac{\\alpha_{2j}}{\\bar{n}}\\sum_{i=1}^{\\bar{n}}\\bigg(\\left [ \\begin{array}{cc } \\frac{1}{\\alpha_{1i } } & \\frac{dm}{\\alpha_{1i } } \\\\ 0 & \\frac{1}{\\alpha_{1i } } \\end{array } \\right ] \\left [ \\begin{array}{c } \\hat{\\theta}_{1i,1 } \\\\ \\hat{\\theta}_{1i,2 } \\end{array } \\right ] \\nonumber \\\\ & & \\hspace{1.5 cm } + \\left [ \\begin{array}{c } \\bar{\\delta}_{1i } \\\\ 0 \\end{array } \\right ] \\bigg ) - \\alpha_{2j}\\left [ \\begin{array}{c } \\bar{\\delta}_{2j } \\\\ 0 \\end{array } \\right]\\end{aligned}\\ ] ] using ( [ eq : theta2iasfxnoftheta1hat ] ) we have @xmath243 where @xmath244,\\end{aligned}\\ ] ] @xmath245 - \\left [ \\begin{array}{c } \\alpha_{21}\\bar{\\delta}_{21 } \\\\ 0 \\\\ \\vdots \\\\ \\alpha_{2\\bar{n}}\\bar{\\delta}_{2\\bar{n } } \\\\ 0 \\end{array}\\right],\\end{aligned}\\ ] ] for @xmath246.\\end{aligned}\\ ] ]    using ( [ eq : theta2barhat ] ) and ( [ eq : theta2asfxnoftheta1hat ] ) , the distribution of @xmath238 can now be found .",
    "@xmath247\\end{aligned}\\ ] ] using the decomposition @xmath248 we have from ( [ eq : theta2barhat ] ) and ( [ eq : theta2asfxnoftheta1hat ] ) @xmath249 @xmath250 giving us @xmath251 thus , the distribution of @xmath238 is @xmath252 @xmath238 is again a @xmath82 column vector where the subvector made up of the ( @xmath105)th and ( @xmath103)th elements , @xmath143 , is @xmath253 .",
    "therefore , as in ( [ eq : alphahat1i ] ) and ( [ eq : deltahat1i ] ) , any node @xmath42 s skew estimate ( [ eq : alphahat ] ) and offset estimate ( [ eq : deltahat ] ) can be found from @xmath254 as @xmath255 and @xmath256    each node @xmath42 will now be able to transmit a sequence of @xmath8 pulses occurring , in the time scale of @xmath257 , at @xmath258 , for @xmath184 , where @xmath259 . repeating the same process we carried out for the observations of any node @xmath216 with any node @xmath260 , we can find @xmath261 .",
    "in fact , continuing this procedure , we can find the distribution of @xmath85 for the @xmath49 nodes as @xmath262 where similar to ( [ eq : mu2 ] ) we have @xmath263 which is found in ( [ eq : muk ] ) and similar to ( [ eq : sigma2 ] ) we have @xmath264 which is found in ( [ eq : sigmak ] ) .",
    "@xmath265 , @xmath115 , @xmath266 , and @xmath267 are as in the theorem statement . as in ( [ eq : alphahat2i ] ) and ( [ eq : deltahat2i ] ) , any node @xmath48 s skew estimate ( [ eq : alphahat ] ) and offset estimate ( [ eq : deltahat ] ) can be found from @xmath113 as @xmath268 and @xmath269 this concludes the proof of theorem  [ theorem : main ] ."
  ],
  "abstract_text": [
    "<S> time synchronization is an important aspect of sensor network operation . </S>",
    "<S> however , it is well known that synchronization error accumulates over multiple hops . </S>",
    "<S> this presents a challenge for large - scale , multi - hop sensor networks with a large number of nodes distributed over wide areas . in this work </S>",
    "<S> , we present a protocol that uses spatial averaging to reduce error accumulation in large - scale networks . </S>",
    "<S> we provide an analysis to quantify the synchronization improvement achieved using spatial averaging and find that in a basic cooperative network , the skew and offset variance decrease approximately as @xmath0 where @xmath1 is the number of cooperating nodes . for general networks , simulation results and a comparison to basic cooperative network results </S>",
    "<S> are used to illustrate the improvement in synchronization performance .    </S>",
    "<S> ( 0,0 ) ( 0,55)submitted to the ieee / acm transactions on networking , october 2006 . </S>"
  ]
}