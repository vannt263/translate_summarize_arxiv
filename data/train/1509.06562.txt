{
  "article_text": [
    "spanning tree problems with constraints and/or objective functions concerning the degrees of the vertices in the tree arise very often in the context of communication networks . in this paper",
    "we deal with the problem of finding spanning trees which minimize the number of branch vertices ( vertices with degree greater than two ) , known in the literature as the _ minimum branch vertices problem _ ( mbv ) .    the mbv was introduced in gargano _",
    "et al . _",
    "@xcite , motivated by the context of optical networks using a technology which allows a specific type of switch to replicate a signal by splitting light .",
    "such a switch is required if a connection arrives at a given vertex of the network and has to be multicasted to different vertices .",
    "therefore , a branch vertex in a network tree would imply the use of such a sophisticated switch .",
    "however , the availability of these switches is usually limited due to their costs , and one is asked to minimize their need in a network topology .",
    "several authors studied different theoretical properties concerning the number of branch vertices in a graph .",
    "et al . _",
    "@xcite showed the problem to be np - hard , besides some additional complexity results .",
    "they also considered bounds on the number of branch vertices and certain algorithmic and combinatorial aspects regarding the existence of structures such as spanning spiders ( trees with at most one branch vertex ) .",
    "et al . _",
    "@xcite give bounds on the number of branch vertices in claw - free graphs .",
    "chimani and spoerhase  @xcite developed a 6/11-approximation algorithm for the complement of the mbv , namely the maximum path - node spanning tree problem , which aims at finding a spanning tree maximizing the number of vertices with degree at most two .",
    "different integer programming and heuristic approaches were proposed to the mbv .",
    "et al . _",
    "@xcite studied integer programming formulations and a lagrangian relaxation approach able to generate good feasible solutions .",
    "et al . _",
    "@xcite showed the relation between three problems : the minimum branch vertices , the minimum degree sum problem and the minimum leaves problem .",
    "they also presented an evolutionary algorithm which could be applied to these problems .",
    "et al . _",
    "@xcite proposed three heuristics to the problem , exploiting vertex weighting , vertex coloring , and an approach combining the previous two .",
    "et al . _",
    "@xcite proposed an iterative refinement local search procedure .",
    "et al . _",
    "@xcite used a constructive heuristic based on breadth - first search , together with some changes in the procedure described in  @xcite .",
    "ncan  @xcite proposed inequalities to improve the linear relaxation bounds obtained with a polynomial size integer programming formulation to the problem . rossi _",
    "et al . _",
    "@xcite implemented a hybrid approach , combining a branch and cut algorithm with a tabu search heuristic , which could be applied to the mbv and to the minimum degree sum problem .",
    "computational experiments showed that their approach outperformed the other integer programming techniques available in the literature .",
    "very recently , marn  @xcite proposed a preprocessing technique , valid inequalities and a heuristic algorithm , which combined could solve to optimality several instances used in the literature .",
    "our work aims at the development of an effective approach to solve the mbv .",
    "the remainder of the paper is organized as follows .",
    "section [ sec : problem ] gives a formal statement of the problem together with an integer programming formulation containing an exponential number of inequalities . in section [ sec : lowerbound ] we give a simple algorithm to derive a combinatorial lower bound , which also determines important information that will be used in our graph decomposition approach . in section [ sec : graphdecomposition ] we present the decomposition method , which aims at dividing the problem into several smaller subproblems that are hopefully more manageable computationally .",
    "two constructive heuristics , which try to take advantage of the problem s structure and of what is expected of a good solution , are described in section [ sec : heuristics ] . in section [ sec :",
    "computation ] , we present computational results considering the proposed approaches together with a branch and cut algorithm using the formulation described in section [ sec : problem ] .",
    "some final remarks are discussed in section [ sec : finalremarks ] .",
    "let @xmath0 be a simple , connected , undirected graph with a set @xmath3 of vertices and a set @xmath4 of edges .",
    "denote @xmath5 the degree of @xmath6 in @xmath2 .",
    "a vertex @xmath6 is a branch vertex if it has degree greater than two , i.e. @xmath7 .",
    "given the graph @xmath2 , the _ minimum branch vertices problem _ ( mbv ) consists in finding a spanning tree @xmath1 , with @xmath8 , minimizing the number of branch vertices .",
    "we now present an integer programming formulation for the problem containing an exponential number of constraints .",
    "consider the variables : @xmath9 @xmath10 using the variables just described , the mbv can be formulated as : @xmath11 the objective function ( [ obj ] ) minimizes the number of branch vertices",
    ". constraints ( [ const-01 ] ) specify that exactly @xmath12 edges are selected . constraints ( [ const-02 ] ) are subtour elimination constraints ; note that we only need to consider subsets @xmath13 such that @xmath14 .",
    "constraints ( [ const-03 ] ) set the branch vertex variable associated to vertex @xmath15 to one in case more than two edges are incident to @xmath15",
    ". constraints ( [ const-04 ] ) are integrality requirements on the variables .",
    "it is worth mentioning that we can fix the @xmath16 variable at zero for any vertex @xmath6 with degree lower or equal to two .",
    "in this section , we present an algorithm to calculate a combinatorial lower bound to the mbv problem , which also determines some important data to be used in a graph decomposition approach .",
    "let @xmath17 be the minimum number of branch vertices in any spanning tree of @xmath2 .",
    "an articulation point ( or cut vertex ) is a vertex whose removal from the graph increases the number of components in the graph .",
    "a straightforward lower bound @xmath18 on the value of @xmath17 can be calculated based on a simple observation of gargano et al .",
    "@xcite : any articulation point whose removal induces at least three connected components is necessarily a branch vertex in any spanning tree of @xmath2 .",
    "we denote such vertices _ obligatory branches _ and define @xmath19 to be the set of obligatory branches of @xmath2 .",
    "let @xmath20 be the subgraph of @xmath2 obtained by removing the vertex @xmath15 together with all its incident edges .",
    "we denote by @xmath21 the number of connected components of @xmath20 .",
    "note that @xmath22 for an articulation point @xmath15 , while @xmath23 for any obligatory branch .",
    "algorithm  [ alg : lowerbound ] calculates the lower bound @xmath18 on the number of branch vertices , the set of obligatory branches @xmath19 and the value of @xmath21 for every obligatory branch @xmath24 .",
    "@xmath25 @xmath26 list of articulation points in @xmath2 @xmath27 number of connected components of @xmath20 @xmath28 @xmath29 @xmath30    algorithm [ alg : lowerbound ] runs in @xmath31 .",
    "the list of articulation points @xmath32 can be obtained in step 2 using a depth - first search ( dfs ) algorithm augmented with the opening time of each vertex , _",
    "i.e. _ its visiting index in the dfs tree . in particular",
    ", we identify an _ articulation _ at a given vertex @xmath33 if , when the search at a neighbor @xmath15 returns , the oldest index ( opened the earliest ) reachable from @xmath15 is no smaller than the opening time of @xmath33 .",
    "finding @xmath34 articulations at a vertex means that the search started from it @xmath34 times , and that @xmath35 components are left after removing it , which is precisely the information used later in step 4 .",
    "the dfs algorithm runs in @xmath31 when an adjacency list is used .",
    "the * for * loop ( lines 3 - 9 ) is executed @xmath36 times , and all operations within it are performed in constant order of complexity . therefore the algorithm runs in @xmath37 @xmath38 @xmath39 .",
    "given that the mbv problem is np - hard , one should note that the lower bound obtained using algorithm [ alg : lowerbound ] is not necessarily tight .",
    "it is actually possible to find situations in which this occurs even for very small graphs .",
    "for instance , consider the graph illustrated in figure [ fig : exampleboundnottight ] , which does not have any obligatory branch vertex .",
    "nevertheless , it is not difficult to check that either @xmath40 or @xmath41 should be a branch vertex in a spanning tree of the considered graph .",
    "in this section , we present a graph decomposition approach to the minimum branch vertices problem based on two different properties of a graph . the first one is grounded on the existence of obligatory branch vertices .",
    "the second builds on the existence of cut edges ( or bridges ) : an edge whose removal increases the number of connected components of a graph .",
    "this decomposition approach aims at dividing the original mbv problem into smaller subproblems , that can be solved separately and then recombined in order to generate a solution to the original problem .",
    "we remark that marn  @xcite proposed a preprocessing routine , which included the identification of cut edges , but that information was not used in a decomposition method by the author .",
    "this first decomposition is based on the fact that an obligatory branch @xmath42 is going to be a branch vertex in any spanning tree of a graph @xmath2 . starting from @xmath0 , we build a new graph @xmath43 as follows .",
    "initially , @xmath44 and @xmath45 , such that @xmath46 .",
    "next , for each obligatory branch @xmath24 , create @xmath21 new vertices @xmath47 and add them to @xmath48 .",
    "let @xmath49 be the set of vertices to which @xmath15 is adjacent in the @xmath50 connected component of the subgraph @xmath20 . for each @xmath51",
    ", create in @xmath52 edges from @xmath53 to every vertex in @xmath49 .",
    "after that , remove @xmath15 from @xmath48 and all its adjacent edges from @xmath52 .",
    "the obligatory branches based decomposition is illustrated in figure [ fig : decompositionoblbr ] for a graph with two obligatory branches .",
    "this decomposition is based on the fact that every cut edge must be in any spanning tree of @xmath2 .",
    "starting from a graph @xmath0 , let @xmath54",
    ".    a new graph @xmath55 can be obtained from @xmath2 by removing from @xmath4 every edge @xmath56 . for the sake of correctness of the formulation for each resulting subproblem defined over @xmath55 ( see section [ sec : decomposed - problem ] ) , we need the information of _ extra degree _ corresponding to both end vertices of the cut edges removed in @xmath55 .",
    "let @xmath57 be the _ extra degree _ of a vertex @xmath15 , which corresponds to the number of cut edges @xmath56 incident to @xmath15 in the initial graph @xmath2 .",
    "the cut edges based decomposition is illustrated in figure [ fig : decompositioncutedges ] for a graph with two cut edges .",
    "we now give an integer programming formulation aimed at solving each component of the decomposed problem as an independent subproblem .",
    "let @xmath58 be the resulting graph after performing the obligatory branches and cut edges based decompositions .",
    "observe that @xmath59 is disconnected in case at least one obligatory branch or one cut edge was found .",
    "let @xmath60 be the number of connected components in @xmath59 , and @xmath61 be the @xmath62 connected subgraph of @xmath59 , with @xmath63 .",
    "define the set @xmath64 .",
    "a formulation for each of the @xmath65 connected components can be obtained as :    @xmath66    an optimal solution to the minimum branch vertices problem can be obtained from the solutions of the @xmath60 connected components of @xmath59 and its optimal value is @xmath67    by definition , each obligatory branch should contribute with one unit to the objective function @xmath68 . since they are not considered in the decomposed objective functions @xmath69 , the @xmath70 units have to be added to @xmath68 .    since every cut edge @xmath56 must be in the spanning tree",
    ", the values @xmath71 and @xmath57 of its incident vertices will guarantee that the additional degree corresponding to these edges will be taken into account in @xmath72 .",
    "considering an obligatory branch @xmath15 , there are no edges linking vertices between two different components in the original graph without @xmath15 , i.e. @xmath20 . therefore the different components of @xmath20 directly implied by the removal of @xmath15 have to be connected through the edges incident to @xmath15 in @xmath2 .    in every connected component @xmath73",
    ", we obtain a spanning tree minimizing the number of branch vertices , disregarding the obligatory branches implied by @xmath19 .",
    "the different trees will be connected to the other components in the original graph via either the obligatory branch vertices or the cut edges .",
    "the resulting forest implies thus a spanning tree with minimum number of branch vertices in the original graph @xmath2 .",
    "we noted that the heuristics available in the literature for the mbv do not take advantage of the problem s structure in order to generate good feasible solutions .",
    "instead , they concentrate into the improvement of available solutions .",
    "we present two simple constructive heuristic algorithms to the mbv that take the structure of the problem into consideration in an attempt to obtain high quality solutions .",
    "the key observation is the fact that in an ideal situation ( one in which no branch vertices are necessary ) , the optimal spanning tree to the problem should be a branch vertex free solution , i.e. a hamiltonian path .",
    "observe also that good solutions will tend to have paths that are as long as possible connected to each other via some branch vertices .",
    "the two constructive heuristics presented in this section take this into consideration .",
    "the basic idea of the path expanding heuristic is to , starting from a tree @xmath74 with a single vertex , constructively turn @xmath74 into a spanning tree by expanding paths already in @xmath74 .",
    "the algorithm has two main components , namely a _",
    "start - restart _ in which a new vertex is selected as source of a new path and a _ path expansion _ in which new vertices are added to the path being expanded .",
    "the greedy criteria for the two components are :    * start - restart ( enumerated in order of priority ) : 1 .",
    "obligatory branch vertex ; 2 .",
    "vertex whose degree is already greater than two in the tree ; 3 .",
    "vertex with the largest number of neighbors which are still not in the tree ; * path expansion : vertex , adjacent to the latest one added to the tree , with the smallest number of neighbors which are still not in the tree .",
    "the heuristic is presented in algorithm [ alg : pathexpanding ] and it works as follows .",
    "start the tree with a vertex selected according to the start - restart greedy criterion .",
    "build a path starting at a vertex already belonging to the partial tree , selecting the next vertices in this path according to the path expansion criterion until it can no longer be expanded .",
    "if there are still vertices not belonging to the tree , another vertex with unvisited neighbors in the partial tree is selected and a new path is constructed starting from the current tree .",
    "the algorithm is illustrated in figure  [ fig : pathexpanding ] .",
    "@xmath74    algorithm [ alg : pathexpanding ] runs in @xmath75 .",
    "a single evaluation of the start - restart or the path expansion criteria can be done in time proportional to @xmath76 , as it requires checking information available at each vertex . in particular , note that checking the number of neighboring vertices which are still not in the tree , _",
    "e.g. _ the last start - restart criterion and the inner loop condition , can be kept at constant asymptotic complexity , provided that we update this information when the tree is grown .    the number of iterations of the outer and the inner * while * loops depends on the particular graph ,",
    "but they sum to @xmath12 since these correspond to the selection of edges in a spanning tree .",
    "therefore , the execution includes @xmath12 steps , each requiring an @xmath76 evaluation ( either start - restart or path expansion ) and @xmath76 operations to update the aforementioned information on the remaining vertices .",
    "the algorithm thus runs in time proportional to @xmath77 .",
    "the multi - path expanding heuristic differs from the path expanding heuristic in the fact that it allows the expansion of any of the paths being expanded at a given moment .",
    "it also has a start - restart component , which is the same for the path - expanding heuristic .",
    "the multi - path expansion component uses the following greedy criterion :    * multi - path expansion : vertex , adjacent to any vertex belonging to the tree , with the smallest number of neighbors which are still not in the tree .",
    "the multi - path expanding heuristic is presented in algorithm [ alg : multipathexpanding ] and it works in the following way .",
    "start the tree with a given vertex , selected according to the start - restart greedy criterion , which forms the list of candidates for path expansion .",
    "continue selecting a vertex adjacent to one of the candidates for path expansion according to the multi - path expansion greedy criterion , add the new vertex to the list of candidates and remove the current candidate from the list of candidates when appropriate . if there are no more vertices , which are still not in the tree , adjacent to the candidates and if the tree is still not a spanning tree , select another vertex to add to the list of candidates .",
    "the algorithm is illustrated in figure  [ fig : multipathexpanding ] .",
    "@xmath74    algorithm [ alg : multipathexpanding ] runs in @xmath75 .",
    "the analysis is analogous to that for algorithm [ alg : pathexpanding ] .",
    "the main difference is that , to keep the multi - path expansion test in @xmath76 time , we need to store the additional information of whether a given unvisited vertex is adjacent to one in the tree .",
    "this can be included in the structure update without increasing its asymptotic complexity .",
    "the operations introduced due to the _ candidates _ set are done in constant order of complexity .",
    "again , there is a total of @xmath78 iterations considering both * while * loops , each selecting a new edge in the tree . when needed , choosing a vertex to enter the set of candidates is done following the same start - restart criterion , in time @xmath76 . in the inner loop ,",
    "both the multi - path expansion and the updating step require @xmath76 time .",
    "therefore , the algorithm requires computational time proportional to @xmath77 .",
    "the main goal of our computational experiments is to assess the effectiveness of the methods proposed in this paper .",
    "the branch and cut algorithm presented by rossi et al .",
    "@xcite is based on the formulation ( [ obj])([const-04 ] ) , and it is a _ state - of - the - art _ among exact approaches to solve the mbv  .",
    "we implemented our own branch and cut algorithm using the formulation ( [ obj])([const-04 ] ) , and refer to it as the _",
    "plain algorithm_. our main results compare it against one variant developed on top of the decomposition and primal heuristics we proposed in previous sections : henceforth , the _ enhanced algorithm _ , using formulation ( [ dec - obj])([dec-04 ] ) .",
    "the algorithms are implemented in _",
    "c++ _ , using the callback mechanism in the concert api of cplex 12.6 .",
    "since the objective function is integer - valued for all the available instances , we set the parameter regarding the absolute mip gap tolerance to @xmath79 ; all remaining options are used as default .",
    "also , the best solution among the path - expanding and the multi - path - expanding heuristics is given as a mip start to the solver .",
    "experiments were carried out on a machine with an intel core i7 - 4790k ( 4.00ghz ) cpu , with 16 gb of ram .",
    "a time limit of one hour ( 3600s wall clock ) was imposed for every execution .",
    "we remark that the whole procedure consisting of the decomposition and the constructive methods runs immediately for all the available benchmark instances .",
    "considering any of those instances , the decomposed integer programming ( ip ) models and heuristic solutions were created in less than @xmath80 seconds .",
    "most papers on the mbv use the large benchmark set of carrabs et al .",
    "@xcite , which includes 525 instances .",
    "section [ sec : xp - carrabs ] reports results using that benchmark .",
    "nevertheless , silva et al .  @xcite",
    "introduced different sets of instances ; for the sake of completeness , we discuss in section [ sec : xp - silva ] the effectiveness of the procedures using those problem sets as well .      we describe next our computational results using the standard benchmark of carrabs et al .",
    "@xcite , which was also used in  @xcite .",
    "the instances are identified as ` spd_rf2_n_m_r ` , in which @xmath81 stands for the number of vertices , @xmath82 for the number of edges , and @xmath83 the seed used to randomly generate the edges of the graph .",
    "we start by describing the effect of the decomposition and comparing the plain and enhanced algorithms .",
    "table [ tab : openinstances ] presents the results for all instances for which an optimal solution was not found by the plain algorithm within the one hour time limit .",
    "the second and third columns indicate the number of obligatory branches ( ob ) and cut edges ( ce ) removed using the decomposition algorithm .",
    "the next three columns concern the enhanced algorithm , and show the best lower and upper bounds and the remaining open gap ( in % ) between them at the end of the execution .",
    "the last three columns give the same information for the plain algorithm .",
    "we also show the time taken for the enhanced algorithm to solve the instances to optimality ( the value 3600 is shown in case the instance remained unsolved at the end of the time limit ) .",
    "the arithmetic mean is used for average values .    in the comparison ,",
    "we argue in favor of the enhanced algorithm for two main reasons .",
    "first , it is consistently superior in finding better solutions for the mbv . note that the enhanced algorithm yields a smaller duality gap in 48 out of 50 instances ( @xmath84 ) .",
    "in fact , it is able to close the gap of 39 among these instances ( @xmath85 ) .",
    "@lcccccccccccc@     + & & & & & + & ob & ce & & lb & ub & gap ( % ) & time ( s ) & & lb & ub & gap ( % ) +     + & & & & & + & ob & ce & & lb & ub & gap ( % ) & time ( s ) & & lb & ub & gap ( % ) + ` spd_rf2_400_519_4731 ` & 52 & 155 & & 70 & 70 & 0 & 227.9 & & 67.66 & 70 & 3.3 + ` spd_rf2_450_548_4915 ` & 68 & 205 & & 89 & 89 & 0 & 324.4 & & 88.00 & 89 & 1.1 + ` spd_rf2_450_581_4947 ` & 59 & 178 & & 76.38 & 80 & 4.5 & 3600.0 & & 75.86 & 80 & 5.2 + ` spd_rf2_450_581_4963 ` & 61 & 178 & & 77 & 77 & 0 & 125.8 & & 75.81 & 78 & 2.8 + ` spd_rf2_450_614_4979 * ` & 45 & 149 & & 64.35 & 67 & 4.0 & 3600.0 & & 64.34 & 66 & 2.5 + ` spd_rf2_450_614_5003 ` & 44 & 153 & & 67 & 67 & 0 & 901.8 & & 64.55 & 68 & 5.1 + ` spd_rf2_500_603_5091 ` & 90 & 264 & & 109 & 109 & 0 & 176.1 & & 107.37 & 109 & 1.5 + ` spd_rf2_500_672_5171 ` & 58 & 180 & & 79.72 & 82 & 2.8 & 3600.0 & & 78.24 & 81 & 3.4 + ` spd_rf2_500_672_5179 ` & 52 & 171 & & 75.45 & 77 & 2.0 & 3600.0 & & 73.83 & 78 & 5.3 + ` spd_rf2_500_672_5187 * ` & 47 & 155 & & 69.51 & 72 & 3.5 & 3600.0 & & 69.53 & 71 & 2.1 + ` spd_rf2_500_672_5195 ` & 57 & 171 & & 77 & 77 & 0 & 2128.6 & & 75.69 & 78 & 3.0 + ` spd_rf2_500_672_5203 ` & 57 & 173 & & 74.58 & 76 & 1.9 & 3600.0 & & 73.47 & 78 & 5.8 + ` spd_rf2_600_749_5355 ` & 136 & 370 & & 143 & 143 & 0 & 462.7 & & 142.00 & 143 & 0.7 + ` spd_rf2_700_821_5523 ` & 164 & 467 & & 182 & 182 & 0 & 12.6 & & 180.71 & 183 & 1.3 + ` spd_rf2_700_861_5563 ` & 151 & 437 & & 159.67 & 161 & 0.8 & 3600.0 & & 159.72 & 161 & 0.8 + ` spd_rf2_700_902_5579 ` & 143 & 408 & & 152 & 152 & 0 & 1106.3 & & 150.73 & 153 & 1.5 + ` spd_rf2_700_902_5595 ` & 143 & 401 & & 153 & 153 & 0 & 130.7 & & 151.86 & 154 & 1.4 + ` spd_rf2_800_886_5659 ` & 212 & 601 & & 227 & 227 & 0 & 10.5 & & 225.67 & 228 & 1.0 + ` spd_rf2_800_930_5715 ` & 200 & 549 & & 212 & 212 & 0 & 49.0 & & 209.42 & 213 & 1.7 + ` spd_rf2_800_973_5747 ` & 183 & 506 & & 197 & 197 & 0 & 3461.6 & & 194.36 & 198 & 1.8 + ` spd_rf2_800_973_5763 ` & 179 & 504 & & 195 & 195 & 0 & 1057.0 & & 191.11 & 197 & 3.0 + ` spd_rf2_800_1017_5771 ` & 164 & 470 & & 176 & 176 & 0 & 1208.5 & & 173.50 & 178 & 2.5 + ` spd_rf2_800_1017_5779 ` & 158 & 467 & & 173 & 173 & 0 & 2375.2 & & 171.25 & 173 & 1.0 + ` spd_rf2_800_1017_5787 ` & 165 & 468 & & 178 & 178 & 0 & 108.6 & & 175.71 & 181 & 2.9 + ` spd_rf2_900_989_5859 ` & 238 & 688 & & 259 & 259 & 0 & 63.7 & & 254.08 & 259 & 1.9 + ` spd_rf2_900_1034_5891 ` & 228 & 640 & & 242 & 242 & 0 & 23.9 & & 238.78 & 243 & 1.7 + ` spd_rf2_900_1034_5907 ` & 220 & 621 & & 239 & 239 & 0 & 1411.3 & & 236.19 & 240 & 1.6 + ` spd_rf2_900_1034_5915 ` & 228 & 642 & & 242 & 242 & 0 & 466.1 & & 238.99 & 243 & 1.7 + ` spd_rf2_900_1079_5931 ` & 206 & 579 & & 222 & 222 & 0 & 332.6 & & 218.77 & 223 & 1.9 + ` spd_rf2_900_1079_5939 ` & 207 & 580 & & 224 & 224 & 0 & 349.5 & & 220.67 & 226 & 2.4 + ` spd_rf2_900_1079_5947 ` & 210 & 582 & & 226 & 226 & 0 & 888.0 & & 220.81 & 230 & 4.0 + ` spd_rf2_900_1079_5963 ` & 205 & 588 & & 222 & 222 & 0 & 27.9 & & 218.52 & 223 & 2.0 + ` spd_rf2_900_1124_5971 ` & 198 & 543 & & 210 & 210 & 0 & 836.7 & & 207.86 & 210 & 1.0 + ` spd_rf2_900_1124_5979 ` & 198 & 549 & & 210 & 210 & 0 & 167.9 & & 207.16 & 210 & 1.4 + ` spd_rf2_900_1124_5987 ` & 190 & 546 & & 203 & 203 & 0 & 340.6 & & 201.54 & 204 & 1.2 + ` spd_rf2_900_1124_6003 ` & 189 & 549 & & 202 & 202 & 0 & 3120.8 & & 199.06 & 203 & 1.9 + ` spd_rf2_1000_1143_6091 ` & 252 & 704 & & 272 & 272 & 0 & 2334.6 & & 268.02 & 274 & 2.2 + ` spd_rf2_1000_1143_6099 ` & 254 & 711 & & 271 & 271 & 0 & 9.5 & & 268.24 & 272 & 1.4 + ` spd_rf2_1000_1143_6107 ` & 251 & 698 & & 272 & 272 & 0 & 108.1 & & 267.17 & 273 & 2.1 + ` spd_rf2_1000_1143_6115 ` & 253 & 700 & & 272 & 272 & 0 & 314.5 & & 269.87 & 272 & 0.8 + ` spd_rf2_1000_1143_6123 ` & 251 & 712 & & 269 & 269 & 0 & 906.0 & & 268.40 & 270 & 0.6 + ` spd_rf2_1000_1191_6131 ` & 228 & 662 & & 247.67 & 249 & 0.5 & 3600.0 & & 243.83 & 250 & 2.5 + ` spd_rf2_1000_1191_6139 ` & 235 & 659 & & 251 & 251 & 0 & 362.4 & & 248.11 & 252 & 1.5 + ` spd_rf2_1000_1191_6147 ` & 233 & 656 & & 250 & 250 & 0 & 945.6 & & 246.47 & 251 & 1.8 + ` spd_rf2_1000_1191_6155 ` & 235 & 655 & & 253 & 253 & 0 & 193.9 & & 251.54 & 253 & 0.6 + ` spd_rf2_1000_1239_6171 ` & 218 & 608 & & 232 & 232 & 0 & 90.9 & & 230.11 & 232 & 0.8 + ` spd_rf2_1000_1239_6179 ` & 222 & 605 & & 236 & 237 & 0.4 & 3600.0 & & 231.26 & 239 & 3.2 + ` spd_rf2_1000_1239_6187 ` & 217 & 611 & & 229.81 & 233 & 1.4 & 3600.0 & & 225.33 & 237 & 4.9 + ` spd_rf2_1000_1239_6195 ` & 222 & 616 & & 238.01 & 241 & 1.2 & 3600.0 & & 229.71 & 243 & 5.5 + ` spd_rf2_1000_1239_6203 ` & 218 & 609 & & 236 & 236 & 0 & 2850.6 & & 230.84 & 237 & 2.6 + average & 20.4% & 48.1% & & & & 0.46 & & & & & 2.3 +    for all the 475 remaining cases in this benchmark , the enhanced algorithm makes finding optimal solutions for the mbv a much faster task , as we present in table [ tab : solvedinstances ] .",
    "given the large number of instances , we present the arithmetic mean after aggregating the results for instances with the same number of vertices ( _ n _ ) and edges ( _ m _ ) .",
    "regarding the smaller instances set ( up to 500 vertices ) , the decomposition approach is able to reduce 15.9% of the vertices and 38.6% of the edges , on average , thus yielding the optimal solution in a smaller amount of time . as for the larger instances set ( from 600 to 1,000 vertices ) ,",
    "the average reduction is of 24.8% of the vertices and 61.3% of the edges , achieving a solution much faster .",
    "@cccccc|cccccc@     + & & & & & + n & m & ob & ce & enhanced & plain & n & m & ob & ce & enhanced & plain +     + & & & & & + n & m & ob & ce & enhanced & plain & n & m & ob & ce & enhanced & plain + 200 & 222 & 45.8 & 127.8 & 0.1 & 1.5 & 600 & 637 & 173.0 & 493.6 & 0.8 & 26.7 + 200 & 244 & 32.2 & 92.4 & 1.1 & 4.4 & 600 & 674 & 156.2 & 437.4 & 5.3 & 131.9 + 200 & 267 & 23.4 & 69.0 & 1.6 & 10.0 & 600 & 712 & 139.6 & 394.4 & 143.0 & 406.6 + 200 & 289 & 15.4 & 56.8 & 78.5 & 77.2 & 600 & 749 & 129.8 & 361.8 & 55.9 & 837.8 + 200 & 312 & 11.0 & 42.2 & 11.5 & 15.2 & 600 & 787 & 119.4 & 333.6 & 202.9 & 849.3 + 250 & 273 & 60.0 & 164.4 & 0.1 & 2.8 & 700 & 740 & 203.0 & 576.8 & 0.7 & 52.0 + 250 & 297 & 43.2 & 120.8 & 3.0 & 14.9 & 700 & 780 & 185.2 & 518.4 & 9.3 & 242.5 + 250 & 321 & 34.2 & 101.8 & 3.2 & 14.5 & 700 & 821 & 167.3 & 471.0 & 54.8 & 1285.6 + 250 & 345 & 24.4 & 76.2 & 42.9 & 76.5 & 700 & 861 & 154.8 & 436.5 & 758.4 & 241.9 + 250 & 369 & 16.8 & 60.0 & 63.6 & 59.2 & 700 & 902 & 147.0 & 402.3 & 25.0 & 773.5 + 300 & 326 & 73.2 & 203.0 & 0.3 & 5.3 & 800 & 1017 & 167.0 & 468.0 & 222.2 & 325.2 + 300 & 353 & 57.8 & 160.2 & 3.8 & 17.8 & 800 & 843 & 232.0 & 666.8 & 1.2 & 69.4 + 300 & 380 & 43.0 & 124.8 & 20.1 & 57.4 & 800 & 886 & 213.8 & 599.0 & 5.4 & 503.8 + 300 & 407 & 34.4 & 104.6 & 60.0 & 117.2 & 800 & 930 & 193.5 & 546.0 & 8.4 & 343.1 + 300 & 434 & 25.6 & 86.4 & 279.0 & 146.2 & 800 & 973 & 180.0 & 506.3 & 1183.7 & 2598.0 + 350 & 378 & 85.4 & 238.8 & 0.6 & 7.9 & 900 & 1034 & 222.5 & 631.0 & 54.4 & 616.9 + 350 & 406 & 67.4 & 190.0 & 12.3 & 48.2 & 900 & 1079 & 207.0 & 589.0 & 171.9 & 775.6 + 350 & 435 & 50.4 & 151.0 & 359.2 & 402.0 & 900 & 1124 & 197.0 & 551.0 & 76.0 & 870.5 + 350 & 463 & 40.2 & 124.2 & 514.6 & 1059.5 & 900 & 944 & 262.2 & 756.4 & 1.7 & 111.5 + 350 & 492 & 29.0 & 103.5 & 73.3 & 262.5 & 900 & 989 & 242.0 & 685.0 & 36.6 & 941.7 + 400 & 429 & 102.4 & 282.6 & 0.8 & 39.4 & 1000 & 1047 & 296.2 & 849.6 & 3.8 & 222.3 + 400 & 459 & 78.6 & 226.4 & 11.1 & 53.2 & 1000 & 1095 & 268.8 & 767.0 & 32.8 & 820.0 + 400 & 489 & 62.2 & 184.8 & 44.0 & 228.4 & 1000 & 1191 & 233.0 & 656.0 & 634.6 & 1524.8 + 400 & 519 & 51.0 & 154.0 & 322.6 & 1198.5 & & & & & & + 400 & 549 & 41.8 & 131.2 & 700.5 & 1058.8 & & & & & & + 450 & 482 & 115.0 & 318.6 & 0.9 & 44.5 & & & & & & + 450 & 515 & 91.6 & 250.6 & 17.4 & 308.5 & & & & & & + 450 & 548 & 74.0 & 209.8 & 44.3 & 442.5 & & & & & & + 450 & 581 & 62.0 & 177.5 & 452.8 & 594.3 & & & & & & + 450 & 614 & 47.7 & 152.3 & 909.5 & 1278.0 & & & & & & + 500 & 534 & 131.8 & 361.0 & 1.5 & 46.7 & & & & & & + 500 & 568 & 106.0 & 294.2 & 26.8 & 256.4 & & & & & & + 500 & 603 & 86.0 & 241.5 & 318.5 & 1404.5 & & & & & & + 500 & 637 & 71.8 & 210.6 & 556.6 & 2103.1 & & & & & & + & 15.9% & 38.6% & 145.2 & 337.0 & & 24.8% & 61.3% & 160.4 & 633.5 +    finally , we compare the performance of our heuristics with the best primal feasible solution cost obtained by the lagrangian heuristics of carrabs et al .",
    "the authors compiled their best bounds on a set of 175 problem instances .",
    "table [ tab : heuristicscarrabs ] compares those values with the ones provided by our heuristics ; we report the best value among the path - expanding and the multi - path expanding algorithms .",
    "we highlight that our proposed constructive algorithms provide better warm starts .",
    "in fact , they provide better primal bounds to 103 instances . on the other hand , the best result presented by carrabs et al .",
    "@xcite is better in 54 instances , and is equal to the solution obtained with our constructive algorithms in 18 instances .",
    "@ccc|ccc@     + & best constructed & best result & & best constructed & best result + & solution & by @xcite & & solution & by @xcite +     + & best constructed & best result & & best constructed & best result + & solution & by @xcite & & solution & by @xcite + ` spd_rf2_200_222_3811 ` & 55 & 54 & ` spd_rf2_350_435_4515 ` & 81 & 77 + ` spd_rf2_200_222_3819 ` & 55 & 54 & ` spd_rf2_350_435_4523 ` & 75 & 74 + ` spd_rf2_200_222_3827 ` & 53 & 51 & ` spd_rf2_350_463_4531 ` & * 69 * & 70 + ` spd_rf2_200_222_3835 ` & 54 & 52 & ` spd_rf2_350_463_4539 ` & 70 & 70 + ` spd_rf2_200_222_3843 ` & 55 & 54 & ` spd_rf2_350_463_4547 ` & * 67 * & 71 + ` spd_rf2_200_244_3851 ` & * 43 * & 46 & ` spd_rf2_350_463_4555 ` & * 68 * & 70 + ` spd_rf2_200_244_3859 ` & * 46 * & 49 & ` spd_rf2_350_463_4563 ` & * 66 * & 73 + ` spd_rf2_200_244_3867 ` & 45 & 43 & ` spd_rf2_350_492_4571 ` & * 55 * & 62 + ` spd_rf2_200_244_3875 ` & * 42 * & 43 & ` spd_rf2_350_492_4579 ` & * 62 * & 64 + ` spd_rf2_200_244_3883 ` & 45 & 45 & ` spd_rf2_350_492_4587 ` & * 59 * & 60 + ` spd_rf2_200_267_3891 ` & * 36 * & 37 & ` spd_rf2_350_492_4595 ` & 59 & 57 + ` spd_rf2_200_267_3899 ` & * 37 * & 39 & ` spd_rf2_350_492_4603 ` & * 59 * & 63 + ` spd_rf2_200_267_3907 ` & 37 & 37 & ` spd_rf2_400_429_4611 ` & 118 & 118 + ` spd_rf2_200_267_3915 ` & * 36 * & 39 & ` spd_rf2_400_429_4619 ` & 118 & 116 + ` spd_rf2_200_267_3923 ` & * 36 * & 41 & ` spd_rf2_400_429_4627 ` & * 115 * & 116 + ` spd_rf2_200_289_3931 ` & * 28 * & 30 & ` spd_rf2_400_429_4635 ` & 117 & 115 + ` spd_rf2_200_289_3939 ` & * 29 * & 35 & ` spd_rf2_400_429_4643 ` & 118 & 117 + ` spd_rf2_200_289_3947 ` & * 31 * & 35 & ` spd_rf2_400_459_4651 ` & 106 & 105 + ` spd_rf2_200_289_3955 ` & * 31 * & 34 & ` spd_rf2_400_459_4659 ` & 101 & 100 + ` spd_rf2_200_289_3963 ` & * 30 * & 32 & ` spd_rf2_400_459_4667 ` & * 102 * & 106 + ` spd_rf2_200_312_3971 ` & 24 & 23 & ` spd_rf2_400_459_4675 ` & * 104 * & 106 + ` spd_rf2_200_312_3979 ` & * 23 * & 27 & ` spd_rf2_400_459_4683 ` & 103 & 103 + ` spd_rf2_200_312_3987 ` & * 26 * & 29 & ` spd_rf2_400_489_4691 ` & 87 & 87 + ` spd_rf2_200_312_3995 ` & * 23 * & 26 & ` spd_rf2_400_489_4699 ` & * 92 * & 98 + ` spd_rf2_200_312_4003 ` & * 28 * & 30 & ` spd_rf2_400_489_4707 ` & * 90 * & 95 + ` spd_rf2_250_273_4011 ` & 71 & 71 & ` spd_rf2_400_489_4715 ` & 91 & 88 + ` spd_rf2_250_273_4019 ` & 70 & 66 & ` spd_rf2_400_489_4723 ` & 92 & 92 + ` spd_rf2_250_273_4027 ` & 70 & 69 & ` spd_rf2_400_519_4731 ` & * 79 * & 83 + ` spd_rf2_250_273_4035 ` & 71 & 69 & ` spd_rf2_400_519_4739 ` & * 77 * & 85 + ` spd_rf2_250_273_4043 ` & * 67 * & 70 & ` spd_rf2_400_519_4747 ` & * 79 * & 82 + ` spd_rf2_250_297_4051 ` & 60 & 60 & ` spd_rf2_400_519_4755 ` & * 80 * & 85 + ` spd_rf2_250_297_4059 ` & * 61 * & 63 & ` spd_rf2_400_519_4763 ` & * 78 * & 84 + ` spd_rf2_250_297_4067 ` & * 57 * & 56 & ` spd_rf2_400_549_4771 ` & * 68 * & 77 + ` spd_rf2_250_297_4075 ` & * 59 * & 63 & ` spd_rf2_400_549_4779 ` & * 66 * & 73 + ` spd_rf2_250_297_4083 ` & 61 & 60 & ` spd_rf2_400_549_4787 ` & 72 & 71 + ` spd_rf2_250_321_4091 ` & * 52 * & 57 & ` spd_rf2_400_549_4795 ` & 71 & 69 + ` spd_rf2_250_321_4099 ` & * 50 * & 53 & ` spd_rf2_400_549_4803 ` & * 73 * & 75 + ` spd_rf2_250_321_4107 ` & * 49 * & 51 & ` spd_rf2_450_482_4811 ` & 131 & 128 + ` spd_rf2_250_321_4115 ` & * 48 * & 54 & ` spd_rf2_450_482_4819 ` & 130 & 130 + ` spd_rf2_250_321_4123 ` & * 50 * & 54 & ` spd_rf2_450_482_4827 ` & 133 & 133 + ` spd_rf2_250_345_4131 ` & * 39 * & 41 & ` spd_rf2_450_482_4835 ` & * 132 * & 133 + ` spd_rf2_250_345_4139 ` & 48 & 47 & ` spd_rf2_450_482_4843 ` & 132 & 130 + ` spd_rf2_250_345_4147 ` & 45 & 44 & ` spd_rf2_450_515_4851 ` & * 116 * & 118 + ` spd_rf2_250_345_4155 ` & * 44 * & 45 & ` spd_rf2_450_515_4859 ` & 118 & 118 + ` spd_rf2_250_345_4163 ` & * 41 * & 47 & ` spd_rf2_450_515_4867 ` & * 112 * & 120 + ` spd_rf2_250_369_4171 ` & 38 & 38 & ` spd_rf2_450_515_4875 ` & 118 & 118 + ` spd_rf2_250_369_4179 ` & * 33 * & 35 & ` spd_rf2_450_515_4883 ` & 117 & 114 + ` spd_rf2_250_369_4187 ` & * 35 * & 37 & ` spd_rf2_450_548_4891 ` & 109 & 105 + ` spd_rf2_250_369_4195 ` & * 35 * & 38 & ` spd_rf2_450_548_4899 ` & * 101 * & 105 + ` spd_rf2_250_369_4203 ` & * 36 * & 40 & ` spd_rf2_450_548_4907 ` & * 100 * & 101 + ` spd_rf2_300_326_4211 ` & 86 & 85 & ` spd_rf2_450_548_4915 ` & * 101 * & 106 + ` spd_rf2_300_326_4219 ` & 87 & 83 & ` spd_rf2_450_548_4923 ` & * 105 * & 107 + ` spd_rf2_300_326_4227 ` & 87 & 85 & ` spd_rf2_450_581_4931 ` & 93 & 93 + ` spd_rf2_300_326_4235 ` & 85 & 85 & ` spd_rf2_450_581_4939 ` & * 90 * & 93 + ` spd_rf2_300_326_4243 ` & 85 & 84 & ` spd_rf2_450_581_4947 ` & * 95 * & 99 + ` spd_rf2_300_353_4251 ` & 75 & 73 & ` spd_rf2_450_581_4955 ` & * 91 * & 97 + ` spd_rf2_300_353_4259 ` & 73 & 72 & ` spd_rf2_450_581_4963 ` & * 90 * & 96 + ` spd_rf2_300_353_4267 ` & 77 & 77 & ` spd_rf2_450_614_4971 ` & * 82 * & 90 + ` spd_rf2_300_353_4275 ` & 77 & 76 & ` spd_rf2_450_614_4979 ` & * 80 * & 88 + ` spd_rf2_300_353_4283 ` & * 75 * & 76 & ` spd_rf2_450_614_4987 ` & * 79 * & 85 + ` spd_rf2_300_380_4291 ` & * 65 * & 69 & ` spd_rf2_450_614_4995 ` & * 79 * & 86 + ` spd_rf2_300_380_4299 ` & 66 & 66 & ` spd_rf2_450_614_5003 ` & * 83 * & 87 + ` spd_rf2_300_380_4307 ` & * 62 * & 64 & ` spd_rf2_500_534_5011 ` & 147 & 145 + ` spd_rf2_300_380_4315 ` & * 58 * & 63 & ` spd_rf2_500_534_5019 ` & 148 & 147 + ` spd_rf2_300_380_4323 ` & * 62 * & 66 & ` spd_rf2_500_534_5027 ` & 150 & 146 + ` spd_rf2_300_407_4331 ` & * 56 * & 60 & ` spd_rf2_500_534_5035 ` & 150 & 148 + ` spd_rf2_300_407_4339 ` & 60 & 58 & ` spd_rf2_500_534_5043 ` & 147 & 145 + ` spd_rf2_300_407_4347 ` & 53 & 63 & ` spd_rf2_500_568_5051 ` & 129 & 128 + ` spd_rf2_300_407_4355 ` & * 53 * & 56 & ` spd_rf2_500_568_5059 ` & * 129 * & 132 + ` spd_rf2_300_407_4363 ` & * 56 * & 59 & ` spd_rf2_500_568_5067 ` & * 131 * & 132 + ` spd_rf2_300_434_4371 ` & * 46 * & 50 & ` spd_rf2_500_568_5075 ` & 133 & 131 + ` spd_rf2_300_434_4379 ` & * 45 * & 47 & ` spd_rf2_500_568_5083 ` & * 130 * & 132 + ` spd_rf2_300_434_4387 ` & * 46 * & 47 & ` spd_rf2_500_603_5091 ` & * 118 * & 125 + ` spd_rf2_300_434_4395 ` & * 48 * & 53 & ` spd_rf2_500_603_5099 ` & 116 & 115 + ` spd_rf2_300_434_4403 ` & * 49 * & 56 & ` spd_rf2_500_603_5107 ` & 122 & 121 + ` spd_rf2_350_378_4411 ` & 100 & 99 & ` spd_rf2_500_603_5115 ` & * 116 * & 123 + ` spd_rf2_350_378_4419 ` & 99 & 96 & ` spd_rf2_500_603_5123 ` & * 116 * & 117 + ` spd_rf2_350_378_4427 ` & 102 & 100 & ` spd_rf2_500_637_5131 ` & * 106 * & 112 + ` spd_rf2_350_378_4435 ` & 99 & 97 & ` spd_rf2_500_637_5139 ` & * 105 * & 108 + ` spd_rf2_350_378_4443 ` & 100 & 98 & ` spd_rf2_500_637_5147 ` & * 102 * & 107 + ` spd_rf2_350_406_4451 ` & * 89 * & 91 & ` spd_rf2_500_637_5155 ` & * 101 * & 106 + ` spd_rf2_350_406_4459 ` & 89 & 87 & ` spd_rf2_500_637_5163 ` & * 97 * & 98 + ` spd_rf2_350_406_4467 ` & * 88 * & 91 & ` spd_rf2_500_672_5171 ` & * 93 * & 105 + ` spd_rf2_350_406_4475 ` & 87 & 85 & ` spd_rf2_500_672_5179 ` & * 90 * & 98 + ` spd_rf2_350_406_4483 ` & * 87 * & 90 & ` spd_rf2_500_672_5187 ` & * 89 * & 92 + ` spd_rf2_350_435_4491 ` & * 75 * & 77 & ` spd_rf2_500_672_5195 ` & * 91 * & 103 + ` spd_rf2_350_435_4499 ` & 75 & 74 & ` spd_rf2_500_672_5203 ` & * 89 * & 97 + ` spd_rf2_350_435_4507 ` & * 71 * & 76 & & & +      the computational results of silva et al .",
    "@xcite include six classes of benchmark instances .",
    "we remark that only three of those sets , which we describe next , were available for our experiments .",
    "set iii : : :    includes four instances adapted from the tsplib , ranging from 1,000 to    4,000 vertices and from 1,998 to 7,997 edges .",
    "set v : : :    includes five instances adapted from the or - library , all with 1,000    vertices and 5,000 edges .",
    "set vi : : :    includes twelve instances proposed by leighton  @xcite , all with 450    vertices and an edge count varying from 5,714 to 17,425 .    although these are relatively large instances , all of them have optimal solutions with no branch vertices that could be obtained with our enhanced algorithm .",
    "table [ tab : silvainstances ] indicates the execution time ( in seconds ) to solve those instances with the enhanced algorithm , and also compare the heuristic solution values achieved with the best results presented by silva et al .",
    "note that the latter is a randomized algorithm , and the authors report the minimum , maximum and average solution values over 100 executions . nevertheless , we present in the table only their results with minimum number of branch vertices .    the path expanding and",
    "multi - path expanding heuristics were able to construct much superior solutions .",
    "in fact , they are able to find provably optimal ( _ i.e. _ branch - free ) solutions in many cases .",
    "note that , for all instances not optimally solved by  @xcite , both our solutions improve their results .",
    "finally , since all the instances in these benchmark sets have optimal solutions with no branch vertices , the obligatory branches lower bound has no effect . as for the cut edges decomposition ,",
    "only one of the instances ( ` vi / le450_15b ` ) has two bridges .",
    ".results regarding the available instances used by silva et al .",
    "all these instances admit a branch - free solution , which could be obtained using the enhanced algorithm in the time indicated in the fourth column . [",
    "tab : silvainstances ] [ cols=\"<,<,<,<,^,^,^,^ \" , ]",
    "this paper introduces an effective decomposition method and two constructive heuristics for the minimum branch vertices problem .",
    "since most benchmark instances for the problem ( 535 out of 546 ) could be solved to optimality by a branch and cut algorithm , we stress the relevance of the algorithms introduced here as preprocessing methods : a phase between formulation and solution for improving the algorithmic solvability of the problem @xcite .",
    "we highlight the computational efficiency of the algorithms we present , whose implementations run in less than a second for all available instances .    we compared a standard branch and cut algorithm with its application on the remaining subproblems after running our decomposition and heuristic methods .",
    "not only does the _ enhanced version _ provide a better duality gap in @xmath84 of the instances with no optimality certificate , as it makes the algorithm consistently faster in all cases .      finally , the heuristics provided better mip starts in most cases : it is better than the ones presented by silva et al .",
    "@xcite in all of the 21 available instances , among those used in their experiments .",
    "our heuristics also provide better primal bounds for 103 out of 175 instances , for which carrabs et al .",
    "@xcite describe extended results .",
    "we remark that our proposed heuristics could be used to rapidly provide very good quality solutions for more advanced local search procedures , such as the one recently proposed by marn  @xcite .",
    "almeida , l.t .",
    "nogueira , and v.g .",
    "pereira de  s .",
    "minimizando ramificaes em rvores geradoras . in _",
    "anais do xlvi simpsio brasileiro de pesquisa operacional _",
    ", sbpo14 , pages 29772985 , salvador , 2014 .",
    "m.  chimani and j.  spoerhase . approximating spanning trees with few branches . in t.",
    "erlebach and g.  persiano , editors , _ approximation and online algorithms _ , volume 7846 of _ lecture notes in computer science _ ,",
    "pages 3041 .",
    "springer berlin heidelberg , 2013 .",
    "l.  gargano , p.  hell , l.  stacho , and u.  vaccaro .",
    "spanning trees with bounded number of branch vertices . in p.",
    "widmayer , s.  eidenbenz , f.  triguero , r.  morales , r.  conejo , and m.  hennessy , editors , _ automata , languages and programming _ , volume 2380 of _ lecture notes in computer science _ , pages 355365 .",
    "springer berlin heidelberg , 2002 .",
    "silva , d.m .",
    "silva , m.g.c .",
    "resende , g.r .",
    "mateus , j.f .",
    "gonalves , and p.  festa .",
    "an edge - swap heuristic for generating spanning trees with minimum number of branch vertices . , 8(4):12251243 , 2014 ."
  ],
  "abstract_text": [
    "<S> given a graph @xmath0 , the _ minimum branch vertices problem _ consists in finding a spanning tree @xmath1 of @xmath2 minimizing the number of vertices with degree greater than two . </S>",
    "<S> we consider a simple combinatorial lower bound for the problem , from which we propose a decomposition approach . </S>",
    "<S> the motivation is to break down the problem into several smaller subproblems which are more tractable computationally , and then recombine the obtained solutions to generate a solution to the original problem . </S>",
    "<S> we also propose effective constructive heuristics to the problem which take into consideration the problem s structure in order to obtain good feasible solutions . </S>",
    "<S> computational results show that our decomposition approach is very fast and can drastically reduce the size of the subproblems to be solved . </S>",
    "<S> this allows a branch and cut algorithm to perform much better than when used over the full original problem . </S>",
    "<S> the results also show that the proposed constructive heuristics are highly efficient and generate very good quality solutions , outperforming other heuristics available in the literature in several situations . </S>",
    "<S> + * keywords : * minimum branch vertices , spanning tree , graph decomposition , heuristics , branch and cut , combinatorial optimization . </S>"
  ]
}