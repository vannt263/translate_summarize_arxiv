{
  "article_text": [
    "_ title of program : _ xperm + _ catalogue identifier : _ + _ program obtainable from : _ ( submitted to computer physics communications ) + ` http://metric.iem.csic.es/martin-garcia/xact/ ` + _ reference in cpc to previous version : _ + _ catalogue identifier of previous version : _",
    "+ _ does the new version supersede the original program ? : _",
    "+ _ computers : _ any computer running c and/or mathematica + _ operating systems under which the new version has been tested : _ linux , unix , windows xp , macos + _ programming language : _ c and mathematica ( version 5.0 or higher ) + _ memory required to execute with typical data : _ 20 mbyte + _ no . of bits in a word : _ 64 or 32 + _ no . of processors",
    "used : _ 1 + _ no .",
    "of bytes in distributed program , including test data , etc . :",
    "_ 1.5 mbyte + _ distribution format : _ unencoded compressed tar file + _ nature of physical problem : _ canonicalization of indexed expressions with respect to permutation symmetries .",
    "+ _ method of solution : _ the butler - portugal algorithm .",
    "+ _ restrictions on the complexity of the problem : _ multiterm symmetries are not considered .",
    "+ _ typical running time : _ a few seconds with generic expressions of up to 100 indices .",
    "tensor calculus is essential in those areas of physics and engineering using curved manifolds and other geometrical structures to model physical objects . in particular , even the space - time itself can be the object of study , as in general relativity or other modern theories of gravity .",
    "computations in this context frequently become difficult , typically due to two main sources of complexity : a high dimensionality @xmath0 or working with a large number @xmath1 of indices .",
    "this is because the size of coordinate expansions grows as @xmath2 and the problem of symmetry handling grows as @xmath3 , respectively . in those cases",
    "the use of tensor computer algebra ( tca in the following ) can be of great help .",
    "tca is not only , however , a way of checking or avoiding our hand computations ; the use of efficient algorithms combined with moderate computer resources ( mainly ram memory ) can widen up enormously the set of problems that we can attack and solve . for a general review on tca see ref .",
    "@xcite .",
    "this article focuses on the treatment of symmetries of tensorial expressions under permutations of their indices . though the basic tensors used in our computations normally do not have complicated symmetries",
    ", their arbitrary tensor products can be very complicated .",
    "traditional methods , based on listing permutations , are exponential in nature with respect to the number of indices , both in the time and memory required to solve a problem .",
    "they become therefore rather slow when working with expressions of several dozens of indices . the butler - portugal @xcite algorithm , based on well - known efficient methods of computational group theory ,",
    "is effectively polynomial and performs much better , as we will show with explicit examples comparing with other systems .    here",
    "we present for the first time a new implementation of the butler - portugal algorithm .",
    "it has been written both as a _",
    "package for generic manipulation of large groups of permutations , and as a c subroutine specialized in the index canonicalization problem",
    ". we shall refer to these two parts of the code as _ xperm - math _ and _ xperm - c _ respectively .",
    "this system is the computational core for a fully - fledged abstract tensor package named _ xtensor _ by the same author , and both are part of the integrated framework _",
    "@xcite for tensor computer algebra .",
    "the properties and capabilities of _ xtensor _ will be reported elsewhere .",
    "section [ algorithms ] summarizes very briefly the theoretical background behind the use of computational group theory in the problem of index canonicalization .",
    "sections [ xperm - math ] and [ xperm - c ] present the code , giving some examples of use .",
    "section [ timings ] analyzes three nontrivial problems , showing the high efficiency and speed of the system .",
    "section [ conclusions ] contains our conclusions .",
    "in this article a tensor , like @xmath4 , is any expression with a _ head _ symbol ( @xmath5 in this case ) and a list of _ slots _ where we can place _ indices_. the expression can then be represented as t[c , b,1,a,-1,-1,-c ] , where we use a minus sign to denote covariant indices .",
    "we shall not be concerned here with the types of indices that can be used , but we shall assume the following : paired symbols ( like c and -c above ) represent a contraction , in the usual einstein convention ; integer indices do not follow the einstein convention , and can be repeated ( like -1 above ) .",
    "the motivation for this is using symbols to denote abstract indices and integers for components .",
    "any index configuration can be sorted into a canonical order following several predefined priorities ( for instance symbols before integers , lowercase before uppercase , free before dummy , contravariant before covariant , etc ) .",
    "following @xcite , we represent that index configuration as the permutation which brings it to canonical order .",
    "for example , if we assume that the canonical order for our configuration @xmath6\\{c , b,1,a,-1,-1,-c } is @xmath7\\{a , c ,- c , b,1,-1,-1 } then @xmath8 can be converted into @xmath9 using the permutation @xmath10 , in disjoint cyclic notation ; that is , at the first slot of @xmath8 we find the second index of @xmath9 , at the second slot we find the fourth index , at the fourth slot we find the first index , etc .",
    "we follow the convention of applying permutations on the right : @xmath11 .",
    "for example @xmath12 and @xmath13 . in other words , @xmath14 means that the image of slot @xmath15 under the permutation @xmath16 is the index @xmath17 in the canonical list .",
    "experimentally we find that the choice of index priorities for the canonical configuration deeply affects the overall efficiency of the algorithm ; having paired indices in consecutive slots of @xmath9 seems to be the best option .",
    "a _ permutation - symmetry _ of a tensor is any rearrangement under which the tensor remains invariant or changes sign .",
    "this forces us to work with _ signed permutations _ , which belong to the extended group @xmath18 , rather than the symmetric group of @xmath1 indices alone . a signed permutation @xmath19 with @xmath20 and @xmath21 acts on a tensor @xmath22 producing @xmath23 .",
    "there are two types of permutation - symmetries :    * those which involve a permutation of the slots independently of which indices they have ( let us call them _ slot - symmetries _ ) . for the riemann tensor examples",
    "are @xmath24 the slot - symmetries of a tensor form a permutation group , denoted by @xmath25 , not abelian in general . * those which involve a permutation among the indices independently of",
    "which slots they are in ( call them _ index - symmetries _ ) .",
    "there are three possible sources : * * exchange of dummies : @xmath26 .",
    "* * `` metric swapping '' : @xmath27 ( or @xmath28 for an antisymmetric metric , as in spinor theory ) . * * repeated indices can always be exchanged , as the component indices 1 in @xmath29 . + these three sources give rise to three respective groups @xmath30 , @xmath31 and @xmath32 , not abelian in general , but which commute with each other .",
    "the complete group of index - symmetries of a tensor is @xmath33 .    as shown in @xcite , every problem of index canonicalization",
    "can be reduced to the problem of canonicalization of the indices of single tensors : terms in a sum are treated independently and factors in a tensor product can be sorted into canonical order so that their indices can be considered to belong to a single tensor .",
    "that tensor will inherit the slot - symmetries of the factors in the product , but can have additional slot - symmetries coming from exchange of several instances of the same tensor .",
    "( at this point it is relevant whether the tensor product is commutative or not . ) in the following we shall assume that we work with a single tensor @xmath34 of arbitrary slot - symmetry group @xmath25 and index - symmetry group @xmath35 .",
    "a given configuration of indices @xmath16 is equivalent to any other configuration @xmath36 with @xmath37 and @xmath38 .",
    "the set @xmath39 of permutations is called a _ double coset _ ,",
    "not a group in general , and the problem of canonicalization of a configuration @xmath16 in the presence of symmetries @xmath25 and @xmath35 can be reduced to defining and finding a canonical representative for the corresponding double coset .",
    "such an algorithm was given by butler @xcite for generic groups @xmath25 and @xmath35 , making intensive use of the efficient group representation provided by a _ strong generating set _",
    "@xcite : given a group @xmath40 of permutations acting on a set @xmath41 of points , a subset @xmath42 of points @xmath43 is said to be a _ base _ of @xmath40 iff none of the permutations of @xmath40 fixes all points in b. then we say that a generating set @xmath44 of @xmath40 is _ strong _ with respect to @xmath45 iff there is a generating set in @xmath44 for each of the stabilizer subgroups @xmath46 .",
    "this induces a hierarchy @xmath47 which efficiently represents the group @xmath40 .",
    "the key idea is that problems concerning permutations in @xmath40 can be translated into equivalent problems for the cosets of the @xmath48 in @xmath49 .",
    "a strong generating set and its base can be obtained from a normal generating set using the schreier - sims algorithm @xcite .",
    "butler s algorithm @xcite for a permutation @xmath50 starts from respective strong generating sets @xmath51 and @xmath52 of two subgroups @xmath25 and @xmath35 of @xmath40 .",
    "the base @xmath53 is extended to be a base @xmath45 of @xmath40 and then sequentially the points of base @xmath54 are changed in a way determined by @xmath16 , so that in the end @xmath55 , uniquely identifying the canonical permutation @xmath56 of the double coset @xmath39 .",
    "butler s algorithm has been adapted by portugal and collaborators @xcite to the case of index canonicalization for a generic group @xmath25 and a group @xmath35 of the form @xmath57 , which simplifies the process because the properties of the strong generating set for such a @xmath35 group are known in advance . in tensorial terms",
    ", the base @xmath53 defines priorities among the slots , and then the algorithm sequentially decides which indices are placed at those slots .",
    "zero is returned as soon as @xmath58 is shown to belong to the double coset @xmath39 . from now on we shall refer to this algorithm as the butler - portugal algorithm . for full details and examples",
    "@xcite , and the _ canon _",
    "@xcite implementation in _",
    "maple _ by the same authors .",
    "butler s algorithm uses internally the intersection algorithm and hence it has global exponential efficiency in the number of indices at hand . in practical generic applications ,",
    "however , it is effectively polynomial because only in a very small subset of cases the exponential character is apparent .",
    "this will become clear in the examples shown in sect .",
    "[ timings ] .    in this article",
    "we perform two straightforward extensions to include the possibility of working with indices of different types ( usually indices on different vector spaces ) and also with component indices , which introduce the possibility of being repeated .",
    "note that both issues affect the @xmath35 group , but not the @xmath25 group .",
    "the key observation is that the @xmath30 and @xmath31 groups act only on abstract indices , while the @xmath32 group acts only on component indices , and so their actions are disjoint .",
    "the construction of the strong generating set for @xmath35 from those of the three groups is hence trivial .",
    "the same observation applies for the groups of the indices of different types which , by definition , also have disjoint action .",
    "minor modifications of the butler - portugal algorithm are required to handle the new @xmath32 groups .",
    "the _ xperm _ package contains a number of tools for efficient manipulation of large groups of permutations .",
    "it has been fine tuned to the problem of index canonicalization , but can be used in a more general context .",
    "it is , however , rather limited in comparison with general - purpose environments in computational group theory like magma @xcite or gap @xcite .",
    "the package is loaded using standard _",
    "notation :     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + package xactxperm    version 1.0.0 , \\{2008 , 3 , 5 } + copyright ( c ) 20032008 jose m. martin - garcia , under gpl + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    there are three sets of commands and algorithms in _",
    "first we have basic tools to manipulate permutations . to avoid problems with the choice of notations , and to compare their different efficiencies , four different notations",
    "have been implemented .",
    "the permutation taking the numbers \\{1,2,3,4,5,6 } to \\{3,2,4,1,6,5 } can be represented using either of these :    * perm[\\{3 , 2 , 4 , 1 , 6 , 5 } ] , rearrangement of numbered objects .",
    "* images[\\{4 , 2 , 1 , 3 , 6 , 5 } ] , list of images .",
    "* cycles[\\{1 , 4 , 3 } , \\{5 , 6 } ] , in disjoint cyclic notation . * rules[1->4 , 4->3 , 3->1 , 5->6 , 6->5 ] , convenient in _",
    "mathematica_.    the function translateperm changes among different notations .",
    "other simple functions include permdeg , inverseperm , permsort , etc . , with obvious meanings",
    ". products of permutations are taken with permute .",
    "given a generating set of permutations , the associated group can be constructed using the dimino algorithm .",
    "a second type of algorithms are those in charge of constructing and manipulating strong generating sets .",
    "we have encoded a larger number of the algorithms given in ref .",
    "@xcite , which include a combination of tools to analyze how points move under the permutations ( orbits and schreier vectors ) and how they do not move under them ( stabilizers ) .",
    "relevant commands are orbit , schreierorbit , traceschreier , stabilizer , and others .",
    "the main algorithm is schreiersims , which constructs a strong generating set of a group @xmath40 from any generating set of @xmath40 .",
    "for example , the symmetry group @xmath25 of the riemann tensor can be described by the generating set    the list \\{1,3 } is a base for @xmath25 , but gs is not strong with respect to it ( there is no permutation of the stabilizer @xmath59 in gs ) .",
    "we construct a strong generating set using     + stronggenset[\\{1,3 } , + genset[@xmath60cycles[\\{1,2}],cycles[\\{1,3},\\{2,4}],@xmath60cycles[\\{3,4 } ] ] ]    which has added the missing permutation .",
    "the group is then decomposed into a hierarchy of subgroups which can be used to get any piece of information using the principles of inductive foundation and backtrack search ( the search command ) .",
    "in particular we can test membership in the group with permmemberq and compute its order with orderofgroup :     + 8    the documentation of _ xperm _ shows all examples in @xcite concerning these algorithms , correcting the results of some of them .",
    "the final third set of implemented algorithms are those needed for index canonicalization , following @xcite with the simple extensions mentioned before .",
    "there is rightcosetrepresentative , which gives the canonical representative of the right coset @xmath61 for any permutation @xmath16 and any group @xmath25 .",
    "this is used to canonicalize free indices first .",
    "then there is doublecosetrepresentative , which does the same for the double coset @xmath39 , canonicalizing the dummy and component indices , taking into account the slot - symmetries which do not move the slots with free indices .",
    "this two - step process is more efficient than using only the second one only .",
    "finally the function canonicalperm is in charge of the combination of both algorithms and is the only function to be called when doing index canonicalization . let us see an example : consider the expression @xmath62 .",
    "a product of two riemann tensors has the slot - symmetries described by    ;    the first line of permutations encodes the four pair antisymmetries ; the second line describes symmetry under exchange of pairs in each riemann ; the third line exchanges both riemanns .",
    "the indices \\{a , d , b ,-",
    "c,1,1 } , already in canonical order have index - symmetries described with the notation :    where the dummyset expression contains all dummies of space m , which has a symmetric metric ( switch 1 ) .",
    "there could be several of those expressions , one for each vector space , and several repeatedset expressions , one per repeated index .",
    "other indices in the canonical list are free :    our expression is represented by the permutation    hence the expression can be canonicalized using     + cycles[\\{2,3,4,5},\\{6,7 } ]    which corresponds to the expression @xmath63 .",
    "canonicalization can be performed using pure _ mathematica _ code ( _ xperm - math _ ) or linking to an external compiled executable ( _ xperm - c _ ) through the _ mathlink _ protocol , which is faster .",
    "this is controlled with the options mathlink - > false or mathlink - > true of canonicalperm , respectively .",
    "all algorithms required for index canonicalization have been recoded in 2400 lines of c code to increase the speed the system .",
    "we use some features of the c99 standard and hence the code must be compiled with some modern c compiler like the gnu gcc compiler for linux , unix or mac , or its cygwin port to windows . for those systems with no such compilers the pure _ mathematica _ code presented in the previous section is always available , with identical output , but slower .    permutations are now represented always as lists of images ( this is the images notation in the _ mathematica _ code of _ xperm _ ) .",
    "the sign of a permutation is encoded in an additional pair of points at the end of the permutation .",
    "for instance images[\\{2,3,4,1 } ] will be encoded as the list \\{2,3,4,1,5,6 } and -images[\\{2,3,4,1 } ] as \\{2,3,4,1,6,5}. the product of two permutations p1 and p2 , both of degree n , is efficiently performed with the function    ....      void product(int * p1 , int * p2 , int * p , int n ) {              while(n-- ) * ( p++ ) = * ( p2 - 1+*(p1++ ) ) ;      } ....    which stores the result in p. similarly , the inverse ip of a permutation p of degree",
    "n is computed using    ....",
    "void inverse(int * p , int * ip , int n ) {              while(n-- ) *",
    "( ip-1+*(p+n ) ) = n+1 ;      } ....    a generating set of @xmath64 permutations of degree @xmath1 is stored as a list of @xmath65 integers .",
    "functions are provided to compute images of points under permutations , stable points , stabilizers , orbits , schreier vectors and other basic constructions in theory of finite groups .",
    "the schreier - sims algorithm has also been encoded in c , for completeness , though in typical applications in tensor algebra we do not expect to find the problem of computing a complex strong generating set from a given set of permutations .",
    "that could happen , for example , if we wanted to canonicalize a tensor with 48 indices and rubik s group as symmetry ( a group of @xmath66 permutations ) . providing the obvious set of six generators it takes 5 seconds in _",
    "xperm _ to compute a strong generating set for that group . as a second nontrivial example ,",
    "a strong generating set for the smallest of the three conway simple sporadic groups , represented with permutations acting on 276 points , is constructed in 2.5 seconds .",
    "( this is a group of order @xmath67 . )",
    "finally there is the canonicalizer function , called canonical_perm_ext .",
    "prototypes and further explanations on the structure of this and other functions are given in appendix [ prototypes ] , to help linking from other codes . in _",
    "the link can be performed via the _ mathlink _ protocol , and a template ( .tm ) file is provided with the _ xperm _ package for this purpose .",
    "* example 1 * : given a general antisymmetric tensor @xmath68 it is simple to see that @xmath69 the slot - symmetry group @xmath25 in this problem is generated by the inherited permutations @xmath70 , @xmath71 , ... , @xmath72 and the tensor - exchange permutations @xmath73 , @xmath74 , ... , @xmath75 , in disjoint cyclic notation .",
    "this is a strong generating set with respect to the base points @xmath76}. by accident , the groups @xmath25 and @xmath35 coincide , though this does not introduce any simplification in the problem .",
    "these are large groups , with orders @xmath77 for @xmath78 and @xmath79 for @xmath80 .",
    "figure [ comparison ] shows a comparison of timings of canonicalization for different systems with respect to the number @xmath1 of antisymmetric tensors .",
    "all systems correctly find that expression ( [ anti ] ) is zero for odd @xmath1 , and it is clear that _ xperm _ and _ canon _ , which use the butler - portugal algorithm , are far more efficient than those systems using more traditional methods .",
    "we see that _ xperm - c _ can handle 100 indices within a few seconds .",
    "note also that more sophisticated methods carry an overhead which makes them slower for very low @xmath1 .",
    "timings , in a logarithmic axis , for canonicalization of expression ( [ anti ] ) with various tensor canonicalizers : _ mathtensor _",
    "@xcite , _ ttc _ ( tools of tensor calculus ) @xcite , _ canon _ @xcite and both the pure _ mathematica _ and the c - based codes reported in this article .",
    "the exponential character of the traditional methods vs. the effectively polynomial character of the butler - portugal algorithm is apparent .",
    ", width=529 ]    * example 2 : * we canonicalize random riemann monomials with all indices contracted .",
    "figure [ riemann_comparison ] shows the results for products of up to 9 riemanns in _ mathtensor _ @xcite and products of up to 50 riemanns with our c canonicalizer .",
    "the global structure coincides with that of figure [ comparison ] , and in particular we also see that 100 indices can be also manipulated in just a few seconds .",
    "it is interesting to comment on the different behaviour of the cases giving zero and those giving nonzero results .",
    "_ mathtensor _ has a special rule transforming contractions of type @xmath81 into 0 , and those trivial zeros are detected in milliseconds .",
    "however there are other nontrivial zeros , like @xmath82 , which take even more than a second .",
    "the systematic and general algorithm of _ xperm _ does not distinguish between trivial and nontrivial zeros and detects both in the same way , with an efficiency which seems to grow as @xmath83 .",
    "the non - zero results show a large disperssion in timings , but the average seems to grow like @xmath84 , confirming the result of a similar experiment in @xcite .",
    "the canonicalization of riemann monomials is essential in our recent construction of the _ invar _ package for fast manipulation of riemann invariants , both algebraic invariants @xcite and differential invariants @xcite .",
    "timings , in a logarithmic axis , for canonicalization of scalar products of @xmath1 riemann tensors .",
    "there are 20 points per value of @xmath1 for _ mathtensor _",
    "@xcite , separated in those cases giving zero ( brown open circles ) and those given nonzero result ( purple crosses ) .",
    "the exponential blow up is clear and it is not possible to go beyond @xmath85 with 1gbtyte ram .",
    "there are also 20 points per value of @xmath1 for the c canonicalizer of _ xperm _ and we show results up to @xmath80 ( that is , 200 indices ) , though it is possible to go much beyond with that ram memory .",
    "dark blue circles represent cases with nonzero results and magenta filled circles are cases with zero result ( for reference we display the curve @xmath86 ) .",
    ", width=529 ]    * example 3 : *",
    "let us now concentrate on riemann invariants of degree @xmath87 , so that we work with 40 indices .",
    "[ riemann10 ] shows an histogram of canonicalization timings of one million random invariants , separating those cases giving zero from those giving nonzero results .",
    "it is clear that zeros are faster than nonzero results , because the butler - portugal algorithm gives 0 as soon as @xmath58 is found in the @xmath39 double coset .",
    "we also see several peaks , corresponding to cases of different complexity .",
    "all zero cases are found in less than 0.1s , while several cases take more than a second to canonicalize .",
    "we believe that the hardest riemann invariants to canonicalize are those of the form @xmath88 which require listing @xmath89 permutations internally in the butler - portugal algorithm ( in particular in the alpha table , see @xcite ) , which clearly renders the whole process exponential in @xmath1 .",
    "compare this with a mere @xmath90 for expressions ( [ anti ] ) .",
    "once the hard cases have been identified it is always possible to prepare the system in advance to detect them and switch to adapted algorithms .",
    "for example , in this case the antisymmetric pairs @xmath91 in dimension @xmath0 can be replaced by a single index @xmath92 in dimension @xmath93 converting the problem into @xmath94 , with @xmath95 symmetric .",
    "this new problem is now nearly identical in nature to our example 1 , and hence as efficient .",
    "histogram of canonicalization timings of one million algebraic riemann invariants of degree 10 with our c canonicalizer .",
    "zeros ( red ) are found faster than nonzero ( blue ) results .",
    "the former are all contained in the figure , but there are 4097 nonzero cases taking more than 0.1 s , and actually six of those take between 1 and 6 seconds .",
    "note the origin of the timings axis at 0.03 s. this is roughly the time that the driving tensor system _ xtensor _ @xcite takes to compute the @xmath25 and @xmath35 groups from the tensor expression .",
    ", width=491 ]",
    "we have presented _ xperm _ , a free - software package for efficient manipulation of large permutation groups in _",
    "mathematica_. its main objective is index canonicalization under permutation symmetries of tensorial expressions . for this , _ xperm _ implements the butler - portugal algorithm , which is effectively polynomial in the number of indices , in contrast to the clear exponential behaviour of more traditional algorithms . as far as the author knows , _ xperm _ is currently the fastest index canonicalizer , and this has been demonstrated comparing timings in some nontrivial example computations with other tensor computer algebra systems .    with a tool like this at hand , we can enormously extend the type of problems in differential geometry that we can attack and solve .",
    "there are already several examples of projects in general relativity which have been possible only through the use of _ xperm_. to name a few : the analysis of the hyperbolicity properties of large families of formulations of the einstein equations @xcite used in numerical relativity ; the construction of the dynamical evolution equations for the bel tensor @xcite ; the computation of the polarization of gravitational radiation at the third post - newtonian order @xcite ; or the construction of a large database of equations among the algebraic and differential invariants of the riemann tensor @xcite .",
    "authors of other packages are encouraged to link to the c code presented here to gain efficiency in the process of index canonicalization , with the only proviso that they must require their users to cite this publication any time the combination of packages is used . the standalone system _ cadabra _",
    "@xcite already has this code at its computational core .",
    "_ xperm _ can be downloaded from the webpage    @xmath96http://metric.iem.csic.es / martin - garcia / xact/",
    "i thank paolo matteucci for suggesting the use of the butler - portugal algorithm for index canonicalization .",
    "i also thank alfonso garca - parrado , carsten gundlach , kasper peeters , renato portugal and david yllanes for helpful discussions and for their help testing the system .",
    "support from the spanish mec under the research project fis2005 - 05736-c03 - 02 is acknowledged .",
    "part of the computations have been performed at the _ centro de supercomputacin de galicia _ ( cesga ) .",
    "\\1 ) the schreier - sims algorithm : given a generating set @xmath44 of @xmath64 elements for the group @xmath97 , return a strong generating set @xmath98 with respect to a base @xmath45 for the group @xmath40 :                              \\4 ) double coset canonicalization : given a permutation @xmath16 we return its canonical representative taking into account the information of the slot - symmetry group @xmath25 and the free , dummy and repeated indices .",
    ".... void canonical_perm_ext(int * perm , int n ,          int sgsq , int * base , int bl , int * gs , int m ,          int * freeps , int fl ,          int * vds , int vdsl , int * dummies , int dl , int * mq ,          int * vrs , int vrsl , int * repes , int rl ,          int * cperm ) ; ....      : permutation to be canonicalized + : degree of all permutations in the computation + : 1 if gs is strong and 0 otherwise + : base of the strong generating set of @xmath25 + : length of the list base + : ( strong ) generating set of @xmath25 + : number of permutations in gs + : free indices in input + : length of the list frees + : list of lengths of dummy - sets + : length of list vds + : list with pairs of dummies + : length of list dummies + : list of symmetries of metric ( -1 , 0 , 1 ) + : list of lengths of repeated - sets + : length of list vrs + : list with repeated indices + : length of list repes"
  ],
  "abstract_text": [
    "<S> we present a very fast implementation of the butler - portugal algorithm for index canonicalization with respect to permutation symmetries . </S>",
    "<S> it is called _ xperm _ , and has been written as a combination of a _ mathematica _ package and a c subroutine . </S>",
    "<S> the latter performs the most demanding parts of the computations and can be linked from any other program or computer algebra system . </S>",
    "<S> we demonstrate with tests and timings the effectively polynomial performance of the butler - portugal algorithm with respect to the number of indices , though we also show a case in which it is exponential . </S>",
    "<S> our implementation handles generic tensorial expressions with several dozen indices in hundredths of a second , or one hundred indices in a few seconds , clearly outperforming all other current canonicalizers . </S>",
    "<S> the code has been already under intensive testing for several years and has been essential in recent investigations in large - scale tensor computer algebra .    </S>",
    "<S> index canonicalization , mathematica , computer algebra 02.70.wz , 02.10.ox , 04.20.cv </S>"
  ]
}