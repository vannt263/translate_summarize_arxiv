{
  "article_text": [
    "two general directions are under consideration in this paper .",
    "first , deductive programming will be used as methodology for solution to scheduling problem .",
    "the second direction is experience that improves protocol synthesis due to synergism between scheduling and deductive programming .",
    "declarative programming is concerned about _",
    "what _ is to be done rather then _ how _ is it implemented .",
    "declarative model is interpreted and transformed to executable model .",
    "+ in this paper word _",
    "model _ is frequently used .",
    "+ _ model _ can present requirements , program , agent or behavior in pure mathematical way or through the program code .",
    "nowadays , there are numerous formal methods , specification languages , model checking and theorem proving tools .",
    "putting together different methods , tools and languages is obtained through model transformation , component composition software composition or similar methods .",
    "+ this paper use different models , each of them is suitable for its particular purpose .",
    "declaration part comes from language specialized for scheduling problem definition .",
    "executable part is found in high level petri net .",
    "together , by means of model transformation solution to the problem is found . + this paper",
    "is structured as follows : before model translation between declarative and executable models two solutions are presented , one by means of _ predicate petri net _ ( @xmath0 ) in section [ sec : prt ] and the other by _ planning domain definition language _ ( @xmath1 ) in section [ sec : pddl ] , respectively .",
    "+ working example is introduced in textual form in section [ sec : example ] . in section",
    "[ sec : programming ] unification between the @xmath0 and @xmath1 model yielding translation between the models is introduced .",
    "section [ sec : scheduling ] introduces metamodel as generalization of model transformations .",
    "+ experience from model translation and scheduling synthesis is used for scenario synthesis in section [ sec : synthesis ] .",
    "+ solution to scheduling problem as _ extended finite state machine _",
    "( @xmath2 ) and @xmath3 _ message sequence diagram _ ( @xmath4 ) is in section [ sec : solution ] . + final sections of the paper bring related work ( section [ sec : related ] ) with some reflection regarding synthesis process ( in section [ sec : scope ] ) as well as briefly recapitulate _ literate programming _ methodology and ` noweb ` tool .",
    "+ at the end in section [ sec : conclusion ] is conclusion with further research directions . +",
    "in this section _ predicate petri net _ ( @xmath0 ) solution is described . textual problem from working example ( section [ sec : example ] ) is defined by ( @xmath0 ) constructs and analyzed . in following text",
    "_ working example _ will be referenced as ` 4ws1tob - problem ` shorter as ` 4ws1tob ` .",
    "+ from the modeling point of view two models can be identified :    1 .   mathematical model : @xmath0 is introduced as 6tuple 2 .",
    "program code that is input to @xmath5 tool for analysis    predicate - transition petri net definition is taken from @xcite .",
    "the tool implementing @xmath0 @xcite has been derived following the same formal definition .",
    "@xmath0 is 6tuple structure or mathematical @xmath0 model @xmath6 such that :    1 .",
    "@xmath7 is the set of places , 2 .",
    "@xmath8 is the set of transitions , @xmath9 , 3 .",
    "@xmath10 is the set of arcs , @xmath11 , 4 .",
    "@xmath12 is the capacity function , @xmath13 , 5 .",
    "@xmath14 is the arc weight function , @xmath15 , 6 .",
    "@xmath16 is initial marking ( in initial state ) @xmath17 where @xmath18 is the set of markings ( states ) , @xmath19 .",
    "@xmath20 tool used in this paper is prod @xcite , @xcite .",
    "analysis is performed by means of reachability tree generation .",
    "+ figure [ fig : prt ] . represents programming model @xmath0 for ` 4ws1tob - problem ` example :    1 .",
    "places ( represented as circles ) are sides of the `` bridge'',representing _ safe _ and _ unsafe _ part of the bridge .",
    "2 .   transitions ( represented as boxes ) are actions or events ( _ tosafe _ and _ tounsafe _ ) denoting `` crossings '' : @xmath21 is event when @xmath22 are crossing from _ unsafe _ to _ safe _ , and @xmath23 is @xmath24 crossing from _ safe _ to _ unsafe _ , respectively 3 .",
    "@xmath25 are markings    there is no direct support for time in @xmath0 as well as in prod program . they are fulfilled afterwords ( subsection [ ssec : time ] ) , by means of special program filter",
    ". more detailed description of @xmath0 in @xmath26 syntax shows that @xmath0 is also declarative ` 4ws1tob ` problem description .",
    "in fact , graph structure from fig.[fig : prt ] has program representation or program model that consists of :    1 .",
    "definitions : tokens in @xmath0 are of type integers , they are used to `` carry '' information about elapsed time , 2 .",
    "places : _ safe _ and _ unsafe _ 3",
    ".   transitions _ tounsafe _ and _ tosafe _    definitions are :    .... # define s1 10 # define s2 20 # define s3 25 # define torch 1 ....    _ unsafe _ place has initial markings describing `` all soldiers are in _ unsafe _ place '' :    .... # place unsafe \\    mk     ( <",
    ".s0.>+<.s1.>+      < .s2.>+<.s3.>+<.torch .",
    "> )   ....    each transition ( _ tosafe _ and _ tounsafe _ ) implements previously mentioned events @xmath21 and @xmath23 , ` in ` is input place and ` out ` is output place , respectively :    .... # trans tosafe in   { unsafe :         < .x.>+<.y.>+<.torch . > ; } out { safe :           < .x.>+<.y.>+<.torch . > ; }     # trans tounsafe in   { safe :    < .x.>+<.torch . > ; } out { unsafe : < .x.>+<.torch . > ; } ....    goal is here expressed as computed tree logic ( ctl ) formula .",
    "formula is used after reachability tree is generated . for that purpose separate program analyzer ( ` probe ` ) is used . + safe place will eventually have all tokens ( or _ all soldier will be at safe side of the bridge _ ) :    .... # define goal    eventuallyonsomebranch ( safe = =    < .1.>+<.5.>+<.10.>+<.20.>+<.25 .",
    "> ) ....    all paths ( branches in ctl prod terminology ) with solutions are present . in order to decrease reachability tree timing constraints are separately calculated .",
    "path filter selects only paths where goal  condition timing constraint holds : @xmath27 where : + @xmath28  event timing , + @xmath29  path length + one of such paths is presented in the section [ sec : solution ] . + as conclusion to this section , experience from @xmath0 analysis can be applied to scheduling scenario generation :    1 .",
    "@xmath0 has mathematical or formal model expressed as 6tuple with program representation  model in ` c - like ` syntax denoted as @xmath30 2 .",
    "@xmath0 is also declarative model because it describes structure , analysis through reachability analysis establish @xmath0 as executable model.executable model is denoted as @xmath31 , 3 .",
    "another declarative models that are established as a _ n  tuple _ consisting of entities , predicates , events / actions and similar structure can be transformed to @xmath0 .",
    "` pddl ` ( * * p**lanning * * d**omain * * d**efinition * * l**anguage ) belongs to pdl ( * * p**roblem * * d**omain * * l**anguage ) @xcite class of languages . `",
    "pddl ` has syntax similar to ` lisp ` and describes _",
    "what _ has to be done rather than _ how _ is implemented .",
    "that fact makes ` pddl ` natural candidate for declarative modeling . + `",
    "pddl ` main purpose is to serve as input language for many planning tools . in this paper ` pddl ` is used as declarative input whose syntax is more general and intuitive and that can hide formal method from the user @xcite .",
    "+ declarative ` pddl ` model describing ` 4ws1tob - problem ` is 5tuple : @xmath32 where :    1 .",
    "objects : items of interest , for ` 4ws1tob ` objects are objects=\\{@xmath33 , @xmath34 , @xmath35 , @xmath36 } 2 .   predicates : properties of objects , can be true or false , ( example : is @xmath37 in state @xmath7  ? ) 3 .",
    "initial state(s ) : set of starting predicates formula ( all @xmath37 in _ unsafe _ ) 4 .   goal state(s ) : set of goal predicates formula ( all @xmath37 in _ safe _ ) 5 .",
    "actions ( operators ) : `` crossing '' the bridge expressed through _ precondition _ and _ effect _ predicates    in previous section ( sec.[sec : prt ] ) place and state are words with similar but in general case different meaning , because ` pddl ` and @xmath0 languages have different semantic . in previous section ( sec.[sec : prt ] ) @xmath0 has two models : mathematical and programming .",
    "pddl ` has also two models , but both are expressed through _",
    "lisp_-like syntax . `",
    "pddl ` can also serve as input to other planning and scheduling tools .",
    "+ @xmath38 problem is expressed through ` pddl ` constructs .",
    "each construct is _",
    "lisp_-like expression .",
    "working example ( ` 4ws1tob ` from sec .",
    "[ sec : example ] ) will be used to illustrate @xmath38 constructs .",
    "now , we can say that ` pddl ` program has the same syntax for mathematical and programming model . `",
    "pddl ` example starts with verbatim list of constructs :    .... ( define ( problem 4ws1tob01 )          ( : domain 4ws1tob )           ( objects )           ( predicates )           ( initial_state )           ( goal_specification           ( actions_operators ) ) ) ....    each construct will be described in more details .",
    "following notation from @xcite types are introduced for each object :    a.   @xmath33 , @xmath34,@xmath35 , @xmath36 are objects of _ type _ sold , b.   _ torch _ is object _ type _ torch , c.   _ safe _ , _ unsafe _ are objects of _ type _ place    objects in ` pddl ` are not object from object oriented programming paradigm . in _",
    "lisp_-like syntax objects are defined by term rewriting : +    .... ( objects ) : : = =      ( : objects s0 s1 s2 s3 - sold        torch - torch       safe unsafe - place ) ....    now object construct is ` pddl ` executable , that means planning tools can execute it .",
    "similarly other constructs are rewrote ( or replaced ) producing declarative specification .",
    "predicates can be used within other components .",
    "+ _ is token _ _ sold _",
    "@xmath37 in _ place _",
    "@xmath39  ? _ is expressed as _ :    ....     ( : predicates          ( pl ? sold ?",
    "place ) ) ....      in initial state component all tokens ( @xmath33 , @xmath34 , @xmath35 , @xmath36 ) are in _ safe _ place and _ unsafe _ place is empty .",
    "timing parameters @xmath40 are set , too .",
    "initial time is set as :    .... ( : init    (= ( t - elapsed ) 0 ) ....",
    "initial state components are coded as follows : if token ` ?",
    "x ` is in place _ unsafe _ than token ` ?",
    "x ` is not in place _ safe _ , yielding following initial conditions :    ....   ( pl s0   unsafe )    ( not ( pl s0   safe ) ) (= ( ts s0 ) 5 )   ( pl s1   unsafe )    ( not ( pl s1   safe ) ) (= ( ts s1 ) 10 )            ( pl s2   unsafe )    ( not ( pl s2   safe ) ) (= ( ts s2 ) 20 )            ( pl s3   unsafe )    ( not ( pl s3   safe ) ) (= ( ts s3 ) 25 )            ( pl torch unsafe ) ) ....    predicate (= ( ts @xmath37 ) @xmath40 ) initialize crossing time for object @xmath37 .",
    "+      goal specification component is theorem about system behavior .",
    "if solution exists place _ unsafe _ is empty and all tokens of type _ sold _ are in place _",
    "safe_. solutions are found if goal is proved :    .... ( : goal ( and    ( pl s0 safe )       ( not ( pl s0 unsafe ) )    ( pl s1 safe )       ( not ( pl s1 unsafe ) )    ( pl s2 safe )       ( not ( pl s2 unsafe ) )    ( pl s3 safe )       ( not ( pl s3 unsafe ) )    ( pl torch safe ) ....",
    "goal has timing goal condition @xmath41 expressed as :    ....    ( ( < = t - elapsed ) 60 ) ) ) ....      action operators realize the following functionality :    a.   two objects ( or tokens ) are transfered from _",
    "unsafe _ to _ safe _ , time @xmath42 incremented b.   single object ( or token ) is transfered from _",
    "safe _ to _ unsafe _ , time @xmath42 incremented c.   redundant token _ torch _ is left in ` pddl ` because implementation must support silent  moves ( @xmath43-actions ) d.   parameters ` ?",
    "x ` and ` ?",
    "y ` are of type _ sold _",
    "objects are used within ` pddl ` terminology while tokens are used within @xmath0 terminology .",
    "model transformations unifies objects and tokens , they will be mixed and used as synonyms .",
    "each action consist of _ preconditions _ and _ effect _ :",
    "effect _ is @xmath21 or @xmath23 event mentioned earlier in fig .",
    "[ fig : prt ] sec.[sec : prt ] .",
    "precondition _ must hold in order an _ effect _ takes place .",
    "preconditions _ for _ tosafe _ action are two tokens of type _ sold _ in place _",
    "unsafe_. 4 .",
    "_ precondition _ for _ tounsafe _ action is token of type _ sold _ in place _",
    "unsafe_.       + event @xmath21 is realized with _",
    "action :    .... ( : action tosafe : parameters ( ? x ?",
    "y )   : precondition     ( and ( pl ? x unsafe ) ( not ( pl ? x safe ) )       ( pl ? y unsafe ) ( not ( pl ? y safe ) )       ( pl torch unsafe ) ( not ( pl torch safe ) ) ) ....    _ effect _ should place chosen tokens in _ safe _ place :       + event @xmath23 is realized with _ tounsafe _",
    "action :    .... : effect         ( and     ( pl ? x safe )      ( not ( pl ? x unsafe ) )    ( pl ?",
    "y safe )      ( not ( pl ? y unsafe ) ) ....    and increment elapsed time @xmath42 :    ....   ( + ( t - elapsed       ( max ( ts ? x)(ts ?",
    "y ) ) ) ) ) ) ....    _ tounsafe _ action is similar to _ tosafe _ action , single token of type _ sold _ is going to _ safe _ place and token ` ?",
    "x ` is removed from _",
    "safe _ place and put into the _",
    "unsafe _ place .",
    "_ precondition _ with _ effect _ is semantically equivalent to ` condition - event ` or ` place - transition ` in petri nets .",
    "that enables smooth model transition to non - colored petri nets .    ....",
    "( : action tounsafe : parameters ( ?",
    "x ) : precondition   ( and    ( pl ? x safe )     ( not ( pl ? x unsafe ) )    ( pl torch safe ) ( not ( pl torch unsafe ) ) )    : effect   ( and    ( pl ? x unsafe ) ( not ( pl ? x safe ) )    ( pl ?",
    "y unsafe ) ( not ( pl ? y safe ) )    ( + ( t - elapsed ( ts ?",
    "x ) ) ) ) ) ....    ` pddl ` described in this paper produces the same results with ` ( lpg ) planning ` software .",
    "program is executable after minor adjustments through software provided by @xcite project .",
    "+ parameters ( @xmath44 , @xmath45 , @xmath46 , @xmath47 ) are preserved through transformation from @xmath31 to @xmath30 .",
    "in this paper intention is to derive executable model from deductive or declarative model . terms _ deductive _ and _ declarative _ are used as synonyms although from the formal point of view it is not the same .",
    "+ intention is to define model ( @xmath48 ) as executable without inventing yet another specialized modeling or specification language . that opens possibilities for reasoning about the model properties and consequently introduces validation in early development phase .",
    "+ this hypothetical ` c ` program becomes deductive program .",
    "deductive or declarative program must have implicitly defined algorithm that should deduce only from declarations and predicates output results .",
    "such ` c ` program describes _",
    "what _ is done rather than _ how _ is it done .",
    "+ the same proposition holds for @xmath48 ` pddl ` and @xmath5 models .",
    "we shall use shorter notation , @xmath49 where @xmath50 is always @xmath51 .",
    "@xmath49 is focused on _ what _ is to be done rather then _ how _ is it done .",
    "natural candidates for the model @xmath49 translation are prototype verification system ( * pvs * ) @xcite , term  rewriting systems and _ lisp _ family of languages .",
    "our solutions uses _ lisp _ like languages . + _",
    "modeling for solution _ effect is achieved through the following model transformations presented as commutative diagram in fig.[fig : cd ] .",
    "such approach verifies proof  of  concept through model transformation experiments .",
    "+ @xmath52 and @xmath53 are program transformation routine . in practical solution @xmath52 and @xmath53 will be realized through the metamodel concept : deductive will be interpreted through metamodel , metamodel is translated to executive model afterwords . in this paper direct model translation is used .",
    "metamodel facilities are introduced in section [ sec : scheduling ] .",
    "@xmath54    each transformation between models @xmath49 require parser , because model transformation is program transformation .",
    "in order to avoid parser development following facts are considered :    1 .",
    "mathematical models for ` pddl ` is 5tuple , introduced with lisp syntax , 2 .",
    "mathematical models for @xmath5 is 6tuple , expressed as mathematical text , not as programming language 3 .",
    "@xmath26 program is in`c`like syntax and presents instantiation of @xmath5    ` prod ` program describing @xmath5 is coded in lisp like constructs :    ....   # trans tosafe     in { unsafe : < .x.>+<.y.>+<.torch . > ; }     out { safe :   < .x.>+<.y.>+<.torch . > ; } ....    becomes lisp @xmath26 or @xmath55 :    ....    ( : trans tosafe       : parameters ( ? x ?",
    "torch )         : in   ( unsafe ?",
    "torch )          : out ( safe :    ?",
    "torch ) ....    note the similarity between ` pddl ` ` : action ` construct and @xmath55 ` : trans ` construct .",
    "+      there is set of mappings between @xmath1 and @xmath55 :    1 .",
    "@xmath56 initial - marking 2 .",
    "@xmath57 final - marking 3 .",
    "@xmath58 ` # trans ` 4 .",
    "@xmath59 ` < .tokens .",
    "> `    translation between @xmath1 and @xmath55 is straightforward : the set of mappings unify ` pddl ` and @xmath55 .",
    "this example belongs to the set of `` toy  problems '' used in experiments during algorithm testing .",
    "working example is simple scheduling problem taken from @xcite , listed verbatim :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ four soldiers who are heavily injured , try to flee to their home land .",
    "the enemy is chasing them and in the middle of the night they arrive at a bridge that spans a river which is the border between the two countries at war .",
    "the bridge has been damaged and can only carry two soldiers at a time . furthermore",
    ", several land mines have been placed on the bridge and a torch is needed to sidestep all the mines .",
    "the enemy is on their tail , so the soldiers know that they have only 60 minutes to cross the bridge .",
    "the soldiers only have a single torch and they are not equally injured .",
    "the following table lists the crossing times ( one - way ! ) for each of the soldiers :    1 .",
    "soldier @xmath60 5 minutes 2 .   soldier @xmath61 10 minutes 3 .",
    "soldier @xmath62 20 minutes 4 .",
    "soldier @xmath63 25 minutes    does a schedule exist which gets all four soldiers to the safe side within 60 minutes ? _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "abstract model here  no metamodel needed here [ sec : fm ] scheduling domain metamodel is derived from ` pddl ` model .",
    "metamodel supports constructs from _ type _ theory , concurrency theory as well as process algebras .",
    "after the analysis of the text from section [ sec : example ] the following list of ` constructs ` are introduced : parameters , entities , predicates , events , traces , initial  conditions , goal  conditions , operators and constraints .",
    "+ in the next step each construct is described through _ lisp_-like constructs :    .... ( def - abstract - semantic - net       \" metametamodel \"    ( problem - domain 4ws1tob )    ( parameters construct )    ( entities construct )     ( predicates construct )    ( events construct )     ( traces construct )      ( initial - conditions construct )    ( goal - conditions construct )     ( operators construct )     ( constraints construct ) ) ....    parameters are data of types _ integer _ or _ real _ :    1 .",
    "number of soldiers @xmath64 2 .   ",
    "` carry two soldiers ` ( to _ safe _ side ) @xmath45 , and @xmath46 ( to _ unsafe _ ) side .",
    "` cross times ` : @xmath65 , @xmath66 , @xmath67 , @xmath68 , 4 .",
    " have only ` 60 min . `",
    "to cross the bridge    torch is not considered here because it has not influence on model behavior .",
    "next models ( @xmath69 , @xmath70 ) can include it but that is not necessary .",
    ".... ( def - parameters   ( n 4 int )    ( ks 2 int )    ( ku 1 int )   ( t0 5 real )   ( t1 10 real )   ( t3 20 real )   ( t4 25 real )   ( t - max 60 real ) ) ....    entities are two sets : one set are variables and the other are values .",
    "set @xmath71 is describing dynamic behavior of the model : in each execution step values from set @xmath72 are assigned to variables from @xmath7 .    1",
    ".   set of soldiers : @xmath73 of _ type _ ` sold ` 2 .",
    "set describing sides of the bridge .",
    "they are introduced as _",
    "places _ ( _ safe _ side and _ unsafe _ side ) of _ type _ ` place ` .",
    "unknown parameter is denoted as @xmath74 or @xmath75 .    ....",
    "( entity ( a ( s0 s1 s2 s3 s4 ) ) ( entity ( as ( safe unsafe ) ) ....    predicates answers the question :    1 .",
    "where is @xmath37  ?",
    "2 .   is @xmath37 in side _ safe _ or _ unsafe _    .... ( pred atplace ?",
    "a ) ( pred ? a ? as )     ....    there are two atomic events :    1 .   two soldiers @xmath37 and @xmath76 are going to _ safe _ side 2 .",
    "single soldier @xmath37 is going to _ unsafe _ side 3 .",
    "event has duration time @xmath40    .... ( es ( unsafe ( ? x ?",
    "y ) safe )      ( time ( max ( ?",
    "ty ) ) ) )    ( eu ( safe ? x unsafe )      ( time ( ?",
    "tx ) ) ) ....    if there is solution for this problem traces should be of finite length @xmath77 coded as finite length vector , such that ` ?",
    "es ` or ` ?",
    "eu ` event of duration ` ?",
    "total - time ` .",
    "this model has no built  in infinite traces .    ....",
    "( er ( foreach r ?",
    "total - time ) ....    initially all @xmath37 are on _ unsafe _ place .",
    "this model has no time counter ( initial - condition ( a ( atunsafe atunsafe atunsafe atunsafe ) ) ) at the end all soldiers must be within @xmath78 minutes in safe side :    .... ( goal - condition      ( a ( atsafe atsafe atsafe atsafe ) )      ( < = total - time t - max ) ) ....    _ operators _ and _ constraints _ constructs serve as additional model input in complex situations where @xmath49 is profiled recursively . +",
    "there are 16 paths from total of 824 paths where timing condition @xmath79 holds . as an example",
    "one path is presented : +    .... path 33 node 0 : transition tosafe     x = 5   y = 10 node 1 : transition tounsafe    x = 5 node 7 : transition tosafe    x = 25   y = 20 node 13 : transition tounsafe    x = 10 node 20 : transition tosafe    x = 10   y = 5 node 21 ....    ` node 0,1,5,13 `  are nodes from reachability tree . variable @xmath80 and @xmath81 are crossing times , for _ tosafe _ transition or @xmath21 event crossing time is @xmath82 .",
    "fig.[fig : efsm ] visualize @xcite solution in the form of extended finite state machine ( ` efsm ` ) .",
    "next step can transform ` efsm ` into the input language for analysis tool .",
    "another possibility is to generate skeleton code in ` c ` or ` java ` programs .",
    "message sequence charts @xcite is another form that can visualize solution ( fig.[fig : msc ] ) .",
    "even the more msc can be used as source for another set of translations into the statecharts , sdl diagrams ",
    "+    4ws1tob.solution",
    "how can _ planning _ and _ scheduling _ methods influence synthesis ? + synergy effect between scheduling and synthesis opens possibilities for interpreting ( ` efsm ` ) in various ways .",
    "each of them benefits through skeleton or templates for ` code ` , ` scripts ` or ` architecture ` definition . during requirement phase",
    "many different scenarios can be automatically generated .",
    "we found that `` side  effects '' or parts of scenarios  specifications that are less obvious but present are reduced . + decidability and computability of our approach is not optimal for big examples because of state explosion problem",
    ". heuristic scheduling algorithms are of little practical importance for synthesis problem .",
    "different problem will in most cases have different declarative program . for that purpose petri net reachability algorithms",
    "will be replaced with satisfiability ( sat ) algorithms .",
    "+ some interpretation of solutions are :    a.   protocol synthesis b.   ` sdl ` process : skeleton of program sdl can be generated and used by designer c.   ` msc ` skeleton processes can be composed in system .",
    "overall behavior is analyzed as early as in requirement phase d.   parallel program job scheduling : an experiment for dynamic job allocation for parallel program is planned using proposed methodology    besides mentioned interpretations other possibilities are :    a.   real  time system job scheduling b.   control software synchronization c.   performance prediction d.   ontology definition concept analysis e.   system maintenance f.   object and methods definition and optimization    proposed approach introduces methodology for identifying and minimization of states in ` fsm ` like models of concurrent reactive systems .",
    "there are various approaches for synthesis problem , the most significant are :    a.   the temporal logic formula describes the system .",
    "synchronization part of the system is derived from temporal formula .",
    "this can be , roughly speaking , interpreted as reverse model checking .",
    "b.   from formal service specification to protocol specification .",
    "formal description is transformed into protocol specification .",
    "even the more , in most cases specification is executable enabling verification , simulation and analysis  c.   extended finite state machine is constructed from executable traces .",
    "traces are sequences of messages , signals or sequence of events .",
    "they can be defined by designer , in this paper intention is to provide traces automatically to the designer .",
    "our approach introduce traces or more preciously event traces as declaration for desired system behavior . an event describe _ crossing the bridge _",
    "( example from section [ sec : example ] .",
    "sequence of events define trace .",
    "the set of all traces represents search space where solution should be found taking timing constraints into the considerations .",
    "+ in this paper traces are interpreted as petri net reachability tree paths .",
    "reachability tree paths and traces describe the same behavior model .",
    "+ if various models @xmath18 have same behavior model then they can be transformed .",
    "transformation is mapping of constructs between models , before mapping constructs are unified .",
    "+ only paths with desired property ( crossing time limit ) are solution paths .",
    "+ another question is how to only generate traces that are solution i.e. to avoid state  space combinatorial explosion .",
    "declarative meta  model has no knowledge about it .",
    "+ modeling for solution has three steps :    a.   model definition b.   translation to domain specific language ( in our case ` pddl - scheduling&planning ` language ) . `",
    "pddl ` can be used as input for scheduling planning tools . c.   translation to high level petri net for analysis and solution finding .",
    "it is obvious fact that _ model  for  solution _ can start and find solution from step _",
    "( ii ) _ or step _ ( iii ) _ without the model . in complex situations , when system is not formally described , where constraints and assertions about the system are contradictory , unknown , unclear or unspecified such model  mixing proves its value .",
    "another motivation is to give designer or modeler support to  play  with with different tools and approaches in order to achieve desired quality of solution .",
    "formal approaches explore the benefits and experience from automatic deductive programming , program transformation as well as literate programming . + previous work were focused on synthesis as component composition : smaller architectural parts or system blocks were composed into the target system .",
    "such approach has usable results for component based architectures like services definition within the intelligent networks as found in numerous @xmath3 recommendations .",
    "later on , working example problem is solved with high level petri net in a way close to approach described in sec.[sec : prt ] . as a consequence , scheduling scenario interpreted as msc scenario yields another synthesis approach .",
    "such interpretation can produce msc chart as solution or synthesize executable specification by means of scheduling methodology .",
    "modeling for solution follows experiments towards synthesis of scenarios and its translation to finite state machine based systems like statecharts or itu - t sdl language .",
    "this paper also try to address such question through reachability tree analysis of scheduling solver .",
    "results and methodology from another research field ( planning and scheduling ) are exercised , yielding synergistic effect on protocol or concurrent reactive system design .",
    "experience shows that scheduling problem generalization and synthesis issues can benefit from each other .",
    "+ in @xcite modeling framework suitable for experiments is introduced .",
    "modeling framework consists of several levels , each level describes position in model hierarchy , from the most abstract level on the top to implementation level at the bottom . within each level components",
    "are introduced ( traditionally called @xmath84 ( * * e**lementary * * c**ommunicating * * p**rocesses ) as black boxes that enables program , tools or even models inter working .",
    "in @xcite synthesis is described as message sequence chart ( msc ) translation into the real - time object oriented model ( room ) .",
    "after that , designer can use room model for simulation as well as other purposes .",
    "formals description technique ( msc ) describing system architecture and behavior is interpreted as executable model .",
    "msc serves as _ top  level  model _ which can be analyzed , simulated and implemented .",
    "+ functional specification of the problem and temporal logic yields state  based automaton as solution for elevator problem @xcite .",
    "satisfiability analysis generates synchronization part of the system",
    ". + synthesis of behavior models from scenarios is introduced in @xcite and @xcite .",
    "+ ` promela ` model serves as input of ` spin ` protocol verifier from @xcite .",
    "results are presented through msc diagrams .",
    "+ results from mathematical description with process algebra and concurrency presented in @xcite are used for further development of metamodel described in section [ sec : scheduling ] .",
    "another metamodel comes from @xcite .",
    "model transformation routines are developed by means of ` noweb ` literate programming tool .",
    "literate programing discipline has been introduced by d.e .",
    "knuth  _ instead of imagining that our main task is to instruct a computer what to do , let us concentrate rather on explaining to human beings what we want a computer to do . _",
    "+ there are many literate programming supporting tools @xcite providing human readable files that incorporate documentation and source code into the single file . in this paper",
    "all sections illustrating concepts and constructs ( functional style programs ) are produced with literate programming tool ` noweb ` @xcite , @xcite .",
    "synergy effect between planning , scheduling and synthesis can improve design process .",
    "there are no universal approach for synthesis problem so only narrow problem domains are possible to solve with difficulties regarding np - hard algorithms and undecidable problems .",
    "this papers describe proof  of  concept rather then industrial strength approach .",
    "+ pros ( + ) and cons ( - ) can be summarized as follows :    1 .",
    "( + )  synergism between synthesis and scheduling planning : all ready developed routines for scheduling have been adopted and used 2 .",
    "( - )  state explosion : petri net can produce unmanageable reachability tree size .",
    "reachability analysis tool support is designed for model checking .",
    "some scheduling issues are unsuitable for model  checking technology 3 .   ( - )  narrow problem domain : declarative model requires significant changes with small domain change 4 .",
    "( - )  small scale problems : synthesized components are sometimes easier to handle by hand 5 .",
    "( + )  proof of concept : model transformation is usable programming paradigm 6 .   ( - )  complex theoretical background : designer should have deep understanding of all models and translation process 7 .",
    "( + )  solution for critical applications : mission critical software can be developed in this way yielding stable solutions 8 .",
    "( + )  open research platform : modifications and updating to new algorithms 9 .",
    "( + )  interworking of different paradigms and formal methods    further work will ( 1 ) use satisfiability algorithms and ( 2 ) explore formal methods interworking .",
    "synthesis method should serve as testbed for formal languages semantic analysis and executable specification languages .",
    "s.  uchitel and j.  kramer , `` a workbench for synthesising behaviour models from scenarios , '' in _ proceedings of the @xmath85 intl .",
    "conf . on software engineering_.1em plus",
    "0.5em minus 0.4emtoronto , canada : acm press , 2001 .",
    "s.  uchitel , r.  chatley , j.  kramer , and j.  magee , `` system architecture : the context for scenario - based model synthesis , '' in _",
    "sigsoft 04/fse-12 : proceedings of the 12th acm sigsoft twelfth international symposium on foundations of software engineering_.1em plus 0.5em minus 0.4em new york , ny , usa : acm press , 2004 , pp .",
    "j.  rushby , `` disappearing formal methods , '' in _ high - assurance systems engineering symposium_.1em plus 0.5em minus 0.4emalbuquerque , nm : association for computing machinery , nov 2000 , pp",
    "[ online ] .",
    "available : http://www.csl.sri.com/papers/hase00/    b.  bruno and m.  randic , `` model based scheduling scenario generation , '' in _ daaam international scientific book 2006 _ ( b.  katalinic , ed . ) , ch .  04 , pp .",
    "031044 , daaam international vienna : tu wien , karlsplatz 13/311 , a-1040 vienna , austria , 2006 .",
    "t.  c. ruys and e.  brinksma , `` experience with literate programming in the modelling and validation of systems , '' in _ proceedings of the fourth international conference on tools and algorithms for the construction and analysis of systems ( tacas98 ) _ ( b.  steffen , ed . ) , no .",
    "1384 in lecture notes in computer science ( lncs ) , ( lisbon , portugal ) , pp .",
    "393408 , springer - verlag , berlin , apr . 1998 .",
    "s.  owre and n.  shankar , `` abstract datatypes in pvs , '' tech .",
    "sri - csl-93 - 9r , computer science laboratory , sri international , menlo park , ca , dec 1993 .",
    "extensively revised june 1997 ; also available as nasa contractor report cr-97 - 206264 .",
    "s.  leue , l.  mehrmann , and m.  rezai , `` synthesizing room models from message sequence chart specifications , '' tech . rep",
    ". 9806 , electrical and computer engineering , university of waterloo , waterloo , ontario n2l 3g1 , canada , april 1998 .",
    "itu , _ z.120 message sequence charts ( msc96 ) _ , itu - t telecommunication standardisation sector , geneva , 1996 .",
    ", `` km3 : a dsl for metamodel specification , '' pp . 171185 , 2006 .",
    "[ online ] .",
    "available : { http://www.lina.sciences.univ-nantes.fr/publications/2006/jb06a}[\\{http://www.lina.sciences.univ-nantes.fr/publications/2006/jb06a } ] , `` petri net modeling for reactive system verification , '' in _ proceedings of 7th contel _",
    "( 1 ) , ( zagreb ) , pp .  257264 , fer ",
    "ieee , june 2003 ."
  ],
  "abstract_text": [
    "<S> this paper presents deductive programming for scheduling scenario generation . modeling for solution is achieved through program transformations . </S>",
    "<S> first , declarative model for scheduling problem domain is introduced . </S>",
    "<S> after that model is interpreted as scheduling domain language and as predicate transition petri net . </S>",
    "<S> generated reachability tree presents search space with solutions . at the end results </S>",
    "<S> are discussed and analyzed . </S>"
  ]
}