{
  "article_text": [
    "andrew gordon @xcite defines a _ nominal calculus _ to be a computational formalism that includes a set of _ pure names _ and allows the dynamic generation of _ fresh _ , _ unguessable _ names .",
    "a name is _ pure _ whenever it is only useful for comparing for identity with other names .",
    "the use of pure names is ubiquitous in programming languages .",
    "some important examples are memory pointers in imperative languages , identifiers in concurrent programming languages , and nonces in security protocols .",
    "in addition to pure names , a _ nominal process calculus _ should provide mechanisms for _ concurrency _ and _ inter - process communication_. a computational model that provides all these features is an adequate abstract formalism for the analysis of _ multithreaded _ and _ distributed _ software .    [ [ the - problem ] ] the problem + + + + + + + + + + +    automated verification of specifications in a nominal process calculus becomes particularly challenging in presence of the following three features : the possibility of generating fresh names ( _ name generation _ ) ; the possibility of transmitting names ( _ name mobility _ ) ; the possibility of dynamically adding new threads of control ( _ unbounded control _ ) .",
    "in fact , a calculus that provides all the previous features can be used to specify systems with a state - space infinite in _ several dimensions_.",
    "this feature makes difficult ( if not impossible ) the application of finite - state verification techniques or techniques based on abstractions of process specifications into petri nets or ccs - like models . in recent years",
    "there have been several attempts of extending automated verification methods from finite - state to infinite - state systems @xcite . in this paper",
    "we are interested in investigating the possible application of the methods we proposed in @xcite to verification problems of interest for nominal process calculi .",
    "[ [ constraint - based - symbolic - model - checking ] ] constraint - based symbolic model checking + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in @xcite we introduced a specification language , called msr(@xmath0 ) , for the analysis of communication protocols whose specifications are parametric in several dimensions ( e.g. number of servers , clients , and tickets as in the model of the ticket mutual exclusion algorithm shown in @xcite ) .",
    "msr(@xmath0 ) combines multiset rewriting over first order atomic formulas @xcite with constraints programming .",
    "more specifically , multiset rewriting is used to specify the control part of a concurrent system , whereas constraints are used to symbolically specify the relations over local data . the verification method proposed in @xcite",
    "allows us to symbolically reason on the behavior of msr(@xmath0 ) specifications .",
    "to this aim , following @xcite we introduced a symbolic representation of infinite collections of global configurations based on the combination of multisets of atomic formulas and constraints , called constrained configurations .",
    "the verification procedure performs a symbolic backward reachability analysis by means of a symbolic _ pre - image _ operator that works over constrained configurations @xcite .",
    "the main feature of this method is the possibility of automatically handling systems with an arbitrary number of components .",
    "furthermore , since we use a symbolic and finite representation of possibly infinite sets of configurations , the analysis is carried out without loss of precision . +",
    "a natural question for our research is whether and how these techniques can be used for verification of abstract models of multithreaded programs .",
    "[ [ our - contribution ] ] our contribution + + + + + + + + + + + + + + + +    in this paper we propose a sound , and fully automatic verification method for abstract models of multithreaded programs that provide _ name generation _",
    ", _ name mobility _ , and _ unbounded control_. as a high level specification language we adopt here an extension with value - passing of the formalism of @xcite based on families of state machines used to specify abstractions of multithreaded software libraries .",
    "the resulting language is called thread definition language ( tdl ) .",
    "this formalism allows us to keep separate the finite control component of a thread definition from the management of local variables ( that in our setting range over a infinite set of names ) , and to treat in isolation the operations to generate fresh names , to transmit names , and to create new threads . in the present paper",
    "we will show that the extension of the model of @xcite with value - passing makes the model turing equivalent .",
    "the verification methodology is based on the encoding of tdl programs into a specification in the instance msr@xmath1 of the language scheme msr(@xmath2 )  of@xcite .",
    "msr@xmath1 is obtained by taking as constraint system a subclass of linear arithmetics with only @xmath3 and @xmath4 relations between variables , called name constraints ( @xmath5 ) .",
    "the low level specification language msr@xmath1 is not just instrumental for the encoding of tdl programs .",
    "indeed , it has been applied to model consistency and mutual exclusion protocols in @xcite . via this encoding ,",
    "the verification method based on symbolic backward reachability obtained by instantiating the general method for msr(@xmath2 )  to nc - constraints can now be applied to abstract models of multithreaded programs .",
    "although termination is not guaranteed in general , the resulting verification method can succeed on practical examples as the challenge - response tdl program defined over binary predicates we will illustrated in the present paper .",
    "furthermore , by propagating the sufficient conditions for termination defined in @xcite back to tdl programs , we obtain an interesting class of decidable problems for abstract models of multithreaded programs still providing name generation , name mobility , and unbounded control .",
    "[ [ plan - of - the - paper ] ] plan of the paper + + + + + + + + + + + + + + + + +    in section [ nominalcalculus ] we present the thread definition language ( tdl ) with examples of multithreaded programs .",
    "furthermore , we discuss the expressiveness of tdl programs showing that they can simulate two counter machines . in section [ msrtranslation ] , after introducing the msr@xmath1 formalism , we show that tdl programs can be simulated by msr@xmath1 specifications . in section [ verification ]",
    "we show how to transfer the verification methods developed for msr(@xmath2 )  to tdl programs .",
    "furthermore , we show that safety properties can be decided for the special class of monadic tdl programs . in section [ conclusions ]",
    "we address some conclusions and discuss related work .",
    "in this section we will define tdl programs .",
    "this formalism is a natural extension with value - passing of the communicating machines used by @xcite to specify abstractions of multithreaded software libraries .",
    "[ [ terminology ] ] terminology + + + + + + + + + + +    let @xmath6 be a denumerable set of _ names _ equipped with the relations @xmath3 and @xmath7 and a special element @xmath8 such that @xmath9 for any @xmath10 .",
    "furthermore , let @xmath11 be a denumerable set of variables , @xmath12 a finite set of constants , and @xmath13 a finite set of _ internal action _ labels .",
    "for a fixed @xmath14 , the set of _ expressions _ is defined as @xmath15 ( when necessary we will use @xmath16 to explicit the set of variables @xmath17 upon which expressions are defined ) .",
    "the set of _ channel expressions _ is defined as @xmath18 .",
    "channel expressions will be used as synchronization labels so as to establish communication links only at execution time .",
    "+ a _ guard over @xmath17 _ is a conjunction @xmath19 , where @xmath20 is either @xmath21 , @xmath22 or @xmath23 with @xmath24 and @xmath25 for @xmath26 .",
    "an _ assignment _",
    "@xmath27 from @xmath17 to @xmath28 is a conjunction like @xmath29 where @xmath30 , @xmath31 for @xmath32 and @xmath33 for @xmath34 .",
    "a _ message template @xmath35 over @xmath17 _ is a tuple @xmath36 of variables in @xmath17 .",
    "a _ tdl program _ is a set @xmath37 of _ thread definitions _",
    "( with distinct names for local variables control locations ) .",
    "a _ thread definition _",
    "@xmath38 is a tuple @xmath39 , where @xmath40 is a finite set of _ control locations _",
    ", @xmath41 is the initial location , @xmath14 is a finite set of _ local variables _ , and @xmath42 is a set of rules . given @xmath43 , and @xmath44 , a _ rule _ has one of the following forms :    * _ internal move _ : @xmath45}$ ] , where @xmath46 is a _",
    "guard over @xmath17 _ , and @xmath27 is an _ assignment _ from @xmath17 to @xmath17 ; * _ name generation _ : @xmath47}$ ] , where @xmath24 , and the expression @xmath48 denotes a _ fresh name _ ; * _ thread creation : _ @xmath49}$ ] , where @xmath50 , and @xmath27 is an _ assignment from @xmath17 to @xmath28 _ that specifies the initialization of the local variables of the new thread ; * _ message sending : _ @xmath51}$ ] , where @xmath52 is a _ channel expression _ , @xmath35 is a _ message template over @xmath17 _ that specify which names to pass , @xmath46 is a _",
    "guard over @xmath17 _ , and @xmath27 is an _ assignment _ from @xmath17 to @xmath17 . *",
    "_ message reception : _",
    "@xmath53}$ ] , where @xmath52 is a channel expression , @xmath35 is a message template over a _",
    "new _ set of variables @xmath54 ( @xmath55 ) that specifies the names to receive , @xmath46 is a _",
    "guard over @xmath56 _ and @xmath27 is an _ assignment _ from @xmath56 to @xmath17 .    before giving an example",
    ", we will formally introduce the operational semantics of tdl programs .      in the following",
    "we will use @xmath57 to indicate the subset of _ used names _ of @xmath6 .",
    "every constant @xmath58 is mapped to a distinct name @xmath59 , and @xmath8 is mapped to @xmath8 .",
    "+ let @xmath60 and @xmath61 .",
    "a _ local configuration _ is a tuple @xmath62 where @xmath63 and @xmath64 is the current value of the variable @xmath65 for @xmath66 .",
    "+ a _ global configuration _",
    "@xmath67 is such that @xmath68 and @xmath69 are local configurations defined over @xmath57 and over the thread definitions in @xmath70 .",
    "note that there is no relation between indexes in a global configuration in @xmath71 and in @xmath70 ; @xmath71 is a _ pool _ of active threads , and _ several active threads _ can be instances of the same _ thread definition_. + given a local configuration @xmath62 , we define the _ valuation _ @xmath72 as @xmath73 if @xmath65 , @xmath74 if @xmath58 , and @xmath75 .",
    "furthermore , we say that @xmath72 satisfies the guard @xmath46 if @xmath76 , where @xmath72 is extended to constraints in the natural way ( @xmath77 , etc . ) . + the execution of @xmath78 has the effect of updating the local variable @xmath79 of a thread with the current value of @xmath52 ( a name taken from the set of used values @xmath57 ) . on the contrary ,",
    "the execution of @xmath80 associates a _",
    "fresh unused name _ to @xmath79 .",
    "the formula @xmath81 has the effect of adding a new thread ( in its initial control location ) to the current global configuration .",
    "the initial values of the local variables of the generated thread are determined by the execution of @xmath27 whose source variables are the local variables of the parent thread .",
    "the channel names used in a rendez - vous are determined by evaluating the channel expressions tagging sender and receiver rules .",
    "value passing is achieved by extending the evaluation associated to the current configuration of the receiver so as to associate the output message of the sender to the variables in the input message template .",
    "the operational semantics is given via a binary relation @xmath82 defined as follows .",
    "[ sos ] let @xmath83 , and @xmath84 be a local configuration for @xmath60 , @xmath61 , then :    * if there exists a rule @xmath45}$ ] in @xmath42 such that @xmath85 satisfies @xmath46 , then @xmath86 ( meaning that only @xmath87 changes ) where @xmath88 , @xmath89 if @xmath29 is in @xmath27 , @xmath90 otherwise , for @xmath66 . *",
    "if there exists a rule @xmath91}$ ] in @xmath42 , then @xmath92 where @xmath88 , @xmath93 is an unused name , i.e. , @xmath94 , @xmath95 for every @xmath96 , and @xmath97 ; * if there exists a rule @xmath98}$ ] in @xmath42 with @xmath99 , @xmath100 , and @xmath27 is defined as @xmath101 then @xmath102 ( we add a new thread whose initial local configuration is @xmath103 ) where @xmath104 , and @xmath105 .",
    "* let @xmath106 ( distinct from @xmath87 ) be a local configuration in @xmath71 associated with @xmath99 .",
    "+ let @xmath51}$ ] in @xmath42 and @xmath107}$ ] in @xmath108 be two rules such that @xmath36 , @xmath109 and @xmath110 ( message templates match ) . we define @xmath111 as the _ value passing _",
    "evaluation @xmath112 for @xmath113 , and @xmath114 for @xmath115 .",
    "+ now if @xmath116 ( channel names match ) , @xmath85 satisfies @xmath46 , and that @xmath111 satisfies @xmath117 , then @xmath118 where @xmath88 , @xmath119 if @xmath120 is in @xmath27 , @xmath90 otherwise for @xmath66 ; @xmath121 , @xmath122 if @xmath123 is in @xmath124 , @xmath125 otherwise for @xmath126 .    an _ initial global configuration _",
    "@xmath127 has an _ arbitrary ( but finite ) number _ of threads with local variables all set to @xmath8 .",
    "a _ run _ is a sequence @xmath128 such that @xmath129 for @xmath130 .",
    "a global configuration @xmath71 is _ reachable _ from @xmath127 if there exists a run from @xmath127 to @xmath71 .",
    "[ alicebob ] let us consider a _ challenge and response _ protocol in which the goal of two agents alice and bob is to exchange a pair of new names @xmath131 , the first one created by alice and the second one created by bob , so as to build a composed secret key .",
    "we can specify the protocol by using new names to dynamically establish _ private channel names _ between instances of the initiator and of the responder .",
    "the tdl program in figure [ model ] follows this idea .",
    "the thread @xmath132 specifies the behavior of the initiator .",
    "he first creates a new name using the internal action @xmath133 , and stores it in the local variable @xmath134 .",
    "then , he sends @xmath134 on channel @xmath135 ( a constant ) , waits for a name @xmath136 on a channel with the same name as the value of the local variable @xmath134 ( the channel is specified by variable @xmath134 ) and then stores @xmath136 in the local variable @xmath137 .",
    "the thread @xmath138 specifies the behavior of the responder . upon reception of a name @xmath79 on channel @xmath135 ,",
    "he stores it in the local variable @xmath139 , then creates a new name stored in local variable @xmath140 and finally sends the value in @xmath140 on channel with the same name as the value of @xmath139 . the thread @xmath141 non - deterministically creates new thread instances of type @xmath132 and @xmath138 .",
    "the local variable @xmath79 is used to store new names to be used for the creation of a new thread instance .",
    "initially , all local variables of threads @xmath142 are set to @xmath8 . in order to allow process instances to participate to several sessions ( potentially with different principals ) , we could also add the following rule @xmath143}\\ ] ] in this rule we require that _ roles _ and _ identities _ do not change from session to session .",
    "starting from @xmath145 , and running the _ main _ thread we can generate any number of copies of the threads @xmath132 and @xmath138 each one with a unique identifier .",
    "thus , we obtain global configurations like @xmath146 where @xmath147 for @xmath148",
    ". the threads of type @xmath132 and @xmath138 can start parallel sessions whenever created . for @xmath149 and @xmath150 one possible session is as follows .",
    "+ starting from @xmath151 if we apply the first rule of thread @xmath132 to @xmath152 we obtain @xmath153 where @xmath154 is the generated name ( @xmath154 is distinct from @xmath8 , @xmath155 , and @xmath156 ) .",
    "now if we apply the second rule of thread @xmath132 and the first rule of thread @xmath138 ( synchronization on channel @xmath135 ) we obtain @xmath157 if we apply the second rule of thread @xmath138",
    "we obtain @xmath158 finally , if we apply the last rule of thread @xmath132 and @xmath138 ( synchronization on channel @xmath154 ) we obtain @xmath159 thus , at the end of the session the thread instances @xmath155 and @xmath156 have both a local copy of the fresh names @xmath154 and @xmath160 .",
    "note that a copy of the main thread @xmath161 is always active in any reachable configuration , and , at any time , it may introduce new threads ( either of type @xmath132 or @xmath138 ) with fresh identifiers .",
    "generation of fresh names is also used by the threads of type @xmath132 and @xmath138 to create nonces .",
    "furthermore , threads can restart their life cycle ( without changing identifiers ) .",
    "thus , in this example the set of possible reachable configurations is infinite and contains configurations with arbitrarily many threads and fresh names .",
    "since names are stored in the local variables of active threads , the local data also range over an infinite domain .      to study the expressive power of the tdl language , we will compare it with the turing equivalent formalism called two counter machines .",
    "a two counters machine configurations is a tuple @xmath162 where @xmath163 is control location taken from a finite set @xmath40 , and @xmath164 and @xmath165 are natural numbers that represent the values of the counters @xmath166 and @xmath167 .",
    "each counter can be incremented or decremented ( if greater than zero ) by one .",
    "transitions combine operations on individual counters with changes of control locations . specifically , the instructions for counter @xmath168 are as follows @xmath169    [ cols= \" < \" , ]     @xmath169 a two counter machine consists then of a list of instructions and of the initial state @xmath170 .",
    "the operational semantics is defined according to the intuitive semantics of the instructions .",
    "problems like control state reachability are undecidable for this computational model",
    ". + the following property then holds .",
    "[ twocounters]tdl programs can simulate two counter machines .    in order to define a tdl program that simulates a two counter machine we proceed as follows .",
    "@xmath171}\\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{tstc ! { \\langle { id , last } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { busy}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{tstc ! { \\langle { id , last } \\rangle}}\\,{wait } } \\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{nz ?",
    "{ \\langle { x } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { wait}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{nz ? { \\langle { x } \\rangle}}\\,{acknz } } & { [ } id = x{]}\\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{z ?",
    "{ \\langle { x } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { wait}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{z ? { \\langle { x } \\rangle}}\\,{ackz } } & { [ } id = x{]}\\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{yes ! { \\langle { i d } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { ackz}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{yes ! { \\langle { i d } \\rangle}}\\,{idle } } \\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{no ! { \\langle { i d } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { acknz}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{no ! { \\langle { i d } \\rangle}}\\,{idle } } \\end{array}\\end{array } \\\\",
    "\\\\ \\begin{array}{l } \\mathbf{(decrement ) } \\\\ \\\\ \\begin{array}{ll } ~~{\\setbox0=\\hbox{$\\ { } ^{dec ? { \\langle { x } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { idle}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{dec ? { \\langle { x } \\rangle}}\\,{dbusy } } & { [ } id = x{]}\\\\ \\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{decc ! { \\langle { id , last } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { dbusy}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{decc ! { \\langle { id , last } \\rangle}}\\,{dwait } } \\\\ \\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{dack ? { \\langle { x , u } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { dwait}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{dack ? { \\langle { x , u } \\rangle}}\\,{dack } } & { [ } id = x , last:=u{]}\\\\ \\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{dack ! { \\langle { i d } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { dack}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{dack ! { \\langle { i d } \\rangle}}\\,{idle } } \\end{array}\\end{array } \\\\ \\\\ \\begin{array}{l } \\mathbf{(increment ) } \\\\ \\\\\\begin{array}{ll } ~~{\\setbox0=\\hbox{$\\ { } ^{inc ? { \\langle { x } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { idle}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{inc ? { \\langle { x } \\rangle}}\\,{inew } } & { [ } id = x{]}\\\\ \\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{new}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { inew}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{new}\\,{irun } } & { [ } aux:=new{]}\\\\ \\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{run}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { irun}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{run}\\,{iack } } & { [ } run~cell~with~ idc:=id ; prev:=last;next:=aux{]}\\\\ \\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{iack ! { \\langle { i d } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { iack}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{iack ! { \\langle { i d } \\rangle}}\\,{idle } } & { [ } last:=aux{]}\\end{array}\\end{array } \\end{array } \\end{array}\\ ] ]    every counter is represented via a _ doubly linked list _ implemented via a collection of threads of type @xmath172 and with a unique thread of type @xmath173 pointing to the head of the list .    @xmath174}\\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{tstc ?",
    "{ \\langle { x , u } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { idle}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{tstc ? { \\langle { x , u } \\rangle}}\\,{acknz } } ~~{[}x = idc , u = next , prev\\neq next { ] } \\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{z ! { \\langle { idc } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { ackz}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{z",
    "! { \\langle { idc } \\rangle}}\\,{idle } } \\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{nz",
    "! { \\langle { idc } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { acknz}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{nz ! { \\langle { idc } \\rangle}}\\,{idle } } \\end{array } \\\\",
    "\\\\ \\begin{array}{l } \\mathbf{(decrement ) } \\\\ \\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{dec ? { \\langle { x , u } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { idle}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{dec ? { \\langle { x , u } \\rangle}}\\,{dec } } ~~{[}x = idc , u = next ,",
    "prev\\neq next{]}\\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{dack ! { \\langle { idc , prev } \\rangle}}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { dec}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{dack",
    "! { \\langle { idc , prev } \\rangle}}\\,{idle } } \\end{array } \\end{array}\\ ] ]    the @xmath175-th counter having value zero is represented as the _ empty list _",
    "@xmath176 for some name @xmath177 and @xmath178 ( we will explain later the use of @xmath178 ) . the @xmath175-th counter having value @xmath179 is represented as @xmath180 for distinct names @xmath181 .",
    "the instructions on a counter are simulated by sending messages to the corresponding @xmath173 thread .",
    "the messages are sent on channel @xmath182 ( zero test ) , @xmath183 ( decrement ) , and @xmath184 ( increment ) . in reply to each of these messages , the thread @xmath173 sends an acknowledgment , namely @xmath185 for the zero test , @xmath186 for the decrement , @xmath187 for the increment operation . @xmath173 interacts with the @xmath172 threads via the messages @xmath188 , @xmath189 , @xmath190 acknowledged by messages @xmath191 , @xmath192 .",
    "the interactions between a @xmath173 thread and the @xmath172 threads is as follows .",
    "[ [ zero - test ] ] zero test + + + + + + + + +    upon reception of a message @xmath194 on channel @xmath182 , the @xmath173 thread with local variables @xmath195 checks that its identifier @xmath196 matches @xmath79 - see transition from @xmath197 to @xmath198 - sends a message @xmath199 on channel @xmath188 directed to the cell pointed to by @xmath200 ( transition from @xmath198 to @xmath201 ) , and then waits for an answer . if the answer is sent on channel @xmath202 , standing for non - zero , ( resp .",
    "@xmath203 standing for zero )",
    "- see transition from @xmath201 to @xmath204 ( resp .",
    "@xmath205 ) - then it sends its identifier on channel @xmath206 ( resp .",
    "@xmath207 ) as an acknowledgment to the first message - see transition from @xmath204 ( resp .",
    "@xmath208 ) to @xmath197 . as shown in fig .",
    "[ thecell ] , the thread @xmath172 with local variables @xmath209 , @xmath210 , and @xmath211 that receives the message @xmath188 , i.e. , pointed to by a thread @xmath173 with the same identifier as @xmath209 , sends an acknowledgment on channel @xmath203 ( zero ) if @xmath212 , and on channel @xmath202 ( non - zero ) if @xmath213 .    [ [ decrement ] ] decrement + + + + + + + + +    upon reception of a message @xmath194 on channel @xmath183 , the @xmath173 thread with local variables @xmath195 checks that its identifier @xmath196 matches @xmath79 ( transition from @xmath197 to @xmath214 ) , sends a message @xmath199 on channel @xmath189 directed to the cell pointed to by @xmath200 ( transition from @xmath198 to @xmath201 ) , and then waits for an answer .",
    "if the answer is sent on channel @xmath192 ( transition from @xmath215 to @xmath186 ) then it updates the local variable @xmath200 with the pointer @xmath216 sent by the thread @xmath172 , namely the @xmath210 pointer of the cell pointed to by the current value of @xmath200 , and then sends its identifier on channel @xmath186 to acknowledge the first message ( transition from @xmath186 to @xmath197 ) .    as shown in fig .",
    "[ thecell ] , a thread @xmath172 with local variables @xmath209 , @xmath210 , and @xmath211 that receives the message @xmath189 and such that @xmath217 sends as an acknowledgment on channel @xmath192 the value @xmath210",
    ".    [ [ increment ] ] increment + + + + + + + + +    to simulate the increment operation , _ last _ does not have to interact with existing @xmath172 threads . indeed , it only has to link a new _ cell _ thread to the head of the list ( this is way the @xmath172 thread has no operations to handle the increment operation ) . as shown in fig .",
    "[ lastcell ] this can be done by creating a new name stored in the local variable @xmath218 ( transition from @xmath219 to @xmath220 ) and spawning a new _ cell _ thread ( transition from @xmath220 to @xmath187 ) with @xmath210 pointer equal to @xmath200 , and @xmath211 pointer equal to @xmath218 .",
    "finally , it acknowledges the increment request by sending its identifier on channel @xmath187 and updates variable @xmath200 with the current value of @xmath218 .",
    "@xmath222}\\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{freshp}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { init_1}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{freshp}\\,{init_2 } } ~~{[}p_1:=new{]}\\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{runc}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { init_2}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{runc}\\,{init_3 } } ~~{[}run~cell~with~ idc:=nid_1 ; prev:=p_1;next:=p_1 { ] } \\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{runl}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { init_3}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{runl}\\,{init_4 } } ~~{[}run~last~with~ idc:=nid_1 ; last:=p_1;aux:=\\bot { ] } \\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{freshid}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { init_4}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{freshid}\\,{init_5 } } ~~{[}nid_2:=new{]}\\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{freshp}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { init_5}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{freshp}\\,{init_6 } } ~~{[}p_2:=new{]}\\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{runc}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { init_6}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{runc}\\,{init_7 } } ~~{[}run~cell~with~ idc:=nid_2 ; prev:=p_2;next:=p_2{]}\\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{runl}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { init_7}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{runl}\\,{init_8 } } ~~{[}run~last~with~ idc:=nid_2 ; last:=p_2;aux:=\\bot { ] } \\medskip\\\\ ~~{\\setbox0=\\hbox{$\\ { } ^{runcm}\\ $ }    \\setbox1=\\hbox{$\\longrightarrow$ }    \\ifdim\\wd0<\\wd1\\setbox0=\\box1\\else\\relax\\fi    { init_8}\\,\\mathop{\\hbox to \\wd0{\\rightarrowfill}}\\limits^{runcm}\\,{init_9 } } ~~{[}run~2cm~with~ id_1:=nid_1 ; id_2:=nid_2{]}\\end{array } \\end{array } \\end{array}\\ ] ]    [ [ two - counter - machine - instructions ] ] two counter machine instructions + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we are now ready to use the operations provided by the thread @xmath173 to simulate the instructions of a two counter machine . as shown in fig",
    ". [ twocm ] , we use a thread @xmath223 with two local variables @xmath224 to represent the list of instructions of a 2 cm with counters @xmath225 .",
    "control locations of the two counter machines are used as local states of the thread @xmath223 .",
    "the initial local state of the @xmath223 thread is the initial control location .",
    "the increment instruction on counter @xmath168 at control location @xmath226 is simulated by an handshaking with the @xmath173 thread with identifier @xmath227 : we first send the message @xmath228 , wait for the acknowledgment on channel @xmath187 and then move to state @xmath229 .",
    "similarly , for the decrement instruction on counter @xmath168 at control location @xmath226 we first send the message @xmath230 .",
    "if we receive an acknowledgment on channel @xmath231 we send a @xmath183 request , wait for completion and then move to @xmath229 .",
    "if we receive an acknowledgment on channel @xmath232 we directly move to @xmath233 .",
    "[ [ initialization ] ] initialization + + + + + + + + + + + + + +    the last step of the encoding is the definition of the initial state of the system . for this purpose",
    ", we use the thread @xmath132 of fig .",
    "the first four rules of @xmath132 initialize the first counter : they create two new names @xmath234 ( an identifier for counter @xmath166 ) and @xmath235 , and then spawn the new threads @xmath236 .",
    "the following four rules spawns the new threads @xmath237 . after this stage",
    ", we create a thread of type @xmath238 to start the simulation of the instructions of the two counter machines .",
    "the initial configuration of the whole system is @xmath239 . by construction",
    "we have that an execution step from @xmath240 to @xmath241 is simulated by an execution run going from a global configuration in which the local state of thread @xmath223 is @xmath242 and in which we have @xmath93 occurrences of thread @xmath172 with the same identifier @xmath227 for @xmath243 , to a global configuration in which the local state of thread @xmath223 is @xmath244 and in which we have @xmath245 occurrences of thread @xmath172 with the same identifier @xmath227 for @xmath243 .",
    "thus , every executions of a 2 cm @xmath246 corresponds to an execution of the corresponding tdl program that starts from the initial configuration @xmath239 .    as a consequence of the previous theorem",
    ", we have the following corollary .    [ reachability ]",
    "given a tdl program , a global configurations @xmath71 , and a control location @xmath163 , deciding if there exists a run going from @xmath127 to a global configuration that contains @xmath163 ( control state reachability ) is an undecidable problem .",
    "as mentioned in the introduction , our verification methodology is based on a translation of tdl programs into low level specifications given in msr@xmath1 .",
    "our goal is to extend the connection between ccs and petri nets @xcite to tdl and msr so as to be able to apply the verification methods defined in @xcite to multithreaded programs . in the next section",
    "we will summarize the main features of the language msr@xmath1 introduced in @xcite .",
    "@xmath5-constraints are linear arithmetic constraints in which conjuncts have one of the following form : @xmath21 , @xmath247 , @xmath248 , @xmath249 , or @xmath250 , @xmath79 and @xmath136 being two variables from a denumerable set @xmath11 that range over the rationals , and @xmath135 being an integer .",
    "the _ solutions _",
    "@xmath251 of a constraint @xmath252 are defined as all evaluations ( from @xmath11 to @xmath253 ) that satisfy @xmath252 .",
    "a _ constraint _",
    "@xmath252 is _ satisfiable _ whenever @xmath254 .",
    "furthermore , @xmath255 _ entails _",
    "@xmath252 whenever @xmath256 .",
    "@xmath5-constraints are closed under elimination of existentially quantified variables .",
    "+ let @xmath257 be a set of predicate symbols . an _ atomic formula _",
    "@xmath258 is such that @xmath259 , and @xmath260 are _ distinct _ variables in @xmath11 .",
    "multiset _ of atomic formulas is indicated as @xmath261 , where @xmath262 and @xmath263 have distinct variables ( we use variable renaming if necessary ) , and @xmath264 is the multiset constructor . + in the rest of the paper we will use @xmath265 , @xmath6 , @xmath266 to denote _ multisets _ of atomic formulas , @xmath267 to denote the _ empty multiset _ ,",
    "@xmath268 to denote _ multiset union _ and @xmath269 to denote _",
    "multiset difference_. an msr@xmath1 _ configuration _ is a multiset of _ ground atomic formulas _ , i.e. , atomic formulas like @xmath270 where @xmath271 is a rational for @xmath272 . +",
    "an msr@xmath1 _ rule _ has the form @xmath273 , where @xmath265 and @xmath274 are two ( possibly empty ) multisets of atomic formulas with _ distinct _",
    "variables built on predicates in @xmath257 , and @xmath252 is an @xmath5-constraint .",
    "the ground instances of an msr@xmath1 rule are defined as @xmath275 where @xmath111 is extended in the natural way to multisets , i.e. , @xmath276 and @xmath277 are msr@xmath1 configurations . + an msr@xmath1 _ specification _",
    "@xmath278 is a tuple @xmath279 , where @xmath257 is a finite set of predicate symbols , @xmath280 is finite a set of ( _ initial _ ) msr@xmath1 configurations , and @xmath281 is a finite set of msr@xmath1 rules over @xmath257 . + the operational semantics describes the update from a configuration @xmath265 to one of its possible successor configurations @xmath274 .",
    "@xmath274 is obtained from @xmath265 by rewriting ( modulo associativity and commutativity ) the left - hand side of an instance of a rule into the corresponding right - hand side . in order to be fireable",
    ", the left - hand side must be included in @xmath265 . since",
    "instances and rules are selected in a non deterministic way , in general a configuration can have a ( possibly infinite ) set of ( one - step ) successors .",
    "+   + formally , a rule @xmath282 from @xmath281 is enabled at @xmath265 _ via _ the ground substitution @xmath283 if and only if @xmath284 .",
    "firing rule @xmath42 enabled at @xmath265 via @xmath111 yields the new configuration @xmath285 we use @xmath286 to denote the firing of a rule at @xmath265 yielding @xmath274 . +",
    "a run is a sequence of configurations @xmath287 with @xmath288 such that @xmath289 for @xmath130 .",
    "a configuration @xmath265 is reachable if there exists @xmath288 such that @xmath290 , where @xmath291 is the transitive closure of @xmath292 .",
    "finally , the successor and predecessor operators @xmath293 and @xmath294 are defined on a set of configurations @xmath295 as @xmath296 and @xmath297 , respectively . @xmath298 and @xmath299 denote their transitive closure . + as shown in @xcite , petri nets represent a natural abstractions of msr@xmath1 ( and more in general of msr rule with constraints ) specifications .",
    "they can be encoded , in fact , in _ propositional _ msr specifications ( e.g. abstracting away arguments from atomic formulas ) .",
    "the first thing to do is to find an adequate representation of names .",
    "since all we need is a way to distinguish old and new names , we just need an infinite domain in which the @xmath3 and @xmath7 relation are supported .",
    "thus , we can interpret names in @xmath6 either as integer of as rational numbers .",
    "since operations like variable elimination are computationally less expensive than over integers , we choose to view names as non - negative rationals .",
    "thus , a local ( tdl ) configuration @xmath300 is encoded as the atomic formula @xmath301 , where @xmath93 is a non - negative rational .",
    "furthermore , a global ( tdl ) configuration @xmath302 is encoded as an msr@xmath1 configuration @xmath303 @xmath304 where the value @xmath305 in the auxiliary atomic formula @xmath306 is an rational number strictly greater than all values occurring in @xmath307 .",
    "the predicate @xmath133 will allow us to generate unused names every time needed .",
    "+ the translation of constants @xmath12 , and variables is defined as follows : @xmath308 for @xmath309 , @xmath310 , @xmath311 for @xmath312 . we extend  @xmath313   in the natural way on a guard @xmath46 , by decomposing every formula @xmath23 into @xmath314 and @xmath315 .",
    "we will call @xmath316 the resulting _ set _ of @xmath5-constraints .",
    "is the constraint @xmath317 then @xmath316 consists of the two constraints @xmath318 and @xmath319 . ]",
    "+ given @xmath61 , we define @xmath54 as the set of new variables @xmath320 .",
    "now , let us consider the assignment @xmath27 defined as @xmath321 ( we add assignments like @xmath322 if some variable does not occur as target of @xmath27 ) .",
    "then , @xmath323 is the @xmath5-constraint @xmath324 .",
    "+ the translation of thread definitions is defined below ( where we will often refer to example [ alicebob ] ) .    [",
    "[ initial - global - configuration ] ] initial global configuration + + + + + + + + + + + + + + + + + + + + + + + + + + + +    given an initial global configuration consisting of the local configurations @xmath325 with @xmath326 for @xmath113 , we define the following msr@xmath1 rule @xmath327 here @xmath328 is the largest rational used to interpret the constants in @xmath0 . + for each thread definition @xmath329 in @xmath70 with @xmath61 we translate the rules in @xmath42 as described below .    [ [ internal - moves ] ] internal moves + + + + + + + + + + + + + +    for every _ internal move _ @xmath45}$ ] , and every @xmath330 we define @xmath331    [ [ name - generation ] ] name generation + + + + + + + + + + + + + + +    for every _ name generation",
    "_ @xmath91}$ ] , we define @xmath332 for instance , the name generation @xmath333}$ ] is mapped into the msr@xmath1 rule @xmath334 where @xmath252 is the constraint @xmath335 .",
    "the constraint @xmath336 represents the fact that the new name associated to the local variable @xmath305 ( the second argument of the atoms representing the thread ) is fresh , whereas @xmath337 updates the current value of @xmath133 to ensure that the next generated names will be picked up from unused values .    [ [ thread - creation ] ] thread creation + + + + + + + + + + + + + + +    let @xmath338 and @xmath339 .",
    "then , for every _ thread creation",
    "_ @xmath340}$ ] , we define @xmath341 e.g. , consider the rule @xmath342}$ ] of example [ alicebob ] . its encoding yields the msr@xmath1 rule @xmath343 , where @xmath255 represents the initialization of the local variables of the new thread @xmath344 .",
    "[ [ rendez - vous ] ] rendez - vous + + + + + + + + + + +    the encoding of rendez - vous communication is based on the use of constraint operations like variable elimination .",
    "let @xmath38 and @xmath345 be a pair of thread definitions , with local variables @xmath61 and @xmath346 with @xmath347 .",
    "we first select all rules @xmath51}$ ] in @xmath42 and @xmath107}$ ] in @xmath108 , such that @xmath348 , @xmath349 and @xmath110 .",
    "then , we define the new msr@xmath1 rule @xmath350 for every @xmath330 and @xmath351 such that the nc - constraint @xmath252 obtained by eliminating @xmath352 from the constraint @xmath353 is _",
    "satisfiable_. for instance , consider the rules @xmath354}$ ] and @xmath355}$ ] .",
    "we first build up a new constraint by conjoining the nc - constraints @xmath356 ( matching of message templates ) , and @xmath357 ( guards and actions of sender and receiver ) . after eliminating @xmath136",
    "we obtain the constraint @xmath252 defined as @xmath358 defined over the variables of the two considered threads .",
    "this step allows us to _ symbolically _ represent the passing of names . after this step",
    ", we can represent the synchronization of the two threads by using a rule that simultaneously rewrite all instances that satisfy the constraints on the local data expressed by @xmath252 , i.e. , we obtain the rule @xmath359     @xmath360    the complete translation of example [ alicebob ]",
    "is shown in fig .",
    "[ abmsr ] ( for simplicity we have applied a renaming of variables in the resulting rules ) .",
    "an example of run in the resulting msr@xmath1 specification is shown in figure [ runabmsr ] .",
    "@xmath361    note that , a fresh name is selected between all values strictly greater than the current value of @xmath133 ( e.g. in the second step @xmath362 ) , and then @xmath133 is updated to a value strictly greater than all newly generated names ( e.g. @xmath363 ) .",
    "let @xmath364 be a collection of thread definitions and @xmath127 be an initial global state .",
    "let @xmath278 be the msr@xmath1 specification that results from the translation described in the previous section .",
    "+ let @xmath365 be a global configuration with @xmath366 , and let @xmath367 be an injective mapping . then",
    ", we define @xmath368 as the msr@xmath1 configuration @xmath369 where @xmath177 is a the first value strictly greater than all values in the range of @xmath370 .",
    "given an msr@xmath1 configuration @xmath265 defined as @xmath371 with @xmath372 , let @xmath373 be the set of values occurring in @xmath265 .",
    "then , given a bijective mapping @xmath374 , we define @xmath375 as the global configuration @xmath376 where @xmath377 . + based on the previous definitions , the following property then holds .",
    "[ soundcomp ] for every run @xmath378 in @xmath70 with corresponding set of names @xmath379 , there exist sets @xmath380 and bijective mappings @xmath381 with @xmath382 for @xmath130 , such that @xmath383 is a run of @xmath278 .",
    "vice versa , if @xmath384 is a run of @xmath278 , then there exist sets @xmath385 in @xmath6 and bijective mappings @xmath386 with @xmath387 for @xmath130 , such that @xmath388 is a run in @xmath70 .",
    "we first prove that every run in @xmath70 is simulated by a run in @xmath278 .",
    "let @xmath389 be a run in @xmath70 , i.e. , a sequence of global states ( with associated set of names @xmath390 ) such that @xmath391 and @xmath392 for @xmath130 .",
    "+ we prove that it can be simulated in @xmath278 by induction on its length @xmath393 .",
    "+ specifically , suppose that there exist sets of non negative rationals @xmath394 and bijective mappings @xmath395 with @xmath396 for @xmath397 , such that    @xmath398 is a run of @xmath278 .",
    "furthermore , suppose @xmath399 .",
    "+ we prove the thesis by a case - analysis on the type of rule applied in the last step of the run .",
    "+ let @xmath400 and @xmath401 be a local configuration for the thread definition @xmath60 with @xmath61 and @xmath402 for @xmath66 .",
    "+ _ assignment _ suppose there exists a rule @xmath403 $ ] in @xmath42 such that @xmath404 satisfies @xmath46 , @xmath405 @xmath406 , @xmath407 , and if @xmath408 occurs in @xmath27 , then @xmath409 , otherwise @xmath90 for @xmath66 .",
    "+ the encoding of the rule returns one @xmath410 rule having the form @xmath411 for every @xmath412 . + by inductive hypothesis , @xmath413 is a multiset of atomic formulas that contains the formula @xmath414 . + now let us define @xmath415 as the mapping from @xmath416 to @xmath417 such that @xmath418 if @xmath419 is in @xmath27 and @xmath420 if @xmath421 is in @xmath27 . furthermore , let us the define the evaluation @xmath422 + then , by construction of the set of constraints @xmath423 and of the constraint @xmath424 , it follows that @xmath111 is a solution for @xmath425 for some @xmath412 . as a consequence",
    ", we have that @xmath426 is a ground instance of one of the considered @xmath410 rules .",
    "+ thus , starting from the @xmath410 configuration @xmath413 , if we apply a rewriting step we obtain a new configuration in which @xmath427 is replaced by @xmath428 , and all the other atomic formulas in @xmath429 are the same as in @xmath413 .",
    "the resulting @xmath410 configuration coincides then with the definition of @xmath429 .",
    "+ _ creation of new names _ let us now consider the case of fresh name generation .",
    "suppose there exists a rule @xmath430 $ ] in @xmath42 , and let @xmath431 , and suppose @xmath432 where @xmath433 , @xmath407 where @xmath434 , and @xmath95 for @xmath96 .",
    "+ we note than that the encoding of the previous rule returns the @xmath410 rule @xmath435 where @xmath252 consists of the constraints @xmath436 and @xmath437 for @xmath96 . by inductive hypothesis",
    ", @xmath413 is a multiset of atomic formulas that contains the formulas @xmath414 and @xmath438 where @xmath439 is a mapping into @xmath417 , and @xmath177 is the first non - negative rational strictly greater than all values occurring in the formulas denoting processes .",
    "+ let @xmath177 be a non negative rational strictly greater than all values in @xmath417 . furthermore , let us define @xmath440 and @xmath441 .",
    "+ furthermore , we define @xmath415 as follows @xmath442 for @xmath443 , and @xmath444 .",
    "furthermore , we define the following evaluation @xmath445 then , by construction of @xmath111 and @xmath424 , it follows that @xmath111 is a solution for @xmath424 .",
    "thus , @xmath446 is a ground instance of the considered @xmath410 rule .",
    "+ starting from the @xmath410 configuration @xmath413 , if we apply a rewriting step we obtain a new configuration in which @xmath427 and @xmath438 are substituted by @xmath428 and @xmath447 , and all the other atomic formulas in @xmath429 are the same as in @xmath413 .",
    "we conclude by noting that this formula coincides with the definition of @xmath429 . + for sake of brevity we omit the case of _ thread creation _ whose only difference from the previous cases is the creation of several new atoms instead ( with values obtained by evaluating the action ) of only one .",
    "+ _ rendez - vous _ let @xmath448 and @xmath449 two local configurations for threads @xmath450 , @xmath402 for @xmath66 and @xmath451 for @xmath113 .",
    "+ suppose @xmath452 $ ] and @xmath453",
    "$ ] , where @xmath454 , and @xmath109 ( all defined over distinct variables ) are rules in @xmath42 .",
    "+ furthermore , suppose that @xmath455 satisfies @xmath46 , and that @xmath456 ( see definition of the operational semantics ) satisfies @xmath117 , and suppose that @xmath457 where @xmath458 , @xmath459 , @xmath460 , and if @xmath461 occurs in @xmath27 , then @xmath462 , otherwise @xmath90 for @xmath66 ; if @xmath463 occurs in @xmath124 , then @xmath464 , otherwise @xmath125 for @xmath113 .",
    "+ by inductive hypothesis , @xmath413 is a multiset of atomic formulas that contains the formulas @xmath414 and @xmath465 .",
    "+ now , let us define @xmath415 as the mapping from @xmath416 to @xmath417 such that @xmath418 if @xmath419 is in @xmath27 , @xmath466 if @xmath467 is in @xmath124 , @xmath420 if @xmath421 is in @xmath27 , @xmath468 if @xmath469 is in @xmath124 .",
    "+ now , let us define @xmath111 as the evaluation from @xmath416 to @xmath417 such that @xmath470 then , by construction of the sets of constraints @xmath471 and @xmath472 it follows that @xmath111 is a solution for the constraint @xmath473 for some @xmath474 and @xmath475 .",
    "note in fact that the equalities @xmath476 express the passing of values defined via the evaluation @xmath456 in the operational semantics .",
    "+ as a consequence , @xmath477 is a ground instance of one of the considered @xmath410 rules .",
    "+ thus , starting from the @xmath410 configuration @xmath413 , if we apply a rewriting step we obtain a new configuration in which @xmath427 has been replaced by @xmath428 , and @xmath478 has been replaced by @xmath479 , and all the other atomic formulas are as in @xmath413 .",
    "this formula coincides with the definition of @xmath429 .",
    "the proof of completeness is by induction on the length of an msr run , and by case - analysis on the application of the rules .",
    "the structure of the case analysis is similar to the previous one and it is omitted for brevity .",
    "[ safety ] safety and invariant properties are probably the most important class of correctness specifications for the validation of a concurrent system . for instance , in example [ alicebob ] we could be interested in proving that every time a session terminates , two instances of thread @xmath132 and @xmath138 have exchanged the two names generated during the session . to prove the protocol correct independently from the number of names and threads generated during an execution",
    ", we have to show that from the initial configuration @xmath127 it is not possible to reach a configuration that violates the aforementioned property .",
    "the configurations that violate the property are those in which two instances of @xmath132 and @xmath138 conclude the execution of the protocol exchanging only the first nonce .",
    "these configurations can be represented by looking at only two threads and at the relationship among their local data .",
    "thus , we can reduce the verification problem of this safety property to the following problem : given an initial configuration @xmath127 we would like to decide if a global configuration that _ contains _ _ at least _ two local configurations having the form @xmath480 and @xmath481 with @xmath482 and @xmath483 for some @xmath484 is reachable .",
    "this problem can be viewed as an extension of the _ control state reachability problem _ defined in @xcite in which we consider both control locations and local variables .",
    "although control state reachability is undecidable ( see corollary [ reachability ] ) , the encoding of tdl into msr@xmath1 can be used to define a sound and automatic verification methods for tdl programs . for this purpose , we will exploit a verification method introduced for msr(@xmath2 )  in @xcite . in the rest of this section",
    "we will briefly summarize how to adapt the main results in @xcite to the specific case of msr@xmath1 .",
    "let us first reformulate the control state reachability problem of example [ alicebob ] for the aforementioned safety property on the low level encoding into msr@xmath1 .",
    "given the msr@xmath1 initial configuration @xmath485 we would like to check that no configuration in @xmath486 has the following form @xmath487 for @xmath488 and an arbitrary multiset of ground atoms @xmath265 .",
    "let us call @xmath489 the set of _ bad msr@xmath1 configurations _ having the aforementioned shape .",
    "notice that @xmath489 is upward closed with respect to multiset inclusion , i.e. , if @xmath490 and @xmath491 , then @xmath492 .",
    "furthermore , for if @xmath489 is upward closed , so is @xmath493 . on the basis of this property ,",
    "we can try to apply the methodology proposed in @xcite to develop a procedure to compute a finite representation @xmath42 of @xmath494 . for this purpose , we need the following ingredients :    1 .   a symbolic representation of upward closed sets of configurations ( e.g. a set of assertions @xmath295 whose denotation @xmath495\\!]}$ ] is @xmath489 ) ; 2 .   a computable symbolic predecessor operator @xmath496 working on sets of formulas such that @xmath497\\!]}=pre ( { [ \\![{s}]\\!]})$ ] ; 3 .",
    "a ( decidable ) entailment relation @xmath498 to compare the denotations of symbolic representations , i.e. , such that @xmath499 implies @xmath500\\!]}\\subseteq { [ \\![{m}]\\!]}$ ] . if such a relation @xmath498 exists , then it can be naturally extended to sets of formulas as follows : @xmath501 if and only if for all @xmath502 there exists @xmath503 such that @xmath499 holds ( clearly , if @xmath498 is an entailment , then @xmath501 implies @xmath495\\!]}\\subseteq { [ \\![{s'}]\\!]}$ ] ) .",
    "the combination of these three ingredients can be used to define a verification methods based on backward reasoning as explained next .    [ [ symbolic - backward - reachability ] ] symbolic backward reachability + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    suppose that @xmath504 are the formulas of our assertional language representing the infinite set @xmath489 consisting of all bad configurations . the symbolic backward reachability procedure ( sbr ) procedure computes a chain @xmath505 of sets of assertions such that @xmath506 the procedure sbr stops when @xmath496 produces only redundant information , i.e. , @xmath507 . notice that @xmath508 always holds since @xmath509 .",
    "[ [ symbolic - representation ] ] symbolic representation + + + + + + + + + + + + + + + + + + + + + + +    in order to find an adequate represention of infinite sets of msr@xmath1 configurations we can resort to the notion of _ constrained configuration _ introduced in @xcite for the language scheme msr(@xmath0 ) defined for a generic constraint system @xmath0 .",
    "we can instantiate this notion with @xmath5 constraints as follows .",
    "a constrained configuration over @xmath257 is a formula @xmath510 where @xmath511 , @xmath512 for any @xmath513 and @xmath252 is an @xmath5-constraint .",
    "the denotation a constrained configuration @xmath514 is defined by taking the upward closure with respect to multiset inclusion of the set of ground instances , namely @xmath515\\!]}=\\ { { { \\cal m } } ' ~|~\\sigma ( { { \\cal m } } ) \\preccurlyeq { { \\cal m } } ' , ~\\sigma\\in{sol}(\\varphi)\\}\\ ] ] this definition can be extended to sets of msr@xmath1 constrained configurations with _",
    "disjoint variables _ ( we use variable renaming to avoid variable name clashing ) in the natural way .    in our example",
    "the following set @xmath516 of msr@xmath1 constrained configurations ( with distinct variables ) can be used to finitely represent all possible violations @xmath489 to the considered safety property @xmath517 notice that we need two formulas to represent @xmath518 using a disjunction of @xmath4 constraints .",
    "the msr@xmath1 configurations @xmath519 , and @xmath520 are both contained in the denotation of @xmath516 . actually , we have that @xmath521\\!]}=u$ ] .",
    "this symbolic representation allows us to reason on infinite sets of msr@xmath1 configurations , and thus on global configurations of a tdl program , forgetting the actual number or threads of a given run .    to manipulate constrained configurations",
    ", we can instantiate to @xmath5-constraints the symbolic predecessor operator @xmath496 defined for a generic constraint system in @xcite .",
    "its definition is also given in section [ preop ] in appendix . from the general properties proved in @xcite",
    ", we have that when applied to a finite set of msr@xmath1 constrained configurations @xmath295 , @xmath522 returns a finite set of constrained configuration such that @xmath523\\!]}=pre ( { [ \\![{s}]\\!]})$ ] , i.e. , @xmath524 is a symbolic representation of the immediate predecessors of the configurations in the denotation ( an upward closed set ) of @xmath295 .",
    "similarly we can instantiate the generic entailment operator defined in @xcite to msr@xmath1 constrained configurations so as to obtain an a relation @xmath498 such that @xmath525 implies @xmath500\\!]}\\subseteq { [ \\![{m}]\\!]}$ ] .",
    "based on these properties , we have the following result .",
    "let @xmath70 be a tdl program with initial global configuration @xmath127 , furthermore , let @xmath278 be the corresponding msr@xmath1 encoding . and @xmath516 be the set of msr@xmath1 constrained configurations denoting a given set of bad tdl configurations .",
    "then , @xmath526 if and only if there is no finite run @xmath527 and mappings @xmath528 from the names occurring in @xmath71 to non - negative rationals such that @xmath529 is a run in @xmath278 and @xmath530\\!]}.$ ]    suppose @xmath531 . since @xmath523\\!]}=pre ( { [ \\![{s}]\\!]})$ ] for any @xmath295 , it follows that there can not exist runs @xmath532 in @xmath278 such that @xmath533\\!]}$ ] .",
    "the thesis then follows from the theorem [ soundcomp ] .    as discussed in @xcite , we have implemented our verification procedure based on @xmath534 and _ linear constraints _ using a clp system with linear arithmetics . by the translation presented in this paper , we can now reduce the verification of safety properties of multithreaded programs to a fixpoint computation built on _ constraint operations_. as example , we have applied our clp - prototype to automatically verify the specification of fig .",
    "[ abmsr ] .",
    "the unsafe states are those described in section [ verification ] .",
    "symbolic backward reachability terminates after 18 iterations and returns a symbolic representation of the fixpoint with 2590 constrained configurations .",
    "the initial state @xmath485 is not part of the resulting set .",
    "this proves our original thread definitions correct with respect to the considered safety property .",
    "the proof of theorem [ twocounters ] shows that verification of safety properties is undecidable for tdl specifications in which threads have several local variables ( they are used to create linked lists ) . as mentioned in the introduction",
    ", we can apply the sufficient conditions for the termination of the procedure sbr given in @xcite to identify the following interesting subclass of tdl programs .",
    "a monadic tdl thread definition @xmath60 is such that @xmath17 is at most a singleton , and every message template in @xmath42 has at most one variable .",
    "a monadic thread definition can be encoded into the monadic fragment of msr@xmath1 studied in @xcite .",
    "monadic msr@xmath1 specifications are defined over atomic formulas of the form @xmath535 or @xmath536 with @xmath535 is a predicate symbol and @xmath79 is a variable , and on atomic constraints of the form @xmath247 , and @xmath248 . to encode a monadic tdl thread definitions into a monadic msr@xmath1 specification , we first need the following observation .",
    "since in our encoding we only use the constant @xmath537 , we first notice that we can restrict our attention to msr@xmath1 specifications in which constraints have no constants at all . specifically , to encode the generation of fresh names we only have to add an auxiliary atomic formula @xmath538 , and refer to it every time we need to express the constant @xmath537 . as an example",
    ", we could write rules like @xmath539 for initialization , and @xmath540 for all assignments involving the constant @xmath537 . by using this trick an by following the encoding of section [ msrtranslation ] , the translation of a collection of monadic thread definitions directly returns a _",
    "monadic _ msr@xmath1 specification . by exploiting this property ,",
    "we obtain the following result .",
    "[ termination1 ] the verification of safety properties whose violations can be represented via an upward closed set @xmath489 of global configurations is decidable for a collection @xmath70 of monadic tdl definitions .",
    "let @xmath278 be the msr@xmath1 encoding of @xmath70 and @xmath516 be the set of constrained configuration such that @xmath541 .",
    "the proof is based on the following properties .",
    "first of all , the msr@xmath1 specification @xmath278 is monadic .",
    "furthermore , as shown in @xcite , the class of monadic msr@xmath1 constrained configurations is closed under application of the operator @xmath522 . finally , as shown in @xcite , there exists an entailment relation @xmath542 for monadic constrained configurations that ensures the termination of the sbr procedure applied to a monadic msr@xmath1 specification .",
    "thus , for the monadic msr@xmath1 specification @xmath278 , the chain defined as @xmath543 , @xmath544 always reaches a point @xmath545 in which @xmath546 , i.e. @xmath547\\!]}$ ] is a fixpoint for @xmath294 .",
    "finally , we note that we can always check for membership of @xmath485 in the resulting set @xmath548 .",
    "as shown in @xcite , the complexity of verification methods based on symbolic backward reachability relying on the general results in @xcite is non primitive recursive .",
    "in this paper we have defined the theoretical grounds for the possible application of constraint - based symbolic model checking for the automated analysis of abstract models of multithreaded concurrent systems providing name generation , name mobility , and unbounded control .",
    "our verification approach is based on an encoding into a low level formalism based on the combination of multiset rewriting and constraints that allows us to naturally implement name generation , value passing , and dynamic creation of threads .",
    "our verification method makes use of symbolic representations of infinite set of system states and of symbolic backward reachability . for this reason",
    ", it can be viewed as a conservative extension of traditional finite - state model checking methods .",
    "the use of symbolic state analysis is strictly related to the analysis methods based on abstract interpretation",
    ". a deeper study of the connections with abstract interpretation is an interesting direction for future research .",
    "[ [ related - work ] ] related work + + + + + + + + + + + +    the high level syntax we used to present the abstract models of multithreaded programs is an extension of the communicating finite state machines used in protocol verification @xcite , and used for representing abstraction of multithreaded software programs @xcite . in our",
    "setting we enrich the formalism with local variables , name generation and mobility , and unbounded control .",
    "our verification approach is inspired by the recent work of abdulla and jonsson . in @xcite , abdulla and",
    "jonsson proposed an assertional language for timed networks in which they use dedicated data structures to symbolically represent configurations parametric in the number of tokens and in the _ age _ ( a real number ) associated to tokens . in @xcite , abdulla and nyln formulate a symbolic algorithm using _ existential zones _ to represent the state - space of timed petri nets .",
    "our approach generalizes the ideas of @xcite to systems specified via multiset rewriting and with more general classes of constraints . in @xcite ,",
    "the authors apply similar ideas to ( unbounded ) channel systems in which messages can vary over an infinite _ name _ domain and can be stored in a finite ( and fixed a priori ) number of data variables .",
    "however , they do not relate these results to multithreaded programs .",
    "multiset rewriting over first order atomic formulas has been proposed for specifying security protocols by cervesato et al . in @xcite .",
    "the relationships between this framework and concurrent languages based on process algebra have been recently studied in @xcite .",
    "apart from approaches based on petri net - like models ( as in @xcite ) , networks of _ finite - state _ processes can also be verified by means of automata theoretic techniques as in @xcite . in this setting the set of possible _ local states _ of individual processes are abstracted into a _ finite alphabet_. sets of global states are represented then as _ regular languages _ , and transitions as relations on languages . differently from the automata theoretic approach , in our setting we handle parameterized systems in which individual components have local variables that range over _ unbounded _ values .",
    "the use of constraints for the verification of concurrent systems is related to previous works connecting constraint logic programming and verification , see e.g. @xcite . in this setting transition systems",
    "are encoded via clp programs used to encode the _ global _ state of a system and its updates . in the approach proposed in @xcite ,",
    "we refine this idea by using multiset rewriting and constraints to _ locally _ specify updates to the _ global _ state . in @xcite , we defined the general framework of multiset rewriting with constraints and the corresponding symbolic analysis technique .",
    "the language proposed in @xcite is given for a generic constraint system @xmath0 ( taking inspiration from @xmath549 the language is called @xmath550 ) . in @xcite , we applied this formalism to verify properties of mutual exclusion protocols ( variations of the _ ticket algorithm _ ) for systems with an arbitrary number of processes .",
    "in the same paper we also formulated sufficient conditions for the termination of the backward analysis .",
    "the present paper is the first attempt of relating the low level language proposed in @xcite to a high level language with explicit management of names and threads .",
    "[ [ acknowledgments ] ] acknowledgments + + + + + + + + + + + + + + +    the author would like to thank ahmed bouajjani , andrew gordon , fabio martinelli , catuscia palamidessi , luca paolini , and sriram rajamani and the anonymous reviewers for several fruitful comments and suggestions .",
    ", erns , k. , jonsson , b. , and tsay , y .- k .",
    "in _ proceedings 11th annual international symposium on logic in computer science ( lics96)_. ieee computer society press , new brunswick , new jersey , 313321 .    \\2001 . .",
    "_ 256 , _  1 - 2 , 145167 .",
    "\\2003 . .",
    "_ 290 , _  1 , 241264 .",
    "in _ proceedings 15th annual international symposium on logic in computer science ( lics00)_. ieee computer society press , santa barbara , california , 132140 .    , chaki , s. , and rajamani , s.  k. 2001 . .",
    "7th international conference on tools and algorithms for construction and analysis of systems ( tacas 2001 ) , genova , italy , april 2 - 6,_. lncs , vol .",
    "springer - verlag , 158173 .    ,",
    "cervesato , i. , lenzini , g. , and martinelli , f. 2005 . relating multiset rewriting and process algebras for security protocol analysis .",
    "_ 13 , _  1 , 347 .",
    "finite state descriptions of communicating protocols .",
    "_ 2 _ , 4657 .    ,",
    "jonsson , b. , nilsson , m. , and touili , t. 2000 . .",
    "proceedings 12th international conference on computer aided verification ( cav00 ) _",
    ", e.  a. emerson and a.  p. sistla , eds .",
    "lncs , vol .",
    "springer - verlag , chicago , illinois , 403418 .",
    "algorithmic verification of invalidation - based protocols . in _",
    "14th international conference on computer aided verification , cav 02_. lecture notes in computer science , vol .",
    "springer .    ,",
    "durgin , n. , lincoln , p. , mitchell , j. , and scedrov , a. 1999 . .",
    "12th computer security foundations workshop ( csfw99)_. ieee computer society press , mordano , italy , 5569 .",
    "in _ verification of parameterized systems - vepas 2001_. entcs , vol .",
    "tech . rep .",
    "tr-05 - 08 , dipartimento informatica e scienze dellinformazione , universit di genova , italia .",
    "proceedings 5th international conference on tools and algorithms for construction and analysis of systems ( tacas99)_. lecture notes in computer science , vol . 1579 .",
    "springer - verlag , amsterdam , the netherlands , 223239 .",
    "_ 256 , _  1 - 2 , 6392 .",
    "\\1992 . .",
    "_ 39 , _  3 , 675735 .",
    "notes on nominal calculi for security and mobility . in _ foundations of security analysis and design , tutorial lectures_. lecture notes in computer science , vol . 2171 .",
    "springer , 262330 .    ,",
    "maler , o. , marcus , m. , pnueli , a. , and shahar , e. 2001 .",
    "symbolic model checking with rich assertional languages .",
    "_ 256 , _  1 , 93112 .",
    "\\2002 . .",
    "_ 83 , _  5 , 251261 .",
    "given a set of msr@xmath1 configurations @xmath295 , consider the msr@xmath1 _ predecessor _ operator @xmath297 . in our assertional language , we can define a symbolic version @xmath522 of @xmath294 defined on a set @xmath551 containing msr@xmath1 constrained multisets ( with _ disjoint _ variables ) as follows : @xmath552 where @xmath553 is a matching relation between constrained configurations that also takes in consideration the constraint satisfaction , namely @xmath554 provided @xmath555 and there exists a permutation @xmath556 of @xmath557 such that the constraint @xmath558 is _ satisfiable _ ; here @xmath559 is an abbreviation for the constraints",
    "@xmath560 if @xmath561 and @xmath562 , @xmath563 otherwise .",
    "as proved in @xcite , the symbolic operator @xmath522 returns a set of msr@xmath1 constrained configurations and it is correct and complete with respect to @xmath294 , i.e. , @xmath564\\!]}=pre ( { [ \\ ! [ { { { s } } } ] \\!]})$ ] for any @xmath551 . it is important to note the difference between @xmath522 and a simple backward rewriting step .",
    "for instance , given the constrained configurations @xmath246 defined as @xmath565 and the rule @xmath566 ( that simulates a rendez - vous ( @xmath567 are channels ) and value passing ( @xmath568 ) ) , the application of @xmath496 returns @xmath569 as well as @xmath570 ( the common multiset here is @xmath267 ) ."
  ],
  "abstract_text": [
    "<S> we present a technique for the automated verification of abstract models of multithreaded programs providing fresh name generation , name mobility , and unbounded control .    as high level specification language </S>",
    "<S> we adopt here an extension of communication finite - state machines with local variables ranging over an infinite name domain , called tdl programs . </S>",
    "<S> communication machines have been proved very effective for representing communication protocols as well as for representing abstractions of multithreaded software .    </S>",
    "<S> the verification method that we propose is based on the encoding of tdl programs into a low level language based on multiset rewriting and constraints that can be viewed as an extension of petri nets . by means of this encoding , the symbolic verification procedure developed for the low level language in our previous work </S>",
    "<S> can now be applied to tdl programs . </S>",
    "<S> furthermore , the encoding allows us to isolate a decidable class of verification problems for tdl programs that still provide fresh name generation , name mobility , and unbounded control . </S>",
    "<S> our syntactic restrictions are in fact defined on the internal structure of threads : in order to obtain a complete and terminating method , threads are only allowed to have at most one local variable ( ranging over an infinite domain of names ) .    </S>",
    "<S> [ firstpage ]    constraints , multithreaded programs , verification . </S>"
  ]
}