{
  "article_text": [
    "codes were introduced by arikan @xcite as the first family of capacity achieving codes with explicit construction method and low encoding / decoding complexities for the class of binary input discrete memoryless channels ( b - dmcs ) .",
    "arikan s original polar codes is based on the kernel matrix @xmath10 and its @xmath11th kronecker power @xmath12 corresponding to a linear code with block length @xmath13 . with arikan s @xmath14 kernel ,",
    "it was shown in @xcite the probability of block error under successive cancellation ( sc ) decoding is @xmath15 with @xmath16 .",
    "it was conjectured in @xcite that channel polarization is a general phenomenon and it was shown in @xcite that the probability of block error under sc decoding is @xmath17 for a general kernel @xmath18 with size @xmath4 .",
    "@xmath19 is called _ exponent _ of the kernel and can exceed @xmath20 for large @xmath21 @xcite .    , @xmath22 , @xmath23 , @xmath24 , @xmath25 , @xmath26 on the bpsk - modulated gaussian channel .",
    "all codes are constructed using gaussian approximation method @xcite at eb / n0@xmath27db .",
    "bottom : list sc @xcite decoding performance of polar codes with kernels @xmath28 and @xmath26 .",
    "@xmath29 code is constructed via the method proposed in at eb / n0@xmath27db and @xmath30 code is based on monte carlo method proposed in [ 1 , sec .",
    "ix ] at eb / n0@xmath27db.,width=264,height=264 ]    based on the above , many researchers had constructed high - dimensional kernels with large exponents .",
    "based on bch codes , korada _",
    "@xcite provided a construction of binary kernels with large exponent .",
    "mori and tanaka @xcite proposed a construction of non - binary kernels with large exponent based on reed - solomon codes . in @xcite ,",
    "code decompositions were used to design good linear and nonlinear binary kernels . in @xcite , constructions were presented for kernels with maximum exponents up to dimension @xmath31 .    however , it was pointed out in @xcite that the complexity of straightforward sc decoder for @xmath18 polar codes behaved like @xmath32 .",
    "so it s not practical for high - dimensional kernels such as @xmath33 .",
    "at present , to the best of our knowledge , there is no efficient sc decoding of large dimension kernels , although exponent s definition is base on sc decoding . in @xcite and @xcite",
    ", they tried to generalize the idea of @xmath28 sc decoding to high - dimensional binary kernels .",
    "but their methods can only work on kernels with very small dimension because their methods need a tree structure for _ bit - channel graph _ @xcite and it s not true for large dimension kernels even with @xmath34 .",
    "in this paper , we propose a low complexity sc decoder for arbitrary binary linear kernels . for @xmath28",
    ", it has @xmath35 which are called the @xmath0-expressions in this paper leading to a low complexity sc decoding of @xmath28 polar codes @xcite .",
    "our basic idea , like @xmath28 , is to obtain @xmath0-expressions for arbitrary binary linear kernel @xmath18 .",
    "[ fig2 - 16 ] shows the error performance of polar codes with different kernels under sc and list sc ( lsc ) decoding through binary - input additive white gaussian noise ( awgn ) channel .",
    "it can be seen that error performance of polar codes are almost decided by the exponent of kernels . @xmath22 and @xmath23 have smaller exponent than @xmath28 and the error performance of polar codes with @xmath22 and @xmath23 is worse than @xmath28 even with longer block length . for kernels with close exponents , high - dimensional kernel polar codes have better error performance than @xmath28 kernel polar codes even with shorter block length such as @xmath36 and @xmath37 . @xmath26",
    "polar codes achieves significant error performance gains than @xmath28 polar codes under sc and lsc decoding , although @xmath26 s exponent is a little bigger than @xmath28 .",
    "next , we use an example to show our main idea .",
    "[ g6 ] @xmath38 the @xmath0-expressions for this kernel : @xmath39    in example [ g6 ] , we give @xmath0-expressions for a @xmath40 optimal kernel . for the above @xmath22 kernel ,",
    "the complexity of straightforward sc decoder is @xmath41 . with these @xmath0-expressions , we reduce the complexity to @xmath42 where @xmath43 is the _ length _ ( defined later on ) of @xmath0-expressions .    the above @xmath22 kernel is given in @xcite and _ optimal _ means it has maximum exponent among all @xmath40 kernels .",
    "@xmath44 defined by @xmath45 ( @xmath3 is the channel ) are channel likelihood ratios and @xmath46 are bit - channels s likelihood ratios .",
    "@xmath47 means @xmath48 . for @xmath49 ,",
    "two parts which are connected by @xmath50 are called _ sub - expressions_. @xmath50 is the same like @xmath51 and it is specially used for separating sub - expressions .",
    "three operators s priority is @xmath52 . then @xmath53 . in example",
    "[ g6 ] , we omit the influence of known values @xmath54 for @xmath55 .",
    "for example , @xmath56 and it will be explained in section iii . c.    by our analysis",
    ", @xmath0-expressions based sc decoder is good for medium kernel size such as @xmath57 .",
    "however , it become impractical for lager kernel size such as @xmath33 .",
    "so , similar to @xmath0-expressions , we propose a @xmath3-expressions method to further reduce the complexity of sc decoder for larger dimension kernels by considering bit - channel transition probabilities @xmath1 and @xmath2 separately . our main achievement is : _ using @xmath3-expressions method , we show that the complexity of @xmath18 sc decoder is @xmath6 for optimal kernels given in @xcite when @xmath7 .",
    "_    the rest of the paper is organized as follows . in section",
    "ii , we introduce the basic definitions and point out our basic task . in section iii , we give details how to get @xmath0-expressions for an arbitrary binary kernel matrix . in section",
    "iv , similar to @xmath0-expressions , we present a @xmath3-expressions method to further reduce the complexity of sc decoder with high dimensional kernel . also , we give complexity analyses of @xmath0-expressions and @xmath3-expressions based sc decoder in this section .",
    "construction methods of polar codes with high dimensional kernel are presented in section v.",
    "we write @xmath58 to denote a b - dmc channel with input alphabet @xmath59 , output alphabet @xmath60 , and transition probabilities @xmath61 .",
    "we use the notation @xmath62 for denoting a row vector @xmath63 . for a general kernel matrix @xmath18 ( all kernels used in this paper are linear kernels given in @xcite ) ,",
    "@xmath64 is defined by @xmath65 then , bit - channels @xmath66 is defined by @xmath67 for sc decoding , the basic task is to calculate following values @xmath68 where @xmath69 means @xmath70 .    in order to facilitate notation .",
    "we use following simple notation instead of ( 3 ) @xmath71 where @xmath72 , @xmath73 .",
    "let @xmath74 denote the element of @xmath18 in the @xmath75th row and @xmath76th column . in the denominator of ( [ sn_def_bit ] ) ,",
    "if @xmath77 , @xmath78 ; otherwise @xmath79 .",
    "[ l - ex_main_idea ] @xmath80    in ( [ sn_def_bit ] ) , we see _ channel expression _",
    "@xmath81 in numerator is different from @xmath82 in denominator .",
    "we call this as one _ difference _ for @xmath83 .",
    "it should be noticed that @xmath84 views as a expression of binary variables , not a value in our algorithm .",
    "for example , @xmath85 in the definition of @xmath86 by ( [ def ] ) .",
    "let @xmath87 denote the set of variables contained in @xmath84 .",
    "so @xmath88 in the previous example .",
    "@xmath89 means @xmath90 .",
    "@xmath91 means @xmath92 .",
    "all of operations in this paper will be over gf(2 ) .",
    "so , if @xmath93 and @xmath94 , @xmath95 .",
    "we write @xmath96 to denote the indicator function of equation @xmath97 ; thus , @xmath96 equals @xmath98 if @xmath97 and @xmath99 otherwise .",
    "in example [ g6 ] , @xmath49 is connected by two sub - expressions with @xmath50 .",
    "we call the _ length _ of @xmath49 is @xmath100 . and",
    "other @xmath0-expressions s lengths are all @xmath98 .",
    "so the total length is @xmath43 for this example .      by using ( [ def ] )",
    ", the total computational cost of @xmath101 is @xmath102 .",
    "we call these calculations as _ inside kernel calculation_. a polar code defined by @xmath103 with block length @xmath104 needs to recursively implement @xmath105 times of _ inside kernel calculation _ for sc decoding .",
    "so the complexity of sc decoding behaves like @xmath32 for a general kernel matrix @xmath18 .",
    "it grows exponentially with the kernel size .",
    "so it is not practical for large kernel size such as @xmath33 .",
    "therefore , our basic task is to reduce the computational cost of ( [ def ] ) .",
    "in this section , we propose our method to generate @xmath0-expressions of @xmath106 for an arbitrary kernel @xmath18 .",
    "we begin with an example to illustrate the method . and we denote some functions in the description of the example . then , a high - level description of the @xmath0-expressions generating algorithm is proposed according to these functions . finally , we give details of these functions in general case and proofs of them .",
    "in example [ l - ex_main_idea ] , we use @xmath49 to illustrate the @xmath0-expressions generating algorithm . based on definition ( [ def ] ) , we get ( [ eqn_dbl_x ] ) .",
    "actually , we omit known values @xmath107 in ( 5 ) .",
    "we will add them in ( [ final - l - expressions ] ) . to omit known values at first and add them in final step ,",
    "we call this function as .    define @xmath108 in ( [ extend1 ] ) and ( [ extend2 ] ) .",
    "then it has @xmath109 .",
    "this function is called as .    by adding a mid term ,",
    "we get ( [ extend1 ] ) and ( [ extend2 ] ) from ( [ eqn_dbl_x ] ) .",
    "@xmath50 is the same as common multiple @xmath51 .",
    "obviously , @xmath110 .",
    "we call ( [ extend1 ] ) and ( [ extend2 ] ) as _ sub - expressions_. @xmath50 is specially used in separating sub - expressions .",
    "it can be seen there are only one _ difference _ in both ( [ extend1 ] ) and ( [ extend2 ] ) .",
    "we call the function from ( [ eqn_dbl_x ] ) to @xmath111 as .    with one difference property in ( [ extend1 ] ) , we get the left part of ( [ fundenmental1 ] ) .",
    "this is our key step and it is called .",
    "firstly , let @xmath112 in ( [ extend2 ] ) . it is .",
    "then , we get the right part of ( [ fundenmental1 ] ) by defining @xmath113 .",
    "we call this function as . with this function",
    ", we have @xmath114 .",
    "the left part of ( [ fundenmental2 ] ) is obtained by doing @xmath115 and @xmath116 for each channel expressions in the numerator and denominator for the left part of ( [ fundenmental1 ] ) , respectively .",
    "the right part of ( [ fundenmental2 ] ) is obtained by doing with defining @xmath117 and in the right part of ( [ fundenmental1 ] ) . implementing in the left part of ( [ fundenmental2 ] ) and doing @xmath118 and @xmath119 in both left and right of ( [ fundenmental2 ] )",
    ", we get ( [ l - expressions ] ) .",
    "doing @xmath120 in ( [ l - expressions ] ) , we get ( [ final - l - expressions ] ) .",
    "we denote , , and and functions in the description of example [ l - ex_main_idea ] .    for a complete description of the @xmath0-expressions generating algorithm , we need two more functions and .",
    "the two functions are not necessary , but it can simplify the final @xmath0-expressions . also , we use to denote and .    based on these functions , we give a high - level description of @xmath0-expressions generating procedure in algorithm [ alga ] .    *",
    "input : * a kernel lower - triangular matrix @xmath18 , index @xmath75 and channel output likelihood ratios @xmath121 * output : * bit - channel likelihood expression @xmath83 as a function of @xmath121    //algorithm starts from @xmath122 * early processing : * implement and on @xmath83    implement as much as possible implement implement implement    in algorithm [ alga ] , every step is working on the result from its previous step . after a _ while _ _ loop _ is finished , variables of expressions reduce at least @xmath98 ( like left part of ( 9 ) to ( 10 ) , @xmath123 to @xmath124 ) .",
    "then , the algorithm will stop after at most @xmath125 _ while _ _ loops_.        given a kernel @xmath18 , let @xmath126 and @xmath127 be the submatrices of @xmath18 consisting of first @xmath128 rows and last @xmath125 rows , respectively .",
    "remember our basic task is to simplify ( [ def ] ) .",
    "let @xmath129 , we have @xmath130 since @xmath131 are known values , we can _ replace _ ( [ def ] ) by following expression @xmath132    [ hide_pro ] assume we get the expression of @xmath133 using ( [ hide ] ) by algorithm [ alga ] .",
    "then the real expression of @xmath134 using ( [ def ] ) is @xmath135 .",
    "@xmath136    for an arbitrary @xmath137 , @xmath138 where @xmath139 and @xmath140 mean @xmath141 using ( [ def ] ) and ( [ hide ] ) , respectively .    based on proposition [ hide_pro ] ,",
    "we implement the algorithm on ( [ hide ] ) instead of ( [ def ] ) . after we get the final @xmath0-expressions , we replace @xmath140 by @xmath142 for each @xmath143 .",
    "a standard likelihood expression @xmath83 has following form @xmath144 that is @xmath145 .",
    "[ set ] for a likelihood expression @xmath83 defined by a lower triangular matrix @xmath18 , it can be transformed to a standard expression .",
    "first , we give an example of _ standard expression transform_. given a lower triangular matrix @xmath146 @xmath147 by doing linear transform in rows @xmath148 of @xmath146 , we get @xmath149 let @xmath150 and @xmath151 are likelihood ratio expressions defined by @xmath146 and @xmath152 , respectively .",
    "notice @xmath151 is in _ standard expression transform_. therefore , we only need to show @xmath153 . since there is one - to - one correspondence between @xmath154 and @xmath155 , it s easy to see @xmath153 by the definition .",
    "the above method can be easily generalized to any @xmath83 of a low triangular matrix @xmath18 .",
    "also , it s provide a procedure to implement _ standard expression transform_.    in lemma [ set ] , we suppose the kernel @xmath18 is a lower triangular matrix since all of optimal kernels given in @xcite are lower triangular matrices .",
    "in fact , we do nt need lower triangular assumption in lemma [ set ] .",
    "because , given any @xmath18 and @xmath83 , we always can transform @xmath156 ( @xmath156 is the submatrix of @xmath18 consisting of last @xmath157 rows ) to a lower triangular form with row transformation and column rearrangement .",
    "[ fun_l ] given a likelihood ratio expression with only one difference between the numerator and denominator such as @xmath158 and assume that @xmath159 and @xmath160 contain @xmath161 , then we have @xmath162 where @xmath163 if @xmath164 contains @xmath161 ; otherwise @xmath165 , @xmath166 in the numerator of ( [ fundamental ] ) . in the denominator of ( [ fundamental ] ) , if @xmath164 contains @xmath161 , @xmath167 ; otherwise @xmath168 .",
    "let @xmath169 and define @xmath170 then @xmath171    in lemma [ fun_l ] , we assume @xmath159 contains @xmath161",
    ". then we have @xmath163 if @xmath164 contains @xmath161 ; otherwise @xmath165 , @xmath166 in the numerator of ( [ fundamental ] ) .",
    "in fact , we do nt need this assumption .",
    "assume @xmath172 , @xmath173 .",
    "we can choose any @xmath174 .",
    "then it has @xmath163 if @xmath164 contains @xmath175 ; otherwise @xmath165 , @xmath166 in the numerator of ( [ fundamental ] ) .",
    "however , we always choose @xmath176 in the algorithm and it s good choice by experiments .",
    "@xmath177    by lemma [ fun_l ] , we reduce one variable from @xmath178 to @xmath179 .",
    "so if there are still only one difference between the denominator and numerator of reduced expression ( consider the left part in ( 8) ) , we can continue to implement lemma1 .",
    "then we get the final likelihood expression after implementing @xmath157 times of lemma [ fun_l ] .",
    "if there are more than one difference between numerator and denominator of expressions , we can define some mid - terms to extend expressions and make extending expressions have only one difference .",
    "[ ex ] given a likelihood ratio expression with two differences between the numerator and denominator such as @xmath180 we have @xmath181    in proposition [ ex ] , we divide the given @xmath83 into two part by operator @xmath50 and it has only one difference in ( [ extend_def1 ] ) and ( [ extend_def2 ] ) , respectively .",
    "@xmath50 is the same as common multiple @xmath51 .",
    "@xmath50 is specially used in _ extend method _ and its priority is lower than @xmath51 .",
    "it s easy to see that the extending method can be generalized to any number of differences .",
    "however , the cost is to increase the length of expression .",
    "the length of final expression of @xmath83 is depend on the number of differences of @xmath83 . using the symmetric property of bit - channel",
    ", the number of differences can be reduced for a given @xmath83 .    given a bit - channel expression @xmath182 and assume that only @xmath159 and @xmath84 contain @xmath161",
    ", we have @xmath183    proof is immediate and omitted . in this proposition",
    ", we change @xmath161 to @xmath184 .",
    "actually , we can change all possible subsets of @xmath178 .",
    "let @xmath185 denote a subset of @xmath178 .",
    "we change it to @xmath186 . for @xmath187",
    ", if it contains odd number variables in @xmath185 , then @xmath188 becomes @xmath189 ; otherwise it does nt change .",
    "[ set ] given a likelihood ratio expression @xmath190 we use _ symmetric property of bit - channel _ to all subsets of @xmath178 for denominator of @xmath83 and obtain @xmath191 equivalent likelihood ratio expressions .",
    "assume that @xmath192 has the least number of _ differences _ among these expressions .",
    "then we replace @xmath83 by @xmath192 .",
    "proposition [ set ] describes a procedure to assure that @xmath83 has least number of difference . to do that , it need @xmath193 times tests .",
    "it s accepted for small kernel size .",
    "actually , we just need to test one and two elements subsets of @xmath178 to acquire the least number of difference equivalent expression of @xmath83 , up to kernel size @xmath33 by our experiments .      in this section ,",
    "we propose two obvious ways to simplify the expressions .",
    "given a likelihood ratio expression as following @xmath194 we have @xmath195 where @xmath196 .",
    "then in the final likelihood expression , it has @xmath197    given a likelihood ratio expression as following @xmath198 and assume @xmath199 , @xmath200 and @xmath201 , @xmath202 .",
    "then we have @xmath203 where @xmath204 .",
    "@xmath136    then in the final likelihood expression , it has @xmath205",
    "@xmath206    where @xmath207 .",
    "in this section , we propose our methods to generate @xmath3-expressions of @xmath208 for an arbitrary kernel @xmath18 .",
    "firstly , we give an analysis about the complexity of @xmath0-expressions based sc decoder and show that @xmath0-expressions method is not accepted for larger kernels such as @xmath33 .",
    "secondly , we analyse one drawback of @xmath0-expressions method and propose a @xmath3-expressions method to overcome the drawback",
    ". then an example of @xmath3-expressions is given for making the method more clear . finally , the complexity analysis of @xmath3-expressions based sc decoder is given and it contains our main achievement .",
    "let @xmath209 denote the average length of @xmath0-expressions for a kernel @xmath18 .",
    "actually @xmath209 is the average number of sub - expressions . for a kernel @xmath18 ,",
    "the complexity of calculating a sub - expression is @xmath210 and it needs to compute @xmath211 sub - expressions for the _ inside kernel calculation_. then the calculation cost of _ inside kernel calculation _",
    "is @xmath212 . because it needs to implement @xmath105 times of _ inside kernel calculation_. so the complexity of @xmath0-expressions based sc decoder is @xmath213 for a general kernel @xmath18 .",
    "table [ l_ex_com ] gives the results of @xmath209 by implementing algorithm [ alga ] for kernels up to @xmath33 .",
    "it can be seen that the @xmath0-expressions method is good for small kernels such as @xmath57 .",
    "however , @xmath209 increases very fast with kernel size @xmath21 . actually , @xmath26 is the first kernel which obtains significant advantages in terms of error performance compared with @xmath28 . but @xmath214 is about @xmath215 times than @xmath216 .",
    "it means that @xmath26 based sc decoder is about @xmath217 times than the @xmath28 based sc decoder with the same block length .",
    "it can not be accepted .",
    ".@xmath209 for different kernels [ cols=\"^,^,^,^,^,^,^,^\",options=\"header \" , ]      in example [ g6 ] , it can be seen that @xmath218 just needs to calculate one time for @xmath49 .",
    "we call this as _ inside expression simplification_. for the complexity analysis of @xmath0-expressions , we do nt consider the _ inside expression simplification _ since it makes no significant complexity reduction . however , it has significant complexity reduction by considering _ inside expression simplification _ for @xmath3-expressions . for example , the length of @xmath219 is @xmath220 .",
    "but we just need to calculate @xmath31 sub - expressions since other sub - expressions are the repetition of these @xmath31 sub - expressions .",
    "let @xmath221 denote the average length of generated @xmath3-expressions for a general kernel @xmath18 .",
    "then the complexity of @xmath3-expressions based sc decoder is @xmath222 for the @xmath18 based polar code .",
    "w_ex_com ] gives the results of @xmath221 by using algorithm [ algb ] for optimal kernels @xcite up to @xmath33 .",
    "it means that the complexity of @xmath3-expressions based sc decoder is @xmath6 when @xmath7 .     for sc decoding with @xmath29 polar code on the bpsk - modulated gaussian channel using tal - vardy method and",
    "monte carlo method @xcite at eb / n0@xmath27db .",
    "the code rate is 0.5.,width=264,height=226 ]",
    "two methods are proposed to construct polar codes with high dimensional polar codes .",
    "one is monte carlo method @xcite , the other is gaussian approximation based density evolution ( ga - de ) method @xcite .",
    "arikan [ 1 , section ix ] provides a monte carlo approach for constructing polar codes . in monte carlo approach",
    ", it assume that all - zero codeword is transmitted .",
    "firstly , for a bit - channel @xmath223 , it assume that @xmath224 are known values",
    ". then it uses sc decoder to evaluate the reliability of @xmath225 . finally , based on reliabilities of @xmath223 ,",
    "it chooses some best bit - channels as information set @xmath226 ; that is the polar code .",
    "[ fig - tal - vs - mc ] gives the comparison of error performances for @xmath29 polar code which are constructed by the monte carlo method and tal - vardy method .",
    "tal - vardy method was considered the optimal construction method .",
    "it was shown that the monte carlo method achieves the same error performance as the tal - vardy method .",
    "therefore , it is conceivable that the monte carlo approach is an optimal method for constructing polar codes .     versus @xmath227 for sc decoding with @xmath228 and @xmath229 polar codes on the bpsk - modulated gaussian channel using ga - de method @xcite and monte carlo method @xcite at eb / n0@xmath27db .",
    "the code rate is 0.5.,width=264,height=226 ]      a first efficient construction of polar codes in general case which are based on density evolution @xcite was made by mori and tanaka @xcite .",
    "then trifinov demonstrated that polar codes can be efficiently constructed using ga - de method @xcite .    with @xmath0-expressions",
    ", it s straightforward to construct polar codes by using ga - de method .",
    "however , polar codes constructed by ga - de method become inaccurate as kernel size @xmath21 become larger by our experiments .",
    "let @xmath230 be bit - channels and @xmath231 denote the probability of error on the @xmath75th bit - channel .",
    "then a union bound on the frame error rate of polar codes is @xmath232 where @xmath226 is the _ information set _ of the code @xcite .",
    "[ fig - ga - vs - mc ] shows @xmath233 vs. @xmath227 results under de - ga and monte carlo methods . for the small block length @xmath234",
    ", it can be considered that monte carlo method is an accurate method for computing @xmath231 .",
    "so fig . [ fig - ga - vs - mc ] confirms that polar codes constructed by ga - de method become inaccurate as kernel size @xmath21 goes larger",
    ".    1 e. arikan , `` channel polarization : a method for constructing capacityachieving codes for symmetric binary - input memoryless channels , '' _ ieee trans .",
    "inf . theory _ ,",
    "55 , no . 7 , pp . 3051 - 3073 , jul .",
    "2009 .",
    "h. lin , s. lin , and k. a. s. abdel - ghaffar , `` linear and nonlinear binary kernels of polar codes of small dimensions with maximum exponents , '' _ ieee trans .",
    "inf . theory _ ,",
    "5253 - 5270 , oct .",
    "2015 .",
    "x. wang , z. zhang , and l. zhang , `` on the sc decoder for any polar code of length @xmath235 , '' _ in proc .",
    "ieee wireless communications and networking conference ( wcnc ) _ , istanbul , turkey , apr .",
    "2014 , pp .",
    "485 - 489 .",
    "chung , t. j. richardson , r. l. urbanke , `` analysis of sum - product decoding of low - density parity - check codes using a gaussian approximation , '' _ ieee trans .",
    "inf . theory _ ,",
    "657 - 670 , feb . 2001 .",
    "r. mori and t. tanaka , `` performance and construction of polar codes on symmetric binary - input memorless channels , '' in _ proc .",
    "inf . theory ( isit ) _ , seoul , korea , jun./jul .",
    "2009 , pp .",
    "1496 - 1500 ."
  ],
  "abstract_text": [
    "<S> a method for efficiently successive cancellation ( sc ) decoding of polar codes with high - dimensional linear binary kernels ( hdlbk ) is presented and analyzed . </S>",
    "<S> we devise a @xmath0-expressions method which can obtain simplified recursive formulas of sc decoder in likelihood ratio form for arbitrary linear binary kernels to reduce the complexity of corresponding sc decoder . by considering the bit - channel transition probabilities @xmath1 and @xmath2 separately , a @xmath3-expressions method is proposed to further reduce the complexity of hdlbk based sc decoder . for a @xmath4 binary kernel , </S>",
    "<S> the complexity of straightforward sc decoder is @xmath5 . with @xmath3-expressions , we reduce the complexity of straightforward sc decoder to @xmath6 when @xmath7 . </S>",
    "<S> simulation results show that @xmath8 kernel polar codes offer significant advantages in terms of error performances compared with @xmath9 kernel polar codes under sc and list sc decoders .    </S>",
    "<S> polar codes , exponent , successive cancellation decoding , high - dimension kernel , @xmath0-expressions , @xmath3-expressions . </S>"
  ]
}