{
  "article_text": [
    "given a formal language @xmath0 specified in some finite way , a common problem is to determine whether @xmath0 is nonempty . and",
    "if @xmath0 is indeed nonempty , then another common problem is to determine good upper and lower bounds on the length of the shortest string in @xmath0 , which we write as @xmath1 .",
    "such bounds can be useful , for example , in estimating the state complexity of @xmath0 , since @xmath2 .    as an example , we start with a very simple result often stated in introductory classes on formal language theory .",
    "let @xmath0 be accepted by an nfa @xmath3 with @xmath4 states and @xmath5 transitions .",
    "then we can decide in time @xmath6 whether @xmath7 .",
    "if @xmath0 is nonempty , then @xmath8 .",
    "further , this bound is tight .",
    "[ one ]    we now turn to a more challenging example . here",
    "@xmath0 is specified as the _ complement _ of a language accepted by an nfa .",
    "let @xmath0 be accepted by an nfa with @xmath4 states .",
    "then it is pspace - complete to determine whether @xmath9 .",
    "if @xmath9 , then @xmath10 .",
    "further , for some constant @xmath11 , @xmath12 , there is an infinite family of examples with @xmath4 states such that @xmath13 .    for the pspace - completeness , see .",
    "the upper bound is easy and follows from the subset construction .",
    "the lower bound is significantly harder ; see @xcite .",
    "these two examples set the theme of the paper .",
    "we examine several problems about shortest strings in regular languages and prove bounds for @xmath1 .",
    "some of the results have appeared in the master s thesis of the second author @xcite .",
    "recall the following classical result about intersections of regular languages .",
    "let @xmath14 ( resp . ,",
    "@xmath15 ) be accepted by an nfa with @xmath16 states and @xmath17 transitions ( resp .",
    ", @xmath18 states and @xmath19 transitions ) then @xmath20 is accepted by an nfa with @xmath21 states and @xmath22 transitions . [",
    "two ]    use the usual direct product construction .",
    "this suggests the following natural problems .",
    "given nfa s @xmath23 and @xmath24 as above , decide if @xmath25 .",
    "this can clearly be done in @xmath26 time , by using the direct product construction followed by breadth - first or depth - first search .",
    "now assume @xmath25 . what is a good bound on @xmath27 ?",
    "combining propositions  [ one ] and [ two ] , we immediately get the upper bound @xmath28",
    ".    however , is this bound tight ? for @xmath29 an obvious construction shows it is , even in the unary case : choose @xmath30 and @xmath31 .",
    "however , this idea no longer works for @xmath32 .",
    "nevertheless , the bound @xmath33 is tight for binary and larger alphabets , as the following result shows .",
    "[ thm : intersect ] for all integers @xmath34 there exist dfas @xmath35 with @xmath36 and @xmath4 states , respectively , and with @xmath37 such that @xmath38 , and @xmath39 .    the proof is constructive . without loss of generality ,",
    "assume @xmath40 , and set @xmath41 .",
    "let @xmath23 be the dfa given by @xmath42 , where @xmath43 , @xmath44 , and for each @xmath45 , @xmath46 , and @xmath47 we set @xmath48 then @xmath49    let @xmath24 be the dfa @xmath50 , shown in figure [ fig : m2 ] , where @xmath51 , @xmath52 , and for each @xmath45 , @xmath53 , @xmath54    focusing solely on the @xmath55 s that appear in some accepting computation in @xmath24 , we see that we can return to @xmath56    * via a simple path with @xmath36 @xmath55 s , or * ( if we go through @xmath57 ) , via a simple path with @xmath58 @xmath55 s and ending in the transition @xmath59 .    after some number of cycles through @xmath56 , we eventually arrive at @xmath57 .",
    "letting @xmath60 denote the number of times a path of type ( b ) is chosen ( including the last path that arrives at @xmath57 ) and @xmath61 denote the number of times a path of type ( a ) is chosen , we see that the number of @xmath55 s in any accepted word must be of the form @xmath62 , with @xmath63 , @xmath64 . the number of @xmath65 s along such a path is then at least @xmath66 , with the @xmath67 in this expression arising from the fact that the last part of the path terminates at @xmath57 without taking an additional @xmath65 transition back to @xmath56 .",
    "thus @xmath68 , there exists an @xmath69 such that @xmath70 , and @xmath71 .",
    "this is obtained , for example , by cycling @xmath61 times from @xmath56 to @xmath72 and then back to @xmath56 via a transition on @xmath55 , then @xmath73 times from @xmath56 to @xmath57 and then back to @xmath56 via a transition on @xmath65 , and finally one more time from @xmath56 to @xmath57 .",
    "it follows then that @xmath74 further , for every such @xmath60 and @xmath61 , there exists a corresponding element in @xmath75 .",
    "since @xmath76 and @xmath36 are relatively prime , the shortest such word corresponds to @xmath77 , @xmath78 , and satisfies @xmath79 . in particular ,",
    "a shortest accepted word is @xmath80 , which is of length @xmath81 .    we can also obtain a bound for the unary case .",
    "let @xmath82 as defined in",
    ".    given unary dfa s @xmath23 ( resp .",
    ", @xmath24 ) with @xmath36 ( resp . , @xmath4 ) states , accepting @xmath14 ( resp . ,",
    "@xmath15 ) , we have @xmath83 . furthermore ,",
    "for all @xmath34 there exist unary dfa s of @xmath36 and @xmath4 states achieving this bound",
    ".    follows from .",
    "recall the post correspondence problem : we are given two finite nonempty languages @xmath84 and @xmath85 , and we want to determine if there exist @xmath86 and a finite sequence of indices @xmath87 such that @xmath88 . as is well - known",
    ", this problem is undecidable .",
    "levent alpoge @xcite asked about the variant where we throw away the `` correspondence '' : determine if there exist @xmath89 and two finite sequences of indices @xmath90 and @xmath91 such that @xmath92 . in other words , we want to decide if @xmath93 .",
    "this variant is , of course , decidable .",
    "in fact , even a more general version is decidable , where the languages need not be finite .",
    "suppose @xmath94 is a language accepted by an nfa @xmath23 with @xmath16 states and @xmath17 transitions , and @xmath95 is accepted by an nfa @xmath24 with @xmath18 states and @xmath19 transitions .",
    "then we can decide in @xmath26 time whether @xmath93 .",
    "given nfa @xmath96 accepting @xmath94 , we can create an nfa-@xmath97 @xmath98 accepting @xmath99 by adding an @xmath97-transition from every final state of @xmath23 back to @xmath56 .",
    "we can apply a similar construction to create @xmath100 accepting @xmath101 .",
    "then we can create an nfa-@xmath97 @xmath3 accepting @xmath102 using the usual direct product construction . since this construction is crucial to what follows , and",
    "since there is one subtle point , we describe it in some detail .    given @xmath98 and @xmath103 as above , @xmath104 , where @xmath105 , @xmath106 $ ] , and @xmath107 .",
    "the transition function @xmath108 is defined as follows :    for @xmath109 , @xmath110 , and @xmath111 we have @xmath112 \\in \\delta([p , q ] , a)$ ] if @xmath113 and @xmath114 .",
    "these transitions correspond to the usual direct product edges of the transition diagram .",
    "however , we also need edges in which one machine performs an explicit @xmath97-transition , and the other machine performs an implicit @xmath97-transition by simply staying in its own state .",
    "this corresponds to including the transitions @xmath112",
    "\\in \\delta([p , q],\\epsilon)$ ] if @xmath115 and @xmath116 or if @xmath117 and @xmath118 .",
    "this construction results in an nfa-@xmath97 accepting @xmath102 and having at most @xmath119 transitions .",
    "now we can use the usual breadth - first or depth - first search to solve the emptiness problem .",
    "[ ab ]    given nfa s @xmath23 accepting @xmath14 ( resp .",
    ", @xmath24 accepting @xmath15 ) of @xmath36 ( resp . ,",
    "@xmath4 ) states , the shortest string in @xmath120 is of length at most @xmath81 .",
    ". then there exists @xmath23 accepting @xmath14 ( resp .",
    ", @xmath24 accepting @xmath15 ) of @xmath36 ( resp .",
    ", @xmath4 ) states such that the shortest string in @xmath120 is of length @xmath122 .",
    "the first assertion follows from proposition  [ ab ] .    for the second assertion",
    ", we can take @xmath23 and @xmath24 as in the proof of theorem  [ thm : intersect ] .",
    "clearly @xmath123 .",
    "when we apply our construction to @xmath24 to create @xmath124 , we add an @xmath97-transition from @xmath57 back to @xmath56 .",
    "the effect is to allow one less @xmath65 in each cycle through the states . as in the proof of theorem  [ thm : intersect ] , to get the proper number of @xmath55 s , we must have @xmath77 , and hence the shortest string in @xmath120 is of length @xmath125 .",
    "we can improve the upper bound to @xmath126 as follows :    [ thm : positiveclosure ] for any @xmath36-state dfa @xmath23 and n - state dfa @xmath24 such that @xmath127 we have @xmath128 .",
    "assume , contrary to what we want to prove , that we have dfas @xmath23 and @xmath24 with @xmath36 and @xmath4 states , respectively , such that @xmath129 .",
    "let @xmath23 be the dfa given by @xmath130 , where @xmath131 , and let @xmath24 be the dfa given by @xmath132 , where @xmath133 .",
    "then let @xmath134 and @xmath135 be the @xmath97-nfas obtained by adding @xmath97-transitions from the final states to the start states in @xmath23 and @xmath24 , respectively .",
    "let @xmath3 be the @xmath97-nfa obtained by applying the cross - product construction to @xmath134 and @xmath135 .",
    "then @xmath3 accepts @xmath136 .",
    "if @xmath3 has more than one final state , a shortest accepting path would only visit one of them , and this immediately gives a contradiction .",
    "so , assume each of @xmath23 and @xmath24 have only one final state ; that is @xmath137 and @xmath138 .",
    "then @xmath139 , { [ p_x , q_y]}),$ ] where for all @xmath140,a)=[\\delta_1(p_i , a),\\delta_2(q_j , a)].$ ] note that @xmath3 has @xmath97-transitions from @xmath141 $ ] to @xmath142 $ ] for all @xmath143 and @xmath144 $ ] to @xmath145 $ ] for all @xmath146 .",
    "let @xmath147 be a shortest word accepted by @xmath23 and @xmath148 be a shortest word accepted by @xmath24 .",
    "then @xmath149 , w_1 ) = [ p_x , q_i]$ ] for some @xmath60 such that @xmath150 , and while carrying out this computation we never pass through two states @xmath151 $ ] and @xmath152 $ ] such that @xmath153 . likewise , @xmath149 , w_2 ) = [ p_j , q_y]$ ] for some @xmath61 such that @xmath154 , and while carrying out this computation we never pass through two states @xmath151 $ ] and @xmath152 $ ] such that @xmath155 .",
    "if both @xmath156 and @xmath157 the shortest accepted string is @xmath97 , so without loss of generality , assume @xmath158 .",
    "then @xmath149 , w_1 ) = [ p_x , q_0]$ ] or else we can visit @xmath159 states with @xmath160 symbols by using an @xmath97-transition and we get a contradiction . if @xmath161 , @xmath147 is the shortest string accepted by @xmath3 and we have a contradiction .",
    "so , @xmath162 and @xmath149 , w_2 ) = [ p_0 , q_y]$ ] .",
    "it follows that reading @xmath147 from the initial state brings us to @xmath163 $ ] without passing through @xmath164 $ ] , and reading @xmath148 from the initial state brings us to @xmath164 $ ] without passing through @xmath163 $ ] .",
    "so , a shortest accepting path need only visit one of @xmath163 $ ] and @xmath165 $ ] , and again we have a contradiction .",
    "we do not know an exact bound for this problem .",
    "however , for the unary case , we can obtain an exact bound based on a function @xmath166 introduced in .",
    "define @xmath167 , and define the variant @xmath168 then @xmath169 . the function @xmath166 is a very difficult one to estimate , although deep results in analytic number theory give some upper and lower bounds .    if @xmath23 ( resp . , @xmath24 )",
    "is a unary nfa with @xmath36 states ( resp .",
    ", @xmath4 states ) and @xmath170 ( resp . , @xmath171 ) , then @xmath172 .",
    "furthermore , for all @xmath34 there exist unary dfa s of @xmath36 and @xmath4 states , respectively , achieving this bound .",
    "assume the input alphabet of both @xmath23 and @xmath24 is @xmath173 .",
    "let @xmath174 ( resp . ,",
    "@xmath175 ) be the length of the shortest nonempty string in @xmath14 ( resp . , @xmath15 ) .",
    "clearly @xmath176 and @xmath177 .",
    "furthermore , if @xmath178 , then @xmath179 , and similarly if @xmath180 then @xmath181 . hence if @xmath182 , then @xmath183 , and hence @xmath184",
    "otherwise either @xmath185 or @xmath186 .",
    "without loss of generality , assume @xmath186 .",
    "then @xmath187 , so @xmath188 .",
    "now suppose we are given @xmath36 and @xmath4 .",
    "let @xmath189 be the integers maximizing @xmath190 over @xmath191 , @xmath192 with @xmath193 .",
    "if @xmath194 , choose @xmath195 , which can be accepted by a dfa with @xmath196 states , and choose @xmath197 , which can be accepted by a dfa with @xmath198 states .",
    "otherwise , reverse the roles of @xmath36 and @xmath4 .",
    "thus we get dfa s of @xmath36 and @xmath4 states , respectively , achieving @xmath199 .",
    "another variation on the post correspondence problem , also proposed by alpoge @xcite , is more interesting .",
    "here we throw away only _ part _ of the `` correspondence '' : given @xmath84 and @xmath200 , we want to decide if there exist @xmath86 and two finite sequences of indices @xmath87 and @xmath201 such that @xmath202 . in other words , we only demand that the number of words on each side be the same .",
    "let @xmath23 ( resp . , @xmath24 ) be an nfa with @xmath16 states and @xmath17 transitions ( resp .",
    ", @xmath18 states and @xmath19 transitions ) . we can decide in polynomial time ( in @xmath203 ) whether there exists @xmath204 such that @xmath205 .",
    "we construct a pushdown automaton @xmath3 accepting @xmath0 . on input @xmath207 , our pda attempts to construct two same - length factorizations of @xmath207 : one into elements of @xmath208 , and one into elements of @xmath209 .",
    "to ensure the factorizations are really of the same length , we use the stack of the pda to maintain a counter that records the absolute value of the difference between the number of factors in the first factorization and the number of factors in the second .",
    "the appropriate sign of the difference is maintained in the state of the pda .",
    "as we read @xmath207 , we simulate the nfa s @xmath23 and @xmath24 .",
    "if we reach a final state in either machine , then we have the option ( nondeterministically ) to deem this the end of a factor in the appropriate factorization , and update the stack accordingly , or continue with the simulation .",
    "we accept if the stack records a difference of @xmath65  that is , if the stack contains no counters and only the initial stack symbol @xmath210  and we are in a final state in both machines ( indicating that the factorization is complete into elements of both @xmath14 and @xmath15 ) .    thus we have shown that @xmath0 is context - free .",
    "furthermore , our pda has @xmath211 states and @xmath212 transitions .",
    "it uses only two distinct stack symbols  the counter and the initial stack symbol  and never pushes more than one additional symbol on the stack in any transition .",
    "such a pda can be converted to a context - free grammar @xmath166 , using the standard `` triple construction '' , using @xmath213 states and @xmath214 transitions .",
    "now we can test the emptiness of the language generated by a context - free grammar of size @xmath5 in @xmath215 time , by removing useless symbols and seeing if any productions remain .",
    "there exist simple examples where @xmath216 is not regular .",
    "for example , take @xmath217 and @xmath218 .",
    "then @xmath219 , the language of nonempty strings with the same number of @xmath45 s and @xmath220 s .    furthermore , if @xmath221 are all nfa s , then the analogous language @xmath222 need not be context - free",
    ". a counterexample is given by taking @xmath223 , @xmath224 , and @xmath225 .",
    "then @xmath226 which is clearly not context - free .",
    "mike domaratzki ( personal communication ) observes that the decision problem `` given @xmath23 , @xmath24 , does there exist @xmath227 such that @xmath205 '' becomes undecidable if @xmath23 and @xmath24 are pushdown automata , by reduction from the problem `` given cfg s @xmath228 , is @xmath229 '' .",
    "given @xmath230 and @xmath231 , we can easily create pda s accepting @xmath232 and @xmath233 , where @xmath234 is a new symbol not in the alphabet of either @xmath230 or @xmath231 .",
    "then @xmath235 for some @xmath227 if and only if @xmath236 . a similar result holds for the linear context - free languages .",
    "we now turn to the question of , given regular languages @xmath94 and @xmath95 , determining the shortest string in @xmath237 , given that it is nonempty .",
    "actually , we consider a more general problem , where we intersect more than two languages .",
    "we start by proving a result about directed graphs .",
    "suppose @xmath238 is a directed graph with edge weights in @xmath239 , where the components of the edge weights are all bounded in absolute value by @xmath240 .",
    "let @xmath241 denote the weight of a path @xmath242 , obtained by summing the weights of all associated edges . if @xmath166 contains a cycle @xmath243 such that @xmath244 , then @xmath166 also contains a cycle @xmath245 with @xmath246 and length at most @xmath247 .",
    "[ luke ]    for each vertex @xmath248 in the cycle @xmath249 , break @xmath249 at the first occurrence of @xmath248 .",
    "this gives us @xmath250 such that @xmath251 where @xmath252 is the set of vertices visited by @xmath249 .",
    "the final vertex , @xmath253 , is the same as @xmath254 because @xmath249 is a cycle .",
    "notice that @xmath255 because each vertex appears at most once in the list @xmath256 .    for each @xmath257 ,",
    "generate a new path @xmath258 by removing all simple subcycles .",
    "the length of @xmath259 is at most @xmath260 ; otherwise some vertex is repeated , so we have not removed all subcycles .",
    "recombine the @xmath259 s into a cycle @xmath261 having length @xmath262 .",
    "in addition to @xmath263 , we have a list of simple subcycles @xmath264 that we removed while generating the @xmath259 s .",
    "consider the cycles we can construct using @xmath265 . for any @xmath266 , we know @xmath263 visits the starting vertex of @xmath266 because @xmath263 visits all the vertices in @xmath249 .",
    "therefore we can splice @xmath266 into @xmath263 at its starting vertex .",
    "since @xmath266 is a cycle , we can insert it into @xmath263 any positive number of times .",
    "we can also append @xmath263 to the whole cycle as many times as we like .",
    "these techniques allow us to construct a cycle with weight @xmath267 where @xmath268 and @xmath269 are all integers .",
    "recall that @xmath270 were constructed by decomposing @xmath249 .",
    "each edge from @xmath249 exists somewhere in @xmath270 , so we have @xmath271 this shows that it is possible to write * 0 * as an integer linear combination of @xmath272 .",
    "unfortunately , for each nonzero @xmath273 we have at least one copy of @xmath266 , with length at most @xmath260 .",
    "since all the @xmath273 s are nonzero and @xmath274 is unbounded , the corresponding cycle has unbounded length .",
    "if we hope to find a bounded cycle by this technique then we need to bound the number of nonzero @xmath273 s .",
    "let us approach the problem with linear programming . construct a matrix @xmath275 where the @xmath60th column is given by @xmath276 .",
    "let @xmath277 be the column vector @xmath278 .",
    "we are looking for solutions to the problem @xmath279 this is just the feasible set of a linear program in standard equality form .",
    "we saw earlier that it has the feasible solution @xmath280 . note that if @xmath94 is not full rank then we remove linearly dependent rows until we have a full rank matrix , and proceed with a matrix of rank @xmath281 .",
    "linear programming theory tells us a feasible problem of this form has a _ basic _ feasible solution @xmath282 with at most @xmath283 nonzero entries . without loss of generality ( relabelling if necessary ) ,",
    "take all but the first @xmath283 entries of @xmath282 to be zero . letting @xmath284",
    "be the first @xmath283 columns of @xmath94 , the basic solution @xmath282 satisfies the following equation : @xmath285    we are not done yet because the @xmath286s are real numbers and we need an integer linear combination .",
    "cramer s rule gives an explicit solution for each coefficient , @xmath287 , where @xmath288 is the matrix @xmath284 with the @xmath60th column replaced by @xmath220 .",
    "note that @xmath284 and @xmath288 are integer matrices , so their determinants are integers and @xmath289 is a rational number .",
    "when we multiply through by @xmath290 , all the coefficients will be positive integers : @xmath291    we can bound the determinants with hadamard s inequality , which says that the determinant of a matrix @xmath3 is bounded by the product of the norms of its columns .",
    "each @xmath266 is a simple cycle , so @xmath292 .",
    "it follows that any entry of @xmath293 is at most @xmath294 , so @xmath295 . on the other hand",
    ", @xmath263 has length at most @xmath296 , giving @xmath297 .",
    "combining these estimates gives @xmath298 for all @xmath60 and @xmath299 .",
    "now we construct the cycle @xmath300 from this linear combination , with @xmath290 copies of @xmath263 and @xmath301 copies of each @xmath266 . by construction",
    ", @xmath300 has weight * 0 * and its length is bounded as follows : @xmath302    consider a generalization of the third problem to @xmath283 languages @xmath303 accepted by nfa s having @xmath304 states , respectively .",
    "if @xmath305 is nonempty , then the shortest string in the language has length bounded by @xmath306 where @xmath307 .",
    "suppose we are given a regular language @xmath94 ( resp . , @xmath95 )",
    "accepted by an nfa @xmath23 ( resp . , @xmath311 .",
    "without loss of generality , we will assume that @xmath23 ( resp . ,",
    "@xmath24 ) has no transitions into its initial state .",
    "this can be accomplished , if necessary , by adding one new state with transitions out the same as the transitions out of the initial state , and redirecting any transitions into the initial state to the new state .",
    "if the original machine had @xmath312 states , then the new machine has at most @xmath313 states . call these new machines @xmath314 and @xmath315 .",
    "next we create an nfa-@xmath97 @xmath316 by adding an @xmath97-transition from every final state of @xmath317 back to its initial state , and by changing the set of final states to be @xmath318 . this new machine",
    "@xmath319 accepts @xmath320 .",
    "we carry out a similar construction on @xmath321 obtaining @xmath322 accepting @xmath323 .",
    "finally , mimicking the construction of theorem  [ ab ] we create an nfa-@xmath97 @xmath324 accepting @xmath310 using the direct product construction outlined above on @xmath319 and @xmath322 .",
    "note that @xmath324 has at most @xmath325 states and has exactly one accepting state , which is its initial state .",
    "we define the edge weights of @xmath326 to be @xmath327 as follows .",
    "an explicit @xmath97-transition in @xmath317 or @xmath321 marks the end of a word , so each explicit @xmath97-transition taken in @xmath317 back to the start gets weight @xmath328 , while each explicit @xmath97-transition in @xmath321 back to the start gets weight @xmath67 . in this way",
    "we keep track of the difference between the number of factors used in @xmath329 and @xmath330 .    for the general case",
    ", we form the intersection automaton as before , and define the @xmath60th coordinate of @xmath331 , for @xmath332 , to be the difference in the number of @xmath97-transitions taken in @xmath317 and @xmath333 .",
    "now just apply lemma  [ luke ] to get the desired bound .",
    "remove simple cycles @xmath335 from @xmath249 until are we left with @xmath336 , which has no proper subcycles .",
    "it follows that @xmath336 must be a simple cycle , so we have decomposed @xmath249 into simple subcycles .",
    "note that the weight of @xmath249 is the sum of the weights of all the @xmath266 s and @xmath336 .",
    "if @xmath336 has weight 0 then take @xmath337 .",
    "we are done because @xmath336 has length at most @xmath338 .",
    "if @xmath336 has nonzero weight then the positive and negative cases are identical so take @xmath336 to have positive weight without loss of generality . then there must be some @xmath266 with negative weight , otherwise the sum of the weights of the @xmath266 s and @xmath336 would be positive , but @xmath249 has weight 0 . call the negative weight cycle @xmath339 .",
    "if @xmath336 and @xmath339 have some vertex in common , then we can splice @xmath340 copies of @xmath339 into @xmath341 copies of @xmath336 to get a cycle @xmath300 of weight 0 .",
    "since @xmath342 and @xmath343 , the cycle has length @xmath344 .    otherwise , @xmath336 and @xmath339 have no vertex in common so we need to find some way to get from @xmath336 to @xmath339 and back again . clearly @xmath249 passes through every vertex in @xmath336 and @xmath339 , but we want a shorter cycle .",
    "let @xmath263 be the shortest cycle that passes through some vertex in @xmath336 and some vertex in @xmath339 .",
    "we will split @xmath263 into @xmath345 , the piece from @xmath336 to @xmath339 , and @xmath346 , the piece from @xmath339 to @xmath336 .",
    "we know that @xmath347 are simple , and @xmath348 must be simple or we could make a shorter cycle @xmath263 by making them shorter",
    ". therefore , any vertex in @xmath349 occurs at most four times in @xmath336 , @xmath339 and @xmath263 , once for each of @xmath350 . but @xmath336 and @xmath339 have no vertices in common , so each vertex occurs at most three times in @xmath336 , @xmath339 and @xmath263 .",
    "now if some vertex @xmath248 occurs three times in @xmath336 , @xmath339 and @xmath263 , then it must be in @xmath345 , @xmath346 and either @xmath336 or @xmath339 ( without loss of generality , let it be in @xmath336 ) .",
    "then we can remove a prefix of @xmath345 up to @xmath248 , producing @xmath351 . similarly , remove a suffix of @xmath346 starting from @xmath248 , giving @xmath352 .",
    "then @xmath353 is a shorter cycle that visits @xmath354 and still visits @xmath339 , contradicting the minimality of @xmath263",
    ". therefore any vertex @xmath248 occurs at most twice in @xmath336 , @xmath339 and @xmath263 , so @xmath355 .",
    "let us combine @xmath263 with @xmath336 if @xmath263 has positive weight and @xmath339 if @xmath263 has negative weight to produce a cycle @xmath356 .",
    "either @xmath336 or @xmath339 is left over , call it @xmath357 .",
    "note that @xmath357 and @xmath356 have opposite sign weights , and also have a vertex in common .",
    "as before , we combine @xmath358 copies of @xmath356 with @xmath359 copies of @xmath357 to produce a cycle @xmath300 of length at most @xmath360 . under the constraint @xmath361 , the length @xmath360 is maximized when @xmath362 , with maximum value @xmath363 , completing the proof .",
    "let @xmath364 be nonempty finite languages over a unary alphabet , say @xmath365 and @xmath366 .",
    "then @xmath367 for some @xmath227 iff @xmath368 and @xmath369 .",
    "if both conditions hold , then @xmath367 for some @xmath370 , and this bound is tight .",
    ". then every element of @xmath372 will be of length greater than every element of @xmath373 .",
    "similarly , if @xmath369 , then every element of @xmath373 will be of length greater than every element of @xmath372 .",
    "hence if either condition holds , we have @xmath374 for all @xmath227 .",
    "now suppose @xmath368 and @xmath369 .",
    "then there exist @xmath375 and @xmath376 such that @xmath377 .",
    "choose @xmath378 and @xmath379 .",
    "then @xmath380 contains @xmath381 .",
    "and @xmath382 contains @xmath383 .",
    "so for @xmath384 we get @xmath367 . now"
  ],
  "abstract_text": [
    "<S> given a formal language @xmath0 specified in various ways , we consider the problem of determining if @xmath0 is nonempty . if @xmath0 is indeed nonempty , we find upper and lower bounds on the length of the shortest string in @xmath0 . </S>"
  ]
}