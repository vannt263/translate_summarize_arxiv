{
  "article_text": [
    "grover s algorithm is a quantum query algorithm solving the unstructured search problem of size @xmath0 using @xmath1 queries .",
    "it is known that any deterministic or randomized algorithm needs linear time ( number of queries ) to solve the above problem .",
    "thus , grover s algorithm provides a significant speed - up over any classical algorithm .",
    "the running time of the algorithm ( number of queries ) , however , is very sensitive to errors in queries .",
    "regev and schiff @xcite have shown that if query has a small probability of failing ( reporting that _ none _ of the elements are marked ) , then quantum speed - up disappears : no quantum algorithm can be faster than a classical exhaustive search by more than a constant factor .",
    "ambainis et al .",
    "@xcite have studied grover s algorithm in the model where each marked element has its own probability to be reported as unmarked , independent of probabilities of other marked elements .",
    "similarly to the result of @xcite , they have shown that if all marked elements are faulty ( have non - zero probability of failure ) then the algorithm needs @xmath2 queries to find a marked element .",
    "although , technically the model of @xcite allows one non - faulty marked element ( element with zero probability of failure ) this case was not included into the analysis .",
    "we study the behavior of the algorithm in the model where the search space contains both faulty and non - faulty marked items . specifically , we focus on the case where the search space contains multiple non - faulty and one faulty marked element .",
    "we analyze the effect of a fault on the state of the algorithm and show that in this setting it is indeed possible to find one of non - faulty marked elements in @xmath1 queries . up to the best our knowledge , this is the first demonstrgggggation of query fault modes which can be tolerated by the grover s algorithm .",
    "we also analyze the limiting behavior of grover s algorithm for a large number of steps and show the existence and the structure of limiting state @xmath3 .",
    "the limiting state is a mixture of a faulty marked element @xmath4 with probability @xmath5 , the uniform superposition of all non - faulty marked elements with probability @xmath5 and the uniform superposition of all non - marked elements with probability @xmath5 . using the approach of @xcite",
    "one can show that convergence time is @xmath6 .",
    "the contrast between this result and the algorithm finding a marked element in @xmath1 steps can be explained by the probability of finding a marked element oscillating between @xmath7 and @xmath8 until these oscillations finally die off after o(@xmath0 ) steps .",
    "we use the standard notions of quantum states , density matrices etc . , as described in @xcite .",
    "suppose we have an unstructured search space of size @xmath0 .",
    "grover s algorithm starts with a starting state @xmath9 .",
    "each step of the algorithm consists of two transformations : @xmath10 and @xmath11 . here",
    ", @xmath10 is a query to a black box defined by    * @xmath12 if @xmath13 is a marked element ; * @xmath14 if @xmath13 is not a marked element .",
    "@xmath11 is the diffusion transformation described by the following @xmath15 matrix : @xmath16 we refer to @xmath17 as the state of grover s algorithm after @xmath18 time steps .",
    "grover s algorithm has been analyzed in detail and many facts about it are known @xcite .",
    "if there is one marked element @xmath13 , the probability of finding it by measuring @xmath19 reaches @xmath20 for @xmath21 .",
    "if there are @xmath22 marked elements , the probability of finding one of them by measuring @xmath19 reaches @xmath20 for @xmath23 .",
    "spherical trigonometry is a branch of geometry which deals with the relationships between trigonometric functions of the sides and angles of the spherical polygons .",
    "trigonometry on a sphere differs from the traditional planar trigonometry .",
    "for example , all distances are measured as angular distances .    in the context of this paper",
    "we need only a few basic formula for right spherical triangles .",
    "let @xmath24 be a right spherical triangle with a right angle @xmath25 .",
    "then the following following set of rules ( known as napier s rules ) applies :    [ cols= \" < , < \" , ]         for more detailed introduction into spherical trigonometry see @xcite .",
    "suppose we have a search space of size @xmath0 containing @xmath22 marked elements @xmath26 .",
    "first @xmath27 marked elements are _ non - faulty _  the query always returns them as marked .",
    "last marked element is _ faulty _  the query might return it as unmarked .    more formally ,",
    "on each step , instead of the correct query @xmath10 , we apply a faulty query @xmath28 defined as follows :    * @xmath29 with probability @xmath30 ; * @xmath31 with probability @xmath32 ; * @xmath33 if @xmath34 .",
    "first we show that if there is at least one non - faulty marked element , then it is still possible to find a non - faulty marked element in @xmath1 queries with @xmath35 probability .",
    "[ thm : search ] let @xmath36 , then we can choose @xmath37 so that , if we run grover s algorithm for @xmath18 steps and measure the final state , the probability of finding a marked element is at least @xmath38 .    for @xmath39 ,",
    "the probability of finding a marked element is at least @xmath38 under a promise that at most one fault occurs and at least @xmath40 in the general case .",
    "we conjecture that , for @xmath39 , the probability is at least @xmath41 even in the general case .",
    "second , we analyze the limiting behavior of the algorithm for a large number of steps and show the existence and structure of limiting state @xmath3 .",
    "[ thm : limiting_behaviour ] let @xmath42 be the density matrix of state of grover s algorithm with a faulty oracle @xmath28 after @xmath18 queries .",
    "then , the sequence @xmath43 converges to @xmath44 where @xmath45 is the uniform superposition over all non - faulty marked elements and @xmath46 is the uniform superposition over all non - marked elements .",
    "in this section we analyze the evolution of the state of grover s algorithm in presence of multiple non - faulty and one faulty marked item .",
    "first we review the original grover s algorithm , then we describe the effect of faults on the state of the algorithm .",
    "we derive upper bounds on the effect of faults and provide a modification of the original grover s search algorithm which finds one of non - faulty marked items with @xmath35 probability in @xmath1 queries .",
    "let us first consider the very basic search problem of grover s algorithm .",
    "namely , we have @xmath0 items among which @xmath22 are marked , as for @xmath47 with sufficiently large @xmath48 the search problem can be trivially solved by a probabilistic algorithm in time @xmath49 . ] .",
    "operator @xmath11 is symmetric w.r.t .",
    "permutations of amplitudes of all items , and operator @xmath10 is symmetric w.r.t .",
    "permutations of amplitudes of marked items , as well as permutations of amplitudes of non - marked items .",
    "so , on any step @xmath18 amplitudes of all marked items are equal to each other and amplitudes of all non - marked items are equal to each other .",
    "thus , we can represent @xmath19 as : @xmath50 where @xmath51 stands for the set of indexes of non - marked items and @xmath52 stands for the set of indexes of @xmath22 marked items . @xmath53 and @xmath54 denote the amplitudes of respectively a non - marked item and a marked item on step @xmath18 . at each step of the algorithm we shall take care of two numbers only : @xmath55 since @xmath19 is a unit vector , we have @xmath56 thus , values meet the equality @xmath57and correspond to a point on the unit circle .",
    "initially all amplitudes are equal , so @xmath58 , and the numbers are @xmath59 during the first step of the algorithm operator @xmath11 does not change amplitudes of the state @xmath60 , and operator @xmath10 negates amplitudes of all marked items : @xmath61 .",
    "so the numbers are @xmath62    ( 150,150 ) ( 0,0 ) ( 10,63 ) ( 80,10 ) ( 80,63 ) ( 80,118 ) ( 145,70 ) ( 80,134 ) ( 135,85 ) ( 135,55 )    according to and , transformation @xmath63 can be represented on the unit circle as shown on figure  [ fig : fig1 ] .",
    "as before , we assume @xmath64 , so that @xmath65 , and the angle between @xmath60 and @xmath66 is @xmath67 ( this approximation holds for small - valued @xmath68 ) .",
    "similarly , all further applications of operator @xmath69 are nothing but clockwise rotations by angle @xmath70 .",
    "after @xmath71 such rotations the resulting state @xmath72 reaches the neighborhood of the point @xmath73 .",
    "measuring @xmath72 results in getting index of a marked item , with probability almost @xmath74 .",
    "let us now consider the case with    * @xmath75 non - marked items , * @xmath76 marked items , and * @xmath74 _ faulty _ marked item .    to simplify the analysis we shall interpret the step of the algorithm as consequent application of three operators : ordinary diffusion @xmath11 and ordinary query @xmath10 , and  with probability @xmath77 ",
    "error @xmath78 , which negates back the amplitude of the faulty marked item .    as the operation @xmath78 is probabilistic one must deal not with a pure state @xmath19 , but with a mixed state @xmath42 ( probabilistic mixture of pure states ) .",
    "we shall denote components of the mixture after @xmath18 steps as @xmath79 , where @xmath80 stands for the sequence of @xmath18 events : @xmath81  the query has negated the amplitude of the faulty marked item ( @xmath69 ) , and @xmath74  the query has left that amplitude of the faulty marked item unchanged ( @xmath82 ) .",
    "so the mixture @xmath42 looks as follows :    @xmath83    transformations @xmath11 , @xmath10 and @xmath78 are symmetric w.r.t .",
    "permutations of amplitudes of non - faulty marked items , as well as permutation of amplitudes of non - marked items .",
    "so , in any state @xmath79 of the mixture @xmath84 , amplitudes of all non - faulty marked items are equal to each other and amplitudes of all non - marked items are equal to each other .",
    "thus , we can represent @xmath79 as : @xmath85 where @xmath51 stands for the set of indexes of non - marked items and @xmath52 stands for the set of indexes of @xmath22 marked items .",
    "@xmath86 , @xmath87 and @xmath88 denote the amplitudes of respectively a non - marked item , a non - faulty marked item and the faulty marked item .    at each step of the algorithm for each of @xmath89 scenarios",
    "@xmath90 we shall take care of three numbers : @xmath91    since @xmath79 are unit vectors we have @xmath92 thus , values meet the equality @xmath93and correspond to a points on the unit sphere .",
    "initially the mixture consists of state @xmath60 with amplitudes of all items being equal , so @xmath94 , and the numbers for @xmath95 are @xmath96 during the first step of the algorithm    * @xmath11 does not change amplitudes of the state @xmath60 ; * @xmath10 negates the amplitudes of all marked items : @xmath97 ; * @xmath78 negates back the amplitude of the faulty marked item : @xmath98 .",
    "so the numbers for @xmath99 are as follows : @xmath100    according to and , transformation @xmath101 can be represented on the unit sphere as shown on figure  [ fig : fig2 ] .",
    "( 400,320 ) ( 0,0 ) and @xmath102 , title=\"fig : \" ] ( 20,142 ) ( 274,142 ) ( 156,142 ) ( 156,23 ) ( 156,274 ) ( 156,274 ) ( 22,13 ) ( 300,148 ) ( 145,306 ) ( 175,132 ) ( 86,100 ) ( 105,140 )    note that if @xmath103 the state of the algorithm travels clockwise along the slanted orthodrome which contains points @xmath60 and @xmath104 .",
    "the travel lasts until the state reaches the neighborhood of the vertical orthodrome ( hereafter we call it _ meridian _ ) where @xmath105 after @xmath106 steps .",
    "( 150,150 ) ( 25,0 ) in the run of grover s algorithm with a faulty marked item.,title=\"fig : \" ] ( 100,73 )    if @xmath64 the rotation angle is sufficiently small .",
    "the run of the algorithm can be viewed as clockwise rotation of a state in parallel to the slanted orthodrome ( @xmath69-movement ) with occasional ( @xmath77-probable ) up - and - down jumps around the horizontal orthodrome ( hereafter we call it _ equator _ ) , which correspond to operator @xmath78 , as shown on figure  [ fig : fig3 ] . during the first @xmath107 steps , the state can not go out of the area which is covered with arrows on the figure .",
    "as we already mentioned , @xmath107 steps are necessary to reach the desired plane where @xmath105 , given that no fault occurs on the way ( in our notation : in expression , @xmath108 ) .",
    "but what could the length of the route be if some faults occur on the state s way to the desired plane ? in the two following subsections",
    "we will derive upper bounds for the effect of these faults .",
    "first , let us assume that the total number of faults is at most one .",
    "although this assumption seems to be rather implausible , we have some arguments for it :    * for sufficiently small @xmath77 , we have @xmath109 , so that probability of more than one fault @xmath110 could be neglected for number of steps @xmath111 ; * as we shall see later , the second and all subsequent faults have smaller effect and even have great chances to drive the state closer to the desired meridian .",
    "( 150,150 ) ( 25,0 ) ( 10,33 ) ( 43,90 ) ( 30,55 ) ( 40,40 ) ( 65,54 )    let us calculate the effect of a fault in the sense of its projection onto the `` no - faults '' route .",
    "on the figure  [ fig : fig4 ] we illustrate @xmath77-probable transformation @xmath112 , which happened on some step @xmath18 .",
    "the fault increases the angular distance to the desired meridian ( @xmath105 ) by @xmath113 .",
    "using rules of spherical trigonometry ( and ) we have :    @xmath114    where @xmath115 is angle between the two equators , and @xmath116 is the distance between @xmath117 and the horizontal equator .",
    "note that @xmath116 is at most @xmath118 ( @xmath119 only when @xmath79 reaches the desired meridian ) , so @xmath120 .",
    "in equation we assumed that @xmath117 is located on the bottom - margin of the arrow - filled area of the figure  [ fig : fig3 ] ( which always holds for one fault case ) .",
    "for @xmath117 located above the bottom margin , we should calculate for a smaller value of @xmath118 , which will result in smaller value of @xmath113 . for @xmath117 located above the horizontal equator ,",
    "the fault - effect @xmath113 is negative , i.e. the resulting state @xmath121 is closer to the desired meridian w.r.t .",
    "the direction in parallel to the slanted orthodrome . relaxing the above - mentioned assumption",
    ", we can conclude the following rough bound :    @xmath122    now , based on the inequality we shall derive more precise bounds .",
    "if the number of non - faulty marked items @xmath123 , then the angle @xmath124 = \\left(0;\\frac{\\pi}{4}\\right]$ ] .",
    "so we have @xmath125 .",
    "now let us consider different values of @xmath116 . if @xmath126 , then is bounded by @xmath127 where the inequalities become equalities for @xmath128 and @xmath129 .",
    "if @xmath130 , then we can follow that the state @xmath117 is gone far away from the point `` @xmath131 '' of the unit sphere .",
    "this distance between the point @xmath104 and the state @xmath117 can be derived from the rule : @xmath132    since the total distance between the point `` @xmath131 '' and any point of the meridian `` @xmath133 '' is exactly @xmath134 , we follow that the state @xmath117 is at most @xmath135 far from the desired meridian .    from and",
    "we formulate the following joint conclusion :    [ cor : onefault ] at least one of the following claims holds for any state @xmath117 with @xmath125 :    * either the fault - effect @xmath136 , * or the state @xmath117 is already at most @xmath137 far from the desired meridian `` @xmath105 '' .",
    "now let us use another approach to study the evolution of a state in the considered settings .",
    "transformation @xmath138 drives the state @xmath79 clockwise in parallel to the slanted orthodrome by a distance , which depends on the position of this state on the unit sphere .",
    "+    ( 150,150 ) ( 55,0).,title=\"fig : \" ] ( 101,57 ) ( 143,59 ) ( 25,0 ) ( 30,33 ) ( 30,81 ) ( 40,116 ) ( 75,151 ) ( 103,73 )    on figure  [ fig : fig5 ] we show a `` speed '' for each possible position of the state @xmath79 . on the `` no - faults '' route (",
    "i.e. the slanted orthodrome ) the speed coincides with that of the original grover s algorithm : .",
    "after a state jumps up , its speed decreases depending on its distance to the slanted orthodrome : e.g. on the parallel circle which contains point `` @xmath139 '' of the units sphere , its speed is @xmath140 .",
    "we can also calculate the speed of a state w.r.t .",
    "the direction in parallel to the horizontal equator , i.e. the speed of its projection onto the horizontal equator @xmath141 . obviously , among all states on some meridian @xmath142 , the uppermost state @xmath143 has the least speed .",
    "distance between @xmath143 and the point `` @xmath144 '' of the unit sphere , can be derived from angle @xmath118 , distance @xmath142 and rule : @xmath145 .",
    "distance between @xmath143 and the slanted orthodrome can be derived from distance @xmath146 , angle @xmath147 and rule : . and the speed of @xmath143 @xmath148 serves as a natural lower bound for the speed of any state located on the same meridian @xmath142 : @xmath149 projection of the speed @xmath150 onto the horizontal equator might be slightly less : @xmath151 vertical jumps leave states on the same meridians , so faults does not affect value @xmath142 . moving at least at speed , a state will pass distance @xmath134 in at most @xmath152 steps .",
    "from we obtain an upper bound for the number of steps until some meridian @xmath153 ( for arbitrary number of faults , i.e. for any @xmath77 ) :    @xmath154    we note that on the fastest `` no - fault '' route a state will travel exactly at speed @xmath155 , so that in the same many @xmath156 steps it can reach at most @xmath157 meridian .    from we",
    "can derive the upper bound for the distance between the two meridians @xmath153 and @xmath158 : @xmath159    for example , if we fix @xmath160 , then for any @xmath161 , value does not exceed @xmath137 .",
    "that is , when the fastest state of a quantum ensemble reaches meridian @xmath162 , the slowest state of the ensemble with certainty reaches at least meridian @xmath160 .",
    "we run standard grover s algorithm @xmath163 times longer than usually , and then perform a measurement .    *",
    "if at most one fault is promised , and @xmath164 , means that there is at least as many non - faulty marked items as faulty marked items .",
    "since we limit our considerations with only one faulty marked item , it suffices with only one non - faulty marked item .",
    "] then we use corollary [ cor : onefault ] and follow that any component of the resulting mixture @xmath165 is at most @xmath166 far from the meridian `` @xmath105 '' . *",
    "if @xmath167 , non - faulty marked items ] then we substitute @xmath160 in and follow exactly the same .",
    "measurement of such @xmath165 results in finding a marked item ( the faulty or a non - faulty one ) with probability at least @xmath168    * otherwise , if @xmath169 and there is no promise on the number of faults , it means that there is exactly 1 non - faulty marked element ( so @xmath170 ) .",
    "in this specific case we run standard grover s algorithm @xmath171 times longer than usually , and then perform a measurement .",
    "we substitute @xmath172 in and follow that value does not exceed @xmath173 .",
    "that is , when the fastest state of a quantum ensemble reaches meridian @xmath174 , the slowest state of the ensemble with certainty reaches at least meridian @xmath175 .",
    "measurement of such @xmath165 results in finding a marked item ( the faulty or a non - faulty one ) with probability at least @xmath176 .",
    "in this section we analyze the state of the algorithm after a large number of steps .",
    "we consider a density matrix of the state and describe how transformations of the algorithm change the state .",
    "we prove an existence of the limiting state and give probabilities of finding a non - faulty marked , as well as faulty marked item then measuring the state .",
    "consider the density matrix @xmath42 of the quantum state of grover s algorithm after @xmath18 queries . due to symmetry",
    ", we can assume that the first @xmath22 basis states correspond to the marked elements .",
    "note that grover s algorithm acts in the same way on all non - faulty marked elements , as well as on all non - marked elements .",
    "therefore , the state of the algorithm is a probabilistic mixture of pure states of the form @xmath177 the density matrix @xmath42 , then , takes the form   @xmath178\\ ] ]    because the density matrix for every pure state ( [ eq : state ] ) in the mixture @xmath42 is of this form .",
    "next we consider the effect of the faulty query @xmath28 and the diffusion transformation @xmath11 on the density matrix @xmath179 .",
    "the effect of the faulty query @xmath28 on the density matrix @xmath42 is :    @xmath180    follows from ( * ? ? ?",
    "* formula ( 2 ) ) .",
    "the effect of the diffusion transformation @xmath11 on the density matrix @xmath179 is :    @xmath181    where @xmath182 is the average of all elements of @xmath179 , @xmath183 is the average of @xmath184 row and @xmath185 is the average of @xmath186 column of @xmath179 .",
    "first we right multiply @xmath187 by @xmath188 .\\ ] ] we get matrix @xmath189 where @xmath190 next we left multiply by @xmath11 and get matrix @xmath191 where @xmath192 @xmath193 @xmath194    as @xmath195 ( this follows from the structure of the density matrix @xmath42 ) we can use @xmath196 to denote both @xmath197 and @xmath198 .    using the same argument as in @xcite",
    "we can prove @xmath199 and @xmath200 .",
    "consider @xmath201 such that for all @xmath202 inequalities @xmath203 and @xmath204 hold .",
    "we will prove that at this moment all elements of @xmath42 should be @xmath205 close to their final values .",
    "the proof is done in two steps .",
    "first we prove that all @xmath196 can differ by at most @xmath205 .",
    "next , as a consequence , we derive @xmath206 .    [ claim : vi_vj ] @xmath207 .",
    "first , note that @xmath208 and @xmath209 .",
    "this follows from the structure of @xmath42 .",
    "next , consider effect of @xmath11 on elements @xmath210 and @xmath211 .",
    "both elements are @xmath205",
    ". corresponding changes @xmath212 and @xmath213 should also be @xmath205 .",
    "thus , @xmath214 from which follows @xmath215 .",
    "now consider @xmath216 . by using",
    "we can write @xmath217 putting this into @xmath218 and opening brackets we get @xmath219 from which follows @xmath220 .",
    "@xmath11 changes elements of @xmath42 by at most @xmath205 .",
    "the change of element @xmath221 is equal to @xmath222 . using claim [ claim : vi_vj ] we can rewrite this equation as @xmath223    @xmath224 .",
    "consider the effect of @xmath28 on @xmath225 .",
    "@xmath28 leaves @xmath116 unchanged , but changes the sign of @xmath146 . as the claim [ claim : vi_vj ] should hold for all subsequent steps , @xmath28 can not change value of @xmath226 by more than @xmath205 .",
    "thus , @xmath227 should be @xmath205 , which means that @xmath224 .",
    "@xmath28 changes elements of @xmath42 by at most @xmath205",
    ".    trivially follows from and the previous corollary .",
    "we can chose @xmath77 to be arbitrary small , thus , we have   @xmath228 .\\ ] ] as @xmath229 ( follows from @xmath230 ) and @xmath231 ( property of density matrix ) we have @xmath232 which completes the proof of the theorem .",
    "in this paper we focus on the case where search space contains multiple non - faulty and one faulty marked element .",
    "first we show that if there are at least two non - faulty marked elements or it there is at most one fault , then it is still possible to find a non - faulty marked element in @xmath1 queries with @xmath35 probability .",
    "it is an open question to generalize the results for more than one faulty marked element .",
    "although the generalization of theorem [ thm : limiting_behaviour ] seems to be straightforward it is not given here .",
    "the generalization of theorem [ thm : search ] might be tricky as one needs to deal with hyper - spherical geometry .",
    "one simple case , in which the theorem still holds for multiple faulty marked elements , is synchronized - fault - case , where each query either fails or succeeds on all faulty marked elements ."
  ],
  "abstract_text": [
    "<S> grover s algorithm is a quantum query algorithm solving the unstructured search problem of size @xmath0 using @xmath1 queries . </S>",
    "<S> it provides a significant speed - up over any classical algorithm @xcite .    </S>",
    "<S> the running time of the algorithm , however , is very sensitive to errors in queries . it is known that if query may fail ( report all marked elements as unmarked ) the algorithm needs @xmath2 queries to find a marked element @xcite . </S>",
    "<S> @xcite have proved the same result for the model where each marked element has its own probability to be reported as unmarked .    </S>",
    "<S> we study the behavior of grover s algorithm in the model where the search space contains both faulty and non - faulty marked elements . </S>",
    "<S> we show that in this setting it is indeed possible to find one of non - faulty marked items in @xmath1 queries .    </S>",
    "<S> we also analyze the limiting behavior of the algorithm for a large number of steps and show the existence and the structure of limiting state @xmath3 . </S>"
  ]
}