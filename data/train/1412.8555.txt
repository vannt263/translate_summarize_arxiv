{
  "article_text": [
    "work we propose and optimize the strategies to increase the throughput of transmission over a block fading channel .",
    "is mostly used to deal with the loss of data packets due to unpredictable changes in the channel and consists in `` handshaking '' between the transmitter and the receiver : the receiver sends the binary messages via a feedback channel to inform the transmitter about the success ( ack message ) or failure ( nack ) of the transmission . then a new version of the lost packet is transmitted .",
    "this process continues till ack is received or  in the case of _ truncated _ till the maximum number of transmission rounds is reached . in practice , the truncation appears as an implementation constraint but also may be justified when transmitting data that is delay - sensitive , which after a prescribed time may loose its validity .",
    "is often perceived as an additional `` guarantee '' , which works on the top of the .",
    "however , it was already shown in previous works , that adjusting the -related parameters ( rate , coding , power ) as a function of the state can significantly improve the performance , e.g. ,  in terms of the average transmission rate ( throughput ) @xcite , or the outage @xcite .",
    "while the parameters of the phy may be adjusted as a function of the number of received nack messages , more substantial gains are obtained exploiting the additional information sent by the receiver .",
    "we thus consider the case when , on top of ack / nack messages , the receiver conveys over the feedback channel , `` multi - bit '' . as we explain later ,",
    "represent the state of the decoder , which is related to the determined by the channel gains in different blocks .",
    "these channel gains are assumed to be random variables ( a modelling , which captures adequately the fact that retransmissions are usually scheduled in well - spaced time instant to absorb the processing and round - trip delays ) .",
    "therefore , the transmitter is unable to infer the instantaneous from the , and thus , the conventional can not be used .",
    "nevertheless , the that accompanies the nack message , provides the transmitter with valuable prior allowing it to suitably adjust its parameters in the subsequent rounds .",
    "indeed , the use of was already considered before in @xcite to adapt the length of the codewords with the implicit objective of shortening the average number of transmissions and using the time `` released '' in such a way to send more packets .",
    "it is worth mentioning here that , in @xcite the lengths were optimized in abstraction of the system - level considerations .",
    "thus , exploiting the released time is not obvious because the codewords with variable lengths are sent within the same block .",
    "the lengths are optimized in abstraction of the block - length so , in general , they do not match the latter .",
    "this , will produce an unoccupied time within the block , which in turn translates into a throughput loss . to address this problem",
    ", @xcite proposed the use of many packets within a single block , reducing in this way the impact of the unoccupied time .",
    "this may go , however , against the practical considerations of having only one or a few packets in the block .",
    "moreover , regardless of system - level considerations , recognizing that various packets are transmitted within the same block raises the question of optimality of the conventional approach , and the @xcite may be an alternative as already considered before with , e.g. ,  in @xcite .",
    "= [ draw , minimum width=1.6 cm , text width=1.5 cm , fill = blue!5 , text centered , minimum height=.9 cm ]    = [ draw = none , minimum width=3.4 cm , text width=1.5 cm , fill = none , text centered , minimum height=0 cm ]    = [ draw , dashed , minimum width=1.5 cm , text width=1.4 cm , fill = blue!2 , text centered , minimum height=1.8 cm ]    = [ draw = none , minimum width=0 cm , text width=0 cm , fill = none , text centered , minimum height=.6 cm ]    = [ draw , ellipse , minimum width=.2 cm , text width=0 cm , fill = none , text centered , minimum height=1 cm ]    = [ draw , ellipse , minimum width=.1 cm , text width=0 cm , fill = none , text centered , minimum height=.6 cm ]    ( channel)[form1 ] channel ;    ( channel.west)+(-2.7,0 ) node[form1](enc ) encoder ; ( channel.east)+(2.7,0 ) node[form1](dec ) decoder ; ( channel.north)+(0,1.6 ) node[form3](fedback ) feedback channel ; ( enc.north)+(0,1.6 ) node[form1](arq_cont1 ) harq controller ; ( dec.north)+(0,1.6 ) node[form1](arq_cont2 ) harq controller ; ( enc.west)+(-1,-0.2 ) node(buff1 ) ;    ( buff1)+(0,2.3 ) node[form2](buff11 ) ; ( buff1)+(-2,2.3 ) node[form2](buff13 ) ; ( buff1.south)+(0,-.3 ) node(buff1p1 ) ; ( buff1.north)+(0,.6 ) node[form4](buff1p2 ) ; ( dec.east)+(1,0 ) node[form2](buff2 ) ;    ( buff2)+(0,2.3 ) node[form2](buff21 ) ; ( buff2)+(2,2.3 ) node[form2](buff23 ) ; ( buff2.south)+(0,-.2 ) node(buff2p1 ) ; ( buff2.north)+(0,.2 ) node(buff2p2 ) ; ( fedback.east)+(0,-0.6 ) node(p1_fed ) ; ( fedback.west)+(0,-0.7 ) node(p2_fed ) ; ( dec.north)+(-0.6,0 ) node(p1_dec ) ; ( enc.north)+(0.6,0 ) node(p1_enc ) ;    ( buff11)(buff1p1.base ) ; ( buff1p1)+(-2,0)(buff13 ) ;    ( buff21)(buff2p1.base ) ; ( buff2p1)+(2,0) ( buff23 ) ;    ( buff1.north)+(-2,0)(buff1.north ) ; ( buff1p1)+(-2,0)node[shift=(0,.3)]@xmath0(buff1p1.base ) ; ( buff1p2)+(-2,0)node[shift=(0,-.3)]@xmath1(buff1p2.base ) ;    ( buff2p1)+(2,0)(buff2p1.base ) ; ( buff2p2)+(2,0)(buff2p2.base ) ;    ( buff1p1)+(-1,1.9 ) node(pts1)@xmath2 ;    ( buff2p1)+(1,1.3 ) node(pts4)@xmath2 ;    ( buff1p1)+ ( .5,0.6 ) node[elip](el ) ;    ( buff2p1)+ ( -.5,0.3 ) node[elip2](el2 ) ;    ( enc.east)node[shift=(0,.3)]@xmath3$](channel.west ) ; ( channel.east)node[shift=(0,.3)]@xmath4$](dec.west ) ;    ( buff1p2.south)+(1,0)(buff1p2.south ) ; ( buff1.base)+(1,0)(buff1.base ) ; ( buff2.base)+(-1,0)(buff2.base ) ;    ( arq_cont1.south)node[shift=(0.8,0)]@xmath5$](enc.north ) ; ( arq_cont2.south)node[shift=(0.4,0)]@xmath6$](dec.north ) ;    ( arq_cont2.west)node[shift=(0,.3)]@xmath6$](fedback.east ) ;    ( arq_cont1.east)node[shift=(0,.3)]@xmath7 , i[n])$](fedback.west ) ;    ( p1_fed.base)-| node[shift=(-1.2,.2)]@xmath8$](p1_dec.base ) ; ( arq_cont1.west)-|(el.north ) ; ( arq_cont2.east)-|(el2.north ) ;    in this work we address these two issues . on one hand , we explicitly consider the constraints resulting from the transmission of variable - length packets within the same block @xcite ; this links the design with system - level considerations , an issue that was lacking in @xcite . on the other hand ,",
    "we consider the and as alternatives for the joint encoding of the new and retransmitted packets ; we formally optimize the parameters which was not considered in @xcite .",
    "we look at the as a _ control _ process based on the feedback signal and we optimize the _ actions _ which are given by the joint encoding ( and its parameters ) to be used . to solve the optimization we define our problem as a ( * ?",
    "7.4 ) , which was already used in different contexts for optimization , e.g. ,  in @xcite .",
    "we maximize the throughput which is a relevant performance criterion as it can be directly related to the ergodic ( long term ) channel capacity @xcite .",
    "the paper is organized as follows : sec .",
    "[ sec : model ] defines the model of the system under study , which is then cast into in sec .",
    "[ sec : mdp.signalling ] .",
    "we explain the optimization in sec .  [",
    "sec : th.mdp ] and the numerical results are shown and discussed in sec .",
    "[ sec : num.results ] .",
    "the case of one bit feedback is analyzed in sec .",
    "[ sec : one_bit ] .",
    "we conclude the work in sec .",
    "[ sec : conclusions ] .",
    "we first describe the conventional , which allows us to define the useful notation and next we discuss the _ multi - packet _ we propose .",
    "we consider a point - to - point transmission using shown in fig .",
    "[ fig : harq_buffer ] , where the transmitter sends the data block @xmath3 $ ] of @xmath9 symbols over a block - fading channel .",
    "each block @xmath10 contains the encoded version of @xmath11 information bits contained in @xmath0 , where @xmath12 indicates the packet at block time @xmath10 ( the packet is the first packet in the buffer to be transmitted ) ; for convenience we say that the packet @xmath1 is `` -next '' .",
    "the coding rate per packet is thus @xmath13 .",
    "the receiver observes the channel outcome @xmath4 $ ] and attempts to decode @xmath0 .",
    "we note that the indices of the packets are not the same as indices of the blocks , we refer to the former via subindexing , e.g. ,  @xmath14 , and  to the latter  via arguments within brackets , e.g. ,  @xmath3 $ ]",
    ". we also use @xmath15 to denote the index of the block @xmath16 $ ] when the packet @xmath14 was transmitted for the first time .",
    "more than one transmission may be necessary to deliver the packet and the index of the transmission round of the packet is kept by transmitter in the counter @xmath17 . for convenience , we assume that the counter @xmath18 for the @xmath19-th packet entering the transmitter s buffer , where @xmath20 is set to zero , i.e. ,  .",
    "the decoding errors are detected at the receiver which sends to the transmitter a binary message @xmath6={{\\mathcal{m}}}_{\\ell,{k}_\\ell}$ ] , where @xmath21 if the decoding of @xmath0 is successful in the @xmath22-th round , or @xmath23 if the decoding fails .",
    "reassume that the feedback channel is error - free .",
    "due to the propagation , transmission , and processing delays , the message @xmath6 $ ] arrives at the transmitter at time block @xmath24 , where it can be used by the controller .",
    "the latter discards the packet when @xmath25 is received or the maximum number of transmission rounds @xmath26 is reached ; then the -next packet becomes the .",
    "formally , this is done , first , incrementing the index , which otherwise does not change , i.e. ,   @xmath27 and , next , increasing the counter of the packet @xmath28    when the packets have their counter sets to zero , increasing it via , we obtain @xmath29 , which means that we start the process of the packet @xmath14 .    the encoding , in general depend on the index of the transmission round , i.e. ,  on the counter @xmath30 , i.e. ,   @xmath31={\\phi}_{{k}_{\\ell}}({\\boldsymbol{u}}_{{\\ell}}).\\end{aligned}\\ ] ]    in particular , when @xmath32 we have the case of transmission with the @xcite @xcite .",
    "that is , irrespectively of @xmath30 , the transmitted symbols @xmath3 $ ] are always the same for the given @xmath33 .",
    "if , on the other hand , @xmath30 is used to extract different subcodewords of the mother code s codeword @xmath34,\\end{aligned}\\ ] ] we obtain the well - known @xcite , where conventionally , all the subcodewords @xmath35 have the same length . is the focus of this work .",
    "the channel outcome at the receiver is given by @xmath36=\\sqrt{{\\mathsf{snr}}[n]}{\\boldsymbol{s}}[n]+{\\boldsymbol{z}}[n],\\ ] ] where @xmath37 $ ] is the channel , @xmath38 $ ] is a zero mean , unitary - variance gaussian variable modelling noise .",
    "we assume that @xmath37 $ ] are and their is known . for numerical evaluation",
    "we use the exponential form ( i.e. ,  we consider rayleigh block fading ) @xmath39 where @xmath40 is the average .    in",
    ", the receiver decodes the packet @xmath0 concatenating the @xmath41 blocks of channel outcomes @xmath42,{\\ldots},{\\boldsymbol{y}}[n_{\\ell}+{k}-1]\\big].\\end{aligned}\\ ] ] then , assuming the subcodewords @xmath43 are drawn from randomly generated codebook , and for sufficiently large @xmath9 , the decoding is successful if the defined as @xmath44 ) \\end{aligned}\\ ] ] exceeds the transmission rate , i.e. ,  @xmath45 for simplicity , we assume only gaussian inputs , i.e. ,  @xmath46 the is thus equivalent to the and we may sent it to the transmitter over the feedback channel but it is irrelevant for the conventional harq .      in the conventional ,",
    "@xmath3 $ ] depends solely on the counter @xmath17 and the packet contents @xmath0 , as per . for the proposed multi - packet harq , we assume that the encoder is able to jointly encode the packet @xmath0 and the -next packet @xmath1 as shown also schematically in fig .  [",
    "fig : harq_buffer ] , i.e. ,  @xmath47={\\phi^{{{\\textnormal{mp}}}}}({{\\boldsymbol{u}}_{{\\ell}},{\\boldsymbol{u}}_{{\\ell}+1},{k}_{{\\ell}},{k}_{{\\ell}+1 } , p}),\\end{aligned}\\ ] ] where @xmath48 is the parameter of the encoding and it is a function of the counters @xmath17 and @xmath49 and the .    we consider four possible encoding modes    * conventional , one - packet transmission , which we denote by 1p , where the block @xmath3 $ ] is occupied only by the subcodewords of the packet , * dropped , one - packet transmission , which we denote by 0p , where we stop the transmission of the packet and @xmath3 $ ] is occupied only by the subcodewords of the -next packet , * transmission , where the subcodewords of the and -next packets are transmitted in non - overlaping parts of the block , with the time - sharing defined by @xmath48 , and * transmission , where both codewords are superimposed with power fractions defined by @xmath48 .",
    "we clarify this in table  [ tab : mod.schemes ] , where we add details to the encoding notation in as follows : @xmath50 where @xmath51 indicates the relative length of the @xmath18th subcodeword composed of @xmath52 symbols .",
    ".results of encoding actions @xmath5 $ ] for the joint encoding of the and -next packets @xmath14 and @xmath1 . [ cols=\"<,^\",options=\"header \" , ]     we note that when the joint encoding ( or ) is chosen , the feedback channel transmits the decoding result for both and -next packets , i.e. ,  @xmath53=({{\\mathcal{m}}}_{{{\\ell}},{k}_{{\\ell}}},{{\\mathcal{m}}}_{{{\\ell}+1},{k}_{{\\ell}+1}})$ ] .",
    "the role of the controller is to decide on the encoding _ actions _",
    "@xmath5=({{\\mathsf{m}}}[n],p[n])$ ] , where @xmath54\\in{{\\mathcal{a}}}_{{\\textnormal{mod}}}={\\{{{\\textnormal{1p}}},{{\\textnormal{0p}}},{{{\\textnormal{ts}}}},{{{\\textnormal{sc}}}}\\}}$ ] defines the encoding `` mode '' and @xmath55 \\in { { \\mathcal{a}}}_{{\\textrm{p}}}=]0,1[$ ] is the encoding parameter as specified also in table  [ tab : mod.schemes ] .",
    "the conventional always takes the same encoding action @xmath5=({{\\textnormal{1p}}},-)$ ] , where we use `` @xmath56 '' to indicate that , in this case , the parameter @xmath48 is irrelevant from the point of view of the encoding .",
    "the actions are taken from the action - space @xmath57 and may result in one - packet ( 1p or 0p ) or a multi - packet ( or ) transmissions .",
    "the rule for updating @xmath12 becomes now the following : @xmath58 and the counters update takes into account the possibility of joint encoding @xmath59 @xmath60 where the second condition in reflects the fact that both , and -next packets are transmitted simultaneously .",
    "we note that the actions from the subspace @xmath61 are explicitly excluded because for the joint encoding with @xmath62 , one of the packets is deprived of the transmission time ( ts ) or power ( sc ) , while its counter would increment as per the second line of .",
    "this is clearly suboptimal so the cases of @xmath62 are handled by the encoding modes 1p or 0p , where only one counter is incremented .",
    "we also note that the action @xmath63 was already used in @xcite@xcite and means that the packet is abandoned when there is no `` reasonable hope '' to decode it successfully . while making such a decision may seem drastic",
    ", the dropped packeted may be re - injected into the transmitter s buffer as may also be other packets considered lost .",
    "this issue depends on the sensitivity of the source to the delay in the packets delivery  the problem we do not consider here .",
    "the decoding is done in the similar way as in the one - packet . in the case of the encoding , after the @xmath64-th transmission , the decoding is successful provided that , with @xmath65 where by definition @xmath66 and to simplify the notation we used @xmath67 $ ] .",
    "at the same time we find the for the -next packet as @xmath68    since @xmath69 is random , increasing @xmath48 , the probability of successful decoding of the packet @xmath0 increases with @xmath48 , see , but at the same time , the probability of correct decoding of the -next packet is decreased .",
    "thus , it is not possible to improve simultaneously the reliability of transmission of both packets .",
    "the challenge of optimizing the encoding actions lies in striking the balance between these contradictory effects .    in the case of the",
    ", the decoding is slightly more involved because the and -next packets interfere with each other . for simplicity",
    "we only consider single packet decoding , in contrast to joint decoding of both packets .",
    "that is , we assume that decoding of @xmath14 depends solely on @xmath70 and @xmath71 $ ] , i.e. ,  the of the packet is given by @xmath72    the for the -next packet is given by @xmath73 in the case @xmath74 we assume that the interference induced by the superposed subcodeword @xmath75 was removed ; in the other case  that the interference can not be removed because the related to the packet is not sufficiently large to allow for decoding ( @xmath76 ) .",
    "we assume that after each multi - packet round , on top of the conventional signalling @xmath6=({{\\mathcal{m}}}_{{{\\ell}},{k}_{{\\ell}}},{{\\mathcal{m}}}_{{{\\ell}+1},{k}_{{\\ell}+1}})$ ] , the transmitter is provided with additional information about the state of the receiver .",
    "in particular , since the decoding success / failure are determined by the ami , see , the @xmath77=(i_{{{\\ell}},{k}_{{\\ell}}},i_{{{\\ell}+1},{k}_{{\\ell}+1}})$ ] is sent via the feedback channel to the transmitter or , instead , report @xmath37 $ ] and let the transmitter to calculate the via , , , or ] , as shown in fig .",
    "[ fig : harq_buffer ] .",
    "we focus on optimizing the encoding action @xmath78 , targeting the maximization of the throughput .",
    "the key idea is to represent the multi - packet as an @xmath79 where @xmath80 and @xmath81 are the state space , the action space and the disturbance space respectively , @xmath82 is the transition law and @xmath83 is the reward ( * ? ? ?",
    "* ch .  1 ) .",
    "being in state @xmath84 at block time @xmath10 gives the controller the possibility to take action @xmath5 \\in { { \\mathcal{a}}}({{\\mathsf{s}}})$ ] , after which the moves to the next state @xmath85 at time @xmath24 . in general , not all actions are allowed in a state @xmath86 , thus @xmath87 .",
    "the transition from the state @xmath86 to @xmath85 depends uniquely on action @xmath5 $ ] and on a random disturbance @xmath88\\in{{\\mathcal{w}}}$ ] .",
    "thus , the transition between states is characterized in probabilistic manner described by the transition law @xmath82 .",
    "the function @xmath89 defines the reward acquired when the system is in state @xmath86 and the controller chooses action @xmath78 .      in the multi - packet ,",
    "the feedback messages @xmath77 $ ] , as well as the counters @xmath90=({k}_{{\\ell } } , { k}_{{\\ell}+1})$ ] define the state of the process .",
    "the @xmath91 is defined over the set @xmath92 by the quantities : @xmath93\\cup { { \\mathcal{i}}}_{r_+},\\\\ \\label{def.rp } { { \\mathcal{i}}}_{r_+}&\\triangleq(r,\\infty),\\end{aligned}\\ ] ] where explicitly groups those values of the which lead to the event of decoding success ( @xmath94 ) .",
    "with @xmath26 allowed transmission rounds and considering that and -next packets may be sent simultaneously , the counters @xmath95 can only take values in the set @xmath96 .",
    "thus , the state space @xmath97 is defined as : @xmath98 .",
    "each state is thus represented by a quadruplet @xmath99 .",
    "we note that the value of @xmath77 $ ] contains implicitly the results of the decoding @xmath6 $ ] .    for @xmath84 ,",
    "we denote by @xmath100 , @xmath101 and @xmath102 the corresponding value of @xmath103 , @xmath95 and @xmath91 respectively .",
    "we distinguish the following subsets : @xmath104 where @xmath105 contains states when both packets are decoded correctly while @xmath106 presents states when both packets failed to be decoded , @xmath107 is the set of states when only one packet is decoded correctly , @xmath108 and @xmath109 characterize the states when the one - packet transmission mode is adopted in the whole rounds and that the packet is successfully or unsuccessfully decoded respectively .",
    "we also consider three types of differentiated by their respective action space :    1 .",
    "conventional one - packet ( 1p ) when @xmath48 is irrelevant . in this case",
    "the action space @xmath110 has only one element @xmath111 and no optimization is needed .",
    "2 .   time sharing multi - packet mode ( ts ) when the action space is defined as @xmath112 with @xmath113 .",
    "superposition coding multi - packet mode ( sc ) when @xmath114 with @xmath115 .",
    "we assume that the joint - encoding actions , i.e. ,  @xmath116 , can be taken for all states @xmath84 except if @xmath117 when only one packet is transmitted .",
    "that is , the joint - encoding actions is only allowed when the packet is not succesfully decoded .",
    "the statistically evolution of the system is represented by the transition law @xmath82 .",
    "since the states and the actions are discrete , see sec .",
    "[ sec.discri ] , this law is given by the state - to - state transition probabilities : @xmath118={{\\mathsf{s}}}'|{{\\mathsf{s}}}[n]={{\\mathsf{s } } } , { { \\mathsf{a}}}[n]={{\\mathsf{a}}}\\}}.\\ ] ] which can be calculated using - .",
    "an example of @xmath119 calculation is shown in appendix a. we assume here the stationary behaviour , in which the time @xmath10 is irrelevant for the transition probability ; this condition is satisfied for sufficiently large @xmath10 , i.e. ,  after the transients phase .",
    "the transition from the state @xmath120 $ ] to the state @xmath121 $ ] depends on the action @xmath5 $ ] and on the disturbance @xmath37 \\geq 0 $ ] as can be seen in - .",
    "consequently we take @xmath122 .",
    "each state - transition yields the reward given by @xmath123 and the expected reward for taking action @xmath78 in the state @xmath86 is then given by @xmath124    our objective is thus to find a _ policy _ @xmath125 , such that the controller taking actions @xmath126 , maximizes the throughput defined as @xmath127,\\pi({{\\mathsf{s}}}[n])),\\big],\\ ] ] where the expectation is taken with respect to the random states @xmath128,{\\ldots } , { { \\mathsf{s}}}[n]$ ] of the process , and @xmath129,\\pi({{\\mathsf{s}}}[n]))$ ] is the random _ reward _ obtained using the actions @xmath130)$ ] after transmission of the block @xmath10 defined in .        the problem is now formulated as the and , in order to make it tractable numerically we make the state - space @xmath97 discrete .",
    "the first dimension @xmath131 of @xmath97 is discrete by definition , so we discretize @xmath132 using @xmath133 points ; which means that we need to discretize the set @xmath134 using @xmath135 points ( we used uniform quantization ) and assign one discretization point to @xmath136 .    similarly , the actions set @xmath110 is discretized over @xmath137 , thus the encoding parameters @xmath138 are discretized over @xmath139 points .      our goal is to solve the following optimization problem @xmath140 where @xmath141 is the set of admissible policies @xmath142 .",
    "this average reward - per - stage problem can be solved using the so - called bellman s equations ( * ? ? ?",
    "7.4 ) , @xmath143,\\quad \\forall { { \\mathsf{s}}}\\neq{{\\mathsf{s}}}_{\\textrm{p}},\\\\ h_{{{\\mathsf{s}}}_{\\textrm{p}}}&=0\\end{aligned}\\ ] ] thanks to the following lemma .",
    "[ assum1 ] there is at least one state , denoted by @xmath144 and @xmath145 , such that , for all initial states and all policies @xmath146 , the probability of being in state @xmath144 at least once within the first @xmath147 times , is non zero , i.e. ,  @xmath148={{\\mathsf{s}}}_{\\textrm{p } } \\}}>0 $ ] , where @xmath149 .",
    "we take the special state @xmath150 , where @xmath151 is the smallest value defined by the discretization . since @xmath152 message occurs with non - zero probability , and the probability of having arbitrarily small",
    "is not zero , the probability of visiting the special state @xmath144 is non - zero , too .    under lemma  [ assum1 ] , we obtain the guarantee that the optimal throughput @xmath153 is independent of the initial state ( * ? ? ?",
    "7.4.1.b ) and to solve equation for all @xmath86 , we may use two - step policy iteration algorithm for the average reward problem ( * ? ?",
    "7.4 ) . in the first step ,",
    "given the policy @xmath146 , we calculate the corresponding average and differential rewards , @xmath154 and @xmath155 , respectively , that is , we solve the following equation for each @xmath156 @xmath157 where @xmath158 . in the next step ,",
    "we perform a policy improvement to update @xmath159 as follows @xmath160.\\ ] ] the steps and are repeated till convergence , which is guaranteed to be attained in finite number of iterations ( * ? ? ?",
    "7.4.2 ) .    in the numerical examples",
    ", the algorithm converges with a relatively small number of iterations ( @xmath161 ) when we choose as initial policy @xmath162=(1p,-)$ ] .      in this section",
    "we compare the performance of the proposed , i.e. ,  ts  and  sc , to the conventional in terms of attainable throughput as well as the outage probability .",
    "the throughput of the conventional can be calculated using renewal - reward theorem @xcite or , using our formulation , by considering that only the `` conventional '' actions for all the states @xmath163 are taken .",
    "that is , adopting the following policy : @xmath164      first we investigate the encoding mode to be used , i.e. ,  we want to find the benefit of deciding in favor of the ts  or  sc .",
    "to this end we first run the optimization for a fixed value of @xmath165 and analyze the case when @xmath112 , that is , the controller is able to choose among the modes 1p , 0p or ts .",
    "these results , denoted by ts , are shown in fig .",
    "[ fig : th.r=4 ] .",
    "we also show therein , under the legend sc , the results of the optimization when @xmath114 , i.e. ,  the controller is to choose one of the modes 1p , 0p or sc .",
    "the throughput of the conventional , denoted as 1p , as well as the ergodic capacity @xmath166 are also shown for comparison .    using the conventional and for the fixed @xmath167 ( i.e.",
    ",  that does not change with @xmath40 ) , the benefit of increasing the number of allowed transmission @xmath26 materializes only for low and thus , for small throughput values .",
    "this is why is sometimes considered valuable only for low regime .",
    "as we will see in fig .",
    "[ fig : f1 ] , similar value of throughput may be obtained decreasing @xmath167 and yet keeping @xmath26 small .",
    "therefore , from the system - level perspective , the most valuable throughput gains are those obtained close to the nominal transmission rate @xmath167 , where we see that the multi - packet provides significant advantage over the conventional .    as a reference we consider the throughput @xmath168 ( shown by the horizontal dashed line in fig .  [ fig : th.r=4 ] ) . an important observation  already made in @xcite  is that the conventional presents a large gap to the ergodic capacity @xmath166 when the transmission rate @xmath167 is fixed .",
    "for instance , the gap of approximately @xmath169  db can be observed in fig .",
    "[ fig : th.r=4 ] .",
    "this puts in the perspective the often evoked property of , which says that the throughput of can attain the ergodic capacity with infinite number of transmissions .",
    "while this is , indeed , true , this condition materializes for the throughput @xmath154 much smaller than @xmath167 or for a very small .",
    "alternatively , to reach the ergodic limit having the fixed , a very large rate @xmath167 is needed .    from that point of view",
    ", the proposed multi - packet transmission mode seems to reduce efficiently the gap .",
    "in fact , when @xmath165 bits / channel use and @xmath170 , the gap is reduced by more than @xmath171% . a multi - packet harq with @xmath172 can easily present a gain above @xmath173  db compared to the conventional harq with larger @xmath26 .",
    "when @xmath174 , the gains are around @xmath175  db ; they increase negligible for @xmath176 .",
    "we also note that , even if the difference is relatively small ( less than @xmath177  db ) , the  sc  always outperforms the  ts . to obtain insight into the relevance of the encoding modes , considering @xmath178 and @xmath172 and defining the following probabilities conditioned on the retransmission being needed ( i.e. ,  on @xmath179 ) @xmath180= { { \\textnormal{1p } } } | { { \\mathsf{s}}}\\in { { \\mathcal{s}}}_{{{{\\textnormal{ack}}}},{{{\\textnormal{nack}}}}}\\}},\\\\ \\label{p.sc } p_{{\\textnormal{{{{\\textnormal{sc}}}}}}}&\\triangleq\\pr { \\ { { { \\mathsf{m}}}[n ] = { { { \\textnormal{sc}}}}| { { \\mathsf{s}}}\\in { { \\mathcal{s}}}_{{{{\\textnormal{ack}}}},{{{\\textnormal{nack}}}}}\\}},\\\\ \\label{p.ts } p_{{\\textnormal{{{{\\textnormal{ts}}}}}}}&\\triangleq\\pr { \\{{{\\mathsf{m}}}[n ] = { { { \\textnormal{ts}}}}| { { \\mathsf{s}}}\\in { { \\mathcal{s}}}_{{{{\\textnormal{ack}}}},{{{\\textnormal{nack}}}}}\\}},\\\\ \\label{p.drop } p_{{\\textnormal{drop}}}&\\triangleq\\pr { \\ { { { \\mathsf{m}}}[n ] = { { \\textnormal{0p } } }   |{{\\mathsf{s}}}\\in { { \\mathcal{s}}}_{{{{\\textnormal{ack}}}},{{{\\textnormal{nack}}}}}\\}},\\\\ \\label{p.ack } p_{{\\textnormal{{{{\\textnormal{ack}}}},1}}}&\\triangleq\\pr { \\ { { { \\mathsf{s}}}\\in { { \\mathcal{s}}}_{{{{\\textnormal{ack}}}},{{{\\textnormal{ack}}}}}\\}},\\end{aligned}\\ ] ] where @xmath181 is the probability of choosing one - packet retransmission , @xmath182 is the probability of choosing encoding , @xmath183 is the probability of choosing encoding , @xmath184 is the probability of  dropping \" the packet without retransmission and @xmath185 is the probability that a packet is decoded after the first transmission .",
    "[ ct][ct][1.2]@xmath40  [ db ] [ ct][ct][1.2]@xmath154 [ cl][cl][1.2]ts [ cl][cl][1.2]sc [ cl][cl][1.2]1p [ cl][cl][1.2]@xmath166 [ cl][cl][1.2]@xmath186 [ cl][cl][1.2]@xmath187 [ cl][cl][1.2]@xmath176 [ cl][cl][1.2]@xmath188    [ l][l][1.2]@xmath184 [ ct][ct][1.2]@xmath40  [ db ] [ l][l][1.2]@xmath181 [ l][l][1.2]@xmath182 [ l][l][1.2]@xmath185 [ l][l][1.2]probability    fig .",
    "[ fig : actions.proba ] shows the above - defined probability as a function of @xmath40 from which the following observations can be made    * below a threshold ( @xmath189  db ) , it is more profitable from the throughput point of view to drop the packet , which corresponds to the action @xmath190 . * the one - packet encoding dominates the multi - packet encoding for @xmath191  db , which explains the throughput results are similar for the conventional and the proposed multi - packet . *",
    "the multi - packet transmission is likely to be used for @xmath192  db ; this region of corresponds also to the throughput of the multi - packet ( sc ) being significantly larger than the throughput of the conventional ( 1p ) .",
    "* when mode is available , the time - sharing mode is never used .",
    "* asymptoticaly , i.e. ,  increasing the , we increase the probability of successful decoding in the first transmission , thus all modes will offer a similar throughput for large .",
    "[ ct][ct][1.2]@xmath40  [ db ] [ ct][ct][1.2]@xmath193 [ cl][cl][1.2]sc [ cl][cl][1.2]ts [ cl][cl][1.2]@xmath194 [ cl][cl][1.2]@xmath186 [ cl][cl][1.2]@xmath187 [ cl][cl][1.2]@xmath176    the price to pay for the larger throughput is the increase in the outage as we illustrate in fig .",
    "[ fig : outage ] .",
    "while outage considerations were absent from our discussion , we note that it is also possible to design the policies which take into account the constraints on the outage , however , we leave this issue beyond the scope of our work .    in fig .",
    "[ fig : actions.par ] we show an example of the optimal value of the parameter @xmath48 as a function of the @xmath195 , i.e. ,  when the optimal actions are @xmath196 or @xmath197 , and when @xmath198 .",
    "the intuition behind such results is clear : for larger @xmath195 , i.e. ,  when the first transmission results are close to being decoded ( this happens when @xmath199 , the power ( for sc ) or the time ( for ts ) fractions attributed to the retransmission decrease .",
    "[ ct][ct][1.2]@xmath200 [ ct][ct][1.2]@xmath48 [ cl][cl][1.2]sc [ cl][cl][1.2]ts      we show the results of the throughput for different values @xmath167 in fig .",
    "[ fig : f1 ] ; the results shown for @xmath165 are the same as those we already presented in fig .",
    "[ fig : th.r=4 ]",
    ". as we can see , the gains of the  sc  over the  ts  are less pronounced for smaller values of @xmath167 and @xmath40 .",
    "this is reminiscence of the similar behaviour of the conventional broadcast transmission , where the gains with respect to the appear also in high .",
    "the main conclusion is that the multi - packet provides an important increase of the throughput in the zone of interest ( that is , for throughput values close to the nominal transmission rate @xmath167 ) .",
    "[ cl][cl][1.2]sc , @xmath172 [ cl][cl][1.2]ts , @xmath172 [ cl][cl][1.2]1p , @xmath172 [ cl][cl][1.2]1p , @xmath170 [ ct][ct][1.2]@xmath40  [ db ] [ ct][ct][1.2]@xmath154 [ cl][cl][1.2]@xmath165 [ cl][cl][1.2]@xmath201 [ cl][cl][1.2]@xmath202 [ cl][cl][1.2]@xmath203 [ cl][cl][1.2]@xmath166      to provide an insight into the discretization effects , we show fig .  [ fig : dis ] .",
    "we emphasize here that we took a sufficiently large @xmath133 to accurately calculate the throughput ( @xmath204 in the numerical examples ) .",
    "thus , discretization effects are almost entirely captured by @xmath137 .",
    "we note that ts  and  sc   present notable gain compared to 1p with only @xmath205 .",
    "the results do not change significantly for @xmath206 . for a given @xmath207",
    ", performance may be improved if we considered non uniform quantization , specially in the case of sc ; the issue of finding the optimal quantization is , however , out of scope of this work .",
    "[ ct][ct][1.2]@xmath40  [ db ] [ ct][ct][1.2]@xmath154 [ cl][cl][1.2]ts , @xmath208 [ cl][cl][1.2]ts , @xmath209 [ cl][cl][1.2]ts , @xmath210 [ cl][cl][1.2]1p , @xmath170 [ cl][cl][1.2]1p , @xmath211 [ cl][cl][1.2]sc , @xmath208 [ cl][cl][1.2]sc , @xmath212 [ cl][cl][1.2]sc , @xmath210 [ cl][cl][1.2]1p , @xmath170 [ cl][cl][1.2]1p , @xmath211 [ cl][cl][1.2]@xmath213     + ( a ) +   + ( b )",
    "in this section , we consider the scenario where only the conventional 1-bit feedback ack / nack  is available at the transmitter . in this case , the state space @xmath98 is partially observable : the random variable @xmath92 is non - observable while @xmath131 is fully observable from transmitter by using only the received ack / nack  bits .",
    "this situation is known in the literature as @xcite .    in the context",
    ", the controller decides to take actions @xmath5 $ ] on the basis of _ observable history _ defined as : @xmath214=({{\\mathsf{s}}}[0],{{\\mathsf{a}}}[0 ] , { { \\mathcal{m}}}[1 ] , { \\boldsymbol{k}}[1 ] , { { \\mathsf{a}}}[1],\\cdots , { { \\mathsf{a}}}[n-1 ] , { { \\mathcal{m}}}[n ] , { \\boldsymbol{k}}[n])\\ ] ] where the initial state @xmath215 $ ] and the corresponding action @xmath216 $ ] are assumed to be known . at the transmitter , the @xmath30 are updated using the _",
    "observable _ feedback messages @xmath6 $ ] ; the past actions @xmath78 are also perfectly known to the transmitter .",
    "in general , not the entire history is useful to the controller but only the parts related to the packets under transmission at time @xmath10 , i.e. ,   and -next packet . the standard procedure to solve problem consists in finding the equivalent perfect state problem @xmath217 @xcite .",
    "the state space @xmath218 is @xmath219 , with @xmath220 , called _ the belief states _ , is the space of all probability measures on @xmath92",
    ". the definition of the action space @xmath110 and the disturbance space @xmath81 are the same as in the sec .",
    "[ sec_multi.bit ] .",
    "let @xmath221 be defined as the couple @xmath222 where @xmath223)$ ] is the a posteriori distribution of @xmath224 given an observable history @xmath225 .",
    "the statistical evolution of the system is captured by the transition law @xmath226 where @xmath227 presents the set of discrete probability distribution over @xmath218 .",
    "the expected reward @xmath228 for taking the action @xmath78 in the state @xmath229 is then given by : @xmath230    the main challenge in solving the problem is the characterization of the space of the belief states @xmath231 , i.e. ,  the space of functions @xmath232 .      when @xmath172 , we only need to track the value @xmath195 or @xmath233 when a nack  message is received , i.e. ,  the after the first transmission of the , or -next packet",
    ". thus , the belief states @xmath232 need to be defined over only one dimension and will be parametrized by the set of possible actions . in other words , we define the state space using the actions @xmath234 $ ] and the feedback message @xmath6 $ ] .",
    "the closed form expression are given in where @xmath235 if @xmath236 is true , and @xmath237 otherwise , @xmath238 is the of @xmath69 and @xmath239 is the probability of not decoding the superposed -next packet given that the packet was also not decoded : @xmath240        when @xmath242 , the belief states @xmath232 are defined over two dimensions and can not be derived in closed form .    when the belief states are defined over one dimension , an approximation method was proposed in @xcite , which projects the beliefs on the parametrized set of functions .",
    "for example , beta@xmath243 function was used in @xcite to parametrize the @xmath244 ( @xcite considered one - packet ) . in our case , the observations @xmath245 and @xmath246 are dependant and we would need a projection of the joint of these two variables on the space of two - dimensional functions .",
    "this approach is thus tedious and to overcome this difficulty , we assume that if a retransmission is needed , the controller will always adopt the unique - action policy : @xmath247 formally , the objective is to solve : @xmath248 and an exhaustive research over the one - dimensional space of allowed actions @xmath110 is sufficient to determine the suboptimal action .",
    "[ ct][ct][1.2]@xmath40  [ db ] [ ct][ct][1.2]@xmath154 [ cl][cl][1.2]@xmath249 [ cl][cl][1.2]ts [ cl][cl][1.2]@xmath250 [ cl][cl][1.2]@xmath251 [ cl][cl][1.2]@xmath186 [ cl][cl][1.2]@xmath187 [ cl][cl][1.2]@xmath176 [ cl][cl][1.2]@xmath249 [ cl][cl][1.2]sc [ cl][cl][1.2]@xmath250 [ cl][cl][1.2]@xmath251     + ( a ) +   + ( b )    fig .",
    "[ fig : all ] compare the performance of the proposed multi - packet protocols .",
    "when the whole history @xmath225 is used , the results are denoted by @xmath249 ( for @xmath186 ) , while @xmath250 presents the simplified policy in .",
    "we observe that    * for  ts , the simplified unique - action protocol defined in yields practically the same throughput as the one based on the complete parametrization of the state - space ( for @xmath186 ) .",
    "we thus conjecture that the same results will be obtained for @xmath252 . * as expected , using one - bit feedback introduces the penalty with respect to multi - bit feedback but still , using , the gains over the conventional are notable , varying from @xmath253  db ( for @xmath186 ) to @xmath254  db ( for @xmath176 ) . * for  sc",
    ", the simplified unique - action protocol yields the same results as the one - packet transmission for @xmath172 ; this is not entirely surprising as we already observed that the is very sensitive to the discretization of the parameter space @xmath255 in fig .",
    "[ fig : dis ] ( b ) . for @xmath176",
    ", we obtain an appreciable gain of @xmath173  db .",
    "* when the complete parametrization of the state - space is used ( for @xmath186 ) , the gains of  sc  over the conventional are around @xmath256 db .",
    "in this work we proposed and analyzed the so - called multi - packet , where various packets are simultaneously transmitted within the same block .",
    "we consider adjusting the joint encoding modes depending on the state of the receiver in the past transmissions and , formulating the problem as partial or full state information markov decision process , we optimize the encoding modes and parameters of the .",
    "our results indicate that the joint encoding yields gains of various db over the conventional even in the simple case of one - bit feedback and truncated to @xmath172 transmission .",
    "these gains can be increased by @xmath257  db by adding a few ( @xmath258 ) additional feedback bits .",
    "we also observed that the gains of the with respect to the are relatively small in the case of full observable state ; one - bit feedback , however , it removes the advantage of the .",
    "thus , in the point - to - point , the , being simpler to implement , should be preferred over .",
    "we aim at determining the expression of @xmath119 when @xmath172 . in this case , the set of possible values of @xmath259 is @xmath260 .",
    "one possible illustration of the state space @xmath97 is given in fig .",
    "[ fig : markov - chain ] . for each possible value of @xmath95",
    ", the vertical line presents the possible values of @xmath261 while the horizontal line presents @xmath262 .",
    "when only the packet is transmitted , i.e. ,  @xmath263 , the horizontal line is irrelevant . for convenience",
    "we refer to the discretization interval corresponding to a state @xmath86 as @xmath264 .",
    "the state @xmath265 in the figure corresponds to parameter @xmath198 and @xmath266 .",
    "the transition from the state @xmath86 at time @xmath10 to the state @xmath267 at time @xmath24 depends on the action @xmath5=({{\\mathsf{m}}}[n],p[n])$ ] and the .",
    "for example three situations can occur regarding the value of @xmath54 $ ] .",
    "namely :    * if @xmath54={{\\textnormal{1p}}}$ ] the system moves to @xmath268 .",
    "this transition , represented by a solid arrow , has the probability @xmath269 . * if @xmath54={{\\textnormal{0p}}}$ ] the controller increments the according to and the system moves to @xmath270 , which is presented by the doted arrow . in this case ,",
    "* if @xmath54={{{\\textnormal{ts}}}}$ ] the multi packet scenario is adopted and the counters are updated to @xmath272 .",
    "this situation is depicted by the dashed arrow and @xmath273 .",
    "( 0,-4.8001366)(10.061289,4.8001366 ) ( 6.2452345,1.0968555)(6.2652345,4.1968555 ) ( 6.2452345,1.0968555)(9.325234,1.0768554 ) ( 6.2652345,3.1368554 ) ( 8.305234,1.0768554 ) ( 5.8637986,3.2418554)@xmath167 ( 8.443799,0.7618555)@xmath167 ( 6.4532814,4.32)@xmath274 ( 9.7987795,1.2018554)@xmath275 ( 6.0423145,0.98185545)@xmath237 ( 1.8452344,1.0768554)(1.8652344,4.1768556 ) ( 1.8652344,3.1168554 ) ( 1.4637989,3.2218554)@xmath167 ( 2.0543358,4.32)@xmath200 ( 1.6423144,0.9618555)@xmath237 ( 6.2852345,-4.0031447)(6.3052344,-0.90314454 ) ( 6.3052344,-1.9631445 ) ( 5.903799,-1.8581445)@xmath167 ( 6.494336,-0.77)@xmath274 ( 6.0823145,-4.1181445)@xmath237 ( 0.8,0.5218555)@xmath276 ( 6.4504104,0.5218555)@xmath277 ( 6.4504104,-4.35)@xmath278 ( 1.8652344,2.1768556 ) ( 7.3252344,2.4768555 ) ( 1.8652344,1.4568554 ) ( 6.3052344,-2.6631446 ) ( 1.9252343,1.3768555)(1.9252343,0.5768555)(2.9552295,-1.3251064)(3.7252343,-1.9631445)(4.4952393,-2.6011827)(5.734739,-3.623025)(6.2452345,-2.7631445 ) ( 1.9252343,1.3968555)(1.9252343,0.59685546)(7.3052344,1.5568554)(7.3052344,2.3568554 ) ( 0.22477505,3.8172667)(2.0248003,1.7960232)0.399366680.0183.60481 ( 7.581504,2.8218555)@xmath267 ( 6.650205,-2.4181445)@xmath267 ( 1.4944726,2.3618555)@xmath267 ( 1.4944726,1.5418555)@xmath86        e.  uhlemann , l.  k. rasmussen , a.  grant , and p .- a .",
    "wiberg , `` optimal incremental - redundancy strategy for type - ii hybrid arq , '' in _ proc .",
    "ieee international symposium on information theory _ , 2003 ,",
    "p. 448 .",
    "l.  szczecinski , s.  r. khosravirad , p.  duhamel , and m.  rahman , `` rate allocation and adaptation for incremental redundancy truncated harq , '' _ ieee trans .",
    "_ , vol .",
    "61 , no .  6 , pp .",
    "25802590 , june 2013 .",
    "s.  m. kim , w.  choi , t.  w. ban , and d.  k. sung , `` optimal rate adaptation for hybrid arq in time - correlated rayleigh fading channels , '' _ ieee trans .",
    "wireless commun .",
    "_ , vol .  10 , no .  3 , pp . 968 979 , mar . 2011 .",
    "x.  wang , q.  liu , and g.  giannakis , `` analyzing and optimizing adaptive modulation coding jointly with arq for qos - guaranteed traffic , '' _ ieee trans . veh . technol . _ , vol .",
    "56 , no .  2 ,",
    "710720 , mar .",
    "2007 .",
    "r.  zhang and l.  hanzo , `` superposition - coding - aided multiplexed hybrid arq scheme for improved end - to - end transmission efficiency , '' _ ieee trans .",
    "_ , vol .",
    "58 , no .  8 , pp .",
    "4681 4686 , oct . 2009",
    ".      t.  v.  k. chaitanya and e.  g. larsson , `` superposition modulation based symmetric relaying with hybrid arq : analysis and optimization , '' _ ieee trans .",
    "_ , vol .  60 , no .  8 ,",
    "36673683 , oct .",
    "2011 .",
    "a.  karmokar , d.  djonin , and v.  bhargava , `` delay - aware power adaptation for incremental redundancy hybrid arq over fading channels with memory , '' _ ieee international conference on communications , icc06 _ , vol .  9 , pp .",
    "43154320 , jun 2006 .",
    "d.  djonin , a.  karmokar , and v.  bhargava , `` joint rate and power adaptation for type - i hybrid arq systems over correlated fading channels under different buffer - cost constraints , '' _ ieee trans . veh .",
    "technol . _ , vol .",
    "57 , no .  1 ,",
    "421 435 , jan .",
    "2008 .",
    "m.  jabi , l.  szczecinski , m.  benjillali , and f.  labeau , `` outage - optimal power adaptation and allocation for truncated harq , '' _ ieee international conference on communications , icc14 _ , pp . 18901896 , june 2014 .",
    "a.  arapostathis , v.  s. borkar , e.  fernandez - gaucherand , m.  k. ghosh , and s.  i. marcus , `` discrete - time controlled markov processes with average cost criterion : a survey , ''",
    "_ siam j. control optim .",
    "31 ( 2 ) , pp .",
    "282344 , 1993 ."
  ],
  "abstract_text": [
    "<S> in this work we consider , where transmission rounds are carried out over independent block - fading channels . </S>",
    "<S> we propose the so - called multi - packet harq where the transmitter allows different packets to share the same channel block . in this way </S>",
    "<S> the resources ( block ) are optimally assigned throughout the transmission rounds . </S>",
    "<S> this stands in contrast with the conventional harq , where each transmission round occupies the entire block . </S>",
    "<S> we analyze superposition coding and time - sharing transmission strategies and we optimize the parameters to maximize the throughput . besides the conventional one - bit feedback ( ack / nack ) we also consider the rich , multi - bit feedback . to solve the optimization problem </S>",
    "<S> we formulate it as a markov decision process ( mdp ) problem where the decisions are taken using accumulated mutual information ( ami ) obtained from the receiver via delayed feedback . when only one - bit feedback is used to inform the transmitter about the decoding success / failure ( ack / nack ) , the partial state information markov decision process ( psi - mdp ) framework is used to obtain the optimal policies . </S>",
    "<S> numerical examples obtained in a rayleigh - fading channel indicate that , the proposed multi - packet harq outperforms the conventional one , by more than 5 db for high spectral efficiencies .    </S>",
    "<S> block fading channels , hybrid automatic repeat request , partial state information , markov decision process , superposition coding , time sharing . </S>"
  ]
}