{
  "article_text": [
    "by birk and kol in @xcite , index coding is the problem of transmitting a set of messages to a number of receivers via a public communication .",
    "each receiver may also have some side information consisting of messages desired by some of the other receivers .",
    "this problem has been the subject of several recent studies ( e.g. see @xcite-@xcite ) in the most general form of the problem , each message can be desired by more than one destination .",
    "however the special case of each message being desired by exactly one receiver admits a graph theoretic representation in terms of directed graphs and thus has received particular attention .",
    "more specifically , if there are @xmath0 receivers , we can construct a graph with @xmath0 vertices .",
    "we draw a directed edge from vertex @xmath1 to vertex @xmath2 if and only if receiver @xmath1 knows the desired message by receiver @xmath2 . for the most part of this paper we work with this graph model for the index coding problem .",
    "observe that in the most general case , one has to work with hypergraphs to represent the side information .",
    "it is common to study the index coding problem in terms of an achievable rate region based on the size of the @xmath0 messages to be decoded by the @xmath0 receivers ( see section [ sec : definitions ] for a formal definition ) . here",
    "the rate of a receiver refers to the normalized amount of information transmitted to it .",
    "the set of all achievable rates , i.e. the capacity region , for index coding problem remains an open problem .",
    "nonetheless , the problem has been solved in some special cases , notably for the equal - rate case under certain graph structures @xcite . in @xcite , the capacity region of an index coding problem",
    "is related to some graph theoretical features such as local chromatic number .",
    "a difference between the performance of linear and non - linear codes is characterized in @xcite .",
    "the index coding problem has significant connections with network coding and wireless communications .",
    "it is clear that every instance of index coding can be represented as an instance of a network coding in which a single node desires to send messages via a unit capacity channel and some channels with infinite capacity representing side information . in @xcite",
    "it is shown that for both linear and non - linear case , for any instance of networking coding problem , there exists an instance of index coding problem with the same capacity region .",
    "in addition , in @xcite a reduction from an instance of network coding problem to an instance of index coding problem is introduced .",
    "they used this reduction to show that the capacity regions for linear and one - shot cases are not equal to capacity region of asymptotic non - linear case .    in @xcite ,",
    "the topological interference management problem is introduced for both wired and wireless networks .",
    "in the wireless set up , this problem refers to the analysis of degrees of freedom of an interference network with the assumption that all weak interferences are zero .",
    "this natural problem in the wireless networks has a significant relation to the index coding problem .",
    "for example , in @xcite it is proved that the set of degrees of freedom which are available through linear schemes in the topological interference management problem is equal to the linear capacity region of an equivalent index coding problem . moreover ,",
    "the non - linear degree of freedom region of the interference management problem is related to the non - linear capacity region of the problem .",
    "given a fixed set of rates , let @xmath3 denote the set of all graphs that support the rates .",
    "we are interested in minimal members of @xmath3 ( with respect to containment of the edge set ) .",
    "more specifically , a graph is said to be _ critical _ ( or _ edge critical _ ) if ( 1 ) it belongs to @xmath3 and ( 2 ) deletion of any edge from the graph makes it to fall outside @xmath3 .",
    "it is useful to study critical graphs since it identifies the minimum - cost architectures of the networks supporting a given set of rates .",
    "to best of our knowledge , critical graphs for index coding have not been studied before .",
    "we present several results in this paper regarding critical graphs . when the rates are all equal , we identify the critical graph with minimum number of edges ( theorem [ thm1 ] ) .",
    "next we study the general case of arbitrary rates via an additivity result that we prove about index coding ( theorem [ thm3new ] ; here we basically prove that a simple time division strategy is optimal ) .",
    "we use this result to show that critical graphs for one - shot and asymptotic linear index coding as well as those of non - linear asymptotic index coding are structured , by proving that they have to be a union of disjoint strongly connected subgraphs ( uscs ) ( theorem [ thm2 ] ) .",
    "equivalently , each directed edge in the graph has to be on a cycle in the graph . on the other hand , for non - linear one - shot index coding",
    ", we construct a counterexample by finding a critical graph that is not uscs .",
    "in addition , using theorem [ thm3new ] , we prove criticality of the union of two critical graphs ( theorem [ thm3 ] ) .",
    "moreover , we show this result holds for symmetric criticality in both one - shot and asymptotic linear case , as well as in asymptotic non - linear case ( theorem [ thm3 ] ) . in the next step ,",
    "we provide a comprehensive list of symmetric critical graphs for graphs with at most five nodes , and use this list identify two general classes of critical graphs which explain many of the critical graphs that we had observed ( theorem [ thm5 ] ) . finally , we have generalized some of our results to the groupcast index coding setting ( theorem [ thm6 ] ) .",
    "a potential application of index coding problem is in the study of wireless broadcast networks .",
    "for example , in @xcite side information of nodes in a broadcast wireless network has been employed to make the communication more efficient . in such schemes ,",
    "study of critical graphs can be helpful as it identifies the side information that can not make the communication more efficient .",
    "for instance , as our results shows , those side information whose corresponding edge in the side information graph do not lie on any cycle , will not improve the efficiency of communication .",
    "hence , these side information can be eliminated .",
    "accordingly , the total storage resources of wireless nodes can be decreased using our results .",
    "additionally , even though we are mostly interested in critical graphs in this work , our results address the `` index coding problem '' itself .",
    "for instance , our result on the additivity of the capacity region of index coding problem ( theorem [ thm3new ] ) finds the index coding capacity of a graph in terms of those of its subgraphs , if the graph has a certain structure .",
    "further we believe that by studying the characteristics of critical graphs , one can use the capacitiy region of some critical subgraphs of the graph @xmath4 to find a lower bound for the index coding problem introduced by graph @xmath4 .",
    "this paper is organized as follows : in section [ sec : definitions ] , we introduce the basic notation and definitions used in this paper . the results are provided in section [ section : statementofresults ] . in subsection",
    "[ subsec : structures ] , some results that suggest structures for critical graphs are given .",
    "in addition , in subsection [ subsec : groupcast ] , an expansion of the former results for groupcast index coding is presented .",
    "appendix [ appendixa ] contains a few lemmas used in the proofs , appendix [ appendixb ] contains the source file for a c program needed to do an exhaustive search to complete the proof of one of the theorems , and appendix [ appendixc ] contains a list of all symmetric rate critical graphs on 5 vertices .",
    "a ( unicast ) index coding problem comprises of @xmath0 nodes , @xmath5 , and a set of @xmath0 message @xmath6 where node @xmath1 needs to decode the message @xmath7 , @xmath8 .",
    "the side information of node @xmath1 is assumed to be a subset of @xmath9 .",
    "we can illustrate this side information by a directed graph @xmath10 , where @xmath11 and node @xmath1 has an edge to node @xmath2 ( that is , @xmath12 ) if node @xmath1 knows @xmath13 .",
    "for simplicity in the rest of this paper , we use graph as a shorthand for directed graphs .",
    "undirected graphs are referred to by the term  bidirectional graph \" .",
    "a code for an index coding problem ( or an index code ) consists of    1 .",
    "@xmath0 alphabet sets @xmath14 , @xmath15 where the message intended by the @xmath1-th party , @xmath7 , belongs to @xmath14 ; 2 .",
    "an encoding function @xmath16 from @xmath17 to @xmath18 that compresses the messages @xmath19 into a symbol in @xmath18 .",
    "@xmath20 is called the public message since it will be made available to all the nodes ; 3 .",
    "a set of @xmath0 decoding functions at the nodes from @xmath21 to @xmath14 for @xmath22 .",
    "every node should be able to decode its message using the public message and its side information .",
    "the rate vector associated with the code is a vector @xmath23 where @xmath24 we will use @xmath25 to indicate the rate vector @xmath23 .",
    "probability of error associated to the code is the probability that node @xmath1 fails to correctly decode @xmath7 for some @xmath22 , where rvs @xmath7 ( @xmath22 ) are assumed to be uniform on their alphabet set and mutually independent of each other .",
    "linear codes form a subclass of codes , and are defined as follows :    a linear code for an index coding problem with finite field @xmath26 consists of    1 .   @xmath0",
    "positive integers @xmath27 indicating that @xmath28 is a sequence of length @xmath29 of symbols in @xmath26 .",
    "in other words , the alphabet set for the random variable @xmath7 is @xmath30 ; 2 .   a linear map @xmath16 from @xmath17 to @xmath31 that compresses the messages @xmath19 into a sequence of length @xmath32 of symbols in @xmath26 ; 3 .   a set of @xmath0 linear decoding functions from @xmath33 to @xmath14 for @xmath22 .",
    "the rate vector associated with the code is a vector @xmath34 where @xmath35    now , we introduce two classifications for the index coding problem .    * linear and non - linear index coding * + in linear index coding we restrict ourselves to linear codes over an arbitrary finite field @xmath26 .",
    "however in the non - linear index coding we are allowed to use an arbitrary code .",
    "* one - shot and asymptotic index coding * + in the one - shot problem , we have fixed message alphabets @xmath36 and seek the code with the smallest alphabet size for the public message that can result in a zero probability of error . on the other hand , in the asymptotic coding scheme we are only given rate vector @xmath34 .",
    "then there should exist a sequence of codes with zero error probability whose rate vectors converge to @xmath34 .    the asymptotic index coding is generally defined for a vanishing probability of error rather than an exactly zero probability of error .",
    "however it is shown in @xcite that the two definitions are equivalent.[rmk : zeroerror ]    * critical graphs and symmetric rate critical graphs * + given an index coding problem ( linear or non - linear / one - shot or asymptotic ) on a graph , we say that the graph is _ critical _ if removal of any edge from it _ strictly _ shrinks the rate region ( capacity when we are looking at asymptotics ) associated to the graph .",
    "the maximum symmetric rate supported by a graph is the supremum of @xmath37 such that @xmath38 is achievable .",
    "we say that the graph is _ symmetric rate critical _ if removal of any edge from it _ strictly _ reduces the maximum symmetric rate by the graph .",
    "every symmetric rate critical graph is critical , but the reverse is not necessarily true ( see theorem [ thm : newstr1 ] ) .    next we need the following definitions from graph theory :    * turn graph * + turn graph of order @xmath0 and @xmath39 , denoted by @xmath40 , is a bidirectional complete @xmath39-partite graph with @xmath41 parts of size @xmath42 and @xmath43 parts of size @xmath44 , where @xmath45 for @xmath46 .",
    "we denote the number of edges of @xmath40 by @xmath47 . in ( * ? ?",
    "5.2.18 ) , it is shown that @xmath48 see also lemma [ lemma : turan ] from appendix [ appendixa ] .    * strongly connected graphs * + the graph @xmath10 is strongly connected if there exists a directed path between every pair of distinct vertices .",
    "it is easy to verify that a graph is strongly connected if and only if every edge of the graphs lies on a ( directed ) cycle .",
    "the graph shown in fig . [ fig : strongly - connected - graph ] is strongly connected .",
    "however , the graph shown in fig .",
    "[ fig : not - connected - graph ] is not strongly connected since there is no directed path between nodes 4 and 2 . here",
    "the edge from node @xmath49 to node @xmath50 does not lie on a directed cycle .",
    "[ - > , > = stealth , shorten > = 1pt , auto , node distance=1.7 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1 ) 1 ; ( 2 ) [ below left of=1 ] 2 ; ( 3 ) [ below right of=1 ] 3 ; ( 4 ) [ right of=3 ] 4 ; ( 5 ) [ above of=4]5 ; ( 1 ) edge node ( 2 ) edge node ( 3 ) ( 2 ) edge node ( 3 ) ( 3 ) edge node ( 4 ) ( 4 ) edge node ( 5 ) ( 5 ) edge node ( 1 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=1.7 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1 ) 1 ; ( 2 ) [ below left of=1 ] 2 ; ( 3 ) [ below right of=1 ] 3 ; ( 4 ) [ right of=3 ] 4 ; ( 5 ) [ above of=4]5 ; ( 1 ) edge node ( 2 ) edge node ( 3 ) edge node ( 5 ) ( 2 ) edge node ( 3 ) ( 3 ) edge node ( 4 ) ( 4 ) edge node ( 5 ) ;    [ ->,>=stealth,shorten > = 1pt , auto , node distance=1.7 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1 ) 1 ; ( 2 ) [ below left of=1 ] 2 ; ( 3 ) [ below right of=1 ] 3 ; ( 4 ) [ right of=3 ] 4 ; ( 5 ) [ above of=4]5 ; ( 6 ) [ right of=4]6 ; ( 1 ) edge node ( 2 ) edge [ bend left ] node ( 3 ) ( 2 ) edge node ( 3 ) ( 3 ) edge [ bend left ] node ( 1 ) ( 4 ) edge [ bend left ] node ( 5 ) ( 5 ) edge [ bend left ] node ( 4 ) ;    * union of two disjoint graphs * + the union of @xmath10 and @xmath51 is defined as @xmath52 .    * uscs graphs * + graph @xmath4 is _ uscs _ ( union of strongly connected subgraphs ) if there exists a set of disjoint graphs @xmath53 such that ( 1 ) @xmath54 is strongly connected and ( 2 ) @xmath55 .    because the graph shown in fig .",
    "[ fig : strongly - connected - graph ] is strongly connected , it is uscs , too . however , the graph shown in fig .",
    "[ fig : not - connected - graph ] is not uscs .",
    "next consider the graph shown in fig .",
    "[ fig : uscs - graph ] .",
    "if we define @xmath56 as the induced subgraph of the set @xmath57 , @xmath58 as the induced subgraph of the set@xmath59 , and @xmath60 as the induced subgraph of the set @xmath61 , then we have @xmath62 .",
    "therefore , due to the fact that @xmath56 , @xmath58 , and @xmath60 are strongly connected , @xmath4 is uscs .",
    "* minimum number of edges for equal rates * + [ thm1 ] every @xmath0-vertex graph supporting a rate vector @xmath63 has at least : @xmath64 edges , if @xmath65 ( @xmath66 is the number of edges in the complement of @xmath67 ) .",
    "moreover , there is a unique graph , up to isomorphism , that has exactly @xmath66 edges and supports the rate vector @xmath63 .",
    "this theorem holds for all cases ( linear or non - linear , one - shot or asymptotic ) .",
    "this theorem shows that there is a unique ( up to isomorphism ) critical graph with minimum number of edges for both one - shot and asymptotic cases .",
    "[ rmk3 ] theorem [ thm1 ] is valid for @xmath65 . for the case",
    "@xmath68 , there is no graph that supports the rate vector @xmath63 since the rate of each node can not be greater than one .",
    "when @xmath69 , it is possible to send all messages as the public message , and as a result , there is no need to have any side information .",
    "therefore , the empty graph is sufficient in this case .",
    "* additivity of index coding capacity region*[thm3new ]    * a ) * given a graph @xmath10 , suppose that @xmath70 and @xmath71 are subgraphs of @xmath4 induced on vertex sets @xmath72 and @xmath73 .",
    "in addition , assume that @xmath72 and @xmath73 partition @xmath74 and there exist no edge like @xmath75 in @xmath76 that starts from @xmath77 and ends up in @xmath78 , i.e. no directed edge from @xmath79 to @xmath80 exists",
    ". then , elimination of all the directed edges from @xmath80 to @xmath79 will not change the rate region in the one - shot linear , and in the asymptotic non - linear index coding problems .    *",
    "b ) * [ optimality of a simple time - division strategy ] . take an index coding problem with graph @xmath81 , such that there is no edge between @xmath79 and @xmath80 .",
    "let @xmath82 , @xmath83 and @xmath84 denote the capacity regions of @xmath4 , @xmath79 and @xmath80 respectively ( the three capacities are all either in the sense of asymptotic linear , or all in the sense of asymptotic non - linear ) .",
    "then @xmath85 } \\alpha \\mathcal{c}'\\oplus ( 1-\\alpha)\\mathcal{c}''$ ] where @xmath86 is the direct sum operator .",
    "alternatively , the index coding region for @xmath4 is of the form @xmath87 for @xmath88 $ ] and vector @xmath89 is in the region of @xmath79 and @xmath90 is in the region of @xmath80 , and @xmath91 is the concatenation of the vectors @xmath92 and @xmath93 .    * critical graphs are uscs*[thm2 ]    * a ) * every critical graph for linear index coding ( one - shot or asymptotic ) and for asymptotic non - linear index coding is uscs . in particular , removing edges that do not lie on a directed cycle does not change the capacity region in these cases .    *",
    "b ) * there exists a critical graph for a one - shot non - linear index coding problem which is not uscs .    the condition given in item ( a ) of theorem [ thm2 ]",
    "are necessary but not necessarily sufficient , i.e. uscs does not necessarily imply criticality .",
    "this follows from the fact that if we add an edge to a uscs graph that supports a given set of rates , the resulting graph remains a uscs graph that still supports the given rates .",
    "however observe that the resulting graph , with one more additional edge , may indeed support higher rates .",
    "this observation may lead one to propose the following modified conjecture :    take a uscs graph that supports a given set of rates for asymptotic non - linear index coding .",
    "let @xmath94 be an edge of the graph that lies on a single directed cycle ( i.e. it is completing a cycle and its removal breaks that cycle ) . then removing the edge @xmath94 from the graph results in a graph that no longer supports the given set of rates .",
    "however the above conjecture is also false .",
    "consider the graph in fig .",
    "[ fig : a22 ] with @xmath95 .",
    "[ ->,>=stealth,shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1 ) 1 ; ( 2 ) [ below left of=1 ] 2 ; ( 3 ) [ below right of=1 ] 3 ; ( 1 ) edge node ( 2 ) edge [ bend left ] node ( 3 ) ( 2 ) edge node ( 3 ) edge [ bend left ] node ( 1 ) ( 3 ) edge node ( 1 ) ;    using lemma [ lemma : rates - sum ] of the appendix [ appendixa ] , the sum of the rate of every subset of nodes which contains no cycle should be less or equal to one . therefore ,",
    "for every rate vector @xmath96 supported by this graph , we have : @xmath97 the edge from node @xmath98 to node @xmath99 lies on a unique cycle @xmath100 .",
    "we show that if this edge is removed , all rate vectors satisfying eqs . and will be still supported .",
    "it suffices to prove that any @xmath96 satisfying @xmath101 and @xmath102 is supported by the new graph .",
    "if we assume that @xmath7 is a binary string of length @xmath29 where @xmath103 , we can create @xmath104 as follows : we concatenate @xmath105 and @xmath106 to create a binary string of length @xmath107 and then xor it with the binary string of @xmath108 .",
    "node @xmath109 knows both @xmath105 and @xmath106 and hence can recover @xmath108 . and both nodes @xmath98 and @xmath99 know @xmath108 .",
    "hence they can both recover their desired message .",
    "there has been some previous work on the effect of edge removal in network coding @xcite-@xcite .",
    "however to best of our knowledge there is no previous work on edge removal in the context of index coding .      in this section",
    "we provide some results on the structure of critical graphs .",
    "the first class of critical graphs that are easy to identify are bidirectional graphs :    [ thm : newstr1 ] any bidirectional graph is critical ( by a bidirectional graph we mean one in which a directed edge from node @xmath1 to @xmath2 implies a directed edge from node @xmath2 to @xmath1 ) . on the other hand",
    "this is not true of symmetric criticality ; in particular a bidirectional cycle of size 4 is not symmetric critical .    to derive the main results for this section , we first produced all symmetric rate critical graphs for graphs on 5 vertices .",
    "this list was compiled using the data available on young - han kim s personal website @xcite , and is given in appendix [ appendixc ] .",
    "we then tried to formulate a few theorems that would explain the structure of critical graphs that we observed .",
    "* union of two critical graphs is critical * + [ thm3 ] if @xmath4 and @xmath110 are two critical graphs , then @xmath111 is also a critical graph for any of linear / non - linear , one - shot / asymptotic formulations .",
    "further , if @xmath4 and @xmath110 are two symmetric rate critical graphs , then @xmath111 is also a symmetric rate critical in one - shot linear , asymptotic linear , and asymptotic non - linear index coding scenarios .",
    "* two structures that are critical * + [ thm5 ] * a ) * suppose @xmath10 is a directed cycle of length @xmath32 , where @xmath112 @xmath113 now , construct a new graph @xmath114 so that @xmath115 and @xmath116 . then , if @xmath117 and @xmath118 , @xmath79 is symmetric rate critical .    *",
    "b ) * suppose @xmath119 is a graph that satisfies the condition of part ( a ) .",
    "we construct a new graph @xmath120 by replacing any vertex @xmath77 by a complete graph ( different vertices can be replaced by complete graphs of different sizes ) .",
    "then , @xmath80 is critical .",
    "more specifically , we replace vertex @xmath121 with @xmath122 vertices @xmath123 that are mutually connected to each other .",
    "we also draw a directed edge from @xmath124 to @xmath125 in @xmath80 for @xmath126 $ ] and @xmath127 $ ] if there exists a directed edge from @xmath121 to @xmath128 in @xmath79 .",
    "[ rmk5a ] the criticallity of graphs fig.[fig:893 ] , fig.[fig:771 ] , fig.[fig:2312 ] , fig.[fig:2120 ] , fig.[fig:2404 ] , fig.[fig:8625 ] , fig.[fig:8495 ] , fig.[fig:8285 ] , fig.[fig:7026 ] , and fig.[fig:8847 ] can be shown by theorem [ thm5 ] .",
    "the index coding problem that we considered so far is called unicast index coding problem .",
    "a generalization of the unicast index coding is the groupcast index coding . in groupcast index coding",
    ", the desired messages of receivers are not necessarily disjoint , i.e. a group of receivers can desire the same message .",
    "* groupcast index coding * + assuming a set of @xmath0 messages @xmath129 , a groupcast index coding problem can be modeled with a directed hypergraph on @xmath0 vertices with node @xmath1 representing @xmath7 .",
    "each receiver can be represented as a directed hyperedge starting from its desired message and ending at its side information .",
    "in other words , if receiver @xmath1 wants to know @xmath130 while having @xmath131 like @xmath132 as its side information , we add a directed hyperedge from @xmath133 to @xmath132 . the number of receivers will be equal to the number of hyperedges .",
    "a hypergraph is said to be critical if eliminating any member of the side information set of any receiver strictly reduces the set of rates supported by the hypergraph .    * underlying digraph of a directed hypergraph * + let @xmath134 be a directed hypergraph .",
    "then we call @xmath135 the underlying digraph ( directed graph ) of @xmath110 , where : @xmath136    since groupcast index coding problem is a generalization of the unicast index coding problem , we can define the side information hypergraph for the unicast index coding problem too .",
    "it can be easily verified that the underlying digraph of this hypergraph is equal to the directed graph we used to model unicast index coding problem .",
    "[ rmk : gic - hypergraph ]    * groupcast critical graphs are uscs too * [ thm6 ]    * a ) * the underlying graph of every critical hypergraph for linear groupcast index coding ( one - shot or asymptotic ) , and for asymptotic non - linear groupcast is uscs .",
    "* b ) * there exists a critical hypergraph for a one - shot non - linear groupcast index coding problem which is not uscs .",
    "consider the index coding for a random graph where directed edges exists between any two nodes with probability @xmath137 and independent of other edges .",
    "computing index coding for this class of random graphs can be of interest .",
    "theorem [ thm2 ] can be used to find a lower bound on the expected number of edges that we can remove from this graph such that it does not affect the capacity region .",
    "a lower bound is the expected value of number of edges that do not lie on a directed cycle , which is equal to @xmath138 times the probability that a directed edge from node @xmath109 to node @xmath98 exists which does not lie on a directed cycle .",
    "the expected value will be equal to @xmath139 where @xmath140 is the probability that there is a directed path from node @xmath109 to node @xmath98 ; we have multiplied @xmath137 with @xmath141 as they correspond to independent events .",
    "computing @xmath140 , pair connectedness in directed random graphs , is a studied topic in percolation theory @xcite but we were not able to find a closed form formula for it .",
    "we begin by proving the given lower bound on the minimum number of edges .",
    "it suffices to prove it for the non - linear asymptotic case since it implies that for all other cases .",
    "suppose that a given graph @xmath10 supports the rate vector @xmath63 for non - linear asymptotic case .",
    "we aim to construct two new graphs and with the help of lemma [ lemma : rates - sum ] and [ lemma : turan ] find some bounds on the number of edges in these two graphs .",
    "then we use these bounds to find a bound on the number of edges in @xmath4 . using lemma [ lemma : rates - sum ] ,",
    "every subset of @xmath142 whose size is bigger than @xmath143 , has a directed cycle , because the sum of the rates of the vertices in this subset is greater than or equal to @xmath144 .",
    "then , we consider an arbitrary order for the vertices of @xmath4 such as @xmath145 and construct two new graphs ( called  forward \" and  backward \" graphs ) as follows : @xmath146 and @xmath147 where @xmath148 , and @xmath149 is a partition of @xmath76 into two sets as follows : @xmath150 contains those edges of @xmath4 whose direction agrees with the mentioned order , that is , @xmath151 .",
    "@xmath152 contains the following edges : @xmath153 .",
    "now , because every cycle in @xmath4 should contain at least one edge from both @xmath150 and @xmath152 , every subset of size more than @xmath143 has at least one edge in both @xmath150 and @xmath152 .",
    "now let us construct a bidirectional graph @xmath154 on the same set of vertices as follows : @xmath155 is connected to @xmath156 in @xmath154 for @xmath157 if an only if @xmath158 .",
    "observe that @xmath154 is like the complement of @xmath150 if we ignore the edge arrows of @xmath150 .",
    "similarly , @xmath159 is constructed as the complement of @xmath152 if we ignore the direction of arrows in it . since every subset of size",
    "more than @xmath143 has at least one edge in both @xmath150 and @xmath152 , we can conclude that @xmath154 and @xmath159 do not have a clique of size @xmath160 . using lemma [ lemma : turan ] ,",
    "the number of edges of both @xmath150 and @xmath152 is at least @xmath161 hence , @xmath4 itself has at least @xmath66 edges .",
    "+ next , we will show that the complement of @xmath162 supports the rate @xmath25 .",
    "it suffices to show this for one - shot linear coding and it implies that for all cases there exists a graph which supports the rate @xmath25 . let @xmath163 for some @xmath164 .",
    "then we construct @xmath4 so that it consists of @xmath41 cliques of size @xmath165 , and @xmath166 cliques of size @xmath44 .",
    "then one can verify that @xmath4 has @xmath167 edges .",
    "in addition , if every node desires only one bit and we transmit the xor of the bits in every clique , every vertex can decode its message , and the rate of every message equals to @xmath168 .",
    "furthermore , it is obvious that this is a one - shot linear coding .",
    "thus we have shown that there exists a graph which supports the rate @xmath25 .",
    "+ lastly , to show that no other graph with exactly @xmath66 edges supports @xmath25 , consider a graph @xmath4 that has @xmath66 edges and supports the rate vector @xmath63 in non - linear asymptotic case ( it suffices to show this for the non - linear asymptotic case and it will imply other cases )",
    ". if we construct @xmath150 and @xmath152 as discussed before , each of them should have exactly @xmath169 edges and they should have the structure mentioned in lemma [ lemma : turan ] .",
    "so , the only remaining step is to show that the cliques in @xmath150 and @xmath152 coincide on each other .",
    "suppose this does not hold , that is , there are two vertices where there is an edge between them in @xmath150 , but not in @xmath152 .",
    "let us call these two vertices @xmath121 and @xmath128 .",
    "choose one vertex from each of the @xmath170 components of @xmath150 such that @xmath121 is chosen and let us denote this set by @xmath171 .",
    "then we claim that @xmath172 does not contain any cycle in @xmath4 .",
    "note that if a cycle exists , it should include the edge between @xmath121 and @xmath128 , because it is the only edge in @xmath172 in @xmath150 and the cycle should have at least one edge from @xmath150 .",
    "now the other edges in the cycle form a path from @xmath128 to @xmath121 in @xmath152 . as",
    "every component of @xmath152 is a clique then @xmath121 and @xmath128 should have an edge , which contradicts our assumption that @xmath121 and @xmath128 are disconnected in @xmath152 .        consider an arbitrary code on the original graph with zero probability of error",
    "let @xmath173 be the public message .",
    "the rate of this code is @xmath174 where @xmath175    the union of @xmath70 and @xmath71 corresponds to the graph @xmath4 after elimination of directed edges from @xmath80 to @xmath79 .",
    "take an arbitrary @xmath176 .",
    "we create a code for the union of @xmath70 and @xmath71 that achieves the rate vector @xmath177 where @xmath178 , with the probability of error being less than @xmath179 .",
    "this concludes the proof ( see remark [ rmk : zeroerror ] on index coding with a vanishing probability of error ) .",
    "we can conceive @xmath32 i.i.d .",
    "repetitions of the given code with @xmath180 and public message @xmath181 .",
    "the rate of the i.i.d .",
    "code is the same as the original one since @xmath182 since the original code had zero error probability , the i.i.d .",
    "code has also a zero probability of error .",
    "we define @xmath183 as a shorthand for @xmath184 , and @xmath185 as a shorthand for @xmath186 .",
    "we define a new code that uses @xmath187 instead of @xmath181 where @xmath188 is used by nodes in @xmath70 and @xmath189 is used by nodes in @xmath71 :    * size of the alphabet of @xmath188 , i.e. @xmath190 , is less than or equal to @xmath191 .",
    "furthermore , the nodes in @xmath70 can use @xmath188 and their side information ( which is inside @xmath70 ) to recover their message with probability @xmath192 .",
    "* size of the alphabet of @xmath189 , i.e. @xmath193 , is less than or equal to @xmath194 .",
    "furthermore , the nodes in @xmath71 can use @xmath189 and part of their side information of messages inside @xmath71 to recover their message with probability @xmath192 .",
    "this would finish the proof since @xmath195 is equal to @xmath196 and by choosing @xmath197 small enough we can ensure that the rate of the new code is within @xmath179 of the original code .    _ construction of @xmath189 : _",
    "we have @xmath198 .",
    "thus , it suffices to construct @xmath189 whose alphabet size is less than or equal to @xmath199 where @xmath200 is the one that minimizes @xmath201 .",
    "let us first assume in the original problem that @xmath202 has occurred and the nodes in @xmath203 are all aware of this ( thus , if some of the nodes in @xmath71 had partial information about messages of nodes in @xmath70 , we are giving all of them a full access to @xmath183 and this should only help them in decoding their message ) .",
    "thus the nodes in @xmath71 should be able to recover their intended messages using @xmath204 and their side information inside @xmath71 with probability one , when @xmath202 is fixed .",
    "we can use the conditional joint pmf @xmath205 as a joint pmf on @xmath206 on @xmath207 and think of it as an index code on nodes in @xmath71 ( since @xmath208 is independent of @xmath183 , the marginal distribution of @xmath209 is uniform and coordinatewise mutually independent ) .",
    "the public message in the index coding problem on @xmath71 would be produced according to @xmath210 and it leads to zero error probability .    if we have @xmath32 i.i.d .",
    "copies of the pmf @xmath140 ( still a code with zero error probability ) , the corresponding public message can be compressed using shannon s source coding theorem and sent to the parties , where nodes in @xmath71 can first decompress it and then use it to run their decoding algorithm .",
    "compression can be achieved at a rate of @xmath211 bits at the cost of a probability of error of @xmath179 , which is tolerated .",
    "note that the public message @xmath189 is only meant for the use of subgraph @xmath71 ; to construct the code for @xmath71 we have pretended that @xmath202 has happened in each copy of @xmath70 .",
    "it is clear that @xmath189 contains no useful information about @xmath212 that has actually occurred , and nodes in @xmath70 can ignore @xmath189 .    _",
    "construction of @xmath188 : _",
    "let @xmath213 denote the joint distribution of @xmath204 and @xmath183 in the original code .",
    "the decoding function used by node @xmath214 can be expressed as the conditional pmf @xmath215 where @xmath216 is the reconstruction of node @xmath1 .",
    "of course @xmath217 since perfect reconstruction is assumed .",
    "therefore the joint pmf @xmath218 has the property that the marginal distribution on @xmath183 and @xmath219 is equal to @xmath220.\\label{eqn : amsm1}\\end{aligned}\\ ] ]    we use the covering lemma ( rate - distortion coding ) to create a code for nodes in @xmath70 .",
    "let @xmath221 be an arbitrary small positive real .",
    "_ codebook generation : _ assume that the transmitter and the receivers initially share a codebook of @xmath191 sequences @xmath222 each being an i.i.d .",
    "sequence according to @xmath223 .",
    "_ encoding : _ having @xmath212 at the transmitter , it finds an index @xmath2 such that @xmath224 is jointly typical with @xmath212 ( i.e. @xmath225 ) , where we use the notion of typicality given in @xcite . since the number of generated @xmath226 sequences is larger than @xmath191 by the covering lemma ( * ? ? ?",
    "* lemma 3.3 ) , this can be done with high probability .",
    "the transmitter then sends the index @xmath2 as @xmath188 to the receiver ( the cardinality of the alphabet of @xmath188 allows it to send the index @xmath2 ) .    _",
    "decoding : _ having received @xmath227 , nodes @xmath214 create @xmath228 as a function of @xmath224 and their side information ( they use the same decoding functions of the original code ) . more precisely , if we denote the joint pmf of @xmath224 and @xmath212 by @xmath229 , the joint pmf of the constructed rv s is equal to @xmath230 if @xmath225 , with high probability we will have @xmath231 for any @xmath232 , as we have passed @xmath233 through the i.i.d .",
    "conditional pmf of @xmath234 ( conditoinal typicality lemma @xcite )",
    ". therefore @xmath235 will be joint typical with high probability .",
    "thus for any @xmath214 , with high probability @xmath236 will be jointly typical .",
    "we claim that two sequences @xmath236 jointly typicality in the sense of @xcite is equivalent with their equality .",
    "equation implies that @xmath237 if and only if @xmath238 , and hence for any pair @xmath239 where @xmath240 we have ( using notation of @xcite ) that@xmath241 hence @xmath242 for any @xmath240 , implying that @xmath243 .",
    "therefore with high probability the decoders will successfully decode their intended messages .",
    "it should be noted that the above proof does not work for asymptotic linear index coding because @xmath188 will not necessarily be linear if @xmath204 is a linear index code .",
    "assume that there exists a valid one - shot linear coding scheme for a graph @xmath4 with @xmath244 vertices such that : @xmath245 where @xmath246 for some field @xmath26 .",
    "additionally , assume that : @xmath247 where @xmath248 is equal to @xmath249 for some coefficients @xmath250 in the field @xmath26 .",
    "in other words , the following matrix is used for the linear map : @xmath251.\\ ] ]    without loss of generality we can assume that @xmath252 is in the row echelon form , since elementary row operation on @xmath252 is equivalent to using _",
    "invertible _ linear combinations of @xmath253 instead of these variables .",
    "the row echelon form can be represented by a sequence of indices @xmath254 that are increasing in a lexicographical order , i.e. either @xmath255 holds or both @xmath256 and @xmath257 hold .",
    "further we must have @xmath258 if @xmath259 is less than @xmath260 in the lexical order .",
    "since all nodes are able to decode their messages via @xmath261 and their side information , there should exist coefficients @xmath262 for each message @xmath263 ( @xmath264 ) so that : @xmath265 is equal to @xmath263 plus a linear combination of @xmath266 that are available to node @xmath1 as side information , i.e. @xmath267 for some coefficients @xmath268 .",
    "now , we turn to the proof of the lemma . without loss of generality ,",
    "suppose that the vertices of @xmath70 are @xmath269 .",
    "note that this assumption and the assumption that @xmath252 is in the row echelon form do not contradict the generality together .",
    "one can simply label the vertices of @xmath4 such that nodes in @xmath70 be labeled with @xmath269 and then applies some elementary row operations to find @xmath252 in row echelon form .",
    "the statement of the theorem basically asks us to show that there is no need for nodes in @xmath71 to know ( as side information ) any of the messages for nodes in @xmath70 , i.e. @xmath184 . to show this",
    ", we first define a new encoding linear map @xmath270 and then prove that it enables nodes in @xmath71 to recover their intended messages without any need to have access to @xmath184 .",
    "nodes in @xmath70 are also shown to be still able to decode their messages with the encoding function @xmath270 using their side information ( nodes in @xmath70 do not know any of the messages of nodes in @xmath71 since @xmath70 does not have any outgoing edge ) .",
    "thus , the edges between @xmath70 and @xmath71 can be removed .",
    "_ part 1 : definition of a new linear encoding function @xmath270 : _ let @xmath271 fig .",
    "[ fig : echelon ] clarifies the definition of the @xmath272 .",
    "( 0,0 ) rectangle ( 8 , 4 ) ; ( 0.0,3.5 ) rectangle ( 8 , 4.0 ) ; ( 1.0,3.0 ) rectangle ( 8 , 3.5 ) ; ( 1.5,2.5 ) rectangle ( 8 , 3.0 ) ; ( 3.0,2.0 ) rectangle ( 8 , 2.5 ) ; ( 4.0,1.5 ) rectangle ( 8 , 2.0 ) ; ( 5.5,1.0 ) rectangle ( 8 , 1.5 ) ; ( 6.0,0.5 ) rectangle ( 8 , 1.0 ) ; ( 7.0,0.0 ) rectangle ( 8 , 0.5 ) ;    ( 0.0,3.5 ) rectangle ( 0.5 , 4.0 ) ; ( 1.0,3.0 ) rectangle ( 1.5 , 3.5 ) ; ( 1.5,2.5 ) rectangle ( 2.0 , 3.0 ) ; ( 3.0,2.0 ) rectangle ( 3.5 , 2.5 ) ; ( 4.0,1.5 ) rectangle ( 4.5 , 2.0 ) ; ( 5.5,1.0 ) rectangle ( 6.0 , 1.5 ) ; ( 6.0,0.5 ) rectangle ( 6.5 , 1.0 ) ; ( 7.0,0.0 ) rectangle ( 7.5 , 0.5 ) ; ( 0,0 ) rectangle ( 8 , 4 ) ; ( 0.5 , 0 )  ( 0.5 , 4 ) ; ( 1.0 , 0 )  ( 1.0 , 4 ) ; ( 1.5 , 0 )  ( 1.5 , 4 ) ; ( 2.0 , 0 )  ( 2.0 , 4 ) ; ( 2.5 , 0 )  ( 2.5 , 4 ) ; ( 3.0 , 0 )  ( 3.0 , 4 ) ; ( 3.5 , 0 )  ( 3.5 , 4 ) ; ( 4.0 , 0 )  ( 4.0 , 4 ) ; ( 4.5 , 0 )  ( 4.5 , 4 ) ; ( 5.0 , 0 )  ( 5.0 , 4 ) ; ( 5.5 , 0 )  ( 5.5 , 4 ) ; ( 6.0 , 0 )  ( 6.0 , 4 ) ; ( 6.5 , 0 )  ( 6.5 , 4 ) ; ( 7.0 , 0 )  ( 7.0 , 4 ) ; ( 7.5 , 0 )  ( 7.5 , 4 ) ;    ( 0 , 0.5 )  ( 8 , 0.5 ) ; ( 0 , 1.0 )  ( 8 , 1.0 ) ; ( 0 , 1.5 )  ( 8 , 1.5 ) ; ( 0 , 2.0 )  ( 8 , 2.0 ) ; ( 0 , 2.5 )  ( 8 , 2.5 ) ; ( 0 , 3.0 )  ( 8 , 3.0 ) ; ( 0 , 3.5 )  ( 8 , 3.5 ) ;    ( 5.5 , 0 )  ( 5.5 , 4 ) ; at ( 6.75 , 4.5)@xmath70 ; at ( 2.75 , 4.5)@xmath71 ;    at ( -1.3 , 1.25)@xmath272 ; ( -1 , 1.25 )  ( -0.2 , 1.25 ) ;    note that @xmath273 can not be empty .",
    "we prove this by contradiction .",
    "suppose that the mentioned set is empty , then for each @xmath274 there exists a @xmath275 that @xmath276 . as a result , @xmath277 now assume that @xmath278 is the smallest number that @xmath279 , then : @xmath280 note that the coefficient of @xmath281 in the above statement is : @xmath282 because @xmath283 is lexicographically smaller than @xmath284 for any @xmath285 : @xmath286 then @xmath287    note that @xmath288 by eq .",
    ", so @xmath289 .",
    "hence , @xmath281 is not provided as side information to node @xmath0 , which is in @xmath70 . as a result ,",
    "the non - zero coefficient of @xmath281 in @xmath290 is in contradiction to eq . .",
    "so we have proved that @xmath291 is a non - empty set and thus @xmath272 is well - defined .",
    "( 0,0 ) rectangle ( 8 , 4 ) ; ( 0.0,3.5 ) rectangle ( 8 , 4.0 ) ; ( 1.0,3.0 ) rectangle ( 8 , 3.5 ) ; ( 1.5,2.5 ) rectangle ( 8 , 3.0 ) ; ( 3.0,2.0 ) rectangle ( 8 , 2.5 ) ; ( 4.0,1.5 ) rectangle ( 8 , 2.0 ) ; ( 5.5,1.0 ) rectangle ( 8 , 1.5 ) ; ( 6.0,0.5 ) rectangle ( 8 , 1.0 ) ; ( 7.0,0.0 ) rectangle ( 8 , 0.5 ) ;    ( 5.5,1.5 ) rectangle ( 8 , 4);a    ( 0.0,3.5 ) rectangle ( 0.5 , 4.0 ) ; ( 1.0,3.0 ) rectangle ( 1.5 , 3.5 ) ; ( 1.5,2.5 ) rectangle ( 2.0 , 3.0 ) ; ( 3.0,2.0 ) rectangle ( 3.5 , 2.5 ) ; ( 4.0,1.5 ) rectangle ( 4.5 , 2.0 ) ; ( 5.5,1.0 ) rectangle ( 6.0 , 1.5 ) ; ( 6.0,0.5 ) rectangle ( 6.5 , 1.0 ) ; ( 7.0,0.0 ) rectangle ( 7.5 , 0.5 ) ; ( 0,0 ) rectangle ( 8 , 4 ) ; ( 0.5 , 0 )  ( 0.5 , 4 ) ; ( 1.0 , 0 )  ( 1.0 , 4 ) ; ( 1.5 , 0 )  ( 1.5 , 4 ) ; ( 2.0 , 0 )  ( 2.0 , 4 ) ; ( 2.5 , 0 )  ( 2.5 , 4 ) ; ( 3.0 , 0 )  ( 3.0 , 4 ) ; ( 3.5 , 0 )  ( 3.5 , 4 ) ; ( 4.0 , 0 )  ( 4.0 , 4 ) ; ( 4.5 , 0 )  ( 4.5 , 4 ) ; ( 5.0 , 0 )  ( 5.0 , 4 ) ; ( 5.5 , 0 )  ( 5.5 , 4 ) ; ( 6.0 , 0 )  ( 6.0 , 4 ) ; ( 6.5 , 0 )  ( 6.5 , 4 ) ; ( 7.0 , 0 )  ( 7.0 , 4 ) ; ( 7.5 , 0 )  ( 7.5 , 4 ) ;    ( 0 , 0.5 )  ( 8 , 0.5 ) ; ( 0 , 1.0 )  ( 8 , 1.0 ) ; ( 0 , 1.5 )  ( 8 , 1.5 ) ; ( 0 , 2.0 )  ( 8 , 2.0 ) ; ( 0 , 2.5 )  ( 8 , 2.5 ) ; ( 0 , 3.0 )  ( 8 , 3.0 ) ; ( 0 , 3.5 )  ( 8 , 3.5 ) ;    ( 5.5 , 0 )  ( 5.5 , 4 ) ; at ( 6.75 , 4.5)@xmath70 ; at ( 2.75 , 4.5)@xmath71 ;    at ( -1.3 , 1.25)@xmath272 ; ( -1 , 1.25 )  ( -0.2 , 1.25 ) ;    further let @xmath292 and @xmath293 for all @xmath294 . set @xmath295 a schematic representation of @xmath296 is given in fig .",
    "[ fig : definition - c - prime ] . observe that eq .",
    "implies that @xmath297 for all @xmath298 .    _",
    "part 2 : showing that nodes in @xmath70 are able to decode their message by using @xmath299 and their side information : _ consider the coefficients @xmath300 for decoding of the original linear mapping given in eq . .",
    "we claim for any @xmath301 ( i.e. @xmath302 ) that @xmath303 for every @xmath304 .",
    "this completes the proof since for every @xmath301 : @xmath305 equations and illustrate that every node @xmath301 is able to obtain @xmath306 in the new coding scheme by calculating @xmath307 .",
    "we prove @xmath303 for every @xmath304 by contradiction .",
    "suppose that @xmath155 is the smallest index that @xmath308 and @xmath309 . by the definition of @xmath272 , @xmath310 ( @xmath311 ) .",
    "it is also clear that the definition of @xmath155 results in : @xmath312 for any @xmath313 . because @xmath314 is strictly increasing : @xmath315 for all @xmath316 . as @xmath317",
    "the coefficient of @xmath318 in @xmath319 is : @xmath320 which is in contradiction to the independency of @xmath321 from @xmath322 , that was guaranteed by eq . .",
    "( note that @xmath301 and @xmath311 , so @xmath322 is not provided as side information to @xmath37 ) +    ( 0,0 ) rectangle ( 8 , 4 ) ;    at ( 1.75 , 5)@xmath323 ; ( 1.75 , 4.7 )  ( 1.75 , 4.2 ) ;    at ( -1.3 , 2.75)@xmath155 ; ( -1 , 2.75 )  ( -0.2 , 2.75 ) ;    ( 0,2.5 ) rectangle ( 8 , 3.0 ) ; ( 0,2.0 ) rectangle ( 8 , 2.5 ) ; ( 0,1.0 ) rectangle ( 8 , 1.5 ) ;    ( 0.0,3.5 ) rectangle ( 8 , 4.0 ) ; ( 1.0,3.0 ) rectangle ( 8 , 3.5 ) ; ( 1.5,2.5 ) rectangle ( 8 , 3.0 ) ; ( 3.0,2.0 ) rectangle ( 8 , 2.5 ) ; ( 4.0,1.5 ) rectangle ( 8 , 2.0 ) ; ( 5.5,1.0 ) rectangle ( 8 , 1.5 ) ; ( 6.0,0.5 ) rectangle ( 8 , 1.0 ) ; ( 7.0,0.0 ) rectangle ( 8 , 0.5 ) ;    ( 0.0,3.5 ) rectangle ( 0.5 , 4.0 ) ; ( 1.0,3.0 ) rectangle ( 1.5 , 3.5 ) ; ( 1.5,2.5 ) rectangle ( 2.0 , 3.0 ) ; ( 3.0,2.0 ) rectangle ( 3.5 , 2.5 ) ; ( 4.0,1.5 ) rectangle ( 4.5 , 2.0 ) ; ( 5.5,1.0 ) rectangle ( 6.0 , 1.5 ) ; ( 6.0,0.5 ) rectangle ( 6.5 , 1.0 ) ; ( 7.0,0.0 ) rectangle ( 7.5 , 0.5 ) ;    ( 1.5,2.5 ) rectangle ( 2.0 , 3.0 ) ;    ( 0,0 ) rectangle ( 8 , 4 ) ; ( 0.5 , 0 )  ( 0.5 , 4 ) ; ( 1.0 , 0 )  ( 1.0 , 4 ) ; ( 1.5 , 0 )  ( 1.5 , 4 ) ; ( 2.0 , 0 )  ( 2.0 , 4 ) ; ( 2.5 , 0 )  ( 2.5 , 4 ) ; ( 3.0 , 0 )  ( 3.0 , 4 ) ; ( 3.5 , 0 )  ( 3.5 , 4 ) ; ( 4.0 , 0 )  ( 4.0 , 4 ) ; ( 4.5 , 0 )  ( 4.5 , 4 ) ; ( 5.0 , 0 )  ( 5.0 , 4 ) ; ( 5.5 , 0 )  ( 5.5 , 4 ) ; ( 6.0 , 0 )  ( 6.0 , 4 ) ; ( 6.5 , 0 )  ( 6.5 , 4 ) ; ( 7.0 , 0 )  ( 7.0 , 4 ) ; ( 7.5 , 0 )  ( 7.5 , 4 ) ;    ( 0 , 0.5 )  ( 8 , 0.5 ) ; ( 0 , 1.0 )  ( 8 , 1.0 ) ; ( 0 , 1.5 )  ( 8 , 1.5 ) ; ( 0 , 2.0 )  ( 8 , 2.0 ) ; ( 0 , 2.5 )  ( 8 , 2.5 ) ; ( 0 , 3.0 )  ( 8 , 3.0 ) ; ( 0 , 3.5 )  ( 8 , 3.5 ) ;    ( 5.5 , 0 )  ( 5.5 , 4 ) ; at ( 6.75 , 4.5)@xmath70 ; at ( 2.75 , 4.5)@xmath71 ;    _ part 3 : showing that under @xmath270 decoding is possible without the need for nodes in @xmath71 to know messages for nodes in @xmath70 : _",
    "for every @xmath324 , let @xmath325 we claim that for every @xmath324 : @xmath326 where @xmath268 is given in eq . .",
    "this shows that nodes at @xmath71 are able to decode their messages using @xmath327 and their side information in @xmath71 ( excluding side information from nodes at @xmath70 ) .",
    "we have : @xmath328 where eqs . and follow from the definition of @xmath296 in eq . .",
    "note that the expression of eq . does not include any of @xmath263 for @xmath329 . moreover , the coefficient of @xmath263 for @xmath330 are the same as those in @xmath331 .",
    "this establishes eq . .",
    "the proof has two parts : first we show that @xmath332 } \\alpha \\mathcal{c}'\\oplus ( 1-\\alpha)\\mathcal{c } '' \\subseteq \\mathcal{c}$ ] and then we will finish the proof by showing that @xmath333 } \\alpha \\mathcal{c}'\\oplus ( 1-\\alpha)\\mathcal{c}''$ ] .    before starting the proof , let us label the vertices of @xmath4 so that the vertices of @xmath79 come first .    _ proving @xmath332 } \\alpha \\mathcal{c}'\\oplus ( 1-\\alpha)\\mathcal{c } '' \\subseteq \\mathcal{c}$ ] _ : take an arbitrary vector @xmath89 in @xmath83 .",
    "then we can allocate all of our resources for @xmath79 and do not send anything for @xmath80 .",
    "this shows that @xmath334 is in @xmath82 .",
    "similarly for any @xmath90 in @xmath84 , we have that @xmath335 is in @xmath82 . using the standard time - sharing techniques",
    ", one can show that the capacity region of the index coding problem is a convex set .",
    "therefore for any @xmath88 $ ] the rate @xmath336 .",
    "this completes the proof .    _",
    "proving @xmath337 } \\alpha \\mathcal{c}'\\oplus ( 1-\\alpha)\\mathcal{c}''$ ] _ : for any rate vector @xmath338 , there exist a sequence of codes like @xmath339 whose rates converge to @xmath25 .",
    "take some @xmath176 and a code described by encoding function @xmath16 whose rate @xmath340 is within @xmath179 distance of @xmath25 .    *",
    "* linear case * : suppose that @xmath341 . in the proof of the part ( a ) , we showed that there exist encoding functions @xmath342 and @xmath343 which are respectively valid for @xmath79 and @xmath80 .",
    "additionally , the size of the range of the concatenation of @xmath270 and @xmath344 equals the size of the range of @xmath16 , i.e. @xmath345 .",
    "hence , if we call the rates of @xmath270 and @xmath344 , @xmath89 and @xmath90 , we will have : @xmath346 + since @xmath347 and @xmath348 , above statement results in the fact that @xmath340 lies in @xmath332 } \\alpha \\mathcal{c}'\\oplus ( 1-\\alpha)\\mathcal{c}''$ ] . by the definition of the asymptotic capacity region , @xmath83 and @xmath84 are closed sets .",
    "we are done with the proof by noting that @xmath340 can be made arbitrarily close to @xmath25 .",
    "* * non - linear case * : suppose that @xmath349 . in the proof of the part ( a ) , we showed that we can find encoding functions @xmath350 and @xmath351 in which @xmath188 and @xmath189 satisfy @xmath352 , @xmath197 is an arbitrary positive real number , and an appropriate @xmath32 can be found for any fixed @xmath197 so that such functions exist .",
    "moreover , @xmath270 and @xmath344 are respectively valid for @xmath79 and @xmath80 over the alphabet sets of @xmath353 and @xmath354 .",
    "hence , if we call the rates of @xmath270 and @xmath344 , @xmath89 and @xmath90 , we will have : @xmath355 thus , @xmath356 as @xmath357 and @xmath358 , @xmath359 lies in @xmath332 } \\alpha \\mathcal{c}'\\oplus ( 1-\\alpha)\\mathcal{c}''$ ] for any @xmath360 . since @xmath332 } \\alpha \\mathcal{c}'\\oplus ( 1-\\alpha)\\mathcal{c}''$ ] is a closed set and we can make @xmath197 and @xmath179 as close to zero as we want , we will be done .",
    "we prove two parts of theorem [ thm2 ] in the following two subsections .      _",
    "linear one - shot case : _ if @xmath4 is uscs , then proof is finished .",
    "otherwise , @xmath4 contains an edge like @xmath75 which is not located in any cycles .",
    "let @xmath361 be the set of vertices that can be reached from @xmath128 .",
    "morever , let @xmath362 be the set of vertices who can not be reached from @xmath128 .",
    "it is easy to verify that there will be no edge that starts from @xmath361 and finishes in @xmath362 . using part ( a ) of theorem [ thm3new ]",
    ", we can remove all edges between @xmath361 and @xmath362 including @xmath94 , so that the rate region does not shrink .",
    "as the number of the edges of @xmath4 is finite , by repeating this process we can find a uscs subgraph of @xmath4 like @xmath79 whose rate region equals the rate region of @xmath4 .",
    "hence , if @xmath4 is a critical graph , it should be equal to @xmath79 which is uscs .",
    "in other words , any critical graph for one - shot linear index coding is uscs .",
    "the proof for _ non - linear asymptotic index coding _ using part ( a ) of theorem [ thm3new ] is similar .",
    "_ linear asymptotic case : _ this follows from the one - shot case . for any code @xmath363 of length @xmath32",
    ", there is another code @xmath364 with the same rate vector on a subgraph @xmath79 of @xmath4 that is uscs .",
    "now , given any arbitrary sequence of codes @xmath339 whose rate vector converges to a given rate vector @xmath174 , we can find a sequence of codes @xmath365 on subgraphs @xmath366 whose rate vector converges to the same rate vector @xmath174 . since any graph @xmath4 has only a finite number of subgraphs , we can find indices @xmath367 such that @xmath368 are identical .",
    "the subsequence of the codes @xmath369 is defined on the uscs graph @xmath370 and has a rate vector that converges to @xmath174 .",
    "since @xmath4 and is critical and @xmath370 is a subgraph of @xmath4 , we conclude that @xmath371 implying that @xmath4 is uscs . +      to prove this part we need to show that a critical graph exists for one - shot non - linear case that is not uscs .",
    "consider the graph given in fig .",
    "we call this graph @xmath372 .",
    "assume that @xmath373 we have the following claim :    sending a symbol from @xmath374 as the public message suffices for every node to decode its message .",
    "[ - > , > = stealth , shorten > = 1pt , auto , node distance=1.7 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 6)at(0,0 ) 6 ; ( 1)at(0 , 1.4 ) 1 ; ( 2 ) at(1.5 , 0.4 ) 2 ; ( 5 ) at(-1.5 , 0.4)5 ; ( 4 ) at(-1 , -1 ) 4 ; ( 3 ) at(1 , -1 ) 3 ; ( 1 ) edge node ( 2 ) edge node ( 5 ) ( 2 ) edge node ( 1 ) edge node ( 3 ) ( 3 ) edge node ( 2 ) edge node ( 4 ) ( 4 ) edge node ( 3 ) edge node ( 5 ) ( 5 ) edge node ( 1 ) edge node ( 4 ) ( 6 ) edge node ( 1 ) edge node ( 2 ) edge node ( 3 ) edge node ( 4 ) edge node ( 5 ) ;    however , if we remove the edges connected to node @xmath375 , which do not belong to any cycle , we need at least 35 symbol to have a successful transmission of the messages .",
    "this claim establishes the desired result , since if @xmath4 is critical it would be an instance of a non - uscs graph that is critical .",
    "if @xmath4 is not critical , there is a subgraph @xmath79 of it ( obtained by removing edges from @xmath4 ) that is critical ; that is the graph @xmath79 is such that sending a symbol from @xmath374 as the public message suffices for every node to decode its message .",
    "however any further removal of edges from @xmath79 results in a graph that does not have this property . by the above claim ,",
    "the minimal graph @xmath79 should contain at least one of the edges connected to the node @xmath375 ; since if not , @xmath79 would be a subgraph of the graph shown in the claim to need at least 35 symbols .",
    "therefore , @xmath79 contains an edge that is not on any cycle .",
    "hence it is a non - uscs and critical graph .",
    "we now turn to the proof of the claim . in order to construct the coding scheme using 32 symbols for @xmath4 , first note that @xmath376 forms a binary sequence of the length 5 . based on the value of @xmath377",
    ", we xor this sequence with one the following sequence : @xmath378 , @xmath379 , @xmath380 , @xmath381 , @xmath382 , that is , if @xmath377 is 0 we xor the sequence with @xmath378 , if it is 1 we xor it with @xmath379 , and so on . then , we transmit the result as the public message ( the public message has 32 different possibilities and can be transmitted ) .",
    "let us denote the 5-bit public message by @xmath383 .",
    "it is sufficient to show that every node can decode its message with the help of the public message and its side information .",
    "first of all , because the node @xmath375 knows the message of 1 to 5 , it can xor their message by the public message and from the xor decode its message . for the other nodes ,",
    "note that @xmath384 for @xmath385 is a function of the side information of node @xmath1 , and therefore , node @xmath1 can decode its message .",
    "we explain the decoding process for node @xmath109 ; the decoding process for other nodes is similar .",
    "node @xmath109 knows @xmath105 and @xmath386 . by comparing these two bits with @xmath387 and @xmath388",
    ", node @xmath109 can exactly recover @xmath377 if it is equal to @xmath389 , @xmath98 or @xmath99 .",
    "if @xmath377 is equal to @xmath109 or @xmath49 , node @xmath109 can not find the exact value of @xmath377 .",
    "however in both cases of @xmath390 we have @xmath391 , and by flipping @xmath392 the first node can recover its intended bit .    [ cols=\"^,^,^\",options=\"header \" , ]     we can check that in every row , two columns do not have common subset . thus , according to this table and the aforementioned argument , it is clear that every node can decode its message .",
    "+    in order to prove that if we remove the edges connected to node @xmath375 , at least 35 symbols are needed , suppose that there exists a coding scheme which requires at most 34 symbols . according to pigeonhole principle , we can conclude that there exists @xmath393 so that if @xmath394 , public message gets at most 6 distinct different values when we vary the @xmath395 , i.e. the cardinality of the set @xmath396 is at most 6 .",
    "for this value of @xmath397 , consider the following function over five variables @xmath395 : @xmath398 since @xmath377 was independent of @xmath399 and we have zero probability of error , the function @xmath400 is a valid encoding function for a cycle of length 5 .",
    "this contradicts lemma [ lemma : cycle - five ] below .",
    "[ lemma : cycle - five ] the bidirectional cycle of length 5 with @xmath401 needs a public message of alphabet size 7 to achieve a zero probability of error for the one - shot problem .",
    "we prove this lemma by contradiction .",
    "assume otherwise that there exists a coding scheme that uses a public message with 6 possibilities .",
    "from the pigeonhole principle , we conclude that the encoding function maps at least 6 combinations of the messages to one symbol , i.e. there are six sequences of @xmath402 , @xmath403 , whose @xmath404 are equal , i.e. their corresponding public message is the same .",
    "thus , the nodes should be able to recover their own messages using their side information .",
    "in other words , for instance for node @xmath109 , if @xmath405 for some @xmath1 and @xmath406 , then we should have @xmath407 .",
    "thus the six sequences should be distinguishable , where we call two sequences @xmath408 and @xmath409 distinguishable if for each @xmath410 either @xmath411 or the @xmath412 for some @xmath413 .    given a sequence @xmath408 , consider the graph induced on the set of vertices @xmath414 .",
    "we call the sequence @xmath408  good \" if the induced graph does not contain of a vertex of degree zero ( i.e. is connected ) . for instance",
    ", in a cycle of size @xmath50 if we take @xmath415 , the induced graph would be on nodes @xmath416 which is connected .",
    "however @xmath417 corresponds to the induced graph on nodes @xmath418 which is not connected since node @xmath49 is not connected to nodes @xmath109 and @xmath98 .",
    "it is easy to verify that @xmath408 and @xmath409 distinguishable if and only if their bitwise xor is good .",
    "for instance @xmath419 and @xmath420 are not distinguishable ( by node 4 ) since their xor , @xmath419 is not good .",
    "now , we know that the xor of any two of @xmath421 , @xmath403 is good . we show that this can not happen . without loss of generality",
    ", we can assume that one of the six sequences is the all zero sequence .",
    "therefore , we should look for 5 sequences that are individually good , and their pairwise bitwise xor is also good . in appendix",
    "[ appendixb ] , we provide a code in @xmath422 which checks all possible cases and shows that such a set of sequences does not exist .",
    "suppose that @xmath372 is a bidirectional graph where @xmath423 . to show that @xmath4 is critical",
    ", we need to find a rate vector , @xmath174 , for every @xmath424 that is achievable in @xmath4 , but it is not achievable in @xmath425 .",
    "we define @xmath25 in the following manner : + @xmath426 to show that @xmath25 is achievable in @xmath4 , suppose that @xmath7 is the message of node @xmath1 , and @xmath427 where : @xmath428 now , if we send @xmath429 as public message , then @xmath121 and @xmath128 can decode their message , because they have the message of each other as side information and the sum of their message . as @xmath14 has only one element for @xmath430 , the other vertices can trivially decode their message .",
    "therefore , @xmath25 is supported by @xmath4 .",
    "additionally , since the set @xmath431 in @xmath432 has no directed cycle , lemma [ lemma : rates - sum ] implies that for every @xmath433 supported by @xmath434 , @xmath435 .",
    "thus , @xmath25 can not be supported by @xmath425 .",
    "next we show that a cycle of size four with vertices @xmath436 and edges @xmath437 @xmath438 is not symmetric rate critical .",
    "if this graph supports the rate vector @xmath439 , as the set @xmath440 has no directed cycle , lemma [ lemma : rates - sum ] gives that @xmath441 .",
    "in addition , consider the subgraph @xmath110 of the cycle with edges@xmath442 . if we send two bits @xmath443 as public message , then all nodes can decode their message . hence , the rate @xmath444 is achievable in @xmath110 . now , since removing edges @xmath445 do not change the symmetric capacity region of cycle of size four , it is not symmetric rate critical .        in order to show the criticality of @xmath111 we need to show that by eliminating every edge like @xmath94 from @xmath111 , the capacity region of the index coding problem related to @xmath111 shrinks strictly . without loss of generality assume that @xmath446 .",
    "as @xmath4 is a critical graph , there exists a rate vector like @xmath25 that supports @xmath4 , but not @xmath447 .",
    "now , consider a rate vector for the index coding problem introduced by @xmath111 in which the rates of nodes in @xmath110 are all zero and rates of the nodes in @xmath4 equals @xmath25 .",
    "this rate vector is evidently admissible for @xmath111 , but not for @xmath448 ( which is @xmath111 after elimination of @xmath94 ) .",
    "showing that the maximal symmetric rate also reduces after we remove an edge from @xmath111 is more challenging .",
    "let @xmath449 and @xmath450 be the maximal symmetric rate for @xmath4 and @xmath110 respectively .",
    "it is clear that concatenation of these two coding functions with proportion of @xmath451 and @xmath452 for @xmath4 and @xmath110 respectively , results in a coding function for @xmath111 with the symmetric rate of @xmath453 .",
    "we claim that this symmetric rate would not be achievable if any edge like @xmath94 is removed from @xmath111 .",
    "this will prove the symmetric criticality of @xmath111 .",
    "we are going to prove this claim by contradiction . without loss of generality , assume that @xmath94 is an edge of @xmath4 .",
    "we refer to the graph obtained by @xmath4 after elimination of @xmath94 as @xmath79 .",
    "suppose that there exists a coding function like @xmath16 for @xmath448 with the symmetric rate of @xmath37 . from theorem [ thm3new ]",
    "then , there exist some @xmath88 $ ] and symmetric rates @xmath454 and @xmath455 for @xmath79 and @xmath110 such that @xmath456 .",
    "this implies that @xmath457 thus , @xmath458 however , by the symmetric criticality of @xmath4 and by the definitions of @xmath449 and @xmath450 , we have that @xmath459 equations and are in contradiction with each other .",
    "this contradiction completes the proof .",
    "consider the symmetric one - shot linear index coding problems defined over @xmath4 , @xmath110 , and @xmath111 .",
    "assume that the alphabet of each node in each of these problems is @xmath460 for some finite field @xmath26 .",
    "let @xmath461 be the minimum possible positive integer number such that there exists a valid linear coding function with the output size of @xmath461 symbols over @xmath26 .",
    "define @xmath462 for @xmath110 in the same manner .",
    "it is clear that there exists an encoding function for the problem related to @xmath463 that uses a public message of @xmath464 symbols by concatenation of the encoding functions that use @xmath461 symbols for @xmath4 and @xmath462 symbols for @xmath110 .",
    "hence , the symmetric rate of @xmath465 is achievable for the index coding problem introduced by @xmath111 .",
    "we are going to show that if @xmath4 and @xmath110 are both symmetric critical , then @xmath111 is symmetric critical too . to prove the symmetric criticality of @xmath111 , we will prove that any valid coding function for @xmath111 needs at least @xmath466 public symbols after removal of any edge like @xmath94 from @xmath111 . without loss of generality , we assume that @xmath94 is removed from the @xmath4 component of @xmath111 .",
    "we refer to the graph obtained by @xmath4 after the removal of @xmath94 as @xmath79 .",
    "then , the graph obtained from @xmath111 after the removal of @xmath94 would be @xmath448 .",
    "let @xmath16 be a valid encoding function for @xmath448 , we have shown in the proof of part ( a ) of theorem [ thm3new ] that there exist two valid encoding functions @xmath270 and @xmath344 for @xmath79 and @xmath110 so that the concatenation of @xmath270 and @xmath344 has the same output size to @xmath16 . as @xmath344 is a valid encoding function for @xmath110 ,",
    "its output size is at least @xmath462 .",
    "in addition , because of the criticality of @xmath4 , we know that every valid encoding function for @xmath79 , including @xmath270 , needs at least @xmath467 symbols . accordingly , the concatenation of @xmath270 and @xmath344 has an output size of at least @xmath466 .",
    "consequently , the output size of the @xmath16 is at least @xmath466 .",
    "this means that @xmath111 is a symmetric critical graph because it can not support the symmetric rate of @xmath465 after removal of any of its edges .        in the first step of the proof",
    ", we will show that the new graph @xmath79 supports the symmetric rate of @xmath468 . in the next step",
    ", we will show that this rate will not be achievable if any edge is eliminated .",
    "these two steps will clearly prove this theorem .    _",
    "( i ) achievability : _ let @xmath7 denote the message of node @xmath1 , and @xmath469 .",
    "consider the encoding function @xmath470    the @xmath471 element of @xmath16 is the sum of the side information of node @xmath472 and @xmath473 ; therefore node @xmath472 ( for @xmath474 ) can decode its message .",
    "node @xmath475 can cosider : @xmath476 since node @xmath475 has @xmath108 and @xmath7 as side information , it can decode its message with the help public message .    as @xmath477 , it shows the achievability of rate @xmath478 . to prove the achievability of rate @xmath25 ,",
    "notice that for @xmath479 , we have @xmath480 therefore , we can only send @xmath481 ; @xmath482 can be omitted from public message and instead recovered from the rest of @xmath483 s .",
    "thus , the rate @xmath25 is achievable , too .    _",
    "( ii ) unachievability after edge removal : _ to show that @xmath79 is critical , it suffices to prove that after removing any edge of @xmath484 , we will need at least @xmath0 bits of public message .",
    "lemma [ lemma : rates - sum ] implies that if there exists a subset of length @xmath0 in a graph which does not contain any cycle , the rate @xmath25 would not be achievable in the graph ( otherwise the sum of the rates would be @xmath485 which is greater that 1 ) .",
    "thus , it suffices to show that for every @xmath486 , there exists a subset of @xmath72 , say @xmath487 , of length at least @xmath0 such that the induced subgraph of @xmath487 in @xmath488 has no directed cycle .",
    "first , suppose that @xmath489 .",
    "then we can choose @xmath490 . as @xmath487 contains exactly @xmath0 vertices and",
    "the induced graph is a directed path which contains no cycle then these edges are critical . for @xmath491 ,",
    "@xmath487 can be chosen as @xmath492 .",
    "same argument can be made for @xmath493 . for @xmath494 ,",
    "@xmath487 can be chosen as @xmath495 .",
    "same argument can be made for @xmath496 .",
    "we use the same approach from part ( a ) to show that the rate @xmath468 is achievable in @xmath80 , and by removing every edge the rate would not be achievable .    _",
    "( i ) achievability : _ suppose that the message of node @xmath497 is @xmath498 .",
    "then , define : @xmath499 similar to part ( a ) , consider the encoding function @xmath500 .",
    "again , for @xmath501 and @xmath502 $ ] , the @xmath471 element of @xmath16 , @xmath503 , is the sum of the side information and @xmath504 .",
    "so , these nodes can decode their message . for @xmath505 $ ]",
    ", node @xmath506 can consider : @xmath507 by definition of @xmath80 , node @xmath506 knows @xmath508 @xmath509 as side information .",
    "therefore , with the help of public message and its side information @xmath506 can decode its message . additionally , for @xmath479",
    ", we have : @xmath480 thus , @xmath482 can be eliminated from the public message ( and instead recovered from the rest ) and the rate @xmath510 would be achieved .    _",
    "( ii ) unachievability after edge removal : _ now , we want to show that by elimination of any edge in @xmath511 , @xmath510 will not be achievable anymore . as discussed in part ( a ) , it suffices to show that after removing any edge in @xmath511 , there will be @xmath512 with at least @xmath0 vertices which does not contain any directed cycle . as we have two different types of edges in @xmath80 , we analyze the impact of edge removal on the capacity region in two different cases .",
    "* case 1 ) * _ @xmath513 where @xmath514 _",
    "+ by definition of @xmath80 , we have @xmath515 . in part",
    "( a ) , we proved that there exists @xmath516 of size @xmath0 which does not contain any cycle in @xmath517 .",
    "now , choose @xmath518 . if @xmath519 and @xmath520 , then @xmath521 and @xmath522 .",
    "thus , @xmath519 has edge to @xmath523 in @xmath80 if and only if @xmath155 has edge to @xmath524 in @xmath79 and because @xmath525 has no cycle in @xmath79 then @xmath487 has no cycle in @xmath80 .",
    "* case 2 ) * _ e=((u , s ) , ( u , t ) ) _",
    "+ for @xmath526 , choose @xmath527 mod @xmath528 , and for @xmath529 .",
    "choose @xmath530 .",
    "it is straightforward to check that these two sets contain no cycle .",
    "as mentioned in remark [ rmk : gic - hypergraph ] , the underlying digraph of the hypergraph that characterizes a unicast index coding problem equals the directed graph model we used for unicast index coding problem . thus , the example we offered in part ( b ) of theorem [ thm2 ] works for the groupcast scenario too .",
    "let @xmath134 be a hypergraph related to a groupcast index coding problem .",
    "further , let @xmath531 be the underlying directed graph of @xmath110 . to prove this theorem , it suffices to show that for every edge @xmath532 in @xmath4 which is not located in any cycles , elimination of @xmath94 will not change the capacity region .",
    "it should be noted that elimination of @xmath94 from the underlying digraph is interpreted as removing @xmath13 from the side information set of all receivers who intend to find @xmath7 . from now on",
    ", we will show the hypergraph obtained by the elimination of @xmath94 from @xmath4 using the notation @xmath533 .",
    "now , we are going to show that for any valid coding function @xmath16 for side information hypergraph @xmath110 , there exists a coding function @xmath270 which is valid for the groupcast index coding problem introduced by @xmath533 and its output size equals the output size of @xmath16 . let @xmath361 be the set of vertices that are reachable from @xmath13 and @xmath534 where @xmath74 is the vertex set of the graph . using the assumption that @xmath94 is not located in any cycles , one can conclude that @xmath74 is partitioned into two parts @xmath361 and @xmath362 such that :    * @xmath535 * @xmath536 * @xmath537    in other words , any receiver who wants to find a message in @xmath361 does not have any side information about the messages in @xmath362 .",
    "this was the only assumption we used in the proof of part ( a ) of theorem [ thm3new ] in order to show that we can find two coding functions @xmath482 and @xmath538 such that all receivers in @xmath539 be able to find @xmath16 using @xmath482 , @xmath538 , and their side information in @xmath539 and the size of @xmath540 equals the output size of @xmath16 .",
    "hence , using same arguments , @xmath540 is a valid coding function for the groupcast index coding problem introduced by the hypergraph obtained by eliminating edges between @xmath361 and @xmath362 ( including @xmath94 ) .",
    "16 y. birk and t. kol , _ informed - source coding - on - demand ( iscod ) over broadcast channels , _ in proc .",
    "( infocom ) , san francisco , ca , mar .",
    "1998 , pp .",
    "1257 - 1264",
    ". s. h. dau , v. skachek , and y. m. chee , _ secure index coding with side information , _ arxiv preprint arxiv:1011.5566 , 2010 .",
    "a. blasiak , r. kleinberg , and e. lubetzky , _ lexicographic products and the power of non - linear network coding , _ in proc . of the 52nd annual ieee symposium on foundations of computer science ( focs ) , 2011 , pp .",
    "609 - 618 .",
    "f. arbabjolfaei , b. bandemer , y. kim , e. sasoglu , and l. wang , _ on the capacity region for index coding , _ arxiv preprint arxiv:1302.1601v2.pdf , 2013 . h. sun and s. a. jafar , _ index coding capacity : how far can one go with only shannon inequalities ? , _ arxiv preprint arxiv:1303.7000.pdf , 2013 .",
    "k. shanmugam , a. g. dimakis , and m. langberg , _ local graph coloring and index coding , _ in ieee international symposium on information theory ( isit ) , 2013 , pp .",
    "1152 - 1156 . s. el rouayheb , a. sprintson , and c. georghiades , _ on the relation between the index coding and the network coding problems , _ ieee international symposium on information theory ( isit ) , 2008 , pp . 1823 - 1827 .",
    "m. effros , s. rouayheb , and m. langberg , _ an equivalence between network coding and index coding , _ arxiv preprint arxiv:1211.6660 , 2012 .",
    "h. maleki , v. cadambe , and s. jafar , _",
    "index coding : an interference alignment perspective , _ in information theory proceedings ( isit ) , 2012 ieee international symposium on .",
    "ieee , 2012 , pp .",
    "2236 - 2240 .",
    "e. lubetzky and u. stav , _ non - linear index coding outperforming the linear optimum , _ in proc .",
    "of the 48th annual ieee symposium on foundations of computer science ( focs ) , 2007 , pp .",
    "161 - 167 .",
    "z. bar - yossef , y. birk , t. s. jayram , and t. kol , _ index coding with side information , _ in 47th annual ieee symposium on foundations of computer science , ( focs ) , 2006 , pp . 197 - 206 .",
    "m. langberg and m. effros , _ network coding : is zero error always possible ? _ in 49th annual allerton conference on communications , control and computing , 2011 , pp .",
    "1478 - 1485 .",
    "t. ho , m. effros , and s. jalali , _ on equivalences between network topologies , _ in 48th annual allerton conference on communication , control , and computing , 2010 .",
    "s. jalali , m. effros , and t. ho , _ on the impact of a single edge on the network coding capacity , _ in information theory and applications workshop ( ita ) , 2011 .",
    "d.b.west , _ introduction to graph theory ( 2nd edition ) , _ prentice hall , 2001 .",
    "a. el gamal and y .- h .",
    "network information theory , _ cambridge university press , 2011 .",
    "jafar , syed a. _ topological interference management through index coding .",
    "_ arxiv preprint arxiv:1301.3106 , 2013 .",
    "neely , michael j. , arash saber tehrani , and zhen zhang .",
    "_ dynamic index coding for wireless broadcast networks . _ in infocom , 2012 proceedings ieee , pp .",
    "316 - 324 .",
    "ieee , 2012 .",
    "arrowsmith , j. w. essam , _ percolation theory on directed graphs ,",
    "_ j. mathematical phys .",
    "18 ( 1977 ) , no . 2 , 235 - 238 .",
    "young - han kim , _ index coding _",
    ", available at http://circuit.ucsd.edu/~yhk/indexcoding.html .",
    "[ lemma : rates - sum ] assume that @xmath541 is a subset of the vertices of a graph @xmath10 which contains no directed cycle . then in every rate vector @xmath542 supported by @xmath4 in non - linear asymptotic case , the following holds : + @xmath543    although the lemma above is proved in @xcite , we will give a simple operational proof based on graph theory .",
    "we construct a new graph @xmath544 by contracting the set @xmath541 in @xmath4 . strictly speaking , the vertices of @xmath79 include the vertices of @xmath4 when we replace all vertices in @xmath541 with a single vertex labeled by @xmath545 : @xmath546 and edges connected to vertices in @xmath171 are now connected to @xmath545 in @xmath79 , i.e. @xmath547 we prove that if we use the same coding scheme of @xmath4 for @xmath79 , the node @xmath545 can decode all messages belonging to the vertices in @xmath541 .",
    "since the set @xmath541 does not contain any cycle , we can order the elements of @xmath541 as @xmath548 such that vertices have only edges to vertices with a higher index , i.e. an edge from vertex @xmath549 to vertex @xmath550 may only exist when @xmath551 . now",
    "the vertex @xmath552 in @xmath79 can decode the message of @xmath553 due to the fact that @xmath553 is the last element of the order , and therefore , it does not know the messages of the other vertices in @xmath541 .",
    "so , @xmath545 has all side information of @xmath553 and can decode its message .",
    "next , @xmath554 can have only the message of @xmath553 from the messages of the vertices in @xmath171 , which has been decoded by now .",
    "thus , @xmath545 in @xmath79 can decode the message of @xmath554 , too , and this process goes on .",
    "therefore , we can prove by induction that @xmath545 can obtain all the messages of the vertices in @xmath541 . in this coding scheme the rate of vertex @xmath545 equals to :",
    "@xmath555 and by considering the fact that the rate of each vertex can not be more than @xmath109 , we get our desired result .",
    "[ lemma : turan ] a bidirectional @xmath0-vertex graph @xmath4 that contains no clique of size @xmath556 has at most @xmath47 edges .",
    "furthermore , the only graph ( up to isomorphism ) which satisfies the aforementioned condition is @xmath40 .    the above lemma is known as the turn theorem , and its proof can be found in many graph theory books such as ( * ? ? ? * thm .",
    "this section provides all symmetric rate critical graphs on 5 nodes using the list given on the website of young - han kim@xcite .",
    "there are a total of 9608 graphs listed on the website , among which 32 are critical , appearing from the next page .",
    "[ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 4 ) edge node ( 5 ) ( 5 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 3 ) edge node ( 5 ) ( 4 ) edge node ( 3 ) ( 5 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 3 ) edge node ( 4 ) edge node ( 5 ) ( 4 ) edge node ( 3 ) edge node ( 5 ) ( 5 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 2 ) edge node ( 5 ) ( 3 ) edge node ( 4 ) ( 4 ) edge node ( 2 ) ( 5 ) edge node ( 3 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 2 ) edge node ( 5 ) ( 3 ) edge node ( 4 ) ( 4 ) edge node ( 3 ) ( 5 ) edge node ( 2 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 2 ) edge node ( 5 ) ( 3 ) edge node ( 2 ) edge node ( 4 ) ( 4 ) edge node ( 2 ) edge node ( 3 ) ( 5 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 2 ) edge node ( 5 ) ( 3 ) edge node ( 4 ) edge node ( 5 ) ( 4 ) edge node ( 2 ) edge node ( 3 ) ( 5 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 2 ) edge node ( 3 ) edge node ( 4 ) edge node ( 5 ) ( 3 ) edge node ( 2 ) edge node ( 4 ) edge node ( 5 ) ( 4 ) edge node ( 2 ) edge node ( 3 ) edge node ( 5 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 4 ) ( 3 ) edge node ( 2 ) ( 4 ) edge node ( 1 ) ( 5 ) edge node ( 3 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 4 ) ( 3 ) edge node ( 2 ) ( 4 ) edge node ( 3 ) ( 5 ) edge node ( 1 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 4 ) ( 3 ) edge node ( 1 ) edge node ( 2 ) ( 4 ) edge node ( 1 ) edge node ( 3 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 4 ) ( 3 ) edge node ( 1 ) edge node ( 2 ) ( 4 ) edge node ( 3 ) edge node ( 5 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 4 ) ( 3 ) edge node ( 1 ) edge node ( 2 ) ( 4 ) edge node ( 3 ) edge node ( 5 ) ( 5 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 4 ) ( 3 ) edge node ( 2 ) edge node ( 5 ) ( 4 ) edge node ( 1 ) edge node ( 3 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 4 ) ( 3 ) edge node ( 2 ) edge node ( 5 ) ( 4 ) edge node ( 1 ) edge node ( 3 ) ( 5 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 4 ) ( 3 ) edge node ( 4 ) edge node ( 5 ) ( 4 ) edge node ( 1 ) edge node ( 3 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 5 ) ( 3 ) edge node ( 2 ) edge node ( 4 ) ( 4 ) edge node ( 1 ) edge node ( 3 ) ( 5 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 3 ) edge node ( 4 ) ( 3 ) edge node ( 2 ) edge node ( 4 ) ( 4 ) edge node ( 1 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 3 ) edge node ( 4 ) ( 3 ) edge node ( 2 ) edge node ( 4 ) ( 4 ) edge node ( 2 ) edge node ( 3 ) ( 5 ) edge node ( 1 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 4 ) edge node ( 5 ) ( 3 ) edge node ( 1 ) ( 4 ) edge node ( 2 ) edge node ( 3 ) ( 5 ) edge node ( 2 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 4 ) edge node ( 5 ) ( 3 ) edge node ( 2 ) edge node ( 4 ) ( 4 ) edge node ( 1 ) edge node ( 2 ) ( 5 ) edge node ( 3 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 1 ) edge node ( 3 ) edge node ( 4 ) ( 3 ) edge node ( 1 ) edge node ( 2 ) edge node ( 4 ) ( 4 ) edge node ( 1 ) edge node ( 2 ) edge node ( 3 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 3 ) edge node ( 4 ) edge node ( 5 ) ( 3 ) edge node ( 1 ) edge node ( 2 ) edge node ( 4 ) ( 4 ) edge node ( 1 ) edge node ( 2 ) edge node ( 3 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 5 ) ( 2 ) edge node ( 3 ) edge node ( 4 ) edge node ( 5 ) ( 3 ) edge node ( 2 ) edge node ( 4 ) edge node ( 5 ) ( 4 ) edge node ( 1 ) edge node ( 2 ) edge node ( 3 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 4 ) edge node ( 5 ) ( 2 ) edge node ( 1 ) edge node ( 3 ) ( 3 ) edge node ( 1 ) edge node ( 2 ) ( 4 ) edge node ( 2 ) edge node ( 3 ) edge node ( 5 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 4 ) edge node ( 5 ) ( 2 ) edge node ( 3 ) edge node ( 5 ) ( 3 ) edge node ( 2 ) edge node ( 4 ) ( 4 ) edge node ( 1 ) edge node ( 3 ) ( 5 ) edge node ( 1 ) edge node ( 2 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 4 ) edge node ( 5 ) ( 2 ) edge node ( 3 ) edge node ( 5 ) ( 3 ) edge node ( 2 ) edge node ( 5 ) ( 4 ) edge node ( 1 ) edge node ( 3 ) ( 5 ) edge node ( 1 ) edge node ( 2 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 4 ) edge node ( 5 ) ( 2 ) edge node ( 3 ) edge node ( 5 ) ( 3 ) edge node ( 2 ) edge node ( 5 ) ( 4 ) edge node ( 1 ) edge node ( 2 ) edge node ( 3 ) ( 5 ) edge node ( 1 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 4 ) edge node ( 5 ) ( 2 ) edge node ( 3 ) edge node ( 5 ) ( 3 ) edge node ( 1 ) edge node ( 2 ) edge node ( 4 ) ( 4 ) edge node ( 1 ) edge node ( 2 ) edge node ( 3 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 4 ) edge node ( 5 ) ( 2 ) edge node ( 3 ) edge node ( 4 ) edge node ( 5 ) ( 3 ) edge node ( 1 ) edge node ( 2 ) ( 4 ) edge node ( 2 ) edge node ( 3 ) edge node ( 5 ) ( 5 ) edge node ( 2 ) edge node ( 3 ) edge node ( 4 ) ;    [ - > , > = stealth , shorten > = 1pt , auto , node distance=2.5 cm , thick , main node/.style = circle , fill = blue!20,draw , font= * * * * ] ( 1)at(0,3)1 ; ( 2)at(3,1)2 ; ( 3)at(1.8,-2.4)3 ; ( 4)at(-1.8,-2.4)4 ; ( 5)at(-3,1)5 ; ( 1 ) edge node ( 2 ) edge node ( 3 ) edge node ( 4 ) edge node ( 5 ) ( 2 ) edge node ( 1 ) edge node ( 3 ) edge node ( 4 ) edge node ( 5 ) ( 3 ) edge node ( 1 ) edge node ( 2 ) edge node ( 4 ) edge node ( 5 ) ( 4 ) edge node ( 1 ) edge node ( 2 ) edge node ( 3 ) edge node ( 5 ) ( 5 ) edge node ( 1 ) edge node ( 2 ) edge node ( 3 ) edge node ( 4 ) ;"
  ],
  "abstract_text": [
    "<S> in this paper we define critical graphs as minimal graphs that support a given set of rates for the index coding problem , and study them for both the one - shot and asymptotic setups . for the case of equal rates , we find the critical graph with minimum number of edges for both one - shot and asymptotic cases . for the general case of possibly distinct rates , we show that for one - shot and asymptotic linear index coding , as well as asymptotic non - linear index coding , each critical graph is a union of disjoint strongly connected subgraphs ( uscs ) . on the other hand </S>",
    "<S> , we identify a non - uscs critical graph for a one - shot non - linear index coding problem . </S>",
    "<S> next , we identify a few graph structures that are critical . we also generalize some of our results to the groupcast problem . </S>",
    "<S> in addition , we show that the capacity region of the index coding is additive for union of disjoint graphs . </S>"
  ]
}