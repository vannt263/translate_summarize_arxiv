{
  "article_text": [
    "resource processing and data transfer multicriteria optimization problems occur in many situations , particularly in large distributed systems , like grids , distributed databases , live and on - demand video streaming applications , peer - to - peer systems , and so on .",
    "the problems that occur in practical settings are of a wide diversity and consider the optimization of various parameters , while imposing constraints on others .",
    "handling such problems from a general perspective is useful when trying to understand and classify them , but it is of little use when we want to solve a specific problem . in this paper",
    "we consider several such multicriteria optimization problems , for which we provide novel , very specific algorithmic solutions . instead of presenting a general technique and analyzing its efficiency on various types of optimization problems",
    ", we focus on the problems and develop different solutions for each problem .",
    "the considered problems are mainly offline , meaning that all the required information is available in advance . from this point of view",
    ", the presented results can not be applied directly in real - time settings ( where most of the resource processing and data transfer optimization problems occur ) . however , from a theoretical point of view , the developed algorithms are of significant interest and they are the first steps towards obtaining efficient online solutions to some of the considered problems .    the rest of this paper is structured as follows . in section 2",
    "we discuss several offline ( multi)point - to-(multi)point data transfer optimization problems , like finding a deadline - constrained packet transfer strategy , computing a minimum cost communication spanning tree when the link providers have special offers , and finding a subset of edges ( vertices ) of maximum average weight ( when we have two weights assigned to every edge or vertex ) . in section 3",
    "we propose a new agent - based peer - to - peer content delivery architecture .",
    "we present generic methods and guidelines and discuss the issues of point - to - point and multicast data transfers within the topology . in section 4",
    "we discuss several constrained ( multi-)permutation construction and sorting problems .",
    "such problems are partially related to efficiently ordering the packets of a communication flow in the transmission buffer . in section 5",
    "we present new algorithmic extensions to the union - find and split - find problems .",
    "these are set maintenance problems which require efficient management and querying of sets of elements .",
    "they have applications in several resource processing situations ( e.g. when reserving resources , see @xcite ) . in section 6",
    "we discuss another resource processing problem , for which we present an optimal algorithm .",
    "the problem consists of activating / deactivating resources in a graph with bounded treewidth by using a minimum cost strategy .",
    "this problem is a more general version of the _ minimum all - ones problem _ @xcite , which assumes that the final state of each resource must always be _ active _ and the cost of selecting a resource is always @xmath0 .",
    "finally , in section 7 we discuss related work and in section 8 we conclude .",
    "we consider a directed graph with @xmath1 vertices and @xmath2 edges . a packet is sent from the source node @xmath3 at time @xmath4 and must reach the destination node @xmath5 by time @xmath6 .",
    "every directed edge @xmath7 from a vertex @xmath8 to a vertex @xmath9 has an associated start time @xmath10 and a finish time @xmath11 ( @xmath12 ) .",
    "the meaning of these parameters is that the packet can only be sent along that edge , from @xmath8 to @xmath9 , starting at the moment @xmath10 and will only arrive at vertex @xmath9 at the moment @xmath11 .",
    "thus , edge @xmath7 corresponds to a reservation in the underlying network .",
    "moreover , out of the total packet transmission time ( equal to @xmath13 ) , @xmath14 is the total time during which the packet has to wait in the waiting queues ( e.g. it must wait for some data processing task or must wait until other packets before it are sent along the edge ) .",
    "the time between the moment when the packet arrives to a vertex @xmath8 and the moment when it is sent to another vertex @xmath9 ( or between the moment when it last arrives at vertex @xmath5 and the moment @xmath6 ) also counts as waiting time .",
    "we want to find a packet transfer strategy minimizing the total waiting time .",
    "the steps of the algorithm are described below .    1 .   for every vertex @xmath9 of the graph : 1 .",
    "we will sort together the incoming and outgoing edges in increasing order , according to a weight assigned to every edge : for an incoming edge @xmath7 from a vertex @xmath8 to vertex @xmath9 , the weight is @xmath15 ; for an outgoing edge @xmath7 from vertex @xmath9 to a vertex @xmath8 , the weight is @xmath16 .",
    "2 .   if two edges ( an incoming and an outgoing one ) have the same weight , then we will place the incoming edge before the outgoing edge in the sorted order .",
    "3 .   for every edge in the sorted order of a vertex @xmath9 we will store its type : incoming or outgoing . 4 .   let @xmath17 be the total number of incoming and outgoing edges adjacent to vertex @xmath9 .",
    "2 .   we will compute @xmath18=the minimum total waiting time required for the packet to be located at vertex @xmath9 at the time moment @xmath19=the weight of the @xmath20 edge in the sorted order for vertex @xmath9 ( @xmath21 ) .",
    "3 .   we will consider @xmath22 and @xmath23 for every vertex @xmath24 and @xmath25 .",
    "4 .   we will sort ascendingly all the time moments @xmath19 ( @xmath26 ) in increasing order ( e.g. by merging the lists of time moments @xmath27 ) and we will store for each moment the associated values @xmath9 and @xmath28 . 5",
    ".   we will traverse all the time moments @xmath19 in increasing order",
    "if @xmath19 corresponds to an incoming edge @xmath7 ( from a vertex @xmath8 to vertex @xmath9 ) , then we will first find the index @xmath29 of the edge @xmath7 in the sorted order of the edges adjacent to vertex @xmath8 .",
    "2 .   we will have @xmath30 , @xmath31 .",
    "if @xmath19 corresponds to an outgoing edge @xmath7 from vertex @xmath9 to a vertex @xmath8 then we set @xmath32",
    ".    we can find the index @xmath29 of an edge @xmath7 in the sorted order of a vertex @xmath8 by using a hash table @xmath33 .",
    "after sorting the edges adjacent to vertex @xmath8 we traverse these edges : let the edge @xmath34 be the @xmath20 edge in this order - then we insert the pair @xmath35 in @xmath33 .",
    "thus , in order to find the index @xmath29 associated to an edge @xmath7 in the sorted order of a vertex @xmath8 we just search in @xmath33 the value associated to the key @xmath7 .",
    "such a lookup takes @xmath36 time and the overall time complexity is @xmath37 .",
    "the final answer is @xmath38 .",
    "as we can notice , the problem can also be interpreted as a shortest path problem in the graph of the pairs @xmath39 , where the starting pair is @xmath40 .",
    "we have an edge from each pair @xmath41 to the pair @xmath39 with cost @xmath42 ( @xmath21 ) .",
    "moreover , we have an edge from each pair @xmath43 to a pair @xmath39 , with cost @xmath14 if @xmath7 is an edge from @xmath8 to @xmath9 and is the @xmath44 edge in the sorted order of vertex @xmath8 and the @xmath20 edge in the sorted order of vertex @xmath9 . with this interpretation , we can compute a shortest path from @xmath40 to the pairs @xmath45 , in @xmath37 time ( the graph of pairs has @xmath46 vertices and edges ) .",
    "if we denote by @xmath18=the length of the shortest path from @xmath40 to @xmath39 , then the answer is computed the same as before .",
    "we are given a ( directed ) graph @xmath47 with @xmath1 vertices and @xmath2 edges .",
    "each ( directed ) edge @xmath48 has two associated values : @xmath49 and @xmath50 , and each vertex @xmath8 has two associated values : @xmath51 and @xmath52 ( e.g. these values could be bandwidth , cost , or latency ) .",
    "we want to find a subset of edges @xmath53 ( vertices @xmath54 ) having a specified property @xmath55 , such that its ratio is maximum ( minimum ) .",
    "the ratio @xmath56 of a subset of edges @xmath53 ( vertices @xmath54 ) is defined as @xmath57 ( @xmath58 ) .",
    "we will use a technique which was previously discussed in other research papers @xcite for solving other optimization problems .",
    "let s consider the following problem : we are given a ( directed ) graph @xmath47 with @xmath1 vertices and @xmath2 edges .",
    "each ( directed ) edge @xmath48 ( vertex @xmath8 ) has a weight @xmath59 ( @xmath60 ) , which may be zero , positive or negative .",
    "we want to find a subset of edges @xmath53 ( vertices @xmath54 ) satisfying property @xmath55 , such that the sum of the weights of the edges @xmath61 ( vertices @xmath62 ) is maximum ( minimum ) .",
    "we will denote the optimization algorithm by @xmath63 , where @xmath47 is the graph .",
    "@xmath63 returns the weight of the subset of edges ( vertices ) .",
    "the algorithm will compute several other values , based on which we will easily be able to find the subset of edges ( vertices ) itself ( not just its weight ) . with this algorithm , we will be able to solve the maximum ( minimum ) ratio problem as follows .",
    "we will binary search the maximum ( minimum ) ratio @xmath64 in the interval @xmath65 $ ] , where @xmath66 is a good upper bound ( e.g. @xmath66 is the maximum among the @xmath67 ( @xmath68 ) values , divided by the minimum among the @xmath69 ( @xmath70 ) values ) . for a candidate value @xmath71 , we will construct a graph @xmath72 having the same set of edges and vertices . the weight of a ( directed ) edge @xmath48 ( vertex @xmath8 ) in @xmath72 , @xmath59 ( @xmath60 ) , will be @xmath73 ( @xmath74 ) . we will now call @xmath75 and store its value as @xmath76 . if @xmath77 , then @xmath71 is larger than the maximum ( minimum ) ratio and we need to consider smaller values ; otherwise , @xmath78 and we can test larger values .",
    "the binary search ends when the length of the search interval becomes smaller than @xmath79 ( where @xmath80 is a very small constant ) .",
    "we will now provide a few examples of optimization problems and algorithms ( @xmath81 ) which can be fit into the generic framework introduced earlier .",
    "given a directed graph @xmath47 with @xmath1 vertices ( numbered from @xmath0 to @xmath1 ) and @xmath2 edges , where each directed edge @xmath48 has a weight @xmath59 ( which may be zero , negative or positive ) and a length @xmath82 , we want to find a ( possibly self - intersecting ) path ( cycle ) of total length at least @xmath83 and at most @xmath84 , whose total weight is maximum .",
    "we will present a pseudo - polynomial algorithm , for the case when the edge lengths are integers . for the path case",
    ", we will compute for each vertex @xmath28 and each number of edges @xmath85 , the value @xmath86=the maximum total weight of a path with length @xmath85 , which ends at vertex @xmath28 .",
    "we have @xmath87 and for @xmath88 , we have @xmath89 or @xmath90 , if no edge @xmath91 with @xmath92 exists . the maximum total weight of an optimal path is @xmath93 .",
    "the time complexity is @xmath94 .",
    "for the cycle case , we consider every possible starting vertex @xmath3 and run the algorithm described above , except that @xmath95 and @xmath96 .",
    "the weight of the optimal cycle starting at vertex @xmath3 is @xmath97 . when there is no constraint on the length of the path ( cycle ) , we first need to decide if the graph contains a cycle whose total weight is positive . if it does , then the weight of the optimal path ( cycle ) is @xmath98 .",
    "we will perform this checking by computing a value @xmath99 for each vertex @xmath28 , using the bellman - ford - moore algorithm .",
    "we initialize @xmath100 and insert all the vertices into a queue @xmath101 .",
    "afterwards , we repeatedly extract from @xmath101 the first vertex @xmath28 , consider all the directed edges @xmath102 ( from @xmath28 to @xmath29 ) and update @xmath103 . if @xmath104 , then we set @xmath105 and insert the vertex @xmath29 at the end of the queue ( if it is not already in the queue ) .",
    "we will also maintain a counter @xmath106 for each vertex @xmath28 , denoting the number of times vertex @xmath28 was inserted into the queue . if , at some point , we have @xmath107 for some vertex @xmath28 , then a cycle with total positive weight exists in the graph . if the algorithm ends without finding a positive cycle , then the maximum total weight of a cycle is @xmath4 and that of a path is @xmath108 .",
    "the time complexity of the algorithm in this case is @xmath109 .",
    "when the graph is a directed path , i.e. we have only the edges @xmath110 ( @xmath111 ) , the optimal path problem can be solved with a better time complexity .",
    "the unconstrained version is equivalent to computing a maximum sum segment in the sequence of @xmath112 weights @xmath113 .",
    "the length constrained version is equivalent to the length constrained maximum sum segment problem .",
    "we consider here a minimum cost spanning tree problem , augmented with special offers .",
    "we have an undirected graph with @xmath1 vertices ( numbered from @xmath0 to @xmath1 ) and @xmath2 edges .",
    "each edge @xmath7 connects two different vertices @xmath114 and @xmath115 , has an owner @xmath116 and two prices : @xmath117 and @xmath118 .",
    "@xmath117 is the normal price of the edge and @xmath118 is the special price of the edge ; @xmath119 .",
    "there are @xmath120 owners overall , numbered from @xmath0 to @xmath120 .",
    "each owner has a special offer : it allows us to pay the special prices for any edges we want owned by that owner , with the condition that we do not take the special offer of any of the other owners .",
    "we want to establish a minimum cost spanning tree of the graph , by using at most one special offer of one of the edge owners .    at first",
    ", we will compute the minimum spanning tree of the graph considering normal prices for all the edges ( in @xmath121 or @xmath122 time ) .",
    "let @xmath123 be the set of @xmath112 edges composing the `` normal '' minimum spanning tree and let @xmath124 be the cost of the minimum spanning tree considering the normal prices .",
    "we will now consider every owner @xmath28 ( from @xmath0 to @xmath120 ) and compute the minimum spanning tree in the case when we take advantage of owner @xmath28 s special offer , i.e. when we consider the special prices for all the edges owned by @xmath28 .",
    "we can recompute each such spanning tree in the same time complexity as when we computed the first minimum spanning tree , but the overall time complexity would be @xmath125 or @xmath126 .",
    "instead , we will proceed as follows .",
    "when computing the minimum spanning tree for the special offer of the owner @xmath28 , we will consider only the subset of edges @xmath127 composed of all the edges owned by @xmath28 ( for which we consider their special prices ) and all the edges from @xmath123 which are not owned by @xmath28 , for which we consider their normal price .",
    "then , we will compute the minimum spanning tree using only the edges in @xmath127 .",
    "note that any edge outside of @xmath127 can not be part of this minimum spanning tree .",
    "thus , the time complexity for one minimum spanning tree computation is @xmath128 or @xmath129 .",
    "the sum of the values @xmath130 @xmath131 is at most @xmath132 .",
    "thus , the overall time complexity will be @xmath133 or @xmath134 , which is much better than that of the trivial algorithm .    for a more in - depth analysis of this problem ( which considers several other constraints and other types of minimum spanning tree algorithms ) ,",
    "see @xcite ( a book based on the first author s ph.d .",
    "in this section we propose a novel architecture of an agent - based peer - to - peer content delivery framework in which data transfer optimization techniques can be used .",
    "the problems posed by this framework are mainly online , but we will also discuss a semi - offline problem in the last subsection . note that we are only presenting the generic principles and guidelines in this section , and not a full implementation .",
    "each agent ( which will be called _ peer _ from now on ) of the peer - to - peer framework has an identifier which is a point in a d - dimensional space ( in which the range of the coordinates in each dimension @xmath28 is @xmath135 $ ] ) .",
    "the identifiers can be self - generated ( e.g. by using hash functions which generate unique values with high probability ) , or may be computed according to some specific rules ( e.g. they may be mapped in the latency space ) @xcite .",
    "the peers interconnect in a peer - to - peer topology by using a distributed decision making mechanism .",
    "in @xcite we presented a generic framework for constructing a peer - to - peer topology based on the peers geometric coordinates .",
    "several methods for choosing neighbors are also described in @xcite , out of which we would like to highlight the _",
    "hyperplanes _ method .",
    "this method makes use of a set of hyperplanes , all of which contain the origin .",
    "these hyperplanes form @xmath101 disjoint regions , whose union is the entire hyper - space .",
    "when a peer @xmath136 has to choose its neighbors from a set @xmath137 , it will divide the peers @xmath138 from @xmath137 according to which region ( among the @xmath101 regions ) they belong to ( when peer @xmath136 is considered to be the origin ) and then it will select as neighbors the closest @xmath139 peers from each region ( @xmath139 may be different for each region and for each peer ) .",
    "closeness may be defined using any geometric norm @xmath140 ( @xmath141 ) .",
    "the peers periodically broadcast their existence a number of hops away in the topology and the set @xmath137 is composed of those peers @xmath138 which broadcasted their existence to @xmath136 recently .",
    "the topology changes as the sets @xmath142 change and the peers select new neighbors , until it reaches an equilibrium ( if no new peer joins the system and no old peer leaves it ) .    in order for the peer - to - peer topology construction mechanism to work properly",
    ", we assumed that all the peers are connectable ( i.e. they have public ip addresses and are not located behind a firewall ) .",
    "note that the system may still work if , whenever a connectable peer @xmath136 selects an unconnectable peer @xmath138 as its neighbor , @xmath138 also selects @xmath136 as a neighbor . in order to handle unconnectable peers we consider assigning coordinates at the edge of the multidimensional space to these peers . this way we expect that an unconnectable peer @xmath138 is less likely to be selected as a neighbor by a connectable peer @xmath136 which is not selected back as a neighbor by @xmath138 .",
    "this does not solve the problem of two unconnectable peers which may select each other as neighbors .",
    "we assume that every peer can detect if it is unconnectable ( this may be easier when the peer has a private ip address than when it is located behind a firewall ) .    in order to send data from one peer to another , we can employ geometric routing ( i.e. we repeatedly forward the data to a neighbor which is closer in the geometric space to the destination ) , or we can use multi - path routing mechanisms @xcite .    searching for a piece of content is not within the scope of this paper .",
    "nevertheless , when the content units have a set of index properties , the approach from @xcite can be used in order to obtain references to every content unit ( or at most a number @xmath143 of them ) whose properties are within a specified multidimensional range .",
    "once we have a reference to a content unit , we can initiate a data transfer from its owner .",
    "except for point - to - point data transfer services , we are interested in supporting multicast communication services within the peer - to - peer architecture . in the following two subsections",
    "we will propose two different methods for achieving this .",
    "we will first present a generic method for constructing multicast trees on demand .",
    "then , we will discuss the problem of maintaining a multicast tree with improved stability , when we have extra information regarding the peers life times .      in order to support multicast communication services , we propose building a multicast tree on demand on top of the peer - to - peer topology .",
    "many spanning tree construction algorithms for arbitrary topologies have been proposed in the literature @xcite .",
    "however , the topology proposed in the previous section has a special geometric structure .",
    "thus , we propose the following high - level construction method .",
    "one of the peers @xmath56 will initiate the multicast data transfer .",
    "let s denote by @xmath144 the zone for which a peer @xmath136 will be responsible .",
    "@xmath145 will be the entire geometric space .",
    "let s assume that a peer @xmath146 received a message with the value of @xmath147 ( peer @xmath56 is considered to receive such a virtual message in the beginning ) .",
    "then , @xmath146 will select a subset of its neighbors @xmath148 which are located within @xmath147 and will construct tree edges from itself towards the peers @xmath149 in @xmath148 .",
    "then , a disjoint zone @xmath150 of the space is computed by peer @xmath146 for each peer @xmath149 in @xmath148 , such that : @xmath151 every zone @xmath150 is fully contained in @xmath147 ; @xmath152 every peer @xmath153 whose coordinates",
    "are within @xmath147 ( except for @xmath146 and the peers from @xmath148 ) must be located within one of the zones @xmath150 ( @xmath154 ) . when using the hyperplanes neighbor selection methods ,",
    "the zones @xmath150 can be computed by clipping the zone @xmath147 with a subset of hyper - planes ( thus , the zones are convex ) .",
    "then , peer @xmath146 sends the message with @xmath150 to every peer @xmath149 from @xmath148 .",
    "the time complexity of this algorithm is optimal , being proportional to the diameter of the underlying peer - to - peer topology .    in some cases",
    ", we may decide that the zones @xmath150 of the peers @xmath154 do not have to be disjoint ( but their union may be equal to @xmath147 ) .",
    "non - disjointness may imply that some peers will end up receiving the data multiple times .",
    "this is acceptable if a peer can detect that the received data is duplicate ( i.e. the data packets have unique identifiers ) and if the complexity of computing non - disjoint zones @xmath150 would be too high ( either from a computational point of view , or because the description complexity of @xmath150 would be too high ) .",
    "the multicast tree constructed by this method would stay alive only as long as data is transferred along its edges ( each edge would have its own expiration timer ) .",
    "a new tree would be constructed for every multicast flow .",
    "although this generates a tree construction overhead for each flow , it is more robust in the presence of node failures ( because the trees are not long - lived , they are less likely to experience node failures or departures ) .      in this subsection",
    "we consider the following scenario .",
    "let s assume that every peer @xmath136 that enters the peer - to - peer system knows the time moment @xmath155 when it will leave the system ( and can guarantee that it will stay within the system until the moment @xmath155 ) .",
    "we would like to use this information in order to construct and maintain a multicast tree with improved stability .    a method of achieving this is the following .",
    "the coordinates of a peer @xmath136 will be of the form @xmath156 ( where @xmath157 can be generated the way we discussed earlier ) .",
    "then , the peer @xmath136 will join the peer - to - peer topology .",
    "once its neighbors are stable ( i.e. peer @xmath136 does not select new neighbors for at least @xmath158 consecutive gossiping periods ) , peer @xmath136 will choose one of its neighbors @xmath138 from the peer - to - peer topology as its neighbor in the tree",
    ". we will refer to @xmath138 as peer @xmath136 s preferred neighbor ( @xmath159 ) .",
    "the set of candidate peers @xmath160 from which @xmath161 can be chosen consists of those peers @xmath138 which are neighbors with @xmath136 in the topology and have @xmath162 .",
    "if @xmath136 has no neighbor @xmath138 with @xmath162 then @xmath136 has the highest value of @xmath155 from the system . in this case , @xmath160 consists of all of @xmath136 s neighbors within the peer - to - peer topology .",
    "the preferred neighbor @xmath161 may be chosen arbitrarily from @xmath160 , but we could also use other rules .",
    "for instance , for each peer @xmath138 , we may impose an upper bound @xmath163 on the number of peers @xmath164 for which @xmath165 .",
    "then , we need to remove from @xmath160 those peers @xmath138 which have already reached their limit . among the remaining peers",
    "we could choose the one with smallest maximum distance from itself towards some other peer in the tree ( the distance is equal to the number of tree edges which need to be traversed from one peer to another ) , in order to minimize the tree diameter .",
    "such information can be maintained through gossiping in the multicast tree ( see , for instance , @xcite ) .",
    "if all the peers in @xmath160 have reached their upper limit , then we may decide to either break one of these limits ( e.g. by choosing the peer @xmath166 with the smallest degree ) or we could replace a tree edge @xmath167 ( where @xmath166 ) .",
    "the tree edge would be replaced by the edges @xmath168 and @xmath169 . in this case",
    ", it might be better to choose that tree edge @xmath167 for which the maximum distance from @xmath164 towards a peer in its subtree ( @xmath170 if we use the notations from @xcite ) is minimum ( also in order to try to minimize the diameter ) .",
    "replacing these edges also implies replacing the corresponding preferred neighbors : if @xmath165 then we will set @xmath171 and @xmath159 ; otherwise , we will set @xmath172 and @xmath173 .    with this method of constructing the tree ,",
    "the peers @xmath136 with smaller values of @xmath155 will be located towards the edge of the tree .",
    "thus , when a peer leaves the system , it will be a leaf in the tree and its departure will not disconnect the tree .",
    "this saves us from the need of taking special measures in case of unexpected peer departures which may leave the multicast tree disconnected .    a situation in which the peers @xmath136 may know exactly the values @xmath155 is in the case of virtual machines ( vms ) deployed in clouds .",
    "if a cloud computing resource is leased for a fixed amount of time in order to run a virtual machine , then the virtual machine may know the amount of time left before it is powered off .",
    "note also that since leasing virtual machines involves a certain service level agreement ( sla ) , we can count on the fact the the vm will be running for the specified amount of time without interruptions . in a way",
    ", we are transferring the reliability of the sla negotiated with the cloud service provider in order to construct a reliable ( and stable ) multicast tree on top of a flexible peer - to - peer topology .",
    "for other scenarios , the assumption of knowing the exact time when the peer leaves the system leads to a semi - offline problem .",
    "we are interested in constructing a permutation with @xmath1 elements , such that , for every two distinct values @xmath174 and @xmath175 ( @xmath176 ) of the same parity , the position @xmath85 on which the element @xmath177 is located must satisfy the condition : @xmath178 or @xmath179 , i.e. the average value must not be located in between the two values in the permutation .",
    "an @xmath180 divide - and - conquer algorithm is not difficult to obtain .",
    "we notice that we can have all the @xmath181 even numbers located before all the @xmath182 odd numbers in the permutation .",
    "then , we need to solve the same problem for @xmath181 and @xmath182 elements . we can obtain a valid @xmath1-element permutation as follows .",
    "we multiply each number in the @xmath183-element solution by @xmath184 , thus obtaining all the even numbers in the set @xmath185 . afterwards , we turn every element @xmath120 in the @xmath186-element solution into @xmath187 and obtain all the odd numbers in the set @xmath188 . by concatenating the two sequences , we obtain the desired permutation .",
    "the time complexity is obviously @xmath180 , because , at each step , we need to solve two approximately equal problems . the base case is @xmath189 , where the only existing permutations is the solution .",
    "we can improve the time complexity to @xmath190 as follows :    * if @xmath191 , then we will call the algorithm for @xmath192 and @xmath192 . *",
    "if @xmath193 , then we will call the algorithm for @xmath192 and @xmath194 . at the next level , however , for the @xmath192-element solution , we will need to solve two @xmath85-element problems , and for the @xmath194-element solution , we will need to solve a @xmath85-element problem and one @xmath195-element problem . * for @xmath196",
    ", we will need to solve two @xmath194-element problems at the next level . *",
    "if @xmath197 , then we will call the algorithm for @xmath194 and @xmath198 . at the next level , however , for the @xmath194-element solution , we will need to solve one @xmath85-element problem and one @xmath195-element problem , and for the @xmath198-element solution , we will need to solve two @xmath195-element problems .",
    "what we notice is that at every level of the recursion , there are at most two distinct ( sub)problems to be solved .",
    "thus , there are only @xmath199 distinct subproblems to solve .",
    "we can use the memoization technique .",
    "after computing a valid @xmath85-element permutation , we store it and retrieve it immediately whenever we require it again . thus ,",
    "at subsequent calls , the time complexity will be @xmath200 , instead of @xmath201 .",
    "because the sizes of the problems at each level decrease exponentially , the total sum of the sizes of the computed permutations is @xmath190 .",
    "thus , the overall time complexity is @xmath190 .",
    "a simpler @xmath190 solution is to consider the largest value @xmath202 such that @xmath203 .",
    "then , we solve the problem for a permutation with @xmath2 elements ( which always has only one ( sub)problem to solve at each recursion level ) and we simply remove all the elements @xmath204 from the obtained permutation .",
    "we consider a permutation with @xmath1 elements .",
    "we want to sort ( ascendingly ) this permutation by performing only operations of the following type : ( case @xmath0 ) we choose a position @xmath28 ( @xmath205 ) and : all the numbers on the positions @xmath206 are rotated one position to the left ( or right , or we can choose the direction of the rotation ) , and all the numbers on the positions @xmath207 are rotated one position to the right ( or left , or we can choose the direction of the rotation ) ; ( case @xmath184 ) we choose a position @xmath28 ( @xmath208 ) and all the numbers on the positions @xmath209 are rotated @xmath0 position to the left ( or right , or we can choose the direction of the rotation ) , and all the numbers on the positions @xmath207 are rotated @xmath0 position to the right ( or left , or we can choose the direction of the rotation ) ; if @xmath210 then the element on the position @xmath28 is not moved",
    ".    we will first consider case @xmath0 .",
    "we repeatedly choose position @xmath1 , until element @xmath0 is on the first position of the permutation .",
    "then , the problem is solved incrementally . at step @xmath85 ( @xmath211 ) , we have all the numbers from @xmath0 to @xmath212 on the positions @xmath213 .",
    "we now want to bring number @xmath85 on position @xmath85 ( unless it s already there ) . in order to achieve this",
    "we will perform the following steps :    1 .",
    "we will repeatedly choose position @xmath4 , until number @xmath85 is on the last position of the permutation .",
    ", we repeatedly choose position @xmath112 , until the numbers @xmath213 are located on the positions @xmath214 ( at every rotation , number @xmath85 remains on the last position of the permutation ) .",
    ", we repeatedly choose position @xmath1 , until the numbers @xmath215 are located on the positions @xmath215 .",
    "case @xmath184 can be solved using a similar strategy . at the first step",
    "we rotate the entire permutation , until element @xmath0 is located on position @xmath0 ( e.g. by repeatedly choosing @xmath216 )",
    ". then , at each step @xmath85 ( @xmath211 ) , we choose position @xmath217 until element @xmath85 reaches position @xmath1 .",
    "afterwards , we repeatedly choose the position @xmath218 , until the numbers @xmath213 are located on the positions @xmath214 . then , we repeatedly choose @xmath216 , rotating the entire permutation until the numbers @xmath215 are located on the positions @xmath215 .    in both cases we have to perform @xmath219 operations . if we actually perform the rotations at every operation , the overall time complexity of the algorithm becomes @xmath220 . in order to maintain the @xmath219 time complexity",
    ", we notice that we do not actually have to perform every operation .",
    "for instance , if , during the algorithm , we choose @xmath221 times consecutively the same position @xmath28 , this is equivalent to rotating the two sides of the permutation by @xmath221 positions .",
    "thus , when we want to move a number @xmath85 on the last position of the permutation we compute the number @xmath222 of operations which need to be performed ( @xmath223 for rotations to the left , or @xmath224 for rotations to the right , where @xmath225 is the current position of element @xmath85 in the permutation ) .",
    "then , when we need to move all the numbers @xmath215 from the positions @xmath226 of the permutation to the positions @xmath227 ( @xmath215 ) of the permutation and they are located in a part containing the positions @xmath228 ( @xmath229 or @xmath230 ) , we will compute the number @xmath231 of operations which need to be performed : @xmath232 ( if @xmath233 ) or @xmath234 ( if @xmath235 ) for rotations to the left ; @xmath236 ( if @xmath237 ) or @xmath238 ( if @xmath239 ) for rotations to the right . then , for each such values @xmath222 and @xmath231 we just perform a rotation by a multiple number of positions ( in @xmath190 ) time .",
    "this way , we only perform @xmath36 rotations per step , obtaining an @xmath219 time complexity .",
    "we consider a permutation of the numbers @xmath240 again .",
    "we want to sort this permutation ascendingly , by using the following type of operations : we choose a position @xmath221 and : all the elements on the positions @xmath241 are reversed , and all the elements on the positions @xmath242 are also reversed .",
    "for instance , if the permutation is @xmath243 and we choose a position @xmath221 , the new permutation will be : @xmath244 .",
    "we can also choose the positions @xmath245 and @xmath246 .",
    "we will present a solution which performs @xmath190 operations . at the first operation we will identify the position @xmath221 on",
    "which element @xmath0 is located .",
    "then , we will choose the position @xmath247 ( and we perform the operation ) .",
    "at the beginning of each step @xmath85 ( @xmath211 ) the numbers @xmath213 will be located on the positions @xmath213 of the permutation , but in reverse order . the steps to be performed",
    "are the following :    1 .",
    "let @xmath221 be the position on which element @xmath85 is located .",
    "we perform an operation by choosing the position @xmath221 . now",
    ", the permutation contains the elements @xmath215 on the positions @xmath248 , in increasing order .",
    "3 .   after this , we will choose the position @xmath247 , which will move the elements @xmath215 on the first @xmath85 positions , in reverse order .",
    "4 .   in the end",
    ", we perform one extra operation : we choose the position @xmath4 .",
    "the algorithm performs @xmath190 operations and the total time complexity is @xmath219 ( @xmath190 per operation ) .",
    "we consider a permutation of the numbers @xmath240 .",
    "we want to sort this permutation ascendingly by performing swaps . a call @xmath249 swaps the elements on the positions @xmath250 and @xmath251 of the permutation",
    ". however , we can only call @xmath249 for certain pairs of positions @xmath252 .",
    "a simple solution is the following .",
    "we construct a graph @xmath47 in which every vertex corresponds to a position of the permutation and we have an edge between vertices @xmath28 and @xmath29 if the call @xmath253 is permitted .",
    "the presented algorithm runs in @xmath1 steps . at step @xmath28",
    ", all the numbers @xmath209 are already on the positions @xmath209 and we will bring element @xmath28 on position @xmath28 ( without changing the positions of the elements @xmath209 ) .",
    "if element @xmath28 is not already on position @xmath28 at step @xmath28 , then we perform the following actions :    1 .",
    "we search for a path in @xmath47 from the vertex corresponding to the current position @xmath221 of the element @xmath28 to the vertex corresponding to position @xmath28 ; let this path be @xmath254 2 .",
    "we perform , in this order , the calls : @xmath255 , @xmath256 @xmath257 @xmath258 @xmath259 @xmath260 ( i.e. we call @xmath261 for @xmath262 in increasing order of @xmath29 ) 3 .",
    "we perform the following calls : @xmath263 for @xmath264 in decreasing order of @xmath29    we notice that after the swaps performed at step @xmath184 , element @xmath28 arrives on position @xmath28 , but many of the other elements may have been moved away from their positions . after performing step @xmath265 however , all the elements are brought back to their original positions ( i.e. those before the swaps at step @xmath184 ) , except for the element",
    "@xmath120 which was previously located on position @xmath28 , and which will now be located on position @xmath221 .",
    "step @xmath0 can be implemented in @xmath266 time ( where @xmath2 is the number of edges of @xmath47 ) , using any graph traversal algorithm ( e.g. dfs or bfs ) .",
    "steps @xmath184 and @xmath265 are trivially implemented in @xmath267 time .",
    "thus , the total time complexity is @xmath268 .",
    "if we initially split @xmath47 into connected components and maintain only a spanning of each connected component , then we can find a path between two positions @xmath221 and @xmath28 in @xmath190 time ( if it exists ) , because we will only consider the @xmath190 edges of a spanning tree .",
    "thus , the overall time complexity becomes @xmath219 .",
    "we consider a permutation @xmath269 of the numbers @xmath240 .",
    "we want to sort this permutation ascendingly by using swaps .",
    "each number @xmath28 ( @xmath210 ) has a cost @xmath270 .",
    "the cost of swapping two elements @xmath271 and @xmath272 in the permutation is @xmath273 .",
    "we want to find a minimum cost strategy which sorts the permutation .",
    "we will construct a graph with @xmath1 vertices , one for each number in the permutation , and @xmath1 directed edges : @xmath274 ( @xmath210 ) .",
    "this graph is a union of disjoint cycles .",
    "we will consider every cycle @xmath275 containing at least two vertices . for each vertex @xmath28 on the cycle ,",
    "let @xmath276 be the vertex following @xmath28 on @xmath275 and @xmath277 be the vertex preceeding @xmath28 on @xmath275 .",
    "we have two options for bringing the values of the vertices on @xmath275 on their corresponding positions .",
    "the first choice is the following :    1 .",
    "let @xmath120 be the vertex of @xmath275 with the minimum cost @xmath278 .",
    "2 .   we will repeatedly swap @xmath120 with every vertex on @xmath275 , starting from @xmath279 and moving in reverse direction of the edges along @xmath275 .",
    "3 .   let @xmath280 be the sum of the costs of the vertices on @xmath275 and let @xmath85 be the number of vertices on @xmath275 .",
    "the cost of performing these swaps is @xmath281 .",
    "the second choice is the following :    1 .",
    "let @xmath282 be the element with the smallest value @xmath283 in the entire permutation .",
    "we swap the elements @xmath120 and @xmath282 , and then we perform the same swaps as before , only using the element @xmath282 instead of @xmath120 .",
    "3 .   in the end , we swap @xmath120 and @xmath282 again ( thus , @xmath120 also reaches its final position ) .",
    "the cost of this choice is @xmath284 ( where @xmath280 and @xmath85 have the same meaning as before ) .    for each cycle @xmath275 we will select the choice with the smallest cost .",
    "the time complexity of the algorithm is @xmath190 .",
    "we consider a multi - permu - tation @xmath269 , in which every number from @xmath0 to @xmath85 occurs at least once .",
    "we want to _ circularly sort _ the multi - permutation by performing swaps .",
    "the multi - permutation is circularly sorted if it is a circular permutation of the multi - permutation in which all the numbers of @xmath221 are sorted ascendingly . in order to sort the multi - permutation we can perform swaps .",
    "the cost of swapping the numbers on the positions @xmath28 and @xmath29 is @xmath285 .",
    "we want to minimize the total number of swaps first and , if there are multiple strategies with the same number of swaps , we want to minimize the total cost of the performed swaps .",
    "we will first use count - sort in order to construct in @xmath286 time the ascending order of the values : @xmath287 .",
    "then , we will consider every circular permutation of @xmath287 .",
    "let @xmath288 be such a circular permutation .",
    "we will compute the best strategy ( minimum number of swaps and minimum total cost ) in order to sort the multi - permutation @xmath221 in the order given by @xmath120 .    for every value @xmath28 ( @xmath289 ) we will compute the list @xmath290 of positions on which it occurs in @xmath221 and the list @xmath291 of positions on which it occurs in @xmath120 . the lists @xmath290 and @xmath291",
    "are sorted ascendingly .",
    "both sets of lists ( @xmath292 and @xmath293 ) can be constructed in overall linear time , as follows : we traverse the multi - permutation @xmath221 ( @xmath120 ) from the position @xmath0 to @xmath1 and we add each position @xmath28 at the end of @xmath294 ( @xmath295 ) ( all the lists are empty before the traversal ) .",
    "the lists @xmath290 need only be computed once , in the beginning ( before considering the first circular permutation @xmath120 ) .",
    "then , we will initialize two variables : @xmath296 and @xmath297 . for each value @xmath28 ( @xmath289 ) we will merge the lists @xmath290 and @xmath291 into a list @xmath298 . then",
    ", we will traverse the list @xmath298 from the beginning to the end .",
    "every time we find two consecutive equal elements @xmath271 in @xmath298 , we add @xmath271 to another list @xmath299 ( which is empty before we start traversing the list @xmath298 ) .",
    "then , we will `` merge '' the lists @xmath290 ( @xmath291 ) and @xmath299 into a list @xmath300 ( @xmath301 ) . during the merge ,",
    "as long as we havent reached the end of any of the two lists , if the current element of @xmath290 ( @xmath291 ) is equal to the current element of @xmath299 then we do not add any of them to @xmath300 ( @xmath301 ) and we simply move to the next elements ; if they are different , then we add the current element of @xmath290 ( @xmath291 ) to the end of @xmath300 ( @xmath301 ) . in the end , if any elements from @xmath290 ( @xmath291 ) were not considered before considering all the elements of @xmath299 , we add these elements , in order , to the end of @xmath300 ( @xmath301 ) .    the lists @xmath300 and @xmath301 are sorted ascendingly and contain the positions @xmath302 on which the element @xmath28 occurs in @xmath221 and , respectively , in @xmath120 , but it does not occur on the same position in the other multi - permutation ( @xmath120 , respectively @xmath221 ) .",
    "let @xmath303 denote the @xmath44 element of a list @xmath304 .",
    "we set @xmath305 to the number of elements in @xmath300 .",
    "then , we traverse the elements of @xmath300 and we increase @xmath306 by @xmath307 ( @xmath29 is the current position of the element from @xmath290 ; initially , @xmath297 ) .",
    "@xmath305 is the minimum number of required swaps and @xmath306 is the minimum total cost ( for performing @xmath305 swaps ) .",
    "if we were only interested in the minimum total cost , then we would use @xmath290 ( @xmath291 ) instead of @xmath300 ( @xmath301 ) when computing the cost @xmath306 .",
    "we will maintain the pair @xmath308 with the minimum value of @xmath305 ( and , in case of ties , with the minimum value of @xmath306 ) .",
    "the time complexity is linear for each multi - permutation @xmath120 . since we consider @xmath1 multi - permutations @xmath120 , the overall time complexity is @xmath219 .",
    "we consider two multi - permutations with @xmath1 elements : @xmath269 and @xmath288 .",
    "both @xmath221 and @xmath120 contain values from @xmath0 to @xmath85 and , moreover , they contain the same number of values @xmath28 ( @xmath289 ) , i.e. @xmath120 is obtained from @xmath221 by permuting its numbers somehow .",
    "we want to transform @xmath221 into @xmath120 by performing the following type of move : we can select a position @xmath28 ( @xmath111 ) and swap the values @xmath174 and @xmath309 .",
    "we want to compute the minimum number of swaps required to transform @xmath221 into @xmath120 .    we will construct a permutation @xmath282 of the numbers @xmath240 , as follows .",
    "we first traverse the permutation @xmath120 from position @xmath0 to @xmath1 and , for every position @xmath28 , we add @xmath28 at the end of a list @xmath310 ( we maintain @xmath85 lists @xmath311 which are initially empty ) .",
    "then , we initialize an array @xmath312 ( @xmath289 ) to @xmath4 and we traverse the permutation @xmath221 from the first to the @xmath313 position . for every position @xmath28 ( @xmath210 )",
    "we : @xmath151 increment @xmath314 ; @xmath152 set @xmath315 ( we denote by @xmath316 the @xmath317 element of the list @xmath318 ) .",
    "the minimum number of swaps required to turn @xmath221 into @xmath120 is equal to the number of inversions of the permutation @xmath282 .",
    "we can compute the number of inversions of a permutation @xmath282 using several algorithms .",
    "the first algorithm consists of extending the merge - sort algorithm .",
    "we will maintain a global variable @xmath319 ( which is initially @xmath4 ) .",
    "let s assume now that , during the merge - sort algorithm , we need to merge two sorted sequences , @xmath56 and @xmath149 ( with @xmath271 and , respectively , @xmath272 elements ) , where @xmath56 consists of elements located to the left of the elements in @xmath149 within @xmath221 . during the merging phase , we maintain two counters @xmath28 and @xmath29 ( initialized at @xmath0 ) , representing the current position in the sequences @xmath56 and , respectively , @xmath149 . if @xmath320 we add @xmath321 at the end of the sorted sequence and we increment @xmath28 by @xmath0 ; otherwise , we add @xmath322 at the end of the sorted sequence , we increment @xmath29 by @xmath0 and we increment @xmath319 by @xmath323 .",
    "when either @xmath28 exceeds @xmath271 or @xmath29 exceeds @xmath272 , the remaining elements are added to the end of the sorted sequence . in the end ,",
    "the number of inversions of @xmath282 is @xmath319 .",
    "the time complexity of this approach is @xmath180 .",
    "a second algorithm consists of using a segment tree .",
    "each of the @xmath1 leaves of the segment tree will have the values @xmath0 .",
    "inner nodes contain the sum of the values of the leaves in their subtrees .",
    "we will traverse the permutation @xmath282 from the position @xmath0 to position @xmath1 .",
    "like before , we will maintain the variable @xmath319 ( initialized to @xmath4 ) .",
    "for a position @xmath28 , we query the segment tree in order to find the sum @xmath324 of the leaves from the interval @xmath325 $ ]",
    ". we will increment @xmath319 by @xmath324 and , after this , we set the value of the leaf @xmath326 to @xmath4 ( also updating the values of the leaf s ancestors ) .",
    "the time complexity of this approach is also @xmath180 .",
    "if instead of the segment tree we use a block partition ( in which every position from @xmath0 to @xmath1 has an initial value of @xmath0 and , after considering the position @xmath28 , we set the value on the position @xmath326 to @xmath4 ) , we can obtain a time complexity of @xmath327 ( we denote by @xmath328 the square root of @xmath271 ) .",
    "the original problem can be solved with a linear ( @xmath190 ) time complexity if @xmath329 .",
    "we construct the lists of positions @xmath330 and @xmath331 on which the value @xmath0 occurs in @xmath221 and , respectively , @xmath120 .",
    "these lists are sorted ascendingly and can be constructed in @xmath190 time , as we discussed earlier .",
    "then , the total number of required swaps is equal to the sum of the values @xmath332 ( where @xmath333 the total number of values equal to @xmath0 in @xmath221 ) .",
    "note that in the case of the problem discussed in this section we can find the minimum number of swaps in @xmath180 time , but this number may be of the order @xmath219 . the strategy performing",
    "the swaps is quite straightforward .",
    "for every position @xmath28 from @xmath0 to @xmath1 , if @xmath334 we will find the element @xmath335 on the smallest position @xmath336 and we swap it repeatedly with the element to its left , until it arrives on the position @xmath28 .",
    "we consider a multi - permutation @xmath269 , which contains every element @xmath28 ( @xmath289 ) at least once .",
    "we want to rearrange the numbers in the multi - permutation such that all equal numbers are located on consecutive positions ( i.e. grouped together in a contiguous sequence ) . in order to achieve this",
    "we can swap any pair of adjacent values ( i.e. we can choose two positions @xmath28 and @xmath337 and swap the values @xmath174 and @xmath309 ; @xmath111 ) .",
    "we want to find a strategy which performs the minimum number of swaps .",
    "a first solution is the following .",
    "we will consider every possible permutation of the @xmath85 distinct values ( there are @xmath338 such permutations ) .",
    "then , let this permutation be @xmath339 .",
    "we will compute the minimum number of swaps required to bring all the values equal to @xmath340 first , then all the values equal to @xmath341 , and so on .    before considering any permutation",
    ", we will compute the values @xmath342 , where @xmath343=the number of elements equal to @xmath29 in the multi - permutation @xmath221 ( we have @xmath344 ) . then , for a given permutation @xmath339 , we will compute the values @xmath345 ( @xmath346 and @xmath347 ( these values are computed in the order given by the permutation @xmath120 ) .",
    "then , we initialize a set of values @xmath348 to @xmath4 and we traverse the multi - permutation @xmath221 ( from @xmath349 to @xmath1 ) . during the traversal we will construct a permutation @xmath282 . for each position @xmath28 of @xmath221 , we will first increment @xmath314 by @xmath0 and then we set @xmath350 . in the end",
    ", @xmath282 is a permutation and the minimum number of swaps required to sort the multi - permutation @xmath221 according to the constraints of the permutation @xmath120 is equal to the number of inversions of @xmath282 .",
    "computing the number of inversions of a permutation with @xmath1 elements can be performed in @xmath180 time , as was shown in the previous subsection .",
    "thus , we obtained an algorithm with a time complexity of @xmath351 .",
    "we can improve our solution as follows . in the beginning",
    "we will compute a @xmath352 matrix @xmath353 , where @xmath354=the number of pairs of positions @xmath102 , such that @xmath355 , @xmath356 , and @xmath176 .",
    "this matrix can be easily computed in @xmath219 time .",
    "we simply initialize it to all zeroes and then we consider every pair of positions @xmath102 ( @xmath357 ) and increment @xmath358 by @xmath0 .",
    "however , we can compute it more efficiently .",
    "we initialize the matrix to zero and then we traverse the multi - permutation from the position @xmath0 to @xmath1 .",
    "we will maintain an array @xmath359 , where @xmath343=the number of values equal to @xmath29 encountered so far .",
    "initially , @xmath360 . for every position @xmath28 ( @xmath210 ) we will consider every value @xmath29 ( @xmath361 ) and we will increment @xmath362 by @xmath343 ; after this , we increment @xmath363 by @xmath0 .",
    "thus , we computed the @xmath353 matrix in @xmath364 time .",
    "after computing the matrix @xmath365 we will consider again all the possible @xmath338 permutations @xmath339 of the distinct values of @xmath221 .",
    "for a given permutation @xmath339 , the minimum number of swaps required to sort the multi - permutation @xmath221 according to the constraints imposed by the permutation @xmath120 is equal to the sum of all the values @xmath366 with @xmath367 .",
    "thus , we obtained a solution with an @xmath368 time complexity . if we generate the @xmath338 permutations in the steinhaus - johnson - trotter order ( also called _ transposition order _ ) , then two consecutive permutations differ from each other in exactly two consecutive positions @xmath28 and @xmath337 .",
    "thus , for the first generated permutation we use the algorithm described above .",
    "then , when we generate a new permutation @xmath339 which differs from the previously generated permutation on the positions @xmath28 and @xmath337 , we will compute the number of swaps as follows .",
    "let @xmath54 be the number of swaps for the previous permutation .",
    "the number of swaps @xmath369 for the current permutation will be equal to @xmath370 .",
    "thus , the time complexity is now @xmath371 ( if we generate every new permutation in @xmath36 ( amortized ) time ) .",
    "another solution , also based on computing the matrix @xmath365 is to use dynamic programming .",
    "we will compute the values @xmath372=the minimum number of swaps required to bring the values belonging to the set @xmath324 in some order before all the other values of the multi - permutation ( and ignoring those values which are not part of @xmath324 ) .",
    "@xmath324 is a subset of @xmath373 .",
    "we will consider the subsets @xmath324 in increasing order of their number of elements ( or in lexicographic order ) .",
    "we have @xmath374 .",
    "for @xmath375 we proceed as follows . for every element @xmath28 from @xmath324 we will consider the case when the values equal to @xmath28 are placed last ( after all the other values in @xmath324 ) .",
    "we will compute @xmath376 plus the sum of the values @xmath377 , where @xmath378 and @xmath379 .",
    "we have @xmath380 .",
    "the final result is @xmath381 .",
    "the time complexity of this solutions is @xmath382 .",
    "this time complexity can be slightly improved as follows .",
    "initially , we will compute the values @xmath383 for every subset @xmath324 and every element @xmath384 , representing the sum of the values @xmath377 for @xmath378 and @xmath379 .",
    "we will compute these values in increasing order of the elements of @xmath324 ( or in lexicographic order of the subsets @xmath324 ) .",
    "we have @xmath385 .",
    "for @xmath386 let @xmath379 be an arbitrary element of @xmath324 .",
    "we have @xmath387 .",
    "this takes @xmath388 time overall .",
    "thus , in the algorithm from the previous paragraph we can compute @xmath389 in @xmath36 time instead of @xmath200 by using the value @xmath383 .",
    "the union - find problem consists of supporting efficiently the following two operations on a family of disjoint sets : _",
    "union(a , b ) _ performs the set union of the sets identified by @xmath56 and @xmath149 ; _",
    "find(x ) _ returns the identifier of the set which contains the element @xmath271 .",
    "the union - find problem has been studied extensively , due to its wide range of applications . in this section",
    "we propose several simple extensions , which , nevertheless , are important from a practical point of view .",
    "we consider the elements of each set arranged in a row . at",
    "first , we have @xmath1 elements , identified with numbers from @xmath0 to @xmath1 ; each element @xmath28 forms a set on its own and has a weight @xmath390 .",
    "we consider a sequence of two types of operations : _ union _ and _ query_. a union specifies the identifiers of two elements @xmath271 and @xmath272 and a direction @xmath5 ( _ left _ or _",
    "right _ ) .",
    "let @xmath391 be the identifier of the set containing @xmath271 and @xmath392 be the identifier of the set containing @xmath272 .",
    "the union operation combines the two sets into a single set , in the following way .",
    "if @xmath393 , then the elements of the set @xmath394 are placed to the left of those in the set @xmath395 ; otherwise , the elements of the set @xmath394 are placed to the right of those in the set @xmath395 .",
    "a query specifies an element @xmath271 and asks for the the aggregate weight of the elements @xmath272 in the same set as @xmath271 which are located ( strictly ) to the left of @xmath271 ( using a pre - specified aggregation function @xmath396 ) .",
    "we will represent the sets as rooted trees .",
    "the root of each tree will be the representative element ( the identifier ) of the set . for each element",
    "@xmath271 we store its parent in the tree ( @xmath397 ) , a value @xmath398 and the aggregate weight of the elements in its subtree ( @xmath399 ) .",
    "we first present a solution for the case when @xmath396 has an inverse @xmath400 .",
    "we initialize @xmath397 to @xmath401 , @xmath398 to the neutral element of @xmath396 ( e.g. @xmath4 , for @xmath402 , @xmath403 ; @xmath0 for @xmath404 ) and @xmath399 to @xmath405 for each element @xmath271 .    for a query operation with the argument @xmath271",
    ", the answer will be the aggregate of the @xmath406 values , where @xmath272 is an ancestor of @xmath271 in its tree ( including @xmath271 ) .    for a union operation ,",
    "we compute the representatives of the sets containing @xmath271 and @xmath272 , @xmath394 and @xmath395 , by following the parent pointers all the way up to the tree roots .",
    "we will use the _ union by rank _ heuristic .",
    "if the height ( or total number of nodes ) of the tree rooted at @xmath394 is smaller than or equal to that of the tree rooted at @xmath395 , we set @xmath407 ; otherwise , we set @xmath408 . after setting the parent pointer of one of the two representatives , we consider the direction @xmath5 of the union :    * if @xmath393 and @xmath407 , we set @xmath409 @xmath396 @xmath410 and , after this , @xmath411 @xmath396 @xmath412 . * if @xmath393 and @xmath408 , then we set @xmath413 @xmath396 @xmath414 @xmath396 @xmath415 . * if @xmath416 and @xmath407 , then we set @xmath417 @xmath396 @xmath418 @xmath396 @xmath412 . *",
    "if @xmath416 and @xmath408 , then we first set @xmath411 @xmath396 @xmath419 ; then , we set @xmath409 @xmath396 @xmath415 ( considering the updated value of @xmath420 ) .    in the end , if @xmath407 then we set @xmath421 @xmath396 @xmath410 ; otherwise , we set @xmath422 @xmath396 @xmath419 .",
    "since we use the union by rank heuristic , the height of every tree is @xmath199 .",
    "thus , performing a query takes @xmath199 time ( because an element has @xmath199 ancestors ) .",
    "we can improve the query time by also using the _ path compression _ heuristic .",
    "the path compression heuristic works as follows . every time we need to traverse all the ancestors of an element @xmath271 ( from @xmath271 towards the root of its tree )",
    ", we change the tree and make @xmath423 , where @xmath394 is the root of element @xmath271 s tree and @xmath272 is on the path between @xmath271 and @xmath394 ( including @xmath271 and excluding @xmath394 ) ; when doing this , we need to take care of also changing the values @xmath406 .",
    "let s assume that the path from @xmath271 to @xmath394 consists of the elements : @xmath424 , @xmath425 , @xmath426 , @xmath427 , @xmath428 ( the root ) . during a _",
    "find(x ) _ call or a query with argument @xmath271 , we compute @xmath429 @xmath396 @xmath427 @xmath396 @xmath430 ( @xmath431 ) ( @xmath432 @xmath396 @xmath433 and @xmath434 ) .",
    "we set @xmath435 to @xmath394 and we set @xmath436 to @xmath437 ( @xmath431 ) .",
    "the overall ( amortized ) time complexity becomes @xmath438 ) , where @xmath439 is the total number of operations and @xmath440 is the inverse of the ackermann function .",
    "we can also use the path compression technique without the complex union rules ( and/or heuristics ) , for the general case where @xmath396 is only commutative and associative ( e.g. @xmath441 , @xmath442 ) .",
    "we will maintain the @xmath399 values as before .",
    "each edge @xmath443 of a tree will have a value @xmath444 .",
    "when we unite two sets with representatives @xmath394 and @xmath395 such that the set @xmath394 will be located to the left of the set @xmath395 , we set @xmath408 and set @xmath445 . afterwards , we update @xmath410 ( we set it to @xmath410 @xmath396 @xmath419 ) . the aggregate weight of the elements located strictly to the left of an element @xmath271 is the aggregate of the @xmath446 values of the edges on the path from @xmath271 to its set representative ( tree root ) . at every @xmath447 ( or query with @xmath271 as an argument ) operation , we compute the set representative @xmath394 and then the values @xmath448 @xmath396 @xmath449 ( where @xmath272 is on the path from @xmath271 to @xmath394 , including @xmath271 ; @xmath450 , i.e. it is the neutral element of the aggregation function ) . then , we set @xmath423 for every node @xmath272 on the path from @xmath271 to @xmath394 ( including @xmath271 , if @xmath451 , and excluding @xmath394 ) , as well as @xmath452 .",
    "the solution presented so far for this problem considered the online case ( i.e. every query and union operation was handled as soon as it was received ) . in the offline case",
    "we can construct a somewhat simpler solution .",
    "we will first process all the union operations ( in order ) , ignoring the queries .",
    "like before , we will maintain disjoint sets with a tree structure .",
    "for each set with its representative @xmath394 we will maintain @xmath453 and @xmath454 , representing the index of the leftmost and rightmost elements in the set .",
    "initially , we have @xmath455 for every element @xmath271 . when we perform a union and the set identified by @xmath394",
    "is placed to the left ( right ) of the set identified by @xmath395 , we will add a directed edge from @xmath454 to @xmath456 ( from @xmath457 to @xmath453 ) .",
    "after this , if we need to set @xmath407 ( @xmath408 ) , then the new root @xmath282 will be @xmath395 ( @xmath394 ) .",
    "if @xmath394 was placed to the left of @xmath395 then we will have @xmath458 and @xmath459 ; otherwise , we will have @xmath460 and @xmath461 .",
    "after processing all the unions , we consider the graph composed of the @xmath1 elements as vertices and the added directed edges . from every vertex",
    "there is at most one outgoing edge .",
    "thus , the graph is the union of a set of disjoint chains ( directed paths ) .",
    "we will arrange all the elements consecutivey in the order in which they appear on their paths .",
    "then we will concatenate the orderings corresponding to each path , considering an arbitrary order of the paths .",
    "thus , we obtain a permutation @xmath269 , such that : if @xmath174 is not the rightmost element in its set , then @xmath309 is the element from its set which is immediately to its right .",
    "then , we will construct a 1d data structure @xmath462 over the ordering of these elements which will allow us to answer range queries efficiently ( a query consists of the aggregate weight of the elements @xmath463 whose positions are contained in a given range @xmath464 $ ] ) .",
    "if the @xmath396 function is invertible , we can compute prefix `` sums '' in order to answer a query in @xmath36 time .",
    "if @xmath396 is _ min _ or _ max _ we can preprocess the elements in order to answer range minimum ( maximum ) queries in @xmath36 time . otherwise , we can construct a segment tree over the @xmath1 elements which will allow us to answer aggregate queries in @xmath199 time .",
    "moreover , for each element @xmath28 ( @xmath210 ) we will store its position @xmath465 in this ordering ( i.e. @xmath466 ) . then , we will process the entire sequence of operations from the beginning .",
    "we reinitialize the disjoint sets and , like before , we will maintain the @xmath467 and @xmath468 values .",
    "this time we will also process the queries . in the case of a query for an element @xmath271 , we first compute @xmath394 the representative of the set containing @xmath271 .",
    "the answer to the query is obtained by range querying @xmath462 with the range @xmath469 $ ] .",
    "we will now present an extension of the split - find problem , which was brought to our attention by r. berinde .",
    "there are @xmath1 elements placed consecutively in a row ( from @xmath0 to @xmath1 ) .",
    "initially , they are all part of the same set ( interval ) .",
    "we can perform two types of operations .",
    "the operations may split an interval into two intervals or undo a split ( unite two intervals back into a larger interval ) . the only initial interval @xmath470 $ ] has color @xmath146 .",
    "the @xmath471 operation considers the interval @xmath464 $ ] starting at @xmath28 and a position @xmath85 ( @xmath472 ) .",
    "the interval @xmath464 $ ] is split into the intervals @xmath473 $ ] and @xmath474 $ ] .",
    "the interval @xmath473 $ ] is colored with color @xmath475 and the interval @xmath474 $ ] is colored using color @xmath476 .",
    "the @xmath477 operation considers a position @xmath85 where an interval @xmath464 $ ] was previously split and unites the two intervals @xmath473 $ ] and @xmath474 $ ] , thus forming the interval @xmath464 $ ] back .",
    "the interval @xmath464 $ ] will get the color it had before the split .",
    "obviously , this operation can only be used if the intervals obtained after the corresponding _ split",
    "_ exist ( i.e. they have not been split further or , if they have , they were put back together ) .",
    "a third operation @xmath478 asks for the color of the interval starting at position @xmath28 ( if such an interval exists ) .",
    "we will present here a solution which takes @xmath36 time per operation , no matter how the operations are mixed into the sequence of operations , and uses @xmath190 memory .",
    "we will maintain several arrays : @xmath479 , where @xmath480 if an interval starts at position @xmath28 ( and @xmath4 , otherwise ) ; @xmath481 , where @xmath482=the color of an interval starting at position @xmath28 ; @xmath483 , @xmath484 , @xmath485 , where the interval @xmath486 $ ] was the last interval split at the position @xmath85 and @xmath487=the color of the interval @xmath488 $ ] before the last split which had the position @xmath85 as a split parameter ; @xmath489 , where @xmath490=the finish endpoint of the interval starting at @xmath28 ( it makes sense only if @xmath480 ) .",
    "initially , we have @xmath491 , @xmath492 , @xmath493 and @xmath494 .",
    "a @xmath495 operation performs the following actions ( assuming @xmath480 ) :    1 .",
    "@xmath496 2 .",
    "@xmath497 3 .",
    "@xmath498 4 .",
    "@xmath499 5 .",
    "@xmath500 6 .",
    "@xmath501 7 .",
    "@xmath502 8 .",
    "@xmath503 9 .",
    "@xmath504    a @xmath478 operation returns @xmath482 , if @xmath480 , or @xmath505 , otherwise .",
    "@xmath477 performs three steps :    1 .",
    "@xmath506 2 .",
    "@xmath507 3 .",
    "@xmath508    we can also support an operation @xmath509 , having the same meaning as @xmath477 , except that the interval which is formed back will get the color @xmath510 instead of the color it had before the split . @xmath509 contains the same steps as @xmath477 , except that step @xmath184 is : @xmath511 .",
    "we can also define the operations @xmath512 and @xmath513 , where @xmath28 is the beginning of an interval which will be united back with the interval after it .",
    "@xmath514)$ ] is equivalent to calling @xmath515)$ ] .",
    "we consider an undirected graph @xmath47 with @xmath221 vertices and @xmath2 edges , together with a tree decomposition of @xmath47 , whose ( tree)width is bounded by a small constant @xmath516 . the tree decomposition @xmath6 contains @xmath1 nodes ( @xmath517 ) .",
    "every node @xmath136 contains a subset @xmath518 of vertices of @xmath47 .",
    "the subsets of vertices of the nodes of any tree decomposition have the following properties :    * if a vertex @xmath8 of @xmath47 belongs to both @xmath518 and @xmath519 then @xmath8 belongs to the subsets @xmath520 of every node @xmath164 on the path between @xmath136 and @xmath138 in @xmath6 * for every edge @xmath48 of @xmath47 there exists at least one subset @xmath518 such that both @xmath8 and @xmath9 belong to @xmath518 * the size of every subset @xmath518 is at most @xmath516    every vertex @xmath8 of @xmath47 has an associated resource which can be in one of the following two states : @xmath521 or @xmath522 .",
    "the initial state of the resource at a vertex @xmath8 is @xmath523 ( @xmath0 for @xmath521 , or @xmath4 for @xmath522 ) . the final desired state of the resource at a vertex @xmath8 is @xmath524 . in order to change the states of the resources",
    ", we can repeatedly perform the following action : we can select a vertex @xmath8 of @xmath47 and change the state of the resource at @xmath8 , as well as the states of the resources of all the neighbors @xmath9 of @xmath8 . changing",
    "the state of a resource means bringing it into the state opposite from the current one ( i.e. from active to inactive , or from inactive to active ) . selecting a vertex @xmath8 for performing",
    "the action incurs a cost @xmath525 .",
    "we want to find a strategy which brings every resource into its final state and which incurs a minimum total cost .",
    "solutions for general graphs ( without bounded treewidth ) , as well as for several particular graphs have been discussed in @xcite . however",
    ", none of those solutions can match the time complexity of the algorithm we will present in this section .",
    "the first observation is that we never need to select a vertex @xmath8 more than once .",
    "thus , a vertex @xmath8 is _ selected _ if it was selected once , and _ not selected _ otherwise .",
    "we will start by presenting a solution for the case in which @xmath47 is a tree . in this case",
    "we do not need to use the tree decomposition @xmath6 .",
    "we will choose an arbitrary vertex @xmath282 as the root of @xmath47 , thus defining parent - son relationships .",
    "for every vertex @xmath8 from @xmath47 we will compute the values @xmath526=the minimum total cost for bringing all the resources within vertex @xmath8 s subtree to their final states ( except possibly for the resource at vertex @xmath8 ) , such that ( the resource at ) vertex @xmath8 is in the state _ state _ and vertex @xmath8 has been selected ( if @xmath527 ) or not ( if @xmath528 ) . these values will be computed bottom - up .    for a leaf vertex @xmath8 we have @xmath529 , @xmath530 and @xmath531 .",
    "for an inner vertex @xmath8 we will compute the required values as follows .",
    "let @xmath532 be the number of sons of the vertex @xmath8 and let @xmath533 be the @xmath44 son of the vertex @xmath8 , in some arbitrary order ( @xmath534 ) .",
    "we will first consider the cases with @xmath528 .",
    "we will compute the values @xmath535 ( @xmath536 ) as the sum of the values @xmath537",
    "@xmath538 @xmath539 @xmath538 @xmath540 with @xmath534 .",
    "we also compute @xmath541 as the number of sons @xmath533 for which @xmath537 @xmath538 @xmath542 @xmath538 @xmath543 ( @xmath534 )",
    ". @xmath541 is the number of selected sons which contribute to the sum @xmath535 .",
    "let @xmath544 @xmath545 @xmath546 @xmath538 @xmath547 @xmath546 @xmath538 @xmath548 .",
    "we have @xmath549 @xmath538 @xmath550 and @xmath551 @xmath552 @xmath538 @xmath553 .    for the case",
    "@xmath527 we have @xmath554 @xmath538 @xmath555 and @xmath556 @xmath538 @xmath557 .",
    "the minimum total cost for bringing every resource into its final state is @xmath558 @xmath559 .",
    "the time complexity of the presented algorithm is @xmath560 ( i.e. linear in the number of vertices of @xmath47 ) .",
    "we will now return to our original problem .",
    "for every node @xmath136 of @xmath6 , let @xmath561 be the number of vertices @xmath562 and let these vertices be @xmath563 .",
    "we will compute the values @xmath564",
    "@xmath565 @xmath566 @xmath257 @xmath567 , representing the minimum total cost for bringing to their final states the resources of all the vertices of @xmath47 belonging to subsets @xmath519 where @xmath138 is in node @xmath136 s subtree ( except possibly for the vertices @xmath568 , @xmath569 ) , such that the resource in every vertex @xmath568 has changed its state an even ( if @xmath570 ) or odd ( if @xmath571 ) number of times , and the vertex @xmath568 has been selected ( if @xmath572 ) or not ( if @xmath573 ) ( @xmath569 ) .    for every node @xmath136 and every combination @xmath574",
    "we will compute @xmath575 ( @xmath576 ) as the number of vertices @xmath577 ( @xmath569 ) with @xmath578 and which are neighbors with the vertex @xmath579 , and @xmath580 as the sum of the costs @xmath581 of the vertices @xmath568 with @xmath578 ( @xmath569 ) .    for each node @xmath136 and each son @xmath138 of @xmath136",
    ", we define the set @xmath582 , containing those vertices belonging to the intersection of @xmath518 and @xmath519 : @xmath583 @xmath584 , where @xmath585 is the number of vertices in the set @xmath582 .",
    "if @xmath282 is the root of @xmath6 then we define @xmath586 .    for every node @xmath136 and for every combination @xmath587 ,",
    "@xmath257 @xmath588 @xmath589 we will compute @xmath590 as the number of vertices @xmath591 ( @xmath592 ) for which @xmath593 and which are neighbors with @xmath594 .",
    "we will also compute @xmath595 as the sum of the costs @xmath596 of the vertices @xmath597 @xmath598 ( @xmath592 ) for which @xmath593 .",
    "we will also maintain two hash tables at every node @xmath136 of @xmath6 .",
    "the first one will map every vertex @xmath568 to its corresponding index in the set @xmath599 ( i.e. based on this hash table we will be able to find out if @xmath600 @xmath601 and , if so , we will be able to find the index @xmath221 associated to @xmath568 such that @xmath602 ) .",
    "the second hash table will map every vertex @xmath597 to its corresponding index in the set @xmath518 ( i.e. based on this hash table we will be able to find the index @xmath120 associated to @xmath597 such that @xmath603 ) .",
    "every operation on each of the hash tables takes constant time .",
    "let s assume first that we computed all the values @xmath604 for a node @xmath136 of @xmath6 .",
    "after having these values computed , we will compute the values @xmath605",
    "@xmath606 @xmath607 = @xmath558 @xmath564 @xmath608 @xmath609 @xmath610 @xmath611 and @xmath612 ( such that @xmath603 ) for every @xmath592 , and @xmath613 or @xmath0 for every vertex @xmath614 @xmath615 @xmath601 ( @xmath0 @xmath616 @xmath617 @xmath616 @xmath561 ) , and @xmath618 @xmath619 @xmath620 @xmath538 @xmath184 ) for every vertex @xmath621 such that @xmath622 and @xmath623 @xmath624 ( @xmath625 ) @xmath626 .",
    "the easiest way to perform these computations is to first initialize @xmath605 @xmath627 @xmath628 .",
    "then , we will consider every possible pair of combinations @xmath629 .",
    "we extract @xmath630 from @xmath631 and @xmath632 from @xmath633 ( by maintaining only those indices @xmath29 for which @xmath634 and reordering the values corresponding to those indices in the order corresponding to the indices of the vertices from the set @xmath599 ( the @xmath635 component of @xmath630 and @xmath632 corresponds to @xmath636 ( @xmath637 ) ) .",
    "then , we set @xmath605 @xmath606 @xmath638 @xmath606 @xmath639 @xmath640 .",
    "we will now show how to compute the values @xmath604 of every node @xmath136 , when traversing the tree @xmath6 bottom - up ( from the leaves towards the root ) .",
    "for every node @xmath136 we will first initialize @xmath641 . then",
    ", we will consider every possible combination @xmath633 and we will compute the values @xmath642 .",
    "if @xmath136 is a leaf in @xmath6 , then the state of the resource from a vertex @xmath568 is @xmath643 @xmath538 @xmath184 .",
    "thus , we will set @xmath564 @xmath644 @xmath538 @xmath645 @xmath646 .",
    "if the node @xmath136 is not a leaf in @xmath6 , then let @xmath647 be the @xmath648 nodes which are the sons of @xmath136 ( in an arbitrary order ) .",
    "we will compute the values @xmath649=the minimum total cost of bringing into their final states the resources of all the vertices of @xmath47 located in the nodes @xmath164 , where either @xmath650 or @xmath164 is a descendant of one of the nodes @xmath651 ( including @xmath651 ) ( @xmath652 ) , except possibly for the resources of the vertices of @xmath518 , whose states were changed a number of times whose parity is defined by @xmath631 .",
    "@xmath633 is the combination we fixed earlier .    for every combination @xmath644 @xmath538 @xmath653 , we will set @xmath654 @xmath609 ; for the other possible combinations @xmath631 we will set @xmath655 @xmath656 .",
    "after this , we will consider the sons @xmath657 of @xmath136 , in increasing order of @xmath29 .",
    "we will first initialize all the values @xmath658 . then",
    ", we will construct a new combination @xmath632 obtained by removing from @xmath633 the components @xmath659 corresponding to those vertices @xmath660 which do not belong to @xmath661 .",
    "then , the remaining components are ordered such that the @xmath635 component of @xmath632 refers to @xmath662 ( @xmath0 @xmath616 @xmath120 @xmath616 @xmath663 ) .",
    "after this , we will consider all the @xmath664 possible combinations ( tuples ) @xmath630 _ = _ @xmath665 @xmath257 @xmath666 .",
    "for each combination @xmath630 we will consider every possible combination @xmath667 @xmath257 @xmath668 .",
    "for each such combination @xmath631 we will construct a new combination @xmath669 , where : @xmath670 @xmath671 if @xmath672 @xmath673 @xmath674 @xmath675 @xmath676 , and @xmath677 @xmath538 @xmath184 ) if @xmath678 @xmath661 and @xmath679 ( @xmath576 ) .",
    "then , we will set @xmath680 @xmath681 @xmath682 @xmath683 @xmath684 @xmath685 .    in the end",
    ", we will have @xmath686 @xmath609 ( for every possible combination @xmath631 ) .",
    "the minimum cost we are looking for is @xmath687 @xmath538 @xmath688 , where @xmath282 is the root node of @xmath6 . with a careful implementation",
    "we can obtain an @xmath689 .",
    "if we precompute all the transformations for each ( generic ) pair @xmath690 _ subset of indices_@xmath691 and @xmath692 _ subset of indices_@xmath693 , and we establish a consistent ordering for the vertices in each subset @xmath518 and @xmath694 ( e.g. the vertices are ordered increasingly according to their identfiers ) , then we can obtain a time complexity of @xmath695 .",
    "data transfer optimization problems have been considered in many papers , because of their highly important practical applications .",
    "references @xcite and @xcite present offline and online algorithms for several multicriteria data transfer optimization problems ( e.g. deadline - constrained data transfer scheduling ) .",
    "@xcite considers the optimal scheduling of two communication flows on multiple disjoint paths in order to minimize the makespan .",
    "applications of several data structures to resource reservations were discussed in @xcite .",
    "the technique for computing optimal average subsets of edges ( or vertices ) has been mentioned ( in a similar form ) in @xcite .",
    "string and permutation sorting problems have also been considered from multiple perspectives and considering various constraints : @xcite considers the sorting of sequences by interchange operations , while @xcite considers sorting permutations by reversal operations .",
    "a permutation sorting problem related to the ones mentioned in this paper was proposed as a task at the baltic olympiad in informatics 2007 : we have a permutation @xmath269 of the numbers @xmath240 .",
    "we want to sort this permutation in ascending order by using a sequence of the operations @xmath696 ( which removes the element from position @xmath28 in the permutation and inserts it at position @xmath29 ) .",
    "the cost of an operation @xmath696 is @xmath697 and we are interested in sorting the permutation with a minimum total cost .",
    "the solution to this problem is based on two important observations : @xmath698 every element is moved at most once ; @xmath699 the moved elements are moved in decreasing order of their values .",
    "these observations lead to a dynamic programming solution .",
    "we compute @xmath700=the minimum total cost of moving the elements @xmath701 such that they are in their correct relative order and element @xmath28 is located at position @xmath29 .",
    "we have @xmath702 and @xmath703 .",
    "we will compute the values @xmath704 in decreasing order of @xmath28 .",
    "we will always have the possibility of moving the element @xmath28 or of not moving it .",
    "however , when not moving element @xmath28 , we will consider a compensation cost , such that elements smaller than @xmath28 may consider that @xmath28 was moved .",
    "we will start by computing the array @xmath225=the position on which element @xmath85 is located in the original permutation ( @xmath705 ) .",
    "now , before computing the values @xmath704 , we will first compute the value @xmath706 , which is equal to @xmath0 plus the number of values @xmath85 such that @xmath707 and @xmath708 ( because these are the only elements which are still to the left of element @xmath28 in the permutation ) .",
    "we will consider that element @xmath28 is moved right before the element @xmath337 .",
    "thus , we will consider all the values @xmath29 from @xmath0 to @xmath709 , in increasing order . while traversing these values , we will maintain a variable @xmath710 , which is initially equal to @xmath0 .",
    "when we reach a value @xmath29 , we will first update @xmath710 : if @xmath711 then @xmath712 ( we consider @xmath713 ) .",
    "then , we set @xmath714",
    ". we will now consider the case when @xmath28 is not moved .",
    "we will consider all the positions @xmath29 from @xmath715 up to @xmath709 in increasing order ; during this time , we will maintain a variable @xmath716 ( which is initially @xmath4 ) .",
    "when we reach such a position @xmath29 , we set @xmath717 .",
    "then , if @xmath711 we will update the variable @xmath716 : @xmath718 ( this is because there are @xmath719 elements which will be moved before element @xmath28 , and their contribution would not be considered otherwise ) .",
    "the minimum total cost is @xmath720 .",
    "the problem presented in section 6 is a more general version of the minimum all ones problem @xcite .",
    "our dynamic programming state definition is similar to the one from @xcite , but our algorithm is substantially different .",
    "the novel contributions of this paper can be classified into three categories :    * offline algorithms for ( multi)point - to-(multi)point data transfer optimization * offline algorithms for resource processing optimization * the architecture of an agent - based peer - to - peer content delivery framework    the considered problems are either new , or extended ( e.g. more general ) versions of other existing problems .",
    "all the presented solutions make use of the specific properties of the considered problems , thus obtaining optimal or near optimal results .",
    "the agent - based content delivery framework is focused on efficient multicast data distribution .",
    "some of the presented offline algorithms could be used for computing a multicast data delivery tree , if information regarding the entire system is available .",
    "the framework is based on the peer - to - peer architectural model presented in @xcite , but the multicast extensions and the proposal for handling unconnectable peers are novel contributions of this paper .    as future work ,",
    "we intend to consider online versions of some of the considered problems and adapt some of the offline solutions that we developed in order to obtain online techniques .",
    "these techniques could then be implemented by specialized agents for solving the problems in real - time .                    , _ optimal scheduling of two communication flows on multiple disjoint packet - type aware paths _ , proc . of the @xmath722 ieee intl .",
    "symp . on symbolic and numeric algo . for sci .",
    "137 - 144 , 2008 .            , _ a fault - tolerant peer - to - peer object storage architecture with multidimensional range search capabilities and adaptive topology _ , proc . of the @xmath724 ieee intl .",
    "conf . on intelligent computer communication and processing , pp .",
    "221 - 228 , 2009 .",
    ", _ data distribution optimization using offline algorithms and a peer - to - peer small diameter tree architecture with bounded node degrees _",
    ", proc . of the @xmath726 international conference on control systems and computer science , vol .",
    "445 - 452 , 2009 .    , _ efficient gaussian elimination on a 2d simd array of processors without column broadcasts _ , politehnica university of bucharest ( upb ) scientific bulletin , series c - electrical engineering and computer science , vol .",
    "71 , issue 4 , pp .",
    "83 - 98 , 2009 ."
  ],
  "abstract_text": [
    "<S> in this paper we present novel algorithmic solutions for several resource processing and data transfer multicriteria optimization problems . </S>",
    "<S> the results of most of the presented techniques are strategies which solve the considered problems ( almost ) optimally . </S>",
    "<S> thus , the developed algorithms construct intelligent strategies which can be implemented by agents in specific situations . </S>",
    "<S> all the described solutions make use of the properties of the considered problems and , thus , they are not applicable to a very general class of problems . however , by considering the specific details of each problem , we were able to obtain very efficient results .    </S>",
    "<S> data transfer optimization , resource processing , peer - to - peer , data structures , permutations , sorting    05a05 , 05c05 , 05c12 , 05c38 , 68m14 , 68p05 , 68p10 , 90c39 </S>"
  ]
}