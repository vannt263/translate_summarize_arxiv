{
  "article_text": [
    "p versus np problem is one of seven millennium prize problems in mathematics that were stated by the clay mathematics institute in 2000 . as of march 2015 ,",
    "six of the problems remain unsolved . a correct solution to any of the problems results in a us 1,000,000 prize ( sometimes called a millennium prize ) being awarded by the institute [ 10 ] . simply speaking",
    ", p problems mean that the class of problems can be solved exactly in polynomial time while np ( non - deterministic polynomial ) problem stands for a class of problems which can not be solved in polynomial time . intuitively , np problem is the set of all decision problems for which the instances where the answer is  yes \" have efficiently verifiable proofs of the fact that the answer is indeed  yes \" . more precisely , these proofs have to be verifiable in polynomial time by a deterministic turing machine . in an equivalent formal definition , np problems is the set of decision problems where the  yes \"- instances can be accepted in polynomial time by a non - deterministic turing machine [ 11 ] .",
    "np problems has far - reaching consequences to other problems in mathematics , biology , philosophy and cryptography .",
    "the official statement of np problem was given by stephen cook [ 2 ] .",
    "we say that a problem @xmath0 in np is np - complete when , for every other problem @xmath1 in np , @xmath1 is easier than @xmath0 , i.e. , @xmath2 . in computational complexity",
    "theory , karp s 21 np - complete problems are a set of computational problems which are np - complete . in his 1972 paper",
    "[ 5 ] , richard karp used stephen cook s 1971 theorem that the boolean satisfiability problem is np - complete ( also called the cook - levin theorem ) to show that there is a polynomial time many - one reduction from the boolean satisfiability problem to each of 21 combinatorial and graph theoretical computational problems , thereby showing that they are all np - complete .",
    "this was one of the first demonstrations that many natural computational problems occurring throughout computer science are computationally intractable , and it drove interest in the study of np - completeness and the p versus np problem .",
    "the complexity class p is contained in np , and np contains many important problems .",
    "the hardest of which are called np - complete problems , whose solutions are sufficient to deal with any other np problems in polynomial time . the most important open question in complexity theory , is the p versus np problem which asks whether polynomial time algorithms actually exist for np - complete problems and all np problems .",
    "it is widely believed that this is not the case [ 3 ] . in 2012 , 10 years later , the same poll was repeated [ 4 ] .",
    "the number of researchers who answered was 126 ( 83% ) believed the answer to be no , 12 ( 9% ) believed the answer is yes , 5 ( 3% ) believed the question may be independent of the currently accepted axioms and therefore is impossible to prove or disprove , 8 ( 5% ) said either do nt know or do nt care or do nt want the answer to be yes nor the problem to be resolved .",
    "most computer scientists seem to suspect p does not equal np .",
    "mit computer scientist scott aaronson gives informal arguments against p = np in his post , including his philosophical argument [ 11 ] :  if p = np , then the world would be a profoundly different place than we usually assume it to be .",
    "there would be no special value in ` creative leaps ' , no fundamental gap between solving a problem and recognizing the solution once it is found .",
    "everyone who could appreciate a symphony would be mozart ; everyone who could follow a step - by - step argument would be gauss ; everyone who could recognize a good investment strategy would be warren buffett .",
    "it is possible to put the point in darwinian terms : if this is the sort of universe we inhabited , why would nt we already have evolved to take advantage of it ? \"",
    "the important thing is that _ karp showed that if any of them have efficient algorithms , then they all do_. many of these problems arise from real - world optimization problems including load balancing , minimizing total busy time of multiple machines , bin packing , hamiltonian cycle , chromatic number .",
    "researchers later extend karp s techniques to show hundreds if not thousands of natural problems are np - complete .",
    "+ there are intensive research on proving ` np not equal to p ' and ` np equals to p ' . however",
    ", none of the ` proved ' results is commonly accepted by the research community yet up to now . in this paper , instead of proving either one , we aim to provide new perspective : transforming two typical np complete problems to exactly solvable p problems in polynomial time . in the following sections , we introduce two np problems and show how to transform them into p problems in polynomial time . the remaining sections are organized as follows . minimizing makespan ( minms ) in load balance of multiple machines",
    "is discussed in section 2 .",
    "minimizing total power - on time ( mintpt ) of multiple machines is proposed in section 3 .",
    "finally we conclude in 4 .",
    "the well - known load balance problem [ 2 ] , its formulation can be described as follows .",
    "given a set of @xmath3 identical machines @xmath4 and a set of @xmath5 requests ( jobs ) , each request has a processing time @xmath6 ( consider only cpu processing for example ) .",
    "each machine can only host one job at any time .",
    "the sum of the process time allocated on a machine is called its workload , or simply load .",
    "traditionally , the makespan is used to measure the workload of multiple machine .",
    "the makespan is the total length of the schedule , i.e. , the time length of the start - time of the first scheduled machine and the end - time of the last scheduled machine where each job occupies the whole capacity of a machine during processing .",
    "the makespan is used to measure the load balance , which is simply the maximum load on any machine .",
    "the smaller the makespan is , the better the load balance .",
    "the objective of load balance is to assign each request to one of machines so that the loads placed on all machines are balanced ( or the maximum load on all machines is minimized ) .",
    "this is called offline load balance since the scheduler knows all requests and status of all machines . _ in this paper , requests and jobs are used interchangeably . _ in tian et al . [",
    "8 ] , an approximation algorithm called prepartition with near optimal results is proposed . in this paper",
    ", we provide exactly solution in polynomial time .",
    "firstly we provide a formal defition of the makespan as follows . +",
    "* the makespan * : _ in any allocation of requests to machines , we can let @xmath7 denote the set of requests allocated to machine @xmath8 , under this allocation , machine @xmath8 will have total load , @xmath9 where @xmath10 is the length of processing time of request @xmath11 . and @xmath12 _",
    "the goal of load balancing is to minimize the maximum load ( makespan ) on any machine . *",
    "theorem 1*. _ minimizing the makespan ( minms ) of offline scheduling in general case is np - complete . _",
    "+ proof : we sketch a brief proof as follows .",
    "we show that a well - know np complete problem , subset sum problem ( ssp ) is polynomial time reducible to minms problem .",
    "thus consider an instance of ssp with numbers @xmath13 , which corresponding to the cpu load of @xmath5 requests and have total cpu load w. to be load - balanced , in an ideal case , it is to let all @xmath3 machines have same share of total cpu load , i.e. , @xmath14 .",
    "this needs all allocations on all machines to be satisfied .",
    "suppose there are @xmath11 jobs on machine @xmath8 , this requires that @xmath15=@xmath16=@xmath14 .",
    "minms problem is reducible to ssp problem in polynomial time and ssp is well - known np complete problem . on the other hand ,",
    "if there is a solution to subset sum problem for a given set of requests , there exists a schedule for the given set of requests .",
    "since ssp is np - hard in the strong sense , our problem is also np - hard . in this way",
    ", we have found that that the minms problem is np - complete problem .",
    "this completes the proof .",
    "+ since minimizing the makespan ( minms ) is np - complete and traditionally the exact solution costs exponential time , so that approximation solution is widely studied .",
    "one of pioneering work is by graham [ 2 ] , where a @xmath17-approximation algorithm called longest process time first ( lpt ) is proposed , and this is the best - known approximation up to now . in the following ,",
    "we introduce a new approach to solve minms problem exactly in polynomial time .",
    "let us consider there are @xmath3 machines and denote opt as the ideal ( theoretical ) optimal solution for a given set of @xmath5 requests .",
    "firstly define @xmath18 the ideal load balance is to allocate each machine with load exactly of opt .",
    "it is impossible to achieve this without additional techniques . in the following , we use virtual machines ( vms ) and apply live vm migration technique to achieve ideal load balance . + * virtual machines ( vms ) . * _ in computing , a virtual machine ( vm ) is an emulation of a particular computer system .",
    "virtual machines operate based on the computer architecture and functions of a real or hypothetical computer , and their implementations may involve specialized hardware , software , or a combination of both . _ + * live vm migrations .",
    "* _ live migration refers to the process of moving a running virtual machine or application between different physical machines without disconnecting the client or application .",
    "memory , storage , and network connectivity of the virtual machine are transferred from the original guest machine to the destination . _ + the virtual machines and vm migrations are currently widely adopted for workload consolidation and load balance in cloud computing , bigdata , etc .. our proposed algorithm will apply live vm migrations .",
    "algorithm .",
    "2.1 shows the pesudocodes of our proposed pam algorithm .",
    "the algorithm firstly computes optimal balance value ( opt ) by equation ( 3 ) .",
    "it sorts all jobs in non - increasing order of their process time , and then finds a machine with the lowest makespan ( load ) and available capacity to allocate in sorted order , and updates the load on each machine .",
    "after all requests are allocated , the algorithm computes the makespan of each machine and finds machines with load more than opt and machines with load less than opt .",
    "pam sorts additional load ( the load more than opt ) in non - increasing order in those machines with load more than opt , and sorts machines with load less than opt in non - decreasing order .",
    "then it partition the load more than opt in those machines and allocate to compensate load in machines with load less than opt to make their load exactly equal to opt , untile all machines have load exactly equal to opt .",
    "for practice , the scheduler has to record all partitions and their hosting machines of each request so that migrations of machines can be conducted in advance to reduce overheads .",
    "initialization : computes opt value and allocates jobs to machines with the lowest load in longest process time ( lpt ) first fashion ; compute the load of each machines and total partitions ( migrations )    * theorem 2 * : _ the computational complexity of pam is @xmath19 using priority queue data structure where @xmath5 is the number of requests after paritions and @xmath3 is total number of machines used_. + proof : the priority queue is designed such that each element ( machine ) has a priority value ( i.e.,makespan ) , and each time the algorithm needs to select an element from it , the algorithm takes the one with the highest priority ( the smaller makespan value is , the higher priority it is ) .",
    "sorting a set of @xmath5 number in a priority queue takes @xmath20 time and a priority queue performs insertion and the extraction of minima in @xmath21 steps for @xmath3 machines ( detailed proof of the priority queue is shown in @xcite ) .",
    "also pam sorts the load in @xmath3 machines in non - increasing order and this takes @xmath22 time .",
    "therefore , by using priority queue or related data structure , the algorithm can find a machine with the lowest makespan in @xmath21 time .",
    "altogether , for @xmath5 requests and @xmath3 machines , pam has time complexity @xmath19 where normally @xmath23 . + * theorem 3 * : _ pam is exact and optimal_. + proof : we sketch the proof as follows .",
    "because opt can be computed in advance , applying pam will migrate the load on machines with load more than opt to machines with load less than opt , and make them have load exactly equal to opt , this will bring ideal load balance to each machine .",
    "this finishes the proof .",
    "+   + * example-1 * : consider the worst case for lpt given in [ 2 ] .",
    "there are @xmath3 machines , and @xmath5=2@xmath3 + 1 jobs with process time of @xmath3,@xmath3,@xmath3,@xmath3 + 1,@xmath3 + 1,@xmath3 + 2,@xmath3 + 2, ... ,@xmath3+(@xmath3 - 1),@xmath3+(@xmath3 - 1 ) . in this case , the total load of all jobs is 3@xmath24 , and opt is 3@xmath3",
    ". the lpt algorithm has result 4@xmath3 - 1 , so its approximation ratio is @xmath25@xmath26@xmath17 , as @xmath3 increases to very large . for pam ,",
    "opt ( 3@xmath24 ) is computed firstly , and applying lpt , the max load of all machines is 4@xmath3 - 1 and other machines will have load 3@xmath3 - 1 .",
    "pam partitions the load in the machine with load more than opt ( in this case @xmath3 - 1 ) into ( @xmath3 - 1 ) equal parts and migrate to each of other @xmath3 - 1 machines with load less than opt .",
    "therefore each machine will have load exactly equal to 3@xmath3 , which is opt .",
    "+ the virtual machine migration is widely adopted for workload consolidation and load balance in cloud computing [ 8 ] . by applying pam ,",
    "the original np - complete minms problem is transferred to p problem and is solved in polynomial time .",
    "minimizing total power - on time ( mintpt ) of all machines is based on the following assumptions and definitions.1 ) .",
    "all data are deterministic unless otherwise specified , the time is considered in discrete slotted window format .",
    "we partition the total time period [ 0 , t ] into slots of equal length ( @xmath27 ) in discrete time , thus the total number of slots is @xmath28=@xmath29 ( always making it a positive integer ) .",
    "the start - time of the system is set as @xmath30=0 .",
    "then the interval of a request @xmath31 can be represented in slot format as a tuple with the following parameters : [ starttime , endtime , requestedcapacity]=@xmath32 $ ] . with both start - time @xmath33 and end - time @xmath34 are non - negative integers .",
    "we set @xmath35=1 ( called unit demand ) in this paper .",
    "+ 2 ) . for all jobs",
    ", there are no precedence constraints other than those implied by the start - time and end - time .",
    "preemption is not considered .",
    "+ mintpt belongs to fixed interval processing problems , see [ 7 ] for a detailed discussion about this problem . in tian",
    "et al . [ 9 ] , an approximation algorithm called mffde with approximation ration 3 is proposed . in this paper",
    ", we aim to solve it exactly in polynomial time . + * definition 1*. _ the interval length : given a time interval @xmath36= [ @xmath33 , @xmath37 $ ] where @xmath33 and @xmath38 are the start slot and end slot , the length of @xmath36 is @xmath39=@xmath38-@xmath33 .",
    "the length of a set of intervals @xmath40=@xmath41 , is defined as @xmath42=@xmath43=@xmath44 , i.e. , the length of a set of interval is the sum of the length of each individual interval . _ + * definition 2*. _ the interval span : the span of a set of intervals , @xmath45 , is defined as the length of the union of all intervals considered . _ + * example-2 * : if @xmath40=@xmath46,[2,4],[5,6]\\}$ ] , then @xmath45=@xmath47[1,4]@xmath47+@xmath47[5,6]@xmath47=(4 - 1)+(6 - 5)=4 , and @xmath42 = @xmath47[1,4]@xmath47+@xmath47[2,4]@xmath47+@xmath47[5,6]@xmath47=6 .",
    "note that @xmath48 and equality holds if and only if @xmath40 is a set of non - overlapping intervals .",
    "+ the mintpt problem has the following formulation : the input is a set of @xmath5 jobs ( requests ) @xmath49= @xmath50 .",
    "each job @xmath51 is associated with an interval @xmath52 $ ] in which it should be processed , where @xmath33 is the start - time and @xmath34 the end - time , both in discrete time . set @xmath6=@xmath34-@xmath33 as the process time of job @xmath51 . for the sake of simplicity , we concentrate on cpu - intensive applications and consider cpu capacity only .",
    "the capacity parameter @xmath53 is the maximal cpu capacity a single machine provides . each job requests unit capacity @xmath35=1 .",
    "the power - on time of @xmath8 is denoted by its working time interval length @xmath54 .",
    "the optimizing objective is to assign the jobs to machines such that the total power - on time of all machines is minimized .",
    "note that the number ( @xmath55 ) of machines to be used is part of the output of the algorithm and takes integer value .",
    "this problem is called mintpt problem for abbreviation . +",
    "* theorem 4*. _ mintpt problem is np - complete problem in general case . _ + * proof * : for completeness , we sketch the proof as follows .",
    "@xmath56-partition problem is np - complete [ 6 ] .",
    "for a given arrangement @xmath57 of positive numbers and an integer @xmath58 , @xmath56-partition problem is to partition @xmath57 into @xmath56 ranges so as the sums of all the ranges are close to each other .",
    "@xmath56-partition problem can be reduced to our mintpt problem as follows . for a set of jobs @xmath49 ,",
    "each has capacity demand @xmath35=1 , partitioning @xmath49 by their capacities into @xmath56 ranges , is the same to allocate @xmath56 ranges of jobs with capacity constraint @xmath59 ( i.e. the sum of each range is at most @xmath59 ) . on the other hand ,",
    "if there is a solution to @xmath56-partition for a given set of intervals , there exists a schedule for the given set of intervals .",
    "since @xmath56-partition is np - hard in the strong sense , our problem is also np - hard . in this way",
    ", we have found that that the mintpt problem is np - complete problem .",
    "+   + * theorem 5 * : _ the lower bound ( opt ) for mintpt problem is the sum of the minimum number of machines used in each slot , i.e. , the lower bound is to allocate exactly min number of machines needed to each time slot_. + * proof : * mintpt problem is offline scheduling , for a given set of jobs @xmath49 , we can find the minimum number of machines needed for each time slot , denoted as @xmath60 for total @xmath58 time slots under consideration , where @xmath61 is the minimum number of machines needed for time slot @xmath31 . by the definition of the interval span and power - on time of each machine , @xmath62=@xmath63 ,",
    "here @xmath15 is the sum of load for time slot @xmath31 .",
    "the total power - on time of all machines is the sum of min number of machines in all time slots in this way , i.e. , the lower bound is the sum of the minimum number of machines used in each slot .",
    "this is the minimum total power - on time of all machines .",
    "this completes the proof . *",
    "remark@xmath64 * : the theoretical lower bound given in theorem 1 is not easy to achieve if each request has to be processed on a single machine without migration .",
    "finding a subset of jobs for each machine to minimize total power - on time is known to be np - complete [ 10 ] .",
    "+    [ htp ! ]    * example-3 : * as shown in fig .  1 , consider there are 4 job requests and @xmath59=3 , jobs @xmath65 , @xmath66 , @xmath67 , @xmath68 have start - time , end - time and capacity demand [ 0 , 3 , 1 ] , [ 0 , 2 , 1 ] , [ 1 , 3 , 1 ] , [ 0 , 3 , 1 ] respectively .",
    "the min number of machines needed is 1 , 2 , 1 respectively in three time slots and total power - on time is 4 in theoretical lower bound ( opt ) . without job migration ,",
    "one solution is to allocate @xmath65 , @xmath66 and @xmath68 to one machine by earliest start time first and @xmath67 to another machine ; in this way the actual total number of machines needed is 2 and the total power - on time is 5 . with job migration",
    ", one can allocate @xmath65 , @xmath66 and @xmath68 to one machine ( @xmath69 during interval [ 0 , 3 ] , allocate @xmath67 to another machine ( @xmath70 ) during interval [ 1 , 2 ] and migrate @xmath67 to @xmath71 during interval [ 2,3 ] ; in this way , the total power - on time is 4 , equal to the opt . *",
    "theorem 6*. _ mintpt problem obtains optimum result if job migration is allowed . _ + * proof * : from theorem 5 , we know that there is a theoretical lower bound for mintpt problem .",
    "the mintpt as proved in theorem 4 , is np - complete in general case without job migration .",
    "however with job migration , a job can be migrated from one machine to another machine to be continuously proceeded , it is possible to obtain the lower bound .",
    "the method is introduced in algorithm 3",
    ".  1 opt - with - migration .",
    "algorithm 3.1 firstly sorts all jobs in non - decreasing order of jobs start - time ( line 1 ) and represents load of each slot by the min number of machines needed ( line 3 - 4 ) ; it allocate jobs non - decreasing order of their start - time ( line 6 - 7 ) ; and migrates the job to an existing machine when the min number of machines will be more than slot load ( line 10 - 11 ) ; it updates load of each machine ( line 12 ) . in this way",
    ", the algorithm obtains the theoretical lower bound ( denote as opt in this paper ) with certain number of migrations .",
    "this completes the proof .",
    "+   +    sort all jobs in non - decreasing order of their start - time ( @xmath33 for job @xmath31 ) , such that @xmath72 , set @xmath73=1 find power - on times of all machines return the set of machines used , and the total power - on time of all machines    * theorem 7*. _ lbm has computational complexity of @xmath74+@xmath75 where @xmath5 is the number of jobs and @xmath28 is the toal number of slots . _ + * proof * : lbm firstly sorts all jobs in non - decreasing order of their start - time , this takes @xmath74 time , and it considers @xmath28 slots for possible migration , taking @xmath75 time .",
    "so all together lbm has computational complexity of @xmath74+@xmath75 . + by applying limited number of migrations",
    ", the original np complete problem mintpt can be transformed into p problem .",
    "as we discussed in previous sections , transforming the minms and mintpt problems into exactly solvable ones in polynomial time have some common features .",
    "their opt value can be computed in advance so that partition and migration can be applied to achieve the opt results .",
    "how about other np complete problems ?",
    "can they also be solved in similar way ? in our previous work",
    "[ 12 ] , we ever proved that the np complete problem , traveling salesman problem ( tsp ) can be solved with near optimal results by iterative k - opt algorithm .",
    "however , whether tsp can be transformed into p problem is not known yet . according to karp s result [ 5 ] that if any of np problems have efficient algorithms , then they all do .",
    "our proposed approach can shine light on other np problems . in the near future",
    ", we will look at other np complete problems and to study the possibility of transforming them into p problems .",
    "this research is sponsored by the national natural science foundation of china ( nsfc ) ( grand number:61450110440 ) .",
    "dr . wenhong tian is currently a visiting fellow at clouds lab at the university of melbourne , australia .",
    "00 stephen cook ( 1971 ) . _",
    "the complexity of theorem proving procedures _ , proceedings of the third annual acm symposium on theory of computing .",
    ". 151158 , march of 1971 .",
    "r. l. graham , _ bounds on multiprocessing timing anomalies _ , siam journal on applied mathematics , vol.17 , no.2 , pp.416 - 429 , 1969 .",
    "william i. gasarch , ( june 2002 ) . _ the p=?np poll _",
    ", sigact news 33 ( 2 ) : 34 - 47 .",
    "doi:10.1145/1052796.1052804 . retrieved 2008 - 12 - 29 .",
    "william i. gasarch , _ the second p=?np poll _ , sigact news 74 , 2012 . richard m. karp ( 1972 ) , _ reducibility among combinatorial problems _ , in r. e. miller and j. w. thatcher ( editors ) .",
    "complexity of computer computations .",
    "new york : plenum .",
    "john kleinberg , e. tardos .",
    "algorithm design .",
    "addison wesley , 2005 .",
    "m. y. kovalyov , c.t .",
    "ng , e. cheng , _ fixed interval scheduling : models , applications , computational complexity and algorithms _ , european journal of operational research , vol . 178 , no . 2 , pp .",
    "331 - 342 , 2007 .",
    "wenhong tian , minxian xu , yu chen , yong zhao , _ prepartition : a new paradigm for the load - balance of virtual mahine reservations in data centers _ , ieee international conference on communications , pp.4017 - 4 - 22 , 10 - 14 june , 2014 , sydney , australia .",
    "wenhong tian , and chee shin yeo , _ minimizing total busy - time in offline parallel scheduling with application to energy efficiency in cloud computing _ ,",
    "concurrency and computation : practice and experience , online first , nov .",
    "wenhong tian , xinyang wang , qin xiong , yu chen , obtaining quality - proved near optimal results for traveling salesman problems , lib-arxiv-008.serverfarm.cornell.edu/pdf/1502.00447 , 2015 - 2 - 3 , under review of acm transactions on algorithm ."
  ],
  "abstract_text": [
    "<S> np complete problem is one of the most challenging issues . </S>",
    "<S> the question of whether all problems in np are also in p is generally considered one of the most important open questions in mathematics and theoretical computer science as it has far - reaching consequences to other problems in mathematics , computer science , biology , philosophy and cryptography . </S>",
    "<S> there are intensive research on proving ` np not equal to p ' and ` np equals to p ' . </S>",
    "<S> however , none of the ` proved ' results is commonly accepted by the research community up to now . in this paper , instead of proving either one , we aim to provide new perspective : transforming two typical np complete problems to exactly solvable p problems in polynomial time . </S>",
    "<S> this approach helps to solve originally np complete problems with practical applications . </S>",
    "<S> it may shine light on solving other np complete problems in similar way . </S>",
    "<S> +    np complete problems , p problems , transforming np to p , exact solution in polynomial time </S>"
  ]
}