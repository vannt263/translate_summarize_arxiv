{
  "article_text": [
    "bipartite correlation clustering ( bcc ) is a problem in which the input is a bipartite graph and the output is a set of disjoint clusters covering the graph nodes .",
    "a cluster may contain nodes from either side of the graph , but it may also contain nodes from only one side .",
    "we think of a cluster as a bi - clique connecting all the elements from its left and right counterparts .",
    "an output clustering is hence a union of bi - cliques covering the input node set .",
    "the cost of the solution is the symmetric difference between the input and the output .",
    "equivalently , any pair of vertices , one on the left and one of the right , will incur a unit cost if either ( 1 ) an edge connects them but the output clustering separates them in distinct clusters , or ( 2 ) no edge connects them but the output clustering puts them in the same cluster .",
    "the objective is to minimize this cost .",
    "this notion of clustering is natural when the number of clusters and their size are not known , and the graph relations are bipartite by nature .",
    "it was studied in context of molecular biology , specifically , in gene expression data analysis ( for example @xcite ) .",
    "other examples for bipartite data abound . in collaborative filtering and",
    "recommender systems interactions are given between users and items @xcite , for example , raters vs. movies / songs .",
    "other examples may include images vs. user generated tags and search engine queries vs. search results .",
    "bccis a bipartite version of the more well known correlation clustering ( cc ) , introduced by bansal , blum and chawla @xcite , where the objective is to cover an input set of nodes with disjoint cliques ( clusters ) minimizing the symmetric difference with a given edge set over these nodes .",
    "one motivation for bcc , which also applies to our setting , is a _",
    "2-stage _ clustering approach in which one ( i ) applies binary classification machine - learning methods to predict pairs of nodes that should be clustered together , and ( ii ) uses the learned classifier , applied to all pairs , as input to bcc .",
    "assuming there is a correct clustering of the data and that the above binary classifier has some bounded error rate with respect to that ground truth , we can recover , using an algorithm for cc(or , bccin our bipartite case ) a clustering of the data which is provably close to the true clustering ( see @xcite ) .",
    "another motivation is the alleviation of the need to specify the number of output clusters , as often needed in clustering settings such as @xmath3-means or @xmath3-median .",
    "the treatment of clustering problems as ccor bccshould be compared to their predating ( by decades ) statistical theory of record linkage where , in a typical application , one wishes to identify duplicate records in a database riddled with human errors .",
    "the number of clusters is clearly unknown .",
    "in fact , the original record linkage literature @xcite considered the bipartite case , a typical example being two government agencies cross - validating large databases of population information .    bansal et .",
    "al @xcite gave a @xmath4 factor for approximating ccrunning in time @xmath5 where @xmath6 is the number of nodes in the graph .",
    "later , demaine et .",
    "al @xcite gave a @xmath7 approximation algorithm for an _ incomplete _ version of cc , relying on solving an lp and rounding its solution by employing a region growing procedure . by incomplete we mean that only a subset of the node pairs participate in the symmetric difference cost calculation .",
    "bccis , in fact , a special case of incomplete cc , in which the non - participating node pairs lie on the same side of the graph .",
    "charikar et .",
    "al @xcite provide a @xmath1-approximation algorithm for cc , and another @xmath8-approximation algorithm for the incomplete case .",
    "later , ailon et .",
    "al @xcite provided a @xmath9-approximation algorithm for ccbased on rounding an lp .",
    "they also provide a simpler @xmath2-approximation algorithm , quickcluster , which runs in time linear in the number of edges of the graph .",
    "in @xcite it was argued that quickcluster runs in expected time @xmath10 .",
    "van zuylen et .",
    "al @xcite provided de - randomization for the algorithms presented in @xcite with no compromise in the approximation guarantees . mathieu and schudy in @xcite considered the _ planted graph _ version , in which the input is a noisy version of a union - of - cliques graph , and show that a ptas is possible for this setting .",
    "also , giotis et .",
    "al @xcite and independently using other techniques , karpinski et .",
    "al @xcite gave a ptas for the cccase in which the number of clusters is constant .",
    "amit @xcite was the first to address bccdirectly .",
    "she proved its np - hardness and gave a constant @xmath0-approximation algorithm based on rounding a linear programming in the spirit of charikar et .",
    "al s @xcite algorithm for cc .",
    "it is worth noting that in @xcite a @xmath1-approximation algorithm for bccwas presented and analyzed .",
    "the presented algorithm is incorrect ( we give a counter example in the paper ) but their attempt to use arguments from @xcite is an excellent one .",
    "we will show that an extension of the method in @xcite is needed .",
    "our main result , requiring a considerable development of previous techniques , is a randomized expected @xmath1-approximation algorithm , pivotbicluster .    to explain how we attain it , we recall the method of ailon et .",
    "al @xcite .",
    "the algorithm for ccpresented there is as follows ( we concentrate on the unweighted case ) .",
    "choose a random vertex , and form a cluster with its neighbors .",
    "remove the cluster from the graph , and repeat until the graph is empty .",
    "this random - greedy algorithm returns a solution with cost at most @xmath2-times that of the optimal solution , on expectation .",
    "the analysis was done by noticing that each cost element is naturally related to a _ contradiction structure _ containing @xmath2 vertices and exactly @xmath11 edges between them .",
    "this structure is , incidentally , the minimal structure forcing any solution to pay . in other words , the locations in which any clustering errs must _ hit _ the set of contradicting structures .",
    "a corresponding hitting set lp lower bounding the optimal solution was defined to capture this simple observation , and a feasible solution was then conveniently assigned to its dual using probabilities arising in the algorithm probability space .",
    "it is tempting here to consider the corresponding minimal contradiction structure for bcc , namely a set of @xmath1 vertices , @xmath11 on each side , with exactly @xmath2 edges between them .",
    "unfortunately , this idea turned out to be evasive ( a proposed solution attempting this @xcite has a counter example which we describe and analyze in appendix  [ section : counter ] and is hence incorrect ) . in our analysis",
    "we resorted to contradiction structures of unbounded size .",
    "such a structure consists of two vertices @xmath12 of the left side and two sets of vertices @xmath13 on the right hand side such that @xmath14 is contained in the neighborhood of @xmath15 for @xmath16 , @xmath17 and @xmath18 .",
    "we define a hitting lp as we did earlier , this time of possibly exponential size , and analyze its dual in tandem with a carefully constructed random - greedy algorithm .",
    "as this analysis sketch suggests , the algorithm is not symmetrical with respect to the right and left side of the input .",
    "indeed , at each round it chooses a random pivot vertex on the left , constructs a cluster with its right hand side neighbors , and then for each other vertex on the left hand side makes a randomized decision whether to join the new cluster based on the intersection pattern of its neighborhood with the pivot s neighborhood .",
    "we start with basic notation in section  [ sec : notation ] .",
    "we then present our main algorithm in section  [ sec : the algorithm ] , followed by its analysis in section  [ sec : analysis ] .",
    "we discuss future work in section  [ sec : future ] .",
    "before describing the framework we give some general facts and notations .",
    "let the input graph be @xmath19 where @xmath20 and @xmath21 are the sets of left and right nodes and @xmath22 be a subset of @xmath23 .",
    "each element @xmath24 will be referred to as a _",
    "pair_.    a solution to our combinatorial problem is a clustering @xmath25 of the set @xmath26 .",
    "we identify such a clustering with a bipartite graph @xmath27 for which @xmath28 if and only if @xmath29 and @xmath30 are in the same cluster @xmath31 for some @xmath32 .",
    "note that given @xmath33 , we are unable to identify clusters contained exclusively in @xmath20 ( or @xmath21 ) , but this will not affect the cost , so we adopt the convention that single - side clusters are always singletons .",
    "we will say that a pair @xmath34 is erroneous if @xmath35 . for convenience ,",
    "let @xmath36 be the indicator function for the erroneous pair set , i.e. , @xmath37 if @xmath38 is erroneous and @xmath39 otherwise .",
    "we will also simply use @xmath40 when it is obvious to which graph @xmath41 and clustering @xmath33 it refers .",
    "the cost of a clustering solution is defined to be @xmath42 .",
    "similarly , we will use @xmath43 when @xmath41 is clear from the context , let @xmath44 be the set of all right nodes adjacent to @xmath45",
    ".    it will be convenient for what follows to define a _",
    "tuple_. we define a tuple @xmath46 to be @xmath47 where @xmath48 , @xmath49 , @xmath50 , @xmath51 and @xmath52 . in",
    "what follows , we may omit the superscript of @xmath46 .",
    "given a tuple @xmath53 , we define the _ conjugate tuple _ @xmath54 .",
    "note that @xmath55 .",
    "we now describe our algorithm pivotbicluster .",
    "the algorithm is sequential . in every cycle it creates one cluster and possibly many singletons ,",
    "all of which are removed from the graph before continuing to the next iteration . abusing notation , by @xmath56 we mean , in the algorithm s description , all the neighbors of @xmath57 which have not yet been removed from the graph .",
    "every such cycle performs two phases . in the first phase , pivotbiclusterpicks a node on the left side uniformly at random , @xmath58 , and forms a new cluster @xmath59 .",
    "this will be referred to as the @xmath58-phase and @xmath58 will be referred to as the left center of the cluster . in the second phase ,",
    "denoted as the @xmath60-sub - phase corresponding to the @xmath58-phase , the algorithm iterates over all other remaining left nodes , @xmath60 , and decides either to ( 1 ) append them to @xmath61 , ( 2 ) turn them into singletons , or ( 3 ) do nothing .",
    "we now explain how to make this decision .",
    "let @xmath62 , @xmath63 and @xmath64 . with probability @xmath65 do one of two things : ( 1 ) if @xmath66 append @xmath60 to @xmath61 , and otherwise ( 2 ) ( if @xmath67 ) , turn @xmath60 into a singleton . in the remaining probability ,",
    "( 3 ) do nothing for @xmath60 , leaving it in the graph for future iterations .",
    "examples for cases the algorithm encounters for different ratios of @xmath68 , @xmath69 , and @xmath70 are given in figure  [ fig : algorithm ] .",
    "[ fig : algorithm ]     either joins the cluster created by @xmath58 or becomes a singleton . in the two right most examples , with the remaining probability nothing is decided about @xmath60.,width=642 ]    [ thm : main ] algorithm pivotbiclusterreturns a solution with expected cost at most @xmath1 that of the optimal solution .",
    "we start by describing _ bad events_. this will help us relate the expected cost of the algorithm to a sum of event probabilities and expected consequent costs .",
    "we say that a _ bad event _ , @xmath71 , happens to the tuple @xmath72 if during the execution of pivotbicluster , @xmath73 was chosen to be a left center while @xmath74 was still in the graph , and _ at that moment _ , @xmath75 , @xmath76 , and @xmath77 .",
    "( we refer by @xmath78 here to the neighborhood function in a particular moment of the algorithm execution . )",
    "if a bad event @xmath71 happens to tuple @xmath46 we `` color '' the following pairs with color @xmath46 :    * @xmath79 , * @xmath80 , * @xmath81 only if we decide to associate @xmath74 to @xmath73 s cluster , or if we decide to make @xmath74 a singleton during the @xmath60-sub - phase corresponding to the @xmath58-phase .",
    "[ lm : mapping errors to tuples ] during the execution of pivotbiclustereach pair @xmath24 is colored at most once , and each pair on which the output errs is colored exactly once .",
    "for the first part , we show that pairs are colored at most once .",
    "a pair @xmath82 can only be colored during an @xmath60-sub - phases with respect to some @xmath58-phase , if @xmath83 .",
    "clearly , this will only happen in one @xmath58-phase , as every time a pair is colored either @xmath60 or @xmath84 ( or both ) are removed from the graph . indeed",
    ", either @xmath85 in which case @xmath84 is removed , or @xmath86 , but then @xmath45 is removed since it either joins the cluster created by @xmath58 or becomes a singleton .",
    "for the second part , note that the only pairs which are not colored are between left centers ( during @xmath58-phases ) and right nodes in the graph at that time . on all these pairs",
    "the algorithm does not err .",
    "we denote by @xmath87 the probability that event @xmath71 occurs and by @xmath88 the number of erroneous pairs that are colored by @xmath71 . from lemma  [ lm : mapping errors to tuples ] we get the following :    [ obs : mapping qbcb to tuples ]    @xmath89 = \\mathbb{e}\\left[\\sum_{e \\in l\\times r }   x(e ) \\right ] = \\mathbb{e}\\left[\\sum_t \\operatorname{cost}(t ) \\right ] = \\sum_t { q_t \\cdot \\mathbb{e}[\\operatorname{cost}(t ) | x_t]}\\ .\\ ] ]    note : in what follows we use the terms _ erroneous pairs _ and _ violating pairs _ or _ violation pairs _ interchangingly , referring to pairs on which the algorithm incurs a unit of cost .",
    "we now identify bad structures in the graph for which every output must incur some cost . in the case of bccthe minimal such structures",
    "are `` bad squares '' : a set of four nodes , two on each side , between which there are only three edges .",
    "we make the trivial observation that any clustering @xmath33 must make at least one mistake on any such bad square , @xmath90 ( we think of @xmath90 as the set of @xmath1 pairs connecting its two left nodes and two right nodes ) .",
    "any clustering solution s violating pair set must hit these squares .",
    "let @xmath91 denote the set of all bad squares in the input graph @xmath41 .",
    "it is not enough to concentrate on squares in our analysis .",
    "indeed , at an @xmath60-sub - phase , decisions are made based on the intersection pattern of the current neighborhoods of @xmath60 and @xmath58 - a possibly unbounded structure .",
    "the _ tuples _ now come in handy .",
    "consider tuple @xmath53 for which @xmath92 and @xmath93 .",
    "notice that for every selection of @xmath94 , and @xmath95 the tuple contains the bad square induced by @xmath96 .",
    "note that there may also be bad squares @xmath97 for every @xmath98 and @xmath95 but these will be associated to the _ conjugate tuple _ @xmath99 .    for each tuple we can write a corresponding linear constraint on the function @xmath100 , indicating , as we explained above , the pairs for which the algorithm errs .",
    "a tuple constraint is the sum of the constraints of the squares it is associated with , where a constraint for square @xmath90 is simply defined as @xmath101 .",
    "since each tuple corresponds to @xmath102 bad squares , we get the following constraint : @xmath103 the following linear program hence provides a lower bound for the optimal solution :    @xmath104    notice that all the constraints in this program are sums of square constraints .",
    "this means that the program is equivalent to one in which only square constraints are present .",
    "our formulation , however , allows the definition of useful dual variables corresponding to each tuple @xmath46 .",
    "the dual program is as follows :    @xmath105      we now relate the expected cost of the algorithm on each tuple to a feasible solution for @xmath106 .",
    "we remind the reader that @xmath87 denotes the probability that a bad event @xmath71 happens to tuple @xmath46 .",
    "let @xmath107 , when + @xmath108 then @xmath109 is a feasible solution to @xmath106 .    in other words , for every edge @xmath110 :",
    "@xmath111 and for every pair @xmath112 : @xmath113    first , notice that given a pair @xmath110 each tuple @xmath46 can appear at most in one of the sums in the lhs of ( [ eq : e in e ] ) .",
    "denote by @xmath114 the event that the edge @xmath38 is colored with color @xmath46 .",
    "we distinguish between two cases .    1 .",
    "consider @xmath46 appearing in the first sum of the lhs of ( [ eq : e in e ] ) , meaning that @xmath115 and @xmath116 .",
    "we distinguish between two sub - cases .",
    "* if @xmath117 , @xmath38 is colored with color @xmath46 if @xmath74 joined the cluster of @xmath73 .",
    "this happens , conditioned on @xmath71 , with probability @xmath118=          \\min \\left\\{\\frac { |r^t_{1,2}| } { |r^t_{2}| } , 1\\right\\}$ ] , * if @xmath119 we color @xmath38 with color @xmath46 if @xmath60 was isolated , which happens with probability @xmath118=\\min \\{\\frac { |r_{1,2}| } { |r_{2}| } , 1\\}$ ] as well .",
    "+ thus , @xmath46 contributes the following expression to the sum : @xmath120 \\pr[x_{e , t}|x_t ]   =   \\pr[x_{e , t } ] .",
    "\\end{aligned}\\ ] ] 2 .",
    "@xmath46 contributes to the second or third sum in the lhs of ( [ eq : e in e ] ) . by definition of the conjugate @xmath121 ,",
    "the following holds : @xmath122 therefore it is sufficient to bound the contribution of each @xmath46 to the rhs of ( [ monkey ] ) .",
    "we may therefore focus on tuples @xmath46 for which if @xmath123 and @xmath124 . consider a moment in the algorithm s execution in which both @xmath125 and @xmath126 were still present in the graph , @xmath75 , @xmath76 , @xmath77 and one of @xmath127",
    "was chosen to be a left center . which depends on the `` current '' state of the graph at that moment , after possibly removing previously created clusters .",
    "] either one of @xmath125 and @xmath126 had the same probability to be chosen .",
    "in other words : @xmath128 = \\pr[x_{\\bar t } | x_t \\cup x_{\\bar t}]\\ , \\ ] ] and hence , @xmath129 .",
    "further , notice that @xmath130 is never colored with color @xmath46 , and if event @xmath131 happens then @xmath38 is colored with color @xmath121 with probability 1 .",
    "therefore : @xmath132 = \\pr[x_{e , \\bar t}]+\\pr[x_{e , t } ] .",
    "\\end{aligned}\\ ] ]    summing this all together , for every edge @xmath133 : @xmath134}.\\ ] ] by the first part of lemma  [ lm : mapping errors to tuples ] we know that @xmath135}$ ] is exactly the probability of the edge @xmath38 to be colored ( the sum is over probabilities of disjoint events ) , therefore it is at most @xmath136 , as required to satisfy  ( [ eq : e in e ] ) .",
    "now consider a pair @xmath137",
    ". a tuple @xmath46 contributes to ( [ eq : e not in e ] ) if @xmath138 and @xmath139 .",
    "since , as before , @xmath140 and since @xmath141 = 1 $ ] ( this follows from the first coloring rule described in the beginning of section  [ sec : analysis ] ) we obtain the following : @xmath142 }   =       \\sum_{\\bar{t}\\ s.t\\ \\ell_2^{\\bar{t}}=\\ell,\\ , r \\in r_{1}^{\\bar{t } } }   { \\pr [ x_{e,{\\bar{t } } } ] }   \\\\    & = & \\sum_{t } { \\pr[x_{e , t}]}.\\end{aligned}\\ ] ] from the same reason as before , this is at most @xmath136 , as required for ( [ eq : e not in e ] ) .    after presenting the feasible solution to our dual program , we have left to prove that the expected cost of pivotbiclusteris at most 4 times the dp value of this solution . for this",
    "we need the following :    [ lm : tuple cost ] for any tuple @xmath46 , @xmath143}\\operatorname{cost}(t)|x_t ] + q_{\\bar t } \\cdot { \\mathbb{e}\\left [ [ \\right]}\\operatorname{cost}({\\bar{t}})|x_{\\bar t } ] \\leq 4\\cdot\\left(\\beta(t ) + \\beta(\\bar{t})\\right ) .\\ ] ]    we consider three cases , according to the structure of @xmath46 .    * case 1 .",
    "* @xmath144 ( equivalently @xmath145 ) : + for this case , @xmath146 , and we have ( recall that @xmath129 ) @xmath147 since @xmath148 , if event @xmath71 happens pivotbicluster adds @xmath74 to @xmath73 s cluster with probability @xmath149 .",
    "therefore the pairs colored with color @xmath46 that pivotbiclusterviolates are all the edges from @xmath74 to @xmath150 and all the non - edges from @xmath74 to @xmath151 , namely , @xmath152 edges .",
    "the same happens in the event @xmath153 as the conditions on @xmath154 , @xmath155 , and @xmath156 are the same , and since @xmath157 .",
    "thus , @xmath158}\\operatorname{cost}(t|x_t)]+ { \\mathbb{e}\\left [ [ \\right]}\\operatorname{cost}({\\bar{t}}|x_{\\bar t})]\\right )          = q_t \\left ( 2\\left ( |r^t_{2}|+|r^t_1|\\right ) \\right )          \\le 4\\cdot \\left(\\beta(t)+\\beta({\\bar{t } } ) \\right).\\ ] ]    * case 2 . *",
    "@xmath159 ( equivalently @xmath160 ) : + here @xmath161 , therefore , @xmath162 as @xmath148 , if event @xmath71 happens pivotbicluster adds @xmath74 to @xmath73 cluster with probability @xmath163 . therefore with probability @xmath164 the pairs colored by color @xmath46 that pivotbiclusterviolate are all the edges from @xmath74 to @xmath150 and all the non - edges from @xmath74 to @xmath151 , and with probability @xmath165 pivotbiclusterviolates all the edges from @xmath74 to @xmath166",
    "thus , @xmath167}\\operatorname{cost}(t)|x_t]&=&\\frac { |r^t_{1,2}|}{|r^t_{2}| } \\left(|r^t_{2}|+|r^t_1|\\right ) +                        \\left(1-\\frac { |r^t_{1,2}|}{|r^t_{2}|}\\right)|r^t_{1,2}|\\\\                   & = & 2\\cdot |r^t_{1,2}| + \\frac { |r^t_{1,2}|\\cdot |r^t_1|-|r^t_{1,2}|^2 }                   { |r^t_{2}|}\\ \\leq\\   2\\cdot|r^t_{1,2}| .",
    "\\end{aligned}\\ ] ] if the event @xmath153 happens , as @xmath168 and @xmath169 , pivotbiclusterchooses to isolate @xmath170 ( @xmath171 ) with probability @xmath136 and the number of pairs colored with color @xmath172 that are consequently violated are @xmath173 .",
    "thus , @xmath174}\\operatorname{cost}(t)|x_t])+ { \\mathbb{e}\\left [ [ \\right]}\\operatorname{cost}(\\bar t ) | x_{\\bar{t}})]\\right )          & \\leq & q_t \\cdot ( 2|r^{t}_{1,2}|+ |r^{t}_1|+|r^{t}_{1,2}|)\\\\          & < & 4 \\cdot q_t \\cdot |r^t_{1,2}|          = 4 \\cdot \\left(\\beta(t)+\\beta(\\bar{t } ) \\right)\\ .",
    "\\end{aligned}\\ ] ]    * case 3 . *",
    "@xmath175 ( equivalently , @xmath176 ) : + here , @xmath177 , thus , @xmath178 conditioned on event @xmath71 , as @xmath179 , pivotbiclusterchooses to isolate @xmath60 with probability @xmath163 .",
    "therefore with probability @xmath164 pivotbicluster colors @xmath180 pairs with color @xmath46 ( and violated them all ) . with probability @xmath181 ,",
    "pivotbicluster colors @xmath182 pairs with color @xmath46 ( and violated them all ) .",
    "we conclude that @xmath183}\\operatorname{cost}(t)|x_t ] = \\frac { |r^t_{1,2}|}{|r^t_{2}| } ( |r^t_{2}|+|r^t_{1,2}|)+          \\left(1-\\frac { |r^t_{1,2}|}{|r^t_{2}|}\\right ) |r^t_{1,2}| = 2 |r^t_{1,2}|\\ .\\ ] ] similarly , for event @xmath153 , as @xmath168 and @xmath184 , pivotbiclusterisolates @xmath58 with probability @xmath185 therefore colors @xmath186 pairs with color @xmath187 ( and violated them all ) . with probability @xmath188 pivotbiclustercolors",
    "@xmath189 pairs with color @xmath190 ( and violates them all ) .",
    "thus , @xmath183}\\operatorname{cost}(\\bar{t})|x_{\\bar t}]=\\frac { |r^t_{1,2}|}{|r^t_1| } ( |r^t_1|+|r^t_{1,2}| )          + \\left(1-\\frac { |r^t_{1,2}|}{|r^t_1|}\\right)|r^t_{1,2}| = 2 |r^t_{1,2}| .\\ ] ] and therefore @xmath191}\\operatorname{cost}(t)|x_t]+ { \\mathbb{e}\\left [ [ \\right]}\\operatorname{cost}(\\bar t ) | x_{\\bar{t}}]\\right )           = 4\\cdot q_t \\cdot |r^t_{1,2}|          = 4\\cdot ( \\beta(t ) + \\beta(\\bar{t } ) ) \\ .\\ ] ]    by corollary  [ obs : mapping qbcb to tuples ] @xmath192 & = & \\sum_t { \\pr[x_t]\\cdot { \\mathbb{e}\\left [ [ \\right]}\\operatorname{cost}(t)|x_t ] } \\\\ & = & \\frac{1}{2 } \\sum_{t}{\\left(\\pr[x_t ] \\cdot",
    "{ \\mathbb{e}\\left [ [ \\right]}\\operatorname{cost}(t)|x_t]+\\pr[x_{{\\bar{t}}}]\\cdot { \\mathbb{e}\\left [ [ \\right]}\\operatorname{cost}(\\bar{t})|x_{\\bar t}]\\right)}\\ .\\end{aligned}\\ ] ] by lemma  [ lm : tuple cost ] the above rhs is at most @xmath193 therefore by the weak duality theorem we conclude that @xmath194\\le 4\\cdot\\sum_{t } { \\beta(t)}\\leq 4 \\cdot opt .\\ ] ] this proves our main result theorem  [ thm : main ] .",
    "improving the approximation factor as well as derandomizing the algorithm ( in the lines of @xcite , or using other techniques ) are interesting questions .",
    "one direction that seems promising is to devise an lp rounding algorithm using a variation of pivotbicluster(in the lines of the lp - based algorithms in @xcite ) .",
    "10    jiong guo , falk hffner , christian komusiewicz , and yong zhang . improved algorithms for bicluster editing . in _",
    "tamc08 : proceedings of the 5th international conference on theory and applications of models of computation _ , pages 445456 ,",
    "berlin , heidelberg , 2008 .",
    "springer - verlag .",
    "sara  c. madeira and arlindo  l. oliveira .",
    "biclustering algorithms for biological data analysis : a survey .",
    ", 1:2445 , january 2004 .",
    "yizong cheng and george  m. church .",
    "biclustering of expression data . in _ proceedings of the eighth international conference on intelligent systems for molecular biology _ , pages 93103 .",
    "aaai press , 2000 .",
    "panagiotis symeonidis , alexandros nanopoulos , apostolos papadopoulos , and yannis manolopoulos .",
    "nearest - biclusters collaborative filtering , 2006 .",
    "nikhil bansal , avrim blum , and shuchi chawla .",
    "correlation clustering .",
    ", 56:89113 , 2004 .",
    "10.1023/b : mach.0000033116.57574.95 .",
    "bianca zadrozny , john langford , and naoki abe .",
    "cost - sensitive learning by cost - proportionate example weighting , 2003 .",
    "ivan  p. fellegi and alan  b. sunter . a theory for record linkage .",
    ", 64(328):11831210 , 1969 .",
    "erik  d. demaine , dotan emanuel , amos fiat , and nicole immorlica .",
    "correlation clustering in general weighted graphs . , 2006 .",
    "moses charikar , venkatesan guruswami , and anthony wirth .",
    "clustering with qualitative information .",
    ", 71(3):360383 , 2005 .",
    "nir ailon , moses charikar , and alantha newman . aggregating inconsistent information : ranking and clustering .",
    ", 55(5):127 , 2008 .",
    "nir ailon and edo liberty .",
    "correlation clustering revisited : the `` true '' cost of error minimization problems . in _",
    "icalp 09 : proceedings of the 36th international colloquium on automata , languages and programming _ , pages 2436 , berlin , heidelberg , 2009 .",
    "springer - verlag .",
    "anke van zuylen , rajneesh hegde , kamal jain , and david  p. williamson .",
    "deterministic pivoting algorithms for constrained ranking and clustering problems . in _",
    "soda 07 : proceedings of the eighteenth annual acm - siam symposium on discrete algorithms _ , pages 405414 , philadelphia , pa , usa , 2007 .",
    "society for industrial and applied mathematics .",
    "claire mathieu and warren schudy .",
    "correlation clustering with noisy input . in _ soda _ ,",
    "pages 712728 , 2010 .",
    "ioannis giotis and venkatesan guruswami .",
    "correlation clustering with a fixed number of clusters . in _ proceedings of the seventeenth annual acm - siam symposium on discrete algorithm _",
    ", pages 11671176 , 2006 .",
    "marek karpinski and warren schudy .",
    "linear time approximation schemes for the gale - berlekamp game and related minimization problems .",
    ", abs/0811.3244 , 2008 .",
    "noga amit .",
    "the bicluster graph editing problem .",
    "master thesis , 2004 .",
    "in @xcite the authors claim to design and analyze a @xmath1-approximation algorithm for bcc .",
    "its analysis is based on bad squares ( and not unbounded structures , as done in our analysis ) .",
    "their algorithm is as follows : first , choose a pivot node uniformly at randomly from the left side , and cluster it with all its neighbors .",
    "then , for each node on the left , if it has a neighbor in the newly created cluster , append it with probability @xmath195",
    ". an exception is reserved for nodes whose neighbor list is identical that of the pivot , in which case these nodes join with probability @xmath136 . remove the clustered nodes and repeat until no nodes are left in the graph .",
    "unfortunately , there is an example demonstrating that the algorithm has an unbounded approximation ratio .",
    "consider a bipartite graph on @xmath196 nodes , @xmath197 on the left and @xmath198 on the right .",
    "let each node @xmath199 on the left be connected to all other nodes on the right except for @xmath200 .",
    "the optimal clustering of this graph connects all @xmath15 and @xmath201 nodes and thus has cost @xmath202 . in the above algorithm , however , the first cluster created will include all but one of the nodes on the right and roughly half the left ones .",
    "this already incurs a cost of @xmath203 which is a factor @xmath6 worse than the best possible ."
  ],
  "abstract_text": [
    "<S> bipartite correlation clustering is the problem of generating a set of disjoint bi - cliques on a set of nodes while minimizing the symmetric difference to a bipartite input graph . </S>",
    "<S> the number or size of the output clusters is not constrained in any way .    </S>",
    "<S> the best known approximation algorithm for this problem gives a factor of @xmath0.- approximation algorithm @xcite is erroneous , as we show in the appendix . </S>",
    "<S> ] this result and all previous ones involve solving large linear or semi - definite programs which become prohibitive even for modestly sized tasks . in this paper </S>",
    "<S> we present an improved factor @xmath1 approximation algorithm to this problem using a simple combinatorial algorithm which does not require solving large convex programs .    </S>",
    "<S> the analysis extends a method developed by ailon , charikar and alantha in 2008 , where a randomized pivoting algorithm was analyzed for obtaining a @xmath2-approximation algorithm for correlation clustering , which is the same problem on graphs ( not bipartite ) . </S>",
    "<S> the analysis for correlation clustering there required defining events for structures containing @xmath2 vertices and using the probability of these events to produce a feasible solution to a dual of a certain natural lp bounding the optimal cost .    </S>",
    "<S> it is tempting here to use sets of @xmath1 vertices , which are the smallest structures for which contradictions arise for bipartite correlation clustering . </S>",
    "<S> this simple idea , however , appears to be evasive . </S>",
    "<S> we show that , by modifying the lp , we can analyze algorithms which take into consideration subgraph structures of unbounded size . </S>",
    "<S> we believe our techniques are interesting in their own right , and may be used for other problems as well .    </S>"
  ]
}