{
  "article_text": [
    "implementing boolean functions on quantum computers is an essential aim , in the exploration of the benefits , which may be gained from systems operating by quantum rules .",
    "it is important to find the corresponding quantum circuits , which can carry out the operations we use to implement on our conventional computers . on classical computers ,",
    "a circuit can be built for any boolean function using and , or and not gates .",
    "this set of gates can not , in general be used to build quantum circuits because the operations are not reversible @xcite .",
    "a corresponding set of reversible gates must be used to build a quantum circuit for any boolean operation . in classical computer science , many clever methods have been used to obtain more efficient digital circuits @xcite for a given boolean function . recently , there have been efforts to find an automatic way to create efficient quantum circuits implementing boolean functions .",
    "it is shown that @xcite any unitary gate can be represented as a composition of simpler gates but it is not necessarily the most efficient circuit for this operation . a method proposed in @xcite used a modified version of _",
    "_ karnaugh maps__@xcite and depends on a clever choice of certain minterm gates to be used in minimization process , however it appears that this method has poor scalability .",
    "another work @xcite , includes a very useful set of transformations for quantum boolean circuits and proposes a method for building quantum circuits for boolean functions by using extra auxiliary qubits , however , this will increase the number of qubits to be used in the final circuits .    in our construction for building quantum circuits for boolean functions",
    ", we will use only one auxiliary qubit ; which we initially set to zero , to hold the result of the boolean function , together with @xmath0 based transformations ( gates ) which work as follows @xcite : @xmath1 is a gate where the target qubit @xmath2 is controlled by a set of qubits @xmath3 such that @xmath4 , the state of the qubit @xmath2 will be flipped from @xmath5 to @xmath6 or from @xmath6 to @xmath7 if and only if the conditions stated by the @xmath0 gate is evaluated to true .",
    "the condition that a certain qubit evaluates to true depends on whether the state of the qubit is @xmath5 ( cond-0 ; @xmath8=1 ) or @xmath6 ( cond-1 ; @xmath8=0 ) according to the condition being set , where @xmath8 is a boolean parameter that will be used in the boolean algebraic expressions to indicate the condition being set on the qubit ; i.e. the new state of target qubit @xmath2 is the result of @xmath9-ing the old state of @xmath2 with the @xmath10-ing of the states of the control qubits @xmath3 ( under the condition being set on each control qubit ) .",
    "for example , consider the @xmath0 gate shown in fig.[bqcfig1 ] , it can be represented as @xmath11 , where @xmath12 and @xmath13 mean that the condition on the qubit will evaluate to true if and only if the state of that qubit is @xmath5 ( cond-0 ) and @xmath14 ( cond-1 ) respectively , while @xmath15 denotes the target qubit which will be flipped if and only if all the conditions set on the control qubits being evaluated to true .",
    "this means that the state of the qubit @xmath16 will be flipped if and only if @xmath17 and @xmath18 . in general , the target qubit in a 4qubit gate will be changed according to the operation @xmath19 , now to represent the gate shown in fig.[bqcfig1 ] , we will set @xmath20 and @xmath21 , so the operation for this gate on @xmath16 will be @xmath22 ,     gate.,width=148,height=148 ]    some special cases of the general @xmath0 gate have their own names , @xmath0 gate with one control qubit with cond-1 is called controlled-@xmath23 gate ; fig.[bqcfig2](a ) , @xmath0 gate with two control qubits both with cond-1 is called _ toffoli _ gate ; fig.[bqcfig2](b ) , and @xmath0 gate with no control qubits at all is called @xmath24 gate ; fig.[bqcfig2](c ) , where @xmath3 will be an empty set ( c = @xmath25 , we will refer to this case as @xmath26 where @xmath27 is the qubit which will be unconditionally flipped .",
    "[ htbp ]     gate.,width=286,height=142 ]",
    "a boolean function , @xmath28 , is a function that takes @xmath29 boolean variables as inputs and gives one boolean variable as output ,    @xmath30    to represent a boolean function of @xmath31 inputs , a quantum circuit with @xmath29 qubits will be used where the extra qubit will be initialised with value @xmath32 , this will then carry the result of the boolean function at the end of the computation .",
    "any boolean function can be represented by a truth table , in order to be reversible ; the truth table must have @xmath29 inputs and @xmath29 outputs .",
    "for example : consider the boolean function @xmath33 , classically it s truth table is represented as shown in table.[bqctab1 ] and for quantum computing purposes , the representation will be as shown in table.[bqctab2 ] .",
    ".classical representation of the truth table for @xmath34 .",
    "[ cols=\"^,^,^,^\",options=\"header \" , ]     [ htbp ]    initial quantum circuit for @xmath33.,width=316,height=187 ]    the maximum number of _ cnot _ gates we can add in this stage will be up to 2@xmath35 _ cnot _ gate where @xmath29 is the number of qubits in the quantum system .      in the following transformations we will trace the operations being applied on the target qubit only , since",
    "no control qubits will be changed during the operations of the circuit .",
    "these circuit transformations are an extension and generalization of some of the equivalence between reversible circuits shown in @xcite .",
    "we will apply this transformations on every @xmath0 gate in the circuit we have , which will expand the number of @xmath0 gates in the circuit , after which we will apply the rule of minimization on the whole circuit to get the final circuit , which implements the boolean finction .",
    "let @xmath27 s be the control qubit , @xmath36 be the target qubits and @xmath37 where i=1,2,  ,@xmath29 - 1 , the general operation to be applied on the target qubit is given by    @xmath38    multiplying all terms we get the following transformation :    @xmath39      _ example 1 : _ if one control qubit with cond-0 .",
    "let @xmath40 = 1 as shown in fig.[bqcfig9 ] .",
    "the following two circuits are equivalent :    @xmath41    [ htbp ]    @xmath29 qubit gate with only @xmath40=1 and it s equivalent circuit.,width=246,height=169 ]      from eqn.[bqceq10 ] , putting @xmath40 = 1 and @xmath42 to get eqn.[bqceq11 ] . the l.h.s . of eqn.[bqceq11 ] will represent l.h.s .",
    "circuit in fig.[bqcfig9 ] , and the r.h.s of eqn.[bqceq11 ] will represent the r.h.s .",
    "circuit in fig.[bqcfig9 ] .",
    "@xmath43    [ htbp ]    @xmath29qubit gate with @xmath40=1 and @xmath44=1 and it s equivalent circuit.,width=321,height=169 ]    _ example 2 : _ if two control qubit with cond-0 .",
    "let @xmath40 = 1 and @xmath44 = 1 as shown in fig.[bqcfig10 ] .",
    "the following two circuits are equivalent :    @xmath45      from eqn.[bqceq10 ] , putting @xmath40 = 1 , @xmath44 = 1 and @xmath46 to get eqn.[bqceq13 ] . the l.h.s .",
    "of eqn.[bqceq13 ] will represent the l.h.s .",
    "circuit in fig.[bqcfig10 ] , and the r.h.s of eqn.[bqceq13 ] will represent the r.h.s .",
    "circuit in fig.[bqcfig10 ] .",
    "@xmath47    [ htbp ]    @xmath29qubit gate with all @xmath48=1 and it s equivalent circuit.,width=580,height=169 ]    _ example 3 : _ the last possible case where all @xmath8 s will be equal to 1 as shown in fig.[bqcfig11 ] .",
    "the following two circuits are equivalent :    @xmath49      from eqn.[bqceq10 ] ; putting all @xmath48 = 1 , @xmath50=1,  ,@xmath29 - 1 to get eqn.[bqceq15 ] , the l.h.s . of eqn.[bqceq15 ] represents the l.h.s .",
    "circuit in fig.[bqcfig11 ] and the r.h.s . of eqn.[bqceq15",
    "] represents the r.h.s .",
    "circuit in fig.[bqcfig11 ] .",
    "@xmath51    where , @xmath52    applying these transformations on the circuit , we get from stage-1 we will get a new circuit with up to @xmath53 @xmath0 gates .",
    "now we have a quantum circuit where all @xmath0 gates are applied on the target qubit @xmath2 with no control qubits with cond-0 . in stage-3 of our method",
    "we carry out minimization to obtain the final simpler circuit .",
    "the method employs the following rule .",
    "@xmath54    if and only if @xmath55 as shown in fig.[bqcfig12 ]    [ htbp ]    rule of minimization.,width=431,height=172 ]    now applying this rule recursively on the circuit we have , we will get a new quantum circuit that on average ( see next section ) efficiently represents our boolean function .",
    "for example , the final quantum circuit for @xmath56 is shown in fig.[bqcfig13 ] .",
    "[ htbp ]    final circuit for @xmath57.,width=239,height=163 ]",
    "applying the above method on a truth table , after stage-1 the number of gates will be up to @xmath58 @xmath0 gates with some controlled qubits with cond-0 and others with cond-1 , the case where the number of @xmath0 gates to be @xmath58 will occur only when all the @xmath59 being set to 1 in the truth table , in this case the most optimum nonzero - gate circuit to be found using this method where only @xmath60 will exist in the final circuit as shown in fig.[bqcfig14 ] .",
    "[ htbp ]    the most efficient non - zero gate with it s truth table.,width=172,height=96 ]    after stage-2 , where the transformations being applied to eliminate all @xmath8 s equal to 1 , we will be left with a new quantum circuit where the number of @xmath0 gates will be up to @xmath53 gates .",
    "starting the minimization of the circuit , analysing the method for @xmath29qubit circuit , we get the following results : the number of possible circuits @xmath61 for all possible input configurations is given by    @xmath62    where @xmath63 and @xmath64 is the number of @xmath0 gates to be found in the final circuit .    from eqn.[bqceq17 ] we can see that the probability that the number of @xmath0 gates in the final circuit is @xmath58 ( @xmath65 ) ; which is the worst case , will be @xmath66 which means that the probability for this case will decrease as the number of qubits increase , similarly the probability that the final circuit to have zero - gates ( identity ; @xmath67 ) is @xmath66 which will decrease as the number of qubits increase as well . the most likely case to appear",
    "is the _ average _ where @xmath68 $ ] , for example consider a 3-qubit circuit : the number of possible circuits is 16 as shown in fig.[bqcfig3qset ] and the probability that a 4-gate circuit or 0-gate circuit to appear is 0.0625 and the probability that @xmath69$]-gates circuit to appear is 0.875 . and for a 4-qubit circuit : the number of possible circuits is 256 and the probability that an 8-gate circuit or 0-gate circuit to appear is 0.00390625 and the probability that @xmath70$]-gates circuit to appear is 0.7109375 .",
    "there is no clear proof at this time that the cost of implementing multiple input @xmath0 gates is higher than @xmath0 gates with fewer inputs , but a further optimization for the cost of @xmath0 gates used in this method can be achieved with a small increase in the number of @xmath0 gates used by applying circuit reduction from the canonical form shown in @xcite .    [ htbp ]    a complete set of a 3qubit quantum circuits.,width=633,height=490 ]    this method is also used to implement boolean arithmetic operations like addition and multiplication and also used to implement @xmath71-to-@xmath29 boolean logic , these results will be presented in a subsequent paper .",
    "the method @xcite uses a modified version of _ karnaugh maps _ and depends on a clever choice of certain minterms to be used in minimization process .",
    "the choice process means that the circuits generated from this method are not unique ( for example , two alternatives are shown in fig.[practfig]).our method will generate a unique form of a circuit similar to that shown in fig.[practfig](b ) , which contains a smaller number of @xmath0 gates .",
    "the generation of circuits with this method may become very difficult problem for larger quantum circuits because of the usage of karnaugh maps .",
    "[ htbp ]    implementaion of @xmath72 according to a ) method @xcite , b ) our method.,width=349,height=295 ]    in another work @xcite a method is described that requires auxiliary qubits in the quantum circuits obtained . in fig .",
    "[ transfig ] we give a comparison of a circuit obtained by this method ( fig .",
    "[ transfig](a ) ) and the equivalent , but much simpler , circuit obtained by the method proposed in this paper ( fig .",
    "[ transfig](b ) ) .",
    "[ htbp ]    implementaion of @xmath73 according to a ) method @xcite , b ) our method.,width=545,height=405 ]",
    "the construction of reversible classical boolean circuits has received much attention @xcite . as a direct result from the 3-qubit quantum circuits shown in fig.15",
    ", we can pick a set of these circuits which represent the reversible version of the classical irreversible operations : and , or , not , nand , nor , xor and xnor . using these versions of quantum circuits as reversible classical gates together with a reversible fan - out version similar to that shown in @xcite as shown in table.[bqctab5 ] , we can build a classical non - quantum reversible version of any known digital circuits .    using the gates shown in table.[bqctab5 ] , we can build the reversible version of any digital circuit and apply the same methods of simplification and optimization applied on those kind of circuits ( as shown in fig.[bqcfig39 ] ) . of course this architecture",
    "need more investigation to estimate its efficiency ."
  ],
  "abstract_text": [
    "<S> in this paper we discuss an efficient technique that can implement any given boolean function as a quantum circuit . </S>",
    "<S> the method converts a truth table of a boolean function to the corresponding quantum circuit using a minimal number of auxiliary qubits . </S>",
    "<S> we give examples of some circuits synthesized with this technique . </S>",
    "<S> a direct result that follows from the technique is a new way to convert any classical digital circuit to its classical reversible form . </S>"
  ]
}