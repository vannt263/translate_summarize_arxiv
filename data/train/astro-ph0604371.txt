{
  "article_text": [
    "for long - term n - body simulations , it is essential that the drift in the values of conserved quantities is kept to a minimum .",
    "the total energy is often used as an indicator of such a drift . during the last fifteen years",
    ", two approaches have been put forward to improve numerical conservation of energy and other theoretically conserved quantities : symplectic integration schemes , where the simulated system is guaranteed to follow a slightly perturbed hamiltonian system , and time - symmetric integration schemes , where the simulated system follows the same trajectory in phase space , when run backward or forward    in both cases , for symplectic as well as for time - symmetric schemes , the introduction of adaptive time steps tends to destroy the desired properties .",
    "symplectic schemes are perturbed to different hamiltonians at different choices of time step length , and therefore lose their global symplecticity .",
    "time - symmetric schemes typically determine their time step length at the beginning of a step , which implies that running a step backward gives a slightly different length for that step .",
    "see @xcite for a recent review of various attempts to remedy this situation .    in practice , many large - scale simulations in stellar dynamics use a block time - step approach , where the only allowed values for the time step length are powers of two @xcite .",
    "the name derives from the fact that , with this recipe , many particles will share the same step size , which implies that their orbit integration can be performed in parallel .",
    "an added benefit , in the case of individual time steps , is the fact that block time steps allow one to predict the positions of all particles only once per block time step , rather than separately for each particle that needs to be moved forward .",
    "since parallelization is rapidly becoming essential for any major simulation , we explore in this paper the possibility to extend time symmetry to the use of block time steps .    in section 2 ,",
    "we analyze some of the problems that occur when applying existing methods to the case of block time steps , and we offer a novel solution , with a truly time symmetric choice of time step , with the restriction that we only allow changes of a factor two in the direction of increasing and decreasing the time step . in section 3",
    ", we present numerical tests of our new scheme in the simplest case of the 2-body problem , which already shows the superiority of our approach over various alternatives . in section 4 , we demonstrate that the advantage carries over to the general n - body problem .",
    "section 5 sums up .",
    "it is surprisingly easy to introduce a time - symmetric version for any adaptive self - starting integration scheme .",
    "let @xmath0 be the @xmath1-dimensional phase space vector for a system with @xmath2 degrees of freedom , and let @xmath3 be the operator that maps the phase space vector of the system at time @xmath4 to a new phase space vector at time @xmath5 .",
    "any choice of self - starting integration scheme , together with a recipe to determine the next time step @xmath6 , at time @xmath4 and phase space value @xmath7 , defines the precise form of @xmath3 .",
    "the recipe for making any such scheme time - symmetric was given by @xcite , as :    @xmath8    where @xmath9 can be any time step criterion .",
    "note that this recipe leads to an implicit integration scheme , which can be solved most easily through iteration . in practice ,",
    "one or two iterations suffice to get excellent accuracy , but at the cost of doubling or tripling the number of force calculations that need to be performed .",
    "extensions of this implicit symmetrization idea have been presented by @xcite and @xcite .",
    "since we will need to inspect the idea of iteration below in more detail , let us write out the process here explicitly .",
    "we start with the given state @xmath10 and the implicit equation for @xmath11 of the form    @xmath12    the first guess for @xmath11 is    @xmath13    and we can consider this as our zeroth - order iteration . with this guess in hand , we can now start to iterate , finding    @xmath14    as our first - order iteration .",
    "this will already be much closer to the final value , as long as the time steps are small enough and the function @xmath6 does not fluctuate too rapidly . in general , the @xmath15 iteration will yield a value for @xmath11 of    @xmath16    we will now consider the application of these techniques to block time steps . for the purpose of illustrating the use of block time steps , it will suffice to use the leapfrog scheme ( also known as the verlet - strmer - delambre scheme , according to the authors who rediscovered this scheme at roughly century - long intervals ) , which we present here in a self - starting , but still time - symmetric form :    @xmath17    all our considerations carry over to higher - order schemes , as long as the base scheme can be made time - symmetric when iterated to convergence .",
    "an example of such a scheme is the widely used hermite scheme@xcite .      to start with",
    ", we apply the recipe of @xcite to block time steps .",
    "let us define a block time step at level @xmath18 as having a length :    @xmath19    where @xmath20 is the maximum time step length .",
    "starting with the continuum choice of    @xmath21    we now force each time step to take on the block value @xmath22 for the smallest @xmath18 value that obeys the condition @xmath23 . in more formal terms ,",
    "@xmath24 for the unique @xmath18 value for which    @xmath25    the problem with this approach is that we are no longer guaranteed to find convergence for our iteration process , as can be seen from the following example .",
    "let @xmath26 and let the time derivative of @xmath27 along the orbit be @xmath28 .",
    "we then get the following results for our attempt at iteration .",
    "@xmath29    @xmath30/2 ) )    \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i([0.502 + ( 0.502 + 0.5*(-0.01))]/2 ) )          \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i([0.502 + 0.497]/2 ) )                        \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i(0.4995 ) )         = f(\\xi_i , 0.25)\\end{aligned}\\ ] ]    @xmath31/2 ) )         \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i([0.502 + ( 0.502 + 0.25*(-0.01))]/2 ) )          \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i([0.502 + 0.4995]/2 ) )                        \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i(0.50075 ) )          = f(\\xi_i , 0.5)\\end{aligned}\\ ] ]    and from here on , @xmath32 for every odd value of @xmath33 and @xmath34 for every even value of @xmath33 : the process of iteration will never converge .    under realistic conditions , for slowly varying @xmath35 functions and small time steps , this flip - flop behavior will not occur often , but it will occur sometimes , for a non - negligible fraction of the time .",
    "we can see this already from the above example : for a linear decrease in the @xmath35 function of @xmath28 , we will get flip - flopping not only for @xmath26 but for any value in the finite range @xmath36 .    since iteration converges correctly over the rest of the interval @xmath37 , we conclude that in this particular case flip - flopping occurs about one quarter of one percent of the time , over this interval .",
    "this is far too frequent to be negligible in a realistic situation .",
    "clearly , a straightforward extension of the implicit iterative time symmetrization approach does not work for block time steps , because iteration does not converge .",
    "we have to add some feature , in some way .",
    "our first attempt at a solution is to take the smallest of the two values in a flip - flop situation .",
    "the most straightforward solution of the flip - flop dilemma is like cutting the gordian knot : we just take the lowest value of the two alternate states .",
    "the drawback of this solution is that in general we need at least two iterations for each time step , to make sure that we have spotted , and then correctly treated , all flip - flop situation . in general , it is only at the third iteration that it becomes obvious that a flip - flop is occurring . to see this ,",
    "consider the previous example with a starting value of @xmath38 . in that case",
    "we will get @xmath39 and @xmath40 , just as when we started with @xmath26 .",
    "the difference shows up only at the second iteration , where we now find @xmath41 , a value that will hold for all higher iterations as well .",
    "the original iterative approach to time symmetry in practice already gives good results when we use only one iteration .",
    "this implies a penalty , in terms of force calculations per time steps , of a factor two compared to non - time - symmetric explicit integration .",
    "now the use of flip - flop resolution will force us to always take at least two iterations per step , raising the penalty to become at least a factor of three .",
    "however , there is a more serious problem : there is still no guarantee that taking the lowest value in a flip - flop situation leads to a time - symmetric recipe .",
    "in fact , what is even more important , we have not yet checked whether our symmetric block time - step scheme is really time symmetric , in the absence of flip - flop complications .    in order to investigate these questions ,",
    "let us return to the example we used above , but instead of a linear time derivative , let us now use a quadratic time derivative for the @xmath35 function that gives the estimate for the time step size . rather than writing a formal definition ,",
    "let us just state the values , while shifting the time scale so that @xmath42 coincides with the particle position being @xmath10 :    @xmath43    when we start at time @xmath42 , and we integrate forward , we find :    @xmath29    @xmath30/2 ) )    \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i([0.502 + 0.499]/2 ) )                        \\nonumber\\\\ & = & f(\\xi_i,\\delta t_i(0.5005 ) )         = f(\\xi_i , 0.5)\\end{aligned}\\ ] ]    and so on : all further @xmath33th iterations will result in @xmath44 .",
    "there is no flip - flop situation , when moving forward in time .",
    "however , when we now turn the clock backward , after taking this step of half a time unit , we start with the value @xmath45 , which leads to a first step back of @xmath46 .",
    "the end point of the first step back is @xmath47 with @xmath48 .",
    "therefore , also here there is no flip - flop situation : all iterations , while going backward , result in a time step size of @xmath46 .",
    "we have thus constructed a counter example , where forward integration would proceed with time step @xmath49 and subsequent backward integration would proceed with time step @xmath46 .",
    "clearly , our scheme is not yet time symmetric , even in the absence of a flip - flop case .",
    "let us rethink the whole procedure .",
    "the basic problem has been that the very first step in any of our algorithms proposed so far has not been time symmetric .",
    "the very first step moves forward , and leads to a newly evolved system at the end of the first step .",
    "only _ after _ making such a trial integration , do we look back , and try to restore symmetry .",
    "however , as we have seen , the danger is large that this trial integration is not exhaustive : it may already go too far , or not far enough , and thereby it may simply overlook a type of move that the same algorithm would make if we would start out in the time - reversed direction .    formulating the problem in this way ,",
    "immediately suggests a solution . at any point in time , let us first try to make the largest step that is allowed .",
    "if that step turns out to be too large for our algorithm , we try a step that is half that size .",
    "if that step is too large still , we again half the size , and so on , until we find a step size that agrees with our algorithm , _ when evaluated in both time directions .",
    "_ a similar treatment has been described by quin et al ( 1997 ) .",
    "this type of approach is clearly more symmetric than what we have attempted so far . instead of using information of the physical system at the starting point of the next integration step , we only use a mathematical criterion to find the largest time step size allowed at that point , _ and",
    "we then apply the physical criteria symmetrically in both directions .",
    "_    let us give an example . if the largest time step size is chosen to be unity , then at time @xmath50 we start by considering this time step .",
    "we try , in this order @xmath51 , @xmath49 , @xmath46 , and so on , until we find a time step for which integration starting in the forward direction , and integration starting in the backward direction , both result in the new time step being acceptable .",
    "let us say that this is the case for @xmath52 .",
    "after taking this step , we are at time @xmath53 .",
    "the largest time step allowed at that point , forward or backward , is @xmath52 .",
    "any larger time step would result in non - alignment of the block time steps : in the backward direction it would jump over @xmath50 .",
    "so at this point we start by considering once more @xmath52 .",
    "if that time step is too large , we try half that time step , halving it successively until we find a satisfactory time step size .",
    "imagine that the second time step size is also @xmath52 .",
    "in that case , we land at @xmath47 . from there on , the maximum allowed time step size is @xmath46 , so the first try should be that size .    in principle , this approach seems to be really time symmetric .",
    "however , there is a huge problem with this type of scheme , as we have just formulated it .",
    "imagine the system to crawl along with time steps of , say @xmath54 , and reaching time @xmath55 .",
    "our new recipe then suggests to start by trying @xmath51 , a 1024-fold increase in time step !",
    "whatever subtle physical effect it was that forced us to take such small time steps , is completely ignored by the mathematical recipe that forces us to look at such a ridiculously large time step .",
    "for example , in the case of stellar dynamics , a double star may force the stars that orbit each other to take time steps that are necessarily far shorter than the orbital period . starting out with a trial step size that is far larger than an orbital period may or may not give spuriously safe - looking results .",
    "clearly , we have to exclude such enormous jumps in time step .      the simplest solution to taming sudden unphysical increases in time steps",
    "is to allow at most an increase of a factor two , in either the forward or the backward direction .",
    "this then implies that we can only allow decreases of a factor two , and not more than two , in either direction .",
    "the reason is that a decrease of a factor four in one direction in time would automatically translate into an increase of a factor four in the other direction .",
    "note that we have to be careful with our time step criterion . if we allow time steps that are too large , we may encounter situations where our time step criterion would suggest us to shrink time steps by a factor of four , from one step to the other .",
    "since our algorithm does not allow this , we can at most shrink by a factor of two , which may imply an unacceptably large step . however , if our time step criterion is sufficiently strict , allowing only reasonably small time steps too start with , it will be able to resolve the gradients in the criterion in such as way as to handle all changes gracefully through halving and doubling .",
    "when we apply this restriction to the scheme outlined in the previous subsection , we arrive at the following compact algorithm .",
    "first a matter of notation .",
    "any block time step , of size @xmath56 , connects two points in time , only one of which can be written at @xmath57 , with @xmath58 an integer .",
    "let us call that time value an _ even time _",
    ", from the point of view of the given time step size , and let us call that other time value an _ odd time_. to give an example , if @xmath52 , than @xmath59 are all even times , while @xmath60 are all odd times",
    ".    here is our algorithm :    * when we start in a given direction direction in time , at a given point in time , we should determine the time step size of the last step made by the system . in that way , we can determine whether the current time is even or odd , with respect to that last time step .",
    "* if the current time is odd , our one and only choice is : to continue with the same size time step , or to halve the time step .",
    "first , we try to continue with the same time step .",
    "if , upon iteration , that time step qualifies according to the time - symmetry criterion used before , eq .",
    "[ blockcondition ] , we continue to use the same time step size as was used in the previous time step .",
    "if not , we use half of the previous time step . *",
    "if the current time step is even , we have a choice between three options for the new time step size : doubling the previous time step size , keeping it the same , or halving it .",
    "we first try the largest value , given by doubling . if eq.[blockcondition ] shows us that this larger time step is not too large , we accept it , otherwise we consider keeping the time step size the same .",
    "if eq.[blockcondition ] shows us that keeping the time step size the same is okay , we accept that choice , otherwise we just halve the time step , in which case no further testing is needed .    note that in this scheme , we always start with the largest possible candidate value for the time step size .",
    "subsequently , we may consider smaller values , but the direction of consideration is always from larger to smaller , never from smaller to larger .",
    "this guarantees that we do not run into the flip - flop problem mentioned above .",
    "the top line with highest slope corresponds to algorithm 1 , the line with intermediate slope corresponds to algorithm 2 , and below those the two lines for algorithms 0 and 3 are indistinguishable in this figure.,scaledwidth=90.0% ]        , but for a duration that is ten times longer.,scaledwidth=90.0% ]    we present here the results for a gravitational two - body integration .",
    "the relative orbit of the two point masses forms an ellipse with an eccentricity of @xmath61 .",
    "we have chosen a time unit such that the period of the orbit is @xmath62 .    we have implemented four different integration schemes :    \\0 ) the original time - symmetric integration scheme described by @xcite , where there is a continuous choice of time step size .",
    "this is the approach described in section [ subsec : implicit ] .",
    "we have used five iterations for each step .",
    "\\1 ) a block - time - step generalization , with a fixed number of iterations .",
    "this is the approach analyzed in section [ subsec : flipflop ] . here , too , we chose five iterations for each step .",
    "\\2 ) a block time step generalization , with a variable number of iterations .",
    "if after five iterations , the fourth and the fifth iterations still give a different block time step size , then we choose the smallest of the two .",
    "this recipe avoids flip - flop situations .",
    "it is the approach described in section [ subsec : noflipflop ] .",
    "the algorithm described in the next section , [ subsec : firsttry ] , we have not implemented here , because it is guaranteed to lead to large errors in those cases where a new large time step is allowed again just before pericenter passage .",
    "we therefore switched directly to the following section :    \\3 ) the implementation of our favorite algorithm , where we start with a truly time symmetric choice of time step , with the restrictions that we only allow changes of a factor two in the direction of increasing and decreasing the time step , and that we only allow an increase of time step on the so - called even time boundaries .",
    "this is the approach given in section [ subsec : secondtry ] .    in figures [ fig1 ] and [ fig2 ]",
    "we show the results of integrating our highly eccentric binary with these four integration schemes . in each case",
    ", the largest errors are produced by algorithm 1 ) , smaller errors are produced by algorithm 2 ) , and even smaller errors appear with algorithm 3 ) . finally , algorithm 0 ) gives the smallest errors .",
    "figure [ fig1 ] shows the energy error in the two - body integration as a function of time .",
    "as is generally the case for time - symmetric integration , the errors that occur during one orbit are far larger than the systematic error that is generated during a full orbit . to bring this out more clearly , figure [ fig2 ]",
    "shows the error only one time per orbit , at apocenter , the point in the orbit where the two particles are separated furthest from each other , and the error is the smallest .",
    "finally , figure [ fig3 ] shows the same data as figure [ fig2 ] , but for a period of time that is ten times longer . in both figures [ fig2 ] and [ fig3 ] ,",
    "it is clear that the first two block time steps algorithms , 1 ) and 2 ) , both show a linear drift in energy .",
    "this is a clear sign of the fact that they violate time symmetry .",
    "note that in both figures algorithm 3 ) gives rise to a time dependency that looks like a random walk .",
    "this may well be the best that can be done with block time steps , when we require time symmetry .",
    "so far , we have discussed the implementation of our block - symmetric algorithm for individual time steps in the case of the two - body problem . of course , for @xmath63 , it is not really necessary to use block time steps , nor is it useful to introduce individual time steps .",
    "the reason we made both of these extensions was to implement and test our basic ideas in the simplest case . in this section ,",
    "we describe and test our algorithm for the general @xmath2-body problem .",
    "the major conceptual difficulty in designing a time - symmetric block step scheme is the global context information that is needed , with extensions toward the future as well as the past . in order to determine the time step for particle @xmath64 at time @xmath65 , we need the information of all other particles @xmath66 at that time . in general",
    ", there will be at least some @xmath66 values for which the position and velocity of particle @xmath66 are not given at time @xmath65 , because particle @xmath66 has a time step larger than particle @xmath64 _ and _ time @xmath65 happens to fall within the duration of one time step for particle @xmath66 .    in such a case , the time step of particle @xmath64 at time @xmath65 depends on the positions and velocities of other particles @xmath66 , that can only be determined from time symmetric interpolation between the positions and velocities of each particle @xmath66 at times earlier and later than @xmath65 .",
    "however , the future @xmath66 positions and velocities depend in turn on the orbit of particle @xmath64 , and thus on the time step of particle @xmath64 at time @xmath65 . in other words",
    ", there is a circular dependence between the future positions and velocities of particles @xmath66 and the time step of particle @xmath64 .    to make things worse",
    ", each of the future positions and velocities of any of the particles in turn will depend on information that is given even further in the future .",
    "if we continue this logic , we would have to know the complete future of a whole simulation , before we could attempt to time symmetrize that whole history . and",
    "while any simulation will stop at a finite time , so the number of time steps for each particle will be a finite number , it is clearly unpractical to let the very first time step depends on the positions and velocities of the particles at the very end of simulation .",
    "a more practical solution is to impose a maximum size for any time step , as @xmath67 .",
    "if we start the simulation at time @xmath68 , we know that all particles will reach time @xmath69 , by making one or more steps . at that time , all particles will be synchronized .",
    "this means that we can focus on time symmetric orbit integration for all particles during the interval @xmath70 $ ] , without the need for any information about any particle at any time @xmath71 .",
    "in other words , we divide and conquer : we split the total history of our simulation into a number of smaller periods , which we call eras .",
    "each era extends a period in time equal to the largest allowed time step @xmath67 , or to an integer multiple of @xmath67 , whatever turns out to be the most convenient .",
    "let the beginning of a single era be @xmath68 and the end @xmath72 . as we saw above , in order to obtain the time step size for particle @xmath64 at time @xmath65 within our era",
    ", we typically need to know the positions and velocities of some other particles at times larger than @xmath65 .",
    "the simplest way to provide this future information is through iteration .",
    "first we just perform standard forward integration , with the usual kind of non - time - symmetric block step algorithm , for the complete duration of our era ( @xmath73 ) . while simultaneously integrating the orbits of all particles , we store the positions and velocities ( and if necessary higher order time derivatives ) for _ all _ time steps for _ all _ particles during our era .",
    "this will then allow us to obtain the position and velocity of any particle at any arbitrary time through interpolation , to the accuracy given by this first try , which will function as our zeroth iteration .",
    "next we make our first iteration .",
    "we again perform orbit integration for our complete @xmath2-body system , during @xmath73 . however , there are two differences with respect to the first try . first of all , in order to calculate the force from particle @xmath66 on particle @xmath64 , we no longer _",
    "extrapolate _ the orbit of particle @xmath66 to the time requested by @xmath64 , but instead we _ interpolate _ the position and velocity of particle @xmath66 to the requested time , using stored positions and velocities of particle @xmath66 at slightly earlier and later times , using a time symmetric interpolation scheme .",
    "secondly , we can now begin to symmetrize the time step for particle @xmath64 , in the same way as we did it for the two - body problem in the previous section , with one exception : we now obtain the estimated time step size at the beginning of the time step from the current iteration , and we obtain the estimated time step size at the end of the time step from the previous iteration ( in the two - body case the iteration was done separately for each step ) .",
    "subsequent attempts , as second and higher iterations , repeat the same steps as the first iteration .    as before ,",
    "we have implemented our iteratively time symmetric block step algorithm using the leapfrog algorithm as our basic integrator .",
    "generalizations to higher - order schemes are somewhat more complex , but follow the same basic logic we are outlining in the current paper .",
    "we have adopted the following time step criterion for particle @xmath64 : @xmath74 where @xmath75 is a constant parameter and @xmath76 and @xmath77 are the relative position and velocity between particles @xmath64 and @xmath66 . to symmetrize the time step",
    ", we simply require that the step sizes that would be determined by the above criterion at both ends of the time step are not smaller than the actual time step used .",
    "in other words , we take the minimum of the two time step values that our criterion gives us at the beginning and at the end of the time step ; this minimum is our symmetrized time step .",
    "we could have taken the average , but here we have used the minimum value , for simplicity .",
    "figure [ fig4 ] show how the energy errors grow in the 100-body problem . in each case",
    ", we started with random realizations of a plummer model , where we used standard @xmath2-body units , in which the gravitational constant @xmath80 , the total mass @xmath81 and the total energy is @xmath82 .",
    "we have integrated each system for 50 time units , with a maximum time step of @xmath83 and @xmath84 ( see eq .",
    "[ eq : nbdt ] ) .",
    "we have used standard plummer type softening with softening length @xmath85 .",
    "we have carried out forty time integrations , starting from twenty different realizations of the plummer model .",
    "for each realization , we have integrated the system once without any time symmetrization and once with time symmetrization using six iterations to guarantee sufficient convergence . in our experience ,",
    "at least three iterations were necessary to achieve high accuracy .",
    "it is clear that all runs without time symmetry show a systematic drift in energy , while no such systematic tendency is visible for time symmetrized runs . among the twenty non - symmetrized runs ,",
    "even the best result came out worse than the worst result among the symmetrized runs .",
    "we conclude that time symmetrization can significantly improve the long - term accuracy of @xmath2-body simulations .",
    "figure [ fig5 ] shows similar results for 512-body runs .",
    "here we have started from a single plummer model realization , and the curves show the effect of varying the number of iterations . in this case , the second and third iteration already show a dramatic improvement in the long - time behavior of the total energy of the system .",
    "the softening used here is @xmath86 .",
    "all other parameters are the same as for the 100-body runs . for the 512-body case ,",
    "the improvement is significantly better than it was in the 100-body runs .",
    "finally , figure [ fig6 ] shows that the results depicted in figure [ fig5 ] are generic : starting from a different set of initial conditions changes the details but not the overall picture , and again the second and third iterations show dramatic improvements over the original run and the first iteration .",
    "we offer the following explanation for the increase in accuracy of the time - symmetric scheme as a function of particle number . in these runs , contributions to the error are largely generated by close encounters between two particles , since the softening we used is relatively small .",
    "these error contributions are dominated by weak encounters , since the softening , while small , is not small enough to make gravitational focusing significant . the number of weak encounters that take place during one time unit , within a particle - particle distance that is less than the inter - particle distance ( of order @xmath87 ) is of order @xmath88 .",
    "if our time symmetrization succeeds in replacing the systematic effects of all these encounters by a random effect , the result will be a shift from a linear to a square root drift , effectively replacing the @xmath88 dependence by a @xmath89 dependence .",
    "we conclude that the relative reduction in the total energy error , due to time symmetrization , grows with @xmath2 , as @xmath90 .    whether or not time - symmetric integration is to be preferred , depends on the number of particles and the duration of the integration . in the example case shown in figure [ fig4 ] , the energy error is about a factor of 10 smaller for time - symmetric integration , but the same effect could be achieved in a computationally cheaper way by reducing the step size by a factor of @xmath91 . for large @xmath2 ,",
    "however , as shown already in figure [ fig5 ] , the effect of time symmetry is more pronounced .",
    "for very long integrations , time - symmetric integration is clearly better , since in that case the error grows in random - walk fashion , as @xmath92 , while for any non - time - symmetric scheme scheme the error grows linearly , proportional to @xmath65 . in the case of a star - cluster simulation which covers many relaxation timescales , the particles in the core can go through a very large number of crossing times .",
    "for example , a simulation of a globular cluster with @xmath93 stars would need to cover at least @xmath94 half - mass crossing times .",
    "the crossing timescale in the core is at least a factor of 100 shorter than that of the half - mass crossing time .",
    "therefore , particles in the core need to be followed for as many as @xmath95 local crossing times .",
    "the difference between the scaling of @xmath92 and @xmath65 produces a improvement of a factor of roughly @xmath96 in the energy error , in the case of time - symmetric integration . with a second - order scheme ,",
    "this translates into a factor of 100 difference in the necessary step size . even with a fourth - order scheme",
    ", it would imply a difference of a factor of ten in the time step .",
    "clearly , even applying five iterations will produce a gain of a factor two with respect to the alternative of having to decrease the time step by a factor of ten .",
    "here we describe the algorithm in some more detail . to enable the reader to check the precise implementation of our algorithm , we have made available",
    "the computer code used to generate figures 4 , 5 , and 6 , on our art of computational science web site    consider the integration of the system from time @xmath68 to @xmath72 .",
    "we can assume for simplicity that the zero point in time has been chosen in such a way as to be compatible with the era size , so that both @xmath68 and @xmath72 are integer multiples of the time interval @xmath97 .",
    "in the first pass through this era , we integrate all particles with the standard block step scheme , without any intention to make the scheme time symmetric . in the calculations reported in this paper , we have used the same predictor - corrector form of the leapfrog algorithm as mentioned earlier in eq .",
    "[ leapfrog ] :    @xmath98    as we discussed before , if one particle @xmath64 wants to step forward in time , we need to know the positions of all particles @xmath66 in order to compute the force that each particle @xmath66 exerts on particle @xmath64 . among the particles",
    "@xmath66 , many may have a larger time step than particle @xmath64 , so we may have to predict the position for such a particle , for the time at which particle @xmath64 wants to make a step .",
    "in addition , we need to predict the velocity of particle @xmath66 , because the velocity difference between particles @xmath64 and @xmath66 are used in determining the time step size , according to eq .",
    "[ eq : nbdt ] .",
    "the predicted position @xmath99 for particle @xmath66 is obtained with a second - order taylor expansion , while for the predicted velocity @xmath100 a first - order expansion suffices :    @xmath101    the integrated positions and velocities for each particle @xmath64 at each time step , @xmath102 and @xmath103 in eq .",
    "[ leapfrog2 ] , are all stored .",
    "in the next iteration , we proceed in the same way , but the time step is calculated differently . at time @xmath65 for particle @xmath64 , let the time step calculated according to the criterion ( [ eq : nbdt ] ) be @xmath104 , and the time step not exceeding this @xmath104 and compatible with the block step criterion be @xmath105 .",
    "but now we would like to know the time step size that would be required at the end of this step , at time @xmath106 .",
    "there are two possibilities . if particle @xmath64 ended a time step at time @xmath107 in the previous iteration , we are in luck , and we can use the same procedure we used in the two - body case . to be specific ,",
    "we test if the time step according to criterion ( [ eq : nbdt ] ) is smaller than @xmath105 ; if so , we halve the value of @xmath105 . however , if we are not in luck , and we do not have time @xmath107 in the list of times for which particle @xmath64 was integrated in the previous iteration , we simply adopt the time step that we obtained looking in the forward direction . in that case",
    ", we have to wait till a next iteration , to apply the time symmetrization procedure .",
    "this occasional miss explains why the iteration procedure often requires several iterations before accurate time symmetry can be obtained .    to calculate the force at the new time for particle @xmath64 ,",
    "we use the positions of the other particles @xmath66 calculated by interpolation , based on the previous iteration , in the following way .",
    "the interpolation itself is done in a straightforward , linear way .",
    "however , since we have a more accurate position at hand for at least the starting point of each orbit segment , for particle @xmath66 , we may as well correct the old orbit segment by shifting it rigidly by an amount equal to the difference between the starting point of the current and the previous iteration .    to be specific ,",
    "the interpolated position at time @xmath65 for particle @xmath66 is given by @xmath108 where @xmath109 , @xmath110 is the largest time in the list of times for particle @xmath66 not exceeding @xmath65 and @xmath111 is the next time in that list , immediately following @xmath110 . here",
    "both @xmath112 and @xmath113 are obtained from the stored results from the previous iteration .",
    "the correction term @xmath114 is defined as @xmath115 where @xmath116 is the position of particle @xmath66 at time @xmath110 in the current iteration . as in the case",
    "described above , sometimes we are unlucky , and @xmath116 is not available . in that case",
    "we just set @xmath114 to be zero , postponing further accuracy improvement until the next iteration .    to make our predictor - corrector form of the leapfrog integration scheme consistent",
    ", we use the same interpolation scheme for the predictor part , for the particles to be integrated . for the corrector part",
    ", we used the trapezoidal scheme , as follows :    @xmath117    here , the subscript _ old _ refers to the value at the previous time , the subscript _",
    "c , new _ refers to the corrected value at the new time , @xmath118 is calculated with the old values for the positions , and @xmath119 is calculated with the predicted values of the positions .",
    "note that the first corrected quantity that can be computed is @xmath120 , based on the old and predicted quantities .",
    "after that , we can also compute the corrected quantity @xmath121 , based on the old quantities and @xmath120 .",
    "we have succeeded in constructing an algorithm for time symmetrizing block time steps that does not show a linear growth of energy errors . as far as we know , this is the first such algorithm that has been discovered .",
    "we expect this algorithm to have practical value for a wide range of large - scale parallel n - body simulations .",
    "while we have illustrated our approach for simplicity with the leapfrog scheme , all our considerations carry over to higher - order schemes , as long as the base scheme can be made time - symmetric when iterated to convergence .",
    "an example of such a scheme is the widely used hermite scheme@xcite .",
    "we plan to discuss such applications in a future paper .",
    "a major novelty in our scheme has been the introduction of a time period , which we can an era , during which all positions and velocities of all particles are stored in memory .",
    "these values are retained from one iteration to the next .",
    "we expect that this procedure will have other advantages as well , in that it prevents sudden surprises to occur .",
    "for example , if a particle will suddenly require a very high speed , it may approach another particle with a long time step without any warning . as another example",
    ", a star may undergo a supernova explosion , something that other particles will normally only notice when there current time step has finished . in both cases , after the first iteration all particles will have access to full knowledge about these unexpected events , and during the iteration procedure , they can automatically adapt to the new situation .",
    "our new scheme promises to be competitive with traditional non - symmetrized schemes , especially for very long integration times , in that the same error bounds may be reached using less computer time . to prove that this will be the case for realistic applications clearly requires further detailed investigations , beyond the scope of the current paper .",
    "the memory use of our scheme may seem formidable , and indeed , when a large value for the era size is chosen , memory use is increased significantly over traditional schemes . for those n - body calculations that are cpu time limited , this may not be much of a concern . however , for large - scale cosmological simulations and other applications for which memory is important , it is possible to choose an era size in such a way that the memory requirement of the new scheme is less than twice the memory requirement of non - symmetric schemes , at a cpu performance penalty of less than a factor two . here",
    "the trick is to take an era size close to the harmonic mean of the time steps of all particles . in that way",
    ", half the computing cost of the non - symmetric scheme is associated with particles that have time steps shorter than this era size . those particles with natural time steps longer than this era choice",
    "will see their step size shortened to the era size , but the total increase in time steps will be less than a factor two .",
    "the reason that our scheme shows a dramatic improvement in accuracy is time symmetry , which suppresses linear error growth .",
    "the reason that our scheme is somewhat complicated is purely empirical : all else failed , in our attempts to try simpler schemes . whether our procedure is the simplest scheme that actually can produce time symmetric versions of block time step codes is an open question .",
    "it may well be , but we certainly have no mathematical proof .",
    "this is an interesting question to be pursued further , for theoretical as well as practical reasons .",
    "we acknowledge conversations with joachim stadel at the ipam workshop on n - body problems in astrophysics , in april 2005 , where he presented a time symmetric version of the preprint by @xcite which is similar to our first attempt at a solution , described in section [ subsec : firsttry ] .",
    "we thank sverre aarseth , mehmet atakan grkan , and an anonymous referee for their comments on the manuscript .",
    "acknowledge research support from itu - sun ceaet grant 5009 - 2003 - 03 .",
    "thanks prof .",
    "ninomiya for his kind hospitality at the yukawa institute at kyoto university , through the grants - in - aid for scientific research on priority areas , number 763 , `` dynamics of strings and fields '' , from the ministry of education , culture , sports , science and technology , japan .        hut , p. , funato , y. , kokubo , e. , makino , j. & mcmillan , s. , 1997 , _ time symmetrization meta - algorithms _ , in _ computational astrophysics _ , eds .",
    "d. a. clarke and m. j. west , asp conference series , vol .",
    "123 ( san francisco : asp ) , pp ."
  ],
  "abstract_text": [
    "<S> the method of choice for integrating the equations of motion of the general n - body problem has been to use an individual time step scheme . for the sake of efficiency , </S>",
    "<S> block time steps have been the most popular , where all time step sizes are smaller than a maximum time step size by an integer power of two . </S>",
    "<S> we present the first successful attempt to construct a time - symmetric integration scheme , based on block time steps . </S>",
    "<S> we demonstrate how our scheme shows a vastly better long - time behavior of energy errors , in the form of a random walk rather than a linear drift . </S>",
    "<S> increasing the number of particles makes the improvement even more pronounced .    ,    ,    </S>",
    "<S> ,    n - body , celestial mechanics , stellar dynamics ; </S>"
  ]
}