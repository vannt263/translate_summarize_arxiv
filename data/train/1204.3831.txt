{
  "article_text": [
    "with the rapid growth of modern computer networks , increasing numbers of systems contain a certain quantity of service providing servers around the world and provide services via the internet .",
    "it s important to verify the legitimacy of a remote user in a public environment before he / she can access the service .",
    "but traditional password based authentication schemes are mostly considered in single server environments .",
    "they are unfitted for the multi - server environments from two aspects . on the one hand",
    ", users need to register in each server and to store large sets of data , including identities and passwords . on the other hand ,",
    "servers are required to store a verification table containing user identities and passwords . @xcite",
    "firstly proposed a remote authentication scheme using smart card based on elgamal s public key cryptosystem@xcite , which does nt need to maintain verification tables .",
    "after that , numerous smart card based single - server authentication schemes using one - way hash functions had been proposed@xcite . however , it is still hard for a user to use different smart cards to login and access different remote servers .",
    "this is because users still need to remember numerous sets of identities and passwords . in order to resolve this problem ,",
    "several schemes have been proposed to the study of authentication and key agreement in the multi - server environment@xcite , all of which claim not to store verification tables .",
    "most of these schemes can be divided into three categories : hash - based , symmetric cryptosystem based and public - key cryptosystem based .",
    "hash - based protocols are considered to be with the most efficiency .    among these schemes , in 2009 ,",
    "hsiang and shih proposed a dynamic identity and one - way hash based remote user authentication protocol for multi - server architecture without a verification table@xcite .",
    "however , in 2011 , sood et al.@xcite pointed that hsiang and shih s protocol can not resist many types of security attacks , such as replay attack , impersonation attack and stolen smart card attack",
    ". then sood et al . proposed an improved scheme which is claimed to achieve user anonymity and resist different types of common security attacks . recently , in @xcite , li et al . found that sood et al.s protocol is still vulnerable to some types of known attacks , such as replay attack , stolen smart card attack and so on .",
    "also the mutual authentication and key agreement phase of sood et al.s protocol can not be successfully finished within some specific scenes .",
    "furthermore , in @xcite , they proposed an improved dynamic identity based authentication and key agreement protocol for multi - server architecture , which is claimed to remove the aforementioned weaknesses of sood et al.s protocol . unfortunately , our further research shows that li et al.s protocol contains several drawbacks and can not resist some types of known attacks , such as leak - of - verifier attack , stolen smart card attack , eavesdropping attack , replay attack , deny - of - service attack and forgery attack and so on .",
    "the rest of this paper is organized as follows : section 2 gives the overview of li et al.s protocol ; section 3 points out the security weaknesses of the protocol in details .",
    "section 4 gives our proposed protocol .",
    "security and performance analysis of our proposed protocol are given in section 5 and section 6 .",
    "at last , section 7 presents the overall conclusion .",
    "in this section , we give the overview of li et al.s proposed protocol , which is an enhanced scheme from sood et al.s protocol .",
    "we firstly summarize the notations used through out li et al.s paper in table 1 .",
    "li et al.s protocol involves 3 kinds of participants : users(taking @xmath0 for example ) , service providing servers(taking @xmath1 for example ) , and the control server(@xmath2 ) .",
    "@xmath2 is a trusted third party responsible for the registration and authentication of the users and the service providing servers .",
    "@xmath2 chooses two security elements @xmath3 and @xmath4.in the registration phase , @xmath1 obtains @xmath5 and @xmath6 from @xmath2 via a secure channel .",
    "@xmath0 randomly selects a number @xmath7 , and computes @xmath8 . after the initialization and the registration phases",
    ", @xmath0 can get a smart card from @xmath2 via a secure channel .",
    "the following elements , @xmath9 , @xmath10 and @xmath7 are stored in the smart card for the user @xmath0 : @xmath11        in @xmath0 s login phase , @xmath0 inserts his smart card into a terminal and inputs his identity @xmath12 and password @xmath13 , then computes @xmath14 and @xmath15 . if @xmath16 is equal to the stored @xmath17 , @xmath0 is considered as a legitimate user",
    "else , the terminal rejects @xmath0 s login request . after the verification , the authentication and key agreement phase takes place among @xmath0 , @xmath1 and @xmath2 , as depicted in figure 1 .",
    "we introduce them as follows :    1 .",
    "* @xmath0 @xmath18 @xmath1 : \\{@xmath19 , @xmath20 , @xmath21 , @xmath22}*. + @xmath0 computes @xmath23 and generates a random number @xmath24 .",
    "then @xmath0 computes @xmath19 , @xmath20 , @xmath21 , @xmath22 as follows : @xmath25 then , @xmath0 sends \\{@xmath19 , @xmath20 , @xmath21 , @xmath22}to @xmath1 over a public channel .",
    "* @xmath1 @xmath18 @xmath2 : \\{@xmath19 , @xmath20 , @xmath21 , @xmath22 , @xmath26 , @xmath27 , @xmath28 } * .",
    "+ after receiving the message from @xmath0 , the server @xmath1 randomly selects a number @xmath29 and computes @xmath27 , @xmath28 as follows : @xmath30 then @xmath1 sends \\{@xmath19 , @xmath20 , @xmath21 , @xmath22 , @xmath26 , @xmath27 , @xmath28 } to @xmath2 over the public channel .",
    "* @xmath2 @xmath18 @xmath1 : \\{@xmath31 , @xmath32 , @xmath33 , @xmath34 } * .",
    "+ after receiving the message from @xmath1 , @xmath2 gets @xmath35 and @xmath36 . then @xmath2 verifies whether @xmath37 is equal to the received @xmath28 . if not , @xmath2 terminates the session ; else , the legitimacy of @xmath1 is verified by @xmath2 .",
    "after that , @xmath2 computes the following elements : @xmath38 then @xmath2 verifies whether @xmath39 is equal to the received @xmath20 . if not , @xmath2 terminates the session ; else , the legitimacy of @xmath0 is verified by @xmath2 .",
    "@xmath2 randomly selects a number @xmath40 , and computes the following elements : @xmath41 then @xmath2 sends \\{@xmath31 , @xmath32 , @xmath33 , @xmath34 } to @xmath42 over a public channel .",
    "* @xmath1 @xmath18 @xmath0 : \\{@xmath33 , @xmath34}*. + after receiving the message from @xmath2 , @xmath1 computes : @xmath43 then @xmath1 verifies whether @xmath44 is equal to the received @xmath33 . if not , @xmath1 terminates the session ; else , the legitimacy of @xmath2 is verified by @xmath1 . after that , @xmath1 sends the message \\{@xmath33 , @xmath34 } to @xmath0 .",
    "5 .   after receiving the message from @xmath1",
    ", @xmath0 computes to get @xmath45 as follows : @xmath46 then @xmath47 verifies whether @xmath45 is equal to the received @xmath33 . if not , @xmath0 terminates the session ; else , the legitimacy of @xmath2 and @xmath1 is verified by @xmath0 .",
    "finally , @xmath0 , @xmath1 and @xmath2 can separately compute the shared session key @xmath48 as follow : @xmath49",
    "although in @xcite , the authors claimed that their protocol can resist many types of security attacks .",
    "unfortunately , our further research shows that li et al.s protocol contains several drawbacks and can not resist some types of known attacks , such as replay attack , deny - of - service attack , smart card forgery attack , eavesdrop attack and forgery attack . the analysis in details",
    "is described as follows .",
    "assume that a malicious attacker can eavesdrop the first sending message from a legitimate user to the server @xmath50 in step1 of the authentication and key agreement phase .",
    "if the message \\{@xmath19 , @xmath20 , @xmath21 , @xmath22 } is eavesdropped , replay attacks can easily be launched by retransmitting \\{@xmath19 , @xmath20 , @xmath21 , @xmath22 } to @xmath1 .",
    "this type of attacks can trick the server @xmath50 and @xmath2 into implementing the following steps step2 - 4 .",
    "moreover , @xmath51 and @xmath2 can not identify the message replayed by the malicious attackers .",
    "even if the user can not get the final correct session key @xmath48 , the server @xmath50 and @xmath2 have made great consumption of computing resources , communication resources and storage resources .",
    "a large number of replay attacks launched at the same time will form a deny - of - service attack , which prevents normal visits from legitimating legitimate users .",
    "assume there is an inside malicious user who has a legitimate smart card . from the elements stored in the smart card",
    ", the malicious user can straightly get @xmath10 .",
    "the malicious attacker @xmath52 can firstly compute his / her @xmath53(@xmath54 ) , and then computes @xmath55 . by knowing @xmath10 and @xmath56 , the attacker can further launch eavesdrop attacks to get the session key shared among any other users , the related service providing servers and @xmath2 .",
    "li et al.s protocol lacks of verification of @xmath57 and @xmath58 by @xmath2 , thus a malicious attacker known @xmath10 and @xmath56 in advance can arbitrarily forge a new smart card . if the attacker wants to forge @xmath59 s smart card , he / she firstly sets @xmath60 and @xmath61 , where @xmath62 and @xmath63 are two random numbers with the same length as @xmath57 , @xmath58 .",
    "the elements of a forgery smart card can be further set as : @xmath64    then if the malicious attacker wants to access the service providing server @xmath1 by using this forgery smart card .",
    "the first message can be computed as : @xmath65    following li et al.s protocol , this message can successfully pass the legitimacy verification by @xmath2 and @xmath1 .",
    "if the random numbers separately chosen by @xmath1 and @xmath2 are @xmath66 and @xmath67 , the malicious attacker , @xmath1 and @xmath2 can successfully agree on a common session key @xmath68 .",
    "assume the authentication and key agreement phase takes place among the legitimate user @xmath69 , the service providing server @xmath70 and the control server @xmath2 .",
    "there is a malicious attacker who has the ability of eavesdropping all of the messages exchanged among these three participants .",
    "furthermore , the malicious attacker is assumed to have known @xmath10 , @xmath56 in advance .",
    "the first message is \\{@xmath71 , @xmath72 , @xmath73 , @xmath74 } send from @xmath69 . from @xmath71 ,",
    "@xmath75 can been easily obtained as follow : @xmath76 next , @xmath77 can be extracted from @xmath73 , then @xmath78 can be extracted from @xmath77 .",
    "the details are described as follows : @xmath79 after that from @xmath74 , @xmath80 can also be easily extracted as : @xmath81    from the above process , only a sending message via a public channel can leak crucial security information ( @xmath80 , @xmath78 , @xmath75 ) of @xmath69 .",
    "also @xmath77 stored in @xmath69 s smart card can also be got .",
    "although because of the user anonymity support , the malicious attacker can not obtain @xmath69 s identity @xmath82 to compute @xmath83 and @xmath84 , but next we will describe how to extract the final session key @xmath48 .    after eavesdropping the message",
    "send in step3 or step4 .",
    "the malicious attacker can extract @xmath85 from @xmath86 as follow : @xmath87    now , the malicious attacker can compute the final session key negotiated among @xmath69 , @xmath70 and @xmath2 .",
    "furthermore , he / she can decrypted all the encrypted data between @xmath69 and @xmath70 .",
    "after successfully obtaining security information of a legitimate user(such as @xmath69 ) via the eavesdrop attack described in section 3.4 , the attacker can launch the masquerade attack to act as the legitimate user . by means of the internal attack",
    ", the malicious attackers can know @xmath10 and @xmath56 . by means of the eavesdrop attack ,",
    "the malicious attacker can further compute @xmath80 , @xmath78 and @xmath77 . by virtue of these information ,",
    "the malicious attacker can pose as @xmath69 to launch authentication and key agreement phase to any other service providing server(take @xmath88 for example ) and @xmath2 .",
    "firstly , the malicious attacker randomly select a number @xmath89 and can successfully forge the first step message to pretend to be @xmath69 : @xmath90    then assume @xmath88 and @xmath2 separately select random numbers @xmath91 and @xmath92 , and step2-step4 are performed normally .",
    "then the malicious attacker , @xmath1 and @xmath2 `` successfully '' agree on a session key @xmath93 . but unfortunately @xmath88 and @xmath2 mistakenly believe that they are communicating with the legitimate user @xmath69 .",
    "first assume that the malicious attacker has eavesdropped a message send from @xmath70 to get @xmath27 and @xmath28 .",
    "furthermore assume a legitimate user @xmath69 s security information has been leaked to the malicious attacker based on the internal attack and the eavesdrop attack .",
    "when @xmath69 wants to login the server @xmath70 , he / she selects a random number @xmath75 and sends the first message in step1(\\{@xmath71 , @xmath72 , @xmath73 , @xmath74 } ) to the service providing server @xmath70 .",
    "the malicious attacker can attack the real server @xmath70 to be down and masquerades to be @xmath70 himself / herself .",
    "after eavesdropping this message , the malicious attacker can attach @xmath27 and @xmath28 in the first message:\\{@xmath71 , @xmath72 , @xmath73 , @xmath74 , @xmath94 , @xmath27 , @xmath28 } .",
    "this message can also successfully pass @xmath2 s verification .",
    "@xmath92 is the random number selected by @xmath2 . after implementing of step3 and step4 ,",
    "the user @xmath69 and @xmath2 can compute the session key as @xmath95 and unfortunately @xmath69 mistakenly believe that he / she is communicating with the legitimate true @xmath70 .",
    "although the malicious attacker can not extract the random number @xmath29 from @xmath27 , he / she still can exact the session key @xmath48 by means of `` masquerade attack as a legitimate user '' described in section 3.5 .",
    "so the malicious attacker can not only masquerade to be the real server , but also decrypt the encrypted data send from the user in the dark .",
    "in this section , we will describe an improved protocol to make up the security weaknesses of li et al.s protocol .",
    "our protocol contains three kinds of participants(the user , the service providing server and the controlling server ) and contains three phases : 1)initialization and registration phase ; 2 ) login phase ; 3)authentication and key agreement phase .",
    "because the notions are different in using from those of li et al.s protocol in protocol designing and some new notions are defined , here we firstly give the notations used in our proposed protocol(summarize in table 2 ) .",
    "we show the protocol in figure 2 and provide more details as follows .",
    "assume the control server @xmath2 is a trusted third party responsible for registration and authentication of users and service providing servers .",
    "@xmath2 chooses two random numbers @xmath3 and @xmath4 .",
    "the registration phase of the user @xmath0 is as follows :    1 .",
    "the user @xmath0 freely choose his / her identity @xmath12 and password @xmath13 , and randomly choose a number @xmath7 .",
    "then @xmath0 compute @xmath8 , and submits the message \\{@xmath12 , @xmath7 , @xmath57 } to @xmath2 via a secure channel .",
    "2 .   after receiving the message , @xmath2 first verifies user s legitimacy . then , @xmath2 computes @xmath96 , @xmath97 .",
    "@xmath2 sends @xmath58 to @xmath0 via a secure channel .",
    "3 .   after receiving the smart card , @xmath0 computes @xmath98 and @xmath99 .",
    "then @xmath0 enters@xmath17 , @xmath100 , @xmath9 and @xmath7 into the smart card . at last ,",
    "the smart card contains ( @xmath17 , @xmath100 , @xmath9 , @xmath7 ) .    for the service providing server @xmath1",
    ", he / she first chooses a random number @xmath101 , and use his / her identity @xmath1 to register with @xmath2 . @xmath2",
    "computes @xmath102 , @xmath103",
    ". then @xmath2 sends @xmath104 to @xmath1 via a secure channel .",
    "@xmath1 stores @xmath104 and @xmath101 in his / her memory .",
    "when the user @xmath0 wants to login to access the server @xmath1 , @xmath0 inserts his smart card into a terminal and inputs his / her identity @xmath12 and password @xmath13 , then computes @xmath14 and @xmath105 . if @xmath16 is equal to the stored @xmath17 , @xmath0 is considered as a legitimate user",
    "otherwise , the terminal rejects @xmath0 s login request .      1 .",
    "* @xmath0 @xmath18 @xmath1 : \\{@xmath19 , @xmath21 , @xmath22 , @xmath20 , @xmath106 , @xmath107}*. + @xmath0 chooses a random number @xmath24 and generates a current timestamp value @xmath107 .",
    "then @xmath0 computes @xmath58 , @xmath19 , @xmath22 , @xmath21 , @xmath20 as follows : @xmath108 where , `` 00 '' is a 2-bit binary-``0 '' , and `` 11 '' is a 2-bit binary-``1 '' .",
    "+ then , @xmath0 sends \\{@xmath19 , @xmath21 , @xmath22 , @xmath20 , @xmath106 , @xmath107}to @xmath1 over a public channel .",
    "* @xmath1 @xmath18 @xmath2 : \\{@xmath19 , @xmath21 , @xmath22 , @xmath20 , @xmath106 , @xmath107 , @xmath109 , @xmath27 , @xmath110 , @xmath28 , @xmath111}*. + after receiving the message from @xmath0 , the server @xmath1 first checks whether the session delay is within the tolerable time interval @xmath112 .",
    "assume the current time is @xmath113 .",
    "if @xmath114 , the session is timeout and @xmath1 terminates the session ; otherwise , @xmath1 continues to perform the following operations .",
    "+ @xmath1 randomly selects a number @xmath29 and computes @xmath109 , @xmath27 , @xmath110 , @xmath28 as follows : @xmath115 where , ` 00' is a 2-bit binary-``0 '' , and `` 11 '' is a 2-bit binary-``1 '' .",
    "+ then @xmath1 sends \\{@xmath19 , @xmath21 , @xmath22 , @xmath20 , @xmath106 , @xmath107 , @xmath109 , @xmath27 , @xmath110 , @xmath28 , @xmath111 } to @xmath2 over the public channel .",
    "* @xmath2 @xmath18 @xmath1 : \\{@xmath13 , @xmath31 , @xmath32 , @xmath33 } * .",
    "+ after receiving the message from @xmath1 , @xmath2 first checks whether the session delay is within the allow time interval @xmath112 .",
    "assume the current time is @xmath116 .",
    "if @xmath117 , the session is timeout and @xmath2 terminates the session ; @xmath2 continues to perform the following operations .",
    "+ @xmath2 computes @xmath118 , @xmath119 and @xmath120 .",
    "then @xmath2 verifies whether @xmath121 is equal to the received @xmath27 . if not , @xmath2 terminates the session ; otherwise , @xmath2 continues to perform the following operations .",
    "@xmath2 computes the following elements : @xmath122 then @xmath2 verifies whether @xmath123 is equal to the received @xmath21 . if not , @xmath2 terminates the session ; otherwise , @xmath2 continues to compute the following elements : @xmath124 then @xmath2 verifies whether @xmath125 and @xmath126 . if not , @xmath2 terminates the session ; otherwise , @xmath2 makes sure the messages are from real @xmath0 and @xmath1 . after the verification",
    ", @xmath2 randomly selects a number @xmath40 , and computes @xmath13 , @xmath31 , @xmath32 @xmath33 as follows : @xmath127 then @xmath2 sends \\{@xmath13 , @xmath31 , @xmath32 , @xmath33 } to @xmath42 over a public channel .",
    "* @xmath1 @xmath18 @xmath0 : \\{@xmath32 , @xmath33}*. + after receiving the message from @xmath2 , @xmath1 firstly computes to get the following elements : @xmath128 then @xmath1 verifies whether @xmath129 is equal to the received @xmath31 . if not , @xmath1 terminates the session ; otherwise , the legitimacy of @xmath2 is verified by @xmath1 .",
    "after that , @xmath1 sends the message \\{@xmath32 , @xmath33 } to @xmath0 .",
    "5 .   after receiving the message from @xmath1",
    ", @xmath0 computes to get @xmath44 as follows : @xmath130 then @xmath47 verifies whether @xmath44 is equal to the received @xmath33 . if not , @xmath0 terminates the session ; otherwise , the legitimacy of @xmath2 and @xmath1 is verified by @xmath0 .",
    "finally , @xmath0 , @xmath1 and @xmath2 can separately compute the common session key @xmath48 as follow : @xmath131      after password based verification in the registration phase , the user @xmath0 s password @xmath13 does not appear in @xmath58 .",
    "thus password updating / changing can happen in anytime .",
    "@xmath0 need to submit his / her @xmath12 and @xmath132 with new password @xmath133 to @xmath2 via a secure channel .",
    "@xmath2 updates @xmath0 s password in its verification table .",
    "meanwhile , @xmath0 can update the parameters in his / her smart card : @xmath134      in order to prevent malicious attackers linking eavesdropped messages of different sessions , we can update the user s @xmath135 periodically to provide security . @xmath0",
    "reselects a random number @xmath136 , and compute @xmath137",
    ". then @xmath0 submits \\{@xmath12,@xmath136 , @xmath138 } to @xmath2 . after verifying @xmath0 s legitimacy",
    ", @xmath2 recomputes @xmath139 , @xmath140 and submits @xmath141 to @xmath0 via a secure channel . after receiving @xmath141",
    ", @xmath0 computes @xmath142 , @xmath143 . at last the smart card",
    "is updated to \\{@xmath144 , @xmath145,@xmath9 , @xmath136}. now @xmath0 s protected pseudonym identity @xmath106 is dynamically changed to @xmath146 .",
    "service providing servers can also periodically update their protected pseudonym identities . take @xmath1 for example",
    ", @xmath1 reselects a random number @xmath147 , and use his / her identity @xmath1 to register with @xmath2 . @xmath2",
    "computes @xmath148 , @xmath149 .",
    "then @xmath2 sends @xmath150 to @xmath1 via a secure channel .",
    "@xmath1 updates @xmath150 and @xmath147 in his / her memory .",
    "in this section , we summarize security analysis of our proposed protocol and compare it with other two related protocols .",
    "first we list security functionality comparison among our protocol and other two related protocols in table 3 .",
    "it demonstrates that our protocol is more secure than other two related protocols .",
    "here we discuss the main security features of our proposed protocol in details :      for the user @xmath0 , we use @xmath106 instead of @xmath12 . by using protected pseudonym identities of users instead of real ones",
    ", the malicious attacker can not get user identities .",
    "meanwhile service providing servers can not know users real identities either . in this way , our protocol provides user anonymity .",
    "furthermore , updating users pseudonym identities periodically can prevent the malicious attacker linking eavesdropped messages of different sessions from the same user .      despite of user anonymity",
    ", @xmath2 can still extract users real identities and link them with protected pseudonym identities .",
    "this make our protocol have the feature of traceability .",
    "this is newly - added function in our proposed protocol different from li et al.s protocol .",
    "using protected pseudonym identities of users and service providing servers ensures that only legitimate @xmath2 can get their real identities .",
    "this can prevent the leakage of private user identities and server identities to malicious attackers . moreover , in order to prevent malicious attackers link eavesdropped messages of different sessions , protected pseudonym identities of users and service providing servers are dynamic and can changed in any time .      as in section 3.2 , within li et al.s protocol , an internal attack can cause information leakage . @xmath10 and @xmath56 are the common parameters for all users , which can further launch eavesdrop attacks , smart card forgery attacks , masquerade attacks and so on . in our proposed protocol , we do not straightly use @xmath10 , @xmath151 , @xmath56 directly .",
    "take the user @xmath52 as insider attacker for example , we use @xmath152 and compute to get @xmath153 , @xmath154 in his / her smart card .",
    "@xmath52 can not guess to generate parameters of any other users smart cards and can not masquerade as any other legitimate user by using security information of himself / herself .      in our proposed protocol",
    ", we firstly assume that if a smart card is stolen , physical protection methods can not prevent malicious attackers to get the stored secure elements .",
    "still take @xmath0 for example , if his / her smart card is stolen , the malicious attacker can get ( @xmath17 , @xmath100 , @xmath9 , @xmath7 ) . but without inputting right password @xmath13 , the malicious attacker can not compute @xmath57 , and further extract @xmath58 from @xmath100 .",
    "firstly the timestamp value is used in our proposed protocol which makes the malicious attacker can not use early message to launch replay attacks .",
    "this makes replay attacks and deny - of - service attacks hard to be launched .",
    "using @xmath21 and @xmath107 in computing @xmath27 avoids the case in li et al.s protocol : if @xmath27 and @xmath28 attached by the service providing server @xmath1 are eavesdropped , they can be used to launch replay attacks , which is described in section 3.6 .",
    "moreover using and verifying timestamp can reduce the success rate of replay attacks .",
    "the malicious attacker can not extract private security information from eavesdropping messages over public channels .",
    "different from li et al.s protocol , because of using @xmath135 in compute @xmath58 and not sharing @xmath151 and @xmath56 between @xmath2 and every user , the malicious attacker can not use one user s elements to extract any other user s security elements in our proposed protocol . moreover",
    ", the malicious attacker can not compute @xmath155 , so @xmath48 can not be computed by the malicious attacker .",
    "the malicious attacker can not derive @xmath0 s security information from eavesdropped sending messages among @xmath0 , @xmath1 and @xmath2 ; meanwhile , the malicious attacker can not forge other user s smart card from known security information of a malicious inside user .",
    "furthermore , using the timestamp value prevents replay of the first message .",
    "because of the above 3 reasons , users can not be masqueraded by malicious attackers .",
    "because of using @xmath21 and @xmath107 in computing @xmath27 , the malicious attacker can not replay @xmath1 s message to attach to the end of the message in step 1 , thus servers can not be masqueraded by malicious attackers .",
    "in this section , we evaluate the computational complexity , computation overhead , storage overhead of our proposed protocol and give the comparisons with other two related protocols : li et al. protocol@xcite and sood et al.s protocol@xcite . before analyzing in details ,",
    "we first give the notation @xmath156 as the time of computing the hash operation .",
    "because @xmath157 and `` @xmath158 '' operations requires very few computations , they are usually omitted in computational complexity computation .",
    "firstly , computational complexity comparison of our protocol and the other two related protocols is given in table 4 .",
    "as in @xcite , we only take the login phase , authentication and session key agreement phase into consideration . different from the description in @xcite ,",
    "the description of the login phase in li et al.s protocol relates only to user legitimacy the by terminal .",
    "similarly , we merge step 2 of the login phase in @xcite into the first step of the authentication and key agreement phase . the similar decryption modification is adopted to sood et al.s protocol@xcite . furthermore , there are separately 1 time of hash computation for computing @xmath48 for the user , the service providing server and @xmath2 , which is not mentioned in table 4 . from table 4 , it is obvious that our protocol almost has the same computational complexity with the other two related protocols . in the authentication and key agreement phase of our proposed protocol ,",
    "@xmath2 have five optional hash operations , which proving the function of traceability .",
    "secondly , we discuss about communication overhead , our proposed protocol and other two related protocols all require 4 times of message transmission in the authentication and key agreement phase . take @xmath0 , @xmath1 and @xmath2 for example , four times of message transmission are @xmath159 , @xmath160 , @xmath161 and @xmath162 , which is demonstrated in figure 1 .",
    "thirdly , just as li et al.s protocol and sood et al.s protocol , our proposed protocol also do not require every service providing server to maintain a verification table .",
    "meanwhile @xmath2 maintains a verification table which is only required to search in the registration phase .",
    "@xmath2 do nt need to use the verification table in the authentication and key agreement phase .",
    "each user only needs to have a smart card .",
    "each service providing server(take @xmath1 for example ) only needs to store @xmath104 and a randomly chosen number@xmath101 obtained in the registration phase .",
    "besides the verification table , @xmath2 only knows @xmath3 and @xmath4 .",
    "in this paper , based on discussing the security weaknesses of li et al.s protocol , we propose an improved dynamic pseudonym identity based authentication and key agreement protocol , which is suitable for the multi - server environment . compared with related protocols ,",
    "our proposed protocol is demonstrated to satisfy all the essential security requirements for authentication and key agreement in the multi - server environment .",
    "meanwhile , in comparison with li et al.s protocol and sood et al s protocol , our proposed protocol keeps efficient , such as low computational complexity , low communication overhead and low storage overhead . in the future , we will survey suitable solutions to further reduce the computational complexity and improve protocol performance while not reducing security .",
    "this work is supported by the national s&t major project of china under grant no . 2010zx03003 - 002 , 2011zx03005 - 006 , the national natural science foundation of china under grant no.60903216 .",
    "33 m. s. hwang , l. h. li , a new remote user authentication scheme using smart cards .",
    "ieee transactions on industrial electronics , 2000 ; 46(1 ) : 28 - 30        x. li , w. qiu , d. zheng , k. chen , j. li .",
    "anonymity enhancement on rebust and efficient password - authenticated key agreement using smart cards , ieee transactions on industrial electronics , 2010 ; 57(2):793 - 800                          x. li , y.p .",
    "xiong , j. ma , w.d .",
    "wang , an efficient and security dynamic identity based authentication protocol for multi - server architecture using smart cards , journal of network and computer applications , 2012 ; 35(2 ) : 763 - 769"
  ],
  "abstract_text": [
    "<S> traditional password based authentication schemes are mostly considered in single server environments . </S>",
    "<S> they are unfitted for the multi - server environments from two aspects . on the one hand </S>",
    "<S> , users need to register in each server and to store large sets of data , including identities and passwords . on the other hand , </S>",
    "<S> servers are required to store a verification table containing user identities and passwords . </S>",
    "<S> recently , on the base on sood et al.s protocol(2011 ) , li et al . proposed an improved dynamic identity based authentication and key agreement protocol for multi - server architecture(2012 ) . </S>",
    "<S> li et al . claims that the proposed scheme can make up the security weaknesses of sood et al.s protocol . </S>",
    "<S> unfortunately , our further research shows that li et al.s protocol contains several drawbacks and can not resist some types of known attacks , such as replay attack , deny - of - service attack , internal attack , eavesdropping attack , masquerade attack , and so on . in this paper </S>",
    "<S> , we further propose a light dynamic pseudonym identity based authentication and key agreement protocol for multi - server architecture . in our scheme , </S>",
    "<S> service providing servers do nt need to maintain verification tables for users . </S>",
    "<S> the proposed protocol provides not only the declared security features in li et al.s paper , but also some other security features , such as traceability and identity protection .    authentication and key agreement ; dynamic pseudonym identity ; multi - server architecture ; hash function ; smart card </S>"
  ]
}