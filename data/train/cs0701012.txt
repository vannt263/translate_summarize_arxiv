{
  "article_text": [
    "a source emits input symbols drawn from the alphabet @xmath6 , where @xmath0 is an integer .",
    "symbol @xmath7 has probability @xmath8 , thus defining probability vector @xmath9 .",
    "only possible symbols are considered for coding and these are , without loss of generality , sorted in decreasing order of probability ; thus @xmath10 and @xmath11 for every @xmath12 such that @xmath13 .",
    "each input symbol is encoded into a codeword composed of output symbols of the @xmath14-ary alphabet @xmath15 .",
    "the codeword @xmath16 corresponding to input symbol @xmath7 has length @xmath17 , thus defining length vector @xmath18 .",
    "the code should be a prefix code , i.e. , no codeword @xmath16 should begin with the entirety of another codeword  @xmath19 .    for the bounded - length coding variant of huffman coding introduced here , all codewords must have lengths lying in a given interval [ @xmath4,@xmath1 ] .",
    "consider an application in the problem of designing a data codec which is efficient in terms of both compression ratio and coding speed .",
    "moffat and turpin proposed a variety of efficient implementations of prefix encoding and decoding in @xcite , each involving table lookups rather than code trees .",
    "they noted that the length of the longest codeword should be limited for computational efficiency s sake .",
    "computational efficiency is also improved by restricting the overall range of codeword lengths , reducing the size of the tables and the expected time of searches required for decoding .",
    "thus , one might wish to have a minimum codeword size of , say , @xmath21 bytes and a maximum codeword size of @xmath22 bytes ( @xmath23 ) .",
    "if expected codeword length for an optimal code found under these restrictions is too long , @xmath4 can be reduced and the algorithm rerun until the proper trade - off between coding speed and compression ratio is found .",
    "a similar problem is one of determining opcodes of a microprocessor designed to use variable - length opcodes , each a certain number of bytes ( @xmath24 ) with a lower limit and an upper limit to size , e.g. , a restriction to opcodes being 16 , 24 , or 32 bits long ( @xmath25 , @xmath26 ) .",
    "this problem clearly falls within the context considered here , as does the problem of assigning video recorder scheduling codes ; these human - readable decimal codes ( @xmath27 ) also have bounds on their size , such as @xmath28 and @xmath29 .",
    "other problems of interest have @xmath30 and are thus length limited but have no practical lower bound on length@xcite . yet",
    "other problems have not fixed bounds but a constraint on the difference between minimum and maximum codeword length , a quantity referred to as fringe @xcite . as previously noted , large",
    "fringe has a negative effect of the speed of a decoder .",
    "if we either do not require a minimum or do not require a maximum , it is easy to find values for @xmath4 or @xmath1 that do not limit the problem .",
    "as mentioned , setting @xmath30 results in a trivial minimum , as does @xmath31 .",
    "similarly , setting @xmath32 or using the hard upper bound @xmath33 results in a trivial maximum value .    if both minimum and maximum values are trivial , huffman coding  @xcite yields a prefix code minimizing expected codeword length @xmath34 .",
    "the conditions necessary and sufficient for the existence of a prefix code with length vector @xmath35 are the integer constraint , @xmath36 , and the kraft ( mcmillan ) inequality  @xcite , @xmath37 finding values for @xmath35 is sufficient to find a corresponding code .",
    "it is not always obvious that we should minimize the expected number of questions @xmath38 ( or , equivalently , the expected number of questions in excess of the first  @xmath4 , @xmath39 , where @xmath40 is @xmath41 if @xmath41 is positive , @xmath42 otherwise ) .",
    "we generalize and investigate how to minimize the value @xmath43 under the above constraints for any penalty function @xmath44 convex and increasing on  @xmath45 .",
    "such an additive measurement of cost is called a quasiarithmetic penalty , in this case a convex quasiarithmetic penalty .",
    "one such function @xmath46 is @xmath47 , a quadratic value useful in optimizing a communications delay problem  @xcite .",
    "another function , @xmath48 for @xmath49 , can be used to minimize the probability of buffer overflow in a queueing system@xcite .    mathematically stating the bounded - length problem , @xmath50 note that we need not assume that probabilities @xmath8 sum to @xmath51 ; they could instead be arbitrary positive weights .    given a finite @xmath0-symbol input alphabet with an associated probability vector @xmath52 ,",
    "a @xmath14-symbol output alphabet with codewords of lengths @xmath53 $ ] allowed , and a constant - time calculable penalty function @xmath46 , we describe an @xmath54-time @xmath55-space algorithm for constructing a @xmath46-optimal code . in section  [ prelim ]",
    ", we present a brief review of the relevant literature before extending to @xmath14-ary codes a notation first presented in @xcite .",
    "this notation aids in solving the problem in question by reformulating it as an instance of the @xmath14-ary coin collector s problem , presented in the section as an extension of the original ( binary ) coin collector s problem@xcite .",
    "an extension of the package - merge algorithm solves this problem ; we introduce the reduction and resulting algorithm in section  [ algorithm ] .",
    "an application to a previously proposed problem involving tree fringe is discussed in section  [ conclusion ] .",
    "reviewing how the problem in question differs from binary huffman coding :    1 .",
    "it can be nonbinary , a case considered by huffman in his original paper@xcite ; 2 .",
    "there is a maximum codeword length , a restriction previously considered , e.g. , @xcite in @xmath56 time @xcite and @xmath57 space , but solved efficiently only for binary coding , e.g. , @xcite in @xmath58 time @xmath55 space and most efficiently in @xcite ; 3 .",
    "there is a minimum codeword length , a novel restriction ; 4 .",
    "the penalty can be nonlinear , a modification previously considered , but only for binary coding , e.g. , @xcite .    the minimum size constraint on codeword length requires a relatively simple change of solution range to @xcite .",
    "the nonbinary coding generalization is a bit more involved ; it requires first modifying the package - merge algorithm to allow for an arbitrary numerical base ( binary , ternary , etc . ) , then modifying the coding problem to allow for a provable reduction to the modified package - merge algorithm .",
    "the @xmath54-time @xmath55-space algorithm minimizes height ( that is , maximum codeword length ) among optimal codes ( if multiple optimal codes exist ) .    before presenting an algorithm for optimizing the above problem",
    ", we introduce a notation for codes that generalizes one first presented in  @xcite and modified in @xcite .    _ the key idea : _ each node @xmath59 represents both the share of the penalty ( [ penalty ] ) ( weight ) and the ( scaled ) share of the kraft sum ( [ kraft ] ) ( width ) assumed for the @xmath60th bit of the @xmath7th codeword . by showing that total weight is an increasing function of the penalty and that there is a one - to - one correspondence between an optimal code and a corresponding optimal nodeset , we reduce the problem to an efficiently solvable problem , the coin collector s problem .    in order to do this , we first need to make a modification to the problem analogous to one huffman made in his original nonbinary solution .",
    "we must in some cases add a `` dummy '' input or `` dummy '' inputs of probability @xmath61 to the probability vector to assure that the optimal code has the kraft inequality satisfied with equality , an assumption underlying both the huffman algorithm and ours .",
    "if we use the minimum number of dummy inputs needed to make @xmath62 , we can assume without loss of generality that @xmath63 .",
    "with this modification , we present nodeset notation :    a node is an ordered pair of integers @xmath64 such that @xmath65 and @xmath66 . call the set of all possible nodes  @xmath67 .",
    "this set can be arranged in an @xmath68 grid , e.g. , fig .",
    "[ nodesetnum ] .",
    "the set of nodes , or nodeset , corresponding to input symbol @xmath7 ( assigned codeword  @xmath16 with length  @xmath69 ) is the set of the first  @xmath70 nodes of column  @xmath7 , that is , @xmath71 .",
    "the nodeset corresponding to length vector  @xmath35 is @xmath72 ; this corresponds to a set of @xmath0 codewords , a code .",
    "thus , in fig .  [ nodesetnum ] , the dashed line surrounds a nodeset corresponding to @xmath73 .",
    "we say a node @xmath59 has width @xmath74 and weight @xmath75 , as shown in the example in fig .",
    "[ nodesetnum ] .",
    "note that if @xmath76 , @xmath77 .",
    "given valid nodeset @xmath78 , it is straightforward to find the corresponding length vector and , if it satisfies the kraft inequality , a code .",
    "we find an optimal nodeset using the @xmath14-ary coin collector s problem .",
    "let @xmath79 denote the set of all integer powers of a fixed integer @xmath80 .",
    "the coin collector s problem of size @xmath81 considers `` coins '' indexed by @xmath82 .",
    "each coin has a width , @xmath83 ; one can think of width as coin face value , e.g. , @xmath84 for a quarter dollar ( 25 cents ) .",
    "each coin also has a weight , @xmath85 .",
    "the final problem parameter is total width , denoted  @xmath86 .",
    "the problem is then : @xmath87 we thus wish to choose coins with total width @xmath86 such that their total weight is as small as possible .",
    "this problem has a linear - time solution given sorted inputs ; this solution was found for @xmath23 in @xcite and is found for @xmath88 here .",
    "let @xmath89 denote both the index of a coin and the coin itself , and let @xmath90 represent the @xmath81 items along with their weights and widths .",
    "the optimal solution , a function of total width @xmath86 and items @xmath90 , is denoted @xmath91 ( the optimal coin collection for @xmath90 and @xmath86 ) .",
    "note that , due to ties , this need not be a unique solution , but the algorithm proposed here is deterministic ; that is , it finds one specific solution , much like bottom - merge huffman coding@xcite or the corresponding length - limited problem@xcite    because we only consider cases in which a solution exists , @xmath92 for some @xmath93 and @xmath94 . here , assuming @xmath95 , @xmath96 and @xmath97 are the unique pair of a power of @xmath14 and an integer that is not a multiple of @xmath14 , respectively , which , multiplied , form  @xmath86 . if @xmath98 , @xmath97 and @xmath96 are not used .",
    "note that @xmath96 need not be an integer .",
    "@xmath99    * algorithm variables * + at any point in the algorithm , given nontrivial @xmath90 and @xmath86 , we use the following definitions :    [ cols=\">,^ , < \" , ]     @xmath99    where @xmath100 denotes integer multiples of @xmath14 and @xmath101 denotes that , for all @xmath102 and @xmath103 , @xmath104 .",
    "then the following is a recursive description of the algorithm :    @xmath99    * recursive @xmath14-ary package - merge procedure *    _ basis . @xmath98 _ : @xmath105 .",
    "@xmath106 and @xmath107 _ : @xmath108 .",
    "_ case 2a .",
    "@xmath109 , @xmath107 , and @xmath110 _ : @xmath111 .",
    "_ case 2b .",
    "@xmath109 , @xmath107 , and @xmath112 _ : create @xmath113 , a new item with weight @xmath114 and width @xmath115 .",
    "this new item is thus a combined item , or package , formed by combining the @xmath14 least weighted items of width  @xmath116 .",
    "let @xmath117 ( the optimization of the packaged version , where the package is given a low index so that , if `` repackaged , '' this occurs after all singular or previously packaged items of identical weight and width ) . if @xmath118 , then @xmath119 ; otherwise , @xmath120 .",
    "if an optimal solution to the coin collector s problem exists , the above recursive ( package - merge ) algorithm will terminate with an optimal solution .    using induction on the number of input items , while the basis is trivially correct , each inductive case reduces the number of items by at least one .",
    "the inductive hypothesis on @xmath121 and @xmath122 is that the algorithm is correct for any problem instance with fewer input items than instance @xmath123 .",
    "if @xmath124 , or if @xmath125 and @xmath126 , then there is no solution to the problem , contrary to our assumption .",
    "thus all feasible cases are covered by those given in the procedure .",
    "case 1 indicates that the solution must contain at least one element ( item or package ) of width  @xmath116 .",
    "these must include the minimum weight item in @xmath127 , since otherwise we could substitute one of the items with this `` first '' item and achieve improvement .",
    "case  2 indicates that the solution must contain a number of elements of width @xmath116 that is a multiple of  @xmath14",
    ". if this number is @xmath42 , none of the items in @xmath128 are in the solution",
    ". if it is not , then they all are .",
    "thus , if @xmath129 , the number is @xmath42 , and we have case 2a . if not , we may `` package '' the items , considering the replaced package as one item , as in case 2b . thus the inductive hypothesis holds .",
    "the algorithm can be performed in linear time and space , as with the binary version @xcite .",
    "the solution @xmath130 of the package - merge algorithm for @xmath131 and @xmath132 has a corresponding length vector @xmath133 such that @xmath134 and @xmath135 .",
    "a formal proof can be found in the full version at @xcite .",
    "the idea is to show that , if there is an @xmath136 with @xmath137 $ ] such that @xmath138 , one can strictly decrease the penalty by substituting item @xmath139 for a set of items including @xmath59 , showing the suboptimality of @xmath130 .",
    "conversely , if there is no such @xmath59 , optimal @xmath130 corresponds to an optimal length vector .    because the coin collector s problem is linear in time and space",
    " same - width inputs are presorted by weight , numerical operations and comparisons are constant time  the overall algorithm finds an optimal code in @xmath140 time and space .",
    "space complexity , however , can be lessened .",
    "this is because the algorithm output is a monotonic nodeset :    a monotonic nodeset , @xmath130 , is one with the following properties : @xmath141 in other words , a nodeset is monotonic if and only if it corresponds to a length vector @xmath35 with lengths sorted in increasing order ; this definition is equivalent to that given in @xcite .    while not all optimal codes are monotonic , using the aforementioned tie - breaking techniques , the algorithm always results in a monotonic code , one that has minimum maximum length among all monotonic optimal codes .",
    "examples of monotonic nodesets include the sets of nodes enclosed by dashed lines in fig .",
    "[ nodesetnum ] and fig .",
    "[ abcd ] . in the latter case , @xmath142 , @xmath143 , @xmath144 , and @xmath29 , so @xmath145 .    in @xcite",
    ", monotonicity allows trading off a constant factor of time for drastically reduced space complexity for length - limited binary codes .",
    "we extend this to the bounded - length problem .",
    "note that the total width of items that are each less than or equal to width @xmath146 is less than  @xmath147 .",
    "thus , when we are processing items and packages of width @xmath146 , fewer than @xmath148 packages are kept in memory . the key idea in reducing space complexity is to keep only four attributes of each package in memory instead of the full contents . in this manner",
    ", we use @xmath55 space while retaining enough information to reconstruct the optimal nodeset in algorithmic postprocessing .",
    "package attributes allow us to divide the problem into two subproblems with total complexity that is at most half that of the original problem .",
    "define @xmath149 for each package @xmath150 , we retain only the following attributes :    1 .",
    "@xmath151 2 .",
    "@xmath152 3 .",
    "@xmath153 4 .",
    "@xmath154    where @xmath155 and @xmath156 .",
    "we also define @xmath157 .    with only these parameters , the `` first run '' of the algorithm takes @xmath55 space .",
    "the output of this run is the package attributes of the optimal nodeset @xmath130 .",
    "thus , at the end of this first run , we know the value for @xmath158 , and we can consider @xmath130 as the disjoint union of four sets , shown in fig .",
    "[ abcd ] :    1 .",
    "@xmath159 = nodes in @xmath160 with indexes in @xmath161 $ ] , 2 .",
    "@xmath162 = nodes in @xmath160 with indexes in @xmath163 $ ] , 3 .",
    "@xmath164 = nodes in @xmath165 , 4 .",
    "@xmath166 = nodes in @xmath167 .",
    "due to the monotonicity of @xmath130 , it is clear that @xmath168 \\times [ l_{\\min}+1 , l_\\mid-1]$ ] and @xmath169 \\times \\{l_\\mid\\}$ ] .",
    "note then that @xmath170 and @xmath171 .",
    "thus we need merely to recompute which nodes are in @xmath159 and in  @xmath166 .    because @xmath166 is a subset of @xmath172 , @xmath173 and @xmath174 .",
    "given their respective widths , @xmath159 is a minimal weight subset of @xmath161 \\times [ l_{\\min}+1,l_{\\mid}-1]$ ] and @xmath166 is a minimal weight subset of @xmath175 \\times [ l_{\\mid}+1,l_{\\max}]$ ] .",
    "these will be monotonic if the overall nodeset is monotonic .",
    "the nodes at each level of @xmath159 and @xmath166 can thus be found by recursive calls to the algorithm .",
    "this approach uses only @xmath55 space while preserving time complexity as in @xcite .",
    "there are changes we can make to the algorithm that , for certain inputs , will result in even better performance .",
    "for example , if @xmath176 , then , rather than minimizing the weight of nodes of a certain total width , it is easier to maximize weight and find the complementary set of nodes .",
    "similarly , if most input symbols have one of a handful of probability values , one can consider this and simplify calculations . these and other similar optimizations have been done in the past for the special case @xmath177 , @xmath178 , @xmath23@xcite , though we will not address or extend such improvements here .",
    "note also that there are cases in which we can find a better upper bound for codeword length than @xmath1 or a better lower bound than @xmath4 .",
    "in such cases , complexity is accordingly reduced , and , when @xmath1 is effectively trivial ( e.g. , @xmath179 ) , and the package - merge approach can be replaced by conventional ( linear - time ) huffman coding approaches .",
    "likewise , when @xmath177 and @xmath180 is not @xmath181 , an approach similar to that of @xcite as applied in @xcite has better asymptotic performance .",
    "these alternative approaches are omitted due to space and can be found at @xcite .",
    "an important problem that can be solved with the techniques in this paper is that of finding an optimal code given an upper bound on fringe , the difference between minimum and maximum codeword length ; such a problem is proposed in @xcite , where it is suggested that if there are @xmath182 codes better than the best code with fringe at most @xmath183 , one can find this @xmath184-best code with the @xmath185-time algorithm in @xcite , thus solving the fringe - limited problem .",
    "however , this presumes we know an upper bound for @xmath184 before running this algorithm .",
    "more importantly , if a probability vector is far from uniform , @xmath184 can be very large , since the number of viable code trees is @xmath186@xcite .",
    "thus this is a poor approach in general .",
    "instead , we can use the aforementioned algorithms for finding the optimal bounded - length code with codeword lengths restricted to @xmath187 $ ] for each @xmath188 , keeping the best of these codes ; this covers all feasible cases of fringe upper bounded by  @xmath183 .",
    "( here we again assume , without loss of generality , that @xmath189 . )",
    "the overall procedure thus has time complexity @xmath190 and @xmath55 space complexity .",
    "the author wishes to thank zhen zhang for first bringing a related problem to his attention and david morgenthaler for constructive discussions on this topic ."
  ],
  "abstract_text": [
    "<S> efficient optimal prefix coding has long been accomplished via the huffman algorithm . however , there is still room for improvement and exploration regarding variants of the huffman problem . </S>",
    "<S> length - limited huffman coding , useful for many practical applications , is one such variant , in which codes are restricted to the set of codes in which none of the @xmath0 codewords is longer than a given length , @xmath1 . </S>",
    "<S> binary length - limited coding can be done in @xmath2 time and @xmath3 space via the widely used package - merge algorithm . in this paper </S>",
    "<S> the package - merge approach is generalized without increasing complexity in order to introduce a minimum codeword length , @xmath4 , to allow for objective functions other than the minimization of expected codeword length , and to be applicable to both binary and nonbinary codes ; nonbinary codes were previously addressed using a slower dynamic programming approach . </S>",
    "<S> these extensions have various applications  including faster decompression  and can be used to solve the problem of finding an optimal code with limited fringe , that is , finding the best code among codes with a maximum difference between the longest and shortest codewords . </S>",
    "<S> the previously proposed method for solving this problem was nonpolynomial time , whereas solving this using the novel algorithm requires only @xmath5 time and @xmath3 space . </S>"
  ]
}