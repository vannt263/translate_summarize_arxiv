{
  "article_text": [
    "a switched network consists of a collection of queues , operating in discrete time . in each time slot , queues are offered service according to a _ service schedule _ chosen from a specified finite set .",
    "for example , in a three - queue system , the set of allowed schedules might consist of `` serve  3 units of work each from queues @xmath0 and @xmath1 '' and `` serve 1 unit of work each from queues @xmath0 and @xmath2 , and 2 units from queue @xmath1 . ''",
    "the rule for choosing a  schedule is called the _ scheduling policy_. new work may arrive in each time slot ; let each queue have a dedicated exogenous arrival process , with specified mean arrival rates .",
    "once work is served , it may either rejoin one of the queues or leave the network .",
    "switched networks are special cases of what harrison @xcite calls `` stochastic processing networks . ''",
    "we believe that switched networks are general enough to model a variety of interesting applications .",
    "for example , they have been used to model input - queued switches , the devices at the heart of high - end internet routers , whose underlying silicon architecture imposes constraints on which traffic streams can be transmitted simultaneously @xcite .",
    "they have also been used to model a multi - hop wireless network in which interference limits the amount of service that can be given to each host @xcite .",
    "the main result of this paper is theorem [ thm : heavytraffic ] , which proves multiplicative state space collapse ( as defined in bramson @xcite ) for a switched network running a generalized version of the maximum - weight scheduling policy of tassiulas and ephremides @xcite , in the diffusion ( or heavy traffic ) limit .",
    "whereas previous works on switched networks and stochastic processing networks in the diffusion limit @xcite have assumed the `` complete resource pooling '' condition , which roughly means that there is a single bottleneck cut constraint , we do not make this assumption .",
    "section [ sec : discussion ] discusses further the related work and our reasons for being interested in the case without complete resource pooling .    to prove multiplicative state space collapse we follow the general method laid out by bramson @xcite . in section [ sec : model ]",
    "we specify a stochastic switched network model and describe the generalized maximum - weight policy . in section  [ sec : fluid ] we specify a fluid model and prove that fluid - scaled performance processes of the switched network are approximated by solutions of this fluid model .",
    "sections [ sec : fluid.behavior ] and [ sec : fluid.behavior.m ] give properties of the solutions of the fluid model for single - hop and multi - hop networks , respectively .",
    "specifically , for nonoverloaded fluid model solutions , we characterize the invariant states and prove that fluid model solutions converge towards the set of invariant states .",
    "in section  [ sec : ht ] we use these properties to prove multiplicative state space collapse .",
    "we use the cluster - point method of bramson  @xcite to prove the fluid model approximation in section [ sec : fluid ] , rather than following an approach based on weak convergence .",
    "the former yields uniform bounds on the error of fluid model approximations , and these uniform bounds are needed in proving multiplicative state space collapse . however , the assumptions we make on the arrival process are not the same as those of bramson @xcite .",
    "in section [ sec : optimal ] we give results concerning the fluid model behavior of a  general single - hop switched network in critical load , and the set of invariant states for the input - queued switch , under a condition that we call `` complete loading . ''",
    "motivated by these results , we define a scheduling policy which we conjecture is optimal in the diffusion limit .",
    "let @xmath3 be the set of natural numbers @xmath4 , let @xmath5 , let @xmath6 be the set of real numbers and let @xmath7 .",
    "let @xmath8 be the indicator function , where @xmath9 and @xmath10 .",
    "let @xmath11 , @xmath12 and @xmath13^+=x{\\vee}0 $ ] .",
    "when @xmath14 is a vector , the maximum is taken componentwise .",
    "we will reserve bold letters for vectors in @xmath15 , where @xmath16 is the number of queues , for example ,",
    "@xmath17_{1\\leq n\\leq n}$ ] . superscripts on vectors are used to denote labels , not exponents , except where otherwise noted ; thus , for example , @xmath18 refers to three arbitrary vectors .",
    "let @xmath19 be the vector of all 0s , and @xmath20 be the vector of all 1s .",
    "use the norm @xmath21 . for vectors @xmath22 and @xmath23 and functions @xmath24 , let @xmath25_{1\\leq n\\leq n } \\quad\\mbox{and}\\quad f({\\mathbf{u } } ) = [ f(u_{n } ) ] _ { 1\\leq{n}\\leq{{n}}},\\ ] ] and let matrix multiplication take precedence over dot product so that @xmath26 let @xmath27 be the transpose of matrix @xmath0 . for a set @xmath28 ,",
    "denote its convex hull by  @xmath29 .    for a fixed @xmath30 , and @xmath31 ,",
    "let @xmath32 be the set of continuous functions @xmath33\\to{\\mathbb{r}}^i$ ] , where @xmath34 is equipped with the norm @xmath35 .",
    "equip @xmath32 with the norm @xmath36 } |f(t)|.\\ ] ] let @xmath37 be the metric induced by this norm . for @xmath38 and @xmath39 , let @xmath40 .",
    "define the modulus of continuity @xmath41 by @xmath42 where @xmath43 $ ] .",
    "since @xmath33 $ ] is compact , each @xmath44 is uniformly continuous , therefore @xmath45 as @xmath46 .",
    "we now introduce the switched network model .",
    "section [ sec : model.queue ] describes the general system model , section [ sec : model.alg ] specifies the class of scheduling policies we are interested in and section [ sec : model.stochastic ] lists the probabilistic assumptions about the arrival process that are needed for the main theorems .",
    "consider a collection of @xmath16 queues .",
    "let time be discrete , indexed by @xmath47 .",
    "let @xmath48 be the amount of work in queue @xmath49 at time slot @xmath50 .",
    "following our general notation for vectors , we write @xmath51 for @xmath52_{1\\leq n\\leq n}$ ] .",
    "the initial queue sizes are @xmath53 .",
    "let @xmath54 be the total amount of work arriving to queue @xmath55 , and @xmath56 be the cumulative potential service to queue @xmath55 , up to time @xmath50 , with @xmath57 .",
    "we first define the queueing dynamics for a single - hop switched network . defining @xmath58 and @xmath59 ,",
    "the basic lindley recursion that we will consider is @xmath60^+ + d{\\mathbf{a}}(\\tau),\\ ] ] where the is taken componentwise .",
    "the fundamental `` switched network '' constraint is that there is some finite set @xmath61 such that @xmath62 we will refer to @xmath63 as a schedule and @xmath64 as the set of allowed schedules . in the applications in this paper , the schedule is chosen based on current queue sizes , which is why it is natural to write the basic lindley recursion as ( [ eq : lindley1 ] ) rather than the more standard @xmath65^+$ ] .",
    "for the analyses in this paper it is useful to keep track of two other quantities .",
    "let @xmath66 be the cumulative amount of idling at queue @xmath55 , defined by @xmath67 and @xmath68^+,\\ ] ] where @xmath69 .",
    "then ( [ eq : lindley1 ] ) can be rewritten @xmath70 also , let @xmath71 be the cumulative time spent on schedule @xmath72 up to time @xmath50 , so that @xmath73    for a multi - hop switched network , let @xmath74 be the routing matrix , @xmath75 if work served from queue @xmath76 is sent to queue @xmath55 and @xmath77 otherwise ; if @xmath77 for all @xmath55 , then work served from queue @xmath76 departs the network .",
    "for each @xmath76 we require @xmath75 for at most one @xmath55 .",
    "( tassiulas and ephremides @xcite described a network model with routing choice , whereas we have restricted ourselves to fixed routing for the sake of simplicity . ) the scheduling constraint ( [ eq : scheduling ] ) is as before , the definition of idling ( [ eq : def.idling ] ) is as before and the queueing dynamics are now defined by @xmath78 equivalently , @xmath79 note that @xmath80 includes only exogenous arrivals to the network , not internally routed traffic .",
    "we will assume that routing is acyclic , that is , that work served from some queue @xmath55 never returns to queue @xmath55 .",
    "for example , border gateway protocol ( bgp ) utilized for routing in the internet is designed to be acyclic @xcite .",
    "this implies that the inverse @xmath81 exists ; by considering the expansion @xmath82 it is clear that @xmath83 for all @xmath76 , @xmath55 and that @xmath84 if work injected at queue @xmath55 eventually passes through @xmath76 , and @xmath85 otherwise . when @xmath86 we obtain a single - hop switched network .",
    "a straightforward bound we shall need is @xmath87 for @xmath88 .      a policy that decides which schedule to choose at each time slot @xmath89",
    "is called a _ scheduling policy_. in this paper we will be interested in the max - weight scheduling policy , introduced by tassiulas and ephremides @xcite",
    ". we will refer to it as mw .",
    "we describe the policy first for a single - hop network .",
    "let @xmath51 be the vector of queue sizes at time  @xmath50 .",
    "define the weight of a schedule @xmath63 to be @xmath90 .",
    "the mw policy then chooses to be a random variable , measurable with respect to the underlying probability space , satisfying ( [ eq : maxweight ] ) for every randomness .",
    "this permits `` break ties at random . '' for the analyses in this paper , it makes no difference which of these two options is used . ] for time slot @xmath50 a schedule @xmath91 with the greatest weight , @xmath92 this policy can be generalized to choose a schedule which maximizes @xmath93 , where the exponent is taken componentwise for some @xmath94 ; call this the mw-@xmath95 policy .",
    "more generally , one could choose a schedule such that @xmath96 for some function @xmath97 ; call this the mw-@xmath98 policy .",
    "it is assumed that  @xmath98 satisfies the following scale - invariance property :    [ cond.f ] assume @xmath98 is differentiable and strictly increasing with @xmath99 .",
    "assume also that for any @xmath100 and @xmath63 , with @xmath101 , @xmath102    this is satisfied by @xmath103 , @xmath94 , but it is not satisfied , for example , for an input - queued switch with @xmath104 .",
    "now we define the multi - hop version of the mw-@xmath98 scheduling policy .",
    "this policy chooses a schedule  @xmath91 at time @xmath50 such that @xmath105 recall that matrix multiplication takes precedence over the @xmath106 operator , so the @xmath107 is of @xmath108 ; note also that @xmath109_n = \\sum_m r_{n m } f(q_m ) = f([r{\\mathbf{q}}]_n),\\ ] ] where @xmath110_n$ ] is the queue size at the first queue downstream of @xmath55 ( or @xmath111 if there is no queue downstream ) . thus @xmath112_n",
    "= f(q_n ) - f([r{\\mathbf{q}}]_n).\\ ] ] the difference @xmath113_n)$ ] is interpreted as the pressure to send work from queue @xmath55 to the queue downstream of @xmath55 ; if the downstream queue has more work in it than the upstream queue , then there is no pressure to send work downstream .",
    "for this reason , it is also known as _ backpressure _ policy .    as before we will assume that @xmath98 satisfies a scale - invariance property , the multi - hop equivalent of assumption [ cond.f ] :    [ multihop.cond.f ] assume @xmath98 is differentiable and strictly increasing with @xmath99 .",
    "assume also that for any @xmath100 and @xmath63 , with @xmath114 , @xmath115    we further require that the scheduler always have the option of not sending work downstream at any individual queue .",
    "our lyapunov function , and indeed our whole fluid analysis in section [ sec : fluid.behavior.m ] , rely on this assumption .",
    "[ cond.monotone ] for the multi - hop setting , assume that @xmath64 satisfies the following : if @xmath63 is an allowed schedule , and @xmath116 is some other vector with @xmath117 for all @xmath55 , then @xmath118 .    in the rest of this paper , whenever we refer to a network running the back - pressure policy , we mean that assumptions [ multihop.cond.f ] and [ cond.monotone ] are satisfied .",
    "some of the results in this paper are about fluid - scaled processes , and others are about multiplicative state space collapse in the diffusion scaling , and the different results make different assumptions about the arrival process .    [ cond : fluid.stoch ] let @xmath119 be a random process with stationary increments .",
    "assume it has a well - defined mean arrival rate vector @xmath120 , that is , assume @xmath121 exists almost surely and is deterministic for every queue @xmath122 , and define @xmath123 assume there is a sequence of deviation terms @xmath124 , @xmath125 , such that @xmath126 as @xmath127 and @xmath128    [ cond : mssc.stoch ] let @xmath129 be a sequence of random processes indexed by @xmath125 . for each @xmath130",
    ", assume that @xmath131 has stationary increments , and a well - defined mean arrival rate vector @xmath132 , and that there is some limiting arrival rate vector @xmath120 such that=-1 @xmath133=0 assume there is a sequence of deviation terms @xmath134 , @xmath135 , such that @xmath136 as @xmath137 and @xmath138    if the arrival process is the same for all @xmath130 , say @xmath139 where @xmath80 has a  well - defined mean arrival rate vector , then assumption [ cond : mssc.stoch ] reduces to @xmath140 and it implies assumption [ cond : fluid.stoch ] . for any arrival process with i.i.d .",
    "increments that are uniformly bounded , that is , such that there is an @xmath141 for which @xmath142\\qquad \\mbox{for all $ n$ , $ \\tau$},\\ ] ] equation ( [ eq : cond.arr ] ) holds with @xmath143 , with choice of an appropriate constant @xmath2 that depends on @xmath141 , by an application of concentration inequality by azuma @xcite and hoeffding @xcite .",
    "more generally , it holds when the increments are not uniformly bounded but instead satisfy a reasonable moment bound . for example",
    ", an application of doob s maximal inequality  @xcite with bounded fourth moment and @xmath144 yields a stronger result than ( [ eq : cond.arr ] ) ; this can be used to show that a poisson process satisfies that equation .",
    "furthermore ( [ eq : cond.arr ] ) holds for a much larger class of stationary arrival processes beyond processes with i.i.d .",
    "increments , for example , markov modulated processes ( see dembo and zeitouni @xcite ) .",
    "an internet router has several input ports and output ports .",
    "a data transmission cable is attached to each of these ports .",
    "packets arrive at the input ports .",
    "the function of the router is to work out which output port each packet should go to , and to transfer packets to the correct output ports .",
    "this last function is called _",
    "switching_. there are a  number of possible switch architectures ; we will consider the commercially popular input - queued switch architecture .    figure [ fig : switch - iq ] illustrates an input - queued switch with three input ports and three output ports .",
    "packets arriving at input @xmath145 destined for output @xmath146 are stored at input port  @xmath145 , in queue @xmath147 ; thus there are @xmath148 queues in total .",
    "( for this example it is more natural to use double indexing , e.g. , @xmath149 , whereas for general switched networks it is more natural to use single indexing , e.g. , @xmath150 for @xmath122 . )",
    "the switch operates in discrete time . in each time slot",
    ", the switch fabric can transmit a number of packets from input ports to output ports , subject to the two constraints that each input can transmit at most one packet and that each output can receive at most one packet .",
    "in other words , at each time slot the switch can choose a _ matching _ from inputs to outputs .",
    "the schedule @xmath151 is given by @xmath152 if input port @xmath145 is matched to output port @xmath146 in a  given time slot , and @xmath153 otherwise .",
    "clearly @xmath72 is a permutation matrix , and the set @xmath64 of allowed schedules is the set of @xmath154 permutation matrices .",
    "figure [ fig : switch - iq ] shows two possible matchings . in the left - hand figure , the matching allows a packet to be transmitted from input port 3 to output port 2 , but since @xmath149 is empty , no packet is actually transmitted .",
    "keslassy and mckeown @xcite found from extensive simulations of an input - queued switch that the average queueing delay is different under mw-@xmath95 policies for different values of @xmath155 .",
    "they conjecture :    [ conj : keslassy ] for an input - queued switch running the mw-@xmath95 policy , the average queueing delay decreases as @xmath95 decreases .",
    "though our work is motivated by the desire to establish conjecture [ conj : keslassy ] , we have not been able to prove it .",
    "but whereas the two main analytic approaches that have been employed in the literature yield results for the input - queued switch that are insensitive to @xmath95 , our result about multiplicative state space collapse _ is _ sensitive , as shown in section [ sec : optimal ] .",
    "we speculate that our result might eventually form part of a proof of the conjecture .",
    "the two main analytic approaches that have been employed in the literature are stability analysis and heavy traffic analysis . in stability analysis ,",
    "one calculates the set of arrival rates for which a policy is stable ( in the sense of @xcite ) .",
    "all the prior work in this context leads to the conclusion that mw-@xmath95 has the optimal stability region , regardless of @xmath95 .    in heavy traffic analysis ,",
    "one looks at queue size behavior under a diffusion ( or heavy traffic ) scaling .",
    "this regime was first described by kingman  @xcite ; since then a substantial body of theory has developed , and modern treatments can be found in @xcite .",
    "stolyar has studied mw-@xmath95 for a  generalized switch model in the diffusion scaling , and obtained a complete characterization of the diffusion approximation for the queue size process , _ under a condition known as _ `` _ _ complete resource pooling__. '' this condition effectively requires that a clever scheduling policy be able to balance work between all the heavily loaded queues .",
    "stolyar @xcite showed in a remarkable paper that the limiting queue size lives in a one - dimensional state space .",
    "operationally , this means that all one needs to keep track of is the one - dimensional total amount of work in the system ( called the _ workload _ ) , and at any point in time one can assume that the individual queues have all been balanced .",
    "dai and lin @xcite have established that similar result holds in the more general setting of a stochastic processing network .    under the complete resource pooling condition ,",
    "the results in @xcite imply that the performance of mw-@xmath95 in an input - queued switch is always optimal ( in the diffusion scaling ) regardless of the value of @xmath94 . therefore these results do not help in addressing conjecture [ conj : keslassy ] .",
    "this is our motivation for studying switched networks in the absence of complete resource pooling . technically , the lifting map for a critically - loaded input - queued switch is degenerate and insensitive to @xmath95 under complete resource pooling , but it is sensitive to @xmath95 otherwise .",
    "we prove multiplicative state space collapse , following the method of bramson  @xcite .",
    "the complement of bramson s work is by williams @xcite , and consists of proving a diffusion approximation , using an appropriate invariance principle along with the multiplicative state space collapse .",
    "we do not carry out this complementary aspect .",
    "stolyar @xcite and dai and lin @xcite have proved the diffusion approximation under the complete resource pooling condition , and kang and williams @xcite have made progress toward it in the case without complete resource pooling , for an input - queued switch under the mw-@xmath156 policy .",
    "whereas in heavy traffic models of other systems @xcite the lifting map from workloads to queue sizes is linear , we find instead that it is nonlinear  in fact it can be expressed as the solution to an optimization problem .",
    "the objective function of the problem is a natural generalization of the lyapunov function introduced by tassiulas and ephremides @xcite for proving stability of the mw-@xmath156 policy ; the constraints of the problem are closely linked to the canonical representation of workload identified by harrison @xcite .",
    "the objective function for mw-@xmath95 depends on @xmath95 , and this hints that the performance measures might also depend on @xmath95 .",
    "finally , we take note of two related results .",
    "first , in @xcite we have reported some results about a critically loaded input - queued switch without a complete resource pooling condition .",
    "second , a sequence of works by kelly and williams @xcite and kang et al .",
    "@xcite has resulted in a diffusion approximation for a bandwidth sharing network model operating under proportionally fair rate allocation , assuming a technical `` local traffic '' condition , but without assuming complete resource pooling .",
    "they show that the resulting diffusion approximation model has a product form stationary distribution .",
    "this section introduces the fluid model and establishes it as an approximation to a fluid - scaled descriptor of the switched network .",
    "intuitively , the fluid model describes the dynamics of the system at the `` rate '' level rather than at finer granularity .",
    "the reader is referred to a recent monography by bramson @xcite and lecture notes by dai @xcite for a  detailed account of fluid approximation for multiclass queueing networks . in section [ sec : fluid.model ] we specify the fluid model , in section [ sec : fluid.result ] we state the main result and in section [ sec : fluid.proof ] we prove it .",
    "let time be measured by @xmath157 $ ] for some fixed @xmath30 .",
    "let @xmath158 , @xmath159 and @xmath160 all be continuous functions mapping @xmath33 $ ] into  @xmath161 , and let @xmath162 be a collection of continuous functions mapping @xmath33 $ ] into  @xmath163 . let @xmath164 .",
    "this lies in @xmath32 where @xmath165 .",
    "the definition below requires these functions to be absolutely continuous ; such functions are differentiable almost everywhere , and the time instants where they are differentiable are called `` regular times . ''",
    "any equations we write involving derivatives are taken to apply only at regular times.=-1    [ def : fms ] let @xmath166 satisfy assumption [ cond.f ] .",
    "say that @xmath167 is a fluid model solution for a single - hop switched network with arrival rate @xmath168 operating under the mw-@xmath98 policy if it satisfies equations ( [ eq : fluid.queue])([eq : fluid.mwm ] ) below .",
    "write @xmath169 for the set of all such @xmath170 .",
    "additionally , define @xmath171 the equations are : @xmath172 @xmath173\\\\[-8pt ] & & \\qquad\\dot{s}_{{\\bolds{\\pi}}}(t ) = 0\\qquad\\mbox{if } { { \\bolds{\\pi}}}{\\cdot}f(\\mathbf{q}(t))<\\max_{{{\\bolds{\\rho}}}\\in{\\mathcal{s } } } { { \\bolds{\\rho}}}{\\cdot}f(\\mathbf{q}(t)).\\nonumber\\end{aligned}\\ ] ]    here , @xmath174 represents the vector of queue sizes at time @xmath175 , @xmath176 represents the cumulative arrivals up to time @xmath175 , @xmath177 represents the cumulative idleness up to time @xmath175 and @xmath178 represents the total amount of time spent on schedule  @xmath72 up to time @xmath175 .",
    "the equation in ( [ eq : fluid.queue ] ) is the continuous analog of ( [ eq : discrete.queue.singlehop ] ) combined with ( [ eq : service ] ) , and the inequality is the analog of the single - hop version of ( [ eq : multihop.discrete.queue.bound ] ) .",
    "equation ( [ eq : fluid.arrivals ] ) represents an assumption about the arrival process , related to ( [ cond.arr ] ) .",
    "equation ( [ eq : fluid.busy ] ) says that the scheduling policy must choose some schedule at every timestep .",
    "both ( [ ineq : fluid.littleidle ] ) and ( [ eq : fluid.idling ] ) derive from the definition of idling , ( [ eq : def.idling ] ) .",
    "equation ( [ eq : fluid.mwm ] ) is the continuous analog of ( [ eq : discrete.mwm ] ) .",
    "let @xmath166 satisfy assumption [ multihop.cond.f ] , and let @xmath64 satisfy assumption [ cond.monotone ] .",
    "say that @xmath179 is a fluid model solution for a multi - hop switched network operating under the mw-@xmath98 policy if it satisfies equations ( [ eq : fluid.arrivals])([eq : fluid.idling ] ) , and additionally  ( [ eq : multihop.fluid.queue ] ) and  ( [ eq : multihop.fluid.mwm ] ) below .",
    "let @xmath180 be the set of all such @xmath181 .",
    "also , let @xmath182 and @xmath183 be defined analogously to the single - hop case .",
    "the extra equations are @xmath184 and @xmath185\\\\[-8pt ] & & \\qquad \\dot{s}_{{\\bolds{\\pi}}}(t)=0\\qquad\\mbox{if } { { \\bolds{\\pi}}}{\\cdot}(i - r)f(\\mathbf{q}(t))<\\max_{{{\\bolds{\\rho}}}\\in{\\mathcal{s } } } { { \\bolds{\\rho}}}{\\cdot}(i - r)f(\\mathbf{q}(t)).\\nonumber\\end{aligned}\\ ] ]    when we refer to `` fluid model solutions for any scheduling policy , '' we mean processes @xmath186 satisfying ( [ eq : fluid.queue ] ) to ( [ eq : fluid.idling ] ) in the single - hop case , or satisfying ( [ eq : fluid.arrivals ] ) to ( [ eq : fluid.idling ] ) plus ( [ eq : multihop.fluid.queue ] ) in the multi - hop case .      the development in this section follows the general pattern of bramson @xcite .",
    "there is , however , a difference in presentation that is worth noting .",
    "the main result of this section , theorem [ thm : fluid ] , is a  general purpose sample path - wise result : it does not make any probabilistic claim nor does it depend on any probabilistic assumptions .",
    "it can be applied to a switched network with stochastic arrivals in two ways : to obtain a result about fluid approximations ( corollary [ cor : fluid ] ) , and to obtain a  result about multiplicative state space collapse ( section [ sec : ht ] ) .",
    "we start by defining the fluid scaling .",
    "consider a switched network of the type described in section [ sec : model.queue ] running a scheduling policy of the type described in section [ sec : model.alg ] .",
    "write @xmath187 , @xmath188 , to denote its sample path . given a scaling parameter @xmath189 ,",
    "define the fluid - scaled sample path @xmath190 for @xmath191 by @xmath192 after extending the domain of @xmath193 to @xmath163 by linear interpolation in each interval @xmath194 . in this section",
    "we are interested in the evolution of @xmath195 over @xmath157 $ ] for some fixed @xmath30 , therefore we take @xmath196 to lie in @xmath32 with @xmath197 .",
    "the following theorem concerns uniform convergence of a set of fluid - scaled sample paths .",
    "every fluid - scaled sample path is assumed to relate to some ( unscaled ) switched network , and all the switched networks are assumed to have the same network data , that is , the same number of queues  @xmath16 , the same set of allowed schedules @xmath64 , the same routing matrix @xmath198 , and the same scheduling policy .",
    "the convergence is indexed by a parameter @xmath146 lying in some totally ordered countable set . for corollary [ cor : fluid ] we will use @xmath199 , and for section [ sec : ht ] we will use a subset of @xmath200 as the index set .",
    "we are purposefully using the symbol  @xmath146 here as an index , rather than the @xmath130 used elsewhere , to remind the reader that the index set is interpreted differently in different results .    [ thm : fluid ] let @xmath201 be the set of all possible sample paths for single - hop switched networks with the network data specified above , running the mw-@xmath98 scheduling policy , where @xmath98 satisfies assumption [ cond.f ] .",
    "fix @xmath202 and @xmath168 .",
    "let there be sequences @xmath203 and @xmath204 , indexed by @xmath146 in some totally ordered countable set , such that @xmath205 consider a sequence of subsets @xmath206 which satisfy the following : for every @xmath207 there is some unscaled sample path @xmath208 such that @xmath196 is the fluid - scaled version of @xmath209 with scaling parameter @xmath210 ( here @xmath210 is permitted to be a function of @xmath209 ) ; and furthermore @xmath211 } | { \\tilde{\\mathbf{a}}}(t)-{\\bolds{\\lambda}}^jt | & \\leq&\\varepsilon_j \\qquad\\mbox{for all $ j$}\\end{aligned}\\ ] ] and @xmath212 then @xmath213 furthermore , fix @xmath214 and a sequence @xmath215 , and assume that the sets  @xmath216 also satisfy @xmath217 then @xmath218 equivalent results to ( [ eq : fluid1 ] ) and ( [ eq : fluid2 ] ) apply to multi - hop switched networks , with references to @xmath169 replaced by @xmath180 and the set @xmath201 modified to refer to multi - hop networks running the mw-@xmath98 scheduling policy where @xmath98 satisfies assumption [ multihop.cond.f ] and @xmath64 satisfies assumption [ cond.monotone ] .    the above theorem as stated applies to the mw-@xmath98 scheduling policy , but it is clear from the proof that a corresponding limit result holds , relating sample paths of _ any _ scheduling policy to fluid models defined by equations  ( [ eq : fluid.queue])([eq : fluid.idling ] ) .",
    "the following corollary is a straightforward application of theorem [ thm : fluid ] .",
    "it specializes the theorem to the case of a single random system @xmath209 , and the sequence of fluid - scaled versions indexed by @xmath125 where the @xmath130th version uses scaling parameter @xmath130 .",
    "the arrival process is assumed to satisfy certain stochastic assumptions .",
    "this corollary is useful when studying the behavior of a single switched network with random arrivals , over long timescales .",
    "[ cor : fluid ] consider a single - hop switched network as described in section [ sec : model.queue ] , running the mw-@xmath98 policy as described in section [ sec : model.alg ] where  @xmath98 satisfies assumption [ cond.f ] .",
    "let the arrival process @xmath119 satisfy assumption  [ cond : fluid.stoch ] , and let the initial queue size @xmath219 be random .",
    "for @xmath125 , let @xmath220 and let @xmath221 , for @xmath157 $ ] where @xmath30 is some fixed time horizon .",
    "then for any @xmath222 @xmath223 the same conclusion holds for a multi - hop switched network running the mw-@xmath98 back - pressure policy where @xmath98 satisfies assumption [ multihop.cond.f ] and @xmath64 satisfies assumption  [ cond.monotone ] , with @xmath169 replaced by @xmath180 .",
    "first define the event @xmath224 by @xmath225 where @xmath120 and @xmath226 are as in assumption [ cond : fluid.stoch ] . by this",
    "we mean that @xmath224 is a  subset of the probability sample space , and we write @xmath227 etc .",
    "for @xmath228 to emphasize the dependence on @xmath224",
    ".    we will apply theorem [ thm : fluid ] with index set @xmath229 to the sequence of sets @xmath230 in order to apply the theorem we will pick constants as follows .",
    "let @xmath231 , let @xmath120 be as in assumption [ cond : fluid.stoch ] , @xmath232 for all @xmath146 , @xmath233 where @xmath226 is as in assumption  [ cond : fluid.stoch ] , @xmath234 and @xmath235 .",
    "we now need to verify the conditions of theorem [ thm : fluid ] .",
    "equation ( [ cond.rateconv ] ) holds by the choice of @xmath236 and by assumption [ cond : fluid.stoch ] .",
    "equation ( [ eq : fluid.scale ] ) holds automatically by choice of @xmath216 . to see that ( [ eq : fluid.arr ] ) holds , rewrite event @xmath224 in terms of the fluid scaled arrival process  @xmath237 to see @xmath238 } |",
    "{ \\tilde{\\mathbf{a}}}^r(t)(\\omega)-{\\bolds{\\lambda}}t| < t\\delta_r\\qquad \\mbox{for all $ r$ and $ \\omega\\in e_r$},\\ ] ] which implies ( [ eq : fluid.arr ] ) ; likewise for ( [ eq : fluid.qbound ] ) and ( [ eq : fluid.initq ] ) .",
    "we conclude that ( [ eq : fluid2 ] ) holds . it may be rewritten in terms of @xmath224 as @xmath239    we next argue that @xmath240 as @xmath127 .",
    "the event @xmath224 is the intersection of two events , one concerning arrivals and the other concerning initial queue size .",
    "the probability of the former @xmath241 as @xmath127 by assumption [ cond : fluid.stoch ] . for the latter ,",
    "@xmath242 as @xmath127 since @xmath53 is assumed not to be infinite . therefore @xmath240 . combining this with ( [ eq : fluid.corr ] ) gives the desired result for single - hop networks .",
    "the multi - hop version follows similarly .",
    "we shall present the proof of theorem [ thm : fluid ] for a single - hop network in detail followed by main ideas required to extend it to multi - hop networks .",
    "here we are interested in convergence in @xmath32 , where @xmath165 and @xmath30 is fixed , equipped with the norm .",
    "the appropriate concept for proving convergence is _",
    "cluster points_. consider any metric space @xmath243 with metric @xmath244 and a sequence @xmath245 of subsets of @xmath243 .",
    "say that @xmath246 is a _",
    "cluster point _ of the sequence if @xmath247 where @xmath248 .",
    "[ prop : tight ] given @xmath202 , @xmath249 and a sequence @xmath250 , let @xmath251 and consider a sequence @xmath245 of subsets of @xmath32 for which @xmath252 .",
    "then @xmath253 as @xmath254 , where @xmath255 is the set of cluster points of @xmath245 .",
    "let @xmath256 .",
    "lemma [ lem : fluid.tight ] below shows that @xmath252 , with @xmath257 as defined in proposition [ prop : tight ] for appropriate constants @xmath258 , @xmath0 and @xmath259 . by applying that proposition , @xmath260 where @xmath255 is the set of cluster points of the @xmath261 sequence .",
    "lemma [ lem : limitpoints ] below shows that all cluster points of the @xmath261 sequence satisfy the fluid model equations .",
    "every cluster point @xmath14 must also satisfy @xmath262 , by ( [ eq : fluid.qbound ] ) .",
    "therefore @xmath263 if in addition ( [ eq : fluid.initq ] ) holds , then every cluster point @xmath14 must also satisfy @xmath264",
    ". therefore @xmath265    [ lem : fluid.tight ] let @xmath258 and @xmath216 be as in theorem  [ thm : fluid ] .",
    "then there exist a constant @xmath249 and a sequence @xmath250 such that for every @xmath207 , @xmath266 and @xmath267    consider @xmath207 , where @xmath268 . as per the definitions in section [ sec : model.queue ] , the only nonzero component of @xmath269 is @xmath270 and @xmath271 by choice of @xmath216 , hence @xmath266 . for the second inequality , without loss of generality",
    "pick any @xmath272 , and let us now look at each component of @xmath273 in turn .    for arrivals , let @xmath274 ; this is finite by the assumption that @xmath275 in theorem [ thm : fluid ] .",
    "then for @xmath207 , @xmath276 & \\leq & 2 \\varepsilon_j + |{\\bolds{\\lambda}}^j|(u - t ) \\qquad\\mbox{by ( \\ref { eq : fluid.arr})}\\\\[-2pt ] & \\leq & 2 \\varepsilon_j + \\lambda^{\\max } ( u - t).\\end{aligned}\\ ] ] for idling , let @xmath277 .",
    "this is the maximum amount of service that can be offered to any queue per unit time , and it must be finite since @xmath278 is finite . then , based on ( [ eq : def.idling ] ) , @xmath279 & \\leq&(u - t ) s^{\\max } + 2 s^{\\max}/z_j^{\\min},\\end{aligned}\\ ] ] where @xmath280 . for service , let @xmath281 be the unscaled process that corresponds to @xmath282 ; since @xmath281 is increasing and since a schedule must be chosen not more than once every time slot , @xmath283 for queue size , note that ( [ eq : discrete.queue.singlehop ] ) carries through to the fluid model scaling , that is , @xmath284 thus @xmath285 & & \\qquad\\leq    + \\sum_{{\\bolds{\\pi}}}\\pi_n | { \\tilde{s}}_{{\\bolds{\\pi}}}(u ) - { \\tilde{s}}_{{\\bolds{\\pi}}}(t ) | + | { \\tilde{y}}_n(u)-{\\tilde{y}}_n(t ) |\\\\[-2pt ] & & \\qquad\\leq ( u - t ) ( \\lambda^{\\max } + |{\\mathcal{s}}| s^{\\max } + s^{\\max } ) + ( 2|{\\mathcal{s}}| s^{\\max } + 2s^{\\max } ) /z_j^{\\min } + 2 \\varepsilon_j.\\end{aligned}\\ ] ] putting all these together , @xmath286 and @xmath287 by the assumptions of theorem [ thm : fluid ] , @xmath288 and @xmath289 as @xmath254 , thus @xmath250 as required .",
    "[ lem : limitpoints ] make the same assumptions as theorem [ thm : fluid ] , and let @xmath290 .",
    "then @xmath291 if @xmath14 is a  cluster point of the @xmath261 sequence .    from lemma [ lem : fluid.tight ] and proposition [ prop :",
    "tight ] , it follows that@xmath292 , @xmath293 as @xmath254 where @xmath255 is the set of cluster points of the sequence @xmath261 .",
    "let @xmath14 be one such cluster point .",
    "that is , there exists a  subsequence @xmath294 and a collection @xmath295 such that @xmath296 .",
    "it easily follows that @xmath297 since @xmath298 for all @xmath299 as argued in lemma  [ lem : fluid.tight ] . using this",
    ", we wish to establish that @xmath14 satisfies all the fluid model equations to conclude @xmath291 . for convenience",
    ", we shall omit the subscript @xmath300 in the rest of the proof ; that is , we shall use @xmath146 in place of @xmath294 and @xmath254 .",
    "_ proof of _ ( [ eq : fluid.queue ] ) , ( [ eq : fluid.busy ] ) , ( [ eq : fluid.increasing]).the discrete ( unscaled ) system satisfies these properties ; therefore the scaled systems @xmath301 do too . taking the limit",
    "yields the fluid equations .",
    "_ proof of _ ( [ ineq : fluid.littleidle]).in ( [ eq : def.idling ] ) , @xmath91 and @xmath51 are both nonnegative ( component - wise ) , hence @xmath302 for all @xmath50 .",
    "summing up over @xmath50 , we see the discrete ( unscaled ) system satisfies the equivalent of ( [ ineq : fluid.littleidle ] ) , so as above we obtain the fluid equation",
    ".    _ proof of _ ( [ eq : fluid.arrivals]).observe that @xmath238 } | \\mathbf{a}(t)-{\\bolds{\\lambda}}t | \\leq \\sup_{t\\in[0,t ] } | \\mathbf{a}(t)-{\\tilde{\\mathbf{a}}}^j(t ) | + \\sup_{t\\in[0,t ] } | { \\tilde{\\mathbf{a}}}^j(t)-{\\bolds{\\lambda}}^j t | + t|{\\bolds{\\lambda}}^j-{\\bolds{\\lambda}}|.\\ ] ] each term converges to 0 as @xmath254 : the first because @xmath303 , the second because @xmath304 so the deviation in @xmath305 is bounded by @xmath306 and @xmath307 and the third because @xmath275 . since the left - hand side does not depend on @xmath146",
    ", it must be that @xmath308 .",
    "_ proof of _ ( [ eq : fluid.abscont]).in lemma [ lem : fluid.tight ] we found constants @xmath0 and @xmath259 such that for all @xmath309 @xmath310 with @xmath311 as @xmath312 . taking the limit of @xmath313 as @xmath254 , we find that @xmath314 ; that is , @xmath14 is ( globally ) lipschitz continuous ( of order @xmath156 with respect to the appropriate metric as defined earlier ) .",
    "this immediately implies that @xmath14 is absolutely continuous .",
    "_ proof of _ ( [ eq : fluid.idling]).since @xmath315 is absolutely continuous , each component is too , which means that @xmath316 is differentiable for almost all @xmath175 .",
    "pick some such @xmath175 , and suppose that @xmath317 .",
    "consider some small interval @xmath318 $ ] about @xmath175 .",
    "since @xmath319 is continuous , we can choose @xmath320 sufficiently small that @xmath321 .",
    "since @xmath322 , we can find @xmath323 such that @xmath324 for all @xmath146 sufficiently large .",
    "since @xmath325 , there exists a corresponding unscaled version of the system , say @xmath326 , and scaling parameter , say  @xmath327 , so that @xmath328 .",
    "therefore , it must be that the corresponding unscaled queue satisfies @xmath329 .",
    "that is , the queue size in the entire interval never vanishes to @xmath111 and hence idling in the entire interval is not possible .",
    "therefore after rescaling we find @xmath330 .",
    "( the switch from @xmath320 to @xmath331 sidesteps any discretization problems . )",
    "therefore the same holds for @xmath316 in the limit .",
    "we assumed @xmath316 to be differentiable at @xmath175 ; the derivative must be @xmath111 .",
    "_ proof of _ ( [ eq : fluid.mwm]).pick a @xmath175 at which @xmath332 is differentiable , and suppose that @xmath333 . as above , pick some small interval @xmath318 $ ] and @xmath146 sufficiently large that @xmath334 writing this in terms of the unscaled system and applying assumption [ cond.f ] , @xmath335 the mw-@xmath98 policy ensures by ( [ eq : discrete.mwm ] ) that @xmath72 will not be chosen throughout this entire interval , so after rescaling we find @xmath336 , and taking the limit gives @xmath337 . since @xmath332 is assumed to be differentiable at @xmath175 ; the derivative must be @xmath111 .",
    "the proof of theorem  [ thm : fluid ] for single - hop network applies verbatim , except that the two lemmas need to be replaced .",
    "@xmath338    [ lem : multihop.fluid.tight ] make the same assumptions as theorem [ thm : fluid ] , multi - hop case , and use the same definition of @xmath216 .",
    "then there exist a constant @xmath249 and a sequence @xmath250 such that for every @xmath207 , @xmath266 and @xmath267    consider @xmath339 , @xmath268 .",
    "the bound @xmath340 follows from an argument similar to that in the single - hop case . the bounds on the arrival process , the idleness and service allocation are as in the single - hop case : for any @xmath341 , @xmath342 where @xmath280 .",
    "the bound on queue size is a little different .",
    "note that ( [ eq : discrete.queue.multihop ] ) carries through to the fluid - scaling , that is , @xmath343 thus @xmath344_n| | { \\tilde{s}}_{{\\bolds{\\pi}}}(u ) - { \\tilde{s}}_{{\\bolds{\\pi}}}(t ) |\\\\[-2pt ] & & { } + | { \\tilde{y}}_{n}(u)-{\\tilde{y}}_{n}(t ) |\\\\[-2pt ] & \\leq & ( u - t ) \\bigl ( \\lambda^{\\max } + |{\\mathcal{s}}| ( n s^{\\max})s^{\\max } + s^{\\max } \\bigr ) \\\\[-2pt ] & & { } + \\bigl(2|{\\mathcal{s}}| ( n s^{\\max})s^{\\max } + 2 s^{\\max } \\bigr)/z_j^{\\min } + 2\\varepsilon_j.\\end{aligned}\\ ] ] putting all these together , for any @xmath345 , @xmath346 where the constants @xmath0 and @xmath259 are @xmath347 here @xmath250 as @xmath254 since @xmath348 by ( [ cond.rateconv ] ) and @xmath349 as @xmath254 by  ( [ eq : fluid.scale ] ) .",
    "[ lem : multihop.limitpoints ] under the setup of theorem  [ thm : fluid ] for a multihop network , let @xmath350 .",
    "then @xmath351 if @xmath14 is a cluster point of the @xmath261 sequence .    given a cluster point @xmath352 , let there be @xmath353 so that @xmath354 , as in the proof of lemma [ lem : limitpoints ] . now the bound @xmath297 and equations ( [ eq : fluid.arrivals])([eq : fluid.idling ] ) all work exactly as in the single - hop case , as does the queue size equation  ( [ eq : multihop.fluid.queue ] ) .",
    "the only equation that needs further argument is the mw-@xmath98 backpressure equation ( [ eq : multihop.fluid.mwm ] ) .",
    "_ proof of _ ( [ eq : multihop.fluid.mwm]).pick a @xmath175 at which @xmath332 is differentiable , and suppose that @xmath355 . as in lemma [ lem : limitpoints ] , proof of ( [ eq : fluid.mwm ] ) , it must be that there is some small interval @xmath356 $ ] such that @xmath72 is not chosen for any @xmath357 , therefore @xmath358 .",
    "in this section we prove certain properties of fluid model solutions , which will be needed for the main result of this paper , multiplicative state space collapse . in order to state these properties , we first need some definitions .",
    "we then state a portmanteau theorem listing all the properties , and give an example to illustrate the definitions . the rest of the section",
    "is given over to proofs and supplementary lemmas .",
    "this section deals with a single - hop switched network ; in the next section we give corresponding results for multi - hop .",
    "our reason for giving separate single - hop and multi - hop proofs , rather than just treating single - hop as a  special case of multi - hop , is that our multi - hop results place additional restrictions on the set of allowed schedules ( assumption [ cond.monotone ] ) beyond what is required for single - hop networks .",
    "this mainly affects the proof ; the portmanteau theorem for multi - hop is nearly identical to that for single - hop .",
    "let @xmath61 be the set of allowed schedules .",
    "let @xmath359 be the convex hull of @xmath64 , @xmath360 define the _ admissible region _",
    "@xmath361 to be @xmath362    define the optimization problem @xmath363 for @xmath168 to be @xmath364 let @xmath365 be the dual to this : it is @xmath366 let @xmath243 be the set of extreme points of the feasible region of the dual problem ; the feasible region is a finite convex polytope so @xmath243 is finite .",
    "define the set of _ virtual resources _",
    "@xmath367 to be the set of maximal extreme points , @xmath368 define the set of _ critically loaded virtual resources _",
    "@xmath369 to be @xmath370    both problems are clearly feasible , and the optimum is attained in each . by slater s condition",
    "there is strong duality , that is , @xmath371 .",
    "[ when we write @xmath363 or @xmath365 in mathematical expressions , we mean the optimum value , not the optimizer . ]",
    "clearly , @xmath372 if and only if @xmath120 is feasible",
    ".    laws @xcite and kelly and laws @xcite used primal and dual problems of this general sort for describing multi - hop queueing networks with routing choice .",
    "harrison @xcite extended the problems for stochastic processing networks .",
    "[ def : lyapunov ] let the scheduling policy be mw-@xmath98 , where @xmath98 satisfies assumption [ cond.f ] .",
    "define the function @xmath373 by @xmath374 where @xmath375 for @xmath376 , and @xmath377_{1\\leq n\\leq n}$ ] as per the notation in section [ sec : intro ] .",
    "define the optimization problem @xmath378 to be @xmath379 note that @xmath380 is strictly convex and increasing , and the feasible region is convex ; hence this problem has a unique optimizer .",
    "define the _ lifting map _ @xmath381 by setting @xmath382 to be the optimizer .",
    "note that @xmath383 and @xmath384 both depend on @xmath120 and @xmath98 , but we will surpress this dependency when the context makes it clear which @xmath120 and @xmath98 are meant .",
    "the results in this section apply to any @xmath385 .",
    "however , if , then @xmath369 is empty , so @xmath386 for all @xmath158 .",
    "the results are only interesting when @xmath387 , so we define @xmath388    we can now state the main result of this section .",
    "[ thm : fp ] let @xmath385 .",
    "consider a single - hop switched network running mw-@xmath98 , where @xmath98 satisfies assumption  [ cond.f ] .",
    "for any @xmath389 , @xmath390 is compact . also , for any fluid model solution with arrival rate @xmath120 , @xmath391 for all @xmath392 .",
    "@xmath384 is continuous .    if @xmath393 , then @xmath394 for all @xmath395 .    say that @xmath396 is an _ invariant state _",
    "if all fluid model solutions @xmath397 with arrival rate @xmath120 , starting at @xmath398 , satisfy @xmath399 for all @xmath392 .",
    "then @xmath396 is an invariant @xmath400 .    for any @xmath401 there",
    "exists some @xmath402 such that , if @xmath397 is a fluid model solution with arrival rate @xmath120 , and @xmath403 , then @xmath404 for all @xmath405 .",
    "a loose interpretation of these results is that the mw-@xmath98 scheduling policy seeks always to reduce @xmath406 [ part ( i ) ] , but it is constrained from reducing it too much , because it is not permitted to reduce the workload at any of the critically loaded virtual resource ( the constraints of @xmath383 ) .",
    "however , it can choose how to allocate work between queues , subject to those constraints .",
    "it heads towards a state where it is impossible to reduce @xmath406 any further [ parts ( iv ) and ( v ) ] .",
    "in all the examples we have looked at , the fluid model solutions reach an invariant state in finite time , that is , ( v ) holds also for @xmath407 , but we have not been able to prove this in general .",
    "consider a system with queues , @xmath0 and @xmath1 .",
    "suppose the set @xmath64 of possible schedules consists of `` serve three packets from queue @xmath0 '' and `` serve one packet each from @xmath0 and  @xmath1 . ''",
    "write these two schedules as @xmath408 and @xmath409 , respectively .",
    "let  @xmath410 and  @xmath411 be the arrival rates at the two queues , measured in packets per time slot .",
    "the arrival rate vector @xmath413 is feasible if there is some @xmath414 with @xmath415 such that @xmath416 . in words ,",
    "the arrival rates are feasible if the switch can divide its time between the two possible schedules in such a way that the service rates at the two queues are at least as big as the arrival rates .",
    "schedule @xmath417 is the only schedule which serves queue @xmath1 , so we would need @xmath418 .",
    "if @xmath419 , then it is impossible to serve all the work that arrives at queue @xmath1 .",
    "otherwise , we may as well set @xmath420 .",
    "the total amount of service given to queue @xmath0 is then @xmath421 ; if @xmath422 , then it is possible to serve all the work arriving at queue @xmath0 .",
    "we have concluded that @xmath423 further algebra tells us that @xmath424 hence @xmath425      the feasible region of @xmath365 is @xmath428 the extreme points may be found by sketching the feasible region ; they are @xmath429 , @xmath430 , @xmath431 and @xmath432 .",
    "clearly the maximal extreme points , that is , the virtual resources , are @xmath433 the set of critically loaded virtual resources depends on @xmath410 and @xmath434 iff @xmath435 , and @xmath436 iff @xmath437 .",
    "each virtual resource @xmath439 may be interpreted as a virtual queue .",
    "for example , take @xmath440 , and define the virtual queue size to be @xmath441 .",
    "think of the virtual queue as consisting of tokens : every time a packet arrives to queue @xmath0 put @xmath442 tokens into the virtual queue , and every time a packet arrives to queue @xmath1 put in @xmath443 tokens . the schedule @xmath444 can remove at most @xmath445 token , and schedule  @xmath417 can remove at most @xmath446 token . in order that the total rate at which tokens arrive should be no more than the maximum rate at which we can remove tokens , we need @xmath447 that is , @xmath448 .",
    "if @xmath449 , then there is some @xmath439 such that @xmath450 , which means that the corresponding virtual queue is unstable ; hence the original system is unstable .      throughout this subsection",
    "we consider a single - hop switched network running mw-@xmath98 with arrival rates @xmath385 .",
    "the first claim of theorem [ thm : fp](i ) , that @xmath451 is compact for any @xmath389 , follows straightforwardly from the facts that @xmath452 as @xmath453 , and @xmath454 is continuous .",
    "the second claim follows from a standard result ( first given by dai and prabhakar @xcite , for an input - queued switch ) , which we include here for the sake of completeness .",
    "[ lem : lyapunov ] for all @xmath455 , @xmath456 also , every fluid model solution satisfies @xmath457    since @xmath385 , we can write @xmath416 componentwise for some @xmath458 with @xmath459 and @xmath460",
    ". hence @xmath461 for the claim about fluid model solutions , @xmath462    to prove theorem [ thm : fp](ii ) , it is useful to work with a `` fuller '' representation of the lifting map",
    ". let @xmath243 be the set of extreme feasible solutions of @xmath365 , and define @xmath463 this includes nonmaximal extreme points , whereas @xmath369 only includes maximal extreme points .",
    "[ lem : liftwplus ] the lifting map @xmath382 is the unique solution to the optimization problem @xmath464 , @xmath465    @xmath464 has a unique minimum for the same reason that @xmath378 has a unique minimum .",
    "next we claim that if @xmath466 is feasible for @xmath378 then it is feasible for @xmath464 .",
    "pick any @xmath467 . by definition",
    ", @xmath468 is an extreme feasible solution of @xmath365 and @xmath469 . since it is an extreme feasible solution , @xmath470 for some virtual resource @xmath471 . since @xmath469 we know @xmath472 , but by assumption @xmath385 ; hence @xmath473 and furthermore @xmath474 only for  @xmath55 where @xmath475 .",
    "now , @xmath476 we assumed that @xmath466 is feasible for @xmath378 ; by the first constraint of @xmath378 the first term in the preceding equation is positive ; by the second constraint the second term is positive .",
    "we have shown that @xmath477 for all @xmath467 ; hence @xmath466 is feasible for @xmath464 .",
    "next we claim that if @xmath466 is optimal for @xmath464 , then it is feasible for @xmath378",
    ". clearly it satisfies the first constraint of @xmath378 .",
    "suppose it does not satisfy the second constraint , that is , that @xmath478 for some @xmath55 where @xmath475 , and define @xmath479 by @xmath480 if @xmath481 and @xmath482 .",
    "then @xmath483 , hence @xmath484 . also , @xmath479 is feasible for @xmath485 . to see this ,",
    "pick any @xmath486 , and let @xmath467 be such that @xmath487",
    "if @xmath481 and @xmath488 . then @xmath489 the inequality is because @xmath466 is feasible for @xmath464 .",
    "this contradicts optimality of @xmath466 .",
    "putting these two claims together completes the proof .    with this representation ,",
    "the lifting map @xmath384 can be split into two parts .",
    "let @xmath490 and define the _ workload map _ @xmath491 by @xmath492_{1\\leq v\\leq v}$ ] . also define @xmath493 by @xmath494 ( this has a unique optimum for the same reason that @xmath495 and @xmath383 have . )",
    "then the lifting map is simply the composition of @xmath496 and @xmath497 .",
    "it is clear that @xmath497 is continuous ; to prove theorem [ thm : fp](ii ) we just need to prove that @xmath496 is continuous .",
    "[ lem : lift.continuous ] @xmath496 is continuous .",
    "if @xmath498 is empty , then @xmath496 is trivial and the result is trivial . in what follows , we shall assume that @xmath498 is nonempty , and we will abbreviate it to @xmath499 . furthermore note that for every @xmath500 there is some queue  @xmath55 such that @xmath501 ; this is because @xmath469 by definition of @xmath499 .",
    "pick any sequence @xmath502 , and let @xmath503 and @xmath504 . we want to prove that @xmath505 .",
    "we shall first prove that there is a compact set @xmath506^n$ ] such that @xmath507^n$ ] for all @xmath300 .",
    "we shall then prove that any convergent subsequence of @xmath508 converges to @xmath466 ; this establishes continuity of  @xmath496 .    first  compactness .",
    "a suitable value for @xmath509 is @xmath510 note than the maximums are over a nonempty set , as noted at the beginning of the proof .",
    "note also that @xmath509 is finite because @xmath511 is finite . now , suppose that @xmath512^n$ ] for some @xmath300 , that is , that there is some queue @xmath55 for which @xmath513 , and let @xmath514 in each component except for @xmath515 .",
    "we claim that @xmath479 satisfies the constraints of the optimization problem for @xmath516 . to see this , pick any @xmath517 ; either @xmath518 in which case @xmath519 , or @xmath520 in which case @xmath521 by construction of @xmath509 . applying this repeatedly , if @xmath512^n$ ]",
    ", then we can reduce it to a queue size vector in @xmath506^n$ ] , thereby improving on @xmath522 , yet still meeting the constraints of the optimization problem for @xmath516 ; this contradicts the optimality of @xmath508 .",
    "hence @xmath507^n$ ] .",
    "next  convergence on subsequences . with a slight abuse of notation ,",
    "let @xmath523 be a convergent subsequence , and recall that @xmath524 and @xmath525 . by continuity of the constraints",
    ", @xmath526 is feasible for the optimization problem for @xmath527 ; we shall next show that @xmath528 .",
    "since @xmath466 is the unique optimum , it must be that @xmath529 .",
    "it remains to show that @xmath528 .",
    "consider the sequence @xmath530 as candidate solutions to the problem @xmath516 where @xmath531 this choice ensures that the candidates are feasible , since @xmath532 ( if we had used @xmath533 rather than @xmath500 , it would not necessarily be true that the candidates are feasible ; this is why we introduced lemma [ lem : liftwplus ] . )",
    "since the candidates are feasible solutions to the problem @xmath516 , and @xmath508 is an optimal solution , it must be that @xmath534 taking the limit as @xmath535 , and noting that @xmath536 is continuous and @xmath537 , we find @xmath538 as required .",
    "this completes the proof .    for the proof of theorem [ thm : fp](iii ) , it is useful to work with a different representation of the constraint of @xmath383 , provided by the following lemma .",
    "[ lem : equiv ]    @xmath539^+$ ] for some @xmath392 and @xmath540 .",
    "@xmath541^+$ ] is feasible for @xmath378 for all @xmath392 and @xmath540 .",
    "\\(i ) we will shortly prove that the following are equivalent , for all @xmath158 and @xmath542 : @xmath543 we use this equivalence as follows . from lemma [ lem : liftwplus ]",
    "we know that @xmath382 is the solution of @xmath464 .",
    "that is , letting @xmath544 , equation ( [ eq : equiv2 ] ) holds with @xmath545 in the place of @xmath466 .",
    "hence ( [ eq : equiv1 ] ) holds for some @xmath392 and @xmath540 ; moreover since @xmath546 it must be that @xmath547^+.\\ ] ] we claim that this inequality is in fact an equality . to see this , note that @xmath548^+$ ] satisfies ( [ eq : equiv1 ] )",
    "; hence it satisfies ( [ eq : equiv2 ] ) ; hence it is a feasible solution of @xmath464 .",
    "note also that @xmath454 is increasing componentwise , hence @xmath549 .",
    "but @xmath464 has a unique minimum , hence @xmath550 as required .",
    "this completes the proof of lemma [ lem : equiv](i ) , once we have proved the equivalence between ( [ eq : equiv1 ] ) and  ( [ eq : equiv2 ] ) .",
    "_ proof that _ ( [ eq : equiv1])@xmath551([eq : equiv2]).pick any @xmath467 . by definition of @xmath498 , we know : @xmath552 ; @xmath553 for all @xmath63 , hence @xmath554 for all @xmath540 ; and @xmath469 .",
    "hence @xmath555    _ proof that _ ( [ eq : equiv1])@xmath556([eq : equiv2]).let @xmath158 and @xmath466 satisfy ( [ eq : equiv2 ] ) , and let @xmath557 for some sufficiently large @xmath191 .",
    "we shortly show that the value of @xmath558 at its optimum is @xmath559 . by strong duality",
    "the value of @xmath560 at its optimum is likewise @xmath559 , and so by definition of @xmath560 we can find some @xmath561 such that @xmath562 componentwise .",
    "then @xmath563 that is , @xmath466 satisfies ( [ eq : equiv1 ] ) .",
    "it remains to show that the value of @xmath558 at its optimum is @xmath559 , that is , that @xmath564 for all dual - feasible @xmath565 .",
    "we have assumed that @xmath385 , hence @xmath566 . on one hand , if @xmath473 , then it follows from the definition of @xmath499 that @xmath567 , hence @xmath568 on the other hand , if @xmath569 , then @xmath570 and this is @xmath571 for @xmath175 sufficiently large . either way , @xmath572 .",
    "therefore the value of @xmath558 at its optimum is @xmath559 .",
    "\\(ii ) for this , we need to check two feasibility conditions of @xmath378 .",
    "the first feasibility condition is @xmath573^+ \\geq{{\\bolds{\\xi}}}{\\cdot}\\mathbf{q}\\qquad \\mbox{for all $ { { \\bolds{\\xi}}}\\in{\\xi}({\\bolds{\\lambda}})$.}\\ ] ] pick any @xmath574 . by definition of @xmath369 , @xmath552 , @xmath553 for all @xmath63 hence @xmath554 for all @xmath575 , and @xmath469 , thus @xmath573^+ \\geq { { \\bolds{\\xi}}}{\\cdot}[\\mathbf{q}+t({\\bolds{\\lambda}}-{\\bolds{\\sigma } } ) ] = { { \\bolds{\\xi}}}{\\cdot}\\mathbf{q}+ t ( 1 - { { \\bolds{\\xi}}}{\\cdot}{\\bolds{\\sigma } } ) \\geq { { \\bolds{\\xi}}}{\\cdot}\\mathbf{q}\\ ] ] as required .",
    "the second feasibility condition is that if @xmath475 for some @xmath55 , then @xmath576^+ = [ q_n - t \\sigma_n]^+ \\leq q_n.\\ ] ] this is true because @xmath577 componentwise for all @xmath540 .",
    "theorem [ thm : fp](iii ) is a corollary of the following lemma .",
    "[ lem : lift.scaleinvariant ] let @xmath100 . then @xmath578 for all @xmath395",
    ".    we will first establish three preliminary properties of @xmath384 .",
    "preliminary 1 is used to prove 2 , and 2 and 3 are used in the main proof .",
    "_ 1.if @xmath579 for",
    "some @xmath580 , then @xmath581 to see this , suppose @xmath63 has maximal weight and consider @xmath582^{+}$ ] .",
    "this is feasible for @xmath378 by lemma [ lem : equiv ] .",
    "now , using the fact that @xmath99 , @xmath583^+\\bigr)\\big| _ { t=0 } = ( { \\bolds{\\lambda}}-{{\\bolds{\\pi}}}){\\cdot}f(\\mathbf{q}).\\ ] ] since @xmath158 is optimal for @xmath584 it is optimal for @xmath378 , hence @xmath585 . on the other hand , @xmath385 so @xmath416 for some @xmath540 , hence @xmath586 .",
    "hence the result follows .    _",
    "preliminary _ 2.suppose that @xmath587 . from lemma [",
    "lem : equiv ] , @xmath548^+$ ] for some @xmath392 and @xmath540",
    ". then either @xmath588 or @xmath589 this is because @xmath175 is an optimal choice , so either @xmath175 is constrained to be @xmath111 or @xmath590^+\\bigr)\\big|_{u = t } = ( { \\bolds{\\lambda}}-{\\bolds{\\sigma}}){\\cdot}f({\\mathbf{r } } ) = 0.\\ ] ] in this second case , @xmath591 by ( [ eq : opt.cond ] ) so the same is true for  @xmath592 .",
    "_ preliminary _ 3.suppose that @xmath593 . from lemma [ lem : equiv ] , we can write it as @xmath548^+$ ] for some @xmath540 .",
    "in fact , for any @xmath594 we can write it as @xmath595^+ \\qquad\\mbox{for some $ { { \\bolds{\\rho}}}\\in\\langle{{\\mathcal{s}}}\\rangle$}.\\ ] ] to see this , recall that @xmath372 , so we can pick some @xmath596 such that @xmath597 , whence @xmath598^+\\\\[-2pt ] & = & [ \\mathbf{q}+ t({\\bolds{\\lambda}}-{{\\bolds{\\rho}}})]^+ \\qquad\\mbox{where } { { \\bolds{\\rho}}}=\\frac{t}{t}{\\bolds{\\sigma}}+\\frac{t - t}{t}\\bar { { \\bolds{\\lambda}}}\\in\\langle{{\\mathcal{s}}}\\rangle.\\end{aligned}\\ ] ] this last expression is feasible for @xmath378 by lemma [ lem : equiv ] . since @xmath466 is optimal for @xmath378 , and the objective function is increasing pointwise , @xmath599^+$ ] as claimed .",
    "_ _ main proof.__let @xmath600 and @xmath601 .",
    "we know that @xmath602 is feasible for @xmath603 because the constraints are linear ; we will now show that @xmath604 ; hence @xmath602 is also optimal for @xmath603 . by uniqueness of the optimum , @xmath605 as required .",
    "it remains to prove that @xmath604 .",
    "since @xmath466 solves @xmath378 and @xmath606 solves @xmath603 , we can use lemma [ lem : equiv ] to write @xmath607^+ , \\qquad \\kappa{\\mathbf{r } } ' = [ \\kappa\\mathbf{q}+ \\kappa t'({\\bolds{\\lambda}}-{\\bolds{\\sigma}}')]^+\\ ] ] for @xmath608 and @xmath609 .",
    "indeed , for @xmath610 we can use ( [ eq : extend ] ) to  write @xmath611 & & \\eqntext{\\mbox{where $ y_{n}=0 $ if $ r_{n}>0$},}\\\\[-2pt ] { \\mathbf{r } } ' & = & \\mathbf{q}+ t({\\bolds{\\lambda}}-{{\\bolds{\\rho}}}'+\\mathbf{y } ' ) \\qquad\\mbox{for $ { { \\bolds{\\rho}}}'\\in\\langle{{\\mathcal{s}}}\\rangle$ , $ \\mathbf{y}'\\in { { \\mathbb{r}}_+}^{{n}}$}\\nonumber\\\\[-2pt ] & & \\eqntext{\\mbox{where $ y'_{n}=0 $ if $ r'_{n}>0$}.}\\end{aligned}\\ ] ] now consider the value of @xmath454 along the trajectory from @xmath612 to @xmath606 . along this trajectory , @xmath613 & = & ( { { \\bolds{\\rho}}}-{{\\bolds{\\rho } } } ' -\\mathbf{y}+\\mathbf{y}'){\\cdot}f(\\kappa { \\mathbf{r}})\\\\[2pt ] & \\geq & ( { { \\bolds{\\rho}}}-{{\\bolds{\\rho } } } ' -\\mathbf{y}){\\cdot}f(\\kappa{\\mathbf{r } } ) \\qquad\\mbox{since $ \\mathbf{y}'\\geq{\\mathbf{0}}$}\\\\[2pt ] & = & ( { { \\bolds{\\rho}}}-{{\\bolds{\\rho}}}'){\\cdot}f(\\kappa{\\mathbf{r } } ) \\qquad\\mbox{since $ y_{n}=0 $ if $ r_{n}>0$}\\\\[2pt ] & \\geq & { { \\bolds{\\rho}}}{\\cdot}f(\\kappa{\\mathbf{r } } ) - \\max_{{{\\bolds{\\pi}}}\\in{\\mathcal{s}}}{{\\bolds{\\pi}}}{\\cdot}f(\\kappa { \\mathbf{r } } ) \\qquad\\mbox{for any $ { { \\bolds{\\rho}}}'\\in\\langle{{\\mathcal{s}}}\\rangle$}\\\\[2pt ] & = & 0.\\end{aligned}\\ ] ] the final equality is because @xmath614 by ( [ eq : optservice ] ) , so @xmath615 by assumption [ cond.f ] .",
    "since @xmath454 is convex , it follows that @xmath616 .",
    "this completes the proof .",
    "the proof of theorem [ thm : fp](iv ) relies on the following lemma .    [ lem : feasible ] consider any fluid model solution , for any scheduling policy , with initial queue size @xmath617 .",
    "then @xmath174 is feasible for @xmath618 for all @xmath392 .",
    "pick any critically loaded virtual resource @xmath574 . by ( [ eq : fluid.queue ] ) ,",
    "@xmath619 the last inequality is because @xmath574 ; so @xmath469 , and @xmath553 for all @xmath63 hence @xmath554 for all @xmath540 . finally , @xmath620 by ( [ eq : fluid.queue ] ) and  ( [ ineq : fluid.littleidle ] ) , and this yields the second constraint of @xmath621 for queues @xmath55 with 0 arrival rate .",
    "theorem [ thm : fp](iv ) is implied by parts ( i ) and ( ii ) of the following lemma .",
    "[ lem : fixedpoint ] the following are equivalent , for @xmath622 :    @xmath623 ;    @xmath396 is an invariant state ;    there exists a fluid model solution with @xmath624 for all @xmath175 ;    @xmath625 .    _",
    "proof that _",
    "( i)@xmath551(ii).suppose that @xmath626 , that is , that @xmath396 is optimal for @xmath627 , and consider any fluid model solution which starts with @xmath398 .",
    "on one hand , lemma [ lem : lyapunov ] says that @xmath628 .",
    "on the other hand , lemma  [ lem : feasible ] says that @xmath174 is feasible for @xmath627 .",
    "since @xmath627 has a unique solution , it must be that @xmath624 .",
    "_ proof that _",
    "( ii)@xmath551(iii).it is easy to find a fluid model solution which starts at @xmath398 : a limit point of the stochastic model from theorem [ thm : fluid ] will do . by ( ii ) , the queue size vector is constant .    _",
    "proof that _",
    "( iii)@xmath551(iv).suppose there is a fluid model solution with @xmath629 . since @xmath630 is constant , @xmath631 .",
    "lemma [ lem : lyapunov ] says that , so the inequality in the proof must be tight for all @xmath175 , that is , @xmath632    _ proof that _",
    "( iv)@xmath551(i).if @xmath633 then the result is trivial .",
    "otherwise , let @xmath634 .",
    "by lemma [ lem : equiv ] , @xmath635^+$ ] for some @xmath392 and @xmath540 . consider the value of @xmath454 along the trajectory from @xmath636 to @xmath466 @xmath637^+\\bigr ) \\bigg| _ { u=0 } & = & ( { \\bolds{\\lambda}}-{\\bolds{\\sigma}}){\\cdot}f(\\mathbf{q}^0 ) \\qquad\\mbox{relying on } f(0)=0\\\\ & = & \\bigl(\\max_{{{\\bolds{\\pi}}}\\in{\\mathcal{s}}}{{\\bolds{\\pi}}}{\\cdot}f(\\mathbf{q}^0)\\bigr ) - { \\bolds{\\sigma}}{\\cdot}f(\\mathbf{q}^0 ) \\qquad\\mbox{by part ( iv)}\\\\ & \\geq&0\\qquad \\mbox{because } { \\bolds{\\sigma}}\\in\\langle{{\\mathcal{s}}}\\rangle.\\end{aligned}\\ ] ] by convexity of @xmath536 , @xmath638 , and @xmath396 is obviously feasible for @xmath627 , but we chose @xmath466 to be optimal for @xmath627 , and the optimum is unique . therefore @xmath626 .",
    "theorem [ thm : fp](v ) is given by the following lemma .",
    "recall that we are using the norm @xmath639 given @xmath385 , for any @xmath401 there exists an @xmath640 such that for every fluid model solution with arrival rate @xmath120 , for which @xmath403 , @xmath641 for all @xmath405 .",
    "the proof is inspired by kelly and williams @xcite , theorem 5.2 , lemma 6.3 .",
    "we start with some definitions .",
    "let @xmath642 { \\mathcal{i}}&= & \\ { \\mathbf{q}\\in{\\mathcal{d}}\\dvtx{\\delta}{w}(\\mathbf { q})=\\mathbf{q}\\};\\\\[-2pt ] { \\mathcal{i}}_\\delta&= & \\ { \\mathbf{q}\\in{\\mathcal{d}}\\dvtx|\\mathbf{q}-{\\mathbf{r}}|<\\delta\\mbox { for some } { \\mathbf{r}}\\in{\\mathcal{i}}\\};\\\\[-2pt ] { \\mathcal{j}}_\\varepsilon&= & \\ { \\mathbf{q}\\in{{\\mathbb{r}}_+}\\dvtx | \\mathbf{q}-{\\delta}{w}(\\mathbf{q } ) | < \\varepsilon\\};\\\\[-2pt ] { \\mathcal{k}}_\\delta&= & \\bigl\\ { \\mathbf{q}\\in{\\mathcal{d}}\\dvtx l(\\mathbf{q})-l ( { \\delta}{w}(\\mathbf{q } ) ) < \\inf_{{\\mathbf{r}}\\in{\\mathcal{d}}\\setminus{\\mathcal{i}}_\\delta } l({\\mathbf{r}})-l({\\delta}{w}({\\mathbf{r } } ) ) \\bigr\\}.\\vspace*{-2pt}\\end{aligned}\\ ] ] we will argue that the function @xmath643 is decreasing along fluid model trajectories , so once you hit @xmath644 you stay there .",
    "we will then argue that @xmath645 for sufficiently small @xmath320 . finally , we will bound the time it takes to hit @xmath644 .    _",
    "_ @xmath258 is decreasing.__lemma [ lem : lyapunov ] says that for any fluid model solution , @xmath646 is decreasing . from lemma [ lem : feasible ] , the feasible set for @xmath647 is a subset of the feasible set for @xmath648 for any @xmath649 , hence @xmath650 , that is , @xmath651 is increasing . therefore @xmath258 is decreasing ( not necessarily strictly ) .    _",
    "_ @xmath652.__to show @xmath653 : the map @xmath384 is continuous by theorem  [ thm : fp](ii ) , and @xmath454 is clearly continuous , so @xmath654 is continuous ; also the set @xmath655 is compact by theorem [ thm : fp](i ) , and @xmath656 is open , so @xmath657 is compact ; so the infimum in the definition of @xmath644 is attained at some @xmath658 .",
    "now , @xmath659 for @xmath660 , so @xmath661 . yet @xmath662 for @xmath663 .",
    "thus @xmath653 .",
    "it is clear by construction that @xmath664 .",
    "to show @xmath665 : the map @xmath666 is continuous , hence it is uniformly  continuous on the compact set @xmath655 , so for any @xmath401 there exists a @xmath222 such that @xmath667 if @xmath668 , then it is within @xmath320 of some @xmath669 , hence @xmath670 & < & \\delta+ 0 + \\varepsilon/2\\\\[-2pt ] & < & \\varepsilon \\qquad\\mbox{for $ \\delta$ sufficiently small}.\\vspace*{-2pt}\\end{aligned}\\ ] ]    _ _ time to hit @xmath644.__consider first the rate of change of @xmath654 while the process is in @xmath671 @xmath672 & \\leq & \\sup_{{\\mathbf{r}}\\in{\\mathcal{d}}\\setminus{\\mathcal{k}}_\\delta } \\bigl[{\\bolds{\\lambda}}{\\cdot}f({\\mathbf{r } } ) - \\max_{{{\\bolds{\\pi}}}\\in{\\mathcal{s } } } { { \\bolds{\\pi}}}{\\cdot}f({\\mathbf{r } } ) \\bigr]\\\\[-2pt ] & \\leq&0\\qquad \\mbox{by lemma \\ref{lem : lyapunov}. } \\nonumber\\vspace*{-2pt}\\end{aligned}\\ ] ] the supremum in ( [ eq : thissup ] ) is of a continuous function of @xmath466 , taken over a compact set ; hence the supremum is attained at some @xmath673 .",
    "if the supremum were equal to 0 , then @xmath674 , so @xmath675 by lemma [ lem : fixedpoint ] ; but @xmath673 , and we just proved that @xmath653 ; hence the supremum is some @xmath676 .    now consider any fluid model solution starting at @xmath617 with @xmath403 .",
    "if , then it remains in @xmath644 , so the theorem holds trivially . if not , then @xmath677 componentwise , so @xmath678 , so @xmath679 ; also @xmath680 is decreasing so @xmath681 for all @xmath392 .",
    "now , @xmath682 all the time that @xmath683 , and this can not go on for longer than @xmath684 .",
    "[ sec : fluid.behavior.m ]    in this section we describe properties of fluid model solutions for a multi - hop switched network running mw-@xmath98 back - pressure , as described in section [ sec : model ] .",
    "let @xmath198 be the routing matrix and @xmath81 ; recall that @xmath84 if work injected at queue @xmath55 eventually passes through @xmath76 , and @xmath111 otherwise . for a vector @xmath685 ,",
    "let @xmath686 : for arrival rate vector @xmath120 , @xmath687 is the total arrival rate of work destined to pass through queue @xmath55 ; for a queue size vector @xmath158 , @xmath688 is the total amount of work at queue @xmath55 and queues upstream of @xmath55 .",
    "the set @xmath361 , the @xmath689 and @xmath690 problems , the set @xmath426 of virtual resources , and @xmath691 are defined as in the single - hop case .",
    "the difference is that we will require @xmath692 , and we will define the set of critically loaded virtual resources to be @xmath693 .",
    "we also need to modify the definition of @xmath383 and the lifting map .    with @xmath373 as in the single - hop case , define the optimization problem @xmath378 to be @xmath694 & & \\mbox{such that } { { \\bolds{\\xi}}}{\\cdot}{\\vec{\\mathbf{r}}}\\geq{{\\bolds{\\xi}}}{\\cdot}{\\vec{\\mathbf{q}}}\\qquad\\mbox{for all $ { { \\bolds{\\xi}}}\\in{\\xi}({\\vec{{\\bolds{\\lambda}}}})$}\\quad\\mbox{and}\\\\[-3pt ] & & \\hphantom{\\mbox{such that } } \\vec{r}_n\\leq{\\vec{q}}_n \\qquad\\mbox{for all $ n$ such that $ { \\vec{\\lambda}}_n=0$}.\\end{aligned}\\ ] ] note that @xmath536 is strictly convex and increasing componentwise , and the feasible region is convex ; hence this problem has a unique optimizer . define the _ lifting map _ @xmath381 by setting @xmath382 to be the optimizer .",
    "the main result of this section is the following . throughout this section",
    "we are considering a multi - hop network with arrival rate vector @xmath695 such that @xmath692 , running mw-@xmath98 back - pressure .",
    "[ thm : fp.m ] the statements of theorem [ thm : fp ] parts hold , for multi - hop fluid model solutions and using the multi - hop definition of @xmath384 .",
    "some of the proofs for the single - hop case carry through to the multi - hop case .",
    "other proofs rely on the fact that for single - hop networks , @xmath696 for some @xmath540 , and these proofs require modification .",
    "we will modify them to use the following result .",
    "[ lem : monotone ] under assumption [ cond.monotone ] , if @xmath540 and @xmath697 is such that @xmath562 , then @xmath698 .",
    "it is sufficient to establish the result for the case when @xmath699 differs from @xmath592 in only one component , as the repeated application of this will yield the full result . without loss of generality ,",
    "assume the queues are numbered such that @xmath700 and @xmath701 for @xmath702 . since @xmath540",
    "there is a collection of positive constants @xmath703 such that @xmath704 and @xmath705 . by assumption [ cond.monotone ] , if @xmath63 , then @xmath706 where @xmath707 thus @xmath708 where @xmath709 . by construction , @xmath710 and @xmath711 for @xmath702 . by choosing the appropriate convex combination @xmath712\\ ] ]",
    "we see @xmath698 .",
    "now we proceed toward establishing theorem [ thm : fp.m ] .",
    "the proof of the first claim of theorem [ thm : fp.m](i ) is just as for the single - hop case .",
    "the second claim follows from the following lemma .",
    "[ lem : lyapunov.multihop ] for all @xmath455 , @xmath713 also , every fluid model solution satisfies @xmath714    since @xmath692 , @xmath715 componentwise for some @xmath540 . because @xmath716 and @xmath695 , @xmath717 componentwise . by lemma [ lem : monotone ] , @xmath718 for some @xmath698 .",
    "hence @xmath719 for the claim about fluid model solutions , @xmath720\\biggr ) { \\cdot}f(\\mathbf{q}(t))\\\\ & & \\mbox{by differentiating ( \\ref{eq : multihop.fluid.queue})}\\\\ & = & { \\bolds{\\lambda}}{\\cdot}f(\\mathbf{q}(t ) ) - \\sum_{{\\bolds{\\pi}}}\\dot{s}_{{\\bolds{\\pi}}}(t ) { { \\bolds{\\pi}}}{\\cdot}(i - r)f(\\mathbf{q}(t ) ) + \\dot{\\mathbf{y}}(t){\\cdot}(i - r)f(\\mathbf{q}(t)).\\end{aligned}\\ ] ] for the middle term , @xmath721 for the last term , we claim that @xmath722 to see this , consider first a queue @xmath55 with @xmath723_n>0 $ ] . as noted in ( [ eq : backpressure ] ) , this implies @xmath724_n)$ ] . by assumption [ multihop.cond.f ]",
    "it must be that @xmath725 , hence @xmath726 by ( [ eq : fluid.idling ] ) .",
    "second , consider a queue @xmath55 with @xmath723_n<0 $ ] .",
    "it must be that all of the active schedules do not serve this queue , that is , @xmath727 , since otherwise by assumption [ cond.monotone ] there is another schedule that has bigger weight than @xmath72 , contradicting ( [ eq : multihop.fluid.mwm ] ) .",
    "third , if @xmath728_n=0 $ ] then obviously @xmath729_n=0 $ ] .",
    "putting these three together proves ( [ eq : multihop.noidle ] ) .",
    "putting together these findings for the middle and last terms , @xmath730 applying ( [ eq : m.lyapunov.neg ] ) this is @xmath731 .",
    "the proof of theorem [ thm : fp.m](ii ) is broadly similar to the single - hop case , lemma  [ lem : lift.continuous ] , but the formulae all have to be adjusted to deal with multi - hop .",
    "@xmath384 is continuous .",
    "if @xmath693 is empty , then the lifting map is trivial , and the result is trivial . in what follows , we shall assume that @xmath693 is nonempty , and we will abbreviate it to @xmath427 . furthermore note that for every @xmath533 we know @xmath732 by definition of @xmath427 , and hence there is some queue @xmath55 such that @xmath501 and @xmath733 .",
    "pick any sequence @xmath734 , and let @xmath735 and @xmath600 .",
    "we want to prove that @xmath505 .",
    "we shall first prove that there is a compact set @xmath506^n$ ] such that @xmath507^n$ ] for all @xmath300 .",
    "we shall then prove that any convergent subsequence of @xmath508 converges to @xmath466 ; this establishes continuity of  @xmath384 .    first  compactness .",
    "a suitable value for @xmath509 is @xmath736 note that the maximums are over a nonempty set , as noted at the beginning of the proof .",
    "note also that @xmath509 is finite because @xmath737 is finite . now , suppose that @xmath512^n$ ] for some @xmath300 , that is , that there is some queue @xmath55 for which @xmath513 , and let @xmath514 in every coordinate except for @xmath515 .",
    "we claim that @xmath479 satisfies the two constraints of @xmath738 . to see that it satisfies the second constraint , note that @xmath739 , and hence if @xmath740 , then @xmath741 . to see that it satisfies the first constraint , pick any @xmath533 .",
    "either @xmath742 for all queues  @xmath76 that are downstream of @xmath55 , that is , for which @xmath84 ; if this is so , then=-1 @xmath743=0 or @xmath744 for some queue @xmath76 that is downstream of @xmath55 ; if this is so , then @xmath745 applying this repeatedly , if @xmath512^n$ ] , then we can reduce it to a queue size vector in @xmath506^n$ ] , thereby improving on @xmath522 , yet still meeting the constraints of @xmath738 ; this contradicts the optimality of @xmath508 .",
    "hence @xmath507^n$ ]",
    ".    next  convergence on subsequences . with a slight abuse of notation ,",
    "let @xmath746 be a convergent subsequence , and recall that @xmath747 and @xmath748 .",
    "by continuity of the constraints of @xmath383 , @xmath526 is feasible for @xmath378 ; we shall next show that @xmath528 .",
    "since @xmath466 is the unique optimum , it must be that @xmath529 .",
    "it remains to show that @xmath528 .",
    "we will construct a sequence @xmath749 of candidate solutions to @xmath738 , choosing @xmath750 and @xmath751 to ensure that the candidate solutions are feasible . specifically , we define @xmath752 and @xmath753 , and @xmath754 we will first deal with the feasibility constraint that pertains when @xmath740 .",
    "note that this implies @xmath755 for all queues @xmath76 that are upstream of @xmath55 , since @xmath756 , and hence that @xmath757 for all upstream queues .",
    "using this we find @xmath758_n\\\\ & & \\qquad= \\sum_m { \\vec{r}}_{n m}[{\\mathbf{r}}-{\\bolds{\\delta}}^k+\\varepsilon^k{\\mathbf{p}}]_m\\\\ & & \\qquad= \\sum_m { \\vec{r}}_{n m}\\bigl(r_m - ( { \\vec{q}}_m-{\\vec{q}}^k_m)^+ \\bigr ) \\qquad\\mbox{since $ { \\vec{\\lambda}}_m=0 $ when $ { \\vec{r}}_{n m}=1$}\\\\ & & \\qquad= \\biggl(\\sum_m { \\vec{r}}_{n m}r_m \\biggr ) - \\biggl(\\sum_m { \\vec{r}}_{n m } ( { \\vec{q}}_m-{\\vec{q}}^k_m)^+ \\biggr ) \\\\ & & \\qquad\\leq \\biggl(\\sum_m { \\vec{r}}_{n m}r_m\\biggr ) - ( { \\vec{q}}_n-{\\vec{q}}^k_n)^+ \\qquad\\mbox{as $ { \\vec{r}}_{nn}=1 $ , $ { \\vec{r}}_{n m } \\geq0 $ for all $ m$}\\\\ & & \\qquad= \\vec{r}_n - ( { \\vec{q}}_n-{\\vec{q}}^k_n)^+\\\\ & & \\qquad\\leq { \\vec{q}}_n - ( { \\vec{q}}_n-{\\vec{q}}^k_n)^+ \\qquad\\mbox{since $ { \\mathbf{r}}$ is feasible for $ { \\operatorname{algd}}(\\mathbf{q})$}\\\\ & & \\qquad= \\min({\\vec{q}}_n,{\\vec{q}}^k_n ) \\leq{\\vec{q}}^k_n.\\end{aligned}\\ ] ] hence @xmath749 satisfies the second feasibility constraint of @xmath738 . for the other feasibility constraint of @xmath738 ,",
    "pick any @xmath533 .",
    "then @xmath759 since the candidates are feasible solutions to @xmath760 , and @xmath508 is an optimal solution , it must be that @xmath761 taking the limit as @xmath535 , and noting that @xmath536 is continuous and @xmath762 and , we find @xmath538 as required .",
    "this completes the proof .    for the proof of theorem [ thm : fp.m](iii ) , it is useful to work with a different representation of @xmath384 , provided by the following lemma , which draws on monotonicity of  @xmath64 .",
    "[ lem : monotonedw ] for any @xmath455 , @xmath382 can be written @xmath763    we will choose @xmath592 simply by multiplying each side of the desired equation by @xmath764 @xmath765 or , rearranging , @xmath766 we will show that @xmath767 for some @xmath768 , hence by lemma [ lem : monotone ] @xmath540 .",
    "first , we show @xmath769 . if @xmath733 this can be achieved by choosing @xmath175 sufficiently large . if @xmath740 , then by the second constraint of @xmath378 we know that",
    "@xmath770 so @xmath771 .",
    "second , we show @xmath772 for all @xmath468 that are feasible for @xmath773 . either , in which case @xmath774 and so by the first constraint of @xmath383 we know that @xmath775 . or @xmath776 , in which case we simply need to choose @xmath175 sufficiently large . either way , @xmath772 for all dual - feasible @xmath468 , hence @xmath777 , hence @xmath778 , hence @xmath779 for some @xmath768 by the definition of @xmath780 .",
    "the proof of theorem [ thm : fp.m](iii ) is given by the following lemma .",
    "this proof is similar to the single - hop case , lemma [ lem : lift.scaleinvariant ] , but it is much shorter because the monotonicity assumption gives us a stronger representation of the lifting map , lemma  [ lem : monotonedw ] .",
    "also , this version makes a weaker claim , namely that the lifting map is scale - invariant at invariant states , whereas the single - hop version shows that the lifting map is invariant everywhere .",
    "[ lem : multihop.scale ] if @xmath393 then @xmath781 for all @xmath395 .",
    "suppose that @xmath393 , and let @xmath782 . clearly @xmath783 is feasible for @xmath603 ; we shall show that @xmath784 , whence @xmath783 is also optimal for @xmath603 , whence @xmath785 by uniqueness of the optimum .    it remains to prove that @xmath786 . by lemma [ lem : monotonedw ]",
    ", we can write @xmath602  as @xmath787 for some @xmath392 and some @xmath788 .",
    "now consider the value of @xmath536 along a straight - line trajectory from @xmath783 to @xmath602 @xmath789 the final equality is because @xmath790 by lemma [ lem : multihop.fixed](iv ) below ( the proof of which does not assume the result of this lemma ) .",
    "hence @xmath791 using assumption [ multihop.cond.f ] and the fact that @xmath792 by lemma [ lem : monotone ] .",
    "the proof of theorem [ thm : fp.m](iv ) relies on the following lemma .",
    "[ lem : multihop.feasible ] consider any fluid model solution , for any scheduling policy , with initial queue size @xmath617 .",
    "then @xmath174 is feasible for @xmath618 for all @xmath392 .",
    "feasibility for @xmath618 has two parts .",
    "for the first part , pick any critically loaded virtual resource @xmath793 , and multiply each side of ( [ eq : multihop.fluid.queue ] ) by @xmath794 and then by @xmath468 to get @xmath795 defining @xmath796 , which is in @xmath29 by ( [ eq : fluid.busy ] ) , @xmath797 & = & { { \\bolds{\\xi}}}{\\cdot}{\\vec{\\mathbf{q}}}(0 ) + t\\bigl(1 - { { \\bolds{\\xi}}}{\\cdot}{\\bolds{\\sigma}}(t)\\bigr ) \\qquad\\mbox{since $ { { \\bolds{\\xi}}}\\in{\\xi}({\\vec{{\\bolds{\\lambda}}}})$}\\\\[-2pt ] & \\geq & { { \\bolds{\\xi}}}{\\cdot}{\\vec{\\mathbf{q}}}(0 ) + t(1 - 1 ) \\qquad\\mbox{since $ { { \\bolds{\\xi}}}$ is a virtual resource and $ { \\bolds{\\sigma}}\\in \\langle{{\\mathcal{s}}}\\rangle$}\\\\[-2pt ] & = & { { \\bolds{\\xi}}}{\\cdot}{\\vec{\\mathbf{q}}}(0)\\end{aligned}\\ ] ] as required for the first part of @xmath383-feasibility .",
    "for the second part , suppose that @xmath740 for some queue @xmath55 .",
    "multiply each side of ( [ eq : multihop.fluid.queue ] ) by @xmath764 to get @xmath798 where the inequality is by ( [ ineq : fluid.littleidle ] ) . since we assumed @xmath740 , @xmath799 .",
    "this completes the proof that @xmath174 is feasible for @xmath618 .",
    "the proof of theorem [ thm : fp.m](iv ) is implied by parts ( i ) and ( ii ) of the following lemma .",
    "[ lem : multihop.fixed ] the following are equivalent , for @xmath622 :    @xmath623 ;    @xmath396 is an invariant state ;    there exists a fluid model solution with @xmath624 for all @xmath175 ;    @xmath800 .",
    "that ( i)@xmath551(ii)@xmath551(iii)@xmath551(iv ) is proved in the same way as in the single - hop case .",
    "we just need to appeal to lemma [ lem : lyapunov.multihop ] rather than [ lem : lyapunov ] for the fact that @xmath680 is decreasing , and to lemma [ lem : multihop.feasible ] rather than [ lem : feasible ] for the fact that @xmath174 remains feasible .",
    "_ proof that _",
    "( iv)@xmath551(i).let @xmath634 . by lemma [ lem : monotonedw ] , @xmath801 for some @xmath392 and @xmath540 . by considering the value of @xmath454 along the trajectory from @xmath396 to @xmath466 , and using ( iv ) ,",
    "we conclude that @xmath638 . by the same argument as in the single - hop case , @xmath626 .    the proof of theorem [ thm : fp.m](v ) is given by the following lemma .",
    "[ lem : multihop.conv ] given @xmath692 , for any @xmath401 there exists an @xmath802 such that for every fluid model solution with arrival rate @xmath120 , for which @xmath403 , @xmath404 for all @xmath803 .",
    "the proof of lemma [ lem : criticalfluid.time ] goes through almost verbatim .",
    "the only changes are in the penultimate paragraph , which should be replaced by the following :    _ _ time to hit @xmath644.__consider first the rate of change of @xmath654 while the process is in @xmath671 @xmath804\\\\ & \\leq&0\\qquad \\mbox{by lemma \\ref{lem : lyapunov.multihop}.}\\end{aligned}\\ ] ] this supremum is of a continuous function of @xmath466 , taken over a closed and bounded set , hence the supremum is attained at some @xmath673 .",
    "if the supremum were equal to 0 , then @xmath805 so @xmath675 by lemma [ lem : multihop.fixed ] ; but @xmath673 and we just proved that @xmath653 ; hence the supremum is some @xmath676 .",
    "this section establishes multiplicative state space collapse of queue size .",
    "it shows that under the mw-@xmath98 policy , and with suitable initial conditions when the network is not overloaded ( i.e. , when @xmath385 ) , the appropriately normalized queue size vector is constrained to lie in or close to the _ set of invariant states _",
    "@xmath806 we assume that arrivals satisfy assumption [ cond : mssc.stoch ] , and let the arrival rate vector @xmath120 be as specified in that assumption .",
    "the function @xmath807 depends on @xmath120 and @xmath98 , as specified in sections [ sec : fluid.behavior ] and [ sec : fluid.behavior.m ] for single - hop and multi - hop networks , respectively , and the interesting case is where @xmath808 ( since otherwise @xmath807 is trivial ) .",
    "this section mostly follows the method developed by bramson @xcite , except that our proof avoids the need for regenerative assumptions on the arrival process by imposing slightly tighter bounds on the uniformity of their convergence , as expressed by assumption [ cond : mssc.stoch ] .",
    "consider a sequence of systems of the type described in section [ sec : model.queue ] running a scheduling policy of the type described in section [ sec : model.alg ] .",
    "let the systems all have the same number of queues @xmath16 , the same set of allowed schedules @xmath64 , the same routing matrix @xmath198 and the same scheduling policy .",
    "let the sequence of systems be indexed by @xmath125 .",
    "write @xmath809 for the @xmath130th system .",
    "define the scaled system @xmath810 for @xmath191 by @xmath811 after extending the domain of @xmath812 to @xmath163 by linear interpolation in each interval @xmath194 .",
    "note that each sample path of a scaled system @xmath813 over the interval @xmath157 $ ] lies in @xmath32 with @xmath165 .",
    "@xmath814 will be fixed for the remainder of this section .",
    "recall the norm @xmath815 .",
    "the main result of this paper is the following .",
    "[ thm : heavytraffic ] consider a sequence of ( single - hop or multi - hop ) switched networks indexed by @xmath816 , operating under the mw-@xmath98 policy ( with @xmath98 satisfying assumptions [ cond.f ] or [ multihop.cond.f ] and @xmath64 with assumption  [ cond.monotone ] ) , as described above .",
    "assume that the arrival processes satisfy assumption  [ cond : mssc.stoch ] with @xmath385 .",
    "also assume that the initial queue sizes are nonrandom , and satisfy @xmath817 for some @xmath818 .",
    "then for any @xmath222 , @xmath819    simulations suggest that a stronger result holds in the widely - studied _ diffusion _ or _",
    "heavy traffic _ scaling , @xmath820 for some nontrivial @xmath821 and @xmath808 .",
    "we conjecture the following .",
    "[ conj : heavytraffic.ssc ] under the assumptions of theorem [ thm : heavytraffic ] and the additional assumption that increments in the arrival process are i.i.d . and uniformly bounded , under the diffusion scaling for any @xmath822 @xmath823    ]      the outline of the proof of theorem  [ thm : heavytraffic ] is as follows .",
    "we are interested in the dynamics of @xmath824 over @xmath157 $ ] , that is , of @xmath825 over @xmath826 $ ] .",
    "we will split this time interval into @xmath827 pieces starting at @xmath828 and look at each piece under a  fluid scaling .",
    "we will define a `` good event '' @xmath829 under which the arrivals in all of the pieces are well behaved ( section [ sec : ht.good ] ) .",
    "we then apply theorem [ thm : fluid ] to deduce that , under this event , the queue size process in each of the pieces can be ( uniformly ) approximated by a fluid model solution ( lemma [ lem : ht.fms ] ) .",
    "we then use the properties of the fluid model solution stated in theorem  [ thm : fp ] to show that in each of the pieces , the queue size is ( uniformly ) close to the set of invariant states ( lemmas [ lem : ht.m ] and [ lem : ssc.pathwise ] ) .",
    "figure [ fig : htscale ] depicts the idea .",
    "finally we show that @xmath830 ( lemma [ lem : ht.prob ] ) .",
    "the formal proof is given in section  [ sec : ht.proof ] .    note that lemmas [ lem : ht.fms][lem : ssc.pathwise ] are all sample path - wise results that hold for every @xmath831 , and so questions of independence etc .",
    "do not arise .",
    "the only part of the proof where probability comes in is lemma [ lem : ht.prob ] .    the proof is written out for a single - hop switched network .",
    "for the multi - hop case , the argument holds verbatim ; simply replace all references to the single - hop fluid limit theorem [ thm : fluid ] by references to the equivalent multi - hop result , and replace all references to the description of single - hop fluid model solutions in theorem [ thm : fp ] by references to the multi - hop version theorem  [ thm : fp.m ] .",
    "define the fluid - scaled pieces @xmath832 of the original process by @xmath833 for @xmath834 , @xmath835 and @xmath836 . here",
    "@xmath130 indicates which process we are considering , @xmath76 indicates the piece and @xmath210 indicates the fluid - scaling parameter .",
    "the scaling parameter @xmath837 is particularly important , and for convenience we will define @xmath838 by=-1 @xmath839=0 the good event is defined to be @xmath840}| { \\tilde{\\mathbf{a}}}^{r , m , w_{r , k}}(u)-{\\bolds{\\lambda}}^r u|<\\eta_r \\mbox { for all $ 0\\leq m\\leq\\lfloor rt\\rfloor$}\\nonumber\\\\[-9pt]\\\\[-9pt ] & & \\hspace*{19pt}\\mbox{and $ 0\\leq k\\leq\\lfloor lr\\log r\\rfloor$ , where $ w_{r , k}=r(1+k/\\log r)$ } \\bigr\\}. \\nonumber\\end{aligned}\\ ] ] by this , we mean that @xmath829 is a subset of the sample space for the @xmath130th system , and we write @xmath841 etc . for @xmath831 when we wish to emphasize the dependence on  @xmath829 .",
    "the constants here are @xmath842 , @xmath843 , @xmath844 is chosen as specified in section  [ sec : ht.proof ] below , @xmath845 is chosen as in theorem [ thm : fp](v ) , @xmath846 , @xmath847 and the sequence of deviation terms @xmath848 $ ] is chosen as specified in lemma [ lem : ht.prob ] such that @xmath849 as @xmath127 .",
    "[ lem : ht.fms ] let @xmath169 be the set of fluid model solutions over time horizon @xmath850 $ ] for arrival rate vector @xmath120 , and let @xmath851 and @xmath852 be as specified in definition [ def : fms ]",
    ". then @xmath853 and @xmath854 where @xmath855 .",
    "the proof of each equation will use theorem [ thm : fluid ] .",
    "we start with ( [ eq : ht.fms.1 ] ) .",
    "the theorem requires the use of an index @xmath146 in some totally ordered countable set ; here we shall use the pair @xmath856 ordered lexicographically , where @xmath125 and @xmath857 .",
    "lexicographic ordering means @xmath858 iff either @xmath859 or both @xmath860 and @xmath861 .",
    "note that @xmath254 implies @xmath127 ( and vice versa ) .    to apply the theorem",
    ", we first need to pick constants .",
    "let @xmath231 , let @xmath120 and @xmath862 as per assumption [ cond : mssc.stoch ] and let @xmath863 so that @xmath288 .",
    "thus condition ( [ cond.rateconv ] ) of theorem [ thm : fluid ] is satisfied .",
    "now let @xmath864 it is worth stressing that @xmath865 is a set of sample paths and associated scaling parameters , not a probabilistic event , and so any questions about the lack of independence between @xmath866 and @xmath867 are void .",
    "note also that although the events @xmath829 lie in different probability spaces for each @xmath130 , this has no bearing on the definition of @xmath216 nor on the application of theorem  [ thm : fluid ] .",
    "we next show that @xmath216 satisfies conditions ( [ eq : fluid.scale])([eq : fluid.qbound ] ) of theorem [ thm : fluid ] , for  @xmath146 sufficiently large . equation ( [ eq : fluid.scale ] ) follows straightforwardly from the fact that @xmath868 , hence @xmath869 , hence @xmath870 . for  ( [ eq : fluid.arr ] ) , later in the proof we will establish that , under @xmath829 for @xmath130 large enough , @xmath871 } }    < \\eta_r\\biggl(1+\\frac{1}{\\log r}\\biggr)\\qquad \\mbox{for all } 0\\leq m\\leq\\lfloor rt \\rfloor,\\ ] ] which implies that for all @xmath872 , @xmath873 } } |{\\tilde{\\mathbf{a}}}^j(t)-{\\bolds{\\lambda}}^j t|<\\varepsilon_j$ ] as required .",
    "equation ( [ eq : fluid.qbound ] ) follows straightforwardly from the scaling used to define @xmath874 : for every @xmath875 , not merely @xmath831 , @xmath876    since @xmath216 satisfies the conditions of theorem [ thm : fluid ] for sufficiently large @xmath146 , we can apply that theorem to deduce @xmath877 rewriting @xmath146 as @xmath878 , and turning the limit statement into a @xmath879 statement , @xmath880 and in particular @xmath881 rewriting @xmath882 in terms of @xmath831 , as per the definition of @xmath883 , @xmath884 interchanging the @xmath885 and the @xmath886 gives ( [ eq : ht.fms.1 ] ) .    to establish ( [ eq : ht.fms.2 ] ) , we will again apply theorem [ thm : fluid ] but this time using the index @xmath887 , @xmath862 and @xmath888 as above , and define @xmath889 equations ( [ cond.rateconv])([eq:fluid.qbound ] ) hold just as before . for ( [ eq : fluid.initq ] )",
    ", we will use @xmath890 as in the statement of this lemma , and @xmath891 .",
    "this is a well - defined constant ( i.e. , it does not depend on the randomness @xmath875 ) , because we assumed in theorem [ thm : heavytraffic ] that the initial queue sizes @xmath892 are nonrandom , and by definition @xmath893 .",
    "furthermore , theorem [ thm : heavytraffic ] assumes @xmath894 , which implies @xmath895 hence @xmath215 .",
    "equation ( [ eq : fluid.initq ] ) then follows straightforwardly , for every @xmath875 not merely @xmath831 .",
    "applying theorem  [ thm : fluid ] , we deduce that @xmath896 equivalently , @xmath897 as required .    to complete the proof of lemma [ lem : ht.fms ] ,",
    "the only remaining claim that needs to be established is ( [ eq : ht.fms.arr ] ) .",
    "we will proceed in two steps .",
    "first we prove that @xmath898 under @xmath829 , for @xmath130 sufficiently large and for all @xmath834 .",
    "to see this , note from ( [ eq : multihop.discrete.queue.bound ] ) that @xmath899 now @xmath829 gives a suitable bound on arrivals : for all @xmath900 , and using the fact that @xmath901 , @xmath902 to @xmath903 we find @xmath904 .",
    "the assumptions of theorem [ thm : heavytraffic ] tell us that @xmath905 for some @xmath906 .",
    "putting all this together , we find that for sufficiently large @xmath130 @xmath907 now we proceed to prove ( [ eq : ht.fms.arr ] ) , under @xmath829 for @xmath130 sufficiently large .",
    "observe that ( for @xmath908 ) there exists @xmath909 such that @xmath910 ; this follows from @xmath911 and the definition of @xmath912 in  ( [ eq : ht.good ] ) .",
    "hence for any @xmath913 $ ] , @xmath914 & & \\qquad= \\biggl|\\frac{{\\mathbf{a}}^r(rm+z_{r , m}t)-{\\mathbf{a}}^r(rm)}{z_{r , m } } - { \\bolds{\\lambda}}^rt\\biggr|\\\\[-2pt ] & & \\qquad= \\biggl|\\frac{{\\mathbf{a}}^r(rm+w_{r , k}u)-{\\mathbf{a}}^r(rm)}{w_{r , k } } - { \\bolds{\\lambda}}^ru\\biggr| \\biggl(\\frac{w_{r , k}}{z_{r , m}}\\biggr ) \\qquad\\mbox{where $ u = t z_{r , m}/w_{r , k}$}\\\\[-2pt ] & & \\qquad=    { w_{r , k}}{z_{r , m}}\\biggr)\\\\[-2pt ] & & \\qquad < \\eta_r \\frac{w_{r , k}}{z_{r , m } } \\qquad\\mbox{since $ { \\hat{e}}_r$ holds and $ u\\leq t\\leq{t^{\\mathrm{fluid}}}$}\\\\[-2pt ] & & \\qquad\\leq \\eta_r \\frac{w_{r , k}}{w_{r , k-1 } } \\qquad\\mbox{since $ z_{r , m}\\geq w_{r , k-1}$}\\\\[-2pt ] & & \\qquad= \\eta_r \\biggl(1+\\frac{1}{k-1+\\log r}\\biggr ) \\leq",
    "\\eta_r\\biggl(1+\\frac{1}{\\log r}\\biggr).\\end{aligned}\\ ] ] this establishes ( [ eq : ht.fms.arr ] ) and completes the proof .    [ lem : ht.m ] given @xmath157 $ ] and @xmath125 , define @xmath915 and @xmath916 by @xmath917 this is a sound definition ( i.e. , the set for @xmath918 is nonempty ) .",
    "further , under event  @xmath829 , either @xmath919 and @xmath920 , or @xmath921 and @xmath922 .",
    "the set for @xmath918 is nonempty because @xmath868 and @xmath923 .",
    "the upper bound for @xmath918 is trivial .",
    "the upper bound for @xmath924 in either case is trivial . to prove the lower bound for @xmath924 when @xmath925 , @xmath926 due to the minimality of @xmath918 .",
    "hence @xmath927 to bound @xmath928 , we can use ( [ eq : multihop.discrete.queue.bound ] ) and the bound on @xmath929 provided by @xmath829 to show that for any @xmath76 @xmath930 & \\leq & \\bigl ( |{\\mathbf{q}}^r(rm - r)| + r(\\lambda^{\\max}+\\eta_r+n s^{\\max } ) \\bigr){\\vee}r\\\\[-2pt ] & \\leq &    s^{\\max } ) \\qquad\\mbox{since $ \\eta_r\\leq1$}\\\\[-2pt ] & \\leq & z_{r , m-1 } ( 2+\\lambda^{\\max}+n s^{\\max } ) \\qquad\\mbox{since $ z_{r , m-1}\\geq r$}.\\end{aligned}\\ ] ] substituting this back into the earlier bound for @xmath924 , @xmath931 and this is equal to @xmath845 by choice of @xmath932 .    [",
    "lem : ssc.pathwise ] let , @xmath157 $ ] and @xmath125 be given .",
    "suppose there exist @xmath933 , @xmath934 $ ] and @xmath935 such that @xmath936 and @xmath937 , and furthermore either @xmath938 and @xmath939 and @xmath940 , or @xmath941 and @xmath942 where @xmath943 is as defined in lemma [ lem : ht.fms ] .",
    "then @xmath944 where @xmath945 is the modulus of continuity of the map @xmath946 over @xmath947 for @xmath454 as in definition [ def : lyapunov ] .",
    "the first inequality is trivially true because @xmath948 } { \\hat{\\mathbf{q}}}^r(u)\\bigr ) { \\vee}1.\\ ] ] for the second inequality , note that after unwrapping the @xmath949 scaling and wrapping it up again in the @xmath950 scaling , the middle term in ( [ eq : ht.pathwise ] ) is latexmath:[\\[\\mbox{mt}=    writing @xmath158 for the queue component of @xmath14 , @xmath952 we can bound each term as follows :    @xmath953 \\begin{tabular}{p{317pt } } is $ < \\zeta$ in the case $ m>0 $ : by the assumptions of the lemma , $ x\\in{\\operatorname{fms}}_1 $ so $ |\\mathbf{q}(0)|\\leq1 $ , and also $ u > h_\\zeta$. the requirements of theorem~\\ref{thm : fp}(v ) are met ; hence we obtain the inequality .",
    "\\end{tabular}\\hspace*{-42pt}\\nonumber\\\\ \\begin{tabular}{p{317pt } } is $ = 0 $ in the case $ m^*=0 $ : in this case , by assumption of the lemma $ x\\in{\\operatorname{fms}}(\\mathbf{q}_0)$ , that is , $ \\mathbf{q}(0)=\\mathbf{q}_0$. by assumption of theorem \\ref { thm : heavytraffic } $ { \\hat{\\mathbf{q}}}_0\\in{\\mathcal{i}}$ , that is , $ { \\hat{\\mathbf{q}}}_0={\\delta}{w}({\\hat{\\mathbf{q}}}_0)$ , therefore by theorem \\ref{thm : fp}(iii ) $ \\mathbf{q}_0\\in { \\mathcal{i}}$ , therefore by theorem \\ref{thm : fp}(iv ) the fluid model solution $ \\mathbf{q}(\\cdot)$ stays constant at $ \\mathbf{q}_0 $ and so $ \\mbox{(\\ref{equ52b})}=0$. \\end{tabular}\\nonumber \\hspace*{-42pt } \\\\ \\label{equ52c } \\\\[-18pt ] \\begin{tabular}{p{317pt } } is $ \\leq{\\operatorname{mc}}_\\zeta({\\delta}{w})$ : by assumption of the lemma , either $ m>0 $ and $ x\\in{\\operatorname{fms}}_1 $ , or $ m=0 $ and $ x\\in{\\operatorname{fms}}(\\mathbf{q}_0)$ where $ \\mathbf{q}_0\\leq{\\mathbf{1}}$ componentwise ; either way $ \\mathbf{q}(0)\\leq{\\mathbf{1}}$ componentwise , so $ l(\\mathbf { q}(0))\\leq l({\\mathbf{1}})$. by theorem \\ref{thm : fp}(i ) $ l(\\mathbf{q}(u))\\leq l({\\mathbf{1}})$",
    "so $ \\mathbf{q}(u)\\in{\\mathcal{d}}$. furthermore , since $ \\|{\\tilde{x}}^{r , m}-x\\|<\\zeta$ by assumption of the lemma , $ |{\\tilde{\\mathbf{q}}}^{r , m}(u)-\\mathbf{q}(u)|<\\zeta<1 $ and so $ { \\tilde{\\mathbf{q}}}^{r , m}(u)\\in{\\mathcal{d}}$. the inequality then follows from the definition of the modulus of continuity .",
    "\\end{tabular}\\nonumber \\hspace*{-42pt}\\end{aligned}\\ ] ]    [ lem : ht.prob ] under the assumptions of theorem [ thm : heavytraffic ] , @xmath830 as @xmath127 .",
    "the deviation terms are given by @xmath954 and @xmath849 as @xmath127 .    by a simple union bound , and then using the fact that the arrival process has stationary increments , @xmath955 } } | { \\tilde{\\mathbf{a}}}^{r , m , w_{r , k}}(u ) - { \\bolds{\\lambda}}^r u| \\geq\\eta_r\\bigr)\\\\[-2pt ] & = & 1 - ( 1+\\lfloor rt\\rfloor ) \\sum_{k=0}^{\\lfloor lr\\log r\\rfloor } { \\mathbb{p}}\\bigl ( { \\sup_{u\\in[0,{t^{\\mathrm{fluid } } } ] } } | { \\tilde{\\mathbf{a}}}^{r,0,w_{r , k}}(u ) - { \\bolds{\\lambda}}^r u| \\geq\\eta_r\\bigr)\\\\[-2pt ] & = & 1 - ( 1+rt ) \\sum_{k=0}^{\\lfloor lr\\log r\\rfloor } { \\mathbb{p}}\\biggl ( \\sup_{u\\in[0,{t^{\\mathrm{fluid } } } ] } \\biggl| \\frac{a^r(w_{r , k}u)}{w_{r , k } } - { \\bolds{\\lambda}}^r u\\biggr| \\geq\\eta _ r\\biggr).\\end{aligned}\\ ] ] to bound this we will use assumption [ cond : mssc.stoch ] , which says that @xmath956 uniformly in @xmath130 . after extending the domain of @xmath131 to @xmath163 by linear interpolation in each interval @xmath194 , and extending the domain of @xmath957 to @xmath958 by @xmath959 , and rescaling @xmath210 by @xmath932 , @xmath960 } \\biggl| \\frac{{\\mathbf{a}}^r(zu)}{z } - { \\bolds{\\lambda}}^ru\\biggr| \\geq{t^{\\mathrm{fluid}}}\\delta(z { t^{\\mathrm{fluid } } } ) \\biggr ) { \\to}0 \\qquad\\mbox{as $ z{\\to}\\infty$}\\ ] ] uniformly in @xmath130 .",
    "in other words , for any @xmath961 there exists @xmath962 such that for all @xmath963 and all @xmath130 , @xmath964 } \\biggl| \\frac{{\\mathbf{a}}^r(zu)}{z } - { \\bolds{\\lambda}}^ru\\biggr| \\geq{t^{\\mathrm{fluid}}}\\delta(z { t^{\\mathrm{fluid } } } ) \\biggr ) < \\frac{\\phi}{z(\\log z)^2}.\\ ] ] now pick @xmath965 sufficiently large that @xmath966 and @xmath967 , which we can do since @xmath968 as @xmath137 by assumption [ cond : mssc.stoch ] .",
    "this choice implies that for any @xmath969 and @xmath835 , @xmath970 [ recall that @xmath971 .",
    "hence , for any @xmath969 and @xmath835 , @xmath964 } \\biggl| \\frac{{\\mathbf{a}}^r(zu)}{z } - { \\bolds{\\lambda}}^ru\\biggr| \\geq\\eta_r \\biggr ) < \\frac{\\phi}{z(\\log z)^2}.\\ ] ] applying this bound to @xmath972 , and using the facts that @xmath973 and@xmath974 , @xmath975 & = & \\phi\\biggl(\\frac{1+\\lfloor rt\\rfloor}{r\\log r}\\biggr ) \\sum _ { k=0}^{\\lfloor lr\\log r\\rfloor}\\frac{1}{k+\\log r}\\\\[-2pt ] & \\leq & \\phi\\biggl(\\frac{1+\\lfloor rt\\rfloor}{r\\log r}\\biggr ) \\int_{\\ell=0}^{\\lfloor lr\\log r\\rfloor } \\frac{1}{\\ell-1+\\log r}\\ , d\\ell \\\\ & = & \\phi\\biggl ( \\frac{1+\\lfloor rt\\rfloor}{r\\log r}\\biggr ) \\log\\biggl(1+\\frac{\\lfloor lr\\log r\\rfloor}{\\log r-1}\\biggr).\\end{aligned}\\ ] ] the final expression converges to @xmath976 as @xmath127 . since",
    "@xmath977 can be chosen arbitrarily small , @xmath830 as @xmath127 .      given @xmath222 ,",
    "pick @xmath844 such that @xmath978 where @xmath945 is the modulus of continuity of @xmath807 over the set @xmath655 specified in lemma [ lem : ssc.pathwise ] .",
    "we can achieve the desired bound by making @xmath979 sufficiently small ; this is because @xmath807 is continuous , hence uniformly continuous on compact sets , and @xmath655 is compact as a consequence of theorem [ thm : fp](i ) , hence @xmath980 as @xmath981 . with this choice of @xmath979 ,",
    "define the good sets @xmath829 and the constants @xmath932 and @xmath845 as specified by ( [ eq : ht.good ] ) .    by lemma [ lem : ht.fms ]",
    ", there exists @xmath965 such that for @xmath982 and for all @xmath831 and all @xmath76 , @xmath983 and @xmath984 , where @xmath943 is defined in the statement of the lemma .",
    "now , pick any @xmath913 $ ] and @xmath969 , and assume @xmath829 holds .",
    "lemma  [ lem : ht.m ] says that we can choose @xmath933 and @xmath985 $ ] such that @xmath936 , and furthermore either ( i ) @xmath938 and @xmath939 or ( ii ) @xmath941 . by lemma  [ lem : ht.fms ]",
    ", we can pick @xmath935 ( depending on @xmath130 , @xmath175 and the @xmath875 ) such that @xmath937 and furthermore either ( i ) @xmath938 and @xmath940 or ( ii ) @xmath941 and @xmath942 . then , by lemma [ lem : ssc.pathwise ] , @xmath986 this bound holds for every @xmath157 $ ] and @xmath969 , in a sample path - wise sense , whenever @xmath831 .",
    "finally , lemma [ lem : ht.prob ] says that @xmath830 .",
    "this completes the proof .",
    "our motivation for this work was conjecture [ conj : keslassy ] , which says that for an input - queued switch the performance of mw-@xmath95 improves as @xmath988 .",
    "we have not been able to prove this .",
    "however , under a  condition on the arrival rate , we can show ( i ) that the critically - loaded fluid model solutions for a single - hop switched network approach optimal ( in the sense of minimizing total amount of work in the network ) as @xmath988 ; and ( ii ) that for an input - queued switch the set of invariant states @xmath989 defined in section [ sec : ht ] is sensitive to @xmath95 .",
    "we speculate that these findings might eventually form part of a proof of a heavy traffic limit theorem supporting conjecture  [ conj : keslassy ] , given that critically loaded fluid models and invariant states play an important role in heavy traffic theorems .    in this section we state the condition on the arrival rates , and give the results ( i ) and ( ii ) .",
    "motivated by these results , we make a conjecture about an optimal scheduling policy .",
    "consider a switched network with arrival rate vector @xmath120 .",
    "say that @xmath120 satisfies the _ complete loading condition _",
    "if @xmath385 , and there is a convex combination of critically loaded virtual resources that gives equal weight to each queue ; in other words if @xmath990    [ thm : opt.dynamic ] consider a single - hop switched network with arrival rate vector @xmath385 .",
    "for any fluid model solution for the mw-@xmath95 policy , @xmath991 .    for any fluid model solution for any scheduling policy ,",
    "if @xmath120 satisfies the complete loading condition , then @xmath992 .",
    "the first claim relies on the standard result that for any @xmath993 and @xmath994 , @xmath995 using the lyapunov function from definition [ def : lyapunov ] , @xmath996 the second claim is a simple consequence of lemma [ lem : feasible ] .",
    "( this lemma is for a single - hop network .",
    "the multi - hop version , lemma [ lem : multihop.feasible ] , does not have such a simple interpretation . )",
    "[ thm : mwma ] consider an @xmath997 input - queued switch running mw-@xmath95 , as introduced in section [ ssec : iq ] .",
    "let @xmath998 be the arrival rate at the queue at input port @xmath145 of packets destined for output port @xmath146 , @xmath999 .",
    "suppose that @xmath1000 componentwise , and furthermore that every input port and every output port is critically loaded , that is , @xmath1001 then @xmath120 satisfies the complete loading condition , and the critically loaded virtual resources are @xmath1002 where @xmath1003 and @xmath1004 are the row and column indicator matrices , @xmath1005 and @xmath1006 .",
    "define the workload map @xmath1007 by @xmath1008_{{{\\bolds{\\xi}}}\\in{\\xi}({\\bolds{\\lambda}})}$ ] . denoting the invariant set by @xmath1009 :",
    "if @xmath511 is in the relative interior of @xmath1010 , then @xmath511 is in @xmath1011 for sufficiently small @xmath94 ;    for a @xmath1012 input - queued switch , @xmath1013 is strictly increasing as @xmath988 .    item ( i ) essentially says that @xmath1014 becomes as large as possible as @xmath988 , except for some possible issues at the boundary .",
    "we have only been able to prove ( ii ) for a @xmath1012 switch , but we believe it holds for any @xmath997 switch .",
    "the proofs are rather long , and depend on the specific structure of the input - queued switch , so they are left to the .",
    "conjecture [ conj : keslassy ] claims that , for an input - queued switch , performance improves as @xmath988 .",
    "examples due to ji , athanasopoulou and srikant @xcite and stolyar ( personal communication ) show that this is not true for general switched networks .",
    "however , theorem [ thm : opt.dynamic ] suggests that the conjecture might apply not just to input - queued switches but also to generalized switches under the complete loading condition ; the examples of ji , athanasopoulou and srikant @xcite and stolyar do not satisfy this condition .",
    "we therefore extend conjecture [ conj : keslassy ] as follows .",
    "consider a general single - hop switched network as described in section [ sec : model ] , running mw-@xmath95 .",
    "consider the diffusion scaling limit ( described in conjecture [ conj : heavytraffic.ssc ] ) , and let @xmath120 be the limiting arrival rates ; assume  @xmath120 satisfies the complete loading condition .",
    "for every @xmath94 there is a  limiting stationary queue size distribution .",
    "the expected value of the sum of queue sizes under this distribution is nonincreasing as @xmath988 .",
    "theorem [ thm : opt.dynamic ] says that mw-@xmath95 approaches optimal as @xmath988 , under the complete loading condition .",
    "it is natural to ask if there is a policy that is optimal , rather than just a sequence of policies that approach optimal . given that mw-@xmath95 chooses a schedule @xmath72 to maximize @xmath1015 ( where the exponent is taken componentwise ) , and since @xmath1016 we propose the following formal limit policy , which we call msmw - log : _ at each time step _ , _ look at all maximum - size schedules _ , _ that is _ , _ those @xmath63 for which @xmath1017 is maximal . among these _ ,",
    "_ pick one which has maximal log - weight _ , _ that is _",
    ", _ for which @xmath1018 is maximal _ , _ breaking ties randomly . _",
    "[ conj : sw ] consider a general single - hop switched network running msmw - log .",
    "consider the diffusion scaling limit , and let @xmath120 be the limiting arrival rates ; assume @xmath120 satisfies the complete loading condition .",
    "there is a limiting stationary queue size distribution .",
    "this distribution minimizes the expected value of the sum of the queue sizes , over all scheduling policies for which this expected value is defined .",
    "scheduling policies based on mw are computationally difficult to implement because there are so many comparisons to be made . in future work",
    "we plan to investigate whether the techniques described in this paper can be applied to policies that may have worse performance but simpler implementation .",
    "in this section we prove theorem [ thm : mwma ] . throughout this appendix",
    "we are considering a @xmath997 input - queued switch .",
    "the set of schedules @xmath64 consists of all @xmath997 permutation matrices .",
    "we assume the arrival rate matrix @xmath120 satisfies the complete loading condition ( [ eq : iq.completeload ] ) and that @xmath1000 componentwise .",
    "we let the scheduling algorithm be mw-@xmath95 , and define @xmath1009 to be the set of invariant states .",
    "the birkhoff ",
    "von neumann decomposition result says that a matrix is doubly substochastic if and only if it is less than or equal to a convex combination of permutation matrices , which yields @xmath1019^{m\\times m } \\dvtx \\sum_{j=1}^m \\lambda_{{{\\hat{\\imath}}},j}\\leq1 \\mbox { and } \\sum_{i=1}^m \\lambda_{i,{{\\hat{\\jmath}}}}\\leq1 \\mbox { for all $ { { \\hat{\\imath } } } , { { \\hat{\\jmath}}}$ } \\biggr\\}.\\ ] ] since @xmath120 satisfies the complete loading condition ( [ eq : iq.completeload ] ) , @xmath385 .",
    "lemma [ lem : iq.vr ] below gives @xmath426 , the set of virtual resources , that is , maximal extreme points of the set of feasible solutions to @xmath365 . from the complete loading condition ,",
    "it is clear that @xmath1020 as claimed in the theorem .",
    "it will also be useful , for the proof of theorem [ thm : mwma](i ) , to identify @xmath498 as defined by ( [ eq : clvrplus ] ) .",
    "we claim that @xmath1021 to see this , suppose @xmath468 is a nonmaximal extreme point of the set of feasible solutions to @xmath365 ; then there exists some other extreme point @xmath565 such that @xmath470 and @xmath1022 ; but because @xmath1000 componentwise it must be that @xmath1023 .",
    "we have found that @xmath385 , so the solution to @xmath365 is @xmath559 , hence @xmath1024 .",
    "therefore @xmath1025 , that is , @xmath498 consists only of maximal extreme points .",
    "[ lem : iq.vr ] the set of maximal extreme points of the set @xmath1026 is given by @xmath1027 where the row and column indicator matrices @xmath1003 and @xmath1004 are defined by @xmath1005 and @xmath1006 .",
    "first we argue that every @xmath439 is a maximal extreme point of  @xmath380 .",
    "it is simple to check that @xmath1028 .",
    "also , @xmath468 is extreme because @xmath1029^{m\\times m}$ ] .",
    "finally , @xmath468 is maximal because if it were not then there would be some @xmath1030 , @xmath1031 , such that @xmath1032 ; but for any such @xmath1033 there is a  matching  @xmath72 such that @xmath1034 hence @xmath1035 .",
    "next we argue the converse , that all maximal extreme points of @xmath380 are in @xmath426 .",
    "the first step is to characterize the extreme points of @xmath380 .",
    "we claim that if @xmath1036 , then it can be written @xmath1037 for some @xmath1038 .",
    "consider the optimization problem @xmath1039\\\\[-10pt ] & & \\mbox{such that } { { \\bolds{\\zeta}}}\\leq\\sum_{{\\hat{\\imath}}}x_{{\\hat{\\imath}}}{\\mathbf{r}}_{{\\hat{\\imath}}}+ \\sum_{{\\hat{\\jmath}}}y_{{\\hat{\\jmath}}}{\\mathbf{c}}_{{\\hat{\\jmath}}}.\\nonumber\\end{aligned}\\ ] ] the dual of this problem is @xmath1040\\\\[-8pt ] & & \\mbox{such that } \\mathbf{a}{\\cdot}{\\mathbf{r}}_{{\\hat{\\imath}}}\\leq1,\\qquad",
    "\\mathbf{a}{\\cdot}{\\mathbf{c}}_{{\\hat{\\jmath}}}\\leq1\\qquad \\mbox{for all } { { \\hat{\\imath}}},{{\\hat{\\jmath}}}.\\nonumber\\end{aligned}\\ ] ] [ these problems are just @xmath1041 and @xmath1042 , resp . , but with respect to the `` virtual '' schedule set @xmath426 rather than the actual schedule set @xmath64 . ]",
    "by slater s condition , strong duality holds .",
    "now , any matrix @xmath159 that is feasible for ( [ eq : iqd.dual ] ) is nonnegative and doubly substochastic , hence by the birkhoff ",
    "von neumann decomposition result it can be written as a @xmath1043 where @xmath1044 is a  convex combination of permutation matrices , that is , @xmath1045 .",
    "but by the assumption that @xmath1036 , @xmath1046 for all @xmath63 , hence @xmath1047 , hence @xmath1048 , so the value of the optimization problem ( [ eq : iqd.dual ] ) is @xmath559 . by strong duality , the value of the optimization problem ( [ eq : iqd.primal ] ) is also @xmath559 .",
    "therefore @xmath1037 for some @xmath1049 .",
    "we now claim that if @xmath1036 then it can be written @xmath1050 where the sum is over some finite collection of values drawn from the set @xmath1051 and all @xmath1052 are @xmath1053 .",
    "we have just shown that @xmath1054 if @xmath1055 we are done .",
    "otherwise , pick some @xmath1056 such that @xmath1057 and define  @xmath1058 by @xmath1059 . noting that @xmath1060 , we can rewrite @xmath565 as @xmath1061 where matrix multiplication is componentwise as per the notation specified in section [ sec : intro ] .",
    "we have thus rewritten @xmath565 in the form ( [ eq : iq.induction ] ) , but now @xmath1062 has one fewer nonzero element . continuing in this way",
    "we can remove all nonzero elements of @xmath1062 , until we are left with @xmath1063 .",
    "we have therefore shown that all extreme points of @xmath380 are in @xmath243 .",
    "clearly , all maximal points of @xmath243 are in @xmath426",
    ". therefore , all the maximal extreme points of @xmath380 are in @xmath426 as claimed .",
    "we first state two lemmas which will be needed in the proof .",
    "the first is a general closure property of permutation matrices , and the second is a property of invariant states of mw-@xmath95 .",
    "we then prove the theorem and the two lemmas .",
    "[ lem : mwm.closure ] let @xmath1064 , and define @xmath1065 by @xmath1066 if there is some matching @xmath118 whose weight @xmath1067 is maximal ( i.e. , @xmath1068 ) and for which @xmath1069 ; and @xmath1070 otherwise . then , for any matching @xmath72 such that @xmath1071 @xmath72 is itself a maximum weight matching .",
    "[ lem : mwm.sameweight ] fix any @xmath385 , and any @xmath1072 . for every @xmath1073 such that @xmath1074 , there exists a matching @xmath63 whose weight @xmath1075 is maximal ( i.e. , @xmath1076 , where the exponent is taken componentwise ) and for which @xmath152 .",
    "proof of theorem [ thm : mwma ] suppose the claim of the theorem is not true , that is , that there exists a sequence @xmath988 such that @xmath1077 for each @xmath95 in the sequence .",
    "write @xmath1078 , and define the function @xmath1079 to give the ( unique ) solution to the optimization problem @xmath1080 this is the optimization problem defined in ( [ eq : liftwplus ] ) ; we have simply written out @xmath498 explicitly using ( [ eq : mwma.clvrp ] ) . by lemma [ lem : liftwplus ] ,",
    "the map @xmath1081 that defines @xmath1009 is simply the composition of @xmath1007 and @xmath1082 .",
    "let @xmath1083 .",
    "note that @xmath1084 ; this is because @xmath1085 is optimal for @xmath1086 , therefore it is optimal for @xmath1087 which has a smaller feasible region , therefore @xmath1088 , that is , @xmath1084 .",
    "we next establish this claim : that _ for each @xmath95 in the sequence _",
    ", _ there exists _",
    "@xmath145 , @xmath146 , @xmath1089 _ and _ @xmath1090 _ such that _ @xmath1091 , @xmath1092 _ and _ @xmath1093 .",
    "to prove this claim , observe that @xmath1094 by the constraints of the optimization problem @xmath1095 ; and that @xmath1084 hence @xmath1096 ; hence @xmath1097 by assumption that @xmath1098",
    ". therefore @xmath1099 in some component , that is , there is some @xmath145 or @xmath146 such that @xmath1100 or @xmath1101 .",
    "indeed , there must be both such an @xmath145 and @xmath146 , since otherwise the sum of row workloads and column workloads would not be equal .",
    "therefore @xmath1091 , since if @xmath1102 , then we could reduce @xmath1103 and still have a feasible solution to the problem that defines @xmath1086 but with a smaller value of the objective function , which contradicts optimality of @xmath1085 .",
    "there must also be a @xmath1090 such that @xmath1093 since otherwise the workload constraint @xmath1104 would not be met .",
    "likewise for @xmath1089 .",
    "we assumed that @xmath1105 is in the relative interior of @xmath1106 .",
    "this set is clearly convex , and from the characterization of relative interior for convex sets , for all @xmath1107 there exists @xmath1108 and @xmath1109 such that @xmath1110 . in particular , by choosing @xmath1111 , we find that @xmath1112 componentwise .    for each @xmath95 in the sequence we can find indices @xmath1113 as above .",
    "some set of indices @xmath1114 must be repeated infinitely often , since there are only finitely many choices .",
    "restrict attention to the subsequence of @xmath95 for which @xmath1115 , @xmath1116 , @xmath1117 , @xmath1118 .",
    "now , consider the submatrix @xmath1119 recall that @xmath1084 . by lemma [ lem : mwm.sameweight ] , and the assumption that @xmath1000 componentwise , every queue is involved in some maximum weight matching . by lemma  [ lem : mwm.closure ] , every matching is a maximum weight matching .",
    "let @xmath72 be any matching with @xmath1120 , and let @xmath1121 be like @xmath72 except with @xmath1122 and @xmath1123 flipped , that is , @xmath1124 and @xmath1125 .",
    "we can write out explicitly the difference in weight between these two matchings @xmath1126 here , @xmath1127 denotes component - wise exponentiation .",
    "recall that along the subsequence we have chosen , @xmath1091 , @xmath1093 and @xmath1092 .",
    "therefore @xmath1128 .",
    "this contradicts the finding that every matching is a maximum weight matching for @xmath1085 .",
    "thus , we have contradicted our original assumption that there exists a  sequence @xmath988 with @xmath1129 .",
    "this completes the proof .",
    "proof of lemma [ lem : mwm.closure ] let @xmath1130 be the weight of the maximum weight matching , let @xmath1131 and let @xmath1132 .",
    "observe that @xmath1133 and @xmath1134 .",
    "therefore , @xmath1135 componentwise .",
    "further , by definition @xmath1136 .",
    "therefore , the matrix @xmath1137 is nonnegative .",
    "since  @xmath592 is sum of @xmath1138 permutation matrices , all its row sums and column sums are equal to @xmath1138 . and since  @xmath72 is a permutation matrix as well , the matrix  @xmath1137 has all its row sums and column sums equal to @xmath1139 ; therefore by the birkhoff ",
    "von neumann decomposition @xmath1140 where each @xmath1141 and @xmath1142 .",
    "now , @xmath1143 by construction of @xmath592 . therefore @xmath1144 & \\leq & { { \\bolds{\\pi}}}{\\cdot}{\\mathbf{x}}+ ( |{\\mathcal{a}}| - 1 ) a \\qquad\\mbox{because } a=\\max_{{{\\bolds{\\rho}}}\\in{\\mathcal{s}}}{{\\bolds{\\rho}}}{\\cdot}{\\mathbf{x}}.\\vspace*{-2pt}\\end{aligned}\\ ] ] rearranging , @xmath1145 .",
    "but @xmath1146 is the weight of the maximum weight matching , thus @xmath1147 .",
    "proof of lemma [ lem : mwm.sameweight ] since @xmath385 , @xmath416 for some @xmath540 , that is , @xmath1148 where @xmath1149 and each @xmath1150 .",
    "therefore @xmath1151 but by lemma [ lem : fixedpoint](iv ) , @xmath1152 , therefore both the inequalities in the above must be equalities . in particular , all matchings @xmath72 for which @xmath1153 are maximum weight matchings . if @xmath1074 , then at least one of these matchings has @xmath1154 .",
    "consider a @xmath1012 switch with arrival rate matrix @xmath120 . since @xmath120 satisfies ( [ eq : iq.completeload ] ) , we may write @xmath1155 for some @xmath1156 . to find @xmath1009 we use the characterization from lemma  [ lem : fixedpoint](iv ) , which says that @xmath1072 if and only if @xmath1152 , that is , if and only if @xmath1157 now , the equation @xmath1158 is satisfied if and only if @xmath1159 , given @xmath1160 .",
    "therefore @xmath1161 we wish show that @xmath1011 is strictly increasing as @xmath988 , where @xmath1162 .",
    "it suffices to show that @xmath1163 is strictly increasing , where @xmath1164 , since there is a  straightforward bijection between @xmath1165 and @xmath1166 .",
    "now , @xmath1167 is in @xmath1168 iff there exists @xmath1169 such that @xmath1170 that is , iff there exists @xmath376 such that @xmath1171 write @xmath1172 for the left - hand side of ( [ eq : mwma2.balance ] ) . since @xmath1172 is increasing in @xmath14 , there exists a solution to ( [ eq : mwma2.balance ] ) iff @xmath1173 at the lower bound in ( [ eq : mwma2.bounds ] ) and @xmath1174 at the upper bound . by considering four separate cases of which of the bounds in ( [ eq : mwma2.bounds ] ) are tight , and after some algebra , we find that there exists a  solution iff @xmath1175 where @xmath1176 and @xmath1177 .",
    "now , it is a standard inequality that for any @xmath1178 and @xmath1179 , and any @xmath1180 , @xmath1181 applying this inequality to ( [ eq : ssc.w ] ) , it follows that @xmath1168 is strictly increasing as .",
    "we would like to thank mike harrison , frank kelly , balaji prabhakar and ruth williams for helpful discussions .",
    "we thank ciamac moallemi for suggesting lemma [ lem : equiv ] .",
    "we also thank the anonymous reviewers for their help in improving readability of the manuscript ."
  ],
  "abstract_text": [
    "<S> we consider a queueing network in which there are constraints on which queues may be served simultaneously ; such networks may be used to model input - queued switches and wireless networks . </S>",
    "<S> the scheduling policy for such a network specifies which queues to serve at any point in time . </S>",
    "<S> we consider a family of scheduling policies , related to the maximum - weight policy of tassiulas and ephremides [ _ ieee trans . </S>",
    "<S> . control _ </S>",
    "<S> * 37 * ( 1992 ) 19361948 ] , for single - hop and multihop networks . </S>",
    "<S> we specify a fluid model and show that fluid - scaled performance processes can be approximated by fluid model solutions . </S>",
    "<S> we study the behavior of fluid model solutions under critical load , and characterize invariant states as those states which solve a certain network - wide optimization problem . </S>",
    "<S> we use fluid model results to prove multiplicative state space collapse . </S>",
    "<S> a notable feature of our results is that they do not assume complete resource pooling .    and    .    </S>"
  ]
}