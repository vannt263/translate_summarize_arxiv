{
  "article_text": [
    "graph analytics has drawn much attention from research and industry communities , due to the wide applications of graph data in different domains .",
    "one of the major issues in graph analytics is identifying cohesive subgraphs .",
    "there are lots of indexes to depict the cohesiveness of a graph , such as cliques , k - truss , k - core , f - groups , n - clans and so on @xcite , among which @xmath0-core is recognized as one of the most efficient and helpful one . given a graph @xmath1 ,",
    "the @xmath0-core is the largest subgraph in @xmath1 , such that the minimum degree of the subgraph is at least @xmath0 .",
    "the core number of a vertex @xmath2 is defined as the largest @xmath0 such that there exists a @xmath0-core containing @xmath2 . in static graphs ,",
    "the computation of the core number of each vertex is known as the @xmath0-core decomposition problem . besides the analysis of cohesive subgroup ,",
    "@xmath0-core decomposition are widely used in a large number of applications to analyze the structure and function of a network .",
    "for example , the k - core decomposition can be used to analyze the topological structure of internet @xcite , @xcite , to identify influential spreader in complex networks @xcite @xcite , to analyze the structure of large - scale software systems @xcite@xcite@xcite@xcite , to predict the function of biology network @xcite , and to visualize large networks @xcite@xcite and so on .    in static graphs ,",
    "the @xmath0-core decomposition problem has been well studied .",
    "the algorithm presented in @xcite can compute the core number of each vertex in @xmath3 time , where @xmath4 is the number of edges in the graph .",
    "however , in many real - world applications , graphs are subject to continuous changes like insertion or deletion of vertices and edges . in such dynamic graphs ,",
    "many applications require to maintain the core number for every vertex online , given the network changes over time .",
    "but it would be expensive to recompute the core numbers of vertices after every change of the graph , though the computation time is linear , as the size of the graph can be very large .",
    "furthermore , the graph change may only affect the core numbers of a small part of vertices .",
    "hence , the _ core maintenance _ problem  @xcite is recommended , which is to identify the vertices whose core numbers will be definitely changed and then update the core numbers of these vertices .",
    "there are two categories of core maintenance , _ incremental _ and _ decremental _ , which handle edge / vertex insertion and deletion respectively .",
    "previous works focus on maintaining the core numbers of vertices in the scenario that a single edge is inserted or deleted from the graph . for multiple edge",
    "/ vertex insertions / deletions , the inserted / deleted edges are processed sequentially .",
    "the sequential processing approach , on the one hand , incurs extra overheads when multiple edges / vertices are inserted / deleted , as shown in fig .",
    "[ fig1 ] , and on the hand , it does not fully make use of the computation power provided by multicore and distributed systems .",
    "therefore , it is necessary to investigate the parallelism in the edge / vertex processing procedure and devise parallel algorithm that suits to implement in multicore and distributed systems .",
    "but to the best of our knowledge , there are no known parallel algorithms proposed for the core maintenance problem . in the core maintenance problem ,",
    "the insertions / deletions of vertices can be handled by implementing an edge insertion / deletion algorithm .",
    "specifically , inserting a vertex is equivalent to the following process : first inserting the vertex into the graph by setting its core number as 0 , and then inserting the edges connected to the new vertex .",
    "similarly , the deletion of a vertex is equivalent to the process that deleting the edges connected to the vertex and finally deleting the vertex .",
    "hence , in this paper , we only consider the edge insertions and deletions .",
    "it is a very difficult task to design parallel algorithms for core maintenance in dynamic graphs .",
    "different from the single edge insertion / deletion case , where the core number of each vertex changes by at most 1 , it is hard to identify the change of a vertex s core number in the multiple edge insertion / deletion scenario , as the change of a vertex core number may be affected by several inserted edges . an intuitive manner is to split the inserted / deleted edges into sets that affect disjoint sets of vertices in the original graph .",
    "however , the parallelism of this manner is poor . in this work ,",
    "we take a more efficient approach that exhibits better parallelism .",
    "specifically , we propose a structure called _ superior edge set_. the inserted / deleted edges can be split into multiple superior edges sets , and for each vertex connected to inserted / deleted edges , a superior edge set contains at least one inserted edge connected to it .",
    "it is shown that the insertion or deletion of edges in a superior edge set can change the core number of every vertex by at most 1 .",
    "hence , the core numbers of vertices when inserting or deleting a superior edge set can be maintained using a parallel procedure : first identifying the vertices whose core numbers will change due to the insertion or deletion of every edge in parallel , and then updating the core number of these vertices by 1 .",
    "a parallel algorithm can then be obtained by iteratively handling the insertions / deletions of split superior edge sets using the above parallel procedure .    in summary ,",
    "our contributions are summarized as follows .",
    "* we propose a structure called _ superior edge set _ , and show that if the edges of a superior edge set is inserted into / deleted from a graph , the core number of each vertex can change by at most 1 .",
    "it implies that the insertion / deletion of these edges can be processed in parallel .",
    "we also give sufficient conditions for identifying the vertices whose core numbers will change , when inserting / deleting a superior edge set . *",
    "we then present parallel algorithms for incremental and decremental core maintenance respectively .",
    "comparing with sequential algorithms , our algorithms reduce the number of iterations for processing @xmath5 inserted / deleted edges from @xmath5 to the maximum number of edges inserted to each vertex . in large - scale graphs , the acceleration is significant , since each vertex can connect to only a few inserted or deleted edges .",
    "for example , as shown in the experiments , even if inserting @xmath6 edges to the livejournal graph ( refer to table [ table_graph ] in section  [ sec : experiment ] ) , the number of iterations is just 3 in our parallel algorithms , in contrast with @xmath6 ones in sequential processing algorithms .",
    "we also conduct extensive experiments over both real - world and synthetic graphs , to evaluate the efficiency , stability and scalability of our algorithms .",
    "the results show that comparing with sequential processing algorithms , our algorithms significantly speed up core maintenance , especially in cases of large - scale graphs and large amounts of edge insertions / deletions .",
    "[ fig1 ]   and @xmath7 are inserted . *",
    "traversal * algorithm in @xcite processes them one by one .",
    "first for edge @xmath8 , it will visit vertices @xmath9 and update their core numbers . and",
    "then when inserting @xmath7 , it will visit @xmath10 , and update core numbers of @xmath11 .",
    "however in our parallel algorithm , edges @xmath8 and @xmath7 are handled in parallel using two processes . in the process handling @xmath8 ,",
    "the algorithm execution will visit and update @xmath9 , and in another process for @xmath7 , the algorithm will visit and update @xmath11 .",
    "hence , the parallel algorithm avoids duplicate visiting of @xmath12.,title=\"fig:\",width=192 ]    the rest of this paper is organized as follows . in section  [ sec : relate ] , we briefly review closely related works . in section  [ sec : problem ] , the problem definitions are given .",
    "theoretical results supporting the algorithm design are presented in section  [ sec : basis ] .",
    "the incremental and decremental parallel algorithms are proposed in section  [ sec : in ] and section  [ sec : de ] respectively . in section",
    "[ sec : experiment ] , the experiment results are illustrated and analyzed . the whole paper is concluded in section  [ sec : conclusion ] .",
    "in static graphs , the core decomposition problem has been extensively studied .",
    "the state - of - the art algorithm was given in @xcite , the runtime of which is linear in the number of edges . in @xcite ,",
    "an external - memory algorithm was proposed when the graph is too large to hold in memory .",
    "core decomposition in the distributed setting was studied in @xcite .",
    "the above three algorithms were compared in @xcite under the graphchi and webgraph models .",
    "parallel core decomposition was studied in @xcite .",
    "core maintenance in dynamic graphs has also been widely studied .",
    "however , all previous works focus on the case of single edge insertion / deletion , and sequentially handle multiple edge insertions / deletions .",
    "efficient algorithms were proposed in @xcite . in @xcite ,",
    "an algorithm was proposed to improve the i / o efficiency .",
    "furthermore , @xcite and @xcite solved the core maintenance problem in the distributed environment .",
    "we consider an undirected , unweighted simple graph @xmath13 , where @xmath14 is the set of vertices and @xmath15 is the set of edges .",
    "let @xmath16 and @xmath17 .",
    "for a node @xmath18 , the set of its neighbors in @xmath1 is denoted as @xmath19 , i.e. , @xmath20 .",
    "the number of @xmath21 s neighbors in @xmath1 is called the degree of @xmath21 , denoted as @xmath22 .",
    "so @xmath23 .",
    "the maximum and minimum degree of nodes in @xmath1 is denoted as @xmath24 and @xmath25 respectively .",
    "we next give formal definitions for the _ core number _ of a vertex and other related concepts .",
    "given a graph @xmath26 and an integer @xmath0 , the @xmath0-core is a maximal connected subgraph @xmath27 of @xmath1 , where each vertex has at least @xmath0 neighbors in @xmath27 , i.e. , @xmath28 .    given a graph @xmath26 , the core number of a vertex @xmath29 , denoted by @xmath30 , is the the largest @xmath0 , such that there exists a @xmath0-core containing @xmath21 . for simplicity",
    ", we use @xmath31 to denote @xmath30 when the context is clear .",
    "the max - k - core associated with a vertex @xmath21 , denoted by @xmath32 , is the @xmath0-core with @xmath33 .    in this work",
    ", we aim at maintaining the core numbers of vertices in dynamic graphs .",
    "specifically , we define two categories of graph changes : _ incremental _ , where a set of edges @xmath34 are inserted to the original graph , and _ decremental _ , where a set of edges are deleted . based on the above classification , we distinguish the core maintenance problem into two scenarios , as defined below .    given a graph @xmath26 , the incremental core maintenance problem is to update the core numbers of vertices after an incremental change to @xmath1 .    given a graph @xmath26",
    ", the decremental core maintenance problem is to update the core numbers of vertices after a decremental change to @xmath1 .    in this paper , we proposed efficient parallel algorithms for both the incremental and decremental core maintenance problem , which are named the * superiorinsert * and * superiordelete * algorithm .",
    "the main idea of our algorithms is to find the definitely updated vertex set when the graph changes , which was first proposed in @xcite . besides",
    ", our algorithms can deal with both edge and vertex insertions / deletions , this to say , we can deal with the insertion and deletion of an arbitrary new graph @xmath35 .",
    "in this section , we give some theoretical lemmas that constitute the theoretical basis of our algorithms .    at first , we introduce some definitions . given a graph @xmath26 , an edge @xmath36",
    "is called a superior edge for @xmath21 if @xmath37 .",
    "notice that in the definition , we do not require @xmath38 , i.e. , @xmath39 may be an edge that is about to insert to graph @xmath1 .",
    "furthermore , we define the core number of an edge as the smaller one of its endpoints , i.e. , @xmath40 .    an edge set @xmath41 is called an @xmath0-superior edge set , if for each edge @xmath42 , it satisfies :    \\(i ) @xmath43 is a superior edge with core number @xmath0 .",
    "( ii ) if @xmath43 and @xmath44 have an common endpoint @xmath45 , @xmath46 .    in other words , in a @xmath0-superior edge set @xmath47 , each edge is a superior edge for a vertex with core number @xmath0 , and in @xmath47 , each vertex connects to at most one superior edge for it .",
    "the union of several @xmath0-superior edge sets with distinct @xmath0 values is called a _",
    "superior edge set_. it can be known that in a superior edge set , each vertex can still connect to at most one superior edge for it .    in the following , we will first show that when inserting / deleting a superior edge set ( lemma [ them : superioredgesetinsert ] and lemma [ them : superioredgesetdelete ] ) , the core number of every vertex can change by at most 1 , and then give a sufficient condition for identifying vertices whose core numbers change ( lemma [ le : exkpaths ] , lemma [ corollary : csd ] and lemma [ corollary : sd ] ) .",
    "we first prove a result on the core number increase of every vertex when inserting a @xmath0-supeior edge set . for simplicity",
    ", we use @xmath31 to denote @xmath30 when the context is clear .",
    "[ lem : k - superioredgesetinsert ] given a graph @xmath26 , if a @xmath0-superior edge set @xmath48 is inserted to @xmath1 , where @xmath49 , for each node @xmath2 , it holds that : + @xmath50 if @xmath51 , @xmath52 can increase by at most 1 ; + @xmath53 if @xmath54 , @xmath52 will not change .    for @xmath50 , we need to show that for a vetex @xmath2 with @xmath55 , @xmath52 can increase by at most 1 .",
    "otherwise , assume @xmath52 increases by @xmath56 to @xmath57 , where @xmath58 .",
    "let @xmath59 and @xmath60 be the max-@xmath0-core of @xmath2 before edge insertion and the max-@xmath61-core of @xmath2 after edge insertion respectively .",
    "then , @xmath62 .",
    "it can be concluded that one of inserted edges must belong to @xmath60 , as otherwise @xmath63 before insertion as well .",
    "let @xmath64 . for a vertex @xmath65 ,",
    "if @xmath66 , the degree of @xmath21 does not change when deleting the edges in @xmath47 , so @xmath67 . if @xmath68 , @xmath21 can lose at most one neighbor that is connected by a superior edge for it in @xmath47 , so @xmath69 . if @xmath70 , @xmath21 must have at least @xmath0 + 1 neighbors whose core numbers are not smaller than @xmath0 + 1 in @xmath1 . we add the vertices whose @xmath71 is larger than @xmath0 back to @xmath72 , and denote the induced graph as @xmath73 . it can be obtained that @xmath74 . and",
    "from @xmath1 to @xmath73 , @xmath21 does not lose any neighbor whose @xmath71 is not smaller than @xmath0 + 1 .",
    "hence , in @xmath73 , @xmath75 . then it can be seen that each vertex in @xmath73 has a degree at least @xmath0 + 1 , i.e. , @xmath76 .",
    "this means that @xmath77 , which contradicts with @xmath78 .",
    "hence , @xmath52 can increase by at most 1 .    for @xmath53 , we need to show that for a vertex @xmath2 if @xmath54 , @xmath52 can not change .",
    "we consider two cases : @xmath79 and @xmath80 .",
    "assume @xmath52 = @xmath81 increases by @xmath56 to @xmath82 , where @xmath83 .",
    "let @xmath59 and @xmath60 be the max-@xmath81-core of @xmath2 before edge insertion and the max-@xmath84-core after edge insertion respectively .",
    "then we have @xmath85 , @xmath86 .",
    "we first consider the @xmath87k@xmath88 case .",
    "there must be at least one of the edges @xmath43 in @xmath47 belonging to @xmath60 , as otherwise @xmath89 before edge insertion .",
    "consider the edge @xmath43 .",
    "at least one of its endpoints has a core number @xmath0 , since @xmath47 is a @xmath0-superior edge set .",
    "denote by @xmath45 the endpoint of @xmath43 with core number @xmath0 .",
    "as shown before , @xmath90 can increase by at most 1 .",
    "hence , after the edge insertion , @xmath91 .",
    "this means that @xmath45 is not in @xmath60 , which is a contradiction .",
    "therefore , if @xmath92 , @xmath52 will not change after the edge insertion .",
    "we next consider the @xmath93 case .",
    "similar as beofore , it can be shown that at least one of the edges @xmath94 in @xmath47 that is contained in @xmath60 .",
    "let @xmath64 .",
    "let @xmath21 be a vertex in @xmath72 , we consider three cases . if @xmath68 and as proved before , it can be obtained that @xmath95 .",
    "if @xmath96 , as shown before , the core number of @xmath21 will not be affected by the edge insertions .",
    "if @xmath66 , because @xmath86 , and @xmath21 does not connect to edges in @xmath47 , we can get that @xmath97 .",
    "let @xmath98 .",
    "based on above , it can be obtained that @xmath72 is a @xmath5-core and @xmath99 . but",
    "this contradicts with the fact that @xmath100",
    ". then we can get that the core number of @xmath2 does not change after inserting @xmath47 .    combining all above together",
    ", the lemma is proved .",
    "using a similar argument as that for proving lemma [ lem : k - superioredgesetinsert ] , we can get that the core number changes of vertices after deleting a @xmath0-superior edge set from graph @xmath1 , as given in the following lemma .",
    "[ lem : k - superioredgesetdelete ] given a graph @xmath26 , if a @xmath0-superior edge set @xmath48 is deleted from @xmath1 , where @xmath49 , for each vertex @xmath2 , it holds that : + @xmath50 if @xmath51 , @xmath52 can decrease by at most 1 ; + @xmath53 if @xmath54 , @xmath52 will not change .    from the above lemma [ lem : k - superioredgesetinsert ] and lemma [ lem : k - superioredgesetdelete ] , we have known that for a graph @xmath26 , after a @xmath0-superior edge set @xmath48 is inserted into or deleted from @xmath1 , only vertices with core numbers @xmath0 may increase / decrease , and the change is at most 1 .",
    "this implies that if a @xmath0-superior edge set is inserted / deleted , it will be enough to only visit vertices whose core numbers are @xmath0 and check if their core numbers will be updated . and because the core numbers of these vertices can change by at most 1 , we can handle these edge insertions in parallel : first we find the update set of vertices that will change core numbers because of the insertion of each particular edge in parallel , and the union of these update sets is just the set of vertices whose core numbers will change by one .    in fact , we can get even better results , which are given in the following lemma  [ them : superioredgesetinsert ] and lemma  [ them : superioredgesetdelete ] .",
    "[ them : superioredgesetinsert ] given a graph @xmath26 and a superior edge set @xmath101 , where @xmath102 for @xmath103 is a @xmath104-superior edge set and @xmath105 if @xmath106 , it holds that after inserting @xmath107 into @xmath1 , the core number of each vertex @xmath21 can increase by at most 1 .",
    "it can be seen that inserting edges in @xmath107 into @xmath1 all together has the same result with inserting @xmath102 one by one .",
    "we next assume @xmath102 are inserted one by one . to prove the lemma",
    ", we need to prove that if inserting @xmath102 makes a vertex increase its core number from @xmath104 to @xmath104 + 1 , its core number can not change any more when inserting @xmath108 for @xmath109 .",
    "clearly , we only need to prove the above result for @xmath110 .",
    "there are two cases we need to consider .",
    "if @xmath111 , by lemma  [ lem : k - superioredgesetinsert ] , the core number of @xmath21 will not increase any more when inserting @xmath110 , since only vertices with core numbers of @xmath112 may increase their core numbers .",
    "we next consider the case of @xmath113 .",
    "we claim that if there is a vertex increasing its core number from @xmath104 to @xmath114 after the insertions of @xmath102 and @xmath110 , the vertex must have a neighbor which increases the core number from @xmath104 to @xmath114 as well during the insertions .",
    "let @xmath21 be a vertex whose core number is increased from @xmath104 to @xmath114 after inserting @xmath102 and @xmath110 .",
    "notice that @xmath21 does not connect to edges in @xmath110 .",
    "hence , the degree of @xmath21 does not change when inserting @xmath110 .",
    "furthermore , by lemma  [ lem : k - superioredgesetinsert ] , the core number of each neighbor of @xmath21 can be increased by at most 1 .",
    "so @xmath21 has at least @xmath114 neighbors whose core numbers are not smaller than @xmath115 and some of these neighbors have a core number of @xmath115 .",
    "denote by @xmath116 the vertices in @xmath19 whose core numbers are @xmath115 before inserting @xmath110 .",
    "it can be obtained that there must be a vertex @xmath117 whose core number is @xmath104 before inserting @xmath102 , as otherwise , the core number of @xmath21 is @xmath115 before inserting @xmath102 , which contradicts with our assumption .",
    "let @xmath118 denote the set of vertices whose core numbers change from @xmath104 to @xmath114 after the insertions of @xmath102 and @xmath110 .",
    "because inserting @xmath110 does not change the degrees of vertices in @xmath118 , there must be a vertex @xmath119 whose core number change is caused because of the core number change of vertices in @xmath120 , as otherwise no vertex in @xmath118 can change the core number .",
    "let @xmath121 be a vertex in @xmath120 whose core number change causes the core number change of @xmath122 .",
    "then @xmath123 is @xmath115 before inserting @xmath102 and is increased to @xmath114 after inserting @xmath110 . to make @xmath122 increase its core number to @xmath114 after inserting @xmath110",
    ", there must be at least @xmath114 neighbors in @xmath120 whose core numbers are initially not smaller than @xmath115 before inserting @xmath102 and @xmath110 .",
    "it concludes that @xmath124 before inserting @xmath102 and @xmath110 .",
    "however , this contradicts with the fact that @xmath125 is @xmath104 before insertions .",
    "the contradiction shows that if the core number of a vertex is changed when inserting @xmath102 , its core number will not change any more when inserting @xmath110 .    combining all above together ,",
    "the lemma is prove .",
    "similarly , for the case of a superior edge set deletion , we have the following result .",
    "[ them : superioredgesetdelete ] given a graph @xmath26 and a superior edge set @xmath126 , where @xmath102 for @xmath103 is a @xmath104-superior edge set and @xmath105 if @xmath106 , it holds that after deleting @xmath107 from @xmath1 , the core number of each vertex @xmath21 can decrease by at most 1 .    in above",
    ", we have shown that when inserting or deleting a superior edge set from a graph , the core numbers of vertices can change by at most 1 .",
    "this implies that the core updates of inserting / deleting edges in a superior edge set can be processed in parallel by distributing distinct @xmath0-superior edge sets to distinct processes .",
    "furthermore , we have also shown which set of vertices may change due to the insertion or deletion of a @xmath0-superior edge set .",
    "in the subsequent section , we give more accurate conditions for a vertex to change its core number when inserting / deleting a superior edge set .",
    "we first introduce some notations .",
    "[ de : sd ] for a vertex @xmath21 in a graph @xmath1 , @xmath2 is a _ superior neighbor _ of @xmath21 if the edge @xmath127 is a _ superior edge _ of @xmath21 .",
    "the number of @xmath21 s superior neighbors is called the _ superior degree _ of @xmath21 , denoted as @xmath128 .",
    "it can be known that only superior neighbors of a vertex may affect the change of its core number .",
    "the _ constraint superior degree _",
    "@xmath129 of a vertex @xmath21 is the number of @xmath21 s neighbors @xmath122 that satisfies @xmath130 or @xmath131 .    for a vertex @xmath21 ,",
    "its constraint superior degree @xmath129 is the number of @xmath21 neighbors @xmath122 , that has a larger core number than @xmath21 or has the same core number but has enough neighbors to support itself to increase core number .",
    "[ def : kpt_u ] for a vertex @xmath21 with a core number @xmath31 , the _ @xmath132-path - tree _ of @xmath21 is a dfs tree rooted at @xmath21 and each vertex @xmath122 in the tree satisfies @xmath133 . for simplicity we use @xmath134 to represent k - path - tree of @xmath21 .",
    "the * @xmath134 * includes all vertices @xmath122 with @xmath133 that are reachable from @xmath21 via paths that consists of vertices with core numbers equal to @xmath31 .",
    "when a superior edge of @xmath21 is inserted or deleted , as shown in lemma [ lem : k - superioredgesetinsert ] , only vertices in @xmath134 may change their core numbers . and for the insertion case , a more accurate condition was given in @xcite for identifying the set of vertices that may change core numbers , as shown below .",
    "[ them : kpath ] given a graph @xmath26 , if an edge @xmath127 is inserted and @xmath135 , then only vertices @xmath122 in the * @xmath134 * of @xmath21 and @xmath136 may have their core numbers increased , and the increase is no more than 1 .",
    "however , the above lemma  [ them : kpath ] is just suitable for the one edge insertion scenario .",
    "we next generalize the above result to the scenario of inserting a @xmath0-superior edge set , as shown in lemma  [ them : exk - path ] below , which will help find the set of vertices with core number changes when inserting multiple edges . before giving the result",
    ", we need to generalize the concept of @xmath132-path - tree to @xmath137-path - tree .",
    "[ def : exk - path - tree ] for a @xmath0-superior edge set @xmath47 = \\{@xmath138 } , w.l.o.g . ,",
    "assume that for each @xmath43 = @xmath139 , @xmath140 .",
    "the union of @xmath141 for every @xmath142 is called the _ exk - path - tree _ of @xmath47 . for simplicity",
    "we use @xmath143 to represent exk - path - tree of @xmath47 .    by lemma",
    "[ them : kpath ] , we can get that when inserting a @xmath0-superior edge set @xmath47 , only vertices @xmath122 in the @xmath143 satisfying @xmath144 may have their core numbers change , and lemma [ lem : k - superioredgesetinsert ] ensures that these vertices can change their core numbers by at most 1 .",
    "this result is summarized in the following lemma .",
    "[ them : exk - path ] given a graph @xmath26 , if a @xmath0-superior edge set @xmath47 is inserted , then only vertices @xmath122 in the @xmath143 satisfying @xmath144 may have their core numbers increased , and the core change is at most 1 .",
    "we only prove the insertion case , and the deletion case can be proved similarly .",
    "notice that the core number changes of vertices are the same in scenarios of inserting all edges in @xmath47 together and inserting the edges in @xmath47 one by one .",
    "so we can assume that the edges in @xmath47 are inserted one by one .",
    "by lemma  [ ]    first we should know that , when a @xmath0-superior edge set @xmath47 = \\{@xmath145 , @xmath146 , ... , @xmath147}is inserted / deleted , the vertices who update cores is the same as when inserting / deleting edges in @xmath47 one by one .",
    "assume @xmath148 and core(@xmath149 ) @xmath150 core(@xmath142 ) = @xmath0 , after inserting / deleting @xmath43 into the graph , vertices who update cores construct a vertex set @xmath151 , after inserting / deleting @xmath47 the update vertex set is @xmath152 .",
    "so we can have @xmath152 = @xmath153 and @xmath154 , where @xmath155 , as otherwise a vertex may update its core more than once , which is a contradiction to theorem [ lem : k - superioredgeset ] . and according to theorem [ them : kpath ] , vertices @xmath122 in @xmath151 are all in the * @xmath141 * of @xmath142 and sd(@xmath122 ) @xmath156 core(@xmath21 ) = @xmath0 .",
    "so all vertices @xmath122 in @xmath152 are in the @xmath143 and satisfies sd(@xmath122 ) @xmath157 .",
    "the proof is completed .",
    "the theorem [ them : exk - path ] identifies vertices who may change cores after inserting a @xmath0-superior edge set @xmath47 .",
    "further , for a superior edge set we can similarly have the following theorem .",
    "[ def : superior - tree ] for a superior edge set @xmath158 = @xmath159 , @xmath160 is a @xmath0-superior edge set where @xmath161 .",
    "we denote the union of @xmath143 for all @xmath160 as the * superior - tree * of @xmath158 .",
    "the vertices in the * superior - tree * is denoted as * @xmath162 * , and all neighbors of all vertices in * @xmath162 * is defined as * @xmath163*.    [ them : superior - tree ] given a graph @xmath26 , if a superior edge set @xmath158 is inserted / removed then only vertices @xmath122 in the * superior - tree * and sd(@xmath122 ) @xmath157 where @xmath0 is the @xmath0-superior edge set @xmath122 belongs to , may have their core numbers increased / decreased .",
    "the proof is similarly as theorem [ them : exk - path ] .",
    "since the insertion / deletion of a @xmath0-superior edge set only affects vertices whose core is @xmath0 as proved before , we can insert / delete a @xmath0-superior edge set at a time , the vertices that update core numbers will be exactly the same as inserting / deleting them all at a time .",
    "we denote all vertices update cores upon the insertion / deletion of @xmath158 as @xmath164 . besides as theorem [ them :",
    "superioredgeset ] and theorem [ them : exk - path ] proves , all vertices can only update core number once and all update vertices @xmath122 are in an @xmath143 and satisfies sd(@xmath122 ) @xmath157    the above lemma [ them : exk - path ] implies that after an edge in a @xmath0-superior edge set @xmath47 is inserted , the vertices whose core numbers change during the insertion will not change any more when inserting other edges in @xmath47 . based on the above result and lemma [ them : superioredgesetinsert ] and lemma [ them : superioredgesetdelete ]",
    ", we can get the set of vertices whose core number change when inserting a superior edge set .",
    "[ le : exkpaths ] given a graph @xmath26 , if a superior edge set @xmath165 is inserted , then only vertices @xmath122 in every * * @xmath166**s of every @xmath102 for @xmath103 satisfying @xmath144 may have their core numbers increased , and the core number change can be at most 1 .    by the definition of @xmath167",
    ", we have the following result .",
    "[ corollary : csd ] given a graph @xmath26 and a vertex @xmath21 with core number @xmath0 . after inserting a superior edge set into @xmath1 ,",
    "if @xmath168 , then @xmath21 can not be in a @xmath169-core .",
    "lemma  [ le : exkpaths ] and lemma [ corollary : csd ] give accurate conditions to determine the set of vertices that will change the core numbers , after inserting a superior edge set .    for deletion case , we have the following result , which can be obtained directly from definition [ de : sd ] .",
    "[ corollary : sd ] after deleting an edge set from a graph @xmath26 , for @xmath18 , if @xmath31 = @xmath0 and @xmath170 , then @xmath21 will decrease its core number .    in this section ,",
    "we have given accurate conditions for the core number changes of vertices after inserting / deleting a superior edge set .",
    "in the subsequent section  [ sec : in ] and section  [ sec : de ] , we will show how to utilize these theoretical results to design parallel algorithms for incremental and decremental core maintenance respectively .",
    "in this section , we present how to find a superior edge set given an arbitrary edge set .",
    "the main structure we proposed is called * superior edge set * , in this structure , each vertex has only one neighbor that has a core number no smaller than itself .",
    "as theorem[them : superioredgeset ] proved , when such a structure is inserted into or deleted from a graph , all vertices can change its core number by at most one , which is easy to update . in this subsection ,",
    "we present how to find such a * superior edge set*. since the hierarchy of k - core , the finding process can be executed in parallel .",
    "each child process searches for the * superior edge set * of a given core number @xmath0 and return the * k - superior edge set * to the main process .",
    "[ htb][alg : findksuperioredges ]    * input * + the graph , @xmath26 ; + the update edge set , @xmath34 ; + the vertices set connected to edges in @xmath34 , @xmath171 a core number @xmath0 ; + let @xmath160 be an empty edge set return @xmath160    the algorithm [ alg : findksuperioredges ] finds a superior edge structure for a given @xmath132 in an arbitrary edge set .",
    "the judgement in line 3 ensures that there can be only one superior edge for each vertex in the final result @xmath160 .",
    "in this section , we present the algorithm for incremental core maintenance , whose pseudo - code is given in algorithm  [ alg : superioredgeinsert ] .",
    "we consider the core number update of vertices after inserting a set of edges @xmath34 to graph @xmath26 .",
    "let @xmath171 denote the set of vertices connecting to edges in @xmath34 .",
    "the set of core numbers of vertices in @xmath171 is denoted as @xmath172 .",
    "[ htb][alg : superioredgeinsert ]    * input * + the graph , @xmath26 ; + the inserted edge set , @xmath34 ; + the set of vertices @xmath171 connected to edges in @xmath34 the core number @xmath52 of each vertex in @xmath14 ; +    [ htb][alg : findksuperioredges ]    * input * + the graph , @xmath26 ; + the update edge set , @xmath34 ; + the set of vertices @xmath171 connected to edges in @xmath34 a core number @xmath0 ; + @xmath173 * return * @xmath47    [ htb][alg : insertk ]    * input * + the graph , @xmath26 ; + the @xmath0-superior edge set , @xmath47 ; + the core number @xmath52 of each vertex in @xmath14 * initially * , @xmath174 empty stack for each vertex @xmath175 , @xmath176\\gets{false } , removed[v]\\gets{false } , cd[v]\\gets{0}$ ] compute @xmath177 for each vertex @xmath2 in @xmath143 of @xmath47    * return * @xmath178 ;    [ alg : insertremove ]    @xmath179 @xmath180 @xmath181 \\gets{true}$ ]    the algorithm is executed in iterations . basically , the algorithm split the inserted edges into multiple superior edge sets , and process the insertion of one superior edge set in one iteration . in each iteration , it first uses a parallel algorithm to find a suporior edge set from the inserted edges that have not been processed so far ( line 3 ) .",
    "then a parallel algorithm is executed for each edge in parallel to identify the set of vertices whose core numbers change , and increase the core numbers of these vertices by 1 ( line 6 - 7 ) .",
    "it deserves to point out that we do not use directly algorithms handling single edge insertion / deletion as subroutine .",
    "instead , we make the edges inserted with the same core number processed together , as we find that this can efficiently avioding duplicate visiting of vertices , which further accelerates our parallel processing procedure .",
    "we next introduce the two parts in each iteration respectively .",
    "because the superior edges of vertices with different core numbers are disjoint , the @xmath0-superior edge sets @xmath182 for different core numbers @xmath183 can be computed in parallel using algorithm  [ alg : findksuperioredges ] . then the computed superior edge set is inserted into the graph and deleted from @xmath34 .",
    "the set of vertices with core number changes is also computed in parallel .",
    "specifically , for each @xmath184 , a child process is assigned to find the vertices whose core number changes are caused by the insertion of the computed @xmath0-superior edge set , using algorithm  [ alg : insertk ] .",
    "algorithm [ alg : insertk ] first computes @xmath185 values for each vertex in @xmath143 of @xmath47 , and then for each edge @xmath186 in a @xmath0-superior edge set , finds the set of vertices whose core numbers change due to the insertion of @xmath43 . for @xmath43 , a _ positive _ depth - first - search ( dfs )",
    "is conducted on vertices in @xmath187 from the root vertex @xmath188 , which is one of @xmath142 or @xmath149 that has a core number @xmath0 and @xmath149 have a core number equal to @xmath0 , then @xmath188 can be either @xmath142 or @xmath149 . ] , to explore the set of vertices whose core numbers potentially change . in the algorithm ,",
    "the @xmath189 value of each vertex @xmath2 is used to evaluate the potential of a vertex to increase its core number , which records the dynamic changes of @xmath167 value .",
    "the intial value of @xmath190 is set as @xmath191 . for a vertex @xmath2 , if @xmath192\\le k$ ] , its core number can not increase .",
    "if a vertex @xmath2 with @xmath192\\le k$ ] is traversed in the positive dfs procedure , a _ negative _ dfs procedure initiated from @xmath2 will be started , to remove @xmath2 and update the @xmath189 values of other vertices with core number @xmath0 .",
    "after all vertices in @xmath187 are traversed , the vertices that are visited but not removed will increase the core numbers by 1 .",
    "* performance analysis .",
    "* we next analyze the correctness and efficiency of the proposed incremental algorithm . at first ,",
    "some notations are defined , which will be used in measuring the time complexity of the algorithm .    for graph @xmath26 , the inserted edge set @xmath34 and a subset @xmath193 of @xmath34 ,",
    "let @xmath194 and @xmath195 be the set of core numbers of vertices in @xmath196 .",
    "for @xmath196 , let @xmath197 .",
    "as shown later , @xmath198 is the max times a vertex @xmath21 can be visited by negative dfs procedures in the algorithm execution . for @xmath199 , let @xmath200 be the set of vertices with core number @xmath0 , and @xmath201 be the neighbors of vertices in @xmath200 .",
    ".    denoted by @xmath203 $ ] the set of edges in @xmath196 that are connected to vertices in @xmath204 .",
    "then we define @xmath205 as follows , which represents the max number of edges travelled when computing @xmath185 in the case of inserting edges to @xmath196 .",
    "@xmath206|\\}.\\ ] ]    furthermore , we define the _ maximum inserted degree _ as the maximum number of edges inserted to each vertex in @xmath14 , denoted as @xmath207 .",
    "[ insertcorrectness ] algorithm [ alg : superioredgeinsert ] can update the core numbers of vertices after inserting an edge set @xmath34 in @xmath208 time .    the algorithm is executed in iterations , and each iteration includes two parts .",
    "the first part computes the superior edge set from unprocessed edges in @xmath34 by executing algorithm [ alg : findksuperioredges ] in parallel , and then inserts the computed superior edge set into graph @xmath1 . by lemma",
    "[ them : superioredgesetinsert ] , after inserting a superior edge set into the graph , each vertex can increase its core by at most 1 .",
    "after that , in the second part , we identifiy vertices that will increase core numbers by executing algorithm [ alg : insertk ] in parallel .",
    "different processes deal with distinct @xmath0-superior edge sets , and visit vertices with distinct core numbers . for each inserted @xmath0-superior edge set @xmath47 , we conduct two kinds of operations : ( 1 ) a positive dfs that visits vertices in the exkpt , and ( 2 ) a negative dfs that will remove vertices that are confirmed not to increase core numbers . by lemma",
    "[ le : exkpaths ] , visiting vertices in the exkpt is enough to find all vertices whose core numbers potentially increase caused by the insertion of @xmath47 . and by lemma  [ corollary : csd ] , if a vertex @xmath122 satisfies @xmath209 \\le k$ ] , @xmath122 will not increase its core number , and it will affect the potential of its neighbors to increase their core numbers . notice that this influence procedure should be spread across vertices in * @xmath210 * , which is done by the negative dfs procedure .",
    "when all eges in @xmath47 are handled , the potential vertices are visited and the ones that can not increase core numbers are removed .",
    "all above ensures the corretness of the algorithm .    as for the time complexity , because in each iteration , for each vertex , at least one inserted edge connected to it can be selected into the superior edge set and processed , there are at most @xmath211 iterations in the algorithm execution .",
    "we next consider the time used in each iteration .",
    "now consider an iteration @xmath212 , and we denote the graph obtained after iteration @xmath213 is @xmath214 .",
    "denote by @xmath193 the superior edge set computed in iteration @xmath212 .",
    "the computation of @xmath167 values for vertices in exkpt of @xmath193 takes @xmath215 time .",
    "the positive dfs visits each vertex in exkpt for one time .",
    "hence the positive dfs procedure takes @xmath216 time . for the negative dfs procedures ,",
    "notice that after each dfs procedure , if a vertex @xmath2 is visited , @xmath190 is decreased by 1 .",
    "hence , each vertex can be visited by at most @xmath198 times , since a vertex will be removed if its @xmath189 values is decreased to its core number .",
    "combining together , the total time for an iteration is @xmath217 .    by above",
    ", it can be got the time complexity of the algorithm as stated in the theorem .",
    "the decremental algorithm is showed in algorithm [ alg : superioredgedelete ] .",
    "similar with the incremental algorithm , we deal with deleted edges in iterations . in each iteration",
    ", a superior edge set is found using a parallel approach .",
    "after that , the graph is updated by deleting the computed superior edge set and the @xmath0-superior edge sets are assigned to child processes . in each child process , the edges in a @xmath0-superior edge set is handled one by one similarly .",
    "the main difference is that we use @xmath185 values to evaluate if a vertex will decrease its core number , and only execute the negative dfs to remove vertices that can not be in the current @xmath0-core . when deleting an edge @xmath127 with core(@xmath21 )",
    "@xmath218 core(@xmath2 ) , it is checked if @xmath21 still has enough superior neighbors that can help it keep the core number .",
    "if @xmath31 is decreased , algorithm  [ alg : deleteremove ] is executed to remove it and disseminate the influence .",
    "[ htb][alg : superioredgedelete ]    * input * + the graph , @xmath26 ; + the deleted edge set , @xmath34 ; + the set of vertices @xmath171 connected to edges in @xmath34 the core number @xmath52 of each vertex in @xmath14    [ htb][alg : deletek ]    * input * + the graph , @xmath26 ; + the @xmath0-superior edge set , @xmath47 ; + the core number @xmath52 of each vertex in @xmath14 * initially * , @xmath174 empty stack for each vertex @xmath175 , @xmath176\\gets{false } , removed[v]\\gets{false } , cd[v]\\gets{0}$ ]    * return * @xmath219 ;    [ alg : deleteremove ]    @xmath180 @xmath181 \\gets{true}$ ]    * performance analysis .",
    "* we next analyze the correctness and efficiency of the proposed decremental algorithm . at first , some notations are defined , which will be used in measuring the time complexity of the algorithm .    for graph @xmath26 , the deleted edge set @xmath34 and a subset @xmath220 of @xmath34 ,",
    "let @xmath221 and @xmath222 be the set of core numbers of vertices in @xmath223 .    for @xmath223 ,",
    "let @xmath224 .    for @xmath225 ,",
    "let @xmath226 be the set of vertices with core number @xmath0 and @xmath227 .",
    "denote by @xmath228 the set of edges connected to vertices in @xmath226 .",
    "we then define @xmath229 as follows , @xmath230|\\}. m_r=\\max_{k\\in k(g_r)}\\{|e(v_r(k))|\\}.\\ ] ] @xmath231 , @xmath232 and @xmath229 will depict the time used in each iteration in the algorithm execution .",
    "furthermore , we define the _ maximum deleted degree _ as the maximum number of edges deleted from each vertex in @xmath14 , denoted as @xmath233 . using a similar argument as that for analyzing the incremental algorithm",
    ", we can get the following result , which states the correctness and efficiency of the decremental algorithm . the detailed proof is put in appendix .",
    "[ deletecorrectness ] algorithm [ alg : superioredgedelete ] can update the core numbers of vertices after inserting an edge set @xmath34 in @xmath234 time .",
    "the proof is similarly as the insertion case , the only difference lies in the second part in each iteration .",
    "we only conduct the negative dfs to remove vertices that will decrease core numbers according to corollary [ corollary : sd ] . for each edge @xmath127 , if core(@xmath21 ) @xmath235 core(@xmath2 ) and @xmath236 , we start the negative dfs rooted as @xmath188 to travel the edges in * @xmath187 * where @xmath188 is @xmath21 or @xmath2 that has a smaller core number . if core(@xmath21 ) = core(@xmath2 ) and @xmath237 , we will travel * @xmath134 * to remove @xmath21 and disseminate the influence first , then if @xmath237 and @xmath2 is not removed yet , remve @xmath2 and disseminate the influence through the negative dfs rooted as @xmath2 . during the dfs",
    "a vertex @xmath122 can be visited by at most @xmath238 times , since a visit will decrease @xmath209 $ ] by 1 and when @xmath209 < k$ ] , @xmath122 will be marked as removed and wont be visited again .",
    "after all edges are handled , the vertices that are marked as visited and removed will decrease core numbers .",
    "algorithm [ alg : deletek ] first compute @xmath185s for vertices in exkpt of @xmath47 and the time complexity is @xmath239 . and the time needed for the negative dfs is @xmath240 , since we travel each vertex in @xmath241 at most @xmath242 times to remove it .",
    "so in one iteration the time complexity of algorithm [ alg : superioredgedelete ] is @xmath243 .",
    "then similarly as the insertion cese , the number of iterations is bounded by the max deleted degree @xmath233 .",
    "so the time complexity of the whole algorithm is @xmath244 .",
    "in this section , we conduct empirical studies to evaluate the performances of our proposed algorithms . the experiments use three synthetic datasets and seven real - world graphs , as shown in table [ table_graph ] .",
    "there are two main variations in our experiments , the original graph and the inserted / deleted edge set .",
    "we first evaluate the efficiency of our algorithms on real - world graphs , by changing the size and core number distribution of inserted / deleted edges . then we evaluate the scalability of our algorithms using synthetic graphs , by keeping the inserted / deleted edge set stable and changing the sizes of synthetic graphs . at last ,",
    "we compare our algorithms with the state - of - the - art core maintenance algorithms for single edge insertion / deletion , traversal algorithms given in @xcite , to evaluate the acceleration ratio of our parallel algorithms .",
    "the comparison experiments are conducted on four typical real - world datasets .",
    "all experiments are conducted on a linux machine with intel xeon cpu e5 - 2670@2.60ghz and 64 gb main memory , implemented in c++ and compiled by g++ compiler .",
    "* datasets .",
    "* we use seven real - world graphs and random graphs generated by three models .",
    "the seven real - world graphs can be downloaded from snap @xcite , including social network graphs ( livejournal , youtube , soc - slashdot ) , collaboration network graphs ( dblp , ca - astroph ) , communication network graphs ( wikitalk ) and web graphs ( web - berkstan ) .",
    "the synthetic graphs are generated by the snap system using the following three models : the erds - r**@xmath245**nyi ( er ) graph model @xcite , which generates a random graph ; the barabasi - albert ( ba ) preferential attachment model @xcite , in which each node creates @xmath0 preferentially attached edges ; and the r - mat ( rm ) graph model @xcite , which can generate large - scale realistic graphs similar to social networks . for all generated graphs , the average degree is fixed to 8 , such that when the number of vertices in the generated graphs is the same , the number of edges is the same as well .",
    "[ core1 ] and fig .",
    "[ core2 ] show the core number distributions of the seven real - world graphs and the generated graphs with @xmath246 vertices . from fig .",
    "[ core1 ] , it can be seen that in real - world graphs , more than 60 percent of vertices have core numbers smaller than 10 .",
    "especially , in wt ( wiki - talk ) , more than 70% of vertices have core number 1 . for the core distributions of generated graphs , as shown in fig .",
    "[ core2 ] , in the ba graphs , all vertices have a core number of 8 . in the er graph ,",
    "the core numbers of vertices are small and the max core number of vertices is 10 , but almost all vertices have core numbers close to the max one .",
    "the rm graph are more close to real - world graphs , where most vertices have small core numbers and as the core number @xmath0 increases , the percentage of vertices with core number @xmath0 decreases .",
    "as shown later , the core distribution of a graph will affect the performances of our algorithms .",
    "the _ core number _ of an edge is defined as the smaller core number of its two endpoints .",
    "we use the _ average processing time per edge _ as the efficiency measurement of the algorithms , such that the efficiency of the algorithms can be compared in different cases .",
    ".real - world graph datasets [ cols=\"^,^,^,^,^\",options=\"header \" , ]      we evaluate the impacts of three factors on the algorithm performance : the size of inserted / deleted edges , the core number distribution of edges inserted / deleted , and the original graph size .",
    "the first factor affects the iterations needed to process the inserted / deleted edges , and the last two factors affect the processing time in each iteration .",
    "the first two evaluations are conducted on real - world graphs , and the third one is on synthetic graphs .",
    "we first evaluate the impact of the number of inserted/ deleted edges on the performances of our algorithms .",
    "the results for the incremental and decremental maintenance algorithm are illustrated in fig .",
    "[ size_ins ] and fig .",
    "[ size_del ] respectively . in the experiments ,",
    "we randomly insert / delete @xmath247% edges with respect to the original graph , where @xmath248 for @xmath249 . in fig .",
    "[ size_ins ] and fig .",
    "[ size_del ] , the x - axis represents the datasets , and the y - axis represents the average processing time per edge . it can be seen that the processing time per edge is less than @xmath250 in all cases , and except for wt and lj , the processing time is much smaller than @xmath250 .",
    "the figures show that the processing time decreases as the number of inserted / deleted edges increases , which demonstrates that our algorithms are suitble for handling large amount of edge insertions / deletions . in this case",
    ", more edges can be selected into the superior edge set in each iteration , and hence our algorithms achieve better parallelism .",
    "furthermore , fig .",
    "[ size_ins ] and fig .",
    "[ size_del ] also illustrate that it needs a larger average processing time when the size of original graphs increases .",
    "the only exception is the wt graph .",
    "though the graph has a smaller size than bs and lj graphs , the average processing time is larger .",
    "this is because the core distribution of wt is rather unbalancing , as showed in figure [ core1 ] , where most vertices possess the same core number . in this extremal case ,",
    "on the one hand , each iteration in the algorithm takes more time in processing the inserted edges , as more vertices need to be traversed , and on the other hand , the parallelism of the algorithm is very limited , as most edges are inserted to vertices with the same core .",
    "we then evaluate the impact of the core number distribution of inserted / deleted edges on the algorithm performance .",
    "the results are illustrated in fig .",
    "[ corechange ] .",
    "in particular , by the core distributions showed in fig .",
    "[ core1 ] , we choose five typical core numbers \\{@xmath251 } in an increasing order for each of the seven graphs . for each core number , 20% edges of that core number",
    "are selected randomly as the update edge set . from fig .",
    "[ corechange ] , it can be seen that larger core number induces a larger average processing time .",
    "this is because , when inserting / deleting edges to vertices with larger core numbers , the degree of these vertices generated by these inserted edges is larger . in our algorithm , only one superior edge can be handled for each vertex in each iteration .",
    "hence , it takes more iterations to process the inserted / deleted edges .",
    "but on the other hand , it can be also seen that the processing time per edge does not vary significantly .",
    "we finally evaluate scalability of our algorithms in synthetic graphs , by letting the number of vertices scale from @xmath252 to @xmath246 and keeping the average degree fixed as 8 .",
    "the results are shown in fig .",
    "[ graphchange ] . in the experiments",
    ", for each graph , we randomly select 10000 edges as the update set . in fig .",
    "[ graphchange ] , the x - axis represents the number of vertices in the graph , and the y - axis represents the average processing time per edge .",
    "[ graphchange ] shows that though the graph size increases exponentially , the average processing time increases linearly .",
    "it demonstrates that our algorithms can work well in graphs with extremely large size . from the figures",
    ", it can be also seen that the processing time in the ba graph is larger than those of the other two graphs .",
    "this is because all vertices in the ba graph have the same core number 8 .",
    "this means that in our algorithm , all edges are initially handled in one process , and hence the parallelism is poor in this extreme case .",
    "this can be seen as the worst case for our algorithms . however , as shown in fig .",
    "[ core1 ] and fig .",
    "[ core2 ] , real - word graphs exhibit much better balance in core number distribution .      in this section ,",
    "we evaluate the acceleration ratio of our parallel algorithms , comparing with algorithms sequentially handling edge insertions / deletions .",
    "we compare with the state - of - the - art sequential algorithm , * traversal * algorithms given in @xcite .",
    "the comparison is conducted on four typical real - world graphs , db , wt , yt and lj in table [ table_graph ] . for each graph",
    ", we randomly select 5k-20k edges as the update set .",
    "the evaluation results are illustrated in fig .",
    "[ cmp_ins ] and fig .",
    "[ cmp_del ] respectively . in the figures ,",
    "the x - axis and y - axis represent the number of inserted / deleted edges and the acceleration ratio , respectively .    from fig .",
    "[ cmp_ins ] and fig .",
    "[ cmp_del ] , it shows that in almost all cases , our algorithms achieves an acceleration ratio as large as @xmath253 times in both incremental and decremental core maintenance .",
    "the acceleration ratio increases as the number of edges inserted / deleted increases , which illustrates that our algorithms have better parallelism in scenarios of large amounts of graph changes .",
    "furthermore , it is also shown that our algorithms achieve larger acceleration ratios as the graph size increases .",
    "all evaluation results show that our algorithms exhibit good parallelism in core maintenance of dynamic graphs , comparing with sequential algorithms .",
    "the experiments illustrate that our algorithms are suitable for handling large amounts of edge insertions / deletions in large - scale graphs , which is desirable in realistic implementations .",
    "in this paper , we present the first known parallel algorithms for core maintenance in dynamic algorithms .",
    "our algorithms have significant accelerations comparing with sequential processing algorithms that handle inserted / deleted edges sequentially , and reduce the number of iterations for handling @xmath5 inserted / deleted edges from @xmath5 to the maximum number of edges inserted to / deleted from a vertex .",
    "experiments on real - world and synthetic graphs illustrate that our algorithms implement well in reality , especially in scenarios of large - scale graphs and large amounts of edge insertions / deletions .    for the future work",
    ", it deserves more efforts to discovering structures other than superior edge set that can help design parallel core maintenance algorithms .",
    "furthermore , it is also meaningful to design parallel algorithms for maintaining other fundamental vertex parameters , such as betweenness centrality  @xcite .",
    "the authors would like to thank ...                                                                    * proof of theorem [ deletecorrectness ] . * + the deletion algorithm is executed in iterations , and each iteration includes two parts . the first part is similarly as the insertion case , which computes the superior edge set in parallel , and then deletes the computed superior edge set from graph @xmath1 . by lemma [ them : superioredgesetdelete ] , after deleting such a superior edge set @xmath47 from the graph , each vertex can decrease its core by at most 1 .    then in the second part , we identifiy vertices that will decrease core numbers by executing algorithm [ alg : deletek ] in parallel . in each child process , it is sufficient to visit vertices in the exkpt of @xmath47 to find all vertices whose core numbers may decrease according to lemma [ le : exkpaths ] . for each edge ,",
    "we start a negative dfs to remove vertices that are confirmed to decrease core numbers . and by lemma  [ corollary : sd ] , for a vertex @xmath2 , if @xmath254 \\le k$ ] , @xmath2 will decrease its core number , and this will affect the @xmath185 value of its neighbors .",
    "so we use a variable value @xmath189 to represent the dynamic changes of @xmath185 value .",
    "after all edges are handled , vertices in exkpt are visited and the ones that can not be in the current @xmath0-core are marked as removed .",
    "all above ensures the corretness of the algorithm .",
    "now consider an iteration @xmath212 , denote the superior edge set computed in current iteration @xmath212 as @xmath220 .",
    "the computation of @xmath185 values for vertices in exkpt of @xmath220 takes @xmath239 time . for the negative dfs procedures ,",
    "if a vertex @xmath2 is visited , @xmath190 is decreased by 1 .",
    "hence , each vertex can be visited by at most @xmath231 times , since a vertex will be removed if its @xmath189 values is decreased below to its core number .",
    "combining together , the total time for an iteration is @xmath256 ."
  ],
  "abstract_text": [
    "<S> this paper initiates the studies of parallel algorithms for core maintenance in dynamic graphs . </S>",
    "<S> the core number is a fundamental index reflecting the cohesiveness of a graph , which are widely used in large - scale graph analytics . </S>",
    "<S> the core maintenance problem requires to update the core numbers of vertices after a set of edges and vertices are inserted into or deleted from the graph . </S>",
    "<S> we investigate the parallelism in the core update process when multiple edges and vertices are inserted or deleted . </S>",
    "<S> specifically , we discover a structure called _ superior edge set _ , the insertion or deletion of edges in which can be processed in parallel . </S>",
    "<S> based on the structure of superior edge set , efficient parallel algorithms are then devised for incremental and decremental core maintenance respectively . to the best of our knowledge , </S>",
    "<S> the proposed algorithms are the first parallel ones for the fundamental core maintenance problem . </S>",
    "<S> the algorithms show a significant speedup in the processing time compared with previous results that sequentially handle edge and vertex insertions / deletions . </S>",
    "<S> finally , extensive experiments are conducted on different types of real - world and synthetic datasets , and the results illustrate the efficiency , stability and scalability of the proposed algorithms . </S>"
  ]
}