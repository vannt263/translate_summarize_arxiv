{
  "article_text": [
    "we consider synchronous communication networks in which some messages can be lost during each round .",
    "these omission faults can be permanent or not ; a faulty link can become reliable again after an unpredictable number of rounds , and it can continue to alternate between being reliable and faulty in an unpredictable way .",
    "this model is more general than other models , such as _ component failure _ models , in which failures , once they appear somewhere , are located there permanently .",
    "the model that we use , called the _ mobile faults _ or _ dynamic faults _ model , was introduced in @xcite and is discussed further in @xcite .",
    "an important property of these systems is that the set of possible simultaneous omissions is the same for each round . in some sense",
    ", the system has no `` memory '' of the previous failures .",
    "real systems often exhibit such memory - less behaviour .    in previous research ,",
    "the sets of possible simultaneous omissions were defined by bounding the numbers of omissions .",
    "recent work on this subject includes @xcite , in which omissions are counted globally , and @xcite , in which the number of omissions is locally bounded .",
    "it has also been shown to be good for _ layered analysis _ @xcite . in this paper",
    "we consider the _ most general case _ of such systems , i.e. systems in which the set of possible simultaneous omissions is arbitrary .",
    "this allows the modelling of any system in which omissions can happen transiently , in any arbitrary pattern , including systems in which the communications are not symmetric .",
    "we investigate two fundamental problems of distributed computing in these networks : the consensus problem and the broadcast problem .",
    "while it has long been known that solvability of the broadcast problem implies solvability of the consensus problem , we prove here that these problems are actually equivalent ( from both the solvability and complexity points of view ) when the sets of possible omissions are defined by bounding the number of failures , for _ any _ possible way of counting them ( locally , globally , any combination , etc . ) .",
    "the consensus problem is a very well studied problem in the area of distributed algorithms .",
    "it is defined as follows .",
    "each node of the network starts with an initial value , and all nodes of the network have to agree on a common value , which is one of the initial values .",
    "many versions of the problem concern the design of algorithms for systems that are unreliable .    the consensus problem has been widely studied in the context of shared memory systems and message passing systems in which any node can communicate with any other node .",
    "surprisingly , there have been few studies in the context of communication networks , where the communication graph is not a complete graph . in one of the first thorough studies @xcite , santoro and widmayer investigate some @xmath0majority problems that are defined as follows .",
    "each node starts with an initial value , and every node has to compute a final _ decided _ value such that there exists a value ( from the set of initial values ) that is decided by at least @xmath1 of the nodes .",
    "the consensus problem ( called the unanimity problem in @xciteagreement ) has different meanings in the different areas . ] ) is the @xmath2majority problem where @xmath3 is the number of nodes in the network .",
    "in their paper , santoro and widmayer give results about solving the consensus problem in communication networks with various types of faults including omission faults . for simplicity ,",
    "we focus here only on omission faults .",
    "we believe that our results can be quite easily extended to other fault models , using the methodology of @xcite .",
    "two of the most widely studied patterns of information propagation in communication networks are _ broadcasting _ and _ gossiping_. a _ broadcast _ is the distribution of an initial value from one node of a network to every other node of the network .",
    "gossip _ is a simultaneous broadcast from every node of the network .",
    "the broadcast problem that we study in this paper is to find a node from which a broadcast can be successfully completed .",
    "there are close relationships between broadcasting and gossiping , and the consensus problem .",
    "indeed , the consensus problem can be solved by first gossiping and then applying a deterministic function at each node to the set of initial values . but a gossip is not actually necessary . if there exists a distinguished node @xmath4 in the network , then a consensus algorithm can be easily derived from an algorithm that broadcasts from @xmath4",
    ". however the broadcast problem and the consensus problem are not equivalent , as will be made clearer in section  [ theproblems ] .      in this paper",
    ", we investigate systems in which the pattern of omission failures is arbitrary .",
    "a set of simultaneous omissions is called a _ communication event_. we characterize the solvability of the broadcast and consensus problems subject to an arbitrary family of possible communication events .",
    "a node from which it is possible to broadcast if the system is restricted to a given communication event is called a _ source _ for the communication event .",
    "we prove that the broadcast problem is solvable if and only if there exists a common source for all communication events .",
    "to study the consensus problem , we define an equivalence relation on a family of communication events based on the collective local observations of the events by the sources .",
    "we prove in theorem  [ impossibility ] that the consensus problem is not solvable for a family of communication events if the broadcast problem is not solvable for one class of the equivalence relation .",
    "_ for consensus to be solvable , the sources of a given event must be able to collectively distinguish communication events with incompatible sources .",
    "_ we conjecture that this is actually a sufficient condition .",
    "it is very simple to characterize broadcastability ( see theorem  [ broadcastability ] ) , so we get very simple and efficient impossibility proofs for solving consensus subject to arbitrary omission failures .",
    "these impossibility conditions are satisfied by the omission schemes of @xcite and @xcite .",
    "this means that our results encompass all previous known results in the area .",
    "furthermore , we prove that under very general conditions , in particular when the possible simultaneous omissions are defined by bounding the number of omissions , for any way of counting omissions , there is actually only one equivalence class when the system is not broadcastable .",
    "an important application is that , _ the consensus problem is exactly the same as the broadcast problem for most omission fault models_. therefore , it is possible to deduce complexity results for the consensus problem from complexity results about broadcasting with omissions .      in @xcite ,",
    "the authors present a model that can describe benign faults .",
    "this model is called the `` heard - of '' model .",
    "it is a round - based model for an omission - prone environment in which the set of possible communication events is not necessarily the same for each round .",
    "however , they require a time - invariance property . as a special case ,",
    "they present a characterization that shows that solving consensus in this environment is equivalent to solving a selection problem .",
    "they also present algorithms for some families of omission schemes .",
    "it is not possible to derive our simple characterizations from @xcite .    in @xcite ,",
    "the consensus and related agreement problems are investigated for networks in which there are at most @xmath5 omissions during any given round .",
    "it is proved that it is impossible to solve consensus if @xmath5 is at least the minimum degree of the graph .",
    "a consensus algorithm is presented for the case where @xmath5 is strictly smaller than the connectivity of the network . in @xcite , a reduction to the two process case",
    "is used to show that the connectivity of the graph is indeed the exact limit for consensus is such omission schemes . in this paper , we generalize these results , showing that exact limits for consensus can be derived from exact limits for broadcast .",
    "while the above studies use a global failure metric , a local failure metric is investigated in @xcite , distinguishing send and receive omissions .",
    "the authors describe which bounds allow consensus to be solved , using a proof technique based on a _ withholding lemma_. they claim that consensus is solvable if and only if no node can withhold its information from some other part of the network .",
    "we will show that this is not true when the pattern of omissions can be arbitrary .",
    "we present ( in example  [ contrex ] ) a system in which nodes can withhold information infinitely but consensus is solvable .",
    "finally , it is worth noting that , although both @xcite and @xcite are using the classic bivalency proof technique , it is not possible to derive any of the results of @xcite or @xcite ( global bound on omissions ) from the results of @xcite ( local bound ) as the omission schemes are not comparable .",
    "our results consolidate these previous results .",
    "furthermore , our approach is more general than these previous approaches and is more suitable for applications to new omission metrics .",
    "we model a communication network by a digraph @xmath6 which does not have to be symmetric . if we are given an undirected graph @xmath7 , we consider the corresponding symmetric digraph .",
    "we always assume that nodes have unique identities . given a set of arcs @xmath8",
    ", we define @xmath9 , the set of nodes that are heads of arcs in @xmath8 .",
    "all sub - digraphs that we consider in this paper are spanning subgraphs . since all spanning subgraphs of a digraph have the same set of nodes",
    ", we will use the same notation to refer to both the set of arcs of a sub - digraph and the sub - digraph with that set of arcs when the set of nodes is not ambiguous .      in this section ,",
    "we introduce our model and the associated notation .",
    "communication in our model is synchronous but not reliable , and communication is performed in rounds .",
    "communication with omission faults is described by a spanning sub - graph of @xmath10 with the semantics that are specified in section  [ execution ] .    throughout this paper ,",
    "the underlying graph @xmath6 is fixed , and we define the set @xmath11 this set represents all possible simultaneous communications given the underlying graph @xmath7 .",
    "an element of @xmath12 is called a _ communication event _ ( or _ event _ for short ) .",
    "an _ omission scenario _ ( or _ scenario _ for short ) is an infinite sequence of communication events .",
    "an _ omission scheme _ over @xmath7 is a set of omission scenarios .",
    "a natural way to describe communications is to consider @xmath12 to be an alphabet , with communication events as letters of the alphabet , and scenarios as infinite words .",
    "we will use standard concatenation notation when describing sequences . if @xmath13 and @xmath14 are two sequences , then @xmath15 is the sequence that starts with the ordered sequence of events @xmath13 followed by the ordered sequence of events @xmath14 .",
    "this notation is extended to sets in an obvious way .",
    "the empty word is denoted @xmath16 .",
    "we will use the following standard notation to describe our communication schemes .    given @xmath17",
    ", @xmath18 is the set of all finite sequences of elements of @xmath19 , and @xmath20 is the set of all infinite ones .",
    "the set of all possible scenarios on @xmath7 is then @xmath21 .",
    "a given word @xmath22 is called a _ partial scenario _ and @xmath23 is the length of this partial scenario .",
    "an omission scheme is then a subset @xmath24 of @xmath21 .",
    "a _ mobile omission scheme _ is a scheme that is equal to @xmath20 for some subset @xmath25 . in this paper",
    ", we consider only mobile omission schemes .",
    "note that we do not require @xmath7 to belong to @xmath19 .",
    "a formal definition of an execution subject to a scenario will be given in section  [ execution ] .",
    "intuitively , the @xmath26-th letter of a scenario will describe which communications are reliable during round @xmath26 .",
    "finally , we recall some standard definitions for infinite words and languages over an alphabet @xmath12 . given @xmath27 , a _",
    "subword _ of @xmath13 is a ( possibly infinite ) sub - sequence @xmath28 , where @xmath29 is a strictly increasing function .",
    "a word @xmath30 is a prefix of @xmath22 ( resp .",
    "@xmath31 ) if there exists @xmath32 ( resp .",
    "@xmath33 ) such that @xmath34 ( resp .",
    "@xmath35 ) .",
    "given @xmath36 and @xmath37 , @xmath38 is the finite prefix of @xmath13 of length @xmath26 .",
    "let @xmath36 and @xmath39 .",
    "then @xmath40 @xmath41 , and @xmath42 .",
    "a word @xmath14 is an _ extension _ of @xmath13 in @xmath43 , if @xmath44 .",
    "we do not restrict our study to regular sets , however all omission schemes known to us are regular , including the following examples , so we will use the notation for regular sets .",
    "we present examples for systems with two processes but they can be easily extended to any arbitrary graph .",
    "the set @xmath45 is the set of directed graphs with two nodes and .",
    "the subgraphs in @xmath12 describe what can happen during a given round with the following interpretation :    @xmath46 all messages that are sent are correctly received ;    @xmath47 the message from process , if any , is not received ;    @xmath48 the message from process , if any , is not received ;    @xmath49 no messages are received .",
    "[ 2processes ] the set @xmath50 corresponds to a reliable system .",
    "the set @xmath51 is well studied and corresponds to the situation in which there is at most one omission per round .",
    "[ contrex ] the set @xmath52 describes a system in which at most one message can be successfully received in any round , and if only one message is sent , it might not be received",
    ".    the examples above are examples of mobile omission schemes .",
    "the following is a typical example of a non - mobile omission scheme .",
    "[ ex : crash ] consider a system in which at most one of the processes can crash . from the communications point of view , this is equivalent to a system in which it is possible that no messages are transmitted by one of the processes after some arbitrary round .",
    "the associated omission scheme is the following : @xmath53      given an omission scheme @xmath24 , we define what is a successful execution of a given algorithm with a given initial configuration @xmath54 .",
    "every process can execute the following communication primitives :    @xmath55 to send a message @xmath56 to an out - neighbour @xmath57 ,    @xmath58 to receive a message from an in - neighbour @xmath57 .",
    "an _ execution _ , or _ run _ , of an algorithm _ subject to _",
    "scenario @xmath59 is the following .",
    "consider process @xmath60 and one of its out - neighbours @xmath57 . during round @xmath37",
    ", a message @xmath56 is sent from @xmath60 to @xmath57 , according to algorithm .",
    "the corresponding @xmath58 will return @xmath56 only if @xmath61 , the @xmath26-th letter of @xmath13 , is such that @xmath62 .",
    "otherwise the returned value is @xmath63 .",
    "all messages sent in a round can only be received in the same round .",
    "after sending and receiving messages , all processes update their states according to and the messages they received .",
    "given @xmath64 , let @xmath65 denote the state of process at the end of the @xmath66-th round of algorithm subject to scenario @xmath13 .",
    "the initial state of is @xmath67 .",
    "configuration _ corresponds to the collection of local states at the end of a given round .",
    "an _ execution _ of subject to @xmath13 is the ( possibly infinite ) sequence of such message exchanges and corresponding configurations .    with this definition of execution ,",
    "the environment is independent of the actual behaviour of the algorithm , so communication failures do not depend upon whether or not messages are sent .",
    "this model is not suitable for modelling omissions caused by congestion .",
    "see @xcite for examples of threshold - based omission models .",
    "a algorithm _ solves a problem _ _ subject to omission scheme @xmath24 _ with initial configuration @xmath54 , if , for any scenario @xmath59 , there exists @xmath64 such that the state @xmath68 of each process @xmath69 satisfies the specifications of for initial configuration @xmath54 . in such a case ,",
    "is said to be _",
    "-reliable _ for .",
    "if there exists an algorithm that solves a problem subject to omission scheme , then we say that is @xmath70solvable .",
    "we emphasize that for an algorithm , `` knowing '' the omission scheme against which it runs is not the same as knowing whether or not a given message is actually received .",
    "a set of synchronous processes wishes to agree about a binary value .",
    "this problem was first identified and formalized by lamport , shostak and pease @xcite . given a set of processes , a consensus protocol must satisfy the following properties for any combination of initial values  @xcite :    _ termination _ : every process decides some value ;    _ validity _ : if all processes initially propose the same value @xmath57 , then every process decides @xmath57 ;    _ agreement _ : if a process decides @xmath57 , then every process decides @xmath57 .    consensus with these termination and decision requirements is more precisely referred to as _ uniform consensus _ ( see @xcite for a discussion ) .",
    "given a fault environment , the natural questions are : is consensus solvable , and if it is solvable , what is the minimum number of rounds to solve it ?      let @xmath6 be a graph . there is a _ broadcast algorithm from _",
    "@xmath71 , if there exists an algorithm that can successfully transmit any value stored in @xmath60 to all nodes of @xmath7 .",
    "the _ broadcast problem on graph @xmath7 _ is to find a @xmath71 and an algorithm such that is a broadcast algorithm from @xmath60 .",
    "given an omission scheme on @xmath7 , @xmath7 is -broadcastable if there exists a @xmath71 such that there is an -reliable broadcast algorithm from @xmath60 .",
    "the next proposition is quite well known but leads to very interesting questions .",
    "let @xmath7 be a graph and an omission scheme for @xmath7 .",
    "if @xmath7 is -broadcastable , then consensus is -solvable on @xmath7 .",
    "if @xmath7 is -broadcastable then there exists a node @xmath60 and an algorithm for broadcasting any value from @xmath60 subject to @xmath24 .",
    "the consensus algorithm uses to broadcast the initial value of @xmath60 , and then every node decides the value received from @xmath60 .",
    "as the value that @xmath60 broadcasts is one of the initial values , the algorithm satisfies all three conditions , and is obviously -reliable .",
    "@xmath72    we now present an example that shows that the converse is not always true .",
    "[ contrex - algo ] the omission scheme @xmath73 of example  [ contrex ] is an example of a system for which there is a consensus algorithm but no broadcast algorithm .",
    "it is easy to see that it is not possible to broadcast from ( resp .  )",
    "subject to @xmath74 because @xmath75 ( resp .",
    "@xmath76 ) is a possible scenario .",
    "however , the following one - round algorithm ( the same for both processes ) is an @xmath77reliable consensus algorithm :    send the initial value ;    if a value is received , decide this value , otherwise decide the initial value .",
    "this algorithm is correct , as exactly one process will receive a value , but it is not possible to know in advance whose value will be received .",
    "we propose to study the following question : when is the solvability of consensus equivalent to the solvability of broadcast ?",
    "that is , given a graph @xmath7 , what are the mobile omission schemes on @xmath7 such that consensus is -solvable and @xmath7 is -broadcastable .",
    "in the process of answering this question , we will give a simple characterization of the solvability of broadcast and a necessary condition for the solvability of consensus subject to mobile omission schemes .",
    "we start with a basic definition and lemma .    consider a sub - digraph @xmath78 of @xmath7 and a node @xmath71 .",
    "a node @xmath79 is _ reachable from @xmath60 in @xmath78 _ if there is a directed path from @xmath60 to @xmath57 in @xmath78 .",
    "node @xmath60 is a _ source _ for @xmath78 if every @xmath79 is reachable from @xmath60 in @xmath78 .    in a _ flooding algorithm _",
    ", one node repeatedly sends a message to its neighbours , and each other node repeatedly forwards any message that it receives to its neighbours . the following useful lemma ( from folklore ) about synchronous flooding algorithms is easily extended to the omission context .",
    "let @xmath80 denote a flooding algorithm that is originated by @xmath71 and that halts after @xmath26 synchronous rounds .",
    "[ obvious ] a node @xmath71 is a _ source _ for @xmath78 if and only if for all @xmath81 , @xmath80 is @xmath82reliable for the broadcast problem .      we have the following obvious but fundamental lemma .",
    "we say that a node is _ informed _ if it has received the value from the originator of a broadcast .",
    "[ subwordflood ] let @xmath83 , and let @xmath84 be the set of nodes informed by @xmath80 under the partial execution subject to @xmath85 then for any subword @xmath14 of @xmath13 , @xmath86    [ broadcastability ] let @xmath7 be a graph and @xmath19 a set of communication events for @xmath7",
    ". then @xmath7 is @xmath87broadcastable if and only if there exists @xmath71 that is a source for all @xmath88 .    in the first direction , suppose that we have a broadcast algorithm from a given @xmath60 that is @xmath87reliable .",
    "then an execution subject to @xmath89 is successful for any @xmath88 , so @xmath60 is a source for @xmath78 by lemma  [ obvious ] .    in the other direction , choose the flooding algorithm @xmath90 to be the broadcast algorithm and consider a scenario @xmath91 there is an event @xmath88 that appears at least @xmath92 times in @xmath13 , hence @xmath93 is a subword of @xmath13 . as @xmath60 is a source for @xmath78 by lemma  [ obvious ] , @xmath94 . by lemma  [ subwordflood ] , @xmath95 , and",
    "the flooding algorithm is @xmath87reliable . @xmath72",
    "the _ set of sources of an event @xmath96 _ is @xmath97    let @xmath98 .",
    "then the set @xmath99 is _ source - incompatible _ if    @xmath100    @xmath101 .",
    "[ intersection ]    with these definitions we can restate the broadcastability theorem ( theorem  [ broadcastability ] ) :    [ equivb ] let @xmath7 be a graph and @xmath19 a set of communication events for @xmath7 .",
    "then @xmath7 is @xmath87broadcastable if and only if every event in @xmath19 has a source , and @xmath19 is not source - incompatible .       given a subset @xmath102 of vertices , and @xmath78 an event we denote @xmath103 .",
    "given an omission scheme .",
    "we now define a more precise relation about indistinguishability .",
    "given three directed graphs @xmath104 , we define the following relation denoted by @xmath105 if @xmath106 .",
    "the relation @xmath107 is the transitive closure of @xmath108 relations for any @xmath109 .",
    "we denote @xmath110 the coarsest equivalence relation included in @xmath107 such that for all graphs @xmath111    [ closure ] @xmath112 and @xmath113 such that    @xmath114 ,    @xmath115    @xmath116    the relation @xmath108 describes how some communication events are indistinguishable to the all the nodes of @xmath117 .",
    "the relation @xmath110 is well defined as the equality relation satisfies such a closure property . and",
    "for any two relations @xmath118 and @xmath119 that satisfy the property , we have @xmath120 that satisfies the closure .    in @xmath121 from example  [ 2processes ] , there is only one equivalence class .",
    "let s see why .",
    "first , the sets of sources to consider are :    @xmath122    @xmath123    @xmath124    we have @xmath125 and @xmath126 .",
    "therefore , all communication events are @xmath127equivalent .",
    "in example  [ contrex ] , @xmath110 has two equivalence classes , and every node can distinguish immediately which communication event happened .    as will be seen later in section  [ equivalence ]",
    ", the omission schemes in @xcite and @xcite , and more generally , all schemes that are defined by bounding the number of omissions in some way , have only one @xmath127class when they are source - incompatible .",
    "finally , we can now state the main theorem .",
    "[ impossibility ] let @xmath7 a graph and @xmath19 a set of communication events for @xmath7 .",
    "if consensus is @xmath87solvable then for every @xmath128class @xmath129 , @xmath7 is @xmath130broadcastable .",
    "first we consider the cases in which there are events without sources .",
    "[ nonreachable ] if there is an @xmath88 that has no source , then consensus is not @xmath87solvable .",
    "if @xmath78 has no source , then there exist two non - overlapping , non - empty subsets of nodes @xmath131 and @xmath132 such that there are no paths in @xmath78 from @xmath133 to @xmath134 , @xmath135 .",
    "we consider the three following initial configurations :    @xmath136 : initial value is @xmath137 at every node ,    @xmath138 : initial value is @xmath139 at every node ,    @xmath140 : initial value is @xmath137 if and only if the node belongs to @xmath141    under scenario @xmath89 , @xmath140 is not distinguishable from @xmath136 ( resp .",
    "@xmath138 ) for @xmath131 ( resp .  @xmath132 ) .",
    "so subject to @xmath89 , the algorithm decides @xmath137 in @xmath131 and @xmath139 in @xmath132 , and this contradicts the agreement property .",
    "@xmath72    the proof of the main theorem uses an approach that is similar to the adjacency and continuity techniques of @xcite .",
    "so , we will first prove these two properties .",
    "what should be noted is that the adjacency and continuity properties are mainly consequences of the fact that the scheme is a mobile scheme .",
    "[ bstable ] let @xmath78 be a subgraph of @xmath7 , and let @xmath142 .",
    "if @xmath143 then @xmath144 .",
    "[ adjacency ] let @xmath88 and @xmath145 such that @xmath146 and @xmath147 for all @xmath148 .",
    "then for all @xmath149 and all @xmath148 , @xmath150 .",
    "the proof relies upon lemma  [ bstable ] which implies that processes from @xmath151 can only receive information from @xmath151 under scenario @xmath152 , for any @xmath149 . @xmath72",
    "[ indist ] let @xmath153 such that @xmath154 for some @xmath155 .",
    "then for all @xmath156 and all @xmath157 , @xmath158 .    by definition of @xmath159 relations , processes in @xmath160 can not distinguish @xmath78 from @xmath161 meaning they are receiving the exact same messages from exactly the same nodes in both scenarios .",
    "hence they end in the same states .",
    "@xmath72    [ continuity ]",
    "let @xmath162 such that @xmath163 then for every @xmath164 , there exist @xmath165 in the @xmath127class of @xmath78 and @xmath161 , and @xmath166 , such that for every @xmath167 and every @xmath168 , @xmath169 , where @xmath170 and @xmath171 .    by lemma  [ indist ] and definition of @xmath110 .",
    "@xmath72      we will use a standard bivalency technique . we suppose that we have an algorithm that solves consensus .",
    "a configuration is said to be @xmath172valent ( resp .",
    "@xmath173valent ) if all extensions decide @xmath137 ( resp .",
    "@xmath139 ) .",
    "a configuration is said to be bivalent subject to @xmath43 if there exists an extension in @xmath43 that decides 0 and another extension in @xmath43 that decides 1 .",
    "[ bivinit ] if there exists a source - incompatible set @xmath174 , then there exists an initial configuration that is bivalent subject to @xmath175 .",
    "suppose that @xmath99 is a source - incompatible set in @xmath174 .",
    "there exist disjoint non - empty sets of nodes @xmath176 such that @xmath177 $ ] , @xmath178    consider @xmath179 ( resp .",
    "@xmath180 ) in which all nodes of @xmath181 have initial value @xmath137 ( resp .",
    "@xmath139 ) .",
    "the initial configuration @xmath179 is indistinguishable from the configuration in which all nodes have initial value @xmath137 for the nodes of @xmath182 under scenario @xmath183 , for every @xmath184 .",
    "hence @xmath179 is @xmath172valent .",
    "similarly @xmath185 is @xmath173valent .",
    "we consider now the initial configurations @xmath186 , @xmath187 in which all nodes from @xmath188 have initial value @xmath137 , and all other nodes have initial value @xmath139 .",
    "suppose now that all initial configurations are univalent .",
    "then there exists @xmath189 such that @xmath190 is @xmath172valent and @xmath186 is @xmath173valent . as the set is source - incompatible , there must exist @xmath191 $ ] such that @xmath192 so , we can apply proposition  [ adjacency ] to @xmath193 .",
    "this means that all nodes in @xmath182 decide the same value for both initial configurations , @xmath190 and @xmath186 , under scenario @xmath183 , and this is a contradiction .",
    "@xmath72    [ extcont ] let @xmath129 be a @xmath127class .",
    "every bivalent configuration in @xmath194 has a succeeding bivalent configuration in @xmath194 .",
    "consider a bivalent configuration obtained after a partial execution subject to @xmath195 . by way of contradiction , suppose that all succeeding configurations in @xmath194 are univalent .",
    "then there exist succeeding configurations @xmath196 and @xmath197 that are respectively @xmath172valent and @xmath173valent , as @xmath13 is bivalent .    by proposition  [ continuity ]",
    ", there exist @xmath165 in @xmath129 and @xmath166 such that @xmath169 for every @xmath198 and every @xmath168 , where @xmath170 and @xmath199 by hypothesis , all succeeding configurations @xmath200 are univalent . as @xmath201",
    ", we get that processes in @xmath202 are in the same state after @xmath78 and after @xmath203 . hence , by proposition  [ adjacency ] , they are also in the same state after @xmath204 and after @xmath205 , so they decide the same value and @xmath206 is @xmath172valent .",
    "we can repeat this for any @xmath207 .",
    "hence @xmath197 is also @xmath172valent , a contradiction .",
    "we can now finish the proof with the standard bivalency arguments .",
    "suppose that we have a source - incompatible set in the same @xmath127class @xmath129 .",
    "also suppose that there exists an @xmath87reliable consensus algorithm for @xmath7 .",
    "by lemma  [ bivinit ] , there exists an initial configuration that is bivalent in @xmath194 . from lemma  [ extcont ]",
    ", we deduce that the algorithm does not satisfy the termination property for consensus on some execution subject to @xmath208 , which is a contradiction . using proposition  [ nonreachable ] and theorem  [ equivb ]",
    ", we conclude the proof of theorem  [ impossibility ] .",
    "in this section , we prove that the consensus and broadcast problems are equivalent for the large family of omission schemes that are defined over convex sets of events .",
    "this has very important consequences as checking broadcastability is quite simple ( see theorem  [ broadcastability ] ) .",
    "[ convexity ] a set of communication events @xmath19 is _ convex _ if , for every @xmath153 and every @xmath209 , @xmath210 .    basically , this definition says that a convex set of communication events @xmath19 is closed under the operation of adding a reliable communication event @xmath211 from one event @xmath161 to another event @xmath78 .",
    "this is an important subfamily because sets of events that are defined by bounding the number of omissions , _ for any way of counting them _",
    ", are convex . stated differently",
    ", adding links to an event @xmath78 with a bounded number of omissions can not result in an event with more omissions .",
    "the convexity property does not depend upon the way that omissions are counted .",
    "let @xmath212 be a convex set of communication events over a graph @xmath7",
    ". then consensus is @xmath87solvable if and only if @xmath7 is @xmath87broadcastable .",
    "[ convex - consensus ]    by theorem  [ impossibility ] , we only have to show that there is no source - incompatible set in @xmath19",
    ". we will show that if there is such a set @xmath99 , then there is only one @xmath213 class .",
    "there exist disjoint , non - empty sets of nodes @xmath176 such that @xmath177 $ ] , @xmath214 .",
    "the @xmath215 are `` generators '' for the sets of sources .",
    "we use @xmath216 to denote @xmath217 for any @xmath218.$ ] note that , as the intersection of the @xmath193 is empty ( definition  [ intersection ] ) , for each @xmath219 $ ] , there exists @xmath220 such that @xmath221 .",
    "now , consider @xmath222 .",
    "we will show that @xmath223 . using the decomposition into @xmath215s ,",
    "there exist three mutually disjoint ( possibly empty ) subsets @xmath224 of @xmath225 $ ] , such that @xmath226 and @xmath227    let @xmath228 . as the intersection of @xmath229 with @xmath230 is empty , we have @xmath231    similarly , letting @xmath232 we have @xmath233    to obtain @xmath234 , we need to add to @xmath235 the arcs with heads in @xmath236 .",
    "let @xmath237 and @xmath238    for each @xmath239 , there exists @xmath240 such that @xmath241 .",
    "therefore , for all @xmath1 , @xmath242 .",
    "so finally , we obtain @xmath223 .",
    "similarly , @xmath243 , and @xmath244 @xmath72    let @xmath245 denote the set of communication events with at most @xmath5 omissions from the underlying graph @xmath7 .",
    "an upper bound on @xmath5 for solvability of consensus subject to @xmath246 was given in @xcite , and it was proved to be tight with an ad hoc technique in @xcite .",
    "we can now state this result as an immediate corollary of theorem  [ convex - consensus ] .",
    "let @xmath247 .",
    "consensus is solvable subject to @xmath248 if and only if @xmath249 , where @xmath250 is the connectivity of the graph @xmath7 .",
    "the equivalence of consensus and broadcast includes the number of rounds to solve them .",
    "let @xmath212 be a convex set of events .",
    "if consensus is @xmath87solvable then it is solvable with exactly the same number of rounds as broadcast subject to @xmath20 .",
    "we only have to show that consensus can not be solved in fewer rounds than broadcast . due to space limitations",
    ", we only present a sketch of the proof .",
    "we use the same bivalency technique as in section  [ proof ] .",
    "so , suppose that consensus is solvable in @xmath251 rounds while broadcast needs more than @xmath251 rounds for any originator .",
    "first , we show that there must be a bivalent initial configuration .",
    "let @xmath252 and let @xmath186 be the initial configuration in which @xmath253 has initial value @xmath137 if @xmath254 .",
    "if all initial configurations @xmath186 , @xmath255 are univalent , then there exists @xmath256 such that @xmath190 is @xmath172valent and @xmath186 is @xmath173valent . as a broadcast from @xmath257 needs strictly more than @xmath251 rounds , there exists a vertex @xmath57 that does not receive the value from @xmath257 , so no executions of length @xmath251 of the consensus algorithm from initial configurations @xmath190 and @xmath186 can be distinguished by @xmath57",
    ". consequently @xmath57 will decide the same value for both initial configurations , a contradiction .",
    "now we show that if all extensions of a bivalent configuration are univalent , then the consensus algorithm needs more than @xmath251 rounds to conclude . indeed ,",
    "if we have an extension , starting with communication event @xmath258 , that is @xmath172valent , and another extension , starting with communication event @xmath203 , that is @xmath173valent , we can repeat the above technique by adding arcs to @xmath258 to obtain @xmath259 .",
    "the addition of arcs can be done by grouping them according to their heads .",
    "if only one node has a different state for two events , then it would need more than @xmath251 rounds to inform all other nodes .",
    "there are many results concerning the broadcast problem in special families of networks .",
    "general graphs are studied in @xcite and hypergraphs are studied in @xcite . an optimal algorithm for the family of hypercubes in given in @xcite . for a hypercube of dimension @xmath3 ,",
    "if at most @xmath260 messages are lost during each round , then broadcast can be solved in @xmath261 rounds , compared to @xmath3 rounds when there are no omission faults . in @xcite , the precise impact on broadcast of the actual number of faults",
    "based on the results in @xcite , we get the following bounds for consensus .    in hypercubes of dimension @xmath3 , if the global number of omissions is at most @xmath5 per round , then    if @xmath262 , then consensus is not solvable ,    if @xmath263 , consensus is solvable in exactly @xmath261 rounds ,    if @xmath264 , consensus is solvable in exactly @xmath265 rounds ,    if @xmath266 , consensus is solvable in exactly @xmath3 rounds .",
    "the following example shows that there are mobile schemes that are broadcastable but for which consensus is solvable is fewer rounds than broadcast .",
    "[ contrex - comp ] let @xmath267 where @xmath203 ( resp .",
    "@xmath268 ) is given by fig .  1 ( resp .  fig .  2 ) .",
    "one can see that @xmath269 needs two rounds to broadcast in @xmath203 , and @xmath270 needs two rounds to broadcast in @xmath268 .",
    "nodes @xmath211 and @xmath271 need more than two rounds .",
    "however there is a consensus algorithm that finishes in one round .",
    "notice that every node can detect which of the communication events actually happened , so the consensus algorithm in which every node decides the value from @xmath270 if @xmath203 happened and the value from @xmath269 if @xmath268 happened uses only one round .",
    "\\(a ) at ( 0,0 ) a ; ( b ) at ( 0:2 cm ) b ; ( c ) at ( 40:1.35 cm ) c ; ( d ) at ( -40:1.35 cm ) d ; ( c ) ",
    "( a ) ; ( c )  ( b ) ; ( d )  ( a ) ; ( d )  ( b ) ;    \\(a ) ",
    "( b ) ; ( c )  ( d ) ; ( b ) to[bend right=45 ] ( c ) ;    \\(a ) at ( 0,0 ) a ; ( b ) at ( 0:2 cm ) b ; ( c ) at ( 40:1.35 cm ) c ; ( d ) at ( -40:1.35 cm ) d ; ( c )  ( a ) ; ( c )  ( b ) ; ( d )  ( a ) ; ( d )  ( b ) ;    \\(b )  ( a ) ; ( d )  ( c ) ; ( a ) to[bend right=45 ] ( d ) ;    [ quickerconsensus ]",
    "we have presented a new necessary condition for solving consensus on communication networks subject to arbitrary mobile omission faults .",
    "we conjecture that this condition is actually sufficient , therefore leading to a complete characterization of the solvability of consensus in environments with arbitrary mobile omissions . for a large class of environments that includes any environment defined by bounding the number of omissions during any round , for _ any _ way of counting omissions",
    ", we proved that the consensus problem is actually equivalent to the broadcast problem .",
    "we also gave examples ( ex .",
    "[ contrex ] and ex .",
    "[ contrex - comp ] ) showing how consensus can differ from broadcast for some environments .    finally , by factoring out the broadcastability properties required to solve consensus",
    ", we think that it is possible to extend this work to other kinds of failures , such as _ byzantine _ communication faults ."
  ],
  "abstract_text": [
    "<S> we compare the solvability of the consensus and broadcast problems in synchronous communication networks in which the delivery of messages is not reliable . </S>",
    "<S> the failure model is the mobile omission faults model . during each round , </S>",
    "<S> some messages can be lost and the set of possible simultaneous losses is the same for each round . </S>",
    "<S> we investigate these problems for the first time for arbitrary sets of possible failures . </S>",
    "<S> previously , these sets were defined by bounding the numbers of failures . in this setting , we present a new necessary condition for the solvability of consensus that unifies previous impossibility results in this area . </S>",
    "<S> this condition is expressed using broadcastability properties . as a very important application , </S>",
    "<S> we show that when the sets of omissions that can occur are defined by bounding the numbers of failures , counted in _ any _ way ( locally , globally , etc . ) , then the consensus problem is actually equivalent to the broadcast problem . </S>"
  ]
}