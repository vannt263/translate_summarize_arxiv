{
  "article_text": [
    "first introduced by gallager @xcite , ldpc codes have been the focus of intense research in the past decade and many of their properties are now well - understood .",
    "the iterative decoding algorithms for ldpc codes have been analyzed in detail , and asymptotic performance results have been derived @xcite",
    ". however , estimation of frame - error - rate ( fer ) for iterative decoding of finite - length ldpc codes is still an unsolved problem .",
    "a special case of interest is the performance of iterative decoding at high signal - to - noise ratio ( snr ) . at high snrs ,",
    "a sudden degradation in the performance of iterative decoders has been observed @xcite,@xcite .",
    "this abrupt change manifested in the fer curve is termed as an `` error - floor . ''",
    "the error - floor problem is well - understood for iterative decoding over the binary erasure channel ( bec ) @xcite .",
    "combinatorial structures called `` stopping sets '' were used to characterize the fer for iterative decoding of ldpc codes over the bec .",
    "it was established that decoding failure occurs whenever all the variables belonging to stopping sets are erased .",
    "@xcite used this fact to construct irregular ldpc codes which avoid small stopping sets thus improving the guaranteed erasure recovery capability of codes under iterative decoding , and hence improving the error - floors . as in the case of bec , a strong connection has been found between the existence of low - weight uncorrectable error patterns and error - floors for additive white gaussian noise ( awgn ) channels and binary symmetric channels ( bsc ) ( see @xcite and @xcite ) .",
    "hence , studying the guaranteed error correction capability of codes under iterative decoding is important in the context of characterization and improvement of the performance of iterative decoding strategies .    in the past",
    ", guaranteed error correction has been approached from the perspective of the decoding algorithm as well as from the perspective of code construction .",
    "sipser and spielman @xcite used expansion arguments to derive sufficient conditions for the parallel bit - flipping algorithm to correct a fraction of errors in codes with column - weight greater than four .",
    "burshtein @xcite proved that for large enough lengths , almost all codes with column - weights greater than or equal to four can correct a certain fraction of errors under the bit - flipping algorithm .",
    "burshtein and miller @xcite derived the sufficient conditions for message - passing decoding to correct a fraction of errors for codes of column - weight greater than five .",
    "however , these proofs were not constructive , i.e. , no explicit code construction which satisfied the sufficient conditions was provided .",
    "moreover , the code - lengths required to guarantee the correction of a small number of errors ( say @xmath0 ) is very high .",
    "also , these arguments can not be extended for message - passing decoding of codes with column - weight three or four .    in order to construct codes with good error correcting properties under iterative decoding , progressive edge growth ( peg ) @xcite and constructions based on finite geometries",
    "@xcite have been used .",
    "however , codes constructed from finite geometries typically have very high column - weight .",
    "although , it has been proved that minimum distance grows at least linearly for codes constructed using peg , no results proving guaranteed error correction under iterative decoding exist for these codes .    in this work ,",
    "we derive necessary and sufficient conditions for the correction of three errors in a column - weight - three code under the hard - decision message - passing algorithm .",
    "we provide a modified peg construction which yields codes with such an error - correction capability . also , we derive the necessary and sufficient conditions for the correction of three errors in four iterations for the case of codes with column - weight four .",
    "again , we provide a modified peg construction which yields codes with such error - correction capability .",
    "the remainder of the paper is organized as follows : we establish the preliminaries of the work in section [ section2 ] .",
    "the necessary and sufficient conditions for the correction of three errors in column - weight - three codes are derived in section [ section3 ] .",
    "the case of column - weight - four codes is dealt with in section [ section4 ] . in section [ section5 ] ,",
    "we describe a technique to construct codes satisfying the conditions of the theorems and provide numerical results .",
    "we conclude with a few remarks in section [ section6 ] .",
    "in this section , we first describe the tanner graph representation of ldpc codes .",
    "then , we establish the notation that will be used throughout this paper .",
    "finally , we describe the hard - decision message - passing algorithm that will be used for decoding .",
    "the tanner graph of an ldpc code , @xmath1 , is a bipartite graph with two sets of nodes : @xmath2 , the variable ( bit ) nodes and @xmath3 , the check ( constraint ) nodes .",
    "every edge @xmath4 in the bipartite graph is associated with a variable node @xmath5 and a check node @xmath6 .",
    "the check nodes ( variable nodes , respectively ) connected to a variable node ( check node , respectively ) are referred to as its neighbors .",
    "the degree of a node is the number of its neighbors . in a @xmath7-regular ldpc code , each variable node has degree @xmath8 and each check node has degree @xmath9 .",
    "the girth @xmath10 is the length of the shortest cycle in @xmath11 .",
    "let @xmath12 such that @xmath13 .",
    "if for all choices of @xmath14 , there are at least @xmath15 neighbors of @xmath14 in @xmath3 , then we say that the @xmath16 condition is satisfied . in this paper",
    ", @xmath17 represents a variable node , @xmath18 represents an even - degree check node and @xmath19 represents an odd - degree check node .",
    "let @xmath20 $ ] , a binary @xmath21-tuple , be the input to the message - passing decoder .",
    "let @xmath22 be a variable node with @xmath23 as its corresponding bit and @xmath24 be a check node neighboring @xmath5 .",
    "let vcj denote the message that @xmath5 sends to @xmath6 in the first half of the @xmath25 iteration and cvj denote the message that @xmath6 sends to @xmath5 in the second half of the @xmath25 iteration    additionally , let v : j be the set of all messages from a variable @xmath5 to all its neighboring checks in the first half of the @xmath25 iteration .",
    "let v:\\cj be the set of all messages that a variable node @xmath5 sends to all its neighboring checks except @xmath6 in the first half of the @xmath25 iteration .",
    "let @xmath26 be the set of all messages received by @xmath5 from all its neighboring in the second half of the @xmath25 iteration .",
    "let @xmath27 be the set of all messages received by @xmath5 from all its neighboring check nodes except @xmath6 in the second half of the @xmath25 iteration .",
    "c : j , c:\\vj , @xmath28 and @xmath29 are defined similarly .",
    "the gallager algorithms @xcite can be defined as follows : the forward messages , vcj ( from variables to checks ) , are defined as @xmath30 where @xmath31 refers to the total number of messages which are of the value @xmath32 .",
    "the backward messages , cvj ( from checks to variables ) , are defined as @xmath33    at the end of each iteration , an estimate of each variable node is made based on the incoming messages and possibly the received value .",
    "the decoder is run until a valid codeword is found or until a maximum number of iterations , say @xmath34 , is reached , whichever is earlier .    in eqn .",
    "( [ equation : forward ] ) , @xmath35 is a threshold which is generally a function of the iteration number , @xmath36 , and the degree of the variable @xmath5 . in this paper , we use @xmath37 for all @xmath5 and @xmath36 for decoding column - weight - three codes . for column - weight - four codes",
    ", we use @xmath38 for all @xmath5 when @xmath39 and @xmath37 for all @xmath5 when @xmath40 .    _ remark : _ we note that eqns .",
    "[ equation : forward ] and [ equation : backward ] then correspond to the gallager - b algorithm @xcite . for the gallager - a algorithm @xcite , @xmath41 , for all @xmath36 , where @xmath42 is degree of variable node @xmath5 .",
    "+ _ a note on the decision rule : _ different rules to estimate a variable node after each iteration are available , and it is likely that changing the rule after certain number of iterations may be beneficial . however , the analysis of such scenarios is beyond the scope of this paper . throughout the paper ,",
    "we use the following decision rule : if all incoming messages to a variable node from neighboring checks are equal , set the variable node to that value ; else set it to its received value .",
    "we discuss briefly the concept of trapping sets .",
    "consider an ldpc code of length @xmath21 .",
    "let @xmath43 be the binary vector which is the input to the hard - decision decoder .",
    "for output symmetric channels , without loss of generality , we can assume that the all - zero - codeword is transmitted .",
    "we make this assumption throughout this paper .",
    "the support of a vector @xmath43 denoted by @xmath44 is defined as the set of all positions @xmath45 where @xmath46 .",
    "for each @xmath47 , @xmath48 , let @xmath49 be the codeword estimate of the decoder at the end of the @xmath50 iteration .",
    "a variable node @xmath5 is said to be _ eventually correct _ if there exists a positive integer @xmath51 such that for all @xmath52 , @xmath5 does not belong to @xmath53 .",
    "@xcite a decoding failure is said to have occurred if there does not exist @xmath54 such that @xmath55    @xcite let @xmath56 denote the set of variable nodes that are not eventually correct . if @xmath56 is not empty , let @xmath57 and @xmath58 be the number of odd - degree check nodes in the subgraph induced by @xmath56 .",
    "we say that @xmath56 is an @xmath59 trapping set .",
    "let @xmath60 be a trapping set and let @xmath61 .",
    "the critical number @xmath62 of trapping set @xmath60 is the minimum number of variable nodes that have to be initially in error for the decoder to end up in the trapping set @xmath60 .",
    "that is , @xmath63 .",
    "@xcite let @xmath60 be a trapping set .",
    "if @xmath64 , then @xmath44 is a failure set of @xmath60 .    for transmission over the bsc , @xmath43 is a fixed point of the decoding algorithm if @xmath65 for all @xmath47 .",
    "it follows that for transmission over the bsc , if @xmath43 is a fixed point , then @xmath66 is a trapping set .",
    "now , we have the following theorem which provides the sufficient condition for a set of variables to be a trapping set :    [ thm1]@xcite let @xmath1 be the tanner graph of a column - weight - three code .",
    "let @xmath67 , be a set consisting of @xmath5 variable nodes with induced subgraph @xmath68 .",
    "let the checks in @xmath68 be partitioned into two disjoint subsets , namely , @xmath69 consisting of checks with odd degree and @xmath70 consisting of checks with even degree .",
    "if ( a ) every variable node in @xmath68 is connected to at least two checks in @xmath70 and at most one check in @xmath69 and ( b ) no two checks of @xmath69 are connected to the same variable node outside @xmath68 , then @xmath60 is a trapping set .",
    "see @xcite .",
    "in this section , we establish necessary and sufficient conditions for a column - weight - three code to correct three errors .",
    "we first illustrate three trapping sets and show that the critical number of these trapping sets is three thereby providing necessary conditions to correct three errors .",
    "we then prove that avoiding structures isomorphic to these trapping sets in the tanner graph is sufficient to guarantee correction of three errors .",
    "[ trappingsets ] shows three subgraphs induced by different numbers of variable nodes .",
    "let us assume that in all these induced graphs , no two odd degree checks are connected to the same variable node outside the graph . by the conditions of theorem [ thm1 ] , all these induced subgraphs are trapping sets . fig .",
    "[ sixcycle ] is a @xmath71 trapping set , fig .",
    "[ 53trappingset ] is a @xmath72 trapping set and fig .",
    "[ weight8codeword ] is a @xmath73 trapping set .",
    "note that a @xmath71 trapping set is isomorphic to a six - cycle and the @xmath73 trapping set is a codeword of weight eight .",
    "we now have the following result :    [ sixcycle ] [ 53trappingset ] [ weight8codeword ]    the critical number for a @xmath71 trapping set which is also a fixed point is at most three . there",
    "exist ( 5,3 ) and ( 8,0 ) trapping sets with critical number three and no ( 5,3 ) or ( 8,0 ) trapping sets with critical number less than three .",
    "[ vc1 ]   [ cv1 ]   [ vc2 ]   [ cv2 ]     the proof for @xmath71 case is trivial .",
    "we prove the lemma for the case of @xmath72 trapping sets and omit the proof for @xmath73 trapping sets .",
    "consider the @xmath74 trapping set shown in fig .",
    "[ messagepassing ] .",
    "let @xmath75 be the set of variables which are initially in error .",
    "let @xmath76 and @xmath77 .",
    "also , assume that no variable node in @xmath78 , has two or more neighbors in @xmath79 . in the first iteration , we have : @xmath80 consequently , all variable nodes in @xmath81 are decoded incorrectly at the end of the first iteration . in the second iteration : @xmath82 and all variable nodes in @xmath83 are decoded incorrectly . continuing in this fashion , @xmath84 and @xmath85",
    "that is , the messages being passed in the tanner graph would repeat after every two iterations .",
    "hence , three variable nodes in error initially can lead to a decoder failure and therefore , this @xmath74 trapping set has critical number equal to three .    to guarantee that three errors in a column - weight - three ldpc code can be corrected by the gallager - a algorithm , it is necessary to avoid @xmath71 , @xmath72 and @xmath73 trapping sets in its tanner graph .",
    "follows from the discussion above .",
    "we now state and prove the main theorem .",
    "if the tanner graph of a column - weight - three ldpc codes has girth eight and does not contain a subgraph isomorphic to a @xmath72 trapping set or a subgraph isomorphic to an @xmath73 trapping set , then any three errors can be corrected using the gallager - a algorithm .",
    "let @xmath86 be the three erroneous variables and @xmath79 be the set of the checks connected to the variables in @xmath83 . in a column - weight - three code ( free of cycles of length four )",
    "the variables in @xmath83 can induce only one of the five subgraphs given in fig .",
    "[ errorconfigs ] . in each case , @xmath87 if @xmath88 and is @xmath89 otherwise .",
    "the proof proceeds by examining these subgraphs one at a time and proving the correction of the three erroneous variables in each case .",
    "[ config1 ]   [ config2 ]   [ config3 ]   [ config4 ]   [ config5 ]     * subgraph 1 : * since the girth of the code is eight , it has no six cycles .",
    "hence , the configuration in fig . [ config1 ] is not possible .",
    "* subgraph 2 : * the variables in @xmath83 induce the subgraph shown in fig .",
    "[ config2 ] . at the end of the first iteration : @xmath90 there can not exist a variable node which is connected to two or more checks in the set @xmath79 without introducing either a six - cycle or a subgraph isomorphic to @xmath72 trapping set .",
    "at the end of first iteration , @xmath91 for all @xmath88 .",
    "furthermore , there exists no @xmath92 for which @xmath93 .",
    "hence , if a decision is made after the first iteration , a valid codeword is found and the decoder is successful .    *",
    "subgraph 3 : * the variables in @xmath83 induce the subgraph shown in fig .",
    "[ config3 ] . at the end of the first iteration : @xmath94 for no @xmath92 , @xmath93 as this would introduce a four - cycle or a six - cycle in the graph . for any @xmath92 ,",
    "@xmath95 only if @xmath96 .",
    "this implies that @xmath5 has two checks in @xmath97 .",
    "let @xmath81 be the set of such variables .",
    "we have the following lemma :    there can be at most one variable in @xmath81 .",
    "suppose @xmath98 .",
    "specifically , assume @xmath99 .",
    "the proof is similar for @xmath100 .",
    "first note that for any @xmath101 , @xmath5 can not be connected to c14 as it would create a six - cycle .",
    "next , let @xmath102 and @xmath103 . then , @xmath5 can not have both checks in either c11 or c12 as this would cause a four - cycle .",
    "hence , @xmath5 has one check in c11 and one check in c12 .",
    "assume without loss of generality that v21 is connected to c11 and c16 .",
    "then , v22 can not be connected to c11 and c17 as this would form a six - cycle .",
    "v22 can not be connected to c12 and c17 as it would create a @xmath74 trapping set .",
    "hence , @xmath104 .",
    "let @xmath105 be connected to c11 , c16 and an additional check c21 . in the second iteration",
    ": @xmath106 we have the following lemma :    [ lemma3:twoincorrectmessages ] there can not exist any variable @xmath107 such that it receives two or more incorrect messages at the end of the second iteration .",
    "suppose there existed a variable @xmath5 such that it received two incorrect messages in the second iteration .",
    "then , it would be connected to two checks in the set @xmath108 .",
    "this is not possible as it would introduce a four - cycle , six - cycle or a @xmath74 trapping set ( _ e.g. _ if @xmath5 is connected to c14 and c21 , it would form a @xmath74 trapping set ) .",
    "thus , in the third iteration : @xmath109 at the end of the third iteration , @xmath110 for all @xmath88 . also , we have the following lemma :    there exists no @xmath92 such that @xmath111 .",
    "suppose there exists @xmath5 such that @xmath111 .",
    "then , @xmath5 is connected to three checks in the set @xmath112 .",
    "this implies that @xmath113 .",
    "however , from lemma [ lemma3:twoincorrectmessages ] it is evident that no such @xmath5 exists .",
    "hence , if a decision is made after the third iteration , a valid codeword is found and the decoder is successful .    *",
    "subgraph 4 : * the variables in @xmath83 induce the subgraph shown in fig .",
    "[ config4 ] . at the end of the first iteration : @xmath114 for no @xmath115 , @xmath113 . for any @xmath115 ,",
    "@xmath95 only if @xmath96 .",
    "let @xmath81 be the set of all such variables .",
    "we have the following lemma :    \\(i ) @xmath81 has at most four variables , and ( ii ) no two variables in @xmath81 can share a check in @xmath116 .",
    "_ sketch of the proof _ : there exists no variable which is connected to two checks from the set @xmath117 as it would introduce a four - cycle or a six - cycle .",
    "however , a variable node can be connected to one check from @xmath118 and to one check from @xmath119 .",
    "there can be at most four such variable nodes .",
    "when four such variable nodes exist , none are connected to c13 .",
    "also , these four variable nodes can not share checks outside the set @xmath120 .",
    "let these four variable nodes be labeled v21 , v22 , v23 and v24 and their third checks c21 , c22 , c23 and c24 , respectively .",
    "let @xmath121 .",
    "hence , in the second iteration : @xmath122 at the end of the second iteration @xmath123 for all @xmath88 . moreover , for no @xmath92 , @xmath113 .",
    "so , if a decision is made after the second iteration , a valid codeword is reached and the decoder is successful .",
    "* subgraph 5 : * the variables in @xmath83 induce the subgraph shown in fig .",
    "[ config5 ] . at the end of the first iteration : @xmath124 if there exists no variable @xmath115 such that @xmath93 , a valid codeword is reached after the first iteration .",
    "suppose this is not the case .",
    "let @xmath81 be the set of variables which receive two or more incorrect messages .",
    "then , we have the following lemma :    \\(i ) there exists one variable @xmath105 such that @xmath125 , and ( ii ) @xmath81 has at most three variables which receive two incorrect messages at the end of the first iteration",
    ". furthermore , they can not share a check in @xmath116 .",
    "we omit the proof of part ( ii ) as it is straightforward . part ( i )",
    "is proved as follows : if there existed no variable , v21 , such that @xmath125 , then the decoder would converge in one iteration .",
    "next , suppose @xmath126 such that @xmath127 .",
    "without loss of generality , let v21 be connected to @xmath128 and @xmath129 .",
    "then , v21 would share two checks in the set @xmath79 .",
    "it is thennot possible to connect v22 without introducing a six - cycle or a @xmath74 trapping set ( _ e.g. _ , if v21 is connected to c12 , c15 and c18 , then it would introduce a @xmath74 trapping set ) .",
    "let the third checks connected to v22 , v23 and v24 be c21 , c22 and c23 , respectively and let @xmath130 in the second iteration : @xmath131 there can not exist a variable node which is connected to one check from @xmath132 and to one check from @xmath133 .",
    "also , there can not be a variable node which is connected to all three checks in the set @xmath132 as this would introduce a graph isomorphic to the @xmath73 trapping set .",
    "however , there can be at most two variable nodes which receive two incorrect messages from the checks in @xmath132 , say v31 and v32 .",
    "let the third checks connected to them be c31 and c32 , respectively .",
    "let @xmath134 and @xmath135 . at the end of the second iteration",
    ", variables v11 , v12 and v13 receive one incorrect message each .",
    "variables in the set @xmath136 receive two incorrect messages each .",
    "therefore , in the third iteration , we have : @xmath137 at the end of the third iteration , @xmath111 for all @xmath88 .",
    "furthermore , for no @xmath92 , @xmath111 .",
    "so , if a decision is made after the third iteration , a valid codeword is reached and the decoder is successful .",
    "in this section , we derive necessary and sufficient conditions for the correction of three errors in column - weight - four codes in four iterations of iterative decoding .",
    "this result is inspired by the analysis of error events in high - rate codes with column - weight four . in simulations , it was found that received vectors which did not converge to a valid codeword in the first 4 to 5 iterations did not converge thenceforth .",
    "hence , it is desirable to devise codes and decoding strategies in which vectors having a small number of errors converged rapidly to a codeword . to this end",
    ", it was found that a hybrid decoding strategy could correct three errors in four iterations if certain conditions are satisfied by the code .",
    "this result is summarized as follows :    [ theorem:4:1 ] an ldpc code with column - weight four and girth six can correct three errors in four iterations of message - passing decoding if and only if the conditions , @xmath138 , @xmath139 , @xmath140 , @xmath141 and @xmath142 are satisfied .    _",
    "remark : _ it is worth noting that if a graph of girth six satisfies the @xmath138 condition , then it satisfies the @xmath139 condition as well .",
    "however , the addition of this extra constraint aids in the proof of the theorem .",
    "first , we prove the sufficiency of the conditions of theorem [ theorem:4:1 ] .",
    "let @xmath86 be the three erroneous variables .",
    "let @xmath79 be the set of checks that are connected to the variables in @xmath83 .",
    "the variables in @xmath83 can induce only one of the five subgraphs shown in fig .",
    "[ figure4 ] .",
    "we prove that in each case , the decoding algorithm converges to the correct codeword in four iterations .",
    "+   +    * subgraph 1 * : the variables in @xmath83 induce the subgraph shown in fig . [ figure4a ] . at the end of the first iteration , @xmath91 for all @xmath88 .",
    "moreover , no variable receives four incorrect messages after the first iteration as the existence of such a variable node would create a four - cycle .",
    "if a decision is made after the first iteration , the decoder is successful .",
    "* subgraph 2 * : the variables in @xmath83 induce the subgraph shown in fig .",
    "[ figure4b ] . at the end of the first iteration : @xmath143 for no @xmath115 , @xmath93 as it would introduce a four - cycle . for any @xmath92 ,",
    "@xmath95 only if @xmath96 .",
    "this implies that @xmath5 is connected to three checks in @xmath144 .",
    "let @xmath81 denote the set of such variables .",
    "we have the following lemma :    there can be at most three variables in @xmath81 .",
    "furthermore , no two variable nodes in @xmath81 share any check in the set @xmath116 .",
    "let @xmath145 .",
    "then the set of variable nodes @xmath146 has at most 15 neighboring checks .",
    "this violates the @xmath141 condition .",
    "hence , @xmath81 can have at most three variables .",
    "next , let @xmath126 .",
    "suppose they share a fourth check @xmath6 .",
    "since v13 can share at most two checks with v21 and v22 , assume that c110 and c111 are not neighbors of v21 , v22 .",
    "the neighbors of the variable nodes in the set @xmath147 all belong to the set @xmath148 which has cardinality 10 , thus violating the @xmath138 condition .",
    "let the fourth neighboring checks of v21 , v22 and v23 be c21 , c22 and c23 , respectively .",
    "let @xmath149 . in the second iteration",
    ": @xmath150 for all @xmath88 , @xmath123 . for no @xmath101 , @xmath113 .",
    "we now have the following lemma :    there exists no variable @xmath107 such that @xmath113 .",
    "the proof is by contradiction .",
    "let @xmath107 such that @xmath113 .",
    "then , @xmath5 is connected to four checks in @xmath151 .",
    "note that only two neighbors of @xmath5 can belong to @xmath152 without introducing a four - cycle .",
    "this combined with the fact that there are at most three variable nodes in @xmath81 implies that there are only two cases : + ( a ) @xmath5 has two neighbors in @xmath152 and two neighbors in @xmath132 , say c21 and c22 . in this case",
    ", the set of variable nodes @xmath153 has @xmath154 check nodes , violating the @xmath140 condition .",
    "\\(b ) @xmath5 has one neighbor in @xmath152 and three neighbors in @xmath132 .",
    "in this case , the set of variable nodes @xmath155 has @xmath156 check nodes , violating the @xmath141 condition .    hence",
    ", if a decision is made after the second iteration , the decoder is successful .",
    "* subgraph 3 * : the variables in @xmath83 induce the subgraph shown in fig .",
    "[ figure4c ] . at the end of the first iteration , v11 , v12 and v13",
    "receive correct messages from all their neighboring check nodes",
    ". moreover , there exists no variable which receives four incorrect messages from checks in the set @xmath79 .",
    "hence , if a decision is made after the first iteration , the decoder is successful .",
    "* subgraph 4 * : the variables in @xmath83 induce the subgraph shown in fig .",
    "[ figure4d ] . at the end of the first iteration : @xmath157 for no @xmath115 , @xmath93 as it this would introduce a four - cycle .",
    "for any @xmath115 , @xmath95 only if @xmath96 .",
    "this implies that @xmath5 has three checks in the set @xmath158 .",
    "let @xmath81 be the set of such variables .",
    "we now have the following lemma :    there can be at most two variables in @xmath81 .",
    "moreover , there exists no check @xmath159 which is shared by two variables in the set @xmath81 .",
    "let @xmath160 .",
    "then , the set @xmath161 has at most @xmath154 checks which violates the @xmath162 condition .",
    "hence , @xmath81 has at most two variables .    next , let two variables @xmath126 share a check @xmath159 . then , the set @xmath163 has at most 11 checks which violates the @xmath139 condition .",
    "let @xmath132 be the set of checks @xmath116 which are connected to variables in @xmath81 .",
    "in the second iteration we have : @xmath164 for no @xmath115 , @xmath113 , for such a structure can not exist without creating a four - cycle or violating one of @xmath139 and @xmath140 conditions . for any @xmath165 , @xmath166 only if @xmath167 .",
    "this implies that @xmath5 has three neighbors in the set @xmath168 .",
    "let @xmath136 be the set of such variables .",
    "we have the following lemma :    for the sets @xmath81 and @xmath136 , the following are true : + ( i ) if @xmath169 , then @xmath136 is empty .",
    "+ ( ii ) if @xmath170 , then @xmath171 . + ( iii ) @xmath172 .",
    "we prove the lemma part by part .",
    "+ ( i ) suppose @xmath169 and that @xmath136 is not empty .",
    "let @xmath173 .",
    "then , the set @xmath174 is of size 6 and has at most @xmath154 checks which violates the @xmath140 condition .",
    "+ ( ii ) suppose @xmath170 .",
    "let @xmath173 .",
    "if @xmath81 is empty , then v31 is connected to three checks in @xmath79 .",
    "this is not possible as @xmath175 .",
    "next , suppose that @xmath98 .",
    "let @xmath126 .",
    "then @xmath176 has at most @xmath154 checks which violates the @xmath140 condition .",
    "+ ( iii ) suppose @xmath177 . by ( ii ) , there exists a variable @xmath105 .",
    "then , @xmath178 has at most @xmath154 checks which violates the @xmath140 condition .",
    "suppose @xmath179 .",
    "denote the fourth check of @xmath180 by @xmath181 .",
    "then , we have at the beginning of the third iteration : @xmath182 at the end of the fourth iteration , @xmath110 for @xmath88 . thus ,",
    "if a decision is made at the end of this iteration , all @xmath88 are decoded correctly .",
    "now we prove the following lemma :    there exists no @xmath183 such that @xmath111 .",
    "suppose that @xmath136 is empty and that there exists a variable @xmath5 such that @xmath111 .",
    "if @xmath81 is empty , then , @xmath5 is connected to four checks in @xmath184 .",
    "this is not possible as it would cause a four - cycle .",
    "if @xmath81 is not empty , then @xmath5 is connected to four checks in @xmath185 .",
    "then , we would have @xmath113 . however , from above , no such variable exists .    next , suppose that @xmath186 and that @xmath187 . then",
    ", c31 is the only check such that @xmath188 and @xmath189 .",
    "it follows then that for any @xmath115 , if @xmath111 , then @xmath5 is connected to c31 . also , it is connected to three checks in the set @xmath190 .",
    "then the set of variables @xmath191 has at most @xmath192 checks .",
    "this violates the @xmath140 condition .",
    "hence , if a decision is made after the third iteration , the decoder is successful .",
    "* subgraph 5 * : the variables in @xmath83 induce the subgraph shown in fig . [ figure4e ] .",
    "for all @xmath88 , @xmath193 .",
    "there exist no @xmath115 that receive three incorrect messages , for the existence of such a variable would violate the @xmath138 condition .",
    "hence , for all @xmath115 , @xmath194 .",
    "let @xmath81 be the set of variables that have two checks in the set @xmath195 .",
    "let @xmath132 be the remaining two checks of these variables .",
    "at the beginning of the fourth iteration , the decoder switches to the gallager - b mode . then : @xmath196 at the end of the fourth iteration , @xmath197 for @xmath88 .",
    "moreover , for no @xmath115 , @xmath198 , as the existence of such a variable would either induce a four - cycle or violate one of the @xmath139 , @xmath140 , @xmath141 or @xmath142 conditions ( the arguments used are similar to the ones used for subgraph 2 and subgraph 4 ) . hence ,",
    "if a decision is made at the end of the fourth iteration , the decoder is successful .",
    "now we prove the necessity of the conditions of the theorem .",
    "we prove this by giving subgraphs which violate _ one _ condition and are not successfully decoded in four iterations .",
    "since the validity of these claims can be checked easily , a detailed proof is omitted .",
    "* necessity of the @xmath199 condition *    consider the subgraph shown in fig .",
    "[ figure4_10_subgraph ] . in this case",
    ", the @xmath138 condition is not satisfied and the errors are not corrected at the end of the fourth iteration .",
    "hence , in order to guarantee the correction of three errors in four iterations , the @xmath138 condition must be satisfied .",
    "subgraph[figure4_10_subgraph],scaledwidth=50.0% ]    * necessity of the @xmath200 condition *    there exists no graph of girth six which satisfies the @xmath138 condition but does not satisfy the @xmath139 condition .",
    "* necessity of the @xmath201 condition *    consider the graph shown in fig .",
    "[ figure6_13_subgraph ] . the graph shown satisfies the @xmath138 and the @xmath139 conditions but not the @xmath140 condition .",
    "the errors are not corrected in four iterations .",
    "hence , in order to guarantee the correction of three errors in four iterations , the @xmath140 condition must be satisfied .",
    "subgraph[figure6_13_subgraph],scaledwidth=50.0% ]    * necessity of the @xmath202 condition *    consider the graph shown in fig . [ figure7_15_subgraph ] . the graph shown satisfies the probability @xmath138 , @xmath139 and the @xmath140 conditions but not the @xmath141 condition .",
    "the errors are not corrected at the end of the fourth iteration .",
    "hence , in order to guarantee the correction three errors in four iterations , the @xmath141 condition must be satisfied .",
    "subgraph[figure7_15_subgraph],scaledwidth=50.0% ]    * necessity of the @xmath203 condition *    consider the graph shown in fig .",
    "[ figure8_17_subgraph ] . the graph shown satisfies the @xmath138 , @xmath139 , @xmath140 and the @xmath141 condition but not the @xmath142 condition .",
    "the errors are not corrected at the end of the fourth iteration . hence , in order to guarantee the correction of three errors in four iterations , the @xmath142 condition must be satisfied .",
    "subgraph[figure8_17_subgraph],scaledwidth=50.0% ]    in this section , we proved necessary and sufficient conditions to guarantee the correction of three errors in column - weight - four codes using an iterative decoding algorithm . by analyzing the messages being passed in subsequent iterations , it may be possible to get smaller bounds on the number of check nodes required in the `` small '' subgraphs",
    "however , we hypothesize that the size of subgraphs to be avoided would be larger .",
    "in this section , we describe a technique to construct codes with column - weight three and four which can correct three errors . codes capable of correcting a fixed number of errors show superior performance on the bsc at low values of transition probability @xmath204 .",
    "this is because the slope of the fer curve is related to the minimum critical number @xcite . a code which can correct @xmath45 errors has minimum critical number at least @xmath205 and the slope of the fer curve is @xmath205 .",
    "we restate the arguments from @xcite to make this connection clear .",
    "let @xmath204 be the transition probability of a bsc and @xmath206 be the number of configurations of received bits for which @xmath207 channel errors lead to codeword ( frame ) error .",
    "the frame error rate ( fer ) is given by :    @xmath208 where @xmath45 is the minimal number of channel errors that can lead to a decoding error and @xmath21 is length of the code .    on a semi - log scale",
    "the fer is given by @xmath209    for small @xmath204 , the expression above is dominated by the first two terms .",
    "that is , @xmath210    the @xmath211 vs. @xmath212 graph is close to a straight line with slope equal to @xmath213 the minimal critical number . if two codes @xmath214 and @xmath215 have minimum critical numbers @xmath216 and @xmath217 such that @xmath218 then the code @xmath214 will perform better than @xmath215 for small enough @xmath219 independent of the number of trapping sets .      from the discussion in above and in section [ section3 ] , it is clear that for a code to have an fer curve with slope at least @xmath220 , the corresponding tanner graph should not contain the trapping sets shown in fig .",
    "[ trappingsets ] as subgraphs .",
    "we now describe a method to construct such codes .",
    "the method can be seen as a modification of the peg construction technique used by hu _",
    "the algorithm is detailed below as algorithm [ algorithm:1 ] .",
    "[ algorithm:1 ]    note that checking for a graph isomorphic to @xmath73 trapping set is computationally complex .",
    "since , the peg construction empirically gives good codes , it is unlikely that it introduces a weight - eight codeword .",
    "however , once the graph is grown fully , it can be checked for the presence of weight - eight codewords and these can be removed by swapping few edges .    using the above algorithm ,",
    "a column - weight - three code with @xmath221 variable nodes and @xmath222 check nodes was constructed .",
    "the code has slight irregularity in check degree .",
    "there is one check node degree five and one check node with degree seven , but the remaining have degree six .",
    "the code has rate 0.5 . in the algorithm",
    ", we restrict maximum check degree to seven .",
    "the performance of the code on bsc is compared with the peg code of same length .",
    "the peg code is empirically the best known code at that length on awgn channel @xcite .",
    "however , it has fourteen @xmath72 trapping sets .",
    "[ pegnewvsold ] shows the performance comparison of the two codes .",
    "as can be seen , the new code performs better than the original peg code at small values of @xmath204 .",
    ", scaledwidth=60.0% ]      unlike column - weight - three codes , the construction of column - weight - four codes involves ensuring certain expansion on subsets of variable nodes .",
    "this can be done only in time which grows exponentially with the length of the code .",
    "hence , we consider the @xmath223 condition rather than the necessary and sufficient conditions discussed in section [ section4 ] . it can be shown that the @xmath223 condition is sufficient for the @xmath138 , @xmath139 , @xmath140 , @xmath141 and the @xmath142 conditions .",
    "there are only two graphs of girth @xmath224 with @xmath220 variable nodes and @xmath225 check nodes",
    "[ figure:4_11 ] shows these two graphs .",
    "avoiding these two subgraphs will ensure a code which can correct three errors .",
    "an algorithm for the construction of such codes is similar to the modified peg algorithm given in algorithm [ algorithm:1 ] .",
    "this algorithm was used to generate a code of length @xmath226 , girth @xmath224 and rate @xmath227 .",
    "the code constructed has a slight irregularity in that three check nodes have degree nine and three have degree seven .    _",
    "remark : _ for the code parameters given above , it was possible to generate a code which satisfied the @xmath223 condition . however , it might not be possible to satisfy this condition for codes with higher rate and/or shorter lengths .",
    "should such a scenario arise , the set of subgraphs to be avoided should be changed ( _ e.g. _ , to those specified in the necessary and sufficient conditions ) .",
    "however , the code construction time will be larger .",
    "hence , at the cost of code - construction time and complexity , it is possible to achieve shorter lengths and/or higher rates .",
    "[ figure:4_11_subgraph_1 ] variable nodes and @xmath225 check nodes .",
    "subgraphs with @xmath220 variable nodes and fewer than @xmath225 check nodes do not exist.[figure:4_11 ] , title=\"fig:\",scaledwidth=40.0% ] [ figure:4_11_subgraph_2 ] variable nodes and @xmath225 check nodes .",
    "subgraphs with @xmath220 variable nodes and fewer than @xmath225 check nodes do not exist.[figure:4_11 ] , title=\"fig:\",scaledwidth=40.0% ]    fig .",
    "[ figure : colwtfourplot ] shows the performance of the code under message - passing decoding .",
    "the curve on the left corresponds to four iterations of message - passing .",
    "the curve in the right corresponds to @xmath228 iterations of message - passing .    after only four iterations , errors of weight four and above",
    "were encountered which were not corrected by the message - passing decoder . however , after @xmath228 iterations , the smallest weight error pattern still remaining had a weight of @xmath229 .",
    "we note that the average slope of the fer curve is @xmath230 which is the weight of the dominant error event at these probabilities of error .",
    "this suggests that analysis over a higher number of iterations and on `` larger '' subgraph search will yield a stronger result .",
    "however , this is beyond the scope of this paper .",
    "also , it is worth noting that the conditions of theorem [ theorem:4:1 ] avoid codewords of length @xmath220 through @xmath230 which improves the minimum distance of the code .     ,",
    "in this paper , we provided a method to derive conditions that guarantee the correction of a finite number of errors by hard - decision decoding .",
    "although more involved than the expander arguments used in previous works , it results in better bounds .",
    "moreover , in contrast to previous expansion arguments , our results give rise to code - construction techniques that yield codes with guaranteed error - correction ability under message - massing decoding at _ practically feasible lengths_. this method can be applied to ( a ) provide conditions for guaranteed correction of a larger number of errors , ( b ) yield similar results for higher column - weights and/or higher girths . however",
    ", such applications would be more involved than the analysis done in this work .",
    "d.  j.  c. mackay and m.  j. postol , `` weaknesses of margulis and ramanujan  margulis low - density parity - check codes , '' in _ proc . of mfcsit2002 , galway _ , ser .",
    "electronic notes in theoretical computer science , vol .",
    "74.1em plus 0.5em minus 0.4emelsevier , 2003 .",
    "[ online ] .",
    "available : http://www.inference.phy.cam.ac.uk/mackay/abstracts/margulis.html          s.  k. chilappagari , s.  sankaranarayanan , and b.  vasic , `` error floors of ldpc codes on the binary symmetric channel , '' in _ proc . of international conference on communications _",
    ", vol .  3 , june 11 - 15 2006 , pp .",
    "10891094 .",
    "y.  kuo , s.  lin , and m.  p.  c. fossorier , `` low - density parity check codes based on finite geometries : a rediscovery and new results , '' _ ieee trans .",
    "inform . theory _",
    "47 , no .  7 , pp . 27112736 , nov .",
    "2001 .",
    "m.  ivkovic , s.  k. chilappagari , and b.  vasic , `` eliminating trapping sets in low - density parity - check codes by using tanner graph covers , '' _ ieee trans .",
    "inf . theory _ ,",
    "54 , no .  8 , pp . 37633768 , 2008 .",
    "[ online ] .",
    "available : http://dx.doi.org/10.1109/tit.2008.926319"
  ],
  "abstract_text": [
    "<S> in this paper , we give necessary and sufficient conditions for low - density parity - check ( ldpc ) codes with column - weight three to correct three errors when decoded using hard - decision message - passing decoding . </S>",
    "<S> additionally , we give necessary and sufficient conditions for column - weight - four codes to correct three errors in four iterations of hard - decision message - passing decoding . </S>",
    "<S> we then give a construction technique which results in codes satisfying these conditions . </S>",
    "<S> we also provide numerical assessment of code performance via simulation results .    </S>",
    "<S> submitted to ieee transactions on information theory , october 2008 </S>"
  ]
}