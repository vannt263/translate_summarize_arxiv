{
  "article_text": [
    "modelling discrete - continuous systems by a hybrid of a discrete transition system and continuous variables which evolve according to a set of differential equations is widely accepted in engineering . while model - checking techniques have been applied to verify safety , liveness and other temporal properties of such systems @xcite , it is also interesting to infer quantitative values for certain queries .",
    "for example , one may not only want to check that a variable of a system does not exceed a given threshold , but also to compute the maximum value of the variable over all runs , checking whether any such threshold exists .",
    "thus far , quantitative testing of hybrid systems has only been done by simulation , and hence lacks the strong guarantees which can be given by model checking . in recent years",
    ", there has been a strong interest in extending classical model - checking techniques and logics to the quantitative setting .",
    "several quantitative temporal logics have been introduced , see e.g.@xcite , together with model - checking algorithms for simple classes of systems , such as finite transition systems with discounts . still , none of those systems allowed for dynamically changing continuous variables .",
    "we present the first model - checking algorithm for a non - stochastic quantitative temporal logic on a class of hybrid systems .",
    "the logic we consider , the quantitative @xmath0-calculus @xcite , is based on a formalism first introduced in @xcite .",
    "it properly subsumes the standard @xmath0-calculus , cf.@xcite , and thus also ctl and ltl",
    ". therefore the present result , namely that it is possible to model check quantitative @xmath0-calculus on initialised linear hybrid systems , properly generalises a previous result on model checking ltl on such systems @xcite , which is one of the strongest model - checking results for hybrid systems .",
    "the restriction to initialised linear systems is made because verification of temporal properties over general hybrid systems is undecidable .",
    "this holds even for linear systems , thus one must pick an appropriate abstraction of the system . an established and very well - studied way to do",
    "this is to first approximate the continuous behaviour of the variables by linear behaviour in a finite number of intervals .",
    "this method , applied to a number of functions @xmath1 that evolve according to a set of arbitrary differential equations @xmath2 , generates a set of disjoint intervals @xmath3 with @xmath4 and a set of linear coefficients @xmath5 such that in @xmath6 it is approximately true that @xmath7 , i.e.the derivative @xmath8 .",
    "there are several ways to generate such linear approximations of solutions of differential equations and , depending on the method in question , one can obtain various kinds of error bounds for the respective classes of functions .",
    "we do not investigate these issues ( or other approximation methods ) here , but focus instead on the linear system obtained .",
    "as stated above , even simple qualitative verification problems are undecidable for general hybrid systems .",
    "this remains true even after the natural approximation by a linear system .",
    "hence , one more assumption is made , namely that if the speed of evolution of a variable changes between discrete locations then also the variable is reset on that transition . systems with this property , called _ initialised _ linear systems , are  besides o - minimal systems @xcite and their recent extensions @xcite  one of the largest classes of hybrid systems with decidable temporal logic @xcite . observe that when an arbitrary hybrid system is approximated by a linear one , one can _ try _ to directly obtain an initialised system by computing boundary values @xcite .",
    "this can be done by either assuring that discrete transitions are taken only at the borders of the intervals @xmath6 , or by taking a finer subdivision of the intervals to increase the precision of coordination between the discrete and the continuous part of the system .",
    "note that , even though this procedure has been implemented in model - checking programs , it is only a heuristic  it necessarily fails for general systems for which the model - checking problem is undecidable .",
    "the logic we study is quantitative  it allows to express properties involving suprema and infima of values of the considered variables during runs that satisfy various temporal properties , e.g.to answer `` what is the maximal temperature on a run during which a safety condition holds ? '' . to model check formulae of the quantitative @xmath0-calculus",
    ", we follow the classical parity game - based approach and adapt some of the methods developed in the qualitative case and for timed systems . to our surprise , these methods turned out not to be sufficient and did not easily generalise to the quantitative case . as we will show below , the quantitative systems we study behave in a substantially different way than their qualitative counterparts .",
    "we overcome this problem by working directly with a quantitative equivalence relation , roughly similar to the region graph for timed automata , and finally by exploiting a recent result on counter parity games .",
    "* organisation . *",
    "the organisation of this paper follows the reductions needed to model check a formula @xmath9 over a hybrid system @xmath10 . in section [ sec_hybrid ] , we introduce the necessary notation , the systems and the logic .",
    "then , we present an appropriate game model in section [ sec_ipg ] and show how to construct a model - checking game @xmath11 for the system and the formula . in section [ sec_basic ] , we transform the interval games constructed for arbitrary initialised linear hybrid systems to flat games , where the linear coefficients are always @xmath12 . in section [ sec_ds ] ,",
    "we show how the strategies can be discretised and still lead to a good approximation of the original game .",
    "finally , in section [ sec_pushdown ] , we reduce the problem to counter parity games and exploit a recent result to solve them . to sum up , the steps taken are depicted below .",
    "we denote the real and rational numbers and integers extended with both @xmath14 and @xmath15 by @xmath16 , @xmath17 and @xmath18 respectively . we write @xmath19 and @xmath20 for all open or closed intervals over @xmath16 with endpoints in @xmath21 and @xmath16 .",
    "a _ linear hybrid system over @xmath22 variables _ , @xmath23 , is based on a directed graph @xmath24 , consisting of a set of locations @xmath25 and transitions @xmath26 .",
    "the labelling function @xmath27 assigns to each transition a finite set of labels .",
    "the set @xmath28 of _ transition labels _ consists of triples @xmath29 , where the vector @xmath30 ( with @xmath31 for @xmath32 ) represents the constraints each of the variables needs to satisfy for the transition to be allowed , the interval @xmath33 represents the possible period of time that elapses before the transition is taken , and the reset set @xmath34 contains the indices of the variables that are reset during the transition , i.e.@xmath35 means that @xmath36 is set to zero . for each @xmath37 of the finite index set @xmath38",
    ", the function @xmath39 assigns to each location the value of the static quantitative predicate @xmath40 .",
    "the function @xmath41 assigns to each location and variable @xmath36 the coefficient @xmath42 such that the variable evolves in this location according to the equation @xmath43 .",
    "please note that although we do not explicitly have any invariants ( or constraints ) in locations , we can simulate them by choosing either the time intervals or variable constraints on the outgoing transitions accordingly .",
    "if the values of predicates and labels range over @xmath17 or @xmath18 instead of @xmath16 , we talk about linear hybrid systems over @xmath44 and @xmath45 , respectively .",
    "the _ state _ of a linear hybrid system @xmath10 is a location combined with a valuation of all @xmath22 variables , @xmath46 . for a state @xmath47",
    "we say that a transition @xmath48 is _ allowed _ by a label @xmath49 if @xmath50 ( i.e.if @xmath51 for all @xmath52 ) .",
    "we say that a state @xmath53 is a successor of @xmath54 , denoted @xmath55 , when there is a transition @xmath56 , allowed by label @xmath57 , such that @xmath58 for all @xmath35 and there is a @xmath59 such that @xmath60 where @xmath61 for all @xmath62",
    ". a run of a linear hybrid system starting from location @xmath63 is a sequence of states @xmath64 such that @xmath65 and @xmath66 for all @xmath37 . given two states @xmath54 and @xmath55 and a reset set @xmath67 we denote by @xmath68 the increase of the non - reset variables that occurred during the transition , i.e.@xmath69 for some @xmath70 where @xmath71 and @xmath72 .",
    "a linear hybrid system @xmath10 is _ initialised _ if for each @xmath73 and each variable @xmath36 it holds that if @xmath74 then @xmath35 for @xmath75 .",
    "intuitively , an initialised system can not store the value of a variable whose evolution rate changes from one location to another .    to clarify the notions we use , we consider a variant of a standard example for a linear hybrid system , the leaking gas burner .",
    "\\(a ) at ( -2 , 0 ) @xmath63 ; ( ) at ( -2 , 0.75 ) ; ( ) at ( -2.5 , -0.75 ) _ _ ; ( b ) at ( 2 , 0 ) @xmath76 ; ( ) at ( 2 , 0.75 ) ;    ( ) at ( 2.5 , -0.75 ) _ _ ; ( a ) edge[bend right,- > ] node[above ] node[below ] ( b ) ; ( b ) edge[bend right,- > ] node[below ] node[above ] ( a ) ;    our version is depicted in figure [ leaking - not - in ] .",
    "this system represents a gas valve that can leak gas to a burner , so it has two states : @xmath63 , where the valve is open ( and leaking gas ) and @xmath76 where it is closed .",
    "this is also indicated by a qualitative predicate @xmath77 that has the value @xmath14 if the gas is leaking ( in location @xmath63 ) and @xmath15 otherwise .",
    "the system has two variables .",
    "the first variable , @xmath78 , is a clock measuring the time spent in each location , and is reset on each transition , i.e.after each discrete system change .",
    "the variable @xmath79 is a stop watch and measures the total time spent in the leaking location .",
    "thus , this system is not initialised .",
    "the time intervals on the transitions control the behaviour of the system . on the transition",
    "@xmath80 there are no restrictions on the variables , but we are only allowed to choose a time unit from @xmath81 $ ] , i.e.we can stay a maximum of one time unit in location @xmath63 . on the transition",
    "@xmath82 there is a restriction on the value of @xmath78 , it has to have a value between 30 and 40 for this transition to be allowed , while there is no restriction on the choice for the time unit ( of course , this could also be modelled the other way around ) .",
    "intuitively , the time intervals indicate that the gas valve will leak gas for a time interval between 0 and 1 seconds and then be stopped and that it can only leak again after at least 30 time units .",
    "+ in figure [ leaking ] , we show an initialised version of the leaking gas burner .",
    "the only difference is that @xmath79 is not a stop watch anymore but a normal clock .",
    "since now both variables are just clocks ( which means that their evolution rates are one everywhere ) , the system is trivially initialised .",
    "\\(a ) at ( -2 , 0 ) @xmath63 ; ( ) at ( -2 , 0.75 ) ; ( ) at ( -2.5 , -0.75 ) _ _ ; ( b ) at ( 2 , 0 ) @xmath76 ; ( ) at ( 2 , 0.75 ) ; ( ) at ( 2.5 , -0.75 ) _ _ ; ( a ) edge[bend right,- > ] node[above ] node[below ] ( b ) ; ( b ) edge[bend right,- > ] node[below ] node[above ] ( a ) ;      in this section , we present a version of the quantitative @xmath0-calculus first introduced in @xcite .",
    "the version we use here is additive and includes variables .",
    "it is evaluated on linear hybrid systems .",
    "given sets of fixpoint variables @xmath83 , system variables @xmath84 and predicates @xmath85 , the formulae of the _ quantitative @xmath0-calculus(@xmath86 ) with variables",
    "_ are given by the ebnf grammar : @xmath87 where @xmath88 , and in the cases @xmath89 and @xmath90 , the variable @xmath91 must appear positively in @xmath9 , i.e.under an even number of negations .",
    "let @xmath92 . given an interpretation @xmath93 , a variable @xmath94 , and a function @xmath95 , we denote by @xmath96 $ ] the interpretation @xmath97 , such that @xmath98 and @xmath99 for all @xmath100 .    given a linear hybrid system @xmath101 and an interpretation @xmath102 , a @xmath103-formula yields a valuation function @xmath104 defined in the following standard way for a state @xmath105 .",
    "@xmath106    @xmath107 , @xmath108 , and @xmath109 , @xmath110    @xmath111 and @xmath112 ,    @xmath113 and @xmath114 ,    @xmath115}^{\\calk } } } \\}$ ] , + @xmath116}^{\\calk } } } \\}$ ] .    for formulae without free variables we write",
    "@xmath117 rather than @xmath118",
    ".    please note that the inclusion of variables does not fundamentally change the semantics of quantitative @xmath0-calculus .",
    "the quantitative @xmath0-calculusin @xcite is evaluated on quantitative transition systems . here",
    ", a formula is evaluated on the state graph of a linear hybrid system , rather than the system itself .",
    "intuitively , a linear hybrid system is a compact representation of an infinite quantitative transition system ( its state graph ) .",
    "thus , many properties of the quantitative @xmath0-calculusfrom @xcite remain true .",
    "for example , to embed the classical @xmath0-calculus in quantitative @xmath0-calculusone must interpret _ true _ as @xmath119 and _ false _ as @xmath15 .",
    "the formula @xmath120 evaluates to the supremum of the values of @xmath79 on all runs from some initial state : e.g. to @xmath14 if evaluated on the simple initialised leaking gas burner model . to determine the longest period of time during which the gas is leaking we use the formula @xmath121 , which evaluates to @xmath12 on the initial state @xmath122 in our example .",
    "the remainder of this paper is dedicated to the proof of our following main result which shows that @xmath117 can be approximated with arbitrary precision on initialised linear hybrid systems .",
    "[ mainthm ] given an initialised linear hybrid system @xmath10 , a quantitative @xmath0-calculusformula @xmath9 and an integer @xmath123 , it is decidable whether @xmath124 , @xmath125 , or else a number @xmath126 can be computed such that @xmath127 .    in other words , for every @xmath128 we can approximate @xmath117 within @xmath128 .",
    "we formulated the theorem above using @xmath129 because it makes the representation of @xmath128 precise , so we can provide a complexity bound : given on input the system @xmath10 , the formula @xmath9 and @xmath129 , we will show how to compute the number @xmath130 ( or output @xmath131 ) in 8exptime .",
    "in this section , we define a variant of quantitative parity games suited for model checking @xmath86on linear hybrid systems .",
    "as mentioned above , a linear hybrid system can be seen as a compact representation of an infinite quantitative transition system .",
    "similarly , a parity game that is played on a linear hybrid system can be viewed as a compact , finite description of an infinite quantitative parity game , as defined in @xcite .",
    "[ def - ipg ] an _ interval parity game _ ( ipg ) @xmath132 , is played on a lhs @xmath133 ( without predicates ) and @xmath134 is divided into positions of either player  @xmath135or 1 .",
    "the transition relation @xmath26 describes possible moves in the game which are labelled by the function @xmath136 .",
    "the function @xmath137 assigns to each position the index of a variable and a multiplicative and additive factor , which are used to calculate the payoff if a play ends in this position .",
    "the priority function @xmath138 assigns a priority to every position .",
    "please note that interval parity games are played on linear hybrid systems without any quantitative predicates , i.e.the set of of predicates is empty and therefore omitted .",
    "a _ state _ @xmath139 of an interval game is a position in the game graph together with a variable assignment for all @xmath22 variables .",
    "a state @xmath140 is a successor of @xmath54 if it is a successor in the underlying lhs , i.e.if @xmath55 .",
    "we use the functions @xmath141 and @xmath142 to access the components of a state . for a real number @xmath130 ,",
    "we denote by @xmath143 and @xmath144 we call @xmath145 the state set @xmath146 where player @xmath37 has to move and @xmath147 .    * how to play . *",
    "every play starts at some position @xmath148 with all variables set to @xmath135 , i.e.the starting state is @xmath149 . for every state @xmath150 ,",
    "player @xmath37 chooses an allowed successor state @xmath55 and the play proceeds from @xmath140 .",
    "if the play reaches a state @xmath54 such that @xmath151 it ends , otherwise the play is infinite .",
    "intuitively , the players choose the time period they want to spend in a location before taking a specified transition .",
    "note that in this game every position could possibly be a terminal position .",
    "this is the case if it is not possible to choose a time period from the given intervals in such a way that the respective constraints on all variables are fulfilled .",
    "* payoffs . * the outcome @xmath152 of a finite play ending in @xmath153 where @xmath154 is @xmath155 . to improve readability , from now on we will simply write @xmath156 in this case .",
    "the outcome of an infinite play depends only on the lowest priority seen infinitely often in positions of the play .",
    "we will assign the value @xmath157 to every infinite play , where the lowest priority seen infinitely often is odd , and @xmath14 to those where it is even .",
    "* the two players have opposing objectives regarding the outcome of the play .",
    "player  @xmath135wants to maximise the outcome , while player  @xmath12wants to minimise  it .",
    "* strategies . * a strategy for player @xmath158 is a function @xmath159 with @xmath160 .",
    "a play @xmath161 is _ consistent with a strategy _",
    "@xmath162 for player @xmath37 , if @xmath163 for every @xmath129 such that @xmath164 . for strategies @xmath165 for the two players , we denote by @xmath166 the unique play starting in state @xmath54 which is consistent with both @xmath167 and @xmath168",
    ".    * determinacy . *",
    "a game is _ determined _ if , for each state @xmath54 , the highest outcome player  @xmath135can assure from this state and the lowest outcome player  @xmath12can assure coincide , @xmath169 where @xmath170 are the sets of all possible strategies for player  @xmath135 , player  @xmath12and the achieved outcome is called the _ value of @xmath11 at @xmath54_.    we say that the interval game is over @xmath44 or @xmath45 if both the underlying lhs and all constants in @xmath171 are of the respective kind",
    ". please note that this does not mean that the players have to choose their values from @xmath44 or @xmath45 , just that the endpoints of the intervals and constants in the payoffs are in those sets .",
    "intuitively , in a play of an interval parity game , the players choose successors of the current state as long as possible .    in figure [ ipg ]",
    ", we show a simple example of an interval parity game .",
    "positions of player  @xmath135are depicted as circles and positions of player  @xmath12as boxes . to keep things simple , there is just one clock variable , @xmath78 , all constraints are trivially true and the reset sets are empty , so we label the transitions only with the time intervals that the players can choose from .",
    "the priorities are depicted next to the nodes for non - terminal positions and the evaluation function above the terminal position ( in general , also positions with outgoing edges could be terminal , however in this example this is not possible as there are no constraints on the variable ) .    a play of this system starting at node",
    "@xmath63 could end after two moves in position @xmath172 , if player  @xmath12decided to move there ( he also has the choice to move down ) .",
    "the payoff of this play would then depend only on the choice that player  @xmath135made in the first move , for example @xmath173 $ ]",
    ". then the payoff would be @xmath174 ( as in this play , the second time interval only permits the choice @xmath175 ) .",
    "if player  @xmath12would move down instead of ending the play and the play would loop infinitely often in the cycle @xmath176 at the bottom , the least priority that occurs infinitely often would determine the outcome of the play ; in this case it would be 0 at @xmath177 and therefore the payoff would be @xmath14 .",
    "[ ipg ]    \\(a ) at ( 0,1 ) @xmath63 ; ( a1 ) at ( 1.3,1 ) ;    \\(b ) at ( 0,-0.5 ) @xmath76 ; ( b1 ) at ( 1.3,-0.5 ) ;    \\(c ) at ( -2,-0.5 ) ; ( c1 ) at ( -2.5,0.1 ) ;    \\(d ) at ( 0,-2 ) @xmath177 ; ( d1 ) at ( -1.3,-2 ) ;    \\(e ) at ( -2,-3 ) @xmath178 ; ( e1 ) at ( -3.3,-3 ) ;    \\(f ) at ( 2,-3 ) @xmath179 ; ( f1 ) at ( 3.3,-3 ) ;    \\(a ) edge [ ] node[right ] ( b ) ; ( b ) edge [ ] node[above ] ( c ) ;    \\(b ) edge [ ] node[right ] ( d ) ; ( d ) edge [ ] node[above ] ( e ) ; ( f ) edge [ ] node[above ] ( d ) ; ( e ) edge [ ] node[above ] ( f ) ; ( f.north ) edge [ bend right]node[right ] ( b.east ) ;    we already mentioned that an interval parity game can be seen as a representation of a quantitative parity game , now we want to describe this formally .",
    "we use the notion from @xcite and define , for an ipg with @xmath22 variables @xmath132 , the corresponding infinite quantitative parity game without discounts @xmath180 with @xmath181 iff @xmath140 is a successor of @xmath54 as above , @xmath182 and @xmath183 iff @xmath184 .",
    "the notions of plays , strategies , values and determinacy for the ipg @xmath11 are defined exactly",
    "as the ones for the quantitative parity game @xmath185 in @xcite . in particular , it follows from the determinacy of quantitative parity games that also interval parity games are determined .",
    "a game @xmath186 is a model - checking game for a formula @xmath9 and a system @xmath187 , if the value of the game starting from @xmath188 is exactly the value of the formula evaluated on @xmath10 at @xmath189 . in the qualitative case , that means , that @xmath9 holds in @xmath187 if player  @xmath135wins in @xmath11 from  @xmath188 . for a linear hybrid system @xmath10 and a @xmath86-formula @xmath9",
    ", we construct an ipg @xmath190 $ ] which is the model - checking game for @xmath9 on @xmath10 .",
    "the full definition of @xmath190 $ ] closely follows the construction presented in  @xcite and is presented below",
    ".    intuitively , the positions are pairs consisting of a subformula of @xmath9 and a location of @xmath10 .",
    "which player moves at which position depends on the outermost operator of the subformula . at disjunctions player  @xmath135moves to a position corresponding to one of the disjuncts and from @xmath191 to @xmath192 where @xmath193 , and player  @xmath12makes analogous moves for conjunctions and @xmath194 . from fixed - point variables",
    "the play moves back to the defining formula and the priorities of positions depends on the alternation level of fixed points , assigning odd priorities to least fixed points and even priorities to greatest fixed points .    for a linear hybrid system @xmath195 and a @xmath86-formula @xmath9 in negation normal form , the interval game @xmath196 = ( v_0 , v_1 , e , { \\ensuremath{\\lambda } } , { \\ensuremath{\\delta } } , { \\ensuremath{\\iota } } , \\omega),\\ ] ] which we call the _ model - checking game _ for @xmath10 and @xmath9 , is constructed in the following way , similar to the standard construction of model - checking games for the @xmath0-calculus ( c.f .",
    "@xcite ) .",
    "* positions . *",
    "the positions of the game are pairs @xmath197 , where @xmath198 is a subformula of @xmath9 , and @xmath148 is a location in the lhs @xmath10 .",
    "positions @xmath199 where the top operator of @xmath198 is @xmath200 , or @xmath201 belong to player  @xmath12and all other positions belong to player  @xmath135 . a state in the game",
    "is denoted by @xmath202 , where @xmath203 is the position and @xmath204 is the variable assignment of the location @xmath188 in the underlying linear hybrid system @xmath10 .",
    "* positions of the form @xmath205 and @xmath206 are terminal positions . from positions of the form @xmath207 , resp .",
    "@xmath208 , one can move to @xmath197 or to @xmath209 .",
    "positions of the form @xmath210 have either a single successor @xmath211 in case @xmath188 is a terminal location in @xmath10 , or one successor @xmath212 for every @xmath213 .",
    "analogously , positions of the form @xmath214 have a single successor @xmath215 if @xmath216 , or one successor @xmath212 for every @xmath213 otherwise .",
    "the moves corresponding to system moves @xmath217 are labelled accordingly with @xmath218 , all other moves are labelled with the empty label @xmath219,(-\\infty , \\infty)^m , \\emptyset)$ ] which indicates that no time passes , there are no constraints on the variables and no variable is reset .",
    "fixed - point positions @xmath220 , resp .",
    "@xmath221 have a single successor @xmath197 .",
    "whenever one encounters a position where the fixed - point variable stands alone , i.e.@xmath222 , the play goes back to the corresponding definition , to @xmath212 .",
    "* payoffs . *",
    "the function @xmath223 assigns @xmath224 to all positions @xmath205 , @xmath225 to all positions @xmath226 and @xmath36 to positions @xmath206 . to discourage the players from ending the game at any other position than a terminal one",
    ", @xmath223 assigns all other positions outcome @xmath15 for player  @xmath135 s positions or @xmath14 for player  @xmath12 s positions .",
    "the payoff @xmath227 of a play @xmath228 is calculated using @xmath223 and the priorities as stated before .",
    "* priorities . *",
    "the priority function @xmath229 is defined as in the classical case using the alternation level of the fixed - point variables , see e.g.@xcite . positions @xmath230 get a lower priority than positions @xmath231 if @xmath232 has a lower alternation level than @xmath233 .",
    "the priorities are then adjusted to have the right parity , such that an even value is assigned to all positions @xmath230 where @xmath232 is a @xmath201-variable and an odd value to those where @xmath232 is a @xmath0-variable .",
    "the maximum priority , equal to the alternation depth of the formula , is assigned to all other positions .",
    "we continue our example of the leaking gas burner and present in figure [ fig - mcgame - example ] the model - checking game for the previously introduced system and formula . in this interval parity game , ellipses depict positions of player  @xmath135and rectangles those of player  @xmath12 . in this game , all priorities are odd ( and therefore omitted ) , i.e.infinite plays are bad for player  @xmath135 .",
    "there is only one position with a constraints on variable @xmath78 and in only two positions a choice about the time that passes can be made .",
    "both of these positions belong to player  @xmath135 in this example and are labelled with the corresponding intervals below ( and in both @xmath78 is also reset ) . in terminal nodes , either the variable @xmath78 or the predicate @xmath77",
    "is evaluated for the payoff ( this choice can be made by player  @xmath12 in this example ) .",
    "the value of the game is @xmath12 , as is the value of the formula on the system starting from either node , and an optimal strategy for player  @xmath135is picking @xmath12 from @xmath81 $ ] and then leaving the cycle where player  @xmath12is forced to choose between the evaluation of @xmath78 or @xmath77 at @xmath76 .",
    "since he is minimising , he will choose to evaluate @xmath78 .",
    "\\(a ) at ( 0,2.5 ) @xmath234 ; ( b ) at ( 0,1 ) @xmath235 ; ( e ) at ( -4,1 ) @xmath236 ; ( f ) at ( -4 , 2.5 ) @xmath237 ; ( g ) at ( -4,-0.5 ) @xmath238 ; ( x ) at ( 0,-0.5 ) @xmath239 ; ( d ) at ( 0,-2 ) @xmath240 ; ( a ) edge [ ] node ( b ) ; ( b ) edge [ ] node ( x ) ; ( x ) edge [ ] node[right ] @xmath241}$ ] ( d ) ; ( b ) edge [ ] node ( e ) ; ( e ) edge [ ] node ( f ) ; ( e ) edge [ ] node ( g ) ; ( a2 ) at ( 5,-2 ) @xmath242 ; ( b2 ) at ( 5,-0.5 ) @xmath243 ; ( x2 ) at ( 5,1 ) @xmath244 ; ( d2 ) at ( 5,2.5 ) @xmath245 ; ( e2 ) at ( 9,-0.5 ) @xmath246 ; ( f2 ) at ( 9 , 1 ) @xmath237 ; ( g2 ) at ( 9,-2 ) @xmath247 ; ( a2 ) edge [ ] node ( b2 ) ; ( b2 ) edge [ ] node ( x2 ) ; ( x2 ) edge [ ] node[right ] @xmath248,[0,\\infty)}$ ] ( d2 ) ; ( b2 ) edge [ ] node ( e2 ) ; ( e2 ) edge [ ] node ( f2 ) ; ( e2 ) edge [ ] node ( g2 ) ; ( d ) edge [ ] node ( a2 ) ; ( d2 ) edge [ ] node ( a ) ;    it has been shown in @xcite that quantitative parity games of any size are determined and that they are model - checking games for @xmath86 .",
    "these results translate to interval parity games and we can conclude the following .",
    "[ mccorrect ] every interval parity game is determined and for every formula @xmath9 in @xmath86 , linear hybrid system @xmath10 , and a location @xmath188 of @xmath10 , it holds that @xmath249(({\\varphi } , v ) , { \\ensuremath{\\overline{0 } } } ) = { { \\ensuremath{\\llbracket{\\varphi}\\rrbracket}}}^\\calk(v , { \\ensuremath{\\overline{0}}}).\\ ] ]    determinacy of an interval parity game @xmath11 follows directly from the determinacy of the infinite qpg @xmath185 used to define @xmath11 .",
    "let @xmath9 be a @xmath86-formula and @xmath10 a linear hybrid system .",
    "let @xmath250 be the state graph of @xmath10 , where @xmath251 is the set of all states , and @xmath252 iff @xmath253 in @xmath10 .",
    "let @xmath254 be the quantitative transition system with predicates @xmath255 where @xmath256 .",
    "let us also rewrite the formula @xmath9 into a formula without variables , @xmath257 , by replacing each occurrence of @xmath36 by the corresponding @xmath255 .",
    "applying the model - checking theorem 12 from @xcite we conclude that for all @xmath258 it holds @xmath259^*({\\varphi } , v ) = { { \\ensuremath{\\llbracket{\\varphi}\\rrbracket}}^*}^{\\calk^*}(v)$ ] , i.e.that @xmath260^*$ ] is the model - checking game for @xmath261 and @xmath257 .",
    "finally , by definition of ipgs on the one hand and the semantics of @xmath103 on the other , it follows that for all @xmath262 @xmath263(({\\varphi } , v ) , { \\ensuremath{\\overline{x } } } ) = { { \\ensuremath{\\llbracket{\\varphi}\\rrbracket}}}^\\calk(v , { \\ensuremath{\\overline{x}}}).\\ ] ]   + -4.2em",
    "in this section , we first give a brief example that illustrates the difference between interval games and timed games .",
    "then , we show how to transform an initialised interval game over @xmath17 into an easier game over @xmath18 in which the all evolution rates are one .    at first sight ,",
    "interval games seem to be very similar to timed games .",
    "simple timed games are solved by playing on the region graph and can thus be discretised . to stress that quantitative payoffs indeed make a difference , we present in figure [ fig - game - half - example ] an initialised interval parity game with the interesting property that it is not optimal to play integer values , even though the underlying system is over @xmath18 .",
    "this simple game contains only one variable ( a clock ) and has no constraints on this variable in any of the transitions , so only the time intervals are shown .",
    "also , as infinite plays are not possible , the priorities are omitted , as well as the indices of non - terminal positions ( they are chosen to be unfavourable for the current player such that she has to continue playing ) .",
    "the payoff rule specifies the outcome of a play @xmath228 ending in @xmath172 as @xmath264 and in @xmath177 as @xmath265 .",
    "this game illustrates that it may not be optimal to play integer values since choosing time @xmath266 in the first move is optimal for player  @xmath135 .",
    "this move guarantees an outcome of @xmath267 which is equal to the value of the game .",
    "( v0 ) at ( 0 , 2.2 ) @xmath63 ; ( v1 ) at ( 0 , 1 ) @xmath76 ; ( e1 ) at ( -2 , 1 ) @xmath172 ; ( ) at ( -2 , 0.25 ) ; ( e2 ) at ( 2 , 1 ) @xmath177 ; ( ) at ( 2 , 0.25 ) ; ( v0 ) edge node[right ] ( v1 ) ; ( v1 ) edge node[above ] ( e1 ) ; ( v1 ) edge node[above ] ( e2 ) ;      so far , we have considered games where the values of variables can change at different rates during the time spent in locations . in this section ,",
    "we show that for initialised games it is sufficient to look at easier games where all rates are one , similar to timed games but with more complex payoff rules .",
    "we call these games flat and show that for every initialised ipg we can construct a flat ipg with the same value",
    ". to do so , we have to consider the regions where the coefficients do not change and rescale the constraints and payoffs accordingly .",
    "for an interval @xmath268 $ ] , we denote by @xmath269 and @xmath270 the intervals @xmath271 $ ] and @xmath272 $ ] respectively , and do analogously for open intervals .",
    "an interval parity game @xmath273 is _ flat _ if and only if @xmath274 for all @xmath148 and @xmath275 .",
    "[ flat ] for each initialised interval parity game @xmath11 there exists a flat game @xmath276 with the same value .",
    "let @xmath273 be an initialised interval parity game .",
    "we construct a corresponding flat game @xmath277 in the following way : for a position @xmath278 and each variable @xmath36 , such that @xmath279 , @xmath280 and an outgoing edge @xmath281 with @xmath282 $ ] we have in the corresponding flat game :    @xmath106    @xmath283    @xmath284 = \\frac 1 { a_i } c_i$ ]    @xmath285    note that we only change the functions @xmath286 and @xmath223 .",
    "we will show that for every play @xmath228 from a starting state @xmath54 consistent with @xmath167 and @xmath168 , we can construct strategies @xmath287 , @xmath288 , such that @xmath289 visits the same locations as @xmath228 and @xmath290 . before we proceed with the proof , notice that it is essential that @xmath11 is an initialised game . intuitively , the value of @xmath36 in @xmath276 is the value of @xmath36 in @xmath11 divided by the coefficient @xmath42 of the current position . when the position changes , it is thus crucial that @xmath42 does _ not _ change , except if @xmath36 is reset  exactly what is required from an initialised game .",
    "the proof proceeds by induction on the length of the plays .",
    "first , if @xmath291 is a state belonging to player  @xmath135and @xmath292 and @xmath293 , then in @xmath276 we define @xmath294 , where @xmath295 , such that @xmath296 for any @xmath297 .",
    "since @xmath298 is allowed in @xmath11 , this means that for all @xmath297 , we have @xmath299 \\in { \\ensuremath{\\lambda}}(v_0,v_1)$ ] .",
    "it follows that @xmath300 for all @xmath301 and therefore @xmath302 is allowed in @xmath276 .",
    "also @xmath303 and therefore the payoff is equal to @xmath304 .",
    "let @xmath305 and @xmath306 be finite histories in @xmath11 and @xmath276 , such that they visit the same locations and @xmath290 . then",
    ", if @xmath307 is a state belonging to player  @xmath135and @xmath308 and @xmath309 , then in @xmath276 we define @xmath310 , where @xmath311 , such that @xmath312 where @xmath313 for any @xmath314 .",
    "since @xmath315 is allowed in @xmath11 , this means that for all @xmath301 , @xmath299 \\in { \\ensuremath{\\lambda}}(v_k , v_{k+1})$ ] .",
    "as @xmath316 for all @xmath301 , we get that @xmath317 is allowed in @xmath276 .",
    "also @xmath318 and therefore the payoff is equal to @xmath319 .",
    "the cases for player  @xmath12are analogous .",
    "note that , for infinite plays , we also have the same payoff , since for the payoff of infinite games only the locations ( and their priorities ) matter . since we can construct , for each pair of strategies in @xmath11 , the corresponding strategies in @xmath276 , and those yield a play with the same payoff , the values of the two games are equal .",
    "consequently , from now on we only consider flat interval parity games and therefore omit the coefficients , as they are all equal to one .",
    "for a flat ipg @xmath320 and a value @xmath321 , we denote by @xmath322 the ipg where @xmath323 iff @xmath156 for all @xmath148 , and @xmath324 iff @xmath325 with @xmath326 and @xmath327 for all @xmath73 .",
    "intuitively , this means that all endpoints in the time intervals ( open and closed ) , and the constraints , and all additive values in the payoff function @xmath223 are multiplied by @xmath328 .",
    "the values of @xmath329 are also equal to the values of @xmath11 multiplied by @xmath328 .",
    "[ mult_games ] for every ipg @xmath11 over @xmath17 and @xmath330 it holds in all states @xmath54 that @xmath331 .",
    "we denote by @xmath332 the strategy with @xmath333 iff @xmath334 the mapping of @xmath11 with strategies for both players @xmath167 and @xmath168 to @xmath329 with @xmath332 and @xmath335 is a bijection ( in the reverse direction take @xmath336 ) .",
    "we also have @xmath337 where @xmath338 which is equal to @xmath339 for all finite plays @xmath228 .",
    "therefore , we know that @xmath340 and the same holds for the supremum and thus we get the desired result .",
    "note that all multiplicative factors in @xmath341 are the same in @xmath11 and in @xmath329 .",
    "moreover , if we multiply all constants in @xmath341 in a game @xmath11 ( both the multiplicative and the additive ones ) by a positive value @xmath130 , then the value of @xmath11 will be multiplied by @xmath130 , by an analogous argument as above .",
    "thus , if we first take @xmath130 as the least common multiple of all denominators of multiplicative factors in @xmath341 and multiply all @xmath341 constants as above , and then take @xmath328 as the least common multiple of all denominators of endpoints in the intervals and additive factors in the resulting game @xmath11 and build @xmath329 , we can conclude the following .",
    "[ mult_games_col ] for every finite ipg @xmath11 over @xmath17 , there exists an ipg @xmath276 over @xmath18 and @xmath342 such that @xmath343 .    from now on",
    "we assume that every ipg we investigate is a flat game over @xmath18 when not explicitly stated otherwise .",
    "our goal in this section is to show that it suffices to use a simple kind of ( almost ) discrete strategies to approximate the value of flat interval parity games over @xmath18 . to this end",
    ", we define an equivalence relation between states whose variables belong to the same @xmath344 intervals .",
    "this equivalence , resembling the standard methods used to build the region graph from timed automata , is a technical tool needed to compare the values of the game in similar states .",
    "we use the standard meaning of @xmath345 and @xmath346 , and denote by @xmath347 the number @xmath348 and by @xmath349 $ ] the pair @xmath350 .",
    "hence , when writing @xmath349=[s]$ ] , we mean that @xmath130 and @xmath54 lie in between the same integers .",
    "note that if @xmath351 then @xmath349 = [ s]$ ] implies that @xmath352 .",
    "we say that two states @xmath54 and @xmath353 in an ipg are equivalent , @xmath354 , if they are in the same location , @xmath355 , and for all @xmath356 :    @xmath106    @xmath357 = [ { \\ensuremath{\\mathrm{var}}}_i(t)]$ ] , and    if @xmath358 then @xmath359 .    intuitively , all variables lie in the same integer intervals and the order of fractional parts is preserved .",
    "in particular , it follows that all integer variables are equal .",
    "the following technical lemma allows for the shifting of moves between @xmath360-states .",
    "[ shift - move ] let @xmath54 and @xmath140 be two states in a flat ipg over @xmath344 such that @xmath361 . if a move from @xmath54 to @xmath353 is allowed by a label @xmath29 , then there exists a state @xmath362 , the move to which from @xmath140 is allowed by the same label @xmath363 and @xmath364 .    if @xmath365 then let @xmath366 . as @xmath361 , the same constraints are satisfied by @xmath54 and @xmath140 and thus the move from @xmath140 to @xmath366 is allowed by the same label .    if @xmath367 then let @xmath368 be the increment chosen during the move . if @xmath369 we let @xmath370 , the conditions follow from the assumption that @xmath361 again .",
    "if @xmath371 , let @xmath37 be the index of a non - reset variable with the smallest fractional part in @xmath353 , i.e. @xmath359 for all @xmath372 . to construct @xmath362 , we must choose @xmath373 with @xmath374 = [ w]$ ] which makes @xmath375 the one with smallest fractional part .",
    "_ case 1 _ : @xmath376 .",
    "+ in this case , for all non - reset variables @xmath377 , holds @xmath378 , intuitively meaning that no variable `` jumped '' above an integer due to @xmath379 .",
    "let @xmath363 be the variable with maximum fractional part in @xmath140 ( and thus , by definition of @xmath360 , also in @xmath54 and in this case in @xmath353 ) .",
    "set @xmath380 clearly @xmath374 = [ w]$ ] and indeed , we preserved the order of fractional parts and integer intervals , thus @xmath360 is preserved .",
    "( -5 , 0 )  ( 5 , 0 ) ; ( -4 , 0.2 )  ( -4 , -0.2 ) ; ( a ) at ( -4 , 0.5 ) @xmath135 ;    ( -3 , 0.1 )  ( -3 , -0.1 ) ; ( b0 ) at ( -3 , 0.5 ) @xmath381 ;    ( -1 , 0.1 )  ( -1 , -0.1 ) ; ( b1 ) at ( -1 , 0.5 ) @xmath382 ;    ( -3,0 ) to node [ below=15pt ] ( -1,0 ) ;    ( 2.5 , 0.1 )  ( 2.5 , -0.1 ) ; ( b3 ) at ( 2.5 , 0.5 ) @xmath383 ;    ( 2.5,0 ) to node [ below=15pt ] ( 4,0 ) ;    ( 4 , 0.2 )  ( 4 , -0.2 ) ; ( d ) at ( 4 , 0.5 ) @xmath12 ;    _ case 2 _ : @xmath384 and for all @xmath372 @xmath385 .",
    "+ in this case , for all non - reset variables @xmath377 , holds @xmath386 , intuitively meaning that all variables `` jumped '' above an integer due to @xmath379 .",
    "let @xmath363 be the variable with maximum fractional part in @xmath140 ( and thus also in @xmath54 ) .",
    "let @xmath387 be a number smaller than both @xmath388 and @xmath389 .",
    "we set @xmath390 by the first assumption on @xmath391 we have @xmath374 = [ w]$ ] and both the order of fractional parts and integer bounds in @xmath362 are the same as in @xmath353 , since @xmath392 by the second assumption on @xmath391 .",
    "the inequality in the other direction holds as well , and we get that @xmath364 as required .",
    "( -5 , 0 )  ( 5 , 0 ) ; ( 2 , 0.2 )  ( 2 , -0.2 ) ; ( a ) at ( 2 , 0.5 ) @xmath12 ;    ( -4 , 0.1 )  ( -4 , -0.1 ) ; ( b0 ) at ( -4 , 0.5 ) @xmath393 ;    ( -2 , 0.1 )  ( -2 , -0.1 ) ; ( b0 ) at ( -2 , 0.5 ) @xmath381 ;    ( 0.5 , 0.1 )  ( 0.5 , -0.1 ) ; ( b0 ) at ( 0.5 , 0.5 ) @xmath383 ;    ( 0.5,0 ) to node [ below=2pt ] ( 1,0 ) ;    ( -4,0 ) to node [ below=15pt ] ( 2,0 ) ;    ( 4 , 0.1 )  ( 4 , -0.1 ) ; ( b3 ) at ( 4 , 0.5 ) @xmath394 ;    _ case 3 _ : @xmath384 and there exists @xmath372 with @xmath395 .",
    "+ in this case let @xmath363 be the variable with maximum fractional part in @xmath353 , i.e.the last one which did not `` jump '' above an integer due to @xmath379 .",
    "the variable with next bigger fractional part in @xmath54 ( and by @xmath360 also in @xmath140 ) is @xmath396 , as depicted in figure  [ fig - case-3-s ] .",
    "( -5 , 0 )  ( 5 , 0 ) ; ( 2 , 0.2 )  ( 2 , -0.2 ) ; ( a ) at ( 2 , 0.5 ) @xmath12 ;    ( -4 , 0.1 )  ( -4 , -0.1 ) ; ( b0 ) at ( -4 , 0.5 ) @xmath397 ;    ( -1 , 0.1 )  ( -1 , -0.1 ) ; ( b0 ) at ( -1 , 0.5 ) @xmath381 ;    ( 0.5 , 0.1 )  ( 0.5 , -0.1 ) ; ( b0 ) at ( 0.5 , 0.5 ) @xmath398 ;    ( -4,0 ) to node [ below=12pt ] ( 0.5,0 ) ;    ( 3.5 , 0.1 )  ( 3.5 , -0.1 ) ; ( b3 ) at ( 3.5 , 0.5 ) @xmath394 ;    to transfer the move to @xmath140 , consider these two variables in @xmath140 as depicted in figure  [ fig - case-3-sprime ] and let @xmath399 .",
    "( -5 , 0 )  ( 5 , 0 ) ; ( 2 , 0.2 )  ( 2 , -0.2 ) ; ( a ) at ( 2 , 0.5 ) @xmath12 ;    ( -4 , 0.1 )  ( -4 , -0.1 ) ; ( b0 ) at ( -4 , 0.5 ) @xmath383 ;    ( -1 , 0.1 )  ( -1 , -0.1 ) ; ( b0 ) at ( -1 , 0.5 ) @xmath393 ;    ( -4,0 ) to node [ below=12pt ] ( -1,0 ) ;    ( -1,0 ) to node [ below=12pt ] ( 2,0 ) ;    we set @xmath400 again @xmath374 = [ w]$ ] and clearly @xmath37 is the variable with smallest fractional part in @xmath362 by construction .",
    "as @xmath361 , the order of fractional parts in @xmath353 and in @xmath362 is the same , and the integer bounds as well , thus @xmath401 .",
    "knowing that we can shift a single move and preserve @xmath360-equivalence , we proceed to show that for ipgs over @xmath18 , fully general strategies are not necessary .",
    "in fact , we can restrict ourselves to discrete strategies and , using this , reduce the games to discrete systems .",
    "intuitively , a discrete strategy keeps the maximal distance of all variable valuations to the closest integer small .    however , for the purposes of constructing an inductive proof of existence of a good discrete strategy , it is not convenient to work , for a state @xmath54 , simply with the maximal distance @xmath402 the reason is that for some moves it is impossible to keep this distance small for each variable and to go to an equivalent state as illustrated in figure [ fig - prob ] . in the depicted situation ,",
    "if we move @xmath79 within @xmath128-neighbourhood of @xmath344 ( below @xmath403 and @xmath404 depict integers ) , then @xmath78 leaves it .",
    "( -5 , 0 )  ( 6.5 , 0 ) ; ( -4 , 0.3 )  ( -4 , -0.3 ) ; ( z0 ) at ( -4 , -1 ) @xmath404 ; ( -3 , 0.1 )  ( -3 , -0.1 ) ; ( z3 ) at ( -3 , -1 ) @xmath78 ; ( -2 , 0.2 )  ( -2 , -0.2 ) ; ( z2 ) at ( -2 , -1 ) @xmath405 ; ( 4 , 0.3 )  ( 4 , -0.3 ) ; ( z1 ) at ( 4 , -1 ) @xmath403 ; ( 2 , 0.2 )  ( 2 , -0.2 ) ; ( e ) at ( 2 , -1 ) @xmath406 ; ( 3 , 0.1 )  ( 3 , -0.1 ) ; ( y ) at ( 3 , -1 ) @xmath79 ; ( 6 , 0.2 )  ( 6 , -0.2 ) ; ( z4 ) at ( 6 , -1 ) @xmath407 ; ( 3,0 ) edge [ bend left ] ( 4.5,0 ) ; ( -3,0 ) edge [ bend left ] ( -1.5,0 ) ;    to give a more suitable notion of distance for a state , let us , for @xmath408 , define @xmath409 this function gives the distance to the closest integer , except that it is negative if the closest integer is greater than @xmath130 , i.e.if the fractional part of @xmath130 is @xmath410 . as depicted in figure [ fig - dist ] .",
    "( -5 , 0 )  ( 5 , 0 ) ; ( -4 , 0.3 )  ( -4 , -0.3 ) ; ( a ) at ( -4 , 0.5 ) @xmath345 ; ( -3 , 0.1 )  ( -3 , -0.1 ) ; ( b ) at ( -3 , 0.5 ) @xmath130 ; ( 0 , 0.3 )  ( 0 , -0.3 ) ; ( c ) at ( 0 , 0.5 ) @xmath411 ; ( 4 , 0.3 )  ( 4 , -0.3 ) ; ( d ) at ( 4 , 0.5 ) @xmath412 ; ( 3 , 0.1 )  ( 3 , -0.1 ) ; ( e ) at ( 3 , 0.5 ) @xmath54 ; ( 3,0 ) to node [ below=15pt ] ( 4,0 ) ; ( -4,0 ) to node [ below=15pt ] ( -3,0 ) ;    please observe that for two real numbers @xmath413 , it follows that @xmath414 also , we observe that    @xmath106    if @xmath415 , then @xmath416 ;    otherwise , if @xmath417 or @xmath418 , then @xmath419 ;    otherwise , if @xmath420 , then @xmath421 ;    if @xmath422 , then @xmath423 .",
    "for a state @xmath54 , we use the abbreviation @xmath424 .",
    "we denote by @xmath425 and @xmath426 the smallest and biggest of all values @xmath427 , and additionally we define the total distance as follows @xmath428    this is illustrated in figure  [ fig - total - dists ] , where @xmath429 stands for an integer and @xmath78 to @xmath430 stand for the fractional parts of the values of the respective variables . in this example",
    ", @xmath78 has the smallest fractional part , i.e.the biggest one bigger than @xmath431 and @xmath430 has the biggest fractional part ( less than @xmath431 ) .",
    "( -5 , 0 )  ( 5 , 0 ) ; ( -4 , 0.2 )  ( -4 , -0.2 ) ; ( a ) at ( -4 , -0.5 ) @xmath432 ; ( -3 , 0.1 )  ( -3 , -0.1 ) ; ( b0 ) at ( -3 , 0.5 ) @xmath78 ; ( 1.5 , 0.1 )  ( 1.5 , -0.1 ) ; ( b1 ) at ( 1.5 , 0.5 ) @xmath79 ; ( 2.5 , 0.1 )  ( 2.5 , -0.1 ) ; ( b3 ) at ( 0.4 , 0.5 ) @xmath433 ; ( 0.4 , 0.1 )  ( 0.4 , -0.1 ) ; ( b2 ) at ( 2.5 , 0.5 ) @xmath430 ; ( 0 , 0.2 )  ( 0 , -0.2 ) ; ( c ) at ( 0 , -0.5 ) @xmath429 ; ( 4 , 0.2 ) ",
    "( 4 , -0.2 ) ; ( d ) at ( 4 , -0.5 ) @xmath434 ; ( 0,0 ) to node [ below=15pt ] ( 2.5,0 ) ; ( -3,0 ) to node [ below=15pt ] ( 0,0 ) ; ( -3,0 ) to node [ above=15pt ] ( 2.5,0 ) ;    first , we will prove that we can always correct a strategy that makes one step which is not @xmath128-discrete . by doing so",
    ", we will guarantee that we reach a state with the same location that is allowed by the labelling and that the values of the variables only change within the same intervals .",
    "[ discrete_succ ] let @xmath54 be a state with @xmath435 and @xmath353 be a successor of @xmath54 , where @xmath436 is allowed by @xmath437 .",
    "then , for every @xmath438 , there exists a successor @xmath439 of @xmath54 such that    @xmath106    @xmath440 ,    @xmath441 is allowed by @xmath363 , and    @xmath442 .",
    "we assume that @xmath443 , otherwise we can take @xmath444 .",
    "let @xmath445 be the increase in the ( non - reset ) values from @xmath54 to @xmath353 , i.e.@xmath446 .",
    "we make a case distinction regarding the computation of @xmath447 .    _ case 1 : _ @xmath448 .",
    "+ we correct @xmath449 in the following way : @xmath450 , where @xmath451 if @xmath452 and @xmath453 otherwise .",
    "first , we have to show that @xmath374 \\in [ w]$ ] and therefore @xmath454 .",
    "since @xmath455 for one @xmath37 , we can conclude from @xmath456 that @xmath457 and therefore @xmath458 , hence @xmath459 .",
    "furthermore , @xmath460 . otherwise , if @xmath461 then @xmath462 .",
    "this is a contradiction , since by definition @xmath463 .",
    "if @xmath464 , we also conclude @xmath460 , since @xmath465 .    next , we have to show , that all variables that are not reset stay in the same interval .",
    "we consider the case , where all values of the variables are increased , therefore we know that @xmath466 for all @xmath467 .",
    "we now have to show that also @xmath468 .",
    "let @xmath377 be the index of the variable which is the closest to the integers ( in this case ) , i.e.@xmath377 , such that @xmath469 .",
    "@xmath470 also , we have to show : @xmath442 .",
    "we know that @xmath471 and @xmath472 for one @xmath377 and @xmath473 .",
    "hence , @xmath474 , since @xmath475 .",
    "we can conclude that @xmath476 .",
    "= [ draw , fill = black , circle , minimum size=1 mm , inner sep=0pt ] ; ( s ) at ( -2,0 ) @xmath477 ; ( -1 , 0 )  ( 5 , 0 ) ; ( 0 , 0.2 )  ( 0 , -0.2 ) ; ( 2 , 0.1 )  ( 2 , -0.1 ) ; ( x1c ) at ( 3.5,0.2 ) ; ( x1 ) at ( 3.5,0 ) ; ( x2c ) at ( 2.8,0.2 ) ; ( x2 ) at ( 2.8,0 ) ; ( 4 , 0.2 )  ( 4 , -0.2 ) ; ( x1 ) to node [ above=8pt ] @xmath478 ( 4 , 0 ) ; ( x2 ) to node [ above=24pt ] @xmath479 ( 4 , 0 ) ; ( 0 , 0 ) to node [ above=8pt ] @xmath480 ( x2 ) ; ( x2 ) to node [ below=8pt ] @xmath481 ( x1 ) ;    ( ss ) at ( -2,-3 ) @xmath482 ; ( -1 , -3 )  ( 5 , -3 ) ; ( 0 , -2.8 ) ",
    "( 0 , -3.2 ) ; ( x1cp ) at ( 3.8,-3.2 ) ; ( x1p ) at ( 3.8,-3 ) ; ( x2cp ) at ( 3.1,-3.2 ) ; ( x2p ) at ( 3.1,-3 ) ; ( 2 , -2.9 )  ( 2 , -3.1 ) ; ( 4 , -2.8 )  ( 4 , -3.2 ) ; ( x2p ) to node [ above=8pt ] @xmath483 ( 4 , -3 ) ;    _ case 2 : _ @xmath484 .    _ subcase 1 : @xmath485 : _ + we correct @xmath449 in the following way : @xmath486 , where @xmath487 .    first , we have to show that @xmath374 \\in [ w]$ ] and therefore @xmath454 . since @xmath488 for one @xmath37 , we can conclude from @xmath456 that @xmath457 and therefore @xmath458 , hence @xmath459 .",
    "furthermore , @xmath489 . otherwise ,",
    "since @xmath464 and we assume that @xmath490 .",
    "this is a contradiction , since by definition @xmath491 .",
    "next , we have to show , that all variables that are not reset stay in the same interval .",
    "we consider the case , where all values of the variables are increased , therefore we know that @xmath466 for all @xmath467 .",
    "we now have to show that also @xmath468 .",
    "let @xmath377 be the index of the variable which is the closest to the integers ( in this case ) , i.e.@xmath377 , such that @xmath492 .",
    "@xmath493    also , we have to show : @xmath442 . we know",
    "that @xmath494 and @xmath495 for one @xmath377 .",
    "@xmath496 . hence",
    ", @xmath497 . we can conclude that @xmath498 . by definition of @xmath499 .",
    "_ subcase 2 : @xmath500 _ + in this case , from @xmath501 and @xmath502 it follows that @xmath503 for all @xmath37 .",
    "thus , we set @xmath504 and the lemma holds .",
    "= [ draw , fill = black , circle , minimum size=1 mm , inner sep=0pt ] ; ( s ) at ( -2,0 ) @xmath477 ; ( -1 , 0 )  ( 5 , 0 ) ; ( 0 , 0.2 )  ( 0 , -0.2 ) ; ( 2 , 0.1 )  ( 2 , -0.1 ) ; ( x1c ) at ( 1.2,0.2 ) ; ( x1 ) at ( 1.2,0 ) ; ( x2c ) at ( 0.5,0.2 ) ; ( x2 ) at ( 0.5,0 ) ; ( 4 , 0.2 )  ( 4 , -0.2 ) ; ( 0,0 ) to node [ above=8pt ] @xmath505 ( x2 ) ; ( 0,0 ) to node [ above=24pt ] @xmath506 ( x1 ) ; ( x1 ) to node [ above=8pt ] @xmath507| ( 4,0 ) ; ( x2 ) to node [ below=8pt ] @xmath481 ( x1 ) ;    ( ss ) at ( -2,-3 ) @xmath482 ; ( -1 , -3 )  ( 5 , -3 ) ; ( 0 , -2.8 )  ( 0 , -3.2 ) ; ( x1cp ) at ( 3.8,-3.2 ) ; ( x1p ) at ( 3.8,-3 ) ; ( x2cp ) at ( 3.1,-3.2 ) ; ( x2p ) at ( 3.1,-3 ) ; ( 2 , -2.9 )  ( 2 , -3.1 ) ; ( 4 , -2.8 ) ",
    "( 4 , -3.2 ) ; ( x2p ) to node [ above=8pt ] @xmath483 ( 4 , -3 ) ;    _ case 3 : _",
    "@xmath508 . +",
    "we correct @xmath449 in the following way : @xmath509 , where @xmath510 .",
    "first , we have to show that @xmath374 \\in [ w]$ ] and therefore @xmath454 .",
    "since @xmath488 for one @xmath37 and @xmath511 for one @xmath377 , we can conclude from @xmath456 and @xmath512 and @xmath513 and @xmath514 therefore @xmath515 .",
    "hence , @xmath459 .",
    "furthermore , @xmath489 , otherwise if @xmath461 then assume @xmath516 .",
    "then @xmath517 .",
    "contradiction . otherwise , if @xmath464 , then @xmath489 , since by definition @xmath518 .",
    "next , we have to show , that all variables that are not reset stay in the same interval .",
    "we consider the case , where all values of the variables are increased , therefore we know that @xmath466 for all @xmath467 .",
    "we now have to show that also @xmath468 .",
    "let @xmath377 be the index of the variable with @xmath519 .",
    "@xmath520    thus we have to show : @xmath442 . we know",
    "that @xmath521 and @xmath522 for @xmath377 such that @xmath469 . also , @xmath523 .",
    "we can conclude that @xmath524 .",
    "= [ draw , fill = black , circle , minimum size=1 mm , inner sep=0pt ] ;    ( ss ) at ( -2,0 ) @xmath477 ; ( -1 , 0 )  ( 5 , 0 ) ; ( 0 , 0.2 )  ( 0 , -0.2 ) ; ( 2 , 0.1 )  ( 2 , -0.1 ) ; ( x1c ) at ( 2.3,0.2 ) ; ( x1 ) at ( 2.3,0 ) ; ( x2c ) at ( 1.6,0.2 ) ; ( x2 ) at ( 1.6,0 ) ; ( 4 , 0.2 )  ( 4 , -0.2 ) ; ( x1 ) to node [ above=8pt ] @xmath505 ( 4,0 ) ; ( 0,0 ) to node [ above=8pt ] @xmath525 ( x2 ) ; ( x2 ) to node [ above=8pt ] @xmath481 ( x1 ) ;    ( ss ) at ( -2,-3 ) @xmath482 ; ( -1 , -3 ) ",
    "( 5 , -3 ) ; ( 0 , -2.8 )  ( 0 , -3.2 ) ; ( x1cp ) at ( 3.8,-3.2 ) ; ( x1p ) at ( 3.8,-3 ) ; ( x2cp ) at ( 3.1,-3.2 ) ; ( x2p ) at ( 3.1,-3 ) ; ( 2 , -2.9 )  ( 2 , -3.1 ) ; ( 4 , -2.8 )  ( 4 , -3.2 ) ; ( x2p ) to node [ above=8pt ] @xmath483 ( 4 , -3 ) ;    knowing that , in one step , the move can always preserve small total distance , we can finally define discrete strategies .",
    "[ edisc ] we call a strategy @xmath167 _ @xmath128-discrete _ if for every @xmath526 it holds that if @xmath527 then @xmath528 , and if for each @xmath37 @xmath529 , then @xmath530 .",
    "observe that it follows directly from the definition that if @xmath531 and both players play discrete strategies , then @xmath532    to see that decreasing @xmath128 in each step is sometimes crucial , consider the game with one variable depicted in figure [ fig - eps - need ] . in each move player",
    "@xmath135has to choose a positive value in @xmath533 .",
    "player  @xmath12can then decide to continue the play or leave the cycle and end the play with the negative accumulated value , i.e.@xmath534 , as payoff .",
    "he can not infinitely often decide to stay in the cycle as then the payoff would be @xmath14 as the priority is @xmath135 . an @xmath128-optimal strategy for player  @xmath135as",
    "the maximising player is thus to start with @xmath535 and decrease in each step .",
    "please note that the value of the game is @xmath135 .",
    "( ) at ( -2 , 0.75 ) ; ( a ) at ( -2 , 0 ) @xmath63 ; ( ) at ( 2 , 0.75 ) ; ( b ) at ( 2 , 0 ) @xmath76 ; ( c ) at ( 6 , 0 ) @xmath172 ; ( ) at ( 6 , -0.75 ) ; ( a ) edge[bend right,- > ] node[below ] ( b ) ; ( b ) edge[bend right,- > ] node[above ] ( a ) ; ( b ) edge[- > ] node[below ] ( c ) ;    we now extend the previous lemma to one that allows for the shifting of a whole move .",
    "[ discrete_succ2 ] let @xmath54 be a state and @xmath353 a successor of @xmath54 , where @xmath436 is allowed by @xmath363 .",
    "let @xmath140 be a state with @xmath536 , such that @xmath361 .",
    "then , for every @xmath537 , there exists a successor @xmath362 of @xmath140 allowed by @xmath363 such that    @xmath106    @xmath538 and    @xmath539 .    since @xmath361 and @xmath540 is allowed by @xmath363 , we know , by lemma [ shift - move ] , that there exists a state @xmath541 allowed by the same label @xmath363 , such that @xmath364 .",
    "we also know from lemma [ discrete_succ ] that , for every choice of @xmath128 , there exists @xmath542 such that @xmath543 and @xmath544 .",
    "since @xmath364 , this also means that @xmath545 , hence @xmath546 fulfils the requirements above .",
    "we can conclude that discrete strategies allow for the approximation of game values .",
    "[ discrete_strat ] fix an @xmath128-discrete strategy @xmath547 of player @xmath548 in @xmath11 , @xmath549 . for every strategy @xmath167 of player",
    "@xmath37 there exists an @xmath128-discrete strategy @xmath550 , such that , for every starting state @xmath551 with @xmath552 , if @xmath553 and @xmath554 , then @xmath555 for all @xmath37 .",
    "we only prove this lemma for player  @xmath135 , the case of player  @xmath12is analogous .",
    "we define @xmath550 inductively .",
    "let @xmath551 be the starting state . if @xmath556 , then by lemma  [ discrete_succ2 ] there is a @xmath557 with @xmath558 , and we set @xmath559 .",
    "let @xmath560 and @xmath561 be finite play histories such that @xmath562 is a prefix of @xmath563 and @xmath564 is consistent with @xmath547 and @xmath550 as defined thus far .",
    "note that @xmath565 and by inductive assumption @xmath555 for @xmath566 , and @xmath567 .",
    "if @xmath568 , then , by lemma  [ discrete_succ2 ] , there also exists a state @xmath569 such that @xmath570 and @xmath571 .",
    "thus , we set @xmath572 to @xmath573 . for all other histories",
    "@xmath574 with @xmath575 , we set @xmath576 for any @xmath577 equivalent with @xmath578 , which exists by lemma  [ shift - move ] , and we can pick a discrete one if @xmath579 by lemma  [ discrete_succ2 ] .    by construction ,",
    "the strategy @xmath550 is discrete and if @xmath553 and @xmath580 @xmath581 then @xmath582 .",
    "[ values_close ] let @xmath11 be a flat interval parity game .",
    "let @xmath583 be the set of all strategies for player @xmath37 and @xmath584 the set of all discrete strategies for player @xmath37 and @xmath585 be the highest value that occurs as a multiplicative factor in @xmath223 .",
    "then it holds , for every starting state @xmath54 , that @xmath586    _ case 1 : _ assume that @xmath587 then there exists a strategy @xmath588 such that @xmath589 fix a strategy @xmath590 , for which @xmath591 from lemma  [ discrete_strat ] , we know , that there is a discrete strategy @xmath592 which is a discrete version of @xmath593 against @xmath550 . from the above , it follows that @xmath594 this is a contradiction , since we know from lemma  [ discrete_strat ] that all states in both plays are equivalent , so for finite plays also the final states are equivalent , which means that the payoffs can not differ by more than @xmath585 as it is the highest occurring multiplicative factor in @xmath223 . if both plays are infinite , then , by definition of @xmath360 , the payoffs are equal .    _ case 2 : _ assume that @xmath595 by theorem  [ mccorrect ] every interval parity game is determined , thus @xmath596 in the next section , we show that restricting to discrete strategies corresponds to playing a counter - reset game , and since these are again determined games , we get that @xmath597",
    "therefore we can rewrite the assumption of this case as @xmath598 then there exists a strategy @xmath599 such that @xmath600 fix a strategy @xmath601 , for which @xmath602 from lemma  [ discrete_strat ] , we know , that there again is a discrete strategy @xmath603 which is a discrete version of @xmath604 against @xmath547 . from the above",
    ", it follows that @xmath605 which again contradicts that all states in these two plays are equivalent .",
    "in this section , we introduce counter - reset games and show , using the discretisation results from the previous section , that approximating the value of an ipg over @xmath18 can be reduced to solving a counter - parity game .",
    "we then solve these games using an algorithm from @xcite .    by proposition  [ values_close ]",
    "above , we can restrict both players in a flat ipg to use @xmath128-discrete strategies to approximate the value of a flat interval game up to the maximal multiplicative factor @xmath585 . multiplying",
    "the game by any number @xmath328 does not change the multiplicative factors in @xmath341 but multiplies the value of the game by @xmath328 .",
    "thus , to approximate the value of @xmath11 up to @xmath606 it suffices to play @xmath128-discrete strategies in @xmath607 .",
    "when players use only discrete strategies , the chosen values remain close to integers ( possibly being up to @xmath128 bigger or smaller ) .",
    "whether the value is bigger , equal or smaller than an integer can be stored in the state , as well as whether the value of a variable is smaller or bigger than any of the ( non - infinite ) bounds in constraint intervals .",
    "this way , we can eliminate both @xmath128 s and constraints and are left with the following games .",
    "a _ counter - reset _ game is a flat interval parity game in which in each label @xmath29 the constraints @xmath608 are trivially true and the interval @xmath609 is either @xmath610 $ ] or @xmath611 $ ] , i.e.either all variables are incremented by @xmath12 or all are left intact .    in figure",
    "[ counterex ] , we depict a simple counter - reset game . as usual , circles represent positions of player  @xmath135and boxes those of player  @xmath12 .",
    "priorities , payoff functions , intervals and reset sets are also depicted as usual next to the corresponding nodes or above transitions . in this game , we have two variables , @xmath612 and as mentioned above , there are no constraints on these variables in counter - reset games , but they can be reset . the only choice in this game that player  @xmath135has is to increase all variables ( `` choose '' 1 from @xmath613 $ ] ) and player  @xmath12can do the same or end the game and get a payoff of @xmath534 .",
    "since he wants to minimise , his best strategy is to loop as long as possible but not infinitely long , as the lowest priority on the according cycle is 0 .",
    "since he can achieve arbitrary small values this way , the value of this game ( starting at @xmath63 or @xmath76 ) is @xmath15 .",
    "[ counterex ]    ( ) at ( -2 , 0.75 ) ; ( a ) at ( -2 , 0 ) @xmath63 ; ( ) at ( 2 , 0.75 ) ; ( b ) at ( 2 , 0 ) @xmath76 ; ( c ) at ( 6 , 0 ) @xmath172 ; ( ) at ( 6 , -0.75 ) ; ( a ) edge[bend right,- > ] node[below ] node[above ] ( b ) ; ( b ) edge[bend right,- > ] node[above ] node[below ] ( a ) ; ( b ) edge[- > ] node[below ] node[above ] ( c ) ;    [ cr_approx ]",
    "let @xmath11 be an ipg over @xmath18 with maximal absolute value of the multiplicative factor in @xmath341 equal to @xmath585",
    ". for each @xmath614 there exists a counter - reset game @xmath615 such that for all states @xmath54 in which all variables are integers : @xmath616    consider first the game @xmath617 . by construction , the multiplicative factors in @xmath341 do not change and thus their maximal value in @xmath618 is still @xmath585 . by lemma [ mult_games ] , in all states",
    "@xmath54 holds @xmath619 moreover , by proposition [ values_close ] applied to @xmath618 @xmath620 and therefore @xmath621    we will now show how to construct the counter - reset game @xmath276 with value equal to @xmath622 , i.e. to the value of @xmath618 when both players play @xmath128-discrete strategies . to this end , we first construct the game @xmath623 which still has constraints , but in which all intervals are @xmath624 $ ] for some @xmath625 .",
    "the game @xmath623 is constructed from @xmath618 by replacing each position @xmath188 by @xmath626 positions @xmath627 .",
    "the sequence @xmath628 keeps track , for each variable , whether it is currently smaller , greater , or equal to an integer .",
    "the interval labels are now converted in the following way . if a move with interval @xmath629 and resets @xmath34 is taken from a position @xmath627 in @xmath623 and would lead to @xmath449 in @xmath618 , then a sequence of moves with labels @xmath630 $ ] for each @xmath631 is added , with the @xmath363-labelled move leading to @xmath632 such that :    @xmath106    if one @xmath633 then all @xmath633 for @xmath634 , and the same if @xmath635 or @xmath636 ,    if @xmath637 then each @xmath638 ( interval was downwards - closed ) , and    if @xmath639 then each @xmath640 ( interval was upwards - open ) .",
    "the situation for open , closed , and open - closed intervals is analogous .",
    "the plays which use discrete strategies in @xmath618 can now be directly transferred to plays in @xmath623 in which indeed in @xmath641 the sign of the fractional part of @xmath642 is equal to @xmath643 .",
    "the same can be done in the other direction , as the constraints listed above allow to choose a value in the interval which leads to the appropriate change in the sign sequence .",
    "therefore @xmath644    to eliminate the constraints from move labels in @xmath623 we determine the highest non - infinite bound @xmath645 which appears in these constraints ( both on the left and on the right side of an interval ) .",
    "then , we construct @xmath276 as the synchronous product of @xmath623 with a memory of size @xmath646 which remembers , for each variable @xmath36 , whether @xmath36 is greater than @xmath645 or equal to @xmath647 . with this memory , we resolve all constraints and remove them from move labels in @xmath276 .",
    "counter reset games are another representation of a class of counter parity games , which were recently studied in @xcite , where an algorithm to solve such games was given , improving our previous decidability result @xcite .    for any finite counter parity game @xmath11 and initial vertex @xmath188 , the value @xmath648 can be computed in 6exptime .",
    "when the number of counters is fixed , the value can be computed in 4exptime .",
    "[ cr_value ] for any finite counter reset game @xmath11 with a starting state @xmath54 where all counters are integers , the value @xmath649 can be computed in 6exptime . with fixed number of counters ,",
    "the value can be computed in 4exptime .",
    "we conclude by completing the proof of our main theorem  [ mainthm ] .",
    "we first observe that , by theorem  [ mccorrect ] , evaluating a @xmath86-formula on a system is equivalent to calculating the value of the corresponding model - checking game .",
    "we can then turn this game into a flat one by lemma  [ flat ] and then into one over @xmath18 by corollary  [ mult_games_col ] . by lemma  [ cr_approx ]",
    "the value of such a game can be approximated with arbitrary precision by counter - reset games , which we can solve by corollary  [ cr_value ] .",
    "all together , we proved that it is possible to approximate the values of quantitative @xmath0-calculus formulae on initialised linear hybrid systems with arbitrary precision . with the recent result on counter parity games , we are even able to provide an elementary algorithm  as the game @xmath615 in lemma  [ cr_approx ] is doubly - exponential in @xmath11 and @xmath129 , the combined complexity of the above procedure is 8exptime ( note the doubly - exponential increase compared to corollary  [ cr_value ] ) .",
    "this complexity is very high and the complexity bound is not tight , thus we can formulate two immediate open problems : ( 1 ) can the exact value of @xmath117 be computed ?",
    "( 2 ) what is the exact complexity of such a computation or its approximation ?",
    "another open question is whether we can use our methods for more general classes of games , e.g. for games with more complex payoff functions such as mean - payoff interval games .",
    "furthermore , we are not only interested in theoretical complexity bounds but also in the practical applicability of quantitative model checking .",
    "this will require a more thorough algorithmic analysis of the problem .",
    "also , since we reduce the problem to counter parity games , the implementation of a solver for this class of games is a necessary first step before we can exploit the methods presented in this paper in practice .",
    "however , even with further research needed to answer these challenges , our result lays the foundation for using quantitative temporal logics in the verification of hybrid systems .",
    "rajeev alur , costas courcoubetis , nicolas halbwachs , thomas  a. henzinger , pei - hsin ho , xavier nicollin , alfredo olivero , joseph sifakis , and sergio yovine . the algorithmic analysis of hybrid systems .",
    ", 138(1):334 , 1995 .",
    "patricia bouyer , thomas brihaye , and fabrice chevalier . weighted o",
    "- minimal hybrid systems are more decidable than weighted timed automata ! in _",
    "proceedings of lfcs07 _ , volume 4514 of _ lncs _ , pages 6983 .",
    "springer , 2007 .",
    "diana fischer and ukasz kaiser .",
    "model checking the quantitative mu - calculus on linear hybrid systems . in _ proceedings of the 38th international colloquium on automata , languages and programming , icalp  2011 ( 2 ) _ , volume 6756 of _ lecture notes in computer science _ , pages 404415 .",
    "springer , 2011 ."
  ],
  "abstract_text": [
    "<S> we study the model - checking problem for a quantitative extension of the modal @xmath0-calculus on a class of hybrid systems . </S>",
    "<S> qualitative model checking has been proved decidable and implemented for several classes of systems , but this is not the case for quantitative questions that arise naturally in this context . recently , </S>",
    "<S> quantitative formalisms that subsume classical temporal logics and allow the measurement of interesting quantitative phenomena were introduced . </S>",
    "<S> we show how a powerful quantitative logic , the quantitative @xmath0-calculus , can be model checked with arbitrary precision on initialised linear hybrid systems . to this end , we develop new techniques for the discretisation of continuous state spaces based on a special class of strategies in model - checking games and present a reduction to a class of counter parity games . </S>"
  ]
}