{
  "article_text": [
    "_ program synthesis _",
    "@xcite is an attractive programming paradigm that aims to automate the development of complex pieces of code .",
    "deriving programs completely from scratch given only a declarative specification is very challenging for all but the simplest algorithms , but recent work has shown that the problem can be made tractable by starting from a partial program  referred to in the literature as a sketch  @xcite , scaffold  @xcite or template  that constrains the space of possible programs the synthesizer needs to consider .",
    "this approach to synthesis has proven useful in a variety of domains including program inversion  @xcite , program deobfuscation  @xcite , development of concurrent data - structures  @xcite and even automated tutoring  @xcite .",
    "this paper presents jsketch , a tool that makes sketch - based synthesis directly available to java programmers .",
    "jsketch is built as a frontend on top of the sketch synthesis system , a mature synthesis tool based on a simple imperative language that can generate c code  @xcite .",
    "jsketch allows java programmers to use many of the sketch s synthesis features , such as the ability to write code with unknown constants ( _ holes _ written ) and unknown expressions described by a _ generator _ ( written ) .",
    "in addition , jsketch provides a new synthesis feature  a class - level generator  that is specifically tailored for object oriented programs .",
    "section  [ sec : overview ] walks through jsketch s input and output , along with a running example .    as illustrated in figure",
    "[ fig : overview ] , jsketch compiles a java program with unknowns to a partial program in the sketch language and then maps the result of sketch synthesis back to java .",
    "the translation to sketch is challenging because sketch is not object oriented , so the translator must model the complex object - oriented features in java  such as inheritance , method overloading and overriding , anonymous / inner classes  in terms of the features available in sketch .",
    "section  [ sec : java - sketch ] briefly explains several technical challenges addressed in jsketch . section  [ sec : experience ] describes our experience with jsketch .",
    "jsketch is available at http://plum - umd.github.io / java - sketch/.",
    "we begin our presentation with two examples showing jsketch s key features and usage .",
    "the input to jsketch is an ordinary java program that may also contain unknowns to be synthesized .",
    "there are two kinds of unknowns : _ holes _ , written , represent unknown integers and booleans , and _ generators _ , written , range over a list of expressions .",
    "for example , consider the following java sketch , similar to an example from the sketch manual  @xcite :    .... class simplemath {      static int mult2(int x ) { return ( ? ? * { | x , 0 | } ) ; } } ....    here we have provided a template for the implementation of method : the method returns the product of a hole and either parameter or 0 .",
    "notice that even this very simple sketch has @xmath0 possible instantiations ( 32 bits of the hole and one bit for the choice of or ) .    to specify the solution we would like to synthesize , we provide a _ harness _ containing assertions about the method :    .... class test {      harness static void test ( ) { assert(simplemath.mult2(3 ) = = 6 ) ; } } ....",
    "now we can run jsketch on the sketch and harness .    ....",
    "$ ./jsk.sh simplemath.java test.java ....    the result is a valid java source file in which holes and generators have been replaced with the appropriate code .",
    ".... $ cat result / java / simplemath.java class simplemath { ... static public int mult2 ( int x ) { return 2 * x ; } } ....      now consider a harder problem : suppose we want to synthesize a finite automaton given sample accepting and rejecting inputs .",
    "there are many possible design choices for finite automata in an object - oriented language , and we will opt for one of the more efficient ones : the current automaton state will simply be an integer , and a series of conditionals will encode the transition function .",
    "figure  [ fig : automaton - sketch ] shows our automaton sketch .",
    "the input to the automaton will be a sequence of s , which have a method returning an integer ( line  [ line : generator ] ) .",
    "an is a class  ignore the keyword for the moment  with fields for the current ( line  [ line : init - st ] ) and the number of states ( line  [ line : num - st ] ) . notice these fields are initialized to holes , and thus the automaton can start from any arbitrary state and have an arbitrary yet minimal number of states ( restricted by sketch s function on line  [ line : min - num - st ] ) .",
    "the class includes a function that asserts that the current state is in - bounds  ( line  [ line : check - state ] ) and updates according to the current state and the input s value  ( retrieved on line  [ line : getid ] ) .",
    "here we face a challenge , however : we do not know the number of automaton states or tokens , so we have no bound on the number of transitions . to solve this problem",
    ", we use a feature that jsketch inherits from sketch : the term expands to the minimum length sequence of s that satisfy the harness . in this case , the body of ( line  [ line : st - transition ] ) is a conditional that encodes an arbitrary transition  if the guard matches the current state and input token , then the state is updated and the method returns .",
    "thus , the method will be synthesized to include however many transitions are necessary .",
    "finally , the class has methods and ; the first performs multiple transitions based on a sequence of input tokens , and the second one determines whether the automaton is in an accepting state .",
    "notice that the inequality ( line  [ line : accept ] ) means that states 0 up to some bound will be accepting ; this is fully general because the exact state numbering does not matter , so the synthesizer can choose the accepting states to follow this pattern .    .... interface token { public int getid ( ) ; } generator class automaton { / * * \\label{line : generator } * /      private int state = ? ? ; / * * \\label{line : init - st } * /      static int num_state = ? ? ; / * * \\label{line : num - st } * /      harness static void min_num_state ( ) { minimize(num_state ) ; } / * * \\label{line : min - num - st } * /      public void transition(token t ) { / * * \\label{line : transition } * /          assert 0 < = state & & state < num_state ; / * * \\label{line : check - state } * /          int i d = t.getid ( ) ; / * * \\label{line : getid } * /          minrepeat { / * * \\label{line : minrepeat } * /              if ( state = = ? ? & & i d = = ? ? ) { state = ? ?",
    "; return;/ * * \\label{line : st - transition } * / }      }    }      public void transitions(iterator < token > it ) { / * * \\label{line : transitions } * /          while ( it.hasnext ( ) ) { transition(it.next ( ) ) ; }      }      public boolean accept ( ) { return state < = ? ? ;",
    "} / * * \\label{line : accept } * / } ....    .... class dbconnection {      class monitor extends automaton { / * * \\label{line : generator2 } * /          final static token open =              new token ( ) { public int getid ( ) { return 1 ; } } ;          final static token close =              new token ( ) { public int getid ( ) { return 2 ; } } ;          public monitor ( ) { }      }      monitor m ;      public dbconnection ( ) { m = new monitor ( ) ; }      public boolean iserroneous ( ) { return !",
    "m.accept ( ) ; }      public void open ( ) { m.transition(monitor.open ) ; } / * * \\label{line : call - transition1 } * /      public void close ( ) { m.transition(monitor.close ) ; } / * * \\label{line : call - transition2 } * / } class cadsr extends automaton { ... / * * \\label{line : generator1 } * /      public boolean accept(string str ) { / * * \\label{line : accept - str } * /          state = init_state_backup ;          transitions(converttoiterator(str ) ) ; / * * \\label{line : to - iter } * /          return accept ( ) ; / * * \\label{line : call - accept } * / }    } ....    .... class testdbconnection {      harness static void scenario_good ( ) { / * * \\label{line : harness - good } * /          dbconnection conn = new dbconnection ( ) ;          assert ! conn.iserrorneous ( ) ;          conn.open ( ) ;   assert ! conn.iserroneous ( ) ;          conn.close ( ) ; assert !",
    "conn.iserroneous ( ) ; }      // bad : opening more than once      harness static void scenario_bad1 ( ) { / * * \\label{line : harness - bad1 } * /          dbconnection conn = new dbconnection ( ) ;          conn.open ( ) ; conn.open ( ) ; assert conn.iserroneous ( ) ; }      // bad : closing more than once      harness static void scenario_bad2 ( ) { / * * \\label{line : harness - bad2 } * /          dbconnection conn = new dbconnection ( ) ;          conn.open ( ) ;          conn.close ( ) ; conn.close ( ) ; assert conn.iserroneous ( ) ; }    } class testcadsr {      // lisp - style identifier : c(a|d)+r      harness static void examples ( ) { / * * \\label{line : harness1 } * /          cadsr a = new cadsr ( ) ;          assert ! a.accept(\"c \" ) ;   assert ! a.accept(\"cr \" ) ;          assert a.accept(\"car \" ) ;   assert a.accept(\"cdr \" ) ;          assert a.accept(\"caar \" ) ; assert a.accept(\"cadr \" ) ;          assert a.accept(\"cdar \" ) ; assert a.accept(\"cddr \" ) ; }    } ....    [ [ class - generators . ] ] class generators .",
    "+ + + + + + + + + + + + + + + + +    in addition to basic sketch generators like we saw in the example , jsketch also supports _ class generators _ , which allow the same class to be instantiated differently in different superclass contexts . in figure",
    "[ fig : automaton - sketch ] , the annotation on line  [ line : generator ] indicates that is such a class .",
    "( class generators are analogous to the the function generators introduced by sketch  @xcite . )",
    "figure  [ fig : automata ] shows two classes that inherit from .",
    "the first class , , has an inner class that inherits from .",
    "the class defines two tokens , and , whose ids are 1 and 2 , respectively .",
    "the outer class has a instance that transitions when the database is opened ( line  [ line : call - transition1 ] ) and when the database is closed ( line  [ line : call - transition2 ] ) . the goal is to synthesize such that it acts as an inline reference monitor to check that the database is never opened or closed twice in a row , and is only closed after it is opened .",
    "the harnesses in in figure  [ fig : sample ] describe both good and bad behaviors .    the second class in figure  [ fig : automata ] ,",
    ", adds a new ( overloaded ) method that converts the input to a token iterator ( details omitted for brevity ) , transitions according to that iterator , and then returns whether the string is accepted .",
    "the goal is to synthesize an automaton that recognizes ` c(a|d)+r ` .",
    "the corresponding harness in figure  [ fig : sample ] constructs a instance and makes various assertions about its behavior .",
    "notice that this example relies critically on class generators , since and must encode different automata .    [",
    "[ output . ] ] output .",
    "+ + + + + + +    .... class automaton1 {    int state = 0 ; static int num_state = 3 ;    public void transition ( token t ) { ...      assert 0 < = state & & state < 3 ;      if ( state = = 0 & & i d = = 1 ) { state = 1 ; return ; } //",
    "open@      if ( state = = 1 & & i d = = 1 ) { state = 2 ; return ; } //",
    "open 2x      if ( state = = 1 & & i d = = 2 ) { state",
    "= 0 ; return ; } //",
    "( init)@      if ( state = = 0 & & i d = = 2 ) { state = 2 ; return ; } //",
    "close 2x    }    public boolean accept ( ) { return state < = 1 ; } ... } class dbconnection { class monitor extends automaton1 { ... } ... } class automaton2 {    int state = 0 ; static int num_state = 3 ;    public void transition ( token t ) { ...      assert 0 < = state & & state < 3 ;      if ( state = = 0 & & i d = = 99 )   { state = 1 ; return ; } // c      if ( state = = 1 & & i d = = 97 )   { state = 2 ; return ; } //",
    "ca      if ( state = = 1 & & i d = = 100 ) { state = 2 ; return ; } //",
    "cd      if ( state = = 2 & & i d = = 114 ) { state = 0 ; return ; } //",
    "c(a|d)+r@    }    public boolean accept ( ) { return state < = 0 ; } ... } class cadsr extends automaton2 { ... } ....    figure  [ fig : output ] shows the output produced by running jsketch on the code in figures  [ fig : template ] and  [ fig : sample ] .",
    "we see that the generator was instantiated as , inherited by , and , inherited by .",
    "both automata are equivalent to what we would expect for these languages .",
    "two things were critical for achieving this result : minimizing the number of states ( line  [ line : min - num - st ] ) and having sufficient harnesses ( figure  [ fig : sample ] ) .",
    "we experimented further with to see how changing the sketch and harness affects the output .",
    "first , we tried running with a smaller harness , i.e. , with fewer examples . in this case",
    ", the synthesized automaton covers all the examples but not the full language . for example , if we omit the four - letter inputs in figure  [ fig : sample ] the resulting automaton only accepts three - letter inputs . whereas going to four - letter inputs constrains the problem enough for jsketch to find the full solution .",
    "second , if we omit state minimization ( line  [ line : min - num - st ] ) , then the synthesizer chooses large , widely separated indexes for states , and it also includes redundant states ( that could be merged with a textbook state minimization algorithm ) .",
    "third , if we manually bound the number of states to be too small ( e.g. , manually set to 2 ) , the synthesizer runs for more than half an hour and then fails , since there is no possible solution .    of these cases",
    ", the last two are relatively easy to deal with since the failure is obvious , but the first one  knowing that a synthesis problem is underconstrained  is an open research challenge",
    ". however , one good feature of synthesis is that , if we do find cases that are not handled by the current implementation , we can simply add those cases and resynthesize rather than having to manually fix the code ( which could be quite difficult and/or introduce its own bugs ) .",
    "moreover , minimization  trying to ensure the output program is small  seems to be a good heuristic to avoid overfitting to the examples .",
    "we implemented jsketch as a series of python scripts that invokes sketch as a subroutine .",
    "jsketch comprises roughly 5.7k lines of code , excluding the parser and regression testing code .",
    "jsketch parses input files using the python front - end of antlr v3.1.3",
    "@xcite and its standard java grammar .",
    "we extended that grammar to support holes , expression - level generators , , and the and modifiers .",
    "there are a number of technical challenges in the implementation of jsketch ; due to space limitations we discuss only the major ones .",
    "[ [ class - hierarchy . ] ] class hierarchy .",
    "+ + + + + + + + + + + + + + + +    the first issue we face is that sketch s language is not object - oriented . to solve this problem",
    ", jsketch follows a similar approach to  @xcite and encodes objects with a new type , defined as a containing all possible fields plus an integer identifier for the class .",
    "more precisely , if @xmath1 are all classes in the program , then we define :    .... struct v_object {    int class_id ; /**\\it fields - from-$c_1$*/ ... /**\\it fields - from-$c_m$*/ } ....    where each @xmath2 gets its own unique i d .",
    "jsketch also assigns every method a unique i d , and it creates various constant arrays that record type information . for a method i d , we set to be its class i d ; to be its number of arguments ; and to be the type of its -th argument .",
    "we model the inheritance hierarchy using a two - dimensional array such that is true if class is a subclass of class .",
    "[ [ encoding - names . ] ] encoding names .",
    "+ + + + + + + + + + + + + + +    when we translate the class hierarchy into jsketch , we also flatten out the namespace , and we need to avoid conflating overridden or overloaded method names , or inner classes .    thus , we name inner classes as , where is the name of the nested class and is the name of the enclosing class .",
    "we also handle anonymous classes by assigning them distinct numbers , e.g. ,",
    ". to support method overriding and overloading , methods are named , where is the name of the method , is the name of the class in which it is declared , and is the list of parameter types . for example , in the finite automaton example , inherits method from ( the second variant of the class generator ) , hence the method is named in sketch .",
    "the first parameter represents the callee of the method .",
    "[ [ dynamic - dispatch . ] ] dynamic dispatch .",
    "+ + + + + + + + + + + + + + + + +    we simulate the dynamic dispatch mechanism of java in sketch . for each method name (",
    "suitably encoded , as above ) , we introduce a function that dispatches based on the field of the callee :    .... void dyn_dispatch_m(v_object self , ... ) {    int cid = self.class_id ;    if ( cid = = r0_id ) return m_r0_p(self , ... ) ;    if ( cid = = r1_id ) return m_r1_p(self , ... ) ;    ...    return ; } ....    note that if is static , the argument is omitted .",
    "[ [ java - libraries . ] ] java libraries .",
    "+ + + + + + + + + + + + + + +    to perform synthesis , we need sketch equivalents of any java standard libraries used in the input sketch . currently , jsketch supports the following collections and apis : , , , , , , , , , , , and .",
    "library classes are implemented using a combination of translation of the original source using jsketch and manual coding , to handle native methods or cases when efficiency is an issue .",
    "note that several of these classes include generics ( e.g. , ) , which is naturally handled because the all objects are uniformly represented as .",
    "[ [ limitations - and - unsupported - features . ] ] limitations and unsupported features .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as java is a very large language , jsketch currently only supports a core subset of java .",
    "we leave several features of java to the future versions of jsketch , including packages , access control , exceptions , and concurrency .",
    "additionally , jsketch assumes the input sketch is type correct , meaning the standard parts of the program are type correct , holes are used either as integers or booleans , and expression generators are type correct .",
    "this assumption is necessary because , although sketch itself includes static type checking , distinctions between different object types are lost by collapsing them all into .",
    "[ [ using - sketch . ] ] using sketch .",
    "+ + + + + + + + + + + + +    we translate jsketch file , which is composed of the user - given template and examples , as well as supportive libraries ( if necessary ) to files as input to sketch .",
    "for example , the example in section  [ sec : simplemath ] is translated to    .... int e_h1 = ? ? ; int mult2_simplemath_int(int x ) { return e_h1 * { | x | 0 | } ; } harness void test_test ( ) { assert mult2_simplemath_int(3 ) = = 6 ; } ....    we refer the reader elsewhere  @xcite for details on how sketch itself works .    after solving the synthesis problem",
    ", jsketch then unparses these same java files , but with unknowns resolved according to the sketch synthesis results .",
    "we use partial parsing  @xcite to make this output process simpler .",
    "we developed jsketch as part of the development of another tool , pasket  @xcite , which aims to construct _ framework models _ , e.g. mock classes that implement key functionality of a framework but in a way that is much simpler than the actual framework code and is more amenable to static analysis .",
    "pasket takes as input a log of the interaction between the real framework and a test application , together with a description of the api of the framework and of the design patterns that the framework uses .",
    "pasket uses these inputs to automatically generate an input to jsketch which is then responsible for actually synthesizing the models . through pasket",
    ", we have used jsketch to synthesize models of key functionality from the swing and android frameworks .",
    "the largest jsketch inputs generated by pasket contain 117 classes and 4,372 lines of code , and solve in about two minutes despite having over @xmath3 possible choices ; this is possible thanks to a new synthesis algorithm called adaptive concretization  @xcite that is available in sketch and was also developed as part of this work .",
    "this research was supported in part by nsf ccf-1139021 , ccf-1139056 , ccf-1161775 , and the partnership between umiacs and the laboratory for telecommunication sciences .",
    "14 [ 1]#1 [ 1]`#1 ` urlstyle    a.  demaille , r.  levillain , and b.  sigoure . .",
    "in _ sac 09 _ , pages 19241929 , 2009 .",
    "j.  jeon , x.  qiu , j.  s. foster , and a.  solar - lezama .",
    ". unpublished manuscript , 2015 .",
    "j.  jeon , x.  qiu , a.  solar - lezama , and j.  s. foster . .",
    "in _ computer aided verification ( cav 15 ) _ , july 2015 .",
    "s.  jha , s.  gulwani , s.  a. seshia , and a.  tiwari .",
    "oracle - guided component - based program synthesis . in _",
    "icse 10 _ ,",
    "pages 215224 , 2010 .",
    "z.  manna and r.  waldinger . .",
    "_ acm transactions on programming languages and systems _ , 20 ( 1):0 90121 , jan",
    ". 1980 .",
    "z.  manna and r.  j. waldinger . toward automatic program synthesis",
    ". _ communications of the acm _ , 140 ( 3):0 151165 , mar .",
    "t.  parr and k.  fisher . .",
    "in _ pldi 11 _ , pages 425436 , 2011 .",
    "r.  singh , s.  gulwani , and a.  solar - lezama . .",
    "in _ pldi 13 _ , pages 1526 , 2013 .",
    "a.  solar - lezama .",
    "program sketching .",
    "_ international journal on software tools for technology transfer _",
    ", 150 ( 5 - 6):0 475495 , 2013 .",
    "a.  solar - lezama . _ the sketch programmers manual _ , 2015 .",
    "version 1.6.7 .",
    "a.  solar - lezama , l.  tancau , r.  bodik , s.  seshia , and v.  saraswat .",
    "combinatorial sketching for finite programs . in _ asplos - xii _ ,",
    "pages 404415 , 2006 .",
    "a.  solar - lezama , c.  g. jones , and r.  bodik .",
    "sketching concurrent data structures . in _",
    "pldi 08 _ ,",
    "pages 136148 , 2008 .",
    "s.  srivastava , s.  gulwani , and j.  s. foster . from program verification",
    "to program synthesis . in _",
    "popl 10 _ ,",
    "pages 313326 , 2010 .",
    "s.  srivastava , s.  gulwani , s.  chaudhuri , and j.  s. foster . .",
    "in _ pldi 11 _ , pages 492503 , june 2011 .",
    "as mentioned in the introduction , jsketch is available at http://plum - umd.github.io / java - sketch/. the tool is at a fairly early stage of development , but is robust enough to be used by the wider research community .",
    "this is a _ sketch _ ( also _ scaffold _ or _ template _ ) , which is a _ partial java program_.",
    "hole_unknown integer  and the other part of the product is a _ generator_ranging over the listed expressions .",
    "notice that this sketch has @xmath0 possible instantiations .",
    "in addition to the template , the other important input to jsketch is _ examples _ that specify the expected behavior of the template .",
    "these are analogous to unit tests .",
    "we provide a _ harness _ containing ions about the method :        .... $ ./jsk.sh simplemath.java test.java 06:07:15 rewriting syntax sugar 06:07:15 specializing class - level generator 06:07:15 rewriting exp hole",
    "06:07:15 semantics checking 06:07:15 building class hierarchy 06:07:15 encoding result / sk_test / simplemath.sk 06:07:15 encoding result / sk_test / test.sk ... 06:07:15 sketch running ...",
    "06:07:15 sketch done : result / output / test.txt 06:07:15 replacing holes 06:07:15 replacing generators 06:07:15 semantics checking 06:07:15 decoding result / java / simplemath.java ... 06:07:15 synthesis done ....          now consider a harder problem : suppose we want to synthesize an automaton - based inline reference monitor to check basic properties of a database connection , namely that the connection is never opened or closed twice in a row and is only closed after being opened .",
    "let s use a simple , efficient implementation : representing states via distinct integers , along with a series of conditionals that encode state transitions .",
    ".... interface token { public int getid ( ) ; } / * * \\label{line2:token } * / class automaton {      private int state = ? ?",
    "; / * * \\label{line2:init - st } * /      static int num_state = ? ? ; / * * \\label{line2:num - st } * /      harness static void min_num_state ( ) { minimize(num_state ) ; } / * * \\label{line2:min - num - st } * /      public void transition(token t ) {          assert 0 < = state & & state < num_state ; / * * \\label{line2:chk - st } * /          int i d = t.getid ( ) ; / * * \\label{line2:getid } * /          minrepeat { / * * \\label{line2:minrepeat } * /              if ( state = = ? ? & & i d = = ? ? ) { state = ? ? ; return ; } / * * \\label{line2:transition } * /      }    }      public void transitions(iterator < token > it ) {          while(it.hasnext ( ) ) { transition(it.next ( ) ) ; }      }      public boolean accept ( ) { return state < = ? ? ; } / * * \\label{line2:accept } * / } ....      * transitions are taken based on the interface * the initial state is arbitrary ( line  [ line2:init - st ] ) * the number of states is arbitrary ( line  [ line2:num - st ] ) * states are dense ( line  [ line2:min - num - st ] ) * we use an assertion to check the validity of the current state ( line  [ line2:chk - st ] ) * a transition is arbitrary as it depends on an arbitrary current state and an arbitrary i d ( line  [ line2:transition ] ) * replicates its body the minimum necessary number of times . * the number of transitions is arbitrary ( line  [ line2:minrepeat ] ) * the number of accepting states is arbitrary ( line  [ line2:accept ] ) ; by packing the states densely , we could use an inequality here      .... class dbconnection {      class monitor extends automaton {          final static token open =              new token ( ) { public int getid ( ) { return 1 ; } } ;          final static token close =              new token ( ) { public int getid ( ) { return 2 ; } } ;          public monitor ( ) { }      }      monitor m ;      public dbconnection ( ) { m = new monitor ( ) ; }      public boolean iserroneous ( ) { return ! m.accept ( ) ; }      public void open ( ) { m.transition(monitor.open ) ; }      public void close ( ) { m.transition(monitor.close ) ; } } ....    the key idea is that each database connection operation is associated with an unique i d , and the monitor maintains an automaton that keeps receiving operation ids . at any point , a client can check the status of the connection by asking the monitor whether it is in an accepting state .      ....",
    "class testdbconnection {      harness static void scenario_good ( ) { / * * \\label{line : harness - good } * /          dbconnection conn = new dbconnection ( ) ;          assert ! conn.iserroneous ( ) ;          conn.open ( ) ;   assert !",
    "conn.iserroneous ( ) ;          conn.close ( ) ; assert !",
    "conn.iserroneous ( ) ;      }      // bad : opening more than once      harness static void scenario_bad1 ( ) { / * * \\label{line : harness - bad1 } * /          dbconnection conn = new dbconnection ( ) ;          conn.open ( ) ; conn.open ( ) ; assert conn.iserroneous ( ) ; }    } ....      .... class automaton {    int state = 0 ;    static int num_state = 3 ;    public void transition ( token t ) { ...      assert 0 < = state & & state < 3 ;      if ( state = = 0 & & i d = = 1 ) { state = 1 ; return ; } //",
    "open@      if ( state = = 1 & & i d = = 1 ) { state = 2 ; return ; } //",
    "open 2x    }    public boolean accept ( ) { return state < = 1 ; } ... } ....    this sort of looks okay , but it s odd that there are no transitions for the operation .",
    "when the monitor is in state 1 and the given operation is , it is fine for the monitor to stay at the same accepting state .",
    "but , it is problematic if we close the connection more than once , which we should have specified :    .... class testdbconnection { ...      // bad : closing more than once      harness static void scenario_bad2 ( ) { / * * \\label{line : harness - bad2 } * /          dbconnection conn = new dbconnection ( ) ;          conn.open ( ) ;          conn.close ( ) ; conn.close ( ) ; assert conn.iserroneous ( ) ; }    } ....      .... class automaton {    int state = 0 ;    static int num_state = 3 ;    public void transition ( token t ) { ...      assert 0 < = state & & state < 3 ;      if ( state = = 0 & & i d = = 1 ) { state = 1 ; return ; } //",
    "open@      if ( state = = 1 & & i d = = 1 ) { state = 2 ; return ; } //",
    "open 2x      if ( state = = 1 & & i d",
    "= = 2 ) { state = 0 ; return ; } // ( init)@      if ( state = = 0 & & i d = = 2 ) { state = 2 ; return ; } // close 2x    }    public boolean accept ( ) { return state < = 1 ; } ... } ....        now let s consider synthesizing another automaton , trying to create a finite automaton given sample accepting and rejecting inputs .",
    "one benefit of java as an object oriented language is code reuse via subclassing , so we could just make another class that extends , assuming we want this to be part of the same program .",
    "but subclassing wo nt quite work here because we need different automata for each use case .",
    "note the overloaded method .",
    "now , we need to specify sample strings that are accepted or rejected by the synthesized automaton .",
    "suppose we want to synthesize an automaton that recognizes lisp - style identifier ` c(a|d)+r ` .",
    "the following harness constructs a instance and makes several assertions about its behavior :    .... class testcadsr {      harness static void examples ( ) {          cadsr a = new cadsr ( ) ;          assert ! a.accept(\"c \" ) ;   assert ! a.accept(\"cr \" ) ;          assert a.accept(\"car \" ) ;   assert a.accept(\"cdr \" ) ;          assert a.accept(\"caar \" ) ; assert a.accept(\"cadr \" ) ;          assert a.accept(\"cdar \" ) ; assert a.accept(\"cddr \" ) ; }    } ....    if we provide less examples , e.g. , if we remove examples about rejected strings , the synthesizer simply returns an automaton that does not make any transitions , while the initial state is an accepting state .",
    "this awkward automaton actually conforms to any accepted strings , and one can easily figure out the necessity of rejected strings .      ....",
    "class automaton2 {    int state = 106 ; static int num_state = 120 ;    public void transition ( token t ) { ...      if ( state = = 106 & & i d = = 99 ) { state = 64 ; return ; }   //",
    "c      if ( state = = 64 & & i d = = 97 ) { state = 100 ; return ; }   // ca      if ( state = = 100 & & i d = = 114 ) { state = 50 ; return ; } // car@      if ( state = = 64 & & i d = = 100 ) { state = 119 ; return ; }",
    "// cd      if ( state = = 119 & & i d = = 114 ) { state = 32 ; return ; } // cdr@      if ( state = = 64 & & i d = = 114 ) { state = 72 ; return ; }   //",
    "cr    }    public boolean accept ( ) { return state < = 50 ; } ... } ....    notice that the synthesizer picked fairly strange numbers for the states and left a lot of states unused .",
    "moreover , the automaton is inefficient in that it uses two different paths and final states to accept `` '' and `` '' .      ....",
    "class automaton2 {    int state = 0 ; static int num_state = 3 ;    public void transition ( token t ) { ...      assert 0 < = state & & state < 3 ;      if ( state = = 0 & & i d = = 99 )   { state = 1 ; return ; } //",
    "c      if ( state = = 1 & & i d = = 97 )   { state = 2 ; return ; } // ca      if ( state = = 1 & & i d = = 100 ) { state = 2 ; return ; } // cd      if ( state = = 2 & & i d = = 114 ) { state = 0 ; return ; } //",
    "c(a|d)+r@    }    public boolean accept ( ) { return state < = 0 ; } ... } ....                .... $ cat result / sk_test / simplemath.sk ... int e_h1 = ? ? ; int mult2_simplemath_int(int x ) { return e_h1 * { | x | 0 | } ; } $ cat result / sk_test / test.sk ... harness void test_test ( ) { assert mult2_simplemath_int(3 ) = = 6 ; } ....      .... $ cat result / log / log.txt ... 06:07:15 [ debug ] java_sk / decode / finder.py:41 hole : simplemath.e_h1 06:07:15 [ info ]",
    "java_sk / decode/__init__.py:69 replacing holes 06:07:15 [ debug ] java_sk /",
    "decode / replacer.py:72 replaced : simplemath.e_h1 = 2 06:07:15 [ debug ] java_sk / decode / replacer.py:89 replaced : e_h1 @ int simplemath.mult2(int ) with 2 06:07:15 [ debug ] java_sk /",
    "decode / finder.py:93 generator@mult2 : { | x | 0 | } 06:07:15 [ info ] java_sk",
    "/ decode/__init__.py:79 replacing generators 06:07:15 [ debug ] java_sk / decode / replacer.py:151 { | x | 0 | } = > x ... ...."
  ],
  "abstract_text": [
    "<S> sketch - based synthesis , epitomized by the sketch tool , lets developers synthesize software starting from a _ partial program _ , also called a _ sketch _ or _ template_. this paper presents jsketch , a tool that brings sketch - based synthesis to java . </S>",
    "<S> jsketch s input is a partial java program that may include _ holes _ , which are unknown constants , _ expression generators _ , which range over sets of expressions , and _ class generators _ , which are partial classes . </S>",
    "<S> jsketch then translates the synthesis problem into a sketch problem ; this translation is complex because sketch is not object - oriented . </S>",
    "<S> finally , jsketch synthesizes an executable java program by interpreting the output of sketch . </S>"
  ]
}