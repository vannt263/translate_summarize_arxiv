{
  "article_text": [
    "we introduce in this paper the language which extends the @xmath0-ary description logics  @xcite and  @xcite as follows :    * the semantics is based on attribute - labelled tuples : an element of a tuple is identified by an attribute and not by its position in the tuple , e.g. , the relation ` person ` has attributes ` firstname ` , ` lastname ` , ` age ` , ` height ` with instance : + ` \\langle firstname : enrico , lastname : franconi , age : 53 , height : 1.90\\rangle ` ; * renaming of attributes is possible , e.g. , to recover the positional semantics : + @xmath1 ; * it can express projections of relations , and therefore inclusion dependencies , e.g. , @xmath2 ; * it can express multiple - attribute cardinalities , and therefore functional dependencies and multiple - attribute keys , e.g. , the functional dependency from ` firstname , ` ` lastname ` to ` age ` in ` person ` can be written as : + @xmath3 \\texttt{person } \\sqsubseteq$ ] + @xmath4(\\exists[\\texttt{firstname , lastname , age } ] \\texttt{person})$ ] ; * it can express global and local objectification ( also known as reification ) : a tuple may be identified by a unique global identifier , or by an identifier which is unique only within the interpretation of a relation , e.g. , to identify the name of a person we can write @xmath5 \\texttt{person } } } $ ] .",
    "we show how a simple syntactic condition on the appearance of projections in the knowledge base makes the language decidable without increasing the computational complexity of the basic language .",
    "we call this fragment of .",
    "is able to correctly express the uml fragment as introduced in  @xcite and the orm fragment as introduced in  @xcite .",
    "[ t ]    @xmath6    [ t ]    @xmath7    we first define the syntax of the language .",
    "signature _ in is a triple @xmath8 consisting of a finite set @xmath9 of _ concept _ names ( denoted by @xmath10 ) , a finite set @xmath11 of _ relation _ names ( denoted by @xmath12 ) disjoint from @xmath9 , and a finite set @xmath13 of _ attributes _ ( denoted by @xmath14 ) , and a _ relation signature _",
    "function @xmath15 associating a set of attributes to each relation name , @xmath16 with @xmath17 .",
    "the syntax of concepts @xmath18 , relations @xmath19 , formulas @xmath20 , and attribute renaming axioms @xmath21 is defined in figure  [ fig : dlrp ] , where @xmath22 is a positive integer and @xmath23 .",
    "we extend the signature function @xmath15 to arbitrary relations as specified in figure  [ fig : syn : tau ] .",
    "we define the arity of a relation @xmath19 as the number of the attributes in its signature , namely @xmath24 .",
    "a _ tbox _ is a finite set of formulas , i.e. , _ concept inclusion _ axioms of the form @xmath25 and _ relation inclusion _ axioms of the form @xmath26 . +",
    "a renaming schema induces an equivalence relation @xmath27 over the attributes @xmath13 , providing a partition of @xmath13 into equivalence classes each one representing the alternative ways to name attributes .",
    "we write @xmath28_\\re$ ] to denote the equivalence class of the attribute @xmath14 w.r.t .",
    "the equivalence relation @xmath27 .",
    "we allow only _ well founded _ renaming schemas , namely schemas such that each equivalence class @xmath28_\\re$ ] in the induced equivalence relation never contains two attributes from the same relation signature . in the following we use the shortcut @xmath29 to group many renaming axioms , with the obvious",
    "meaning that @xmath30 , for all @xmath31 .",
    "a knowledge base @xmath32 is composed by a tbox @xmath33 and a renaming schema @xmath34 .",
    "the renaming schema reconciles the attribute and the positional perspectives on relations ( see also the similar perspectives in relational databases  @xcite ) .",
    "they are crucial when expressing both inclusion axioms and operators ( @xmath35 ) between relations , which make sense only over _ union compatible _ relations .",
    "two relations @xmath36 are union compatible if their signatures are equal up to the attribute renaming induced by the renaming schema @xmath34 , namely , @xmath37 and @xmath38 have the same arity @xmath0 and @xmath39_\\re=[v_i]_\\re$ ] for each @xmath40 .",
    "notice that , thanks to the renaming schema , relations can use just local attribute names that can then be renamed when composing relations .",
    "also note that it is obviously possible for the same attribute to appear in the signature of different relations .    to show the expressive power of the language ,",
    "let us consider the following example with tree relation names @xmath41 and @xmath42 with the following signature : @xmath43 to state that @xmath44 is the _ multi - attribute key _ of @xmath45 we add the axiom : @xmath46 r_1 \\sqsubseteq \\exists^{\\leq 1}[u_1,u_2 ] r_1    \\end{aligned}\\ ] ] where @xmath47 r$ ] stands for @xmath48 r$ ] . to express that there is a _ functional dependency _ from the attributes @xmath49 to the attribute @xmath50 of @xmath51 we add the axiom : @xmath52 r_2 \\sqsubseteq \\exists^{\\leq 1}[v_3,v_4](\\exists[v_3,v_4,v_5 ] r_2)\\end{aligned}\\ ] ] the following axioms express that @xmath51 is a sub - relation of @xmath45 and that a projection of @xmath42 is a sub - relation of a projection of @xmath45 , together with the corresponding axioms for the renaming schema to explicitly specify the correspondences between the attributes of the two inclusion dependencies : @xmath53 r_3 & \\sqsubseteq \\exists[u_3,u_4,u_5 ] r_1\\\\    v_1v_2v_3v_4v_5 & \\looparrowright u_1u_2u_3u_4u_5 \\\\",
    "w_1w_2w_3 & \\looparrowright u_3u_4u_5\\end{aligned}\\ ] ]",
    "[ t ]    @xmath54=d\\}\\right| \\lesseqgtr q \\}\\\\                          { ( { \\ensuremath{\\bigocircr}})^{\\imc}\\xspace } = & \\{d\\in { \\ensuremath{\\delta}\\xspace}\\mid d=\\imath(t ) \\land t\\in { r^{\\imc}\\xspace}\\}\\\\                                      \\vspace{2ex }                                      { ( { \\ensuremath{\\bigodotr\\!n}})^{\\imc}\\xspace } = & \\{d\\in { \\ensuremath{\\delta}\\xspace}\\mid d=\\ell_{r\\!n}(t)\\land t\\in",
    "{ r\\!n^{\\imc}\\xspace}\\}\\\\                          { ( r_1\\setminus r_2)^{\\imc}\\xspace } = & { r^{\\imc}\\xspace}_{1 } \\setminus { r^{\\imc}\\xspace}_{2}\\\\                          { ( r_{1}\\sqcap r_{2})^{\\imc}\\xspace } = & { r^{\\imc}\\xspace}_{1 } \\cap { r^{\\imc}\\xspace}_{2}\\\\                          { ( r_{1}\\sqcup r_{2})^{\\imc}\\xspace } = & \\{t\\in{r^{\\imc}\\xspace}_{1}\\cup{r^{\\imc}\\xspace}_{2}\\mid \\rho(\\tau(r_1))= \\rho(\\tau(r_2))\\}\\\\                          { ( \\selects { u_i}{c}{r})^{\\imc}\\xspace } = & \\{\\parbox[t ] {              \\textwidth}{$ t\\in{r^{\\imc}\\xspace } \\mid t[\\rho(u_i)]\\in{c^{\\imc}\\xspace}\\ } $ } \\\\                          { ( \\existr{q}{u_1,\\ldots , u_k } r)^{\\imc}\\xspace } = & \\ { \\parbox[t ] {              \\textwidth}{$ \\langle \\rho(u_1):d_1,\\ldots,\\rho(u_k):d_k\\rangle \\in t_{{\\ensuremath{\\delta}\\xspace}}(\\{\\rho(u_1),\\ldots,\\rho(u_k)\\ } ) \\mid~\\vspace{0.5ex}\\\\              \\left|\\{t\\in{r^{\\imc}\\xspace } \\mid t[\\rho(u_1)]=d_1,\\ldots , t[\\rho(u_k)]=d_k\\}\\right| \\lesseqgtr q \\ } $ }           \\end{array }          } $ ]    the semantics makes use of the notion of _ labelled tuples _ over a domain set @xmath55 : a _ @xmath13-labelled tuple over @xmath55 _ is a function @xmath56 . for @xmath57 , we write @xmath58 $ ] to refer to the domain element @xmath59 labelled by @xmath14 , if the function @xmath60 is defined for @xmath14  that is , if the attribute @xmath14 is a label of the tuple @xmath60 . given @xmath61 , the expression @xmath62 stands for the @xmath13-labelled tuple @xmath60 over @xmath55 ( tuple , for short ) such that @xmath63=d_i}$ ] , for @xmath64 .",
    "we write @xmath65}$ ] to denote the _ projection _ of the tuple @xmath60 over the attributes @xmath66 , namely the function @xmath60 restricted to be undefined for the labels not in @xmath66 .",
    "the set of all @xmath13-labelled tuples over @xmath55 is denoted by @xmath67 .    a _ interpretation _ , @xmath68 , consists of a nonempty _ domain _ @xmath69 , an _ interpretation function _",
    "@xmath70 , a _ renaming function _ @xmath71 , a _ global objectification function _ @xmath72 , and a family of _ local objectification functions _",
    "@xmath73 , one for each named relation @xmath74 .",
    "the renaming function @xmath71 for attributes is a total function @xmath75 representing a canonical renaming for all attributes .",
    "we consider , as a shortcut , the notation @xmath76 .",
    "+ the global objectification function is an injective function , @xmath77 , associating a _ unique _ global identifier to each possible tuple .",
    "+ the local objectification functions , @xmath78 , are distinct for each relation name in the signature , and as the global objectification function they are injective : they associate an identifier  which is unique only within the interpretation of a relation name  to each possible tuple . + the interpretation function @xmath70 assigns a set of domain elements to each concept name , @xmath79 , and a set of @xmath80-labelled tuples over @xmath69 to each relation name conforming with its signature and the renaming function : @xmath81    the interpretation function @xmath70 is unambiguously extended over concept and relation expressions as specified in the inductive definition of fig .",
    "[ fig : sem : dlrp ] .",
    "an interpretation @xmath82 satisfies a concept inclusion axiom @xmath25 if @xmath83 , it satisfies a relation inclusion axiom @xmath26 if @xmath84 , and it satisfies a renaming schema @xmath34 if the renaming function @xmath71 renames the attributes in a consistent way with respect to @xmath34 , namely if @xmath85_\\re\\land\\forall v\\in [ u]_\\re{\\mathpunct{\\mbox{\\bf .}}}\\rho(u)=\\rho(v).\\ ] ]    an interpretation is a _ model _ for a knowledge base @xmath86 if it satisfies all the formulas in the tbox @xmath33 and it satisfies the renaming schema @xmath34 .",
    "we define _ kb satisfiability _ as the problem of deciding the existence of a model of a given knowledge base , _ concept satisfiability _ ( resp .",
    "_ relation satisfiability _ ) as the problem of deciding whether there is a model of the knowledge base that assigns a non - empty extension to a given concept ( resp .",
    "relation ) , and _ entailment _ as the problem to check whether a given knowledge base logically implies a formula , that is , whenever all the models of the knowledge base are also models of the formula .",
    "+ for example , from the knowledge base @xmath87 introduced in the previous section the following logical implication holds : @xmath88 r_2 \\sqsubseteq \\exists^{\\leq 1}[v_1,v_2 ] r_2\\end{aligned}\\ ] ] i.e. , the attributes @xmath89 are a key for the relation @xmath51 .",
    "the problems of kb satisfiability , concept and relation satisfiability , and entailment are mutually reducible in .",
    "we first show that we can reduce all the problems to concept satisfiability , where a concept @xmath18 is satisfiable iff @xmath90 .",
    "* @xmath87is satisfiable iff @xmath91 ; * @xmath92 iff @xmath93 ; * @xmath94 iff @xmath95(r_1\\sqcap \\neg r_2)\\sqsubseteq \\bot$ ] , for some @xmath96 ; * @xmath97 iff @xmath98r\\sqsubseteq \\bot$ ] , for some @xmath99 .",
    "viceversa , we can show that concept satisfiability can be reduced to any other problem .",
    "first , note that concept satisfiability is already expressed as a logical implication problem . for the other cases ,",
    "given a fresh new binary relation @xmath100 , we have that    * @xmath90 iff @xmath101(p\\sqcap \\sigma_{u_2:c}p)\\}$ ] is satisfiable ; * @xmath90 iff @xmath102",
    ".    can express complex inclusion and functional dependencies , for which it is well known that reasoning is undecidable  @xcite .",
    "also includes the extension together with unary functional dependencies  @xcite , which also has been proved to be undecidable .",
    "given a knowledge base @xmath103 , we define the _ projection signature _ as the set @xmath104 including the signatures @xmath105 of the relations @xmath106 , the singletons associated with each attribute name @xmath107 , and the relation signatures as they appear explicitly in projection constructs in the relation inclusion axioms of the knowledge base , together with their implicit occurrences due to the renaming schema :    1 .",
    "@xmath108 @xmath106 ; 2 .",
    "@xmath109 @xmath107 ; 3 .",
    "@xmath110 @xmath111 @xmath112_\\re $ ]  @xmath113 .",
    "we call _ projection signature graph _ the directed acyclic graph @xmath114 with the attribute singletons @xmath115 being the sinks .",
    "the fragment of allows only for knowledge bases with a projection signature graph being a _ multitree _ , namely the set of nodes reachable from any node of the projection signature graph should form a tree .",
    "given a relation name @xmath116 , the subgraph of the projection signature graph dominated by @xmath116 is a tree where the leaves are all the attributes in @xmath117 and the root is @xmath117 .",
    "+ we call @xmath118 the tree formed by the nodes in the projection signature graph dominated by the set of attributes @xmath119 . given two relation signatures ( i.e. , two sets of attributes ) @xmath120 , by @xmath121 we denote the path in @xmath114 between @xmath122 and @xmath123 , if it exists .",
    "note that @xmath124 both when a path does not exist and when @xmath125 , and @xmath126 is functional in due to the multitree restriction on projection signatures .",
    "the notation @xmath127 means that @xmath128 is a child of @xmath129 in @xmath114 .",
    "in addition to the above multitree condition , the fragment of allows for knowledge bases with projection constructs @xmath130 ( resp .",
    "@xmath131 ) with a cardinality @xmath132 only if the length of the path @xmath133 ( resp .",
    "@xmath134 ) is 1 .",
    "this allows to map cardinalities in into cardinalities in .",
    "figure  [ fig : multitree ] shows that the projection signature graph of the knowledge base introduced in section  [ sec : syntax ] is indeed a multitree .",
    "note that in the figure we have collapsed equivalent attributes in a unique equivalence class , according to the renaming schema .",
    "restricts only in the way multiple projections of relations appear in the knowledge base .",
    "it is easy to see that is included in , since the projection signature graph of any knowledge base has maximum depth equal to 1 .  @xcite",
    "together with ( unary ) functional dependencies is also included in , with the proviso that projections of relations in the knowledge base form a multitree projection signature graph . since ( unary )",
    "functional dependencies are expressed via the inclusions of projections of relations ( see , e.g. , the functional dependency  ( [ funct - dep ] ) in the previous example ) , by constraining the projection signature graph to be a multitree , the possibility to build combinations of functional dependencies as the ones in  @xcite leading to undecidability is ruled out . also note that is able to correctly express the uml fragment as introduced in  @xcite and the orm fragment as introduced in  @xcite .",
    "we show that reasoning in is -complete by providing a mapping from knowledge bases to knowledge bases ; the reverse mapping from knowledge bases to knowledge bases is well known . the proof is based on the fact that reasoning with knowledge bases is -complete  @xcite . we adapt and extend the mapping presented for in  @xcite .    in the following we use the shortcut @xmath135 for @xmath136 , the shortcut @xmath137 for @xmath138 and the shortcut @xmath139 for @xmath140 . note that these shortcuts for the role chain constructor `` @xmath141 '' are not correct in general , but they are correct in the context of the specific knowledge bases used in this paper .",
    "let @xmath142 be a knowledge base .",
    "we first rewrite the knowledge base as follows : for each equivalence class @xmath28_{\\re}$ ] a single _ canonical _ representative of the class is chosen , and the @xmath87is consistently rewritten by substituting each attribute with its canonical representative . after this rewriting , the renaming schema does not play any role in the mapping .    the mapping function @xmath143 maps each concept name @xmath10 in the knowledge base to an concept name @xmath10 , each relation name @xmath12 in the knowledge base to an concept name @xmath144 ( its global reification ) , and each attribute name @xmath14 in the knowledge base to an role name , as detailed below .",
    "+ for each relation name @xmath12 the mapping introduces a concept name @xmath145 and a role name @xmath146 ( to capture the local reification ) , and a concept name @xmath147 for each projected signature @xmath148 in the projection signature graph dominated by @xmath105 , @xmath149 ( to capture global reifications of the projections of @xmath12 ) .",
    "note that @xmath150 coincides with @xmath144 .",
    "furthermore , the mapping introduces a role name @xmath151 for each projected signature @xmath148 in the projection signature , @xmath152 , such that there exists @xmath153 with @xmath154 , i.e. , we exclude the case where @xmath148 is one of the roots of the multitree induced by the projection signature .",
    "+ the mapping @xmath143 applies also to a path .",
    "let @xmath155 be two generic sets of attributes such that the function @xmath156 , then , a path is mapped as follows : @xmath157    intuitively , the mapping reifies each node in the projection signature graph : the target signature of the example of the previous section is partially presented in fig .",
    "[ fig : mapping ] , together with the projection signature graph .",
    "each node is labelled with the corresponding ( global ) reification concept ( @xmath158 ) , for each relation name @xmath159 and each projected signature @xmath160 in the projection signature graph dominated by @xmath161 , while the edges are labelled by the roles ( @xmath151 ) needed for the reification .",
    "[ t ]    @xmath162    the mapping @xmath143 is extended to concept and relation expressions as in figure  [ fig : themapping ] , with the proviso that whenever @xmath121 returns an empty path then the translation for the corresponding expression becomes the bottom concept .",
    "note that in the cardinalities on a path are restricted to the case @xmath163 whenever a path is of length greater than @xmath164 , so we still remain within the description logic when the mapping applies to cardinalities .",
    "so , if we need to express a cardinality constraint @xmath165 , ] with @xmath132 , then @xmath166 should not be mentioned in any other projection of the relation @xmath19 in such a way that @xmath167 .    in order to explain the need for",
    "the path function in the mapping , notice that a relation is reified according to the decomposition dictated by projection signature graph it dominates .",
    "thus , to access an attribute @xmath168 of a relation @xmath169 it is necessary to follow the path through the projections that use that attribute .",
    "this path is a role chain from the signature of the relation ( the root ) to the attribute as returned by the @xmath170 function .",
    "for example , considering fig .",
    "[ fig : mapping ] , in order to access the attribute @xmath171 of the relation @xmath42 in the expression @xmath172 , the path @xmath173 is equal to the role chain @xmath174 , so that @xmath175 + similar considerations can be done when mapping cardinalities over relation projections .",
    "the mapping @xmath176 of a knowledge base @xmath87with a signature @xmath177 is defined as the following tbox : @xmath178 where @xmath179{\\textwidth}{$ a_{r\\!n}\\sqsubseteq\\exists q_{r\\!n}{\\mathpunct{\\mbox{\\bf .}}}a_{r\\!n}^l,~",
    ".}}}\\top\\sqsubseteq \\bot,\\\\ a_{r\\!n}^l \\sqsubseteq \\exists q_{r\\!n}^-{\\mathpunct{\\mbox{\\bf",
    ".}}}a_{r\\!n},~ \\exists^{\\geq 2 } q_{r\\!n}^-{\\mathpunct{\\mbox{\\bf .}}}\\top\\sqsubseteq \\bot\\}.$ }     \\ ] ]    intuitively , @xmath180 ensures that relations with different signatures are disjoint , thus , e.g. , enforcing the union compatibility .",
    "the axioms in @xmath181 introduce classical reification axioms for each relation and its relevant projections .",
    "the axioms in @xmath182 make sure that each local objectification differs form the global one .    clearly , the size of @xmath176 is polynomial in the size of @xmath183 ( under the same coding of the numerical parameters ) , and thus we are able to state the main result of this paper .",
    "[ th : sat ] a knowledge base @xmath183 is satisfiable iff the knowledge base @xmath176 is satisfiable .",
    "we assume that the @xmath87is consistently rewritten by substituting each attribute with its canonical representative , thus , we do not have to deal with the renaming of attributes . furthermore , we extend the function @xmath72 to singleton tuples with the meaning that @xmath184 .",
    "+ ( @xmath185 ) let @xmath186 be a model for a knowledge base @xmath183 . to construct a model @xmath187 for the knowledge base @xmath176 we set @xmath188 .",
    "furthermore , we set : @xmath189 , for every atomic concept @xmath190 , while for every @xmath191 and @xmath192 we set @xmath193=d_1,\\ldots , t[u_k]=d_k\\}.    \\end{gathered}\\ ] ] for each role name @xmath151 , @xmath152 , we set @xmath194 ) , d_2=\\imath(t[{\\tau_i}])\\\\      \\text { and } { \\ensuremath{\\textsc{child}_{\\mathscr{t}}(\\tau_j,\\tau_i)}\\xspace } , \\text { for some } { r\\!n}\\in\\r\\}.    \\end{gathered}\\ ] ] for every @xmath191 we set @xmath195 and @xmath196 we now show that @xmath197 is indeed a model of @xmath176 .    1 .   @xmath198 .",
    "this is a direct consequence of the fact that @xmath72 is an injective function and that tuples with different aryties are different tuples .",
    "2 .   @xmath199 , for every @xmath200 .",
    "we show that , for each @xmath201 s.t .",
    "@xmath202 and @xmath149 , @xmath203 and @xmath204 : * @xmath203 .",
    "let @xmath205 , by  ( [ eq : r ] ) , @xmath206 s.t .",
    "@xmath207)$ ] . since @xmath202 , then @xmath208)$ ] and , by  ( [ eq : q ] ) , @xmath209 , while by  ( [ eq : r ] ) , @xmath210 .",
    "thus , @xmath211 . *",
    "the fact that each @xmath212 is interpreted as a funcional role is a direct consequence of the construction  ( [ eq : q ] ) and the fact that @xmath72 is an injective function .",
    "@xmath213 , for every @xmath200 .",
    "similar as above , considering the fact that each @xmath214 is an injective function and equations  ( [ eq : loc])-([eq : aloc ] ) .",
    "4 .   @xmath215 and @xmath216 .",
    "since @xmath217 and @xmath218 , it is enough to show the following : * @xmath219 , for all  concepts ; * @xmath220 , for all  relations .",
    "+ before we proceed with the proof , it is easy to show by structural induction that the following property holds : @xmath221 , \\text { for some } r\\!n\\in\\r .",
    "\\end{aligned}\\ ] ] we now proceed with the proof by structural induction .",
    "the base cases , for atomic concepts and roles , are immediate form the definition of both @xmath222 and @xmath223 .",
    "the cases where complex concepts and relations are constructed using either boolean operators or global reification are easy to show .",
    "we thus show only the following cases .",
    "+ let @xmath224 . then , @xmath225 with @xmath226 . by induction ,",
    "@xmath227 and , by @xmath228 , there is a @xmath229 s.t . @xmath230 and @xmath231 . by  ( [ eq : loc ] ) , @xmath232 and , since @xmath214 is injective , @xmath233 .",
    "thus , @xmath234 . + let @xmath235 r)^\\imc$ ] .",
    "then , there are different @xmath236 s.t .",
    "@xmath237=d$ ] , for all @xmath238 . by induction ,",
    "@xmath239 while , by  ( [ prop : rn1 ] ) , @xmath240 , for some atomic relation @xmath241 and a tuple @xmath242 s.t .",
    "@xmath243 $ ] . by  @xmath244 and  ( [ eq : q ] ) , @xmath245 and @xmath246 . since @xmath72 is injective , @xmath247 when @xmath248 , thus , @xmath235 r)^{\\dag\\jmc}$ ] .",
    "+ let @xmath249 .",
    "then , @xmath250 and @xmath251\\in c^\\imc$ ] and , by induction , @xmath252 and @xmath251\\in c^{\\dag \\jmc}$ ] . as before , by @xmath253 and by  ( [ eq : q ] ) and ( [ prop : rn1 ] ) , @xmath254)\\in({\\ensuremath{\\textsc{path}_{\\mathscr{t}}(\\tau(r),\\{u_i\\})}\\xspace}^\\dag)^\\jmc$ ] .",
    "since @xmath255 is functional , then we have that @xmath256 .",
    "+ let @xmath257 r)^{\\imc}$ ] .",
    "then , there is a tuple @xmath258 s.t .",
    "@xmath259=t$ ] and , by induction , @xmath260 . as before , by @xmath253 and by  ( [ eq : q ] ) and ( [ prop : rn1 ] ) , we can show that @xmath261 and thus @xmath262 r)^{\\dag\\jmc}$ ] .",
    "+ all the other cases can be proved in a similar way .",
    "we now show the vice versa .",
    "+ let @xmath234 .",
    "then , @xmath263 and @xmath264 , for some @xmath265 , i.e. , @xmath224 .",
    "+ let @xmath266 r)^{\\dag \\jmc}$ ] .",
    "then , there are different @xmath267 s.t . @xmath268 and @xmath269 , for @xmath238 . by induction , each @xmath270 and @xmath271 .",
    "since @xmath72 is injective , then @xmath272 for all @xmath273 , @xmath248 .",
    "we need to show that @xmath237 = d$ ] , for all @xmath238 . by  ( [ eq : q ] ) and the fact that @xmath268 , then @xmath274)=t_l[u_i]$ ] .",
    "+ let @xmath275 .",
    "then , @xmath252 and , by induction , @xmath250 .",
    "let @xmath251=d$ ] .",
    "we need to show that @xmath276 . by @xmath253 and by  ( [ eq : q ] ) and ( [ prop : rn1 ] ) , @xmath277 , then @xmath278 and , by induction , @xmath279 .",
    "+ let @xmath262 r)^{\\dag\\jmc}$ ] .",
    "then , there is @xmath280 s.t . @xmath281 and @xmath282 . by induction , @xmath283 and @xmath258 . by  ( [ eq : q ] ) , @xmath284)$ ] , i.e. , @xmath285 $ ] .",
    "thus , @xmath257 r)^{\\imc}$ ] .",
    "+ ( @xmath286 ) let @xmath187 be a model for the knowledge base @xmath176 . without loss of generality",
    ", we can assume that @xmath197 is a _",
    "we then construct a model @xmath287 for a knowledge base @xmath183 .",
    "we set : @xmath288 , @xmath289 , for every atomic concept @xmath190 , while , for every @xmath191 , we set : @xmath290)\\in ( { \\ensuremath{\\textsc{path}_{\\mathscr{t}}(\\tau(r\\!n),\\{u_i\\})}\\xspace}^\\dag)^\\jmc \\text { for } i=1,\\ldots , n\\}.\\end{gathered}\\ ] ] since @xmath197 satisfies @xmath253 , then , for every @xmath291 there is a unique tuple @xmath292 , we say that @xmath293 _ generates _ @xmath294 and , in symbols , @xmath295 .",
    "furthermore , since is tree shaped , to each tuple corresponds a unique @xmath293 that generates it .",
    "thus , let @xmath295 , by setting @xmath296 and @xmath297)=d_{\\tau_i } , \\text { s.t . } \\\\    ( d , d_{\\tau_i})\\in({\\ensuremath{\\textsc{path}_{\\mathscr{t}}(\\{u_1,\\ldots , u_n\\},\\tau_i)}\\xspace}^\\dag)^\\jmc,\\end{gathered}\\ ] ] for all @xmath298 , then , the function @xmath72 is as required .",
    "+ by setting @xmath299 by @xmath300 , both @xmath146 and its inverse are interpreted as a functional roles by , thus the function @xmath214 is as required .",
    "+ it is easy to show by structural induction that the following property holds : @xmath301 , \\text { for some } r\\!n\\in\\r.\\end{aligned}\\ ] ] we now show that @xmath82 is indeed a model of @xmath183 , i.e. , @xmath217 and @xmath218 .",
    "as before , since @xmath215 and @xmath302 , it is enough to show the following : * @xmath219 , for all  concepts ; * @xmath220 , for all  relations .",
    "+ the proof is by structural induction .",
    "the base cases are trivially true .",
    "similarly for the boolean operators and global reification . we thus show only the following cases .",
    "+ let @xmath224 . then , @xmath225 with @xmath226 . by induction ,",
    "@xmath227 and , by @xmath228 , there is a @xmath229 s.t . @xmath230 and @xmath231 . by  ( [ eq : lobj ] ) , @xmath303 and thus , @xmath304 .",
    "+ let @xmath266 r)^{\\imc}$ ] .",
    "then , there are different @xmath236 s.t .",
    "@xmath237=d$ ] , for all @xmath238 . for each @xmath305 ,",
    "by  ( [ prop : rn ] ) , there is a @xmath306 $ ] , for some @xmath307 , while , by induction , @xmath239 and @xmath240 .",
    "thus , @xmath308=t_l[u_i]=d$ ] and , by  ( [ eq : rn ] ) , @xmath309 while , by  ( [ eq : iota ] ) , @xmath310 .",
    "since allows only for knowledge bases with a projection signature graph being a multitree , then , @xmath311 thus , @xmath312 and , since @xmath72 is injective , then , @xmath247 when @xmath248 .",
    "thus , @xmath266 r)^{\\dag\\jmc}$ ] .",
    "+ let @xmath249 .",
    "then , @xmath250 and @xmath251=d\\in c^\\imc$ ] . by induction ,",
    "@xmath313 and @xmath314 . as before , by  ( [ eq : rn ] ) ,  ( [ eq : iota ] ) and  ( [ prop : rn ] ) , we can show that @xmath277 and , since @xmath315 is functional , then @xmath275 .",
    "+ let @xmath257 r)^{\\imc}$ ] .",
    "then , there is a tuple @xmath258 s.t .",
    "@xmath259=t$ ] and , by induction , @xmath260 . as before , by  ( [ eq : iota ] ) and ( [ prop : rn ] ) , we can show that @xmath261 and thus @xmath262 r)^{\\dag\\jmc}$ ] .",
    "+ all the other cases can be proved in a similar way .",
    "we now show the vice versa .",
    "+ let @xmath234 .",
    "then , @xmath263 and , by @xmath228 , there is a @xmath229 s.t . @xmath316 and @xmath317 . by induction , @xmath318 with @xmath319 and thus , @xmath320 and , by  ( [ eq : lobj ] ) , @xmath321 , i.e. , @xmath224 .",
    "+ let @xmath266 r)^{\\dag \\jmc}$ ] .",
    "thus , there are different @xmath267 s.t . @xmath268 and @xmath269 , for @xmath238 . by induction , each @xmath270 and @xmath271 . since @xmath72 is injective , then @xmath272 for all @xmath273 , @xmath248 .",
    "we need to show that @xmath237 = d$ ] , for all @xmath238 .",
    "by  ( [ prop : rn ] ) , there is a @xmath306 , \\text { for some    } r\\!n\\in\\r$ ] and , by  ( [ eq : iota ] ) , @xmath322 . since @xmath323 and @xmath126 is functional in , then , @xmath324 and , by  ( [ eq : rn ] ) , @xmath308=t_l[u_i ] = d$ ] .",
    "+ let @xmath275 .",
    "thus , @xmath252 and , by induction , @xmath250 .",
    "let @xmath251=d$ ] .",
    "we need to show that @xmath276 . as before ,",
    "by  ( [ prop : rn ] ) and  ( [ eq : iota ] ) , we have that @xmath277",
    ". then @xmath278 and , by induction , @xmath279 .",
    "+ let @xmath262 r)^{\\dag\\jmc}$ ] .",
    "then , there is @xmath280 s.t . @xmath281 and @xmath325 . by induction , @xmath283 and @xmath258 .",
    "as before , by  ( [ eq : iota ] ) and ( [ prop : rn ] ) , we can show that there is a tuple @xmath326 s.t .",
    "@xmath327 and thus , @xmath285 $ ] , i.e. , @xmath257 r)^{\\imc}$ ] .    as a direct consequence of the above theorem and the fact that is a sublanguage of",
    ", we have that    reasoning in is an -complete problem .",
    "we thank alessandro mosca for working with us on all the preliminary work necessary to understand how to get these technical results .",
    "a.  artale , d.  calvanese , r.  kontchakov , v.  ryzhikov , and m.  zakharyaschev .",
    "reasoning over extended er models . in _ proc .  of the 26th int .",
    "conf .  on conceptual modeling ( er07 )",
    "_ , volume 4801 of _ lecture notes in computer science _ , pages 277292 .",
    "springer , 2007 .",
    "d.  calvanese , g.  de giacomo , and m.  lenzerini . on the decidability of query containment under constraints . in _ proc . of the 17th acm sym . on principles of database systems ( pods98 )",
    "_ , pages 149158 , 1998 .",
    "diego calvanese , giuseppe de giacomo , and maurizio lenzerini .",
    "identification constraints and functional dependencies in description logics .",
    "in _ proceedings of the seventeenth international joint conference on artificial intelligence , ijcai-01 _ , pages 155160 .",
    "morgan kaufmann , 2001 ."
  ],
  "abstract_text": [
    "<S> we introduce an extension of the n - ary description logic to deal with attribute - labelled tuples ( generalising the positional notation ) , with arbitrary projections of relations ( inclusion dependencies ) , generic functional dependencies and with global and local objectification ( reifying relations or their projections ) . </S>",
    "<S> we show how a simple syntactic condition on the appearance of projections and functional dependencies in a knowledge base makes the language decidable without increasing the computational complexity of the basic language . </S>"
  ]
}