{
  "article_text": [
    "the construction of intelligent agents that can be effective in real - world environments has been a goal of researchers from the very first days of artificial intelligence .",
    "it has long been recognized that an intelligent agent must be able to _ acquire _ , _ represent _ , and _ reason _ with knowledge . as such",
    ", a _ reasoning component _ has been an inseparable part of most agent architectures in the literature .",
    "although the underlying representations and implementations may vary between agents , the reasoning component of an agent is often responsible for making decisions that are critical to its existence .",
    "logic programming languages offer many properties that make them very suitable as knowledge representation languages .",
    "their declarative nature supports the modular development of provably correct reasoning modules  @xcite .",
    "recursive definitions can be easily expressed and reasoned upon .",
    "control knowledge and heuristic information can be declaratively and incrementally introduced in the reasoning process .",
    "furthermore , many logic programming languages offer a natural support for non - monotonic reasoning , which is considered essential for common - sense reasoning  @xcite .",
    "these features , along with the presence of efficient inference engines @xcite , make logic programming an attractive paradigm for knowledge representation and reasoning .    in the context of knowledge representation and reasoning , a very important application of logic programming",
    "has been in the domain of _ reasoning about actions and change _ and , more specifically , _",
    "planning_. planning problems have been effectively encoded using answer set programming ( asp )  @xcite  where distinct answer sets represent different trajectories leading to the desired goal .",
    "other logic programming paradigms , e.g. , _ constraint logic programming over finite domains ( clp(fd ) ) _",
    "@xcite , have been used less frequently to handle problems in reasoning about actions ( e.g. ,  @xcite ) .",
    "comparably more emphasis has been placed in encoding planning problems as ( non - logic programming ) constraint satisfaction problems  @xcite .",
    "recent proposals on representing and reasoning about actions and change have relied on the use of concise and high - level languages , commonly referred to as _ action description languages _ ; some well - known examples include the languages @xmath0 and @xmath1  @xcite and extensions like @xmath2  @xcite and @xmath3  @xcite .",
    "action languages allow one to write propositions that describe the effects of actions on states , and to create queries to infer properties of the underlying transition system . an _ action domain description _ is a specification of a planning domain using an action language .",
    "the goal of this work is to explore the relevance of constraint solving and constraint logic programming  @xcite in dealing with action languages and planning .",
    "the push towards this exploratory study came from recent investigations  @xcite aimed at comparing the practicality and efficiency of answer set programming versus constraint logic programming in solving various combinatorial and optimization problems .",
    "the study indicated that clp offers a valid alternative , especially in terms of efficiency , to asp when dealing with planning problems .",
    "furthermore , clp offers the flexibility of programmer - developed search strategies and the ability to handle numerical constraints .",
    "the first step , in this paper , is to illustrate a scheme that directly processes an action description specification , in a language similar to @xmath1  @xcite , producing a clp(fd ) program that can be used to compute solutions to the planning problem .",
    "our encoding has some similarities to the one presented by lopez and bacchus @xcite , although we rely on constraint logic programming instead of plain constraint satisfaction ( csp ) , and our action language supports static causal laws and non - determinism  while the work of lopez and bacchus is restricted to strips - like specifications .",
    "while the first step relies on using constraints to compute solutions to a planning problem , the second step brings the expressive power of constraints to the level of the action language , by allowing multi - valued fluents and constraint - producing actions to be used in the domain specification . the extended action language ( named @xmath4 )",
    "can be as easily supported by the clp(fd ) framework , and it allows a declarative encoding of problems involving actions with resources , delayed effects , and maintenance goals .",
    "these ideas have been developed in a prototype , and some preliminary experiments are reported .",
    "we believe that the use of clp(fd ) can greatly facilitate the transition of declarative extensions of action languages to concrete and effective implementations , overcoming some inherent limitations ( e.g. , efficiency and limited handling of numbers ) of other logic - based systems ( e.g. ,  asp ) .    the presentation is organized as follows .",
    "the first part of our paper ( sections  [ blanguage ] and [ implemb ] ) provides an overview of the action language @xmath1 and illustrates our approach to modeling problem specifications in @xmath1 using constraints and constraint logic programming .",
    "section  [ motivat ] provides motivations for the proposed multi - valued extensions .",
    "section  [ bmvsyntax ] introduces the full syntax of the new language .",
    "the action language  expands the previous language to a language with constraints and multi - valued fluents , that enables the use of dynamic and static causal laws ( a.k.a .",
    "state constraints ) , executability conditions , and non - markovian forms of reasoning with arbitrary relative or absolute references to past and future points in time .",
    "the semantics and the abstract implementation of  is incrementally developed in section  [ bmvsemantics ] , where we first consider a sub - language not involving non - markovian references , and later we extend it to the full .",
    "a concrete implementation in clp(fd ) is described in section  [ concreteimplebmv ] , and an experimental evaluation is discussed in section  [ sec : experimental ] .",
    "section  [ sec : related ] presents an overview of related efforts appeared in the literature , while section  [ sec : endofit ] presents conclusions and the directions for future investigation .",
    "_ `` action languages are formal models of parts of the natural language that are used for talking about the effects of actions '' _  @xcite .",
    "action languages are used to define _",
    "action descriptions _ that embed knowledge to formalize planning problems . in this section",
    ", we use the same variant of the language @xmath1 used in  @xcite  see also section  [ sec : related ] for a comparison . with a slight abuse of notation , we simply refer to this language as @xmath1 .",
    "an action signature consists of a set @xmath6 of _ fluent _ names , a set @xmath0 of _ action _ names , and a set @xmath7 of values for fluents in @xmath6 . in this section ,",
    "we consider boolean fluents , hence @xmath8 . to denote _ false _ and @xmath9 to denote _",
    "true_. consequently , we often say that a fluent is true ( resp .",
    ", false ) if its value is @xmath9 ( resp . ,  @xmath10 ) .",
    "] a _ fluent literal _ is either a fluent @xmath11 or its negation @xmath12 .",
    "fluents and actions are concretely represented by _ ground _ atomic formulae @xmath13 from an underlying logic language  @xmath14 . for simplicity , we assume that the set of terms is finite  e.g . , either there are no function symbols in @xmath14 , or the use of functions symbols is restricted , for instance by imposing a fixed maximal depth on the nesting of terms , to avoid the creation of arbitrary complex terms .",
    "the language @xmath1 allows us to specify an _ ( action ) domain description _ @xmath15 .",
    "the core components of a domain description are its _",
    "fluents_properties used to describe the state of the world , that may dynamically change in response to execution of actions  and _ actions_denoting how an agent can affect the state of the world .",
    "fluents and actions are introduced by assertions of the forms and .",
    "an action description @xmath15 relates actions , states , and fluents using axioms of the following types where denotes a list of fluent literals :    * : this axiom encodes a dynamic causal law , describing the effect ( i.e. , truth assignment to the fluent literal @xmath16 ) of the execution of action @xmath17 in a state satisfying the given conditions * : this axiom describes a static causal law  i.e . , the fact that the fluent literal @xmath16 is true in any state satisfying the given preconditions .",
    "moreover , preconditions can be imposed on the executability of actions by means of assertion of the forms :    * : this axiom asserts that , for the action @xmath17 to be executable , the given conditions have to be satisfied in the current state .",
    "a _ domain description _ is a set of static causal laws , dynamic laws , and executability conditions .",
    "a specific _ planning problem _ @xmath18 contains a domain description @xmath15 along with a set @xmath19 of _ observations _ describing the _ initial state _ and the _ desired goal _ :    * asserts that the fluent literal @xmath16 is true in the initial state * asserts that the goal requires the fluent literal @xmath16 to be true in the final state .    in the specification of an action theory",
    ", we can take advantage of a prolog - like syntax to express in a more succinct manner the laws of the theory .",
    "for instance , to assert that in the initial state all fluents are true , we can simply write the following rule : @xmath20 instead of writing a fact for each possible fluent  @xmath11 . remember that the notation @xmath21 is a syntactic sugar for the logical formula @xmath22 where @xmath23 are all the variables present in @xmath24 .",
    "0 + % % some type information + barrel(5 ) .",
    "+ barrel(7 ) .",
    "+ barrel(12 ) .",
    "+ liter(0 ) .",
    "+ liter(1 ) . +   + liter(12 ) .",
    "+   + % % identification of the fluents + fluent(cont(b , l)):- barrel(b ) , liter(l ) , l @xmath25 b. +   + % % identification of the actions + action(fill(x , y)):- barrel(x ) , barrel(y ) , x @xmath26 y. +   + % % dynamic causal laws + causes(fill(x , y ) , cont(x,0 ) , [ cont(x , lx ) , cont(y , ly ) ] ) : - + action(fill(x , y ) ) , fluent(cont(x , lx ) ) , + fluent(cont(y , ly ) ) , y - ly @xmath27 lx . + causes(fill(x , y ) , cont(y , lynew ) , [ cont(x , lx ) , cont(y , ly ) ] ) : - + action(fill(x , y ) ) , fluent(cont(x , lx ) ) , + fluent(cont(y , ly ) ) , y - ly @xmath27 lx , lynew is lx+ly",
    ". + causes(fill(x , y ) , cont(x , lxnew ) , [ cont(x , lx ) , cont(y , ly ) ] ) : - + action(fill(x , y ) ) , fluent(cont(x , lx ) ) , + fluent(cont(y , ly ) ) , lx @xmath27 y - ly , lxnew is lx - y+ly",
    ". + causes(fill(x , y ) , cont(y , y ) , [ cont(x , lx ) , cont(y , ly ) ] ) : - + action(fill(x , y ) ) , fluent(cont(x , lx ) ) , + fluent(cont(y , ly ) ) , lx @xmath27 y - ly .",
    "+   + % % executability conditions + executable(fill(x , y ) , [ cont(x , lx ) , cont(y , ly ) ] ) : - + action(fill(x , y ) ) , fluent(cont(x , lx ) ) , + fluent(cont(y , ly ) ) , lx > 0 , ly < y. +   + % % static causal laws caused([cont(x , lx ) ] , neg(cont(x , ly ) ) ) : - + fluent(cont(x , lx ) ) , fluent(cont(x , ly ) ) , + barrel(x ) , liter(lx ) , liter(ly ) , lx@xmath26ly . +   + % % description of the initial and goal state + initially(cont(12,12 ) ) .",
    "+ initially(cont(7,0 ) ) .",
    "+ initially(cont(5,0 ) ) .",
    "+ goal(cont(12,6 ) ) .",
    "+ goal(cont(7,6 ) ) .",
    "+ goal(cont(5,0 ) ) .",
    "[ exempiobarrelsb ] figure  [ bool_barrels ] presents an encoding of the three - barrel planning problem using the language  @xmath1 .",
    "there are three barrels of capacity @xmath28 ( an even number ) , @xmath29 , and @xmath30 , respectively . at the beginning ,",
    "the largest barrel is full of wine while the other two are empty .",
    "we wish to reach a state in which the two larger barrels contain the same amount of wine .",
    "the only permissible action is to pour wine from one barrel to another , until the latter is full or the former is empty .",
    "figure  [ bool_barrels ] shows the encoding of the problem for @xmath31 .",
    "notice that we also require that the smallest barrel is empty at the end .",
    "if @xmath32 is a fluent , and @xmath33 is a set of fluent literals , we say that @xmath34 if and only if @xmath35 and @xmath36 if and only if @xmath37 . a list of literals @xmath38 $ ] denotes a conjunction of literals , hence @xmath39 if and only if @xmath40 for all @xmath41 .",
    "we denote with @xmath42 the set @xmath43 a set of fluent literals is _ consistent _ if there is no fluent @xmath11 s.t .",
    "@xmath34 and @xmath36 . if @xmath44 then @xmath33 is _ complete_.",
    "a set @xmath33 of literals is _ closed _",
    "a set of static laws @xmath45 , if for all @xmath41 it holds that @xmath46 implies @xmath40 .",
    "the set @xmath47 is defined as the smallest set of literals containing @xmath33 and closed w.r.t .",
    "@xmath47 is uniquely determined and not necessarily consistent .",
    "the semantics of an action language on the action signature @xmath49 is given in terms of a transition system @xmath50 @xcite , consisting of a set @xmath51 of states , a total interpretation function @xmath52 ( in this section @xmath8 ) , and a transition relation @xmath53 .",
    "given a transition system @xmath50 and a state @xmath54 , let : @xmath55 observe that @xmath56 is consistent and complete .",
    "given a set of dynamic laws @xmath57 ,",
    "@xmath58 , @xmath59 for the action @xmath60 and a state @xmath61 , we define the _",
    "( direct ) effects of @xmath17 in @xmath62 _ as follows : @xmath63    the action @xmath17 is said to be _",
    "executable _ in a state @xmath62 if it holds that @xmath64 where @xmath65 , @xmath58 , @xmath66 for @xmath67 , are the executability axioms for the action @xmath17 in @xmath15 .",
    "observe that multiple executability axioms for the same action @xmath17 are considered disjunctively .",
    "hence , for each action @xmath17 , at least one executable axiom must be present in the action description . in @xcite",
    " see also remark  [ execvsnonexec ] . ]",
    "let @xmath15 be an action description defined on the action signature @xmath49 , composed of dynamic laws @xmath68 , executability conditions @xmath69 , and static causal laws @xmath48 .    the transition system @xmath50 _ described by _",
    "@xmath15 is a transition system such that :    * @xmath51 is the set of all states @xmath62 such that @xmath56 is closed w.r.t . @xmath48 ; * @xmath70 is the set of all triples @xmath71 such that @xmath17 is executable in @xmath62 and @xmath72    let @xmath73 be a planning problem instance , where @xmath74 is a consistent and complete set of fluent literals .",
    "a _ trajectory _ in @xmath50 is a sequence @xmath75 such that @xmath76 for all @xmath77 .",
    "a sequence of actions @xmath78 is a solution ( a _ plan _ ) to the planning problem @xmath73 if there is a trajectory @xmath79 in @xmath80 such that :    * @xmath81 for each @xmath82 , and * @xmath83 for each @xmath84 .",
    "the plans characterized in this definition are _",
    ", we disallow concurrent actions .",
    "observe also that the desired plan length @xmath85 is assumed to be given .",
    "[ sequentiality ] in this paper we focus on sequential plans only .",
    "hence , we assume that only one action is executed in each state transition composing a given trajectory .",
    "note that the constraint - based encoding we will propose in the rest of this manuscript can be easily adapted to deal with concurrent actions . nevertheless , we have opted to ignore this aspect in this manuscript , to avoid further complications of notation , and dealing with issues of concurrency goes beyond the scope of this paper .",
    "the interested reader is referred to  @xcite for some further considerations on this matter .",
    "[ execvsnonexec ] notice that the satisfaction of  ( [ execcond ] ) is just a necessary requirement for the executability of an action and it might not represent a sufficient precondition . indeed , as far as the definition of transition system is considered , it is easy to see that , even if  ( [ execcond ] ) is satisfied for certain @xmath17 and @xmath62 , the execution of @xmath17 in @xmath62 might be inhibited because of the contradictory effects of the causal laws .",
    "a simple example is represented by the following action description  @xmath15 :    l +   +    the action @xmath17 is always executable ( according to its executability law ) , but the execution of @xmath17 would yield an inconsistent situation . indeed , the execution of @xmath17 does not correspond to any state transition in the transition system described by  @xmath15 .",
    "the above example also suggests a possible extension of the action description language that involves laws of the form @xmath86 the semantics for such an extended action language can be defined by replacing the condition  ( [ execcond ] ) , with the following one : @xmath87 where , @xmath58 , and , @xmath58 , , for @xmath67 and @xmath88 , are defined for the action @xmath17 .",
    "thus , the action @xmath17 is executable only if at least one of the @xmath89s is satisfied and all @xmath90s are unsatisfied in the state @xmath62 .    an alternative interpretation of the axioms can be adopted .",
    "namely , the law can be considered simply as shorthand for the pair of dynamic causal laws and .",
    "( actually , this possibility also applies to the languages proposed in  @xcite ) .",
    "this shows that ( non)executability laws do not increase the expressive power of the action language .",
    "nevertheless , the availability of both types of laws permits the direct and explicit formalization of preconditions for actions execution .",
    "let us describe how action descriptions are mapped to finite domain constraints .",
    "we will focus on how constraints can be used to model the possible transitions from each individual state of the transition system .",
    "( 400,150)(0,35 ) ( 60,158 ) ( 100,100)(100,100 ) ( 100,130 ) ( 70,128)@xmath91 ( 100,70 ) ( 70,68)@xmath92 ( 100,80)(100,120 ) ( 267,158 ) ( 300,100)(100,100 ) ( 300,130 ) ( 310,128)@xmath93 ( 300,70 ) ( 310,68)@xmath94 ( 300,80)(300,120 ) ( 160,120)(1,0)80 ( 185,125)@xmath95 ( 200,100)(200,115 ) ( 160,80)(1,0)80 ( 185,85)@xmath96 ( 156,45)@xmath97      let us consider a domain description @xmath15 and the state transition system described by @xmath15 .",
    "let us also denote with @xmath98 and @xmath99 the starting and ending states of an arbitrary transition of such a system .",
    "we assert constraints that relate the truth value of fluents in @xmath98 and @xmath99 .",
    "this is intuitively illustrated in figure  [ act_fig ] , where @xmath100 and @xmath101 .",
    "( cf . , section  [ clpmappingb ] and figure  [ setonefluent ] ) . ]",
    "a boolean variable is introduced to describe the truth value of each fluent literal in a state .",
    "the value of a fluent literal @xmath16 in @xmath98 is represented by the variable @xmath102 ; analogously , its value in the destination state @xmath99 is represented by the variable @xmath103 . for the sake of simplicity",
    ", we will freely refer to these variables as boolean entities  and compose them with logical connectives to form boolean expressions  as well as 0/1 variables  and compose them with arithmetic operators .",
    "concrete clp(fd ) systems , e.g. , sicstus , eclipse , and bprolog , enable this type of alternative perspectives , providing basic primitive constraints ( e.g. , ` # = ` and ` # > ` ) and boolean compositions of constraints .",
    "given a conjunction of literals @xmath104 $ ] we will denote with @xmath105 the expression @xmath106 .",
    "we will also introduce , for each action @xmath17 , a boolean variable @xmath107 , representing whether the action is executed or not in the transition from @xmath98 to @xmath99 under consideration .",
    "given a specific fluent literal @xmath16 , we develop constraints that determine when @xmath103 is true and false .",
    "let us consider the dynamic causal laws that have @xmath16 as a consequence :    [ cols=\">,^,^,^ , < \" , ]         notice that , for any given dynamic law @xmath108 , such that  @xmath17 is executed in a state  @xmath98 satisfying  @xmath109 , the constraint @xmath110 has to be evaluates / satisfied in the target state  @xmath99 .",
    "hence , the ( relative ) timed references occurring in @xmath110 ( respectively , in @xmath109 ) are resolved with respect to  @xmath99 ( resp .",
    ",  @xmath98 ) . on the other hand , for a static law @xmath111",
    ", relative timed references of both @xmath112 and @xmath113 have to be resolved with respect to the current state .",
    "the language  allows the definition of _ absolute temporal constraints _",
    "i.e. , constraints that refer to specific moments in time in the trajectory ( by associating the time point @xmath10 to the initial state ) . differently from the case of annotated fluents , where points in time are _ relative _ to the current state .",
    "a _ timed fluent _ is defined as an expression of the form @xmath114 timed fluents can be used to build _ timed fluent expressions _ ( @xmath115 ) and _ timed primitive constraints _ ( @xmath116 ) , similarly to what done for normal fluents .",
    "for instance , the constraint @xmath117 states that the value the fluent @xmath11 has at time @xmath118 in the plan is less than the value that the fluent @xmath119 has at time  4 .",
    "similarly , @xmath120 imposes that the fluent @xmath121 must assume value @xmath122 at time  @xmath118 .",
    "timed constraints can be used in the following kind of assertion : @xmath123 the assertion requires the timed constraint @xmath116 to hold .",
    "some other accepted constraints are :    * @xmath124 : this constraint is a particular case of the previous one .",
    "it is satisfied if the primitive fluent constraint @xmath125 holds in the @xmath126 state .",
    "it is therefore a generalization of the axiom .",
    "observe that assertions of this kind can be used to guide the search of a plan by adding some point - wise information about the states occurring along the computed trajectory ( e.g. , this is useful to implement the landmarks model as used in the ff planner  @xcite ) .",
    "* @xmath127 : this constraint imposes the condition that the fluent constraint @xmath125 holds in all the states .",
    "observe that @xmath125 has to be evaluated in all states , and its evaluation is strict  i.e .",
    ", any reference to fluents outside the time limits leads to the satisfaction of the constraint ; hence , annotated fluents should be avoided in @xmath125 .    in specifying a planning problem @xmath18 , we can consider such kinds of assertions as part of the observations @xmath19 .",
    "let us consider the case of an agent that has a certain amount of money ( e.g. , @xmath128 ) to invest ; she is interested in purchasing as many stocks as possible .",
    "the stocks can be purchased from three trading agencies ( @xmath9 , @xmath118 , and @xmath122 ) ; each agency has @xmath129 stocks available at @xmath130 each .",
    "the stocks have to be purchased in separate transactions , but each trading agency require the agent to have a balance of at least @xmath131 at the start of the day before agreeing in the transaction .",
    "a purchase can be of at most @xmath132 shares at a time .",
    "we can model this problem with the following fluents : @xmath133    the only action is @xmath134 the executability condition for the action captures one property : the agent is accepted by the trading agency .",
    "@xmath135 the dynamic causal law for this action is : @xmath136    the initial state can be described as @xmath137       in  it is possible to specify information about the _ cost _ of each action and about the _ global cost _ of a plan ( that is defined as the sum of the costs of all its actions ) .",
    "this type of information are useful to explore the use of constraints in determining _ optimal _ plans .",
    "the cost of actions is expressed using assertions of the following forms ( where @xmath138 is a fluent expression built using the fluents present in the state ) :    * @xmath139 specifies the cost of the execution of the action @xmath17 as result of the expression @xmath138 .",
    "* @xmath140 specifies the cost of a state as the result of the evaluation of @xmath138 .",
    "whenever , for an action or a state , no cost declaration is provided , a default cost of @xmath9 is assumed .",
    "once we have provided the costs for actions and states , we can impose constraints on the cumulative costs of specific states or complete trajectories . this can be done in  using assertions of the following types ( where @xmath141 is a number and  a relational operator ) :    * @xmath142 ; the assertion adds a constraint on the global cost of the plan . * @xmath143 ; the assertion imposes a constraint on the global cost of the final state . * @xmath144 ; the assertion imposes a constraint on the global cost of the @xmath145 state of the trajectory .    as an immediate generalization of the above constraints , we admit assertions of the form  @xmath146 ,   where @xmath109 is a constraint , possibly involving fluents , where the atoms , , and might occur in any place where a fluent might  intuitively representing the cost of a plan , of the goal state , and of the @xmath145 state , respectively .",
    "some directives can be added to an action theory to select optimal solutions with respect to the specified costs : @xmath147 where @xmath138 is an expression involving the atoms , , and , and possibly other fluents .",
    "this assertion constrains the search to determine a plan that minimizes the value of the expression @xmath138 .",
    "for instance , the two assertions  @xmath148   and  @xmath149   constrain the search of a plan with minimal global cost and with minimal cost of the goal state , respectively .",
    "we provide a more precise semantics for all these assertions in section  [ sema_4 ] . in specifying a planning problem @xmath18",
    ", we consider cost constraints as part of the observations  @xmath19 .",
    "we will build the semantics of the language  incrementally .",
    "we will start by building the semantics for the sub - language of  devoid of any form of time reference and cost constraints ( section  [ markovianbmv ] ) .",
    "this core language is called .",
    "the subsequent sections  [ sema_2][sema_4 ] treat the full .",
    "[ markovianbmv ]    each fluent @xmath11 is uniquely assigned to a domain @xmath150 in the following way :    * if @xmath151 , then @xmath152 .",
    "a function @xmath153 is a _ state _ if @xmath154 for all @xmath32 .",
    "the special symbol @xmath155 denotes that the value of the fluent is undefined .",
    "a state @xmath99 is _ complete _ if for all @xmath156 , @xmath157 . for a number @xmath158",
    ", we define a _ state sequence _ @xmath159 as a tuple @xmath160 where each @xmath161 is a state .    given a state @xmath162 , and an expression @xmath163",
    ", we define the _ value _ of @xmath163 in @xmath162 ( with abuse of notation , denoted by @xmath164 ) as follows:[reificasem ] denotes the ( algebraic ) absolute value of  @xmath165 . ]",
    "@xmath166 we treat the interpretation of the various @xmath167 operations and relations as strict with respect to  @xmath155 ( i.e. , @xmath168 , @xmath169 , etc . ) .",
    "the last two cases in  ( [ eq : semofbmv ] ) specify the semantics of reification .",
    "reified constraints are useful to enable reasoning about the satisfaction state of other formulae .",
    "the intuitive semantics is that a fluent expression @xmath170 , where @xmath109 is a fluent constraint , assumes a boolean value ( @xmath10 or @xmath9 ) depending on the truth of  @xmath109 .",
    "note that the semantics of reified constrains relies on the notion of _ satisfaction _ , which in turn is defined by structural induction on constrains , as follows .",
    "given a primitive fluent constraint @xmath171 , a state @xmath162 _ satisfies _ @xmath171 , written @xmath172 , if and only if it holds that @xmath173 where the semantics of the arithmetic relators / operators is the usual one on @xmath174 .",
    "if either @xmath175 or @xmath176 is @xmath155 , we assume that @xmath177 ( and @xmath178 where is the negation of the operator ) . basically undefined formulas are neither proved nor disproved .",
    "the satisfaction relation @xmath179 can be generalized to the case of propositional combinations of fluent constraints in the usual manner .    given a constraint @xmath109 ,",
    "let @xmath180 be the set of fluents occurring in it .",
    "a function @xmath181 is a _ solution _ of @xmath109 if @xmath182 .",
    "we denote the domain @xmath180 of the function @xmath183 as @xmath184 . in other words ,",
    "a solution @xmath183 of @xmath109 can be seen as a partial state satisfying @xmath109 .",
    "observe that we require the solution to manipulate exclusively the fluents that appear in the constraint .",
    "[ rico1 ] let us consider an action theory over the fluents @xmath185 , where each fluent has domain @xmath186 .",
    "if @xmath109 is the constraint @xmath187 , then a solution of @xmath109 is @xmath188 .",
    "note that the substitution @xmath189 is not a solution of @xmath109 , since @xmath190 .",
    "let @xmath183 be a solution of a constraint @xmath109 and @xmath99 a state , with @xmath191 we denote the state obtained completing @xmath183 in @xmath99 _ by inertia _",
    ", as follows : @xmath192    let us continue with example [ rico1 ] . if @xmath188 and @xmath193 , then @xmath194 .     an action @xmath17 is _ executable _ in a state @xmath162 if there is an axiom @xmath195 such that @xmath196",
    ".    as for the case of the language @xmath1 , also in  the executability laws express necessary but not sufficient preconditions for action execution ( cf .",
    ", remark  [ execvsnonexec ] ) .",
    "moreover , thanks to the generality of the constraint language  i.e .",
    ", any propositional combination of primitive constraints can be used in the laws also allow direct formulation of non - executability conditions and the roles of the and axioms coincide .",
    "let us denote with @xmath197 the set of dynamic causal law axioms for action @xmath17 .",
    "the _ effect _ of executing @xmath17 in state @xmath99 , denoted by @xmath198 , is a constraint defined as follows : @xmath199      let us start by considering the simplified situation in which @xmath200 , i.e. , no static causal laws are specified in the domain description .    during the execution of an action , a fluent has to be considered as inertial , provided that it does not appear among the effects of the dynamic laws for . in other words , since these effects are expressed through constraints , a fluent is inertial if it does not occur in any of the constraints specified in the dynamic laws for .",
    "the description of the state transition system corresponding to a given action description theory @xmath201 can be completed by defining the notion of transition .    a triplet @xmath202 , where @xmath203 are complete states and @xmath17 is an action , is a _ valid state transition _ if :    * the action @xmath17 is executable in @xmath204 ,  and * @xmath205 , where @xmath183 is a solution of the constraint @xmath206 .",
    "let @xmath73 be an instance of a planning problem , @xmath207 be a sequence of complete states and @xmath208 be actions .",
    "we say that @xmath209 is a _ valid trajectory _ if :    * for each axiom of the form @xmath210 in @xmath19 , we have that @xmath211 , * for each axiom of the form @xmath212 in @xmath19 , we have that @xmath213 , and * for all @xmath214 , @xmath215 is a valid state transition .    let us consider the example [ rico2 ] .",
    "observe that @xmath216 is a valid trajectory .     given a planning problem @xmath217 in , differently from what happens in the case of @xmath1 , a solution to a planning problem",
    "is described by a valid trajectory , not just by a sequence of actions .",
    "this is the case because actions might have non - deterministic effects .",
    "for instance , let us consider example [ rico2 ] . if the action is executed and the precondition holds , then the dynamic causal law imposes the constraint in the reached state .",
    "there are many different ways to satisfy this requirement .",
    "hence , in general , a sequence of actions might not characterize a unique state sequence .",
    "the same argument also applies to the action description language , so in what follows we will consider the valid trajectories as the solutions of a planning problem .",
    "[ nonmarkovianbmv ]    in this section we propose a constraint - based characterization of the state transition system defined in section  [ sema_0 ] .",
    "similarly to what we have done in the case of @xmath1 , for any specific state , each fluent @xmath11 will be represented by an integer - valued constraint variable .",
    "boolean variables will instead model the occurrences of actions .",
    "let @xmath98 be a state ; given a fluent @xmath11 , we indicate with @xmath218 the variable representing @xmath11 in @xmath98 .",
    "we generalize such a notation to any constraint @xmath109 , i.e. , we denote with @xmath219 the constraint obtained from @xmath109 by replacing each fluent @xmath220 by @xmath218 . for each action",
    "@xmath60 , a boolean variable @xmath107 is introduced , representing whether the action is executed or not in the transition from @xmath98 to the next state .",
    "given a specific fluent @xmath11 , we develop a system of constraints to constrain the values of  @xmath218 .",
    "let us consider the dynamic causal laws that have @xmath11 within their consequences : @xmath221    for each action @xmath17 we will have its executability conditions : @xmath222    figure  [ cieffebis ] describes the constraints @xmath223 that can be used in encoding the relations that determine the value of the fluent @xmath11 in the state @xmath99 ( i.e. , constrain the variable @xmath224 ) w.r.t .",
    "the application of the action @xmath17 in the state  @xmath98 .",
    "after the settings of the domains ( by  ( [ cieffebis9 ] ) ) , we impose through  ( [ cieffebis10 ] ) that if action @xmath17 is executed , then at least one of the preconditions for its executability must hold in @xmath98 . for each @xmath225",
    "the constraint  ( [ cieffebis11 ] ) defines a boolean flag @xmath226 that holds if and only if action @xmath227 is applicable in @xmath98 and the preconditions of the @xmath228 dynamic causal law for @xmath11 holds in @xmath98 .",
    "the constraint  ( [ cieffebis12 ] ) requires that if @xmath226 is true , then the corresponding effects must hold in the new state @xmath99 .",
    "finally , inertia constraints are set by means of  ( [ cieffebis13 ] ) .",
    "we will denote with @xmath229 the conjunction of these constraints for all actions @xmath230 .",
    "given an action domain specification over the signature @xmath231 and two states @xmath232 , the system of constraints @xmath233 includes :    * the constraint @xmath229 for each fluent literal @xmath11 in the language of @xmath6 * the constraint @xmath234 ( unique action execution in the state transition ) .",
    "the next theorem states completeness and soundness of the encoding described so far .",
    "we need a further piece of notation . given two states @xmath232 and an action  @xmath17 , let @xmath235 be the constraint obtained from @xmath233 by setting @xmath236 , @xmath237 for all @xmath238 , and @xmath239 for each fluent literal @xmath11 .",
    "[ soundcompletebmv0 ] let @xmath240 and let @xmath232 two states and @xmath17 an action .",
    "then @xmath241 is a valid transition in the semantics of the language if and only if @xmath99 represents a solution of the constraint @xmath235 .",
    "( @xmath242 ) : :    let @xmath241 be a valid transition . then",
    ",    @xmath17 is executable in @xmath98 .",
    "hence    @xmath243 for some    @xmath244 and  ( [ cieffebis10 ] ) is satisfied .    by the definition of state we have that  ( [ cieffebis9 ] )",
    "is also    satisfied .",
    "let @xmath245 with    @xmath183 solution of @xmath246 .",
    "+    if @xmath11 is a fluent not belonging to    @xmath184 then @xmath11 does not    occur in @xmath246 and it is not affected by    any dynamic causal law involved in the state transition . by definition    of @xmath247",
    "we have that    @xmath248 and this satisfies constraint  ( [ cieffebis13 ] ) .",
    "satisfaction of constraints  ( [ cieffebis11 ] ) and  ( [ cieffebis12 ] ) is    immediately verified by observing that for all dynamic causal laws    @xmath249    having @xmath11 in @xmath250 , the constraint    @xmath251 is false in @xmath98 .",
    "then , the    corresponding flag @xmath252 is set false    by  ( [ cieffebis11 ] ) .",
    "consequently ,  ( [ cieffebis12 ] ) is satisfied .",
    "+    assume now that @xmath11 is a fluent in    @xmath184 .",
    "this means that there are    dynamic causal laws    @xmath249    such that @xmath251 is true in @xmath98 , for    @xmath253 .",
    "consequently , the flag @xmath252 is set true for    @xmath254 and false otherwise .",
    "since @xmath183    is a solution of @xmath246 , @xmath99    satisfies the constraint @xmath255 for all    @xmath256 .",
    "this implies that  ( [ cieffebis12 ] ) is satisfied    for each @xmath225 . since some flags    @xmath257 are true constraint  ( [ cieffebis13 ] ) is    satisfied too .",
    "( @xmath258 ) : :    assume that @xmath99 satisfies the constraint    @xmath235 .",
    "by  ( [ cieffebis10 ] ) , because    @xmath236 , some of the constraints    @xmath259 is satisfied . hence",
    ", action    @xmath17 is executable in @xmath98 . by the satisfaction    of  ( [ cieffebis11 ] ) and  ( [ cieffebis12 ] ) , @xmath99 satisfies all    constraints @xmath255 for which the corresponding    @xmath260 is satisfied .",
    "then , @xmath99 is    a solution for @xmath246 .",
    "consequently , since    @xmath261 ( by definition , since    @xmath99 is complete ) , @xmath241 is a    valid transition .",
    "let @xmath18 be an instance of a planning problem where @xmath15 is an action description and  @xmath19 contains any number of axioms of the form @xmath210 and @xmath212 .",
    "we can state the following .",
    "[ completebmv0soundbmv0 ] there is a valid trajectory @xmath262 if and only if there is a solution for the constraint @xmath263    the result follows from ( repeated ) applications of theorem  [ soundcompletebmv0 ] .       in this section",
    "we consider the case of action theories @xmath264 of , involving static causal laws ( i.e. , such that @xmath265 ) .",
    "the presence of static laws requires refining the semantics of the language , in order to ensure proper treatment of inertia in the construction of a valid trajectory .",
    "we start by defining three operations @xmath266 , and @xmath267 on states , as follows : @xmath268 where the set @xmath33 used in @xmath267 is a set of fluents .",
    "observe that @xmath269 .",
    "a state @xmath99 is _ closed _",
    "a set of static causal laws @xmath270 if @xmath271 .",
    "we denote this property as @xmath272 .    given two states @xmath203 , a set of fluents @xmath273 , and a set @xmath48 of static causal laws , we say that @xmath274 is _ minimally closed _",
    "@xmath275 and @xmath48 if    * @xmath276 ( i.e. , @xmath274 is closed ) and * for all @xmath277 , if @xmath278 then @xmath279 .    the notion of minimally closed state is intended to capture the law of inertia , w.r.t .  a given set @xmath273 of fluents .",
    "notice , in fact , that @xmath280 . intuitively speaking",
    ", @xmath274 is minimally closed when it is obtainable from @xmath99 by applying a minimal set of ( necessary ) changes in the values of the ` inertial ' fluents ( those in @xmath273 ) . in other words , it is not possible to obtain from @xmath99 a state different from @xmath274 and closed w.r.t .",
    "@xmath48 , by applying `` fewer changes '' than those involved in obtaining  @xmath274 .",
    "a pictorial representation of @xmath281 is shown in figure  [ chiusuraminima ] .",
    "observe that if @xmath200 then @xmath274 is minimally closed w.r.t .",
    "@xmath275 and @xmath48 if and only if @xmath282 .    [ esa : miniclo ] let @xmath283 be fluents with @xmath284 and +    @xmath285 .    consider the states @xmath286 , @xmath287 , @xmath288 and let @xmath289",
    ". then , @xmath274 and @xmath290 are both closed w.r.t .",
    "@xmath48 .    however , @xmath290 is minimally closed w.r.t .",
    "@xmath99 , @xmath273 , and @xmath48 , while @xmath274 is not minimally closed since @xmath291 is different from @xmath274 and closed .     a triplet @xmath292 , where @xmath99 and @xmath274 are complete states and @xmath17 is an action , is a _ valid transition _ if :    1 .   the action @xmath17 is executable in @xmath99 and 2 .",
    "we have that @xmath293 where * @xmath183 is a solution of the constraint @xmath206 , and * @xmath274 is minimally closed w.r.t.@xmath99 , @xmath294 , and @xmath48 .    intuitively , the conditions that define a transition are designed to guarantee that :    * a solution @xmath183 for the constraints describing the effects of the action is determined ; * such solution is part of the new state @xmath274 constructed ( thanks to @xmath295 ) ; and * the new state is minimally closed with respect to all the fluents not affected by the execution of the action .",
    "let us observe that , since all fluents in the domain of any solution @xmath183 of @xmath296 maintain the same value in  @xmath274 , it holds that @xmath297 .",
    "notice that the notion of a valid transition given in presence of static laws properly extends the one given in section  [ sema_0 ] .",
    "in fact , the following property holds :    if @xmath298 then @xmath299 .",
    "it is sufficient to note that , if @xmath298 then @xmath274 is minimally closed w.r.t .",
    "@xmath300 if and only if @xmath301 .",
    "let us extend the action description of example [ esa : miniclo ] .",
    "we consider the following domain description : @xmath302 let us consider the three states @xmath286 , @xmath287 , and @xmath288 .",
    "then @xmath303 is a valid transition , while @xmath202 is not .",
    "let @xmath73 be a planning problem instance .",
    "let @xmath207 be a sequence of complete states and let @xmath208 be actions .",
    "then @xmath209 is a _ valid trajectory _ if the following conditions hold :    * @xmath304 , and for each axiom @xmath210 in @xmath19 , we have that @xmath305 ; * for each axiom of the form @xmath212 in @xmath19 , we have that @xmath213 ; * @xmath306 is a valid transition , for each @xmath214 .",
    "let us consider a fluent @xmath11 and a transition from state @xmath98 to state @xmath307 , due to an action @xmath17 , and let us adopt the same notation ( @xmath218 , @xmath219 , @xmath107 , etc . )",
    "introduced in section  [ absconcbmvi ] .",
    "the state transition from @xmath98 to @xmath307 can be seen as the composition of two steps involving an intermediate state @xmath99 .",
    "the first of these steps reflects the effects of the dynamic laws , whereas the second step realizes the closure w.r.t .  the static causal laws .",
    "hence we proceed by introducing a set of variables corresponding to the intermediate state @xmath308 , where @xmath183 is a solution of @xmath246 .",
    "the constraint - based description of the first step is essentially the same we described in section  [ nonmarkovianbmv]thus , we only need to extend the constraint system defined in figure  [ cieffebis ] to reflect the second part of the transition .    given a set @xmath309 of fluents ,",
    "let @xmath310 be the collection of all static causal laws in which at least one fluent of @xmath311 occurs .",
    "moreover , for simplicity , let @xmath312 denote @xmath313 , i.e. , the set of all static causal laws that involve the fluent @xmath11 .",
    "let us define a relation @xmath314 so that @xmath315 if and only if @xmath316 .",
    "@xmath70 is an equivalence relation and it partitions @xmath6 .",
    "each element ( i.e. , equivalence class ) of the quotient @xmath317 is said to be a _ cluster _ ( w.r.t .",
    "@xmath48 ) .",
    "notice that a cluster can be a singleton @xmath318 .",
    "let @xmath11 be a fluent , we denote with @xmath319 its cluster w.r.t .",
    "@xmath48 .",
    "assume that @xmath48 consists of the rules @xmath320 then the two clusters are @xmath318 and @xmath321 .",
    "given a fluent @xmath11 , let us consider the sets of dynamic and executability laws @xmath322 and @xmath323 , as defined in section  [ absconcbmvi ] .",
    "moreover , let us consider the cluster containing @xmath11 , let it be @xmath324 , and the corresponding set of static causal laws @xmath325 : @xmath326    figure  [ cieffequatris ] describes the constraints ( to be added to those in figure  [ cieffebis ] ) that are used in encoding the relations that determine the value of the fluent @xmath11 in state @xmath307 ( represented through the variable @xmath327 ) after the execution of action @xmath17 in the state  @xmath98 ( we recall that @xmath99 is to be considered as an intermediate state @xmath245 ) .",
    "the constraint ( [ cieffequatris15 ] ) sets the domains for the variables @xmath327 .",
    "the constraint  ( [ cieffequatris20 ] ) propagates to @xmath307 the effects of the dynamic laws .",
    "constraint  ( [ cieffequatris21 ] ) imposes closure w.r.t .  the static causal laws .",
    "finally , constraints  ( [ cieffequatris22])([cieffequatris23 ] ) require that if all the fluents in @xmath184 that belong to the cluster @xmath319 are left unchanged in the transition , then all the fluents of @xmath319 should not change their values .",
    "more precisely , as far as  ( [ cieffequatris22 ] ) is concerned , @xmath328 is set to true if , for all fluents @xmath119 in @xmath319 , either @xmath119 is not affected by the dynamic laws ( i.e. , @xmath329 ) , or for each activated dynamic law @xmath330 ( i.e. , such that its precondition @xmath260 is true ) , @xmath119 does not occur in its effects ( i.e. , in @xmath331 ) . notice that , with respect to a specific state transition , we are not considering subject to inertia all those fluents that occur in the effects of ( at least ) one activated dynamic law .",
    "the enforcement of the constraint  ( [ cieffequatris23 ] ) constitutes a necessary , but not sufficient , condition for the target state to be minimally closed .",
    "we will discuss later on this point .",
    "let us denote with @xmath332 the conjunction of the constraints ( [ cieffebis9])([cieffequatris21 ] ) for all actions @xmath230 .",
    "given an action domain specification over the signature @xmath231 , the system of constraints @xmath333 includes :    * the constraint @xmath332 for each fluent literal @xmath11 in the language of @xmath6 ; * the constraint @xmath234 .",
    "similarly , let @xmath334 denote the conjunction of all the constraints of the forms  ( [ cieffequatris22 ] ) and ( [ cieffequatris23 ] ) .",
    "the next theorem states completeness of the encoding described so far .",
    "again , given two states @xmath335 and an action  @xmath17 , let @xmath235 and @xmath336 denote the constraints obtained from @xmath333 and @xmath334 , respectively , by setting @xmath236 , @xmath237 for all @xmath238 , and @xmath239 for each fluent literal @xmath11 .",
    "[ completebmv1 ] let @xmath337 and let @xmath335 two states and @xmath17 an action .",
    "then , if @xmath338 is a valid transition in the semantics of the language , then @xmath307 represents a solution of the constraint @xmath339 .    for the constraints  ( [ cieffebis9])([cieffequatris15 ] ) , considering the transition from @xmath98 to @xmath99 , the proof proceeds analogously to the first part of the proof of theorem  [ soundcompletebmv0 ] .",
    "let us sketch the part of the proof regarding the effect of the static causal laws .",
    "since @xmath338 is a valid transition , @xmath340 , @xmath307 agrees with @xmath245 on all fluents in @xmath184 , hence  ( [ cieffequatris20 ] ) hold .",
    "moreover , @xmath307 is closed w.r.t .",
    "@xmath48 , hence it satisfies  ( [ cieffequatris21 ] ) . from the fact that @xmath307 is minimally closed w.r.t.@xmath341 , and @xmath48 , it follows that @xmath307 satisfies  ( [ cieffequatris22])([cieffequatris23 ] ) .",
    "the above encoding does not guarantee soundness .",
    "this is because the constraints  ( [ cieffequatris20])([cieffequatris21 ] ) in figures  [ cieffebis ] and  [ cieffequatris ] might admit solutions not corresponding to minimally closed states .    we introduced the notion of cluster to partially recover the soundness of the encoding . intuitively speaking , a cluster generalizes , to the multi - valued case",
    ", the notion of loop seen in section  [ soundcompleofb ] : a cluster is a set of fluents whose values have been declared to be mutually dependent through a set of static causal laws . in a state transition , similarly to the case of loops , changes to the fluents of a cluster might occur because of their mutual influence , not being ( indirectly ) caused by dynamic laws .",
    "constraints  ( [ cieffequatris22 ] ) and ( [ cieffequatris23 ] ) impose inertia on all the fluents of a cluster whenever none of them is influenced by dynamic laws .",
    "however , note that imposing  ( [ cieffequatris22])([cieffequatris23 ] ) does not completely circumvent the problem because state transitions violating the inertia are still admitted .",
    "in fact , ( [ cieffequatris22])([cieffequatris23 ] ) do not impose inertia on the fluents of a cluster when at least one of them is changed by the dynamic laws .",
    "this might lead to invalid transitions , in which a change in the value of a fluent of a cluster happens even if this is not necessary in order to satisfy all the static causal laws .",
    "nevertheless , we introduced the constraints  ( [ cieffequatris22 ] ) and ( [ cieffequatris23 ] ) because they constitute a good compromise w.r.t .",
    "the efficiency of a concrete implementation ( as discussed later ) .    to completely enforce soundness",
    ", we need to apply a filter on the solutions that are admitted by the encoding described so far . to this aim ,",
    "let us introduce a condition on the values of the fluent , which is intended to mimic , in the multi - valued setting , the effect of loop formulae .",
    "let us assume that the action @xmath17 is executed in the state @xmath98 , and that @xmath183 , @xmath99 , and @xmath307 have been determined so that to satisfy the constraint @xmath333 . in this situation the following constraint characterizes an hypothetical state @xmath342 , different from @xmath307 : @xmath343 intuitively , the satisfaction of such a formula witnesses the existence of a counterexample for the minimal closure of @xmath307 .",
    "notice that , being @xmath183 , @xmath99 , and @xmath307 already determined , the only fluents / variables to be determined are those describing the state  @xmath342 , if any .",
    "the conjunct in line  ( [ formulazza2 ] ) states that @xmath342 is a target state alternative to @xmath307 ; in particular , it enforces the closure of @xmath342 w.r.t .",
    "the conjunction  ( [ formulazza1 ] ) states that @xmath342 and @xmath307 agree on the fluents in @xmath184 .",
    "finally ,  ( [ formulazza3 ] ) states that @xmath342 must differ from @xmath307 and it must agree with @xmath98 in at least one fluent  that , because of  ( [ formulazza1 ] ) , it is in @xmath344 .",
    "we can prove the following result , that generalizes theorem  [ soundcompletebmv0 ] to the case of @xmath265 .",
    "[ soundbmv1 ] let @xmath337 and @xmath335 two states , with @xmath98 closed w.r.t .",
    "@xmath48 . let @xmath17 an action such that @xmath307 represents a solution of the constraint @xmath235 .",
    "then @xmath338 is a valid transition in the semantics of the language , if @xmath345 is unsatisfiable .    by proceeding as in the proof of theorem  [ soundcompletebmv0 ]",
    ", we can show that all needed conditions for @xmath338 to be a valid transition are satisfied , except for the minimal closure of @xmath307 .",
    "let us assume , by contradiction , that @xmath307 is not minimally closed w.r.t .",
    "@xmath98 , @xmath344 , and @xmath48 .",
    "then , there exists @xmath346 such that @xmath347 and @xmath348 for each fluent @xmath349 it holds that @xmath350 .",
    "moreover , @xmath351 holds too , because @xmath307 satisfies @xmath235 .",
    "hence , @xmath352 holds for all  @xmath353 .    for each fluent @xmath11 , since @xmath342 is closed w.r.t .",
    "@xmath48 , we have that @xmath354 ( for all @xmath355 ) .",
    "observe that the conditions of the forms  ( [ cieffebis9])([cieffequatris15 ] ) in the conjunct at line  ( [ formulazza2 ] ) ( i.e. , in @xmath356 ) do not depend on the specific @xmath342 .",
    "then , the conjunct  ( [ formulazza2 ] ) is satisfied .",
    "let us also observe that condition  ( [ formulazza1 ] ) holds too .",
    "this is so because , for all @xmath357 we have that @xmath358 .",
    "from the fact that @xmath359 it follows that @xmath360 holds .",
    "finally , the condition  ( [ formulazza3 ] ) is satisfied because , whenever @xmath361 holds , by the definition of @xmath267 , it must be the case that @xmath362 .",
    "it follows that @xmath345 is satisfiable ( by @xmath342 ) .",
    "this is a contradiction and proves that @xmath307 is minimally closed w.r.t .",
    "@xmath98 , @xmath344 , and @xmath48 , and that @xmath338 is a valid transition .",
    "let @xmath18 be an instance of a planning problem , where @xmath15 is a domain description and @xmath19 contains any number of axioms of the form @xmath210 and @xmath212 .",
    "we conclude this section by stating a generalization of theorem  [ completebmv0soundbmv0 ] to the case of @xmath265 .",
    "[ completebmv1soundbmv1 ] there is a valid trajectory @xmath262 if and only if    * @xmath363 * there is a solution for the constraint @xmath364 * for each @xmath365 the formula @xmath366 is unsatisfiable .",
    "the result follows from theorems  [ completebmv1 ] and  [ soundbmv1 ] .",
    "we conclude this section by showing that  is at least as expressive as @xmath1 . to this aim",
    "it suffices to describe how to translate a domain description @xmath15 of @xmath1 to a domain description @xmath367 , in such a way that the semantics of the domain is preserved .",
    "let us outline the main points of such a translation .",
    "each boolean fluent @xmath11 in @xmath15 can be modeled in  by a multi - valued fluent @xmath368 whose domain is @xmath369 .",
    "each action in @xmath15 uniquely corresponds to an action in @xmath367 .",
    "let us consider a dynamic causal law of @xmath15 , e.g. , @xmath370)}.\\ ] ] this law is translated in @xmath367 as @xmath371)}.\\ ] ] in a similar manner , static laws and executability conditions of @xmath15 are mapped into .",
    "consequently , the two domain descriptions @xmath15 and @xmath367 describe two isomorphic transition systems .      in this section ,",
    "we generalize the treatment described in section  [ bmvisemantics ] in order to provide a state - transition semantics for  suitable to cope with temporal references .",
    "the first form of temporal references involves annotated fluents and concerns relative access to their past values , w.r.t .  the current state .",
    "there is no restriction on the occurrences of this kind of annotated fluents : they might be used in all laws of a domain description . in this case , the extension of the semantics described in section  [ bmvisemantics ] comes rather naturally .",
    "since references may relate different points in time along the plan , the approach consists of considering sequences of states instead of pairs of states , to define the transition constraints .",
    "regarding references to future points in time ( i.e. , positively annotated fluents ) , we recall that they are admitted in the consequences of dynamic causal laws only .",
    "this restriction allows the treatment of future and past references by exploiting the very same mechanisms .",
    "the semantics is further enriched in section  [ sema_4 ] to encompass state constraints specified by using absolute time references , as well as costs .",
    "let @xmath372 be a state sequence .",
    "given @xmath159 , and @xmath373 , we define the concept of _ value _ of @xmath163 in @xmath159 at time @xmath374 ( with abuse of notation , denoted by @xmath375 ) as follows : to be the current point in time and @xmath353 to be negative .",
    "the notation could then be simplified by considering just a prefix @xmath376 of the state sequence . ]",
    "@xmath377 where @xmath378 , @xmath379 .    as for ( [ eq : semofbmv ] ) of section  [ bmvisemantics ] , the semantics of reified constraints relies on the notion of satisfaction , which in turn has to be contextualized to a specific point in time  @xmath374 .",
    "more formally , given a fluent constraint @xmath171 and a state sequence @xmath159 , the notion of satisfaction at time @xmath374 is defined as @xmath380 .",
    "the notion @xmath381 is generalized to the case of propositional combinations of fluent constraints in the usual manner .    given a constraint @xmath109 ,",
    "let @xmath382 be the set of annotated fluents @xmath383 , for @xmath384 , occurring in @xmath109 .",
    "given a state sequence @xmath385 , with @xmath386 , a function @xmath387 is an _",
    "@xmath374-solution _ of @xmath109 w.r.t .",
    "@xmath159 , if it holds that @xmath388 where each @xmath389 ( for @xmath88 ) is the restriction of the assignment @xmath183 to the fluent annotated with @xmath141 , and @xmath390 denotes the substitution obtained by completing @xmath391 , with assignment to @xmath155 for all fluents not in @xmath392 .",
    "note that we treat the interpretation of the various operations as strict w.r.t .",
    "@xmath155 and we assume satisfied all constraints that refer to undefined expressions . hence , for instance , if @xmath109 is constraint and there is a sub - expression @xmath393 of @xmath109 evaluated as @xmath155 , then we assume @xmath394 .",
    "[ rico3 ] let @xmath395 and @xmath396 .",
    "consider the constraint @xmath397 and let @xmath398 .",
    "then @xmath399 is a 1-solution of the constraint  @xmath109 , since    * @xmath400 ,  and * @xmath401 , in fact , we have that @xmath402 is @xmath403 , which is equivalent to @xmath404 .",
    "a state sequence @xmath405 is _ closed _",
    "w.r.t .  a set of static causal laws @xmath406",
    "if for all @xmath407 it holds that @xmath408 .    we also generalize the notion of minimal closure as follows : given a state sequence @xmath409 and a state @xmath274 we say that @xmath274 is minimally closed w.r.t .",
    "@xmath159 , @xmath273 , and @xmath48 if    * @xmath410 is closed w.r.t . @xmath48 * for all sets of fluents @xmath277 , if the state @xmath411 is different from @xmath274 , then @xmath412 is not closed w.r.t . @xmath48 .    the action @xmath17 is _ executable _ in @xmath159 at time @xmath374 if there is an axiom @xmath195 such that @xmath413 .",
    "let us denote with @xmath197 the set of dynamic causal laws for an action @xmath17 .",
    "the _ effects _ of executing @xmath17 in @xmath159 at time @xmath374 , denoted by @xmath414 , is @xmath415    given a constraint @xmath109 , we denote by @xmath416 the constraint obtained from @xmath109 by replacing each fluent @xmath417 with @xmath418 .",
    "let us assume that @xmath419 is a sequence of complete states and that @xmath420 is a sequence of actions @xmath421 .",
    "the effects of the sequence of actions in @xmath159 is represented by the formula @xmath422    let us observe that this constraint might involve all fluents of the states @xmath423 , as well as fluents of future states .",
    "the values of fluents in states @xmath423 are fixed by @xmath159 .",
    "let @xmath73 be a planning problem instance , @xmath207 be a sequence of complete states and @xmath208 be actions .",
    "then , @xmath424 is a _ valid trajectory _",
    "if the following conditions hold :    * @xmath425 is closed w.r.t . @xmath48",
    "* for each axiom of the form @xmath426 in @xmath19 , we have that @xmath427 * for each axiom of the form @xmath212 in @xmath19 , we have that @xmath428 * for each @xmath214 the following conditions hold * * action @xmath429 is executable in @xmath159 at time @xmath374 and * * we have that @xmath430 where * * * @xmath183 is a @xmath374-solution of the constraint @xmath431 w.r.t .",
    "@xmath432 , * * * @xmath433 is minimally closed w.r.t .",
    "@xmath434 , @xmath294 , and @xmath48 .",
    "let us consider the following domain specification and planning problem instance ( for @xmath435 ) : @xmath436 observe that the only valid trajectory is @xmath437 the validity can be verified by observing that :    * @xmath438 satisfies all the constraints provided in the declarations ; * @xmath439 satisfies the goal constraint @xmath440 ; * the action @xmath17 is executable in @xmath441 and action @xmath442 is executable in @xmath443 ( since both their executability laws and the action conditions are trivially true ) .",
    "* consider the first state transition and @xmath444 and note that @xmath445 .",
    "then , @xmath446 is a @xmath10-solution of @xmath447 w.r.t .",
    "in fact , @xmath449 , @xmath450 , and * * @xmath451 * * @xmath452 . * * @xmath453 is minimally closed w.r.t .",
    "@xmath454 , @xmath455 and @xmath456 . *",
    "consider the second state transition and @xmath396 and note that @xmath457 .",
    "then , @xmath458 is a @xmath9-solution of @xmath459 w.r.t .",
    "in fact , @xmath461 , and * * @xmath462 * * @xmath463 . * * @xmath464 is minimally closed w.r.t .",
    "@xmath465 , @xmath466 and @xmath456 .",
    "the constraint encoding for  is similar to the one developed earlier for the case of  ( cf .",
    ", figures  [ cieffebis ] and  [ cieffequatris ] ) . in the encoding of a trajectory @xmath209 in",
    ", we introduced a variable @xmath467 to represent the value of the fluent @xmath11 in the @xmath468 state  @xmath161 . in each state transition , say from @xmath161 to @xmath433 , the implementation of imposes only constraints involving the variables / fluents of the current state . in the language encompassing timed references",
    ", each constraint occurring in the action description can address the values that fluents assume in any of the states of the sequence @xmath207 .",
    "since all the variables representing these values are present in the encoding , only the following change is needed to adapt to  the implementation designed for : to obtain from a constraint @xmath109 ( involving fluents ) , a constraint @xmath469 ( involving the corresponding variables ) , at time @xmath374 , we replace each @xmath470 with the variable @xmath471 .    by adopting this refined construction for @xmath469",
    ", we can inherit all the results of section  [ absconcbmvii ] .",
    "in particular , for an action description @xmath15 , similarly to what done in section  [ absconcbmvii ] , we denote by @xmath472 and by @xmath473 the constraints homologous to @xmath474 and @xmath475 , respectively .    the completeness result for",
    "directly generalizes that obtained for . with regards to soundness",
    ", the observation made w.r.t .  in section  [ absconcbmvii ] still applies .",
    "in fact , let @xmath18 be an instance of a planning problem where @xmath15 is a domain description and @xmath19 contains axioms of the form @xmath210 and @xmath212 .",
    "we state the following :    [ completebmvsoundbmv ] there is a valid trajectory @xmath476 if and only if    * @xmath477 is closed w.r.t .",
    "@xmath48 * there is a solution for the constraint @xmath478 * for each @xmath365 the formula @xmath479 is unsatisfiable .",
    "cost and time constraints can be introduced by filtering the solutions characterized by theorem  [ completebmvsoundbmv ] , in order to rule out the unsatisfactory solutions .",
    "more precisely , given a trajectory @xmath480 satisfying the requirements of theorem  [ completebmvsoundbmv ] , we say that the trajectory satisfies a set of global constraints as described in sections  [ absolutetemporalconstraints ] and  [ costconstraints ] if all the constraints described next hold .",
    "let us start by investigating the cost constraints .",
    "let @xmath481 and @xmath482 be specified in the action description .",
    "let us recall that the general form of cost constraints is @xmath146 , where @xmath109 is a constraint defined as in section  [ bmvsyntax ] , with the added ability to refer to the atoms , , and wherever fluents can be used .",
    "consequently , we extend our definition of value of an expression @xmath163 in @xmath483 at time @xmath374 ( for all @xmath353 ) : @xmath484 ( assigning cost constraints to to states outside the plan is senseless .",
    "however , for completeness , for @xmath485 or @xmath486 we set @xmath487 but any other choice  e.g. , @xmath155 , or the values on states @xmath10 or @xmath85  is reasonable ) .",
    "this modification allows us to derive the notion of satisfaction of a cost constraint @xmath109 from the notion of satisfaction defined in section  [ abstractimplbmv ] .",
    "as particular cases , we obtain that :    * for each assertion @xmath488 the plan cost @xmath489 has to satisfy the stated constraint , i.e. , it must hold that @xmath490 ; * for each assertion @xmath491 , the cost @xmath492 of the goal state must satisfy the constraint : @xmath493 ; * for each assertion @xmath494 , the cost @xmath495 assigned to the @xmath468 state has to satisfy the constraint @xmath496 .",
    "the handling of time constraints requires the following modifications :    * for each assertion @xmath497 , it holds that @xmath498 , where each timed fluent @xmath499 is evaluated as @xmath500 ; * for each assertion of the form @xmath501 it holds that @xmath502 ; * for each assertion of the form @xmath503 , it holds that @xmath502 for all @xmath504 .",
    "moreover , if @xmath505 is specified , then there exists no other trajectory @xmath506 such that @xmath507 . as particular cases",
    ", we have that    * if ( ) is specified , then there exists no other trajectory having a smaller plan cost ; * if ( ) is specified in the action description , then there is no trajectory @xmath508 , fulfilling all constraints , and such that @xmath509 .    in this manner",
    ", we characterize the solutions of a given planning problem to be exactly those solutions described by theorem  [ completebmvsoundbmv ] that additionally satisfy all the global constraints , the requirements on costs , and the time constraints expressed in the action description .",
    "soundness and completeness properties directly carry over",
    ".    55 [ bmapcode056 ] set_one_fluent(fluent(fluentname , iv ) ,  actionoccs ,  now ,  states ) : - + [ bmapcode057 ] findall([act , op , fe1,fe2,l ] , + [ bmapcode058 ]  ( causes(act , fc , l ) , zero_subterm(fluentname , fc ) , + [ bmapcode059 ]  fc = ..  [ op , fe1,fe2 ] ) , dyn ) , + [ bmapcode060 ] state_select(now , states , fromstate ) , + [ bmapcode061 ] next is now+1 , + [ bmapcode062 ] state_select(next , states , tostate ) , + [ bmapcode063 ] member(fluent(fluentname , ev ) , tostate ) , + [ bmapcode064 ] dynamic(dyn , actionoccs , fromstate , dynformula , next , states ) , + [ bmapcode065 ] cluster_rules(fluentname , stat ) , % % % these 2 lines can be dropped in + [ bmapcode066 ] static(stat , states , next , statformula),%%% absence of static laws + [ bmapcode067 ] bool_disj(dynformula , statformula , formula ) , + [ bmapcode068 ] ` # \\ ` formula ` # = > ` ev ` # = ` iv .",
    "+ [ bmapcode069 ] dynamic ( [ ] , _ , _ , [ ] , _ , _ ) .",
    "+ [ bmapcode070 ] dynamic([[act , op , fe1,fe2,prec]|rest],aoccs , state,[flag|pf1],now , states )  : - + [ bmapcode071 ] member(action(act , va ) , aoccs ) , + [ bmapcode072 ] last is now-1 , % % % looks for preconditions in fromstate and before + [ bmapcode073 ] get_precondition_vars(last , prec , states , listpv ) , + [ bmapcode074 ] length(prec , nprec ) , + [ bmapcode075 ] sum(listpv , sumprec ) , + [ bmapcode076 ] % % % the effect is in the next state ( now = last+1 ) + [ bmapcode077 ] rel_parsing(fe1 , val1 , now , states ) , + [ bmapcode078 ] rel_parsing(fe2 , val2 , now , states ) , + [ bmapcode079 ] exp_constraint(val1 , op , val2 , c ) , + [ bmapcode080 ] ( va ` # /\\ `",
    "( sumprec ` # = ` nprec ) ) ` # < = > ` flag , + [ bmapcode081 ] flag ` # = > ` c , + [ bmapcode082 ] dynamic(rest , actionoccs , state , pf1 , now , states ) . + [ bmapcode083 ] rel_parsing(num , num , _ , _ ) : - + [ bmapcode084 ] integer(num ) , ! . + [ bmapcode085 ] rel_parsing(rei(rc ) , val , time , states ) : - + [ bmapcode086 ] rc = ..  [ op , e1,e2 ] , + [ bmapcode087 ] rel_parsing(e1 , val1 , time , states ) , + [ bmapcode088 ] rel_parsing(e2 , val2 , time , states ) , + [ bmapcode089 ] exp_constraint(val1 , op , val2 , val ) , ! .",
    "+ [ bmapcode090 ] rel_parsing(abs(fe ) , val , time , states ) : - % % % similar for -(fe ) + [ bmapcode091 ] rel_parsing(fe , val1 , time , states ) , + [ bmapcode092 ] val ` # = ` abs(val1 ) , ! . + [ bmapcode093 ] rel_parsing(fe , val , time , states ) : - + [ bmapcode094 ] fe = ..  [ op , fe1,fe2 ] , + [ bmapcode095 ] member(op , [ + , -,mod,/ , * ] ) , + [ bmapcode096 ] rel_parsing(fe1 , val1 , time , states ) , + [ bmapcode097 ] rel_parsing(fe2 , val2 , time , states ) , + [ bmapcode098 ] ( op = + - > val ` # = ` val1 + val2 ; + [ bmapcode099 ] op = - - > val ` # = ` val1 - val2 ; + [ bmapcode100 ] op = * - > val ` # = ` val1 * val2 ; + [ bmapcode101 ] op = / - > val ` # = ` val1 / val2 ; + [ bmapcode102 ] op = mod - > val ` # = ` val1 mod val2 ) , ! .",
    "+ [ bmapcode103 ] rel_parsing(fluent`^`delta , val , time , states ) : - + [ bmapcode104 ] h is time+delta , + [ bmapcode105 ] length(states , n ) , + [ bmapcode106 ] in_interval(h , n , e ) , + [ bmapcode107 ] state_select(e , states , state ) , + [ bmapcode108 ] member(fluent(fluent , val),state),!. + [ bmapcode109 ] rel_parsing(fluent ` @ ` time , val , _ , states ) : - + [ bmapcode110 ] state_select(time , states , state ) , + [ bmapcode111 ] member(fluent(fluent , val),state ) , ! .",
    "+ [ bmapcode112 ] rel_parsing(fluent , val , time , states ) : - + [ bmapcode113 ] state_select(time , states , state ) , + [ bmapcode114 ] member(fluent(fluent , val ) , state ) . + [ bmapcode115 ] parsing(fluent , val , state ) : - + [ bmapcode116 ] rel_parsing(fluent , val , 0 , [ state ] ) . + [ bmapcode117 ] exp_constraint(l , op , r , c ) : - + [ bmapcode118 ] ( op = = eq - > c ` # < = > ` l ` # = ` r ; + [ bmapcode119 ] op = = neq - > c ` # < = > ` l `",
    "# \\= ` r ; + [ bmapcode120 ] op = = geq - > c ` # < = > ` l ` # > = ` r ; + [ bmapcode121 ] op = = leq - > c ` # < = > ` l `",
    "# = < ` r ; + [ bmapcode122 ] op = = gt - > c ` # < = > ` l ` # > ` r ; + [ bmapcode123 ] op = = lt - > c ` # < = > ` l ` # < ` r ) .",
    "the overall structure of the concrete implementation of the language  follows that used for implementing the @xmath1 language .",
    "we focus here on the main differences .    to start ,",
    "let us briefly describe the code depicted in figure  [ fig : codice_bmvi ] and show that this concrete implementation reflects the abstract one defined in figure  [ cieffebis ] .",
    ", @xmath26 , etc . ]",
    "hence , we preliminarily ignore lines ( [ bmapcode065])([bmapcode066 ] ) of figure  [ fig : codice_bmvi ] .",
    "the first difference w.r.t .",
    "the implementation of @xmath1 ( cf .",
    ", section  [ implemb ] ) is that each fluent variable is assigned to a finite set domain , drawn from the fluent declaration  instead of being treated as a boolean variable .",
    "the predicate ( lines ( [ bmapcode056])([bmapcode068 ] ) ) has a similar role as in the implementation of @xmath1 .",
    "given the fluent , the relevant parts of the dynamic causal laws are collected in lines ( [ bmapcode057])([bmapcode059 ] ) .",
    "the predicate is an auxiliary predicate that detects if a constraint involves a fluent  i.e . , it looks for an occurrence of in the constraint imposed by the dynamic causal laws .",
    "all the fluents explicitly involved in the consequence of a dynamic law are collected . in line ( [ bmapcode063 ] ) , the variable identifying the fluent in the following state is retrieved .",
    "the predicate ( line ( [ bmapcode064 ] ) ) collects the list of boolean flags .",
    "if one of the variables in is true then the variable is involved in a constraint imposed by a dynamic causal law . in line ( [ bmapcode067 ] )",
    "the disjunction of these flag variables is computed in ( let us ignore , for the time being , the variable ) . in line ( [ bmapcode068 ] ) the inertia constraint is added : if is false then the value of the fluent is left unchanged by the transition ( i.e. , @xmath510 ) .",
    "this corresponds to the @xmath247 operator .    for each action affecting the value ,",
    "the predicate ( lines ( [ bmapcode069])([bmapcode082 ] ) ) retrieves its preconditions and builds the constraint involving that must be imposed if the preconditions are satisfied .",
    "the flag variable in line ( [ bmapcode080 ] ) is introduced to keep track of the fact that the action has occurred ( i.e. , is true ) and the corresponding precondition holds . if is true then the constrain is asserted ( line ( [ bmapcode081 ] ) ) .",
    "all flags are stored in a list ( cf . , the variable in line ( [ bmapcode064 ] ) ) .",
    "lines ( [ bmapcode083])([bmapcode114 ] ) provide an excerpt of the definition of the predicate .",
    "this predicate is used to transform fluent expressions to internal expressions involving fluent variables .",
    "is a list of states ( each of them , in turn is a list of all the fluent variables ) . the first argument is the fluent expression and the second one is the output internal expression .",
    "the argument represents the specific point in time in which a fluent is referred to ( cf .",
    ", the variable used in lines ( [ bmapcode069])([bmapcode082 ] ) and ( [ bmapcode124])([bmapcode134 ] ) to specify the precise point in time in which a fluent expression / constraint has to be evaluated ) . the predicate called in line ( [ bmapcode106 ] ) sets @xmath511 if @xmath512 , @xmath513 ( resp .",
    ", @xmath514 ) if @xmath515 ( resp . , @xmath516 ) .",
    "similarly , predicate ( lines ( [ bmapcode117])([bmapcode123 ] ) ) transforms fluent constraints into the corresponding constraints on the fluent variables .    the above described fragment of implementation is completed with the code needed to handle initial and goal state specifications .",
    "namely , for a specific instance of a planning problem @xmath18 , as done for @xmath1 , all constraint on the initial state ( resp . , those on the goal state ) are reflected by constraining the variables @xmath517 in the representation of the initial ( resp . , final ) state .",
    "we proceed by splitting the correctness proof into steps .",
    "we can now state the following result .",
    "[ concretesoundcompletenostatic ] the concrete implementation ( partially depicted in figure  [ fig : codice_bmvi ] ) is correct and complete w.r.t.the system of constraints of figure  [ cieffebis ] .",
    "this result immediately follows from the above argument .",
    "in fact , the constraint  ( [ cieffebis9 ] ) of figure  [ cieffebis ] is implicitly rendered by domain assignment for clp variables .",
    "constraints  ( [ cieffebis11 ] ) and ( [ cieffebis12 ] ) are dealt with in lines  ( [ bmapcode057])([bmapcode064 ] ) .",
    "line  ( [ bmapcode068 ] ) imposes constraint  ( [ cieffebis13 ] ) . concerning the sequentiality of the plan and the executability conditions ( i.e. , constraint  ( [ cieffebis10 ] ) )",
    ", we can observe that the implementation does not differ from that of @xmath1 ( in figure  [ fig : codice_bmvi ] we omitted the corresponding code , see figure  [ execfig ] ) .",
    "123 [ bmapcode124 ] static ( [ ] , _ , _ , [ ] ) . + [ bmapcode125 ] static([[op , fe1,fe2,cond]|others ] , states , now , [ flag|flags ] ) : - + [ bmapcode126 ] get_precondition_vars(now , cond , states , list ) , + [ bmapcode127 ] length(list , nl ) , + [ bmapcode128 ] sum(list , result ) , + [ bmapcode129 ] rel_parsing(fe1 , val1 , now , states ) , + [ bmapcode130 ] rel_parsing(fe2 , val2 , now , states ) , + [ bmapcode131 ] exp_constraint(val1 , op , val2 , c ) , + [ bmapcode132 ] ( result ` # = ` nl ) ` # < = > ` flag , + [ bmapcode133 ] flag ` # = > ` c , + [ bmapcode134 ] static(others , states , now , flags ) .",
    "let us now consider the presence of static causal laws . in figure  [ fig : bmvii ] , we list the predicate used to add constraints for the static causal laws .",
    "notice that the concrete implementation of figure  [ fig : bmvii ] contains a discrepancy with respect to the abstract one of figure  [ cieffequatris ] .",
    "in particular , the concrete implementation does not deal with an intermediate state ( named @xmath99 in the abstract implementation ) .",
    "the fluents of the target state are computed by exploiting direct relationships with the starting state of the transition .",
    "this allows us to introduce fewer clp variables .    in line  ( [ bmapcode065 ] ) of figure  [ fig : codice_bmvi ]",
    "the predicate collects all the ( static ) conditions imposed on the fluents of the cluster of .",
    "the call to the predicates ( line ( [ bmapcode066 ] ) ) collects the list of boolean flags which are used to model the constraints  ( [ cieffequatris22 ] ) and  ( [ cieffequatris23 ] ) of figure  [ cieffequatris ] . in line ( [ bmapcode067 ] ) ,",
    "the disjunction of these flag variables , together with those originating from the dynamic causal laws ( i.e. , ) , is computed in , as explained above .    for each condition implied by a static causal law , the predicate ( lines ( [ bmapcode124])([bmapcode134 ] ) )",
    "builds the constraint that must be imposed to ensure closure .",
    "the flag variable in line ( [ bmapcode132 ] ) is introduced to reflect the satisfaction of the constraint .",
    "if is true then the constrain is asserted ( line ( [ bmapcode133 ] ) ) .",
    "all such flags are stored in the list ( cf . ,",
    "the variable ) .",
    "we have the following result :    [ completofconcretebmvii ] the concrete implementation ( partially depicted in figures  [ fig : codice_bmvi ] and [ fig : bmvii ] ) is complete w.r.t .  the system of constraints of figures  [ cieffebis ] and [ cieffequatris ] .",
    "the result directly follows from the above argument .",
    "constraint ( [ cieffequatris15 ] ) of figure  [ cieffequatris ] is implicitly rendered by the domain assignment for the clp variables ( let us remember that the intermediate state @xmath99 is not explicit in the concrete implementation ) .",
    "constraints  ( [ cieffebis9])([cieffebis13 ] ) are dealt with as done in theorem  [ concretesoundcompletenostatic ] .",
    "the conditions originating from the static causal laws are dealt with through the predicates and .",
    "let us observe that there is a second difference between the concrete implementation of figures  [ fig : codice_bmvi ] and [ fig : bmvii ] and the abstract one of figure  [ cieffequatris ] : no requirements for the unsatisfiability of @xmath518 are imposed in correspondence of the state transition from @xmath519 to @xmath520 ( for any @xmath374 ) .",
    "this allows the generation of state transitions where the target state is potentially not minimally closed .",
    "this means that the concrete implementation may produce solutions ( i.e. , plans ) that the abstract semantics would forbid because of the non - minimal effects of ( clusters of ) static causal laws . on the other hand ,",
    "we reflect constraints  ( [ cieffequatris22 ] ) and  ( [ cieffequatris23 ] ) as described earlier , through the predicates ( listed in figure  [ fig : bmvii ] ) and ( whose obvious code is omitted ) .",
    "the final step in the design of the concrete implementation is the introduction of suitable restrictions on the labeling phase of the clp solver .",
    "notice that , if at step @xmath374 in a trajectory , a consequence of a dynamic law involves a fluent @xmath470 , for @xmath521 , then such a constraint has to be evaluated considering as already assessed all the states @xmath522 preceding  @xmath161 .",
    "hence , the labeling has to proceed `` left - to - right '' w.r.t .",
    "the clp variables that model the states @xmath523 .",
    "in other words , when searching for a solution , the variables representing the state @xmath522 have to be labeled before those representing the state @xmath524 , for each @xmath522 in the trajectory .",
    "the implementation of this labeling strategy is depicted in figure  [ mylabeling ] .",
    "moreover , observe that we impose further restrictions ( through the predicate in lines ( [ bmapcode147])([bmapcode155 ] ) ) to avoid loops in plans , i.e. , to forbid those trajectories where the same state appears twice .",
    "134 [ bmapcode135 ] lm_labeling(actionsocc , states ) : - + [ bmapcode136 ] lm_labeling(actionsocc , states , 1 ) . + [ bmapcode137 ] lm_labeling ( [ ] , _ , _ ) : - ! . + [ bmapcode138 ] lm_labeling([curract|actions ] , states , i ) : - + [ bmapcode139 ] lm_labeling_aux(curract ) , + [ bmapcode140 ] no_loop(states , i ) , + [ bmapcode141 ] i1 is i+1 , + [ bmapcode142 ] lm_labeling(actions , states , i1 ) .",
    "+ [ bmapcode143 ] lm_labeling_aux ( [ ] ) . +",
    "[ bmapcode144 ] lm_labeling_aux([action(_,a)|r ] ) : - + [ bmapcode145 ] indomain(a ) , + [ bmapcode146 ] lm_labeling_aux(r ) .",
    "+ [ bmapcode147 ] no_loop(states , a ) : - + [ bmapcode148 ] state_select(a , states , statea ) , + [ bmapcode149 ] no_loop(a , states , statea ) . +",
    "[ bmapcode150 ] no_loop(0 , _ , _ ) : - ! .",
    "+ [ bmapcode151 ] no_loop(b , states , statea ) : - + [ bmapcode152 ] b1 is b-1 , + [ bmapcode153 ] state_select(b1 , states , stateb ) , + [ bmapcode154 ] statea ` \\== ` stateb , + [ bmapcode155 ] no_loop(b1 , states , statea ) .    to complete the implementation of  we need to take care of the cost - based constraints , whose behavior relies on the optimization features offered by sicstus labeling predicate : the labeling phase is guided by an objective function to be optimized .    constraints on costs , as well as absolute temporal constraints , are handled by asserting suitable clp constraints on the variables that model fluent values .",
    "this is realized through the predicates listed in figure  [ codiceglobalconstraints ] . in particular , deals with constraints on actions",
    "/ plans and states .",
    "for instance , ( line  [ statecost ] ) retrieves all the assertions of the form and imposes the corresponding constraints .",
    "a similar predicate ( not reported in the figure ) accomplishes the same for the final state only .",
    "the predicate acts similarly , using the predicate ( lines  ( [ bmapcode184])([bmapcode185 ] ) ) where the cost for each single action is considered .",
    "all the absolute temporal constraints defined in the action description are handled by the predicate ( cf .",
    ", lines  ( [ bmapcode186])([bmapcode194 ] ) ) . also in this case , direct references to clp variables implement the references to fluent expressions in any absolute point in time .",
    "as mentioned , all these constraints can be seen as filters used to validate each trajectory found by the labeling phase .",
    "the planner described in figures  [ fig : codice_bmvi][mylabeling ] is completed by adding the code in figure  [ codiceglobalconstraints ] .",
    "completeness of the implementation of the full  immediately follows from the above discussion .",
    "155 set_cost_constraints(states , plancost , goalcost ) : - + set_goalcost(states , goalcost ) , + set_plancost(plancost ) , + set_statecosts(states ) .",
    "+ set_plancost(pc ) : - + findall([op , num],(cost_constraint(c ) , c= .. [op , plan , num ] ) , plancosts ) , + set_plancost_aux(plancosts , pc ) .",
    "+ set_plancost_aux ( [ ] , _ ) .",
    "+ set_plancost_aux([[op , num]|plancosts],pc ) : - + add_constraint(pc , op , num ) , + set_plancost_aux(plancosts , pc ) . + [ statecost]set_statecosts(states ) : - + findall([i , op , n],(cost_constraint(c ) , c= .. [op , state(i),n ] ) , costs ) , + set_statecost_aux(costs , states )",
    ". + set_statecost_aux ( [ ] , _ ) .",
    "+ set_statecost_aux([[i , op , num]|statecosts],states ) : - + ( state_cost(fe ) , ! ; fe = 1 ) , + rel_parsing(fe , val , i , states ) , + add_constraint(val , op , num ) , + set_statecost_aux(statecosts , states ) .",
    "+ [ bmapcode168 ] make_action_occs(n , actionsocc , plancost , na ) : - + [ bmapcode169 ] setof(a , action(a ) , la ) , + [ bmapcode170 ] length(la ,",
    "na ) , + [ bmapcode171 ] make_action_occurrences(n , la , actionsocc , plancost ) . + [ bmapcode172 ] make_action_occurrences(1 , _ , [ ] , 0 ) . + [ bmapcode173 ] make_action_occurrences(n , list , [ act|actionsocc ] , cost ) : - + [ bmapcode174 ] n1 is n-1 , + [ bmapcode175 ] make_action_occurrences(n1 , list , actionsocc , cost1 ) , + [ bmapcode176 ] make_one_action_occurrences(list , act , cost2 ) , + [ bmapcode177 ] get_action_list(act , alist ) , + [ bmapcode178 ] fd_only_one(alist ) , + [ bmapcode179 ] cost ` # = ` cost1+cost2 . + [ bmapcode180 ] make_one_action_occurrences ( [ ] , [ ] , 0 ) . + [ bmapcode181 ] make_one_action_occurrences([a|actions ] , [ action(a , occa)|occacts ] , cost ) : - + [ bmapcode182 ] make_one_action_occurrences(actions , occacts , cost1 ) , + [ bmapcode183 ] fd_domain_bool(occa ) , + [ bmapcode184 ] ( action_cost(a , ca ) , ! ; ca = 1 ) , % % % default action cost = 1 + [ bmapcode185 ] cost ` # = ` occa*ca+cost1 .",
    "+ [ bmapcode186 ] set_time_constraints(states ) : - + [ bmapcode187 ] findall([fe1,op , fe2 ] , ( time_constraint(c),c= .. [op , fe1,fe2 ] ) , timecs ) , + [ bmapcode188 ] set_time_constraints(timecs , states ) . + [ bmapcode189 ] set_time_constraints ( [ ] , _ ) . + [ bmapcode190 ] set_time_constraints([[fe1,op , fe2]|rest ] , states ) : - + [ bmapcode191 ] rel_parsing(fe1 , val1 , _ , states ) , + [ bmapcode192 ] rel_parsing(fe2 , val2 , _ , states ) , + [ bmapcode193 ] add_constraint(val1 , op , val2 ) , + [ bmapcode194 ] set_time_constraints(rest , states ) . + [ bmapcode195 ] add_constraint(l , op , r ) : - + [ bmapcode196 ] exp_constraint(l , op , r , 1 ) .",
    "we implemented clp - based prototypes of @xmath1 and .",
    "these have been realized in sicstus prolog 4 , and they have been developed on an amd opteron 2.2ghz linux machine .",
    "extensive testing has been performed to validate our clp - based approach . here",
    "we concentrate on a few representative examples .",
    "the source code of the implementations and the examples can be found at www.dimi.uniud.it/dovier/clpasp .",
    "no particular built - in predicates of sicstus have been used and therefore porting to other clp - based prolog systems is straightforward . a porting to b - prolog has been realized and used to participate in the 2009 asp competition .    in the rest of this section ,",
    "we analyze the performance of the implementation on a diverse set of benchmarks . for each benchmark",
    ", we compare a natural encoding using the traditional @xmath1 language with an encoding using .",
    "the problems encoded in @xmath1 have been solved using both the clp(fd ) implementation and implementations obtained by mapping the problem to asp and using different asp solvers ( smodels , clasp , and cmodels with different sat - solvers ) .    in order to solve a @xmath1-planning problem @xmath525 using an asp solver ,",
    "we have developed a prolog translator that takes as input @xmath525 and the plan length , and it generates an asp program , whose stable models are in one - to - one correspondence with the plans of length for @xmath525 .",
    "this encoding follows the general ideas outlined in @xcite .",
    "in particular , the definitions of , , and are already in asp syntax . the length of the plan is used to define the predicate .",
    "the asp - based planner makes use of a choice rule to ensure that exactly one action is applied at each time step : +    .",
    "the predicate defines the truth value of a fluent at a given time step ( ) .",
    "the truth value of the fluents at time @xmath10 are given as facts describing the initial state ; we require the initial state to be complete .",
    "the executability rules , the dynamic causal laws and the static causal laws are instantiated for each admissible time step .",
    "finally , the goal conditions are added to define the predicate ; the requirement that the goal has to be satisfied at the end of the plan is imposed using an asp constraint of the form +    .",
    "as far as the clp - based implementations are concerned , we use a leftmost variable selection strategy .",
    "moreover , we included a loop control feature to avoid the repetition of the same state in a trajectory ( cf .",
    ", the predicate in figure  [ mylabeling ] )",
    ".    tables  [ tabellabottinoloop][tabellawgc ] , discussed in detail in the next subsections , illustrate an excerpt of the experimental results . in order to simplify the comparison among the solvers , in each table we introduce an extra column , denoted by `` best asp , '' which indicates the performance of an hypothetical asp - solver that always acts as the best between all the asp - solvers considered .",
    "the specific meaning of the various columns is as follows :    * _ instance _ : the name of the specific instance of the problem * _ length _ : the plan length used in searching for a solution * _ answer _ : indication of whether an answer exists or not for the given plan length * _ lparse _ : the time required to ground the asp encoding of the problem ( using lparse 1.1.1 ) * _ smodels _ : the execution time using the smodels system ( using smodels 2.32 ) * _ cmodels _ : the execution time using the cmodels system ( using cmodels 3.70 with different sat solvers ) * _ clasp _ : the execution time using the clasp system ( using clasp 1.0.2 ) * _ best asp _ : a summary of the best execution time across all the different asp solvers * _",
    "clp(fd ) _ : the execution time using the clp(fd)-based implementation of @xmath5 .",
    "execution times have the form @xmath526 , where @xmath527 is the time needed for posting constraints and @xmath528 the time for solving the constraints ( i.e. , finding a plan ) * _ _ : the execution time using the  encoding of the problem .",
    "the first column is related to computations where no constraints for the plan cost are imposed . instead",
    ", the computations of the second column have a constraint that limits the plan cost to the number in parenthesis .",
    "the format is @xmath526 as explained in the previous point .    in the remaining subsections",
    "we briefly describe the benchmarks tested and the obtained results . the actual encoding in @xmath1 and",
    "have been placed in the appendix for the sake of readability . a summary and a discussion of all the experiments",
    "is presented in section  [ pallosection ] .",
    "capacities &    90(5,10)length    &    90(5,10)answer    & & & & & & & & + & & & & & zchaff & relsat & minisat & & & & & + 8 - 5 - 3 & 6 & n & 8.74 & 0.10 & 0.34 & 0.63 & 0.30 & 0.27 & 0.10 & 0.14 + 0.29 & 0.03 + 0.03 & ( 70 ) & 0.02 + 0.03 + 8 - 5 - 3 & 7 & y & 8.92 & 0.20 & 1.87 & 2.39 & 0.55 & 0.23 & 0.20 & 0.22 + 0.28 & 0.03 + 0.02 & ( 70 ) & 0.02 + 0.02 + 8 - 5 - 3 & 8 & y & 8.87 & 0.20 & 7.34 & 3.63 & 0.62 & 0.53 & 0.20 & 0.26 + 1.04 & 0.05 + 0.07 & ( 70 ) & 0.01 + 0.06 + 8 - 5 - 3 & 9 & y & 9.03 & 0.17 & 17.60 & 5.02 & 0.60 & 2.34 & 0.17 & 0.24 + 1.03 & 0.02 + 0.05 & ( 70 ) & 0.02 + 0.06 + 12 - 7 - 5 & 10 & n & 34.47 & 1.98 & 153.36 & 14.56 & 41.34 & 29.13 & 1.98 & 0.58 + 4.85 & 0.04 + 0.13 & ( 120 ) & 0.04 + 0.13 + 12 - 7 - 5 & 11 & y & 34.54 & 2.28 & 98.72 & 15.78 & 11.71 & 52.15 & 2.28 & 0.64 + 2.61 & 0.02 + 0.07 & ( 120 ) & 0.03 + 0.07 + 12 - 7 - 5 & 12 & y & 35.42 & 1.60 & 125.84 & 20.45 & 83.06 & 35.81 & 1.60 & 0.73 + 8.11 & 0.07 + 0.18 & ( 120 ) & 0.05 + 0.19 + 12 - 7 - 5 & 13 & y & 35.69 & 0.68 & 342.40 & 42.36 & 97.99 & 111.36 & 0.68 & 0.79 + 6.23 & 0.07 + 0.14 & ( 120 ) & 0.07 + 0.14 + 16 - 9 - 7 & 14 & n & 115.47 & 11.15 & 1508.43 & 613.42 & 75.67 & 1838.39 & 11.15 & 1.30 + 27.16 & 0.03 + 0.31 & ( 200 ) & 0.07 + 0.31 + 16 - 9 - 7 & 15 & y & 114.03 & 12.30 & 586.43 & 58.45 & 65.19 & 1133.21 & 12.30 & 1.53 + 13.35 & 0.06 + 0.13 & ( 200 ) & 0.07 + 0.14 + 16 - 9 - 7 & 16 & y & 115.60 & 6.06 & 793.00 & 151.56 & 157.38 & 744.60 & 6.06 & 1.62 + 37.69 & 0.07 + 0.37 & ( 200 ) & 0.07 + 0.36 + 16 - 9 - 7 & 17 & y & 114.60 & 1.75 & 2963.37 & 128.91 & 145.11 & 14106.98 & 1.75 & 1.67 + 26.98 & 0.07 + 0.27 & ( 200 ) & 0.07 + 0.27 + 20 - 11 - 9 & 18 & n & 185.38 & 43.71 & 2949.10 & 2312.09 & 493.98 &  & 43.71 & 2.76 + 102.14 & 0.09 + 0.58 & ( 300 ) & 0.08 + 0.57 + 20 - 11 - 9 & 19 & y & 186.76 & 40.08 & 3053.53 & 1187.10 & 1152.27 & 11292.40 & 40.08 & 2.94 + 45.43 & 0.09 + 0.24 & ( 300 ) & 0.10 + 0.24 + 20 - 11 - 9 & 20 & y & 186.31 & 21.67 & 1866.28 & 2265.05 & 1378.93 & 12286.98 & 21.67 & 3.05 + 120.90 & 0.09 + 0.68 & ( 300 ) & 0.09 + 0.65 + 20 - 11 - 9 & 21 & y & 189.28 & 4.39 & 5482.78 & 586.18 & 1746.81 &  & 4.39 & 3.17 + 80.54 & 0.10 + 0.46 & ( 300 ) & 0.10 + 0.43 +      we experimented with different encodings of the three - barrel problem .",
    "our formulation is as described in example  [ exempiobarrelsb ] .",
    "figure  [ bool_barrels ] and section  [ mv_barrels ] show the encoding of the problem ( for @xmath31 ) in @xmath529 and in , respectively .",
    "notice that , in order to represent each multi - valued fluent @xmath11 of the  formulation , a number of boolean fluents have to be introduced in the @xmath1 encoding , one for each admissible value of  @xmath11 .",
    "table  [ tabellabottinoloop ] provides the execution times ( in seconds ) for different values of @xmath28 and different plan lengths .",
    "the results show that the constraint - based encoding of @xmath529 outperforms the asp encodings ( if we consider both grounding and execution ) . in turn",
    ", the  encoding outperforms all other encodings .",
    "this can be explained by considering that the clp encoding of this problem benefits from numerical fluents ( in reduced number , w.r.t .  the @xmath529 formulation ) and from arithmetic constraints ( efficiently handled by clp(fd ) ) .",
    "the problem we have encoded is a simplification of the protein structure folding problem .",
    "the input is a chain @xmath530 with @xmath531 , initially placed in a vertical position , as in figure  [ pffigure1]-left .",
    "we will refer to each @xmath532 as an _ amino acid_. the permissible actions are the counter - clockwise / clockwise _ pivot moves_. once one point @xmath374 of the chain is selected , the points @xmath533 will remain fixed , while the points @xmath534 will perform a rigid counter - clockwise / clockwise rotation .",
    "each conformation must be a _ self - avoiding - walk _",
    ", i.e. , no two amino acids are in the same position .",
    "moreover , the chain can not be broken ",
    ", two consecutive amino acids are always at points at distance 1 ( i.e. , in contact ) .",
    "the goal is to perform a sequence of pivot moves leading to a configuration where at least @xmath141 non - consecutive amino acids of value 1 are in contact .",
    "figure  [ pffigure1 ] shows a possible plan to reach a configuration with 4 contacts .",
    "table  [ pffigure2 ] reports some execution times .",
    "section  [ pf - encoding ] reports the  action description encoding this problem .",
    "since the goal is based on the notion of cost of a given state , for which reified constraints are used extensively , a direct encoding in @xmath1 does not seem to be feasible .",
    "( 55,135)(-10,-10 ) ( 10,10)(30,0 ) ( 10,20)(30,0 ) ( 10,30)(30,0 ) ( 10,40)(30,0 ) ( 10,50)(30,0 ) ( 10,60)(30,0 ) ( 10,70)(30,0 ) ( 10,80)(30,0 ) ( 10,90)(30,0 ) ( 10,100)(30,0 ) ( 10,110)(30,0 ) ( 10,120)(30,0 ) ( 10,130)(30,0 ) ( 10,0)(0,130 ) ( 20,0)(0,130 ) ( 30,0)(0,130 ) ( 15,-10)10 ( -10,28)10 ( -10,118)19 ( 20,30 ) ( 20,30)(0,1)90 ( 20,40 ) ( 20,50 ) ( 20,60 ) ( 20,70 ) ( 20,80 ) ( 20,90 ) ( 20,100 ) ( 20,110 ) ( 20,120 )       l pivot(2,clock ) + pivot(3,clock ) + pivot(9,clock ) + pivot(8,clock ) + pivot(7,antick ) + pivot(6,clock ) + pivot(4,antick ) + pivot(5,clock ) +   +   +   +       ( 75,135)(-25,-10 ) ( -10,0)(60,0 ) ( -10,10)(60,0 ) ( -10,20)(60,0 ) ( -10,30)(60,0 ) ( -10,40)(60,0 ) ( -10,50)(60,0 ) ( -10,60)(60,0 ) ( -10,70)(60,0 ) ( -10,80)(60,0 ) ( -10,90)(60,0 ) ( -10,100)(60,0 ) ( -10,110)(60,0 ) ( -10,120)(60,0 ) ( -10,130)(60,0 ) ( -10,0)(0,130 ) ( 0,0)(0,130 ) ( 10,0)(0,130 ) ( 20,0)(0,130 ) ( 30,0)(0,130 ) ( 40,0)(0,130 ) ( 50,0)(0,130 ) ( 15,-10)10 ( -25,28)10 ( 20,30 ) ( 20,30)(0,1)10 ( 20,40 ) ( 20,40)(1,0)10 ( 30,40 ) ( 30,40)(0,-1)10 ( 30,30 ) ( 30,30)(1,0)10 ( 40,30 ) ( 40,30)(0,-1)10 ( 40,20 ) ( 40,20)(-1,0)10 ( 30,20 ) ( 20,10)(1,0)10 ( 30,10 ) ( 30,10)(0,1)10 ( 20,10 ) ( 20,10)(0,1)10 ( 20,20 )     1@xmath535 - 2 & 3 & y & 0.07 + 0.01 + 1@xmath535 - 2 & 4 & y & 0.09 + 0.01 + 1@xmath536 - 6 & 3 & n & 0.42 + 19.91 + 1@xmath536 - 6 & 4 & y & 0.57 + 35.16 + 1(001)@xmath537 - 2 & 3 & n & 0.06 + 0.09 + 1(001)@xmath537 - 2 & 4 & y & 0.07 + 0.01 + 1(001)@xmath538 - 4 & 7 & n &  0.47 + 7521.13 + 1(001)@xmath538 - 4 & 8 & y & 0.49 + 50.46 + 1(001)@xmath538 - 4 & 9 & ? & ",
    "+ 1(001)@xmath538 - 4 & 10 & y & 0.63 + 603.37 +    let us consider the resolution of the instance depicted in figure  [ pffigure1 ] , i.e. , the folding of the input chain @xmath539 of @xmath540 amino acids .",
    "asking for a plan of @xmath541 ( resp .",
    "@xmath542 ) moves and for a solution with cost @xmath543 , our planner finds the 8-moves plan shown in figure  [ pffigure1]-center in 50.46s ( a 10-moves plan in found in 603.37s ) . by removing the two constraints that keep fixed @xmath544 :     +",
    "the solutions are found in 52.72s and 617.68s , respectively . on the other hand , by keeping fixed @xmath544 and adding the two constraints     +    the execution time is reduced to 4.06s and 52.97s . adding the additional constraints     +    the plans are found in only 0.37s and 4.62s .",
    "this shows that the use of multi - valued fluents and the ability to exploit domain - specific knowledge , in the form of symmetry - breaking constraints , allows  to effectively converge to a solution .      the _ community _ problem is formulated as follows",
    ". there are @xmath545 individuals , identified by the numbers @xmath546 . at each time step , one of them ,",
    "say @xmath353 , gives exactly  @xmath353 dollars to someone else , provided she / he owns more than @xmath353 dollars .",
    "nobody can give away all of her / his money .",
    "the goal consists of reaching a state in which all the participants have the same amount of money .",
    "table  [ tabellacommunity ] lists some results for four variants of the problem : the person @xmath374 initially owns @xmath547 dollars ( instances @xmath548 ) , @xmath549 dollars ( instances @xmath550 ) , @xmath551 dollars ( instances @xmath552 ) , or @xmath553 dollars ( instances @xmath554 ) .",
    "the representations of this problem are reported in sections  [ bcommunity ] and  [ mvcommunity ] .",
    "notice that the large number of boolean fluents that have to be introduced in the @xmath1 description causes failures due to lack of memory during the grounding phase ( these instances are marked `` mem '' in table  [ tabellacommunity ] ) .",
    "for all these experiments , the bound on memory usage was 4  gb ( for the grounder , the asp - solvers , and the clp(fd ) engine ) .",
    "observe that , in some cases , also the clp(fd)-based solver for  @xmath1 runs out of memory , while the failures of the clp(fd ) solver for  have been caused by expiration of the time limit . in summary ,",
    "the constraint - based encodings provides better performance in most of the instances , especially considering their better scalability w.r.t .",
    "the size of the instances .",
    "this originates from the smaller number of numerical fluents and from the efficiency of the underlying constraint solver .",
    "90(5,10)instance    &    90(5,10)length    &    90(5,10)answer    & & & & & & & + & & & & & zchaff & relsat & minisat & & & & + a@xmath555 & 5 & n & 34.34 & 11.12 & 1.78 & 11.68 & 0.67 & 0.45 & 0.45 & 0.71 + 14.14 & 0.01 + 3.31 + a@xmath555 & 6 & y & 34.90 & 1.43 & 0.26 & 7.38 & 0.57 & 0.09 & 0.09 & 0.82 + 0.10 & 0.03 + 0.00 + a@xmath555 & 7 & y & 35.44 & 15.72 & 0.39 & 47.74 & 0.80 & 0.10 & 0.10 & 0.94 + 0.12 & 0.03 + 0.01 + a@xmath556 & 5 & n & 201.88 & 100.58 & 5.22 & 125.63 & 2.30 & 1.19 & 1.19 & 2.64 + 157.48 & 0.02 + 41.15 + a@xmath556 & 6 & y & 202.64 & 11.43 & 1.85 & 442.22 & 1.63 & 0.28 & 0.28 & 3.17 + 0.21 & 0.01 + 0.04 + a@xmath556 & 7 & y & 202.12 & 34.02 & 2.81 & 114.74 & 2.31 & 0.27 & 0.27 & 3.71 + 447.87 & 0.04 + 142.27 + b@xmath556 & 5 & n & 51.87 & 30.04 & 4.24 & 44.49 & 1.49 & 0.69 & 0.69 & 1.03 + 77.06 & 0.03 + 23.13 + b@xmath556 & 6 & y & 52.04 & 2.07 & 1.32 & 37.96 & 0.99 & 0.14 & 0.14 & 1.31 + 0.11 & 0.04 + 0.02 + b@xmath556 & 7 & y & 52.94 & 13.49 & 0.80 & 41.86 & 1.27 & 0.42 & 0.42 & 1.40 + 0.17 & 0.05 + 0.04 + b@xmath557 & 5 & n & mem & & & & & & & 7.67 + 3345.56 & 0.05 + 1421.54 + c@xmath556 & 5 & n & mem & & & & & & & 16.98 + 85.71 & 0.02 + 49.83 + c@xmath556 & 6 & n & mem & & & & & & & 20.44 + 1926.97 & 0.04 + 888.30 + c@xmath557 & 5 & n & mem & & & & & & & mem & 0.05 + 3186.34 + d@xmath555 & 5 & n & 138.91 & 7.08 & 1.28 & 13.48 & 0.76 & 0.43 & 0.43 & 3.70 + 21.19 & 0.01 + 6.83 + d@xmath555 & 6 & n & 139.88 & 90.32 & 11.56 & 87.11 & 3.62 & 3.72 & 3.72 & 4.32 + 0.50 & 0.02 + 0.74 + d@xmath555 & 7 & n & 139.82 & 1015.44 & 104.36 & 788.94 & 33.70 & 22.86 & 22.86 & 5.17 + 5.55 & 0.04 + 7.64 + d@xmath556 & 5 & n & mem & & & & & & & 24.64 + 24.12 & 0.05 + 93.88 + d@xmath556 & 6 & n & mem & & & & & & & 29.60 + 1490.48 & 0.02 + 1801.78 +    cc    ( -0.4,-1.4)(6.5,6.5 ) ( 1,1 ) ( 1,1 ) ( 1,1 ) ( 1,1 ) ( 1,1 ) ( 1,1 ) ( 1,1 ) ( 1,1 ) ( a1)(a5)(b9)(b10)(b11)(a6)(a10)(a1 ) ( 1,1 ) ( qc1)(0.06,0.19 ) ( a5)(qa5 ) ( a1)(a2)(a3)(a4)(a5)(a1 ) ( a6)(a7)(a8)(a9)(a10)(a6 ) ( 1.45,0.55 ) ( 1.60,0.95 ) ( 1.45,1.40 ) ( 0.85,0.95 ) ( 0.25,0.55 ) ( 0.10,0.95 ) ( 0.25,1.40 ) ( 1.10,1.70 ) ( 1.10,0.25 ) ( 0.57,1.70 ) ( 0.59,0.25 ) ( 1,1 ) ( c8)(b20)(b1)(b2)(b3)(b4)(b5)(b6)(b7)(b8)(b9)(b10)(b11)(b12)(b13)(b14)(b15)(b16)(b17)(b18)(b19)(b20)(c8)(c7)(c6)(c5)(c4)(c3)(c2)(c1)(c8 )    & @xmath558{|c|c|c|r| } { \\begin{turn}{90}{\\makebox(35,10){instance}}\\end{turn } }   & { \\begin{turn}{90}{\\makebox(35,10){length}}\\end{turn } } & { \\begin{turn}{90}{\\makebox(35,10){answer}}\\end{turn } } & { \\mbox{$\\mathcal{b}^{mv}$}}\\\\ \\cline{1 - 4 } a_{\\mathit{1 } } &   6 & n &          0.07 + 13.48 \\\\ a_{\\mathit{1 } } &   7 & y &          0.10 + 5.35 \\\\ b_{\\mathit{1 } } & 10 & n &          0.17 + 3846.20 \\\\ b_{\\mathit{1 } } & 11 & y &          0.14 + 1802.76 \\\\ b_{\\mathit{1 } } & 12 & y &          0.15 + 933.35 \\\\ b_{\\mathit{1 } } & 13 & y &          0.16 + 302.34 \\\\ b_{\\mathit{1 } } & 14 & y &          0.14 + 4.60 \\\\ b_{\\mathit{2 } } & 10 & n &          0.13 + 11134.82 \\\\ b_{\\mathit{2 } } & 11 & y &          0.15 + 4191.20 \\\\ b_{\\mathit{2 } } & 12 & y &          0.16 + 2156.52 \\\\ b_{\\mathit{2 } } & 13 & y &          0.18 + 710.53 \\\\ b_{\\mathit{2 } } & 14 & y &          0.17 + 6.36 \\\\ b_{\\mathit{3 } } & 10 & n &          0.12 + 18763.27 \\\\ b_{\\mathit{3 } } & 11 & y &          0.16 + 6124.91 \\\\ b_{\\mathit{3 } } & 12 & y &          0.15 + 3148.43 \\\\ b_{\\mathit{3 } } & 13 & y &          0.20 + 1145.04 \\\\ b_{\\mathit{3 } } & 14 & y &          0.18 + 9.97 \\\\ b_{\\mathit{4 } } & 10 & n &          0.11 + 17109.05 \\\\ b_{\\mathit{4 } } & 11 & y &          0.15 + 6173.49 \\\\ b_{\\mathit{4 } } & 12 & y &          0.14 + 3180.53 \\\\ b_{\\mathit{4 } } & 13 & y &          0.16 + 1159.27 \\\\ b_{\\mathit{4 } } & 14 & y &          0.18 + 10.34 \\\\ \\cline{1 - 4 } \\end{array}$ ]      the gas - diffusion problem can be formulated as follows . a building contains a number of rooms .",
    "each room is connected to ( some ) other rooms via gates .",
    "initially , all gates are closed and some of the rooms contain a quantity of gas  while the other rooms are empty . each gate can be opened or closed and are the only possible actions , provided that there is a gate between room   and room  . when a gate between two rooms is open , the gas contained in these rooms flows through the gate .",
    "the gas diffusion continues until the pressure reaches an equilibrium .",
    "the only condition to be always satisfied is that a gate in a room can be opened only if all the other gates are closed .",
    "the goal is to move a desired quantity of gas to one specified room .",
    "we experimented with instances of the problem where the building has a specific topology : there are eleven rooms , all having the same physical volume .",
    "each room is connected to the other rooms via gates as depicted in figure  [ gasdiffusionexp ] .",
    "since all rooms have the same volume , when equilibrium is reached between two rooms sharing an open gate , they will both contain the same amount of gas .",
    "a  specification of this planning problem is given in section  [ gasdiffusion ] .",
    "we experimented with different instances of the gas - diffusion problem obtained by considering different goal states and by requiring that some of the rooms have to be kept empty .",
    "moreover , we seek plans of different length .",
    "figure  [ gasdiffusionexp ] ( on the right ) summarizes the results obtained .",
    "in particular , all instances share the same initial state : rooms 10 and 3 contain 128 moles of gas .",
    "all the other rooms are empty .",
    "moreover ,    * in the instance a@xmath559 the goal state is : room 1 contains at least 32 moles of gas ; * in all the instances b@xmath560 the goal is : room 1 contains at least 50 moles of gas .",
    "the b@xmath560 instances differ in the constraints imposed on the desired plan : * * in the instance b@xmath559 , rooms 7 , 9 , and 4 must remain empty .",
    "this condition can be imposed by including in the action description the constraints +   +   + * * in the instance b@xmath561 , rooms 7 , 8 , and 5 must be kept empty . * * in the instance b@xmath562 , only room 6 must be kept empty . * * in the instance b@xmath563 , no constraint is imposed .",
    "observe that it is quite natural to design a  encoding of this problem , by exploiting the multi - valued fluents . on the other hand , adopting the naive approach used for",
    "the three - barrel problem would force the introduction of ( at least ) 128 distinct boolean fluents for each multi - valued fluent .",
    "such a large number of boolean fluents generates a large state space , making the task of any solver for @xmath1 considerably harder .",
    "we report results from two other planning problems .",
    "the first3x3-puzzle  is an encoding of the 8-tile puzzle problem , where the goal is to find a sequence of moves to re - order the 8 tiles , starting from a random initial position .",
    "the performance results for this puzzle are reported in table  [ tabellapuzzle ] .",
    "the second problem is the well - known _ wolf - goat - cabbage _ problem .",
    "the performance results are reported in table  [ tabellawgc ] .",
    "notice that these planning problems are predominantly boolean .",
    "the constraint - based encodings perform well in solving the instances of the wolf - goat - cabbage problem .",
    "in contrast , for the 8-tile puzzle problem , the use of numerical fluents allows us to achieve a compact encoding , but it does not necessarily lead to a better performance w.r.t .",
    "asp .",
    "90(5,10)instance    &    90(5,10)length    &    90(5,10)answer    & & & & & & & + & & & & & zchaff & relsat & minisat & & & & + i@xmath559 & 9 & n & 41.49 & 0.94 & 2.06 & 3.36 & 1.54 & 0.52 & 0.52 & 0.64 + 4.42 & 0.25 + 2.64 + i@xmath559 & 10 & y & 41.80 & 2.02 & 2.52 & 7.36 & 2.06 & 0.70 & 0.70 & 0.73 + 5.43 & 0.29 + 3.64 + i@xmath561 & 14 & n & 42.68 & 27.10 & 34.46 & 90.07 & 7.15 & 7.42 & 7.15 & 1.03 + 57.54 & 0.40 + 38.67 + i@xmath561 & 15 & y & 43.14 & 50.73 & 49.50 & 131.38 & 8.90 & 1.98 & 1.98 & 1.06 + 7.08 & 0.43 + 4.60 + i@xmath562 & 19 & n & 43.76 & 739.39 & 1255.46 & 911.82 & 91.75 & 268.69 & 91.75 & 1.39 + 967.26 & 0.54 + 673.66 + i@xmath562 & 20 & y & 44.52 & 368.28 & 1090.66 & 1445.78 & 58.89 & 268.59 & 58.89 & 1.46 + 597.92 & 0.52 + 435.96 + i@xmath563 & 24 & n & 51.59 & 10247.47 &  & 5613.98 & 7862.10 & 4185.42 & 4185.42&1.70 + 13887.17 & 0.71 + 10109.58 + i@xmath563 & 25 & y & 55.54 & 1430.43 & 954.68 & 1023.22 & 437.11 & 875.16 & 437.11 & 1.84 + 79.20 & 0.73 + 57.00 + i@xmath564 & 24 & n & 49.64 & 6936.39 &  & 6041.87 & 1239.72 & 4901.13 & 1239.72&1.69 + 11092.48 & 0.73 + 9155.79 + i@xmath564 & 25 & n & 51.07 & 14079.78 & 3747.96 & 8583.44 & 11745.93 & 8557.94 & 3747.96&1.84 + 18301.15 & 0.73 + 14195.54 +        90(5,10)length    &    90(5,10)answer    & & & & & & & + & & & & zchaff&relsat&minisat & & & & + 21 & n & 0.10 & 0.19 & 1.38 & 1.89 & 0.67 & 0.19 & 0.19 & 0.10 + 0.20 & 0.09 + 0.15 + 22 & n & 0.10 & 0.25 & 1.46 & 3.32 & 0.77 & 0.56 & 0.25 & 0.09 + 0.21 & 0.11 + 0.17 + 23 & y & 0.10 & 0.26 & 2.30 & 4.34 & 0.58 & 0.13 & 0.13 & 0.12 + 0.17 & 0.07 + 0.15 + 24 & n & 0.11 & 0.43 & 3.10 & 4.75 & 0.67 & 1.09 & 0.43 & 0.07 + 0.32 & 0.06 + 0.25 + 25 & y & 0.12 & 0.27 & 1.15 & 4.92 & 0.74 & 0.42 & 0.27 & 0.12 + 0.06 & 0.08 + 0.08 + 26 & n & 0.12 & 0.68 & 7.23 & 11.52 & 1.18 & 0.69 & 0.68 & 0.10 + 0.49 & 0.10 + 0.40 + 27 & y & 0.13 & 0.43 & 1.93 & 6.68 & 0.93 & 0.84 & 0.43 & 0.10 + 0.03 & 0.06 + 0.03 + 28 & n & 0.14 & 1.24 & 9.44 & 18.72 & 1.59 & 2.15 & 1.24 & 0.10 + 0.80 & 0.08 + 0.69 + 29 & y & 0.14 & 0.41 & 1.75 & 15.55 & 1.10 & 0.60 & 0.41 & 0.11 + 0.01 & 0.07 + 0.03 + 30 & n & 0.15 & 2.97 & 16.17 & 43.53 & 2.31 & 1.78 & 1.78 & 0.11 + 1.08 & 0.08 + 1.05 + 31 & y & 0.15 & 0.49 & 8.40 & 7.10 & 0.89 & 4.60 & 0.49 & 0.12 + 0.01 & 0.11 + 0.04 + 32 & n & 0.16 & 2.78 & 23.76 & 38.58 & 2.20 & 5.37 & 2.20 & 0.13 + 1.35 & 0.09 + 1.32 + 33 & y & 0.16 & 1.06 & 31.92 & 26.67 & 1.23 & 0.57 & 0.57 & 0.10 + 0.07 & 0.14 + 0.06 + 34 & n & 0.17 & 3.61 & 38.62 & 51.22 & 3.11 & 5.86 & 3.11 & 0.13 + 1.75 & 0.10 + 1.60 + 35 & y & 0.18 & 1.39 & 31.10 & 30.25 & 3.20 & 4.21 & 1.39 & 0.15 + 0.54 & 0.08 + 0.32 + 36 & n & 0.18 & 4.55 & 43.97 & 57.21 & 4.24 & 12.68 & 4.24 & 0.13 + 1.87 & 0.11 + 1.79 +      table  [ pallogramma ] pictorially summarizes some of the results relating the performance of the different approaches . for each problem instance",
    ", we compare the execution times obtained by the best asp - solver and the clp(fd ) solvers for @xmath1 and  action description languages .",
    "we considered only those instances for which at least one of the solvers gave an answer .",
    "a score of @xmath9 ( @xmath10 , @xmath565 ) is assigned to the fastest ( second fastest , slowest ) solver .",
    "the scores of all instances of a problem have been summed together , and this provides the radius of the circles in the figure .",
    "instances have been separated between _",
    "`` yes '' _ instances ( they admit a solution ) and _ `` no '' _ instances ( they have no solutions ) .",
    "the success of the constraint - based approach is evident .",
    "however , it is interesting to observe that the planning problems that do not make significant use of non - boolean fluents tend to perform better in the asp - based implementations  possibly due to the greater efficiency of asp solvers in propagating boolean knowledge during search for a solution .",
    "conversely , when numerical quantities are relevant in modeling a planning problem , the use of multi - valued fluents and constraints not only reduces the modeling effort , yielding more concise formalizations , but also requires a smaller number of fluents ( compared with the analogous boolean encoding ) .",
    "this , combined with the use of constraints , often translates into a smaller state space to be explored in finding a solution .",
    "these seem to be the main reasons for the better behavior provided by the  approach .    the distinction between _",
    "`` yes '' _ and _ `` no '' _ instances is also very relevant .",
    "the clp - based solvers tend to perform better on the _ `` yes '' _ instances , especially for large instances .",
    "it is interesting to observe that a similar behavior has been observed in recent studies comparing performance of asp and clp solutions to combinatorial problems  @xcite .",
    "the literature on planning and planning domain description languages is extensive , and it would be impossible to summarize it all in this context .",
    "we focus our discussion and comparison to the papers that present languages and techniques similar to ours .",
    "the language investigated in this work is a variant of the language @xmath1 originally introduced in  @xcite , as presented in  ( * ? ? ?",
    "* sect .  2 ) .",
    "apart from minor syntactical differences , any action description @xmath15 from the language of  @xcite can be embedded in our  @xmath1 .",
    "the semantics for @xmath1 presented here reproduces the one of  @xcite .    the language @xmath3 has been introduced in @xcite to model planning problems in presence of actions with duration and delayed effects .",
    "the language relies on multi - valued fluents , akin to those used in our language .",
    "have two types of effects :    1 .   direct modification of fluent values , described by dynamic causal laws of the forms @xmath566 the first axiom describes the value of the fluent @xmath11 as a function , that modifies its value over the period of time from @xmath527 to @xmath528these represent time units relative to the current point in time .",
    "the second axiom is similar , except that it denotes the quantity that should be added to the value of @xmath11 over the period of time .",
    "these axioms are important when describing actions whose effect has a known duration over time ( i.e. , the interval of length @xmath567 ) .",
    "2 .   indirect modifications through the initiation and termination of _ processes _ , that can modify fluents until explicitly stopped",
    "; the axioms involved are axioms for the creation and termination of processes : @xmath568 and axioms that describe how processes modify fluents @xmath569 the first axiom describes how the value of the fluent @xmath11 will change as a function of time once a process is started ; the second axiom determines how the value of @xmath11 changes while the process @xmath570 is active .",
    "@xmath3 has some similarities to ; they both allow multi - valued fluents and some forms of temporal references .",
    "has the flexibility of allowing non - markovian behavior and it allows references to values of fluents at different time points , features that are missing in @xmath3 . on the other hand , @xmath3 allows the representation of continuous time and the ability to describe continuous changes to the value of fluents .",
    "several features of @xmath3 can be reasonably simulated in ; we will focus on the axioms of type ( [ eq3])([eq6 ] ) , since these subsume the capabilities of axioms ( [ eq1 ] ) and ( [ eq2 ] ) :    * we can represent each process @xmath570 using a corresponding fluent ; * the axioms ( [ eq3 ] ) and ( [ eq4 ] ) can be simulated by @xmath571 * the axiom ( [ eq5 ] ) can be simulated by introducing the static causal law @xmath572    note that , due to the inability of  to handle continuous time , we are considering only discrete time measures .",
    "the language @xmath573 proposed in @xcite also has some similarities to the language .",
    "@xmath573 does not offer capabilities for non - markovian and temporal references , but supports multi - valued fluents .",
    "the syntax of @xmath573 builds on a language of fluent constants ( each with an associated domain ) and action names ( viewed as boolean variables ) :    * static causal laws @xmath574 where @xmath575 and @xmath576 are fluent formulae ( i.e. , propositional combinations of atoms of the form @xmath577 for @xmath11 fluent and @xmath578 ) .",
    "the language introduces syntactic restrictions that are effectively equivalent to preventing cyclic dependencies among fluents .",
    "static causal laws describe dependencies between fluents within a state of the world . *",
    "fluent dynamic laws @xmath579 where @xmath575 and @xmath576 are fluent formulae and @xmath580 is a formula that may also contain action variables .",
    "the semantics of dynamic laws can be summarized as follows : if @xmath580 holds in a state , then the implication @xmath581 should hold in the successive state . * actions that can be freely generated are declared to be exogenous @xmath582 * fluents can be declared to be inertial ( i.e. , they satisfy the frame axiom ) @xmath583    the relationships between the two languages can be summarized as follows :    * @xmath573 is restricted to non - cyclic dependencies among fluents , while  lifts this restriction . *",
    "@xmath573 is capable of identifying fluents as inertial or non - inertial , while  focuses only on inertial fluents ( though it is relatively simple to introduce an additional type of constraint to create non - inertial fluents ) .",
    "* @xmath573 can describe domains where concurrent actions are allowed  by allowing occurrences of different action variables in the @xmath580 component of the fluent dynamic laws ; although  does not currently supports this feature , a similar extension has been investigated in a recent paper  @xcite .",
    "subsets of  and @xmath573 can be shown to have the same expressive power ; in particular , let us consider the subset of @xmath573 that contains only domains that meet the following requirements :    * there are no concurrent actions  i.e .",
    ", each @xmath580 contains exactly one occurrence of an action variable ; thus @xmath584 where @xmath580 is a fluent formula ; * for each action @xmath17 , there is a declaration @xmath585    under these restrictions , it is possible to map a @xmath573 domain @xmath273 to an equivalent domain in . in particular :    * for each non - inertial fluent @xmath11 , with default value @xmath99 , we introduce the static law @xmath586 * for each static causal law * caused * @xmath575 * if * @xmath576 we introduce a causal law @xmath587 * for each fluent dynamic law @xmath588 of the form @xmath589 , we introduce the following axioms ( where @xmath590 is a fresh fluent ) : @xmath591    logic programming , and more specifically prolog , has been also used to implement the first prototype of golog ( as discussed in @xcite ) .",
    "golog is a programming language for describing agents and their capabilities of changing the state of the world .",
    "the language builds on the foundations of situation calculus .",
    "it provides high level constructs for the definition of complex actions and for the introduction of control knowledge in the agent specification .",
    "prolog is employed to create an interpreter , which enables , for example , to answer projection queries ( i.e. , determine the properties that hold in a situation after the execution of a sequence of actions ) .",
    "the goals of golog and the use of logic programming in that work are radically different from the focus of our work .",
    "the work by  @xcite takes a different perspective in using constraint programming to handle problems in reasoning about actions and change .",
    "thielscher s work builds on the use of fluent calculus  @xcite for the representation of actions and their effects .",
    "fluent calculus views states as sets of fluents , constructed using an operator @xmath592 , and with the ability to encode partially specified sets ( e.g. , @xmath593 where @xmath594 represents the `` rest '' of the state ) . in  @xcite ,",
    "an encoding of the fluent calculus axioms using constraint handling rules ( chrs ) is presented ; the encoding uses _ lists _ to represent states , and it employs chrs to explicitly implement the operations on lists required to operate on states  e.g . , truth or falsity of a fluent , validation of disjunctions of fluents . the ability to code open lists enables reasoning with incomplete knowledge .",
    "experimental results ( reported in  @xcite ) denote a good performance with respect to golog .",
    "the framework is very suitable for dealing with incomplete knowledge and sensing actions . differently from our framework",
    ", it does not support non - markovian reasoning , multi - valued reasoning , and it does not bring the expressiveness of constraint programming to the level of the action specification language .",
    "the use of constraints in the two approaches is radically different ",
    "thielscher s work develops new constraint solvers to implement reasoning about states , while we use existing solvers as black boxes .",
    "a strong piece of work regarding the use of constraint programming in planning is  @xcite .",
    "the authors use constraint programming , based on the claire language  @xcite , to encode temporal planning problems and to search for minimal plans .",
    "they also use a series of interesting heuristics for solving that problem .",
    "this line of research is more accurate than ours from the implementation point of view ",
    "although their heuristic strategies can be implemented in our system and it would be interesting to exploit them during the labeling phase .",
    "on the other hand , the proposal by vidal and geffner only deals with boolean fluents and without explicitly defined static causal laws .",
    "similar considerations can be done with respect to the cited proposal by lopez and bacchus  @xcite .",
    "the authors start from graphplan and exploit constraints to encode problems .",
    "fluents are in this case only boolean ( not multi - valued ) and the process is deterministic once an action is chosen ( instead , we deal also with non - determinism , e.g. , when we have consequences such as @xmath595 ) .",
    "the proposal of lopez and bacchus does not address the encoding of static causal laws .",
    "in this paper , we investigated the application of constraint logic programming technology to the problem of reasoning about actions and change and planning .",
    "in particular , we presented a modeling of the action language @xmath1 using constraints , developed an implementation using clp(fd ) , and reported on its performance .",
    "we also presented the action language , which allows the use of multi - valued fluents and the use of constraints as conditions and consequences of actions .",
    "once again , the use of constraints is instrumental in making these extensions possible .",
    "we illustrated the application of both @xmath1 and  to several planning problems .",
    "both languages have been implemented using sicstus prolog .",
    "we consider the research and the results discussed in this paper as a preliminary step in a very promising direction .",
    "the experimental results , as well as the elegance of the encodings of complex problems , shows the promise of constraint - based technology to address the needs of complex planning domains .",
    "a number of research directions are currently being pursued :    * we have introduced the use of global constraints to encode different forms of preferences ( e.g. , action costs ) and control knowledge .",
    "global constraints have been widely used in constraint programming to enhance efficiency , by providing more effective constraint propagations between sets of variables ; we believe a similar use of global constraints can be introduced in the context of planning  e.g . , the use of techniques used to efficiently handle the global constraint to enforce non - repetition of states in a trajectory .",
    "* we also believe that significant improvements in efficiency can be achieved by delegating parts of the constraint solving process to an efficient dedicated solver ( e.g. , encoded using a constraint platform such as gecode , possibly enhanced with local search moves ) . * the encoding in clp(fd )",
    "allow us to think of extensions in several directions , such as the encoding of qualitative and quantitative preferences ( a preliminary study has been presented in  @xcite ) , and the use of constraints to represent incomplete states  e.g .",
    ", to determine most general conditions for the existence of a plan and to support conformant planning  @xcite .",
    "* an interesting line of research is represented by the application of the approach discussed here to multi - agent systems . in that case , besides admitting the execution of more that one action in each state transition ( cf .",
    ", remark  [ sequentiality ] ) , other important issues have to be addressed , since different agents may compete or collaborate in order to reach the desired results .",
    "for instance , concurrency of actions may be subject to constraints to model incompatibilities or interdependencies among the occurrences / effects of different actions executed by different agents ( even in different points in time ) .",
    "hence , the action description language , as well as its clp encoding , has to be suitably enriched in order to deal with these aspects .",
    "a first step in this direction has been presented in  @xcite .",
    "the authors would like to thank the following researchers for their help , comments , and suggestions : son cao tran , michael gelfond , and the anonymous reviewers of iclp 2007 and tplp .",
    "the research has been partially supported by nsf grants iis-0812267 , hrd-0420407 , and cns-0220590 , by the firb grant rbne03b8kk , and by gncs_gruppo nazionale per il calcolo scientifico _",
    "( project _ tecniche innovative per la programmazione con vincoli in applicazioni strategiche _ ) .",
    "cambridge university press .",
    "cambridge university press .",
    "a transition function based characterization of actions with delayed and continuous effects . _ principles and practice of knowledge representation and reasoning _ , morgan kaufmann , pp . 291302 , 2002 .",
    "claire : combining sets , search and rules to better express algorithms . _ theory and practice of logic programming _ , 2(6):769805 , 2002 .    , formisano , a. , and pontelli , e. 2005 . .",
    "in _ proc . of iclp 2008 _ , m.  gabbrielli and g.  gupta , eds .",
    "lecture notes in computer science , vol . 3668 .",
    "springer verlag , 6782 .    ,",
    "formisano , a. , and pontelli , e. 2007 .",
    "an experimental comparison of constraint logic programming and answer set programming . in _ proceedings of the twenty - second aaai conference on artificial intelligence_.",
    "aaai press , vancouver , british columbia , canada , 16221625 .    ,",
    "formisano , a. , and pontelli , e. 2009a .",
    "an empirical study of clp and asp solutions of combinatorial problems .  _ 21 ,",
    "_  2 ( jun .",
    ") , 79121 .    ,",
    "formisano , a. , and pontelli , e. 2009b .",
    "representing multi - agent planning in clp . in _ logic programming and non - monotonic reasoning , 10th international conference , lpnmr 2009 , potsdam , germany , september 14 - 18 , 2009 ,",
    "proceedings _ , e.  erdem , f.  lin , and t.  schaub , eds .",
    "lecture notes in computer science , vol . 5753 .",
    "springer , 423429 .    ,",
    "faber , w. , leone , n. , pfeifer , g. , and polleres , a. 2004 . a logic programming approach to knowledge - state planning : semantics and complexity .",
    "_ 5 , _  2 ( apr . ) , 206263 .",
    "non - markovian control in the situation calculus . in _ proceedings of the eighteenth national conference on artificial intelligence _ , r.  dechter , m.  kearns , and r.  s. sutton , eds .",
    "american association for artificial intelligence , aaai press , menlo park , california , 519524 .",
    ", kaufmann , b. , neumann , a. , and schaub , t. 2007 . _ clasp : _ a conflict - driven answer set solver . in _ logic programming and non - monotonic reasoning _ , c.  baral , g.  brewka , and j.  s. schlipf , eds .",
    ", springer verlag , 260265 .",
    "action languages .",
    "_ 2 _ , 193210 .    ,",
    "lee , j. , lifschitz , v. , mccain , n. , and turner , h. 2004 .",
    "non - monotonic causal theories .",
    "_ artificial intelligence _",
    "_ 153 , _  ( 12 ) , 49104 .    ,",
    "lierler , y. , and maratea , m. 2004 .",
    "-based answer set programming . in _",
    "aaai-04 _ ,",
    "d.  l. mcguinness and g.  ferguson , eds . the mit press , 6166 .    ,",
    "porteous , j. , and sebastia , l. 2004 . ordered landmarks in planning .",
    "_ journal of artificial intelligence research _ , 22:215278 .",
    "andmaher , m. 1994 . constraint logic programming : a survey . , 19/20:503581 .",
    "\\2003 . describing additive fluents in action language c+ . in _",
    "ijcai-03 , proceedings of the eighteenth international joint conference on artificial intelligence , acapulco , mexico , august 9 - 15 , 2003 _ , g.  gottlob and t.  walsh , eds .",
    "morgan kaufmann , 10791084 .    ,",
    "pirri , f. , and reiter , r. 1997 . : a logic programming language for dynamic domains .",
    ", 31(13):5983 .    , pirri , f. , and reiter , r. 1998 .",
    "foundations for the situation calculus .",
    "_ 2 _ , 159178 .",
    "answer set planning .",
    "in _ proc .  of the 16th intl .",
    "conference on logic programming _",
    ", d.  de  schreye , ed . mit press , 2337 .    \\2004 .",
    ": computing answer sets of a logic program by sat solvers .",
    "_ 157 , _  12 , 115137 .",
    "generalizing graphplan by formulating planning as a csp . in _",
    "ijcai-03 , proceedings of the eighteenth international joint conference on artificial intelligence , acapulco , mexico , august 9 - 15 , 2003 _ , g.  gottlob and t.  walsh , eds .",
    "morgan kaufmann , 954960 .",
    "the mit press .",
    "elephant 2000 - a programming language based on speech acts .",
    "available in www.formal.stanford.edu/jmc .",
    "ress , bradford books , cambridge , ma .",
    "\\2000 . extending and implementing the stable model semantics .",
    "thesis , helsinki university of technology .",
    ", baral , c. , and mcilraith , s.  a. 2001 .",
    "planning with different forms of domain - dependent control knowledge - an answer set programming approach .",
    "in _ logic programming and non - monotonic reasoning , 6th international conference , lpnmr 2001 , vienna , austria , september 17 - 19 , 2001 , proceedings _",
    ", t.  eiter , w.  faber , and m.  truszczyski , eds .",
    "lecture notes in computer science , vol . 2173 .",
    "springer , 226239 .",
    ", tu , p.  h. , and baral , c. 2007 .",
    "reasoning and planning with sensing actions , incomplete information , and static causal laws using answer set programming .",
    "_ 7 , _  4 , 377450 .",
    "\\1999 . from situation calculus",
    "to fluent calculus : state update axioms as a solution to the inferential frame problem . in _ artificial intelligence _",
    ".    2002a .",
    "reasoning about actions with chrs and finite domain constraints .",
    "_ 2401 _ , 7084",
    ".    2002b . pushing the envelope : programming reasoning agents . in",
    "_ aaai workshop on cognitive robotics _ , aaai press .    , son ,",
    "t.  c. , and pontelli , e. 2007 . : a constraint logic programming based planner with preferences . in _ logic programming and non - monotonic reasoning , 9th international conference , lpnmr 2007 , tempe , az , usa , may 15 - 17 , 2007 , proceedings _ , c.  baral , g.  brewka , and j.  s. schlipf , eds .",
    "lecture notes in computer science , vol . 4483 .",
    "springer , 290296 .    , and geffner , g. 2006 .",
    "branching and pruning : an optimal temporal pocl planner based in constraint programming .",
    "0 barrel(5 ) . + barrel(7 ) .",
    "+ barrel(12 ) .",
    "+   + fluent(cont(b),0,b ) : - barrel(b ) .",
    "+   + action(fill(x , y ) ) : - barrel(x ) , barrel(y ) , neq(x , y ) .",
    "+   + causes(fill(x , y ) , cont(x ) eq 0 , [ y - cont(y ) geq cont(x ) ] ) : - + action(fill(x , y ) ) .",
    "+ causes(fill(x , y ) , cont(y ) eq cont(y)^(-1)+cont(x)^(-1 ) , + [ y - cont(y ) geq cont(x ) ] ) : - + action(fill(x , y ) ) .",
    "+ causes(fill(x , y ) , cont(y ) eq y , [ y - cont(y ) lt cont(x ) ] ) : - + action(fill(x , y ) ) .",
    "+ causes(fill(x , y ) , cont(x ) eq cont(x)^(-1)-y+cont(y)^(-1 ) , + [ y - cont(y ) lt cont(x ) ] ) : - + action(fill(x , y ) ) .",
    "+   + executable(fill(x , y ) , [ cont(x ) gt 0 , cont(y ) lt y ] ) : - + action(fill(x , y ) ) .",
    "+   + caused ( [ ] , cont(12 ) eq 12-cont(5)-cont(7 ) ) .",
    "+   + initially(cont(12 ) eq 12 ) .",
    "+   + goal(cont(12 ) eq cont(7 ) ) .        0 length(10 ) .",
    "+ amino(a ) : - length(n ) , interval(a,1,n ) .",
    "+ direction(clock ) .",
    "+ direction(antick ) .",
    "+   + fluent(x(a),1,m ) : - + length(n ) , m is 2*n , amino(a ) .",
    "+ fluent(y(a),1,m ) : - + length(n ) , m is 2*n ,",
    "amino(a ) .",
    "+ fluent(type(a),0,1 ) : - + amino(a ) .",
    "+ fluent(saw,0,1 ) .",
    "+   + action(pivot(a , d ) ) : - + length(n ) , amino(a ) , + 1<a , a < n , direction(d ) .",
    "+   + executable(pivot(a , d ) , [ ] ) : - action(pivot(a , d ) ) .",
    "+   + causes(pivot(a , clock ) , x(b ) eq x(a)^(-1)+y(b)^(-1)-y(a)^(-1 ) , [ ] ) : - + action(pivot(a , clock ) ) , amino(b ) , b > a. + causes(pivot(a , clock ) , y(b ) eq y(a)^(-1)+x(a)^(-1)-x(b)^(-1 ) , [ ] ) : - + action(pivot(a , clock ) ) , amino(b ) , b > a. + causes(pivot(a , antick ) , x(b ) eq x(a)^(-1)-y(b)^(-1)+y(a)^(-1 ) , [ ] ) : - + action(pivot(a , antick ) ) , amino(b ) , b > a. + causes(pivot(a , antick ) , y(b ) eq y(a)^(-1)-x(a)^(-1)+x(b)^(-1 ) , [ ] ) : - + action(pivot(a , antick ) ) , amino(b ) , b > a. +   + caused([x(a ) eq x(b ) , y(a ) eq y(b ) ] , saw eq 0 ) : - + amino(a ) , amino(b ) , a < b. +   + initially(saw eq 1 ) .",
    "+ initially(x(a ) eq",
    "n ) : - length(n ) , amino(a ) .",
    "+ initially(y(a ) eq y ) : - length(n ) , amino(a ) , y is n+a-1",
    ". + initially(type(x ) eq 1 ) : - amino(x ) , x mod 3 = : = 1 .",
    "+ initially(type(x ) eq 0 ) : - amino(x ) , x mod 3 = @xmath596= 1 .",
    "+   + goal(saw gt 0 ) .",
    "+   + state_cost(fe ) : - length(n ) , auxc(1,4,n , fe ) .",
    "+ auxc(i , j , n,0 ) : - i >",
    "n-3,!. + auxc(i , j , n , fe ) : - j > n , ! , i1 is i+1 , + j1 is i1 + 3 , auxc(i1,j1,n , fe ) .",
    "+ auxc(i , j ,",
    "n , fe1+type(i)*type(j)*rei(abs(x(i)-x(j))+abs(y(i)-y(j ) ) eq 1 ) ) : - + j1 is j+2 , auxc(i , j1,n , fe1 ) .",
    "+   + always(x(1 ) eq 10 ) .",
    "always(y(1 ) eq 10 ) .",
    "+ always(x(2 ) eq 10 ) .",
    "always(y(2 ) eq 11 ) .",
    "+   + cost_constraint(goal geq 4 ) .        0 max_people(4 ) .",
    "+ person(x ) : - max_people(n ) , interval(x,1,n ) .",
    "+ money(x ) : - max_people(n ) , m is n*(n+1 ) , interval(x,1,m ) .",
    "+   + fluent(owns(b , m ) ) : - person(b ) , money(m ) .",
    "+   + action(gives(x , y ) ) : - + person(x ) , person(y ) , neq(x , y ) .",
    "+   + executable(gives(x , y ) , [ owns(x , mx ) ] ) : - + action(gives(x , y ) ) , + fluent(owns(x , mx ) ) , mx > x. +   + causes(gives(x , y ) , owns(x , newmx ) , [ owns(x , mx ) ] ) : - + action(gives(x , y ) ) , money(mx ) , + fluent(owns(x , newmx ) ) , fluent(owns(x , mx ) ) , + newmx is mx - x .",
    "+ causes(gives(x , y ) , owns(y , newmy ) , [ owns(y , my ) ] ) : - + action(gives(x , y ) ) , money(my ) , + fluent(owns(y , newmy ) ) , fluent(owns(y , my ) ) , + newmy is my+x .",
    "+   + caused([owns(x , mx ) ] , neg(owns(x , other ) ) ) : - + fluent(owns(x , mx ) ) , fluent(owns(x , other ) ) , + person(x ) , money(mx ) , money(other ) , neq(mx , other ) .",
    "+   + initially(owns(x , m ) ) : - + person(x ) , m is 2*x .",
    "+   + goal(owns(x , mid ) ) : - + person(x ) , max_people(n ) , mid is ( n*(n+1))//n",
    ".      0 max_people(4 ) .",
    "+ person(x ) : - max_people(n ) , interval(x,1,n ) .",
    "+   + fluent(owns(b),1,m ) : - + person(b ) , max_people(n ) , m is n*(n+1 ) .",
    "+   + action(gives(x , y ) ) : - + person(x ) , person(y ) , neq(x , y )",
    ". +   + executable(gives(x , y ) , [ owns(x ) gt x ] ) : - + action(gives(x , y ) ) .",
    "+   + causes(gives(x , y ) , owns(x ) eq owns(x)^(-1)-x , [ ] ) : - + action(gives(x , y ) ) .",
    "+ causes(gives(x , y ) , owns(y ) eq owns(y)^(-1)+x , [ ] ) : - + action(gives(x , y ) ) .",
    "+   + initially(owns(x ) eq m ) : - + person(x ) , m is 2*x .",
    "+   + goal(owns(x ) eq mid ) : - + person(x ) , max_people(n ) , mid is ( n*(n+1))//n .        0 cell(x ) : - interval(x,1,9 ) .",
    "+ val(x ) : - interval(x,1,9 ) , neq(x,3 ) .",
    "+ near(1,2 ) .",
    "near(1,4 ) .",
    "+ near(2,1 )",
    ".  near(2,3 ) .",
    "near(2,5 ) .",
    "+ near(3,2 ) .",
    "near(3,6 ) .",
    "+ near(4,1 ) .",
    "near(4,5 ) .",
    "near(4,7 ) . + near(5,2 ) .",
    "near(5,4 ) .",
    "near(5,6 ) .  near(5,8 ) .",
    "+ near(6,3 ) .",
    "near(6,5 ) .",
    "near(6,9 ) .",
    "+ near(7,4 ) .",
    "near(7,8 ) .",
    "+ near(8,5 ) .",
    "near(8,7 ) .",
    "near(8,9 ) .",
    "+ near(9,6 ) .",
    "near(9,8 ) .",
    "+   + fluent(at(x , y ) ) : - val(x ) , cell(y ) .",
    "+ fluent(free(y ) ) : - cell(y ) .",
    "+   + action(move(x , y ) ) : - val(x ) , cell(y ) .",
    "+   + executable(move(x , y ) , [ at(x , z ) , free(y ) ] ) : - + val(x ) , cell(y ) , cell(z ) , near(z , y ) .",
    "+   + causes(move(x , y ) , at(x , y ) , [ ] ) : - + val(x ) , cell(y ) .",
    "+ causes(move(x , y ) , free(z ) , [ at(x , z ) ] ) : - + val(x ) , cell(y ) , cell(z ) .",
    "+ caused([at(x , y ) ] , neg(free(y ) ) ) : - + val(x ) , cell(y ) .",
    "+   + caused([at(x , y ) ] , neg(at(x , z ) ) ) : - + val(x ) , cell(y ) , cell(z ) , neq(y , z ) .",
    "+ caused([at(x , y ) ] , neg(at(w , y ) ) ) : - + val(x ) , val(w ) , cell(y ) , neq(x , w ) .",
    "+   + initially(at(1,1 ) ) .",
    "initially(at(2,3 ) ) .",
    "initially(at(4,8 ) ) .",
    "+ initially(at(5,2 ) ) .",
    "initially(at(6,9 ) ) .",
    "initially(at(7,4 ) ) .",
    "+ initially(at(8,6 ) ) .",
    "initially(at(9,7 ) ) .",
    "initially(free(5 ) ) .",
    "+ initially(neg(at(1,x ) ) ) : - cell(x ) , neq(x,1 ) .",
    "+ initially(neg(at(2,x ) ) ) : - cell(x ) , neq(x,3 ) .",
    "+ initially(neg(at(4,x ) ) ) : - cell(x ) , neq(x,8 ) .",
    "+ initially(neg(at(5,x ) ) ) : - cell(x ) , neq(x,2 ) .",
    "+ initially(neg(at(6,x ) ) ) : - cell(x ) , neq(x,9 ) .",
    "+ initially(neg(at(7,x ) ) ) : - cell(x ) , neq(x,4 ) .",
    "+ initially(neg(at(8,x ) ) ) : - cell(x ) , neq(x,6 ) .",
    "+ initially(neg(at(9,x ) ) ) : - cell(x ) , neq(x,7 ) .",
    "+ initially(neg(free(x ) ) ) : - cell(x ) , neq(x,5 ) .",
    "+   + goal(at(x , x ) ) : - val(x ) .",
    "+ goal(free(3 ) ) .",
    "+      0 cell(x ) : - interval(x,1,9 ) .",
    "+ tile(x ) : - interval(x,1,9 ) , neq(x,3 ) .",
    "+ near(1,2 ) .",
    "near(1,4 ) .",
    "+ ... % as for @xmath1 ... + near(9,6 ) .",
    "near(9,8 ) .",
    "+ fluent(at(x),1,9 ) : - tile(x ) .",
    "+ fluent(free,1,9 ) .",
    "+   + action(move(x , y ) ) : - cell(y ) , tile(x ) .",
    "+   + executable(move(x , y ) , [ at(x ) eq z , free eq y ] ) : - + tile(x ) , cell(y ) , near(z , y ) .",
    "+ causes(move(x , y ) , at(x ) eq y , [ ] ) : - + tile(x ) , cell(y ) .",
    "+ causes(move(x , y ) , free eq at(x)^(-1 ) , [ ] ) : - + tile(x ) , cell(y ) .",
    "+   + initially(at(1 ) eq 1 ) .",
    "initially(at(2 ) eq 3 ) .",
    "+ initially(at(4 ) eq 8) .",
    "initially(at(5 ) eq 2 ) .",
    "+ initially(at(6 ) eq 9 ) .",
    "initially(at(7 ) eq 4 ) .",
    "+ initially(at(8 ) eq 6 ) .",
    "initially(at(9 ) eq 7 ) .",
    "+ initially(free eq 5 ) .",
    "+ goal(at(x ) eq x ) : - tile(x ) .",
    "+ goal(free eq 3 ) .",
    "+        0 obj(goat ) .",
    "+ obj(cabbage ) .",
    "+ obj(wolf ) .",
    "+ obj(man ) .",
    "+ side(left ) .",
    "side(right ) .",
    "+ pos(x ) : - side(x ) .",
    "+ pos(boat ) .",
    "+   + fluent(is_in(x , y ) ) : - obj(x ) , pos(y ) .",
    "+ fluent(boat_at(y ) ) : - side(y ) .",
    "+ fluent(alive ) .",
    "+   + action(sail(a , b ) ) : - side(a ) , side(b ) , neq(a , b ) .",
    "+ action(go_aboard(a ) ) : - obj(a ) . + action(get_off(a ) ) : - obj(a ) .",
    "+   + executable(sail(a , b ) , [ boat_at(a ) , is_in(man , boat ) ] ) : - + side(a ) , side(b ) , neq(a , b ) .",
    "+ executable(go_aboard(a ) , [ boat_at(l ) , is_in(a , l ) ] ) : - + obj(a ) , side(l ) . + executable(get_off(a ) , [ is_in(a , boat ) ] ) : - + obj(a ) .",
    "+   + causes(sail(a , b ) , boat_at(b ) , [ ] ) : - + side(a ) , side(b ) , neq(a , b ) .",
    "+ causes(go_aboard(a ) , is_in(a , boat ) , [ ] ) : - + obj(a ) .",
    "+ causes(get_off(a ) , is_in(a , l ) , [ boat_at(l ) ] ) : - + obj(a ) , side(l ) .",
    "+   + caused([is_in(ogg , l1 ) ] , neg(is_in(ogg , l2 ) ) ) : - + obj(ogg ) , pos(l1 ) , pos(l2 ) , neq(l1,l2 ) .",
    "+ caused([boat_at(l1 ) ] , neg(boat_at(l2 ) ) ) : - + side(l1 ) , side(l2 ) , neq(l1,l2 ) .",
    "+ caused([is_in(a , boat ) , is_in(b , boat ) ] , neg(alive ) ) : - + obj(a ) , obj(b ) , diff(a , b , man ) .",
    "+ caused([is_in(wolf , l ) , is_in(goat , l ) , neg(is_in(man , l ) ) ] , neg(alive ) ) : - + pos(l ) .",
    "+ caused([is_in(cabbage , l ) , is_in(goat ,",
    "l ) , neg(is_in(man , l ) ) ] , neg(alive ) ) : - + pos(l ) .",
    "+   + initially(is_in(a , left ) ) : - obj(a ) .",
    "+ initially(alive ) .",
    "+ initially(boat_at(left ) ) .",
    "+   + goal(is_in(a , right ) ) : - obj(a ) .",
    "+ goal(alive ) .      0 obj(goat ) .",
    "+ obj(cabbage ) .",
    "+ obj(wolf ) .",
    "+ obj(man ) .",
    "+ % 0=boat , 1=on - the - left , 2=on - the - right : +   + fluent(is_in(x),0,2 ) : - obj(x ) .",
    "+ fluent(boat_at,1,2 ) .",
    "+ fluent(alive,0,1 ) .",
    "+   + action(sail ) .",
    "+ action(go_aboard(a ) ) : - obj(a ) . + action(get_off(a ) ) : - obj(a ) .",
    "+   + executable(sail , [ is_in(man ) eq 0 ] ) .",
    "+ executable(go_aboard(a ) , [ boat_at eq is_in(a ) ] ) : - + obj(a ) .",
    "+ executable(get_off(a ) , [ is_in(a ) eq 0 ] ) : - + obj(a ) .",
    "+   + causes(sail , boat_at eq 1 , [ boat_at eq 2 ] ) .",
    "+ causes(sail , boat_at eq 2 , [ boat_at eq 1 ] ) .",
    "+ causes(go_aboard(a ) , is_in(a ) eq 0 , [ ] ) : - + obj(a ) .",
    "+ causes(get_off(a ) , is_in(a ) eq boat_at^(-1 ) , [ ] ) : - + obj(a ) .",
    "+   + caused([is_in(a ) eq 0 , is_in(b ) eq 0 ] , alive eq 0 ) : - + obj(a ) , obj(b ) , diff(a , b , man ) .",
    "+ caused([is_in(wolf ) eq is_in(goat ) , + is_in(man ) neq is_in(wolf ) ] , alive eq 0 ) .",
    "+ caused([is_in(cabbage ) eq is_in(goat ) , + is_in(man ) neq is_in(cabbage ) ] , alive eq 0 ) .",
    "+   + initially(is_in(a ) eq 1 ) : - obj(a ) .",
    "+ initially(boat_at eq 1 ) .",
    "+ initially(alive eq 1 ) .",
    "+   + goal(is_in(a ) eq 2 ) : - obj(a ) .",
    "+ goal(alive eq 1 ) .",
    "0 room(n ) : - interval(n,1,11 ) .",
    "+ gate(1,2 ) .",
    "+ gate(1,7 ) .",
    "+ gate(1,11 ) .",
    "+ gate(2,3 ) .",
    "+ gate(3,4 ) .",
    "+ gate(4,5 ) .",
    "+ gate(5,6 ) .",
    "+ gate(6,7 ) .",
    "+ gate(6,8 ) .",
    "+ gate(8,9 ) .",
    "+ gate(9,10 ) .",
    "+ gate(10,11 ) .",
    "+   + fluent(contains(n),0,255 ) : - room(n ) .",
    "+ fluent(is_open(x , y),0,1 ) : - gate(x , y ) .",
    "+   + action(open(x , y ) ) : - gate(x , y ) .",
    "+ action(close(x , y ) ) : - gate(x , y ) .",
    "+   + executable(open(x , y),l ) : - + action(open(x , y ) ) , + findall((is_open(x , z ) eq 0 ) , gate(x , z),l1 ) , + findall((is_open(z , x ) eq 0 ) , gate(z , x),l2 ) , + findall((is_open(y , z ) eq 0 ) , ( gate(y , z),neq(z , x)),l3 ) , + findall((is_open(z , y ) eq 0 ) , ( gate(z , y),neq(z , x)),l4 ) , + append(l1,l2,la),append(l3,l4,lb),append(la , lb , l ) . + executable(close(x ,",
    "y ) , [ is_open(x , y ) eq 1 ] ) : - + action(close(x , y ) ) .",
    "+   + causes(open(x , y ) , + contains(y ) eq ( contains(x)^(-1)+contains(y)^(-1))/2 , + [ ] ) : - + action(open(x , y ) ) .",
    "+ causes(open(x , y ) , + contains(x ) eq ( contains(x)^(-1)+contains(y)^(-1))/2 , + [ ] ) : - + action(open(x , y ) ) .",
    "+ causes(open(x , y ) , is_open(x , y ) eq 1 , [ ] ) : - + action(open(x , y ) ) .",
    "+ causes(close(x , y ) , is_open(x , y ) eq 0 , [ ] ) : - + action(close(x , y ) ) .",
    "+   + initially(is_open(x , y ) eq 0 ) : - gate(x , y ) .",
    "+ initially(contains(10 ) eq 128 ) .",
    "+ initially(contains(3 ) eq 128 ) .",
    "+ initially(contains(a ) eq 0 ) : - room(a ) , diff(a,3,10 ) .",
    "+   + goal(contains(1 ) gt 50 ) ."
  ],
  "abstract_text": [
    "<S> action description languages , such as @xmath0 and @xmath1 @xcite , are expressive instruments introduced for formalizing planning domains and planning problem instances </S>",
    "<S> . the paper starts by proposing a methodology to encode an action language ( with conditional effects and static causal laws ) , a slight variation of @xmath1 , using _ </S>",
    "<S> constraint logic programming over finite domains_. the approach is then generalized to raise the use of constraints to the level of the action language itself . </S>",
    "<S> a prototype implementation has been developed , and the preliminary results are presented and discussed . </S>",
    "<S> + to appear in _ theory and practice of logic programming _ ( tplp ) .    </S>",
    "<S> action description languages , knowledge representation , planning , constraint logic programming </S>"
  ]
}