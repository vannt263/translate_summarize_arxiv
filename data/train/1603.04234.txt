{
  "article_text": [
    "a set of agents is deployed in a network represented by a weighted graph @xmath2 .",
    "an edge weight is a positive real representing the length of the edge , i.e. , the distance between its endpoints along the edge .",
    "the agents start simultaneously at different nodes of @xmath2 .",
    "every agent has a battery : a power source allowing it to move in a continuous way along the network edges .",
    "an agent may stop at any point of a network edge ( i.e. at any distance from the edge endpoints , up to the edge weight ) .",
    "the movements of an agent use its battery proportionally to the distance traveled .",
    "we assume that all agents move at the same speed that is equal to one , i.e. , we can interchange the notions of the distance traveled and the time spent while traveling . in the beginning , the agents start with the same amount of power noted @xmath3 , allowing all agents to travel the same distance @xmath3 .",
    "we consider two tasks : _ convergecast _ , in which at the beginning , each agent has some initial piece of information , and information of all agents has to be collected by some agent , not necessarily predetermined ; and _ broadcast _ in which information of one specified agent has to be made available to all other agents . in both tasks ,",
    "agents notice when they meet ( at a node or inside an edge ) and they exchange the currently held information at every meeting .    the task of convergecastis important , e.g. ,",
    "when agents have partial information about the topology of the network and the aggregate information can be used to construct a map of it , or when individual agents hold measurements performed by sensors located at their initial positions and collected information serves to make some global decision based on all measurements .",
    "the task of broadcastis used , e.g. , when a preselected leader has to share some information with others agents in order to organize their collaboration in future tasks .",
    "agents try to cooperate so that convergecast ( respectively broadcast ) is achieved with the smallest possible agent s initial battery power @xmath4 ( respectively @xmath5 ) , i.e. , minimizing the maximum distance traveled by an agent .",
    "we investigate these two problems in two possible settings , centralized and distributed .    in the centralized setting",
    ", the optimization problems must be solved by a central authority knowing the network and the initial positions of all the agents .",
    "we call _ _ a finite sequence of movements executed by the agents . during each movement ,",
    "starting at a specific time , an agent walks between two points belonging to the same network edge .",
    "a is a convergecast if the sequence of movements results in one agent getting the initial information of every agent .",
    "a is a broadcast if the sequence of movements results in all agents getting the initial information of the source agent .",
    "we consider two different versions of the problem : the decision problem , i.e. , deciding if there exists a convergecast or a broadcast using power @xmath3 ( where @xmath3 is the input of the problem ) and the optimization problem , i.e. , computing the smallest amount of power that is sufficient to achieve convergecastor broadcast .    in the distributed setting , the task of convergecastor broadcast must be approached individually by each agent .",
    "each agent is unaware of the network , of its position in the network and of the positions ( or even the presence ) of any other agents .",
    "the agents are anonymous and they execute the same deterministic algorithm .",
    "each agent has a very simple sensing device allowing it to detect the presence of other agents at its current location in the network .",
    "each agent is also aware of the degree of the node at which it is located , as well as the port through which it enters a node , called an _",
    "entry port_. we assume that the ports of a node of degree @xmath6 are represented by integers @xmath7 .",
    "agents can meet at a node or inside an edge .",
    "when two or more agents meet at a node , each of them is aware of the direction from which the other agent is coming , i.e. , the last entry port of each agent .    since the measure of efficiency in this paper is the battery power ( or the maximum distance traveled by an agent , which is proportional to the battery power used ) we do not try to optimize the other resources ( e.g. global execution time , local computation time , memory size of the agents , communication bandwidth , etc . ) . in particular , we conservatively suppose that , whenever two agents meet , they automatically exchange the entire information they hold ( rather than the new information only ) .",
    "this information exchange procedure is never explicitly mentioned in our algorithms , supposing , by default , that it always takes place when a meeting occurs .",
    "the efficiency of a distributed solution is expressed by the _ competitive ratio _ , which is the worst - case ratio of the amount of power necessary to solve the convergecast or the broadcast problem by the distributed algorithm with respect to the amount of power computed by the optimal centralized algorithm , which is executed for the same agents initial positions .",
    "it is easy to see , that in the optimal centralized solution for the case of the line and the tree , the original network may be truncated by removing some portions and leaving only the connected part of it containing all the agents ( this way all leaves of the remaining tree contain initial positions of agents ) .",
    "we make this assumption also in the distributed setting , since no finite competitive ratio is achievable if this condition is dropped .",
    "indeed , two nearby anonymous agents inside a long line need to travel , in the worst case , a long distance to one of its endpoints in order to meet .",
    "rapidly developing network and computer industry fueled the research interest in mobile agents computing .",
    "mobile agents are often interpreted as software agents , i.e. , programs migrating from host to host in a network , performing some specific tasks . however , the recent developments in computer technology bring up problems related to physical mobile devices . these include robots or motor vehicles and various wireless gadgets .",
    "examples of agents also include living beings : humans ( e.g. soldiers in the battlefield or disaster relief personnel ) or animals ( e.g. birds , swarms of insects ) .    in many applications",
    "the involved mobile agents are small and have to be produced at low cost in massive numbers .",
    "consequently , in many papers , the computational power of mobile agents is assumed to be very limited and feasibility of some important distributed tasks for such collections of agents is investigated .",
    "for example @xcite introduced _ population protocols _ , modeling wireless sensor networks by",
    "extremely limited finite - state computational devices .",
    "the agents of population protocols move according to some mobility pattern totally out of their control and they interact randomly in pairs .",
    "this is called _ passive mobility _ , intended to model ,",
    "e.g. , some unstable environment , like a flow of water , chemical solution , human blood , wind or unpredictable mobility of agents carriers ( e.g. vehicles or flocks of birds ) . on the other hand , @xcite introduced anonymous , oblivious , asynchronous , mobile agents which can not directly communicate , but they can occasionally observe the environment .",
    "gathering and convergence @xcite , as well as pattern formation @xcite were studied for such agents .",
    "apart from the feasibility questions for limited agents , the optimization problems related to the efficient usage of agents resources have been also investigated .",
    "energy management of ( not necessarily mobile ) computational devices has been a major concern in recent research papers ( cf .",
    "fundamental techniques proposed to reduce power consumption of computer systems include power - down strategies ( see @xcite ) and speed scaling ( introduced in @xcite ) .",
    "several papers proposed centralized @xcite or distributed @xcite algorithms .",
    "however , most of this research on power efficiency concerned optimization of overall power used . similar to our setting , assignment of charges to the system components in order to minimize the maximal charge has a flavor of another important optimization problem which is load balancing ( cf .",
    "@xcite ) .    in wireless sensor and ad hoc",
    "networks the power awareness has been often related to the data communication via efficient routing protocols ( e.g. @xcite .",
    "however in many applications of mobile agents ( e.g. those involving actively mobile , physical agents ) the agent s energy is mostly used for it s mobility purpose rather than communication , since active moving often requires running some mechanical components , while communication mostly involves ( less energy - prone ) electronic devices .",
    "consequently , in most tasks involving moving agents , like exploration , searching or pattern formation , the distance traveled is the main optimization criterion ( cf .",
    "@xcite ) . single agent exploration of an unknown environment has been studied for graphs , e.g. @xcite , or geometric terrains , @xcite .    while a single agent can not explore a graph of unknown size unless pebble ( landmark ) usage is permitted ( see @xcite ) , a pair of robots are able to explore and map a directed graph of maximal degree @xmath6 in @xmath8 time with high probability ( cf .",
    "@xcite ) . in the case of a team of collaborating mobile agents",
    ", the challenge is to balance the workload among the agents so that the time to achieve the required goal is minimized .",
    "however this task is often hard ( cf .",
    "@xcite ) , even in the case of two agents in a tree , @xcite . on the other hand , the authors of @xcite study the problem of agents exploring a tree , showing @xmath9 competitive ratio of their distributed algorithm provided that writing ( and reading ) at tree nodes is permitted .",
    "assumptions similar to our paper have been made in @xcite where the mobile agents are constrained to travel a fixed distance to explore an unknown graph @xcite , or tree @xcite . in @xcite",
    "a mobile agent has to return to its home base to refuel ( or recharge its battery ) so that the same maximal distance may repeatedly be traversed .",
    "@xcite gives an 8-competitive distributed algorithm for a set of agents with the same amount of power exploring the tree starting at the same node .",
    "the convergecast problem is sometimes viewed as a special case of the data aggregation question ( e.g. @xcite ) and it has been studied mainly for wireless and sensor networks , where the battery power usage is an important issue ( cf .",
    "recently @xcite considered the online and offline settings of the scheduling problem when data has to be delivered to mobile clients while they travel within the communication range of wireless stations .",
    "@xcite presents a randomized distributed convergecast algorithm for geometric ad - hoc networks and study the trade - off between the energy used and the latency of convergecast .",
    "the broadcastproblem for stationary processors has been extensively studied both for the message passing model , see e.g. @xcite , and for the wireless model , see e.g. @xcite .",
    "to the best of our knowledge , the problem of the present paper , when the mobile agents perform convergecast or broadcast by exchanging the held information when meeting , while optimizing the maximal power used by a mobile agent , has never been investigated before .      in the centralized setting ,",
    "we give a linear - time algorithm to compute the optimal battery power and the strategy using it , both for convergecastand for broadcast , when agents are on the line .",
    "we also show that finding the optimal battery power for convergecastor for broadcastis np - hard for the class of trees .",
    "in fact , the respective decision problem is strongly np - complete . on the other hand ,",
    "we give a polynomial algorithm that finds a 2-approximation for convergecastand a 4-approximation for broadcast , for arbitrary graphs .    in",
    "the distributed setting , we give a 2-competitive algorithm for convergecast in trees and a 4-competitive algorithm for broadcastin trees .",
    "the competitive ratio of 2 is proved to be the best for the problem of convergecast , even if we only consider line networks .",
    "indeed , we show that there is no ( @xmath0)-competitive algorithm for convergecastor for broadcastin the class of lines , for any @xmath1 .",
    "the following table gives the summary of our results .",
    "[ -0.22cm]centralized & + & + & @xmath10 polynomial 2-approximation on arbitrary graphs&@xmath10 polynomial 4-approximation on arbitrary graphs + [ 0.22cm]distributed&@xmath10 2-competitive algorithm for trees&@xmath10 4-competitive algorithm for trees + & +    * roadmap *    in section 2 , we show that we can restrict the search for the optimal strategy for convergecast or broadcast on the line to some smaller subclass of strategies called regular strategies . in section 3 , we present our centralized algorithms for convergecast and broadcast on lines .",
    "section 4 is devoted to centralized convergecast and broadcast on trees and graphs . in section 5 , we investigate convergecast and broadcast in the distributed setting .",
    "section 6 contains conclusions and open problems .",
    "in this section , we show that if we are given a convergecast ( respectively broadcast ) strategy for some initial positions of agents in the line , then we can always modify it in order to get another convergecast ( respectively broadcast ) strategy , using the same amount of maximal power for every agent , satisfying some simple properties . such strategies will be called _ regular_. these observations permit to restrict the search for the optimal strategy to some smaller and easier to handle subclass of strategies .",
    "we order agents according to their positions on the line .",
    "hence we can assume w.l.o.g .",
    ", that agent @xmath11 , for @xmath12 is initially positioned at point @xmath13 $ ] of the line of length @xmath14 and that @xmath15 < pos[2 ] < \\ldots < pos[n]\\leq\\ell $ ] .",
    "the set @xmath16 $ ] will be called a _ configuration _ for the line of length @xmath14 .      given a configuration",
    "@xmath16 $ ] , a starting point @xmath17 , a target point @xmath18 ( @xmath19 ) , and an amount of power @xmath3 , we want to know if there exists a strategy @xmath20 for the agents enabling them to move the information from @xmath17 to @xmath18 so that the amount of power spent by each agent is at most @xmath3 .",
    "strategies that move information from point @xmath17 to point @xmath18 will be called _ carry _ strategies for @xmath21,s , t , p)$ ] .",
    "we restrict attention to configurations @xmath16 $ ] such that @xmath22|<p$ ] and @xmath23|<p$ ] because otherwise either @xmath24 $ ] ( respectively @xmath25 $ ] ) is useless or it is impossible to carry information from @xmath17 to @xmath18 . a _",
    "regular _ carry strategy for @xmath21,s , t , p)$ ] is the set of moves for agents @xmath26 defined as follows : agent @xmath11 first goes back to a point @xmath27 $ ] , getting there the information from the previous agent ( except @xmath28 that has to go to @xmath17 ) , then it goes forward to a point @xmath29 .",
    "moreover , we require that each agent travels the maximal possible distance , i.e. , it spends all its power .",
    "[ lem - subproblem ] if there exists a carrystrategy for @xmath21,s , t , p)$ ] , then there exist the following two regular carrystrategies .",
    "the pull strategy that can be computed iteratively ( in linear time ) starting with the last agent :    1 .",
    "@xmath30 , @xmath31 , 2 .",
    "@xmath32 , 3 .",
    "@xmath33 \\geq b_i ,   \\forall 1 \\leq i \\leq n$ ] .",
    "the push strategy that can be computed iteratively ( in linear time ) starting with the first agent :    1 .",
    "@xmath34,s\\}$ ] , @xmath35 , 2 .",
    "@xmath36 ) , \\forall 2 \\leq i \\leq n$ ] , 3",
    ".   @xmath33 \\geq b_i ,   \\forall 1 \\leq i \\leq n$ ] .",
    "we first show that there exists a pull strategy .",
    "consider @xmath21,s , t , p)$ ] with the minimum number of agents such that there exists a carrystrategy , but no pull strategy .",
    "we consider the smallest value @xmath17 such that @xmath21,s , t , p)$ ] admits a carrystrategy but no pull strategy .",
    "if @xmath24 < s$ ] , then either @xmath24+p < s$ ] , or @xmath24+p \\geq s$ ] . in the first case , @xmath28 can not move the information between @xmath17 and @xmath18 , and then @xmath37,s , t , p)$ ] admits a carry strategy but not a pull strategy and has fewer agents . in the second case ,",
    "@xmath20 is also a carrystrategy for @xmath21,pos[1],t , p)$ ] and there is no pull strategy for @xmath21,pos[1],t , p)$ ] , contradicting our choice of @xmath17 .",
    "hence , we may suppose that @xmath24\\geq s$ ] .",
    "since there exists a carry strategy @xmath20 , let @xmath11 be the first agent that reaches @xmath17 .",
    "the rightmost point where @xmath11 can move the information from @xmath17 is @xmath38 $ ] .",
    "since @xmath20 is a carrystrategy , when considering all the agents except @xmath39 , @xmath20 is a carrystrategy for @xmath40,s',t , p)$ ] . by minimality of the number of agents",
    ", the pull strategy solves the subproblem on @xmath40,s',t , p)$ ] .",
    "consequently , we can assume that @xmath20 is a pull strategy on @xmath40,s',t , p)$ ] .",
    "if @xmath41 , by minimality of @xmath17 , we have @xmath42 and thus @xmath20 is a pull strategy which is a contradiction . hence , suppose that @xmath43 . note that if @xmath13=pos[1]$ ] , we can exchange the roles of @xmath11 and @xmath28 and we are in the previous case . hence , suppose that @xmath13 > pos[1]$ ] and let @xmath44 $ ] be the interval that @xmath28 traverses with the information when @xmath20 is applied ; by minimality of @xmath17 , @xmath45 and consequently we have @xmath46 + b_1 - 2s = pos[1]+f_1 - 2b_1 $ ] , and thus @xmath47+pos[1]+f_1 - 3p)/4 $ ] .",
    "consider now the strategy where we exchange the roles of @xmath28 and @xmath11 : @xmath28 gets the information from @xmath17 , gives it to @xmath11 , and @xmath11 goes to @xmath48 .",
    "more formally , let @xmath49 , @xmath50 + f_i ' - p)/2 $ ] , @xmath51 and @xmath52 + f_1 ' - p)/2 $ ] . from our definition of @xmath53 and @xmath54 and the first part of the proof , there exists a carrystrategy for @xmath21,b_1',t , p)$ ] .",
    "however , @xmath55+pos[i]+f_1 - 3p)/4 = s + ( pos[1 ] - pos[i])/4 < s$ ] , contradicting the minimality of @xmath17 .",
    "consequently , if there exists a carry strategy @xmath20 for @xmath21,s , t , p)$ ] , then there exists a pull strategy on @xmath21,s , t , p)$ ] .",
    "now suppose that @xmath21,s , t , p)$ ] admits a carrystrategy . from the first part of the proof , we know that it admits a pull strategy .",
    "the push strategy for @xmath21,s , t , p)$ ] can be obtained inductively from the pull strategy .",
    "let @xmath56 $ ] for @xmath57 be the set of intervals that induces the pull strategy for @xmath21,s , t , p).$ ] notice that @xmath56 $ ] for @xmath58 induces the pull strategy for @xmath59,s , b_n , p).$ ] by induction , there exists a set of intervals @xmath60 $ ] that induces a push strategy for @xmath59,s , b_n , p)$ ] with @xmath61 we define @xmath62,f'_{n-1}\\}$ ] and @xmath63.$ ] since @xmath64 we deduce that @xmath65 and therefore the set of intervals @xmath60 $ ] induces a push strategy for @xmath21,s , t , p)$ ] .",
    "[ rem - pull - push ] note that the pull strategy is uniquely defined by a configuration @xmath16 $ ] , a target point @xmath18 , and an amount of power @xmath3 and enables to compute the smallest @xmath17 such that @xmath21,s , t , p)$ ] admits a carrystrategy .",
    "similarly , the push strategy is uniquely defined by a configuration @xmath16 $ ] , a starting point @xmath17 , and an amount of power @xmath3 and enables to compute the largest @xmath18 such that @xmath21,s , t , p)$ ] admits a carrystrategy .",
    "note that carry strategies are defined for the target @xmath18 larger than the starting point @xmath17",
    ". a carry strategy will be called _",
    "reverse _ if the target @xmath18 is smaller than @xmath17 and all moves to the right are replaced by moves to the left and vice - versa .",
    "we now define the notion of a regular convergecast strategy for @xmath16 $ ] on the segment @xmath66 $ ] , using power at most @xmath3 . without loss of generality",
    ", we suppose that @xmath24=0 $ ] and @xmath25=\\ell$ ] .",
    "intuitively , a regular convergecast strategy divides the set of all agents into the set of left agents and the set of right agents such that left agents execute a push strategy from @xmath24 $ ] and right agents execute a reverse push strategy from @xmath25 $ ] .",
    "more formally , a _ regular _ convergecast strategy is given by a partition of the agents into two sets @xmath67 and @xmath68 for some @xmath69 , and by two points @xmath70 of segment @xmath71 $ ] for each agent @xmath11 , such that    1 .   if @xmath72 , @xmath73\\}$ ] and @xmath74 $ ] , 2 .   if @xmath75 , @xmath76\\}$ ] and @xmath77 $ ] , 3 .",
    "@xmath78 .",
    "suppose that we are given a partition of the agents into two disjoint sets @xmath79 and @xmath80 and values @xmath70 for each agent @xmath11 satisfying conditions ( 1)-(3 ) . then the following moves define a regular convergecast strategy : first , every agent @xmath81 moves to @xmath82 ; subsequently , every agent in @xmath79 moves to @xmath83 once it learns the initial information of @xmath28 ; then , every agent in @xmath80 moves to @xmath83 once it learns the initial information of @xmath84 .",
    "let @xmath85 be an agent from @xmath79 such that @xmath86 is maximum .",
    "once @xmath85 has moved to @xmath86 , it knows the initial information of all the agents @xmath11 such that @xmath87 . if @xmath88 , convergecast is achieved . otherwise , since @xmath89 , we know that there exists an agent @xmath90 such that @xmath91 . when @xmath92 reaches @xmath86 it knows the initial information of all the agents such that @xmath93 and thus , @xmath92 and @xmath85 know the initial information of all agents , which accomplishes convergecast .",
    "the following lemma shows that we can restrict attention to regular convergecast strategies .",
    "[ lem : regconv ] if there exists a convergecast strategy for a configuration @xmath16 $ ] using power at most @xmath3 then there exists a regular convergecast strategy for the configuration @xmath16 $ ] using power at most @xmath3 .    consider a convergecast strategy @xmath20 for a configuration @xmath16 $ ] using power at most",
    "suppose that convergecast occurred at time @xmath18 at some point @xmath94 .",
    "if an agent @xmath11 does not get the initial information of @xmath28 , then at time @xmath18 it must have been in the segment @xmath95 $ ] .",
    "hence , by time @xmath18 , it must have learned the initial information of @xmath84 .",
    "it follows that every agent @xmath11 , for @xmath96 , must learn either the initial information of agent @xmath28 or of @xmath84 .",
    "therefore , we can partition the set of agents performing a convergecast strategy into two subsets @xmath79 and @xmath80 , such that each agent @xmath72 learns the initial information of agent @xmath28 before learning the initial information of agent @xmath84 ( or not learning at all the information of @xmath84 ) .",
    "all other agents belong to @xmath80 .",
    "we denote by @xmath56 $ ] the interval of all points visited by @xmath72 and by @xmath97 $ ] the interval of points visited by @xmath90 .",
    "let @xmath98 and @xmath99 . since @xmath20 is a convergecast strategy , we have @xmath100 .",
    "observe that the agents in @xmath79 move the initial information of @xmath28 from @xmath24 $ ] to @xmath101 and that the agents in @xmath80 move the initial information of @xmath84 from @xmath25 $ ] to @xmath102 . from lemma  [ lem - subproblem ] , we can assume that the agents in @xmath79 ( resp .",
    "@xmath80 ) execute a push strategy ( resp . a reverse push strategy ) and thus conditions ( 1)-(3 ) hold .",
    "suppose now that there exists an agent @xmath75 such that @xmath103 .",
    "let @xmath104 and @xmath105 ; note that @xmath106\\}$ ] and @xmath107\\}$ ] .",
    "consider the strategy where we exchange the roles of @xmath11 and @xmath108 , i.e. , we put @xmath72 and @xmath109 .",
    "let @xmath110\\}$ ] , @xmath111\\}$ ] , @xmath112 $ ] and @xmath113 $ ] .    if @xmath114 $ ] , then @xmath115-p \\leq b_{i+1 } \\leq f_{lr}(i+1)$ ] . if @xmath116 $ ] , then @xmath117+p \\geq b_{i } \\geq f_{rl}(i)$ ] . in both cases , we still have a convergecast strategy .",
    "if @xmath118 $ ] and @xmath119 $ ] , then @xmath120 > 2 f_{lr}(i+1 ) + p -pos[i+1 ] = f_{i+1}$ ] , and @xmath121 < 2 f_{rl}(i ) - p -pos[i ] = f_{i}$ ]",
    ". consequently , we still have a convergecast strategy .    applying this exchange a finite number of times",
    ", we get a regular convergecast strategy .",
    "we now define the notion of a regular broadcast strategy for @xmath16 $ ] where the source agent is @xmath85 , on the segment @xmath66 $ ] , using power at most @xmath3 . without loss of generality",
    ", we suppose that @xmath24=0 $ ] and @xmath25=\\ell$ ] .",
    "intuitively , a regular broadcast strategy divides the set of all agents into the set of left agents and the set of right agents such that left agents execute a reverse pull strategy from @xmath122 $ ] and right agents execute a pull strategy from @xmath122 $ ] .    more formally , a _ regular _ broadcast strategy is given by points @xmath70 of segment @xmath71 $ ] defined for each agent @xmath11 such that    1",
    ".   @xmath123+p$ ] , @xmath124 -p$ ] , 2 .   if @xmath125 , @xmath126 and @xmath127+p)/2 $ ] , 3 .",
    "if @xmath128 , @xmath129 and @xmath127-p)/2 $ ] , 4 .",
    "@xmath130 and @xmath131 - f_k|    \\leq p$ ]    suppose that we are given points @xmath70 for each agent @xmath11 , satisfying conditions ( 1)-(4 ) . then the following moves define a regular broadcast strategy : initially every agent @xmath11 moves to @xmath82 . once @xmath11 learns the source information , @xmath11 moves to @xmath83 . since ( 1)-(4 )",
    "hold , this is a broadcast strategy and the maximum amount of power spent is at most @xmath3 .    before proving that it is enough to only consider regular broadcast strategies , we need to prove the following technical lemma .",
    "[ lem - strat1-broadcast ] there exists a broadcast strategy @xmath20 for a configuration @xmath21,k , p)$ ] if and only if for every @xmath39 , there exist positions @xmath132 such that    1 .   for each @xmath39 ,",
    "@xmath133 2 .",
    "@xmath134 $ ] ; 3 .   for each @xmath39",
    ", @xmath135| + \\min(x_i+r_i-2l_i , 2r_i - x_i - l_i )    \\leq p$ ] .",
    "4 .   for each @xmath39 , if @xmath136 $ ] ( resp .",
    "$ ] ) , there exists @xmath138 such that @xmath139 $ ] and @xmath140 ( resp .",
    "@xmath141 ) .    consider a broadcast strategy @xmath20 where the maximum amount of power spent is @xmath3 .",
    "for every agent @xmath11 , let @xmath142 be the position where @xmath11 learns the information that has to be broadcast , and let @xmath143 ( resp .",
    "@xmath144 ) be the leftmost ( resp .",
    "rightmost ) position reached by @xmath11 once it got the information . by definition of @xmath132 , ( 1 ) and",
    "( 2 ) hold .",
    "since the maximum amount of power spent by an agent is at most @xmath3 , and since the agent has to go from @xmath13 $ ] to @xmath142 and then to @xmath144 and @xmath143 , ( 3 ) holds . since every agent learns the information , for every agent @xmath11 , either @xmath145 $ ] , or @xmath11 meets an agent @xmath92 in @xmath142 such that @xmath92 already has the information .",
    "assume that @xmath136 $ ] ( the other case is symmetric ) .",
    "if @xmath146 , then ( 4 ) holds for @xmath39 .",
    "suppose now that @xmath147 $ ] and let @xmath148 be the non - empty set of agents @xmath92 such that @xmath149 and @xmath92 learns the information before @xmath11 .",
    "let @xmath150 be the agent that is first to learn the information .",
    "since @xmath151 $ ] , @xmath92 learns the information from an agent @xmath152 that does not belong to @xmath148 .",
    "consequently , @xmath153 and thus @xmath154 \\subseteq [ l_{j'},r_{j'}]$ ] . thus ( 4 ) holds for @xmath39 .",
    "conversely , if we are given values @xmath155 satisfying ( 1)-(4 ) , we can exhibit a strategy for broadcast : initially every agent @xmath11 moves to @xmath142 . once @xmath11 learns the information , if @xmath156 , then @xmath11 moves to @xmath143 and to @xmath144 and if @xmath157 , then @xmath11 moves to @xmath144 and to @xmath143 . since ( 4 ) holds , this is a broadcast strategy and since ( 3 ) holds , the maximum amount of power spent is at most @xmath3 .",
    "the following lemma shows that we can restrict attention to regular broadcast strategies .",
    "[ lem - shape - algo - b ] if there exists a broadcast strategy for a configuration @xmath16 $ ] with source agent @xmath85 , using power at most @xmath3 , then there exists a regular broadcast strategy for the configuration @xmath16 $ ] with source agent @xmath85 , using power at most @xmath3 .",
    "suppose that there exists a broadcaststrategy for @xmath21,k , p)$ ] .",
    "for every agent @xmath11 , @xmath158 we define @xmath159 as in the definition of a regular broadcast strategy .",
    "note that the agents @xmath160 execute a reverse pull strategy between @xmath161 and @xmath24+p$ ] .",
    "similarly , the agents @xmath162 execute a pull strategy between @xmath163 and @xmath25-p$ ] . by remark  [ rem - pull - push ] , it means that there exists @xmath164 ( resp .",
    "@xmath165 ) such that @xmath11 reaches @xmath161 ( resp .",
    "@xmath163 ) with the information from @xmath85 . moreover , since the agents execute either a reverse pull strategy or a pull strategy , we have @xmath166 \\leq b_{k-1}$ ] , and @xmath167\\geq b_{k+1}$ ] .",
    "suppose the lemma does not hold .",
    "this means that @xmath168 - b_{k-1 } > p$ ] , and @xmath169 - 2b_{k-1 } > p$ ] . consequently , @xmath85 can not reach both @xmath161 and @xmath163 ,",
    "i.e. , there exists @xmath170 such that @xmath11 reaches @xmath163 , or there exists @xmath164 such that @xmath11 reaches @xmath161 .",
    "if @xmath122 \\leq b_{k-1}$ ] , it implies that @xmath171 + p$ ] , and consequently , there can not exist a broadcast strategy since there is no carrystrategy on @xmath172,pos[k],pos[n]-p , p)$ ] .",
    "consequently , we can assume that @xmath122 > b_{k-1}$ ] .",
    "using a similar argument we can also assume that @xmath122 < b_{k+1}$ ] .    among all broadcast strategies ,",
    "consider the strategy that minimizes the size of @xmath173 . without loss of generality , assume that @xmath85 does not reach @xmath161 , and let @xmath164 such that @xmath11 reaches @xmath161 .",
    "for each agent @xmath92 , let @xmath174 be defined as in lemma  [ lem - strat1-broadcast ] .",
    "note that @xmath175+p$ ] and @xmath176+p$ ] .",
    "moreover , @xmath13 - p \\leq l_i \\leq b_{k-1 } \\leq l_k$ ] .    consider the new strategy defined as follows : for each agent @xmath177 , let @xmath178 and @xmath179 ; let @xmath180 $ ] , @xmath181+pos[i])/2 $ ] and @xmath182-p$ ] ; let @xmath183+pos[i])/2 $ ] and @xmath184 + p$ ] .",
    "note that @xmath185 - 2l_i ' \\leq p$ ] and @xmath186-l'_k \\leq p$ ] . since @xmath187 \\cup [ l_k , r_k ] \\subseteq [ pos[i]-p , pos[k]+p ] = [ l'_k , r'_k ] \\cup [ l'_i , r'_i]$ ] , this is still a broadcast strategy , in view of lemma  [ lem - strat1-broadcast ] .",
    "however , in this new strategy , there is one agent less in @xmath188 than in @xmath148 , contradicting the choice of our strategy .",
    "consequently , either @xmath168 - b_{k-1 } > p$ ] , or @xmath189 - 2b_{k-1 } > p$ ] and the lemma holds .",
    "in this section we consider the centralized convergecast problem for lines .",
    "we give an optimal , linear - time , deterministic centralized algorithm , computing the optimal amount of power needed to solve convergecast for line networks and we provide a regular convergecast strategy for this amount of power . as the algorithm",
    "is quite involved , we start by observing some properties of the optimal strategies .      in the following ,",
    "we only consider regular convergecast strategies .",
    "note that a regular convergecast strategy is fully determined by the value of @xmath3 and by the partition of the agents into the two sets @xmath79 and @xmath80 . for each agent @xmath72 ( resp .",
    "@xmath75 ) , we denote @xmath83 by @xmath190 ( resp .",
    "@xmath191 ) . observe that @xmath190 is the rightmost point on the line to which the set of @xmath39 agents at initial positions @xmath192 $ ] , each having power @xmath3 , may transport their total information .",
    "similarly , @xmath191 is the leftmost such point for agents at positions @xmath193 $ ] .",
    "lemma  [ lem : regconv ] permits to construct a linear - time decision procedure verifying if a given amount @xmath3 of battery power is sufficient to design a convergecast strategy for a given configuration @xmath16 $ ] of agents .",
    "we first compute two lists @xmath190 , for @xmath12 and @xmath191 , for @xmath194",
    ". then we scan them to determine if there exists an index @xmath138 , such that @xmath195 .",
    "in such a case , we set @xmath196 and @xmath197 and we apply lemma  [ lem : regconv ] to obtain a regular convergecaststrategy where agents @xmath92 and @xmath198 meet and exchange their information which at this time is the entire initial information of the set of agents . if there is no such index @xmath138 , no convergecast strategy is possible .",
    "this implies    in @xmath199 time we can decide if a configuration of @xmath200 agents on the line , each having a given maximal power @xmath3 , can perform convergecast .",
    "the remaining lemmas of this subsection bring up observations needed to construct an algorithm finding the optimal power @xmath4 and designing an optimal convergecast strategy .    note that if the agents are not given enough power , then it can happen that some agent @xmath201 may never learn the information from @xmath28 ( resp . from @xmath84 ) .",
    "in this case , @xmath201 can not belong to @xmath79 ( resp .",
    "@xmath80 ) .",
    "we denote by @xmath202 the minimum amount of power needed to ensure that @xmath201 can learn the information from @xmath28 : if @xmath203 , @xmath204\\}$ ] .",
    "similarly , we have @xmath205\\}$ ] .    given a strategy using power @xmath3 , for each agent @xmath206",
    ", we have @xmath207 and either @xmath208 $ ] , or @xmath209 $ ] .",
    "in the first case , @xmath210+p$ ] , while in the second case , @xmath211 $ ] .",
    "we define threshold functions @xmath212 and @xmath213 that compute , for each index @xmath69 , the minimal amount of power ensuring that agent @xmath201 does not go back when @xmath214 ( respectively @xmath215 ) , i.e. , such that @xmath216 $ ] ( respectively @xmath217 $ ] ) . for each @xmath69 , let @xmath218+p\\}$ ] and @xmath219-p\\}$ ] . clearly , @xmath220 .",
    "the next lemma shows how to compute @xmath221 and @xmath222 if we know @xmath212 and @xmath213 for every agent @xmath69 .",
    "[ lem - eqn - reach ] consider an amount of power @xmath3 and an index @xmath94 .",
    "if @xmath223 , then @xmath224 + ( 2^{q - p+1}-1)p - \\sum_{i = p+1}^{q } 2^{q - i}pos[i]$ ] .",
    "similarly , if @xmath225 , then @xmath226 - ( 2^{p - q+1}-1)p - \\sum_{i = q}^{p-1 } 2^{i - q}pos[i]$ ] .    we prove the first statement of the lemma ; the proof of the other statement is similar .",
    "we first show the following claim",
    ".    * claim . *",
    "if for every @xmath227 $ ] , @xmath228 , then @xmath229.\\ ] ]    we prove the claim by induction on @xmath230 .",
    "note that since @xmath231 , @xmath232 $ ] .",
    "thus if @xmath233 , the statement holds .",
    "suppose now that @xmath234 .",
    "since @xmath235 , by the induction hypothesis , we have    @xmath236.\\ ] ]    consequently , we have @xmath237\\\\ & = & 2^{q - p}{reach_{lr}^c\\xspace}(p , p ) + ( 2^{q - p}-2)p - \\sum_{i = p+1}^{q-1 } 2^{q - i}pos[i]+p - pos[q ] \\\\ & = & 2^{q - p}{reach_{lr}^c\\xspace}(p , p ) + ( 2^{q - p}-1)p - \\sum_{i = p+1}^{q } 2^{q - i}pos[i].\\\\\\end{aligned}\\ ] ] this concludes the proof of the claim .",
    "if @xmath238 , then for each @xmath239 $ ] , @xmath240 and @xmath241+p$ ] . consequently ,    @xmath242 + ( 2^{q - p+1}-1)p - \\sum_{i = p+1}^{q } 2^{q - i}pos[i].\\ ] ]    in the following , we denote @xmath243 $ ] and @xmath244 $ ] .",
    "[ rem - slr ] for every @xmath245 , we have @xmath246 .",
    "we now show that for an optimal convergecast strategy , the last agent of @xmath79 and the first agent of @xmath80 meet at some point between their initial positions and that they need to use all the available power to meet .",
    "[ lem - egalite - reach ] suppose there exists an optimal convergecast strategy for a configuration @xmath16 $ ] , where the maximum power used by an agent is @xmath3 .",
    "then , there exists an integer @xmath247 such that @xmath248 < { reach_{lr}^c\\xspace}(p , p ) = { reach_{rl}^c\\xspace}(p+1,p ) < pos[p+1].$ ]    moreover , @xmath249 , @xmath250 and @xmath251 , @xmath252 .    in the proof we need the following claim",
    ".    * claim . * for every @xmath253 , the function @xmath254 which assigns the value @xmath255 for any argument @xmath3 , is an increasing , continuous , piecewise linear function with at most @xmath69 pieces on @xmath256 .    for every @xmath253 ,",
    "the function @xmath257 which assigns the value @xmath258 for any argument @xmath3 , is a decreasing continuous piecewise linear function with at most @xmath69 pieces on @xmath259 .",
    "we prove the first statement of the claim by induction on @xmath69 .",
    "for @xmath260 , @xmath261 + p$ ] and the claim holds .",
    "suppose that @xmath254 is a continuous piecewise linear function on @xmath256 and consider @xmath262 .",
    "first note that @xmath263 . since @xmath254 is a continuous , increasing function , there exists a unique @xmath264 such that @xmath265 $ ] and for every @xmath266 , @xmath267 $ ] .",
    "consequently , @xmath262 is well defined on @xmath268 .    since @xmath254 is a continuous , increasing function",
    ", there exists a unique @xmath269 such that @xmath270 $ ] .",
    "if @xmath271 , @xmath272 $ ] and thus @xmath262 is an increasing , continuous , piecewise linear function on @xmath273 $ ] with at most @xmath69 pieces .",
    "if @xmath274 , @xmath275 + p$ ] and thus , @xmath262 is an increasing , continuous , linear function on @xmath276 .",
    "since @xmath277 = pos[p+1]+ { th_{lr}^c\\xspace}(p+1)$ ] , the function @xmath262 is an increasing , continuous , piecewise linear function on @xmath278 with at most @xmath279 pieces .",
    "one can show the second statement of the claim using similar arguments .",
    "this ends the proof of the claim .",
    "suppose we are given @xmath69 and consider the partition of the agents into @xmath280 and @xmath281 .",
    "consider a regular convergecast strategy for this partition and where the maximum amount of power @xmath3 used by an agent is minimized .",
    "we first show that @xmath282 .",
    "let @xmath283 .",
    "since @xmath254 is an increasing continuous function on @xmath256 and @xmath284 is a decreasing continuous function on @xmath285 , the difference @xmath286 is a continuous increasing function on @xmath287 .",
    "consider the case where @xmath288 ( the other case is similar ) .",
    "since @xmath289+q$ ] , @xmath290+q < pos[p+1]+q = { reach_{rl}^c\\xspace}(p+1,q)$ ] and thus , @xmath291 . by definition of a regular convergecast strategy , there exists @xmath292 such that @xmath293 .",
    "consequently , since the difference @xmath286 is a continuous increasing function on @xmath287 , there exists a unique @xmath294 such that @xmath295 .",
    "consider an optimal regular convergecast strategy and let @xmath3 be the maximum amount of power used by any agent . by definition of a regular convergecast strategy",
    ", there exists an index @xmath69 such that @xmath282 .",
    "suppose that @xmath296 $ ] . in this case",
    ", we have @xmath297 - p < { reach_{lr}^c\\xspace}(p-1,p)$ ] since @xmath298 . consequently , according to what we have shown above , there exists @xmath299 such that @xmath300 and @xmath3 is not the optimal value needed to solve convergecast .",
    "this contradiction shows that @xmath248 < { reach_{lr}^c\\xspace}(p , p)$ ] .    for similar reasons , if @xmath301 $ ] , @xmath3 is not the optimal value needed to solve convergecast",
    "this contradiction shows that @xmath302 $ ] .",
    "we now prove that for each @xmath303 $ ] , @xmath304 .",
    "this follows from the fact that for each @xmath305 such that @xmath306 , we have @xmath307 .",
    "consequently , for each @xmath308 $ ] , @xmath309 .",
    "moreover , if @xmath255 is defined , then @xmath207 . if @xmath310 , then @xmath241-p$ ] and thus , @xmath311 - p > pos[p ] - p \\geq { reach_{lr}^c\\xspace}(p , p)$ ] .",
    "this contradicts the first statement of the lemma .",
    "hence , we have @xmath312 .    for similar reasons , for each @xmath313 $ ] , @xmath314 .",
    "we finally prove that for each @xmath303 $ ] , @xmath315 .",
    "suppose there exists @xmath94 such that @xmath316 and consider @xmath317 and @xmath318 . since @xmath319 , @xmath320 - p = { reach_{rl}^c\\xspace}(q , p)$ ] and consequently , the first statement of the lemma implies that there exists @xmath321 such that @xmath322 .",
    "this implies that @xmath3 is not the optimal value needed to solve convergecast .",
    "this contradiction implies that for each @xmath303 $ ] , @xmath315 .    for similar reasons , for each @xmath313 $ ] , @xmath323 .",
    "we first sketch a suboptimal but much easier algorithm and later present and analyze in detail a more involved linear - time solution to our problem .",
    "first , we need to compute the functions @xmath254 and @xmath257 for all @xmath69 such that @xmath324 . by lemma",
    "[ lem - eqn - reach ] , the function @xmath254 can be computed from the values @xmath325 for all @xmath94 such that @xmath326 .",
    "starting from @xmath260 , one can compute all these functions @xmath254 , since each value @xmath327\\}$ ] can be deduced from @xmath328 .",
    "the computation at step @xmath69 has a time complexity in @xmath329 and so the computation of all the functions @xmath254 takes time @xmath330 .",
    "similarly , it is possible to compute all the functions @xmath257 , for all @xmath69 such that @xmath331 , in time @xmath330 . since @xmath254 and @xmath284 are increasing , continuous , piecewise linear functions with at most @xmath200 pieces , by the claim from the proof of lemma  [ lem - egalite - reach ] , it is possible to compute the value @xmath3 such that @xmath282 in time @xmath199 .",
    "hence the optimal value of power needed to achieve convergecast on lines , which is @xmath332 by lemma  [ lem - egalite - reach ] , can be computed in time @xmath330 .",
    "the following result shows that the optimal power needed for convergecast on the line can in fact be computed in linear time .",
    "[ thm : optpower ] in @xmath199 time it is possible to compute the optimal power needed to achieve convergecast on the line for configuration @xmath16 $ ] and to compute the optimal convergecast strategy .",
    "we first explain how to compute a stack of couples @xmath333 that we can subsequently use to calculate @xmath255 for any given @xmath3 .",
    "then , we present a linear algorithm that computes the value needed to solve convergecast when the last index @xmath334 is provided : given an index @xmath335 , we compute the optimal power needed to solve convergecast assuming that @xmath336 and @xmath337 .",
    "finally , we explain how to use techniques introduced in the two previous algorithms in order to compute the optimal power needed to solve convergecast .",
    "[ [ computing - the - threshold - values . ] ] computing the threshold values .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in order to describe explicitly the function @xmath338 , we need to identify the indices @xmath69 such that for every @xmath339 $ ] , we have @xmath340 . they correspond to the breakpoints at which the slopes of the piecewise linear function @xmath338 change . indeed ,",
    "if we are given such an index @xmath69 , then for every @xmath3 comprised between @xmath212 and @xmath341 , we have @xmath342 + ( 2^{q - p+1}-1)p - { s_{lr}^c\\xspace}(p , q)$ ] .",
    "we denote by @xmath343 this set of indices @xmath344 , { th_{lr}^c\\xspace}(r ) > { th_{lr}^c\\xspace}(p)\\}$ ] .",
    "in particular , if we want to compute @xmath345 , we just need to find @xmath346\\}$ ] , and then @xmath345 is the value of power @xmath3 such that @xmath347 + ( 2^{q - p+1}-1)p - { s_{lr}^c\\xspace}(p , q ) = pos[q+1]$ ] . moreover , by the choice of @xmath69 , we have @xmath348 .",
    "using these remarks , the function , with an input index @xmath335 of an agent , returns a stack @xmath349 containing couples @xmath350 such that @xmath351 and @xmath352 .",
    "note that in the stack @xmath349 , the elements @xmath350 are sorted along both components , the largest being on the top of the stack .    the function is described as follows .",
    "initially , the stack @xmath349 contains only the couple @xmath353 . at each iteration , given the stack corresponding to the index @xmath94 , in order to compute the stack for the index @xmath354 , we first pop out all elements @xmath350 such that @xmath355 $ ] .",
    "after that , the integer @xmath69 needed to compute @xmath345 is located on the top of the stack .",
    "finally , the couple @xmath356 is pushed on the stack before we proceed with the subsequent index @xmath357 the function returns the stack @xmath349 corresponding to the index @xmath335 .",
    "below , we give the pseudo - code of the function .",
    "@xmath358 ( @xmath349,@xmath359 ) ( @xmath349 )    the number of stack operations performed during the execution of this function is @xmath360 .",
    "however , in order to obtain a linear number of arithmetic operations , we need to be able to compute @xmath361 and @xmath362 in constant time .    in order to compute @xmath361 efficiently , we can store the values of @xmath363 , @xmath364 $ ] in an auxiliary array , that we have precomputed in @xmath199 time .",
    "we can not precompute all values of @xmath362 since this requires calculating @xmath365 values .",
    "however , from remark  [ rem - slr ] , we know that @xmath366 .",
    "consequently , it is enough to precompute @xmath367 for each @xmath368 $ ] .",
    "since @xmath369 $ ] , this can be done using @xmath199 arithmetic operations .",
    "similarly , we can define the function ( ` array ` @xmath16 $ ] ` of real ` , @xmath335`:integer):stack ` that returns a stack @xmath370 containing all pairs @xmath371 such that for every @xmath372 $ ] , we have @xmath373 .    [ [ computing - the - optimal - power - when - lr - and - rl - are - known . ] ] computing the optimal power when @xmath79 and @xmath80 are known .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    to facilitate further reading , we first show how to compute the optimal power @xmath4 , if the sets @xmath79 and @xmath80 are known .",
    "this will be done by function optimalatindexwhich will be not used in our final algorithm to compute optimal power but whose role is to explain some of the techniques under these additional assumptions .",
    "suppose that we are given an agent index @xmath335 and we want to compute the optimal power needed to solve convergecast when @xmath374 and @xmath375 .",
    "from lemma  [ lem - egalite - reach ] , we know that there exists a unique value @xmath4 such that @xmath376 .    as previously , by lemma  [ lem - eqn - reach ] , we know that the value of @xmath377 depends on @xmath378 . similarly , @xmath379 depends on @xmath380 . if we are given the values of @xmath69 and @xmath94 , then @xmath4 is the unique value of @xmath3 such that @xmath381 - ( 2^{r - p+1}-1)p - { s_{lr}^c\\xspace}(p , r ) = 2^{q - r-1}pos[q ] -            ( 2^{q - r}-1)p - { s_{rl}^c\\xspace}(q , r+1).\\ ] ]    in function optimalatindex , we first use functions and to compute the two stacks @xmath349 and @xmath370 containing respectively @xmath382 and @xmath383 . then at each iteration , we consider the two elements @xmath384 and @xmath385 that are on top of both stacks .",
    "if @xmath386 ( the other case is symmetric ) , we check whether @xmath387 . in this case",
    ", we have @xmath388 , so we remove @xmath384 from the stack @xmath349 and we proceed to the next iteration . if @xmath389 , we know that @xmath390 and we can compute the value of @xmath4 using lemma  [ lem - eqn - reach ] .",
    "let @xmath391 denote @xmath392 and @xmath393 .",
    "[ rem - atpos ] at the end of the execution of function optimalatindex , @xmath349 and @xmath370 contain respectively @xmath394 and @xmath395 .",
    "moreover , if initially the two stacks @xmath349 and @xmath370 contain respectively @xmath391 and @xmath396 for some @xmath397 , then the value computed by the function is also @xmath4 .",
    "the pseudo - code of the of function optimalatindexis given below .",
    "@xmath398 ; @xmath399    @xmath400 ; @xmath401 ; @xmath402    ( + ) @xmath403 + ( 2^{r - p+1}-1)p - { s_{lr}^c\\xspace}(p , r ) \\geq   2^{q - r-1}pos[q ] - ( 2^{q - r}-1)p - { s_{rl}^c\\xspace}(q , r+1 )   $ ] @xmath404 @xmath405 - { s_{rl}^c\\xspace}(q , r+1 ) - 2^{r - p}pos[p]+{s_{lr}^c\\xspace}(p , r))/(2^{r - p+1}+2^{q - r}-2)$ ] ( @xmath4 )    [ [ computing - the - optimal - power - for - convergecast . ] ] computing the optimal power for convergecast .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we now explain how to compute the optimal amount of power needed to achieve convergecast using a linear number of operations .",
    "notice that function optimalatindexdoes it only provided the partition of the agents in @xmath79 and @xmath80 .",
    "let @xmath406 be the optimal value needed to solve convergecast when @xmath407 , i.e. , when the two agents whose meeting results in merging the entire information are @xmath11 and @xmath108 for some @xmath408 .",
    "if @xmath409 , then @xmath410 . however , if @xmath411 , then @xmath412 and @xmath413 is the unique value of @xmath3 such that @xmath414 .",
    "this corresponds to the value returned by function optimalatindex(@xmath415 ) .",
    "the general idea of function is to iteratively compute the value of @xmath406 .",
    "if we need a linear time algorithm , we can not call repeatedly the function optimalatindex .",
    "however , from remark  [ rem - atpos ] , in order to compute @xmath413 when @xmath416 , it is enough to know @xmath417 and @xmath418 .",
    "if we know @xmath417 and @xmath418 , then we can use the same algorithm as in optimalatindexin order to compute @xmath413 .",
    "moreover , from remark  [ rem - atpos ] , we also get @xmath419 and @xmath420 when we compute @xmath413 .    before proceeding to the next iteration",
    ", we need to compute @xmath421 and @xmath422 from @xmath419 and @xmath420 .",
    "note that if @xmath423 , then @xmath424 . if @xmath425 , we can use the same function as in to compute @xmath426 from @xmath419 .",
    "consider now @xmath422 .",
    "if @xmath427 , then @xmath428 , and @xmath429 .",
    "if @xmath430 , then either @xmath431-p_{<r+1 } \\geq { reach_{rl}^c\\xspace}(r+1,p_{<r+1})$ ] if @xmath410 , or @xmath431-p_{<r+1 } = { reach_{rl}^c\\xspace}(r+1,p_{<r+1 } ) = { reach_{lr}^c\\xspace}(r , p_{<r+1})$ ] if @xmath412 . in both cases , it implies that @xmath432 .",
    "therefore , by lemma  [ lem - egalite - reach ] , @xmath433 for every @xmath434 and we can return the value of @xmath413 .    in function , at each iteration",
    ", the stack @xmath349 contains @xmath417 ( except its top element ) and the stack @xmath370 contains @xmath418 ( except its top element ) .",
    "initially , @xmath349 is empty and @xmath370 contains @xmath199 elements . in each iteration , at most one element is pushed into the stack @xmath349 and no element is pushed into the stack @xmath370 .",
    "consequently , the number of stack operations performed by function is linear .",
    "@xmath358 ; @xmath435    @xmath436 ; @xmath437 @xmath436 ; @xmath260;@xmath438    notice that the partition of agents into sets @xmath79 and @xmath80 is given by the value of index @xmath335 when @xmath4 is returned by function .",
    "since an optimal regular convergecast strategy is fully determined by the value of @xmath4 and by the partition of the agents into the sets @xmath79 and @xmath80 , function also yields an optimal convergecast strategy .",
    "hence , this concludes the proof of theorem  [ thm : optpower ] .      in this section",
    "we consider the centralized broadcast problem for lines .",
    "we give an optimal , linear - time , deterministic centralized algorithm , computing the optimal amount of power needed to solve broadcast for line networks and computing an optimal broadcast strategy .      in the following ,",
    "we only consider regular broadcast strategies .",
    "note that a regular broadcast strategy is fully determined by the value of @xmath3 and by the two possible values of @xmath439 for the source agent @xmath85 ( @xmath440 or @xmath441 ) .",
    "let @xmath442 and @xmath443 .",
    "( note that we slightly abuse notation by using the same names @xmath79 and @xmath80 for subsets of agents as in convergecast . ) for each agent @xmath444 ( resp .",
    "@xmath445 ) , we denote @xmath82 by @xmath446 ( resp .",
    "@xmath447 ) . observe that @xmath446 is the rightmost point on the line from which the set of @xmath39 agents at initial positions @xmath192 $ ] , each having power @xmath3 , may pick the information and bring it back to @xmath28 .",
    "similarly , @xmath447 is the leftmost point from which the agents at positions @xmath193 $ ] may pick the information and bring it back to @xmath84 .",
    "lemma  [ lem - shape - algo - b ] permits to construct a linear - time decision procedure verifying if a given amount @xmath3 of battery power is sufficient to design a broadcast strategy for a given configuration @xmath16 $ ] of agents and a specified source agent @xmath85 .",
    "we first compute @xmath448 and @xmath449",
    ". then we test if @xmath450 - { reach_{rl}^b\\xspace}(k+1,p)|$ ] or @xmath451 - { reach_{lr}^b\\xspace}(k-1,p)|$ ] are less or equal than @xmath3 .",
    "if one of the inequalities is true then there is a broadcast strategy .",
    "otherwise , broadcast is not possible .",
    "this implies    in @xmath199 time we can decide if a configuration @xmath16 $ ] of @xmath200 agents on the line , each having a given maximal power @xmath3 , can perform broadcast for a given source agent .",
    "note that if the agents are not given enough power , then it can happen that some agent @xmath452 @xmath453 ( resp .",
    "@xmath454 ) can not reach the point @xmath455 ( resp .",
    "@xmath456 ) .",
    "we denote by @xmath457 ( resp .",
    "@xmath458 ) the minimum amount of power @xmath3 we have to give the agents to ensure that @xmath201 ( resp .",
    "@xmath459 ) can reach @xmath455 ( resp .",
    "@xmath456 ) .",
    "we have : @xmath460 and if @xmath461 @xmath462-p\\}$ ] .",
    "similarly , if @xmath463 we have @xmath464+p\\}$ ] .    in a regular broadcast strategy using power @xmath3 , for each agent @xmath206 such that @xmath465 we have @xmath466)/2 $ ] .",
    "similarly , for each agent @xmath467 such that @xmath468 we have @xmath469)/2 $ ] .",
    "the next lemma shows how to compute @xmath470 on the interval @xmath471 for every @xmath472 and @xmath473 on the interval @xmath474 for every @xmath475    [ lem - eqn - reach - b ] consider an index @xmath472 and an amount of power @xmath476 then @xmath477 analogously , for an index @xmath478 and an amount of power @xmath479 we have @xmath480    first , we show by induction on @xmath69 that for any @xmath472 and an amount of power @xmath481 , we have @xmath477 this is true for @xmath260 since @xmath482 , @xmath483 and @xmath484 .",
    "now , assume by induction that @xmath485 .",
    "by definition of a regular broadcast strategy , we have for all @xmath486 :    @xmath487+p}{2}\\\\ & = \\frac{{reach_{lr}^b\\xspace}(p-1,{act_{lr}^b\\xspace}(p-1 ) ) + p - { act_{lr}^b\\xspace}(p-1)+pos[p]+p}{2}\\\\ & = p+\\frac{{reach_{lr}^b\\xspace}(p-1,{act_{lr}^b\\xspace}(p-1 ) ) - { act_{lr}^b\\xspace}(p-1)+pos[p]}{2}\\\\ \\end{aligned}\\ ] ]    observe that for @xmath488 , we have : @xmath489}{2 } + { act_{lr}^b\\xspace}(p).\\end{aligned}\\ ] ] hence we have : @xmath490    this concludes the proof by induction .",
    "similarly , we can show by induction on @xmath94 that for any @xmath491 and an amount of power @xmath481 , we have @xmath492      in this section , we prove the following theorem .",
    "[ thm : optpower - b ] in @xmath199 time it is possible to compute the optimal power needed to achieve broadcast for a configuration @xmath493 $ ] of @xmath200 agents on the line for any source agent and to compute an optimal broadcast strategy .",
    "we formulate function which computes in linear time the optimal power for the broadcast in the line .",
    "@xmath494    @xmath495 , q = n$ ]    @xmath496    @xmath497    in order to compute this value , function first computes the minimal amount of power @xmath498 such that all agents in @xmath499 are activated , i.e. , @xmath500 . in order to compute @xmath498 ,",
    "the function iteratively increases the power sufficient to activate all agents in @xmath79 .",
    "then , it does the same with agents in @xmath80 .",
    "the function computes iteratively for each agent @xmath11 from @xmath28 to @xmath501 in @xmath79 ( respectively from @xmath502 to @xmath503 in @xmath80 ) , the value @xmath504 ( respectively @xmath505 ) and the value @xmath506 ( respectively @xmath507 ) .",
    "once @xmath498 is known , the function computes the minimal amount of power @xmath508 that enables the agent @xmath85 to reach @xmath509 and @xmath510 .",
    "this will be proved to be the minimal power to accomplish broadcast .",
    "notice that in order to accomplish broadcast , agent @xmath501 must be able to reach @xmath511 .",
    "hence the optimal value @xmath5 of power sufficient to accomplish broadcast must be at least @xmath512 .",
    "similarly , @xmath5 must be at least @xmath513 .",
    "hence , we will first prove that the values of @xmath514 , @xmath515 , @xmath516 and @xmath517 are correctly computed for @xmath518 and @xmath519 .",
    "we only prove that the values of @xmath520 and @xmath515 are correctly computed for @xmath518 , as the proof that @xmath521 and @xmath458 are correctly computed for @xmath519 is similar .",
    "the proof is by induction on @xmath69 . for @xmath260 ,",
    "the values of @xmath520 and @xmath457 are correctly computed since @xmath522 and @xmath523 .",
    "suppose that the values of @xmath520 and @xmath515 are correctly computed .",
    "if @xmath524-p$ ] , then @xmath525 . by lemma  [ lem - eqn - reach - b ]",
    ", all functions @xmath526 are linear with coefficient 1 on @xmath471 .",
    "hence , if @xmath527-{act_{lr}^b\\xspace}(p)$ ] , we have @xmath528-p-{reach_{lr}^b\\xspace}(p,{act_{lr}^b\\xspace}(p)))/2 $ ] .",
    "this shows that @xmath529 is correctly computed .",
    "it remains to show that @xmath530 is correctly computed . by definition of a regular broadcast strategy",
    ", we have @xmath531)/2 $ ] .",
    "if @xmath524-{act_{lr}^b\\xspace}(p)$ ] , then @xmath532 is correctly computed as the above formula is used by the function . otherwise , we have : @xmath528-{act_{lr}^b\\xspace}(p)-{reach_{lr}^b\\xspace}(p,{act_{lr}^b\\xspace}(p)))/2 $ ] . using the notation @xmath533 , @xmath534 , @xmath535 , @xmath536",
    "we have :    @xmath537}{2}\\\\ & = & \\frac{(r+a'-a ) + ( a+(pos[p+1]-a - r)/2 ) + pos[p+1]}{2}\\\\ & = & \\frac{(r+(pos[p+1]-a - r)/2 ) ) + ( a+(pos[p+1]-a - r)/2 ) + pos[p+1]}{2}\\\\ & = & pos[p+1].\\end{aligned}\\ ] ]    this completes the proof by induction .    again , using the fact that all functions @xmath526 are linear with coefficient 1 on @xmath471 , the function computes correctly the value @xmath538 .",
    "the same is true for @xmath539 .",
    "finally , we consider three cases : @xmath122 \\le { x_{lr}^b\\xspace}$ ] , @xmath540 < { y_{rl}^b\\xspace}$ ] or @xmath541 $ ] to compute the additional power @xmath542 that has to be used . by definition of @xmath509 and @xmath510 , we conclude that @xmath3 is the optimal value of power to achieve broadcast by a regular strategy . in view of lemma  [ lem - shape - algo - b ] , this concludes the proof that @xmath3 is the optimal value of power to achieve broadcast .",
    "the complexity @xmath199 of the function is straightforward by its formulation .    since a regular broadcast strategy",
    "is fully determined by the value of @xmath3 and by the two possible values of @xmath439 for the source agent @xmath85 ( @xmath440 or @xmath441 ) , computing the optimal power @xmath3 yields an optimal broadcast strategy .",
    "this concludes the proof of theorem  [ thm : optpower - b ] .",
    "we start the section by showing that for arbitrary trees the centralized convergecast problem and the centralized broadcast problem are substantially harder than on lines .",
    "a configuration for convergecast on arbitrary graphs is a couple @xmath543 where @xmath2 is a @xmath200-node weighted graph representing the network and @xmath148 of size @xmath544 is the set of the starting nodes of the agents .",
    "a configuration for broadcast additionally specifies the starting node of the source agent .",
    "we consider the centralized convergecast decision problem and the broadcast decision problem formalized as follows .    *",
    "centralized convergecast decision problem * + _ instance : _ a configuration @xmath543 and a real @xmath3 .",
    "+ _ question : _ is there a convergecast for @xmath543 , in which each agent uses at most @xmath3 battery power  ?",
    "* centralized broadcast decision problem * + _ instance : _ a configuration @xmath543 with a specified source agent and a real @xmath3 .",
    "+ _ question : _ is there a broadcast for @xmath543 with the specified source agent , in which each agent uses at most @xmath3 battery power ?    we will prove that both these problems are strongly np - complete . in order to do this , we consider _ star configurations _",
    ", i.e. , configurations @xmath543 in which @xmath2 is a star , i.e. , a tree of diameter 2 .",
    "we define a class of strategies in a star called _ simple _ that consist of the following two phases :    * the strategy starts with a gathering phase lasting time @xmath3 , in which each agent uses all its available power to move towards the center of the star and then waits until time @xmath3 .",
    "the agents that have used all their power during this phase without reaching the center are called _",
    "depleted_. * in the second phase , the agents does not move past depleted agents , i.e. , never enter the segment between a leaf and a depleted agent .",
    "the following lemma shows that it is enough to consider simple strategies for convergecast and broadcast .",
    "[ cl : simpl ] if there exists a convergecast ( respectively a broadcast strategy ) in a star using power @xmath3 , then there exists a simple convergecast ( respectively a simple broadcast strategy ) using power @xmath3 .",
    "let @xmath20 be a convergecast or a broadcast .",
    "we construct a simple @xmath545 as follows . in @xmath545 ,",
    "each agent moves towards the center of the star until it has used all its battery power or has reached the center of the star .",
    "this gathering phase lasts from time @xmath546 to time @xmath3 .",
    "if an agent has not reached the center in strategy @xmath20 , then it stops forever in @xmath545 .",
    "otherwise , consider time @xmath18 at which it arrives at the center in @xmath20 .",
    "then , in strategy @xmath545 , the agent executes at time @xmath547 each movement performed at time @xmath548 in @xmath20 .",
    "however , if a movement of an agent would result in the agent moving past a depleted agent from time @xmath335 to @xmath549 in @xmath20 , then in strategy @xmath545 the agent waits at the position of the depleted agent instead of moving past it . by construction",
    ", @xmath545 is a simple .",
    "observe that in @xmath545 , the non - depleted agents share all their information at the center of the star at time @xmath3 .",
    "since two depleted agents can not meet , it remains to show that when a non - depleted agent @xmath550 meets a depleted agent @xmath551 at time @xmath18 in @xmath20 , they meet at time @xmath552 in @xmath545 .",
    "the final position of agent @xmath551 is not farther from the center in @xmath545 than in @xmath20 .",
    "hence , any agent @xmath550 that meets agent @xmath551 at time @xmath18 is at the new position of @xmath551 in @xmath545 at time @xmath552 .",
    "hence , the meeting between @xmath551 and @xmath550 occurs in @xmath545 as well .",
    "if @xmath20 was a convergecast strategy ( respectively a broadcast strategy ) then @xmath545 is a simple convergecast strategy ( respectively a simple broadcast strategy ) .",
    "[ th : np - graph ] the centralized convergecast decision problem and the centralized broadcast decision problem are strongly np - complete for trees .",
    "the proof of theorem [ th : np - graph ] is split into three lemmas .",
    "we first show that the centralized convergecast decision problem is strongly np - hard , then that the centralized broadcast decision problem is strongly np - hard , and finally that both problems are in np .",
    "[ th : np - hard - graph ] the centralized convergecast decision problem is strongly np - hard for trees .    we construct a polynomial - time many to one reduction from the following strongly np - complete problem @xcite .",
    "* 3-partition problem * + _ instance : _ a multiset @xmath553 of @xmath554 positive integers @xmath142 such that for @xmath555 with @xmath556 .",
    "+ _ question : _ can @xmath553 be partitioned into @xmath557 disjoint sets @xmath558 of size 3 , such that @xmath559 for @xmath560 ?",
    "we construct an instance @xmath561 of the centralized convergecast problem from an instance of 3-partition as follows .",
    "the graph @xmath2 is a star with @xmath562 leaves and @xmath563 is the set of leaves of @xmath2 .",
    "hence , there are @xmath562 agents , each located at a leaf of the star .",
    "we consider a partition of the set of agents into three subsets : @xmath148 , @xmath564 and @xmath565 .",
    "the subset @xmath566 contains @xmath567 agents .",
    "the leaves containing these agents are incident to an edge of weight @xmath568 .",
    "the subset @xmath569 contains @xmath570 agents . for @xmath571 ,",
    "the weight of the edge incident to the leaf containing agent @xmath82 is @xmath572 .",
    "the subset @xmath573 contains one agent .",
    "the leaf containing agent @xmath574 is incident to an edge of weight @xmath575 .",
    "figure  [ fig : reduc ] depicts the star obtained in this way .",
    "the battery power @xmath3 allocated to each agent is equal to @xmath576 .",
    "the construction can be done in polynomial time .",
    "we show that the constructed instance of the centralized convergecast problem gives answer yes if and only if the original instance of 3-partition gives answer yes .",
    "first , assume that there exists a solution @xmath558 for the instance of the 3-partition problem .",
    "we show that the agents can solve the corresponding instance of the centralized convergecast problem using the following .",
    "agent @xmath574 moves at distance @xmath577 from the center and for each @xmath571 , agent @xmath82 moves at distance @xmath142 from the center . at this point , all these agents have used all their battery power . each agent in @xmath148 moves to the center of the star . for @xmath578 and for each of the three agents @xmath579 such that @xmath580 , agent @xmath11 moves to meet @xmath579 and goes back to the center of the star",
    "the cost of this movement is @xmath581 , which is exactly the remaining battery power of agent @xmath11 .",
    "observe that since agents in @xmath148 have met all agents in @xmath564 , agents in @xmath148 , located at the center of the star , have the information of all agents except agent @xmath574",
    ". then agent @xmath582 moves to meet agent @xmath574 .",
    "agents @xmath582 and @xmath574 have the information of all the agents .",
    "hence , this is a solution of the instance of the centralized convergecast problem .",
    "now assume that there exists a solution ( strategy ) to the convergecast problem . by lemma  [ cl : simpl ]",
    ", we can assume that the convergecast is simple .",
    "consider the star @xmath2 after the gathering phase of the simple .",
    "each agent in @xmath148 is at the center of the star . for @xmath583 , the agent @xmath11 has the remaining power of @xmath577 . for @xmath571 , the agent",
    "@xmath82 is at distance @xmath142 from the center of the star and agent @xmath574 is at distance @xmath577 from the center .",
    "since the agents in @xmath148 are the only agents with remaining battery power , they must move to collect the information of agents in @xmath584 .",
    "we call this phase the collecting phase . observe that since agent @xmath574 is at distance @xmath577 from the center , it is impossible for agents in @xmath148 to transport this information . indeed , when an agent reaches @xmath574 , it has used all its battery power .",
    "hence , the entire information must be collected at the position of @xmath574 . in order to collect the information",
    ", agents in @xmath148 must go to the position of each agent in @xmath564 and transport the information of these agents to the center .",
    "the total cost to move these information is at least twice the sum of the distances between each agent in @xmath564 and the center .",
    "this is equal to @xmath585 .",
    "then , this information must be moved to the position of @xmath574 .",
    "this costs at least @xmath577 .",
    "hence , the total cost of collecting information after the gathering phase is at least @xmath586 .",
    "the amount of power available to the agents for the collecting phase is equal to the amount of power needed to collect the information , since there are @xmath567 agents each having power @xmath577 .",
    "this means that during the collecting phase , for @xmath587 , agents can not collectively use a power larger than @xmath588 to collect the information of @xmath82 .",
    "suppose by contradiction that during the collecting phase , more than one agent in @xmath148 enters an edge @xmath589 to collect the information of agent @xmath82 at distance @xmath142 from the center , for some @xmath39 such that @xmath571 .",
    "let @xmath590 be the agent that has reached the position of @xmath82 .",
    "if @xmath590 comes back to the center , it has used at least power @xmath588 . since",
    "at least one other agent has used some power to enter edge @xmath589 , these agents have used more than @xmath588 battery power to collect information of agent @xmath82 .",
    "if @xmath590 does not come back to the center , then some other agent has to move the information to the center .",
    "if the agent @xmath590 stops at distance @xmath335 from the center , then at least one other agent has to go to this position ( at distance @xmath335 from the center ) and come back .",
    "thus , the cost is at least @xmath591 . in both cases ,",
    "the agents have used more power than @xmath588 , which leads to a contradiction .",
    "hence , for each @xmath571 , there is only one agent that collects the information of agent @xmath82 and enters the corresponding edge .",
    "we can assume , without loss of generality , that agent @xmath582 is the agent that transports the information to @xmath574 .",
    "observe that @xmath582 can not collect information from other nodes since moving to @xmath574 uses exactly all its remaining power .",
    "hence , only agents in @xmath592 can collect the information of agents in @xmath564 .",
    "let @xmath593 be the partition of @xmath553 defined by @xmath594 , for each @xmath578 .",
    "we have @xmath595 since each agent from @xmath596 has battery power at most @xmath577 .",
    "the power needed to collect information of agents in @xmath564 is @xmath597 which is exactly equal to the combined power available to agents in @xmath596 .",
    "this means that each agent in @xmath596 must use all its power to collect information and @xmath598 .",
    "hence , @xmath593 is a solution to the instance of 3-partition .",
    "[ th : np - hard - graph - b ] the centralized broadcast decision problem is strongly np - hard for trees .",
    "again , we construct a polynomial - time many to one reduction from 3-partition .",
    "the general structure of the proof is similar as in lemma  [ th : np - hard - graph ] but details differ .",
    "we construct an instance @xmath561 of the centralized broadcast problem from an instance of 3-partition as follows .",
    "the graph @xmath2 is a star with @xmath599 leaves and @xmath563 is the set of leaves of @xmath2 .",
    "hence , there are @xmath599 agents , each located at a leaf of the star .",
    "we consider a partition of the set of agents into three subsets : @xmath148 , @xmath564 and @xmath565 .",
    "the subset @xmath600 contains @xmath557 agents .",
    "the leaves containing these agents are incident to an edge of weight @xmath568 .",
    "the subset @xmath569 contains @xmath570 agents . for @xmath571 ,",
    "the weight of the edge incident to the leaf containing agent @xmath82 is @xmath601 .",
    "the subset @xmath602 contains @xmath557 agents .",
    "all leaves containing an agent in @xmath565 are incident to an edge of weight @xmath603 .",
    "figure  [ fig : reducb ] depicts the star obtained in this way .",
    "the battery power @xmath3 allocated to each agent is equal to @xmath575 and agent @xmath28 is the source agent .",
    "the construction can be done in polynomial time .",
    "we show that the constructed instance of the centralized broadcast problem gives answer yes if and only if the original instance of 3-partition gives answer yes .",
    "first , assume that there exists a solution @xmath558 for the instance of the 3-partition problem .",
    "we show that the agents can solve the corresponding instance of the centralized broadcast problem using the following . for each @xmath39 ,",
    "agent @xmath604 moves at distance @xmath577 from the center and for each @xmath571 , agent @xmath82 moves at distance @xmath142 from the center . at this point , all these agents have used all their battery power .",
    "each agent in @xmath148 moves to the center of the star .",
    "hence , each agent @xmath11 obtains the information of @xmath28 . for @xmath578 and each of the three agents @xmath579 such that @xmath580 , agent @xmath11 moves to meet @xmath579 and goes back to the center of the star",
    "the cost of this movement is @xmath581 .",
    "observe that since agents in @xmath148 have met all agents in @xmath564 , all agents except those in @xmath565 have the information of @xmath28 .",
    "each agent @xmath605 moves to meet agent @xmath604 .",
    "each agent @xmath604 obtains the information of @xmath28 .",
    "hence , this is a solution to the instance of the centralized broadcast problem .",
    "now assume that there is a solution ( strategy ) to the broadcast problem . by lemma  [ cl : simpl ]",
    ", we can assume that the centralized broadcast is simple .",
    "consider the star @xmath2 after the gathering phase of the simple .",
    "each agent in @xmath148 is at the center of the star . for @xmath578 , the agent @xmath11 has the remaining power of @xmath606 . for @xmath571 , the agent",
    "@xmath82 is at distance @xmath142 from the center of the star . for @xmath578 , agent",
    "@xmath604 is at distance @xmath577 from the center . since the agents in @xmath148 are the only agents with remaining battery power , they must move to give the information to agents in @xmath584 .",
    "observe that since each agent @xmath604 is at distance @xmath577 from the center , an agent in @xmath148 that moves to meet an agent @xmath604 has not enough power to meet another depleted agent afterwards .",
    "hence , each agent @xmath11 must meet exactly one agent @xmath607 . without loss of generality",
    ", we can assume that each agent @xmath11 meets @xmath604 .",
    "before agents in @xmath148 meet agents in @xmath565 , they must meet agents in @xmath564 .",
    "the total cost to give the information to all agents in @xmath564 is at least twice the sum of the distances between each agent in @xmath564 and the center .",
    "this is equal to @xmath585 .",
    "the total cost to give the information to agents in @xmath565 is @xmath608 .",
    "the amount of power available to the agents in @xmath148 is @xmath609 , which is exactly the power needed for broadcast .",
    "assume for the sake of contradiction that two or more agents in @xmath148 enter the same edge incident to the leaf of an agent @xmath82 .",
    "in this case , one of the agents must meet @xmath82 .",
    "this costs the agent @xmath588 and other agents have used some power to enter this edge .",
    "this gives a contradiction because the total cost is more than the available power .",
    "thus , we can assume that each agent @xmath579 meets exactly one agent @xmath11 .",
    "let @xmath593 be the partition of @xmath553 defined by @xmath610 , for each @xmath578 .",
    "we have @xmath595 since the total power that agents in @xmath148 can use to meet agents in @xmath564 is at most @xmath608 .",
    "the power needed to give information to agents in @xmath564 is @xmath597 which is exactly equal to the combined power available to agents in @xmath148 .",
    "this means that each agent in @xmath148 must use all its power to meet agents in @xmath564 and @xmath598 .",
    "hence , @xmath593 is a solution to the instance of 3-partition .",
    "[ lem : np - graph ] the centralized convergecast decision problem and the centralized broadcast decision problem are in np .",
    "we consider the verifier - based definition of np .",
    "consider the @xmath20 of the agents for an instance of the centralized convergecast or centralized broadcast problems .",
    "we construct the certificate for the instance as follows .",
    "we say that a meeting of two or more agents is _ useful _ if at least one of the agents received a new piece of information during this meeting .",
    "each agent participates in at most @xmath611 useful meetings where @xmath544 is the number of agents .",
    "hence , there are at most @xmath612 useful meetings .",
    "the certificate contains the list of all useful meetings in chronological order . for the @xmath39-th meeting ,",
    "the certificate encodes the identities of the meeting agents and the location of the meeting : a node @xmath142 or an edge @xmath613 of the graph @xmath2 .",
    "if the meeting has occurred on an edge , the certificate encodes a variable @xmath614 .",
    "the variable @xmath614 represents the distance between @xmath615 and the meeting point @xmath616 . if a previous meeting of number @xmath138 has occurred on the same edge , the certificate encodes if @xmath617 , or @xmath618 or @xmath619 . for each of the meeting agents",
    ", the certificate also encodes the node from which it has entered the edge ( @xmath615 or @xmath620 ) just before the meeting and the node from which it exits the edge just after the meeting .",
    "we consider the @xmath545 defined as follows .",
    "for each useful meeting in chronological order , the meeting agents move to the meeting location following a shortest path from their previous position .",
    "if the meeting occurs on an edge , the meeting agents enter and exit the edge using the node encoded in the certificate .",
    "@xmath545 is a convergecast since each time an agent has collected a new piece of information in @xmath20 , it collects the same information during the corresponding meeting in @xmath545 . moreover , the agents use at most as much power in @xmath545 as in @xmath20 since they move to the same meeting points using shortest paths .",
    "the verifier simulates the @xmath545 defined by the certificate .",
    "the verifier first checks that all the agents possess the entire information at the end of the algorithm . this can be done in polynomial time .",
    "then , the verifier computes the distance traveled by each agent .",
    "these distances are linear sums of variables @xmath614 with @xmath621 and of a constant .",
    "finding an assignment of the variables , such that the distance traveled by each agent is less or equal than @xmath3 , can be done in polynomial time using linear programming .",
    "thus , the certificate can be verified in polynomial time .",
    "theorem [ th : np - graph ] is a direct consequence of lemmas [ th : np - hard - graph ] , [ th : np - hard - graph - b ] and [ lem : np - graph ] .",
    "since both decision problems concerning convergecast and broadcast are np - hard for the class of trees , the same is true for their optimization counterparts , i.e. , computing the smallest amount of power that is sufficient to achieve convergecast or broadcast . in spite of that",
    ", we will show how to obtain , in polynomial time , a 2-approximation of the power needed to achieve centralized convergecast on arbitrary graphs and a 4-approximation of the power needed to achieve centralized broadcast on arbitrary graphs .",
    "let @xmath622 , where @xmath623 is the distance between @xmath624 and @xmath625 in @xmath2 .",
    "the following proposition shows a relation between @xmath626 and the above optimal power values .",
    "[ lem : twice - p ] consider a configuration @xmath543 for convergecast and a configuration @xmath543 with a specified source agent for broadcast . then @xmath627 and @xmath628 for any source agent in @xmath543 .",
    "we prove the proposition for the case of convergecast .",
    "the proof for broadcast is similar .",
    "suppose , by contradiction , that there is a partition of @xmath148 into @xmath629 and @xmath630 such that for each @xmath631 and @xmath632 the distance between @xmath624 and @xmath625 is greater than @xmath633 .",
    "it means that no agents in @xmath629 can meet an agent in @xmath630 using power @xmath4 .",
    "this contradicts the fact that there is a convergecast in @xmath2 using battery power @xmath4 .",
    "hence , for every partition of @xmath148 into @xmath629 and @xmath630 , there exist agents @xmath631 and @xmath632 that are at distance at most @xmath633 .    in view of proposition [ lem : twice - p ]",
    ", the following theorem shows that the convergecast problem has a polynomial - time 2-approximation .",
    "[ cor : fourapr ] consider a configuration @xmath543 .",
    "there is a polynomial algorithm computing a convergecast strategy in which each agent uses power @xmath626 .",
    "we formulate algorithm @xmath634 which produces the desired convergecast strategy .",
    "the parameters of the algorithm are the graph @xmath2 and the nodes corresponding to the initial positions of agents ( stored in @xmath635 $ ] ) .",
    "@xmath636 @xmath637\\}$ ] @xmath638    let @xmath613 be the nodes chosen at the @xmath39-th iteration of the first loop and let @xmath639 be the value of @xmath640 at the end of the @xmath39-th iteration .",
    "we set @xmath641 $ ] and @xmath642 .",
    "we show , by induction , that at the start of the @xmath39-th iteration of the second loop , agents that started in @xmath643 hold collectively all the information .",
    "it is clearly true for @xmath644 .",
    "assume by induction that it is true for @xmath39 .",
    "the agent that started at @xmath645 moves to node @xmath646 for some @xmath647 , during the @xmath39-th iteration of the second loop . after this move ,",
    "the agent that started at @xmath648 has the information of the agent that started at @xmath645 .",
    "agents in @xmath649 collectively hold all the information .",
    "hence , the property is true for @xmath650 and this concludes the argument by induction . at the end of the algorithm , the agent at @xmath651 $ ] has all the information since @xmath652\\}$ ] .",
    "let @xmath148 be the set of agents .",
    "consider the partition of @xmath148 into sets @xmath653 and @xmath654 .",
    "we have @xmath655 since @xmath613 is the couple @xmath656 such that @xmath657 is minimal . hence",
    ", no agent will traverse distance larger than @xmath633 by proposition  [ lem : twice - p ] .    in @xmath658 time , it is possible to precompute all shortest paths between @xmath659 and @xmath660 for all @xmath661 .",
    "each iteration of the first repeat loop can be computed in @xmath330 time and there are @xmath611 such iterations where @xmath662 is the number of agents .",
    "hence , executing the first repeat loop takes time @xmath658 . the execution the second repeat loop takes time @xmath330 .",
    "hence , the overall complexity of the algorithm is @xmath658 .",
    "the above theorem gives the following corollary for the broadcast problem on arbitrary graphs .",
    "the broadcast problem on arbitrary graphs has a polynomial - time 4-approximation .",
    "let @xmath543 be a configuration with an arbitrary source agent @xmath551 . by theorem [ cor : fourapr ]",
    ", there is a convergecast strategy @xmath553 for @xmath543 using power at most @xmath626 that can be computed in polynomial time .",
    "let @xmath550 be the agent that collects all information upon completion of this strategy .",
    "consider the strategy @xmath663 which consists of performing the reverse of all moves of @xmath553 in the reverse order .",
    "the strategy @xmath663 is a broadcast strategy for source agent @xmath550 .",
    "hence , the strategy @xmath553 followed by @xmath663 is a broadcast strategy for source agent @xmath551 .",
    "the required power is at most @xmath664 which gives a 4-approximation of the broadcast problem in view of proposition  [ lem : twice - p ] .",
    "in this section , we consider the convergecast and the broadcast problem in the distributed setting .",
    "as explained in the introduction , we consider weighted trees with agents at every leaf . in view of proposition  [ lem : twice - p ] , the following theorem implies that there exists a 2-competitive distributed algorithm for the convergecast problem on trees .",
    "[ thm : fourcomp ] consider a configuration @xmath665 where @xmath666 is a tree and @xmath148 contains all the leaves of @xmath666 .",
    "there exists a distributed convergecast algorithm in which each agent uses power at most @xmath667 .",
    "the idea behind the algorithm is similar to the saturation technique used for message passing systems ( see chapter 2.6.1 of @xcite ) .",
    "each agent starting at a leaf moves until it reaches the neighbor of its starting position .",
    "when an agent reaches a node , it waits until an agent has arrived from each incident edge except one .",
    "when this happens , the agent with the most remaining power moves via the edge from which no agent has arrived .",
    "one can show that each agent will not move more than @xmath667 and thus twice @xmath4 by proposition  [ lem : twice - p ] . at some point ,",
    "the saturation occurs , i.e. , two agents meet inside an edge or agents meet at a node coming from all incident edges . at this point",
    ", the convergecast is achieved .",
    "the pseudocode of the algorithm ( executed distributedly by all agents ) is the following .",
    "@xmath668    first , we show that if each agent executes algorithm  [ algo:2appr ] then , eventually , one agent will hold all the information .",
    "consider an agent @xmath551 executing the algorithm .",
    "let @xmath669 be the subtree rooted at the last visited node and containing all nodes accessible from the current position of @xmath551 by shortest paths containing a non - null part of the last edge traversed by agent @xmath551 .",
    "hence , when @xmath551 enters a new node @xmath659 , @xmath659 is added to @xmath670 .",
    "we show by induction on the number of nodes of @xmath670 that @xmath551 has the initial information of every agent that started at a node of @xmath670 . for @xmath671 ,",
    "this is true since @xmath551 is the only agent that started in @xmath670 .",
    "the size of @xmath670 grows only when @xmath551 enters or exits some node @xmath660 .",
    "when @xmath551 enters a new node @xmath660 , we show that any agent that started at @xmath660 did not move yet .",
    "assume by contradiction that there is an agent @xmath550 that started at @xmath660 and has moved before the arrival of @xmath551 .",
    "it means that agents have arrived from all but one edge incident to @xmath660 . in that case",
    ", agent @xmath550 follows the edge from which no agent has arrived .",
    "hence , the only possible edge that agent @xmath550 can follow is the edge taken by agent @xmath551 to arrive at @xmath660 .",
    "this leads to a contradiction since agents @xmath551 and @xmath550 must have met inside the edge and agent @xmath551 would have stopped before reaching @xmath660 .    when an agent @xmath551 moves from a node @xmath660 of degree @xmath542 , there were @xmath672 agents @xmath673 that have arrived at @xmath660 before .",
    "by the induction hypothesis , each agent @xmath82 , for @xmath674 , has collected all the information from agents starting inside the subtree @xmath675 .",
    "since agent @xmath551 moves in the only direction from which no agent has arrived , it has the information of every agent that started in @xmath676 .",
    "this concludes the proof by induction .",
    "observe that for each @xmath677 the tree @xmath678 grows until either @xmath11 meets agents that have arrived from all incoming ports of its current position , or another agent @xmath92 with more power moves in a yet unexplored direction . in the latter case , @xmath679 and the tree @xmath680 will grow under the same conditions .",
    "thus , @xmath681 will eventually be equal to @xmath666 .",
    "this happens when either two agents @xmath682 meet inside an edge or @xmath542 agents @xmath683 meet at a node of degree @xmath542 .",
    "these agents have the entire information since @xmath684 ( @xmath685 if the meeting occurs on an edge ) .",
    "it remains to show that the agents do not use more battery power than @xmath667 .",
    "let @xmath69 be the point where some agent @xmath551 has finished the execution of the algorithm ( when the value of @xmath686 becomes true for this agent ) and let @xmath660 be the last node visited by @xmath551 before reaching @xmath69 .",
    "consider @xmath670 when @xmath551 exited @xmath660 .",
    "agent @xmath551 is the agent starting in @xmath670 for which the distance between its initial position and the node @xmath660 was the smallest , since it was the agent that has used the least power when it arrived at @xmath660 .",
    "thus , the distance between the initial position of an agent in @xmath670 and an agent in @xmath687 is less or equal than @xmath626 .",
    "hence we conclude that @xmath688 . by property",
    "[ lem : twice - p ] , we have that @xmath689 and hence the algorithm is 2-competitive .",
    "again in view of proposition  [ lem : twice - p ] , the following corollary implies that there exists a 4-competitive distributed algorithm for the broadcast problem on trees .",
    "[ cor : fourcomp ] consider a configuration @xmath665 with a specified source agent , where @xmath666 is a tree and @xmath148 contains all the leaves of @xmath666 .",
    "there exists a distributed broadcast algorithm in which each agent uses power at most @xmath690 .",
    "let @xmath665 be a configuration with a specified source agent @xmath551 .",
    "all agents execute the following algorithm consisting of two phases . in the first phase , each agent executes algorithm from the proof of theorem [ thm : fourcomp ] to achieve convergecast .",
    "suppose that @xmath564 is the set of agents that get the total information at the end of the execution of this phase .",
    "all agents in @xmath564 are aware of this fact .",
    "agents in @xmath564 start the second phase .",
    "we call them _ active _ agents .",
    "each active agent backtracks to its initial position , by walking along the path reverse to the one used in phase 1 . on its way",
    ", it activates all agents it meets and conveys all the information to each of them .",
    "the process continues until each agent is activated and is back at its initial position . at this time , all information and in particular information of the source agent @xmath551 is known to all agents .",
    "the energy spent is at most @xmath690 .",
    "the following theorem shows that no distributed algorithm may offer a better competitive ratio than @xmath691 for convergecast or for broadcast , even if we only consider line networks .",
    "[ thm : twoapropt ] consider any @xmath692 , and any value of power @xmath3 .",
    "there exists an integer @xmath200 and a configuration @xmath16 $ ] of @xmath200 agents on the line such that :    * there exists a centralized convergecast strategy using power @xmath3 and there is no deterministic distributed strategy allowing the agents to solve convergecast when the amount of power given to each agent is @xmath693 .",
    "* there exists a centralized broadcast strategy using power @xmath3 for source agent starting at @xmath24 $ ] and there is no deterministic distributed strategy for source agent starting at @xmath24 $ ] allowing the agents to solve broadcast when the amount of power given to each agent is @xmath693 .    before proving theorem  [ thm : twoapropt ] , we prove two technical lemmas .",
    "[ lem - offline - group ] consider any @xmath694 , an amount of power @xmath3 , and a set @xmath695 @xmath696 of @xmath697 agents located at positions @xmath698 $ ] . if @xmath699- { reach_{lr}^c\\xspace}(1,p ) \\leq p-\\varepsilon$ ] , and if @xmath700 , there exists @xmath701 such that @xmath702 $ ] .",
    "suppose , by contradiction , that the lemma does not hold .",
    "it means that for each @xmath703 , @xmath704 $ ] .",
    "therefore , in view of the claim from the proof of lemma  [ lem - eqn - reach ] , we have @xmath705\\\\ & = & { reach_{lr}^c\\xspace}(1,p ) + ( 2^{k}-1)p - \\sigma_{i=1}^{k } 2^{k - i}(pos[i]-{reach_{lr}^c\\xspace}(1,p))\\\\ & \\geq & { reach_{lr}^c\\xspace}(1,p ) + ( 2^{k}-1)p - \\sigma_{i=1}^{k } 2^{k - i}(p-\\varepsilon)\\\\ & \\geq & { reach_{lr}^c\\xspace}(1,p ) + ( 2^{k}-1)p - ( 2^{k}-1)(p-\\varepsilon)\\\\ & \\geq & { reach_{lr}^c\\xspace}(1,p ) + ( 2^{k}-1)\\varepsilon\\end{aligned}\\ ] ]    consequently , if @xmath706 , we have @xmath707 $ ] , a contradiction .",
    "[ lem - online - gap ] consider an amount of power @xmath3 , a distance @xmath708 , and a set @xmath709 of @xmath544 agents located at positions @xmath710 $ ] .",
    "let @xmath711 be the closest point from @xmath712 $ ] that @xmath28 reached .",
    "assume that @xmath712-r_1 = d$ ] .",
    "suppose that all the agents execute the same distributed deterministic algorithm and do not know their initial position , and assume that some agent @xmath713 meets agent @xmath28 before any couple of agents in @xmath714 meet .",
    "then , @xmath715 and when @xmath716 meets @xmath28 , for each @xmath717 , agent @xmath11 is located on @xmath13-d$ ] .    moreover , if @xmath718 is the rightmost point reached by some agent knowing the initial information of agent @xmath28 , then @xmath719 + p - 2d$ ] .",
    "since all agents are executing the same distributed deterministic algorithm , let us consider the execution of the algorithm until some agent meets agent @xmath28 .",
    "during this period , all the agents perform exactly the same moves . since they started simultaneously",
    ", no agent meets another agent before agent @xmath716 meets @xmath28 at point @xmath711 or to the left of @xmath711 .",
    "when agent @xmath716 meets @xmath28 , it has moved at least a distance of @xmath6 . until this meeting between @xmath28 and @xmath716 ,",
    "every other agent has also moved a distance of at least @xmath6 , and is located at distance @xmath6 to the left of its starting position .",
    "consequently , no agent can go further than @xmath720 to the right of @xmath122 $ ] .",
    "theorem [ thm : twoapropt ] let @xmath721 and @xmath722 .",
    "let @xmath723 , @xmath724 and @xmath725 . consider a set of @xmath200 agents positioned on a line as follows ( see figure  [ fig-2-comp ] ) .",
    "there is an agent @xmath28 ( resp .",
    "@xmath502 ) on the left ( resp .",
    "right ) end of the line on position @xmath726 ( resp .",
    "@xmath727 ) . for each @xmath728",
    ", there is a set @xmath729 of @xmath544 agents that start on distinct positions within a segment @xmath730 $ ] of length @xmath731 such that for each @xmath732 , the distance between @xmath733 and @xmath734 is @xmath735 .",
    "in other words , for each @xmath39 , @xmath736 and @xmath737 .",
    ".,width=604 ]    first , let us consider the execution of the optimal convergecast centralized algorithm for this configuration .",
    "we claim that if the amount of power given to each agent is @xmath3 , then convergecast is achievable .",
    "we show by induction on @xmath39 that for every @xmath39 , @xmath738 . for @xmath739 , @xmath261+p > p-\\epsilon = s_1-p+\\epsilon$ ] .",
    "suppose that @xmath740 .",
    "consider the agents in @xmath729 , i.e. , the agents @xmath741 , @xmath742 $ ] .",
    "since @xmath743 , and since @xmath744 , we know by lemma  [ lem - offline - group ] that @xmath745 $ ] . since @xmath746",
    ", it follows that @xmath747+p \\geq s_i + p = s_i'+p-\\sigma \\geq s_i'+p-\\epsilon$ ] .",
    "consequently , this concludes the proof by induction .",
    "since @xmath748 , @xmath3 is sufficient to solve convergecast .",
    "notice that the same strategy guarantees broadcast for source agent @xmath28 for configuration @xmath16 $ ] and power @xmath3 .",
    "consider any distributed deterministic algorithm where the amount of power given to each agent is @xmath693 , yielding a strategy @xmath20 of the agents .",
    "a _ step _ in @xmath20 is a moment when two agents meet .",
    "let @xmath749 ( resp .",
    "@xmath750 ) be the first step where an agent from @xmath729 meets an agent from @xmath751 with @xmath752 ( resp .",
    "@xmath753 ) .",
    "let @xmath754 ( resp .",
    "@xmath755 ) be the rightmost point ( resp .",
    "the leftmost point ) reached by any agent from @xmath729 after some agent in @xmath729 has met an agent from @xmath751 with @xmath752 ( resp .",
    "@xmath756 ) . for any @xmath757 ,",
    "let @xmath758 .",
    "we show by induction on time @xmath18 that for each @xmath759 $ ] such that @xmath760 and for each @xmath761 $ ] such that @xmath762 , the following properties hold :    1 .",
    "@xmath763 for each @xmath764 $ ] and @xmath765 for each @xmath766 $ ] , 2 .   for each @xmath764 $ ] , if @xmath767 then @xmath768 , and for each @xmath766 $ ] , if @xmath769 then @xmath770 3 .",
    "@xmath771 and @xmath772 , 4 .",
    "no agent in @xmath751 , @xmath773 meets any agent from @xmath774 and no agent in @xmath775 , @xmath776 meets any agent from @xmath777 .",
    "first , consider @xmath778 . clearly , @xmath779 and @xmath780 .",
    "since all agents in @xmath781 execute the same algorithm , they all perform the same moves until either the leftmost agent of @xmath782 meets @xmath783 ( at step @xmath784 ) , or the rightmost agent of @xmath785 meets @xmath786 ( at step @xmath787 ) . in the first case",
    ", it shows that @xmath788 and @xmath789 for any @xmath790 . by lemma  [ lem - online - gap ] , @xmath791 . by symmetry , in the second case , @xmath792 and @xmath793 for any @xmath794 and @xmath795 . in both cases , properties for @xmath796",
    "hold for @xmath778 .",
    "notice that for any @xmath797 $ ] , no agent in @xmath729 has met an agent of @xmath798 . hence , property @xmath799 hold for @xmath778 .",
    "suppose that the induction hypothesis holds for all @xmath800 and let @xmath801 and @xmath802 .",
    "note that by @xmath799 , we have @xmath803 and @xmath804 . by @xmath805 and @xmath806 , before step @xmath18 , no agent in @xmath751 , @xmath807 has met any other agent from a set @xmath808 , @xmath809 .",
    "thus , since all agents in @xmath810 execute the same deterministic distributed algorithm starting simutaneously , they have performed exactly the same moves and they have not met any other agent before step @xmath18 .",
    "suppose that an agent from @xmath810 meets another agent at step @xmath18 .",
    "then , either the leftmost agent @xmath11 from @xmath729 meets an agent @xmath811 from @xmath751 with @xmath752 , or the rightmost agent from @xmath798 meets an agent from @xmath775 with @xmath812 .    by symmetry , it is enough to consider only one case . in the following ,",
    "we assume that @xmath813 meets an agent @xmath814 with @xmath752 at step @xmath18 . in this case ,",
    "@xmath815 and thus @xmath816 and @xmath817 for each @xmath818 ; consequently , properties @xmath805 and @xmath806 hold for @xmath18 .",
    "moreover , by induction hypothesis , the meeting between @xmath11 and @xmath811 occurs at a point @xmath819 .",
    "first suppose that @xmath803 .",
    "by lemma  [ lem - online - gap ] , we have @xmath820 , and thus property @xmath821 and @xmath799 holds for @xmath18 .",
    "then suppose that @xmath822 .",
    "we have @xmath823 .",
    "but this is impossible since the initial position of the leftmost agent @xmath551 of @xmath824 is @xmath825\\geq s_l$ ] and the power available to @xmath551 is @xmath826 .",
    "this concludes the proof by induction .",
    "in particular , no agent from @xmath827 ever meets any agent from @xmath828 and consequently , @xmath20 is neither a distributed convergecast strategy nor a distributed broadcast strategy for any source agent .",
    "theorems  [ thm : fourcomp ] and [ thm : twoapropt ] show that for the distributed convergecast problem on the class of trees , the competitive ratio 2 is optimal .",
    "in the centralized setting , we showed that the breaking point in complexity between polynomial and np - hard , both for the convergecast and for the broadcast problem , is already present inside the class of trees .",
    "namely , agents optimal power and the strategy using it can be found in polynomial time for the class of lines but it is np - hard for the class of arbitrary trees .",
    "nevertheless , we found polynomial approximation algorithms for both these problems .",
    "it remains open if better approximation constants can be found .",
    "the problem of a single _ information transfer _ by mobile agents between two stationary points of the network , which we called _ carry _ in the case of lines , is also interesting . in particular",
    ", it is an open question whether the problem of finding optimal power for this task is np - hard for arbitrary tree networks or if a polynomial - time algorithm is possible in this case .",
    "our reduction from 3-partition is no longer valid for this problem .    in",
    "the distributed setting , we showed that 2 is the best competitive ratio for the problem of convergecast .",
    "however , our distributed algorithm for the broadcast problem is only 4-competitive .",
    "it remains open to find the best competitive ratio for the broadcast problem .",
    "additional natural questions related to our research include other variations of the agent model , e.g. , agents with unequal power , agents with non - zero visibility , labeled agents in the distributed setting , as well as fault - tolerant issues , such as unreliable agents or networks with possibly faulty components .            c.  ambhl .",
    "an optimal bound for the mst algorithm to compute energy efficient broadcast trees in wireless networks . in _ proceedings of the international colloquium on automata , languages , and programming ( icalp ) _ , volume 3580 of _ lecture notes in computer science _ , pages 11391150 , 2005 .",
    "m.  bender and d.  slonim .",
    "the power of team exploration : two robots can learn unlabeled directed graphs . in _ proceedings of the 35th annual symposium on foundations of computer science ( focs ) _ , pages 7585 , 1994 .",
    "m.  cieliebak , p.  flocchini , g.  prencipe , and n.  santoro . solving the robots gathering problem . in",
    "_ proceedings of the international colloquium of automata , languages and programming ( icalp ) _ , volume 2719 of _ lecture notes in computer science _ , pages 11811196 .",
    "springer berlin heidelberg , 2003 .",
    "a.  cord - landwehr , b.  degener , m.  fischer , m.  hllmann , b.  kempkes , a.  klaas , p.  kling , s.  kurras , m.  mrtens , f.  meyer auf  der heide , c.  raupach , k.  swierkot , d.  warner , c.  weddemann , and d.  wonisch . a new approach for analyzing convergence algorithms for mobile robots . in l.",
    "aceto , m.  henzinger , and j.  sgall , editors , in _ proceedings of the international colloquium of automata , languages and programming ( icalp ) _ , volume 6756 of _ lecture notes in computer science _ , pages 650661 , 2011 .",
    "s.  das , p.  flocchini , n.  santoro , and m.  yamashita . on the computational power of oblivious robots",
    ": forming a series of geometric patterns . in _ proceedings of the 29th acm sigact - sigops symposium on principles of distributed computing ( podc ) _ , pages 267276 , 2010 .",
    "m.  dynia , m.  korzeniowski , and c.  schindelhauer .",
    "power - aware collective tree exploration . in _ architecture of computing systems ( arcs )",
    "_ , volume 3894 of _ lecture notes in computer science _ , pages 341351 , 2006 .",
    "b.  krishnamachari , d.  estrin , and s.  wicker . the impact of data aggregation in wireless sensor networks . in _ proceedings of the 22nd international conference on distributed computing systems workshops",
    "_ , pages 575578 , 2002 ."
  ],
  "abstract_text": [
    "<S> a set of identical , mobile agents is deployed in a weighted network . </S>",
    "<S> each agent has a battery  a power source allowing it to move along network edges . </S>",
    "<S> an agent uses its battery proportionally to the distance traveled . </S>",
    "<S> we consider two tasks : _ convergecast _ , in which at the beginning , each agent has some initial piece of information , and information of all agents has to be collected by some agent ; and _ broadcast _ in which information of one specified agent has to be made available to all other agents . in both tasks , the agents exchange the currently possessed information when they meet .    </S>",
    "<S> the objective of this paper is to investigate what is the minimal value of power , initially available to all agents , so that convergecast or broadcast can be achieved . </S>",
    "<S> we study this question in the centralized and the distributed settings . in the centralized setting </S>",
    "<S> , there is a central monitor that schedules the moves of all agents . in </S>",
    "<S> the distributed setting every agent has to perform an algorithm being unaware of the network .    in the centralized setting , </S>",
    "<S> we give a linear - time algorithm to compute the optimal battery power and the strategy using it , both for convergecastand for broadcast , when agents are on the line . </S>",
    "<S> we also show that finding the optimal battery power for convergecastor for broadcastis np - hard for the class of trees . on the other hand </S>",
    "<S> , we give a polynomial algorithm that finds a 2-approximation for convergecastand a 4-approximation for broadcast , for arbitrary graphs .    in </S>",
    "<S> the distributed setting , we give a 2-competitive algorithm for convergecast in trees and a 4-competitive algorithm for broadcastin trees . </S>",
    "<S> the competitive ratio of 2 is proved to be the best for the problem of convergecast , even if we only consider line networks . </S>",
    "<S> indeed , we show that there is no ( @xmath0)-competitive algorithm for convergecastor for broadcastin the class of lines , for any @xmath1 . </S>"
  ]
}