{
  "article_text": [
    "parametric real - time systems arise in a natural way in a wide range of applications , including controllers for systems of cars , trains , and planes .",
    "since many such systems are safety - critical , there is great interest in methods for ensuring that they are safe . in order to verify such systems",
    ", one needs ( i ) suitable formalizations and ( ii ) efficient verification techniques . in this paper",
    ", we analyze both aspects . our main focus throughout",
    "the paper will be on reducing complexity by exploiting modularity at various levels : in the specification , in verification , and also structurally .",
    "the main contributions of the paper are :    * we exploit modularity at the specification level . in sect .",
    "[ sec : modularspecifications ] , we use the modular language csp - oz - dc ( cod ) , which allows us to separately specify processes ( as communicating sequential processes , csp ) , data ( using object - z , oz ) and time ( using the duration calculus , dc ) . * we exploit modularity in verification ( sect .",
    "[ sec : verification ] ) . * * first , we consider transition constraint systems ( tcss ) that can be automatically obtained from the cod specification , and address verification tasks such as invariant checking .",
    "we show that for pointer data structures , we can obtain decision procedures for these verification tasks . * * then we analyze situations in which the use of cod specifications allows us to decouple verification tasks concerning data ( oz ) from verification tasks concerning durations ( dc ) . for systems with a parametric number of components ,",
    "this allows us to impose ( and verify ) conditions on the single components which guarantee safety of the overall complex system .",
    "* we also use modularity at a structural level . in sect .",
    "[ sec : complextopologies ] , we use results from @xcite to obtain possibilities for modular verification of systems with complex topologies by decomposing them into subsystems with simpler topologies . *",
    "we describe a tool chain which translates a graphical uml version of the csp - oz - dc specification into tcss , and automatically verifies the specification using our prover h - pilotand other existing tools ( sect .",
    "[ sec : tools ] ) .",
    "* we illustrate the ideas on a running example taken from the european train control system standard ( a system with a complex topology and a parametric number of components  modeled using pointer data structures and parametric constraints ) , and present a way of fully automatizing verification ( for given safety invariants ) using our tool chain",
    ".    * related work .",
    "* model - based development and verification of railway control systems with a complex track topology are analyzed in @xcite .",
    "the systems are described in a domain - specific language and translated into systemc code that is verified using bounded model checking .",
    "neither verification of systems with a parametric number of components nor pointer structures are examined there .    in existing work on the verification of parametric systems often only few aspects of parametricity",
    "are studied together .",
    "@xcite addresses the verification of temporal properties for hybrid systems ( in particular also fragments of the etcs as case study ) but only supports parametricity in the data domain .",
    "@xcite presents a method for the verification of a parametric number of timed automata with real - valued clocks , while in @xcite only finite - state processes are considered . in @xcite , regular model checking for a parametric number of homogeneous linear processes and systems operating on queues or stacks is presented .",
    "there is also work on the analysis of safety properties for parametrized systems with an arbitrary number of processes operating on unbounded integer variables @xcite .",
    "in contrast to ours , these methods sacrifice completeness by using either an over - approximation of the transition relation or abstractions of the state space .",
    "we , on the other hand , offer complete methods ( based on decision procedures for data structures ) for problems such as invariant checking and bounded model checking .",
    "* motivating example . * [ sec : illustration ] consider a system of trains on a complex track topology as depicted in fig .",
    "[ fig : tracktopology ] , and a radio block center ( rbc ) that has information about track segments and trains , like e.g. length , occupying train and allowed maximal speed for segments , and current position , segment and speed for trains",
    ". we will show under which situations safety of the system with complex track topology is a consequence of safety of systems with linear track topology .",
    "such modular verification possibilities allow us to consider the verification of a simplified version of this example , consisting of a _ linear track _ ( representing a concrete route in the track topology ) , on which trains are allowed to enter or leave at given points .",
    "we model a general rbc controller for an area with a linear track topology and an arbitrary number of trains . for this",
    ", we use a theory of pointers with sorts @xmath0 ( for trains ; next@xmath1 returns the next train on the track ) and @xmath2 ( for segments ; with next@xmath3 , prev@xmath3 describing the next / previous segment on the linear track ) . the link between trains and segments is described by appropriate functions @xmath4 and @xmath5 ( cf .",
    "[ fig : simple - track ] ) .",
    "[ fig : simple - track ]    in addition , we integrated a simple timed train controller @xmath6 into the model .",
    "this allowed us to certify that certain preconditions for the verification of the rbc are met by every train which satisfies the specification of @xmath6 , by reasoning on the timed and the untimed part of the system independently .",
    "we start by presenting the specification language csp - oz - dc ( cod ) @xcite which allows us to present in a modular way the control flow , data changes , and timing aspects of the systems we want to verify .",
    "we use _ communicating sequential processes _ ( csp ) to specify the control flow of a system using processes over events ; _ object - z _ ( oz ) for describing the state space and its change , and the _ duration calculus _ ( dc ) for modeling ( dense ) real - time constraints over durations of events .",
    "the operational semantics of cod is defined in @xcite in terms of a timed automata model . for details on csp - oz - dc and its semantics ,",
    "we refer to @xcite .",
    "our benefits from using codare twofold :    * codis compositional in the sense that it suffices to prove safety properties for the separate components to prove safety of the entire system @xcite .",
    "this makes it possible to use different verification techniques for different parts of the specification , e.g. for control structure and timing properties .",
    "* we benefit from high - level tool support given by syspect , a uml editor for a dedicated uml profile @xcite proposed to formally model real - time systems .",
    "it has a semantics in terms of cod .",
    "thus , syspectserves as an easy - to - use front - end to formal real - time specifications , with a graphical user interface .      to illustrate the ideas , we present some aspects of the case study mentioned in sect .  [",
    "sec : illustration ] ( the full case study is presented in @xcite ) .",
    "we exploit the benefits of cod in ( i ) the specification of a complex rbc controller ; ( ii ) the specification of a controller for individual trains ; and ( iii ) composing such specifications .",
    "even though space does not allow us to present all details , we present aspects of the example which can not be considered with other formalisms , and show how to cope in a natural way with parametricity .    * csp part . * the processes and their interdependency is specified using the csp specification language .",
    "the rbc system passes repeatedly through four phases , modeled by events with corresponding codschemata @xmath7 ( _ speed update _ ) , @xmath8 ( _ request update _ ) , @xmath9 ( _ allocation update _ ) , and @xmath10 ( _ position update _ ) .",
    "0=1=spread -10__csp : _ _    the _ speed update _ models the fact that every train chooses its speed according to its knowledge about itself and its track segment as well as the next track segment",
    ". the _ request update _ models how trains send a request for permission to enter the next segment when they come close to the end of their current segment .",
    "the _ allocation update _ models how the rbc may either grant these requests by allocating track segments to trains that have made a request , or allocate segments to trains that are not currently on the route and want to enter .",
    "the _ position update _ models how all trains report their current positions to the rbc , which in turn de - allocates segments that have been left and gives movement authorities to the trains . between any of these four updates , we can have trains _ leaving _ or _ entering _ the track at specific segments using the events @xmath11 and @xmath12 .",
    "the effects of these updates are defined in the oz part .",
    "* oz part . *",
    "the oz part of the specification consists of data classes , axioms , the schema , and update rules .",
    "* data classes . *",
    "the data classes declare function symbols that can change their values during runs of the system , and are used in the oz part of the specification .",
    "* axioms . *",
    "the axiomatic part defines properties of the data structures and system parameters which do not change during an execution of the system : @xmath13 ( the global maximum speed ) , @xmath14 ( the maximum deceleration of trains ) , @xmath15 ( a safety distance between trains ) , and @xmath16 ( mapping the speed of a train to a safe approximation of the corresponding braking distance ) .",
    "we specify properties of those parameters , among which an important one is @xmath17 stating that the safety distance @xmath18 to the end of the segment is greater than the braking distance of a train at maximal speed @xmath19 plus a further safety margin ( distance for driving @xmath20 time units at speed @xmath19 ) . furthermore",
    ", unique , non - negative ids for trains ( sort @xmath21 ) and track segments ( sort @xmath22 ) are defined .",
    "the route is modeled as a doubly - linked list of track segments , where every segment has additional properties specified by the constraints in the state schema .",
    "r.5    e.g. , @xmath23 is increasing along the @xmath24 pointer , the @xmath25 of a segment is bounded from below in terms of @xmath18 and @xmath26 , and the difference between local maximal speeds on neighboring segments is bounded by @xmath27 .",
    "finally , we have a function @xmath28 , the value of which is either a train which wants to enter the given segment from outside the current route , or @xmath29 if there is no such train .",
    "although the valuation of @xmath28 can change during an execution , we consider the constraint ( * ) as a property of our environment that always holds . apart from that ,",
    "incoming may change arbitrarily and is not explicitly updated .",
    "note that @xmath21 and @xmath22 are pointer sorts with a special null element ( @xmath29 and @xmath30 , respectively ) , and all constraints implicitly only hold for non - null elements .",
    "so , constraint ( * ) actually means    r.5    * init schema . *",
    "the _ init schema _ describes the initial state of the system .",
    "it essentially states that trains are arranged in a doubly - linked list , that all trains are initially placed correctly on the track segments and that all trains respect their speed limits",
    ".    * update rules .",
    "* updates of the state space , that are executed when the corresponding event from the csp part is performed , are specified with _",
    "effect schemata_. the schema for @xmath7 , for instance , consists of three rules , distinguishing ( i ) trains whose distance to the end of the segment is greater than the safety distance @xmath18 ( the first two lines of the constraint ) , ( ii ) trains that are beyond the safety distance near the end of the segment , and for which the next segment is allocated , and ( iii ) trains that are near the end of the segment without an allocation . in case ( i ) , the train can choose an arbitrary speed below the maximal speed of the current segment . in case ( ii ) , the train needs to brake if the speed limit of the next segment is below the current limit . in case ( iii ) , the train needs to brake such that it safely stops before reaching the end of the segment .",
    "updspd ( spd ) + t : train | pos ( t ) < length ( segm ( t ) ) - d spd ( t ) - decmax t > 0 + @ \\{0 , spd ( t ) - decmax t } spd ( t ) lmax ( segm ( t ) ) + t : train | pos ( t ) length ( segm ( t ) ) - d alloc ( nexts ( segm ( t ) ) ) = tid ( t ) + @ \\{0 , spd ( t ) - decmax t } spd ( t ) \\{lmax ( segm ( t ) ) , lmax ( nexts ( segm ( t ) ) ) } + t : train | pos ( t ) length ( segm ( t ) ) - d alloc ( nexts ( segm ( t ) ) ) = tid ( t ) + @ spd ( t ) = \\{0 , spd ( t ) - decmax t }    * timed train controller . * +    r7.2 cm    = [ rectangle , draw = black , fill = white , thick , inner sep=2 mm ] = [ > = latex , semithick,- > , auto ] = [ sdt , minimum width=2cm , node distance=3 cm ]    node[strb , label=[yshift=2mm]right:@xmath31 ( trn ) train node[strb , right of = trn , label=[yshift=2mm]left:1 ] ( rbc ) rbc node[sdt , minimum width=5 cm , node distance=1.2 cm ] ( env ) at ( [ xshift=1.5cm , yshift=-1.2cm]trn.mid |- rbc.mid ) environment ;    ( trn ) edge node[anchor = north ] node[anchor = south ] ( rbc ) ( rbc ) edge ( rbc ) ( trn ) edge node node[anchor = north east ] 1 node[anchor = south east ] 1 ( trn    node[anchor = south east ] 1 ( rbc |- env.north ) ;    node[sdt , inner sep=.8 mm ] ( tdt ) at ( [ xshift=4mm , yshift=-.9mm]rbc.north east ) traindata node[sdt , inner sep=.8 mm ] ( sdt ) at ( [ xshift=4mm , yshift=.9mm]rbc.south east ) segmentdata ;    ( [ yshift=1.5 mm ] rbc.east ) edge ( [ yshift=1.5 mm ] tdt.west |- rbc.east ) ( [ yshift=-1.5mm]rbc.east ) edge ( [ yshift=-1.5mm]sdt.west |- rbc.east ) ;    in the dc part of a specification , real - time constraints are specified : a second , timed controller train ( for one train only ) interacts with the rbc controller , which is presented in the overview of the case study in fig .",
    "[ fig : classes ] .",
    "the train controller train consists of three timed components running in parallel .",
    "the first updates the train s position .",
    "this component contains e.g.  the dc formula @xmath32 that specifies a lower time bound @xmath20 on @xmath10 events .",
    "the second component checks periodically whether the train is beyond the safety distance to the end of the segment",
    ". then , it starts braking within a short reaction time .",
    "the third component requests an extension of the movement authority from the rbc , which may be granted or rejected .",
    "the full train controller can be found in @xcite .",
    "in this section , we combine two approaches for the verification of safety properties of cod specifications :    * we introduce the invariant checking approach and present decidability results for local theory extensions that imply decidability of the invariant checking problem for a large class of parameterized systems . *",
    "we illustrate how we can combine this invariant checking for the rbc specification with a method for model checking of real - time properties ( introduced in @xcite ) for the cod specification for a single train train .",
    "formally , our approach works on a _ transition constraint system _ ( tcs ) obtained from the cod specification by an automatic translation ( see @xcite ) which is guaranteed to capture the defined semantics of cod ( as defined in @xcite ) .",
    "the tuple @xmath33 is a _ transition constraint system _ , which specifies : the variables ( @xmath34 ) and function symbols ( @xmath35 ) whose values may change over time ; a formula @xmath36 specifying the properties of initial states ; and a formula @xmath37 which specifies the transition relation in terms of the values of variables @xmath38 and function symbols @xmath39 before a transition and their values ( denoted @xmath40 , @xmath41 ) after the transition .",
    "in addition to the tcs , we obtain a _ background theory _",
    "@xmath42 from the specification , describing properties of the used data structures and system parameters that do not change over time .",
    "typically , @xmath43 consists of a family of standard theories ( like the theory of real numbers ) , axiomatizations for data structures , and constraints on system parameters . in what follows @xmath44 denotes logical entailment and means that every model of the theory @xmath42 which is a model of @xmath45 is also a model for @xmath46 .",
    "we denote false by @xmath47 , so @xmath48 means that @xmath45 is unsatisfiable w.r.t . @xmath42 .",
    "we consider the problem of _ invariant checking _ of safety properties . to show that a safety property , represented as a formula @xmath49 ,",
    "is an invariant of a tcs @xmath50 ( for a given background theory @xmath42 ) , we need to identify an _ inductive invariant _",
    "@xmath51 which strengthens @xmath52 , i.e. , we need to prove that    * @xmath53 , * @xmath54 , and * @xmath55 , where @xmath56 results from @xmath51 by replacing each @xmath57 by @xmath40 and each @xmath39 by @xmath58    if @xmath59 and @xmath37 belong to a class of formulae for which the entailment problems w.r.t .",
    "@xmath42 above are decidable then the problem of checking that @xmath51 is an invariant of @xmath50 ( resp .",
    "@xmath50 satisfies the property @xmath49 ) is decidable .",
    "we use this result in a verification - design loop as follows : we start from a specification written in cod .",
    "we use a translation to tcs and check whether a certain formula @xmath60 ( usually a safety property ) is an inductive invariant .",
    "\\(i ) if invariance can be proved , safety of the system is guaranteed .",
    "\\(ii ) if invariance can not be proved , we have the following possibilities :    * use a specialized prover to construct a counterexample ( model in which the property @xmath60 is not an invariant ) which can be used to find errors in the specification and/or to strengthen the invariant . * using results in @xcite we can often derive additional ( weakest ) constraints on the parameters which guarantee that @xmath61 is an invariant .",
    "of course , the decidability results for the theories used in the description of a system can be also used for checking consistency of the specification .    if a tcs models a system with a parametric number of components , the formulae in problems ( 1)(3 ) may contain universal quantifiers ( to describe properties of all components ) , hence standard smt methods  which are only complete for ground formulae ",
    "do not yield decision procedures .",
    "in particular , for ( ii)(1,2 ) and for consistency checks we need possibilities of reliably detecting satisfiability of sets of universally quantified formulae for which standard smt solvers can not be used .",
    "we now present situations in which this is possible .",
    "we identify classes of theories for which invariant checking ( and bounded model checking ) is decidable .",
    "let @xmath62 be a theory with signature @xmath63 , where @xmath64 is a set of sorts , and @xmath65 and @xmath66 are sets of function resp .",
    "predicate symbols .",
    "we consider extensions of @xmath62 with new function symbols in a set @xmath35 , whose properties are axiomatized by a set @xmath67 of clauses .",
    "* local theory extensions .",
    "* we are interested in theory extensions in which for every set @xmath68 of ground clauses we can effectively determine a finite ( preferably small ) set of instances of the axioms @xmath67 sufficient for checking satisfiability of @xmath68 without loss of completeness .",
    "if @xmath68 is a set of @xmath69-clauses ( where @xmath69 is the extension of @xmath70 with constants in a set @xmath71 ) , we denote by @xmath72 the set of ground terms starting with a @xmath35-function symbol occurring in @xmath67 or @xmath68 , and by @xmath73 $ ] the set of instances of @xmath67 in which the terms starting with @xmath35-functions are in @xmath72 .",
    "@xmath74 is a _",
    "local extension _ of @xmath62 @xcite if the following condition holds :    [ cols= \" < , < \" , ]      + ( obtained on : amd64 , dual - core 2 ghz , 4 gb ram )    * experimental results . *",
    "[ sec : experimental - results ] table  [ tab : experiments ] gives experimental results for checking the rbc controller .",
    "the table lists execution times for the involved tools : ( sys ) contains the times needed by syspect and the pea toolkit to write the tcs , ( hpi ) the time of h - pilotto compute the reduction and to check satisfiability with yices as back - end , ( yic ) the time of yices to check the proof tasks without reductions by h - pilot . due to some semantics - preserving transformations during the translation process",
    "the resulting tcs consists of 46 transitions .",
    "since our invariant @xmath75 is too complex to be handled by the clausifier of h - pilot , we check the invariant for every transition in two parts yielding 92 proof obligations .",
    "in addition , results for the most extensive proof obligation are stated : one part of the speed update .",
    "further , we performed tests to ensure that the specifications are consistent .",
    "the table shows that the time to compute the tcs is insignificant and that the overall time to verify all transition updates with yices and h - pilotdoes not differ much . on the speed update h",
    "- pilotwas 5 times faster than yices alone . during the development of the case",
    "study h - pilothelped us finding the correct transition invariants by providing models for satisfiable transitions .",
    "the table lists our tests with the verification of condition ( safe ) , which is not inductive over all transitions ( cf .",
    "[ sec : verification ] ) : here , h - pilotwas able to provide a model after 8s whereas yices detected unsatisfiability for 17 problems , returned `` unknown '' for 28 , and timed out once ( listed as ( t.o ) in the table ) . for the consistency check h - pilotwas able to provide a model after 3s , whereas yices answered `` unknown '' ( listed as ( u ) ) .",
    "in addition , we used armc to verify the property @xmath76 of the timed train controller",
    ". the full tcs for this proof tasks comprises 8 parallel components , more than 3300 transitions , and 28 real - valued variables and clocks ( so it is an infinite state system ) .",
    "for this reason , the verification took 26 hours ( on a standard desktop computer ) .",
    "we augmented existing techniques for the verification of real - time systems to cope with rich data structures like pointer structures .",
    "we identified a decidable fragment of the theory of pointers , and used it to model systems of trains on linear tracks with incoming and outgoing trains .",
    "we then proved that certain types of complex track systems can be decomposed into linear tracks , and that proving safety of train controllers for such complex systems can be reduced to proving safety of controllers for linear tracks .",
    "we implemented our approach in a new tool chain taking high - level specifications in terms of cod as input . to uniformly specify processes , data and time , @xcite use similar combined specification formalisms .",
    "we preferred cod due to its strict separation of control , data , and time , and its compositionality ( cf .",
    "[ sec : modularspecifications ] ) , which is essential for automatic verification .",
    "there is also sophisticated tool support given by syspectand the pea toolkit . using this tool chain we automatically verified safety properties of a complex case study , closing the gap between a formal high - level language and the proposed verification method for tcs .",
    "we plan to extend the case study to also consider emergency messages ( like in @xcite ) , possibly coupled with updates in the track topology , or updates of priorities .",
    "concerning the track topology , we are experimenting with more complex axiomatizations ( e.g.  for connectedness properties ) that are not in the pointer fragment presented in sect .",
    "[ sect : local ] ; we already proved various locality results .",
    "we also plan to study possibilities of automated invariant generation in such parametric systems .",
    "* acknowledgments . * many thanks to werner damm , ernst - rdiger olderog and the anonymous referees for their helpful comments .",
    "abdulla , p.a . , jonsson , b. : verifying networks of timed processes . in : steffen , b. ( ed . )",
    "lncs , vol . 1384 , pp .",
    "springer , heidelberg ( 1998 ) abdulla , p.a . , jonsson , b. , nilsson , m. , saksena , m. : a survey of regular model checking . in : gardner ,",
    "p. , yoshida , n. ( eds . ) concur04 .",
    "lncs , vol . 3170 , pp .",
    "springer , heidelberg ( 2004 )      arons , t. , pnueli , a. , ruah , s. , xu , j. , zuck , l.d .",
    ": parameterized verification with automatically computed inductive assertions . in : berry , g. , comon , h. , finkel , a. ( eds . ) cav01 .",
    "lncs , vol .",
    ". 221234 .",
    "springer , heidelberg ( 2001 )      clarke , e.m . , talupur , m. , veith , h. : environment abstraction for parameterized verification . in : emerson ,",
    "namjoshi , k.s .",
    "lncs , vol . 3855 , pp .",
    "springer , heidelberg ( 2006 )    faber , j. , ihlemann , c. , jacobs , s. , sofronie - stokkermans , v. : automatic verification of parametric specifications with complex topologies .",
    "reports of sfb / tr 14 avacs no .",
    "66 , sfb / tr 14 avacs ( 2010 ) , www.avacs.org    faber , j. , jacobs , s. , sofronie - stokkermans , v. : verifying csp - oz - dc specifications with complex data types and timing parameters . in : davies , j. , gibbons , j. ( eds . ) ifm07 .",
    "lncs , vol . 4591 , pp .",
    "springer , heidelberg ( 2007 )    haxthausen , a.e . ,",
    "peleska , j. : a domain - oriented , model - based approach for construction and verification of railway control systems . in : jones , c.b . , liu , z. , woodcock , j. ( eds . ) formal methods and hybrid real - time systems .",
    "lncs , vol .",
    "4700 , pp .",
    "springer , heidelberg ( 2007 )                    meyer , r. , faber , j. , hoenicke , j. , rybalchenko , a. : model checking duration calculus : a practical approach .",
    "20(45 ) , 481505 ( 2008 ) mller , m. , olderog , e.r . , rasch , h. , wehrheim , h. : integrating a formal method into a software engineering process with uml and java .",
    "comput . 20 , 161204 ( 2008 )    platzer , a. , quesel , j.d .",
    ": european train control system : a case study in formal verification . in : breitman , k. ,",
    "cavalcanti , a. ( eds . ) icfem09 .",
    "lncs , vol .",
    "5885 , pp .",
    "springer , heidelberg ( 2009 )"
  ],
  "abstract_text": [
    "<S> the focus of this paper is on reducing the complexity in verification by exploiting modularity at various levels : in specification , in verification , and structurally . for specifications </S>",
    "<S> , we use the modular language csp - oz - dc , which allows us to decouple verification tasks concerning data from those concerning durations . at the verification level , we exploit modularity in theorem proving for rich data structures and use this for invariant checking . at the structural level , we analyze possibilities for modular verification of systems consisting of various components which interact . </S>",
    "<S> we illustrate these ideas by automatically verifying safety properties of a case study from the european train control system standard , which extends previous examples by comprising a complex track topology with lists of track segments and trains with different routes . </S>"
  ]
}