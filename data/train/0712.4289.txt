{
  "article_text": [
    "given a pair of 2d maps ( `` images '' ) @xmath0 and @xmath1 of some scalar quantity , with the second image taken slightly later than the first one , what is the 2-d flow field @xmath2 , v_y[x , y ] ) $ ] which , when applied to the scalar field in the first image , will most closely resemble the second image ?",
    "this definition of lct is not a precise one , and the lct technique incorporates no physical conservation laws .",
    "schuck ( 2005 ) showed that lct methods are more consistent with an advection equation , rather than a continuity equation . here , we acknowledge these shortcomings and forge ahead , noting that lct results must be interpreted carefully .    in solar physics , the idea for lct is generally attributed to november and simon ( 1988 ) . in the engineering literature ,",
    "the problem is known as the `` optical flow '' problem ( see schuck [ 2006 ] and references therein ) . here , we present the technique behind the recently upgraded fourier lct ( flct ) method , first described in welsch , fisher , & abbett ( 2004 ) .",
    "to construct a 2d velocity field that connects two images @xmath3 and @xmath4 taken at two different times @xmath5 and @xmath6 , one must start from some given location within both images , compute a velocity vector , and then repeat the calculation while varying that location over all pixel positions .",
    "this involves three high - level operations : ( 1 ) windowing the input images to isolate the neighborhood around the pixel of interest ; ( 2 ) computing the correlation function between the two images ; and ( 3 ) locating the peak of the cross correlation function .    for each pixel",
    "at which a velocity is to be computed , a windowing function is used to de - emphasize parts of the image far away from that pixel .",
    "flct does this localization by multiplying each of the two images by a gaussian of width @xmath7 , centered at pixel location @xmath8 .",
    "we denote the resulting images as `` sub - images '' @xmath9 and @xmath10 .",
    "the expressions for @xmath9 and @xmath10 are : @xmath11 ^ 2 / \\sigma^2 }   \\nonumber \\\\ s_2^{(i , j)}(x , y ) & = & i_2(x , y ) e^{-[(x - x_i ) ^2+(y - y_j ) ] ^2 / \\sigma^2 }   ~. \\label{eqn : subimages } \\end{aligned}\\ ] ]    the quantity @xmath7 is a free parameter in flct , and its optimal value changes depending on the nature of the image and the size scales present in the velocity field . as discussed in welsch _",
    "et al . _  ( 2007 ) , one way to choose the optimal @xmath7 for a given application is to select the @xmath7 that statistically minimizes the difference between the final image and the advected initial image , @xmath12    for the @xmath13th pixel , the cross - correlation function of sub - image 1 with sub - image 2 is defined by @xmath14    we want to find , for each pair of sub - images @xmath9 and @xmath10 centered at position @xmath15 , the shifts @xmath16 and @xmath17 that maximize @xmath18 .",
    "the amplitude of the shifts , divided by the time @xmath19 between images 1 and 2 defines the velocity determined by flct : @xmath20 , and @xmath21 .",
    "flct uses the convolution theorem to compute @xmath22 using fourier transforms .",
    "if we write @xmath23 and , @xmath24 where @xmath25 denotes fourier transform , then the above equation can be written @xmath26 where @xmath27 denotes the inverse fourier transform .",
    "we sometimes find it useful to perform a low - pass gaussian filter on the functions @xmath28 and @xmath29 before applying equation ( [ eqn : convol ] ) if the original images are noisy .",
    "other researchers have used different cross - correlation functions ; some calculate the correlation in @xmath30-space , e.g. , november and simon ( 1988 ) .",
    "next , we must find the peak of the cross - correlation function .",
    "sub - pixel accuracy is required , as shifts are frequently substantially less than 0.1 pixel . as a practical matter",
    ", we find the peak of @xmath31 , rather than @xmath32 so that the operation does not involve complex arithmetic . for notational simplicity , we henceforth use @xmath30 for @xmath33 in the following discussion .",
    "previous versions of flct followed @xcite , and interpolated @xmath34 around its pixel - accuracy peak onto a finer grid , and took the location of the maximum of the resulting discretely sampled function as the shift .",
    "this approach , however , is only as accurate as the resolution of the interpolated grid , and is therefore computationally expensive  many unnecessary interpolations are required to reach the necessary spatial resolution .",
    "our current version employs a curve - fitting approach to find the peak in @xmath35 that was inspired by that of chae ( 2004 , private communication ; lct code written in idl ) .",
    "first , since the images and sub - images are computed at discrete points in space , we identify the pixel coordinates @xmath36 of the largest value of @xmath34 , denoting the largest value of @xmath34 as @xmath37 note that @xmath36 may not be equal to @xmath15 , if the location of the peak of @xmath35 has shifted by more than a pixel in @xmath38 or @xmath39 to find the peak to sub - pixel resolution , we then taylor - expand @xmath35 to 2nd order about the @xmath36 location , denoting the expansion as @xmath40 , @xmath41 where the partial derivatives are evaluated at the point @xmath42 .    at the peak , we require that the @xmath38 and @xmath43 partial derivatives of the taylor expansion @xmath40 vanish",
    ". these conditions result in a pair of linear equations which allow us to solve for the location @xmath44 of the peak : @xmath45 to evaluate the partial derivatives , we use standard , second - order finite difference expressions , assuming a uniform grid in the sub - images : @xmath46 the total shift in @xmath47 that corresponds to the peak in @xmath34 is then given by @xmath48 equations ( [ eqn : maxx ] ) through ( [ eqn : shifts ] ) thus provide a simple and accurate method for finding the peak of the cross- correlation function to sub - pixel resolution .",
    "our method requires two input images , @xmath49 and @xmath50 , recorded at times @xmath5 and @xmath51 .",
    "the algorithm then loops over all pixels in @xmath49 and @xmath50 for which @xmath52 , where @xmath53 is a user - set threshold .",
    "for each such pixel , it must :    1 .   compute sub - images @xmath9 and @xmath54 2 .",
    "compute fourier transforms of @xmath9 and @xmath10 , @xmath28 and @xmath55 3 .",
    "perform low - pass filters on @xmath28 , @xmath29 if needed .",
    "4 .   compute inverse fourier transform of @xmath56 .",
    "this is @xmath57 .",
    "compute the absolute value of @xmath58 .",
    "compute the shifts @xmath59 that maximize @xmath60 . 7 .",
    "compute velocities @xmath61    the flct code , which is currently called ` flct ` , was initially written in idl , but has since been re - written in c for portability and speed .",
    "flct also uses its own endian - independent binary input format for the images and for the output velocity arrays .",
    "flct uses the fftw library ( version 3 ) for computing the fast - fourier transforms needed to compute the cross - correlation functions .",
    "we have written idl procedures which write the two images ` flct ` needs into an input file , and which read the flct output file , consisting of two - dimensional , floating point arrays of @xmath62 , and a mask array , @xmath63 equal to one in pixels with @xmath52 and zero elsewhere .",
    "these idl i / o utilities enable ` flct ` to be run easily from within an idl session .",
    "to compile the flct code , the only external library needed is the fftw3 library .",
    "to download a copy of the flct source code and compilation instructions , along with idl i / o procedures , go to our web site .",
    "be sure to get the c version ( not the idl version ) , and get version ` test_13 ` or later .",
    "the ` flct ` is code invoked from the command - line  either a terminal window on a unix - like machine , from the command - prompt tool in ms windows , or from within an idl session using either a shell escape character or the spawn command . in all cases ,",
    "the syntax for flct is as follows :    ` flct infile outfile deltat deltas sigma -t thr -k kr -h -q ` + * required arguments : *    ` infile ` - contains 2 images for local correlation tracking . to create ` infile `",
    "use the idl procedure ` vcimage2out.pro `    ` outfile ` - contains output @xmath64 ( @xmath30 velocity and mask arrays ) .",
    "mask array is zero where velocity not computed . to read ` outfile ` , use the idl procedure ` vcimage3in.pro `    ` deltat ` - amount of time between images .    `",
    "deltas ` - units of length of the side of a single pixel ; velocity is computed in units of ` deltas / deltat ` .    ` sigma ` - sub - images are weighted by gaussian of width sigma .",
    "if sigma is set to 0 , only single values of shifts are returned as @xmath65 these values correspond to the overall shifts between the two images , and these values can be used to co - register the images if desired .",
    "* optional parameters : *    ` -t thr ` - determines threshold parameter @xmath53 .",
    "if @xmath66 in a pixel , then skip calculation of shifts for that pixel . for ` thr ` @xmath67 ` thr ` is assumed to be in relative units of the maximum absolute pixel value in @xmath68 . to force ` thr ` values between zero and unity to be in absolute units , append an a to ` thr ` .",
    "if calculation is skipped for a pixel , then the @xmath69 mask array is set to zero at that pixel location .",
    "it is otherwise set to 1 .    `",
    "-k kr ` - apply a low - pass filter to the sub - images , with a gaussian of a characteristic wavenumber that is a factor of @xmath70 times the largest possible wave numbers in @xmath30 directions .",
    "@xmath70 should be positive .",
    "( if @xmath71 , the unfiltered result should be recovered ) .",
    "this option is sometimes useful for datasets that contain noise at high spatial frequencies .",
    "test cases in which mdi quiet - sun magnetograms are shifted by 10 milli - pixels frequently result in a factor of two under - estimate by ` flct ` of the applied shift . by setting @xmath70 to numbers between 0.2 to 0.5 , the full applied shifts can be recovered .",
    "experimentation is recommended .    `",
    "-h ` - `` hires '' mode . set this flag to use cubic convolution interpolation of the @xmath35 function to re - grid it to higher resolution before finding shift .",
    "it is unclear that this interpolation improves accuracy .",
    "currently , this option seldom used , and may be dropped in the future .",
    "it has been retained for heritage .    ` -q ` - flag to suppress printing of all non - error messages .    from within idl",
    ", a simple demonstration of flct can be run using the following commands .",
    "+   + ` idl > f1=randomu(seed,101,101 ) ` + ` idl > f2=shift(f1,1,-1 ) ` + ` idl > vcimage2out , f1,f2,testin.dat ` + ` idl > $ flct testin.dat testout.dat 1 . 1 . 15 . `",
    "+ ` idl > vcimage3in , vx , vy , vm , testout.dat ` + ` idl >",
    "shade_surf , vx ` + ` idl >",
    "shade_surf , vy ` +",
    "how quickly does flct run ? on a 1.6 ghz pentium m ( laptop processor ) running ms windows xp , the flct code flct can process roughly 200 pixels per second for images with over 40,000 pixels ( time per pixel is much less than this for smaller images ) .",
    "the code is speeded up dramatically if the ` -t thr ` option is used , in which the velocity calculation is skipped if the image values are less than the chosen threshold .",
    "there are many avenues available for further speedup of the flct code .",
    "very little experimentation has been done with multiple threads thus far .",
    "an experimental version of flct written in fortran , using mpi has been tested on our linux cluster , _ grizzly _ , and the compute speed was found to scale almost perfectly with the number of processors .",
    "an mdi magnetogram of the quiet sun . by applying known shifts and rotations to such magnetograms",
    ", we can test the performance of flct.,width=528 ]",
    "figure [ fig : mdiqs ] shows an mdi @xcite magnetogram of the quiet sun .",
    "( for a discussion about applying tracking techniques like flct to magnetograms , see the paper welsch and fisher in this volume . ) to test the ability of flct to reconstruct rotations , we rotated the image , using cubic - convolution interpolation , by a fixed angle about the center of the image to generate a second image .",
    "the applied `` velocity field '' then corresponds to simple , solid - body rotation , with the speed increasing linearly with radius , @xmath72 , from image center .     a scatter plot of derived speeds versus input speeds , for an applied rotation of 1@xmath73 .",
    "the straight line shows the applied speed .",
    "there is no significant bias in the derived speed.,width=528 ]     a scatter plot of derived speeds versus input speeds , for an applied rotation of 0.01@xmath73 .",
    "the scatter is significant , and the derived speeds are biased on the low side as compared to the applied speeds.,width=528 ]    how well does flct recover the applied velocity field ? in figures [ fig:1deg ] and [ fig : hundeg ] , we show scatter plots of derived speeds versus input speeds for a rotations of 1@xmath73 and 0.01@xmath73 , respectively .",
    "units of velocity are in pixel widths per unit time .",
    "the straight lines show the applied speed , and the scatter plots show the inverted speeds for all inverted pixels ( only points with @xmath74 10 g were inverted ) . @xmath75",
    "15 pixels was assumed . for the 1@xmath73 rotation , the scatter is typically 0.1 - 0.2 , and there is no significant bias in the derived speed . for the 0.01@xmath73 rotation , the scatter is significant , and the derived speeds are biased on the low side as compared to the applied speeds . for the 1@xmath73 rotation ,",
    "the recovered rotation profile ( not shown ) accurately reproduces the imposed rotation profile .",
    "these and other tests suggest that flct can accurately recover shifts @xmath76 pixels , but smaller shifts can be problematic .",
    "what is the difference between the new ( upgraded ) flct code , described here , and that originally described in welsch _",
    "et al . _  ( 2004 ) ?",
    "the main difference is in how the location of the peak of the cross - correlation function is determined to sub - pixel resolution . the old version used cubic convolution interpolation to compute the cross - correlation function on a much finer grid ( 0.1 or 0.02 pixel spacing ) and then simply found the location of the largest value within the finer grid .",
    "we ( and other users ) found that this resulted in serious `` quantization '' errors when the time between images was small enough that shifts were of order 0.1 - 0.2 pixels or less .",
    "the new code uses equations ( [ eqn : derivs ] ) and ( [ eqn : shifts ] ) of this paper to find the location of the peak to sub - pixel resolution .",
    "we have found this to be more accurate , and more computationally efficient  and therefore much faster  than the old technique .",
    "we strongly recommend that users use the new version and not any of the old versions .",
    "scherrer , p. , bogart , r.  s. , bush , r.  i. , hoeksema , j.  t. , kosovichev , a. , schou , j. , rosenberg , w. , springer , l. , tarbell , t. , title , a. , wolfson , c. , zayer , i. , and the mdi team , 1995 , solar  phys .",
    "162 , 129 ."
  ],
  "abstract_text": [
    "<S> we describe the computational techniques employed in the recently updated fourier local correlation tracking ( flct ) method . </S>",
    "<S> the flct code is then evaluated using a series of simple , 2d , known flow patterns that test its accuracy and characterize its errors . </S>"
  ]
}