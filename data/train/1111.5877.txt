{
  "article_text": [
    "an _ @xmath0-step self - avoiding polygon _ ( sap ) @xmath1 on a regular lattice is a sequence of _ distinct _ vertices @xmath2 such that each vertex is a nearest neighbour of its predecessor and @xmath3 and @xmath4 are nearest - neighbours .",
    "sap are considered distinct up to translations of the starting point @xmath3 and orientation .",
    "the sap problem on regular lattices is one of the most important and classic combinatorial problems in statistical mechanics @xcite .",
    "sap are often considered in the context of lattice models of ring - polymers and vesicles @xcite .",
    "the fundamental problem is the calculation of the number of sap , @xmath5 , with @xmath0 steps .",
    "note that on the square lattice polygons have an _ even _ perimeter and @xmath6 for @xmath0 odd .",
    "as most interesting combinatorial problems , sap have exponential growth @xmath7,\\ ] ] where @xmath8 is the so - called connective constant , @xmath9 is a ( known ) universal critical exponent @xcite , and @xmath10 is a critical amplitude .",
    "when analysing the data it is often convenient to use the associated generating function @xmath11 this series has a singularity at the critical point @xmath12 with critical exponent @xmath13 .",
    "the enumeration of sap has a long and glorious history .",
    "suffice to say that early calculations were based on various direct counting algorithms of exponential complexity , with computing time @xmath14 growing asymptotically as @xmath15 , where @xmath16 , the connective constant for sap on the square lattice .",
    "enting @xcite was the first to produce a major breakthrough by applying transfer matrix ( tm ) methods to the enumeration of sap on finite lattices .",
    "this so - called finite lattice method ( flm ) led to a very significant reduction in complexity to @xmath17 , so @xmath18{3}=1.316\\ldots$ ] .",
    "more recently we @xcite refined the algorithm using the method of pruning and reduced the complexity to @xmath19 .",
    "an example of a sap on a @xmath20 rectangular piece of the square lattice .",
    "the dashed line shows a position of the tm boundary at a particular stage of the calculation . ]    all of the above tm algorithms are based on keeping track of the way partially constructed sap are connected to the left of a line bisecting the given finite lattice ( rectangles in the case of the square lattice ) . in this paper",
    "we take a new approach and instead keep track of how partially constructed sap must connect up to the right of the boundary line .",
    "the major gain is that it is now straightforward to calculate the number additional bonds required to complete a given partial sap , this in turn results in a substantially faster algorithm .",
    "the draw - back is that some updating rules become much more complicated .",
    "the basic idea can best be illustrated by considering the specific example of a sap given in figure  [ fig : sap ] .",
    "if we cut the sap by a vertical line ( the dashed line ) we see that the sap is broken into two pieces to the left and right of the cut - line .",
    "on _ either _ side of the line we are left with a set of partial loops .",
    "this means that at any stage a given configuration of occupied edges along the cut - line can be described in two ways .",
    "we can describe how the edges are connected in pairs forming loops to the left or right of the cut - line . moving from left to",
    "right we can in other words keep track of what happened in the past , that is how loops are connected to the left , or prescribe what must happen in the future , that is how edges are to be connected to the right of the cut - line so as to form a valid sap .",
    "one may think of the new flm method as taking an initial seed sap which must touch the left hand boundary of the enclosing rectangle .",
    "here there is a known part consisting of two edges to the left of the boundary line , and to the right of the boundary line a self - avoiding walk of known topology but unknown shape and length . as the boundary line is moved through the lattice the overall topology of the sap must be preserved , but the topology of the configuration on the right hand side of the boundary line may be deformed .",
    "the restriction in the extent to which the topology can be deformed is a consequence of the choice in updates for the boundary line , which for the square lattice only moves to enclose one additional vertex and two additional edges in each update .",
    "this picture of the new flm method is equally applicable to the enumeration of any lattice object with fixed topology , such as self - avoiding walks , theta graphs @xcite , or star polymers .",
    "all tm algorithms used to enumerate sap on the square lattice build on the pioneering work of enting @xcite who enumerated square lattice self - avoiding polygons using the finite lattice method .",
    "the first terms in the series for the polygon generating function can be calculated using transfer matrix techniques to count the number of polygons in rectangles @xmath21 vertices wide and @xmath22 vertices long . due to the symmetry of the square lattice one need only consider rectangles with @xmath23 .",
    "any polygon spanning such a rectangle has a perimeter of length at least @xmath24 . by adding the contributions from all rectangles of width @xmath25 (",
    "where the choice of @xmath26 depends on available computational resources ) and length @xmath27 , with contributions from rectangles with @xmath28 counted twice , the number of polygons per vertex of an infinite lattice is obtained correctly up to perimeter @xmath29 .       a snapshot of the boundary line ( dashed line ) during the transfer matrix calculation of type @xmath30 configurations on a strip of size @xmath31 .",
    "sap are enumerated by successive moves of the kink in the boundary line , as exemplified by the position given by the dotted line , so that one vertex and two edges at a time are added to the strip . to the left of the boundary line",
    "we have drawn an example of a partially completed sap . ]    the generating function for a rectangle is calculated using transfer matrix techniques .",
    "details of our previous algorithm can be found in @xcite and chapter 7 of @xcite .",
    "here we outline those aspects common to both algorithms that are needed to appreciate the differences .",
    "the most efficient implementation of the tm algorithm generally involves bisecting the finite lattice with a boundary and moving the boundary in such a way as to build up the lattice vertex by vertex as illustrated in figure  [ fig : transfer ] .",
    "if we draw a sap and then cut it by a line we observe that the partial sap to the left of this line consists of a number of loops connecting two edges ( we shall refer to these as loop - ends ) in the intersection .",
    "each end of a loop is assigned one of two labels depending on whether it is the lower or upper end of a loop .",
    "each configuration along the boundary line can thus be represented by a set of edge states @xmath32 , where    @xmath33    if we read from the bottom to the top , the configuration or signature @xmath34 along the intersection of the partial sap in figure  [ fig : transfer ] is @xmath35 . since crossings are not permitted this encoding uniquely",
    "describes how the loop - ends are connected .",
    "in applying the transfer matrix technique to the enumeration of polygons we regard them as sets of edges on the finite lattice with the properties :    * a weight @xmath36 is associated with each occupied edge . *",
    "all vertices are of degree 0 or 2 . *",
    "apart from isolated sites , the graph has a single connected component .",
    "* each graph must span the rectangle from left to right and from bottom to top .",
    "constraint ( 1 ) is trivial to satisfy .",
    "the sum over all contributing graphs ( valid sap ) is calculated as the boundary is moved through the lattice . for each configuration of occupied or empty edges along the intersection",
    "we maintain a generating function @xmath37 for partial polygons with signature @xmath34 .",
    "in exact enumeration studies @xmath37 is a truncated polynomial @xmath38 where @xmath36 is conjugate to the number of occupied edges . in a tm",
    "update each source signature @xmath34 ( before the boundary is moved ) gives rise to one or two new target signatures @xmath39 ( after the move of the boundary line ) and @xmath40 or 2 new edges are inserted leading to the update @xmath41 .",
    "constraint ( 2 ) is easy to satisfy .",
    "if both kink edges are empty we can leave both new edges empty or insert a partial new loop by occupying both of the new edges .",
    "if one of the kink edges is occupied then one of the new edges must also be occupied .",
    "if both of the kink edges are occupied both of the new edges must be empty .",
    "it is easy to see that these rules leads to graphs satisfying constraint ( 2 ) .",
    "three ways in which graphs with separate components could occur . ]",
    "constraint ( 3 ) is the most difficult to satisfy .",
    "we have shown some examples of two - component graphs in figure  [ fig : mulcomp ] .",
    "graphs of the type shown in the left - most panel , where separate components occur side by side , are quite easy to avoid by never allowing the insertion of a new loop into the totally empty configuration except for the initial seed state .",
    "this also ensures that all polygons touch the left - most border of the rectangle .",
    "there are only two distinct ways in which a pair of loops can be placed relative to one another ",
    "side by side or nested  as shown in the last two panels of figure  [ fig : mulcomp ] . with the loop encoding given above multiple components are avoided by not allowing two connected loop - ends to join _ except _ when no other loop - ends are present in which case a completed sap is formed .    in order to satisfy constraint ( 4 )",
    "we need to add more information to a signature .",
    "in addition to the usual labelling of the intersection with the boundary line we also have to indicate whether the partially completed polygon has reached neither , both , the lower , or the upper boundaries of the rectangle . in order",
    "to represent a given partial polygon we have to add a some information to the usual set of edge states @xmath42 .",
    "we add two extra ` virtual ' edge states @xmath43 and @xmath44 , where @xmath43 is 0 or 1 if the bottom of the rectangle has or has not been touched .",
    "similarly , @xmath44 is 0 or 1 if the top of rectangle has or has not been touched .",
    "most of the basic properties and considerations outlined in the previous section apply also to the new algorithm .",
    "a major difference is conceptual namely that as stated in section  [ sec : intro ] we change the way we keep track of the partial loops intersecting the boundary line .",
    "while we can use exactly the same encoding of a signature as ( [ eq : states ] ) the meaning of ` lower ' and ` upper ' loop - end is profoundly different . in the original algorithm these terms referred to partial loops connected to the left of the boundary , that is , to how the existing loops in the partially generated sap are already connected .",
    "however , in the new algorithm ` lower ' and ` upper ' loop - end refers to how occupied edges along the boundary must be connected via a loop at some later stage ( to the right of the boundary ) .",
    "this change in turn results in new updating rules for the cases where a new loop is inserted or two loop - ends join at the kink .",
    "we deal with the latter easier modification first .",
    "we can join two loop - ends at the boundary kink _ only _ if they belong to the same loop , thus closing a partial loop of the sap , since the loop encoding of new algorithm simply prescribes how occupied edges are to be connected .",
    "thus the only valid case is the kink - state ` 12 ' and all the other kink states ( ` 11 ' , ` 22 ' and ` 21 ' ) are forbidden since they would correspond to connecting occupied edges which should not have been connected .",
    "two situations arise when a partial loop is closed ; _ either _ there are other occupied edges along the boundary and one just proceeds with the calculation or all other edges are empty and a closed sap is formed and added to the running total for the sap generating function .",
    "the possible basic deformations to the topology of a boundary state as the boundary line is shifted are shown schematically above .",
    "the corresponding basic loop updates are shown immediately below . ]",
    "while edge - joining is simplified the insertion of a new loop becomes much more complicated . in the original approach",
    "the insertion was done and no further action was required . in the new approach",
    "we must connect the two new occupied edges to other occupied edges on the boundary line .",
    "the restrictions on sap enumeration mean that the two new occupied edges must connect to existing _ connected edges _",
    "provided these are reachable ( more on this later ) .",
    "the state of the new occupied edges will depend on their placement relative to the edges they become connected to , and the state of the existing occupied edges may change . in figure",
    "[ fig : basic ] we show the two basic situations : the new occupied edges are either placed inside the loop formed by the two existing connected edges or they are placed outside them . in the first case , shown to the left in figure  [ fig : basic ] , the upper ( lower ) end of the inserted loop must connect with the upper ( lower ) end of the existing loop , in terms of the edges involved the states change from ` 1002 ' to ` 1212 ' . in the second case , in the middle of the figure , the upper ( lower ) end of the inserted loop must connect with",
    "the lower ( upper ) end of the existing loop , in terms of the edges involved the states change from ` 1200 ' to ` 1122 ' .",
    "so _ both _ new occupied edges become ` lower ' loop - ends while the existing lower loop - end is changed to an upper loop - end .",
    "shown to the right in figure  [ fig : basic ] , there is also a symmetric case where the new loop is placed above the existing loop leading to the state change ` 0012 ' to ` 1122 ' .",
    "the newly inserted loop can connect to any existing loop that can be reached without crossing another loop .",
    "the general situation is illustrated in figure  [ fig : insert ] where we see that the new loop can be connected to three existing loops ( indicated by thick lines ) .",
    "the second loop to the right of the new loop is nested inside an existing loop and can therefore _ not _ be reached without crossing the enclosing loop .",
    "likewise any loops outside the large loop enclosing the new loop are unreachable .",
    "so in this case the insertion of a single new loop gives rise to three new loop configurations as illustrated in the top panels of figure  [ fig : insert ] .",
    "the states of the edges in the new loop configurations are obtained by applying the appropriate basic loop insertion from above .     the possible updates resulting from the insertion of a new partial loop into an existing loop configuration . at the bottom",
    "we indicate by a lower arc the new partial loop . in the existing loop configuration ( upper arcs )",
    "accessible loops are indicated with heavy lines .",
    "the three possible new loop configurations are shown on top . ]    at this stage it seems nothing has been gained .",
    "some updates simplify while loop - insertion becomes much more complicated .",
    "the true pay - off comes when we look to pruning . in the original approach pruning",
    "can be very complicated . with deeply nested configurations one simply has to search through all possible ways of connecting existing partial loops in order to find the connection pattern which minimises the number of extra edges required to form a valid sap .",
    "in the new approach this complication is completely gone since connections between edges is already prescribed : there is one and only one way of completing the sap !",
    "the principle behind pruning is quite simple and briefly works as follows .",
    "firstly , for each signature we keep track of the current minimum number of steps @xmath45 already inserted to the left of the boundary line in order to build up that particular configuration .",
    "secondly , we calculate the minimum number of additional steps @xmath46 required to produce a valid polygon .",
    "there are three contributions , namely the number of steps required to close the polygon , the number of steps needed ( if any ) to ensure that the polygon touches both the lower and upper border , and finally the number of steps needed ( if any ) to extend at least @xmath21 edges in the length - wise direction ( remember we only need rectangles with @xmath23 ) .",
    "if the sum @xmath47 we can discard the partial generating function for that configuration , and of course the configuration itself , because it will not make a contribution to the polygon count up to the perimeter lengths we are trying to obtain .",
    "for instance polygons spanning a rectangle with a width close to @xmath26 have to be almost convex , so very convoluted polygons are not possible .",
    "thus configurations with many loop - ends ( non - zero entries ) make no contribution at perimeter length @xmath48 .     examples of partially generated polygons ( thick solid lines ) to the left of the intersection ( dashed line ) and how to close them in a valid way ( thick wavy line ) .",
    "upper left panel shows how to close the configuration @xmath49 .",
    "the upper middle and right panels show the two possible closures of the configuration @xmath50 .",
    "the lower panels show the three possible closures of the configuration @xmath51 .",
    ", width=415 ]    the complicated part of the pruning approach is the algorithm to calculate the number of steps required to close the polygon . in the first stage",
    "we connect any separate pieces as illustrated in figure  [ fig : sapclose ] .",
    "separate pieces are easy to locate and ( provided one is not at the last edge in the configuration ) the top - most upper edge of one piece can be connected to the lower edge above",
    ". then @xmath52 is incremented by the number of steps ( the distance ) between the edges and the two edge - states are removed from the configuration before further processing . in the second stage",
    "we transform configurations starting ( ending ) as @xmath53 ( @xmath54 ) since the two lower ( upper ) edges can safely be connected .",
    "the two edge - states are removed from the configuration ",
    "leading to the new configuration @xmath55 ( @xmath56 )  before further processing .",
    "after these two stages we may be left with a configuration which has just a single lower edge and a single upper edge .",
    "we are almost done since these two edges can be connected to form a valid polygon .",
    "this is illustrated in figure  [ fig : sapclose ] where the upper left panel shows how to close the partial polygon with the intersection @xmath49 , which contain three separate pieces .",
    "after connecting these pieces we are left with the configuration @xmath57 .",
    "we now connect the two lower edges and note that the first upper edge is relabeled as a lower - edge ( it has become the new lower end of the loop ) .",
    "thus we get the configuration @xmath58 and we can now connect the remaining two edges and end up with a valid completed polygon .",
    "note that in the last two cases , in addition to the steps spanning the distance between the edges , an additional two horizontal steps had to be added in order to form a valid loop around the intervening edges .",
    "if the transformations above do not result in a closed polygon we must have a configuration of the form @xmath59 .",
    "the difficulty lies in finding the way to close such configurations with the smallest possible number of additional steps .",
    "suffice to say that if the number of non - zero entries is small one can easily code all possible valid ways of closing a polygon and thus find the minimum number of additional steps . in figure",
    "[ fig : sapclose ] we show all possible ways of closing polygons with 8 non - zero entries . note that we have shown the generic cases here .",
    "in actual cases there could be any number of empty edges interspersed in the configurations and this would determine which way of closing the sap would minimise @xmath52 .",
    "the number of distinct configurations are given by the catalan numbers so there is only 1 configuration with 6 occupied edges , while there are 2 with 8 occupied edges , and 5 with 10 occupied edges . in @xcite",
    "the various possible ways of closing all such configurations was hand - coded . in the more general case ( configurations with 12 or more non - empty entries ) we devised a basic search algorithm that simply tried all possible ways of closing loops .",
    "in practise initially two loop - ends are connected .",
    "the resulting new configuration is passed through the two stages above and we are left with a configuration with at least two fewer loop - ends . if there are still open loops we do another pass and so on until all loops have been closed .",
    "this process is then repeated but starting with a different pair of initial edges . in this way one can search through all possible ways of completing a sap .",
    "obviously one would expect that this process should ultimately grow exponentially with the number of non - zero edges .",
    "however , due to the simplifying feature of passing through the first two stages the growth is quite slow .    in the new approach",
    "almost all of the complications of pruning are gone . since",
    "connections between edges are already prescribed there is one and only one way of completing the sap !",
    "the only complicating factor is that in order to calculate @xmath52 we need to know the nesting level @xmath60 of each partial loop .",
    "the number of edges it takes to connect two loop - ends at positions @xmath61 and @xmath62 is simply @xmath63 .",
    "in addition we must connect to the lower and upper boundaries and ensure that the sap extends at least @xmath21 edges in the length - wise direction .",
    "this pruning procedure can be performed in @xmath64 operations .",
    "in analysing the complexity of the two algorithms , we note that the update step when the boundary is moved may result in @xmath65 signatures for the previous algorithm , and @xmath64 for the new one .",
    "however , in the average case we still expect the new algorithm to create @xmath65 signatures , because connections with distant loop - ends are typically pruned away .    for pruning , we believe that the complexity of the old algorithm is exponential in @xmath21 ( as we will see below , the growth constant is mercifully small for sap ) , whereas for the new algorithm the complexity is @xmath64 .    in table",
    "[ tab : algcomp ] we compare the resources used by the two algorithms in a calculation of the number of sap with perimeter up to @xmath66 . from this",
    "it is clear that the new approach is more efficient with substantial savings in time .",
    "the required number of configurations and terms go down very slightly while the total cpu time decrease by about 16% for @xmath67 .",
    "there is little variation in this for the listed values of @xmath66 . for higher values of @xmath66",
    "we expect to eventually see even more substantial savings in time .",
    "as @xmath66 increases more deeply nested configurations occur and these are more expensive to prune in the old algorithm .",
    "that we do not see an increasing time saving yet is testament to the special nature of square lattice sap making pruning particularly simple for this problem , and the effort put into the original implementation of pruning for this case .",
    "we mention in passing that a preliminary implementation for self - avoiding walks have yielded more substantial time savings of more than 60% for the square lattice .",
    ".[tab : algcomp ] a comparison of the resources required by the two algorithms in order to calculate the number of sap up to length @xmath66 . [ cols= \" > , > , > , > , > , > , > \" , ]     to gauge whether or not the estimates truly are as well converged as the results in table  [ tab : analysis ] would suggest we find it useful to plot the actual individual estimates against @xmath0 ( where @xmath5 is the last terms used to form a given differential approximant ) . in the first two panels of figure  [ fig : crpexp ] we have plotted the estimates for @xmath68 and @xmath13 as functions of @xmath0 .",
    "each point represents an estimate from a third order differential approximant .",
    "the approximants appear very well converged and given the very high resolution of the abscissa there is no sign of any significant systematic drift . finally , in the third panel we plotted the estimated for @xmath13 versus the corresponding estimates for @xmath68 .",
    "if the conjectures for the exact values are correct the estimates should ideally pass through the point of intersection between the conjectured values .",
    "clearly there is a very slight discrepancy here and for @xmath69 the ` biased ' estimate for the critical point is @xmath70 . since the difference only occurs in the @xmath71 significant digit we do not feel confident that the numerical evidence alone is sufficient to settle the matter .",
    "ultimately we will let the reader make their own judgement .",
    "estimates of the critical point @xmath68 and critical exponent @xmath13 versus @xmath0 ( left and middle panels ) and @xmath13 versus @xmath68 ( right panel ) for the square lattice polygon generating function .",
    "the straight lines correspond to @xmath69 and @xmath72 . ]",
    "estimates for the amplitude @xmath10 versus @xmath73 .",
    "each data set is obtained by fitting @xmath5 to the form ( ) using from 6 to 14 correction terms .",
    "the plot on the right is an enlarged version of the plot to the left . ]",
    "the detailed asymptotic form of the coefficients @xmath5 of the polygon generating function has been studied in detail previously @xcite . as argued in @xcite",
    "there is no sign of non - analytic corrections - to - scaling exponents to the polygon generating function and one therefore finds that @xmath74 estimates for the leading amplitude @xmath75 can thus be obtained by fitting @xmath5 to the form ( [ eq : sapasymp ] ) using increasing values of @xmath76 .",
    "it is useful to check the behaviour of the estimates by plotting the results for the leading amplitude versus @xmath73 ( see figure  [ fig : bampl ] ) , where @xmath5 is the last term used in the fitting , and @xmath0 is varied from 130 down to 50 .",
    "note that as more and more correction terms are added the estimates exhibits less curvature and the slope become less steep .",
    "this is very strong evidence that ( [ eq : sapasymp ] ) is indeed the correct asymptotic form of @xmath5 .",
    "we estimate that @xmath77 .",
    "we have implemented a new algorithm for the enumeration of sap on the square lattice ; the new method shows considerable promise for future enumeration studies .",
    "the new algorithm was used to extend the series for the number of sap on the square lattice from @xmath78 to @xmath79 .",
    "our analysis of the extended series yielded improved estimates of critical parameters : @xmath80 ( @xmath81 ) , @xmath82 , and @xmath77 .",
    "we expect that the new algorithm will prove to be widely applicable .",
    "we chose sap on the square lattice for this study because it is the simplest model for computer implementation and thus best for illustrating the basic principles involved and the differences between the old and new algorithms .",
    "the improvement in running time of some 15% while significant is unspectacular . however , we anticipate that the gains realised by the new algorithm will be greater for other lattices , and other models such as self - avoiding walks , theta graphs , and star polymers",
    ". it will be especially useful in situations where many candidate completions must be considered while pruning .",
    "this is certainly the case for three - dimensional lattices , for which the restrictions on crossing of nested loops do not exist , and we are hopeful that the new algorithm will allow for fast enumeration of three - dimensional lattice objects via the finite lattice method . in future , we will test this by implementing the new algorithm for sap and saw on the simple cubic lattice .",
    "this work was supported by an award under the merit allocation scheme on the nci national facility at the anu .",
    "nc was supported by the arc centre of excellence for mathematics and statistics of complex systems ( mascos ) .",
    "ij was supported under the australian research council s discovery projects funding scheme by the grant dp0770705 ."
  ],
  "abstract_text": [
    "<S> we present a new and more efficient implementation of transfer - matrix methods for exact enumerations of lattice objects . </S>",
    "<S> the new method is illustrated by an application to the enumeration of self - avoiding polygons on the square lattice . </S>",
    "<S> a detailed comparison with the previous best algorithm shows significant improvement in the running time of the algorithm . </S>",
    "<S> the new algorithm is used to extend the enumeration of polygons to length 130 from the previous record of 110 . </S>"
  ]
}