{
  "article_text": [
    "the recent growth in mobile and media - rich applications continuously increases the demand for wireless bandwidth , and puts a strain on wireless networks @xcite , @xcite .",
    "this dramatic increase in demand poses a challenge for current wireless networks , and calls for new network control mechanisms that make better use of scarce wireless resources .",
    "furthermore , most existing , especially low - cost , wireless devices have a relatively rigid architecture with limited processing power and energy storage capacities that are not compatible with the needs of existing theoretical network control algorithms .",
    "one important problem , and the focus of this paper , is that low - cost wireless interface cards are built using first - in , first - out ( fifo ) queueing structure , which is not compatible with the per - flow queueing requirements of the optimal network control schemes such as backpressure routing and sheduling @xcite .",
    "the backpressure routing and scheduling paradigm has emerged from the pioneering work @xcite , @xcite , which showed that , in wireless networks where nodes route and schedule packets based on queue backlogs , one can stabilize the queues for any feasible traffic .",
    "it has also been shown that backpressure can be combined with flow control to provide utility - optimal operation @xcite . yet",
    ", backpressure routing and scheduling require each node in the network to construct per - flow queues .",
    "the following example demonstrates the operation of backpressure .",
    "let us consider a canonical example in fig .",
    "[ fig : example_fifo_v1](a ) , where a transmitter node @xmath3 , and two receiver nodes @xmath4 , @xmath5 form a one - hop downlink topology .",
    "there are two flows with arrival rates @xmath6 and @xmath7 destined to nodes @xmath4 and @xmath5 , respectively .",
    "the throughput optimal backpressure scheduling scheme , also known as max - weight scheduling , assumes the availability of per - flow queues @xmath8 and @xmath9 as seen in fig .",
    "[ fig : example_fifo_v1](a ) , and makes a transmission decision at each transmission opportunity based on queue backlogs , _",
    "@xmath8 and @xmath9 .",
    "in particular , the max - weight scheduling algorithm determines @xmath10 , and transmits from queue @xmath11 .",
    "it was shown in @xcite , @xcite that if the arrival rates @xmath6 and @xmath7 are inside the stability region of the wireless network , the max - weight scheduling algorithm stabilizes the queues .",
    "on the other hand , in some devices , per - flow queues can not be constructed . in such a scenario , a fifo queue ,",
    "say @xmath12 is shared by flows @xmath4 and @xmath5 as shown in fig .",
    "[ fig : example_fifo_v1](b ) , and the packets are served from @xmath12 in a fifo manner .",
    "@xmath13    constructing per - flow queues may not be feasible in some devices especially at the link layer due to rigid architecture , and one fifo queue is usually shared by multiple flows .",
    "for example , although current wifi - based devices have more than one hardware queue @xcite , their numbers are restricted ( up to 12 queues according to the list in @xcite ) , while the number of flows passing through a wireless device could be significantly higher .",
    "also , multiple queues in the wireless devices are mainly constructed for prioritized traffic such as voice , video , etc .",
    ", which further limits their usage as per - flow queues .",
    "on the other hand , constructing per - flow queues may not be preferable in some other devices such as sensors or home appliances for which maintaining and handling per - flow queues could introduce too much processing and energy overhead .",
    "thus , some devices , either due to rigid architecture or limited processing power and energy capacities , inevitably use shared fifo queues , which makes the understanding of the behavior of fifo queues over wireless networks very crucial .",
    "_ example 1 - continued : _ let us consider fig .",
    "[ fig : example_fifo_v1 ] again . when a fifo queue is used instead of per - flow queues , the well - known head - of - line ( hol ) blocking phenomenon occurs . as an example",
    ", suppose that at transmission instant @xmath14 , the links @xmath15 and @xmath16 are at `` on '' and `` off '' states , respectively .",
    "in this case , a packet from @xmath8 can be transmitted if per - flow queues are constructed . yet , in fifo case , if hol packet in @xmath17 belongs to flow @xmath5 , no packet can be transmitted and wireless resources are wasted .",
    "@xmath13    although hol blocking in fifo queues is a well - known problem , achievable throughput with fifo queues in a wireless network is generally not known . in particular , stability region of a wireless network with fifo queues as well as resource allocation schemes to achieve optimal operating points in the stability region are still open problems . in this work ,",
    "we investigate fifo queues over wireless networks .",
    "we consider a wireless network model presented in fig .",
    "[ fig : main - example ] with multiple fifo queues that are in the same transmission and interference range .",
    "( note that this scenario is getting increasing interest in practice in the context of device - to - device and cooperative networks @xcite . )",
    "our first step towards understanding the performance of fifo queues in such a setup is to characterize the stability region of the network .",
    "then , based on the structure of the stability region , we develop efficient resource allocation algorithms ; _ deterministic fifo - control _ ( @xmath0 ) and _ queue - based fifo - control _ ( @xmath1 ) .",
    "the following are the key contributions of this work :    * we characterize the stability region of a general scenario where an arbitrary number of fifo queues are shared by an arbitrary number of flows . *",
    "the stability region of the fifo queueing system under investigation is non - convex .",
    "thus , we develop a convex inner - bound on the stability region , which is provably tight for certain operating points . *",
    "we develop a resource allocation scheme ; @xmath0 , and a queue - based stochastic flow control and scheduling algorithm ; @xmath1 .",
    "we show that @xmath1 achieves optimal operating point in the convex inner bound . * we evaluate our schemes via simulations for multiple fifo queues and flows .",
    "the simulation results show that our algorithms significantly improve the throughput as compared to the well - known queue - based flow control and max - weight scheduling schemes .",
    "the structure of the rest of the paper is as follows .",
    "section  [ sec : system ] gives an overview of the system model .",
    "section  [ sec : stability_region ] characterizes the stability region with fifo queues .",
    "section  [ sec : ofc_qfc ] presents our resource allocation algorithms ; @xmath0 and @xmath1 .",
    "section  [ sec : performance ] presents simulation results .",
    "section  [ sec : related ] presents related work .",
    "section  [ sec : conclusion ] concludes the paper .",
    "_ wireless network setup : _ we consider a wireless network model presented in fig .",
    "[ fig : main - example ] with @xmath18 fifo queues .",
    "let @xmath19 be the set of fifo queues , @xmath20 be the @xmath21th fifo queue , and @xmath22 be the set of flows passing through @xmath20 .",
    "also , let @xmath23 and @xmath24 denote the cardinalities of sets @xmath20 and @xmath22 , respectively .",
    "we assume in our analysis that time is slotted , and @xmath14 refers to the beginning of slot @xmath14 .    _",
    "flow rates : _ each flow passing through @xmath20 and destined for node @xmath25 is generated according to an arrival process @xmath26 at time slot @xmath14 .",
    "the arrivals are i.i.d . over the time slots such that for every @xmath27 and @xmath28 , we have @xmath29 $ ] and @xmath30<\\infty$ ] , where @xmath31 $ ] denotes the expected value .    _ channel model : _ in our setup in fig .",
    "[ fig : main - example ] , as we mentioned earlier , we assume that all fifo queues are in the same transmission and interference range , _",
    "i.e. , _ only one fifo queue could be served by a shared wireless medium at time @xmath14 . on the other hand ,",
    "a channel state from a fifo queue to a receiver node may vary .",
    "in particular , at slot @xmath14 , @xmath32 is the channel state vector , where @xmath33 is the state of the link at time @xmath14 from the @xmath21th queue @xmath34 to receiver node @xmath25 such that @xmath28 .",
    "the link state @xmath33 takes values from the set @xmath35 according to a probability distribution which is i.i.d . over time slots .",
    "if @xmath36 , packets can be transmitted to receiver node @xmath25 with rate @xmath37 .",
    "we assume , for the sake of simplicity in this paper , that @xmath38 , and @xmath39 packet can be transmitted at time slot @xmath14 if @xmath36 .",
    "if @xmath40 , no packets are transmitted .",
    "the @xmath41 and @xmath42 probabilities of @xmath33 are @xmath43 and @xmath44 , respectively .",
    "note that @xmath33 only determines the channel state ; _ i.e. , _ the actual transmission opportunity from @xmath20 depends on the hol packet as explained next .",
    "_ queue structure and evolution : _ suppose that the head - of - line ( hol ) packet of @xmath34 at time @xmath14 is @xmath45 .",
    "the hol packet together with the channel state defines the state of @xmath34 .",
    "in particular , let @xmath46 be the state of @xmath34 at time @xmath14 such that @xmath47 .",
    "the state of @xmath34 is @xmath41 , _",
    "i.e. , _ @xmath48 if @xmath49 at time @xmath14 . otherwise , @xmath50 .",
    "we define @xmath51 @xmath52 @xmath53 @xmath54 @xmath55 @xmath56 @xmath57 @xmath54 @xmath58 @xmath59 @xmath60 as the set of the states of all fifo queues .",
    "let us now consider the evolution of the hol packet .",
    "if the state of queue @xmath34 is @xmath41 at time @xmath14 , _",
    "@xmath61 , the hol packet can be transmitted ( depending on the scheduling policy ) .",
    "if we assume that hol packet is transmitted according to the scheduling policy , then a new packet is placed in the hol position in @xmath34 . the probability that this new hol packet belongs to the @xmath25th flow is @xmath62 and it depends on the arrival rates via @xmath63",
    "now , we can consider the evolution of @xmath34 . at time @xmath14",
    ", @xmath64 packets arrive to @xmath34 , and @xmath65 packets are served according to the fifo manner .",
    "thus , queue size @xmath66 evolves according to the following dynamics .",
    "@xmath67 + \\sum_{k \\in { \\mathcal{k}}_{n } } \\lambda_{n , k}(t).\\end{aligned}\\ ] ] note that @xmath65 depends on the states of the queues ; @xmath68 at time @xmath14 , which characterize the stability region of the wireless network .",
    "note that @xmath68 depends on arrival rates of flows to each fifo queue ; _ i.e. , _ @xmath69 as well as the @xmath41-@xmath42 probability of each link , _ i.e. , _ @xmath44 . in the next section , by taking into account @xmath69 and @xmath44 , we characterize the stability region of the wireless network .",
    "in this section , our goal is to characterize the stability region of a wireless network where an arbitrary number of fifo queues are served by a wireless medium .",
    "we first begin with the single - queue case shown in fig .",
    "[ fig : fifo_one_queue_fig ] to convey our approach for a canonical scenario , then we extend our stability region analysis for arbitrary number of fifo queues and flows .",
    "we study the special case of a single fifo queue @xmath70 where @xmath71 with @xmath72 . for this special case , we thus drop the queue index @xmath21 from the notation in section [ sec : system ] for brevity . in other words",
    ", we write @xmath73 instead of @xmath74 , @xmath75 instead of @xmath33 , and so on .",
    "our main result in this context is then the following theorem .",
    "[ theorem1 ] for a fifo queue @xmath76 shared by @xmath77 @xmath52 @xmath78 @xmath79 @xmath80 flows , if the channel states @xmath75 and arrival rates @xmath81 are i.i.d . over time slots ,",
    "the stability region @xmath82 includes all arrival rates satisfying @xmath83 in other words , the stability region of the single - fifo queue system is @xmath84 ( [ eq : stab_one_queue])@xmath85 .    _",
    "proof : _ the state of the fifo queue @xmath76 takes values from @xmath35 depending the hol packet and the states of the wireless links .",
    "now , let us take a closer look at the fifo states .",
    "the @xmath42 state occurs if for some @xmath86 we have @xmath87 and @xmath88 .",
    "let @xmath89 be the state that @xmath87 and @xmath88 .",
    "we denote the probability of @xmath89 as @xmath90 = p[h = k,\\,c_k = off]$ ] .",
    "also , let @xmath91 be the state that fifo queue is at @xmath41 state for some hol packet .",
    "the state @xmath91 happens precisely when the channel corresponding to the hol packet is in the @xmath41 state .",
    "therefore , the probability of @xmath91 is @xmath92 = p [ c_h = on]$ ] .",
    "having defined the queue state probabilities , we can observe that the packets from the fifo queue could be served only at state @xmath91 .",
    "it is also clear that the sum of the arrival rates to the queue @xmath76 should be less than the service rate , which is @xmath92 $ ] . noting that we assumed @xmath93 , we conclude that @xmath94 $ ] .",
    "let us now calculate @xmath92 $ ] and @xmath90,\\,k \\in { \\mathcal{k}}$ ] using a markov chain with states ; @xmath91 and @xmath95 .",
    "we first show that the state transition probability from @xmath91 to @xmath89 is @xmath96 , where @xmath97 .",
    "since we consider only one fifo queue , when the queue is at state @xmath91 , the hol packet is always transmitted .",
    "the new hol packet in the next state will belong to the @xmath25th flow with probability @xmath98 , and @xmath88 with probability @xmath99 .",
    "therefore , the state transition probability from @xmath91 to @xmath89 is @xmath100 , as claimed .",
    "the probability of moving from state @xmath89 to @xmath91 is @xmath101 as we can move to the unblocking state @xmath91 from the blocking state @xmath89 if the channel is @xmath41 ( with probability @xmath102 . ) . on the other hand ,",
    "staying in the blocking state @xmath89 is the @xmath42 probability of the channel @xmath103 .",
    "thus , @xmath104 . note that the expressions for @xmath105 and @xmath106 do not involve the quantity @xmath98 .",
    "the reason is that @xmath89 is the blocking state , so when we move from @xmath89 to another state ( or staying at state @xmath89 ) , the hol packet is not transmitted and does not change ( because @xmath107 at state @xmath89 ) .",
    "for any given @xmath108 with @xmath109 , the state transition probability from @xmath110 to @xmath111 is @xmath112 .",
    "this follows since it is not possible to move from a blocking state to another ( the hol packet can not be transmitted . ) .",
    "finally , the probability of staying at state @xmath91 is @xmath113 as the condition @xmath114 should be satisfied .",
    "the state transition probabilities are as shown in fig .",
    "[ fig : markov_chain_single_fifo ] .",
    "now that we know the state transition probabilities of our markov chain , we can calculate the balance equations , and these yield @xmath92 = \\frac{\\sum_{k \\in { \\mathcal{k } } } \\lambda_{k } } { \\sum_{k \\in { \\mathcal{k } } } \\lambda_{k}/\\bar{p}_{k}}$ ] .",
    "the calculations are provided in the following .",
    "let @xmath115 = \\begin{bmatrix } p[z_0 ] & p[z_1 ] & \\ldots & p[z_k ] \\end{bmatrix}^{t}$ ] . in the steady the state , the following set of equations are satisfied for the markov chain shown in fig .",
    "[ fig : markov_chain_single_fifo ] .",
    "@xmath116^{t }     \\begin{bmatrix } 1 - \\sum_{k \\in { \\mathcal{k } } } \\alpha_kp_k & \\alpha_1p_1   & \\ldots & \\alpha_kp_k \\\\",
    "\\bar{p}_1                          & p_1           & \\ldots & 0            \\\\",
    "\\bar{p}_2                          & 0             & \\ldots & 0            \\\\     \\vdots                          & \\vdots        & \\ddots & \\vdots   \\\\ \\bar{p}_{k }                            & 0             & \\ldots & p_k             \\end{bmatrix }   = p[\\boldsymbol z]\\end{aligned}\\ ] ] if we combine the @xmath117th equation in ( [ eq : ststmatrix ] ) , which is @xmath90 = p[z_0 ] \\frac{\\alpha_kp_k}{\\bar{p}_{k}}$ ] , and the fact that @xmath92 + \\sum_{k \\in { \\mathcal{k } } } p[z_k ] = 1 $ ] , we have @xmath118 = \\frac{\\sum_{k \\in { \\mathcal{k } } } \\lambda_{k}}{\\sum_{k \\in { \\mathcal{k } } } \\lambda_{k}/\\bar{p}_{k}}\\end{aligned}\\ ] ]    we can then obtain @xmath94 = \\frac{\\sum_{k \\in { \\mathcal{k } } } \\lambda_{k } } { \\sum_{k \\in { \\mathcal{k } } } \\lambda_{k}/\\bar{p}_{k}}$ ] which is equivalent to ( [ eq : stab_one_queue ] ) .",
    "this concludes the proof .",
    "@xmath119    now suppose that single - fifo queue @xmath76 is shared by two flows with rates @xmath120 and @xmath121 . according to theorem  [ theorem1 ]",
    ", the arrival rates should satisfy @xmath122 for stability .",
    "this stability region is shown in fig .",
    "[ fig : fifo_one_queue_fig](b ) . in the same figure",
    ", we also show the stability region of per - flow queues , @xcite . as seen , the fifo stability region is smaller as compared to per - flow capacity region .",
    "yet , we still need flow control and scheduling algorithms to achieve the optimal operating point in this stability region . this issue will be discussed later in section  [ sec : ofc_qfc ] .",
    "@xmath13      we now consider a wireless network with arbitrary number of fifo queues and flows as shown in fig .",
    "[ fig : main - example ] .",
    "the main challenge in this setup is that packet scheduling decisions affect the stability region .",
    "for example , if both @xmath123 and @xmath20 in fig .",
    "[ fig : main - example ] are at @xmath41 state , a decision about which queue to be served should be made .",
    "this decision affects future transmission opportunities from the queues , hence the stability region .    in this paper",
    ", we consider a scheduling policy where the packet transmission probability of each queue depends only on the queue states .",
    "in other words , if the state of the fifo queues is @xmath124 , a packet from queue @xmath21 is transmitted with probability @xmath125 .",
    "we call this scheduling policy the _ queue - state _ policy . note that as @xmath126 @xmath127 @xmath54 @xmath55 is the transmission probability from queue @xmath34 , we have the obvious constraint @xmath128 our main result is then the following theorem .",
    "[ theorem2 ] for a wireless network with @xmath18 fifo queues , if a queue - state policy @xmath126 is employed , then the stability region consists of the flow rates that satisfy @xmath129}}{\\sum_{k \\in { \\mathcal{k}}_{n } } \\lambda_{n , k}/\\bar{p}_{n , k } }",
    "\\nonumber \\\\ & \\prod_{m \\in { \\mathcal{n}}-\\{n\\ } }   \\biggr ( \\frac{\\sum_{k \\in { \\mathcal{k}}_{m } } \\lambda_{m , k } \\rho_{m , k}(s_m)}{\\sum_{k \\in { \\mathcal{k}}_{m } } \\lambda_{m , k}/\\bar{p}_{m , k } } \\biggl ) \\tau_{n } ( s_1 , \\ldots , s_n ) \\biggr \\ } , \\nonumber \\\\ &",
    "\\forall n \\in { \\mathcal{n } } , k \\in { \\mathcal{k}}_{n},\\end{aligned}\\ ] ] where @xmath130 } & = \\left\\{\\begin{array}{rl}1 , & s_n = on \\\\ 0 , & s_{n } = off\\end{array}\\right . , \\\\",
    "\\rho_{m , k}(s_m ) & = \\left\\{\\begin{array}{rl } 1 , & s_m = on \\\\",
    "{ p_{m , k}}/{\\bar{p}_{m , k } } , & s_m = off \\end{array }   \\right .. \\end{aligned}\\ ] ]    _ proof : _ the proof is provided in appendix a. @xmath119    the stability region of a fifo queue system with @xmath18 fifo queues served by a wireless medium is characterized by @xmath82 @xmath52 @xmath131 ( [ eq : lamdba_nk ] ) , ( [ eq : sum_tau])@xmath132 @xmath69 @xmath133 @xmath21 @xmath59 @xmath134 @xmath25 @xmath59 @xmath135 @xmath136 @xmath54 @xmath55 @xmath137 @xmath138 @xmath139 @xmath21 @xmath140 .",
    "now let us consider two fifo queues @xmath34 and @xmath141 which are shared by three flows with rates ; @xmath142 , @xmath143 , and @xmath144 ( fig .",
    "[ fig : two_queue](a ) ) . according to theorem  [ theorem2 ]",
    ", the stability region @xmath82 should include arrival rates satisfying inequalities in ( [ eq : lamdba_nk ] ) and ( [ eq : sum_tau ] ) . in this example , with two queues and three flows , these inequalities are equivalent to @xmath145 with @xmath146 @xmath147 @xmath148 @xmath149 , and @xmath150 @xmath151 @xmath39 .",
    "the stability region corresponding to these inequalities is the region below the surface in fig .",
    "[ fig : two_queue](b ) .",
    "@xmath13    in general , we wish to find the optimal operating points on the boundary of the stability region @xmath82 . however , the stability region may not be convex for arbitrary number of queues and flows . developing a convex",
    "inner bound on the stability region is crucial for developing efficient resource allocation algorithms for wireless networks with fifo queues .",
    "we thus next propose a convex inner bound on the stability region .",
    "let us consider a flow with arrival rate @xmath69 to the fifo queue @xmath34 .",
    "if there are no other flows and queues in the network , then the arrival rate should satisfy @xmath152 according to theorem  [ theorem2 ] . in this formulation",
    ", @xmath153 is the total amount of wireless resources that should be allocated to transmit the flow with rate @xmath69 . for multiple - flow , single - fifo case ,",
    "the stability region is @xmath154 .",
    "similar to the single - flow case , @xmath155 term is the amount of wireless resources that should be allocated to the @xmath25th flow .",
    "finally , for the general stability region for arbitrary number of queues and flows , let us consider ( [ eq : lamdba_nk ] ) again .",
    "assuming @xmath156 , we can write @xmath157 from ( [ eq : lamdba_nk ] ) as ; @xmath158}}{\\sum_{k \\in { \\mathcal{k}}_{n } } \\lambda_{n , k}/\\bar{p}_{n , k } } \\nonumber \\\\ & \\prod_{m \\in { \\mathcal{n}}-\\{n\\ } }   \\psi_{m}(s_m )   \\tau_{n } ( s_1 , \\ldots , s_n ) \\biggr \\ } , \\forall n \\in { \\mathcal{n } } , k \\in { \\mathcal{k}}_{n}\\end{aligned}\\ ] ] which , assuming that @xmath159 , is equivalent to @xmath160 } \\prod_{m \\in { \\mathcal{n}}-\\{n\\ } }   \\psi_{m}(s_m ) \\nonumber \\\\ & \\tau_{n } ( s_1 , \\ldots , s_n ) , \\forall",
    "n \\in { \\mathcal{n } } , k \\in { \\mathcal{k}}_{n}\\end{aligned}\\ ] ] intuitively speaking , the right hand side of ( [ eq : gec_v2 ] ) corresponds to the amount of wireless resources that is allocated to the @xmath21th queue @xmath34 .",
    "thus , similar to the single - fifo queue , we can consider that @xmath155 term corresponds to the amount of wireless resources that should be allocated to the @xmath25th flow .",
    "our key point while developing an inner bound on the stability region is to provide rate fairness across competing flows in each fifo queue . since each flow requires @xmath155 amount of wireless resources ; it is intuitive to have the following equality @xmath161 , @xmath109 to fairly allocate wireless resources across flows .",
    "more generally , we define a function @xmath162 , @xmath163 where @xmath164 , and we develop a stability region for @xmath165 instead of @xmath69 .",
    "the role of the exponent @xmath166 is to provide flexibility to the targeted fairness .",
    "for example , if we want to allocate more resources to flows with better channels , then @xmath166 should be larger .",
    "now , by the definition of @xmath165 , we have the equivalent form @xmath167}}{\\sum_{k \\in { \\mathcal{k}}_{n } } ( \\bar{p}_{n , k})^{\\beta-1 } } \\prod_{m \\in { \\mathcal{n}}- \\{n\\ } }   \\omega_{m}(s_{m } ) \\nonumber \\\\ & \\tau_{n}(s_1 , \\ldots , s_n ) , \\forall n \\in { \\mathcal{n}}\\end{aligned}\\ ] ] of ( [ eq : lamdba_nk ] ) , where @xmath168 .",
    "as seen , ( [ eq : an ] ) is a convex function of @xmath165 .",
    "thus , we can define the region @xmath169 ( [ eq : an ] ) , ( [ eq : sum_tau ] ) , @xmath170 , which is clearly an inner bound on the actual stability region @xmath82 . despite the fact that @xmath171 is only inner bound on @xmath82 , for some operating points , _",
    "i.e. , _ at the intersection of @xmath161 , @xmath109 lines , the two stability regions ( @xmath171 and @xmath82 ) coincide .",
    "thus , for some utility functions , optimal operating points in both @xmath171 and @xmath82 coincide . in the next section ,",
    "we develop resource allocation schemes ; @xmath0 and @xmath1 that achieve utility optimal operating points in @xmath171 .",
    "in this section , we develop resource allocation schemes ; _ deterministic fifo - control _ ( @xmath0 ) , and a _ queue - based fifo control _ ( @xmath1 ) . in general , our goal is to solve the optimization problem @xmath172 and to find the corresponding optimal rates , where @xmath173 is a concave utility function assigned to flow with rate @xmath69 . although the objective function @xmath174 in ( [ eq : main_opt ] ) is concave , the optimization domain @xmath82 ( _ i.e. , _ the stability region ) may not be convex .",
    "thus , we convert this problem to a convex optimization problem based on the structure of the inner bound we have developed in section  [ sec : stability_single_innerbound ] . in particular , setting @xmath162 , the problem in ( [ eq : main_opt ] ) reduces to @xmath175 @xmath176 , @xmath177 .",
    "this is our deterministic fifo - control scheme ; @xmath0 and expressed explicitly as ;    @xmath178}}{\\sum_{k \\in { \\mathcal{k}}_{n } } ( \\bar{p}_{n , k})^{\\beta-1 } } \\nonumber \\\\ & \\prod_{m \\in { \\mathcal{n}}- \\{n\\ } } \\omega_{m}(s_m )   \\tau_{n}(s_1 , \\ldots , s_n ) , \\forall",
    "n \\in { \\mathcal{n}}\\nonumber \\\\ & \\sum_{n \\in { \\mathcal{n } } } \\tau_{n } ( s_1 , \\ldots , s_n ) \\leq 1 , \\forall ( s_1 , \\ldots , s_n ) \\in { \\mathcal{s}}\\nonumber \\\\ & a_n \\geq 0 , \\forall n \\in { \\mathcal{n } } , ( s_1 , \\ldots , s_n ) \\in { \\mathcal{s}}\\nonumber \\\\ & \\tau_{n } ( s_1 , \\ldots , s_n ) \\geq 0 , \\forall n \\in { \\mathcal{n } } , ( s_1 , \\ldots , s_n ) \\in { \\mathcal{s}}\\end{aligned}\\ ] ] note that @xmath0 optimizes @xmath165 and @xmath179 . after the optimal values are determined , packets are inserted into the fifo queue @xmath34 depending on @xmath180 and served from the fifo queue @xmath34 depending on @xmath179 .",
    "although @xmath0 gives us optimal operating points in the stability region ; @xmath171 , it is a centralized solution , and its adaptation to varying wireless channel conditions is limited .",
    "thus , we also develop a more practical and queue - based fifo - control scheme @xmath1 , next .",
    "* _ flow control : _ at every slot @xmath14 , the flow controller attached to the fifo queue @xmath34 determines @xmath181 according to ; @xmath182 - q_{n}(t)a_{n}(t ) \\nonumber \\\\ \\mbox{s.t . } \\mbox { }   &   a_n(t ) \\leq r_{n}^{max } , a_n(t ) \\geq 0 \\end{aligned}\\ ] ] where @xmath183 is a large positive number , and @xmath184 is a positive value larger than the maximum outgoing rate from fifo queue @xmath20 ( which is @xmath185 as we assume that the maximum outgoing rate from a queue is 1 packet per slot ) .",
    "after @xmath181 is determined according to ( [ eq : flow_control ] ) , @xmath26 is set as @xmath26 @xmath52 @xmath186 @xmath187 .",
    "then , @xmath26 packets from the @xmath25th flow are inserted in @xmath34 . * _ scheduling : _ at slot @xmath14 , the scheduling algorithm determines the fifo queue from which a packet is transmitted according to ; @xmath188}}{\\sum_{k \\in { \\mathcal{k}}_{n } } ( \\bar{p}_{n , k})^{\\beta } }    \\tau_{n}(s_1(t ) , \\ldots , s_n(t ) ) \\nonumber \\\\ \\mbox{s.t . }",
    "\\mbox { }   &   \\sum_{n \\in { \\mathcal{n } } } \\tau_{n } ( s_1(t ) , \\ldots , s_n(t ) ) \\leq 1 , \\nonumber \\\\ & \\tau_{n } ( s_1(t ) , \\ldots , s_n(t ) ) \\geq 0\\end{aligned}\\ ] ] after @xmath189 is determined , the outgoing traffic rate from queue @xmath34 is set to @xmath65 @xmath52 @xmath126 @xmath190 @xmath54 @xmath191 @xmath192}$ ] , and @xmath65 packets ( which is 1 or 0 in our case ) are transmitted from @xmath34 .    thus , the queue dynamics change according to ( [ eq : queue_qn ] ) and based on ( [ eq : flow_control ] ) and ( [ eq : scheduling ] ) .",
    "such queue dynamics lead to the following result .",
    "[ theorem_lyap ] if the channel states are i.i.d . over time slots ,",
    "the traffic arrival rates are controlled by the rate control algorithm in ( [ eq : flow_control ] ) , and the fifo queues are served by the scheduling algorithm in ( [ eq : scheduling ] ) , then the admitted flow rates converge to the utility optimal operating point in the stability region @xmath171 with increasing @xmath183 .",
    "_ proof : _ the proof is provided in appendix b. @xmath13",
    "in this section , we evaluate our @xmath0 and @xmath1 algorithms as compared to the baselines ; ( i ) _ optimal _ solution , and ( ii ) _ max - weight _ algorithm for different number of fifo queues and flows .",
    "next , we briefly explain our baselines .",
    "the _ optimal _ solution is a solution to ( [ eq : main_opt ] ) , and we compared @xmath0 and @xmath1 with the _ optimal _ solution for some scenarios where the stability region @xmath82 is convex . on the other hand , _ max - weight _ algorithm is a queue - based flow control and max - weight scheduling scheme .",
    "our baseline _ max - weight _ algorithm mimics the structure of the solution provided in @xcite , and it is summarized briefly in the following .    * _ flow control : _ at every time slot @xmath14 , the flow controller attached to the fifo queue @xmath34 determines @xmath26 according to ; @xmath193 - q_{n , k}(t)\\lambda_{n , k}(t ) \\nonumber \\\\ \\mbox{s.t . }",
    "\\mbox { }   &   \\lambda_{n , k}(t ) \\leq r_{n , k}^{max } , \\forall k \\in { \\mathcal{k}}_{n}\\end{aligned}\\ ] ] where @xmath183 and @xmath194 are positive large constants similar to ( [ eq : flow_control ] ) , and @xmath195 is the number of packets that belong to the @xmath25th flow in queue @xmath34 . *",
    "_ scheduling : _ at slot @xmath14 , the scheduling algorithm determines the fifo queue from which a packet is transmitted according to ; @xmath196 } \\tau_{n}(s_1(t ) , \\ldots , s_n(t ) ) \\nonumber \\\\ \\mbox{s.t . } \\mbox { }   &   \\sum_{n \\in { \\mathcal{n } } } \\tau_{n } ( s_1(t ) , \\ldots , s_n(t ) ) \\leq 1 \\nonumber \\\\ & \\tau_{n } ( s_1(t ) , \\ldots , s_n(t ) ) \\geq 0\\end{aligned}\\ ] ] after @xmath126 @xmath190 @xmath54 @xmath197 is determined , a packet from the queue @xmath34 is transmitted if @xmath126 @xmath190 @xmath54 @xmath191 @xmath52 @xmath39 ; no packet is transmitted , otherwise .",
    "next , we present our simulation results for single and multiple fifo queues .      in this section ,",
    "we consider a single fifo queue @xmath198 .",
    "similar to section  [ sec : stability_single_queue ] , we drop the queue index @xmath199 from the notation for brevity . in other words , we write @xmath200 instead of @xmath201 , @xmath99 instead of @xmath202 , and so on .    fig .",
    "[ fig : sim_1 ] presents simulation results for a single queue and two flows for @xmath203 , @xmath204 , and @xmath205 .",
    "[ fig : sim_1](a ) shows per - flow rates ; @xmath206 and @xmath207 when @xmath208 is increasing .",
    "as seen , @xmath206 is the same for all algorithms ; optimal , @xmath0 , and @xmath1 .",
    "this also holds for @xmath207 .",
    "these results show that our algorithms @xmath0 and @xmath1 are as good as the optimal solution , and achieve the optimal operating points in @xmath82 in this scenario .",
    "the simulations results also show that our algorithms reduce the second flow rate @xmath207 when @xmath208 increases while @xmath206 and @xmath209 do not change .",
    "this means that our algorithms do not penalize a flow ( flow 1 ) when the channel of another competing flow ( flow 2 ) deteriorates , which shows the effectiveness of our algorithms to provide fairness .",
    "[ fig : sim_1](b ) shows the total rate @xmath210 versus @xmath208 for the same setup .",
    "as seen , our algorithms improves throughput over max - weight significantly .",
    "this is expected as our algorithms are designed to reduce the hol blocking and to allocate wireless resources fairly among multiple flows .",
    "[ fig : sim_2 ] shows simulation results for a single queue shared by multiple flows . in this setup , @xmath211 is selected randomly between @xmath212 $ ] , @xmath213 , @xmath205 .",
    "the simulations are repeated for 1000 different seeds , and the average values are reported .",
    "[ fig : sim_2](a ) shows average flow rate versus number of flows for our algorithms as well as max - weight . as seen , @xmath0 and @xmath1 are as good as the optimal solution , and they improve over max - weight significantly . fig .  [",
    "fig : sim_2](b ) shows the same simulation results , but reports the improvement of @xmath1 over max - weight .",
    "this figure shows that the improvement of our algorithms increases with increasing number of flows .",
    "indeed , the improvement is up to 100% when @xmath214 , which is significant .",
    "the improvement is higher for large number of flows , because our algorithm allocates resources to the flows based on the quality of their channels and reduces the flow rate for the flows with bad channel conditions .",
    "however , max - weight does not have such a mechanism , and when there are more flows in the system , the probability of having a flow with bad channel condition increases , which reduces the overall throughput .      in this section ,",
    "we consider two fifo queues @xmath141 and @xmath34 .",
    "there are four flows in the system and each queue carries two flows , _",
    "@xmath34 carries flows with rates @xmath142 , @xmath143 and @xmath141 carries flows with rates @xmath144 , @xmath215 .",
    "( [ fig : sim_3])(a ) shows the total flow rate versus @xmath166 for the scenario of two - fifo queues with four flows when @xmath216 , @xmath217 , @xmath218 , @xmath219 , and @xmath220 utility is employed , _",
    "i.e. , _ @xmath221 .",
    "( we do not present the results of the optimal solution as the stability region @xmath82 is not convex in this scenario . ) as seen , @xmath0 and @xmath1 have the same performance and improve over max - weight .",
    "the improvement increases with increasing @xmath166 as @xmath0 and @xmath1 penalize flows with bad channel conditions more when @xmath166 increases , which increases the total throughput .",
    "( [ fig : sim_3])(b ) shows the total rate versus @xmath222 for two - fifo queues with four flows when @xmath223 and @xmath224 .",
    "as seen , @xmath0 and @xmath1 improve significantly over max - weight .",
    "furthermore , they achieve almost maximum achievable rate @xmath39 all the time .",
    "the reason is that @xmath0 and @xmath1 penalizes the queues with with bad channels .",
    "for example , when @xmath225 , the total rate is @xmath39 , because they allocate all the resources to @xmath142 and @xmath144 as there is no point to allocate those resources to @xmath143 and @xmath215 since their channels are always @xmath42 . on the other hand , max - weight",
    "does not arrange the flow and queue service rates based on the channel conditions , so the total rate reduces to @xmath226 when @xmath225 , _",
    "i.e. , _ it is not possible to transmit any packets when max - weight is employed in this scenario .",
    "[ fig : sim_4 ] further demonstrates how our algorithms treat flows with bad channel conditions .",
    "in particular , fig .  [",
    "fig : sim_4 ] presents per - flow rate versus @xmath227 for the scenario of two - fifo queues with four flows when @xmath228 and @xmath224 for ( a ) @xmath0 and @xmath1 and ( b ) max - weight .",
    "as seen , when @xmath227 increases , @xmath215 decreases in fig .",
    "[ fig : sim_4](a ) since its channel is getting worse . yet",
    ", this does not affect the other flows .",
    "in fact , @xmath144 even increases as more resources are allocated to it when @xmath227 increases . on the other hand , both @xmath144 and @xmath215 decrease with increasing @xmath227 in max - weight ( fig .",
    "[ fig : sim_4](b ) ) .",
    "this is not fair , because @xmath144 decreases with increasing @xmath227 although its channel is always @xmath41 as @xmath229 . in the same scenario ( fig .",
    "[ fig : sim_4](b ) ) , the rates of the @xmath21th queue ( @xmath142 and @xmath143 ) increase with increasing @xmath227 as they use available resource opportunistically .",
    "this makes the total rate the same for @xmath0 , @xmath1 , and max - weight . yet , as we discussed , max - weight is not fair to flow @xmath144 in this scenario .",
    "in this work , our goal is to understand fifo queues in wireless networks and develop efficient flow control and scheduling policies for such a setup . in the seminal paper @xcite ,",
    "the authors analyze fifo queues in an input queued switch .",
    "they show that the use of fifo queues in that context limits the throughput to approximately 58% of the maximum achievable throughput . however , in the context of wireless networks , similar results are in general not known .",
    "backpressure routing and scheduling framework has emer - ged from the pioneering work @xcite , which has generated a lot of research interest @xcite ; especially for wireless ad - hoc networks @xcite .",
    "furthermore , it has been shown that backpressure can be combined with flow control to provide utility - optimal operation guarantee @xcite .",
    "such previous work mainly considered per - flow queues .",
    "however , fifo queueing structure , which is the focus of this paper , is not compatible with the per - flow queueing requirements of these routing and scheduling schemes .",
    "the strengths of backpressure - based network control have recently received increasing interest in terms of practical implementation .",
    "multi - path tcp scheme is implemented over wireless mesh networks in @xcite for routing and scheduling packets using a backpressure based heuristic . at the link layer ,",
    "@xcite propose , analyze , and evaluate link layer backpressure - based implementations with queue prioritization and congestion window size adjustment .",
    "backpressure is implemented over sensor networks @xcite and wireless multi - hop networks @xcite . in these schemes ,",
    "either last - in , first - out queueing is employed @xcite or link layer fifo queues are strictly controlled @xcite to reduce the number of packets in the fifo queues , hence hol blocking .    in backpressure",
    ", each node constructs per - flow queues .",
    "there is some work in the literature to stretch this necessity .",
    "for example , @xcite , @xcite propose using real per - link and virtual per - flow queues .",
    "such a method reduces the number of queues required in each node , and reduces the delay , but it still needs to construct per - link queues .",
    "similarly , @xcite constructs per - link queues in the link layer , and schedule packets according to fifo rule from these queues .",
    "such a setup is different than ours as per - link queues do not introduce hol blocking .",
    "the main differences in our work are : ( i ) we consider fifo queues shared by multiple flows where hol blocking occurs as each flow is transmitted over a possibly different wireless link , ( ii ) we characterize the stability region of a general scenario where an arbitrary number of fifo queues , which are served by a wireless medium , are shared by an arbitrary number of flows , and ( iii ) we develop efficient resource allocation schemes to exploit achievable rate in such a setup .",
    "we investigated the performance of fifo queues over wireless networks and characterized the stability region of this system for arbitrary number of fifo queues and flows .",
    "we developed inner bound on the stability region , and developed resource allocation schemes ; @xmath0 and @xmath1 , which achieve optimal operating point in the convex inner bound .",
    "simulation results show that our algorithms significantly improve throughput in a wireless network with fifo queues as compared to the well - known queue - based flow control and max - weight scheduling schemes .",
    "cisco visual networking index : global mobile data traffic forecast update , 2010 - 2015 .",
    "ericsson mobility report , november 2013 .",
    "l. tassiulas and a. ephremides , `` stability properties of constrained queueing systems and scheduling policies for maximum throughput in multihop radio networks , '' _ ieee trans . autom .",
    "19361948 , dec . 1992 .",
    "l. tassiulas and a. ephremides , `` dynamic server allocation to parallel queues with randomly varying connectivity , '' _ ieee trans .",
    "inf . theory _ ,",
    "2 , pp . 466478 , mar .",
    "m. j. neely , e. modiano , and c. li , `` fairness and optimal stochastic control for heterogeneous networks , '' _ ieee / acm trans .",
    "2 , pp . 396409 , apr . 2008 .    http://madwifi-project.org/wiki/chipsets .",
    "l.  keller , a.  le , b.  cici , h.  seferoglu , c.  fragouli , a.  markopoulou , `` microcast : cooperative video streaming on smartphones , '' _ acm mobisys _ , june 2012 .",
    "m. j. karol , m. g. hluchyj , and s. p. morgan , `` input versus output queueing on a space - division packet switch , '' _ ieee trans .",
    "13471356 , dec . 1987 .",
    "m. j. neely , _",
    "stochastic network optimization with application to communication and queueing systems _ ,",
    "morgan & claypool , 2010 .",
    "l. tassiulas , `` scheduling and performance limits of networks with constantly changing topology , '' _ ieee trans .",
    "inf . theory _ ,",
    "3 , pp . 10671073 , may 1997 .",
    "n. kahale and p. e. wright , `` dynamic global packet routing in wireless networks , '' _ ieee infocom _ , apr .",
    "m. andrews , k. kumaran , k. ramanan , a. stolyar , p. whiting , and r. vijaykumar , `` providing quality of service over a shared wireless link , '' _ ieee commun . mag .",
    "2 , pp . 150154 , feb . 2001 .",
    "m. j. neely , e. modiano , and c. e. rohrs , `` dynamic power allocation and routing for time varying wireless networks , '' _ ieee j. select .",
    "areas commun .",
    "1 , pp . 89103 , jan .",
    "a. l. stolyar , `` greedy primal dual algorithm for dynamic resource allocation in complex networks , '' _ queuing systems _ , vol .",
    "3 , pp . 203220 , 2006 .",
    "j. liu , a. l. stolyar , m. chiang , and h. v. poor , `` queue backpressure random access in multihop wireless networks : optimality and stability , '' _ ieee trans .",
    "inf . theory _ ,",
    "9 , pp . 40874098 , sept . 2009 .",
    "b. radunovic , c. gkantsidis , d. gunawardena , and p. key , `` horizon : balancing tcp over multiple paths in wireless mesh network , '' _ acm mobicom _",
    ", sept . 2008 .",
    "a. warrier , s. janakiraman , s. ha , i. rhee , `` diffq : practical differential backlog congestion control for wireless networks , '' _ ieee infocom _ , apr .",
    "u. akyol , m. andrews , p. gupta , j. hobby , i. saniee , and a. stolyar , `` joint scheduling and congestion control in mobile ad - hoc networks , '' _ ieee infocom _ , apr .",
    "a. sridharan , s. moeller , b. krishnamachari , `` making distributed rate control using lyapunov drifts a reality in wireless sensor networks , '' _ ieee wiopt _ , apr .",
    "s. moeller , a. sridharan , b. krishnamachari , and o. gnawali , `` routing without routes : the backpressure collection protocol , '' _ acm ipsn _",
    "r. laufer , t. salonidis , h. lundgren , and p. l. guyadec , `` xpress : a cross - layer backpressure architecture for wireless multi - hop networks , '' _ acm mobicom _ , sept . 2011 .",
    "e.  athanasopoulou , l.  x.  bui , t.  ji , r.  srikant , and a.  stolyar , `` backpressure - based packet - by - packet adaptive routing in communication networks , '' _ ieee / acm trans .",
    "1 , pp . 244257 , feb . 2013 .",
    "l.  x.  bui , r.  srikant , and a.  stolyar , `` a novel architecture for reduction of delay and queueing structure complexity in the back - pressure algorithm , '' _ ieee / acm trans .",
    "19 , no . 6 , pp .",
    "15971609 , dec . 2011 .",
    "h.  seferoglu , e.  modiano , `` diff - max : separation of routing and scheduling in backpressure - based wireless networks , '' _ ieee infocom _ , apr .",
    "in this section , we provide a proof of theorem  [ theorem2 ] for arbitrary number of fifo queues and flows .",
    "let us first consider @xmath69 , which should satisfy the following inequality .",
    "1_{[s_n ] } \\nonumber \\\\ & \\tau_{n}(s_1,\\ldots , s_n ) ,   \\forall n \\in { \\mathcal{n } } , k \\in { \\mathcal{k}}_{n}.\\end{aligned}\\ ] ] where @xmath231 $ ] is the probability that the states of the queues are @xmath232 and @xmath233 , which is required as we can transmit a packet from the @xmath25th flow only when the hol packet belongs to the @xmath25th flow . in this equation , we can calculate @xmath231 $ ] as @xmath234   = \\sum_{l_1 \\in { \\mathcal{k}}_{1 } } \\ldots \\sum_{l_{n-1 } \\in { \\mathcal{k}}_{n-1 } } \\sum_{l_{n+1 } \\in { \\mathcal{k}}_{n+1 } } \\ldots \\nonumber \\\\ & \\sum_{l_n \\in { \\mathcal{k}}_{n } } p[s_{1 } , \\ldots , s_{n } , h_{n}=k , h_1=l_1 , \\ldots , h_{n-1}=l_{n-1 } , \\nonumber \\\\ & h_{n+1}=l_{n+1 } , \\ldots , h_{n}=l_{n } ] , \\end{aligned}\\ ] ] @xmath234   = \\sum_{l_1 \\in { \\mathcal{k}}_{1 } } \\ldots \\sum_{l_{n-1 } \\in { \\mathcal{k}}_{n-1 } } \\sum_{l_{n+1 } \\in { \\mathcal{k}}_{n+1 } } \\ldots \\nonumber \\\\ & \\sum_{l_n \\in { \\mathcal{k}}_{n } } \\underbrace{p[s_1 | h_1=l_1]}_{\\triangleq \\xi_{1,l_1}(s_1 ) } \\ldots \\underbrace{p[s_{n-1 } | h_{n-1}=l_{n-1}]}_{\\triangleq \\xi_{n-1,l_{n-1}}(s_{n-1 } ) } \\nonumber \\\\ & \\underbrace{p[s_{n } | h_{n}=k]}_{\\triangleq \\xi_{n , k}(s_{n } ) }   \\underbrace{p[s_{n+1 } | h_{n+1 } = l_{n+1}]}_{\\triangleq \\xi_{n+1,l_{n+1}}(s_{n+1 } ) } \\ldots \\underbrace{p[s_{n } | h_{n } = l_{n}]}_{\\triangleq \\xi_{n , l_{n}}(s_{n } ) }   \\nonumber \\\\",
    "& p[h_{n}=k ,   h_{1}=l_{1 } , \\ldots , h_{n-1}=l_{n-1 } , h_{n+1}=l_{n+1 } , \\ldots , \\nonumber \\\\ & h_{n}=l_{n}]\\end{aligned}\\ ] ] thus , we have @xmath235   = \\sum_{l_1 \\in { \\mathcal{k}}_{1 } } \\ldots \\sum_{l_{n-1 } \\in { \\mathcal{k}}_{n-1 } } \\sum_{l_{n+1 } \\in { \\mathcal{k}}_{n+1 } } \\ldots \\nonumber \\\\ & \\sum_{l_n \\in { \\mathcal{k}}_{n } } { \\xi_{1,l_1}(s_1 ) } \\ldots { \\xi_{n-1,l_{n-1}}(s_{n-1 } ) } { \\xi_{n , k}(s_{n } ) } \\nonumber \\\\ & { \\xi_{n+1,l_{n+1}}(s_{n+1 } ) }   \\ldots { \\xi_{n , l_{n}}(s_{n } ) }    p[h_{n}=k ,   h_{1}=l_{1 } , \\ldots , \\nonumber \\\\ & h_{n-1}=l_{n-1 } ,    h_{n+1}=l_{n+1 } , \\ldots ,   h_{n}=l_{n } ] . \\end{aligned}\\ ] ] now , we should calculate @xmath236 $ ] .",
    "we claim that @xmath237 @xmath238 @xmath54 @xmath239 @xmath240 @xmath54 @xmath241 $ ] @xmath52 @xmath242 $ ] @xmath79 @xmath243 $ ] @xmath244 $ ] @xmath245 $ ] @xmath79 @xmath246 $ ] . to prove this claim , we should show , without loosing generality , that the following conditions hold .",
    "@xmath247 = p[h_{n}=k ]   \\nonumber \\\\",
    "\\mbox{c2 : } & p[h_{n}=k | h_1=l_1 , \\ldots , h_{n-1}=l_{n-1 } , h_{n+1}=l_{n+1 } , \\nonumber \\\\ & \\ldots , h_{n-1}=l_{n-1 } ] = p[h_{n}=k ]   \\nonumber   \\\\   & \\mbox {                 } \\vdots \\nonumber \\\\ \\mbox{cn : }   & p[h_{n}=k | h_1=l_1 ] = p[h_{n}=k ] \\end{aligned}\\ ] ] we can calculate the conditional probabilities in the left hand side of the conditions ; c1 , c2 , @xmath79 , cn in ( [ eq : app_cond_prob ] ) by using a markov chain . for c1 , we can write a state transition probability of going from state @xmath248 to @xmath249 as @xmath250 @xmath240 @xmath54 @xmath241 $ ] , which is equal to @xmath251 .",
    "_ i.e. , _ @xmath252 @xmath239 @xmath253 $ ] @xmath52 @xmath251 . similarly , if we write the state transition probabilities for the other conditions c2 ,",
    "@xmath79 , cn , we have @xmath254 $ ] @xmath52 @xmath255 $ ] @xmath52 @xmath79 @xmath52 @xmath256 $ ] @xmath52 @xmath257 $ ] @xmath52 @xmath257 $ ] @xmath52 @xmath258 .",
    "therefore , in all markov chains we can create for c1 , c2 , @xmath79 , cn , we have the same transition probabilities , so we have @xmath259 $ ] @xmath52 @xmath260 $ ] @xmath52 @xmath261 $ ] @xmath52 @xmath262 $ ] .",
    "this proves our claim that @xmath263 @xmath239 @xmath264 $ ] @xmath52 @xmath242 $ ] @xmath79 @xmath243 $ ] @xmath244 $ ] @xmath245 $ ] @xmath79 @xmath246 $ ] .",
    "now that we have shown that @xmath263 @xmath239 @xmath264 $ ] @xmath52 @xmath242 $ ] @xmath79 @xmath243 $ ] @xmath244 $ ] @xmath245 $ ] @xmath79 @xmath246 $ ] holds , ( [ eq : states_v1 ] ) is expressed as @xmath265   = \\sum_{l_1 \\in { \\mathcal{k}}_{1 } } \\ldots \\sum_{l_{n-1 } \\in { \\mathcal{k}}_{n-1 } } \\sum_{l_{n+1 } \\in { \\mathcal{k}}_{n+1 } } \\ldots \\nonumber \\\\ & \\sum_{l_n \\in { \\mathcal{k}}_{n } } { \\xi_{1,l_1}(s_1)}p[h_1=l_1 ] \\ldots { \\xi_{n-1,l_{n-1}}(s_{n-1 } ) } \\nonumber \\\\ &   p[h_{n-1}=l_{n-1 } ] { \\xi_{n , k}(s_{n } ) } p[h_{n}=k ] { \\xi_{n+1,l_{n+1}}(s_{n+1 } ) } \\nonumber \\\\ &   p[h_{n+1}=l_{n+1 } ] \\ldots { \\xi_{n , l_{n}}(s_{n } ) } p[h_{n}=l_{n } ] ,   \\end{aligned}\\ ] ] which leads to @xmath266   =   \\xi_{n , k}(s_n)p[h_n = k ] \\nonumber \\\\ & \\prod_{m \\in { \\mathcal{n}}-\\{n\\ } } \\left ( \\sum_{k \\in { \\mathcal{k}}_{m } } \\xi_{m , k}(s_{m } ) p[h_{m}=k ] \\right ) . \\end{aligned}\\ ] ] now , we should calculate @xmath267 $ ] in ( [ eq : states_v4 ] ) .",
    "the state transition diagram for the states @xmath268 , @xmath269 and for the @xmath270th queue is shown in fig .",
    "[ fig : app_km_flows ] .    we can write the global balance equations for the state @xmath271 as @xmath272 \\bar{p}_{m,1}\\pi_{m}\\alpha_{m , k } + \\ldots + p[h_m = k][1 - \\bar{p}_{m , k}\\pi_{m } \\nonumber \\\\ & + \\bar{p}_{m , k}\\pi_{m}\\alpha_{m , k } ] + \\ldots + p[h_m = k_m ] \\bar{p}_{m , k_m}\\pi_{m}\\alpha_{m , k } = \\nonumber \\\\ &   p[h_m = k ] , \\end{aligned}\\ ] ] which is expressed as @xmath273 + \\ldots + \\bar{p}_{m , k } p[h_m = k ] + \\ldots + \\nonumber \\\\ & \\bar{p}_{m , k_m } p[h_m = k_m ]   ) = p[h_m = k ] \\bar{p}_{m , k } \\pi_{m } , \\end{aligned}\\ ] ] which leads to @xmath274 = p[h_m = k ] \\bar{p}_{m , k}.   \\end{aligned}\\ ] ] similarly , the global balance equations for state @xmath275 leads to @xmath276 = p[h_m = l ] \\bar{p}_{m , l}.   \\end{aligned}\\ ] ] from ( [ eq : app_state_mk ] ) and ( [ eq : app_state_ml ] ) , we have @xmath277\\bar{p}_{m , k}}{p[h_m = l]\\bar{p}_{m , l}}.\\end{aligned}\\ ] ] thus , we have @xmath278 = \\frac{\\alpha_{m , l}}{\\bar{p}_{m , l } } \\frac{p[h_m = k]}{\\alpha_{m , k } } \\bar{p}_{m , k}. \\end{aligned}\\ ] ] since @xmath279 = 1 $ ] should be satisfied , we have @xmath280 = \\frac{\\lambda_{m , k}/\\bar{p}_{m , k}}{\\sum_{l \\in { \\mathcal{k}}_{m } } \\lambda_{m , l } / \\bar{p}_{m , l}}. \\end{aligned}\\ ] ] when ( [ eq : app_prob_hm_k ] ) is substituted in ( [ eq : states_v4 ] ) , we have @xmath281   = \\xi_{n , k}(s_n ) \\frac{\\lambda_{n , k}/\\bar{p}_{n ,",
    "k}}{\\sum_{l \\in { \\mathcal{k}}_{m } } \\lambda_{n , l } / \\bar{p}_{n , l } } \\nonumber \\\\ & \\prod_{m \\in { \\mathcal{n}}-\\{n\\ } } \\frac{\\sum_{k \\in { \\mathcal{k}}_{m } } \\xi_{m , k}(s_m)\\lambda_{m , k}/\\bar{p}_{m , k}}{\\sum_{k \\in { \\mathcal{k}}_{m } } \\lambda_{m , k}/\\bar{p}_{m , k}}. \\end{aligned}\\ ] ] since @xmath282 , we have @xmath283   = \\xi_{n , k}(s_n ) \\frac{\\lambda_{n , k}/\\bar{p}_{n , k}}{\\sum_{l \\in { \\mathcal{k}}_{m } } \\lambda_{n , l } / \\bar{p}_{n , l } } \\nonumber \\\\ & \\prod_{m \\in { \\mathcal{n}}-\\{n\\ } } \\frac{\\sum_{k \\in { \\mathcal{k}}_{m } } \\rho_{m , k}(s_m)\\lambda_{m , k}}{\\sum_{k \\in { \\mathcal{k}}_{m } } \\lambda_{m , k}/\\bar{p}_{m , k}}. \\end{aligned}\\ ] ] when we substitute ( [ eq : states_v6 ] ) into ( [ eq : appa_1 ] ) , we have ( [ eq : lamdba_nk ] ) .",
    "this concludes the proof .",
    "let define a lyapunov function as ; @xmath284 , and the lyapunov drift as ; @xmath285 $ ] , where @xmath286 .",
    "then , the lyapunov drift is expressed as ; @xmath287 \\end{aligned}\\ ] ]    note that we have , from eq .",
    "( [ eq : queue_qn ] ) and the assumption @xmath288 that , @xmath289 + a_{n}(t ) \\sum_{k \\in { \\mathcal{k}}_{n}}(\\bar{p}_{n , k})^{\\beta}\\end{aligned}\\ ] ] using eq .",
    "( [ eq : appb_queue_qn ] ) in eq .",
    "( [ eq : appb_drift1 ] ) , and using the fact that @xmath290 , we have @xmath291\\end{aligned}\\ ] ] which is expressed as @xmath292\\end{aligned}\\ ] ] there always exist a finite and positive @xmath5 satisfying ; @xmath293 $ ] .",
    "thus , eq .  ( [ eq : appb_drift2 ] ) is expressed as ; @xmath294\\end{aligned}\\ ] ] note that if the flow arrival rates @xmath295 are inside the capacity region @xmath171 , then the minimizing the right hand side of the drift inequality in eq .",
    "( [ eq : appb_drift3 ] ) corresponds to the scheduling part of @xmath1 in eq .",
    "( [ eq : scheduling ] ) .",
    "now , let us consider again the stability region constraint in eq .",
    "( [ eq : appa_1 ] ) , which is @xmath69 @xmath151 @xmath296 1_{[s_n ] }   \\tau_{n}(s_1,\\ldots , s_n ) ,   \\forall",
    "n \\in { \\mathcal{n } } , k \\in { \\mathcal{k}}_{n}$ ] , and expressed as ; @xmath297   \\bigr ) 1_{[s_n ] } \\nonumber \\\\ & \\tau_{n}(s_1 \\ldots s_n)\\end{aligned}\\ ] ] which is equal to @xmath298    1_{[s_n ] } \\tau_{n}(s_1 \\ldots s_n)\\end{aligned}\\ ] ] since @xmath299 , we have @xmath300    1_{[s_n ] } \\tau_{n}(s_1 \\ldots s_n)\\end{aligned}\\ ] ] @xmath301    1_{[s_n ] } \\tau_{n}(s_1 \\ldots s_n)\\end{aligned}\\ ] ] @xmath302    \\frac{1_{[s_n]}\\tau_{n}(s_1 \\ldots s_n)}{\\sum_{k \\in { \\mathcal{k}}_{n } }   ( \\bar{p}_{n , k})^{\\beta } } \\end{aligned}\\ ] ] let @xmath303}\\tau_{n}(s_1 \\ldots s_n)$ ] .",
    "then , eq .  ( [ eq : appb_gec1 ] ) is expressed as ; @xmath304    \\frac{g_n}{\\sum_{k \\in { \\mathcal{k}}_{n } }   ( \\bar{p}_{n , k})^{\\beta } } \\end{aligned}\\ ] ] there exists a small positive value @xmath305 satisfying @xmath306    \\frac{g_n}{\\sum_{k \\in { \\mathcal{k}}_{n } }   ( \\bar{p}_{n , k})^{\\beta } } \\end{aligned}\\ ] ] thus , we can find a randomized policy satisfying @xmath307 \\leq -\\epsilon\\end{aligned}\\ ] ]    now , let us consider eq .",
    "( [ eq : appb_drift3 ] ) again , which is expressed as ; @xmath308\\end{aligned}\\ ] ] we minimize the right hand side of eq .",
    "( [ eq : appb_drift3 ] ) , so the following inequality satisfies ; @xmath309 \\leq e \\bigl [   { { \\mathop{a}\\limits^{\\vbox to -.5\\ex@{\\kern-\\tw@\\ex@ \\hbox{\\scriptsize * } \\vss}}}}_{n}(t ) -   \\frac{{{\\mathop{g}\\limits^{\\vbox to -.5\\ex@{\\kern-\\tw@\\ex@ \\hbox{\\scriptsize * } \\vss}}}}_{n}(t)}{\\sum_{k \\in { \\mathcal{k}}_{n } } ( \\bar{p}_{n , k})^{\\beta } } \\nonumber \\\\ & | \\boldsymbol q(t)\\bigr]\\end{aligned}\\ ] ] where @xmath310 and @xmath311 are the solutions of a randomized policy . incorporating eq .  ( [ eq : appb_randep ] ) in eq .  ( [ eq : appb_drift4 ] ) , we have @xmath312 the time average of eq .",
    "( [ eq : appb_drift5 ] ) leads to @xmath313\\end{aligned}\\ ] ] @xmath314 this concludes that the time average of the queues are bounded if the arrival rates are inside the capacity region @xmath171 .",
    "now , let us focus on the original claim of theorem  [ theorem2 ] .",
    "let us consider a drift+penalty function as ; @xmath315   \\leq \\nonumber \\\\ & b + e \\bigl",
    "[ \\sum_{n \\in { \\mathcal{n } } } q_{n}(t ) \\bigl(a_{n}(t ) -   \\frac{g_{n}(t)}{\\sum_{k \\in { \\mathcal{k}}_{n } } ( \\bar{p}_{n , k})^{\\beta } } \\bigr ) | \\boldsymbol q(t)\\bigr ] - \\nonumber \\\\ & \\sum_{n \\in { \\mathcal{n } } } \\sum_{k \\in { \\mathcal{k}}_{n } } m e[u_{n , k } ( \\lambda_{n , k}(t ) ) | \\boldsymbol q(t ) ] \\end{aligned}\\ ] ] since we set @xmath295 , we have @xmath316   \\nonumber \\\\ &",
    "\\leq   b + \\sum_{n \\in { \\mathcal{n } } } e \\bigl [   q_{n}(t ) \\bigl(a_{n}(t ) -   \\frac{g_{n}(t)}{\\sum_{k \\in { \\mathcal{k}}_{n } } ( \\bar{p}_{n , k})^{\\beta } } \\bigr ) | \\boldsymbol q(t)\\bigr ] - \\nonumber \\\\ & \\sum_{n \\in { \\mathcal{n } } } \\sum_{k \\in { \\mathcal{k}}_{n } } m e[u_{n , k } ( a_{n}(t ) ( \\bar{p}_{n , k})^{\\beta } ) | \\boldsymbol q(t ) ] \\end{aligned}\\ ] ] note that minimizing the right hand side of eq .",
    "( [ eq : appb_dpp1 ] ) corresponds to the flow control and scheduling algorithms of @xmath1 in eq .",
    "( [ eq : flow_control ] ) and eq .",
    "( [ eq : scheduling ] ) , respectively . since there exists a randomized policy satisfying eq .",
    "( [ eq : appb_randep ] ) , eq .",
    "( [ eq : appb_dpp1 ] ) is expressed as @xmath317   \\nonumber \\\\ & \\leq   b - \\epsilon \\sum_{n \\in { \\mathcal{n } } } q_{n}(t ) - \\sum_{n \\in { \\mathcal{n } } } \\sum_{k \\in { \\mathcal{k}}_{n } } m u_{n , k}(a_n(\\bar{p}_{n , k})^{\\beta } + \\delta ) \\end{aligned}\\ ] ] where @xmath318 is the maximum time average of the sum utility function that can be achieved by any control policy that stabilizes the system .",
    "then , the time average of eq .",
    "( [ eq : appb_dpp2 ] ) becomes @xmath319    \\biggr \\ }",
    "\\leq   \\nonumber \\\\ & \\limsup_{t \\rightarrow \\infty }   \\frac{1}{t } \\sum_{\\tau = 0}^{t-1 }   \\biggl \\ { b - \\epsilon \\sum_{n \\in { \\mathcal{n } } } q_{n}(\\tau ) - \\nonumber \\\\ &",
    "\\sum_{n \\in { \\mathcal{n } } } \\sum_{k \\in { \\mathcal{k}}_{n } } m u_{n , k } ( a_n(\\bar{p}_{n , k})^{\\beta } + \\delta )   \\biggr \\}\\end{aligned}\\ ] ] now , let us first consider the stability of the queues . if both sides of eq .  (",
    "[ eq : appb_dpp3 ] ) is divided by @xmath305 and the terms are arranged , we have @xmath320 \\bigr \\ } - \\sum_{k \\in { \\mathcal{n } } } \\sum_{k \\in { \\mathcal{k}}_{n } } \\frac{m}{\\epsilon } u_{n , k } ( a_n(\\bar{p}_{n , k})^{\\beta } + \\delta)\\end{aligned}\\ ] ] since the right hand side is a positive finite value , this concludes that the time averages of the total queue sizes are bounded .",
    "now , let us consider the optimality . if both sides of eq .",
    "( [ eq : appb_dpp3 ] ) are divided by @xmath183 , we have @xmath321 \\leq   \\nonumber \\\\ & \\limsup_{t \\rightarrow \\infty }   \\frac{1}{t } \\sum_{\\tau = 0}^{t-1 }   \\bigl \\ { \\frac{b}{m } - \\frac{\\epsilon}{m } \\sum_{n \\in { \\mathcal{n } } } q_{n}(\\tau ) - \\nonumber \\\\",
    "& \\sum_{n \\in { \\mathcal{n } } } \\sum_{k \\in { \\mathcal{k}}_{n } }   u_{n , k } ( a_n(\\bar{p}_{n , k})^{\\beta } + \\delta )   \\bigr \\}\\end{aligned}\\ ] ] by arranging the terms , we have @xmath322 \\geq   \\nonumber \\\\ & \\limsup_{t \\rightarrow \\infty }   \\frac{1}{t } \\sum_{\\tau = 0}^{t-1 }   \\bigl \\ {   \\sum_{n \\in { \\mathcal{n } } } \\sum_{k \\in { \\mathcal{k}}_{n } }   u_{n , k } ( a_n(\\bar{p}_{n , k})^{\\beta } + \\delta ) - \\frac{b}{m } \\nonumber \\\\ & + \\frac{\\epsilon}{m } \\sum_{n \\in { \\mathcal{n } } } q_{n}(\\tau )   \\bigr \\}\\end{aligned}\\ ] ] since @xmath323 is positive for any @xmath324 , we have @xmath322 \\geq   \\nonumber \\\\ & \\limsup_{t \\rightarrow \\infty }   \\frac{1}{t } \\sum_{\\tau = 0}^{t-1 }   \\bigl \\ {   \\sum_{n \\in { \\mathcal{n } } } \\sum_{k \\in { \\mathcal{k}}_{n } }   u_{n , k } ( a_n(\\bar{p}_{n , k})^{\\beta } + \\delta ) - \\frac{b}{m }    \\bigr \\}\\end{aligned}\\ ] ] which leads to @xmath322 \\geq   \\nonumber \\\\ & \\sum_{n \\in { \\mathcal{n } } } \\sum_{k \\in { \\mathcal{k}}_{n } }   u_{n , k } ( a_n(\\bar{p}_{n , k})^{\\beta } + \\delta ) - \\frac{b}{m } \\end{aligned}\\ ] ] this proves that the admitted flow rates converge to the utility optimal operating point with increasing @xmath183 .",
    "this concludes the proof ."
  ],
  "abstract_text": [
    "<S> we investigate the performance of first - in , first - out ( fifo ) queues over wireless networks . </S>",
    "<S> we characterize the stability region of a general scenario where an arbitrary number of fifo queues , which are served by a wireless medium , are shared by an arbitrary number of flows . in general </S>",
    "<S> , the stability region of this system is non - convex . </S>",
    "<S> thus , we develop a convex inner - bound on the stability region , which is provably tight in certain cases . </S>",
    "<S> the convexity of the inner bound allows us to develop a resource allocation scheme ; @xmath0 . </S>",
    "<S> based on the structure of @xmath0 , we develop a stochastic flow control and scheduling algorithm ; @xmath1 . </S>",
    "<S> we show that @xmath1 achieves optimal operating point in the convex inner bound . </S>",
    "<S> simulation results show that our algorithms significantly improve the throughput of wireless networks with fifo queues , as compared to the well - known queue - based flow control and max - weight scheduling .    </S>"
  ]
}