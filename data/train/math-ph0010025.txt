{
  "article_text": [
    "it is already more than 10 years ago that the symbolic manipulation program form was introduced . at the time it was constructed more or less as a successor to schoonschip  @xcite which , due to the limitations of its language of implementation , became harder and harder to use .",
    "in addition the continuous development of methods of computation in many fields of science required a rapid expansion of the possibilities of the symbolic programs .",
    "admittedly programs like reduce , maple and mathematica offer a host of possibilities combined with extensive libraries , but the speed of schoonschip was always something that set it apart from the other programs .",
    "hence the task was to create a program that would be at least as fast as schoonschip and be fully portable . in particular it should be usable on the fastest computers that are suitable for this kind of work ( eg .",
    "vector processors will rarely give great benefits to symbolic manipulation in general . as we will see this is completely different for parallel processing ) .",
    "this resulted in version 1 of form . due to more modern algorithms and the benefits of a second generation approach",
    "it is actually somewhat faster than schoonschip when the problems remain limited in size and much faster when the expressions become large .",
    "compared to the more popular computer algebra systems the difference in speed and use of memory depends largely on the type of the problem .",
    "this is due to a completely different philosopy of design and use .",
    "typical factors are between 10 and 100 , but there have been rare cases for which the factor was considerably less and cases for which the factor was considerably larger .",
    "such a factor translates into a timeshift with respect to when a given calculation can be done in practise with other programs . over the past years",
    "the computer industry has given us on average every three years a factor 4 in increase in capabilities .",
    "hence for form this translates into a shift of more than 5 years . as a consequence",
    "most of the calculations in quantum field theory for which the available computer resources are a consideration have been using form over the past years .",
    "of course the development of form has continued .",
    "version 2.0 was introduced in 1991 .",
    "it contained a number of improvements that were inspired by the use of the program in a number of actual research projects .",
    "since then regular small improvements were made , dictated by more and more complicated projects .",
    "after a number of years it became clear that a number of fundamental internal changes would enhance the capabilities very much and hence work on version 3 was started .",
    "most of the code of version 2 was replaced , introducing better structured ways of dealing with internal objects .",
    "even though the language of implementation is still regular c , the methods used are in many cases those of object oriented programming .",
    "it was of course important to do this in such a way that the speed and compactness of the expressions would not suffer from this .",
    "this has been achieved .",
    "after this revamping the new facilities were added .",
    "some of them are completely new in the field of symbolic manipulation .",
    "this does not set the claim that such things are impossible with other programs .",
    "it just means that the form approach to some things is far more direct and often easier to program , even if some people may not like the language .    in this paper",
    "the most important new features are described shortly . in most cases",
    "some short examples of code are given with the corresponding output .",
    "it should be understood that this paper is not a manual . because a number of packages comes with the form distribution ,",
    "the examples to illustrate the features come mainly from these packages .",
    "in addition there are examples from some incomplete future packages . to improve the understanding of the above ,",
    "first a very short description of form is given .",
    "there is also a short section on a parallel version of form .",
    "it looks like this will be a major new feature that is currently still under development but results have been obtained already with one of the packages . the actual target is to run nearly unmodified form programs ( the mincer package that has been used already was not modified at all ) on a number of processors in such a way that to the user it looks like a much faster sequential machine .",
    "this is very useful for among others the development cycle of big programs .",
    "the final section discusses the availability of form . in the appendix",
    "we give a short description of the packages with some examples of their use .",
    "here a very brief overview of form is given .",
    "for a complete introduction one can consult the manual which contains a complete tutorial and a reference section .",
    "form is not an interactive system .",
    "it runs in batch . in unix terms",
    "one would say that form is a filter . for large programs",
    "this is the natural mode anyway .",
    "it also allows the user to prepare programs with a familiar editor .",
    "the editor used by the author is stedi which has a folding capability that is recognized by form .",
    "the sources of this editor are available in the form distribution as well .",
    "if everan interactive version will be constructed , it will be based on this editor .",
    "the language of form uses strong typing .",
    "this means that all objects that will be used in a program will have to be declared .",
    "this allows form to use a number of properties of such objcets and this adds to the speed of the program .",
    "algebraic objects in form are expressions , symbols , functions , vectors and indices . in addition",
    "there are $ -expressions , sets , numbers , preprocessor variables and argument field wildcards .",
    "the functions are subdivided in categories of commuting and noncommuting functions .",
    "additionally there are the classes of tensors , tables and regular functions .",
    "the basic _ modus operandi _ of form is that variables are declared .",
    "then one or more expressions are defined by giving them initial contents .",
    "after that operations are applied to one or more of these expressions .    a form program is subdivided in modules .",
    "each module is an individual entity of which the contents are compiled when it is the turn of the module to be executed .",
    "after the module has been executed , the compiled version is forgotten again , but depending on the type of the module , declarations and expressions will be kept .",
    "hence at the level of complete modules form acts as an interpreter .",
    "the contents of expressions as they were at the start of the module will be forgotten , unless the user takes some special action .",
    "this is needed to prevent the disk from filling up too quickly . at the beginning of each module",
    "extra variables can be declared and new expressions can be defined . if necessary old expressions can be deleted . in principle",
    "the operations of the module are applied to all old and new expressions .",
    "the basic object for manipulation is the term .",
    "expressions consist of terms , separated by addition operators ( or subtraction of course ) .",
    "this addition operator is commutative and associative .",
    "function arguments can consist of subexpressions , i.e. smaller expressions which are limited in size .",
    "such subexpressions also consist of terms .",
    "terms consist of subterms .",
    "the subterms are separated by the multiplication operator .",
    "this multiplication operator is associative and usually commutative . only in the case of noncommuting functions and still unsubstituted objects that could contain noncommutative functions",
    "is the multiplication order sensitive .",
    "the number zero is not considered to be a term .",
    "an expression that is zero contains no terms .",
    "form works its way through an expression in a sequential manner .",
    "it starts with the first term , applies all statements of a module to it and puts the results away for sorting ( normal ordering of the complete expression is called sorting here .",
    "it does involve adding coefficients of terms that are identical with the exception of their prefactor ) .",
    "partial sorting may occur when buffers become too full .",
    "after all terms of an expression have been treated this way the sorting is completed .",
    "once all expressions have been treated this way the new versions of the expressions replace the old versions",
    ".    the actions inside a module can be either predefined operations or substitutions that may involve rather complicated patterns involving wildcarding .",
    "wildcarding is the use of generic variables that represent a whole category of objects , both in the left hand side ( the pattern ) and in the right hand side ( the replacement expression ) .",
    "a number of special functions is available to make the use of the program easier and often much faster .",
    "these involve amoung others a sum function , a number of combinatoric functions and a number of numerical functions .",
    "in addition there are special tensors like the kronecker delta and the levi civita tensor .",
    "and there is much more .    for the use in particle physics",
    "there are dirac gamma matrices and trace operations .",
    "it should be noted however that this is nowadays a rather unimportant part of the program as there exist many facilities to emulate these objects and operations ( and similar operations that can be much more complicated ) .",
    "results of a calculation can be presented in many different ways .",
    "one way is to print them to regular output .",
    "they can be written to file in internal notation for use in future form programs . or they can be written to special files , etc .",
    "there is a powerful preprocessor that can manipulate the input at the character level .",
    "it is fully adapted to the requirements of symbolic manipulation .",
    "there are now also some mechanisms for the feedback of algebraic results to the preprocessor .",
    "this facilitates the possibility to have form programs write parts of themselves .",
    "a number of buffers in form have to be allocated at startup .",
    "the user can influence these allocations with a special setup file .",
    "ordinarily this is considered an advanced feature .",
    "for the description of the new features it is assumed that the user has some experience with the older versions .",
    "the distribution contains a good tutorial .",
    "the interested reader without experience could look at the many examples in it . here",
    "we concentrate on the new concepts . for a complete description and the exact syntax and for the many additional new features we refer to the new manual .",
    "the complete internal adminstration of variables has been made dynamic .",
    "this means that the old restrictions on the number of variables have been lifted .",
    "the setup file is no longer needed when more than 100 variables of the same type are asked for .",
    "the limit lies now at 6000 for 32-bit systems and @xmath0 for 64-bit systems .",
    "similarly the compiler buffer , the input buffer and the various preprocessor buffers are arranged dynamically .",
    "the reason that in the older versions these things were set up in a static way was due to the size of the computer memories in the late 80 s .",
    "preprocessor variables can be used ` recursively ' . the old notation to enclose a preprocessor variable in quotes has been changed into a notation in which the variable is enclosed in a backquote - quote pair as if these are brackets . this way they can be nested as in    ....",
    "# do itabs = 1,`size ' # ifndef ` stable`itabs'hfile ' # call table`itabs ' # endif # enddo ....    in the summer package there are 8 files table`itabs'.prc all having something like :    .... # procedure table5 # ifndef ` stable5hfile ' # define   stable5hfile \" 1 \"      lots of tables # endif # endprocedure ....    this way the procedures are not called twice . of course",
    "the contents would not be used twice anyway , but some of them are rather lengthy and form would have to read the whole procedure to find the @xmath1endif .",
    "that is avoided this way .    to make the preprocessor variables even more powerful",
    "there are also postincrement and postdecrement operators for preprocessor variables as in the c language :    ....       # define k \" 1 \"       local f`k++ ' = ... ;       local f`k++ ' = ... ;       local f`k++ ' = ... ;       local f`k++ ' = ... ; ....    would result in the definitions of ` f1 ` to ` f4 ` . in the end ` k ` would have the value 5 .",
    "this is particularly handy when the program is generating expressions and we do not know in advance how many .",
    "the notation has been cleaned up a bit by introducing a new operator for the compilation stages .",
    "this operator is indicated by three dots as in    ....",
    "symbols x1, ... ,x100 ;      local fac10 = 1* ... *10 ; ....    actually there is an even more general notation involving @xmath2 :    ....      i d   f(<p1?,m1?,i1?>, ... ,<p6?,m6?,i6",
    "? > ) =   ....    here the @xmath2 enclose a pattern .",
    "form will look for the differences in the begin pattern and the end pattern , calculate their numerical differences and if they all have the same absolute value we can make a ` running pattern ' and make the substitution .",
    "hence    ....      i d   f(<p1,m4>, ... ,<p4,m1 > ) =   ....    would evaluate into    ....      i d   f(p1,m4,p2,m3,p3,m2,p4,m1 ) =   ....    this facility can not be used recursively but already it can clean up the code considerably when compared to how one would have to do this with do loops in the old versions of form .",
    "it becomes really powerful in combination with preprocessor variables :    ....      # do j = 1,`max'-1          i d   e_(i1?, ...",
    ") =                  sum_(k,1,`max',e_(i1, ... ,i`j',k)*f(`j'+1,k ) ) ;          i d   f(`j',k ? )",
    "= tab(`j',k ) ;          .sort : step ` j ' ;      # enddo      i d   e_(1, ... ,`max ' ) = 1 ; ....    this would be the central step in computing the determinant of a matrix that has been defined in the two dimensional table named tab .",
    "we use an intermediate function f to make sure that first the levi - civita tensors with two indentical indices are killed before table substitution is attempted .",
    "this is a very efficient algorithm for sparse matrices , especially when the matrices have been ordered in such a way that the first columns have the largest number of zeroes .",
    "these variables are at the same time small algebraic expressions and character strings .",
    "they can be used as either . when they are used and they are enclosed between a backquote - quote pair , the compiler will make their character representation and substitute this like a preprocessor variable .",
    "this use as a preprocessor variable even includes the possibility of using the postincrement or postdecrement operators .",
    "if they are not enclosed between the backquote - quote pair the contents are seen as an algebraic expression to be used during execution time .",
    "this can lead to very flexible code .",
    "if they are to be given an initial value , this can be done with the character @xmath1 before their name to have the preprocessor provide the value ( hence this is done once during compilation time ) , or without the @xmath1 to indicate that this value should be provided during execution , each time a term passes this position in the code .",
    "there are additional methods to provide the $ -variables with a value that is the match of a wildcard variable .",
    "let us have a look at an example :    ....      # $ max = -100 ;      if ( count(x,1 ) > $ max ) $ max = count_(x,1 ) ;      .sort      # do i = 1,`$max '          ...      # enddo ....    here we give ` $ max ` the initial value -100 . during execution",
    "we look for the maximum power of the variable ` x ` .",
    "once the module has finished this maximum should be indeed the value of ` $ max ` , provided it is at least -100 .",
    "at this point we can use this value as a parameter in a do loop .",
    "note that the .sort is essential , because if we were to omit it , the do loop would have the bounds 1,-100 because the do loop instruction would be translated before any algebraic manipulation would have taken place ( first the complete module is translated , then execution takes place ) .",
    "it is also possible to manipulate the contents of the $ -variables , provided these do make sense .",
    "the contents of these $ -variables are kept in memory .",
    "this means that the user should not try to see them as a substitute for regular expressions and have some of them grow to a large size .",
    "it would work , but performance might suffer when the physical memory is exhausted in the same way that mathematica and maple become rather disagreeable when they need more memory than is available .      when there are several expressions active at the same time , sometimes there is the need to temporarily put some of them ` out of the way ' .",
    "form has several mechanisms for this .",
    "the skip statement would just skip the indicated expression(s ) by copying them directly from the input to the output of the module .",
    "this is not always efficient .",
    "in addition one has to specify this in each module seperately .",
    "a more basic solution is to copy the expression(s ) to a special location where they remain suspended until called back .",
    "this is done with the hide and unhide statements .",
    "the hidden expressions can still be used in the right hand side of expressions in the same way as fully active expressions can be used .",
    "this is a faster mechanism than the one that is used with stored expressions .    ....",
    ".sort      hide f1,f2 ;      local f4 = f1+f3 ;      .sort           more modules      .sort      unhide f1,f2 ;      i d   x = y+1 ; ....    here f1 and f2 are not operated upon for a few modules .",
    "then they are called back and they are immediately active again .",
    "this means that the substitution of x also holds for the terms of f1 and f2 .",
    "there is another mechanism when one or a few statements should be applied only to a limited number of expressions .",
    "this concerns a new option of the if statement :    ....      if ( expression(g ) = = 0 ) ;         statements      endif ; ....    in this case the statements are applied to the terms of all active expressions except for the terms of the expression g.      this is a preprocessor controled instruction that can write either to regular output , to the log file or to any named file .",
    "it has a format string as in the printf function of the c language .",
    "it specifies what should be printed .",
    "there are some examples in which complete procedure files are constructed this way for later use in the same program .",
    "the new feature of the print statement is a mode like printf in the c language that can print information during execution .",
    "it can handle the printing of messages and even individual terms or $ -variables .",
    "this gives it great value as a debugging tool .",
    "a good example is given with the splitarg statement in [ splitarg ] .",
    "this facility involves a statement , a special function and a special print statement . the table _ function can be used to load the contents of a table into an expression .",
    "the table indices are represented by powers of a given set of symbols .",
    "the fillexpression statement does the opposite .",
    "it takes an expression that is bracketed in a number of symbols and loads the contents into a table .",
    "the powers of the symbols indicate the table indices and the contents of the brackets form the corresponding table elements .",
    "the printtable statement writes a table to file in the form of fill statements .",
    "this file can be used in a future program to fill the table .",
    "together these facilities allow the dynamic extension of tables in a program .",
    "if a table element that is needed has not yet been defined , one could compute it on the spot and add it to the table .",
    "the results can be written in such a way that in future programs the same element does not have to be recalculated .",
    "functions can have properties of symmetry .",
    "these properties hold for the set of all arguments .",
    "the functions or tensors can be symmetric , antisymmetric , cyclesymmetric and reversecyclesymmetric .",
    "this last means that the function is invariant both under cyclic permutations and a complete reversal of all arguments .",
    "these properties are put in the declaration of the function or tensor . each time some arguments of the function are changed , form will check whether permutations have to be made .",
    "there are some restrictions .",
    "form will not accept argument field wildcards ( wildcards that match zero , one or more function arguments ) in patterns in which such a wildcard occurs inside a symmetric or antisymmetric function .",
    "the pattern matching would become extremely slow when no match occurs ( all possibilities have to be searched and that involves n ! possibilities for n arguments ) .",
    "there are tricks to circumvent this in most cases .      in combination with the symmetry properties form",
    "has now a command to look for loop structures in argument contractions .",
    "what this means is that if we have a network in which v is a vertex function and its arguments are indices and connections are represented by two vertices having identical indices , form can find the smallest loop in such a structure and make replacements based on this .",
    "there are some examples in the color package in which the vertex function is the antisymmetric tensor f with three indices .",
    "in the program    .... # - indices i1, ... ,i9 ; cf f(antisymmetric),ff ; local f = f(i1,i2,i3)*f(i2,i4,i5)*f(i3,i5,i6 ) *            f(i4,i7,i8)*f(i6,i7,i9)*f(i1,i8,i9 ) ; replaceloop , f ,",
    "arguments=3,loopsize = all , outfun = ff ; print + f ; .end ....    the replaceloop command takes the smallest loop , removes the loop indices and puts the remainder in the output function ff which should be at least cyclesymmetric ( at least the action we take here implies it ) .",
    "if there is more than one possibility form takes the first one it encounters .",
    "the result of this program is    ....     f = f(i1,i8,i9)*f(i4,i7,i8)*f(i6,i7,i9)*ff(i1,i6,i4 ) ; ....    only a single loop has been replaced .",
    "if one would like to replace all loops one should put a repeat / endrepeat combination around the replaceloop statement .",
    "this would result in    ....     f = - ff(i1,i4,i6)*ff(i1,i6,i4 ) ; ....    if such a command would not exist , the color package would be much more restricted because it would need a statement for each loop ( loops with one vertex , two vertices , three vertices etc . ) also the corresponding pattern matching would be much slower . in the crucial phases of the program this made a factor 10",
    "difference in speed and it also made the code much shorter .",
    "this is a rather useful tool for investigating arguments of functions . in its basic form",
    "it splits a multiterm argument into a number of arguments , each with a single term .",
    "there are variations for faster operation when only a single term should be taken from the multiterm argument .",
    "take for instance the following example in which we want to select all functions den that contain the symbol ` j1 ` in its argument .    ....",
    "splitarg,((j1)),den ; * take all terms in j1 separately      i d   den(j1 ) = den1(0,j1 ) ; * a single term does not get split      *                            we may need more of these statements      i d   den(x?,x1 ? ) = den1(x / x1*j1,j1)/x1*j1 ; * normalize the j1 argument .",
    "*      * all den with two arguments have now just j1 without factor .",
    "*      repeat i d den1(x?,j1)*j1 = 1-x*den1(x , j1 ) ;      repeat i d den1(x1?!{x2?},j1)*den1(x2?!{x1?},j1 ) =                 ( den1(x1,j1)-den1(x2,j1))*den(x2-x1 ) ;      i d   den(x?number _ ) = 1/x ; ....    code of this nature occurs frequently in the summer package .",
    "it splits the fractions , being careful not to divide by zero ( in some cases one has to be far more careful and involve theta _ and delta _ functions ) .",
    "let us see what this code does .",
    "we use the following program ( this is also a demonstration of the new print statement capabilities ) :    .... # - s    j1,x , x1,x2 ; cf   den , den1 ; off statistics ; l    f = den(j1)*den(2+j1)*den(3 - 2*j1 ) ;    print + f \" < 1 > % t \" ; splitarg,((j1)),den ;    print + f \" < 2 > % t \" ; i d   den(j1 ) = den1(0,j1 ) ;    print + f \" <3 > % t \" ; i d   den(x?,x1 ? ) = den1(x / x1*j1,j1)/x1*j1 ;    print + f \" < 4 > % t \" ; repeat i d den1(x?,j1)*j1 = 1-x*den1(x , j1 ) ;    print + f \" < 5 > % t \" ; repeat ;      i d den1(x1?!{x2?},j1)*den1(x2?!{x1?},j1 ) =           ( den1(x1,j1)-den1(x2,j1))*den(x2-x1 ) ;      print + f \" < 6 > % t \" ; endrepeat ; i d   den(x?number _ ) = 1/x ;    print + f \" < 7 > % t \" ; print + f ; .end ....    which results in    ....      # - < 1 >   + den(j1)*den(2 + j1)*den(3 - 2*j1 ) < 2 >   + den(2,j1)*den(3 , - 2*j1)*den(j1 ) <3 >   + den(2,j1)*den(3 , - 2*j1)*den1(0,j1 ) < 4 >   - 1/2*den1(0,j1)*den1(2,j1)*den1 ( - 3/2,j1 ) < 5 >   - 1/2*den1(0,j1)*den1(2,j1)*den1 ( - 3/2,j1 ) < 6 >   - 1/2*den(2)*den1(0,j1)*den1 ( - 3/2,j1 ) < 6 >   - 1/2*den(2)*den ( - 3/2)*den1(0,j1 ) < 6 >   - 1/2*den(2)*den ( - 3/2)*den1(0,j1 ) < 7 >   + 1/6*den1(0,j1 ) < 6 >   + 1/2*den(2)*den ( - 3/2)*den1 ( - 3/2,j1 ) < 6 >   + 1/2*den(2)*den ( - 3/2)*den1 ( - 3/2,j1 ) < 7 >   - 1/6*den1 ( - 3/2,j1 ) < 6 >   + 1/2*den(2)*den1(2,j1)*den1 ( - 3/2,j1 ) < 6 >   + 1/2*den(2)*den ( - 7/2)*den1(2,j1 ) < 6 >   + 1/2*den(2)*den ( - 7/2)*den1(2,j1 ) < 7 >   - 1/14*den1(2,j1 ) < 6 >   - 1/2*den(2)*den ( - 7/2)*den1 ( - 3/2,j1 ) < 6 >",
    "- 1/2*den(2)*den ( - 7/2)*den1 ( - 3/2,j1 ) < 7 >   + 1/14*den1 ( - 3/2,j1 )       f =         - 2/21*den1 ( - 3/2,j1 ) + 1/6*den1(0,j1 ) - 1/14*den1(2,j1 ) ; ....    note that the termwise option of the print statement gives us a trace of what happens and in what order .",
    "sometimes one needs to work things out for just a few terms , but an intermediate sort for the results of these manipulations is needed in order to have things cancel . or one would like to do even fancier things like trying whether the contents of certain brackets can be factorized by a given expression .",
    "if so , one would like to make that factorization .",
    "the term environment defines the current term temporarily as a small expression . because this is done during the processing of the terms , sorting can not be done with the .sort instruction which works for the whole expression .",
    "this means that we need a separate sort statement for all these small expressions .",
    "it should however be noted that the complete term environment consisting of the term statement , the endterm statement , and the intermediate regular statements and sort statements are all part of the same module and hence are all compiled before execution starts .",
    "basically we use the same mechanism of operation in the argument environment .",
    "there function arguments can be operated upon and when the endargument statement is encountered the results are sorted and put back inside the function .",
    "the sort statement is hence equivalent to an endargument statement followed by a new argument statement .",
    "this last construction has the limitation that the result has ` to fit ' and hence is limited to maxtermsize or less .",
    "the term environment does not suffer from this restriction because we do not have to keep the results inside a function argument and also in the intermediate stages even the disk can be used and the expression may be quite large .    .... # - s    x , y,[x+1],[x+2],x1,x2 ; cf   acc ; l    f = y*(x+1)^2*(x+2)+y^2*(x+1)*x+y^3*(x+2)*x+y^4*x^2 ; b    y ; print + f ; .sort collect , acc ; term ;      $ min1 = 1000 ;      $ min2 = 1000 ;      i d acc(x ? ) = x ;      i d   x = x1 - 1 ;      sort ;      if ( count(x1,1 ) < $ min1 ) $ min1 = count_(x1,1 ) ;      sort ;      multiply ( [ x+1]/x1)^$min1 ;      i d   x1 = x+1 ;      i d   x = x2 - 2 ;      sort ;      if ( count(x2,1 ) < $ min2 ) $ min2 = count_(x2,1 ) ;      sort ;      multiply ( [ x+2]/x2)^$min2 ;      i d   x2 = x+2 ; endterm ; print + f ; .end ....    which gives    ....      # -       f =         + y * ( 2 + 5*x + 4*x^2 + x^3 )         + y^2 * ( x + x^2 )         + y^3 * ( 2*x + x^2 )         + y^4 * ( x^2 ) ;       f =        x*y^2*[x+1 ] + x*y^3*[x+2 ] + x^2*y^4 + y*[x+1]^2*[x+2 ] ; ....    of course this works only if one has a suspicion which factors are involved and things would go much better if form would be able to deal with factorizations by itself .",
    "this is considered for the future . for",
    "now this provides at least a partial solution .      in the old versions form",
    "would look for the contents of brackets inside an expression in a sequential manner .",
    "for relatively small expressions in computers with not much memory this was still not optimal , but also not a complete disaster . with the growing of the computers and hence the expressions the inefficiency of this method became a major factor as it is an algorithm that has a linear dependence of the size of the expression .",
    "hence now the brackets can be indexed if the user asks for it .",
    "the index will of course take space of its own , and this space can approach ( in principle ) the size of the expression if the brackets have very little contents .",
    "this could result in bad problems again .",
    "therefore there is a maximum to the size of the index ( can be changed in the setup file ) and when this maximum is reached form will start skipping brackets in the index .",
    "if such a skipped bracket is asked for , form will do a linear search , starting from the nearest bracket in front of it .",
    "the result is still a speedup by a big factor .",
    "the brackets in the index are located by a tree - like binary search which gives a logarithmic dependence of the number of brackets in the index .",
    "the degrading factor when brackets are skipped is proportional to the size of the expression divided by the number of brackets in the index .",
    "hence in that case the improvement is proportional to a factor @xmath3 with b the number of brackets in the index .",
    "usually however there should be no problem in fitting the entire index inside the memory . because this use of brackets is not very common and the making of the index does cost resources , the default is to not make an index .",
    "here we have a simple example    .... # - symbols   x1, ... ,x10 ; local     f = ( x1+ ... +x10)^10 ; bracket+ x1 ; .sort drop f ; # do i = 0,10 local     f`i ' = f[x1^`i ' ] ; # enddo .end ....    when we run this program the second module takes 1.59 sec on a pentium 300 . without the + in bracket+ this step takes 2.84 seconds and this is not a very big expression yet .",
    "the program that solves the equations for the values in @xmath4 in the summer package had an improvement factor of more than 100 .",
    "the error messages have been changed completely .",
    "the most noticeable change is the indication of where the error occurs when the input listing is off .",
    "this mode is standard for procedures .",
    "there are additional warnings and there is a way to let form print its interpretation of the input . together with the already existing printing of the name lists this provides extra tools for the debugging of form programs . in this example",
    "we have made two errors .",
    "it is the program of the bracket index .",
    "the name of the file is ex1.frm .",
    "because we had turned off the listing , the line number information is rather crucial :    .... # - symbols   x1, ... ,x10 ; local     f = ( x1+ ... +x10)^^10 ; bracket+ x1 ; .sort drop f ; # do i = 0,10 local     f`i ' = ff[x1^`i ' ] ; # enddo .end ....    when this program is run we obtain :    ....      # - ex1.frm line 3 -- > illegal position for operator : ^10 ex1.frm line 8 -- > undeclared variable ff + + + + errors in loop ....    because nearly all error messages have been changed and actually the complete compiler has been replaced , it is possible that some error messages either do not make complete sense or are too vague . the author is open for suggestions .",
    "because of the way form processes expressions it should be possible to achieve a high degree of parallelization for the complete program . after an initial study at the special computer at fnal in 1991 this assumption was verified .",
    "it took however till the late 90 s before a more serious attempt was made .",
    "this was made possible in the framework of a large phenomenology project centered at the university of karlsruhe ( dfg contract ku 502/8 - 1 ) .",
    "two people worked part time on this ( albert rtey and denny fliegner ) and after struggling for a long time with the hardware and the parallelization library software they did indeed manage to obtain a working version of form that can run the mincer package on an eight processor machine with a speed that ranges from 3 to 5 times the speed of a single processor . in addition many tests were made with other architectures  @xcite .",
    "it should be noted that thus far the parallelization has been rather crude .",
    "the terms of the input expression in a module are distributed over the various processors .",
    "these do their work , and they sort their results .",
    "after this the outputs are collected by the master processor for a final merge and the output is written to disk .",
    "it is possible to be far more refined about this and make a much better load balancing by interfering , if needed , in the main expansion tree .",
    "the main problem however is the speed of transfer of operation .",
    "thus far use has been made of the mpi protocol ( and in tests of much more of course ) . in the future",
    "it is expected that the use of threads will increase the data transfer rate considerably .",
    "it is of course this transfer rate that puts a limit to the eventual speed that can be obtained .",
    "a given transfer speed in combination with slow processors will lead to saturation for a much larger number of processors than in the case that fast processors are used . in a shared memory machine with threads",
    "however the transfer rate would be mostly a function of the processor speed and hence much is expected of this model .",
    "unfortunately the implementation is not yet complete .    at the moment",
    "the only readily available version is the one for a compaq alpha server ( with 8 alpha 21264 processors ) .",
    "it is expected that more will follow .",
    "a time prognosis can not be given yet .",
    "of course it is not always possible to run code in parallel .",
    "especially the new $ -variables could cause problems because their eventual contents depend on the order in which terms passed .",
    "if each processor keeps its own version of a $ -variable the processors may not have identical values at the end of the module .",
    "take the simple code    .... # $ max = -100 ; if ( count(x,1 ) > $ max ) $ max = count_(x,1 ) ; ....    which tries to find the maximum power of x. the various processors may have a different value in the end .",
    "hence form should not parallelize modules in which $ -variables obtain values during running time , unless the user can provide some extra information .",
    "this can be done in the moduleoption statement . in that statement one",
    "can tell form that the final value of the $ -variable is either a sum , a maximum , a minimum or completely unimportant .",
    "in such cases form knows what to do with the results and the module can be run in parallel after all .",
    "it should be realized that this is all very new .",
    "hence it could well be that many new facilities will be developed here and that there may be more ways in which future versions of form can decide about parallelization .",
    "any statement that concerns the parallelization will be completely ignored by a sequential version of form .",
    "this means that when a program is being prepared one could or should include already some of the indications for the parallel version .",
    "this way the upgrading to a parallel machine would be rather smooth .",
    "whereas version 2 of form has been commercial , it was judged that the scientific community as well as the reputation of the author would benefit more from a free distribution .",
    "hence , starting version 3 , form will be freely available again . for the moment",
    "this will involve a number of binary executables of the program .",
    "amoung these will be at least executables for linux on pc architectures and for alpha processors running unix .",
    "more binaries will become available in the near future",
    ". the manual will be available both as a postscript file and as a .pdf file .",
    "this will allow the average user to obtain the system and print out its manual as well as view it on the computerscreen .",
    "of course it is hoped that this development will not only improve the visibility and popularity of form , but will also lead to more possibilities to improve form itself .",
    "the potential for this depends of course on people in charge of jobs knowing about the importance of form in the science community .",
    "hence it is expected that people who use form for scientific publications will refer to the current paper . this way the use of form can be ` measured ' .",
    "the author hopes that the free distribution in combination with a proven popularity will lead to more people being involved in the development of form itself .",
    "there is still a whole list of potential improvements waiting for implementation .",
    "undoubtedly many users will have their own suggestions .",
    "also more packages would be appreciated .",
    "the form distribution contains :    * executables for a variety of computers . * the conv2to3 program with its sources",
    "this program converts old form code into new form code .",
    "* a postscript and a pdf version of the manual and a tutorial by andr heck . * a number of packages .",
    "currently these are ` summer ' , ` harmpol ' , ` meltran ' , ` color ' and ` mincer ' .",
    "* the sources of the stedi editor .",
    "this editor works on bsd 4.0 systems and systems that still have an old compatibility mode .",
    "it also works under linux .",
    "there is a manual with it .",
    "originally it was an editor for the atari st computers , made to work as well under ms - dos .",
    "then it was ported to bsd unix where it did run inside terminal windows . under linux and x",
    "- windows it has recovered most of its old ease of use . * the sources of the minos database program for organizing large calculations .",
    "there is a small manual with it .",
    "the program should work on nearly any system .",
    "the database files should be system independent . * the axodraw system for including simple drawings and figures inside latexfiles .",
    "this includes the manual .",
    "the files can be obtained from the www pages in http://www.nikhef.nl/@xmath5form .",
    "disclaimer : the files are provided without guarantee whatsoever . if some commands do not work as mentioned in the manual or as the user thinks they should work , the user should submit a bug report .",
    "this may or may not be reacted to depending on circumstances .",
    "acknowledgements : the author is thankful for many comments during the development of form .",
    "many people contributed in the form of bug reports and useful suggestions .",
    "some people however stand out .",
    "denny fliegner and albert rtey for developing the parallel version of form ( with support of dfg contract ku 502/8 - 1 ( _ dfg - forschergruppe ` quantenfeldtheorie , computeralgebra und monte carlo simulationen ' _ ) , geert jan van oldenborgh for being the main guinea pig during the early stages of the project , andr heck for writing a good quality tutorial , walter hoogland for allowing me to spend so much time on the project in its early stages when success had not been proven yet .",
    "a few packages are provided with the form distribution . these packages are useful not only for their field of applicability .",
    "they also serve as examples of form packages and programming techniques . in this paper",
    "we took most of the examples from them . here",
    "we give a very short description of what these packages are good for .",
    "more information is in a number of papers and in the future there may be some manuals .",
    "this packages deals with harmonic sums .",
    "a full description of these sums is given in ref .",
    "we give a short overview .",
    "the harmonic series is defined by @xmath6 in which @xmath7 .",
    "one can define higher harmonic series by @xmath8 with the same conditions on @xmath9 .",
    "the @xmath9 and the @xmath10 are referred to as the indices of the harmonic series . in the program we will use @xmath11 ` s(r(j1, ... ,jp),n ) ` .",
    "there is an alternative notation in which the indices are one of the values 0,1,-1 .",
    "a zero indicates that actually one should be added to the absolute value of the nonzero index to the right of the zero as in : @xmath12    the weight of a sum is sum of the absolute value of its indices . in the notation with",
    "the 0,1,-1 it is equal to the number of indices .",
    "the harmonic sums with the same argument form a ( weight preserving ) algebra : the product of two sums with weights @xmath13 and @xmath14 respectively is a sum of terms , each with a single sum of weight @xmath15 .",
    "the routine ` basis ' in the package implements this property .",
    "example :        ....     f = - s(r(-3,2,3),n ) - s(r(-3,3,2),n ) + s(r(-3,5),n )         + 2*s(r(-1,2,2,3),n ) + s(r(-1,2,3,2),n ) - s(r(-1,2,5),n )         - s(r(-1,4,3),n ) - s(r(2,-4,2),n ) + s(r(2,-1,2,3),n )         + s(r(2,-1,3,2),n ) - s(r(2,-1,5),n ) + s(r(2,3,-1,2),n ) ; ....               f = - s(r(-1,-3,2,3),n ) + s(r(-1,-2,-2,-1,3),n ) + s(r(-1,-2,-1,-2,3),n )         - s(r(-1,-2,2,-4),n ) + s(r(-1,-2,2,-3,-1),n ) + s(r(-1,-2,2,-2,-2),n )                  ....         + s(r(1,2,-1,-3,-2),n ) + s(r(1,2,-1,2,-3),n ) + 2*s(r(1,2,-1,3,-2),n )         + 3*s(r(1,2,-1,4,-1),n ) - 4*s(r(1,2,-1,5),n ) + s(r(1,2,3,-1,2),n ) ; ....    when @xmath4 there are relations in addition to the regular algebraic relations .",
    "they allow all the sums in infinity to be expressed in terms of a rather small number of trancendental numbers of the euler zagier type  @xcite . in order to obtain these expressions",
    "one has to solve for each weight a number of equations .",
    "this number grows exponentially with the weight .",
    "the system has been solved exactly up to weight 9 and the file with the solutions is part of the distribution .",
    "it is about 20 mbytes . in the file",
    "` summer6.h ' only the solutions up to weight 6 have been included .",
    "the programs that solve these systems of equations are also part of the distribution . in the case of weight 9",
    "there were more than 40000 equations in 13122 objects .",
    "the divergent sums were part of this because they can all be expressed properly into combinations of the basic divergence @xmath16 .",
    "this database of sums is rather important for whole categories of integrals as we will see in the harmpol and meltran packages .",
    "it should be noted that at the moment of writing , no constructive algerithms are known to determine these constants one by one .",
    "the only ` algorithm ' that comes close is the numerical evualuation of each individual sum , making an ansatz about which constants form a minimal set and then fitting all sums with a special numerical program  @xcite .",
    "this has been done for @xmath17 and in a restricted way for some higher values of @xmath18  @xcite .",
    "the weight one harmonic polylogarithms are given by : @xmath19 for the higher weights we first define @xmath20 then @xmath21 with @xmath22 an array with w zeroes while if the sequence @xmath23 of w elements 0,1,-1 is not equal to @xmath22 @xmath24 the weight of the harmonic polylogarithms is the number of indices .",
    "the argument @xmath25 can in principle take any complex value , but depending on the indices there may be a cut for real values @xmath26 or @xmath27 .",
    "these cuts are due to powers of @xmath28 or @xmath29 .",
    "such powers can be extracted , resulting in combinations of these logarithms and @xmath30-functions without these cuts .",
    "this will be needed for the mellin transforms .",
    "it should be noted that we can use also the notation of the harmonic sums for the indices ( with values beyond the set 1,0,-1 ) .",
    "also the harmonic polylogarithms form a weight preserving algebra .",
    "in addition there are extra relations for @xmath31 .",
    "one has to be rather careful with the divergent elements at @xmath31 .",
    "the powerseries expansion of @xmath30 contains harmonic sums .",
    "the algebraic relations for general @xmath25 are related to the @xmath4 relations of the harmonic sums and the extra relations in @xmath31 are related to the general algebraic relations for the harmonic sums .",
    "the transformations @xmath32 , @xmath33 and @xmath34 give some interesting relations that allow for a reasonably fast numerical evaluation of the function over most of the complex plane ( excepting the regions around @xmath35 ) .",
    "the values in @xmath31 can be expressed in terms of the harmonic sums in @xmath4 . because a weight w @xmath30-function is an integral over a denominator and a weight @xmath36 @xmath30-function this gives us whole categories of integrals that were till now extremely hard to solve .",
    "the results will be in terms of a limited number of trancendental numbers , but the relations for @xmath32 at @xmath37 will allow them to be expressed in terms of relatively fast converging series .",
    "hence these numbers can be evaluated to any precision when the need arises .",
    ".... # - # include harmpol.h off statistics ; .global local f = h(r(1,0,1),x)*h(r(-1,1,-1),x ) ; # call hbasis(h , x ) repeat i d h(r(?a , n?!{1,0,-1},?b),x ? ) = h(r(?a,0,n - sig_(n),?b),x ) ; .sort on statistics ; print + f ; .end ....             f =        h(r(-1,1,-1,1,0,1),x ) + h(r(-1,1,0,1,-1,1),x ) + 2*h(r(-1,1,0,1,1,-1),x )         + 2*h(r(-1,1,1,-1,0,1),x ) + 2*h(r(-1,1,1,0,-1,1),x ) + 2*h(r(-1,1,1,0,1 ,        -1),x ) + h(r(1,-1,0,1,-1,1),x ) + 2*h(r(1,-1,0,1,1,-1),x ) + h(r(1,-1,1,-1        , 0,1),x ) + h(r(1,-1,1,0,-1,1),x ) + h(r(1,-1,1,0,1,-1),x ) + h(r(1,0,-1,1 ,        -1,1),x ) + 2*h(r(1,0,-1,1,1,-1),x ) + h(r(1,0,1,-1,1,-1),x ) ; ....    the conversion of combinations of denominators , logarithms and polylogarithms in terms of @xmath30-functions is usually a straightforward exercise in integration by parts , provided that it can be done at all .",
    "we give one example of an integral    .... # - # include harmpol.h # call htables(6 ) cf   int ; off statistics ; .global local f = ln_(1+x)^2*ln_(1-x)^2*ln_(x)/x*int(x,0,1 ) ; i d   ln_(1+x ) =   h(r(-1),x ) ; i d   ln_(1-x ) = -h(r(1),x ) ; i d   ln_(x )    =   h(r(0),x ) ; # call hbasis(h , x ) i d   h(r(?a),x)/x*int(x,0,1 ) = h(r(0,?a),1)-h(r(0,?a),0 ) ; i d   h(r(?a , n?{1,-1},?b),0 ) = 0 ;   * provided there is a nonzero index # do i = 1,6 i d   h(r(n1?, ...",
    ",n`i'?),1 ) = htab`i'(n1, ... ,n`i ' ) ; # enddo .sort on statistics ; print + f ; .end ....                this package does the mellin transforms and inverse mellin transforms between the harmonic polylogarithms and the harmonic sums .",
    "it allows calculations to be done in either space and then converted to the other , whatever is easiest .",
    "the definition of a mellin transform is : @xmath38 in which the function @xmath39 is supposed to be finite for @xmath31 when the factor @xmath40 is present .",
    "hence we see that the first step in the mellin transformation of a @xmath30-function is the extraction of potential powers of @xmath28 .",
    "the mellin transform of a @xmath30-function , divided by either @xmath41 or @xmath42 can be solved recursively and the result is a combination of harmonic sums in the mellin parameter @xmath43 .",
    "there is a one to one correspondence between the mellin transform of @xmath30-functions of weight @xmath18 , divided by either @xmath41 or @xmath42 and harmonic sums of weight @xmath44 ( the mellin transform can also contain sums of a lower weight , but of the highest weight there is only a single term ) .",
    "hence the inverse mellin transform can also be obtained rather easily .",
    "the only complicating factor is that there will be terms in @xmath31 or @xmath4 .",
    "currently these can only be combined into a ` minimal ' representation if the weights are at most 9 .",
    "of course it should be clear that with these techniques one can do many integrals involving combinations of powers of @xmath25 , denominators with @xmath45 , @xmath29 , @xmath46 and polylogarithms with a large variety of arguments .",
    "this is usually a soft spot in most computer algebra systems .",
    "this package handles group invariants .",
    "the theory behind this is given in ref .",
    "all internal variables in this package have a name that starts with the characters col in order to avoid potential name conflicts . with this package",
    "one can , for instance , compute the group invariants that are needed in complicated feynman diagram calculations in such a way that the values for a specific representation of a specific group can be substituted at a later stage .",
    "this makes calculations more general .",
    "a simple example of the use of this package is the calculation of a diagram with 14 vertices each having three legs , connected in such a way that the smallest loop contains 6 vertices .",
    "this diagram is unique .",
    "if the vertices all belong to the adjoint representation the program would be :    .... # include color.h off statistics ; .global g    g14 = colf(coli1,coli2,coli3)*colf(coli1,coli4,coli5 )           * colf(coli2,coli6,coli7)*colf(coli3,coli8,coli9 )           * colf(coli4,coli10,coli11)*colf(coli5,coli12,coli13 )           * colf(coli6,coli14,coli15)*colf(coli7,coli16,coli17 )           * colf(coli8,coli18,coli19)*colf(coli9,coli20,coli21 )           * colf(coli10,coli21,coli15)*colf(coli13,coli19,coli14 )           * colf(coli17,coli11,coli18)*colf(coli12,coli16,coli20 ) ; sum coli1, ... ,coli21 ; .sort # call docolor .sort on statistics ; print + f + s ; .end ....          this was run on a pentium 300 .",
    "note that the customary f has to be given as colf etc .",
    "similarly the regular @xmath47 is given as colca .",
    "the values for the invariants for a given group can be found in the paper . as an example",
    "we give here the value of e8 :    .... * *    numbers for exceptional algebras * s    [ na+2],eta ; i d   cold644(colpa1,colpa2,colpa3 ) = 175/48*colca^7*colna/[na+2]^2 ; i d   cold444(colpa1,colpa2,colpa3 ) = colca^6*colna/[na+2]^2                                      * ( 125/27 + 125/216*colna ) ; * *    and for e8 * i d   colna = 248 ; i d   1/[na+2 ] = 1/250 ; i d   colca = 30*eta ; print + f + s ; .end ....            this is a pure particle physics package .",
    "it concerns the evaluation of massless propagator type integrals with up to three loops .",
    "in addition there are routines for the expansion in ( fixed ) mellin moments .",
    "computation time for higher mellin moments can be rather large .",
    "in addition the disk requirements increase exponentially with the number of the moment .",
    "one needs to specify the topology of the diagram and a few other options .",
    "a simple example is given by    .... # - # define scheme \" 0 \" # define topo \" la \" v    p1, ... ,p8,q ; # include mincer.h off statistics ; .global",
    "l    dia = 4*p7.p8 ^ 2/p1.p1/p2.p2/p3.p3/p4.p4 ^ 2/p5.p5/p6.p6/p7.p7/p8.p8*q.q ; .sort # call integral(`topo ' ) .sort on statistics ; multiply ep^3 ; i d   ep = 0 ; print ; .end ....            for more details one should have a look at the paper that comes with the package .",
    "this mincer package has been in use by the author for 9 years now . over the years",
    "it has steadily been improved and optimized .",
    "the code is basically code for version 2 of form .",
    "it is this package that was used to test the parallel version .",
    "l. euler , novi comm .",
    "petropol . 20",
    "( 1775 ) 140 .",
    "d. zagier , first european congress of mathematics , volume ii , birkhuser , boston , 1994 , pp .",
    "497 - 512 .",
    "borwein , d.m .",
    "bradley , d.j .",
    "broadhurst , hep - th/9611004 , the electronic journal of combinatorics , vol .",
    "2 ( wilf fetschrift ) , 1997 , # r5 ( http://www.combinatorics.org/volume_4/wilftoc.html ) ."
  ],
  "abstract_text": [
    "<S> version 3 of form is introduced . </S>",
    "<S> it contains many new features that are inspired by current developments in the methodology of computations in quantum field theory . </S>",
    "<S> a number of these features is discussed in combination with examples . </S>",
    "<S> in addition the distribution contains a number of general purpose packages . </S>",
    "<S> these are described shortly .    </S>",
    "<S> # 1_#1 _ # 1_#1 _ ( # 1)(-1)^#1 ( # 1,#2 )    (    c # 1 + # 2    ) </S>"
  ]
}