{
  "article_text": [
    "when numerically integrating an autonomous hamiltonian system , one typically monitors the error in the preservation of the hamiltonian function to check the precision of the numerical solution . however , severe loss of precision can actually occur for sufficiently long integration intervals , while displaying a good preservation of the value of hamiltonian function . for high precision numerical integrations , where round - off errors may dominate truncation errors",
    ", it is highly desirable both reducing and monitoring the propagation of round - off errors .",
    "we propose an implementation of symplectic implicit runge - kutta schemes ( such as rk collocation methods with gaussian nodes ) that takes special care in reducing the propagation of round - off errors .",
    "our implementation is intended to be applied to non - stiff problems , which motivates us to solve the implicit equations by fixed - point iteration ( see for instance  @xcite@xcite for numerical tests comparing the efficiency of implementations based on fixed point iterations and simplified newton ) .",
    "we work under the assumption that the ( user defined ) function that evaluates the right - hand side of the differential equations is implemented in such a way that input and output arguments are machine numbers of some prescribed floating point arithmetic .",
    "our actual implementation includes the option of computing , in addition to the numerical solution , an estimation of the propagated round - off error .",
    "the starting point of our implementation is the work of hairer et al .",
    "@xcite . there",
    ", the authors observe that a standard fixed - point implementation of symplectic implicit rk ( applied with compensated summation  @xcite ) exhibits an unexpected systematic error in energy due to round - off errors , not observed in explicit symplectic methods .",
    "they make the following observations that allow them to understand that unfavorable error behavior : ( a ) the implicit runge - kutta method whose coefficients @xmath0 are the floating - point representation of the coefficient @xmath1 of a symplectic runge - kutta method is not symplectic ; ( b ) the error due to the application at each step of a fixed point iteration with standard stopping criterion ( depending on a prescribed tolerance of the iteration error ) tends to have a systematic character .",
    "motivated by these observations , they modify the standard implementation of fixed point iteration which allows them to reduce the effect of round - off errors .",
    "no systematic error in energy is observed in the numerical experiments reported in  @xcite .",
    "however , we observe in some numerical experiments that the stopping criterion for the fixed point iteration that they propose fails to work properly in some cases . in addition",
    ", we claim that their implementation is still not optimal with respect to round - off error propagation .    in section  3 ,",
    "we propose alternative modifications of the standard fixed point implementation of symplectic implicit runge - kutta methods , which compare very favorably with that proposed in  @xcite .",
    "we first define a reference implementation with fixed point iteration where all the arithmetic operations other than the evaluation of the right - hand side of the system of differential equations are performed in exact arithmetic , and as many iterations as needed are performed in each step .",
    "such an implementation , that we call fpiea ( fixed point iteration with exact arithmetic ) implementation , is based on the following two modifications to the standard implementation with fixed point iterations : ( i ) from one hand , we reformulate each symplectic implicit runge - kutta method in such a way that its coefficients can be approximated by machine numbers while still keeping its symplectic character exactly ( subsection  3.1 ) .",
    "( ii ) on the other hand , we propose a modification of the stopping criterion introduced in  @xcite that is more robust and is independent of the chosen norm ( subsection  3.2 )    the implementation we present here is based on the fpiea implementation , with most multiplications and additions performed ( for efficiency reasons ) in the prescribed floating point arithmetic , but some of the operations performed with special care in order to reduce the effect of round - off errors . in particular , this includes a somewhat non - standard application of kahan s `` compensated summation '' algorithm  @xcite@xcite@xcite , described in detail in subsection  3.3 .",
    "finally , in subsection  3.4 , we present a simple procedure to estimate the round - off error propagation as the difference of the actual numerical solution , and a slightly less precise second numerical solution .",
    "these two numerical solutions can be computed either in parallel , or sequentially with a lower computational cost than two integrations executed in completely independent way .    in section  4 ,",
    "we show some numerical experiments to asses the performance of our final implementation .",
    "some concluding remarks are presented in section  5 .",
    "we are mainly interested in the application of symplectic implicit runge - kutta ( irk ) methods for the numerical integration of hamiltonian systems of the form @xmath2 where @xmath3 .",
    "recall that the hamiltonian function @xmath4 is a conserved quantity of the system .",
    "more generally , we consider initial value problems of systems of autonomous odes of the form @xmath5 where @xmath6 is a sufficiently smooth map and @xmath7 . in the case of the hamiltonian system ( [ eq : hamsyst ] ) , @xmath8 , @xmath9 .    for the system of differential equations ( [ eq : ivp ] ) , an s - stage implicit runge - kutta method is determined by an integer @xmath10 and the real coefficients @xmath11 ( @xmath12 ) , @xmath13 ( @xmath14 ) .",
    "the approximations @xmath15 to the solution @xmath16 of ( [ eq : ivp ] ) at @xmath17 for @xmath18 are computed as @xmath19 where the _ stage vectors _ @xmath20 are implicitly defined at each step by @xmath21 an irk scheme is symplectic if an only if  @xcite @xmath22 in that case , the irk scheme conserves exactly all quadratic first integrals of the original system ( [ eq : ivp ] ) , and if the system is hamiltonian , under certain assumptions  @xcite , it approximately conserves the value of the hamiltonian function @xmath23 over long time intervals .",
    "let @xmath24 be the set of machine numbers of a prescribed floating point system .",
    "let @xmath25 be a map that sends each real number @xmath26 to a nearest machine number @xmath27 .",
    "we assume that instead of the original map @xmath28 , we have a computational substitute @xmath29 ideally , for each @xmath30 , @xmath31 . in practice ,",
    "the intermediate computations to evaluate @xmath32 are typically made using the floating point arithmetic corresponding to @xmath33 , which will result in some error @xmath34 caused by the accumulated effect of several round - off errors .",
    "we aim at efficiently implementing a given symplectic irk scheme under the assumption that @xmath28 is replaced by ( [ eq : tildef ] ) .",
    "hence , the effect of round - off errors will be present even in the best possible ideal implementation where exact arithmetic were used for all the computations except for the evaluations of the map ( [ eq : tildef ] ) .",
    "our goal is to implement the irk scheme working at the prescribed floating point arithmetic , in such a way that the effect of round - off errors is similar in nature and relatively close in magnitude to that of such ideal implementation .",
    "obtaining the numerical approximation @xmath35 , ( @xmath36 ) to the solution @xmath16 of the initial value problem ( [ eq : ivp ] ) defined by ( [ eq : yz])([eq : y ] ) requires computing the sums @xmath37 where @xmath38    for an actual implementation that only uses a floating point arithmetic with machine numbers in @xmath33 , special care must be taken with the additions ( [ eq : sumy_n ] ) .",
    "it is worth mentioning that for sufficiently small step - length @xmath39 , the components of @xmath40 are smaller in size than those of @xmath41 ( provided that the components of the solution @xmath16 of ( [ eq : ivp ] ) remain away from zero ) .",
    "the naive recursive algorithm @xmath42 , ( @xmath43 ) , typically suffers , for large @xmath44 , a significant loss of precision due to round - off errors .",
    "it is well known that such a round - off error accumulation can be greatly reduced with the use of kahan s compensated summation algorithm  @xcite ( see also  @xcite ,  @xcite ) .",
    "given a sequence @xmath45 of machine numbers , kahan s algorithm is aimed to compute the sums @xmath46 , ( @xmath47 , ) using a prescribed floating point arithmetic , more precisely than with the naive recursive algorithm . in kahan s algorithm , machine numbers @xmath48 representing the sums @xmath49",
    "are computed along with additional machine numbers @xmath50 intended to capture the error @xmath51 .",
    "the actual algorithm reads as follows :    @xmath52    the sums @xmath53 ( which in general do not belong to @xmath33 ) are more precise approximations of the exact sums @xmath54 than @xmath55 . in this sense , if @xmath56 , the algorithm ( [ alg : kahanscs ] ) should be initialized as @xmath57 and @xmath58 ( rather than @xmath59 ) .    of course ,",
    "algorithm ( [ alg : kahanscs ] ) also makes sense for @xmath60-vectors of machine numbers @xmath61 . in this setting , algorithm ( [ alg : kahanscs ] ) can be interpreted as a family of maps parametrized by @xmath44 and @xmath60 , @xmath62 that given the arguments @xmath63 , returns @xmath64 such that @xmath65 is intended to represent the sum @xmath66 ( with some small error ) .",
    "if the coefficients @xmath67 determining a symplectic irk are replaced by machine numbers @xmath68 that approximate them ( say , @xmath69 , @xmath70 ) , then the resulting irk scheme typically fails to satisfy the symplecticity conditions ( [ eq : sympl_cond_1 ] ) .",
    "this results in a method that does not conserve quadratic first integrals and exhibits a linear drift in the value of the hamiltonian function  @xcite .",
    "motivated by that , we recast the definition of a step of the irk method as follows : @xmath71 where @xmath72 condition ( [ eq : sympl_cond_1 ] ) now becomes , @xmath73 the main advantage of the proposed formulation over the standard one is that the absence of multiplications in the alternative symplecticity condition makes possible ( see appendix  a for the particular case of the 12th order gauss collocation irk method ) to find machine number approximations @xmath74 of @xmath75 satisfying exactly the symplecticity condition @xmath76      the fixed point iteration can be used to approximately compute the solution of the implicit equations ( [ eq : yl ] ) as follows : for @xmath77 obtain the approximations @xmath78}$ ] , @xmath79}$ ] of @xmath20 , @xmath80 ( @xmath81 ) as @xmath82 } = h b_i\\ ,   f(y_{n , i}^{[k-1 ] } ) , \\quad y_{n , i}^{[k ] }   = y_n+ \\sum^s_{j=1}\\ ,   \\mu_{ij}\\ , l_{n , j}^{[k ] } \\quad   i=1 , \\ldots , s.\\ ] ] the iteration may be initialized simply with @xmath83}=y_n$ ] , or by some other procedure that uses the stage values of the previous steps  @xcite .",
    "if the step - length @xmath39 is sufficiently small , these iterations converge to a fixed point that is solution of the algebraic equations ( [ eq : yl ] ) .",
    "the situation is different for an actual computational version of these iterations , where @xmath84 is replaced in ( [ eq : fixed_point_iteration ] ) by its computational substitute ( [ eq : tildef ] ) .",
    "the @xmath85th iteration then reads as follows : for @xmath86 , @xmath87 } =   \\tilde f({{\\mathrm{fl}}(y_{n , i}^{[k-1 ] } ) } ) , \\quad l_{n , i}^{[k ] } = h b_i\\ , f_{n , i}^{[k ] } , \\quad y_{n , i}^{[k ] }   =   { y_n+ \\sum^s_{j=1}\\ ,   \\mu_{ij}\\ , l_{n , j}^{[k ] } } .\\ ] ] in this case , either a fixed point of ( [ eq : fixed_point_iteration_ideal ] ) is reached in a finite number of iterations , or the iteration fails ( mathematically speaking ) to converge . in the former case , however ( provided that @xmath39 is small enough for the original iteration ( [ eq : fixed_point_iteration ] ) to converge ) , after a finite number of iterations , a computationally acceptable approximation to the fixed point of ( [ eq : fixed_point_iteration ] ) is typically achieved , and the successive iterates remain close to it . according to our experience and the numerical experiments reported in  @xcite , a computational fixed point is reached for most steps in a numerical integration with sufficiently small step - length @xmath39 .",
    "in standard implementations of implicit runge - kutta methods , one considers @xmath88 } = ( y_{n,1}^{[k]}-y_{n,1}^{[k-1 ] } , \\ldots , y_{n , s}^{[k]}-y_{n , s}^{[k-1 ] } ) \\in { \\mathbb{f}}^{s d},\\ ] ] ( for notational simplicity , we avoid reflecting the dependence of @xmath44 on @xmath89}$ ] ) , and stops the iteration provided that @xmath90}|| { \\leqslant}\\mathrm{tol}$ ] , with a prescribed vector norm @xmath91 and iteration error tolerance @xmath92 .",
    "if the chosen value of @xmath92 is too small , then the iteration may never end when the computational sequence does not arrive to a fixed point in a finite number of steps .",
    "if @xmath92 is not small enough , the iteration will stop too early , which will result in an iteration error of larger magnitude than round - off errors .",
    "furthermore , as observed in  @xcite , such iteration errors tend to accumulate in a systematic way .",
    "the remedy proposed in  @xcite is to stop the iteration either if @xmath89}=0 $ ] ( that is , if a fixed point is reached ) or if @xmath90}|| { \\geqslant}|| \\delta^{[k-1]}||$ ] .",
    "the underlying idea is that ( provided that @xmath39 is small enough for the original iteration ( [ eq : fixed_point_iteration ] ) to converge ) , typically @xmath90}||",
    "< || \\delta^{[k-1]}||$ ] whenever the iteration error is substantially larger than round - off errors , and thus @xmath90}|| { \\geqslant}|| \\delta^{[k-1]}||$ ] may indicate that round - off errors are already significant .",
    "we have observed that hairer s strategy works well in general , but in some cases it stops the iteration too early .",
    "indeed , it works fine for the initial value problem on a simplified model of the outer solar system ( oss ) reported in  @xcite with a step - size @xmath39 of @xmath93 days , but it goes wrong with @xmath94 .",
    "actually , we have run http://www.unige.ch/~hairer/preprints/code.tar[hairers fortran code ] and observed that the computed numerical solution exhibits an error in energy that is considerably larger than round - off errors .",
    "the evolution of relative error in energy is displayed on the left of figure  [ fig : plot0 ] , which shows a linear growth pattern .",
    "we have checked that , for instance , at the first step , @xmath95}\\| > \\|\\delta^{[2]}\\| > \\cdots > \\|\\delta^{[12]}\\| = 3.91\\times 10^{-14 } \\le \\|\\delta^{[13]}\\| = 4.35\\times 10^{-14}\\ ] ] which causes the iteration to stop at the @xmath96th iteration , which happens to be too early , since subsequently , @xmath97}\\|",
    "> \\|\\delta^{[14]}\\| > \\|\\delta^{[15]}\\| > \\|\\delta^{[16]}\\|=0",
    "$ ] .    [ cols=\"^,^ \" , ]",
    "symplectic implicit runge - kutta schemes ( such as rk collocation methods with gaussian nodes ) are very appropriate for the accurate numerical integration of general hamiltonian systems . for non - stiff problems , implementations based on fixed - point iterations seem to be more efficient than those based on newton method or some of its variants .",
    "we propose an implementation that takes special care in reducing the propagation of round - off errors , and includes the option of computing , in addition to the numerical solution , an estimation of the propagated round - off error .",
    "we claim that our implementation with fixed point iterations is near optimal , in the sense that the propagation of round - off errors is essentially no worse than the best possible implementation with fixed point iteration .",
    "our claim seems to be confirmed by our numerical experiments .",
    "a key point in our implementation has been the introduction of a new stopping criterion for the fixed point iteration .",
    "we believe that such a stopping criterion could be also useful in other contexts .    according to our numerical experiments",
    ", it seems that , in some cases , some small linear drift of the mean energy error may be unavoidable for the fixed point implementations of irk schemes .",
    "whenever avoiding any drift of energy error becomes critical it might be preferable to use some newton based iteration instead .",
    "the c code of our implicit runge - kutta implementation with fixed point iterations can be downloaded from < https://github.com/mikelehu/irk-fixedpoint>[irk-fixedpoint ] github software repository or go to the next url : https://github.com/mikelehu/irk-fixedpoint .    [",
    "[ acknowledgements ] ] acknowledgements + + + + + + + + + + + + + + + +    m. antoana , j. makazaga , and a. murua have been partially supported by projects mtm2013 - 46553-c3 - 2-p from ministerio de economa y comercio , spain , by project mtm2016 - 76329-r `` imagearth '' from spanish ministry of economy and competitiveness and as part of the consolidated research group it649 - 13 by the basque government .",
    "10    d.  brouwer .",
    "http://dx.doi.org/10.1086/105423[on the accumulation of errors in numerical integration ] . ,",
    "46:0 149153 , 1937 .",
    "n.  d. dumitru .",
    "http://dx.doi.org/10.13140/2.1.5033.2969[fast detection of chaotic or regular behavior of double pendulum system : application of the fast norm vector indicator method ] . ,",
    "grazier , w.i .",
    "newman , j.  m. hyman , p.  w. sharp , and d.  j. goldstein .",
    "http://dx.doi.org/http://dx.doi.org/10.21914/anziamj.v46i0.990[achieving brouwer s law with high - order stormer multistep methods ] . , 46:0 786804 , 2005 .",
    "e.  hairer , c.  lubich , and g.  wanner .",
    "numerical integration : structure - preserving algorithms for ordinary differential equations _ ] , volume  31 .",
    "springer science & business media , 2006 .",
    "e.  hairer , r.  i. mclachlan , and a.  razakarivony .",
    "http://dx.doi.org/10.1007/s10543-008-0170-3[achieving brouwer s law with implicit runge  kutta methods ] . , 480 ( 2):0 231243 , 2008",
    ".    nicholas  j. higham .",
    "http://dx.doi.org/10.1137/1.9780898718027[_accuracy and stability of numerical algorithms _ ] .",
    "siam , 2002 .",
    "w.  kahan .",
    "further remarks on reducing truncation errors . ,",
    "80 ( 1):0 40 , 1965 .    r.  i. mclachlan and p.  atela .",
    "accuracy of symplectic integrators ] .",
    ", 50 ( 2):0 541 , 1992 .    j.m .",
    "muller , n.  brisebarre , f.  de  dinechin , c.p .",
    "jeannerod , v.  lefevre , g.  melquiond , n.  revol , d.  stehl , and s.  torres .",
    "http://dx.doi.org/10.1007/978-0-8176-4705-6[_handbook of floating - point arithmetic _ ] .",
    "springer science & business media , 2009 .",
    "sanz  serna and m.p .",
    "chapman and hall , 1994 .",
    "we next illustrate , by considering in detail the case of the 6th stage gauss collocation method for the 64-bit ieee double precision floating point arithmetic , how to determine appropriate machine number coefficients @xmath98 , @xmath99 , that approximate the real numbers @xmath100 of a given symplectic integration .    for all @xmath81 , @xmath101 . for @xmath102 , @xmath103 , which satisfy @xmath104 , which implies that @xmath105 is a machine number .",
    "this results in machine number coefficients @xmath98 that satisfy the symplecticity conditions ( [ eq : sympl_cond_2 ] ) ."
  ],
  "abstract_text": [
    "<S> we propose an implementation of symplectic implicit runge - kutta schemes for highly accurate numerical integration of non - stiff hamiltonian systems based on fixed point iteration . provided that the computations are done in a given floating point arithmetic , the precision of the results is limited by round - off error propagation . </S>",
    "<S> we claim that our implementation with fixed point iteration is near - optimal with respect to round - off error propagation under the assumption that the function that evaluates the right - hand side of the differential equations is implemented with machine numbers ( of the prescribed floating point arithmetic ) as input and output . </S>",
    "<S> in addition , we present a simple procedure to estimate the round - off error propagation by means of a slightly less precise second numerical integration . some numerical experiments </S>",
    "<S> are reported to illustrate the round - off error propagation properties of the proposed implementation .    </S>",
    "<S> = 1 </S>"
  ]
}