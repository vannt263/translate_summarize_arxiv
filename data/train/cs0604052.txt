{
  "article_text": [
    "form @xcite is a symbolic manipulation system ( sms ) specialized to handle extremely large or more .",
    "this exceeds the current capabilities of mathematica of maple by a large factor . ]",
    "expressions of many millions of terms in an efficient way .",
    "form allows mainly local operations on single terms , like replacing parts of a term or multiplying something to it ( the `` locality principle '' , see sect.[locality ] ) .",
    "this special property of form allows it to deal with expressions that are much larger than the main memory available .",
    "it also enables parallelization  @xcite .",
    "together these features make form a unique tool suitable for state of the art evaluations .",
    "it is widely used in quantum field theory , where the calculation of very large sequences of algebraic expressions is required , e.g.  @xcite .",
    "effective manipulation of large expressions requires that all algebraic instructions are applied to a big sequence of terms .",
    "the sheer size of the intermediate results prevents storage of more than a single version of an expression .",
    "hence in form there is no benefit in `` interactivity '' and it is used in an non - interactive way .",
    "form provides a special programming language adapted for the manipulating of large sequences of algebraic terms and the user supplies programs written in this language . the major non - local operation which brings expressions to a standard form ( the sort operation ) makes the language powerful enough to program quite non - trivial algorithms ; several form packages are widely used in multiloop calculations , e.g. mincer @xcite and matad @xcite .    because form programs mainly describe the treatment of individual terms , rather than that of complete expressions , and because there are few libraries for many popular algebraic operations , form is considered to be less user - friendly than for instance the computer algebra systems ( cas ) mathematica or maple . on the other hand , very large expressions and time",
    "consuming operations often need special rather than generic algorithms anyway and one can not use the libraries in that case .",
    "there are however cases in which it is useful to have access to the facilities of other specialized software .",
    "that is why sometimes form is used in combination with other software systems which provide a more fluent control flow in conjunction with some specialized programs .",
    "an example is the combination of the programs qgraf @xcite , q2e , exp @xcite and matad glued together with the help of the make utility .",
    "several other systems use form as a sub - system for the evaluation of `` hard '' expressions .",
    "the c - program diana @xcite designed as a master program for higher - order calculations uses form ( see implementations e.g. @xcite and references in @xcite ) .",
    "the automatic calculation systems comphep @xcite and grace @xcite are currently migrating from reduce to form for analytical calculations .",
    "sanc @xcite is a recently developed world - wide network system which consists of sanc servers and sanc clients which uses form for analytical evaluations .",
    "also formcalc @xcite uses mathematica as a user - friendly front - end to form .",
    "as one can see , form is often used in co - operation with other software .",
    "this makes the improvement of the form abilities to communicate with other programs into an urgent problem .",
    "the locality principle restricts the variety of possible algorithms or at least the way they should be programmed .",
    "it is impossible to avoid non - local operations completely .",
    "hence form supports a number of non - local operations the most important of which is the sort operation .",
    "another is the explicit bracketing of some common factor . by implementing a general interface for form to communicate with external programs , other non - local operations like polynomial factoring or the elimination of greatest common divisors ( gcd ) between numerators and denominators",
    "can be delegated to other ( less efficient but less restricted ) programs .",
    "recently , such an interface was elaborated .",
    "the interface permits form to run external programs and to be embedded in other applications . in the present paper we concentrate on the detailed description of the interface .",
    "of course , the systematic introduction to the form language is far beyond the scope of this paper .",
    "there are different manuals and tutorials devoted the form language , see the form homepage  @xcite .    after a very short introduction to the form language and the mechanisms behind it in sect .",
    "[ forminternas ] , we discuss different ways to communicate with the underlying operating system ( unix ) available in form3.1 ( the current form version ) , sect .",
    "[ extworld ] .",
    "the new mechanism available in the upcoming version form3.2 permitting a dialog with an external program is presented in sect .",
    "[ async ] .",
    "the exact syntax is described in sect .",
    "[ exactsytntax ] .",
    "a working example of using the reduce  @xcite system from form is described and discussed in appendix  [ reduce ] .",
    "form is used non - interactively by executing a program that contains several parts called _ modules_. the programs are executed module by module .",
    "modules are terminated with `` dot''-instructions that cause the execution of the module , see the example on the left of fig.[example ] .",
    "=    this example consists of only two modules .",
    "there are two `` dot''-instructions : a .sort and a .end . in both cases the result is sorted .",
    ".end additionally terminates the program .",
    "the execution of each module is divided into three steps :    * * compilation : * the input is translated into an internal representation . * * generating : * for each term of the input expressions the statements of the module are executed .",
    "this in general generates a lot of terms for each input term . *",
    "* sorting : * all the output terms that have been generated are sorted and equivalent terms are summed .",
    "mostly form allows only local operations on single terms , like replacing parts of a term or multiplying something to it ; non - local operations like replacing a sum of two terms by another term are not allowed .",
    "we refer to this property as the _ locality principle _ : all _ explicit _ algebraic operations are local .",
    "non - local operations are allowed only implicitly in the sorting procedure at the end of the modules , when equivalent terms are summed up , and in some special references to the contents of brackets in the input expression .",
    "together with a sophisticated pattern matcher , this at first strong limitation allows the formulation of general and efficient algorithms .",
    "the limitation to local operations makes it possible to handle expressions as `` streams '' of terms that can be read sequentially from memory or a file and processed independently , which allows dealing with expressions that are larger than the available main memory and in addition allows parallelism @xcite .    in principle",
    "non - local operations like polynomial factoring or gcd contraction could be performed at the level of the preprocessor , but this means that we would like to design some new cas in the frame of the form preprocessor .",
    "the more natural solution would be to delegate this problem to other ( less efficient but less restricted ) cas . at this point",
    "we come to the problem of how to interact with the outside world .",
    "the generation of terms is performed by the algebraic processor applying the algebraic imperatives ( the statements inside a module ) to each term of all active expressions .",
    "thus , the control flow immediately splits into many independent branches .",
    "the control flow can be manipulated by restricting the application of statements to those terms that fulfil some criteria as is done in the following ` if ` statement    ....    if ( count(b,1 ) = = 1 ) ;      multilpy 4*a / b ;    endif ; ....    the above means that we assign to each power of @xmath0 a degree of 1 and only terms in which the total degree is exactly 1 are multiplied by @xmath1 .",
    "control flow based on complete expressions is not possible at the algebraic processor level .",
    "but it is possible at the preprocessor level .",
    "the preprocessor in form is a notably important ingredient .",
    "it coordinates the execution of the program and eventually calls the processor to perform the actual module execution .",
    "all the `` real '' control flow in form is performed by the preprocessor .",
    "and , of course , interactivity is possible only at the preprocessor level .",
    "the interactive mode `` human ",
    "form '' makes no sense because form usually deals with very big expressions , and intermediate results that may take gigabytes of storage are not readily open for inspection by the programmer . on the other hand the interaction `` form",
    " another program '' often does make sense . in principle , a realization of this could be delegated to the underlying operating system .",
    "of course , this introduces operating system dependent code and should be used with great care .",
    "let us first look at the existing mechanisms of running external programs in form3 .",
    "the easiest model of interaction is just to start some operating system command and wait until it finishes .",
    "the preprocessor instruction    ....    # system systemcommand ....    forces a system command to be executed by the operating system .",
    "the complete string ( excluding initial blanks or tabs ) is passed to the operating system .",
    "form will then wait until control is returned .",
    "one evident drawback of this mechanism is that there is no feedback from the system command .",
    "the only way to communicate is by means of the file system .",
    "it is quite clear that any nontrivial model would require that the output of the program is intercepted by form .",
    "there is another preprocessor instruction , namely , ` # pipe ` :    .... # pipe   systemcommand ....    this forces a system command to be executed by the operating system . the complete string ( excluding initial blanks or tabs )",
    "is passed to the operating system .",
    "next form will intercept the output of the command and read it as an input similar to the ` # include ` instruction .",
    "whenever output is produced form will take action , and it will wait when no output is ready .",
    "after the command has been finished , form will continue with the next line .",
    "this preprocessor instruction is much more powerful than the former one .",
    "but the communication channel established by the ` # pipe ` instruction does nt satisfy all our requirements .",
    "evidently , this is mostly a _",
    "unidirectional _ channel ; form could read an output , but establishing a dialog with the running program is very tricky ( see appendix  [ pipecm ] ) .",
    "let us now try to formulate the requirements more precisely .",
    "even the simple ` # system ` can be used for the extension of the form functionality .",
    "for example , consider an expression `` ` withgcd ` '' which is a ratio of two polynomials in @xmath2 : @xmath3 factoring both the numerator and the denominator we get @xmath4 so after contracting the gcd we obtain @xmath5 suppose , there is some light - weight cas which is able to do the gcd contraction .",
    "how could we proceed with the ` # system ` instruction ?    consider the following simplified form program ( for the full working example see appendix  [ system ] ) :    ....    # define cmd . .",
    "symbol d ;    local withgcd = ( 2*d^4 + 3*d^3 - 22*d^2 - 13*d+30)/(d^3 - 11*d+10 ) ;    # write < finput > \" % e\",withgcd    # system cat finput | ` cmd ' > foutput    local nogcd =    # include foutput             ;    print ;    .end ....    here we assume that the preprocessor variable ` \\`cmd ' ` contains the command starting the external program .",
    "first , we save the initial expression into the file `` finput '' , then we run the external program performing the gcd contraction saving the result into another file `` foutput '' and at the end we read the result from the file .",
    "this works , and the result is given in the following simplified listing :    ....    . .",
    "withgcd =        30/(10 - 11*d+d^3)-13/(10 - 11*d+d^3)*d       -22/(10 - 11*d+d^3)*d^2 + 3/(10 - 11*d+         d^3)*d^3 + 2/(10 - 11*d+d^3)*d^4 ;        nogcd =        3 + 2*d ; ....    this is acceptable provided we need this only once or a few times but could be too time consuming for frequent usage like in a loop .",
    "how can one reduce the overhead ?    the use of intermediate files for input and output is , evidently , a cost factor . using the more powerful ` # pipe ` instruction we would get rid of these files , e.g. by the following simplified form program :    ....    # define cmd . .",
    "symbol d ;    local withgcd = ( 2*d^4 + 3*d^3 - 22*d^2 - 13*d+30)/(d^3 - 11*d+10 ) ;    .sort    $ exp = withgcd ;    .sort    local nogcd =    # pipe echo \" ` $ exp ' \" | ` cmd '             ;    print ;    .end ....    ( for the full working example see appendix  [ pipe ] ) . here",
    "instead of saving the input expression to a file we put it into the command line and read the results back directly from the external command output .",
    "but the overhead is not much less : for each evaluation we have to start a new copy of the external program .",
    "this is because the pipe establishes only a unidirectional channel with the external program , so we are not able to organize a dialog with it .    in principle , the ` # pipe ` preprocessor instruction can be used in order to establish a real dialog of form with the external program , see appendix  [ pipecm ] . but this is quite tricky , extremely inconvenient and hardly applicable in practice . in order to extend the form functionality we need a really full duplex channel to the external program .",
    "recently a full duplex interface has been implemented .",
    "the new preprocessor instruction ` # external ` starts the system command opening an input - output channel for it . after the instruction ` # external ` returns the control to the form program , external programs initiated by the instruction continue to run . the standard input and output",
    "are intercepted by form and not connected with any terminal device .",
    "generally speaking , the system command initiates several processes starting several external programs combined into the `` job '' .",
    "we refer to the job initiated by the instruction ` # external ` as the `` external command '' .",
    "the instruction ` # toexternal ` is used to send some text to the running external command .",
    "its syntax is similar to the ` # write ` instruction .",
    "the instruction ` # fromexternal ` is used to read the text from the running external command .",
    "its syntax is similar to the ` # include ` instruction .    the ( simplified , for the full example see appendix  [ external ] ) variant of the above form program based on this new mechanism may look like :    ....    # define cmd . .",
    "symbol d ;    # external ` cmd '      local withgcd = ( 2*d^4 + 3*d^3 - 22*d^2 - 13*d+30)/(d^3 - 11*d+10 ) ;    .sort    # toexternal \" % e\\n\",withgcd    local nogcd =    # fromexternal            ;    print ;    .end ....    note that now we have a real dialog .    after the instruction ` # external \\`cmd ' ` the control returns to form while all the processes initiated by ` \\`cmd ' ` continue to run . the external command that is running",
    "is embedded in the form system and visible from the form program as a duplex channel .",
    "the instruction ` # toexternal ` provides the external command with input data while the instruction ` # fromexternal ` reads its resulting output .",
    "it is interesting to compare the speed of all three programs . to minimize irrelevant overhead we repeat the corresponding evaluation 1000 times via a preprocessor ` # do ` loop and measure the wall - clock time .",
    "the results are as follows :    [ cols= \" < , > , > \" , ]",
    "the design of the full duplex channel is not so trivial ; automatic bidirectional interaction can be dangerous due to possible deadlocks .",
    "this requires careful design and flexibility for all the communication primitives .",
    "there are several modes of starting and finishing the external program . by default",
    ", the command is run in a subshell in a new session and in a new process group . before form finishes ( or by the ` # rmexternal ` preprocessor instruction ) the kill signal",
    "is sent to the whole group .",
    "the preprocessor instruction ` # setexternalattr ` could be used in order to change this default behavior .    performing the `",
    "# fromexternal ` instruction form continues to read the output of the running external program until the external program outputs a _",
    "prompt_. the prompt is a line consisting of a given prompt string . by default , this is an empty string . the prompt string",
    "can be changed by means of the preprocessor instruction ` # prompt ` .",
    "several external commands can be run simultaneously .",
    "the external command that is started last becomes the _ current _ ( active ) one .",
    "instructions ` # toexternal ` and ` # fromexternal ` deal with the current external command . at any time",
    "the current external command can be changed by the instruction ` # setexternal ` .",
    "this approach was chosen in order to reduce possible overhead .",
    "alternatively , one could implement an additional argument to all primitives containing information about an identifier for each external command .",
    "special external channels ( `` pre - opened '' ) could be available provided form was started by a parent process with some special command line option . in that case form",
    "is able to communicate with the parent process by means of the same mechanism .",
    "this permits form to be embedded in other applications , see appendix [ preopened ] .",
    "an external command can be terminated by the instruction ` # rmexternal ` .      ` # external [ \" prevar \" ] ` systemcommand + starts the command in the background , connecting to its standard input and output . by default , the external command has no controlling terminal , the standard error stream is redirected to ` /dev / null ` and the command is run in a subshell in a new session and in a new process group ( see the preprocessor instruction ` # setexternalattr ` ) .",
    "the optional parameter `` prevar '' is the name of a preprocessor variable placed between double quotes .",
    "if it is present , the `` descriptor '' ( small positive integer number ) of the external command is stored into this variable and can be used for references to this external command ( if there is more than one external command running simultaneously ) .",
    "the external command that is started last becomes the `` current '' ( active ) external command .",
    "all further instructions ` # fromexternal ` and ` # toexternal ` deal with the current external command .",
    "` # toexternal \" formatstring \" [ , variables ] ` + sends the output to the current external command .",
    "the semantics of the ` \" formatstring \" ` and the ` [ , variables ] ` is the same as for the ` # write ` instruction , except for the trailing end - of - line symbol .",
    "in contrast to the ` # write ` instruction , the ` # toexternal ` instruction does not append any new line symbol to the end of its output .    `",
    "# fromexternal[+|- ] [ \" [ $ ] varname\",[maxlength ] ] ` + appends the output of the current external command to the form program .",
    "the semantics differ depending on the optional arguments .",
    "after the external command sends the prompt , form will continue with a next line after the line containing the ` # fromexternal ` instruction .",
    "the prompt string is not appended .",
    "the optional + or - sign after the name has influence on the listing of the content .    `",
    "# fromexternal[+|- ] ` + the semantics is similar to the ` # include ` instruction but folders are not supported .    `",
    "# fromexternal[+|- ] \" [ $ ] varname \" ` + is used to read the text from the running external command into the preprocessor variable ` varname ` , or into the dollar variable ` $ varname ` if the name of the variable starts with the dollar sign `` $ '' .    `",
    "# fromexternal[+|- ] \" [ $ ] varname \" maxlength ` + is used to read the text from the running external command into the preprocessor ( or dollar ) variable ` varname ` .",
    "only the first ` maxlength ` characters are stored .",
    "the prompt is a line consisting of a single prompt string . by default , this is an empty string .",
    "the prompt can be changed by means of the instruction ` # prompt ` :    ` # prompt [ newprompt ] ` + sets a new prompt for the current external command ( if present ) and all further ( newly started ) external commands .",
    "if ` newprompt ` is an empty string , the default prompt ( an empty line ) will be used .",
    "` # setexternal",
    "n ` + sets the `` current '' external command . the instructions ` # toexternal ` and ` # fromexternal ` deal with the current external command . the integer number ` n ` must be the descriptor of a running external command .    ` # rmexternal [ n ] ` + terminates an external command . the integer number ` n ` must be either the descriptor of a running external command , or 0 .",
    "if ` n ` is 0 , then all external programs will be terminated .    if ` n ` is not specified , the current external command will be terminated .",
    "the action of this instruction depends on the attributes of the external channel ( see the preprocessor instruction ` # setexternalattr ` ) . by default",
    ", the instruction closes the commands io channels , sends a kill signal to every process in its process group and waits for the external command to be finished .    ` # setexternalattr ` list_of_attributes + sets attributes for _ newly started _ external commands . already running external commands",
    "are not affected .",
    "the list of attributes is a comma separated list of pairs attribute = value , e.g. :    ....    # setexternalattr shell = noshell , kill=9,killall = false ....",
    "possible attributes are :    * ` kill ` specifies the signal to be sent to the external command either before the termination of the form program or by the preprocessor instruction ` # rmexternal ` . by default",
    "this is 9 ( sigkill ) .",
    "number 0 means that no signal will be sent . * ` killall ` indicates whether the kill signal will be sent to the whole group or only to the initial process .",
    "possible values are `` ` true ` '' and `` ` false ` '' . by default",
    ", the kill signal will be sent to the whole group . * ` daemon ` indicates whether the command should be `` daemonized '' , i.e. the initial process will be passed to the init process and will belong to the new process group in the new session .",
    "possible values are `` ` true ` '' and `` ` false ` '' . by default , `` ` true ` '' . * ` shell ` specifies which shell is used to run a command . by default",
    "this is `` ` /bin",
    "/ sh -c ` '' .",
    "if set ` shell = noshell ` , the command will be stared by the instruction ` # external ` directly but not in a subshell , so the command should be a name of the executable file rather than a system command .",
    "the instruction ` # external ` will duplicate the actions of the shell in searching for an executable file if the specified file name does not contain a slash ( / ) character . the search path is the path specified in the environment by the path variable .",
    "if this variable is nt specified , the default path `` ` : /bin:/usr / bin ` '' is used . * ` stderr ` specifies a file to redirect the standard error stream to . by default",
    "it is `` ` /dev",
    "/ null ` '' .",
    "only attributes that are explicitly mentioned are changed , all others remain unchanged .",
    "note , changing attributes should be done with care .",
    "for example ,    ....    # setexternalattr daemon = false , kill=9,killall = true ....    starts a command in the subshell within the current process group .",
    "the instruction ` rmexternal ` sends the kill signal to the whole group , which means that also form itself will be killed .    the example :    [ source , numberlines ] ----    symbol",
    "a , b ;      # external \" n1 \" cat -u      # external \" n2 \" cat -u      *   cat simply repeats its input . the default prompt is an    *   empty line .",
    "so we use \" \\n\\n \" here -- one \" \\n \" is to finish    *   the line , and the next \" \\n \" is the prompt :    # toexternal \" ( a+b)^2\\n\\n \"      # setexternal ` n1 '    *   for this channel the prompt will be \" ready\\n \" :    # toexternal \" ( a+b)^3\\nready\\n \"      # setexternal ` n2 '    *   set the default prompt :    # prompt    local aplusbto2=    # fromexternal           ;      # setexternal ` n1 '    # prompt ready    local aplusbto3=    # fromexternal           ;      # rmexternal ` n1 '    # rmexternal ` n2 '      print ;    .end ----    two external channels are opened in lines 3 and 5 .",
    "the unix utility `` ` cat ` '' simply repeats its input .",
    "the option `` ` -u ` '' is used to prevent the output buffering .",
    "the option is ignored by the gnu ` cat ` utility but is mandatory for non - gnu versions of ` cat ` .",
    "after line 5 the current external channel is `` n2 ` ' .",
    "the default prompt is an empty line so in line 10 `` ` \\n\\n ` '' is used ",
    "one `` ` \\n ` '' is to finish the line , and the next `` ` \\n ` '' is the prompt .",
    "line 12 switches the current channel to `` n1 ` ' . for this channel",
    "the prompt will be `` ` ready ` '' , see line 24 , hence the expression is finished by `` ` \\nready\\n ` '' .",
    "line 16 switches to the `` n2 ` ' external channel and line 18 sets the default prompt ( which is extra in this example since the default prompt was not changed up to now ) .",
    "results ( just a literal repetition of the sent expressions ) are read in lines 20 and 26 .",
    "lines 29 and 30 close the external channels .",
    "an interface like the one described above can be used in order to extend form in the spirit of a component model where the term `` component model '' means that a software system is built from `` components '' .",
    "components are high level aggregations of smaller software pieces and provide a `` black box '' building block approach to software construction ( see , e.g. , @xcite ) .",
    "the communication is performed only via standard input and output streams without any special protocol , i.e. , the input is expected to follow the form syntax conventions .",
    "but this is not restrictive since the communication could easily be established through an intermediate gateway program ( also called filter ) which performs a translation between the external programs and form ( see the discussion in appendix  [ fermat ] and [ reduce ] ) .",
    "there are two important points :    * the interface is implemented at the preprocessor level .",
    "this means that the structure of the form algebraic processor is not touched and all the form advantages persist .",
    "* it would also allow us to implement a model of parallelization , in which several external components are running simultaneously at the preprocessor level while the form algebraic processor continues to work on some huge expression .",
    "the technique described is applied directly to form swallowing the external program , or to embedding form in other applications .",
    "however , this mechanism is quite general and can be used also in order to build form in the client - server architecture .",
    "the idea is that form can use the `` ` # external ... ` '' instruction in order to start a client or a server .",
    "the client ( or the server ) then establishes a connection with an external application and uses its standard input and output in order to communicate with form .",
    "the corresponding library ( `` formlink '' ) is under development and will be available from the form distribution site @xcite in the near future .",
    "we want to thank k. chetyrkin , h .-",
    "staudenmaier and m. steinhauser for interesting discussions .",
    "we would also like to thank a. grozin for advises and useful remarks concerning reduce and c. sturm for continuous testing of the software in a real application .",
    "the work of m.t . has been supported by the deutsche forschungsgemeinschaft in sonderforschungsbereich / transregio 9 `` computational particle physics '' .",
    "the work of j.v . has been part of the research program of the dutch foundation for fundamental research of matter ( fom ) .",
    "the technique we presented was developed and tested in an experimental form version used in multiloop calculations @xcite applying the laporta algorithm @xcite .",
    "the implementation requires some operations on polynomials with integer / rational coefficients .",
    "there are surprisingly few decent programs available for this .",
    "it should be a program performing some basic operations on polynomials , and it should be completely stateless , i.e. allow to handle input expressions independent of each other .",
    "ideally , this program should be :    1 .",
    "fast enough ; 2 .   able to handle very large expressions ; 3 .   available on most hardware / software platforms ; 4 .",
    "open source .    for",
    "the above example we found only two suitable programs , reduce  @xcite and fermat  @xcite .",
    "reduce is fast enough , it is an open source system ( but _ not _ a free one ! ) but on 32-bit platforms it is rather restrictive , and there is no ia64 ( intel itanium ) - based version of reduce at the moment . appendix  [ reduce ] contains an example of a fully functional embedding of reduce in form .",
    "in our examples we selected fermat , `` conjugated '' with the ` # external ` -based form interface by a gateway program which performs a syntax translation and proper masking @xcite in order to isolate form from long expressions treated by fermat .",
    "the gateway starts fermat , reads input from stdin , passes expressions in the variable d ( indicating the dimension of space - time in our example ) , which form collected into the function acc , to fermat , reads an answer from fermat , stores the answer into an internal table , contracts it to the string `` ` dd ( # ) ` '' , where `` ` # ` '' is the order number of the expression produced by fermat , and outputs the result to the stdout .",
    "here is a very short introduction to the ideas behind it .",
    "for example , the expression    ....    some string + acc((d+1)/(d-1)+d ) + another string ....    will be converted to    ....    some string + dd(1 ) + another string ....",
    "where ` dd(1 ) ` is equal to ` ( d^2 + 1)/(d-1 ) ` .",
    "it is stored internally and may be extracted by means of the command @v , see below .",
    "all lines started with the character @ are commands for the gateway .",
    "we show some of them ( just a few ones ) :    * @f0 - do not filter the content of acc ( ) through fermat ; + @f1 - filter the content of acc ( ) through fermat ( default ) ; * @e0 - reduce all rational functions in d in acc ( ) to dd ( # ) ( default ) ; @e1 - expand all dd ( # ) to corresponding rational functions ( not only in acc ( ) ! ) ; * @vsome text @ ( # ) another text - repeat the line after @v , substituting @ ( # ) by the content of the corresponding dd - variable .",
    "example : `` @vid dd(1 ) = @(1 ) ; '' will result in `` i d dd(1 ) = ( d^2 + 1)/(d-1 ) ; '' * @sfilename - all stored variables will be saved into the file `` filename '' , one variable per line , in the order as they were stored ( i.e. , dd(5 ) will occupy the line number 5 ) ; + @rfilename - all lines from the file `` filename '' ( without trailing `\\n` ) will be loaded into the internal table .",
    "fermat is not an open source program ; it is available only for macintosh , sun sparc , and windows and linux ia32-based platforms ( and even not for all of them ) but it is able to handle very large expressions even on 32-bit platforms .",
    "fermat is approx .",
    "20 times faster than the mathematica function `` together [ ] '' and a little bit faster than reduce .",
    "it is used for performing the operations on polynomials arising in coefficient functions ; we need only basic polynomial arithmetic ( which , in principle , form provides itself , but still in an experimental and far from optimized way ) and the only non - local operation we really need from fermat is a gcd contraction .",
    "fermat is an interpreter providing a complete programming language .",
    "most of its commands begin with the symbol ` & ` and have the syntax ` & < symbol > ` or ` & ( < symbol>=<value > ) ` , as in ` & q ` for quitting the program .",
    "there are also some other classes of commands and the terminal i / o commands ! and ? .",
    "entered commands are separated by a new line or by a semicolon",
    ".    entered arithmetic expressions are reduced to some unique form and printed to the terminal .",
    "two arithmetic modes are possible in fermat , rational arithmetic and modular .",
    "a session with fermat starts in rational mode ( see example below ) .",
    "all arithmetic is that of rational numbers and the gcd of a numerator and a denominator is contracted .",
    "the user may change the ground field by converting it into a polynomial ring entering the `` adjoin polynomial '' command , ` & j ` .",
    "after that , the user may enter any polynomial sums and ratios and fermat will bring them into a unique form of a rational function ( `` quolynomial '' ) .    in the following example of the fermat session",
    "the character `` ` > ` '' is the fermat prompt , characters after the prompt are typed by the user , and strings without the prompt are printed by fermat .",
    "we do not show some of the housekeeping information printed by fermat :    [ source , numberlines ] ----    > 21/14     3 / 2 ;   or   1.5000000000000    > & d     enter display size .",
    "> 0    > 21/14     3 / 2    > & ( j = d )     > ( d^2 - 4)/(d+2 )      d - 2    > & ( j = x )    > ( x^2 + 2*x*d + d^2)^2/(x+d )      x^3 + ( 3d)x^2 + ( 3d^2)x + d^3 ----    the command ` & d ` is used in order to change the number of blocks of 8 significant digits to the right of the decimal point displayed by the interpreter when a non - integer is displayed . if it is 0 , this feature is disabled .",
    "in line 8 we change the ground field ( rationals ) to the ring of polynomials in @xmath2 , and after line number 11 the ground ring becomes the ring of polynomials in the two variables @xmath2 and @xmath6 .",
    "we describe briefly some other fermat commands which are used in the rest of the paper .    ` & ( m= ' ' ) ` change the prompt to just an empty line .    ` & ( t=0 ) ` switch off the output of information about the time .    ` & u ` toggle switch to display long integers and polynomials in the style of other computer algebra systems ( maple ) .",
    "here we compare all techniques that were available in form3 with the new techniques available in form 3.2 .",
    "we provide examples of form programs but these programs are only simplified conceptual ( but working ) examples of how this could be done .",
    "general comments :    * as an external cas , in appendix  [ runextcmd ] and [ pipecm ] we use the program fermat , see appendix  [ fermat ] .",
    "we assume that the executable file is available from the current directory as `` ./fermat '' . * for simplicity , we do not pay any attention to the line lengths .",
    "in reality , some intermediate gateway program ( script ) should be used in order to make a proper formatting .",
    "all the form programs in the examples below are started with the statement `` ` format 254 ; ` '' .",
    "this means , the examples may not work if the total transferred length exceeds 254 characters . * in order to compare the speed of the examples in all the versions , we repeat the evaluation 1000 times by means of a preprocessor ` # do ` loop . however , in the example in appendix  [ pipecm ] the loop is performed by a `` while '' loop in the shell . * the common structure of all the examples is the same .",
    "we create the local expression `` withgcd '' which is expr .",
    "( [ withgcd ] ) , and subsequently repeat 1000 times the process of filtering the expression through fermat and putting the resulting expr .",
    "( [ nogcd ] ) back into form .",
    "the following form program exploits the ` # system ` preprocessor instruction to start fermat .",
    "the information is transferred by conventional files .",
    "[ source , numberlines ] ----    off statistics ;    format 254 ;    # define cmd \" ./fermat",
    "|grep le=|sed s/^.\\*le=// \"    # define prolog \" & u ; & ( j = d ) ; ! ( \\'le=\\ ' , \"    # define epilog \") ; & q \"    symbol d ;    local withgcd = ( 2*d^4 + 3*d^3 - 22*d^2 - 13*d+30)/(d^3 - 11*d+10 ) ;    .sort    # do i = 1,1000      # write < finput > \" ` prolog ' % e ` epilog'\",withgcd      # system cat finput | ` cmd ' > foutput      # remove < finput >      local nogcd =      # include foutput               ;      print ;      .sort      drop nogcd ;      .sort    # enddo    .end ----    first the expression ` withgcd ` is saved to the file `` finput '' ( line 10 ) , then fermat is started ( line 11 ) .",
    "the contents of the input file is passed to the fermat standard input and the answer is redirected to the file `` foutput '' .",
    "note that the file ` finput ` must be removed ( line 12 ) or else in each iteration the ` # write ` instruction will append the input expression to the file .",
    "after fermat has been started , the content of the file `` finput '' is sent to it :    ....    & u ; & ( j = d ) ; !",
    "( ' le=',(2*d^4 + 3*d^3 - 22*d^2 - 13*d+30)/                                              ( d^3 - 11*d+10 ) ) ; & q ....    fermat prints a lot of text , and one line with the answer :    ....    le=   2*d+3 ....    the answer is selected by the filter    ....    grep le=|sed s/^.\\*le=// ....    and redirected to the file `` foutput '' .",
    "the program is placed into the file `` system.frm '' and the following command is executed :    ....    ( time form system.frm ) > system.res 2>&1   ....    the result is redirected to the file system.res . here",
    "are several lines from the end of the file system.res :    ....       nogcd =          3 + 2*d ;          .end      real   8m26.815s    user   5m4.010s    sys    0m24.250s ....      the following form program uses the ` # pipe ` preprocessor instruction to start fermat :    [ source , numberlines ] ----    off statistics ;    # define cmd \" |./fermat |grep le=|sed s/^.\\*le=// \"    # define prolog \" \\&u\\ ; \\&\\(j = d\\)\\ ; \\!\\(\\'le=\\ ' , \"    # define   epilog \" \\)\\ ; \\&q \"    symbol d ;    local withgcd = ( 2*d^4 + 3*d^3 - 22*d^2 - 13*d+30)/(d^3 - 11*d+10 ) ;    .sort    $ exp = withgcd ;    .sort    # do i=1,1000      local nogcd =      # pipe echo ` prolog ' \" ` $ exp ' \" ` epilog ' ` cmd '                ;      print ;      .sort      drop nogcd ;      .sort    # enddo    .end ----    the initial expression is passed to fermat after the initialization commands which use the command `` echo '' directly from the command line .",
    "the answer is read from the fermat standard output intercepted by form in the instruction ` # pipe ` .",
    "the local expression ` withgcd ` defined on line 6 is passed to the preprocessor on line 12 by means of a dollar variable ` $ exp ` initialized on line 8 .",
    "the program is placed into the file `` pipe.frm '' and the following command is executed :    ....    ( time form pipe.frm ) > pipe.res 2>&1   ....    the result is redirected to the file pipe.res .",
    "we show several lines at the end of the file pipe.res :    ....       nogcd =          3 + 2*d ;           .end      real   6m37.593s    user   5m3.360s    sys    0m23.750s ....      the following form program uses the ` # external ` preprocessor instruction to start fermat : [ external ]    [ source , numberlines ] ----    off statistics ;    format 250 ;    # define cmd \" ./fermat \"    # define init \" & d\\n0\\n&(m=\\ ' \\')\\n&(t=0)\\n&u\\n&(j = d)\\n \"    symbol d ;    # external ` cmd '    # toexternal \" ` init ' \"    # do i = 1,19      # fromexternal \" tmp \"    # enddo    local withgcd = ( 2*d^4 + 3*d^3 - 22*d^2 - 13*d+30)/(d^3 - 11*d+10 ) ;    .sort    # do i=1,1000      # toexternal \" % e\\n\",withgcd      # fromexternal \" tmp \"      local nogcd =      # fromexternal               ;      print ;      .sort      drop nogcd ;      .sort    # enddo    .end ----    after fermat has been started on line 6 the initialization string is sent in line 7 .",
    "fermat answers with 19 lines of text which are read into the preprocessor variable `` ` tmp ` '' and subsequently ignored ( lines 8 - 10 ) . after the expression has been sent ( line 14 ) , fermat produces an empty line ( which is read in line 15 and ignored ) and the output expression is assigned to the local expression `` ` nogcd ` '' ( lines 16 - 18 ) .",
    "the program is placed in the file `` extern.frm '' and the following command is executed :    ....    ( time form extern.frm ) > extern.res 2>&1   ....    the result is redirected to the file extern.res , of which we show several lines at the end :    ....       nogcd =          3 + 2*d ;           .end       real   0m0.799s    user   0m0.160s    sys    0m0.010s ....",
    "a `` real '' dialog between form and some external program is possible only if the full duplex channel is established between form and the external program . in principle , this could be done based on the ` # pipe ` instruction using the following trick ( we do nt claim this to be the only way in which it can be done )",
    ".    the `` main '' processor program could be not form but something started by form via the ` # pipe ` instruction .",
    "form is only waiting for commands from the main processor , performs these commands and returns results back by means of some sockets or named pipes , see fig .",
    "[ process ] .",
    "= .7 +    the form program itself is rather trivial :    ....    off statistics ;    format 250 ;    # pipe processor.sh    .end ....    the main functionality is contained by the shell script `` processor.sh '' :    [ source , numberlines ] ----    # ! /bin",
    "/ bash    rm -f tofermat fromfermat fromform 2 > /dev / null    mkfifo tofermat fromfermat fromform    ./fermat < tofermat > fromfermat &    exec 3 > tofermat    exec 4 < fromfermat    echo -e \" & d\\n0\\n&(m= ' ' ) \\n&(t=0)\\n&u\\n&(j = d ) \" > & 3    echo \" ! ( ' prompt ' ) \" > & 3    while [ \" $ reply \" ! = \" prompt \" ] ; do    read -u 4    done    read -u 4 ; read -u 4    echo ' # write < fromform > \" prompt \" '    echo ' symbol d ; '    exec 6 < fromform    read -u 6    echo \" local withgcd = ( 2*d^4 + 3*d^3 - 22*d^2 - 13*d+30)\\                                                 /(d^3 - 11*d+10 ) ; \"    echo \" .sort \"    i=0    while [ $ i -lt 1000 ] ; do    let i++ ;    echo ' # write < fromform > \" % e\",withgcd '    echo    read -u 6    echo \" $ reply \" > & 3    read -u 4 ; read -u 4 ;    echo \" local nogcd = $ { reply } ; \"    read -u 4    echo ' print ; '    echo ' .sort '    echo ' drop nogcd ; '    echo ' .sort '    done    rm -f tofermat fromfermat fromform ----    this file must be executable , which is achieved by entering the command + `` ` chmod + x ./processor.sh ` '' + after the file has been created .",
    "the script is the `` real '' main program and uses form for some algebraic evaluations .",
    "the communication between form and fermat is established by the script using several fifos ( named pipes ) .",
    "these pipes are created at lines 2 and 3 .",
    "the named pipe `` tofermat '' will be used in order to send data to fermat while the named pipe `` fromfermat '' will be used in order to receive data from fermat .",
    "the named pipe `` fromform '' will be used in order to get data from form while data to form are sent by the script via the standard output .    first",
    ", the script starts fermat ( line 4 ) intercepting the output by opening corresponding fifos ( lines 5 and 6 ) .",
    "then it initializes fermat ( line 7 ) and reads all the unimportant stuff produced by fermat ( lines 8  12 )",
    ".    then the script asks form to create the local expression ` withgcd ` , reads the result ( line 25 ) and sends it to fermat ( line 26 ) .",
    "the fermat answer is , again , passed to form ( line 28 ) and then the script asks form to print the result ( line 30 ) .",
    "the form program is placed into the file `` wrapper.frm '' and the following command is executed :    ....    ( time form wrapper.frm ) > process.res 2>&1   ....    the result is redirected to the file process.res . here",
    "are several lines at the end of the file process.res :    ....       nogcd =          3 + 2*d ;           drop nogcd ;        .sort",
    ".end       real   0m1.340s    user   0m0.500s    sys    0m0.060s ....    note that logically the main processor program ( the script `` processor.sh '' ) appears to be dependent on the `` stub''-like wrapper form program `` wrapper.frm '' .",
    "the `` main '' processor program should really parse the input in order to decide what should be sent to form and which data should be passed to fermat .",
    "practically , the processor program is a new cas using form to evaluate large - scale expressions , and fermat is used for non - local algebraic operations .",
    "this is rather similar to the use of perl scripts in which alternatingly form and maple are used to solve problems in mathematics  @xcite .",
    "the external channel instructions permit form to swallow an external program .",
    "the same mechanism can be used in order to _ embed _ form in other applications .",
    "there is a possibility to start form from another program providing one ( or more ) communication channels ( see below ) .",
    "these channels will be visible from a form program as `` pre - opened '' external channels existing after form starts .",
    "there is no need to open them with the `` ` # external ` '' instruction . in this case , the preprocessor variable `` ` pipes _ ` '' is defined and is equal to the total number of the pre - opened external channels .",
    "pre - opened external channel descriptors are contained in the preprocessor variables `` ` pipe1 _ ` '' , `` ` pipe2 _ ` '' , etc .",
    "for example , if `` pipes _ ` ' is 3 then there are 3 pre - opened external channels with the descriptors `` pipe1 _ ` ' , `` pipe2 _ ` ' and `` pipe3 _ ` ' so e.g. the following instruction could be used :    .... # setexternal ` pipe2 _ ' ....    without    .... # external \" pipe2 _ \" ....    the external channel attributes make no sense for the pre - opened channel ( see the preprocessor instruction ` # setexternalattr ` ) .",
    "formally , they are as follows :    ....     kill=0 ,     killall = false ,     daemon = false ,     stderr=/dev / tty ,     shell = noshell ....    in order to activate the pre - opened external channels , the parent application must follow some standards . here",
    "we describe a low - level protocol , the corresponding c - interface is available from the form distribution site @xcite .    before starting form ,",
    "the parent application must create one or more pairs of pipes .",
    "the read - only descriptor of the first pipe in the pair and the write - only descriptor of the second pipe must be passed to form as an argument of a command line option `` ` -pipe ` '' in ascii decimal format .",
    "the argument of the option is a comma - separated list of pairs `` ` r#,w # ` '' where `` ` r # ` '' is a read - only descriptor and `` ` w # ` '' is a write - only descriptor .",
    "for example , to start form with two pre - opened external channels the parent application has to create first four pipes .",
    "lets us suppose the first pipe was created with the descriptors 5 and 6 , the second pipe has the descriptors 7 and 8 , the third pipe has the descriptors 9 and 10 and the fourth pipe has the descriptors 11 and 12 .",
    "the descriptors 5 and 8 will be used by form as the input and the output for the first pre - opened external channel while the descriptors 9 and 12 will be used by form as the input and the output for the second pre - opened external channel .",
    "then the parent application must start form with the following command line option :    ....     -pipe 5,8,9,12 ....    upon startup , form sends its pid ( the process identifier ) in ascii decimal format with an appended newline character to the descriptor 8 and then form will wait for the answer from the descriptor 5 .",
    "the answer must be two comma - separated integers in ascii decimal format followed by a newline character .",
    "the first integer corresponds to the form pid while the second one is the parent process pid .",
    "if the answer is not obtained after some timeout , or if it is not correct ( i.e. it is not a list of two integers or the first integer is not the form pid ) then form fails .",
    "if everything is correct , form creates the pre - opened channel and puts its descriptor in the preprocessor variable `` ` pipe1 _ ` '' .",
    "then form processes the second pair of arguments , `` ` 9,12 ` '' .",
    "after all pairs have been processed form creates the preprocessor variable `` ` pipes _ ` '' and puts into this variable the total number of created pre - opened external channels .",
    "the order of processing the pairs of numbers in the argument is fixed exactly as it was described above i.e. from the left to the right .",
    "the presented technique can also be used to embed the reduce system in form .    transferring data to reduce",
    "we could ask form to use the output format to be compatible with the reduce one and the reduce output is essentially understandable by form although some minor syntax translation should be done .",
    "hence we do need a gateway .",
    "the following simple shell script could be used as a gateway :        echo ' off int$ ' > reduceinit    echo ' lisp setq(promptstring!*,\"\")$ ' > > reduceinit    echo ' lisp setq(promptexp ! * ' \" , ' ! ) $ \" > > reduceinit    echo ' off nat$ '   > > reduceinit    echo ' on gcd$ '    > > reduceinit    echo ' on ezgcd$ ' > > reduceinit    echo ' 1 ; ' > > reduceinit      reduce=\"$reduce / lisp / psl/$machine / psl / bpsl -td 128000000 \\                                                      -f $ image \"    outf1='sed -u   s/\\$/\\np\\n / g '    outf2='sed -u /^$/d '    cat -u reduceinit -|$reduce|$outf1|$outf2    rm -f reduceinit ----    the shell variable ` reduce ` defined on line 2 is the reduce root ( dependent of the reduce installation ! ) .",
    "the variables ` machine ` , ` reduce ` and ` lisp ` should be exported in order for reduce to work properly ( lines 3 - 8 ) .",
    "next the script prepares the initialization commands .",
    "these commands are placed into the file ` reduceinput ` ( lines 10 - 16 ) which will be deleted afterwards ( line 23 ) .",
    "the contents of the file are copied to reduce using the standard input , see the command ` cat ` ( line 22 ) .",
    "the argument `` ` - ` '' means that the standard input will be appended ( _ after _ the contents of the initialization file ` reduceinput ` ) .",
    "the option `` ` -u ` '' is ignored by the gnu ` cat ` utility but is mandatory for non - gnu versions of ` cat ` .",
    "the problem here is that most utilities attached to something different than the terminal perform so called `` block buffering '' ,",
    "i.e. , the data are passed to the standard output only when the internal buffer is full or when the end - of - file condition is reached .",
    "evidently , we need a different behavior : the data should be passed every time the string is ready .",
    "this is so called `` line buffering '' , or just unbuffered output .",
    "there are two unix utilities supporting this mode , namely ` cat ` and ` sed ` .",
    "the mode should be switched on explicitly by the ` -u ` option ( the gnu version of ` cat ` does this by default , and the option ` -u ` is just ignored ) .",
    "the prompt is set to `` ` p ` '' .",
    "the end of the reduce output expression is the character `` ` $ ` '' , which the output filter `` ` outf1 ` '' ( line 20 ) replaces by a line that contains only the string `` ` p ` '' .",
    "the `` ` outf2 ` '' filter on line 21 removes empty lines .",
    "the initialization commands are : + ` off int$ `  do not remember a history ; + ` lisp setq(promptstring!*\"\")$ ` , ` lisp setqpromptexp ! * , ' ! ) $ `  set the prompt string to be a new line character ; + ` off nat$ `  switch on a `` flat '' output ; + ` on gcd$ `  contract a greatest common divisor ; + ` on ezgcd$ `  use the ez gcd algorithm ( extended zassenhaus gcd , + http://www.uni-koeln.de/reduce/3.6/doc/reduce/node120.html ) .",
    "+ the input ` 1 ; ` is added in order to get the prompt string `` ` p ` '' .    let us suppose the script is placed into the executable file `` ` runreduce ` '' available in the current directory .",
    "the following form program , named + `` ` usereduce.frm ` '' demonstrates how to embed reduce in form :    [ source , numberlines ] ----    symbol d ;    format reduce ;    # prompt p    # external ./runreduce    # fromexternal \" tmp \" 1    local withgcd = ( 2*d^4 + 3*d^3 - 22*d^2 - 13*d+30)/(d^3 - 11*d+10 ) ;    .sort    # toexternal \" % e\\n\",withgcd    local nogcd =    # fromexternal             ;    print ;    .sort    # toexternal \" ( % e)*(%e)*(%e)\";\\n , withgcd , withgcd , withgcd    local nogcd1 =    # fromexternal             ;    print ;    .sort    # toexternal \" ( % e)^20;\\n\",withgcd    local nogcd2 =    # fromexternal             ;    print ;    .end ----      manipulating the output format of form is sometimes not so convenient .",
    "the `` reduce '' format option is not guaranteed to be perfect . using a gateway",
    ", we could translate the form default output into the reduce syntax `` on the fly '' .",
    "echo ' off int$ ' > reduceinit    echo ' lisp setq(promptstring!*,\"\")$ ' > > reduceinit    echo ' lisp setq(promptexp ! * ' \" , ' ! ) $ \" > > reduceinit    echo ' off nat$ '   > > reduceinit    echo ' on gcd$ '    > > reduceinit    echo ' on ezgcd$ ' > > reduceinit    echo ' 1 ; ' > > reduceinit      reduce=\"$reduce / lisp / psl/$machine / psl / bpsl -td 128000000 \\                                                       -f $ image \"    inf1='sed -u s/\\^-[0123456789]*/&pr / g '    inf2='sed -u s/\\-[0123456789]*pr/(&)/g '    inf3='sed -u -e s / pr//g -e s/\\^/**/g '    outf0='sed -u   s/\\*\\*/\\^/g '    outf1='sed -u   s/\\$/\\np\\n / g '    outf2='sed -u /^$/d '    cat -u reduceinit \\",
    "-|$inf1|$inf2|$inf3|$reduce|$outf0|$outf1|$outf2    rm -f reduceinit ----        input filters are defined in lines 20 - 22 .",
    "the problem here is that reduce does not understand expressions like ` a^-1 ` ; it needs at least ` a^(-1 ) ` instead of it .",
    "the standard symbol for the power operation in reduce is `` ` * * ` ''",
    "so all `` ` ^ ` '' are replaced by `` ` * * ` '' ( though this is not necessary since reduce understans the symbol `` ^`' in the input correctly ) .",
    "the `` ` inf1 ` '' filter translates the `` bare '' negative powers like `` ` a^-1 ` '' into the form `` ` a^-1pr ` '' , the filter `` ` inf2 ` '' converts it into an expression like `` ` a^(-1pr ) ` '' and the filter `` ` inf3 ` '' finally replaces the power operation symbol `` ` ^ ` '' by the reduce - standard `` ` * * ` '' and removes the auxiliary tag `` ` pr ` '' .",
    "the output filter `` ` outf0 ` '' ( line 23 ) translates the reduce power operation `` ` * * ` '' to the form notation `` ` ^ ` '' . in principle , this is not necessary since form understands the reduce - like input notation .        note , reduce will produce some strange line breaks when the numbers become too big , hence a simple gateway like ` runreduce1 ` is not completely suitable .",
    "if , for instance , line number 20 of the file `` ` usereduce.frm ` '' is changed into        the problem is that reduce could break the line just before the symbol `` ` * ` '' and form ignores the next line assuming this is a comment .",
    "the comment character could be changed but in general it is more reliable to get the answer without linebreaks at all .    unfortunately , there is no standard unix utility permitting unbuffered operations on the end - of - line symbol .",
    "the only way here is to write some small program , e.g. , the following perl script placed in the file `` ` smallfilter.pl ` '' :            line 4 of `` ` smallfilter.pl ` '' is equivalent to the filter `` ` outf0 ` '' in line 23 of the script `` ` runreduce1 ` '' .",
    "line 6 of `` ` smallfilter.pl ` '' is equivalent to the filter `` ` outf1 ` '' in line 24 of the script `` ` runreduce1 ` '' , and line 5 of `` ` smallfilter.pl ` '' extends the functionality of the filter `` ` outf2 ` '' in line 25 of the script + `` ` runreduce1 ` '' just gluing a whole portion of the output into a single line .",
    "print w   \" off int\\$\\n \" ; print w \" lisp setq(promptstring!*,\\\"\\\")\\$\\n \" ; print w \" lisp setq(promptexp ! * , ' ! ) \\$\\n \" ; print w \" off nat\\$\\n \" ; print w \" on gcd\\$\\n \" ; print w \" on ezgcd\\$\\n \" ; print w \" 1;\\n \" ; $ outp=<r > until $ outp eq \" 1\\$\\n \" ;    while ( < > ) {     $ _ = ~ s/\\^\\-([0 - 9]+)/^(-$1)/g ;     $ _",
    "= ~ s/\\^/**/g ;     print w $ _ ;     $ ransw = m/;/ ;     while($ransw ) {        $ outp=<r > ;        $ outp = ~ s/\\*\\*/^/g ;        $ outp = ~ s/\\n//g ;        $ outp = ~ s/(\\$)/\\np\\n / g ;        print $ outp ;        $ ransw=($1 ne ' $ ' ) ;     } } print w \" bye;\\n \" ; < r>;<r > ; close(r ) ; close(w ) ; ----    reduce is started ( line 15 ) by means of a standard ipc::open2 module ( line 2 ) .",
    "line 3 switches off buffering . lines 5 - 8 set necessary paths and some environment variables which are exported on lines 9 - 11 .",
    "initialization commands ( lines 17 - 23 ) are the same as discussed above ( lines 10 - 16 of the file `` ` runreduce ` '' ) . in contrast to shell scripts , the reduce response is read directly from the script and ignored ( line 24 ) .",
    "the script reads line by line from the standard input ( in the conditional expression of the ` while ` loop , line 26 ) into the default variable ` $ _ ` .",
    "after some syntax translation ( lines 27 and 28 ) the translated line is sent to reduce ( line 29 ) .",
    "line 27 corresponds to the input filters ` inf1 ` and ` inf2 ` and line 28 corresponds to the filter ` inf3 ` of the script `` ` runreduce1 ` '' ( see lines 20 - 22 of the file `` ` runreduce1 ` '' ) . in principle , the line 28 is not needed since reduce understands the power symbol `` ` ^ ` '' in the input expression .",
    "once the script detects a semicolon in an input line ( lines 30 , 31 ) it starts to read an answer from reduce , lines 31 - 38 , performing a ( generally speaking , unnecessary ) syntax translation from reduce to form ( line 33 ) .",
    "all newline characters are removed ( line 34 ) and the reduce end - of - expression character `` ` $ ` '' is converted to the prompt `` ` p ` '' .",
    "if such a conversion occurs , the variable `` ` ransw ` '' becomes ` false ` ( line 37 ) and the script continues to read the standard input .",
    "99 j.a.m .",
    "vermaseren , math - ph/0010025 .",
    "all programs and examples relating to this publication can be obtained from the directory publications / external in the form distribution site http://www.nikhef.nl/~form .",
    "m. tentyukov j.a.m .",
    "vermaseren and h.m .",
    "staudenmaier , `` parform : recent development '' , to appear in : nuclear instruments and methods in physics research section a ; cs.sc/0510093    s.  moch , j.  a.  m.  vermaseren and a.  vogt , nucl .",
    "b * 688 * ( 2004 ) 101 , arxiv : hep - ph/0403192 ; a.  vogt , s.  moch and j.  a.  m.  vermaseren , nucl .",
    "b * 691 * ( 2004 ) 129 , arxiv : hep - ph/0404111 ; j.  blumlein and j.  a.  m.  vermaseren , phys .",
    "b * 606 * ( 2005 ) 130 , arxiv : hep - ph/0411111 ; p.  a.  baikov , k.  g.  chetyrkin and j.  h.  kuhn , phys .",
    "* 95 * ( 2005 ) 012003 , arxiv : hep - ph/0412350 ; y.  schrder and a.  vuorinen , jhep * 0506 * ( 2005 ) 051 , arxiv : hep - ph/0503209 ; j.  a.  m.  vermaseren , a.  vogt and s.  moch , nucl .",
    "b * 724 * ( 2005 ) 3 , arxiv : hep - ph/0504242 ; r.  bonciani and a.  ferroglia , phys .  rev .",
    "d * 72 * ( 2005 ) 056004 arxiv : hep - ph/0507047 ; p.  a.  baikov , k.  g.  chetyrkin and j.  h.  kuhn , phys .",
    "* 96 * ( 2006 ) 012003 , arxiv : hep - ph/0511063 ; y.  schrder and m.  steinhauser , jhep * 0601 * ( 2006 ) 051 , arxiv : hep - ph/0512058",
    ". k.  g.  chetyrkin , j.  h.  kuhn and c.  sturm , arxiv : hep - ph/0512060 ; t.  aoyama , m.  hayakawa , t.  kinoshita and m.  nio , arxiv : hep - ph/0512288 ;"
  ],
  "abstract_text": [
    "<S> we describe the implementation of facilities for the communication with external resources in the symbolic manipulation system form . </S>",
    "<S> this is done according to the posix standards defined for the unix operating system . </S>",
    "<S> we present a number of examples that illustrate the increased power due to these new capabilities .    </S>",
    "<S> sfb / cpp-06 - 15 + ttp06 - 12 + nikhef 06 - 002 </S>"
  ]
}