{
  "article_text": [
    "the performance of backtracking algorithms for solving finite - domain constraint satisfaction problems can be improved substantially by so called look - back and look - ahead methods @xcite .",
    "look - back techniques extract information by analyzing failing search paths that are terminated by dead ends and use that information to prune the search tree .",
    "look - ahead techniques use constraint propagation algorithms in an attempt to avoid such dead ends altogether .",
    "constraint propagation can rather easily be isolated from the search itself and can be localized in a constraint store . following the seminal work of @xcite ,",
    "look - ahead techniques are available to the logic programmer in a large number of systems .",
    "this is not the case for look - back methods .",
    "intelligent backtracking has been explored as a way of improving the backtracking behavior of logic programs @xcite . for some time , a lot of effort went into adding intelligent backtracking to prolog implementations ( see references in @xcite ) . however ,",
    "the inherent space and time costs , which must be paid even when no backtracking occurs , impeded its introduction in real implementations .    for a long time , look - ahead methods dominated in solving constraint satisfaction problems . however , already in @xcite we have shown empirical evidence that look - back methods can be useful , even that it can be interesting to combine both . starting in the nineties",
    "there is a renewed interest in look - back methods , _",
    "e.g. _ , @xcite , and in combining look - back with look - ahead _",
    "e.g. _ , @xcite .",
    "look - back turned out to be the most successful of the approaches tried in a research project aiming at detecting unsolvable queries ( queries that do not terminate , such as the query @xmath0 for a program defining odd and even numbers ) .",
    "the approach was to construct a model of the program over a finite domain in which the query was false .",
    "the central part of this model construction was to search for a pre - interpretation leading to the desired model , _",
    "i.e. _ , with @xmath1 the domain , to find an appropriate function @xmath2 for every n - ary functor in the program .",
    "a meta - interpreter was built which performed a backtracking search over the solution space .",
    "a control strategy was devised which resulted in the early detection of instances of program clauses which showed that the choices made so far could not result in the desired model .",
    "this meta - interpreter outperformed dedicated model generators on several problems @xcite .",
    "however it remained very sensitive to the initial ordering in which the various components of the different functions were assigned .",
    "the point was that not all choices made so far necessarily contributed to the evaluation of a clause instance .",
    "we experimented with constraint techniques and also investigated the use of intelligent backtracking .",
    "with a small programming effort , we could enhance the meta - interpreter to support a form of intelligent backtracking . as reported in @xcite",
    ", this was the most successful approach .",
    "as prolog is a popular tool for prototyping search problems and as look - back methods , though useful , are not available in off - the - shelf prolog systems , we decided to describe for a wider audience how to enhance a prolog search program with a form of intelligent backtracking .",
    "the technique crucially depends on the impure feature of prolog ( assert / retract ) that allows storing information when a dead end is reached .",
    "the stored information is used to decide whether a choice point should be skipped when chronological backtracking returns to it .",
    "hence we propose the technique as a black pearl .    in the application",
    "mentioned above , the meta - interpreter is performing a substantial amount of computation after making a choice whereas the amount of computation added to support intelligent backtracking is comparatively small .",
    "this is not always the case .",
    "when the amount of computation in between choices is small and solutions are rather easy to find , the overhead of supporting intelligent backtracking may be larger than the savings due to the pruning of the search space .",
    "this is the case in toy problems such as the n - queens . in the example",
    "we develop here , there is a small speed - up .",
    "we recall some basics of intelligent backtracking in section  [ sec : ib ] . in section",
    "[ sec : nqueens ] , we introduce the example program and in section [ sec : ib ] we enhance it with intelligent backtracking .",
    "we conclude with a discussion in section  [ sec : discussion ] .",
    "intelligent backtracking as described in @xcite is a very general schema .",
    "it keeps track of the reason for eliminating a variable in a domain . upon reaching a dead end",
    ", it identifies a culprit for the failure and _ jumps back _ to the choice point where the culprit was assigned a value .",
    "information about the variables assigned in between the culprit and the dead end can be retained if still valid , as in the dynamic backtracking of @xcite which can be considered as an instance of the schema .",
    "more straightforward in a prolog implementation is to give up that information , this gives the backjumping algorithm ( algorithm 3.3 ) in @xcite ( intelligent backtracking with static order in @xcite ) .",
    "we follow rather closely @xcite for introducing it .    a constraint satisfaction problem ( csp )",
    "can be identified by a triple @xmath3 with @xmath4 a set of variables , @xmath1 a mapping from variables to domains and @xmath5 a set of constraints .",
    "each variable @xmath6 is mapped by @xmath1 into a domain @xmath7 of possible values .",
    "each constraint @xmath8 defines a relation @xmath9 over a set @xmath10 of variables and is satisfied for the tuples in that relation . a solution to a csp consists of a value @xmath11 ( an _ assignment _ ) for each variable @xmath12 in @xmath4 such that : ( 1 ) for all variables @xmath12 : @xmath13 and , ( 2 ) for all constraints @xmath14 : with @xmath15 , it holds that @xmath16 .",
    "a partial solution to a csp @xmath3 is a subset @xmath17 and an assignment to each variable in @xmath18 . a partial solution @xmath19 is ordered by the order in which the algorithm that computes it assigns values to the variables and is denoted by a sequence of ordered pairs @xmath20 .",
    "a pair @xmath20 indicates that variable @xmath12 is assigned value @xmath11 ; @xmath21 denotes the set of variables assigned values by @xmath19 .",
    "given a partial solution @xmath19 , an _ eliminating explanation _",
    "( cause - list in @xcite ) for a variable @xmath12 is a pair @xmath22 where @xmath23 and @xmath24 .",
    "it expresses that the assignments to the variables of @xmath25 by the partial solution @xmath19 can not be extended into a solution where variable @xmath12 is assigned value @xmath11 .",
    "contrary to @xcite , we use an _ elimination mechanism _ that tests one value at a time .",
    "hence we assume a function @xmath26 that returns true when @xmath27 satisfies all constraints over @xmath28 and a function @xmath29 that returns an eliminating explanation @xmath22 when @xmath30 .",
    "below , we formulate the backjumping algorithm ; next we clarify its reasoning .",
    "@xmath31 is the set of eliminating explanations for variable @xmath12 .",
    "[ alg:1 ] given as inputs a csp @xmath3 .    1 .",
    "set @xmath32 .",
    "2 .   if @xmath33 return @xmath19 . otherwise select a variable @xmath34 , set @xmath35 and @xmath36 .",
    "3 .   if @xmath37 is empty then go to step 4 ; otherwise , remove an element @xmath11 from it .",
    "+ if @xmath26 then extend @xmath19 with @xmath20 and go to step 2 ; otherwise add @xmath38 to @xmath31 and go to step 3 .",
    "( @xmath37 is empty and @xmath31 has an eliminating explanation for each value in @xmath7 . ) let @xmath5 be the set of all variables appearing in the explanations of @xmath31 .",
    "if @xmath39 , return failure .",
    "otherwise , let @xmath40 be the last pair in @xmath19 such that @xmath41 .",
    "remove from @xmath19 this pair and any pair following it .",
    "add @xmath42 to @xmath43 , set @xmath44 and go to step 3 .    in step 3 , when the extension of the partial solution is inconsistent then @xmath29 returns a pair @xmath45 such that the partial solution @xmath46 violates the constraints .",
    "the inconsistency of this assignment can be expressed by the clause : @xmath47 ( the head is false , the body is a conjunction ) .    in step 4 ,",
    "when @xmath37 is empty , we have an eliminating explanation for each value @xmath48 in the domain @xmath7 .",
    "hence we have a set of clauses of the form @xmath49    the condition that the variable @xmath12 must be assigned a value from domain @xmath7 with @xmath50 elements can be expressed by the clause ( the head is a disjunction , the body is true ) : @xmath51    now , one can perform hyperresolution @xcite between clause ( [ cl1 ] ) and the clauses of the form ( [ cl2 ] ) ( for @xmath52 from 1 to @xmath50 ) .",
    "this gives : @xmath53    this expresses a conflict between the current values of the variables in the set @xmath54 .",
    "hence , with @xmath55 the last assigned variable in @xmath5 , @xmath56 is an eliminating explanation for @xmath57 . the conflict @xmath5 is computed in step 4 . when empty , the problem has no solution as detected in step 5 .",
    "otherwise , step 5 backtracks and adds the eliminating explanation @xmath58 to the set of eliminating explanations of variable @xmath55 .",
    "one can observe that the algorithm does not use the individual eliminating explanations in the set @xmath59 , but only the set @xmath5 which is the union of the sets @xmath60 .",
    "as we have no interest in introducing more refined forms of intelligent backtracking , we develop algorithm  [ alg:2 ] where @xmath31 holds the union of the sets @xmath60 in the eliminating explanations of variable @xmath12 . to obtain an algorithm that closely corresponds to the prolog encoding we present in section  [ sec : ib ] , we reorganise the code and introduce some more changes .",
    "the function @xmath61 that returns an eliminating explanation @xmath22 for the current value of variable @xmath12 is replaced by a function @xmath62 that returns the set @xmath63 ( the variables that participate in a conflict as represented by equation  [ cl2 ] ) .",
    "this conflict is stored in a variable @xmath5 ( step 3 of algorithm  [ alg:2 ] ) .",
    "it is nonempty and @xmath12 is the last assigned variable , hence the value of @xmath12 remains unchanged in step 4 and , in step 5 , the eliminating explanation @xmath64 is added to @xmath31 .",
    "this reorganisation of the code has as result that a local conflict ( the chosen value for the last assigned variable @xmath12 is inconsistent with the partial solution ) and a deep conflict ( all values for variable @xmath12 have been eliminated ) are handled in a uniform manner : upon failure , the algorithm computes a conflict and stores it in variable @xmath5 ( for the local conflict in step 3 , for the deep conflict in step 5 ) , backtracks to the variable computed in step 4 ( the `` culprit '' ) and resumes in step 5 with updating @xmath31 and trying a next assignment to variable @xmath12 .",
    "[ alg:2 ] given as input a csp @xmath3 .    1 .",
    "set @xmath32 .",
    "2 .   if @xmath33 return p. otherwise select a variable @xmath34 .",
    "select a value @xmath11 from @xmath7 . set @xmath65 and @xmath36 .",
    "3 .   if @xmath66 then extend @xmath19 with @xmath20 and go to step 2 ; otherwise set @xmath67 .",
    "4 .   if @xmath68 then return failure ; otherwise let @xmath40 be the last pair in @xmath19 such that @xmath41 .",
    "set @xmath44 .",
    "5 .   add @xmath64 to @xmath31 . if @xmath69 then @xmath70 and go to step 4 ; otherwise select and remove a value @xmath11 from @xmath37 and go to step 3 .",
    "the code below is , apart from the specific constraints , fairly representative for a finite domain constraint satisfaction problem .",
    "the problem is parameterized with two cardinalities : varcard , the number of variables ( the first argument of problem/3 ) and valuecard , the number of values in the domains of the variables ( the second argument of problem/3 ) .",
    "the third argument of problem/3 gives the solution in the form of a list of elements @xmath71 .",
    "the main predicate uses init_domain/2 to create a domain @xmath72 $ ] and init_pairs/3 to initialize @xmath73 as a list of pairs @xmath12-@xmath7 with @xmath7 the domain of variable @xmath12 .",
    "the first argument of extend_solution/3 is a list of pairs @xmath12-@xmath7 with @xmath12 an unassigned variable and @xmath7 what remains of its domain ; the second argument is the ( consistent ) partial solution ( initialized as the empty list ) and the third argument is the solution .",
    "the predicate is recursive ; each iteration extends the partial solution with an assignment to the first variable on the list of variables to be assigned .",
    "the nondeterministic predicate my_assign/2 selects the value .",
    "if desirable , one could introduce a selection function which dynamically selects the variable to be assigned next .",
    "consistency of the new assignment with the partial solution is tested by the predicates consistent1/2 and consistent2/2 .",
    "they create a number of binary constraints .",
    "the binary constraints themselves are tested with the predicates constraint1/2 and constraint2/2 .",
    "what they express is not so important .",
    "the purpose is to create a problem that is sufficiently difficult so that enhancing the program with intelligent backtracking pays off . for the interested reader",
    ", the predicate consistent2/2 creates a very simple constraint that verifies ( using constraint1/2 ) that the value of the newly assigned variable is different from the value of the previously assigned variable .",
    "the predicate consistent1/2 creates a set of more involved constraints .",
    "the odd numbered and even numbered variables each encode the constraints of the n - queens problem . as a result ,",
    "the solution of _",
    "problem(16,8,s ) contains a solution for the 8-queens problem in the odd numbered variables and a _ different _ ( due to the constraints created by consistent2/2 ) solution in the even numbered variables .",
    "substantial search is required to find a first solution .",
    "for example , the first solution for problem(16,8,s ) is found after 32936 assignments ( using a similar set - up of constraints , a solution is found for the 8-queen problem after only 876 assignments ) .",
    "note that the constraint checking between the new assigned variable and the other assigned variables is done in an order that is in accordance with the order of assigning variables .",
    "hence consistent1/2 is not tail recursive .",
    "the order is not important for the algorithm without intelligent backtracking .",
    "however , it is crucial to obtain optimal intelligent backtracking : as with chronological backtracking , constraint checking will stop at the first conflict detected and an eliminating explanation will be derived from it . as an eliminating explanation with an older assigned variable gives more pruning than one with a more recently assigned variable , the creation of constraints requires one to pay attention to the order .",
    "it is done already here to minimize the differences between this version and the enhanced version .    ....",
    "problem(varcard , valuecard , solution ) : -          init_domain(valuecard , domain ) ,          init_pairs(varcard , domain , pairs ) ,          extend_solution(pairs,[],solution ) .",
    "init_domain(valuecard , domain ) : -          ( valuecard=0 - > domain= [ ]          ; valuecard>0 , valuecard1 is valuecard-1 ,               domain=[valuecard|domain1 ] ,              init_domain(valuecard1,domain1 )          ) .",
    "init_pairs(varcard , domain , vars ) : -          ( varcard=0 - > vars = [ ]          ; varcard>0 , varcard1 is varcard-1 ,              vars=[varcard - domain|vars1 ] ,              init_pairs(varcard1,domain , vars1 )          ) .",
    "extend_solution([],solution , solution ) .",
    "extend_solution([var - domain|pairs],partialsolution , solution ) : -          my_assign(domain , value ) ,          consistent1(partialsolution , assign(var , value ) ) ,          consistent2(partialsolution , assign(var , value ) ) ,          extend_solution(pairs ,                         [ assign(var , value)|partialsolution ] ,                         solution ) .",
    "my_assign([value|_],value ) .",
    "my_assign([_|domain],value ) : - my_assign(domain , value ) .    consistent1 ( [ ] , _ ) .",
    "consistent1 ( [ _ ] , _ ) .",
    "consistent1 ( [ _ , assignment1|partialsolution],assignment0 ) : -           consistent1(partialsolution , assignment0 ) ,          constraint1(assignment0,assignment1 ) ,          constraint2(assignment0,assignment1 ) .",
    "consistent2 ( [ ] , _ ) .",
    "consistent2([assignment1|_],assignment0 ) : -           constraint1(assignment0,assignment1 ) .    constraint1(assign(_,value0),assign(_,value1 ) ) : - value0 \\== value1 .",
    "constraint2(assign(var0,value0),assign(var1,value1 ) ) : -          d1 is abs(value0-value1 ) ,          d2 is abs(var0-var1)//2 ,          d1 \\== d2 . ....",
    "adding intelligent backtracking requires us to maintain eliminating explanations . in algorithm",
    "[ alg:2 ] , a single eliminating explanation is associated with each variable . the eliminating explanation of a variable @xmath12 is initialised as empty in step 2 , when assigning a first value to the variable .",
    "it is updated in step 5 , when the last assigned value turns out to be the `` culprit '' of an inconsistency .",
    "this happens just before assigning the next value to variable @xmath12 .",
    "this indicates that the right place to store eliminating explanations is as an extra argument in the predicate my_assign/2 . in step 4 ,",
    "the algorithm has to identify the `` last '' variable @xmath55 of a conflict ( the `` culprit '' ) , just before updating the eliminating explanation .",
    "we will also use the my_assign/2 predicate to check whether the variable it assigns corresponds to the culprit of the failure .",
    "hence also the identitity of the variable should be an argument .",
    "these considerations lead to the replacement of the my_assign/2 predicate by the following my_assign/4 predicate .    ....",
    "my_assign([value|_],_var,_explanation , value ) .",
    "my_assign([_|domain],var , explanation0,value ) : -          get_conflict(conflict ) ,          remove(var , conflict , explanation1 ) ,          set_union(explanation0,explanation1,explanation ) ,          my_assign(domain , var , explanation , value ) .",
    "my_assign([],_var , explanation,_value ) : -          save_conflict(explanation ) , fail .",
    "....    it is called from extend_solution/4 as myassign(domain , var,[],value ) ( what remains of the domain is the first argument , the second argument is the variable being assigned , the third argument is the initially empty eliminating explanation and the fourth argument returns the assigned value ) . the initial call together with the base case perform the otherwise branch of step 2 .",
    "the second clause , entered upon backtracking when the domain is nonempty , checks whether the variable being assigned is the culprit . to do so",
    ", it needs the conflict .",
    "as this information is computed just before failure occurs , it can not survive backtracking when using the pure features of prolog .",
    "one has to rely on the impure features for asserting / updating clauses .",
    "either assert/1 and retract/1 or more efficient variants of specific prolog systems .",
    "the call to get_conflict(conflict ) picks up the saved conflict ; next , the call remove(var , conflict , explanation1 ) checks whether var is part of it . if not , my_assign/4 fails and backtracking returns to the previous assignment .",
    "if var is the culprit , then the code performs step 5 of the algorithm : remove/3 returns the eliminating explanation in its third argument , set_union/3 adds it to the current eliminating explanation and the recursive call checks whether the domain is empty . if not ,",
    "the base case of my_assign/4 assigns a new value .",
    "if the domain is empty , then the last clause is selected .",
    "the eliminating explanation becomes the conflict and is saved with the call to save_conflict(explanation ) that relies on the impure features and the clause fails .",
    "further modifications are in the predicates constraint1/2 and constraint2/2 that perform the constraint checking .",
    "if a constraint fails , the variables involved in it make up the conflict and have to be saved so that after re - entering myassign/4 the conflict can be picked up and used to compute an eliminating explanation ( step 3 ) . as the last assigned variable participates in all constraints , it is part of the conflict .",
    "for example , the code for constraint1/2 becomes :    .... constraint1(assign(var0,value0),assign(var1,value1 ) ) : -          ( value0 \\== value1 - > true          ; save_conflict([var0,var1 ] ) , fail          ) . ....",
    "the modification to constraint2/2 is similar .",
    "recall that the order in which constraints are checked determines the amount of pruning that is achieved .",
    "finally , if one is interested in more than one solution then also a conflict has to be stored when finding a solution .",
    "it consists of all variables making up the solution . using a predicate allvars/2 that extracts the variables from a solution ,",
    "the desired behavior is obtained as follows :    .... problem(varcard , valuecard , solution ) : -          init_domain(valuecard , domain ) ,          init_pairs(varcard , domain , pairs ) ,          extend_solution(pairs,[],solution ) ,          initbacktracking(solution ) .",
    "initbacktracking(solution ) : -          allvars(solution , conflict ) ,          save_conflict(conflict ) .",
    "....    the enhanced program generates the same solutions as the original , and in the same order . for problem(16,8,s ) the number of assignments goes down from 32936 to 4015 and the execution time from 140ms to 70ms ; for problem(20,10,s ) , the reduction is respectively from 75950 to 15813 and from 370ms to 310ms .",
    "the achieved pruning more than compensates for the ( substantial ) overhead of recording and updating conflicts and of the calls to remove/3 and set_union/3 .",
    "note that the speed - up decreases with larger instances of this problem .",
    "this is likely due to the increasing overhead of the latter two predicates . keeping the conflict set sorted ( easy here because the variable numbers corresponds with the order of assignment ) such that the culprit is",
    "always the first element could reduce that overhead .",
    "in this black pearl , we have illustrated by a simple example how a chronological backtracking algorithm can be enhanced to perform intelligent backtracking .",
    "as argued in the introduction , look - back techniques are useful in solving various search problems . hence exploring their application",
    "can be very worthwhile when building a prototype solution for a problem .",
    "the technique presented here illustrates how this can be realized with a small effort when implementing a prototype in prolog .",
    "interestingly , the crucial feature is the impurity of prolog that allows the search to transfer information from one point in the search tree ( a dead end ) to another .",
    "it illustrates that prolog is a multi - faceted language . on the one hand it allows for pure logic programming ,",
    "on the other hand it is a very flexible tool for rapid prototyping .",
    "note that the savings due to the reduction of the search space could be undone by the overhead of computing and maintaining the extra information , especially , when the amount of computation between two choice points is small .    the combination of look - back and look - ahead techniques can be useful , and algorithms integrating both can be found , _",
    "e.g. _ , @xcite .",
    "the question arises whether our solution can be extended to incorporate look - ahead .",
    "this requires some work , however , much of the design can be preserved .",
    "the initialization ( init_domains/3 ) should not only associate variables with their initial finite domain , but also with their eliminating explanations ( initially empty ) .",
    "then the code for the main iteration could be as follows :    .... extend_solution([],solution , solution ) .",
    "extend_solution(vars , partialsolution , solution ) : -          selectbestvar(vars , var(var , values , explanation),rest ) ,          myassign(values , var , explanation , value ) ,          consistent(partialsolution , assign(var , value ) ) ,          propagate([assign(var , value)|partialsolution ] ,                    newpartialsolution )          extend_solution(vars , newpartialsolution , solution ) .",
    "....    the predicate selectbestvar/3 is used to dynamically select the next variable to assign .",
    "it returns the identity of the variable ( @xmath74 ) , the available values ( @xmath75 ) and the explanation ( @xmath76 ) for the eliminated values .",
    "when a partial solution is successfully extended , the predicate propagate/2 has to take care of the constraint propagation : eliminating values from domains and updating the corresponding explanations after which the next iteration can start .",
    "computing the eliminating explanation for each eliminated value requires great care and depends on the kind of look - ahead technique used .",
    "it is pretty straightforward for forward checking but requires careful analysis in case of _",
    "e.g. _ , arc consistency as no pruning will occur on backjumping when the elimination is attributed to _ all _ already assigned variables .",
    "i am grateful to bart demoen , gerda janssens and henk vandecasteele for useful comments on various drafts of this pearl .",
    "i am very grateful to the reviewers . indeed ,",
    "as often is the case , their persistence and good advise greatly contributed to the clarity of the exposition .          ,",
    "vandecasteele , h. , de  waal , d.  a. , and denecker , m. 1998 .",
    "etecting unsolvable queries for definite logic programs . in _ principles of declarative programming ,",
    "plilp98 and alp98 _ , c.  palamidessi , h.  glaser , and k.  meinke , eds .",
    "springer , 118133 .",
    "mpirical study of some constraint satisfaction algorithms . in _ artificial intelligence ii , methodology , systems , applications , proc .",
    "aimsa86 _ , p.  jorrand and v.  sgurev , eds .",
    "north holland , 173180 ."
  ],
  "abstract_text": [
    "<S> this paper illustrates how a prolog program , using chronological backtracking to find a solution in some search space , can be enhanced to perform intelligent backtracking . </S>",
    "<S> the enhancement crucially relies on the impurity of prolog that allows a program to store information when a dead end is reached . to illustrate the technique , </S>",
    "<S> a simple search program is enhanced .    </S>",
    "<S> to appear in theory and practice of logic programming .    </S>",
    "<S> [ firstpage ]    intelligent backtracking , dependency - directed backtracking , backjumping , conflict - directed backjumping , nogood sets , look - back . </S>"
  ]
}