{
  "article_text": [
    "hedges are finite sequences of unranked terms .",
    "these are terms in which function symbols do not have a fixed arity : the same symbol may have a different number of arguments in different places .",
    "manipulation of such expressions has been intensively studied in recent years in the context of xml processing , rewriting , automated reasoning , knowledge representation , just to name a few .",
    "when working with unranked terms , variables that can be instantiated with hedges ( hedge variables ) are a pragmatic necessity . in ( pattern - based ) programming , hedge variables help to write neat , compact code . using them , for instance , one can extract duplicates from a list with just one line of a program .",
    "several languages and formalisms operate on unranked terms and hedges .",
    "the programming language of mathematica @xcite is based on hedge pattern matching .",
    "languages such as tom @xcite , maude @xcite , asf+sdf @xcite provide capabilities similar to hedge matching ( via associative functions ) .",
    "@xmath1log @xcite extends logic programming with hedge transformation rules , see also @xcite .",
    "xduce @xcite enriches untyped hedge matching with regular expression types .",
    "the constraint logic programming schema has been extended to work with hedges in clp(flex ) @xcite , which is a basis for the xml processing language xcentric @xcite and a web site verification language veriflog @xcite .",
    "the goal of this paper is to describe a precise semantics of constraint logic programs over hedges .",
    "we consider positive clp programs with two kinds of primitive constraints : equations between hedges , and membership in a hedge regular language .",
    "function symbols are unranked .",
    "predicate symbols have a fixed arity .",
    "terms may contain three kinds of variables : for terms ( term variables ) , for hedges ( hedge variables ) , and for function symbols ( function variables ) .",
    "moreover , we may have function symbols whose argument order does not matter ( unordered symbols ) : a kind of generalization of the commutativity property to unranked terms .",
    "as it turns out , such a language is very flexible and permits to write short , yet quite clear and intuitive code : one can see examples in sect .",
    "[ sect : examples ] .",
    "we call this language @xmath0 , for clp over hedges .",
    "it generalizes clp(flex ) with function variables , unordered functions , and membership constraints .",
    "hence , as a special case , our paper describes the semantics of clp(flex ) .",
    "moreover , as hedges generalize strings , @xmath0 can be seen also as a generalization of clp over strings @xmath2",
    "@xcite , string processing features of prolog iii  @xcite , and clp over regular sets of strings clp(@xmath3 )  @xcite .",
    "note that some of these languages allow an explicit size factor for string variables , restricting the length of strings they can be instantiated with .",
    "we do not have size factors , but can express this information easily with constraints .",
    "for instance , to indicate the fact that a hedge variable @xmath4 can be instantiated with a hedge of minimal length 1 and maximal length 3 , we can write a disjunction @xmath5 , where the lower case @xmath6 s are term variables .    flexibility and the expressive power of @xmath0 has its price : equational constraints with hedge variables , in general , may have infinitely many solutions  (; ) .",
    "therefore , any complete equational constraint solving procedure with hedge variables is nonterminating .",
    "the solver we describe in this paper is sound and terminating , hence incomplete for arbitrary constraints .",
    "however , there are fragments of constraints for which it is complete , i.e. , computes all solutions .",
    "one such fragment is so called well - moded fragment , where variables in one side of equations ( or in the left hand side of the membership atom ) are guaranteed to be instantiated with ground expressions at some point .",
    "this effectively reduces constraint solving to hedge matching  (; ) , plus some early failure detection rules .",
    "another fragment for which the solver is complete is named after the knowledge interchange format , kif  @xcite , where hedge variables are permitted only in the last argument positions .",
    "we identify forms of @xmath0 programs which give rise to well - moded or kif constraints .",
    "uses unitary unification for higher - order patterns instead of undecidable higher - order unification . ]    we can easily model lists with ordered function symbols and multisets with the help of unordered ones .",
    "in fact , since we may have several such symbols , we can directly model colored multisets .",
    "constraint solving over lists , sets , and multisets has been intensively studied , see , e.g. ,  @xcite and references there , and the clp schema can be extended to accommodate them . in our case",
    ", an advantage of using hedge variables in such terms is that hedge variables can give immediate access to collections of subterms via unification .",
    "it is very handy in programming .",
    "this paper is an extended and revised version of  @xcite .",
    "it is organized as follows : after establishing the terminology in section  [ sect : preliminaries ] , we give two motivating examples in section  [ sect : examples ] to illustrate @xmath0 .",
    "the algebraic semantics is studied in section  [ sect : semantics ] .",
    "the constraint solver is introduced in section  [ sect : solver ] .",
    "the operational semantics of @xmath0 is described in section  [ sect : operational ] . in sections",
    "[ sect : well - moded ] and [ sect : kif ] , we introduce the well - moded and kif fragments , respectively .",
    "section  [ sect : conclusion ] contains concluding remarks .",
    "for common notation and definitions , we mostly follow  @xcite .",
    "the alphabet @xmath7 consists of the following pairwise disjoint sets of symbols :    * @xmath8 : term variables , denoted by @xmath9 , * @xmath10 : hedge variables , denoted by @xmath11 , * @xmath12 : function variables , denoted by @xmath13 , * @xmath14 : unranked unordered function symbols , denoted by @xmath15 , * @xmath16 : unranked ordered function symbols , denoted by @xmath17 , * @xmath18 : ranked predicate symbols , denoted by @xmath19 .",
    "the sets of variables are countable , while the sets of function and predicate symbols are finite .",
    "in addition , @xmath7 also contains    * the propositional constants @xmath20 and @xmath21 , the binary equality predicate @xmath22 , and the unranked membership predicate @xmath23 .",
    "* regular operators : @xmath24 . *",
    "logical connectives and quantifiers : @xmath25 , @xmath26 , @xmath27 , @xmath28 , @xmath29 , @xmath30 , @xmath31 . * auxiliary symbols : parentheses and the comma .",
    "_ function symbols , _ denoted by @xmath32 , are elements of the set @xmath33 a _ variable _ is an element of the set @xmath34 .",
    "a _ functor _ , denoted by @xmath35 , is a common name for a function symbol or a function variable .",
    "we define _ terms , hedges , _ and other syntactic categories over @xmath7 as follows : @xmath36 we denote the set of terms by @xmath37 and the set of ground ( i.e. , variable - free ) terms by @xmath38 . besides the letter @xmath39 , we use also @xmath40 and @xmath41 to denote terms .",
    "we make a couple of conventions to improve readability .",
    "the empty hedge is written as @xmath42 .",
    "the terms of the form @xmath43 and @xmath44 are abbreviated as @xmath45 and @xmath46 , respectively .",
    "we put parentheses around hedges , writing , e.g. , @xmath47 instead of @xmath48 . for hedges @xmath49 and @xmath50",
    ", the notation @xmath51 stands for the hedge @xmath52 .",
    "two hedges are _ disjoint _ if they do not share a common element . for instance ,",
    "@xmath53 and @xmath54 are disjoint , whereas @xmath53 and @xmath55 are not , because @xmath56 is their common element .",
    "an _ atom _ is a formula of the form @xmath57 , where @xmath58 is an @xmath59-ary predicate symbol .",
    "atoms are denoted by @xmath60 .",
    "_ regular hedge expressions _",
    "@xmath61 are defined inductively : @xmath62 where the dot @xmath63 stands for concatenation , @xmath64 for choice , and @xmath65 for repetition .",
    "_ primitive constraints _ are either term equalities @xmath66 or membership for hedges @xmath67 .",
    "they are written in infix notation , such as @xmath68 , and @xmath69 .    a _ literal _",
    "@xmath70 is an atom or a primitive constraint .",
    "_ formulas _ are defined as usual .",
    "constraint _ is an arbitrary first - order formula built over @xmath20 , @xmath21 , and primitive constraints .",
    "the set of free variables of a syntactic object @xmath71 is denoted by @xmath72 .",
    "we let @xmath73 denote the formula @xmath74 , where @xmath75 .",
    "@xmath76 denotes @xmath77 .",
    "we write @xmath78 ( resp .",
    "@xmath79 ) for the existential ( resp .",
    "universal ) closure of @xmath80 .",
    "we refer to a language over the alphabet @xmath7 as @xmath81 .",
    "a _ substitution _ is a mapping from term variables to terms , from hedge variables to hedges , and from function variables to functors , such that all but finitely many variables are mapped to themselves .",
    "we use lower case greek letter to denote them .    for an expression",
    "( i.e. , a term , hedge , functor , literal , or a formula ) @xmath82 and a substitution @xmath83 , we write @xmath84 for the _ instance _ of @xmath82 under @xmath83 .",
    "this is a standard operation that replaces in @xmath82 each free occurrence of a variable @xmath85 by its image under @xmath83 , i.e. , by @xmath86 .",
    "if needed , bound variables are renamed to avoid variable capture . for instance , for the constraint @xmath87 and the substitution @xmath88 , we have @xmath89 .",
    "a substitution @xmath83 is _ grounding _ for an expression @xmath82 if @xmath84 is a ground expression .",
    "a _ ( constraint logic ) program _ is a finite set of _ rules _ of the form @xmath90 , @xmath91 , usually written as @xmath92 , where @xmath60 is an atom and @xmath93 are literals other than @xmath20 and @xmath21 .",
    "a _ goal _ is a formula of the form @xmath94 , @xmath95 , usually written as @xmath96 where @xmath93 are literals other than @xmath20 and @xmath21 .",
    "we say a variable is _ solved _ in a conjunction of primitive constraints @xmath97 , if there is a @xmath98 @xmath99 , such that    * the variable is @xmath6 , @xmath100 , and @xmath101 occurs neither in @xmath39 nor elsewhere in @xmath102 , or * the variable is @xmath4 , @xmath103 , and @xmath4 occurs neither in @xmath104 nor elsewhere in @xmath105 , or * the variable is @xmath106 , @xmath107 and @xmath108 occurs neither in @xmath109 nor elsewhere in @xmath105 , or * the variable is @xmath101 , @xmath110 and @xmath111 does not occur in membership constraints elsewhere in @xmath102 , or * the variable is @xmath4 , @xmath112 , @xmath4 does not occur in membership constraints elsewhere in @xmath102 , and @xmath61 has the form @xmath113 or @xmath114 .    in this case",
    "we also say that @xmath115 is _ solved in _",
    "moreover , @xmath105 is called _ solved _ if for any @xmath116 , @xmath115 is solved in it .",
    "@xmath105 is _ partially solved _ , if for any @xmath116 , @xmath115 is solved in @xmath105 , or has one of the following forms :    * membership atom : * * @xmath117 .",
    "* * @xmath118 where @xmath119 and @xmath61 has the form @xmath120 or @xmath121 . *",
    "equation : * * @xmath122 where @xmath123 , @xmath124 and @xmath125 . * * @xmath126 , where @xmath127 , @xmath124 , and @xmath128 . the variables @xmath129 and @xmath130 are not necessarily distinct . *",
    "* @xmath131 where @xmath132 and @xmath133 are disjoint .",
    "a constraint is _ solved _ , if it is either @xmath20 or a non - empty quantifier - free disjunction of solved conjunctions .",
    "a constraint is _ partially solved _",
    ", if it is either @xmath20 or a non - empty quantifier - free disjunction of partially solved conjunctions .",
    "in this section we illustrate the expressive power of @xmath0 by two examples : the rewriting of terms from some regular hedge language and an implementation of the recursive path ordering with status .",
    "[ exmp : rewriting ] the general rewriting mechanism can be implemented with two @xmath0 clauses : the base case @xmath134 and the recursive case @xmath135 where @xmath136 are term variables , @xmath137 are hedge variables , and @xmath106 is a function variable .",
    "it is assumed that there are clauses which define the _ rule _ predicate .",
    "the base case says that a term @xmath6 can be rewritten to @xmath138 if there is a rule which does it .",
    "the recursive case rewrites a nondeterministically selected subterm @xmath6 of the input term to @xmath138 , leaving the context around it unchanged . applying the base case before the recursive case gives the outermost strategy of rewriting , while the other way around implements the innermost one .",
    "an example of the definition of the _ rule _ predicate is @xmath139 where the constraint .",
    "however , for brevity and clarity of the presentation we omit @xmath140 here . ]",
    "@xmath141 requires @xmath142 to be instantiated by hedges from the language generated by the regular hedge expression @xmath143 ( that is , from the language @xmath144 ) .    with this program , the goal @xmath145 has two answer substitutions : @xmath146 and @xmath147 . to obtain them ,",
    "the goal is first transformed by the recursive clause , leading to the new goal @xmath148 together with the constraint @xmath149 for @xmath6 .",
    "the next transformation is performed by the base case of the _ rewrite _ predicate , resulting into the goal @xmath150 .",
    "this goal is then transformed by the _ rule _",
    "clause , which gives the constraint @xmath151 .",
    "this constraint has two solutions , depending whether @xmath142 equals @xmath152 or to @xmath153 . from one",
    "we get @xmath154 , and from the other @xmath155 .",
    "these solutions give the above mentioned answers .",
    "[ exmp : rpo ] the recursive path ordering ( rpo ) @xmath156 is a well - known term ordering  @xcite used to prove termination of rewriting systems . its definition is based on a precedence order @xmath157 on function symbols , and on extensions of @xmath156 from terms to tuples of terms .",
    "there are two kinds of extensions : lexicographic @xmath158 , when terms in tuples are compared from left to right , and multiset @xmath159 , when terms in tuples are compared disregarding the order .",
    "the status function @xmath160 assigns to each function symbol either _ lex _ or _ mul _ status .",
    "then for all ( ranked ) terms @xmath161 , we define @xmath162 , if @xmath163 and    1 .",
    "either @xmath164 or @xmath165 for some @xmath166 , @xmath167 , or 2 .",
    "@xmath168 , @xmath169 for all @xmath170 , and either 1 .",
    "@xmath171 , or ( b ) @xmath172 and @xmath173 .    to implement this definition in @xmath0",
    ", we use the predicate _ rpo _ for @xmath156 between two terms , and four helper predicates : @xmath174 to implement the comparison @xmath169 for all @xmath175 ; @xmath176 to implement the comparison depending on the precedence ; @xmath177 to implement the comparison with respect to an extension of @xmath156 ; and _ status _ to give the status of a function symbol . the predicate _",
    "lex _ implements @xmath158 and _ mul _ implements @xmath159 .",
    "the symbol @xmath178 is an unranked function symbol , and @xmath179 is an unordered unranked function symbol .",
    "as one can see , the implementation is rather straightforward and closely follows the definition .",
    "@xmath156 requires four clauses , since there are four alternatives in the definition : @xmath180    @xmath174 is implemented with recursion : @xmath181 the definition of _ prec _ as an ordering on finitely many function symbols is straightforward .",
    "more interesting is the definition of _ ext _ : @xmath182 _ status _ can be given as a set of facts , _ lex _ needs one clause , and _ mul _ requires three : @xmath183    that s all .",
    "this example illustrates the benefits of all three kinds of variables we have and unordered function symbols .",
    "for a given set @xmath184 , we denote by @xmath185 the set of finite , possibly empty , sequences of elements of @xmath184 , and by @xmath186 the set of sequences of length @xmath59 of elements of @xmath184 .",
    "the empty sequence of symbols from any set @xmath184 is denoted by @xmath42 . given a sequence @xmath187 , we denote by @xmath188 the set of sequences @xmath189 is a permutation of @xmath190    a _ structure _",
    "@xmath191 for a language @xmath81 is a tuple @xmath192 made of a non - empty carrier set of _ individuals _ and an interpretation function @xmath193 that maps each function symbol @xmath194 to a function @xmath195 , and each @xmath59-ary predicate symbol @xmath196 to an @xmath59-ary relation @xmath197 .",
    "moreover , if @xmath198 then @xmath199 for all @xmath200 and @xmath201 a _ variable assignment _ for such a structure is a function with domain @xmath202 that maps term variables to elements of @xmath203 , hedge variable to elements of @xmath204 , and function variables to functions from @xmath204 to @xmath203 .    the interpretations of our syntactic categories w.r.t . a structure @xmath205 and variable assignment @xmath83 is shown below .",
    "the interpretations @xmath206\\!]}_{\\mstruct,\\sigma}$ ] of hedges ( including terms ) is defined as follows : @xmath207\\!]}_{\\mstruct,\\sigma }   : = \\sigma(v ) , \\text { where } v \\in \\cvi \\cup \\cvs.\\\\ & { [ \\![{f(\\hdg)}]\\!]}_{\\mstruct,\\sigma }    : = \\sint(f)({[\\![{\\hdg}]\\!]}_{\\mstruct,\\sigma}).\\\\ & { [ \\![{\\fv(\\hdg)}]\\!]}_{\\mstruct,\\sigma }     : = \\sigma(\\fv)({[\\![{\\hdg}]\\!]}_{\\mstruct,\\sigma}).\\\\ &   { [ \\![{(\\ts_1,\\ldots , \\ts_n)}]\\!]}_{\\mstruct,\\sigma } : = ( { [ \\![{\\ts_1}]\\!]}_{\\mstruct,\\sigma},\\ldots,{[\\![{\\ts_n}]\\!]}_{\\mstruct,\\sigma}).\\end{aligned}\\ ] ]    note that terms are interpreted as elements of @xmath203 and hedges as elements of @xmath204 .",
    "we may omit @xmath83 and write simply @xmath208\\!]}_\\mstruct$ ] for the interpretation of a ground expression  @xmath209 .",
    "the interpretation of regular expressions is defined as follows : @xmath210\\!]}_\\mstruct   : = \\{\\mathtt{\\epsilon}\\}.\\\\    & { [ \\![{f(\\rh)}]\\!]}_\\mstruct   : = \\{\\sint(f)(\\hdg ) \\mid \\hdg\\in { [ \\![{\\rh}]\\!]}_\\mstruct\\}. \\\\    & { [ \\![{\\rh_1 \\chs \\rh_2}]\\!]}_\\mstruct   : = { [ \\![{\\rh_1}]\\!]}_\\mstruct \\cup { [ \\![{\\rh_2}]\\!]}_\\mstruct .   \\\\    & { [ \\![{\\rh_1 \\concs \\rh_2}]\\!]}_\\mstruct   : = \\{(\\hdg_1,\\hdg_2 ) \\mid \\hdg_1\\in { [ \\![{\\rh_1}]\\!]}_\\mstruct , \\hdg_2\\in{[\\![{\\rh_2}]\\!]}_\\mstruct\\}.\\\\    & { [ \\![{\\rh^\\strs}]\\!]}_\\mstruct : = { [ \\![{\\rh}]\\!]}^*_\\mstruct.\\end{aligned}\\ ] ]    primitive constraints are interpreted with respect to a structure @xmath191 and variable assignment @xmath83 as follows : @xmath211\\!]}_{\\mstruct,\\sigma}={[\\![{t_2}]\\!]}_{\\mstruct,\\sigma}.\\\\   & \\mstruct \\models_\\sigma \\hdg\\inc \\rh \\text { iff } { [ \\![{\\hdg}]\\!]}_{\\mstruct,\\sigma}\\in{[\\![{\\rh}]\\!]}_\\mstruct.\\\\   &",
    "\\mstruct \\models_\\sigma p(t_1,\\ldots , t_n ) \\text { iff } \\sint(p)({[\\![{t_1}]\\!]}_{\\mstruct,\\sigma},\\ldots,{[\\![{t_n}]\\!]}_{\\mstruct,\\sigma}).\\end{aligned}\\ ] ]    the notions @xmath212 for validity of an arbitrary formula @xmath80 in @xmath191 , and @xmath213 for validity of @xmath80 in any structure are defined in the standard way .",
    "an _ intended structure _ is a structure @xmath214 with the carrier set @xmath38 and interpretations @xmath193 defined for every @xmath194 by @xmath215 .",
    "thus , intended structures identify terms and hedges by themselves .",
    "also , if @xmath61 is any regular hedge expression then @xmath216\\!]}_{\\istruct}$ ] is the same in all intended structures , and will be denoted by @xmath216\\!]}$ ] .",
    "other remarkable properties of intended structures @xmath214 are : variable assignments are substitutions , @xmath217 iff @xmath218 , and @xmath219 iff @xmath220\\!]}$ ] .    given a program @xmath221 , its herbrand",
    "base @xmath222 is , naturally , the set of all atoms @xmath57 , where @xmath223 is an @xmath59-ary user - defined predicate in @xmath221 and @xmath224 .",
    "then an intended interpretation of @xmath221 corresponds uniquely to a subset of @xmath222 .",
    "intended model _ of @xmath221 is an intended interpretation of @xmath221 that is its model .    as usual",
    ", we will write @xmath225 if @xmath226 is a goal which holds in every model of @xmath221 .",
    "since our programs consist of positive clauses , the following facts hold :    1 .",
    "every program @xmath221 has a least intended model , which we denote by @xmath227 .",
    "if @xmath226 is a goal then @xmath225 iff @xmath227 is a model of @xmath226 .",
    "a ground substitution @xmath228 is an _ intended solution _",
    "( or simply _ solution _ ) of a constraint @xmath229 if @xmath230 for all intended structures @xmath214 .",
    "theoremonethmsatisfiable [ thm : sat ] if the constraint @xmath231 is solved , then @xmath232 holds for all intended structures @xmath214 .",
    "in this section we present a constraint solver for quantifier - free constraints in dnf .",
    "it is based on rules , transforming a constraint in _ disjunctive normal form _ ( dnf ) into a constraint in dnf .",
    "we say a constraint is in dnf , if it has a form @xmath233 , where @xmath105 s are conjunctions of @xmath20 , @xmath21 , and primitive constraints .",
    "the number of rules is not small ( as it is usual for such kind of solvers , cf .",
    ", e.g. , @xcite ) . to make their comprehension easier , we group them so that similar ones are collected together in subsections . within each subsection , for better readability",
    ", the rule groups are put between horizontal lines .    before going into the details ,",
    "we introduce a more conventional way of writing expressions , some kind of syntactic sugar , that should make reading easier . instead of @xmath234 and @xmath235 we write @xmath236 and @xmath237 respectively . the symmetric closure of the relation @xmath22 is denoted by @xmath238 .",
    "the rules are applied in any context , i.e. , they behave as rewrite rules . moreover ,",
    "when a rule applies to a conjunction of the form @xmath239 , it is intended to act on an entire conjunct of the dnf , modulo associativity and commutativity of @xmath27 .",
    "these assumptions guarantee that the constraint obtained after each rule application is again in dnf .",
    "there are eight logical rules which are applied at any depth in constraints , modulo associativity and commutativity of disjunction and conjunction .",
    "@xmath80 stands for any formula .",
    "we denote the whole set of rules by log .",
    "width 0.4pt width 0.1 @xmath240\\ ! ] } \\vspace{-0.5cm}\\end{aligned}\\ ] ]    ' '' ''    ' '' ''      the first two rules perform occurrence check , rules ( f3 ) and ( f5 ) detect function symbol clash , and rules ( f4 ) , ( f6 ) , ( f7 ) detect inconsistent primitive constraints .",
    "we denote the set of rules ( f1)(f7 ) by fail .",
    "width 0.4pt width 0.1 @xmath241\\!]}$}.\\\\ { \\sf ( f7 ) } & \\quad & & ( \\hdg_1,t , \\hdg_2 ) \\inc \\eps   \\leadsto   \\false .",
    "\\vspace{-0.5cm}\\end{aligned}\\ ] ]    ' '' ''    ' '' ''      the set of these rules is denoted by dec .",
    "they operate on a conjunction of literals and give back either a conjunction of literals again , or a constraint in dnf",
    ".    width 0.4pt width 0.1 @xmath242    ' '' ''    ' '' ''      these rules delete identical terms or hedge variables from both sides of an equation .",
    "we denote this set of rules by del .",
    "width 0.4pt width 0.1 @xmath243    ' '' ''    ' '' ''      these rules eliminate variables from the given constraint keeping only a solved equation for them .",
    "they apply to disjuncts .",
    "the first two rules replace a variable with the corresponding expression , provided that the occurrence check fails : width 0.4pt width 0.1 @xmath244    ' '' ''    ' '' ''    the next two rules ( e3 ) and ( e4 ) assign to a variable an initial part of the hedge in the other side of the selected equation .",
    "the hedge has to be a sequence of terms @xmath245 in the first rule .",
    "the disjunction in the rule is over all possible splits of @xmath245 . in the second rule ,",
    "only a split of the prefix @xmath245 of the hedge is relevant and the disjunction is over all such possible splits of @xmath245 .",
    "the rest is blocked by the term @xmath39 due to occurrence check : no instantiation of @xmath4 can contain it .",
    "width 0.4pt width 0.1 @xmath246    ' '' ''    ' '' ''    finally , there are three rules for function variable elimination .",
    "their behavior is standard :    width 0.4pt width 0.1 @xmath247    ' '' ''    ' '' ''",
    "we denote the set of rules ( e1)(e7 ) by elim .",
    "note that the assumption of finiteness of @xmath248 guarantees that the disjunction in ( e7 ) is finite .",
    "the membership rules apply to disjuncts of constraints in dnf , to preserve the dnf structure .",
    "they provide the membership check , if the hedge @xmath104 in the membership atom @xmath69 is ground .",
    "nonground hedges require more special treatment as one can see .",
    "to solve membership constraints for hedges of the form @xmath249 with @xmath39 a term , we rely on the possibility to compute the linear form of a regular expression , that is , to express it as a finite sum of concatenations of regular hedge expressions that identify all plausible membership constraints for @xmath39 and @xmath250 . formally , the _ linear form _ of a regular expression @xmath61 , denoted @xmath251 , is a finite set of pairs @xmath252 , which is defined recursively as follows : @xmath253\\!]}.\\\\   &     \\lf(\\rh_1\\concs\\rh_2 ) = { }   \\lf(\\rh_1 ) \\odot \\rh_2 \\cup\\lf(\\rh_2 ) ,   \\text { if } \\epsilon\\in{[\\![{\\rh_1}]\\!]}.\\\\   &     \\lf(\\rh^\\strs ) =    \\lf(\\rh ) \\odot \\rh^\\strs .",
    "\\end{aligned}\\ ] ] these equations involve an extension of concatenation @xmath254 that acts on a linear form and a regular expression and returns a linear form .",
    "it is defined as @xmath255 and @xmath256 , if @xmath257    the linear form @xmath251 of a regular expression @xmath61 has the property  @xcite : @xmath258\\!]}\\setminus \\{\\epsilon\\}= \\bigcup_{(f(\\rh_1),\\rh_2)\\in \\lf(\\rh)}{[\\![{f(\\rh_1)\\concs \\rh_2}]\\ ! ] } , \\tag{\\sc{lf}}\\ ] ] which justifies its use in the rule m2 below .",
    "the first group of membership rules looks as follows :    width 0.4pt width 0.1 @xmath259\\ ! ] } =   { [ \\![{\\rh_1}]\\!]}\\cap { [ \\![{\\rh_2}]\\ ! ] } , \\text { and neither } v \\inc \\rh_1 \\text { nor }   v \\inc \\rh_2 \\\\   & & &   \\text{can be transformed by the other rules}. \\vspace{-0.5cm}\\end{aligned}\\ ] ]    ' '' ''    ' '' ''",
    "next , we have rules which constrain singleton hedges to be in a term language .",
    "they proceed by the straightforward matching or decomposition of the structure .",
    "note that in ( m12 ) , we require the arguments of the unordered function symbol to be terms .",
    "( m10 ) and ( m9 ) do not distinguish whether @xmath260 is ordered or unordered : width 0.4pt width 0.1 @xmath261    ' '' ''    ' '' ''    we denote the set of rules ( m1)(m12 ) by memb .",
    "in this section we present an algorithm that converts a constraint with respect to the rules specified in section  [ subsect : rules ] into a partially solved one .",
    "first , we define the rewrite step @xmath262    when applied to a constraint , @xmath263 transforms it by the _ first _",
    "applicable rule of the solver , looking successively into the sets log , fail , del , dec , elim , and memb .",
    "if none of them apply , then the constraint is said to be in a _ normal form _ with respect to @xmath263 .",
    "the constraint solving algorithm implements the strategy @xmath264 defined as a repeated application of the rewrite step , aiming at the computation of a normal form with respect to @xmath263 .",
    "but it also makes sure that the constraint , passed to step , is in dnf : @xmath265    hence , @xmath264 takes a quantifier - free constraint , transforms it into its equivalent constraint in dnf ( the strategy dnf in the definition stands for the algorithm that does it ) , and then repeatedly applies @xmath263 to the obtained constraint in dnf as long as possible .",
    "it remains to show that this definition yields an algorithm , which amounts to proving that the strategy nf(step ) indeed produces a constraint to which none of the rules from log , fail , del , dec , elim , and memb apply .",
    "the termination theorem states exactly this :    theoremtwothmtermination [ thm : termination ] @xmath264 terminates on any quantifier - free constraint .    with the next two statements we show that the solver reduces a constraint to its equivalent constraint :    lemmathreelemequiv [ lem : equivalence ] if @xmath266 , then @xmath267 for all intended structures @xmath214 .",
    "theoremfourthmequiv [ thm : equivalence ] if @xmath268 , then @xmath269 for all intended structures @xmath214 , and @xmath270 is either partially solved or the @xmath21 constraint .",
    "in this section we describe the operational semantics of @xmath0 , following the approach for the clp schema given in @xcite .",
    "a _ state _ is a pair @xmath271 , where @xmath226 is the sequence of literals and @xmath272 , where @xmath105 s are conjunctions of @xmath20 , @xmath21 , and primitive constraints .",
    "the _ definition of an atom @xmath273 in program _",
    "@xmath221 , @xmath274 , is the set of rules in @xmath275 such that the head of each rule has a form @xmath276 .",
    "we assume that @xmath277 each time returns fresh variants .",
    "a state @xmath278 can be _ reduced with respect to @xmath221 _ as follows : select a literal @xmath279 . then",
    ":    * if @xmath279 is a primitive constraint and @xmath280 , then it is reduced to @xmath281 . *",
    "if @xmath279 is a primitive constraint and @xmath282 , then it is reduced to @xmath283 . *",
    "if @xmath279 is an atom @xmath273 , then it is reduced to @xmath284 for some @xmath285 . *",
    "if @xmath279 is a atom and @xmath286 , then it is reduced to @xmath283 .",
    "a _ derivation from a state _ @xmath184 in a program @xmath275 is a finite or infinite sequence of states @xmath287 where @xmath288 is @xmath184 and there is a reduction from each @xmath289 to @xmath290 , using rules in @xmath275 .",
    "derivation from a goal _ @xmath226 in a program @xmath275 is a derivation from @xmath291 .",
    "the _ length _ of a ( finite ) derivation of the form @xmath292 is @xmath59 .",
    "a derivation is _ finished _ if the last goal can not be reduced , that is , if its last state is of the form @xmath293 where @xmath231 is partially solved or @xmath21 .",
    "if @xmath294 is @xmath21 , the derivation is said to be _",
    "failed_.    naturally , it is interesting to find syntactic restrictions for programs guaranteeing that non - failed finished derivations produce a solved constraint instead of a partially solved one . in the next two sections we consider such restrictions , leading to well - moded and kif style @xmath0 programs that have the desired property",
    "the concept of well - modedness is due to  @xcite .",
    "a _ mode _ for an @xmath59-ary predicate symbol @xmath223 is a function @xmath295 . if @xmath296 ( resp .",
    "@xmath297 then the position @xmath175 is called an _ input _ ( resp . _ output",
    "_ ) _ position _ of @xmath223 .",
    "the predicates @xmath23 and @xmath22 have only output positions . for a literal @xmath298 ( where @xmath223 can be also @xmath23 or @xmath22 ) , we denote by @xmath299 and @xmath300 the sets of variables occurring in terms in the input and output positions of @xmath223 .",
    "if a predicate is used with different modes @xmath301 in the program , we may consider each @xmath302 as a separate predicate .",
    "therefore , we can assume without loss of generality that every predicate has exactly one mode ( cf .",
    ", e.g. , @xcite ) .",
    "an _ extended literal _",
    "@xmath209 is either a literal , @xmath20 , or @xmath21 .",
    "we define @xmath303 , @xmath304 , @xmath305 , and @xmath306 .",
    "a _ sequence of extended literals @xmath307 is well - moded _ if the following hold :    1 .   for all @xmath116 , @xmath308 .",
    "2 .   if for some @xmath116 , @xmath309 is @xmath310 , then @xmath311 or @xmath312 .",
    "3 .   if for some @xmath116 , @xmath309 is a membership atom , then the inclusion @xmath313 holds .    a _ conjunction of extended literals @xmath226 is well - moded _",
    "if there exists a well - moded sequence of extended literals @xmath314 such that @xmath315 modulo associativity and commutativity of conjunction .",
    "formula in dnf is well - moded _ if each of its disjuncts is .",
    "state @xmath316 is well - moded _",
    ", where @xmath105 s are conjunctions of @xmath20 , @xmath21 , and primitive constraints , if the formula @xmath317 is well - moded .",
    "a _ clause @xmath318 is well - moded _ if the following hold :    1 .",
    "[ wel ] for all @xmath116 , @xmath319 .",
    "2 .   @xmath320 .",
    "3 .   if for some @xmath116 , @xmath279 is @xmath310 , then @xmath321 or @xmath322 .",
    "4 .   if for some @xmath116 , @xmath279 is a membership atom , then @xmath323 @xmath324 @xmath325 .",
    "a _ program is well - moded _ if all its clauses are well - moded .    in example",
    "[ exmp : rewriting ] , if in the user - defined binary predicates @xmath326 and @xmath327 the first argument is the input position and the second argument is the output position , then it is easy to see that the program is well - moded . in example",
    "[ exmp : rpo ] , for well - modedness we need to define both positions in the user - defined predicates to be the input ones .    in the rest of this section",
    "we investigate the behavior of well - moded programs . before going into the details ,",
    "we briefly summarize two main results :    * the solver can completely solve satisfiable well - moded constraints ( instead of partial solutions computed in the general case ) .",
    "see theorem  [ lem : solvedform ] . * any finished derivation from a well - moded goal with respect to a well - moded program either ends with a completely solved constraint , or fails .",
    "see theorem  [ thm : finalstate ] .    to prove these statements ,",
    "some technical lemmas are needed .",
    "lemmafivelemwellmodedness [ lem : well : modedness:1 ] let @xmath328 be an equation , where @xmath85 is a variable and @xmath82 is the corresponding expression such that @xmath85 does not occur in @xmath82 .",
    "let @xmath329 and @xmath330 be two arbitrary ( possibly empty ) conjunctions of extended literals such that the conjunction @xmath331 is well - moded .",
    "let @xmath332 be a substitution .",
    "then @xmath333 is also well - moded .",
    "the next lemma states that reduction with respect to a well - moded program preserves well - modedness of states :    lemmasixlemwellmodednessreduction [ lem : well : modedness:2 ] let @xmath275 be a well - moded @xmath0 program and @xmath334 be a well - moded state . if @xmath335 is a reduction using clauses in @xmath275 , then @xmath336 is also a well - moded state .",
    "corollarysevencorwellmodedness [ cor : wellmoded ] if @xmath294 is a well - moded constraint , then @xmath337 is also well - moded .",
    "the following theorem shows that satisfiable well - moded constraints can be completely solved :    theoremeightthmsolvedform [ lem : solvedform ] let @xmath294 be a well - moded constraint and @xmath338 , where @xmath339 .",
    "then @xmath340 is solved .",
    "we illustrate how to solve a simple well - moded constraint :    let @xmath341 .",
    "then @xmath264 performs the following derivation ( some steps are contracted ) : @xmath342 the obtained constraint is solved .",
    "the next theorem is the main result for well - moded @xmath0 programs .",
    "it states that any finished derivation from a well - moded goal leads to a solved constraint or to a failure :    theoremninethmmainwellmoded [ thm : finalstate ] let @xmath343 be a finished derivation with respect to a well - moded @xmath0 program , starting from a well - moded goal @xmath344 .",
    "if @xmath345 , then @xmath231 is solved .",
    "knowledge interchange format , shortly kif  @xcite , is a computer - oriented language for the interchange of knowledge among disparate programs .",
    "it permits variadic syntax and hedge variables , under the restriction that such variables are only the last arguments of subterms they appear in .",
    "such a fragment has some good computation properties , e.g. , unification is unitary  @xcite .",
    "the special form of programs and constraints considered in this section originates from this restriction .",
    "_ terms and hedges in the kif form _ or , shortly , _ kif terms _ and _ kif hedges _ , are defined by the following grammar : @xmath346    that means that a term is in the kif form if hedge variables occur only below ordered function symbols as the last arguments .",
    "for example , the terms @xmath347 and @xmath348 are in the kif form , while @xmath349 and @xmath350 are not .",
    "if the language does not contain unordered function symbols , then we permit hedge variables under function variables , again in the last position , i.e. , of the form @xmath351 .",
    "in this section we consider only kif terms .",
    "therefore , the subscript @xmath352 will be omitted .",
    "_ kif equations _ and _ kif atoms _ are constructed from kif terms . in a _",
    "kif membership atom _ @xmath353 , the hedge @xmath104 is a kif hedge .",
    "_ kif formulas _ are constructed from kif primitive constraints and kif atoms .",
    "this special form guarantees that the solver does not need to use all the rules . simply inspecting them",
    ", we can see that del1 , e3 , e4 , and m3 are not used . in del3 , it is guaranteed that @xmath354 will be always empty , and in m1 the @xmath59 will be equal to 1 .    similarly to the well - moded restriction above , our interest to the kif fragment is justified by its two important properties that characterize the kif constraint solving and derivation of kif goals :    * the solver can completely solve satisfiable kif constraints ( instead of partial solutions computed in the general case ) .",
    "see theorem  [ thm : kif : solved ] . * any finished derivation from a kif goal with respect to a kif program either ends with a completely solved constraint , or fails .",
    "see theorem  [ thm : kif : derivation ] .",
    "their proofs are easier than the ones of the corresponding statements for well - moded programs .",
    "this is largely due to the following lemma :    lemmatenlemkifpartiallysolved [ lem : kif : partially : solved ] any partially solved kif constraint is solved .",
    "one can see that no solving rule inserts a term or a hedge variable after the last argument of subterms in constraints .",
    "that means , kif constraints are again transformed into kif constraints .",
    "hence , the constraint computed by @xmath264 will be a kif constraint .",
    "it leads us to the following result :    theoremeleventhmkifsolved [ thm : kif : solved ] let @xmath294 be a kif constraint and @xmath338 , where @xmath339 .",
    "then @xmath340 is solved .",
    "we illustrate now how to solve a simple kif constraint :    let @xmath355 .",
    "then @xmath264 performs the following derivation : @xmath356 the obtained constraint is solved .",
    "state @xmath316 is in the kif form _",
    "( _ kif state _ ) , if the formula @xmath317 is a kif formula .    _",
    "kif clauses _ are constructed from kif atoms and literals .",
    "_ kif programs _ are sets of kif clauses .",
    "it is not hard to check that each reduction step ( with respect to a kif program ) in the operational semantics preserves kif states : it follows from the definition of the operational semantics and the fact that @xmath264 computes kif constraints .",
    "therefore , we can establish the following theorem :    theoremtwelvethmkifderivation [ thm : kif : derivation ] let @xmath357 be a finished derivation with respect to a kif program , starting from a kif goal @xmath344 . if @xmath339 , then @xmath340 is solved .",
    "[ exmp : dl ] the well - known technique of appending two difference lists can be used in @xmath0 for a more general task : to combine arguments of arbitrary two terms .",
    "the program remains the same as in the standard logic programming : @xmath358 where the hyphen is a function symbol and @xmath359 are term variables .",
    "the kif goal @xmath360 can be used to append to the arguments of @xmath361 the arguments of @xmath362 , obtaining @xmath363 . note that the terms may have different heads .",
    "the derivation proceeds as follows : @xmath364 the constraint in the final state is solved .",
    "solving equational and membership constraints over hedges is not an easy task : the problem is infinitary and any procedure that explicitly computes all solutions is non - terminating .",
    "the solver that we presented in this paper is not complete , but it is terminating .",
    "it solves constraints partially and tries to detect failure as early as it can .",
    "incorporating the solver into the clp schema gives @xmath0 : constraint logic programming for hedges .",
    "we defined algebraic semantics for it and used it to characterized the constraint solver : the output of the solver ( which is either partially solved of @xmath21 ) is equivalent to the input constraint in all intended structures .",
    "the fact that the solver , in general , returns a partially solved result ( when it does not fail ) , naturally raises the question : are there some interesting fragments of constraints that the solver can completely solve ? we give a positive answer to this question , defining well - moded and kif constraints and showing their complete solvability .",
    "it immediately poses the next question : can one characterize @xmath0 programs that generate only well - moded or kif constraints only ?",
    "we show that by extending the notions of well - modedness and kif form to programs , we get the desired fragments . any finished derivation of a goal for such fragments gives a definite answer : either the goal fails , or a solved constraint is returned .",
    "the constraints we consider in this paper are positive , but at least the well - moded programs can be easily enriched with the negation .",
    "well - modedness guarantees that the eventual test for disequality or non - membership in constraints will be performed on ground hedges , which can be effectively decided .",
    "this research has been partially supported by liacc through programa de financiamento plurianual of the fundao para a cincia e tecnologia ( fct ) , by the fct fellowship ( ref .",
    "sfrh / bd/62058/2009 ) , by the austrian science fund ( fwf ) under the project stout ( p 24087-n18 ) , and the by rustaveli science foundation under the grants di/16/4 - 120/11 and fr/611/4 - 102/12 .",
    "partial derivatives of regular expressions and finite automaton constructions .",
    "_ 155 , _  2 , 291319 .    ,",
    "brauner , p. , kopetz , r. , moreau , p. , and reilles , a. 2007 .",
    "tom : piggybacking rewriting on java . in _",
    "term rewriting and applications , 18th international conference , rta 2007 , paris , france , june 26 - 28 , 2007 , proceedings _",
    ", f.  baader , ed .",
    "lecture notes in computer science , vol . 4533 .",
    "springer , 3647 .",
    ", durn , f. , eker , s. , lincoln , p. , mart - oliet , n. , meseguer , j. , and talcott , c.  l. , eds . 2007 . .",
    "lecture notes in computer science , vol .",
    "springer .",
    "\\2004 . constraint logic programming applied to xml processing . in _ on the move to meaningful internet systems 2004 : coopis , doa , and odbase , otm confederated international conferences , agia napa , cyprus , october 25 - 29 , 2004 , proceedings , part ii _",
    ", r.  meersman and z.  tari , eds .",
    "lecture notes in computer science , vol .",
    "springer , 10981112 .",
    "constraint logic programming approach to verification of website content . in _ advanced web and network technologies , and applications , apweb 2006 international workshops : xra , iwsn , mega , and icse , harbin , china , january 16 - 18 , 2006 , proceedings _ , h.  t. shen , j.  li , m.  li , j.  ni , and w.  wang , eds .",
    "lecture notes in computer science , vol . 3842 .",
    "springer , 148156 .",
    "logic programming for xml processing . in _ 9th acm international workshop on web information and data management ( widm 2007 ) , lisbon , portugal , november 9 , 2007 _ ,",
    "i.  fundulaki and n.  polyzotis , eds .",
    "acm , 18 .",
    "an introduction to prolog iii .",
    "_ 33 , _  7 , 6990 .",
    "completion of rewrite systems with membership constraints .",
    "part ii : constraint solving .",
    "_ 25 , _  4 , 421453 .",
    "\\1985 . and - parallelism with intelligent backtracking for annotated logic programs .",
    "in _ proceedings of the 1985 symposium on logic programming , boston , massachusetts , usa , july 15 - 18 , 1985_. ieee - cs , 2938 .",
    "orderings for term - rewriting systems .",
    "_ 17 _ , 279301 .    , piazza , c. , pontelli , e. , and rossi , g. 2000 . sets and constraint logic programming .",
    "_ 22 , _  5 , 861931 .    ,",
    "piazza , c. , and rossi , g. 2008 . a uniform approach to constraint - solving for lists , multisets , compact lists , and sets .",
    "_ 9 , _  3 , 130 .    ,",
    "florido , m. , kutsia , t. , and marin , m. 2014 . constraint logic programming for hedges : a semantic reconstruction . in _ functional and logic programming - 12th international symposium , flops 2014 , kanazawa , japan , june 4 - 6 , 2014 .",
    "proceedings _ , m.  codish and e.  sumii , eds .",
    "lecture notes in computer science , vol . 8475 .",
    "springer , 285301 .",
    "\\1992 . termination proofs of well - moded logic programs via conditional rewrite systems . in _",
    "conditional term rewriting systems , third international workshop , ctrs-92 , pont -  - mousson , france , july 8 - 10 , 1992 , proceedings _ ,",
    "m.  rusinowitch and j.  remy , eds .",
    "lecture notes in computer science , vol .",
    "springer , 430437 .",
    "logic-92 - 1 , stanford university , stanford , ca , usa .",
    "\\2003 . regular expression pattern matching for xml .",
    "_ 13 , _  6 , 9611004 .    , maher , m.  j. , marriott , k. , and stuckey , p.  j. 1998 .",
    "the semantics of constraint logic programs .",
    "_ 37 , _  1 - 3 , 146 .",
    "equational prover of theorema . in _ rewriting techniques and applications , 14th international conference , rta 2003 , valencia , spain , june 9 - 11 , 2003 , proceedings _ , r.  nieuwenhuis , ed .",
    "lecture notes in computer science , vol . 2706 .",
    "springer , 367379 .    \\2004 . solving equations involving sequence variables and sequence functions . in _ artificial intelligence and symbolic computation ,",
    "7th international conference , aisc 2004 , linz , austria , september 22 - 24 , 2004 , proceedings _ , b.  buchberger and j.  a. campbell , eds .",
    "lecture notes in computer science , vol . 3249 .",
    "springer , 157170 .",
    "\\2007 . solving equations with sequence variables and sequence functions .",
    "_ 42 , _  3 , 352388 .",
    "can context sequence matching be used for querying xml ? in _ proceedings of the 19th international workshop on unification unif05 _ , l.  vigneron , ed .",
    "nara , japan , 7792 .",
    "2005b . matching with regular constraints . in _",
    "logic for programming , artificial intelligence , and reasoning , 12th international conference , lpar 2005 , montego bay , jamaica , december 2 - 6 , 2005 , proceedings _ , g.  sutcliffe and a.  voronkov , eds .",
    "lecture notes in computer science , vol . 3835 .",
    "springer , 215229 .    \\2003 . on the implementation of a rule - based programming system and some of its applications . in _ proceedings of the 4th international workshop on the implementation of logics ( wil03 ) _ , b.  konev and r.  schmidt , eds .",
    "almaty , kazakhstan , 5568 .",
    "foundations of the rule - based system @xmath1log .  _",
    "16 , _  1 - 2 , 151168 .",
    "\\1991 . a logic programming language with lambda - abstraction , function variables , and simple unification .",
    "_ 1 , _  4 , 497536 .",
    "constraint logic programming on strings : theory and applications .",
    "in _ logic programming , proceedings of the 1994 international symposium , ithaca , new york , usa , november 13 - 17 , 1994 _ , m.  bruynooghe , ed . mit press , 681 .    , van deursen , a. , heering , j. , de  jong , h. , de  jonge , m. , kuipers , t. , klint , p. , moonen , l. , olivier , p.  a. , scheerder , j. , vinju , j.  j. , visser , e. , and visser , j. 2001 .",
    "the asf+sdf meta - environment : a component - based language development environment .",
    "_ 44 , _  2 , 38 .",
    "constraint logic programming with regular sets .",
    "in _ logic programming , proceedings of the sixth international conference , lisbon , portugal , june 19 - 23 , 1989 _ , g.  levi and m.  martelli , eds . mit press , 181196 .",
    "\\2003 . , fifth ed .",
    "wolfram - media .",
    "since @xmath231 is solved , each disjunct @xmath105 in it has a form @xmath365 where @xmath366 , @xmath367 and @xmath368 is an expression corresponding to @xmath369 .",
    "moreover , @xmath370 are distinct and @xmath371\\!]}\\neq \\emptyset $ ] for all @xmath372 .",
    "note that while @xmath369 s do not occur anywhere else in @xmath105 , it still might be the case that some @xmath373 , @xmath374 , occurs in some @xmath375 , @xmath376 .",
    "let @xmath377 be an element of @xmath378\\!]}$ ] for all @xmath372 .",
    "assume that for each @xmath379 , the substitution @xmath380 is a grounding substitution for @xmath368 with the property that @xmath381 for all @xmath382 .",
    "then @xmath383 solves @xmath105 .",
    "therefore , @xmath384 holds .",
    "measures are compared by the multiset extension of the lexicographic ordering on tuples .",
    "the components that are natural numbers ( @xmath397 and @xmath399 ) are , of course , compared by the standard ordering on naturals . the multiset components @xmath404 , @xmath405 , and @xmath406 are compared by the multiset extension of the standard ordering on the naturals .",
    "the strict part of the ordering on measures is obviously well - founded .",
    "the log rules strictly reduces it . for the other rules , the table below shows which rule reduces which component of the measure .",
    "the symbols @xmath407 and @xmath408 indicate the strict and non - strict decrease , respectively .",
    "it implies the termination of the algorithm @xmath264 .       by case distinction on the inference rules of the solver , selected by the strategy first in the application of step .",
    "we illustrate here two cases , when the selected rules are ( e3 ) and ( m2 ) . for the other rules the lemma can be shown similarly .    in ( e3 )",
    ", @xmath231 has a disjunct @xmath409 with @xmath410 , and @xmath270 is the result of replacing @xmath105 in @xmath231 with the disjunction @xmath411 where @xmath412 .",
    "therefore , it is sufficient to show that @xmath413 . since @xmath414 ,",
    "this amounts to showing that for all ground substitutions @xmath83 of @xmath415 we have @xmath416 iff @xmath417    * assume @xmath416 .",
    "we can split @xmath418 into @xmath419 and @xmath420 such that @xmath421 and @xmath422 .",
    "now , we show @xmath423 for all @xmath424 . indeed , if @xmath425 , the equality trivially holds .",
    "if @xmath426 , we have @xmath427 .",
    "hence , @xmath417 * assume @xmath428 .",
    "then there exists the split @xmath429 such that @xmath430 .",
    "again , we can show @xmath423 for all @xmath424 .",
    "hence , @xmath431 .",
    "it finishes the proof for ( e3 ) .",
    "now , let the selected rule be ( m2 ) . in this case",
    "@xmath231 has a disjunct @xmath432 with @xmath433 and @xmath434 .",
    "then @xmath270 is the result of replacing @xmath105 in @xmath231 with @xmath435 .",
    "therefore , to show @xmath436 , it is enough to show that @xmath413 .",
    "since @xmath414 , this amounts to showing that for all ground substitutions @xmath83 of @xmath415 we have @xmath437 iff @xmath438 .    * assume @xmath437 . by the property ( [ eq : lf ] ) above and by the definitions of intended structure and entailment",
    ", we get that @xmath439 implies @xmath440 .",
    "hence , we can conclude @xmath441 . *",
    "assume @xmath441 .",
    "then we have @xmath442 which , by ( [ eq : lf ] ) , implies @xmath443 .",
    "we assume without loss of generality that @xmath231 is in dnf .",
    "@xmath444 follows from lemma  [ lem : equivalence ] and the following property : if @xmath445 and @xmath446 , then @xmath447 .",
    "the property itself relies on the fact that @xmath448 , which holds because all variables introduced by the rules of the solver in @xmath449 are fresh not only for @xmath450 , but also for @xmath451 .",
    "as for the partially solved constraint , by the definition of @xmath264 and theorem  [ thm : termination ] , @xmath270 is in a normal form .",
    "assume by contradiction that it is not partially solved .",
    "by inspection of the solver rules , based on the definition of partially solved constraints , we can see that there is a rule that applies to @xmath270 .",
    "but this contradicts the fact that @xmath270 is in a normal form .",
    "hence , @xmath270 is partially solved .",
    "the point in this lemma is that it does not matter how @xmath329 and @xmath330 are chosen .",
    "we consider two cases .",
    "first , when @xmath328 is the leftmost literal containing @xmath85 in a well - moded sequence corresponding to @xmath331 and , second , when this is not the case",
    ".    _ case 1 .",
    "_ let @xmath452 be a well - moded sequence corresponding to @xmath331 , such that @xmath453 does not contain @xmath85 .",
    "note that there is no assumption ( apart from what guarantees well - modedness of @xmath331 ) on the appearance of literals in @xmath453 and @xmath454 : they may contain literals from @xmath329 only , from @xmath330 only , or from both @xmath329 and @xmath330 .",
    "well - modedness of @xmath452 requires the variables of @xmath82 to appear in @xmath453 .",
    "consider the sequence @xmath455 $ ] , where the notation @xmath456 $ ] stands for such an instance of @xmath457 in which @xmath458 affects only literals from @xmath330 .",
    "then @xmath459 is well - moded and it can be safely extended by @xmath460 $ ] without violating well - modedness , because the variables in @xmath461 still precede ( in the well - moded sequence ) the literals from @xmath460 $ ] , and the relative order of the other variables ( in the well - moded sequence ) does not change .",
    "hence , @xmath455 $ ] is a well - moded sequence that corresponds to @xmath462 .    _",
    "_ let @xmath463 be a well - moded sequence corresponding to @xmath464 , where @xmath465 is the leftmost literal that contains @xmath85 in an output position .",
    "again , we make no assumption on literal appearances in the subsequences of the sequence .",
    "then @xmath466 is also a well - moded sequence ( corresponding to @xmath464 ) , because @xmath85 still appears in an output position in @xmath465 left to @xmath328 , the variables in @xmath82 still precede literals from @xmath467 , and the relative order of the other variables does not change . for literals in @xmath454 that contain variables from @xmath82 such",
    "a reordering does not matter .",
    "note that @xmath85 does not appear in @xmath453 : if it were there in some literal in an output position , then @xmath465 would not be the leftmost such literal .",
    "if it were there in some literal @xmath468 in an input position , then well - modedness of the sequence would require @xmath85 to appear in an output position in another literal @xmath469 that is even before @xmath468 , i.e. , to the left of @xmath465 and it would again contradict the assumption that @xmath465 is the leftmost literal containing @xmath85 in an output position .",
    "then it replaces @xmath85 in @xmath465 with @xmath82 , i.e. , @xmath471=\\lit\\substb$ ] .",
    "then the variables of @xmath82 appear in output positions in @xmath472 and , hence , placing @xmath461 after @xmath472 in the sequence would not destroy well - modedness .",
    "as for the @xmath472 itself , we have two alternatives :    1 .   @xmath472 is an equation , say @xmath473 , obtained from @xmath474 by replacing occurrences of @xmath85 in @xmath39 by @xmath82 . in this case , by well - modedness of @xmath466 , variables of @xmath41 appear in @xmath453 and @xmath41 does not contain @xmath85 . then the same property is maintained in @xmath475,\\se_3[\\substb]$ ] , since @xmath41 remains in @xmath472 and @xmath453 does not change .",
    "@xmath472 is an atom .",
    "then replacing @xmath85 by @xmath82 in an output position of @xmath465 , which gives @xmath472 , does not affect well - modedness .",
    "hence , we got that @xmath476 is well - moded .",
    "now we can safely extend this sequence with @xmath460,\\se_3[\\substb]$ ] , because variables in new occurrences of @xmath82 in @xmath460,\\se_3[\\substb]$ ] are preceded by @xmath461 , and the relative order of the other variables does not change .",
    "hence , the sequence @xmath475,\\se_3[\\substb]$ ] is well - moded .      hence , we showed also in _ case 2 _ that there exists a well - moded sequence of literals , namely , @xmath470,\\allowbreak v\\eql e , \\se_2[\\substb],\\se_3[\\substb]$ ] , that corresponds to @xmath462 . hence , @xmath462 is well - moded .",
    "let @xmath478 , @xmath479 , and @xmath334 be a well - moded state .",
    "we will use the notation @xmath480 for the conjunction of all literals in @xmath344 , i.e. , @xmath481 .",
    "assume that @xmath482 is the selected literal in reduction that gives @xmath483 from @xmath484 .",
    "we consider four possible cases , according to the definition of operational semantics :    _ case 1 .",
    "_ let @xmath482 be a primitive constraint and @xmath485 .",
    "let @xmath270 denote the dnf of @xmath486 .",
    "in order to prove that @xmath483 is well - moded , by the definition of @xmath264 , it is sufficient to prove that @xmath487 is well - moded . since , obviously , @xmath488 is a well - moded state , we have to show that state well - modedness is preserved by each rule of the solver .",
    "since @xmath485 , the step is not performed by any of the failure rules of the solver . for the rules m1m8 , m11m12 , d1 , and d2 ,",
    "it is pretty easy to verify that @xmath487 is well - moded .",
    "therefore , we consider the other rules in more detail .",
    "we denote the disjunct of @xmath270 on which the rule is applied by @xmath489 .",
    "the cases below are distinguished by the rules :    here the same variable is removed from both sides of the selected equation .",
    "assume @xmath490 is a well - moded sequence corresponding to @xmath491 , and @xmath492 is the selected equation affected by one of the deletion rules .",
    "well - modedness of @xmath490 requires that the variable deleted at this step from @xmath492 should occur in an output position in some other literal in @xmath493 .",
    "let @xmath494 be the equation obtained by the deletion step from @xmath492 .",
    "then @xmath495 is again well - moded , which implies that @xmath496 is well - moded and , therefore , that @xmath487 is well - moded .",
    "let @xmath491 be represented as @xmath497 , where @xmath498 is the membership atom affected by the rule .",
    "note that then @xmath499 is also well - moded . applying lemma  [ lem : well : modedness:1 ] , we get that @xmath500 is well - moded , where @xmath501 .",
    "then we get well - modedness of @xmath496 , which implies well - modedness of @xmath487 .",
    "let @xmath491 be represented as @xmath502 , where @xmath503 is the membership atom affected by the rule .",
    "note that then @xmath504 is also well - moded .",
    "applying lemma  [ lem : well : modedness:1 ] , we get that @xmath505 is well - moded , where @xmath506 . but",
    "it means that @xmath496 is well - moded , which implies that @xmath487 is well - moded .",
    "let @xmath491 be represented as @xmath507 , where @xmath508 is the equation affected by the rule and @xmath509 .",
    "then @xmath510 is also well - moded for some @xmath511 and @xmath512 with @xmath513 . applying lemma  [ lem : well : modedness:1 ] , we get that @xmath514 is well - moded , where @xmath515 .",
    "since @xmath511 and @xmath512 were arbitrary , it implies that @xmath496 and , therefore , @xmath487 is well - moded .",
    "_ let @xmath482 be a primitive constraint and @xmath516 , where @xmath517 . then by the operational semantics we have @xmath518 and the theorem trivially holds , since the state @xmath519 is well - moded .",
    "_ let @xmath482 be an atom @xmath520 .",
    "assume that @xmath275 contains a clause of the form @xmath521 , where @xmath522 denotes the body of the clause .",
    "assume also that for the predicate @xmath223 , the set @xmath523 is the set of the input positions and @xmath524 is the set of the output ones .",
    "then we have @xmath525 from well - modedness of the state @xmath526 we know that for all @xmath374 , the literals from @xmath527 and @xmath528 can be reordered in two sequences of literals @xmath529 and @xmath530 in such a way that the sequence @xmath531 is well - moded .",
    "then we have @xmath532 @xmath533 .",
    "therefore , we obtain that the sequence @xmath534 is well - moded for all @xmath374 .    from well - modedness of @xmath521",
    "we know that @xmath535 . by item [ wel ] of the definition of program well - modedness",
    ", the literals of @xmath522 can be put into a well - moded sequence , written , say , as @xmath536 , such that for each @xmath537 and @xmath538 we have @xmath539 for some @xmath540 , or @xmath541 .",
    "from then we can say that the sequence @xmath542 is well - moded .    from ( [ wm:1 ] ) and ( [ wm:2 ] ) , by the definition of well - modedness",
    ", we can conclude that @xmath543 is well - moded for all @xmath374 . by construction ,",
    "the literals in ( [ wm:3 ] ) are exactly those from @xmath544 for @xmath374 .",
    "it means that @xmath545 is well - moded for all @xmath374 , which implies that @xmath546 is well - moded .      by the definition of well - modedness , since @xmath231 is well - moded , the state @xmath548 is also well - moded , where @xmath45 is an arbitrary function symbol .",
    "by the operational semantics , we have the reduction @xmath549 . by lemma [ lem : well : modedness:2 ] , we get that @xmath550 is also well - moded and , hence , @xmath551 is well - moded . by the definition of @xmath264 and the rules of the solver , it is straightforward to see that @xmath552 . hence , @xmath553 is well - moded .    by the corollary [ cor : wellmoded ] , the constraint @xmath340 is well - moded . if @xmath340 is @xmath20 then it is already solved .",
    "consider the case when @xmath340 is not @xmath21 .",
    "let @xmath554 . since @xmath339 , by the theorem [ thm : equivalence ] @xmath340 is partially solved .",
    "it means that each @xmath555 , @xmath374 , is partially solved and well - moded . by definition , @xmath555 is well - moded if there exists a permutation of its literals @xmath556 which satisfies the well - modedness property .",
    "assume @xmath557 are solved . by this assumption and the definition of well - modedness ,",
    "each of @xmath557 is an equation whose one side is a variable that occurs neither in its other side nor in any other primitive constraint .",
    "then well - modedness of @xmath555 guarantees that the other sides of these equations are ground terms .",
    "assume by contradiction that @xmath558 is partially solved , but not solved .",
    "if @xmath115 is a membership constraint , well - modedness of @xmath555 implies that @xmath115 does not contain variables and , therefore , can not be partially solved .",
    "now let @xmath115 be an equation .",
    "since all variables in @xmath559 are solved , they can not appear in @xmath115 .",
    "from this fact and well - modedness of @xmath555 , @xmath115 should have at least one ground side .",
    "but then it can not be partially solved .",
    "the obtained contradiction shows that @xmath340 is solved .",
    "we prove a slightly more general statement : let @xmath560 be a derivation with respect to a well - moded program , starting from a well - moded goal @xmath561 and ending with @xmath562 that is either @xmath563 or consists only of atomic formulas without arguments ( propositional constants ) . if @xmath339 , then @xmath340 is solved .",
    "to prove this statement , we use induction on the length @xmath59 of the derivation . when @xmath564 , then @xmath565 and it is solved . assume the statement holds when the derivation length is @xmath59 , and prove it for the derivation with the length @xmath566 .",
    "let such a derivation be @xmath567 .",
    "assume that @xmath568 that is either @xmath563 or consists only of propositional constants .",
    "according to the operational semantics , there are two possibilities how the last step is made :    1 .",
    "@xmath569 has a form ( modulo permutation ) @xmath570 , @xmath571 , where @xmath465 is primitive constraint , the @xmath223 s are propositional constants , @xmath572 , and @xmath573 .",
    "2 .   @xmath569 has a form ( modulo permutation ) @xmath574 , @xmath571 , where @xmath575 and @xmath223 s are propositional constants , the program contains a clause @xmath576 , @xmath577 , where all @xmath578 , @xmath579 , are propositional constants , @xmath580 , and @xmath581 .    in the first case , by the @xmath59-fold application of lemma  [ lem : well : modedness:2 ] we get that @xmath582 is well - moded . since the @xmath223 s",
    "have no influence on well - modedness ( they are just propositional constants ) , @xmath583 is well - moded and hence it is solvable . by theorem  [ lem : solvedform ]",
    "we get that if @xmath584 , then @xmath585 is solved .    in the second case ,",
    "since @xmath586 consists of propositional constants only , by the induction hypothesis we have that if @xmath587 is not @xmath21 , then it is solved .",
    "but @xmath588 . it finishes the proof .",
    "let @xmath105 be a partially solved conjunction of primitive constraints .",
    "then , by the definition , each primitive constraint @xmath589 from @xmath105 should be either solved in @xmath105 , or should have one of the following forms :    * membership atom : * * @xmath117 . * * @xmath118 where @xmath119 and @xmath61 has the form @xmath120 or @xmath121 .",
    "* equation : * * @xmath122 where @xmath123 , @xmath124 and @xmath125 . * * @xmath126 , where @xmath127 , @xmath124 , and @xmath128 . the variables @xmath129 and @xmath130 are not necessarily distinct .",
    "* * @xmath131 where @xmath132 and @xmath133 are disjoint .    however , @xmath589 is also a kif constraint . by the definition of kif form ,",
    "none of the above mentioned forms for membership atoms and equations are permitted .",
    "hence , @xmath589 is solved in @xmath105 and , therefore , @xmath105 is solved .",
    "it implies the lemma .",
    "since the reduction preserves kif states , @xmath340 is in the kif form .",
    "since the derivation is finished and @xmath339 , by the definition of finished derivation , @xmath340 is partially solved . by lemma  [ lem : kif : partially : solved ] , we conclude that @xmath340 is solved ."
  ],
  "abstract_text": [
    "<S> @xmath0 is an instantiation of the general constraint logic programming scheme with the constraint domain of hedges . </S>",
    "<S> hedges are finite sequences of unranked terms , built over variadic function symbols and three kinds of variables : for terms , for hedges , and for function symbols . </S>",
    "<S> constraints involve equations between unranked terms and atoms for regular hedge language membership . </S>",
    "<S> we study algebraic semantics of @xmath0 programs , define a sound , terminating , and incomplete constraint solver , investigate two fragments of constraints for which the solver returns a complete set of solutions , and describe classes of programs that generate such constraints .    to appear in theory and practice of logic programming ( tplp ) .    </S>",
    "<S> [ firstpage ]    constraint logic programming , constraint solving , hedges . </S>"
  ]
}