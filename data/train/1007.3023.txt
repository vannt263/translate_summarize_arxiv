{
  "article_text": [
    "_ purely functional programming _ ( pfp ) has a chance of becoming very popular for the simple reason that we now have laptops with four cores and more .",
    "the promise of pfp is that because there are no side - effects , no destructive updates , and no shared mutable state , partitioning a program into pieces that run in parallel becomes straightforward .",
    "another consequence of the freedom from impure language constructs is that reasoning about program correctness , both formally and informally , becomes much easier in pfp languages than in , say , imperative languages .",
    "therefore it is not surprising that pfp is popular within the theorem proving community .",
    "for example , the source code of the interactive theorem proving assistant isabelle  @xcite is mostly written in a purely functional style .",
    "outside of such specialty communities though , pfp clearly has not reached the mainstream yet .    a programming paradigm that pervades today s mainstream is dijkstra s _ structured programming _",
    "@xcite ( sp ) . most young programmers even do not know the term structured programming anymore ,",
    "but anyway still construct their object - oriented programs out of building blocks like ` if`-branches and ` while`-loops .",
    "interestingly , the pfp community largely rejects sp because it smells of side - effects , destructive updates , and mutable state , just the things a purely functional programmer wants to avoid . as an example , let us examine the isabelle ( version 2009 - 2 ) source code .",
    "discounting blank lines , it consists of about 140000 lines of standard ml  @xcite ( sml ) code . yet",
    ", only ten of those lines use the ` while ` keyword of sml ! furthermore , five out of those ten lines are part of isabelle s system level code , and a further three lines stem from the author of this paper trying to circumvent missing tail - recursion optimization .",
    "the reason for this sparse use of ` while ` is clear : in order to use ` while ` in sml one must also use reference cells which are the embodiment of the small amount of impurity still left in sml .",
    "the easiest way to make pfp more mainstream might be to make sp , which already is part of the mainstream , an integral part of pfp ! this is what this paper is about .",
    "our central tool for such a unification of pfp and sp is the notion of _ linear scope_. linear scope makes heavy use of _ shadowing _ , therefore we first look at shadowing and its treatment in other languages that draw on functional programming , like erlang and scala .",
    "we then present the syntax of a toy language called _",
    "mini babel-17 _ to prepare a proper playground for the introduction of linear scope .",
    "first we concentrate on how linear scope interacts with the sequencing and nesting of statements . from there the extension to conditionals and loops is straightforward .",
    "finally we give a formal semantics for mini babel-17 and hence also for linear scope .",
    "here is how you could code in sml the function @xmath0 :    fn x = > let val x = x * x in x * x end    there is no doubt that the above denotes a pure function .",
    "the fact that the introduction of the variable ` x ` via ` val x = x * x ` _ shadows _ the previous binding of ` x ` in ` fn x ` might make it look a little bit more unusual than the more common    fn x = > let val y = x * x in y * y end ,    but of course both denotations are equivalent . rewriting both functions in de bruijn notation  @xcite would actually yield the exact same closed term .",
    "yet it seems that the conception that shadowing is somehow wrong lies at the heart of why pfp and sp do not overlap in the mind of many programmers .",
    "an instance where shadowing is forbidden in order to obtain a notion of pure variables is the programming language erlang which features _ single - assignment _ of variables . quoting the inventor of erlang  @xcite :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ when erlang sees a statement such as x = 1234 , it binds the variable x to the value 1234 . before being bound",
    ", x could take any value : it s just an empty hole waiting to be filled .",
    "however , once it gets a value , it holds on to it forever .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    clearly in erlang shadowing is a victim of the idea that variables are not just names bound to values , but that _ the variables themselves are the state_.    something similar can be observed in the programming language scala  @xcite .",
    "scala combines functional and structured programming in an elegant fashion .",
    "but when it comes to integrate _",
    "purely _ functional programming and sp , scala does not go all the way : it also forbids shadowing .",
    "for example , the following scala function implements @xmath1 ,    ( x : int ) = > val y = x*x ; val z = y*y ; z*z ,    but both of the following expressions are illegal in scala :    ( x : int ) = > val y = x*x ; val y = y*y ; y*y , ( x : int ) = > val y = x*x ; y = y*y ; y*y .",
    "the last expression can be turned into a legal scala expression by replacing the keyword ` val ` , which introduces immutable variables , with the keyword ` var ` , which introduces mutable variables :    ( x : int ) = > var y = x*x ; y = y*y ; y*y .",
    "it might seem that after all , shadowing in scala is possible ! but this is not the case . that ` var ` behaves differently than shadowing can easily be checked :    ( x : int ) = > var y = x*x val h = ( ) = >",
    "y y = y*y h ( ) * y    also implements @xmath1 . with shadowing",
    ", we would expect above function to implement @xmath2 .",
    "_ babel-17 _  @xcite is a new dynamically - typed programming language in the making which is being developed by the author of this paper .",
    "one of its main features is that it combines purely functional programming and structured programming , building on the key observation that shadowing is purely functional . for illustration purposes we use a simplified version of a subset of babel-17 , which we call _ mini babel-17",
    "_ , as a proposal of how a purely functional structured programming language could look like .",
    "an implementation of mini babel-17 is available at  @xcite",
    ".    a _ block _ in mini babel-17 is a sequence of _ statements _ :    @xmath3 @xmath4 @xmath5 @xmath6 @xmath7    several statements within a single line are separated via semicolons .",
    "there are seven kinds of statements :    @xmath8 @xmath4 @xmath9 @xmath10 @xmath11 @xmath10 @xmath12 @xmath10 @xmath13 @xmath10 @xmath14 @xmath10 @xmath15 @xmath10 @xmath16    @xmath9 @xmath4 val @xmath17 = @xmath18 @xmath19 @xmath4 @xmath17 = @xmath18 @xmath12 @xmath4 yield @xmath18 @xmath13 @xmath4 if @xmath20 then @xmath3 else @xmath3 end @xmath14 @xmath4 while @xmath20 do @xmath3 end @xmath15 @xmath4 for @xmath17 in @xmath20 do @xmath3 end @xmath16 @xmath4 begin @xmath3 end    if the last statement of a _ block _ is a _ yield - statement _ , then the ` yield ` keyword may be dropped in that statement .",
    "a _ simple - expression _ is an expression like it can be found in most other functional languages , i.e. it can be an integer , a boolean , an identifier , an anonymous function , function application , or some operation on _ expressions _ like function application , multiplication or comparison :    @xmath20 @xmath4 @xmath21 @xmath10 @xmath22 @xmath10 @xmath17 @xmath10 @xmath17 = >",
    "@xmath18 @xmath10 @xmath23 @xmath24 @xmath10 @xmath23 * @xmath24 @xmath10 @xmath23 = = @xmath24 @xmath6    an _ expression _ is either a _ simple - expression _ or a statement :    @xmath18 @xmath4 @xmath20 @xmath10 @xmath13 @xmath10 @xmath14 @xmath10 @xmath15 @xmath10 @xmath16",
    "let us gain a first intuitive understanding of mini babel-17 before formally introducing its semantics",
    ". here is how you could denote @xmath1 in mini babel-17 :    x = > begin val y = x*x ; val z = y*y ; z*z end    this looks pretty much like the scala denotation of @xmath1 from section  [ sec : shadowing ] .",
    "but because mini babel-17 is designed so that shadowing of variables is allowed , an equivalent notation is :    x = > begin val x = x*x ; val x = x*x ; x*x end    the central idea of mini babel-17 is the notion of _ linear scope_. whenever an identifier x is in linear scope , it is allowed to rebind x to a new value , and _ that rebinding will affect all other _ later _ lookups of @xmath25 that happen within its normal lexical scope_. the rebinding is done via a _ val - assign - statement_.    the linear scope of a variable is contained in the usual lexical scope of that variable .",
    "the linear scope of a variable x starts    * in the statement after the _ val - statement _ that defines @xmath25 , or * in the first statement of an anonymous function that binds @xmath25 as a function argument , if the body of that function is a block , or * in the first statement of the block of a _ for - loop _ where x is the identifier bound by that loop .",
    "it continues throughout the rest of the block unless a new linear scope for @xmath25 starts .",
    "it does extend into nested blocks and statements , but not into _ simple - expressions_. the reason for this is that blocks and statements are ordered sequentially , but there is no natural order for the evaluation of the components of a _ simple - expression_.    using the linear scope rules of mini babel-17 , the above function can also be encoded as    x = > begin x = x*x ; x = x*x ; x*x end    if there are no nested blocks involved , then linear scope is no big deal .",
    "it is just a fancy way of saying that when in a _ val - statement _ the variable being defined shadows a previously defined variable , often it is ok to drop the _",
    "keyword , effectively turning a _",
    "val - statement _ into a _ val - assign - statement_.    but with nested blocks , linear scope becomes important :    c|cc|cc    val x = 2 begin val y = x*x val x = y end x+x    & &    val x = 2 begin val y = x*x x = y end x+x    & &    val x = 2 begin val y = x*x val x = 0 x = y end x+x     + evaluates to 4 & & evaluates to 8 & & evaluates to 4    the left and right programs both evaluate to 4 because the ` begin ` ... ` end ` block is superfluous as none of its statements have any effect in the outer scope .",
    "the middle program evaluates to 8 , though , because the rebinding ` x = y ` effects all later lookups in the lexical scope of that x that has been introduced via ` val x = 2 ` , and ` x+x ` certainly is such a later lookup .    maybe the rules of linear scope sound confusing at first .",
    "but they really are not .",
    "just replace in your mind in the above three programs the ` val`s by ` var`s and view them as imperative programs .",
    "what value would you assign now to each program ?",
    "let us also recode the last scala expression of section  [ sec : shadowing ] as a mini babel-17 expression :    x = > begin val y = x*x val h = dummy = > y y = y*y h 0 * y end    mini babel-17 is purely functional , therefore the value of h is of course not changed by the rebinding ` y = y*y ` which affects only _ later _ lookups of y. thus the above expression implements @xmath2 , not @xmath1 .",
    "conditionals and especially loops are the meat of structured programming . with linear scope , they are easily seen also as part of purely functional programming .",
    "all we need to do is to apply linear scoping rules to the nested blocks that the _ if_- , _ while- _ and _ for - statements _ consist of .",
    "for example , this is how you can encode the subtraction based euclidean algorithm for two non - negative integers in mini babel-17 :    a = > b = > if a = = 0 then b else val a = a while b ! = 0 do if a > b then a = a - b else b = b - a end end a end    note the line ` val a = a ` which on first sight seems to be superfluous .",
    "but while the linear scope of ` b ` encompasses the whole function body , the linear scope of ` a ` does not , because linear scope does not extend into _ simple - expressions_. if mini babel-17 had pattern matching , the line ` val a = a ` could be avoided by starting the function definition with    [ a , b ] = > @xmath6    instead .",
    "in this section we define an operational semantics for mini babel-17 by building a mini babel-17 interpreter written in standard ml .",
    "first we represent the grammar of mini babel-17 as sml datatypes :    datatype block = block of statement list and statement = sval of identifier * expression | sassign of identifier * expression | syield of expression | sif of simple_expression * block * block | swhile of simple_expression * block | sfor of identifier * simple_expression * block | sblock of block and expression = esimple of simple_expression | eblock of statement and simple_expression = eint of int | ebool of bool    * value - > value ) * expression * expression and identifier = i d of string    note that function application , multiplication , comparison and so on are all described via the ` ebinop ` constructor by providing a suitable parameter of type ` value * value - > value ` .",
    "the type ` value ` represents all values that can be the result of evaluating a mini babel-17 program :    datatype value = vbool of bool | vint of int | vfun of value - > value | vlist of value list    mini babel-17 wants to be both purely functional and structured ; the most important ingredients of a purely functional program are expressions ; the most important ingredients of an sp program are blocks and statements .",
    "this dilemma is resolved by treating statements as special expressions .",
    "the interpreter defines the following evaluation functions :    eval_b : environment - > block - > environment * value list eval_st : environment - > statement - > environment * value list eval_e : environment - > expression - > value eval_se : environment - > simple_expression - > value    the evaluation of blocks and statements yields lists of values instead of single values , the block    begin yield 1 ; yield 2 ; 3 end    for example evaluates to ` [ 1 , 2 , 3 ] ` .",
    "consider the following mini babel-17 program :    val x = 0 begin x = 1 ; x end * begin val x = x + 2 ; x end    it does not obey the linear scoping rules of mini babel-17 because x is not in linear scope in the _ val - assign - statement _ ` x = 1 ` . in such a situation , the exception illformed is raised during evaluation .",
    "furthermore , an exception typeerror is raised when for example the condition of an if - statement evaluates to a list instead of a boolean .",
    "note by the way that the program    val x = 0 begin val x = 1 ; x end * begin val x = x + 2 ; x end    is perfectly fine and evaluates to 2 .",
    "what does the environment look like ?",
    "it is actually split into two parts , one part for those identifiers that have linear scope , and one part for identifiers that do nt .",
    "the nonlinear part is a mapping from identifiers to values , the linear part a mapping from identifiers to reference cells of values .",
    "both parts can be described by the polymorphic type a idmap :    type idmap = ( string * a ) list fun lookup [ ] _ = raise illformed | lookup ( ( t , x)::r ) ( i d s ) = if t = s then x else lookup r ( i d s ) fun remove [ ] _ = [ ] | remove ( ( t , x)::r ) ( i d s ) = if t = s then r else remove r ( i d s ) fun insert m ( ( i d s),x ) = ( s , x)::(remove m ( i d s ) )    the type of environments is then introduced as follows :    type environment = value idmap * ( value ref ) idmap fun deref [ ] = [ ] | deref ( ( s , vr)::m ) = ( ( s,!vr)::(deref m ) ) fun freeze ( nonlinear , linear ) = ( nonlinear@(deref linear ) , [ ] ) fun bind ( nonlinear , linear ) ( id , value ) = ( remove nonlinear i d , insert linear ( i d , ref value ) ) fun rebind ( env as ( _ , linear ) ) ( i d , value ) = ( lookup linear i d : = value ; env )    note that bind returns a new environment , and rebind returns the same environment with a mutated linear part .",
    "the function freeze turns all mutable linear bindings into immutable nonlinear ones .",
    "now we can give the definition of all evaluation functions :    fun eval_b env ( block [ ] ) = ( env , [ ] ) | eval_b env ( block ( s::r ) ) = let val ( env , values_s ) = eval_st env s val ( env  , values_r ) = eval_b env ( block r ) in ( env  , values_s @ values_r ) end and eval_nestedb env b = let val ( _ , values ) = eval_b env b in ( env , values ) end and eval_st env ( sval ( i d , e ) ) = let val value = eval_e env e in ( bind env ( i d , value ) , [ ] ) end | eval_st env ( sassign ( i d , e ) ) =",
    "let val value = eval_e env e in ( rebind env ( i d , value ) , [ ] ) end | eval_st env ( syield e ) = let val value = eval_e env e in ( env , [ value ] ) end | eval_st env ( sblock b ) = eval_nestedb env b | eval_st env ( sif ( cond , yes , no ) ) = ( case eval_se env cond of vbool true = > eval_nestedb env yes | vbool false = >",
    "eval_nestedb env no | _",
    "= > raise typeerror ) | eval_st env ( loop as swhile ( cond , body ) ) = ( case eval_se env cond of vbool true = > let val ( _ , values_1 ) = eval_b env body val ( _ , values_2 ) = eval_st env loop in ( env , values_1 @ values_2 ) end | vbool false = > ( env , [ ] ) | _",
    "= > raise typeerror ) | eval_st env ( sfor ( i d , list , body ) ) = ( case eval_se env list of vlist l = > eval_for env i d body l | _",
    "= > raise typeerror ) and eval_for env i d body [ ] = ( env , [ ] ) | eval_for env i d body ( x::xs ) = let val ( _ , values_1 ) = eval_b ( bind env ( id , x ) ) body val ( _ , values_2 ) = eval_for env i d body xs in ( env , values_1@values_2 ) end and eval_e env ( esimple se ) = eval_se env se | eval_e env ( eblock s ) = ( case eval_b env ( block [ s ] ) of ( _ , [ a ] ) = > a | ( _ , l ) = > vlist l ) and eval_se env se = eval_simple ( freeze env ) se and eval_simple env ( eint i ) = vint i | eval_simple env ( ebool b ) = vbool b | eval_simple env ( ebinop ( f , a , b ) ) = f ( eval_e env a , eval_e env b ) | eval_simple ( nonlinear , _ ) ( eid i d ) = lookup nonlinear i d | eval_simple env ( efun ( i d , body ) ) = vfun ( fn value = > eval_e ( bind env ( i d , value ) ) body )    here is the evaluation function that computes the meaning of a mini babel-17 program , i.e. of a block :    eval : block - > value fun eval prog = snd ( eval_e ( [ ] , [ ] ) ( eblock ( sblock prog ) ) )    it is straightforward how to extract from above evaluation functions a wellformedness - criterion such that if a mini babel-17 program is statically checked to be wellformed according to that criterion , no illformed exception will be raised during the evaluation of the program :    val value = vint 0 fun check_b env ( block [ ] ) = env | check_b env ( block ( s::r ) ) = check_b ( check_st env s ) ( block r ) and check_st env ( sval ( i d , e ) ) = ( check_e env e ; bind env ( i d , value ) ) | check_st env ( sassign ( i d , e ) ) = ( check_e env e ; rebind env ( i d , value ) ) | check_st env ( syield e ) = ( check_e env e ; env ) | check_st env ( sblock b ) = ( check_b env b ; env )    yes ; check_b env no ; env ) | check_st env ( loop as swhile ( cond , body ) ) = ( check_se env cond ; check_b env body ; env ) | check_st env ( sfor ( i d , list , body ) ) = ( check_se env list ; check_b ( bind env ( i d , value ) ) body ; env ) and check_e env ( esimple se ) = check_se env se | check_e env ( eblock s ) = ( check_b env ( block [ s ] ) ; ( ) ) and check_se env se = check_simple ( freeze env ) se and check_simple env ( eint i ) = ( ) | check_simple env ( ebool b ) = ( ) | check_simple env ( ebinop ( f , a , b ) ) = ( check_e env a ; check_e env b ) | check_simple ( nonlinear , _ ) ( eid i d ) = ( lookup nonlinear i d ; ( ) ) | check_simple env ( efun ( i d , body ) ) = check_e ( bind env ( i d , value ) ) body fun check prog = check_e ( [ ] , [ ] ) ( eblock ( sblock prog ) )    the function _ check _ terminates because it is basically defined via primitive recursion on the structure of the program .",
    "furthermore , the set of calls to _ lookup _ generated during an execution of _ check prog _ is clearly a superset of the set of calls to _ lookup _ generated during the execution of _ eval prog_. therefore , if _ check prog _ does not raise an exception _ illformed _ , then neither will _ eval prog_.",
    "with mini babel-17 , you can freely choose between a programming style that uses loops and a programming style that puts its emphasis on the use of higher - order functionals .",
    "if you have an imperative background , you might start out with using loops everywhere , and then migrate slowly to the use of functionals like _ map _ or _ fold _ as your understanding of functional programming increases .",
    "but even after your functional programming skills have matured , you might still choose to use loops in appropriate situations .",
    "let us for example look at a function that takes a list of integers @xmath26 $ ] and an integer @xmath25 as arguments and returns the list",
    "@xmath27 \\quad \\text{where } \\quad q_k = \\sum_{i=0}^k a_i\\ , x^i\\ ] ] the implementation in mini babel-17 via a loop is straightforward , efficient and even elegant :    m = > x = > begin val y = 0 val p = 1 for a in m do y = y + a*p",
    "p = p * x yield y end end",
    "we have already mentioned how scala also combines structured programming with functional programming , but fails to deliver a combination of structured programming and _ purely _ functional programming .",
    "actually , it should be possible to conservatively extend scala so that linear scope for variables defined via ` val ` is supported .",
    "the work done on monads in the purely functional programming language haskell  @xcite has a superficial similarity with the work done in this paper . with monads",
    "it is possible to formulate sequences of ( possibly shadowing ) assignments , and with the help of monad transformers even loops can be modeled .",
    "but in order to understand and effectively use monads a solid background in functional programming is useful , if not even required ; linear scope on the other hand is understood intuitively by programmers with a mostly imperative background , because mini babel-17 programs can look just like imperative programs and do not introduce additional clutter like the need for lifting .",
    "actually , in haskell monads are used to limit the influence of mutable state to a confined region of the code that can be recognized by its type ; the work in this paper has the entirely different focus of trying to merge the structured and purely functional programming style as seamlessly as possible .",
    "this work is not directly connected to work done on linear or uniqueness types  @xcite . of course one might think about applying uniqueness typing to mini babel-17 , but mini babel-17 itself is dynamically - typed and its values are persistent and can be passed around without any restrictions .",
    "the current separation between sp and pfp is an artificial one .",
    "there is no good reason anymore why sp should not be used where appropiate for the sequential parts of a purely functional program except the personal preference of the programmer .",
    "the purpose of mini babel-17 is to show the importance of linear scope for unifying sp and pfp .",
    "babel-17 incorporates further important features for purely functional and structured programming like mutually recursive functions , pattern matching , exceptions , objects , memoization , concurrency , laziness , and more syntactic sugar ."
  ],
  "abstract_text": [
    "<S> the idea of functional programming has played a big role in shaping today s landscape of mainstream programming languages . </S>",
    "<S> another concept that dominates the current programming style is dijkstra s structured programming . </S>",
    "<S> both concepts have been successfully married , for example in the programming language scala . </S>",
    "<S> this paper proposes how the same can be achieved for structured programming and _ purely _ functional programming via the notion of _ linear scope_. one advantage of this proposal is that mainstream programmers can reap the benefits of purely functional programming like easily exploitable parallelism while using familiar structured programming syntax and without knowing concepts like monads . </S>",
    "<S> a second advantage is that professional purely functional programmers can often avoid hard to read functional code by using structured programming syntax that is often easier to parse mentally . </S>"
  ]
}