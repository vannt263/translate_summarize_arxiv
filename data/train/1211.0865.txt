{
  "article_text": [
    "this paper develops a significant part of the theory of simple types based on a recently introduced rewriting approach to typing .",
    "the idea of viewing typing as a small - step abstract reduction relation was proposed by kuan , macqueen , and findler in 2007 , and explored also by ellison , erbnu , and rou  @xcite .",
    "these works sought to use rewrite systems to specify typing in a finer - grained way than usual type systems .",
    "our motivation is more foundational : we seek to prove standard meta - theoretic properties of type systems directly , based on the rewriting formulation .",
    "the goal is to develop new methods which could provide a different perspective on familiar type systems , and perhaps yield new results for more advanced type systems .",
    "our focus in this paper is simple type systems , where the central typing construct is the function type @xmath0 .",
    "we will view such types as abstractions of functions , and incrementally rewrite ( typable ) functions to such function types , using an abstract small - step reduction relation",
    ". it will be straightforward to prove the standard property of type safety , based on type preservation and progress , using this rewriting formulation .",
    "this viewpoint also allows us to combine the usual concrete reduction relation and our new abstract reduction relation together , simply by taking their set - theoretic union .",
    "we will prove that this combined reduction relation is confluent for typable terms , defined as terms which reduce , using abstract steps , to a type . to prove both type preservation and confluence we use observations developed in the context of abstract reduction systems .",
    "we then develop our final main result , which is a proof of normalization for the simply typed lambda calculus , based on the rewriting approach .",
    "this proof has several novel features , which shed new light on the reducibility semantics of types used in standard proofs of normalization .",
    "this paper expands in several important ways on a previous paper of stump , kimmell , and el haj omar , which was presented at rta 2011  @xcite :    @xmath1    we use the rewriting method to prove type preservation for full @xmath2-reduction ; the rta 11 paper showed it only for call - by - value computation .",
    "we prove preservation for a new notion we call generalized typing , where concrete and abstract reduction steps can be intermixed .",
    "this generalizes the so - called _ direct computation rules _ of the well - known nuprl system  @xcite .",
    "we correct an error in the rta 11 paper , where we claimed that type preservation is a corollary of confluence for typable terms .",
    "in fact , confluence is a straightforward corollary of type preservation .",
    "we have shown how a standard proof of normalization for simply typable terms is adapted to the rewriting approach to typing .",
    "this adaptation reveals an interesting perspective on types as abstractions of terms .    due to the amount of new material",
    ", we have dropped the treatment of several variants of stlc , which are studied in the rta paper .",
    "as zantema had a substantial contribution to these extensions , he was added as an author .",
    "the remainder of the article is organized as follows .",
    "section  [ sec : rewriting - prelim ] provides a brief introduction to abstract reduction systems as used later in the paper .",
    "section  [ sec : std - presentation ] gives a standard presentation of the simply typed lambda calculus along with the fundamental meta - theoretic properties .",
    "section  [ sec : restlc ] recasts the simply typed lambda calculus static and operational semantics within the framework of abstract reduction systems",
    ". section  [ sec : ars ] gives some abstract reduction theory to be used in section  [ sec : presstlc ] where type preservation and confluence is proved .",
    "section  [ sec : progtpsafe ] then proves progress and type safety .",
    "section  [ sec : unistc ] proves type preservation and confluence for a system with uniform syntax for types and term . for this result , we use automated tools developed in the term - rewriting community , to verify some of the properties necessary for applying theorems proved in section  [ sec : ars ] .",
    "section  [ sec : genpresstlc ] extends these to a generalized notion of typing , based on the union of the concrete and abstract reduction relations .",
    "section  [ sec : normstlc ] applies a rewriting approach to prove the normalization of well - typed simply typed lambda calculus terms .",
    "we conclude and identify future directions in section  [ sec : conclusion ] .",
    "in this section we collect some basic properties in the setting of abstract reduction systems .",
    "that is , we consider relations @xmath3 being a subset of @xmath4 for some arbitrary set @xmath5 .",
    "we write @xmath6 for relation composition , and inductively define @xmath7 ( the identity ) and @xmath8 for @xmath9 . as usual , for a relation @xmath3 we write @xmath10 for its reverse , @xmath11 for its reflexive closure ( zero or one times ) , @xmath12 for its transitive closure ( one or more times ) , and @xmath13 for its transitive reflexive closure ( zero or more times ) .",
    "we will also use standard notation @xmath14 for the image of set @xmath15 under relation @xmath16 : @xmath17 we can use this notation to denote the set of predecessors of a set @xmath15 with respect to @xmath3 as @xmath18 . we will also write @xmath19 for @xmath20 .",
    "a relation @xmath3 is said to    @xmath1    be _ confluent _ ( church rosser , @xmath21 ) if @xmath22 ,    be _ locally confluent _ ( weak church rosser , @xmath23 ) if @xmath24 ,    have the _ diamond property _ ( @xmath25 ) if @xmath26 ,    be _ deterministic _",
    "( det@xmath27 ) if @xmath28 .",
    "be _ terminating _ if there is no infinite descending chain @xmath29 .",
    "be _ convergent _ if it is confluent and terminating .",
    "we will sometimes also call an element @xmath30 confluent iff for all @xmath31 with @xmath32 and @xmath33 , there exists @xmath34 with @xmath35 and @xmath36 .",
    "it is well - known and easy to see that det@xmath37 .       finally , if @xmath38 and @xmath39 are binary relations , below we will often write @xmath40 for @xmath41 .",
    "in this section , we summarize a standard presentation of the simply typed lambda calculus ( stlc ) , including syntax and semantics , and statements of the basic meta - theoretic properties of type preservation and progress . sections  [ sec : restlc ] and following will recapitulate this development in detail , from the rewriting perspective . including some type and term constants , together with reduction rules for them ,",
    "is very standard in the study of programming languages and typed lambda calculus .",
    "one example is mitchell s treatment of stlc with additional rules  ( * ? ? ?",
    "* section 4.4.3 ) ) . for progress , it is indeed instructive to include reduction rules for some selected constants . otherwise , there are no stuck terms that should be ruled out by the type system , since in pure stlc , every closed normal form is a value , namely a @xmath42-abstraction .",
    "we treat additional rules representatively ( as opposed to parametrically ) , using constants @xmath43 and @xmath44 below .",
    "the syntax for terms , types , and typing contexts is the following , where @xmath15 , @xmath44 , and @xmath43 are specific constants , and @xmath45 ranges over a countably infinite set of variables : @xmath46 we will write _ types _ for the set of all types .",
    "we assume standard additional conventions and notations , such as @xmath47t'$ ] for the capture - avoiding substitution of @xmath48 for @xmath45 in @xmath49 , and @xmath50 $ ] for grafting a term into an evaluation context .",
    "figure  [ fig : stlc ] defines a standard type system for stlc",
    ". the judgments derived by the rules in the figure are of the form @xmath51 , which can be viewed as deterministically computing a type @xmath52 as output , given a term @xmath48 and a typing context @xmath53 as inputs . in the topmost leftmost rule of the figure",
    ", we use the notation @xmath54 to mean that there is a binding @xmath55 in @xmath53 .",
    "we assume there is at most one such binding in @xmath53 , renaming bound variables as necessary to ensure this .",
    "a standard small - step reduction semantics , for unrestricted @xmath2-reduction , is defined using the rules of figure  [ fig : stlcopsem ] . following standard usage , terms of the form @xmath56 or @xmath57",
    "are called redexes .",
    "an example of a concrete reduction is ( with redexes underlined ) : @xmath58    @xmath59    @xmath60\\ \\to\\ e[[t'/x]t]}{\\ } \\\\ \\\\",
    "\\infer{e[f\\ a]\\ \\to\\ e[a]}{\\ } \\end{array }    &    \\begin{array}{rll } \\textit{values}\\ v & : : = & \\lambda x : t .",
    "|\\ a\\ |\\ f \\\\ \\textit{evaluation contexts}\\ e & : : = & * \\ |\\ ( e\\ t)\\ |\\ ( t\\ e)\\ |\\ \\lambda x : t.\\ , e\\ \\\\ \\ \\\\ \\end{array } \\end{array}\\ ] ]      the main theorem relating the reduction relation @xmath3 and typing is * type preservation * , which states the following , either for unrestricted @xmath2-reduction @xmath3 or for some restriction of @xmath3 ( as we will consider below ) : @xmath61    the standard proof method is to proceed by induction on the structure of the typing derivation , with case analysis on the reduction derivation ( cf .",
    "chapters 8 and 9 of  @xcite ) .",
    "a separate induction is required to prove a substitution lemma , needed critically for type preservation for @xmath2-reduction steps : @xmath62t':t'\\ ] ]    for call - by - value programming languages , one also typically proves * progress * , formulated in terms of values : @xmath63 here , the notation @xmath64 means @xmath65 ; i.e. , @xmath48 is a normal form .",
    "normal forms which are not values are called _ stuck _ terms .",
    "an example is @xmath66 .",
    "combining type preservation and progress allows us to prove * type safety *  @xcite .",
    "this property states that the normal forms of closed well - typed terms are values , not stuck terms , and in our setting can be stated : @xmath67 this is proved by induction on the length of the reduction sequence from @xmath48 to @xmath49 . as already noted , without constants ( @xmath44 and @xmath43 here ) ,",
    "this result is not so interesting for stlc , since it follows already by simpler reasoning : reduction can not introduce new free variables , so @xmath49 must be closed ; and it is then easy to prove that closed normal forms are @xmath42-abstractions , and hence values by definition .",
    "in this section , we see how to view a type - computation ( also called type - synthesis ) system for stlc as an abstract operational semantics .",
    "we view function types @xmath68 as abstract functions from @xmath69 to @xmath70 , and allow these to be applied to arguments .",
    "when @xmath68 is applied to the abstract term @xmath69 , an abstract @xmath2-reduction step is possible , simulating concrete @xmath2-reduction for any function of type @xmath68 applied to an argument of type @xmath69 .",
    "thus , we will see abstract reduction as truly an abstraction of the usual reduction , which we thus view , in contrast , as concrete .",
    "@xmath71    @xmath72{e_c[f\\ a]\\ \\to_c\\ e_c[a]}{\\ } & \\ & \\infer[\\textit{c}(\\beta)]{e_c[(\\lambda x : t.\\,m)\\ u]\\ \\to_c\\ e_c[[u / x]m]}{\\ } \\\\ \\\\",
    "\\infer[\\textit{b}(\\textit{f-}\\beta)]{e_a[f\\ a]\\ \\to_b\\ e_a[a]}{\\ } & \\ & \\infer[\\textit{b}(\\beta)]{e_a[(\\lambda x : t.\\,m)\\ m']\\ \\to_b\\ e_a[[m'/x]m]}{\\ } \\\\ \\\\ \\infer[\\textit{a}(\\beta)]{e_a[(t { \\rightarrow}m)\\ t]\\ \\to_a\\ e_a[m]}{\\ } & \\ & \\ \\infer[\\textit{a}(\\lambda)]{e_a[\\lambda x : t.\\ , m]\\ \\to_a\\",
    "e_a[t{\\rightarrow}[t / x]m]}{\\ } \\\\ \\\\",
    "\\infer[\\textit{a}(f)]{e_a[f]\\ \\to_a\\ e_a[a{\\rightarrow}a]}{\\ } & \\ & \\ \\infer[\\textit{a}(a)]{e_a[a]\\ \\to_a\\ e_a[a]}{\\ }    \\end{array } \\\\ \\\\ \\\\    \\begin{array}{lll } \\textit{call - by - value evaluation contexts}\\ e_c & : : = & * \\ |\\ ( e_c\\ m)\\ |\\ ( u\\ e_c ) \\\\ \\textit{unrestricted evaluation contexts}\\ e_a & : : = & * \\ |\\ ( e_a\\ m)\\ |\\ ( m\\ e_a)\\ |\\ \\lambda x : t.\\ , e_a\\ |\\ t{\\rightarrow}e_a \\\\ \\end{array } \\end{array}\\ ] ]    to view typing as an abstract form of reduction , we use mixed terms , defined in figure  [ fig : synrestlc ] .",
    "types like @xmath68 will serve as abstractions of @xmath42-abstractions . for our development below , we are going to consider both unrestricted @xmath2-reduction , and also call - by - value @xmath2-reduction , a common restriction implemented in practical functional programming languages like ocaml .",
    "figure  [ fig : restlc ] gives rules for concrete call - by - value reduction ( @xmath73 ) , concrete full @xmath2-reduction ( @xmath39 ) , and abstract reduction ( @xmath38 ) . as above , we will refer to any term of the form displayed in context on the left hand side of the conclusion of a rule as a redex .",
    "we denote the union of these reduction relations as @xmath74 . the definition of call - by - value evaluation contexts @xmath75 enforces left - to - right evaluation order in a standard way , while unrestricted evaluation contexts @xmath76 make abstract reduction and full @xmath2-reduction non - deterministic : reduction is allowed anywhere inside a term .",
    "this is different from the approach followed by kuan et al . , where abstract and concrete reduction are both deterministic .",
    "here is an example of reduction using the abstract operational semantics : @xmath77 the final result is a type @xmath52 , which does not reduce ( as noted below ) .",
    "indeed , using the standard typing rules of section  [ sec : stlcstand ] , we can prove that the starting term of this reduction has that type @xmath52 , in the empty typing context .",
    "abstract reduction to a type plays the role of typing above .",
    "[ lem : tpnorm ] for all types @xmath52 , we have @xmath78 .",
    "this follows by induction on @xmath52 and inspection of the rules for @xmath38 .",
    "if we look back at our standard typing rules ( figure  [ fig : stlc ] ) , we can now see them as essentially big - step abstract operational rules .",
    "recall that big - step call - by - value operational semantics for stlc includes this rule ( as well as several others which we elide ) : @xmath79t_1'\\ \\downarrow\\ t'}\\ ] ] in our setting , big - step call - by - value semantics would be seen as a concrete big - step reduction , which we might denote @xmath80 .",
    "the abstract version of this rule , where we abstract @xmath42-abstractions by arrow - types , is @xmath81 if we drop the typing context from the standard typing rule for applications ( in figure  [ fig : stlc ] ) , we obtain essentially the same rule .    the standard approach to proving",
    "type preservation relates a small - step concrete operational semantics with a big - step abstract operational semantics ( i.e. , the standard typing relation ) .",
    "we find it both more elegant , and arguably more informative to relate abstract and concrete small - step relations , as we will do in section  [ sec : presstlc ] below .      in this subsection",
    ", we study the properties of abstract reduction from the perspective of the theory of abstract reduction systems ( arss ) . from this point of view",
    ", abstract reduction is very well behaved : it is a convergent ars , as the following two theorems show .",
    "[ thm : termabstr ] the relation @xmath38 is terminating .",
    "we recursively define a natural - number measure @xmath82 which can be confirmed to reduce from @xmath83 to @xmath84 whenever @xmath85 : @xmath86    [ lem : confl ] the relation @xmath38 is confluent .    in fact , we will prove @xmath38 has the diamond property ( and hence is confluent ) .",
    "suppose @xmath87 and @xmath88 .",
    "no critical overlap is possible between these steps , because none of the redexes in the @xmath43-rules of figure  [ fig : restlc ] ( such as @xmath89 in the @xmath90 rule ) can critically overlap another such redex .",
    "if the positions of the redexes in the terms are parallel , then ( as usual ) we can join @xmath91 and @xmath92 by applying to each the reduction required to obtain the other . finally , we must consider the case of non - critical overlap ( where the position of one redex in @xmath83 is a prefix of the other position ) .",
    "we can also join @xmath91 and @xmath92 in this case by applying the reduction to @xmath93 which was used in @xmath94 , because abstract reduction can not duplicate or delete an @xmath43-redex .",
    "the only duplication of any subterm in the abstract reduction rules of figure  [ fig : restlc ] is of the type @xmath52 in @xmath95 .",
    "the only deletion possible is of the type @xmath52 in @xmath96 .",
    "since types can not contain redexes , there is no duplication or deletion of redexes .",
    "this means that if the position of the first redex is a prefix of the second ( say ) , then there is exactly one descendant ( see section 4.2 of  @xcite ) of the second redex in @xmath91 , and this can be reduced in one step to join @xmath91 with the reduct of @xmath92 obtained by reducing the first redex .",
    "so every _ aa_-peak can be completed with one joining step on each side of the diagram .",
    "this gives the diamond property ( and thus confluence for @xmath38 ) .      in this subsection , we prove the following theorem , which relates our notion of typing with the standard one . the proof begins after the statement of some simple auxiliary lemmas , whose proofs are routine and omitted .",
    "the proof of the right - to - left direction of the implication will take advantage of the fact that abstract reduction is convergent , as proved in the previous subsection .",
    "[ thm : relatetyp ] for standard terms @xmath48 , a typing judgment @xmath97 holds iff @xmath98 t \\to_a^ * t$ ] .",
    "[ lem : lemma1 ] if @xmath99 , then @xmath100 .",
    "[ lem : lemma2 ] if @xmath101 , then @xmath102 .",
    "[ lem : lemma3 ] if @xmath103 , then @xmath104 .",
    "suppose @xmath97 .",
    "we will now prove @xmath98 t \\to_a^ * t$ ] by induction on the structure of the typing derivation of @xmath48 . to simplify the writing of the proof",
    ", we will use the following notation : @xmath105 \\end{array}\\ ] ]    * base case : * @xmath106 there must be some @xmath107 such that @xmath108 and @xmath109 .",
    "so @xmath110 as required .",
    "* base case : * @xmath111 we indeed have @xmath112 , as required . the case for @xmath113 is similar .",
    "* case : * @xmath114 by the induction hypotheses for the derivations given for the two premises of this rule , we have : @xmath115 our goal now is to construct the reduction sequence : @xmath116 to construct this sequence , it is sufficient to apply transitivity of @xmath117 and lemmas  [ lem : lemma1 ] and  [ lem : lemma2 ] .",
    "* case : * @xmath118 by the induction hypothesis on the premise of this rule , we have : @xmath119\\ t \\to_a^ * t'\\ ] ] now we need to show that @xmath120 by applying one @xmath121 step and lemma  [ lem : lemma3 ] we get : @xmath122\\ t ) \\to_a^ * ( t { \\rightarrow}t')\\ ] ] this requires the fact that @xmath123 =            [ t / x]\\gamma_{sub}$ ] , which holds because @xmath124 since we may rename @xmath45 to avoid this , and because @xmath52 contains no term variables and hence is unaffected by applying @xmath125 .    since abstract reduction is convergent ( theorems  [ thm : termabstr ] and  [ lem : confl ] ) , we may assume that redexes in the reduction sequence to @xmath52 are always reduced in leftmost order .",
    "note that convergence is sufficient to justify this assumption , as @xmath52 is a normal form , and hence any strategy is guaranteed to reduce the starting term to @xmath52 in a finite number of steps .",
    "this assumption will simplify some reasoning below .",
    "we assume @xmath98 t \\to_a^ * t$ ] and prove @xmath97 by induction on the number @xmath126 of leftmost @xmath38 steps in the reduction to @xmath52 .    *",
    "base case : * there are no @xmath38 steps .",
    "this means that our term @xmath48 can not be reduced @xmath127 in this case , @xmath48 must be a variable ( or else substitution could not result in a type @xmath52 ) .",
    "so , @xmath128 for some variable @xmath45 , where @xmath129 .",
    "then we get : @xmath106    * step case : * there is at least one @xmath38 step .",
    "we proceed by case splitting on the form of @xmath48 .",
    "* case : * @xmath130 this case can not occur , since either @xmath124 , in which case we can not have @xmath131 for any type @xmath52 ; or else @xmath132 , and then @xmath133 .",
    "we can not have a @xmath38 step in that case , because types are normal forms for abstract reduction ( lemma  [ lem : tpnorm ] ) .",
    "* case : * @xmath134 the only possible step is @xmath135 , and we indeed have @xmath136 .",
    "the case for @xmath137 is similar .    *",
    "case : * @xmath138 in this case , the reduction sequence must be of the following form , for some mixed term @xmath49 and type @xmath70 , and some natural numbers @xmath139 and @xmath140 : @xmath141 where @xmath142 we are justified in assuming this , because there must be some first position in the reduction sequence from @xmath143 to @xmath52 where a descendant of @xmath143 is reduced .",
    "that descendant here is @xmath144 . in the reduction sequence",
    "prior to that point , we are assuming ( as noted at the start of the proof ) that steps occur in leftmost order , so the @xmath145 steps come first , and then the @xmath146 ones .",
    "now we can apply the induction hypothesis to ( 1 ) and ( 2 ) , which each have shorter length than the original reduction sequence .",
    "this gives us the premises of the following inference , which suffices to complete this case : @xmath147    * case : * @xmath148 in this case , we may assume the reduction sequence is of the following form , for some @xmath149 : @xmath150 \\gamma_{sub}\\ t ' ) \\to_a^ * ( t ' { \\rightarrow}t'')\\ ] ] where @xmath151 \\gamma_{sub}\\ t ' \\to_a^ * t''\\ ] ] this is because @xmath152 is itself an abstract redex , and since we are assuming our reduction is in leftmost , it must be reduced immediately .",
    "now we can apply the induction hypothesis on @xmath153 \\gamma_{sub}\\ t ' \\to_a^ * t''$ ] and get the premise of the following inference , which suffices to complete this case :    @xmath154",
    "in this section , we collect some abstract properties for @xmath38 and @xmath39 , from which type preservation and confluence of @xmath155 can be concluded . in subsequent sections",
    "we will instantiate these theorems with abstract and concrete reduction relations .",
    "for the first theorem , recall that in our setting @xmath38 computes the type of a term , or else could reach a stuck term like @xmath156 which does not correspond to a type .",
    "we want to speak about reductions that lead to types , so we need to phrase the following theorem in terms of some set @xmath157 , which we will instantiate later with a set of types . in condition ( 3 ) of the theorem , we interpose @xmath158 to restrict peaks to those objects which @xmath43-reduce to an object in @xmath157 .    [ thmtp ] assume    1 .",
    "@xmath159 ( that is , @xmath157 is a set of objects in normal form with respect to @xmath38 ) .",
    "2 .   @xmath38 is confluent .",
    "3 .   @xmath160 ; that is , for every @xmath83 such that there exists @xmath161 with @xmath162 , and every @xmath84 and @xmath163 with @xmath164 and @xmath165 , there exists a @xmath166 such that @xmath167 and either @xmath168 or @xmath169 .",
    "every normal form with respect to @xmath38 is also a normal form with respect to @xmath39 .    then if @xmath161 and @xmath170 , we have @xmath171 .",
    "let @xmath172 and @xmath173 , we have to prove that @xmath174 .",
    "we do this by induction on the number @xmath126 of steps in @xmath175 . in case",
    "we have @xmath177 . by ( 1 )",
    ", @xmath52 is a normal form with respect to @xmath38 , which is a normal form with respect to @xmath39 due to ( 4 ) .",
    "so @xmath173 is not possible , and the claim holds trivially .    for the induction step assume @xmath87 for which @xmath178 . applying ( 3 ) now yields @xmath179 such that @xmath180 and either @xmath181 or @xmath182 . in case",
    "@xmath181 we apply the induction hypothesis on @xmath183 and conclude @xmath184 . in case",
    "@xmath182 we apply confluence of @xmath38 ( 2 ) by which @xmath52 and @xmath179 have a common @xmath38-reduct . as @xmath52 is a normal form with respect to @xmath38 by ( 1 ) , we conclude @xmath184 , concluding the proof .",
    "[ lem : extendac ] suppose @xmath38 and @xmath39 are binary relations such that    1 .",
    "@xmath38 is confluent , and 2",
    ".   @xmath185 .",
    "then we also have @xmath186    assume @xmath187 and @xmath188 ; we have to find @xmath189 such that @xmath190 and @xmath191",
    ". we do this by induction on @xmath126 . for @xmath176",
    "we choose @xmath192 . for @xmath9 write @xmath193 . by ( 2 )",
    "an element @xmath194 exists such that @xmath195 and either @xmath196 or @xmath197 .",
    "if @xmath196 we apply ( 1 ) yielding @xmath189 satisfying @xmath198 and @xmath199 and we are done . if @xmath197 then we apply the induction hypothesis yielding @xmath200 and @xmath199 .",
    "[ thmcr ] let @xmath38 and @xmath39 be binary relations ( recall from section  [ sec : rewriting - prelim ] that we write @xmath40 for @xmath201 ) .",
    "assume    1 .",
    "@xmath38 is terminating , 2 .",
    "@xmath38 is confluent , 3 .",
    "@xmath185 , and 4 .",
    "every normal form with respect to @xmath38 is also a normal form with respect to @xmath39 .",
    "then @xmath40 is confluent .    by lemma  [ lem : extendac ]",
    ", we have : @xmath202 now let @xmath203 and @xmath204 ; for proving the theorem we have to prove that @xmath189 exists satisfying @xmath205 and @xmath206 .",
    "choose @xmath189 to be a @xmath38-normal form of @xmath48 , which exists due to ( 1 ) .",
    "assume @xmath207 ; we will prove that @xmath198 by induction on @xmath126 .",
    "for @xmath208 this follows from @xmath209 . for @xmath9 let @xmath210 . from the induction hypothesis",
    "we conclude @xmath211 . combining ( 2 ) and @xmath212 yields",
    "@xmath213 so since @xmath214 we conclude that @xmath215 exists satisfying @xmath216 or @xmath217 , and @xmath218 . since @xmath189 is not only a @xmath38-normal form , but also a @xmath39-normal form according to ( 4 ) , we conclude @xmath219 .",
    "hence @xmath220 , concluding the proof of @xmath198 . applying the same argument on @xmath204 we conclude @xmath191 , concluding the proof of the theorem .    one may wonder whether the requirement of termination is essential for theorem [ thmcr ] .",
    "it is : on the set @xmath221 the relations @xmath222 and @xmath223 satisfy all requirements of theorem [ thmcr ] , while @xmath40 is not confluent .",
    "one may wonder whether in theorem [ thmcr ] the condition ( 4 ) on normal forms is essential .",
    "it is , even if not only @xmath38 is terminating and confluent but also @xmath39 , as is shown by the following example of relations on 10 elements , in which @xmath38 steps are denoted by dashed arrows and @xmath39 steps are denoted by solid arrows .",
    "( 0,0)(10,4 ) ( 1.3,3.2 ) ( 0,2 ) ( 5,4 ) ( 6,2 ) ( 7.7,2.5 ) ( 2.3,1.5 ) ( 4,2 ) ( 5,0 ) ( 10,2 ) ( 8.7,0.8 )    in this example there are two convertible normal forms , so the union is not confluent , and both @xmath38 and @xmath39 are both confluent and terminating ; @xmath38 is even deterministic .",
    "also condition @xmath224 of theorem [ thmcr ] is easily checked , even stronger : @xmath225 .",
    "this example was found using a sat solver .",
    "a direct encoding of the example to be looked for run out of resources .",
    "however , by adding a symmetry requirement , was observed on the first example , the sat solver yielded a satisfying assignment that could be interpreted as a valid example . the example given above was obtained from this after removing some redundant arrows .",
    "independently , bertram felgenhauer found an example that could be simplified to exactly the same example as given here .",
    "this remarkable example was the starting point of developing the tool carpa by which such examples can be found fully automatically .",
    "we now prove type preservation for full @xmath2-reduction ( the @xmath39 relation of section  [ sec : restlc ] ) , based on the rewriting formulation .",
    "this is in contrast to the results of kuan et al .",
    ", who obtain type preservation for the rewriting approach as a corollary of type preservation based on a standard big - step notion of typing ( and the relation of that notion of typing with the small - step notion ) .",
    "a mixed term @xmath83 is called * typable * if @xmath226 for some type @xmath52 .",
    "if we translate our standard statement of type preservation ( at the beginning of section  [ sec : basicmeta ] ) so that it uses abstract reduction instead of the usual typing relation , we have the following .    [ thm : presstlc ] let @xmath227 be mixed terms and @xmath52 be a type .",
    "if @xmath172 and @xmath173 , then @xmath228 .    the proof of this theorem",
    "is given by applying theorem [ thmtp ] : we need to check its conditions ( 1 ) , ( 2 ) , ( 3 ) and ( 4 ) .",
    "we instantiate the set @xmath157 in condition ( 1 ) with the set of types @xmath52 , which are normal forms by lemma  [ lem : tpnorm ] .",
    "condition ( 2 ) follows from lemma [ lem : confl ] .",
    "condition ( 4 ) is immediate from the definitions of @xmath38 and @xmath39 : if @xmath39 applies on a term @xmath48 , then @xmath48 either contains @xmath229 via rule @xmath230 by which @xmath38 applies via @xmath231 , or @xmath48 contains @xmath232 $ ] via rule @xmath233 by which @xmath38 applies via @xmath121 .",
    "so it remains to check condition ( 3 ) , which follows from the following lemma .",
    "[ lem : beta ] let @xmath234 be a typable mixed term and let @xmath235 be mixed terms such that @xmath236 and @xmath237 . then a mixed term @xmath238 exists such that @xmath239 and either @xmath181 or @xmath182 .",
    "furthermore , if the step from @xmath234 to @xmath92 is a call - by - value step , so is the step from @xmath91 to @xmath179 .",
    "we distinguish the ways the redexes in @xmath234 are related .",
    "if the redexes of @xmath236 and @xmath237 are parallel , then @xmath179 can be chosen such that @xmath181 and @xmath240 ( preserving whether or not the @xmath241-step is call - by - value ) .",
    "if the redex of @xmath236 is above the redex of @xmath242 , then the @xmath38 step is either of the type @xmath90 or @xmath121 , in which the @xmath39 acts on the mixed term @xmath83 as it occurs in the rule @xmath90 or @xmath121 . as this @xmath83",
    "is not duplicated , we get @xmath179 such that @xmath181 and @xmath243 ( and the step @xmath244 is not call - by - value ) .    if the redex of @xmath236 is below the redex of @xmath242 , then some further case analysis is required .",
    "if there is no overlap , then @xmath179 can be chosen such that @xmath181 ( preserving being call - by - value ) and @xmath239 .    if there is overlap and @xmath236 is an application of @xmath231 or @xmath245 , then @xmath246 $ ] and @xmath247 $ ] , and @xmath179 can be chosen to be @xmath248 $ ] , satisfying @xmath249 and @xmath240 .",
    "the remaining case is illustrated by the following picture :    ( 0,1.5 ) node(t ) @xmath250 $ ] ; ( -2.5,0 ) node(sa ) @xmath251m)\\ m']$ ] ; ( 2.5,0 ) node(sb ) @xmath252m]$ ] ;    \\(t )  node[left=1pt , very near end]@xmath43 ( sa ) ; ( t )  node[left=1pt , very near end]@xmath241 ( sb ) ;    ( -2.5,-1.5 ) node ( saa ) @xmath253m)\\ t]$ ] ; ( 0,-3 ) node ( b ) @xmath254m]$ ] ;    ( sb ) ",
    "node[right=2pt ] _ since _  @xmath228 node[left=1pt , very near end]@xmath43 node[right=1pt , very near end ] * ( b ) ; ( sa )  node[left=2pt ] _ since",
    "_  @xmath228 node[left=1pt , very near end]@xmath43 node[right=1pt , very near end ] * ( saa ) ; ( saa ) ",
    "node[left=1pt , very near end]@xmath43",
    "( b ) ;    the picture already shows that by choosing @xmath255m]$ ] we obtain @xmath182 and @xmath239 if we can prove @xmath228 .",
    "for doing so we use the assumption that @xmath234 is typable : there exists a type @xmath256 such that @xmath250 \\to_a^ * t'$ ] . since @xmath256 is a type it does not contain a @xmath42 symbol , so somewhere in this reduction the @xmath42 in @xmath257 should be removed . by inspecting the rules we see that this can only be done by the rule @xmath121 by which @xmath258 is replaced by @xmath259 .",
    "next the ( invisible ) application symbol in @xmath260 should be removed .",
    "this can only be done by the rule @xmath90 .",
    "this rule is only applicable if first @xmath84 is rewritten by @xmath38 steps to @xmath52 , indeed proving @xmath228 .",
    "[ prop : confstlch ] the relation @xmath261 is confluent",
    ".    we will apply theorem [ thmcr ] . for this",
    ", we need to check properties ( 1 ) to ( 4 ) for the particular relations @xmath262 and @xmath263 .",
    "property ( 2 ) follows from theorem [ lem : confl ] and the fact that @xmath264 is the identity relation .",
    "all peaks must be of the form @xmath265 , due to the composition with @xmath264 . by theorem [ lem : confl ] , if @xmath266 , then there exists @xmath179 such that @xmath267 .",
    "thus , any @xmath262 peak @xmath268 can be completed with @xmath269 .",
    "likewise , by theorem [ thm : termabstr ] @xmath38 is terminating , so @xmath270 is also terminating , proving property ( 1 ) . property ( 3 )",
    "follows from lemma [ lem : beta ] .",
    "so it remains to prove property ( 4 ) .",
    "this is immediate from the definitions of @xmath38 and @xmath39 : if @xmath39 applies on a term @xmath48 , then @xmath48 either contains @xmath229 via rule @xmath230 by which @xmath38 applies via @xmath231 , or @xmath48 contains @xmath271 via rule @xmath272 by which @xmath38 applies via @xmath121 .",
    "[ prop : confstlc ] every typable mixed term is confluent with respect to the reduction relation @xmath40 .",
    "confluence of the set of typable mixed terms is equivalent to confluence of the relation @xmath273 , which is easily seen to be equal to @xmath274 by theorem  [ prop : confstlch ] , the latter relation is confluent .",
    "a form of typability is essential , since the relation @xmath40 is not confluent in general , as kuan et al .",
    "note also in their setting .",
    "for instance , the non - typable term @xmath275 has two distinct normal forms @xmath276",
    "in this section , we complete the basic meta - theory for stlc by proving progress and type safety theorems for call - by - value reduction ( the @xmath73 relation of section  [ sec : restlc ] ) . lemmas  [ lem : cac ] and  [ lem : stuck ] are stated in a somewhat more general way , so that we can also use them to show type safety for the generalized form of typability we will consider in section  [ sec : genpresstlc ] .",
    "we begin by inductively defining the set of * quasi - stuck * terms @xmath157 , in figure  [ fig : qs ] .",
    "also , let us call a quasi - stuck term which is not a value * stuck*. the purpose of these definitions is to generalize a characterization of @xmath277-normal standard terms to mixed terms ( lemmas  [ lem : qsnf ] and  [ lem : qsnfb ] , proved next ) , in such a way that we can show that the set of quasi - stuck terms is closed under abstract reduction ( lemma  [ lem : redqs ] , proved below ) .",
    "this will allow us to prove that typable quasi - stuck terms must be values ( lemma  [ lem : stuck ] ) , from which we easily obtain the desired main theorems of progress and type safety .",
    "@xmath1    mixed values @xmath278 are in @xmath157 .",
    "terms of the form @xmath279 or @xmath280 are in @xmath157 if @xmath281 .",
    "terms of the form @xmath282 or @xmath283 are in @xmath157 if @xmath281 and @xmath284 is neither @xmath43 nor @xmath15",
    ".    terms of the form @xmath285 or @xmath286 are in @xmath157 if @xmath281 and @xmath284 is not a mixed value .",
    "terms of the form @xmath287 are in @xmath157 if @xmath288 and @xmath284 is not a mixed value .",
    "[ lem : qsnf ] if @xmath83 is quasi - stuck , then @xmath289 .",
    "the proof is by an easy structural induction on @xmath83 , using the definition of quasi - stuck .",
    "[ lem : qsnfb ] if standard term @xmath48 is closed and @xmath290 , then @xmath48 is quasi - stuck .",
    "the proof is by structural induction on @xmath48 . if @xmath48 is a ( standard ) value it is quasi - stuck , and it can not be a variable since @xmath48 is closed .",
    "so suppose it is an application @xmath143 .",
    "since @xmath145 is closed , @xmath145 can not be a variable .",
    "we consider now the remaining possibilities .",
    "it could be that @xmath145 is @xmath43 and @xmath146 is some other @xmath277-normal form . then by the induction hypothesis ,",
    "@xmath146 is quasi - stuck , and @xmath48 is , too , using the second clause above in the definition of quasi - stuck terms .",
    "next , we could have the situation where @xmath145 is @xmath44 , and @xmath146 is any @xmath277-normal form except @xmath43 .",
    "then by the induction hypothesis , @xmath146 is quasi - stuck , and @xmath48 is , too , using the third clause in the definition of quasi - stuck terms .",
    "next , we could have that @xmath145 is a @xmath42-abstraction , and @xmath146 is any @xmath277-normal form except a standard value . then by the induction hypothesis , @xmath146 is quasi - stuck , and it can not be a mixed value other than a standard value , because @xmath146 is a standard term .",
    "so @xmath48 is quasi - stuck , too , using the fourth clause .",
    "finally , if @xmath145 is some application , then by the induction hypothesis , @xmath145 and @xmath146 are both quasi - stuck .",
    "since @xmath145 is not a value , the fifth clause above gives us that @xmath48 is quasi - stuck .",
    "[ lem : redqs ] if @xmath83 is quasi - stuck , and @xmath85 , then @xmath84 is also quasi - stuck . furthermore , if @xmath83 is a mixed value , then so is @xmath84 ; and if @xmath83 is not a mixed value , then neither is @xmath84 .",
    "the proof is by structural induction on @xmath83 .",
    "suppose @xmath83 is a mixed value .",
    "then it is easy to see by inspection of the reduction rules that @xmath84 must be , too .",
    "so suppose @xmath83 is of the form @xmath279 or @xmath280 with @xmath281 .",
    "then either the assumed reduction is of the form @xmath291 , or else of the form @xmath292 or @xmath293 . in the former case ,",
    "the resulting term is a quasi - stuck non - value . in the latter",
    ", we may apply the induction hypothesis to conclude that @xmath163 is quasi - stuck , and hence @xmath294 ( or @xmath295 ) is a quasi - stuck non - value .",
    "if @xmath83 is of the form @xmath282 or @xmath283 , where @xmath281 and @xmath284 is not @xmath43 or @xmath15 , then either the assumed reduction is of the form @xmath296 or else @xmath297 or @xmath298 . in the former case ,",
    "the resulting term is a quasi - stuck non - value , by the third clause of the definition of quasi - stuck terms above . in the latter ,",
    "if @xmath284 is not a value , we again use our induction hypothesis to conclude that @xmath163 is a quasi - stuck non - value , and hence not @xmath43 or @xmath15 .",
    "so @xmath84 is a quasi - stuck non - value , too .",
    "if @xmath284 is a value , then so is @xmath163 , and reduction can not turn a value other than @xmath43 into @xmath43 or @xmath15 .",
    "so again , @xmath163 has the required form to be a quasi - stuck non - value .",
    "suppose @xmath83 is of the form @xmath299 or @xmath300 , with @xmath281 and @xmath284 not a mixed value",
    ". then either the assumed reduction is of the form @xmath301m'')\\ s$ ] ; or else of the form @xmath302 or @xmath303 ; or else of the form @xmath304 or @xmath305 . in the first two cases , the resulting term still has the required form to be a quasi - stuck non - value . in the third case ,",
    "we know @xmath284 is not a value by the definition of quasi - stuck terms , so we may use our induction hypothesis to conclude that @xmath166 is a quasi - stuck non - value , which is sufficient to conclude that the resulting term is again stuck .",
    "finally , suppose @xmath83 is of the form @xmath306 , where @xmath91 is not a mixed value .",
    "then the assumed reduction must be of the form either @xmath307 or else @xmath308 , for some @xmath309 with @xmath310 , or else some @xmath311 with @xmath312 .",
    "this is because , by inspection of the reduction rules , @xmath83 itself can not be a redex if @xmath91 is not a mixed value . in the former case , we may apply the induction hypothesis to conclude that @xmath309 is a quasi - stuck non - value , and hence so is @xmath84 . in the latter , we may apply the induction hypothesis to conclude that @xmath311 is quasi - stuck , and hence so is @xmath84 .",
    "[ lem : cac ] if @xmath83 is quasi - stuck ( including the case where @xmath83 is a closed mixed value ) , and @xmath313 , then @xmath172 .",
    "the proof is by induction on the length of the reduction sequence from @xmath83 to @xmath52 .",
    "if this length is @xmath314 , the result obviously holds .",
    "so suppose we have @xmath315 .",
    "since @xmath83 is quasi - stuck , we have @xmath289 by lemma  [ lem : qsnf ] .",
    "so it must be the case that @xmath85 .",
    "since @xmath84 is quasi - stuck by lemma  [ lem : redqs ] , we may apply our induction hypothesis to conclude @xmath228 , and hence @xmath316 .",
    "[ lem : stuck ] suppose @xmath83 is a closed quasi - stuck term .",
    "suppose further that @xmath317 .",
    "then @xmath83 is a mixed value .",
    "the proof is similar to the previous one , and proceeds by induction on the length of the reduction sequence from @xmath83 to @xmath52 .",
    "if this length is @xmath314 , the result holds , since types are mixed values .",
    "so suppose we have @xmath318 .",
    "since @xmath83 is quasi - stuck , we have @xmath289 by lemma  [ lem : qsnf ] .",
    "so it must be the case that @xmath85 .",
    "we now consider cases on the form of @xmath83 . if @xmath83 is a mixed value the result holds .",
    "so suppose it is a non - value .",
    "then by lemma  [ lem : redqs ] , @xmath84 must also be a quasi - stuck non - value , and we may apply the induction hypothesis to derive a contradiction .",
    "armed with the concept of quasi - stuck terms and its associated lemmas , we can now obtain the main results of this section .    [ thm : progstlc ] if standard term @xmath48 is closed , @xmath319 , and @xmath290 , then @xmath48 is a ( standard ) value .    by lemma  [ lem : qsnfb ] and the assumption @xmath290 ,",
    "we know @xmath48 is quasi - stuck .",
    "now since our assumption that @xmath319 implies @xmath320 , we can apply lemma  [ lem : stuck ] to conclude that @xmath48 is a mixed value ( and hence a standard value , since @xmath48 is a standard term ) .",
    "[ thm : safety ] if standard term @xmath48 is closed , @xmath319 , and @xmath321 , then @xmath83 is a standard value .",
    "the proof is by induction on the length of the reduction sequence from @xmath48 to @xmath83 . in the base case",
    ", we apply theorems  [ thm : progstlc ] , since we have @xmath322 in that case . for the step case , suppose we have @xmath323 . in this case , we can apply theorem  [ thm : presstlc ] to conclude @xmath324 .",
    "it is easily proved by induction on the structure of call - by - value evaluation contexts @xmath75 that if we have @xmath325 , then @xmath84 is a standard term @xmath49 .",
    "we may now apply the induction hypothesis , since we have @xmath326 and @xmath327 .",
    "in this section , we show how automated tools for analyzing term - rewriting systems can be applied to automate part of the proof of type preservation .",
    "we will consider a language , which we call uniform - stc , that does not distinguish terms and types syntactically .",
    "advanced type systems like pure type systems must often rely solely on the typing rules to distinguish terms and types ( and kinds , superkinds , etc . )  @xcite . in uniform - stc , we explore issues that arise in applying the rewriting approach to more advanced type systems .",
    "we must now implement kinding ( i.e. , type checking of types ) as part of the abstract reduction relation .",
    "we adopt a combinatory formulation so that the abstract reduction relation can be described by a first - order term - rewriting system .",
    "@xmath328    @xmath329 \\to_c e_c[u\\ u''\\ ( u'\\ u'')]}{\\ } \\\\ \\\\",
    "\\textit{c}(\\beta\\textit{-k } ) . \\!\\!&\\!\\ !   \\infer{e_c[k\\langle",
    "t_1,t_2\\rangle\\ u\\ u ' ] \\to_c e_c[u]}{\\ } \\\\",
    "\\\\    \\textit{a}(s ) .",
    "\\!\\!&\\!\\ !",
    "s\\langle t_1,t_2,t_3\\rangle \\to_a \\textit{kind}(t_1,\\textit{kind}(t_2,\\textit{kind}(t_3 , ( t_1{\\rightarrow}t_2 { \\rightarrow}t_3 ) { \\rightarrow}(t_1{\\rightarrow}t_2 ) { \\rightarrow}(t_1 { \\rightarrow}t_3 ) ) ) )    \\\\    \\textit{a}(k ) . \\!\\!&\\!\\ !",
    "k\\langle t_1,t_2\\rangle \\to_a \\textit{kind}(t_1,\\textit{kind}(t_2,(t_1{\\rightarrow}t_2 { \\rightarrow}t_1 ) ) )",
    "\\\\    \\textit{a}(\\beta ) . \\!\\!&\\!\\ !   ( t_1{\\rightarrow}t_2)\\ t_1 \\to_a \\textit{kind}(t_1,t_2 )    \\\\    \\textit{a}(\\textit{k-}{\\rightarrow } ) . \\!\\!&\\!\\ !   \\textit{kind}((t_1 { \\rightarrow}t_2 ) , t ) \\to_a \\textit{kind}(t_1,\\textit{kind}(t_2,t ) )    \\\\    \\textit{a}(\\textit{k - a } ) . & \\textit{kind}(a , t ) \\to_a t    \\end{array}\\ ] ]    figure  [ fig : unified - syntax ] shows the syntax for the uniform - stc language .",
    "there is a single syntactic category @xmath48 for mixed terms and types , which include a base type @xmath15 and simple function types . @xmath330 and @xmath331 are the usual combinators , indexed by terms which determine their simple types .",
    "the _ kind _ construct for terms is used to implement kinding .",
    "the rules for concrete and abstract reduction are given in figure  [ fig : uni - rules ] .",
    "the concrete rules are just the standard ones for call - by - value reduction of combinator terms . for abstraction reduction",
    ", we are using first - order term - rewriting rules ( unlike for previous systems ) .    for stlc ( section  [ sec : presstlc ] ) , abstract @xmath2-redexes have the form @xmath332 . for uniform - stc ,",
    "since there is no syntactic distinction between terms and types , abstract @xmath2-redexes take the form @xmath333 , and we must use kinding to ensure that @xmath145 is a type .",
    "this is why the @xmath90 rule introduces a _",
    "we also enforce kinding when abstracting simply typed combinators @xmath330 and @xmath334 to their types . the rules for",
    "_ kind_-terms ( @xmath335 and @xmath336 ) make sure that the first term is a type , and then reduce to the second term .    here",
    ", we define typability by value @xmath278 to mean abstract reduction to @xmath278 where @xmath278 is _ kindable _ , which we define as @xmath337 . this definition avoids the need to define types syntactically .    following the methodology embodied in theorem  [ thmtp ]",
    ", we must first prove the abstract reduction is confluent .",
    "in fact , it is convergent , and we can apply analysis tools to determine this , as shown in the next two theorems .    [",
    "uni - term ] the term rewriting system @xmath38 is terminating .",
    "the automated termination checker aprove reports that the rewrite system for @xmath38 is terminating , using a recursive path ordering  @xcite .",
    "[ uni - confluent ] the term rewriting system @xmath38 is confluent .",
    "abstract reduction for uniform - stc does not have the diamond property due to the non - left - linear rule @xmath90 , where there could indeed be redexes in the expressions matching the repeated variable @xmath145 . by theorem  [ uni - term ] , however , we can apply newman s lemma to conclude confluence from local confluence .",
    "local confluence follows because all the @xmath338-peaks can be joined using either one @xmath43-step on either side as for stlc , or else using additional balancing steps if one of the rules applied is @xmath90 .",
    "but even easier than this reasoning is applying an automated confluence checker : the acp tool immediately reports that the abstract reduction relation is confluent  @xcite .",
    "the proofs of theorems  [ uni - term ] and  [ uni - confluent ] demonstrate how the rewriting approach to typing benefits from recent advances in analysis tools for term rewriting : we can use termination and confluence checkers to analyze the abstract reduction relation @xmath38 corresponding to typing .",
    "we expect this situation to recur for more advanced type systems , although some may provide new challenges for automated analysis tools ( we give an example below ) .",
    "[ uni - complete ] @xmath339 .",
    "we distinguish the peaks originating at typable terms @xmath48 .",
    "if @xmath340 and @xmath73 steps are parallel  @xmath341 \\leftarrow_a e_c[t ] \\leftarrow_{id } e_c[t ] \\to_{id } e_c[t ] \\to_c e_c[t']$ ]  the peak can be completed directly @xmath341 \\to_{id } e'_c[t ] \\to_c e'_c[t ' ] \\leftarrow_a e_c[t ' ] \\leftarrow_{id } e_c[t']$ ] .    if the @xmath340 and @xmath73 steps overlap , there are two cases , corresponding to @xmath342 and @xmath343 reduction steps .",
    "we show the completion for @xmath342 peaks ( omitting the @xmath344 steps to simplify the presentation ) ; the argument for @xmath343 peaks is similar .",
    "@xmath345 \\leftarrow_a e_c[(k\\langle t_1,t_2\\rangle\\ t\\ t ' ) ] \\to_a e_c[t]\\\\ l. & e_c[u[(\\hat{t}\\ t\\ t ' ) ] ] \\to_a^ *   e_c[u[(\\hat{t}\\ t_1\\ t '' ) ] ] \\to_a e_c[u[((t_2{\\rightarrow}t_1)\\ t '' ) ] ] \\to_a^*\\\\ \\ & e_c[u[((t_2{\\rightarrow}t_1)\\ t_2 ) ] ] \\to_a e_c[\\textit{kind}(t_1,\\textit{kind}(t_2,t_1 ) ) ] \\to_a^ * e_c[t_1 ] \\\\",
    "r. & e_c[t ] \\to_a^ *   e_c[t_1 ] \\end{array}\\ ] ]    the @xmath117-steps are justified because the peak term ( shown on line ( p ) ) is typable by composition with @xmath158 . by confluence of abstract reduction , this implies that the sources of all the left steps are also typable . for each @xmath117-step , since abstract reduction can not drop redexes ( as all rules are non - erasing ) , we argue as for stlc that a descendant of the appropriate displayed _ kind_-term or application must eventually be contracted , as otherwise , a stuck descendant of such would remain in the final term .",
    "kindable terms can not contain stuck applications or stuck _ kind_-terms , because our abstract reduction rules are non - erasing . and contraction of those displayed _ kind_-terms or applications requires the reductions used for the @xmath117-steps , which are sufficient to complete the peak .",
    "[ uni - normal ] every normal form with respect to @xmath38 is also a normal form with respect to @xmath39 .",
    "the normal forms of @xmath38 include @xmath15 , @xmath346 where @xmath145 and @xmath146 are @xmath43-normal forms , @xmath347 where @xmath348 , and @xmath349 where @xmath145 is not generated by the grammar @xmath350 . by inspection , @xmath351 \\not\\to_c$ ] and",
    "@xmath352 \\not\\to_c$ ] .",
    "[ thm : presuni ] let @xmath227 be mixed terms and @xmath52 be a term such that @xmath353 . if @xmath172 and @xmath354 , then @xmath228 .    by application of theorem  [ thmtp ] .",
    "condition ( 1 ) is satisfied by instantiating @xmath157 by the set of terms @xmath355 .",
    "condition ( 2 ) follows by theorem  [ uni - confluent ] .",
    "condition ( 3 ) by lemma  [ uni - complete ] , condition ( 4 ) by lemma  [ uni - normal ] .",
    "[ uni - combined - confluent ] every mixed typable term is confluent with respect to the reduction relation @xmath356 .    for proving that @xmath40 is confluent for typable mixed terms we need to check properties ( 1 ) to ( 4 ) of theorem [ thmcr ] for the particular relations @xmath357 and @xmath358 .",
    "the composition of @xmath38 and @xmath39 with @xmath158 serves to ensure that we are only considering typable terms .",
    "property ( 2 ) follows from theorem [ uni - confluent ] and the fact that @xmath264 is the identity relation .",
    "all 1-step peaks of must be of the form @xmath359 , due to the composition with @xmath264 . by theorem [ uni - confluent ] , if @xmath266 , then there exists @xmath179 such that @xmath267 .",
    "thus , any @xmath262 peak @xmath265 can be completed with @xmath360 . by theorem",
    "[ uni - term ] @xmath38 is terminating , so @xmath361 is also terminating , proving property ( 1 ) . property ( 3 ) follows from lemma [ uni - complete ] .",
    "property ( 4 ) follows from lemma  [ uni - normal ] .    as an aside ,",
    "note that a natural modification of this problem is out of the range of acp , version 0.20 .",
    "suppose we are trying to group kind - checking terms so that we can avoid duplicate kind checks for the same term .",
    "for this , we may wish to permute _",
    "kind_-terms , and pull them out of other term constructs .",
    "the following rules implement this idea , and can be neither proved confluent nor disproved by acp , version 0.20 .",
    "just the first seven rules are also unsolvable by acp .",
    ".... ( var a b c a b c d ) ( rules    s(a , b , c ) - > kind(a , kind(b , kind(c ,                arrow(arrow(arrow(a , arrow(b , c)),arrow(a , b)),arrow(a , c ) ) ) ) )    k(a , b ) - > kind(a , kind(b , arrow(a , arrow(b , a ) ) ) )    app(arrow(a , b),a ) - > kind(a , b )    kind(base , a ) - > a    kind(arrow(a , b),a ) - > kind(a , kind(b , a ) )    kind(a , kind(a , a ) ) - > kind(a , a )    kind(a , kind(b , a ) ) - > kind(b , kind(a , a ) )    app(kind(a , b),c ) - > kind(a , app(b , c ) )    app(c , kind(a , b ) ) - > kind(a , app(c , b ) )    arrow(kind(a , b),c ) - > kind(a , arrow(b , c ) )    arrow(c , kind(a , b ) ) - > kind(a , arrow(c , b ) )    kind(kind(a , b),c ) - > kind(a , kind(b , c ) ) ) ....",
    "martin - lf s intuitionistic type theory ( itt ) , as formulated in  @xcite , is a system of four judgments presented with a rigorous but informal semantics .",
    "a typing judgment of the form @xmath362 `` means that @xmath43 has a canonical object of the canonical type denoted by a as value ''  @xcite . here , martin - lf is making use of the concept of a term ( of itt ) having a value , a concept he defines earlier in the paper .",
    "the authors of the nuprl system realized that this semantics justifies more permissive typing rules than allowed by martin - lf s own formal systems  @xcite ( see also section 2.2 of  @xcite for a historical perspective ) .",
    "in particular , it justifies so - called _ direct computation _ rules , which turned out to be useful for formal development with nuprl : @xmath363 applying theorem  [ thm : relatetyp ] , we can view this rule from a rewriting perspective .",
    "we will use call - by - value reduction , as full @xmath2-reduction would require additional technicalities that would not be illuminating ( we would have to use parallel reduction and incorporate a proof of confluence of @xmath2-reduction , in order to get preservation of generalized typing ) .",
    "@xmath364 in this section , we will take the idea of nuprl s direct computation rules one step further , by adopting the following definition .",
    "a mixed term @xmath83 is called * generalized typable * if @xmath313 for some type @xmath52 .",
    "this allows us to view ( call - by - value versions of ) nuprl s direct computation rules as embodying a special case of generalized typability , namely @xmath365 .",
    "we will see in this section that we can prove type preservation directly for generalized typing , using the rewriting approach .",
    "note that generalized typability is not obviously decidable , since @xmath74 is not terminating    a simple example of generalized typability is given by the term @xmath366 .",
    "note that the argument term @xmath367 is not simply typable .",
    "this term has several @xmath368-reduction sequences , including the following one : @xmath369 because this term @xmath368-reduces to a type , the generalized type - safety property we will obtain in this section tells us that the @xmath277-normal form of this term , if such exists , is a value .",
    "this can , of course , be confirmed for this case , where the @xmath277-normal form is just @xmath370 .",
    "notice that this example also shows that @xmath74 is not confluent , as we can also reduce it to a stuck term in this way : @xmath371    [ thm : genpresstlc ] if @xmath317 and @xmath354 , then @xmath372",
    ".    we can not conveniently apply theorem  [ thmtp ] , because the natural instantiation would be to take @xmath74 for the relation @xmath38 in the theorem ",
    "but then we would have to prove confluence of @xmath74 , which does not hold ( as shown just above ) .",
    "so instead we give a direct proof , by induction on the length of the assumed @xmath373-sequence from @xmath83 to @xmath52 .",
    "the sequence can not be of length @xmath314 , since @xmath83 can not be a type ( since it @xmath277-reduces , as no type can ) .    for the step case",
    ": suppose the assumed @xmath368-reduction is of the form @xmath374 .",
    "we now consider cases for the form of overlap of the step @xmath375 and @xmath354 .",
    "suppose the @xmath277-step is @xmath376\\to_c e_c[a]$ ] .",
    "if the @xmath43-step is in @xmath75 , that means @xmath377 $ ] , where the hole in @xmath75 is at the same position as in @xmath378 .",
    "we can just permute these steps , to obtain @xmath379\\to_a e_c'[a]$ ] and @xmath380\\to_c e_c'[a]$ ] . now",
    "the induction hypothesis can be applied with @xmath380 $ ] ( i.e. , @xmath163 ) as the peak term , and @xmath381 $ ] as the term to which it @xmath277-steps .",
    "so suppose the @xmath43-step is in the displayed @xmath57 of @xmath376 $ ] .",
    "then before the reduction sequence from @xmath163 to @xmath52 can perform a @xmath277-step , it must first reduce the residual of @xmath57 to @xmath15 , since that residual occurs in a @xmath277-reduction position .",
    "so the reduction sequence from @xmath163 to @xmath52 must look like the following , where the hole in @xmath75 and in @xmath378 are at the same position : @xmath382 \\to_{ca}^ * t\\ ] ] by performing the @xmath43-reductions which transformed @xmath75 to @xmath378 , we can reduce @xmath379 $ ] to @xmath383 $ ] , and then we are done , since we then have @xmath384\\to_{ca}^ * t$ ] .",
    "we now must consider the case where the @xmath277-step is @xmath385\\to_c e_c[[u / x]m_1]$ ] .",
    "again , if the @xmath43-step is in @xmath75 , we can permute steps and apply the induction hypothesis .",
    "if the @xmath43-step is in @xmath91 or in @xmath278 , we can also permute the steps , though if the reduction is in @xmath278 ( say @xmath386 ) , we will in general have @xmath387m_1]\\to_a^ * e_c[[u'/x]m_1]$ ] , since @xmath45 need not appear exactly once in @xmath91 .",
    "nevertheless , we can still apply the induction hypothesis with @xmath163 as the peak term , since we will only ever produce one @xmath277-step from @xmath163 by permuting steps .",
    "finally , suppose the @xmath43-step is @xmath388\\to_a e_c[(t'{\\rightarrow}[t'/x]m_1)\\ u]$ ] .",
    "by similar reasoning as in the previous case , the @xmath368-reduction sequence from @xmath389m_1)\\ u]$ ] to @xmath52 may contain @xmath43-steps transforming @xmath75 to some @xmath378 , but it can not take a @xmath277-step until it has reduced the displayed @xmath390m_1)\\ u$ ] to @xmath153m_1'$ ] , with @xmath391 and @xmath392 .",
    "this is because that displayed term is in @xmath277-reduction position and neither a value nor a redex .",
    "we can then duplicate any @xmath43-steps taken in @xmath75 to @xmath43-reduce @xmath387m_1]$ ] ( i.e. , @xmath84 ) to @xmath393m_1']$ ] .",
    "this term then @xmath373-reduces to @xmath52 , and we are done .",
    "[ thm : genprogstlc ] if standard term @xmath48 is closed , @xmath394 , and @xmath290 , then @xmath48 is a ( standard ) value .    as for theorem",
    "[ thm : progstlc ] , we obtain this result by applying lemmas  [ lem : qsnfb ] and  [ lem : stuck ] .",
    "[ thm : gensafety ] if standard term @xmath48 is closed , @xmath394 , and @xmath395 , then @xmath49 is a ( standard ) value .",
    "this is a direct corollary of theorems  [ thm : genpresstlc ] and  [ thm : genprogstlc ] .",
    "in this section , we will see how the rewriting approach to typing impacts a standard approach to proving that every typable ( closed ) standard term of the simply typed lambda calculus has a @xmath241-normal form .",
    "we will work with a slightly different presentation of stlc than we saw in section  [ sec : restlc ] , in particular dispensing with the term constants @xmath43 and @xmath44 .",
    "we assume a non - empty set of type constants @xmath15 .",
    "the syntax we are using in this section is :    @xmath396    the abstract and concrete reduction relations are then defined as follows , where we use mixed terms @xmath83 as contexts ( sometimes using meta - variable @xmath397 in this case ) , writing @xmath398 $ ] to denote the replacement of the unique occurrence of a special variable @xmath399 in @xmath83 by @xmath84 .",
    "@xmath400{\\hat{m}[(\\lambda x : t.\\,m)\\ m']\\ \\to_b\\ \\hat{m}[[m'/x]m]}{\\ } \\\\\\\\",
    "\\infer[\\textit{a}(\\beta)]{\\hat{m}[(t { \\rightarrow}m)\\ t]\\ \\to_a\\ \\hat{m}[m]}{\\ } \\\\\\\\ \\infer[\\textit{a}(\\lambda)]{\\hat{m}[\\lambda x : t.\\ , m]\\ \\to_a\\ \\hat{m}[t{\\rightarrow}[t / x]m]}{\\ } \\end{array}\\ ] ]      the proof in this section is based on ideas from standard proofs , such as girard s proof in the book _ proofs and types _",
    "the technical details evolve differently , however , since we are using the rewriting approach to typing . similarly to girard s proof , we are going to define an interpretation of open types as sets of standard terms . here , we need to generalize this to give interpretations @xmath401\\negthinspace]}_\\phi$ ] of mixed terms @xmath83 , where ( as standard ) @xmath402 assigns interpretations to the free variables of @xmath83 .",
    "the most enlightening observation that will come from this is theorem  [ thm : abstr ] ( abstraction theorem ) , which says that interpretation is monotonic with respect to abstract reduction : if @xmath85 , then @xmath401\\negthinspace]}_\\phi\\subseteq{[\\negthinspace[m']\\negthinspace]}_\\phi$ ] .",
    "if one views a set as abstracting its elements , and if one considers a mixed term as a code for the set of terms which is its interpretation , then the abstraction theorem shows that more abstract codes have more abstract interpretations .",
    "this is an elegant perspective that arises  from the standard tait - girard method  only by taking a small - step view of typing ; existing proofs for normalization in the literature do not have any theorem which corresponds ( in any obvious way ) to the abstraction theorem .",
    "so now to begin the development , let wn be the set of standard terms which are weakly normalizing with respect to @xmath39 ( that is , terms @xmath48 such that there exists some @xmath49 such that @xmath403 ) . also , if @xmath3 is any binary relation on standard terms and @xmath16 any set of standard terms , we will write @xmath404 for the image of @xmath16 under @xmath3 ( that is , @xmath405 ) .    we first define @xmath406 to be the set of all sets @xmath16 of standard terms satisfying the following conditions :    1 .",
    "@xmath407 2 .",
    "@xmath408 3 .",
    "@xmath409    the first condition ensures that @xmath410 and @xmath411 imply @xmath412 . an assumption like this",
    "is often made about such sets of terms .",
    "we will call elements of @xmath406 _ reducibility sets_. much work has been devoted to comparing different conditions for families of sets in the context of the interpretation of types ( see , e.g. ,  @xcite ) .",
    "our focus here is not so much on the specific conditions on the interpretations of mixed terms , as on how interpretations of terms in the abstract reduction relation are related .",
    "the conditions we adopt here are simple and sufficient for weak normalization of closed terms ( cf . also chapter 12 of  @xcite )",
    ".    we will use @xmath402 as a meta - variable for _ assignments _ , which are functions from _ var _ to @xmath406 .",
    "we write @xmath413 $ ] to mean the function @xmath402 updated to map variable @xmath45 to @xmath414 . now for any @xmath83 and @xmath402 with @xmath415 , we define the interpretation @xmath401\\negthinspace]}_\\phi$ ] of @xmath83 with respect to @xmath402 in figure  [ fig : interp ] . to ensure that interpretations of types satisfy the first property above of reducibility sets , we need to close under @xmath416 in the last two clauses of the definition ( in figure  [ fig : interp ] ) . since we are proving normalization , we take the set of normalizing terms as the interpretation of @xmath15 , similarly to what is standardly done for atomic types ( e.g. , in girard s proof ) .",
    "@xmath417\\negthinspace]}_\\phi & = & \\ { t\\ |\\ \\forall t'\\in{[\\negthinspace[t]\\negthinspace]}_\\phi.\\ t\\ t'\\in{[\\negthinspace[m]\\negthinspace]}_\\phi \\ } \\\\ { [ \\negthinspace[x]\\negthinspace]}_\\phi & = & \\phi(x ) \\\\ { [ \\negthinspace[a]\\negthinspace]}_\\phi & = & \\textnormal{wn } \\\\ { [ \\negthinspace[\\lambda x : t.m]\\negthinspace]}_\\phi & = & { \\leftarrow}_b^ * ( \\ { \\lambda x : t. t\\ |\\ \\forall t'\\in{[\\negthinspace[t]\\negthinspace]}_\\phi.\\ [ t'/x]t\\in{[\\negthinspace[m]\\negthinspace]}_{\\phi[{[\\negthinspace[t]\\negthinspace]}_\\phi / x ] } \\ } ) \\\\ { [ \\negthinspace[m_1\\ m_2]\\negthinspace]}_\\phi & = & { \\leftarrow}_b^*(\\ { t_1\\ t_2\\ |\\ t_1\\in{[\\negthinspace[m_1]\\negthinspace]}_\\phi\\ \\wedge\\ t_2\\in{[\\negthinspace[m_2]\\negthinspace]}_\\phi \\ } \\end{array}\\ ] ]      in this section , we prove that for all types @xmath52 and @xmath402 with @xmath418 , we have @xmath419\\negthinspace]}_\\phi\\in\\mathcal{r}$ ] .",
    "we will elide this condition relating @xmath52 ( or instead @xmath83 ) and @xmath402 below .",
    "we prove the three properties of reducibility sets given in the previous section .",
    "the properties must be proved in order , as later properties depend on earlier ones .",
    "the first property is needed in a more general form , for any mixed term @xmath83 , and not just types @xmath52 .",
    "the second two properties are only needed for types .",
    "the proofs in this section are similar to those used for the standard definition of typing , except that there , they are usually proved by mutual induction . here",
    "we can prove them independently , though in sequence , due to the simpler form of the second property .",
    "while the development in this section is similar to the usual one , in the next section we will see something significantly different .",
    "[ lem1 ] @xmath420\\negthinspace]}_\\phi\\subseteq { [ \\negthinspace[m]\\negthinspace]}_\\phi$ ]    the proof is by structural induction on @xmath83 .",
    "if @xmath83 is a @xmath42-abstraction , or application , the desired property follows by idempotence of @xmath416 as an operator on sets of terms .",
    "if @xmath83 is a variable @xmath45 , then the property follows by the same property for @xmath421 , since we stipulated assignments map variables to elements of @xmath406 . if @xmath422 , then we must prove @xmath423 but this just amounts to the obvious fact that if @xmath424 and @xmath48 is weakly normalizing , then @xmath49 is also weakly normalizing .",
    "finally , suppose @xmath83 is @xmath425 for some @xmath84 .",
    "assume an arbitrary @xmath426\\negthinspace]}_\\phi$ ] , and arbitrary @xmath49 with @xmath410 .",
    "we must show @xmath427\\negthinspace]}_\\phi$ ] . to do this , by the definition of the interpretation of @xmath428-terms",
    ", it suffices to consider arbitrary @xmath429\\negthinspace]}_\\phi$ ] , and show @xmath430\\negthinspace]}_\\phi$ ] .",
    "we have @xmath431\\negthinspace]}_\\phi$ ] by the definition of the interpretation of @xmath428-terms .",
    "then we get the desired conclusion by the induction hypothesis on @xmath84 , since @xmath432 .",
    "@xmath419\\negthinspace]}_\\phi \\neq \\emptyset$ ]    the proof is by structural induction on @xmath52 .",
    "if @xmath52 is @xmath15 , then the desired property holds immediately , since @xmath45 is in @xmath433\\negthinspace]}_\\phi$ ] .",
    "so suppose @xmath434 , for some @xmath69 and @xmath70 .",
    "we must exhibit some @xmath435\\negthinspace]}_\\phi$ ] . by the induction hypothesis applied to @xmath70 , there exists some @xmath436\\negthinspace]}_\\phi$ ] .",
    "now take @xmath437 for the required term @xmath48 , where we assume @xmath438 .",
    "we just have to confirm that @xmath439\\negthinspace]}_\\phi$ ] .",
    "so assume arbitrary @xmath440\\negthinspace]}_\\phi$ ] , and show @xmath441\\negthinspace]}_\\phi$ ] .",
    "by lemma  [ lem1 ] , it suffices to prove @xmath436\\negthinspace]}_\\phi$ ] , since @xmath442 .",
    "but we are assuming @xmath436\\negthinspace]}_\\phi$ ] .",
    "@xmath419\\negthinspace]}_\\phi \\subseteq \\textnormal{wn}$ ]    the proof is again by structural induction on @xmath52 , and is trivial when @xmath52 is @xmath15 .",
    "so suppose @xmath434 , and assume arbitrary @xmath435\\negthinspace]}_\\phi$ ] .",
    "we must show @xmath443 . by lemma  [ lem2 ]",
    ", we know there exists some term @xmath444\\negthinspace]}_\\phi$ ] .",
    "then by the definition of the interpretation of @xmath428-terms , @xmath445\\negthinspace]}_\\phi$ ] . by the induction hypothesis applied to @xmath70 , we then have @xmath446 .",
    "but this implies @xmath443 , as required .",
    "@xmath419\\negthinspace]}_\\phi \\in \\mathcal{r}$ ]    the above lemmas have proved that @xmath419\\negthinspace]}_\\phi$ ] satisfies the three properties for membership in @xmath406 . in the next section",
    ", we will also need the following lemma , whose proof is routine and omitted :    [ lem : semsubst ] @xmath447m]\\negthinspace]}_\\phi\\ = \\ { [ \\negthinspace[m]\\negthinspace]}_{\\phi[{[\\negthinspace[t]\\negthinspace]}_\\phi / x]}$ ]      in this section , we prove a remarkable theorem , from which the normalization property for typable terms will follow as a corollary . for any mixed terms @xmath83 and @xmath84 , and any @xmath402 with @xmath415 , we have :    [ thm : abstr ] @xmath448\\negthinspace]}_\\phi\\subseteq{[\\negthinspace[m']\\negthinspace]}_\\phi$ ]    note that well - definedness of @xmath449\\negthinspace]}_\\phi$ ] in the statement of the theorem follows from the assumption about @xmath402 and the observation that abstract reduction can not introduce new variables .",
    "this theorem is remarkable because it reflects the essence of abstraction : the gathering of different concrete entities under the same abstract one .",
    "the abstraction theorem shows that abstract reduction is increasing the set of concrete terms which are collected under a mixed ( and so partially abstract ) term .",
    "in the next section , we will see how to conclude normalization from this theorem .",
    "it suffices to prove by structural induction on @xmath397 that for all @xmath402 and for all @xmath83 and @xmath84 where @xmath83 is a redex and @xmath84 its contractum : @xmath450 \\to_a \\hat{m}[m']\\longrightarrow { [ \\negthinspace[\\hat{m}[m]]\\negthinspace]}_\\phi\\subseteq{[\\negthinspace[\\hat{m}[m']]\\negthinspace]}_\\phi\\ ] ] * case : * @xmath451 , where the hole is in @xmath91 . the case where the hole is in @xmath92 is similar , so we omit it . to show the required @xmath452\\ m_2]\\negthinspace]}_\\phi\\subseteq{[\\negthinspace[m_1[m']\\ m_2]\\negthinspace]}_\\phi$ ] , consider arbitrary @xmath453\\ m_2]\\negthinspace]}_\\phi$ ] . by the definition of the interpretation of applications",
    ", we must have @xmath454\\negthinspace]}_\\phi$ ] and @xmath455\\negthinspace]}_\\phi$ ] with @xmath456 .",
    "now by the induction hypothesis applied to @xmath91 we have : @xmath457\\negthinspace]}_\\phi\\subseteq{[\\negthinspace[m_1[m']]\\negthinspace]}_\\phi\\ ] ] this implies @xmath458\\ m_2]\\negthinspace]}_\\phi$ ] . from this , we obtain the desired @xmath459\\ m_2]\\negthinspace]}_\\phi$ ] by the definition of the interpretation of applications .",
    "* case : * @xmath460 , for some @xmath45 , @xmath52 , and @xmath91 , with the hole in @xmath91 .",
    "consider an arbitrary @xmath461\\negthinspace]}_\\phi$ ] . by the definition of the interpretation of @xmath42-abstractions",
    ", this implies that there exists a term @xmath145 such that @xmath462 and for all @xmath429\\negthinspace]}_\\phi$ ] , we have @xmath463t_1\\in{[\\negthinspace[m_1[m]]\\negthinspace]}_{\\phi[{[\\negthinspace[t]\\negthinspace]}_\\phi / x]}$ ] .",
    "we must show @xmath464\\negthinspace]}_\\phi$ ] . by the definition of the interpretation of @xmath42-terms and lemma  [ lem1 ]",
    ", it suffices to prove @xmath465\\negthinspace]}_{\\phi[{[\\negthinspace[t]\\negthinspace]}_\\phi / x]}$ ] for arbitrary @xmath429\\negthinspace]}_\\phi$ ] . again applying lemma  [ lem1 ]",
    ", we can see it suffices to prove @xmath463t_1\\in{[\\negthinspace[m_1[m']]\\negthinspace]}_{\\phi[{[\\negthinspace[t]\\negthinspace]}_\\phi / x]}$ ] .",
    "this now follows by the induction hypothesis applied to context @xmath91 .",
    "* case : * @xmath466 .",
    "now we must distinguish the two cases for an abstract reduction .",
    "* suppose that we have @xmath467m\\ ] ] we must prove @xmath468\\negthinspace]}_\\phi\\subseteq\\ { [ \\negthinspace[t{\\rightarrow}[t / x]m]\\negthinspace]}_\\phi$ ] .",
    "so assume arbitrary @xmath469\\negthinspace]}_\\phi$ ] , and show @xmath470m]\\negthinspace]}_\\phi$ ] . to show that , it suffices to consider arbitrary @xmath429\\negthinspace]}_\\phi$ ] , and prove @xmath471m]\\negthinspace]}_\\phi$ ] . by the definition of the interpretation of @xmath42-abstractions",
    ", we have @xmath472 , for some @xmath49 , with @xmath463t'\\in{[\\negthinspace[m]\\negthinspace]}_{\\phi[{[\\negthinspace[t]\\negthinspace]}_\\phi / x]}$ ] for all @xmath429\\negthinspace]}_\\phi$ ] . since @xmath473t'$ ]",
    ", it suffices by lemma  [ lem1 ] just to prove @xmath463t'\\in{[\\negthinspace[[t / x]m]\\negthinspace]}_\\phi$ ] .",
    "this follows from the fact just derived , applying also lemma  [ lem : semsubst ] .    * case 2 .",
    "* suppose that we have @xmath474 assume an arbitrary @xmath475\\negthinspace]}_\\phi$ ] . by the definition of the interpretation of applications",
    ", we then have that there exists @xmath476\\negthinspace]}_\\phi$ ] and @xmath477\\negthinspace]}_\\phi$ ] such that @xmath456 .",
    "we must show @xmath478\\negthinspace]}_\\phi$ ] . by the definition of the interpretation of @xmath428-terms , we obtain @xmath479\\negthinspace]}_\\phi$ ] . by lemma  [ lem1 ] , this suffices to establish @xmath478\\negthinspace]}_\\phi$ ] , since @xmath456 .",
    "using the abstraction theorem , we can obtain the main result that typable terms are normalizing .",
    "first , we need this helper lemma stating that standard terms are in their own interpretations :    [ lem : inown ] consider an arbitrary standard term @xmath48 and assignment @xmath402 , as well as function @xmath480 from variables to standard terms .",
    "suppose also that for all @xmath481 , we have @xmath482 . then we have @xmath483\\negthinspace]}_\\phi$ ] .",
    "the proof is by structural induction on @xmath48 .",
    "if @xmath48 is a variable @xmath45 , then we have @xmath484 by assumption .",
    "if @xmath48 is of the form @xmath485 , then the definition of the interpretation of mixed terms tells us : @xmath486\\negthinspace]}_\\phi = { \\leftarrow}_b^*(\\ { \\lambda x : t.t'\\ |\\ \\forall t''\\in{[\\negthinspace[t]\\negthinspace]}_\\phi.\\ [ t''/x]t'\\in{[\\negthinspace[t_1]\\negthinspace]}_\\phi \\})\\ ] ] to show that @xmath487 is itself a member of the set on the right - hand side of this equation , it suffices to consider an arbitrary @xmath429\\negthinspace]}_\\phi$ ] , and show @xmath463(\\sigma t_1)\\in{[\\negthinspace[t_1]\\negthinspace]}_{\\phi[{[\\negthinspace[t]\\negthinspace]}_\\phi / x]}$ ] .",
    "here we can apply the induction hypothesis for @xmath145 , with @xmath488 $ ] and @xmath489\\negthinspace]}_\\phi / x]$ ] .",
    "the two substitutions still satisfy the required properties .",
    "finally , if @xmath48 is of the form @xmath143 , the result easily follows from the induction hypothesis applied to @xmath145 and also to @xmath146 , and the definition of the interpretation of applications .    for all closed standard terms @xmath48 and types @xmath52 , if @xmath319 , then @xmath443 .    by lemma  [ lem : inown ]",
    ", we have @xmath490\\negthinspace]}_\\emptyset$ ] .",
    "then by iterated application of theorem  [ thm : abstr ] , we know that @xmath491\\negthinspace]}_\\emptyset\\subseteq{[\\negthinspace[t]\\negthinspace]}_\\emptyset$ ] . by lemma  [ lem3 ] , @xmath419\\negthinspace]}_\\emptyset\\subseteq\\textnormal{wn}$ ] . putting these facts together ,",
    "we get this chain of relationships , which suffices : @xmath492\\negthinspace]}_\\emptyset\\ \\subseteq \\ { [ \\negthinspace[t]\\negthinspace]}_\\emptyset\\ \\subseteq\\ \\textnormal{wn}\\eqno{\\qed}\\ ] ]      here , we summarize girard s proof of strong normalization , for purposes of comparison  @xcite .",
    "this proof is based on the usual judgment @xmath493 for stlc .",
    "one first defines an interpretation of types : @xmath494 this does not require use of a function @xmath402 as above ( though the standard proof for system f does ) . for this interpretation of types ,",
    "one then proves these three properties , by mutual structural induction on the type @xmath52 mentioned in all three properties :    1 .   @xmath495 .",
    "3 .   if @xmath48 is neutral , then @xmath497 .",
    "a term is neutral iff it is not a @xmath42-abstraction .",
    "the third property implies that all the variables are in @xmath498 for every @xmath52 .",
    "finally , one derives the following different theorem in place of the abstraction theorem :    [ thm : red ] suppose @xmath499 , and consider arbitrary @xmath500 , for all @xmath107",
    ". then @xmath501\\ , t\\in{\\textit{red}_{t}}$ ] .",
    "now we can obtain as a corollary that @xmath493 implies @xmath502 , since @xmath503 by the first property above , and a substitution @xmath480 replacing @xmath45 by @xmath45 satisfies the required condition , since all variables are included in all sets @xmath498 .      the main difference in the rewriting - based development and the standard",
    "one is in deriving the abstraction theorem .",
    "the form of the theorem is completely different from theorem  [ thm : red ] .",
    "one nice technical feature is that for the proof of the abstraction theorem , we did not need to apply a substitution to terms inhabiting interpretations of types , as we did for theorem  [ thm : red ] .",
    "we still needed to use the idea of such a substitution , but it appeared only in a simple helper lemma , namely lemma  [ lem : inown ] .",
    "this is an advantage of the rewriting - based version , since the substitution does not clutter up the proof of the central result .",
    "one disadvantage of the rewriting - based version is that we needed the function @xmath402 and lemma  [ lem : semsubst ]  but this is not such a significant disadvantage , since those devices are needed when we move to system f in the standard development anyway .",
    "we have seen how rewriting techniques can be used to develop the meta - theory of simple types .",
    "typing is treated as a small - step abstract reduction relation , and type safety , based on type preservation and progress theorems , can be established by analysis of the interactions between abstract and concrete reduction steps",
    ". a crucial ingredient of our approach to type preservation , as defined by theorem  [ thmtp ] , is to have a confluent abstract reduction relation . for simply typed lambda calculus ,",
    "this was a trivial matter , but we saw a more complex example , where applying automated confluence - checking tools developed in the term - rewriting community was able to automate this part of the type preservation proof .",
    "confluence of the combination of abstract and concrete reduction for typable terms is an easy corollary of type preservation ( theorem  [ thmcr ] ) .",
    "we have also seen how to adapt a standard proof of normalization for simply typed terms , for the rewriting approach to typing . for this proof ,",
    "mixed terms are interpreted as sets of standard terms , and the crucial insight is embodied in the abstraction theorem , which shows that those sets are enlarged by reduction of the corresponding mixed terms .",
    "there are many avenues for future work .",
    "first , the rewriting approach should be applied to more advanced type systems , including ones with impredicative polymorphism .",
    "dependent type systems pose a particular challenge , because from the point of view of abstract reduction , @xmath504-bound variables must play a dual role .",
    "when computing a dependent function type @xmath505 from an abstraction @xmath506 , we may need to abstract @xmath45 to @xmath52 , as for stlc ; but we may also need to leave it unabstracted , since with dependent types , @xmath45 is allowed to appear in the range type @xmath256 .",
    "it would also be interesting to see if there are consequences of the rewriting approach to typing when applied to proofs via the curry - howard isomorphism .",
    "theorem  [ thm : abstr ] ( abstraction ) shows how the set of proofs in the meaning of a mixed proof term ( part proof and part formula ) increases as the term is abstracted .",
    "certainly , the present methods yield the syntactic capability to incrementally transform a proof to the theorem it proves",
    ". this could already be valuable in practice for efficient proof checking , for example of large proofs produced by sat or smt solvers ( cf .",
    ".    it would be interesting to go further in automating proofs of type preservation based on the rewriting approach .",
    "while the programming languages community has invested substantial effort in recent years on computer - checked proofs of properties like type safety for programming languages ( initiated particularly by the poplmark challenge  @xcite ) , there is relatively little work on fully automatic proofs of type preservation ( an example is  @xcite ) .",
    "the rewriting approach could contribute to filling that gap , since the methods we used above for analyzing interactions of abstract and concrete steps to prove type preservation are similar to those used for proving confluence of combined reduction .",
    "our longer term goal is to use this approach to design and analyze type systems for symbolic simulation . in program verification tools like pex and key",
    ", symbolic simulation is a central component  @xcite .",
    "but these systems do not seek to prove that their symbolic - simulation algorithms are correct .",
    "indeed , the authors of the key system argue against expending the effort to do this  @xcite .",
    "the rewriting approach promises to make it easier to relate symbolic simulation , viewed as an abstract reduction relation , with the small - step operational semantics .    * acknowledgments . *",
    "we thank the anonymous lmcs reviewers for their very detailed comments , and a number of technical suggestions which have greatly improved this paper ; and also participants of the rta 2011 conference for their helpful feedback and suggestions about this work .",
    "b.  aydemir , a.  bohannon , m.  fairbairn , j.  foster , b.  pierce , p.  sewell , d.  vytiniotis , g.  washburn , s.  weirich , and s.  zdancewic . .",
    "in _ proceedings of the eighteenth international conference on theorem proving in higher order logics ( tphols 2005 ) _ , 2005 .          robert  l. constable , stuart  f. allen , s.  f. allen , h.  m. bromley , w.  r. cleaveland , j.  f. cremer , r.  w. harper , douglas  j. howe , t.  b. knoblock , n.  p. mendler , p.  panangaden , scott  f. smith , james  t. sasaki , and s.  f. smith . .",
    "prentice hall , 1986 .",
    "m.  hills and g.  rosu . .",
    "in c.  lynch , editor , _ proceedings of the 21st international conference on rewriting techniques and applications , rta 2010 , july 11 - 13 , 2010 , edinburgh , scotland , uk _ , pages 151160 , 2010 .                aaron stump , garrin kimmell , and roba el  haj omar . .",
    "in manfred schmidt - schau , editor , _ proceedings of the 22nd international conference on rewriting techniques and applications ( rta ) _ , volume  10 of _ lipics _ , pages 345360 , 2011 ."
  ],
  "abstract_text": [
    "<S> this paper shows how a recently developed view of typing as small - step abstract reduction , due to kuan , macqueen , and findler , can be used to recast the development of simple type theory from a rewriting perspective . </S>",
    "<S> we show how standard meta - theoretic results can be proved in a completely new way , using the rewriting view of simple typing . </S>",
    "<S> these meta - theoretic results include standard type preservation and progress properties for simply typed lambda calculus , as well as generalized versions where typing is taken to include both abstract and concrete reduction . </S>",
    "<S> we show how automated analysis tools developed in the term - rewriting community can be used to help automate the proofs for this meta - theory . </S>",
    "<S> finally , we show how to adapt a standard proof of normalization of simply typed lambda calculus , for the rewriting approach to typing .        </S>",
    "<S> [ thm]theorem [ thm]lemma [ thm]corollary [ thm]definition [ thm]proposition </S>"
  ]
}