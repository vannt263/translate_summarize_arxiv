{
  "article_text": [
    "the most common approach to calculate the algorithmic complexity of a string is the use of compression algorithms exploiting the regularities of the string and producing shorter compressed versions .",
    "the length of a compressed version of a string is an upper bound of the algorithmic complexity of the string @xmath1 .    in practice",
    ", it is a known problem that one can not compress short strings , shorter , for example , than the length in bits of the compression program which is added to the compressed version of @xmath1 , making the result ( the program producing @xmath1 ) sensitive to the compressor choice and the parameters involved .",
    "however , short strings are quite often the kind of data encountered in many practical settings . while compressors asymptotic behavior guarantees the eventual convergence to the algorithmic complexity of @xmath1 , thanks to the invariance theorem ( to be enunciated later ) , measurements differ considerably in the domain of short strings . a few attempts to deal with this problem",
    "have been reported before @xcite .",
    "the conclusion is that estimators are always challenged by short strings .",
    "attempts to compute the uncomputable are always challenging , see for example @xcite and more recently @xcite and @xcite .",
    "this often requires combining theoretical and experimental results . in this paper",
    "we describe a method to compute the algorithmic complexity ( hereafter denoted by @xmath2 ) of ( short ) bit strings by running a set of ( relatively ) large number of turing machines for which the halting runtimes are known thanks to the busy beaver problem @xcite .    in the spirit of the experimental paradigm",
    "suggested in @xcite , the method in this paper describes a way to find the shortest program given a standard formalism of turing machines , executing all machines from the shortest ( in number of states ) to a certain ( small ) size one by one recording how many of them produce a string and then using a theoretical result linking this string frequency with the algorithmic complexity of a string .",
    "the result is a novel approach that we put forward for numerically calculate the complexity of short strings as an alternative to the indirect method using compression algorithms .",
    "the procedure makes use of a combination of results from related areas of computation , such as the concept of halting probability @xcite , the busy beaver problem @xcite , algorithmic probability @xcite , levin s semi - measure and levin - zvonkin - chaitin s coding theorem ( from now on _ coding theorem _ ) @xcite .",
    "the approach , never attempted before to the authors knowledge , consists in the thorough execution of all 2-symbol turing machines up to 4 states ( the exact model is described in [ d ] ) which , upon halting , generate a set of output strings from which a frequency distribution is calculated to obtain the algorithmic probability of a string .",
    "the algorithmic complexity of a string can then be evaluated from the algorithmic probability using the coding theorem .",
    "the paper is structured as follows . in section [ preliminaries ]",
    "it is introduced the various theoretical concepts and experimental results utilized in the experiment , providing essential definitions and referring the reader to the relevant papers and textbooks .",
    "section [ d ] introduces the definition of our empirical probability distribution @xmath3 . in [ method ]",
    "we present the methodology for calculating @xmath3 . in [ results ]",
    "we calculate @xmath3 and provide numerical values of the algorithmic complexity for short strings by way of the theory presented in [ preliminaries ] , particularly the coding theorem .",
    "finally , in [ conclusions ] we summarize , discuss possible applications , and suggest potential directions for further research .",
    "as widely known , the halting problem for turing machines is the problem of deciding whether an arbitrary turing machine @xmath5 eventually halts on an arbitrary input @xmath1 . halting computations can be recognized by simply running them for the time they take to halt .",
    "the problem is to detect non - halting programs , about which one can not know if the program will run forever or will eventually halt .",
    "an elegant and concise representation of the halting problem is chaitin s irrational number @xmath4 @xcite , defined as the halting probability of a universal computer programmed by coin tossing .",
    "formally , + definition 1 .",
    "@xmath6 with @xmath7 the size of @xmath8 in bits .",
    "+ @xmath4 is the halting probability of a universal ( prefix - free and @xmath9 such that @xmath9 is a proper extension of @xmath10 .",
    "inequality @xcite guarantees that for any prefix - free set a , @xmath11 . ] ) turing machine running a random program ( a sequence of fair coin flip bits taken as a program ) .    for",
    "an @xmath4 number one can not compute more than a finite number of digits .",
    "the numerical value of @xmath12 depends on the choice of universal turing machine @xmath13 .",
    "there are , for example , @xmath4 numbers for which no digit can be computed @xcite .",
    "knowing the first @xmath14 bits of an @xmath4 allows to determine whether a program of length @xmath15 bits halts by simply running all programs in parallel until the sum exceeds that @xmath4 .",
    "all programs with length @xmath15 not halting yet will never halt . using these kind of arguments , calude and stay @xcite have shown that most programs either stop `` quickly '' or never halt because the halting runtime ( and therefore the length of the output upon halting ) is ultimately bounded by its program - size complexity .",
    "the results herein connect theory with experiments by providing empirical values of halting times and string length frequencies .",
    "the algorithmic complexity @xmath16 of a string @xmath1 with respect to a universal turing machine @xmath13 , measured in bits , is defined as the length in bits of the shortest ( prefix - free ) turing machine @xmath13 that produces the string @xmath1 and halts @xcite . formally , + definition 2 .",
    "@xmath17 where @xmath7 is the length of @xmath8 measured in bits . +",
    "this complexity measure clearly seems to depend on @xmath13 , and one may ask whether there exists a turing machine which yields different values of @xmath2 .",
    "the answer is that there is no such turing machine which can be used to decide whether a short description of a string is the shortest ( for formal proofs see @xcite ) .",
    "the ability of universal machines to efficiently simulate each other implies a corresponding degree of robustness .",
    "the invariance theorem @xcite states that if @xmath16 and @xmath18 are the shortest programs generating @xmath1 using the universal turing machines @xmath13 and @xmath19 respectively , their difference will be bounded by an additive constant independent of @xmath1 .",
    "formally : + theorem ( invariance @xcite ) 1 .",
    "@xmath20 + a major drawback of @xmath21 as a function taking @xmath1 to the length of the shortest program producing @xmath1 , is its non - computability proven by reduction to the halting problem .",
    "in other words , there is no program which takes a string @xmath1 as input and produces the integer @xmath2 as output .",
    "deeply connected to chaitin s halting probability @xmath4 , is solomonoff s concept of algorithmic probability , independently proposed and further formalized by levin s @xcite semi - measure herein denoted by @xmath22 .",
    "unlike chaitin s @xmath4 , it is not only whether a program halts or not that matters for the concept of algorithmic probability ; the output and halting time of a halting turing machine are also relevant in this case .",
    "levin s semi - measure @xmath22 is the probability of producing a string @xmath1 with a random program @xmath8 ( i.e. every bit of @xmath8 is the result of an independent toss of a fair coin ) when running on a universal prefix - free turing machine @xmath13 . formally , + definition 3 .",
    "@xmath23 + levin s probability measure induces a distribution over programs producing @xmath1 , assigning to the shortest program the highest probability and smaller probabilities to longer programs .",
    "there is a theorem connecting algorithmic probability to algorithmic complexity .",
    "algorithmic probability is related to algorithmic complexity in that @xmath22 is at least the maximum term in the summation of programs given that it is the shortest program that has the greater weight in the summation of the fractions defining @xmath22 .",
    "formally , the theorem states that the following relation holds : + theorem ( coding theorem @xcite ) 2 .",
    "@xmath24 + nevertheless , @xmath22 as a function of @xmath1 is , like @xmath2 and chaitin s @xmath4 , noncomputable due to the halting problem as semi - measure is that it dominates any other effective semi - measure @xmath25 because there is a constant @xmath26 such that , for all @xmath1 , @xmath27 .",
    "for this reason @xmath22 is often called a _ universal distribution _",
    "notation : we denote by @xmath28 the class ( or space ) of all @xmath14-state 2-symbol turing machines ( with the halting state not included among the @xmath14 states ) . + definition 4 .",
    "@xcite if @xmath29 is the number of 1s on the tape of a turing machine @xmath5 upon halting , then : @xmath30 .",
    "+ definition 5 .",
    "@xcite if @xmath31 is the number of steps that a machine @xmath5 takes upon halting , then @xmath32 .",
    "+ @xmath33 and @xmath34 as defined ( and denoted by busy beaver functions ) in 4 and 5 are noncomputable by reduction to the halting problem @xcite .",
    "yet values are known for @xmath28 with @xmath35 .",
    "the solution for @xmath28 with @xmath36 is trivial , the process leading to the solution in @xmath37 is discussed by lin and rado @xcite , and the process leading to the solution in @xmath38 is discussed in @xcite .",
    "a program showing the evolution of all known busy beaver machines developed by one of this paper s authors is available online @xcite .",
    "the turing machine model followed in this paper is the same as the one described for the busy beaver problem as introduced by rado @xcite .",
    "it is important to describe the turing machine formalism because exact values of algorithmic probability for short strings will be provided under this chosen standard model of turing machines .",
    "definition 6 .",
    "consider a turing machine with the binary alphabet @xmath39 and @xmath14 states @xmath40 and an additional halt state denoted by 0 ( just as defined in rado s original busy beaver paper @xcite ) .",
    "+ the machine runs on a @xmath41-way unbounded tape . at each step :    the machine s current `` state '' ( instruction ) ; and    the tape symbol the machine s head is scanning    define each of the following :    a unique symbol to write ( the machine can overwrite a @xmath42 on a @xmath43 , a @xmath43 on a @xmath42 , a @xmath42 on a @xmath42 , and a @xmath43 on a @xmath43 ) ;    a direction to move in : @xmath44 ( left ) , @xmath42 ( right ) or @xmath43 ( none , when halting ) ; and    a state to transition into ( may be the same as the one it was in ) .    the machine halts if and when it reaches the special halt state 0 .",
    "there are @xmath45 turing machines with @xmath14 states and 2 symbols according to the formalism described above .",
    "no transition starting from the halting state exists , and the blank symbol is one of the 2 symbols ( 0 or 1 ) in the first run , while the other is used in the second run ( in order to avoid any asymmetries due to the choice of a single blank symbol ) . in other words",
    ", we run each machine twice , one with 0 as the blank symbol ( the symbol with which the tape starts out and is filled with ) , and an additional run with 1 as the blank symbol .",
    "the output string is taken from the number of contiguous cells on the tape the head of the halting @xmath14-state machine has gone through .",
    "a machine produces a string upon halting .",
    "+ definition 7 .",
    "@xmath46 is the function that retrieves the number of machines that halt ( denoted by @xmath47 ) in @xmath28 and then assigns to every string @xmath1 produced by @xmath28 the quotient : ( number of times that a machine in @xmath28 produces @xmath1 ) / ( number of machines in @xmath28 that halt ) . + examples of @xmath46 for @xmath48 :    @xmath49 , @xmath50 + @xmath51 , @xmath52 +    tables 1 , 2 and 3 in [ results ] show the results for @xmath53 , @xmath54 and @xmath55 , and table 4 the top ranking of @xmath56 .",
    "+ theorem 3 .",
    "@xmath46 is noncomputable .",
    "+ proof ( by reduction to the halting problem ) : the result is obvious , since from the knowledge of the number of @xmath14-state turing machines that halt , it is easy to know for every turing machine if it stops or not by the following argument ( by contradiction ) : assume @xmath46 is computable .",
    "let @xmath5 be any arbitrary turing machine . to solve the halting problem for @xmath5 , calculate @xmath46 , where @xmath14 is the number of states in @xmath5 .",
    "suppose that ( by hypothesis ) @xmath46 outputs @xmath47 and the assignation list of strings and frequencies .",
    "run all possible @xmath14-state turing machines in parallel , and wait until @xmath47 many of the machines have halted . if @xmath5 is one of the machines that has halted , then @xmath5 halts .",
    "otherwise , @xmath5 does nt halt .",
    "we have just shown that if @xmath46 were computable , then the halting problem would be solvable .",
    "since the halting problem is known to be unsolvable , @xmath3 must be noncomputable .",
    "exact values of @xmath46 can be , however , calculated for small turing machines because of the known values ( in particular @xmath34 ) of the busy beaver problem for @xmath57 .",
    "for example , for @xmath58 , @xmath59 , so we know that any machine running more than 107 steps will never halt and so we stop it thereafter .    for each busy beaver candidate with @xmath60 states , a sample of turing machines running up to the candidate",
    "@xmath34 is also possible . as for rado s busy beaver functions @xmath33 and @xmath34 , @xmath46 is also approachable _ from above_. for larger @xmath14 , sampling methods asymptotically converging to @xmath46 can be used to approximate @xmath46 . in section [ results ]",
    "we provide exact values of @xmath46 for @xmath57 thanks to the the busy beaver known values .",
    "another property shared between @xmath46 and the busy beaver problem is that @xmath56 , just as the values of the busy beaver , is well - defined in the sense that the calculation of the digits of @xmath46 are fully determined once calculated , but the calculation of @xmath46 rapidly becomes impractical to calculate , for even a slightly larger number of states .",
    "our quest is thus similar in several respects to the busy beaver problem or the calculation of the digits of chaitin s @xmath4 number .",
    "the main underlying difficulty in analyzing thoroughly a given class of machines is the undecidability of the halting problem , and hence the uncomputability of the related functions .",
    "the approach for evaluating the complexity @xmath2 of a string @xmath1 presented herein is limited by ( 1 ) the halting problem and ( 2 ) computing time constraints .",
    "restriction ( 1 ) was overcome using the values of the busy beaver problem providing the halting times for all turing machines starting with a blank tape .",
    "restriction ( 2 ) represented a challenge in terms of computing time and programming skills .",
    "it is also the same restriction that has kept others from attempting to solve the busy beaver problem for a greater number of states .",
    "we were able to compute up to about @xmath61 machines per day or 15943 per second , taking us about 9 days function available in @xmath62 8 for @xmath63 and a c++ program for @xmath58 .",
    "since for @xmath58 there were @xmath64 machines involved , running on both 0 and 1 as blank , further optimizations were required .",
    "the use of a bignum library and an actual enumeration of the machines rather than producing the rules beforehand ( which would have meant overloading the memory even before the actual calculation ) was necessary . ] to run all @xmath38 turing machines each up to the number of steps bounded by the busy beaver values .    just as it is done for solving small values of the busy beaver problem , we rely on the experimental approach to analyze and describe a computable fraction of the uncomputable .",
    "a similar quest for the calculation of the digits of a chaitin s @xmath4 number was undertaken by calude et al .",
    "@xcite , but unlike chaitin s @xmath4 , the calculation of @xmath46 does not depend on the enumeration of turing machines ( because ) .",
    "it is easy to see that every @xmath65 turing machine contributing to @xmath46 is included in @xmath66 simply because every turing machine in @xmath65 is also in @xmath67 .",
    "we consider the space @xmath28 of turing machines with @xmath68 .",
    "the halting `` history '' and output probability followed by their respective runtimes , presented in tables 1 , 2 and 3 , show the times at which the programs in the domain of m halt , the frequency of the strings produced , and the time at which they halted after writing down the output string on their tape .",
    "we provide exact values for @xmath69 in the results [ results ] .",
    "we derive @xmath46 for @xmath57 from counting the number of n - strings produced by all @xmath28 turing machines upon halting .",
    "we define @xmath3 to be an @xmath70 _ universal distribution _ in levin s sense , and calculate the algorithmic complexity @xmath21 of a string @xmath1 in terms of @xmath3 using the coding theorem , from which we wo nt escape to an additive constant introduced by the application of the coding theorem , but the additive constant is common to all values and therefore should not impact the relative order .",
    "one has to bear in mind , however , that the tables in section [ results ] should be read as dependent of this last - step additive constant because using the coding theorem as an approximation method fixes a prefix - free universal turing machine via that constant , but according to the choices we make this seems to be the most natural way to do so as an alternative to other indirect choosing procedures .",
    "we calculated the 72 , 20000 , 15059072 and 22039921152 two - way tape turing machines started with a tape filled with 0s and 1s for @xmath54 , @xmath55 and @xmath56 was 77.06 gb . ] .",
    "the number of turing machines to calculate grows exponentially with the number of states . for @xmath71",
    "there are 53119845582848 machines to calculate , which makes the task as difficult as finding the busy beaver values for @xmath72 and @xmath73 , busy beaver values which are currently unknown but for which the best candidate may be @xmath74 which makes the exploration of @xmath75 a greatest challenge .",
    "although several ideas exploiting symmetries to reduce the total number of turing machines have been proposed and used for finding busy beaver candidates @xcite in large spaces such as @xmath76 , to preserve the structure of the data we could nt apply all of them .",
    "this is because , unlike the busy beaver challenge , in which only the maximum values are important , the construction of a probability distribution requires every output to be equally considered .",
    "some reduction techniques were , however , utilized , such as running only one - direction rules with a tape only filled with 0s and then completing the strings by reversion and complementation to avoid running every machine a second time with a tape filled with 1s . for an explanation of how we counted the number of symmetries to recuperate the outputs of the machines that were skipped see @xcite .",
    "@xmath53 is trivial .",
    "@xmath77 turing machines produce only two strings , with the same number of machines producing each .",
    "the busy beaver values for @xmath78 are @xmath79 and @xmath80 .",
    "that is , all machines that halt do so after 1 step , and print at most one symbol .",
    "[ firsttable ]    .distribution ( @xmath53 ) from the @xmath49 machines in @xmath77 that halt , out of a total of 64 turing machines . [ cols=\"^,^,^ \" , ]     [ default ]    among the various miscellaneous facts from these results :    all 1-bit strings were produced at @xmath81 .",
    "2-bit strings were produced at all @xmath82 times .",
    "@xmath83 was the time at which the first 2 bit strings of different lengths were produced ( @xmath84 and @xmath85 ) .",
    "strings produced before 8 steps account for 49% of the strings produced by all @xmath38 halting machines .",
    "there were 496 string groups produced by @xmath38 , that is strings that are not symmetric under reversion or complementation .",
    "there is a relation between @xmath86 and @xmath14 ; no n - bit string is produced before @xmath87 .",
    "this is obvious because a machine needs at least @xmath86 steps to print @xmath86 symbols .    at every time @xmath86",
    "there was at least one string of length @xmath14 for @xmath88 .",
    "intuitively , one may be persuaded to assign a lower or higher algorithmic complexity to some strings when looking at tables 9 and 10 , because they may seem simpler or more random than others of the same length .",
    "we think that very short strings may appear to be more or less random but may be as hard to produce as others of the same length , because turing machines producing them may require the same quantity of resources to print them out and halt as they would with others of the same ( very short ) length .",
    "for example , is 0101 more or less complex than 0011 ? is 001 more or less complex than 010 ?",
    "the string 010 may seem simpler than 001 to us because we may picture it as part of a larger sequence of alternating bits , forgetting that such is not the case and that 010 actually was the result of a machine that produced it when entering into the halting state , using this extra state to somehow delimit the length of the string .",
    "no satisfactory argument may exist to say whether 010 is really more or less random than 001 , other than actually running the machines and looking at their objective ranking according to the formalism and method described herein .",
    "the situation changes for larger strings , when an alternating string may in effect strongly suggest that it should be less random than other strings because a short description is possible in terms of the simple alternation of bits .",
    "some strings may also assume their correct rank when the calculation is taken further , for example if we were able to compute @xmath71 .    on the other hand",
    ", it may seem odd that the program size complexity of a string of length @xmath89 is systematically larger than @xmath89 when @xmath89 can be produced by a _ print _ function of length l+\\{the length of the print program } , and indeed one can interpret the results exactly in this way .",
    "the surplus can be interpreted as a constant product of a _ print _ phenomenon which is particularly significant for short strings .",
    "but since it is a constant , one can subtract it from all the strings .",
    "for example , subtracting 1 from all values brings the complexity results for the shortest strings to exactly their size , which is what one would expect from the values for algorithmic complexity . on the other hand , subtracting the constant preserves the relative order , even if larger strings continue having algorithmic complexity values larger than their lengths .",
    "what we provide herein , besides the numerical values , is a hierarchical structure from which one can tell whether a string is of greater , lesser or equal algorithmic complexity .",
    "the _ print program _ assumes the implicit programming of the halting configuration . in c language , for example , this is delimited by the semicolon .",
    "the fact then that a single bit string requires a 2 bit `` program '' may be interpreted as the additional information represented by the length of the string ; the fact that a string is of length @xmath14 is not the result of an arbitrary decision but it is encoded in the producing machine . in other words ,",
    "the string not only carries the information of its @xmath14 bits , but also of the delimitation of its length .",
    "this is different to , for example , approaching the algorithmic complexity by means of cellular automata  there being no encoded halting state , one has to manually stop the computation upon producing a string of a certain arbitrary length according to an arbitrary stopping time .",
    "this is a research program that we have explored before @xcite and that we may analyze in further detail somewhere else .",
    "it is important to point out that after the application of the coding theorem one often gets a non - integer value when calculating @xmath2 from @xmath22 .",
    "even though when interpreted as the size in bits of the program produced by a turing machine it should be an integer value because the size of a program can only be given in an integer number of bits .",
    "the non - integer values are , however , useful to provide a finer structure providing information on the exact places in which strings have been ranked .",
    "an open question is how much of the relative string order ( hence the relative algorithmic probability and the relative algorithmic complexity ) of @xmath46 will be preserved when calculating @xmath90 for larger turing machine spaces such that @xmath91 . as reported here , @xmath46 preserves most of the string orders of @xmath92 for @xmath93 .",
    "while each space @xmath28 contains all @xmath94 machines , the exponential increase in number of machines when adding states may easily produce strings such that the order of the previous distribution is changed .",
    "what the results presented here show , however , is that each new space of larger machines contributes in the same proportion to the number of strings produced in the smaller spaces , in such a way that they preserve much of the previous string order of the distributions of smaller spaces , as shown by calculating the spearman coefficient indicating a very strong ranking correlation .",
    "in fact , some of the ranking variability between the distributions of spaces of machines with different numbers of states occurred later in the classification , likely due to the fact that the smaller spaces missed the production of some strings .",
    "for example , the first rank difference between @xmath55 and @xmath56 occurred in place 20 , meaning that the string order in @xmath55 was strictly preserved in @xmath56 up to the top 20 strings sorted from higher to lower frequency .",
    "moreover , one may ask whether the actual frequency values of the strings converge .",
    "we have provided numerical tables with values the algorithmic complexity for short strings , and we have shed light into the behavior of small turing machines , particularly halting runtimes and output frequency distributions .",
    "the calculation of @xmath46 provides an empirical and _ natural _ distribution that does not depend on an additive constant and may be used in several practical contexts .",
    "the approach , by way of algorithmic probability , also reduces the impact of the additive constant given that one does not seem to be forced to make many arbitrary choices other than fixing a standard model of computation ( as opposed to fixing a specific universal turing machine ) . in other words ,",
    "the approach is bottom - up rather than top - down .",
    "an interesting open question is how robust the produced complexity classifications are to variations in the computational description formalism , such as using turing machines with one - directional tapes rather than bi - directional , or following completely different models such as @xmath14-dimensional cellular automata , or post tag systems .",
    "we ve shown in @xcite that reasonable formalisms seem to produce reasonable complexity classifications , in the sense that : a ) they are close to what intuition would tell should be and b ) they are statistically correlated with each other at various degrees of confidence .",
    "this is , however , a topic of current investigation .",
    "hector zenil wants to thank matthew szudzik for his always valuable advice .",
    "a. h. brady , the determination of the value of rado s noncomputable function @xmath95 for four - state turing machines .",
    "_ 40 , 647 - 665 , 1983 .",
    "delahaye and h. zenil , on the kolmogorov - chaitin complexity for short sequences . in c.s .",
    "calude ( ed . ) _ randomness and complexity : from leibniz to chaitin .",
    "_ world scientific , 2007 .",
    "chaitin , _ algorithmic information theory . _ cambridge university press , 1987 .",
    "calude , _ information and randomness : an algorithmic perspective .",
    "_ , springer ; 2nd . edition , 2002 . c.s . calude and m.a .",
    "stay , most programs stop quickly or never halt .",
    "_ advances in applied mathematics . _ 40 295308 , 2005 .",
    "calude , m.j .",
    "dinneen , and c - k .",
    "shu , computing a glimpse of randomness . _ experimental mathematics _ , 11(2 ) : 369 - 378 , 2002 . j. hertel , computing the uncomputable rado sigma function : an automated , symbolic induction prover for nonhalting turing machines . _ the mathematica journal _ , 11:2 2009 .",
    "a. holkner , acceleration techniques for busy beaver candidates .",
    "_ proceedings of the second australian undergraduate students computing conference _ , 2004 .",
    "w. kirchherr , m. li and p. vitanyi , the miraculous universal distribution . _ math .",
    "intelligencer _ , 19(4 ) , 715 , 1997 .",
    "a. n. kolmogorov .",
    "three approaches to the quantitative definition of information .",
    "_ problems of information and transmission _ , 1(1 ) : 17 , 1965 .",
    "l. levin , laws of information conservation ( non - growth ) and aspects of the foundation of probability theory .",
    "_ problems in form .",
    "transmission _ 10 , 206210 , 1974 . l. levin , on a concrete method of assigning complexity measures .",
    "_ doklady akademii nauk sssr , _",
    "vol.18(3 ) , pp . 727 - 731 , 1977 .",
    "universal search problems .",
    "9(3 ) : 265 - 266 , 1973 ( c ) .",
    "( submitted : 1972 , reported in talks : 1971 ) .",
    "english translation in : b.a.trakhtenbrot . _ a survey of russian approaches to perebor ( brute - force search ) algorithms .",
    "_ annals of the history of computing 6(4 ) : 384 - 400 , 1984 . m. li , p. vitnyi , _ an introduction to kolmogorov complexity and its applications .",
    "_ springer , 3rd . revised edition , 2008 .",
    "s. lin and t. rado , computer studies of turing machine problems .",
    "_ 12 , 196212 , 1965 .",
    "r. machlin , and q. f. stout , the complex behavior of simple machines .",
    "_ physica 42d .",
    "_ 85 - 98 , 1990 . h. marxen and j. buntrock . attacking the busy beaver 5 .",
    "_ bull eatcs _ 40 , 247251 , 1990 . t. rado , on noncomputable functions , _ bell system technical j. _ 41 , 877884 , 1962 .",
    "r. solomonoff , a preliminary report on a general theory of inductive inference .",
    "_ revision of report v-131 _ , contract af 49(639)-376 , report ztb138 , zator co. , cambridge , mass . ,",
    "nov , 1960 .",
    "solovay , a version of omega for which zfc can not predict a single bit , in : c.s .",
    "calude and g. pun ( eds . ) , _ finite versus infinite .",
    "_ pp . 32333 , 2000 .",
    "u. speidel , a note on the estimation of string complexity for short strings .",
    "7th international conference on information , _ communications and signal processing ( icics ) _ , 2009 .",
    "a.m. turing , on computable numbers , with an application to the entscheidungsproblem .",
    "_ proceedings of the london mathematical society , _ 2 42 : 23065 , 1936 , published in 1937 .",
    "s. wolfram , _ a new kind of science .",
    "_ wolfram media , 2002 .",
    "h. zenil and j - p .",
    "delahaye , on the algorithmic nature of the world , in g. dodig - crnkovic and m. burgin ( eds ) , _ information and computation",
    ". _ world scientific , 2010 .",
    "h. zenil , _ busy beaver .",
    "_ from the wolfram demonstrations project , + http://demonstrations.wolfram.com / busybeaver/."
  ],
  "abstract_text": [
    "<S> we describe an alternative method ( to compression ) that combines several theoretical and experimental results to numerically approximate the algorithmic ( kolmogorov - chaitin ) complexity of all @xmath0 bit strings up to 8 bits long , and for some between 9 and 16 bits long . </S>",
    "<S> this is done by an exhaustive execution of all deterministic 2-symbol turing machines with up to 4 states for which the halting times are known thanks to the busy beaver problem , that is 11019960576 machines . </S>",
    "<S> an output frequency distribution is then computed , from which the algorithmic probability is calculated and the algorithmic complexity evaluated by way of the ( levin - zvonkin - chaitin ) coding theorem .    </S>",
    "<S> algorithmic probability , algorithmic ( program - size ) complexity , halting probability , chaitin s omega , levin s universal distribution , levin - zvonkin - chaitin coding theorem , busy beaver problem , kolmogorov - chaitin complexity . </S>"
  ]
}