{
  "article_text": [
    "exploration of networks by visiting all of their nodes is one of the basic tasks performed by a mobile agent in networks . in applications ,",
    "a software agent may need to collect data placed at nodes of a network , or a mobile robot may need to collect samples of air or ground in a contaminated mine whose corridors form links of a network , with corridor crossings represented by nodes .    the network is modeled as a simple connected undirected graph @xmath20 with @xmath0 nodes , called _ graph _ in the sequel .",
    "nodes are unlabeled , and all ports at any node of degree @xmath1 are arbitrarily numbered @xmath2 .",
    "the agent is initially situated at a starting node @xmath3 of the graph .",
    "when the agent located at a current node @xmath21 gets to a neighbor @xmath22 of @xmath21 by taking port @xmath23 , it learns the port @xmath24 by which it enters node @xmath22 and it learns the degree of @xmath22 .",
    "the agent has to visit all nodes of the graph and stop .",
    "the _ time _ of the exploration is the number of edge traversals .",
    "we consider the problem of how much knowledge the agent has to have a priori , in order to explore the graph in a given time , using a deterministic algorithm .",
    "it is well - known that some information is necessary , as witnessed even by the class of rings in which ports at all nodes are numbered 0,1 in clockwise order .",
    "navigating in such a ring , the agent can not learn its size .",
    "if there existed an exploration algorithm not using any a priori knowledge , then it would have to stop after some @xmath25 steps in every ring , and hence would fail to explore a @xmath26-node ring .",
    "following the paradigm of _ algorithms with advice _",
    "@xcite , this a priori information ( advice ) , needed for exploration , is provided to the agent by an _ oracle _ , in the form of a binary string , whose length is called the _ size of advice_. we consider two types of oracles .",
    "an _ instance oracle _ knows the entire instance of the exploration problem , i.e. , the port - numbered map of the graph and the starting node of the agent in this map .",
    "map oracle _ knows the port - numbered map of the graph but does not know the starting node of the agent . formally , a map oracle is a function @xmath27 , where @xmath28 is the set of graphs and @xmath29 is the set of finite binary strings .",
    "an instance oracle is a function @xmath30 , where @xmath31 is the set of couples @xmath32 , with @xmath33 and @xmath3 being the starting node of the agent in graph @xmath34 .",
    "the advice @xmath35 is an input to an exploration algorithm .",
    "we say that exploration in time @xmath25 with advice of size @xmath36 given by an instance oracle is possible , if there exists advice of length @xmath36 depending on the instance @xmath32 , and an exploration algorithm using this advice , which explores every graph in time @xmath25 , starting from node @xmath3 .",
    "likewise , we say that exploration in time @xmath25 with advice of size @xmath36 given by a map oracle is possible , if there exists advice of length @xmath36 depending on the graph @xmath34 , and an exploration algorithm using this advice , which explores every graph in time @xmath25 , starting from any node .",
    "( integers @xmath36 and @xmath25 depend on the size of the graph . )",
    "proving that such an exploration is possible consists in showing an oracle of the appropriate type giving advice of size @xmath36 , and an exploration algorithm using this advice and working in time @xmath25 , for any graph and any starting node .",
    "proving that such an exploration is impossible consists in showing that , for any oracle of the appropriate type giving advice of size @xmath36 , and for any exploration algorithm using it , there exists a graph and a starting node for which this algorithm will exceed time @xmath25 .",
    "the central question studied in this paper is :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ what is the minimum size of advice that has to be given to the agent by an instance oracle ( resp . by a map oracle ) to permit the agent to explore any graph in a given time ? _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    our main contribution are negative results of two types :    * impossibility results showing that the less powerful map oracle can not help to achieve the same exploration time as the more powerful instance oracle , regardless of the size of advice ; * lower bounds showing that the size of some natural advice leading to a simple exploration in a given time can not be improved significantly .",
    "while in most cases our bounds on the size of advice are asymptotically tight , in one case the remaining gap is cubic .",
    "we first consider exploration in polynomial time , and determine the exact minimum size of advice to achieve it . indeed , we prove that some advice of size @xmath4 , for any constant @xmath5 , is sufficient to permit polynomial exploration of all @xmath0-node graphs , and that no advice of size @xmath6 , where @xmath7 is any function diverging to infinity , can help to do this .",
    "both these results hold both for the instance and for the map oracles .    on the other side of the spectrum ,",
    "when advice is large , there are two natural time thresholds : @xmath8 for a map oracle , and @xmath9 for an instance oracle .",
    "this is because , in both cases , these time benchmarks can be achieved with sufficiently large advice ( advice of size @xmath10 suffices ) .",
    "we show that , with a map oracle , time @xmath8 can not be improved in general , regardless of the size of advice .",
    "what is then the smallest advice to achieve time @xmath8 with a map oracle ?",
    "we show that this smallest size of advice is larger than @xmath11 , for any @xmath12 .    for large advice , the situation changes significantly when we allow an instance oracle instead of a map oracle . in this case ,",
    "advice of size @xmath10 is enough to achieve time @xmath13 .",
    "is such a large advice needed to achieve linear time ?",
    "we answer this question affirmatively . indeed",
    ", we show more : with any advice of size @xmath14 , the time of exploration must be at least @xmath15 , for any @xmath16 , and with any advice of size @xmath13 , the time must be @xmath17 .",
    "we finally look at hamiltonian graphs , as for them it is possible to achieve the absolutely optimal exploration time @xmath18 , when sufficiently large advice ( of size @xmath10 ) is given by an instance oracle . we show that a map oracle can not achieve this : regardless of the size of advice , the time of exploration must be @xmath17 , for some hamiltonian graphs . on the other hand , even for an instance oracle , with advice of size @xmath14 , optimal time @xmath18 can not be achieved : indeed , we show that the time of exploration with such advice must sometimes exceed the optimal time @xmath18 by a summand @xmath15 , for any @xmath19 .",
    "our results permit to compare advice of different size and of different quality .",
    "the size is defined formally , and for quality we may say that advice given by an instance oracle is superior to advice given by a map oracle , because an instance oracle , seeing not only the graph but also the starting node of the agent , can use the allowed bits of advice in a better way .",
    "looking from this perspective it turns out that both size and quality of advice provably matter . the fact that quality of advice matters is proved by the following pair of results : for a map oracle ,",
    "time @xmath8 can not be beaten , regardless of the size of advice , while for an instance oracle time @xmath13 can be achieved with @xmath10 bits of advice .",
    "the fact that the size of advice matters ( with the same quality ) is proved by the following pair of results : for an instance oracle , time @xmath13 can be achieved with @xmath10 bits of advice , but with @xmath14 bits of advice time must be at least @xmath15 , for any @xmath16 .",
    "the problem of exploration and navigation of mobile agents in an unknown environment has been extensively studied in the literature for many decades ( cf . the survey @xcite ) .",
    "the explored environment has been modeled in two distinct ways : either as a geometric terrain in the plane , e.g. , an unknown terrain with convex obstacles @xcite , or a room with polygonal @xcite or rectangular @xcite obstacles , or as we do in this paper , i.e. , as a graph , assuming that the agent may only move along its edges .",
    "the graph model can be further specified in two different ways : either the graph is directed , in which case the agent can move only from tail to head of a directed edge @xcite , or the graph is undirected ( as we assume ) and the agent can traverse edges in both directions @xcite . the efficiency measure adopted in most papers dealing with exploration of graphs is the time ( or cost ) of completing this task , measured by the number of edge traversals by the agent .",
    "some authors impose further restrictions on the moves of the agent .",
    "it is assumed that the agent has either a restricted tank @xcite , and thus has to periodically return to the base for refueling , or that it is attached to the base by a rope or cable of restricted length @xcite .    another direction of research concerns exploration of anonymous graphs .",
    "in this case it is impossible to explore arbitrary graphs and stop after exploration , if no marking of nodes is allowed , and if nothing is known about the graph .",
    "hence some authors @xcite allow _ pebbles _ which the agent can drop on nodes to recognize already visited ones , and then remove them and drop them in other places .",
    "a more restrictive scenario assumes a stationary token that is fixed at the starting node of the agent @xcite . exploring anonymous graphs without the possibility of marking nodes ( and thus possibly without stopping )",
    "is investigated , e.g. , in @xcite .",
    "the authors concentrate attention not on the cost of exploration but on the minimum amount of memory sufficient to carry out this task . in the absence of marking nodes , in order to guarantee stopping after exploration , some knowledge about the graph is required , e.g. , an upper bound on its size @xcite .",
    "providing nodes or agents with arbitrary kinds of information that can be used to perform network tasks more efficiently has been previously proposed in @xcite in contexts ranging from graph coloring to broadcasting and leader election .",
    "this approach was referred to as _ algorithms with advice_. the advice is given either to nodes of the network or to mobile agents performing some network task . in the first case , instead of advice , the term _ informative labeling schemes _ is sometimes used , if different nodes can get different information .",
    "several authors studied the minimum size of advice required to solve network problems in an efficient way .",
    "in @xcite , given a distributed representation of a solution for a problem , the authors investigated the number of bits of communication needed to verify the legality of the represented solution . in @xcite , the authors compared the minimum size of advice required to solve two information dissemination problems using a linear number of messages . in @xcite",
    ", it was shown that advice of constant size given to the nodes enables the distributed construction of a minimum spanning tree in logarithmic time .",
    "in @xcite , the advice paradigm was used for online problems . in @xcite , the authors established lower bounds on the size of advice needed to beat time @xmath37 for 3-coloring cycles and to achieve time @xmath37 for 3-coloring unoriented trees . in the case of @xcite ,",
    "the issue was not efficiency but feasibility : it was shown that @xmath38 is the minimum size of advice required to perform monotone connected graph clearing . in @xcite ,",
    "the authors studied radio networks for which it is possible to perform centralized broadcasting in constant time .",
    "they proved that constant time is achievable with @xmath13 bits of advice in such networks , while @xmath39 bits are not enough . in @xcite",
    ", the authors studied the problem of topology recognition with advice given to nodes .",
    "the topic of @xcite and @xcite was the size of advice needed for fast leader election , resp .",
    "in anonymous trees and in arbitrary anonymous graphs .",
    "exploration with advice was previously studied only for trees @xcite , and algorithm performance was measured using the competitive approach . in the present paper , the performance measure of an algorithm is the order of magnitude of exploration time , and hence the case of trees is trivial , as they can be explored in linear time without any advice .",
    "as a warm - up , we first consider the following question : what is the minimum size of advice permitting the agent to explore any graph in time polynomial in the size of the graph ? in this section we give the exact answer to this question , both for the instance oracle and for the map oracle .",
    "it is well - known that , if the agent knows an upper bound @xmath40 on the number @xmath0 of nodes of the graph , then exploration in time polynomial in @xmath40 is possible , starting from any node of the graph . the first result implying this fact was proved in @xcite .",
    "the exploration proposed there works in time @xmath41 , and is based on universal traversal sequences ( uts ) .",
    "later on , an exploration algorithm working in time polynomial in @xmath40 based on universal exploration sequences ( uxs ) was established in @xcite .",
    "while the polynomial in the latter paper has much higher degree , the solution from @xcite can be carried out in logarithmic memory .",
    "both uts and uxs permit to find a sequence of port numbers to be followed by the agent , regardless of the topology of the graph and of its starting node . in the case of uts ,",
    "the sequence of port numbers to be followed is the uts itself , and in the case of uxs it is constructed term by term , on the basis of the uxs and of the port number by which the agent entered the current node . regardless of which solution is used , we have the following proposition :    @xcite[uts ] if the agent knows an upper bound @xmath40 on the number @xmath0 of nodes of the graph , there exists an algorithm with input @xmath40 that permits the agent starting at any node of the graph to explore the graph and stop after @xmath42 steps , where @xmath43 is some polynomial .    the positive part of our result on minimum advice is formulated in the following lemma .",
    "its proof is based on proposition [ uts ] .",
    "the advice given to the agent is some prefix of the binary representation of the number @xmath44 , on the basis of which the agent computes a rough but sufficiently precise upper bound on the size of the graph which permits it to explore the graph , in time polynomial in its size .",
    "[ poly - ub ] for any positive constant @xmath5 , there exists an exploration algorithm using advice of size @xmath45 , that works in time polynomial in @xmath0 , for any @xmath0-node graph .",
    "let @xmath46 be an algorithm and let @xmath43 be a polynomial such that , if the agent knows an upper bound @xmath40 of the number @xmath0 of nodes of a graph @xmath34 , then it can explore @xmath34 in time @xmath42 , starting from any node , using algorithm @xmath46 with input @xmath40 .",
    "without loss of generality suppose @xmath47 for some constant @xmath48 .",
    "we will show that there exists a binary string @xmath35 of length @xmath45 such that if @xmath35 is given to the agent as advice , the agent can explore all nodes of @xmath34 in time polynomial in @xmath0 . to show the existence of such a string @xmath35 ,",
    "let @xmath49 be the binary representation of @xmath50 .",
    "let @xmath35 be the string obtained from @xmath49 by deleting the last @xmath51 bits of @xmath49 .",
    "the length of @xmath35 is at most @xmath45 .",
    "this string @xmath35 is given to the agent as the advice .",
    "let @xmath52 be string resulting from @xmath35 by adding @xmath53 1 s at the end of @xmath35 .",
    "let @xmath54 be the integer whose binary representation is @xmath52 .",
    "let @xmath55 . by definition , we have @xmath56 .",
    "hence , @xmath57 , and thus @xmath58 .    after receiving the string @xmath35",
    ", the agent computes the integer @xmath59 and performs algorithm @xmath46 with input @xmath59 . since @xmath58 , the agent correctly explores the graph in time @xmath60 .    to prove that the exploration time is polynomial in @xmath0 , let @xmath61 be the string which is obtained from @xmath35 by adding @xmath51 0 s at the end of @xmath35 .",
    "let @xmath62 be the integer whose binary representation is @xmath61 .",
    "we have @xmath63 .",
    "therefore , + @xmath64 @xmath65 @xmath66 @xmath67 let @xmath68 . then @xmath69 . also , @xmath70 .",
    "hence , the time taken by the agent is at most @xmath71 . since @xmath5 is a constant",
    ", @xmath72 is a polynomial in @xmath0 .",
    "the next result shows that the upper bound from the previous lemma is tight .",
    "indeed , the following lower bound holds even for oriented rings , i.e. , rings in which ports 0 and 1 are in clockwise order at every node .",
    "[ poly - lb ] for any function @xmath73 such that @xmath74 as @xmath75 , it is not possible to explore an @xmath0-node oriented ring in polynomial time , using advice of size at most @xmath76 .",
    "the proof is by contradiction .",
    "suppose that there exists an algorithm @xmath77 , permitting the agent to explore an @xmath0-node oriented ring with at most @xmath78 bits of advice , in time @xmath79 , where @xmath80 is a polynomial .",
    "without loss of generality assume that @xmath81 for some constant @xmath48 .",
    "since @xmath7 diverges to infinity , there exists some @xmath82 such that @xmath83 , for all @xmath84 .",
    "there are at most @xmath85 binary strings of length at most @xmath86 .",
    "define @xmath87 .",
    "take a family of @xmath88 oriented rings @xmath89 with @xmath90 nodes , for @xmath91 , where @xmath92 and @xmath84 . by the pigeonhole principle ,",
    "there exist indices @xmath93 such that @xmath89 and @xmath94 must have the same advice string , with @xmath95 .",
    "the correctness of @xmath77 implies that the agent explores all the nodes of @xmath89 and stops after @xmath96 steps .",
    "since the agent has the same advice for @xmath94 , it also stops after @xmath96 steps in @xmath94 .",
    "we have @xmath97 .",
    "since @xmath98 , we have @xmath99 @xmath100 . hence , @xmath101 .",
    "therefore , @xmath102 , i.e. , @xmath103 .",
    "this implies that the agent stops after fewer than @xmath104 steps in @xmath94 , but it is not possible to explore @xmath94 in fewer than @xmath104 steps , which is a contradiction .",
    "therefore , there does not exist any algorithm that can explore an @xmath0-node oriented ring with advice of size at most @xmath105 .",
    "notice that lemmas [ poly - ub ] and [ poly - lb ] hold both for the instance oracle and for the map oracle .",
    "the positive result from lemma [ poly - ub ] holds even for the map oracle , as the advice concerns the size of the graph and does not require knowing the starting node of the agent .",
    "the negative result from lemma [ poly - lb ] holds even for the instance oracle , as it is true even in oriented rings , where knowledge of the starting node does not provide any insight , since all nodes look the same .",
    "hence lemmas [ poly - ub ] and [ poly - lb ] imply the following theorem that gives a precise answer to the question stated at the beginning of this section .",
    "the minimum size of advice permitting the agent to explore any graph in time polynomial in the size @xmath0 of the graph is @xmath106 , both for the instance oracle and for the map oracle .",
    "when advice given to the agent can be large , there are two natural time thresholds : @xmath8 for a map oracle , and @xmath9 for an instance oracle .",
    "this is because , in both cases , these time benchmarks can be achieved with sufficiently large advice . indeed",
    ", we have the following proposition .    [ ub ] 1 .",
    "there exists an exploration algorithm , working in time @xmath107 and using advice of size @xmath10 , provided by a map oracle , for @xmath0-node graphs .",
    "there exists an exploration algorithm , working in time @xmath13 and using advice of size @xmath10 , provided by an instance oracle , for @xmath0-node graphs .    in order to guarantee exploration time @xmath107 ,",
    "it is enough to provide the agent with some port - numbered spanning tree @xmath108 of the graph .",
    "given such a tree @xmath108 , the agent identifies an euler tour @xmath109 of @xmath108 starting at @xmath21 , for any node @xmath21 of @xmath108 .",
    "( the tour is coded as a sequence of port numbers , including both the outgoing port and the incoming port at every step . )",
    "let @xmath110 be the reverse string of @xmath109 , and let @xmath111 be the concatenation of @xmath109 and @xmath110 .",
    "the agent performs each @xmath111 one after another .",
    "if some tour is impossible to continue , because the required outgoing port is not available , or the incoming port is not matched ( which can happen , if @xmath21 is not the starting node of the agent ) , the tour is simply aborted , and the agent backtracks to its starting node .",
    "the tour @xmath112 , where @xmath3 is the starting node of the agent , must succeed , and this tour visits all nodes of @xmath108 , and hence explores the graph .",
    "since there are @xmath0 tours , each of length @xmath13 , this gives time @xmath107 .    in order to guarantee exploration time @xmath13 ,",
    "it is enough to provide the agent with some rooted port - numbered spanning tree @xmath108 of the graph , where the root is the starting node of the agent .",
    "the agent performs an euler tour of this rooted tree in time @xmath113 .",
    "it remains to show that a port - numbered spanning tree can be given by a map oracle , and a port - numbered spanning tree rooted at the starting node of the agent can be given by an instance oracle , in both cases using @xmath10 bits .",
    "this can be done as follows . consider the dfs tree @xmath108 rooted at some arbitrary node in the case of a map oracle , and rooted at the starting node of the agent , in the case of an instance oracle , where neighbors of a node are explored in order of increasing port numbers .",
    "give the shape of @xmath108 as a binary sequence of length @xmath113 , where a 0 means `` go down the tree '' and 1 means `` go up the tree '' , in this dfs exploration .",
    "moreover , give the sequence of all port numbers , as they are encountered in order during this dfs exploration .",
    "this is a sequence of @xmath13 terms each of which is a number smaller than @xmath0 .",
    "hence , both sequences can be given to the agent using @xmath10 bits .",
    "on their basis , the agent first reconstructs the shape of @xmath108 , and then puts the port numbers in appropriate places .    in the rest of this section",
    "we prove negative results indicating the quality of the natural solution given in proposition [ ub ] . for the map oracle ,",
    "we show that quadratic exploration time can not be beaten , and we give a lower bound on the size of advice sufficient to guarantee this time . for the instance oracle ,",
    "we show that proposition [ ub ] gives optimal advice for linear exploration time .",
    "our first result for the map oracle shows that , regardless of the size of advice , exploration time @xmath8 can not be beaten , for some @xmath0-node graphs .",
    "we will use the following construction from @xcite of a family @xmath114 of graphs .",
    "let @xmath115 be an @xmath116-regular graph with @xmath117 nodes , where @xmath117 is even , e.g. , the complete bipartite graph .",
    "let @xmath108 be the set of edges of any spanning tree of @xmath115 .",
    "let @xmath29 be the set of edges of @xmath115 outside @xmath108 .",
    "let @xmath118 and @xmath119 .    for @xmath120 , the @xmath121-node graph @xmath122 is constructed from @xmath115 by taking two disjoint copies @xmath123 and @xmath124 of @xmath115 , and crossing some pairs of edges from one copy to the other . for @xmath125 ,",
    "if the @xmath126th bit of @xmath36 is 1 , then the edge @xmath127 is deleted from both copies of @xmath115 and two copies of @xmath128 are crossed between the two copies of @xmath115 .",
    "more precisely , let @xmath129 be the set of nodes of @xmath115 and let @xmath130 and @xmath131 be the nodes corresponding to @xmath132 , in @xmath123 and @xmath124 , respectively .",
    "let @xmath133 and @xmath134 be the sets of nodes of @xmath123 and @xmath124 , respectively .",
    "define @xmath135 , where @xmath136 .",
    "let @xmath137 .    according to the result from @xcite , for every node @xmath138",
    ", there exists some sequence @xmath139 such that if an exploration of @xmath115 performed according to some sequence @xmath140 of port numbers , starting from node @xmath141 , visits node @xmath3 at most @xmath35 times , then in one of the copies @xmath123 or @xmath124 in @xmath142 the node @xmath143 or @xmath144 is not visited at all , if the same sequence @xmath140 is used to explore the graph @xmath142 starting from @xmath145 .",
    "intuitively , the result from @xcite shows a class of graphs with the property that if some node in one of these graphs is not visited many times , then the exploration algorithm fails _ in some other graph _ of this class .",
    "there is no control in which graph of the class this will happen .",
    "we use the graphs from @xcite as building blocks to prove a different kind of lower bound .",
    "indeed , we construct a _ single graph _ having the property that if some of its nodes is not visited many times , then exploration must fail in this graph .",
    "this will prove a lower bound on exploration time for some graph , even if the agent knows the entire graph .    using the graphs",
    "@xmath146 from @xcite we construct the graph @xmath147 as follows . for any @xmath148 ,",
    "let @xmath149 be the node corresponding to node @xmath150 from @xmath123 in the graph @xmath151 .",
    "connect the graphs @xmath151 , for @xmath148 , and an oriented cycle @xmath152 with nodes @xmath153 ( port numbers 0,1 are in clockwise order at each node of the cycle ) , by adding edges @xmath154 , for @xmath148 .",
    "the port numbers corresponding to these edges are : 2 at @xmath155 and @xmath116 at @xmath156 . see fig .",
    "[ graph g^ ] . the cycle @xmath152 is called the",
    "_ main cycle _ of @xmath147 .",
    ", scaledwidth=40.0% ]    let @xmath157 be the number of nodes in @xmath147 .    by the construction of @xmath147 ,",
    "any exploration algorithm with the agent starting from any node of the main cycle , has the following _ obliviousness property_. for any step @xmath23 of the algorithm , if the agent is at some node @xmath3 in this step , and the algorithm prescribes taking some port @xmath158 at this node , then the port @xmath159 through which the agent enters the adjacent node @xmath22 in the @xmath160-th step , and the degree of the node @xmath22 are predetermined ( i.e. , they are independent of the starting node in the main cycle ) . intuitively , the agent does not learn anything during the algorithm execution .",
    "therefore , every exploration algorithm with the agent starting from any node of the main cycle can be uniquely coded by a sequence of port numbers which the agent takes in consecutive steps of its exploration .",
    "let @xmath161 be any exploration algorithm for @xmath147 , and suppose that the agent starts from some node of the main cycle .",
    "we use @xmath162 for concatenation of sequences .",
    "[ repr ] let @xmath163 be the sequence of port numbers corresponding to the movement of the agent according to algorithm @xmath161 , starting at some node of the main cycle @xmath152 of @xmath147 .",
    "then @xmath164 , where each @xmath165 is a sequence of port numbers corresponding to the movement of the agent along @xmath152 and each @xmath166 is a sequence of port numbers corresponding to the movement of the agent inside some @xmath151 .",
    "let the agent start from @xmath167 .",
    "let @xmath168 be the first node where the agent takes the port 2 .",
    "let @xmath169 be the sequence of port numbers corresponding to the movement from @xmath167 to @xmath168 . at @xmath168 ,",
    "the agent takes the port 2 .",
    "let @xmath170 be the sequence of port numbers corresponding to the movement of the agent after it takes the port 2 and before it takes the port @xmath116 at @xmath171 .",
    "therefore the sequence of port numbers until this moment can be written as @xmath172 .",
    "continuing in this way , the sequence @xmath163 of port numbers can be written as @xmath173 .",
    "call an exploration algorithm of @xmath147 _ non - repetitive _ ,",
    "if the agent , starting from the main cycle , enters each @xmath151 , for @xmath148 , exactly once . by definition",
    ", the sequence of port numbers corresponding to a non - repetitive algorithm can be written as @xmath174 , where each @xmath175 is a sequence of port numbers corresponding to the movement of the agent along @xmath152 and each @xmath176 is a sequence of port numbers corresponding to the movement of the agent inside some @xmath151 .",
    "notice that since the algorithm is non - repetitive , the number of blocks @xmath176 is exactly @xmath117 .",
    "the following lemma proves that to show a lower bound on the exploration time in @xmath147 , it is enough to consider only the class of non - repetitive algorithms .",
    "[ non - rep ] if the agent starts from some node of the main cycle of @xmath147 and executes any exploration algorithm @xmath161 of @xmath147 , then there exists a non - repetitive algorithm @xmath177 for this agent , such that the time of @xmath177 is at most the time of @xmath161 .",
    "@xmath164 be the sequence of port numbers corresponding to the algorithm @xmath161 , represented as in lemma [ repr ] .",
    "for any @xmath178 , consider all the blocks @xmath179 corresponding to moves of the agent inside @xmath180 , and let @xmath176 be the concatenation of all these blocks .",
    "delete all these blocks together with the preceding @xmath181 and succeeding @xmath182 for each block .",
    "put @xmath183 at the position of the first deleted block .",
    "consider the sequence @xmath184 , which results from this operation performed for all @xmath178 . by definition",
    ", the sequence @xmath184 of port numbers corresponds to a non - repetitive algorithm , and the length of @xmath184 is less or equal to the length of @xmath163 .",
    "hence the lemma follows .",
    "the next lemma implies that the sequence @xmath163 corresponding to a correct non - repetitive exploration algorithm must be long .",
    "let @xmath185 be the sequence of port numbers corresponding to a non - repetitive algorithm .",
    "if there exists some @xmath186 such that the agent following @xmath186 in @xmath115 starting from node @xmath141 visits some node @xmath187 of @xmath115 at most @xmath35 times , then there exists a starting node in the main cycle of @xmath147 , such that the agent starting at this node and following @xmath163 does not visit all the nodes of @xmath147 .",
    "[ lem : lemmap1 ]    suppose that there exists some @xmath186 such that the agent following @xmath186 in @xmath115 starting from node @xmath141 visits some node @xmath187 of @xmath115 at most @xmath35 times .",
    "choose the starting node of the agent in the main cycle of @xmath147 , so that the part of its trajectory corresponding to @xmath186 visits @xmath180",
    ". then by the property of @xmath180 , at least one copy of @xmath187 in @xmath180 will not be explored by the agent . since @xmath180 is visited by the agent only when it follows @xmath186 , some node in @xmath147 is not explored by the agent following  @xmath163 .",
    "any exploration algorithm using any advice given by a map oracle must take time @xmath17 on graph @xmath147 , for some starting node in the main cycle , for arbitrarily large @xmath0 .",
    "[ th : thmap ]    by lemma [ non - rep ] , it is enough to consider only non - repetitive algorithms .",
    "let @xmath185 be the sequence of port numbers corresponding to such an algorithm .",
    "then by lemma [ lem : lemmap1 ] , for each @xmath23 , @xmath148 , the agent following @xmath186 in @xmath115 starting from node @xmath141 visits each node @xmath187 of @xmath115 , for @xmath178 , at least @xmath188 times . therefore the length of @xmath186 is at least @xmath189 .",
    "hence , the length of @xmath163 is at least @xmath190 . since @xmath191 ,",
    "the length of @xmath163 is in @xmath17 .",
    "theorem [ th : thmap ] shows that , for some @xmath0-node graph , no advice given by a map oracle can help to explore this graph in time better than @xmath8 .",
    "it is then natural to ask what is the minimum size of advice to achieve time @xmath8 with a map oracle , for every @xmath0-node graph .",
    "our next result shows that any exploration algorithm using advice of size @xmath192 for @xmath193 , must take time @xmath194 , on some @xmath0-node graph .",
    "fix a constant @xmath195 .",
    "let @xmath115 be an @xmath116-regular graph with @xmath117 nodes , where @xmath117 is even .",
    "let @xmath129 be the set of nodes of @xmath115 .",
    "consider a subset @xmath196 of size @xmath197 .",
    "let @xmath198 and @xmath199 .",
    "we construct an @xmath0-node graph @xmath200 from @xmath115 .",
    "the construction of @xmath200 is similar to the construction of @xmath147 at the beginning of this section .",
    "let @xmath201 . to construct @xmath200 , connect the ( previously described ) graphs @xmath202 , for @xmath203 , and an oriented cycle @xmath204 ( called the main cycle ) with nodes @xmath205 , by adding edges @xmath206 , for @xmath203 .",
    "the port numbers corresponding to these edges are : 2 at @xmath155 and @xmath116 at @xmath207 . note that the same obliviousness property applies to exploration algorithms in graphs @xmath200 , when the agent starts from a node of the main cycle .",
    "let @xmath208 be the set of all possible graphs @xmath200 constructed from @xmath115 .",
    "we have @xmath209 .",
    "[ exceed ] for any @xmath210 , any exploration algorithm using advice of size @xmath211 must take time @xmath194 on some graph of the class @xmath208 and for some starting node in the main cycle of this graph , for arbitrarily large @xmath0 .",
    "since @xmath210 , there exists an integer @xmath5 such that @xmath212 . we show that if the size of the advice is at most @xmath213 , then there exists a graph in @xmath208 for which the time required for exploration is @xmath194 .",
    "we have @xmath214 .",
    "there are fewer than @xmath215 different binary strings of length at most @xmath216 . by the pigeonhole principle",
    ", there exists a family of graphs @xmath217 of size at least @xmath218 such that all the graphs in @xmath219 get the same advice .",
    "define @xmath220 . intuitively , @xmath221 is the subset of nodes of @xmath115 , such that for each @xmath222 , there exists some graph in @xmath219 that contains @xmath142 as a subgraph .",
    "* claim : * @xmath223 .",
    "we prove the claim by contradiction .",
    "suppose that @xmath224 .",
    "each graph in @xmath219 has @xmath158 different subgraphs @xmath142 , where @xmath225 .",
    "there are @xmath226 different graphs in @xmath219 which is at most @xmath227 .",
    "this contradiction proves the claim .",
    "consider the exploration of some graph @xmath228 starting from the main cycle .",
    "let @xmath229 be the sequence of port numbers corresponding to a non - repetitive algorithm exploring @xmath200 .",
    "then for each @xmath23 , @xmath230 , the agent following @xmath186 in @xmath115 starting from node @xmath141 must visit each node @xmath222 at least @xmath188 times .",
    "( otherwise , there would exist a graph in @xmath219 and a starting node in the main cycle , for which one node would not be explored by @xmath163 ) .",
    "hence , for sufficiently large @xmath117 , the length of @xmath186 is at least @xmath231 , because @xmath232 .",
    "therefore , the length of @xmath163 is at least @xmath233 . since @xmath212",
    ", we have @xmath234 .",
    "therefore , the length of @xmath163 is in @xmath235 , and hence exploration time is in @xmath194 .    since @xmath195 implies @xmath236 , theorem [ exceed ] yields the following corollary .",
    "for any @xmath237 , any exploration algorithm using advice of size @xmath238 must take time @xmath194 on some @xmath0-node graph , for arbitrarily large @xmath0 .      for the instance oracle",
    "we show a general lower bound on the size of advice needed to achieve a given exploration time .",
    "the main corollaries of this lower bound are :    * the size of advice @xmath38 from proposition [ ub ] , sufficient to achieve linear exploration time , can not be beaten ; * for advice of linear size , exploration time must be quadratic .    to prove our lower bound we will use the following construction .",
    "let @xmath34 be an @xmath239-regular @xmath240-node graph , where @xmath0 is divisible by 4 .",
    "we can use , for example the complete bipartite graph with @xmath240 nodes .",
    "let @xmath241 .",
    "let @xmath141 , @xmath242 , @xmath243 , @xmath244 be the nodes of @xmath34 .",
    "let @xmath245 be a sequence of @xmath117 integers where @xmath246 , for @xmath247 .",
    "let @xmath49 be the set of all such sequences .",
    ".5   from @xmath34,title=\"fig : \" ]    .5   from @xmath34,title=\"fig : \" ]    we construct an @xmath0-node graph @xmath248 as follows . for each @xmath247 , add a new node @xmath249 of degree 1 to @xmath34 . replace the port number @xmath250 at @xmath132 by port number @xmath116 .",
    "add the edge @xmath251 with the port number @xmath250 at @xmath132 .",
    "an example of the construction of @xmath248 from @xmath34 is shown in fig .",
    "[ fig : fig1 ] .",
    "let @xmath114 be the set of all possible graphs @xmath248 constructed from @xmath34 .",
    "[ th : instance1 ] for any function @xmath252 , and for any exploration algorithm using advice of size @xmath253 , this algorithm must take time @xmath254 on some @xmath0-node graph from the family @xmath114 , for arbitrarily large integers @xmath0 .",
    "let @xmath0 be divisible by 4 . we show that if the size of the advice is at most @xmath255 , then there exists an @xmath0-node graph in the family @xmath114 , for which the time required for exploration is @xmath254 .",
    "we have @xmath256 .",
    "there are fewer than @xmath257 different binary strings of length at most @xmath258 . by the pigeonhole principle",
    ", there exists a family of graphs @xmath259 , of size at least @xmath260 , such that all the graphs in @xmath261 get the same advice .",
    "let @xmath262 .",
    "let @xmath263 and let @xmath264 . intuitively , @xmath265 is the set of indices , for which the set of terms of sequences @xmath36 that produce graphs from @xmath261 is large .",
    "let @xmath266 .",
    "* claim : * @xmath267 .",
    "we prove the claim by contradiction .",
    "suppose that @xmath268 .",
    "since @xmath269 and @xmath270 , we have @xmath271 . note that for all @xmath272 , we have @xmath273 , and for @xmath274 , we have @xmath275 . therefore , @xmath276 .",
    "hence , @xmath277 , which is a contradiction .",
    "this proves the claim .",
    "consider any exploration algorithm for the class @xmath261 .",
    "there exists a graph @xmath278 , such that , at each node @xmath187 of @xmath248 , for @xmath274 , the agent must take all the ports in @xmath279 . indeed , suppose that the agent does not take some port @xmath280 , where @xmath281 and @xmath282 . consider the exploration of any graph @xmath283 , where @xmath284 . since the agent can visit @xmath285 only coming from @xmath187 ,",
    "using port @xmath286 in @xmath287 , the node @xmath285 remains unexplored , as the port @xmath286 at @xmath187 is never used , which is a contradiction .",
    "hence , the agent must visit at least @xmath288 ports at each node @xmath187 for @xmath274 .",
    "since @xmath289 , the time required for exploration is at least @xmath290 , i.e. , it is at least @xmath291 .    if @xmath292 where @xmath5 is a constant , then theorem [ th : instance1 ] implies that any exploration algorithm using advice of size at most @xmath293 , must take time at least @xmath294 .",
    "this implies that , if the size of advice is at most @xmath295 , for any constant @xmath296 , then exploration time is @xmath17 .",
    "hence we have the following corollary .",
    "any exploration algorithm using advice of size @xmath13 must take time @xmath17 on some @xmath0-node graph , for arbitrarily large @xmath0 .    for @xmath297 , theorem [ th : instance1 ]",
    "implies an exploration time @xmath298 which shows that the upper bound on the size of advice from proposition [ ub ] is asymptotically tight for exploration in linear time .",
    "the following corollary improves this statement significantly , showing that exploration time is very sensitive to the size of advice at the threshold @xmath38 of the latter .",
    "[ th : instance2 ] consider any constant @xmath16 .",
    "any exploration algorithm using advice of size @xmath299 must take time @xmath300 , on some @xmath0-node graph , for arbitrarily large @xmath0 .    if the size of advice is @xmath14 , then it is @xmath301 , where @xmath302 , with @xmath303 as @xmath75 .",
    "theorem [ th : instance1 ] implies that exploration time must be @xmath304 .",
    "since , for any constant @xmath305 , we have @xmath306 , the corollary holds .",
    "in this section we turn attention to hamiltonian graphs .",
    "these graphs have a special feature from the point of view of exploration : with sufficiently large advice of appropriate type , the agent can explore a hamiltonian graph without any loss of time , visiting each node exactly once , i.e. , in time @xmath18 , for @xmath0-node graphs . indeed , an instance oracle can give as advice the sequence of port numbers along a hamiltonian cycle , from the starting node of the agent , and then the agent takes the prescribed ports in @xmath18 consecutive steps . since it is enough to give @xmath18 port numbers , and the binary representation of each port number uses @xmath307 bits , advice of size @xmath10 , given by an instance oracle , suffices .",
    "we show that neither the quality nor the size of advice can be decreased to achieve the goal of optimal exploration of hamiltonian graphs . to prove the first statement",
    ", we show a graph which is impossible to explore in time @xmath18 when advice of any size is given by a map oracle .",
    "indeed , we construct an @xmath0-node hamiltonian graph for which even knowing the entire map of the graph ( but not knowing its starting node ) an agent must use time @xmath17 to explore it . to prove the second statement , we construct a class of @xmath0-node hamiltonian graphs for which advice of size @xmath14 , even given by an instance oracle , is not enough to permit exploration of graphs in this class in time @xmath18 .",
    "indeed , we show more : any exploration algorithm using such advice must exceed the optimal time @xmath18 by a summand @xmath15 , for any @xmath19 , on some graph of this class .    in order to prove the first result",
    ", we construct a @xmath308-node hamiltonian graph @xmath309 from the @xmath0-node graph @xmath147 described in section [ sec : map ] .",
    "first , we consider an @xmath116-regular @xmath117-node hamiltonian graph @xmath115 ( for example , the complete bipartite graph ) .",
    "let @xmath310 be the nodes of @xmath115 along a hamiltonian cycle .",
    "the graph @xmath147 is constructed from @xmath115 as described in section [ sec : map ] , where the hamiltonian path @xmath311 is taken as the spanning tree @xmath108 .",
    "we construct the hamiltonian graph @xmath309 from the graph @xmath147 as follows .",
    "denote by @xmath312 the degree of node @xmath3 in @xmath147 .",
    "for each node @xmath3 in @xmath147 , consider a cycle of three nodes @xmath313 , @xmath314 , and @xmath315 , in @xmath309 , with port numbers @xmath316 in clockwise order at each of these three nodes .",
    "for each edge @xmath317 in @xmath147 , such that the port numbers corresponding to this edge are @xmath158 at @xmath21 and @xmath159 at @xmath3 , add , in @xmath309 , the edges @xmath318 , for @xmath319 , with the following port numbers .",
    "the port numbers corresponding to edge @xmath318 are : @xmath320 at @xmath321 and @xmath322 at @xmath323 , see fig .",
    "[ fig : ham1 ] .",
    ".5   from @xmath147,title=\"fig : \" ]    .5   from @xmath147,title=\"fig : \" ]    the graph @xmath309 is hamiltonian .    according to the definition of @xmath151 in section [ sec : map ] , this graph has a spanning tree @xmath324 that contains two copies of @xmath108 , corresponding to @xmath123 and @xmath124 , and an edge which crosses from @xmath123 to @xmath124 .",
    "consider the spanning tree @xmath325 of @xmath147 that contains all @xmath324 , for @xmath148 , a spanning path @xmath326 of the main cycle , and the set of edges @xmath154 .",
    "see fig . [",
    "fig : ham2 ] . note that the maximum degree of a node in @xmath325 is three . since each node in @xmath147",
    "is replaced by a cycle of three nodes in @xmath309 , an euler tour of the tree @xmath325 yields a hamiltonian cycle in @xmath309 .",
    "therefore , @xmath309 is hamiltonian .     of @xmath147,scaledwidth=70.0% ]",
    "let @xmath161 be an exploration algorithm for @xmath309 starting from node @xmath327 , for some @xmath328 .",
    "we describe the following algorithm @xmath329 on @xmath147 , starting from node @xmath155 .",
    "ignore all moves of @xmath161 taking port @xmath330 or @xmath331 at a node @xmath323 , for @xmath332 , of @xmath309 .",
    "replace every move of @xmath161 taking port @xmath333 , at node @xmath323 , for @xmath332 , in @xmath309 , where @xmath334 , by a move taking port @xmath158 in @xmath147 .",
    "then the agent executing @xmath329 in @xmath147 , starting from the main cycle , explores all the nodes . the time used by @xmath329 in @xmath147",
    "does not exceed the time used by @xmath161 in @xmath309 .",
    "since , by theorem [ th : thmap ] , any exploration algorithm for @xmath147 , starting from the main cycle , must take time @xmath17 , algorithm @xmath161 must take time @xmath17 to explore @xmath309 . replacing @xmath335 by @xmath0 we have the following theorem .",
    "any exploration algorithm using any advice given by a map oracle must take time @xmath17 on some @xmath0-node hamiltonian graph , for arbitrarily large @xmath0 .",
    "our last result shows that advice of size @xmath14 causes significant increase of exploration time for some hamiltonian graphs , as compared to optimal time @xmath18 achievable with advice of size @xmath10 , given by an instance oracle .    for any constant @xmath19 , and for any exploration algorithm using advice of size",
    "@xmath299 , this algorithm must take time @xmath336 , on some @xmath0-node hamiltonian graph , for arbitrarily large @xmath0 .",
    "fix a constant @xmath19 .",
    "we show that if the size of the advice is at most @xmath337 , then there exists an @xmath0-node graph , for which the time required for exploration is @xmath338 .",
    "the construction of the graphs is similar as in section [ sec : instance ] .",
    "now , we start with a @xmath239-regular @xmath240-node hamiltonian graph @xmath34 , for @xmath0 divisible by 4",
    ". we can use the complete bipartite graph with @xmath240 nodes , which is hamiltonian .",
    "we construct @xmath248 from @xmath34 as in section [ sec : instance ] .",
    "let @xmath339 be the nodes of @xmath34 along a hamiltonian cycle .",
    "let @xmath340 be the graph which is obtained from @xmath248 by adding the set of edges @xmath341 .",
    "each of these edges is given port number 2 at both its endpoints .",
    "an example of the construction of @xmath340 from @xmath34 is shown in fig .",
    "[ fig : ham3 ] . since @xmath34 is hamiltonian , @xmath340 is also hamiltonian , as @xmath342 is a hamiltonian cycle in @xmath340 .",
    "let @xmath343 be the set of all possible graphs @xmath340 constructed from @xmath34 .",
    "then @xmath344 , where @xmath241 .",
    "there are fewer than @xmath345 different binary strings of length @xmath346 . by the pigeonhole principle",
    ", there exists a family of graphs @xmath259 , of size at least @xmath347 , such that all the graphs in @xmath261 get the same advice .",
    "let @xmath348 .",
    "let @xmath349 and let @xmath264 .",
    "let @xmath266 . by similar arguments as in the proof of theorem [ th : instance1 ]",
    ", we have @xmath267 .",
    "therefore there exists some @xmath23 , @xmath148 for which both @xmath350 and @xmath351 belong to @xmath265 .",
    ".5   from @xmath34,title=\"fig : \" ]    .5   from @xmath34,title=\"fig : \" ]    consider any exploration algorithm for the class @xmath352 .",
    "let the agent start from some node @xmath353 , @xmath354 .",
    "the agent must traverse one of the edges @xmath355 or @xmath356 in order to visit the nodes @xmath357 and @xmath358 .",
    "hence , by a similar argument as in the proof of theorem [ th : instance1 ] , the agent must take at least @xmath359 ports at the node @xmath350 or @xmath351 , on some graph @xmath360 . to visit the remaining @xmath361 nodes ,",
    "the agent needs time at least @xmath362 .",
    "hence , the time required for visiting all the nodes of @xmath363 is at least @xmath364 , i.e. , the time required for exploration is @xmath365 .",
    "since this holds for any @xmath19 , the simpler lower bound @xmath336 , for any @xmath19 , holds as well , for arbitrarily large @xmath0 .",
    "most of our lower bounds on the size of advice are either exactly or asymptotically tight .",
    "the lower bound @xmath106 on the size of advice sufficient to explore all @xmath0-node graphs in polynomial time is exactly tight : with advice of any such size , polynomial exploration is possible , and with advice of any smaller size it is not . for an instance oracle , the lower bound @xmath366 on the size of advice sufficient to explore @xmath0-node graphs in @xmath13 time is asymptotically tight , as we gave a linear time exploration algorithm using advice of size @xmath10 .",
    "an exception to this tightness is the lower bound on the size of advice given by a map oracle , permitting exploration in time @xmath107 . while the natural upper bound is @xmath10 , our lower bound is only @xmath192 for any @xmath237 .",
    "hence the main remaining question is :              r. aleliunas , r. karp , r. lipton , l. lovasz c. rackoff , random walks , universal traversal sequences , and the complexity of maze problems , proc .",
    "20th annual ieee symposium on foundations of computer science ( focs 1979 ) , 218 - 223 .",
    "j. chalopin , s. das , a. kosowski , constructing a map of an anonymous graph : applications of universal sequences , proc .",
    "14th international conference on principles of distributed systems ( opodis 2010 ) , 119 - 134 .                  p. fraigniaud , d. ilcinkas , a. pelc , communication algorithms with advice , journal of computer and system sciences 76 ( 2010 ) , 222232 .",
    "p. fraigniaud , d. ilcinkas , a. pelc , tree exploration with advice , information and computation 206 ( 2008 ) , 12761287 .",
    "n. s. v. rao , s. kareti , w. shi and s.s .",
    "iyengar , robot navigation in unknown terrains : introductory survey of non - heuristic algorithms , tech .",
    "report ornl / tm-12410 , oak ridge national laboratory , july 1993 ."
  ],
  "abstract_text": [
    "<S> we consider the fundamental task of graph exploration . </S>",
    "<S> an @xmath0-node graph has unlabeled nodes , and all ports at any node of degree @xmath1 are arbitrarily numbered @xmath2 . </S>",
    "<S> a mobile agent , initially situated at some starting node @xmath3 , has to visit all nodes and stop . </S>",
    "<S> the _ time _ of the exploration is the number of edge traversals . </S>",
    "<S> we consider the problem of how much knowledge the agent has to have a priori , in order to explore the graph in a given time , using a deterministic algorithm . </S>",
    "<S> following the paradigm of _ algorithms with advice _ </S>",
    "<S> , this a priori information ( advice ) is provided to the agent by an _ oracle _ </S>",
    "<S> , in the form of a binary string , whose length is called the _ size of advice_. we consider two types of oracles . </S>",
    "<S> the _ instance oracle _ knows the entire instance of the exploration problem , i.e. , the port - numbered map of the graph and the starting node of the agent in this map . </S>",
    "<S> the _ map oracle _ knows the port - numbered map of the graph but does not know the starting node of the agent . </S>",
    "<S> what is the minimum size of advice that must be given to the agent by each of these oracles , so that the agent explores the graph in a given time ?    </S>",
    "<S> we first consider exploration in polynomial time , and determine the exact minimum size of advice to achieve it . indeed , we prove that some advice of size @xmath4 , for any constant @xmath5 , is sufficient to permit polynomial exploration , and that no advice of size @xmath6 , where @xmath7 is any function diverging to infinity , can help to do this . </S>",
    "<S> these results hold both for the instance and for the map oracles .    on the other side of the spectrum , when advice is large , there are two natural time thresholds : @xmath8 for a map oracle , and @xmath9 for an instance oracle . </S>",
    "<S> this is because , in both cases , these time benchmarks can be achieved with sufficiently large advice ( advice of size @xmath10 suffices ) . </S>",
    "<S> we show that , with a map oracle , time @xmath8 can not be improved in general , regardless of the size of advice . </S>",
    "<S> what is then the smallest advice to achieve time @xmath8 with a map oracle ? </S>",
    "<S> we show that this smallest size of advice is larger than @xmath11 , for any @xmath12 .    </S>",
    "<S> for large advice , the situation changes significantly when we allow an instance oracle instead of a map oracle . in this case , </S>",
    "<S> advice of size @xmath10 is enough to achieve time @xmath13 . </S>",
    "<S> is such a large advice needed to achieve linear time ? </S>",
    "<S> we answer this question affirmatively . indeed </S>",
    "<S> , we show more : with any advice of size @xmath14 , the time of exploration must be at least @xmath15 , for any @xmath16 , and with any advice of size @xmath13 , the time must be @xmath17 .    </S>",
    "<S> we finally look at hamiltonian graphs , as for them it is possible to achieve the absolutely optimal exploration time @xmath18 , when sufficiently large advice ( of size @xmath10 ) is given by an instance oracle . </S>",
    "<S> we show that a map oracle can not achieve this : regardless of the size of advice , the time of exploration must be @xmath17 , for some hamiltonian graphs . on the other hand , even for the instance oracle , with advice of size @xmath14 , optimal time @xmath18 can not be achieved : indeed , we show that the time of exploration with such advice must sometimes exceed the optimal time @xmath18 by a summand @xmath15 , for any @xmath19 .    * keywords : * algorithm , graph , exploration , mobile agent , advice    0.2 in 0.1 in 0em </S>"
  ]
}