{
  "article_text": [
    "multiuser scheduling is one of the core challenges in wireless communications . due to channel fading and wireless interference ,",
    "scheduling algorithms need to dynamically allocate resources based on both the demands of the users and the channel states to maximize network throughput .",
    "the celebrated maxweight algorithm developed in @xcite for exploiting channel variations works as follows .",
    "consider a network with a single base station and @xmath0 users , and further assume that the base station can transmit to only one user in each time slot .",
    "the maxweight algorithm computes the product of the queue length and current channel rate for each user , and chooses to transmit to that user which has the largest product ; ties can be broken arbitrarily .",
    "the throughput - optimality property of the maxweight algorithm was first established in @xcite , and the results were later extended to more general channel and arrival models in @xcite .",
    "the maxweight algorithm should be contrasted with other opportunistic scheduling such as @xcite which exploit channel variations to allocate resources fairly assuming continuously backlogged users , but which are not throughput - optimal when the users are not continuously backlogged .    while the results in @xcite demonstrate the power of maxweight - based algorithms , they were obtained under the assumptions that _ the number of users in the network",
    "is fixed and the traffic flow generated by each user is long - lived , i.e. , each user continually injects new bits into the network .",
    "_ however , practical networks have flow - level dynamics : users arrive to transmit data and leave the network after the data are fully transmitted . in a recent paper @xcite ,",
    "the authors show that the maxweight algorithm is in fact _ not throughput optimal _ in networks with flow - level dynamics by providing a clever example showing the instability of the maxweight scheduling .",
    "the intuition is as follows : if a long - lived flow does not receive enough service , its backlog builds up , which forces the maxweight scheduler to allocate more service to the flow .",
    "this interaction between user backlogs and scheduling guarantees the correctness of the resource allocation .",
    "however , if a flow has only a finite number of bits , its backlog does not build up over time and it is possible for the maxweight to stop serving such a flow and thus , the flow may stay in the network forever .",
    "thus , in a network where finite - size flows continue to arrive , the number of flows in the network could increase to infinity .",
    "one may wonder why flow - level instability is important since , in real networks , base stations limit the number of simultaneously active flows in the network by rejecting new flows when the number of existing flows reaches a threshold .",
    "the reason is that , if a network model without such upper limits is unstable in the sense that the number of flows grows unbounded , then the corresponding real network with an upper limit on the number of flows will experience high flow blocking rates .",
    "this fact is demonstrated in our simulations later .    in @xcite ,",
    "the authors address this instability issue of maxweight - based algorithms , and establish necessary and sufficient conditions for the stability of networks with flow - level dynamics .",
    "the authors also propose throughput - optimal scheduling algorithms .",
    "however , as the authors mention in @xcite , the proposed algorithms require prior knowledge of channel distribution and traffic distribution , which is difficult and sometimes impossible to obtain in practical systems , and further , the performance of the proposed algorithms is also not ideal .",
    "a delay - driven maxweight scheduler has also been proposed to stabilize the network under flow - level dynamics @xcite .",
    "the algorithm however works only when the maximum achievable rates of the flows are identical .    since flow arrivals and departures are common in reality , we are interested in developing practical scheduling algorithms that are throughput - optimal _ under flow - level dynamics .",
    "_ we consider a wireless system with a single base station and multiple users ( flows ) .",
    "the network contains both long - lived flows , which keep injecting bits into the network , and short - lived flows , which have a finite number of bits to transmit .",
    "the main contributions of this paper include the following :    * we obtain the necessary conditions for flow - level stability of networks with both long - lived flows and short - lived flows .",
    "this generalizes the result in @xcite , where only short - lived flows are considered .",
    "* we propose a simple algorithm for networks with short - lived flows only . under this algorithm",
    ", each flow keeps track of the best channel condition that it has seen so far . each flow",
    "whose current channel condition is equal to the best channel condition that it has seen during its lifetime is eligible for transmission .",
    "it is shown that an algorithm which uniformly and randomly chooses a flow from this set of eligible flows for transmission is throughput - optimal .",
    "note that the algorithm is a purely opportunistic algorithm in that it selects users for transmission when they are in the best channel state that they have seen so far , without considering their backlogs . * based on an optimization framework , we propose to use the estimated _ workload _ , the number of time slots required to transmit the remainder of a flow based on the best channel condition seen by the flow so far , to measure the backlog of short - lived flows . by comparing this short - lived flow backlog to the queue lengths and channel conditions of the long - lived flows ,",
    "we develop a new algorithm , named workload - based scheduling with learning , which is throughput - optimal under flow - level dynamics .",
    "the term `` learning '' refers to the fact that the algorithm learns the best channel condition for each short - lived flow and attempts to transmit when the channel condition is the best .",
    "* we use simulations to evaluate the performance of the proposed scheduling algorithm , and observe that the workload - based scheduling with learning performs significantly better than the maxweight scheduling in various settings .",
    "the terminology of long - lived and short - lived flows above has to be interpreted carefully in practical situations . in practice",
    ", each flow has a finite size and thus , all flows eventually will leave the system if they receive sufficient service .",
    "thus , all flows are short - lived flows in reality .",
    "our results suggest that transmitting to users who are individually in their best estimated channel state so far is thus , throughput optimal . on the other hand ,",
    "it is also well known that real network traffic consists of many flows with only a few packets and a few flows with a huge number of packets .",
    "if one considers the time scales required to serve the small - sized flows , the large - sized flows will appear to be long - lived ( i.e. , persistent forever ) in the terminology above .",
    "thus , if one is interested in performance over short time - scales , an algorithm which considers flows with a very large number of packets as being long - lived may lead to better performance and hence , we consider the more general model which consists of both short - lived flows and long - lived flows .",
    "our simulations later confirm the fact that the algorithm which treats some flows are being long - lived leads to better performance although throughput - optimality does not require such a model .",
    "in addition , long - lived flows partially capture the scenario where all bits from a flow do not arrive at the base station all at once .",
    "this fact is also exploited in our simulation experiments .",
    "* network model : * we consider a discrete - time wireless downlink network with a single base station and many flows , each flow associates with a distinct mobile user .",
    "the base station can serve only one flow at a time .",
    "* traffic model : * the network consists of the following two types of flows :    * * long - lived flows : * long - lived flows are traffic streams that are always in the network and continually generate bits to be transmitted . * * short - lived flows : * short - lived flows are flows that have a finite number of bits to transmit .",
    "a short - lived flow enters the network at a certain time , and leaves the system after all bits are transmitted .",
    "we assume that the set of long - lived flows is fixed , and short - lived flows arrive and depart .",
    "we let @xmath1 be the index for long - lived flows , @xmath2 be the set of long - lived flows , and @xmath3 be the number of long - lived flows , i.e. , @xmath4 furthermore , we let @xmath5 be the number of new bits injected by long - lived flow @xmath1 in time slot @xmath6 where @xmath5 is a discrete random variable with finite support , and independently and identically distributed ( i.i.d . ) across time slots .",
    "we also assume @xmath7=x_l$ ] and @xmath8 for all @xmath1 and @xmath9    similarly , we let @xmath10 be the index for short - lived flows , @xmath11 be the set of short - lived flows in the network at time @xmath6 and @xmath12 be the number of short - lived flows at time @xmath6 i.e. , @xmath13 we denote by @xmath14 the size ( total number of bits ) of short - lived flow @xmath15 and assume @xmath16 for all @xmath17    it is important to note that we allow different short - lived flows to have different maximum link rates .",
    "a careful consideration of our proofs will show the reader that the learning algorithm is not necessary if all users have the same maximum rate and that one can simply transmit to the user with the best channel state if it is assumed that all users have the same maximum rate .",
    "however , we do not believe that this is a very realistic scenario since snr variations will dictate different maximum rates for different users .    * residual size and queue length : * for a short - lived flow @xmath15 let @xmath18 which we call the residual size , denote the number of bits still remaining in the system at time @xmath19",
    ". for a long - lived flow @xmath20 let @xmath21 denote the number of bits stored at the queue at the base station .",
    "* channel model : * there is a wireless link between each user and the base station .",
    "denote by @xmath22 the state of the link between short - lived flow @xmath10 and the base station at time @xmath19 ( i.e. , the maximum rate at which the base station can transmit to short - lived flow @xmath10 at time @xmath19 ) , and @xmath23 the state of the link between long - lived flow @xmath1 and the base station at time @xmath9 we assume that @xmath22 and @xmath23 are discrete random variables with finite support .",
    "define @xmath24 and @xmath25 to be the largest values that these random variables can take , i.e. , @xmath26 for each @xmath27    blackchoose    @xmath28 and @xmath29 such that @xmath30 the states of wireless links are assumed to be independent across flows and time slots ( but not necessarily identically distributed across flows ) .",
    "the independence assumption across time slots can be relaxed easily but at the cost of more complicated proofs .",
    "in this section , we introduce a new scheduling algorithm called workload - based scheduling with learning ( wsl ) .    * workload - based scheduling with learning : * for a short - lived flow @xmath15 we define @xmath31 where @xmath32 is the time short - lived flow @xmath10 joins the network and @xmath33 is called the learning period .",
    "a key component of this algorithm is to use @xmath34 to evaluate the workload of short - lived flows ( the reason will be explained in a detail in section [ sec : th ] ) .",
    "however , @xmath24 is in general unknown , so the scheduling algorithm uses @xmath35 as an estimate of @xmath36    during each time slot , the base station first checks the following inequality : @xmath37 where @xmath38    = 1em    if inequality ( [ eq : svsl ] ) holds , then the base station serves a short - lived flow as follows : if at least one short - lived flow ( say flow @xmath10 ) satisfies @xmath39 or @xmath40 then the base station selects such a flow for transmission ( ties are broken according to a _ good _ tie - breaking rule , which is defined at the end of this algorithm ) ; otherwise , the base station picks an arbitrary short - lived flow to serve .    if inequality ( [ eq : svsl ] ) does not hold , then the base station serves a long - lived flow @xmath41 such that @xmath42 ( ties are broken arbitrarily ) .    *",
    "`` good '' tie - breaking rule : * assume that the tie - breaking rule is applied to pick a short - lived flow every time slot ( but the flow is served only if @xmath43 ) .",
    "we define @xmath44 to be the event that the tie - breaking rule selects a short - lived flow with @xmath45    black define @xmath46 which is he total workload of the system at time @xmath9    a tie - breaking rule is said to be _ good _ if the following condition holds : consider the wsl with the given tie - breaking rule and learning period @xmath47 given any @xmath48 there exist @xmath49 and @xmath50 such that @xmath51 if @xmath52 and @xmath53    _ remark 1 : _ while all wsl scheduling algorithms with good tie - breaking rules are throughput optimal , their performances in terms of other metrics could be different depending upon the tie - breaking rules .",
    "we consider two tie - breaking rules in this paper :    * * uniform tie - breaking : * among all short - lived flows satisfying @xmath54 or @xmath55 the base - station uniformly and randomly selects one to serve . * * oldest - first tie - breaking : * let @xmath56 denote the number of time slots a short - lived flow has been in the network .",
    "the base station keeps track @xmath57 for every short - lived flow , where @xmath58 is some fixed positive integer . among all short - lived flows satisfying @xmath54 or",
    "@xmath55 the tie - breaking rule selects the one with the largest @xmath59 and the ties are broken uniformly and randomly . on @xmath60 for technical reasons that facilitate the throughput - optimality proof .",
    "since @xmath58 can be arbitrarily large , we conjecture that this upper bound is only for analysis purpose , and not required in practical systems . ]",
    "the `` goodness '' of these two tie - breaking rules are proved in appendix c and d , and the impact of the tie - breaking rules on performance is studied in section [ sec : simu ] using simulations .",
    "_ remark 2 : _",
    "the @xmath61 in inequality ( [ eq : svsl ] ) is a parameter balancing the performance of long - lived flows and short - lived flows .",
    "a large @xmath61 will lead to a small number of short - lived flows but large queue - lengths of long - lived flows , and vice versa .",
    "_ remark 3 : _ in theorem [ thm : learning ] , we will prove that wsl is throughput optimal when @xmath62 is sufficiently large . from purely throughput - optimality considerations",
    ", it is then natural to choose @xmath63 however , in practical systems , if we choose @xmath62 too large , such as @xmath64 then it is possible that a flow may stay in the system for a very long time if its best channel condition occurs extremely rarely .",
    "thus , it is perhaps best to choose a finite @xmath62 to tradeoff between performance and throughput .",
    "_ remark 4 : _",
    "if all flows are short - lived , then the algorithm simplifies as follows : if at least one short - lived flow ( say flow @xmath10 ) satisfies @xmath39 or @xmath40 then the base station selects such a flow for transmission according to a `` good '' tie - breaking rule ; otherwise , the base station picks an arbitrary short - lived flow to serve",
    ". simply stated , the algorithm serves one of the flows which can be completely transmitted or sees its best channel state , where the best channel state is an estimate based on past observations .",
    "if no such flow exists , any flow can be served .",
    "we do not separately prove the throughput optimality of this scenario since it is a special case of the scenario considered here .",
    "but it is useful to note that , in the case of short - lived flows only , the algorithm does not consider backlogs at all in making scheduling decisions .",
    "we will prove that wsl ( with any @xmath65 ) is throughput - optimal in the following sections , i.e. , the scheduling policy can support any set of traffic flows that are supportable by any other algorithm . in the next section , we first present the necessary conditions for the stability , which also define the network throughput region .",
    "in this section , we establish the necessary conditions for the stability of networks with flow - level dynamics . to get the necessary condition",
    ", we need to classify the short - lived flows into different classes .",
    "= 1em    a short - lived flow class is defined by a pair of random variables @xmath66 .",
    "class-@xmath67 is associated with random variables @xmath68 and @xmath69 to indicate that the notation is associated with a class of short - lived flows instead of an individual short - lived flow . ]",
    "a short - lived flow @xmath10 belongs to class @xmath67 if @xmath22 has the same distribution as @xmath68 and the size of flow @xmath10 ( @xmath14 ) has the same distribution as @xmath69 we let @xmath70 denote the number of class-@xmath67 flows joining the network at time @xmath6 where @xmath70 are i.i.d . across time slots    blackand",
    "independent but not necessarily identical across classes ,    and @xmath71=\\lambda_k.$ ] denote by @xmath72 the set of distinct classes .",
    "we assume that @xmath72 is finite , @xmath73 and @xmath74\\leq \\lambda^{\\max}$ ] for all @xmath19 and @xmath75    let @xmath76 denote an @xmath3-dimensional vector describing the state of the channels of the long - lived flows . in state @xmath77 @xmath78 is the service rate that long - lived flow @xmath1 can receive if it is scheduled .",
    "we denote by @xmath79 the set of all possible states .",
    "let @xmath80 denote the state of the long - lived flows at time @xmath6 and @xmath81 denote the probability that @xmath80 is in state @xmath82    let @xmath83 be the probability that the base station serves flow @xmath1 when the network is in state @xmath82 clearly , for any @xmath77 we have @xmath84 note that the sum could be less than @xmath85 if the base station schedules a short - lived flow in this state .",
    "let @xmath86 be the probability that the base station serves a short - lived flow when the network is in state @xmath82    let @xmath87 denote the number of short - lived flows that belong to class-@xmath67 and have residual size @xmath88 note that @xmath60 can only take on a finite number of values .",
    "consider traffic parameters @xmath89 and @xmath90 and suppose that there exists a scheduling policy guaranteeing @xmath91<\\infty.\\ ] ] then there exist @xmath92 and @xmath86 such that the following inequalities hold : @xmath93\\leq \\sum_{\\mathbf{c}\\in{\\cal c}}\\mu_{\\mathbf{c},s}\\pi_{\\mathbf{c}}.&\\label{nc : s2}\\\\ & \\displaystyle \\left(\\sum_{l\\in{\\cal l}}p_{\\mathbf{c},l}\\right)+\\mu_{\\mathbf{c},s}\\leq 1 \\hbox { } \\forall c\\in{\\cal c}. & \\label{nc : s}\\end{aligned}\\ ] ] [ thm : nc ]    inequality ( [ nc : l ] ) and ( [ nc : s2 ] ) state that the service allocated should be no less than the user requests if the flows are supportable .",
    "inequality ( [ nc : s ] ) states that the overall time used to serve long - lived and short - lived flows should be no more than the time available .",
    "black to prove this theorem , it can be shown that for any traffic for which we can not find @xmath92 and @xmath86 satisfying the three inequalities in the theorem , a lyapunov function can be constructed such that the expected drift of the lyapunov function is larger than some positive constant under any scheduling algorithm , which implies the instability of the network .    the complete proof is based on the strict separation theorem and is along the lines of a similar proof in @xcite ,    blackand is omitted in this paper .",
    "first , we provide some intuition into how one can derive the wsl algorithm from optimization decomposition considerations",
    ". then , we will present our main throughput optimality results .",
    "given traffic parameters @xmath89 and @xmath90 the necessary conditions for the supportability of the traffic is equivalent to the feasibility of the following constraints : @xmath94\\leq \\sum_{\\mathbf{c}\\in{\\cal c } } \\mu_{\\mathbf{c},s}\\pi_{\\mathbf{c}}\\label{nc : sf}\\\\ & \\sum_{l\\in{\\cal l } } p_{\\mathbf{c},l}+\\mu_{\\mathbf{c},s}\\leq 1 & \\forall \\mathbf{c}.\\nonumber\\end{aligned}\\ ] ] for convenience , we view the feasibility problem as an optimization problem with the objective @xmath95 where @xmath96 is some constant .",
    "while we have not explicitly stated that the @xmath97 s and @xmath98 s are non - negative , this is assumed throughout .    partially augmenting the objective using lagrange multipliers",
    ", we get @xmath99- \\sum_{\\mathbf{c}\\in{\\cal c } } \\mu_{\\mathbf{c},s}\\pi_{\\mathbf{c}}\\right)\\\\ s.t.&\\sum_{l\\in{\\cal",
    "l } } p_{\\mathbf{c},l}+\\mu_{\\mathbf{c},s}\\leq 1 \\hbox { } \\forall \\mathbf{c}.\\end{aligned}\\ ] ] for the moment , let us assume lagrange multipliers @xmath100 and @xmath101 are given .",
    "then the maximization problem above can be decomposed into a collection of optimization problems , one for each @xmath102 @xmath103 it is easy to verify that one optimal solution to the optimization problem above is :    = 1em    if @xmath104 then @xmath105 and @xmath106    otherwise , @xmath107 and @xmath108 for some @xmath109 and @xmath110 for other @xmath111    the complementary slackness conditions give @xmath112 since @xmath113 is the mean arrival rate of long - lived flow @xmath1 and @xmath114 is the mean service rate , the condition on @xmath100 says that if the mean arrival rate is less than the mean service rate , @xmath100 is equal to zero . along with the non - negativity condition on @xmath115",
    "this suggests that perhaps @xmath100 behaves likes a queue with these arrival and service rates .",
    "indeed , it turns out that the mean of the queue lengths are proportional to lagrange multipliers ( see the surveys in @xcite ) . for long - lived flow @xmath20 we can treat the queue - length @xmath21 as a time - varying estimate of lagrange multiplier @xmath116 similarly @xmath101 can be associated with a queue whose arrival rate is @xmath117,$ ] which is the mean rate at which workload arrives where workload is measured by the number of slots needed to serve a short - lived flow if it is served when its channel condition is the best .",
    "the service rate is @xmath118 which is the rate at which the workload can potentially decrease when a short - lived flow is picked for scheduling by the base station .",
    "thus , the workload in the system can serve as a dynamic estimate of @xmath119    letting @xmath120 ( @xmath65 ) be an estimate of @xmath121 the observations above suggest the following workload - based scheduling algorithm if @xmath24 are known",
    ".    * workload - based scheduling ( ws ) : * during each time slot , the base station checks the following inequality : @xmath122    = 1em    if inequality ( [ eq : svsl1 ] ) holds , then the base station serves a short - lived flow as follows : if at least one short - lived flow ( say flow @xmath10 ) satisfies @xmath39 or @xmath123 then such a flow is selected for transmission ( ties are broken arbitrarily ) ; otherwise , the base station picks an arbitrary short - lived flow to serve .    if inequality ( [ eq : svsl1 ] ) does not hold , then the base station serves a long - lived flow @xmath41 such that @xmath124 ( ties are broken arbitrarily )",
    ".    the factor @xmath61 can be obtained from the optimization formulation by multiplying constraint ( [ nc : sf ] ) by @xmath61 on both sides    however , this algorithm which was directly derived from dual decomposition considerations is not implementable since @xmath24 s are unknown .",
    "so wsl uses @xmath35 to approximate @xmath36 note that an inaccurate estimate of @xmath125 not only affects the base station s decision on whether @xmath126 but also on its computation of @xmath127 however , it is not difficult to see that the error in the estimate of the total workload is a small fraction of the total workload when the total workload is large : when the workload is very large , the total number of short - lived flows is large since their file sizes are bounded .",
    "since the arrival rate of short - lived flows is also bounded , this further implies that the majority of short - lived flows must have arrived a long time ago which means that with high probability , their estimate of their best channel condition must be correct .",
    "next we will prove that both ws and wsl can stabilize any traffic @xmath113 and @xmath128 such that @xmath129 and @xmath130 are _ supportable , _",
    "i.e. , satisfying the conditions presented in theorem [ thm : nc ] .",
    "in other words , the number of short - lived flows in the network and the queues for long - lived flows are all bounded . even though ws is not practical , we study it first since the proof of its throughput optimality is easier and provides insight into the proof of throughput - optimality of wsl .",
    "let @xmath131 since the base station makes decisions on @xmath132 and @xmath133 under ws .",
    "it is easy to verify that @xmath132 is a _ finite - dimensional _ markov chain under ws .",
    "assume that @xmath70 , @xmath134 and @xmath5 are such that the markov chain @xmath135 is _ irreducible _ and _",
    "aperiodic_.    given any traffic @xmath113 and @xmath128 such that @xmath129 and @xmath130 are supportable , the markov chain @xmath132 is _ positive - recurrent _ under ws , and @xmath136 < \\infty.\\ ] ] [ thm : ori ]    we consider the following lyapunov function : @xmath137 and prove that @xmath138 \\leq u_d1_{{\\bf m}(t)\\in\\upsilon } -\\frac{\\epsilon}{2}\\left[\\alpha \\bar{\\lambda}w_s(t ) \\right.\\\\ + \\left .",
    "\\sum_{l\\in \\cal{l } } q_l(t)x_l \\right ] 1_{{\\bf m}(t)\\not\\in\\upsilon}\\end{aligned}\\ ] ] for some @xmath139 @xmath140 , @xmath141 , and a finite set @xmath142 positive recurrence of @xmath135 then follows from foster s criterion for markov chains @xcite , and the boundedness of the first moment follows from @xcite .",
    "the detailed proof is presented in appendix a.    we next study wsl , where @xmath24 is estimated from the history .",
    "we define @xmath143 to be the number of short - lived flows that belong to class-@xmath144 have a residual size of @xmath145 and have @xmath146 furthermore , we define @xmath147 from some @xmath148 it is easy to see that @xmath149 is a _ finite - dimensional _ markov chain under wsl . to include the information required for tie - breaking , and then use the analysis in appendix b to prove the positive recurrence . ]",
    "consider traffic @xmath113 and @xmath128 such that @xmath129 and @xmath130 are supportable .",
    "given wsl with a _ good _ tie - breaking rule , there exists @xmath150 such that the markov chain @xmath149 is _ positive - recurrent _ under the wsl with learning period @xmath151 and the given tie - breaking rule .",
    "further , @xmath136 < \\infty.\\ ] ] [ thm : learning ]    the proof of this theorem is built upon the following two facts :    = 1em    when the number of short - lived flows is large , the majority of short - lived flows must have been in the network for a long time and have obtained the correct estimate of the best channel condition , which implies that @xmath152    when the number of short - lived flows is large , the short - lived flow selected by the base station ( say flow @xmath10 ) has a high probability to satisfy @xmath153 or @xmath154    from these two facts , we can prove that with a high probability , the scheduling decisions of wsl are the same as those of ws , which leads to the throughput optimality of wsl . the detailed proof is presented in appendix b.",
    "in this section , we use simulations to evaluate the performance of different variants of wsl and compare it to other scheduling policies .",
    "there are three types of flows used in the simulations :    = 1em    * s - flow : * an s - flow has a finite size , generated from a truncated exponential distribution with mean value @xmath155 and maximum value @xmath156 non - integer values are rounded to integers .",
    "* m - flow : * an m - flow keeps injecting bits into the network for @xmath157 time slots and stops .",
    "the number of bits generated at each time slot follows a poisson distribution with mean value @xmath158    * l - flow : * an l - flow keeps injecting bits into the network and never leaves the network .",
    "the number of bits generated at each time slot follows a truncated poisson distribution with mean value @xmath85    blackand maximum value @xmath159 .    here",
    "s - flows represent short - lived flows that have finite sizes and whose bits arrive all at once ; l - flows represent long - lived flows that continuously inject bits and never leave the network ; and m - flows represent flows of finite size but whose arrival rate is controlled at their sources so that they do not arrive instantaneously into the network .",
    "our simulation will demonstrate the importance of modeling very large , but finite - sized flows as long - lived flows .",
    "we assume that the channel between each user and the base station is distributed according to one of the following three distributions :    = 1em    * g - link : * a g - link has five possible link rates @xmath160 and each of the states happens with probability @xmath161    * p - link : * a p - link has five possible link rates @xmath162 and each of the states happens with probability @xmath161    * r - link : * an r - link has five possible link rates @xmath163 and the probabilities associated with these link states are @xmath164    the g , p and r stand for good , poor and rare , respectively .",
    "we include these three different distributions to model the snr variations among the users , where g - links represent links with high snr ( e.g. , those users close to the base station ) , p - links represent links with low snr ( e.g. , those users far away from the base station ) , and r - links represent links whose best state happens rarely .",
    "the r - links will be used to study the impact of learning period @xmath62 on the network performance .",
    "we name the wsl with the uniform tie - breaking rule wslu , and the wsl with the oldest - first tie - breaking rule wslo . in the following simulations",
    ", we will first demonstrate that the wslu performs significantly better than previously suggested algorithms , and then show that the performance can be further improved by choosing a good tie - breaking policy ( e.g. , wslo ) .",
    "we set @xmath61 to be @xmath165 in all the following simulations .",
    "we first use the simulation to demonstrate the importance of considering a flow with a large number of packets as being long - lived .",
    "we consider a network consisting of multiple s - flows and three m - flows , where the arrival of s - flows follows a truncated poisson process with maximum value @xmath166 and mean value @xmath167 all the links are assumed to be g - links .",
    "we evaluate the following two schemes :    = 1em    * scheme-1 : * both s - flows and m - flows are considered to be short - lived flows .",
    "* scheme-2 : * an m - flow is considered to be long - lived before its last packet arrives , and to be short - lived after that .    the performance of these two schemes are shown in figure [ fig : switch ] , where ws with uniform tie - breaking rule is used as the scheduling algorithm .",
    "we can see that the performances are substantially different ( note that the network is stable under both schemes ) .",
    "the number of queued bits of m - flows under scheme-1 is larger than that under scheme-2 by _ two orders of magnitude .",
    "_ this is because even an m - flow contains a huge number of bits ( @xmath168 on average ) , it can be served only when the link rate is @xmath165 under scheme-1 .",
    "this simulation suggests that when the performance we are interested is at a small scale ( e.g. acceptable queue - length being less than or equal to @xmath166 ) compared with the size of the flow ( e.g. , @xmath169 in this simulation ) , the flow should be viewed as a long - lived flow for performance purpose .          in this simulation",
    ", we investigate the impact of @xmath62 on the performance of wslu .",
    "recall that it is nature to choose @xmath170 for purely throughput - optimality considerations , but the disadvantage is that a flow may stay in the network for a very long time if the best link state occurs very rarely .",
    "we consider a network consisting of s - flows , which arrive according to a truncated poisson process with maximum value @xmath166 and mean @xmath171 and three l - flows .",
    "all links are assumed to be r - links .",
    "figure [ fig : d ] depicts the mean and standard deviation of the file - transfer delays with @xmath172 and @xmath170    black when the traffic load is light or medium .    as we expected , the standard deviation under wslu with @xmath170 is significantly larger than that under wslu with @xmath172 when @xmath173 is large",
    "this occurs because the best link rate @xmath166 occurs with a probability @xmath174 this simulation confirms that in practical systems , we may want to choose a finite @xmath62 to get desired performance .     and",
    "@xmath170 when the traffic load is light or medium , title=\"fig:\",width=249 ]   and @xmath170 when the traffic load is light or medium , title=\"fig:\",width=249 ]    black further we would like to comment that while the wslu algorithm with a small @xmath62 has a better performance in light or medium traffic regimes , throughput optimality is only guaranteed when @xmath62 is sufficiently large .",
    "figure [ fig : d_heavy ] illustrates the average number of s - flows and average file - transfer delay for @xmath172 and @xmath170 in heavy traffic regime .",
    "we can observe that in the heavy traffic regime , the wslu with @xmath170 still stabilizes the network but the algorithm with @xmath172 does not .",
    "so there is a clear tradeoff in choosing @xmath62 : a small @xmath62 reduces the file - transfer delay in light or medium traffic regimes , but a large @xmath62 guarantees stability in heavy traffic regime .     and",
    "@xmath170 when the traffic load is heavy , title=\"fig:\",width=249 ]   and @xmath170 when the traffic load is heavy , title=\"fig:\",width=249 ]      black in the following simulations , we choose @xmath175 in the introduction , we have pointed out that the maxweight is not throughput optimal under flow - level dynamics because the backlog of a short - lived queue does not build up even when it has not been served for a while . to overcome this",
    ", one could try to use the delay of the head - of - line packet , instead of queue - length , as the weight because the head - of - line delay will keep increasing if no service is received . in the case of",
    "long - lived flows only , this algorithm is known to be throughput - optimal @xcite .",
    "we will show that this delay - based scheduling does not solve the instability problem when there are short - lived flows .",
    "* delay - based scheduling : * at each time slot , the base station selects a flow @xmath10 such that @xmath176 where @xmath177 is the delay experienced so far by the head - of - line packet of flow @xmath17    we first consider the case where all flows are s - flows , which arrive according to a truncated poisson process with maximum value @xmath166 and mean @xmath167 an s - flow is assigned with a g - link or a p - link equally likely .",
    "figure [ fig : dslwo ] shows the average file - transfer delay and average number of s - flows under different values of @xmath167 we can see that wslu performs significantly better than the maxweight and delay - based algorithms .",
    "specifically , under maxweight and delay - based algorithms , both the number of s - flows and file - transfer delay explode when @xmath178 wslu , on the other hand , performs well even when @xmath179        next , we consider the same scenario with three l - flows in the network .",
    "two of the l - flows have g - links and one has a p - link .",
    "figure [ fig : slw ] shows the average number of short - lived flows and average file - transfer delay under different values of @xmath167 we can see that the maxweight becomes unstable even when _ the arrival rate of s - flows is very small .",
    "_ this is because the maxweight stops serving s - flows when the backlogs of l - flows are large , so s - flows stay in the network forever .",
    "the delay - based scheduling performs better than the maxweight , but significantly worse than wslu .          while our theory assumes that the number of flows in the network can be infinite , in reality , base stations limit the number of simultaneously active flows , and reject new flows when the number of existing flows above some threshold . in this simulation , we assume that the base station can support at most @xmath180 s - flows",
    ". a new s - flow will be blocked if @xmath180 s - flows are already in the network . in this setting ,",
    "the number of flows in the network is finite , so we compute the blocking probability , i.e. , the fraction of s - flows rejected by the base station .",
    "we consider the case where no long - lived flow is in the network and the case where both short - lived and long - lived flows are present in the network .",
    "the flows and channels are selected as in simulation iii .",
    "the results are shown in figure [ fig : blocking_1 ] and [ fig : blocking_2 ] .",
    "we can see that the blocking probability under wslu is substantially smaller than that under the maxweight or the delay - based scheduling .",
    "thus , this simulation demonstrates that instability under the assumption when the number of flows is allowed to unbounded implies high blocking probabilities for the practical scenario when the base station limits the number of flows in the network .              in this simulation",
    ", we study the impact of tie - breaking rules on performance .",
    "we compare the performance of the wslu and wslo .",
    "we first study the case where the base station does not limit the number of simultaneously active flows and there is no long - lived flow in the network .",
    "the simulation setting is the same as that in simulation iii .",
    "figure [ fig : wsluo_without ] shows the average file - transfer delay and average number of s - flows under different values of @xmath167 we can see that the wslo reduces the file - transfer delay and number of s - flows by nearly @xmath181 when @xmath182 which indicates the importance of selecting a good tie - breaking rule for improving the network performance .",
    "next , we study the case where the base station does not limit the number of simultaneously active flows and there are three l - flows in the network .",
    "figure [ fig : wsluo_with ] shows the average number of short - lived flows and average file - transfer delay under different values of @xmath167 we can see again that the wslo algorithm has a much better performance than the wslu , especially when @xmath173 is large .",
    "finally we consider the situation where the base station can support at most @xmath180 s - flows .",
    "a new s - flow will be blocked if @xmath180 s - flows are already in the network .",
    "the simulation setting is the same as that in simulation iv .",
    "we calculate the blocking probabilities , and the results are shown in figure [ fig : wsluo_blocking_1 ] and [ fig : wsluo_blocking_2 ] .",
    "we can see that the blocking probability under the wslo is much smaller than that under the wslu policy when @xmath173 is large .",
    "in this paper , we studied multiuser scheduling in networks with flow - level dynamics .",
    "we first obtained necessary conditions for flow - level stability of networks with both long - lived flows and short - lived flows .",
    "then based on an optimization framework , we proposed the workload - based scheduling with learning that is throughput - optimal under flow - level dynamics and requires no prior knowledge about channels and traffic . in the simulations , we evaluated the performance of the proposed scheduling algorithms , and demonstrated that the proposed algorithm performs significantly better than the maxweight algorithm and the delay - based algorithm in various settings .",
    "next we discuss the limitations of our model and possible extensions .      according to theorem [ thm : learning ] , the learning period @xmath62 should be sufficiently large to guarantee throughput - optimality .",
    "our simulation results on the other hand suggested that a small @xmath62 may result in better performance .",
    "therefore , there is clear trade - off in choosing @xmath47 the study of the choice for @xmath62 is one potential future work .",
    "one limitation of our model is that the random variables associated with the number of file arrivals and file sizes are assumed to be upper bounded .",
    "one interesting future research problem is to extend the results to unbounded number of file arrivals and file sizes .",
    "recall that @xmath183 we define @xmath184 to be the largest achievable link rate of class-@xmath67 short - lived flows , and @xmath185 which is the amount of new workload ( from short - lived flows ) injected in the network at time @xmath6 and @xmath186 to be the decrease of the workload at time @xmath6 i.e. , @xmath187 if the workload of short - lived flows is reduced by one and @xmath188 otherwise . based on the notations above",
    ", the evolution of short - lived flows can be described as : @xmath189 further , the evolution of @xmath21 can be described as @xmath190 where @xmath191 is the decrease of @xmath21 due to the service long - lived flow @xmath1 receives at time @xmath6 and @xmath192 is the unused service due to the lack of data in the queue .",
    "we consider the following lyapunov function @xmath193 we will prove that the drift of the lyapunov function satisfies @xmath138 \\leq u_d1_{{\\bf m}(t)\\in\\upsilon } -\\frac{\\epsilon}{2}\\left[\\alpha \\bar{\\lambda}w_s(t ) \\right.\\\\ + \\left .",
    "\\sum_{l\\in \\cal{l } } q_l(t)x_l \\right ] 1_{{\\bf m}(t)\\not\\in\\upsilon}\\end{aligned}\\ ] ] for some @xmath139 @xmath141 and a finite set @xmath194 ( the values of these parameters will be defined in the following analysis ) .",
    "positive recurrence of @xmath135 then follows from foster s criterion for markov chains @xcite .",
    "first , since the number of arrivals , the sizes of short - lived flows and channel rates are all bounded , it can be verified that there exists @xmath195 independent of @xmath196 such that @xmath197\\\\ = & { \\textbf{\\textsc{e}}}\\left[\\alpha\\left(w_s(t+1)\\right)^2-\\alpha\\left(w_s(t)\\right)^2+\\right.\\\\ & \\hspace{0.2in}\\left.\\left.\\sum_{l\\in{\\cal l}}(q_l(t+1))^2-\\sum_{l\\in{\\cal l}}(q_l(t))^2\\right|\\mathbf{m}(t)\\right]\\\\ \\leq&u+2\\alpha w_s(t ) { \\textbf{\\textsc{e}}}\\left[\\left.a_s(t)-\\mu_s(t)\\right|\\mathbf{m}(t)\\right]+\\\\ & \\hspace{0.4in}2\\sum_{l\\in{\\cal l}}q_l(t){\\textbf{\\textsc{e}}}\\left[\\left.x_l(t)-\\mu_l(t)\\right|\\mathbf{m}(t)\\right]\\\\ \\leq&u+2\\alpha w_s(t)\\left(\\left(\\sum_{k\\in{\\cal k}}\\lambda_k { \\textbf{\\textsc{e}}}\\left[\\left\\lceil\\frac{\\hat{f}_k}{\\hat{r}^{\\max}_k}\\right\\rceil\\right]\\right)\\right.\\\\ & \\hspace{1.6in}-{\\textbf{\\textsc{e}}}\\left[\\left.\\mu_s(t)\\right|\\mathbf{m}(t)\\right]\\big)\\\\ & \\hspace{0.2in}+2\\sum_{l\\in{\\cal l}}q_l(t)\\left(x_l-{\\textbf{\\textsc{e}}}\\left[\\left.\\mu_l(t)\\right|\\mathbf{m}(t)\\right]\\right).\\end{aligned}\\ ] ] recall that we assume that @xmath129 and @xmath130 satisfy the supportability conditions of theorem [ thm : nc ] . by adding and subtracting",
    "corresponding @xmath198 and @xmath199 we obtain that @xmath200-u\\\\ & \\leq&2\\alpha w_s(t ) { \\textbf{\\textsc{e}}}\\left[\\left.{\\textbf{\\textsc{e}}}\\left[\\left.\\mu_{\\mathbf{c},s}-\\mu_{s}(t)\\right|\\mathbf{c}(t)=\\mathbf{c}\\right]\\right|\\mathbf{m}(t)\\right]\\\\ & & + 2\\sum_{l\\in{\\cal l}}q_l(t){\\textbf{\\textsc{e}}}\\left[\\left.{\\textbf{\\textsc{e}}}\\left[\\left.p_{\\mathbf{c},l}r_{\\mathbf{c},l}-\\mu_l(t)\\right|\\mathbf{c}(t)=\\mathbf{c}\\right]\\right|\\mathbf{m}(t)\\right]\\\\ & & -2\\epsilon\\alpha w_s(t ) \\bar{\\lambda}-2\\epsilon\\sum_{l\\in{\\cal l}}q_l(t)x_l,\\end{aligned}\\ ] ] where @xmath201\\right).\\ ] ]    next we assume @xmath202 and analyze the following quantity @xmath203 we have the following facts :    * * fact 1 : * _ assume that there exists a short - lived flow @xmath10 such that @xmath204 or @xmath154 _ if a short - lived flow is selected to be served , then the workload of the selected flow is reduced by one and @xmath205 if long - lived flow @xmath1 is selected , the rate flow @xmath1 receives is @xmath206 thus , we have that @xmath207 where the last inequality holds because @xmath208 therefore , we have @xmath209 in this case .",
    "* * fact 2 : * _ assume that there does not exist a short - lived flow @xmath10 such that @xmath204 or @xmath154 _ in this case , we have @xmath210    now we define a set @xmath194 such that @xmath211 where @xmath212 is a positive integer satisfying that @xmath213 and @xmath214 is a positive integer satisfying @xmath215    we next compute the drift of the lyapunov function according to the value of @xmath216    * * case i : * assume @xmath217 according to the definition of @xmath218 we have",
    "@xmath138\\leq u+2\\alpha u_w+ 2{r}^{\\max } l u_q.\\end{aligned}\\ ] ] * * case ii : * assume @xmath219 since the size of a short - lived flow is upper bounded by @xmath220 @xmath221 implies that at least @xmath222 short - lived flows are in the network at time @xmath9 define @xmath223 to be the following event : + blackno short - lived flow satisfies @xmath153 or @xmath39 .",
    "+ recall that @xmath224 given at least @xmath225 short - lived flows are in the network , we have that @xmath226 + according to facts 1 and 2 , @xmath227 is positive only if @xmath223 occurs and the value of @xmath227 is bounded by @xmath228 therefore , we can conclude that in this case ( case ii ) , @xmath200\\nonumber\\\\ & \\leq & u+2 \\epsilon_1 \\left(\\alpha   w_s(t)+r^{\\max}\\max_{l\\in{\\cal l}}q_l(t)\\right)\\nonumber\\\\ & & -2\\epsilon \\alpha   w_s(t ) \\bar{\\lambda}-2\\epsilon\\sum_{l\\in{\\cal l}}q_l(t)x_l \\nonumber\\\\ & \\leq & u-\\epsilon \\alpha w_s(t ) \\bar{\\lambda}-\\epsilon\\sum_{l\\in{\\cal l}}q_l(t)x_l \\label{eq : ii1}\\\\ & \\leq & -\\frac{\\epsilon}{2}\\left[\\alpha \\bar{\\lambda}w_s(t)+ \\sum_{l\\in \\cal{l } } q_l(t)x_l \\right]\\label{eq : ii2}\\end{aligned}\\ ] ] where inequality ( [ eq : ii1 ] ) holds due to the definition of @xmath229 ( [ eq : uw1 ] ) , and inequality ( [ eq : ii2 ] ) holds due to inequality ( [ eq : uw2 ] ) . *",
    "* case iii : * assume that @xmath230 and @xmath231 for some @xmath111 in this case , if a long - lived flow is selected for a given @xmath77 we have @xmath232 otherwise , if a short - lived flow is selected , it means for the given @xmath77 we have @xmath233 and @xmath234 therefore , we can conclude that in this case , @xmath197\\nonumber\\\\ \\leq & u+4\\alpha w_s(t)-2\\epsilon\\alpha w_s(t ) \\bar{\\lambda}-2\\epsilon\\sum_{l\\in{\\cal l}}q_l(t)x_l\\label{eq : use1}\\\\ \\leq & u+4\\alpha u_w-2\\epsilon\\alpha w_s(t ) \\bar{\\lambda}-2\\epsilon\\sum_{l\\in{\\cal l}}q_l(t)x_l\\nonumber\\\\ \\leq&-\\frac{\\epsilon}{2}\\left[\\alpha \\bar{\\lambda}w_s(t)+ \\sum_{l\\in \\cal{l } } q_l(t)x_l \\right]\\end{aligned}\\ ] ] where the last inequality yields from the definition of @xmath214 ( [ eq : uq0 ] ) .    from the analysis above",
    ", we can conclude that @xmath138 \\leq u_d1_{{\\bf m}(t)\\in\\upsilon } -\\frac{\\epsilon}{2}\\left[\\alpha \\bar{\\lambda}w_s(t ) \\right.\\\\ + \\left .",
    "\\sum_{l\\in \\cal{l } } q_l(t)x_l \\right ] 1_{{\\bf m}(t)\\not\\in\\upsilon},\\end{aligned}\\ ] ] where @xmath235 and @xmath194 is a set with a finite number of elements .",
    "black since @xmath236 for all @xmath6 the lyapunov function is always lower bounded .",
    "further the drift of the lyapunov is upper bounded when @xmath237 belongs to a finite set @xmath218 and is negative otherwise .    so invoking foster s criterion , the markov chain @xmath132 is positive recurrent and the boundedness of the first moment follows from @xcite .",
    "consider the network that is operated under wsl , and define @xmath238 to be @xmath239 now _ given @xmath240 _ we define the following notations :    * define @xmath241 if flow @xmath1 is selected by wsl , and @xmath242 otherwise .",
    "* define @xmath243 if flow @xmath10 is selected by wsl and the workload of flow @xmath10 can be reduced by one , and @xmath244 otherwise . * define @xmath245 if flow @xmath1 is selected by ws , and @xmath246 otherwise . *",
    "define @xmath247 if flow @xmath10 is selected by ws and the workload of flow @xmath10 can be reduced by one , and @xmath248 otherwise .",
    "we remark that @xmath249 is the action selected by the base station at time @xmath19 under wsl and @xmath250 is the action selected by the base station at time @xmath19 under ws , assuming the same history @xmath251    we define the lyapunov function to be @xmath252    black this lyapunov function is similar to the one used in the proof of theorem [ thm : ori ] , and we will show that this is a valid lyapunov function for the workload - based scheduling with learning .    then , it is easy to verify that there exists @xmath253 independent of @xmath254 such that @xmath255\\nonumber\\\\ < & u_1 + 2\\alpha { \\textbf{\\textsc{e}}}\\left[w_s(nt)\\left.\\sum_{t = nt}^{(n+1)t-1}\\left(a_s(t)-\\mu_{2;s}(t)\\right)\\right|\\tilde{\\mathbf{m}}(n)\\right]\\nonumber\\\\ & + \\sum_{l\\in{\\cal l}}2{\\textbf{\\textsc{e}}}\\left[\\left.q_l(nt)\\sum_{t = nt}^{(n+1)t-1}\\left(x_l(t)-\\mu_{2;l}(t)\\right)\\right|\\tilde{\\mathbf{m}}(n)\\right].\\end{aligned}\\ ] ] dividing the time into two segments @xmath256 $ ] and @xmath257,$ ] we obtain @xmath255\\nonumber\\\\ < & u_1 + 2\\alpha w_s(nt ) \\bar{\\lambda } d+2\\sum_{l\\in{\\cal l } } q_l(nt)x_ld\\\\ & + 2\\alpha { \\textbf{\\textsc{e}}}\\left[w_s(nt)\\left.\\sum_{t = nt+d}^{(n+1)t-1}\\left(a_s(t)-\\mu_{2;s}(t)\\right)\\right|\\tilde{\\mathbf{m}}(n)\\right]\\nonumber\\\\ & + \\sum_{l\\in{\\cal l}}2{\\textbf{\\textsc{e}}}\\left[\\left.q_l(nt)\\sum_{t = nt+d}^{(n+1)t-1}\\left(x_l(t)-\\mu_{2;l}(t)\\right)\\right|\\tilde{\\mathbf{m}}(n)\\right].\\end{aligned}\\ ] ]    note that @xmath258 and @xmath259 are both bounded by some constants independent of @xmath260 so there exists @xmath261 such that @xmath255\\nonumber\\\\ < & \\tilde{u}+2\\alpha w_s(nt ) \\bar{\\lambda } d+2\\sum_{l\\in{\\cal l } } q_l(nt)x_ld\\\\ & + 2{\\textbf{\\textsc{e}}}\\left[\\left.\\alpha\\sum_{t = nt+d}^{(n+1)t-1}w_s(t)\\left(a_s(t)-\\mu_{2;s}(t)\\right)\\right|\\tilde{\\mathbf{m}}(n)\\right]\\nonumber\\\\ & + \\sum_{l\\in{\\cal l}}2{\\textbf{\\textsc{e}}}\\left[\\left.\\sum_{t = nt+d}^{(n+1)t-1}q_l(t)\\left(x_l(t)-\\mu_{2;l}(t)\\right)\\right|\\tilde{\\mathbf{m}}(n)\\right].\\end{aligned}\\ ] ] now , by adding and subtracting @xmath262 we obtain @xmath255\\\\ \\leq&\\tilde{u}+2\\alpha w_s(nt ) \\bar{\\lambda } d+2\\sum_{l\\in{\\cal l } } q_l(nt)x_ld+\\sum_{t = nt+d}^{(n+1)t-1 } \\hbox{drift}(t),\\end{aligned}\\ ] ] where @xmath263\\label{eq : 1:1}\\\\ & -2{\\textbf{\\textsc{e}}}[\\alpha w_s(t)\\mu_{1;s}(t)+\\sum_{l\\in{\\cal",
    "l } } q_l(t)\\mu_{1;l}(t)|\\tilde{\\mathbf{m}}(n)]\\label{eq : 1:2}\\\\ & + \\sum_{l\\in{\\cal l}}2{\\textbf{\\textsc{e}}}[q_l(t)\\left(\\mu_{1;l}(t)-\\mu_{2;l}(t)\\right)|\\tilde{\\mathbf{m}}(n)]\\label{eq : 2:2}\\\\ & + 2{\\textbf{\\textsc{e}}}\\left[\\alpha w_s(t)\\left(\\mu_{1;s}(t)-\\mu_{2;s}(t)\\right)|\\tilde{\\mathbf{m}}(n)\\right].\\label{eq : 4}\\end{aligned}\\ ] ]    note that ( [ eq : 2:2])+([eq : 4 ] ) is the difference between ws and wsl . in the following analysis , we will prove that this difference is small compared to the absolute value of ( [ eq : 1:1])+([eq : 1:2 ] ) .",
    "we define @xmath264 and @xmath265 next , we compute its value in three different situations :    * * situ - a : * _ consider the situation in which @xmath266 _ we note that @xmath267 since @xmath268 for all @xmath19 and @xmath17 therefore , given @xmath269 both ws and wsl will select a long - lived flow . in this case , we can conclude that @xmath270 and @xmath271 * * situ - b : * _ consider the situation in which @xmath272 _ in this case , both ws and wsl will select a short - lived flow , which implies that @xmath273 and @xmath274 * * situ - c : * _ consider the situation in which @xmath275 _ in this case , ws will select a long - lived flow and wsl will select a short - lived flow . we hence have @xmath276 and @xmath277    according to the analysis above , we have that @xmath278\\\\ \\leq &   { \\textbf{\\textsc{e}}}\\left[\\alpha w_s(t)|\\hbox{situ - b } , \\mu_{2;s}=0 , \\tilde{\\mathbf{m}}(n)\\right]\\times\\\\ & \\pr\\left(\\hbox{situ - b } , \\mu_{2;s}=0|\\tilde{\\mathbf{m}}(n)\\right)\\\\ + & { \\textbf{\\textsc{e}}}\\left[\\alpha\\tilde{w}_s(t)|\\hbox{situ - c } , \\mu_{2;s}=0 , \\tilde{\\mathbf{m}}(n)\\right]\\times\\\\ & \\pr\\left(\\hbox{situ - c } , \\mu_{2;s}=0|\\tilde{\\mathbf{m}}(n)\\right)\\\\ + & { \\textbf{\\textsc{e}}}\\left[\\alpha\\tilde{w}_s(t)-\\alpha w_s(t)|\\hbox{situ - c } , \\mu_{2;s}=1 , \\tilde{\\mathbf{m}}(n)\\right]\\times\\\\ & \\pr\\left(\\hbox{situ - c } , \\mu_{2;s}=1|\\tilde{\\mathbf{m}}(n)\\right).\\end{aligned}\\ ] ]    next we define a finite set @xmath279 we first introduce some constants :    * @xmath280 * @xmath281 and @xmath282 and @xmath283 are the numbers that guarantee @xmath284 which are defined by the goodness of the tie - breaking rule .",
    "* @xmath285 which is the maximum number of bits of short - lived flows injected in one time slot , and also the upper bound on the new workload injected in the network in one time slot .",
    "we define a set @xmath286 such that @xmath287 in this definition , @xmath288 is a positive integer satisfying that @xmath289 and @xmath290 is a positive integer satisfying @xmath291 since the changes of @xmath292 and @xmath21 during each time slot is bounded by some constants independent of @xmath260 it is easy to verify that @xmath286 is a set of a finite number of elements .",
    "next , we analyze the drift of lyapunov function case by case assuming that @xmath293 and @xmath294    = 1em    * case i : * assume that @xmath295 in this case , it is easy to verify that @xmath296 $ ] is bounded by some constant @xmath297    * case ii : * assume that @xmath298 recall that @xmath44 is the event such that the tie - breaking rule selects a short - lived flow with @xmath45 note that @xmath299 implies that @xmath44 occurs .",
    "also note the following facts :    * for any @xmath300 we have @xmath301 * given @xmath302 we have @xmath303 for all @xmath304 then according to the definition of @xmath305 and @xmath288 and assumption that the tie - breaking rule is good , we have @xmath306 for all @xmath307 * given any @xmath149 and any @xmath308 we have @xmath309\\times\\nonumber\\\\ & \\pr\\left(\\hbox{situ - c } , \\mu_{2;s}=1|\\tilde{\\mathbf{m}}(n)\\right)\\nonumber\\\\ \\leq &   { \\textbf{\\textsc{e}}}\\left[\\alpha \\tilde{w}_s(t)-\\alpha w_s(t)|\\tilde{\\mathbf{m}}(n)\\right]\\nonumber\\\\ = & { \\textbf{\\textsc{e}}}\\left[\\left.{\\textbf{\\textsc{e}}}\\left[\\left.\\alpha   \\tilde{w}_s(t)- \\alpha   w_s(t)\\right|w_s(t - d)|\\right]\\right|\\tilde{\\mathbf{m}}(n)\\right]\\nonumber\\\\ \\leq & { \\textbf{\\textsc{e}}}\\left[\\alpha(1-p_s^{\\max})^dw_s(t - d)r^{\\max}+\\alpha\\lambda^{\\max}_w d|\\tilde{\\mathbf{m}}(n)\\right]\\label{eq : 5}\\\\ \\leq&{\\textbf{\\textsc{e}}}\\left[\\alpha ( 1-p_s^{\\max})^d(w_s(t)+d)r^{\\max}+\\alpha \\lambda^{\\max}_w d|\\tilde{\\mathbf{m}}(n)\\right]\\nonumber,\\end{aligned}\\ ] ] where the inequality ( [ eq : 5 ] ) holds because at most @xmath310 bits belonging to short - lived flows are in the network for less than @xmath62 time slots at time @xmath6 and a flow having been in the network for at least @xmath62 time slots can estimate correctly its workload with a probability at least @xmath311    now according to the observations above , we can obtain that @xmath278\\\\ \\leq & \\epsilon_2\\alpha \\left(w_s(nt)+\\lambda_{w}^{\\max}t\\right)+ \\epsilon_2\\alpha \\left(r^{\\max}w_s(nt)+\\lambda_{w}^{\\max}t\\right ) \\\\ & +   { \\textbf{\\textsc{e}}}\\left[\\alpha(1-p_s^{\\max})^d(w_s(t)+d)r^{\\max}+\\alpha\\lambda^{\\max}_w d|\\tilde{\\mathbf{m}}(n)\\right].\\end{aligned}\\ ] ] combining with the analysis leading to ( [ eq : ii1 ] ) in appendix a , we conclude that @xmath312\\\\ \\leq & { \\textbf{\\textsc{e}}}\\left[\\left.-\\epsilon\\left(\\alpha \\bar{\\lambda } w_s(t)+\\sum_{l\\in { \\cal l}}x_l q_l(t)\\right)\\right|\\tilde{\\mathbf{m}}(n)\\right],\\end{aligned}\\ ] ] where the last inequality holds due to ( [ eq : uw22 ] ) .",
    "* case iii : * assume that @xmath313 and @xmath314 for some @xmath111 in this case , we have @xmath315 combining with the analysis leading to ( [ eq : use1 ] ) in appendix a , we have that @xmath316\\\\ \\leq & { \\textbf{\\textsc{e}}}\\left[\\left.-\\epsilon\\left(\\alpha \\bar{\\lambda } w_s(t)+\\sum_{l\\in { \\cal l}}x_l q_l(t)\\right)\\right|\\tilde{\\mathbf{m}}(n)\\right],\\end{aligned}\\ ] ] where the last inequality holds due to ( [ eq : uq ] ) .",
    "now , combining case ii and case iii , we can obtain that @xmath255\\\\ \\leq&\\tilde{u}+2\\alpha w_s(nt ) \\bar{\\lambda } d+2\\sum_{l\\in{\\cal l } } q_l(nt)x_ld\\\\ & + \\sum_{t = nt+d}^{(n+1)t-1 } { \\textbf{\\textsc{e}}}\\left[\\left.-\\epsilon\\left(\\alpha \\bar{\\lambda } w_s(t)+\\sum_{l\\in { \\cal l}}x_l q_l(t)\\right)\\right|\\tilde{\\mathbf{m}}(n)\\right]\\\\ \\leq&\\tilde{u}+2\\alpha w_s(nt ) \\bar{\\lambda } d+2\\sum_{l\\in{\\cal l } } q_l(nt)x_ld\\\\ & -\\epsilon ( t - d ) \\left(\\alpha \\bar{\\lambda }",
    "w_s(nt)+\\sum_{l\\in { \\cal l}}x_l q_l(nt)\\right)\\\\ & + \\epsilon(t - d)(\\alpha\\bar{\\lambda } t+\\sum_{l\\in{\\cal l } } x_l r^{\\max } t)\\\\ \\leq&-\\tilde{u}-\\sum_{t = nt+d}^{(n+1)t-1 } { \\textbf{\\textsc{e}}}\\left[\\left.\\frac{\\epsilon}{2}\\left(\\alpha \\bar{\\lambda } w_s(t)+\\sum_{l\\in { \\cal l}}x_l q_l(t)\\right)\\right|\\tilde{\\mathbf{m}}(n)\\right],\\end{aligned}\\ ] ] where the last inequality yields from the definition of @xmath288 and @xmath317 finally , we can conclude the theorem from @xcite .",
    "recall that we define @xmath44 to be the event that the tie - breaking rule selects a short - lived flow with @xmath45    the uniform tie - breaking rule is good .",
    "suppose set @xmath318 under the uniform tie - breaking , @xmath44 occurs with probability @xmath319    assume that @xmath320 short - lived flows are in the network at time @xmath321 and denote by @xmath322 the set of these short - lived flows .",
    "our proof contains the following two steps :    * step 1 : * we first obtain an upper bound on @xmath323 considering a short - lived flow ( flow @xmath10 ) which is in the network at time @xmath324 we have @xmath325 thus , @xmath326\\leq \\epsilon n.$ ] according to the chernoff bound , we have @xmath327)^2}{3{\\textbf{\\textsc{e}}}[n_1]}\\right)\\\\ & \\leq&\\exp\\left(-\\frac{(0.1\\epsilon n+d)^2}{3\\epsilon n}\\right)\\\\ & \\leq&\\exp\\left(-0.003\\epsilon n-0.06d\\right).\\end{aligned}\\ ] ]    next note that at most @xmath328 short - lived flows join the network during each time slot , so we can conclude that @xmath329    * step 2 : * since at most one flow can be completely transmitted in one time slot , so least @xmath330 flows are in the network at time @xmath6 each having a probability at least @xmath331 to be in the best channel state . @xmath332",
    "* summary : * from step 1 and step 2 , we can conclude that @xmath333 which converges to zero as both @xmath62 and @xmath334 go to infinity .",
    "the proposition holds because the sizes of short - lived flows are bounded and a large workload implies a large number of short - lived flows .",
    "the oldest - first tie - breaking is a _ good _ tie - breaking rule .",
    "we assume that at time slot @xmath324 there are @xmath335 short - lived flows in the network .",
    "we group _ short - lived flows _ into groups",
    "@xmath336 according to the time they arrived at the network such that group @xmath337 contains all flows arriving no less than @xmath58 time slots ago at time @xmath6 and group @xmath338 contains the flows arriving exact @xmath339 time slots ago at time @xmath19 ( @xmath340 ) .    *",
    "case 1 : * assume that @xmath341 we first consider the following probability @xmath342 note that @xmath337 can contain at most @xmath343 additional flows compared to @xmath344 since @xmath345 for all @xmath346 following the analysis for the uniform tie - breaking in appendix c , we can easily prove that @xmath347 as @xmath62 goes to infinity .",
    "next , note that at most one short - lived flow can be completely transmitted in one time slot , so @xmath337 containing at least @xmath348 flows at time @xmath6 which implies that @xmath349 therefore , we conclude that @xmath350 which converges to zero as @xmath62 goes to infinity .    * case 2 : * assume that @xmath351 in this case , we search the groups starting from group @xmath337 and stop at group @xmath352 if @xmath353 note that when @xmath62 is sufficiently large , such @xmath352 exists and @xmath354 because @xmath335 and @xmath345 for all @xmath346 considering a certain flow @xmath10 such that @xmath355 we have that @xmath356 thus , we can obtain that @xmath357 which converges to zero as @xmath62 goes to infinity .",
    "further , similar to the analysis in case 1 , we can obtain that when @xmath62 is sufficiently large , @xmath358 which converges to zero as well .",
    "b.  sadiq and g.  de  veciana , `` throughput optimality of delay - driven maxweight scheduler for a wireless system with flow dynamics , '' in _ proc .",
    "allerton conf .",
    "communication , control and computing _ , 2009 .",
    "l. tassiulas and a. ephremides ,  stability properties of constrained queueing systems and scheduling policies for maximum throughput in multihop radio networks \" , _ ieee transactions on automatic control _ , vol .",
    "12 , pp . 1936 - 1949 , december 1992 .",
    "m.  andrews , k.  kumaran , k.  ramanan , a.  stolyar , r.  vijayakumar , and p.  whiting , `` scheduling in a queueing system with aynchronously varying service rates , '' _ probability in the engineering and informational sciences _ , vol .  18 , pp . 191217 , 2004 .",
    "m. j. neely , e. modiano , and c. e. rohrs ,  dynamic power allocation and routing for time varying wireless networks , \" _ ieee journal on selected areas in communications _",
    ", special issue on wireless ad - hoc networks , vol .",
    "89 - 103 , jan . 2005 .",
    "x. liu , e. chong , and n. shroff , ",
    "opportunistic transmission scheduling with resource - sharing constraints in wireless networks , \" _ ieee journal on selected areas in communications _ , vol .",
    "10 , pp . 2053 - 2064 , october , 2001 ."
  ],
  "abstract_text": [
    "<S> we consider multiuser scheduling in wireless networks with channel variations and flow - level dynamics . </S>",
    "<S> recently , it has been shown that the maxweight algorithm , which is throughput - optimal in networks with a fixed number of users , fails to achieve the maximum throughput in the presence of flow - level dynamics . in this paper </S>",
    "<S> , we propose a new algorithm , called _ workload - based scheduling with learning _ , which is provably throughput - optimal , requires no prior knowledge of channels and user demands , and performs significantly better than previously suggested algorithms . </S>"
  ]
}