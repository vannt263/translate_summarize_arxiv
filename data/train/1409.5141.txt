{
  "article_text": [
    "using optimization theory to solve channel decoding problems dates back at least to  @xcite , where breitbach _ et al . _",
    "form an integer programming problem and solve it using a branch - and - bound approach .",
    "linear programming ( lp ) decoding of binary low - density parity - check ( ldpc ) codes is introduced by feldman _",
    "et al . _ in  @xcite .",
    "feldman s lp decoding problem is defined by a linear objective function and a set of linear constraints .",
    "the linear objective function is constructed using the log - likelihood ratios and is the same objective as in maximum likelihood ( ml ) decoding .",
    "the set of constraints is obtained by first relaxing each parity - check constraint to a convex polytope called the `` parity polytope '' and then intersecting all constraints .",
    "compared to classic belief propagation ( bp ) decoding , lp decoding is far more amenable to analysis .",
    "many decoding guarantees ( e.g. ,  @xcite ) have been developed for lp decoding in the literature .",
    "however , lp decoding suffers from high computational complexity when approached using generic solvers . since  @xcite",
    ", many works have sought to reduce the computational complexity of lp decoding of binary ldpc codes  @xcite .",
    "of particular relevance is  @xcite where the authors use the alternating direction method of multipliers ( admm ) to decompose the lp decoding problem into simpler sub - problems and develop an efficient decoder that has complexity comparable to the sum - product bp decoder . in a more recent work  @xcite , liu _",
    "_ use admm to try to solve a penalized lp decoding objective and term the problem _ admm penalized decoding_. the penalized lp objective is constructed by adding a non - convex term to the lp decoding objective to penalize pseudocodewords , to which lp decoding can fail .",
    "empirically , admm penalized decoding outperforms admm lp decoding in terms of both word - error - rate ( wer ) and computational complexity .",
    "there are two important lessons from  @xcite and  @xcite .",
    "first , admm based decoding algorithms can be efficient algorithms that are promising for practical implementation .",
    "second , these algorithms can achieve lower wers than bp does at both low and high signal - to - noise ratios ( snrs ) .",
    "in particular , simulation results in  @xcite show that admm penalized decoding can outperform bp decoding at low snrs and does not suffer from an error - floor at wers above @xmath2 for the @xmath3 $ ] `` margulis '' ldpc code .",
    "lp decoding of non - binary ldpc codes is introduced by flanagan _",
    "_ in  @xcite .",
    "results in  @xcite and  @xcite motivate us to extend admm decoding to non - binary codes . however , this extension is non - trivial . one key component of the admm decoder in  @xcite is a sub - routine that projects a length-@xmath4 vector onto the parity polytope  the convex hull of all length-@xmath4 binary vectors of even parity . the projection algorithm developed in @xcite has a complexity of @xmath5 .",
    "more recently ,  @xcite and  @xcite propose more efficient projection algorithms , e.g. , the algorithm proposed in  @xcite has linear complexity in dimension @xmath4 .",
    "unfortunately , these techniques can not be directly applied to lp decoding of non - binary codes as the polytope induced has two major differences .",
    "first , unlike the binary case where @xmath6 can be directly embedded into the real space , elements of @xmath7 need to be mapped to binary vectors of dimension at least @xmath8  @xcite .",
    "second , permutations of a codeword of non - binary single parity - check ( spc ) codes are not necessarily codewords whereas for binary spc codes all permutations of a codeword are codewords .",
    "we briefly describe our approach to developing an efficient lp decoder using admm .",
    "we focus on non - binary codes in fields of characteristic two and represent each element in @xmath0 by a binary vector of dimension @xmath9 , where each entry corresponds to a coefficient of the polynomial representing that element .",
    "this allows us to build a connection between an element s embedding ( i.e. , those defined in  @xcite ) and its binary vector representation .",
    "we then obtain a factor graph characterization of valid embeddings . with this characterization ,",
    "the polytopes considered in  @xcite can be further relaxed to intersections of simplexes and parity polytopes .",
    "we develop two sets of important results pertinent to this relaxation .",
    "first , we show several properties of the aforementioned factor graph of embeddings .",
    "as we will see in the main text , these properties are crucial for developing an efficient admm update algorithm .",
    "further , these properties are useful in determining the computational complexity of the decoder .",
    "second , we regain the permutation properties by introducing a rotation step similar to the one used in the study of bp decoding of non - binary codes in  @xcite . this rotation step is generic and can be applied to any finite field .",
    "it rotates the polytope so that it has a `` block permutation '' property .",
    "this result is not only an interesting theoretical characterization of the polytope but also plays an important role in the algorithm .",
    "several other works also address the complexity of lp decoding of non - binary ldpc codes .",
    "for example , in  @xcite and  @xcite , algorithms are presented that perform coordinate - ascent on an approximation of the dual of the original lp decoding problem . using binary vectors to represent elements of @xmath0 for lp decoding is considered in  @xcite and  @xcite .",
    "in particular in  @xcite , honda and yamamoto introduced a subtle connection between a constant weight embedding of fields of characteristic two and the binary vector representation of fields of characteristic two in  @xcite .",
    "although the authors of  @xcite did not provide an efficient algorithm to leverage this connection , we think that this work is important and inspiring , and build off it herein",
    ".    we list below our contributions in this paper .    *",
    "we extend the ideas of  @xcite and establish connections between flanagan s embedding of finite fields  @xcite and the binary vector representation of finite fields .",
    "we introduce a new factor graph representation of non - binary constraints based on embeddings ( section  [ section.combinatorics_spc_gf2m ] ) .",
    "* we study the geometry of the lp decoding constraints .",
    "we show that the polytope formed from embeddings of the non - binary single parity - check code can be rotated so that the vertices have a `` block permutation '' property .",
    "in addition , we compare two relaxations in terms of their tightness ( section  [ section.relaxation ] ) .",
    "a conjecture that characterizes the polytope for @xmath10 is discussed in appendix  [ appendix.conjecture ] . * in the context of lp decoding , we conduct an extensive study of both flanagan s embedding method and the constant - weight embeddingfrom  @xcite .",
    "the main result is that lp decoding using either embedding method achieves the same wer performance ( section  [ subsec.equivalence_embeddings ] ) .",
    "* we formulate two admm decoding algorithms .",
    "the formulation in section  [ subsec.genericadmm ] applies to lp decoding and to penalized decoding ( cf .",
    "section  [ section.penalized ] ) of non - binary codes in arbitrary fields .",
    "however , in arbitrary fields we have not been successful in developing a computationally simple projection sub - routine . in section  [ section.lpandadmm_noadmmproj ]",
    "we limit our focus to lp decoding of codes in @xmath0 and develop an efficient algorithm . *",
    "we show through numerical results that the penalized decoder improves the wer performance significantly at low snrs ( section  [ section.numerical ] ) .",
    "in this section , we fix some notation and definitions that will be used through out the paper .",
    "we use @xmath11 to denote the set of real numbers and @xmath7 to denote finite fields of size @xmath12 .",
    "we denote by @xmath0 fields of characteristic two .",
    "we use bold capital letters to denote matrices and bold small letters to denote vectors .",
    "we use non - bold small letters to denote entries of matrices and vectors .",
    "for example , @xmath13 is a matrix and @xmath14 is the entry at the @xmath15-th row and the @xmath16-th column .",
    "@xmath17 is a vector and its @xmath15-th entry is @xmath18 .",
    "we use script capital letters to denote discrete sets and use @xmath19 to denote the cardinality of a set .",
    "further , we denote by @xmath20 $ ] the set @xmath21 .",
    "we use sans - serif font to represent mappings and functions , e.g. @xmath22 and @xmath23 .",
    "we also explicitly define the following operations : @xmath24 is the operation of taking the convex hull of a set in @xmath25 . it is defined as @xmath26 @xmath27 the operation @xmath28 vectorizes a matrix , i.e. , it stacks all columns of a matrix to form a column vector .",
    "for example , let @xmath13 be a @xmath29 matrix ; then @xmath30 .      throughout this paper",
    "we use roman blackboard bold symbols to denote convex sets , e.g. , @xmath31 .",
    "( for real numbers ) and @xmath32 ( for finite fields ) are two special cases where we use roman blackboard bold symbols . ] in particular , we define the following polytopes that will be used extensively throughout this paper :    let @xmath33 denote the _ parity polytope _ of dimension @xmath4 , @xmath34 let @xmath35 denote the positive orthant of a unit @xmath36 ball of dimension @xmath37 , @xmath38 let @xmath39 denote the _",
    "standard @xmath4-simplex _ , @xmath40    it is easy to verify that @xmath41 implies @xmath42 where @xmath43 .",
    "because of this relationship , we use @xmath35 with one dimension less than @xmath39 .",
    "further , we let the vector index start from @xmath44 for vectors in @xmath39 and @xmath45 for vectors in @xmath35 .      we consider non - binary linear codes of length @xmath46 with @xmath47 checks , and use @xmath48 to denote the parity - check matrix of a code where each entry @xmath49 .",
    "we use @xmath16 to represent a check node index and @xmath15 to represent a variable node index .",
    "then the set of codewords is @xmath50 .",
    "when represented by a factor graph , the set of variable and check nodes are denoted by @xmath51 and @xmath52 respectively .",
    "let @xmath53 and @xmath54 be the respective set of neighboring nodes of variable node @xmath15 and of check node @xmath16 .      in this paper",
    "we often consider finite fields of characteristic two .",
    "since we will have more occasion to add in finite fields than to multiply , we represent each element of @xmath0 using an integer in @xmath55 . without loss of generality",
    ", an element @xmath56 can be represented by a polynomial @xmath57 . in this paper",
    "we often use the integer representation of @xmath58 which is given by @xmath59 .",
    "[ example.finite_fields_representations ] we consider @xmath60 and let the primitive polynomial be @xmath61 .",
    "let @xmath62 be the primitive element of the field .",
    "we list different representations of elements in @xmath60 in table  [ table.integer_rep ] .",
    ".different representations of elements in @xmath60 .",
    "[ cols=\"^,^,^,^\",options=\"header \" , ]      we first focus on lp decoding using the tight code polytope @xmath63 .",
    "[ theorem.equiv_lp ] consider any finite field @xmath64 and let @xmath65 .",
    "let @xmath66 be a length-@xmath67 vector where @xmath68 . if @xmath69 is the solutionof * lp - ft * , then @xmath70 is the solutionof * lp - ct*. conversely , if @xmath71 is the solutionof * lp - ct*for some @xmath72 , then @xmath69 is the solutionof * lp - ft*.    see appendix  [ proof.equiv_lp ]    this theorem builds the equivalence in the sense that , if * lp - ft*and * lp - ct*are given the same channel output vector , then there is a bijective mapping between their decoding results .",
    "it is then easy to show the following corollary .",
    "[ corollary.equiv_error_rate ] both * lp - ft*and * lp - ct*achieve the same symbol - error - rate and word - error - rate .    by theorem  [ theorem.equiv_lp ] , * lp - ft*decodes a channel output @xmath73 to a fractional solution if and only if * lp - ct*decodes @xmath73 to a fractional solution .",
    "thus the two decoders either both succeed or both fail .    under the channel symmetry condition in the sense of  @xcite , the probability that * lp - ct*fails is independent of the codeword that was transmitted .",
    "this is due to theorem  5.1 in  @xcite and corollary  [ corollary.equiv_error_rate ] .",
    "we now consider the lp decoding problem for codes in fields of characteristic two when the relaxed code polytope is used in lp decoding .",
    "[ theorem.equiv_lp_relax ] consider finite fields @xmath0 and let @xmath65 .",
    "let @xmath66 be a length-@xmath74 vector where @xmath68 .",
    "if @xmath69 is the solutionof * lp - fr * , then @xmath70 is the solutionof * lp - cr*. conversely , if @xmath71 is the solutionof * lp - cr*for some @xmath72 , then @xmath69 is the solutionof * lp - fr*.    see appendix  [ proof.equiv_lp_relax ] .",
    "[ corollary.equiv_error_rate_relaxed ] both * lp - fr*and * lp - cr*achieve the same symbol - error - rate and word - error - rate .",
    "[ corollary.codewordindependence ] under the channel symmetry condition in the sense of  @xcite , the probability that * lp - fr*fails is independent of the codeword that was transmitted .",
    "this is due to theorem  2 in  @xcite and theorem  [ theorem.equiv_lp_relax ] .",
    "we also provide our direct proof of this corollary in appendix  [ proof.codewordindependence ] .",
    "our proof leverages the proof technique taken in  @xcite .",
    "in addition , we show a symmetry property of @xmath75 .      *",
    "our results imply that one has the freedom to choose either flanagan s embeddingor the constant - weight embeddingfor lp decoding .",
    "both embedding methods yield the same error rates . *",
    "we note that the relaxed versions of lp decoding ( * lp - fr*and * lp - cr * ) are in general worse than the tighter versions ( * lp - ft*and * lp - ct * ) in terms of error rates . *",
    "lp decoding using flanagan s embeddingrequires fewer variables .",
    "in addition , we show in section  [ section.numerical ] that the admm lp decoder in section  [ section.lpandadmm_noadmmproj ] , which uses flanagan s embedding , converges faster than its constant - weight embeddingcounterpart .      in this section , we derive a generic admm formulation for lp decoding of non - binary codes .",
    "this generic formulation applies to arbitrary field @xmath7 , however it requires a sub - routine that projects a vector onto @xmath63 or @xmath75 . in our previous work  @xcite , we developed a projection algorithm onto @xmath75 .",
    "but efficient algorithms for projection onto @xmath63 .",
    "we formulate the admm algorithm under the assumption that a sub - routine that projects a vector onto @xmath63 or @xmath75 is provided .",
    "we will use the formulation in this section to develop a penalized lp decoder in section  [ section.penalized ] .",
    "we derive the `` @xmath17-update '' for this admm when the variables are related to embeddings .",
    "we use the shorthand notation @xmath76 , and following the methodology of  @xcite , cast the lp into a form solvable using admm .",
    "we introduce replicas @xmath77 for all @xmath78 .",
    "each @xmath77 is a length-@xmath79 vector where @xmath80 is the check degree .",
    "we then express   in the following , equivalent , form : @xmath81 where @xmath82 is the sub - vector selected from the @xmath15-th ( @xmath8)-length block of @xmath17 . in other words , @xmath83 corresponds to the embedded vector of the @xmath15-th non - binary symbol .",
    "@xmath84 is the @xmath8 simplex defined in  .",
    "the augmented lagrangian is @xmath85 @xmath86 admm iteratively performs the following updates : @xmath87 in the @xmath88-update we solve the following optimization problem : @xmath89 we first introduce some additional notation . let @xmath90 be the vector of log - likelihood ratios that correspond to the @xmath15-th symbol of the code . in other words , @xmath91 let @xmath92 be the length-@xmath67 sub - vector of @xmath93 that corresponds to the @xmath15-th symbol of the code .",
    "similarly , we define @xmath94 to be the sub - vector of @xmath77 that correspond to the @xmath15-th symbol of the code .",
    "we then write @xmath95 as @xmath96 @xmath97 note that when @xmath77 and @xmath93 are fixed for all @xmath98 , we can decouple @xmath83 for all @xmath99 in the sense that they can be individually solved for . therefore @xmath100 where @xmath101 .",
    "\\end{aligned}\\ ] ] thus , the @xmath17-update is equivalent to a euclidean projection onto @xmath102 , which is solvable in linear time ( i.e. , @xmath103 ) using techniques proposed in  @xcite .",
    "note that the @xmath104 in   is an average of the corresponding replicas ( i.e. , @xmath94 ) plus adjustments from the lagrange multipliers ( i.e. , @xmath92 ) and the log - likelihood ratios ( i.e. , @xmath90 ) .    in the @xmath105-update we can solve for each @xmath77 separately .",
    "when @xmath83 and @xmath93 are fixed for all @xmath99 and @xmath78 we complete the square with respect to each @xmath77 and obtain the following update rule : @xmath106 where @xmath107 .",
    "thus the @xmath105-update is equivalent to the euclidean projection onto @xmath108 .    for * lp - fr * , the respective @xmath105-update is equivalent to projection onto @xmath109 .",
    "that is , @xmath110 in our previous work  @xcite , we proposed an admm algorithm to solve  .",
    "we show in section  [ section.lpandadmm_noadmmproj ] that the complexity of the decoding algorithm in  @xcite can be greatly reduced .      in this section",
    ", we focus on * lp - fr*and propose an admm decoding algorithm that does not require a sub - routine that projects onto @xmath75 .",
    "we note that it is easy to extend the techniques in this section to problem * lp - cr*.    for an ldpc code , all entries of the embedded vector of a non - binary variable @xmath99 participate in @xmath111 non - binary checks .",
    "when embedding is used , each non - binary check can be decomposed by at - most - one - on - checks and parity - checks .",
    "we may think of these constraints having two hierarchies .",
    "the first hierarchy consists of constraints defined by the parity - check matrix of a non - binary code .",
    "the second hierarchy consists of constraints defined by the spc code embeddings ( i.e. , definition  [ def.relaxed_code_polytope ] ) .",
    "we illustrated this in example  [ example.two_level_factor_graph ] .",
    "[ example.two_level_factor_graph ] we build the factor graph of embeddings for an ldpc code in @xmath10 .",
    "assume that the @xmath16-th check is connected to three variable nodes @xmath112 , @xmath113 and @xmath114 .",
    "then , the embedded variables ( @xmath115 binary variables ) are connected to the @xmath16-th non - binary check .",
    "this connection is captured by the matrix @xmath116 in  .",
    "we can think of this as the first hierarchy .",
    "there is another hierarchy of factor graph inside the @xmath16-th constraint set , namely , those constraints defined by lemma  [ lemma.equiv_integer_constraint ] .",
    "the variables are first permuted by the rotation steps defined in section  [ subsec.rotation ] where the permutations are captured by the matrix @xmath117 .",
    "then , they are connected to a normalized constraint set defined by three at - most - one - on - checks and three parity - checks .",
    "the three at - most - one - on - checks are connected to the vector triplets @xmath118 , @xmath119 and @xmath120 respectively",
    ". the three parity - check are specified by @xmath121 for @xmath122 and @xmath123 ; and are connected to the * permuted * entries of @xmath118 , @xmath119 and @xmath120 .",
    "these connections are shown in figure  [ fig.layered_factor_graph ] .",
    "we note that we obtain figure  [ fig.layered_factor_graph ] by going through two hierarchies of constraints . however , the resulting graph is nothing but a factor graph of embeddings with two types of factor nodes : at - most - one - on - check nodes and parity - check nodes .",
    "the connections between variable nodes and factor nodes are specified by both the parity - check matrix of the code and the constraints specified for spc codes ( i.e. , those in lemma  [ lemma.equiv_integer_constraint ] ) .",
    "we now formally state the admm formulation based on the factor graph of embeddings .",
    "we will assume that the code has regular variable degree @xmath124 for conciseness .",
    "however , our derivation can easily extend to irregular codes . by lemma  [ lemma.rotation_equivalence ] ,",
    "we can rewrite the lp decoding problem using the normalized polytope @xmath125 and rotation matrix @xmath117 . from now on , we use @xmath126 to denote the rotation matrix @xmath127 , where @xmath128 is the non - zero sub - vector of the @xmath16-th check of the code . then , * lp - fr*can be rewritten as @xmath129",
    "note that @xmath125 is defined as the intersection of simplexes ( condition @xmath130 and @xmath131 in definition  [ def.relaxed_code_polytope ] ) and parity polytopes ( condition @xmath132 in definition  [ def.relaxed_code_polytope ] ) .",
    "for condition @xmath132 we define a select - and - add matrix @xmath133 using the following procedure .",
    "we first let @xmath134 , @xmath135 $ ] , be all non - empty subsets of @xmath136 $ ] .",
    "we then use @xmath137 to denote the matrix that selects the entries in @xmath138 and adds them to form the vector @xmath139 . as a result , we can rewrite   as @xmath140\\\\ \\quad &   { { \\boldsymbol}{x}}_i \\in { \\mathbb{s}}_{q-1 } \\text { for all } i\\in { { \\mathcal}{i}}. \\end{split}\\ ] ] we introduce replicas @xmath141 and @xmath142 . we let @xmath143 and @xmath144",
    ". however , note that we draw a distinction between @xmath105 and @xmath145 only for notation purposes . both @xmath105 and @xmath145 serve the same purpose ( i.e. , replicas ) in the admm algorithm .",
    "@xmath146 \\text { and } i\\in{{\\mathcal}{i}},\\\\ \\quad   & { { \\boldsymbol}{z}}_{j,{k } } = { { \\boldsymbol}{t}}_k { { { \\boldsymbol}{d}}}_j^{-1 } { { \\boldsymbol}{p}}_j { { \\boldsymbol}{x } } , \\\\",
    "\\quad & { { \\boldsymbol}{z}}_{j,{k } } \\in { \\mathbb{p}}_{{d_c } } , \\\\ \\quad & { { \\boldsymbol}{s}}_i   = { { \\boldsymbol}{x}}_i,\\\\ \\quad &   { { \\boldsymbol}{s}}_i \\in { \\mathbb{s}}_{q-1}. \\end{split}\\ ] ] by defining @xmath147 , we can write the augmented lagrangian as @xmath148 where @xmath149 selects the sub - vector @xmath83 from @xmath17 . the admm updates for this problem are @xmath150 we make the following remarks .",
    "first , the @xmath17-update is an unconstrained optimization problem , which is different from the case in section  [ subsec.genericadmm ] .",
    "second , we separate the @xmath105-update and the @xmath145-update because the two types of replicas are in two different polytopes ( @xmath151 and @xmath102 respectively ) .      by taking the gradient of @xmath152 and setting it to the all - zeros vector we obtain the following @xmath17-update @xmath153 @xmath154 where @xmath155 and the identity matrix @xmath156 comes from the fact that @xmath157 .",
    "note that @xmath158 has at most one @xmath45 in each row due to constraints defined in definition  [ def.relaxed_code_polytope ] . since the permutation matrix @xmath159 and the selection matrix @xmath116 all have at most one @xmath45 in each column",
    ", @xmath160 simply selects the entries in @xmath161 that correspond to some entries in @xmath17 maps @xmath17 to the replica @xmath161 .",
    "in addition , there is at most one @xmath45 per column in @xmath162 .",
    "this implies that @xmath160 has at most one @xmath45 per row .",
    "thus , @xmath160 simply selects entries from @xmath161 . ] .",
    "we use the notation @xmath163 to represent the length-@xmath67 sub - vector of @xmath161 that corresponds to @xmath83 .",
    "therefore , we can rewrite @xmath17-update as @xmath164 where @xmath165 and @xmath166 note that the matrix @xmath167 is fixed by the code .",
    "therefore one needs to calculate it only once per code .",
    "however , a naive calculation of @xmath168 has complexity @xmath169 which can be prohibitive for large @xmath46 .",
    "we therefore introduce a method to calculate this product in linear complexity @xmath170 .",
    "[ lemma.x_update_algorithm ] @xmath168 can be calculated in linear complexity @xmath170 .",
    "see appendix  [ appendix.x_update_algorithm ] .",
    "the @xmath105- and @xmath145-updates are the same as   except that we now perform the respective projections onto @xmath171 and @xmath172 .",
    "@xmath173,\\end{aligned}\\ ] ] where @xmath174 and @xmath175 .",
    "both projection operations have complexity that is linear in @xmath176 and @xmath80 respectively ( cf .  @xcite and  @xcite ) .",
    "[ proposition.computationalcomplexity ] let @xmath177 be the solution of the lp decoding problem  .",
    "for any @xmath178 , algorithm  [ algorithm.admmlp_noprojection ] will , in @xmath179 time , determine a vector @xmath180 that satisfies the constraints in   and that also satisfies the following bound : @xmath181 where @xmath73 is the channel output , @xmath182 is the field size and @xmath80 is the check degree .",
    "this proposition is similar to proposition 1 in  @xcite .",
    "we omit the details but point out that admm takes @xmath183 iterations to converge to a point with @xmath184 gap to optimal . for each iteration ,",
    "the complexity of the @xmath17-update is @xmath179 .",
    "the complexity of each @xmath185-update is @xmath186 .",
    "since @xmath80 does not scale , we deduce that the complexity of each iteration is @xmath179 . therefore due to the @xmath183 requirement on the number of iterations ,",
    "the overall complexity is @xmath179 .",
    "we summarize admm lp decoding in algorithm  [ algorithm.admmlp_noprojection ] .",
    "construct the @xmath187 matrices @xmath162 for all @xmath98 and @xmath135 $ ] based on the factor graph of embeddings .",
    "construct the @xmath188 matrices @xmath189 for all @xmath68 based on the at - most - one - on constraints .",
    "initialize all entries of @xmath190 and @xmath191 to @xmath44 .",
    "initialize all entries of @xmath161 and @xmath192 to @xmath193 .",
    "initialize iterate @xmath194 . to simplify the notation",
    ", we drop iterate @xmath195 except when determining the stopping criteria .",
    "compute vector @xmath196 using equation  .",
    "store @xmath197 .",
    "compute the variables @xmath198 and @xmath199 per lemma  [ lemma.invertzplusi ] .",
    "update @xmath200 .    set @xmath201 .",
    "update @xmath202 where @xmath203 is a projection onto the parity polytope of dimension @xmath80 .",
    "update @xmath204 .    set @xmath205 .",
    "update @xmath206 where @xmath207 is a projection onto @xmath102 .",
    "update @xmath208 .",
    "+ * return * @xmath17 .      in practice",
    ", admm can be terminated whenever a codeword is found .",
    "doing so often reduces the number of iterations needed to decode .",
    "we observe empirically that early termination does affect the wer for some very short block length codes .",
    "however , it does not create observable effects for the codes we study in section  [ section.numerical ] .",
    "we use the vectors @xmath142 for all @xmath68 to determine whether or not the corresponding non - binary vector is a codeword .",
    "the decision process is as follows . for each @xmath99",
    ", we first obtain the vector @xmath210 by letting @xmath211 and @xmath212 for all @xmath213 $ ] .",
    "then , the @xmath15-th non - binary symbol is determined by @xmath214 .",
    "after we have obtained the length-@xmath46 non - binary vector @xmath215 , we terminate admm if @xmath216 in @xmath0 where @xmath48 is the parity - check matrix of the code . in order to determine whether an intermediate result is a codeword or not , we need to first round the result to a non - binary vector and then test it with the parity - check matrix of the code .",
    "it is worth mentioning that unlike the binary admm lp decoder  @xcite the @xmath17 variables in algorithm  [ algorithm.admmlp_noprojection ] are not bounded by @xmath217 $ ] . in algorithm",
    "[ algorithm.admmlp_noprojection ] , the vectors that we use for rounding and early termination are the vectors @xmath142 for all @xmath68 .",
    "this is because @xmath218 for all @xmath68 .",
    "note that not all length-@xmath67 binary vectors are embeddings of some non - binary symbols . therefore rounding a non - integral @xmath142 to the nearest binary vector",
    "is inappropriate .",
    "in addition , it is inappropriate to round to the nearest valid embedding because flanagan s embeddingtreats @xmath44 differently from other elements in the field .",
    "it is however , it is easy to observe that all possible embeddings of the constant - weight embeddingare symmetrically placed",
    ". therefore for a non - integral @xmath142 , we can identify the nearest embedded non - binary symbol in the constant - weight embedding , which is the point where @xmath142 should be rounded to .",
    "the corresponding non - binary symbol can then be used to determine whether or not the codeword is valid . as a result",
    ", the admm algorithm can be terminated whenever a valid codeword is found .",
    "another useful technique in practice is over - relaxation , which is already used in  @xcite .",
    "readers are referred to  @xcite and references therein for details on over - relaxation .",
    "we observe that over - relaxation is effective for algorithm  [ algorithm.admmlp_noprojection ] .",
    "experiments surrounding the choices of over - relaxation parameter @xmath219 are presented in section  [ section.numerical ] .",
    "in this section , we introduce an admm penalized decoder for non - binary codes .",
    "this decoder is analogous to the penalized decoder for binary codes introduced in  @xcite .",
    "it is shown in  @xcite that adding a non - convex penalty term to the lp decoding objective can improve the low snr performance of lp decoding .",
    "the penalty term penalizes fractional solutions and can improve the performance because correct solutions should be integral . herein , we extend this idea to embeddings of non - binary symbols .",
    "one important characteristic of linear codes is that , at least when codewords are transmitted over a symmetric channel , the probability of decoding failure should be independent of the codeword that is transmitted . to get this property to hold for the non - binary penalized decoder ,",
    "herein , we use the constant - weight embedding .",
    "this desired `` codeword - independent '' property follows because all non - binary symbols are embedded symmetrically with respect to each other . as a reminder , for flanagan s embedding , symbol @xmath44",
    "is treated differently from others symbol in the field .",
    "we discuss this issue in details in section  [ subsection.discussions ] .",
    "formally , we consider the following decoding problem : @xmath220 where @xmath83 is the sub - vector of @xmath17 that corresponds to the @xmath15-th non - binary symbol .",
    "we focus on @xmath221 because we have developed an admm projection algorithm onto @xmath221 in  @xcite .",
    "however , the same decoding objective can be applied to @xmath222 .",
    "@xmath223 is a penalty function satisfying the following two basic properties :    1 .",
    "let @xmath224 , then @xmath225 if @xmath226 .",
    "2 .   let @xmath227 be any vector obtained from permuting @xmath228 , then @xmath229 .",
    "further , we would like to obtain simple admm updates for the decoding problem  .",
    "therefore , we focus on a @xmath230 penalty and propose applying the admm framework to the following problem : @xmath231 where @xmath232 is the relaxed polytope under the constant - weight embedding(definition  [ def.cw_code_polytopes ] ) , @xmath233 and @xmath234    we pick the @xmath230 norm as the penalty in   because it yields simple admm update rules and because it yields good empirical performance ( cf .  section  [ section.numerical ] ) .",
    "for both the @xmath17-update and the @xmath105-update , we complete the square and then perform minimizations . as a result , the @xmath17-update can be expressed as a projection onto @xmath235 ; and the @xmath105-update can be expressed as a projection onto @xmath232 . in particular , the @xmath17-update rule is @xmath236.\\end{aligned}\\ ] ]    the @xmath105-update can be written as a projection onto @xmath221 . for this projection operation",
    ", we use the rotate - and - project technique introduced in section  [ subsec.rotation ] ( see also  @xcite for more details ) .",
    "the admm penalized decoder is summarized in algorithm  [ algorithm.penalized_decoder ] .",
    "construct the @xmath237 selection matrix @xmath238 for all @xmath239 based on the parity - check matrix @xmath48 .",
    "construct the log - likelihood ratio @xmath240 .",
    "for all @xmath241 , initialize all entries of @xmath93 to @xmath44 and initialize all entries of @xmath77 to @xmath242 .",
    "initialize iterate @xmath194 . to simplify the notation , we drop iterate @xmath195 except when determining the stopping criteria .",
    "[ algstep.xupdate1 ] update @xmath83 by +    set @xmath243 .",
    "update @xmath244 where @xmath245 is a projection onto the relaxed code polytope defined by the @xmath16-th check .",
    "update @xmath246 .",
    "+ * return * @xmath17 .",
    "[ theorem.penalized_decoder_allzero ] under the channel symmetry condition in the sense of  @xcite , the probability that algorithm  [ algorithm.penalized_decoder ] fails is independent of the codeword that was transmitted .",
    "see appendix  [ proof.penalized_decoder_allzero ]      the penalized decoder described above requires a sub - routine that projects onto the code polytope .",
    "the admm projection technique introduced in  @xcite scales linearly with @xmath247 , where @xmath4 is the degree of the check node and @xmath12 is the field size .",
    "however , this projection technique is iterative and inaccurate , because it accepts an error tolerance @xmath248 . as a result ,",
    "the provable number of iterations scales linearly with @xmath249 due to the linear convergence rate of admm ( cf .",
    "this means that each iteration of the admm penalized decoder scales linearly with @xmath250 . on the contrary",
    ", each iteration of algorithm  [ algorithm.admmlp_noprojection ] does not depend on such error tolerance . as a result ,",
    "the computational complexity of the penalized decoder is much higher than the admm lp decoder in algorithm  [ algorithm.admmlp_noprojection ] .",
    "we observe empirically that in our implementation of admm penalized decoding is around @xmath251 times slower than the admm lp decoder in algorithm  [ algorithm.admmlp_noprojection ] .",
    "we note that algorithm  [ algorithm.admmlp_noprojection ] , in fact , can be used to try to solve the penalized objective  .",
    "however , we observe empirically that the resulting decoder does not have the codeword symmetry property in the sense of theorem  [ theorem.penalized_decoder_allzero ] .",
    "we briefly discuss why the proof technique of theorem  [ theorem.penalized_decoder_allzero ] can not be applied to this decoder .",
    "first , note that the penalized decoder tries to solve a non - convex program . as a result",
    ", the output of the penalized decoder can not be determined solely by the optimization problem .",
    "it depends on the admm update rules ( the @xmath17- , @xmath105- and @xmath252-update ) , which are determined by the way the optimization problem is stated . in the proof of theorem",
    "[ theorem.penalized_decoder_allzero ] , we show that the decoding process when decoding the all - zeros codeword is `` symmetric '' with respect to any other codeword s decoding process in the sense of lemma  [ lemma.quiviter ] ( see rigorous discussions in appendix  [ proof.penalized_decoder_allzero ] ) .",
    "this symmetry behavior is due to the symmetric structure of @xmath221 ( lemma  [ lemma.relative_code_polytope ] ) .",
    "if we were to use algorithm  [ algorithm.admmlp_noprojection ] to try to solve  , the polytopes used to describe the constraint set are parity polytopes and simplexes , not @xmath221 . as a result , we can not have the symmetry behavior for parity polytopes and simplexes in the sense of lemma  [ lemma.relative_code_polytope ] .",
    "observe that the only difference between applying algorithm  [ algorithm.admmlp_noprojection ] to   and algorithm  [ algorithm.penalized_decoder ] is the way the constraint set is parameterized .",
    "the constraint set in algorithm  [ algorithm.penalized_decoder ] is parameterized using @xmath221 but the one in algorithm  [ algorithm.admmlp_noprojection ] is described as a intersection of parity polytopes and simplexes .",
    "this difference does not change the solution of lp decoding because lp decoding always outputs the unique solution of the problem .",
    "however , the penalized decoder tries to solve a non - convex problem .",
    "in fact , we observe empirically that applying algorithm  [ algorithm.admmlp_noprojection ] to   does not have the symmetry property in the sense of theorem  [ theorem.penalized_decoder_allzero ] .    on the other hand",
    ", we note that applying algorithm  [ algorithm.admmlp_noprojection ] to   results in a significant improvement in terms of decoding efficiency when compared to algorithm  [ algorithm.penalized_decoder ] .",
    "furthermore , we observe empirically that this technique can achieve a much reduced error rate when compared to lp decoding ( * lp - fr*and * lp - cr * ) for the all - zeros codeword .",
    "open questions include whether all codewords experience some improvement and how much improvement each codeword receives .",
    "these questions are non - trivial because of the non - convexity of the penalized objective .",
    "in this section we present numerical results for admm lp decoding ( algorithm  [ algorithm.admmlp_noprojection ] ) and admm penalized lp decoding ( algorithm  [ algorithm.penalized_decoder ] ) .",
    "first , we show the error rate performance of the two decoders as a function of snr . in addition",
    ", we compare our decoders to the low - complexity lp ( lclp ) decoding technique proposed by punekar _",
    "_ in  @xcite .",
    "next , in section  [ subsection.parameter_lp ] , we focus on choosing a good set of parameters for algorithm  [ algorithm.admmlp_noprojection ] .",
    "finally , we show how the penalty coefficient @xmath58 ( cf .  ) affects the wer performance of admm penalized decoding .      in this subsection",
    "we simulate three codes and demonstrate their error rate performance as a function of snr .",
    "the first code we simulate is derived from a binary length-@xmath253 progressive edge growth ( peg ) code that can be obtained from  @xcite .",
    "the other two codes are derived from two binary tanner codes obtained from@xcite .",
    "we select these codes for the following reasons .",
    "first , we select codes that are of different block lengths ( @xmath253 , @xmath254 and @xmath255 ) and in different fields ( @xmath10 and @xmath60 ) .",
    "second , the two tanner codes have been studied in  @xcite .",
    "therefore we can make direct comparisons with the results therein .",
    "last but not least , the parity - check matrices of these codes are easy to obtain ( e.g. , from  @xcite ) .",
    "our intent is to make our simulations using these codes easy to repeat and thus to compare to",
    ".    figure  [ fig.sim_peg2048_wer_ser ] plots the word - error - rate ( wer ) and symbol - error - rate ( ser ) of a length-@xmath253 ldpc code when decoded using admm lp decoding and admm penalized decoding .",
    "this code is derived from the peg @xmath256 $ ] binary ldpc code obtained from  @xcite .",
    "we use the same parity - check matrix as the original peg code except that we let each non - zero check value be @xmath257 .",
    "the code symbols are modulated using quaternary phase - shift keying ( qpsk ) and transmitted over an awgn channel .",
    "denote by @xmath258 the in - phase and quadrature components .",
    "we modulate the symbols in the following way : @xmath259 , @xmath260 , @xmath261 and @xmath262",
    ". we use energy per information symbol ( @xmath263 ) as our unit of snr .",
    "we show explicitly how we calculate @xmath263 in appendix  [ appendix.esn0 ] . in this simulation",
    ", we decode using admm lp decoding ( algorithm  [ algorithm.admmlp_noprojection ] ) and admm penalized decoding ( algorithm  [ algorithm.penalized_decoder ] ) .",
    "we note that both algorithms require many parameters .",
    "we show how to choose parameters in sections  [ subsection.parameter_lp ] and  [ subsection.penalized ] . for admm lp",
    "decoding we use the following parameter settings : the `` step size '' of admm @xmath264 ( cf .  ) ; the maximum number of iterations @xmath265 ; the ending tolerance @xmath266 ( cf . algorithm  [ algorithm.admmlp_noprojection ] ) , and the over - relaxation parameter @xmath267 ( cf . section  [ subsubsection.early_term_and_overrel ] ) . for admm penalized decoding ,",
    "we let @xmath268 , @xmath265 , @xmath269 , @xmath266 , and @xmath270 ( cf .  ) . for each data point , we collect more than @xmath271 word errors .    we make the following observations .",
    "first , both decoding algorithms display a `` waterfall '' behavior in terms of error rates .",
    "however , penalized decoding initiates the waterfall at a much lower snr ( about @xmath272db lower in this example ) .",
    "this shows that admm penalized decoding significantly improves lp decoding at low snrs .",
    "second , admm penalized decoding displays an error - floor at wer @xmath273 ( ser @xmath274 )",
    ". however , lp decoding does not display an error - floor for wer above @xmath275 ( ser above @xmath276 ) .",
    "both observations are consistent with binary lp decoding and binary penalized decoding  @xcite .",
    "we note that unlike the case with binary decoders where the binary admm penalized decoder outperforms the binary admm lp decoding in terms of both the number of iterations and execution time , the average decoding time of algorithm  [ algorithm.penalized_decoder ] using our implementation is much longer than that of algorithm  [ algorithm.admmlp_noprojection ] due to the reasons discussed in section  [ section.penalized ] . although algorithm  [ algorithm.penalized_decoder ] is competitive in terms of wer performance , it is not competitive in terms of execution time .",
    "$ ] peg code in @xmath10 . ]",
    "the second code we simulate is the length-@xmath254 code used in  @xcite .",
    "this code is derived from the tanner @xmath277 $ ] binary ldpc code introduced by tanner in  @xcite .",
    "similar to the previous case , each binary non - zero entry is replaced by the value @xmath278 .",
    "we keep all other simulation settings the same as the previous case , i.e. , we use the same awgn channel with qpsk modulation and the same parameter settings for algorithm  [ algorithm.admmlp_noprojection ] . for the penalized decoder , we change the parameter settings .",
    "we use the following settings : @xmath268 , @xmath269 , @xmath279 , @xmath266 , and @xmath280 .",
    "we first plot the wer performance of the code in figure  [ fig.sim_tanner1055_wer ] .",
    "the performance of lclp and the sum - product algorithm ( spa ) decoders are plotted for comparison .",
    "the data for these decoders is obtained from  @xcite .",
    "we make the following observations .",
    "first , we observe that admm lp decoding outperforms both spa and lclp in terms of wer .",
    "admm lp decoding has a @xmath281db snr gain when compared to the lclp algorithm of  @xcite .",
    "this result is interesting because admm lp decoding uses the relaxed code polytope @xmath75 .",
    "thus , one might expect that in general it would perform worse than flanagan s lp decoding algorithm .",
    "however , we recall that we validated numerically that @xmath282 for @xmath10 ( cf .",
    "appendix  [ appendix.conjecture ] ) .",
    "figure  [ fig.sim_tanner1055_wer ] suggests that lclp may have a @xmath281db snr loss due to the approximations made in that algorithm ( see  @xcite for details ) .",
    "second , the penalized decoder improves the wer performance by @xmath283db .",
    "this effect is consistent with figure  [ fig.sim_peg2048_wer_ser ] .",
    "third , we note that none of the decoders used in figure  [ fig.sim_tanner1055_wer ] displays an error - floor .",
    "$ ] code in @xmath10 . ]    in figure  [ fig.sim_tanner1055_iter ] and  [ fig.sim_tanner1055_time ] , we show results on computational complexity of algorithm  [ algorithm.admmlp_noprojection ] . in figure",
    "[ fig.sim_tanner1055_iter ] , we plot the average number of iterations for erroneous decoding events , all decoding events , and correct decoding events .",
    "we observe that for correct decoding events , the average number of iterations is less than @xmath271 at all snrs .",
    "this indicates that we can lower @xmath284 without greatly impacting wer .",
    "in fact , we observe that there is less than a @xmath285db loss if we use @xmath279 ( data not shown ) .    in figure  [ fig.sim_tanner1055_time ] , we plot execution time statistics for the decoding events . in these simulations ,",
    "the decoder is implemented using c++ and data is collected on a 3.10ghz intel(r ) core(tm ) i5 - 2400 cpu .",
    "we make the following observations : first , the average decoding time for correctly decoded events decreases as the snr increases .",
    "however , the average decoding time for erroneous decodings does not vary significantly with snr .",
    "second , the average time per decoding decreases rapidly at low snrs .",
    "this is due to the waterfall behavior of the error rate .",
    "third , we note that admm lp decoding ( algorithm  [ algorithm.admmlp_noprojection ] ) is a much faster algorithm in terms of execution time than admm penalized decoding ( algorithm  [ algorithm.penalized_decoder ] ) . as an example",
    ", the average decoding time for admm lp decoding at @xmath286db is @xmath287s .",
    "in contrast , the average decoding time for admm penalized decoding at @xmath286db is @xmath288s ( data not shown ) , which is about 15 - 20 times slower than algorithm  [ algorithm.admmlp_noprojection ] .     plotted as a function of snr for the tanner @xmath277 $ ] code in @xmath10 . ]     plotted as a function of snr for the tanner @xmath277 $ ] code in @xmath10 . ]    in figure  [ fig.sim_tanner755_wer ] , we show results for the length-@xmath255 code also studied in  @xcite .",
    "this code has symbols in @xmath60 and is derived from the tanner @xmath289 $ ] binary ldpc code  @xcite .",
    "we use the same non - binary parity - check matrix and the same @xmath290-psk modulation method as in  @xcite .",
    "we make the following remarks .",
    "first , admm lp decoding performs worse than lclp in our simulations .",
    "this is due to the fact that admm lp decoding uses the relaxed code polytope . unlike in the @xmath10 case",
    ", relaxing the polytope using definition  [ def.relaxed_code_polytope ] induces a loss in terms of snr performance .",
    "we observe that admm lp decoding is about @xmath291db worse than lclp .",
    "second , and similar to what we saw in the simulations for the previous two codes , the penalized decoder improves the low - snr performance of lp decoding by around @xmath292db for @xmath293db .",
    "however , the wer curve displays a significant error - floor .",
    "we observe that the optimal value for the penalty coefficient @xmath58 decreases as snr increases ( data not shown ) . at @xmath294db , adding a positive penalty does not lead to an observable improvement in wer .",
    "third , in comparison to figure  [ fig.sim_tanner1055_wer ] in which no error - floor is observed for any decoder , we believe that the @xmath295 $ ] tanner code is a problematic code .",
    "thus , we think designing a good code for admm decoding is important future work .",
    "$ ] code in @xmath60 . ]",
    "we make two concluding remarks .",
    "first , algorithm  [ algorithm.admmlp_noprojection ] solves the relaxed lp decoding problem efficiently .",
    "it is competitive with earlier decoders in terms of wer performance , especially for @xmath10 .",
    "second , the penalized decoder is a very promising decoder because it improves the low - snr performance of lp decoding consistently .",
    "however , it suffers from high - complexity and may suffer from an early error - floor .",
    "it is important in future work to improve the complexity of the penalized decoder .      in this section",
    "we study the effects of the choice of parameters for algorithm  [ algorithm.admmlp_noprojection ] .",
    "we conduct simulations based on the @xmath277 $ ] tanner code described in the previous subsection , and use the early termination technique described in section  [ subsubsection.early_term_and_overrel ] . for each data point",
    ", we collect more than @xmath271 word errors .",
    "the admm algorithm has many parameters : the `` step size '' of admm @xmath296 ( cf .  ) , the maximum number of iterations @xmath284 , the ending tolerance @xmath297 ( cf .",
    "algorithm  [ algorithm.admmlp_noprojection ] ) , and the over - relaxation parameter @xmath219 ( cf .",
    "section  [ subsubsection.early_term_and_overrel ] ) .",
    "we fix the number of iterations to be @xmath265 and ending tolerance to be @xmath266 because the decoder is less sensitive to the settings of these two parameters than it is to @xmath296 or @xmath219 .    in figures",
    "[ fig.parameter_mu_different_rho_wer ] and  [ fig.parameter_mu_different_rho_iter ] we study the effects of the choice of parameter @xmath296 on the decoder . in figure  [ fig.parameter_mu_different_rho_wer ]",
    "we plot the wer as a function of @xmath296 when @xmath298 , @xmath292 and @xmath299 .",
    "we ran simulations for @xmath286db and @xmath300db . in figure  [ fig.parameter_choice_mu_cw_vs_flanagan_iter ]",
    "we plot the corresponding average number of iterations .",
    "we make the following observations .",
    "first , the wer does not change much as a function of @xmath296 as long as @xmath301 $ ] .",
    "in addition , the lowest number of iterations is attained when @xmath301 $ ] .",
    "this means that a choice of @xmath296 within the range @xmath302 $ ] is good for practical reasons .",
    "second , the trend of the curves for different values of @xmath219 is similar . in other words",
    ", the choice of @xmath219 does not strongly affect the choice of @xmath296 , at least empirically .",
    "this is useful because it simplifies the task of choosing good parameters .",
    "third , we observe that the wer curves for both snrs flatten when @xmath301 $ ] .. ] this indicates the parameter choice for this data point allows admm to converge fast enough to achieve the lp decoding solution within the set number of iterations , at least in most cases .",
    "in particular , if we increase @xmath284 , the range of the flat region increases . we observe that for @xmath286db , @xmath303 , and @xmath298 , the wers are between @xmath304 and @xmath305 for @xmath306 $ ] .",
    "this also shows that in this case increasing @xmath284 does not greatly improve wer performance .",
    "fourth , we observe that the wer performance of the decoder can be improved by assigning a large value to @xmath219 .",
    "this effect is demonstrated further in figures  [ fig.parameter_rho_different_mu_wer ] and  [ fig.parameter_rho_different_mu_iter ] . finally , we observe that the average numbers of iterations are small for both snrs .",
    "note that the snrs in figures  [ fig.parameter_mu_different_rho_wer ] and  [ fig.parameter_mu_different_rho_iter ] are low snrs and the corresponding wers are high .",
    "recall that in figure  [ fig.sim_tanner1055_iter ] the average number of iterations is much smaller than @xmath265 for high snrs .",
    "this means that @xmath284 does not need to be large .    :",
    "number of iterations plotted as a function of @xmath296 for the tanner @xmath277 $ ] code in @xmath10 , @xmath265 , and @xmath266 . ]    in figures  [ fig.parameter_rho_different_mu_wer ] and  [ fig.parameter_rho_different_mu_iter ] , we study the effect of the choice of parameter @xmath219 on the decoder . in figure  [ fig.parameter_rho_different_mu_wer ]",
    "we plot wer as a function of @xmath219 when @xmath296 takes on values @xmath292 and @xmath307 .",
    "again we simulate for @xmath286db and @xmath300db . in figure",
    "[ fig.parameter_rho_different_mu_iter ] , we plot the corresponding average number of iterations as a function of @xmath219 . in these two figures we observe results that are consistent with figures  [ fig.parameter_mu_different_rho_wer ] and  [ fig.parameter_mu_different_rho_iter ] , i.e. , the number of iterations decreases as @xmath219 increases .",
    "however , the wer does not decrease significantly for @xmath308 .",
    ": wer plotted as a function of @xmath219 for the tanner @xmath277 $ ] code in @xmath10 , @xmath265 , and @xmath266 . ]    : number of iterations plotted as a function of @xmath219 for the tanner @xmath277 $ ] code in @xmath10 , @xmath265 , and @xmath266 . ]    finally , we compare flanagan s embeddingand the constant - weight embeddingin terms of decoding performance . for flanagan s embeddingwe use algorithm  [ algorithm.admmlp_noprojection ] . for the constant - weight embeddingwe",
    "apply the method in algorithm  [ algorithm.admmlp_noprojection ] to the lp decoding problem  .",
    "due to the similarity between flanagan s embeddingand the constant - weight embedding , results in section  [ section.lpandadmm_noadmmproj ] can be easily extended to the constant - weight embedding . in figures",
    "[ fig.parameter_choice_mu_cw_vs_flanagan_wer ] and  [ fig.parameter_choice_mu_cw_vs_flanagan_iter ] , we compare both wer and the average number of iterations for the two decoders . in this set of simulations we let @xmath286db , @xmath265 , and @xmath266 . in figure  [ fig.parameter_choice_mu_cw_vs_flanagan_wer ]",
    "we observe that the wer for the constant - weight embeddingis higher than it is for flanagan s embeddingin most cases .",
    "the exception is the data points at @xmath269 and @xmath309 $ ] , where both embeddings attain the same wers .",
    "this exception is because that parameter choices allow admm to converge fast enough to obtain the lp decoding solution .",
    "recall that we proved that the two embedding methods are equivalent in terms of lp decoding ( cf .",
    "corollary  [ corollary.equiv_error_rate_relaxed ] ) .",
    "it is not surprising that both decoders can achieve the same wers when a sufficient number of iterations is allowed . from figure  [ fig.parameter_choice_mu_cw_vs_flanagan_iter ]",
    "we observe that the number of iterations for the constant - weight embeddingis greater than that required for flanagan s embedding .",
    "recall that flanagan s embeddingsaves exactly @xmath45 coordinate for each embedded vector when compared to the constant - weight embedding(cf .",
    "section  [ sec.embedding_finite_fields ] ) . as a result , the constant - weight embeddingrequires slightly more memory than flanagan s embedding .",
    "thus , in practice , flanagan s embeddingfor lp decoding would be preferred .",
    "for the tanner @xmath277 $ ] code in @xmath10 .",
    "the snr is @xmath286db and @xmath265 .",
    "`` cw '' stands for `` constant weight '' . ]     for the tanner @xmath277 $ ] code in @xmath10 .",
    "the snr is @xmath286db and @xmath265 .",
    "`` cw '' stands for `` constant weight '' . ]    to summarize the above discussions , we emphasize four points :    * @xmath310 $ ] and @xmath267 are good parameter choices for the tanner @xmath277 $ ] code . *",
    "the error performance of the decoder only weakly depends on parameter settings . *",
    "flanagan s embeddingis slightly better than the constant - weight embeddingin terms of computational complexity and memory usage . * the effects of the choice of parameters for the peg @xmath256",
    "$ ] code discussed in section  [ subsection.snr_performance ] are similar to that for the tanner @xmath277 $ ] code .",
    "we observe that @xmath311 $ ] and @xmath267 are good parameter choices for the peg @xmath256 $ ] code .",
    "we now study the admm penalized decoder and show how to choose a good penalty parameter @xmath58 .",
    "we use the same tanner @xmath277 $ ] code from section  [ subsection.snr_performance ] and simulate for the awgn channel . for this simulation",
    ", we do not perform an extensive grid search over the possible parameter choices because of limited computational resources . however , the following parameters are good enough to produce good decoding results : @xmath268 , @xmath269 , and @xmath279 .    in figure  [ fig.parameter_pd_alpha_wer ] we plot wer as a function of the penalty parameter @xmath58 .",
    "we observe that the wer first decreases as the value of @xmath58 increases .",
    "but when we penalize too heavily ( e.g , when @xmath312 ) , the wer starts to increase again",
    ". a similar effect can be observed in figure  [ fig.parameter_pd_alpha_iter ] , i.e. , the average number of iterations decreases for @xmath58 small , and then starts to increase once @xmath58 becomes sufficiently large ( @xmath313 in figure  [ fig.parameter_pd_alpha_iter ] ) .",
    "we make two remarks .",
    "first , we observe that @xmath314 is optimal in terms of wer for all snrs we simulated .",
    "this is * not * necessarily the case for other codes or other snrs .",
    "we do observe that for some codes ( e.g. , the tanner @xmath315 $ ] code studied in section  [ subsection.snr_performance ] ) the optimal value for @xmath58 is a ( non - constant ) function of snr .",
    "second , we observe that the optimal @xmath58 in terms of wer is * not * the optimal in terms of the average number of iterations . as a result , there is a trade - off between the optimal computational complexity and the optimal wers in choosing @xmath58 .    : admm penalized decoding wer plotted as a function of @xmath58 for the tanner @xmath277 $ ] code in @xmath10 . ]    : admm penalized decoding number of iterations plotted as a function of @xmath296 for the tanner @xmath277 $ ] code in @xmath10 . ]",
    "in this paper , we develop two types of admm decoders for decoding non - binary codes in fields of characteristic two .",
    "the first is a natural extension of the binary admm decoder introduced by barman _",
    "_ in  @xcite .",
    "this admm algorithm requires a sub - routine that projects a vector onto the polytope formed by the embeddings of an spc code .",
    "the second admm algorithm leverages the factor graph representation of the @xmath0 spc code embedding and does not require the projection sub - routine that is necessary for the first admm algorithm .",
    "we further improve the efficiency of this latter algorithm using new properties of the embedding of spc codes that we have discovered .",
    "we summarize three important future directions relevant to this topic .",
    "first , the relaxed code polytope considered in this work is conjectured to be tight for @xmath10 .",
    "the proof of this conjecture is still open . to the best of the authors knowledge",
    ", there has been no known characterization of @xmath10 pseudocodewords .",
    "therefore we believe this conjecture , if proved , is an important theoretical result to develop en - route to understanding pseudocodewords of non - binary lp decoding .",
    "second , as mentioned many times in the paper , improving the projection sub - routine of admm decoding is important future work ( i.e. , for the `` first '' type of admm algorithm as per the previous paragraph ) .",
    "finally , we show through execution time statistics that the proposed admm lp decoder is efficient and could be interesting in practical ( hardware ) implementation",
    ". however , many missing pieces remain to be developed before the decoder can be applied in practice . in particular , there have been no approximation algorithms developed for admm lp decoding that are analogous to the relationship between the min - sum algorithm and the sum - product algorithm .",
    "such algorithms may substantially reduce computational complexity and hence are important directions of future work .",
    "furthermore , studying finite precision effects on admm lp decoding is another crucial direction to pursue , one that is very important to hardware implementation .",
    "the authors would like to thank vitaly skachek for useful discussions and references .",
    "the authors would also like to thank the associate editor , prof .",
    "roxana smarandache , and three anonymous reviewers for their comments and suggestions .",
    "in this section , we state the definitions and lemmas for the constant - weight embeddingthat are omitted in section  [ sec.embedding_and_spc ] .    [ def.valid_cw_embedding ] under the constant - weight embeddinglet @xmath316 and",
    "denote by @xmath317 the set of _ valid embedded matrices _ defined by check @xmath318 .",
    "an @xmath319 binary matrix @xmath320 if and only if it satisfies the following conditions :    1 .",
    "@xmath321 , where @xmath322 and @xmath323 .",
    "2 .   @xmath324 where @xmath182 .",
    "for any non - zero @xmath325 and @xmath326 $ ] , let @xmath327 , where @xmath328 denotes the @xmath329-th entry of the vector .",
    "let @xmath330 , then @xmath331\\ ] ] where the addition is in @xmath332 .",
    "note that condition @xmath132 is the same for both embeddings .",
    "this is due to two facts .",
    "first , @xmath333 .",
    "second , the constant - weight embeddingis indexed starting from @xmath44 ( cf . definition  [ def.constant_weight_embedding ] ) .",
    "thus , entries from definition  [ def.validembedding ] that participate in @xmath334 remain unchanged .",
    "[ lemma.valid_cw_codeword ] in @xmath0 , let @xmath335 be the set of codewords that correspond to check @xmath336 .",
    "then @xmath337 where @xmath317 is defined by definition  [ def.valid_cw_embedding ] .",
    "see appendix  [ proof.valid_codeword ] .",
    "[ def.cw_factor_graph_spc ] the conditions in definition  [ def.valid_cw_embedding ] can be represented using factor graphs . in this graph , there are three types of nodes : ( i ) _ variable nodes _ , ( ii ) _ parity - check nodes _ and ( iii ) _ one - on - check node_. each variable node corresponds to an entry @xmath338 for @xmath339 and @xmath340 .",
    "each parity - check node corresponds to a parity - check of the @xmath329-th bit where @xmath341 $ ] ; it connects all variable nodes in @xmath342 for all @xmath343 $ ] .",
    "each one - on - check node corresponds to a constraint @xmath324 .",
    "[ lemma.cw_equiv_integer_constraint ] consider the constant - weight embeddingand let @xmath344 be the set of @xmath345 binary matrices defined by the first two conditions of definition  [ def.valid_cw_embedding ] but with the third condition replaced by the condition @xmath346 defined below , then @xmath347 .",
    "the complete set of conditions are    1 .",
    "2 .   @xmath324 where @xmath182 .",
    "3 .   let @xmath348 be any nonempty subset of @xmath136 $ ] .",
    "for any non - zero @xmath325 , let @xmath349 , where @xmath350 denotes the @xmath329-th entry of the vector @xmath351 .",
    "let @xmath352 , then @xmath353 for all @xmath354 $ ] , @xmath355 , where the addition is in @xmath1 .",
    "see appendix  [ proof.equiv_integer_constraint ]    [ def.cw_code_polytopes ] let @xmath335 be a non - binary spc code defined by check vector @xmath318 . denote by @xmath222 the `` tight code polytope '' for the constant - weight embeddingwhere @xmath356    in @xmath0 denote by @xmath221 the `` relaxed code polytope '' for the constant - weight embeddingwhere a @xmath345 matrix @xmath357 if and only if the following constraints hold :    1 .",
    "@xmath358 $ ] .",
    "2 .   @xmath324 .",
    "3 .   let @xmath359 be the same set defined in lemma  [ lemma.cw_equiv_integer_constraint ] .",
    "let @xmath360 be a vector of length @xmath80 such that @xmath361 , then @xmath362 \\text { and } { { { \\mathcal}{k}}}\\neq \\emptyset\\ ] ]    [ def.cw_permutation ] let @xmath363 be a non - zero element in @xmath64 .",
    "let @xmath364 be a @xmath365 permutation matrix indexed starting from row @xmath44 and column @xmath44 , and satisfying the following equation @xmath366 where the multiplication @xmath367 is in @xmath64 .",
    "for a vector @xmath368 such that @xmath369 for all @xmath370 $ ] , let @xmath371    we note that lemma  [ lemma.general_rotation_equivalence ] , lemma  [ lemma.general_rotation_projection ] , lemma  [ lemma.rotation_equivalence ] and lemma  [ lemma.rotation_projection ] all hold for the constant - weight embeddingwhen @xmath372 is used .",
    "the proofs for the constant - weight embeddingcan be easily extended from the proofs for flanagan s embedding .",
    "first , @xmath373 because the @xmath329-th bit is fixed to @xmath45 . since dividing by a fixed @xmath363 only permutes the elements in finite fields , @xmath374 is also @xmath375 .",
    "we first prove that for a vector @xmath376 and its embedded matrix @xmath377 , @xmath378 if and only if @xmath379 for all @xmath16 and @xmath329 . for a fixed @xmath16 ,",
    "if @xmath379 , then @xmath380 by the definition of @xmath381 . note that the @xmath16-th column of @xmath377 , denoted by @xmath382 , is a vector such that @xmath383 and @xmath384 for all @xmath385 . hence @xmath386 .",
    "if @xmath387 , then @xmath388 .",
    "since @xmath384 for all @xmath385 , we get @xmath389 .    using this result",
    "we show @xmath390 implies @xmath391 . if @xmath390 , then there exists a vector @xmath392 such that @xmath393 . by the definition of @xmath394 , condition @xmath130 and @xmath131 per definition  [ def.validembedding ]",
    "are satisfied by @xmath377 . for condition @xmath132 , note that @xmath395 is a codeword .",
    "this implies that @xmath396 in @xmath0 .",
    "further , due to the fact that we are working in extension fields of @xmath307 , @xmath397 is an all - zero vector of length @xmath9 .",
    "this means that for all @xmath398 , @xmath399 .",
    "thus , @xmath400 .",
    "this implies that condition @xmath132 is satisfied .",
    "conversely , let @xmath391 . then by condition @xmath130 and @xmath131 , we know that there is a unique vector @xmath401 such that @xmath393 . by condition @xmath132 , we know that for any fixed @xmath329 , @xmath402",
    ". therefore , @xmath403 for all @xmath329 , where @xmath404 .",
    "this implies that @xmath395 is a valid codeword , or equivalently , @xmath392 and hence @xmath405 .",
    "this is a simple consequence due to the bijective relationship between the constant - weight embeddingand flanagan s embedding . formally , if a matrix @xmath406 , we construct @xmath377 by eliminating the first row of @xmath407 .",
    "then it is simple to verify that @xmath391 . by lemma  [ lemma.valid_codeword ]",
    ", @xmath377 is the embedding for some codeword @xmath395 .",
    "this shows that @xmath408 .",
    "conversely , for each codeword @xmath392 , we can reverse the process and find an @xmath407 that satisfies definition  [ def.valid_cw_embedding ] .",
    "we first show that @xmath409 if and only if @xmath410 .",
    "suppose @xmath410 , then there exists a unique @xmath15 such that @xmath411 and @xmath412 . since @xmath413 and condition @xmath131 holds , @xmath414",
    ". therefore @xmath415 . by the definition of @xmath416 , @xmath409 . on the other hand ,",
    "if @xmath417 , then @xmath418 .",
    "this implies @xmath419 .",
    "next , note that condition @xmath346 only adds more constraints to definition  [ def.validembedding ] .",
    "thus @xmath420 .",
    "conversely , using the same definition in the proof in appendix  [ proof.valid_codeword ] , @xmath399 .",
    "this means that for any subset @xmath348 , @xmath421 .",
    "in addition , @xmath422 using the result we just proved , we deduce that @xmath353 .",
    "this shows that @xmath423 . in other words",
    ", we have shown that any valid codeword @xmath392 satisfies condition @xmath346 in lemma  [ lemma.equiv_integer_constraint ] .",
    "it is easy to verify this lemma following the same logic in appendix  [ proof.valid_codeword ] .",
    "first consider all binary vectors of length @xmath424 that sum up to @xmath45 .",
    "the number of such vectors is @xmath425 .",
    "the number of binary vectors of length @xmath426 is @xmath427 .",
    "thus @xmath428 .",
    "we first introduce notation that we use in this proof .",
    "let `` @xmath429 '' denote the relationship of majorization .",
    "let @xmath430 and @xmath431 be length-@xmath432 vectors , then @xmath431 majorizes @xmath430 is written as @xmath433 .",
    "we refer readers to definition  1 in  @xcite for the definition of majorization .",
    "we use theorem  1 in  @xcite in this proof .",
    "let @xmath434 and consider the length-@xmath435 vector @xmath436 .",
    "first , we show @xmath437 .",
    "this immediately implies that all permutations of @xmath438 are in @xmath439",
    ". then we show @xmath440 . by theorem  1 in  @xcite",
    ", this implies that @xmath17 is in the convex hull of permutations of @xmath438 , each of which is in @xmath439",
    ". therefore @xmath441 .",
    "since @xmath434 , there exists a set @xmath442 of length-@xmath443 binary vectors with even parity such that @xmath444 for some @xmath445 and @xmath446 .",
    "let @xmath447 , then @xmath448 is a binary vector of length @xmath435 with even parity . also note that @xmath449 .",
    "this implies @xmath437 .    in order to show @xmath440",
    ", we need to consider partial sums based on the sorted vectors of @xmath17 and @xmath438 .",
    "let @xmath450 ( resp .",
    "@xmath451 ) be the set indicies of the @xmath329 largest entries in @xmath17 ( resp .",
    "@xmath438 ) .",
    "let the operator @xmath452 be defined as @xmath453 if @xmath454 . since all entries of @xmath17 and @xmath438 are non - negative , @xmath455 for all @xmath16",
    ". therefore @xmath456 , where the second inequality is because @xmath451 contains the largest @xmath329 entries of @xmath438 .",
    "in addition , @xmath457 . by the definition of majorization , these imply that @xmath440 .",
    "we first show that if @xmath458 then @xmath459 .",
    "let @xmath460 , @xmath461 , be vectors in @xmath462 , then @xmath463 where @xmath464 are vectors in @xmath465 .",
    "therefore @xmath466 .",
    "conversely , if @xmath467 , @xmath468 .",
    "let @xmath464 , @xmath469 , be vectors in @xmath465 , then @xmath470 where @xmath460 are vectors in @xmath462 . therefore @xmath471 .",
    "first , by lemma  [ lemma.general_rotation_equivalence ] , @xmath467 .",
    "therefore we need to show that there is no vector in @xmath63 that has a smaller euclidean distance to @xmath228 then does @xmath472 .",
    "suppose that there is a vector @xmath473 such that @xmath474 .",
    "then @xmath475 , where the second equality is due to the fact that @xmath476 is a permutation matrix .",
    "we then deduce that @xmath477 which contradicts with the fact that @xmath478 is the projection of @xmath479 onto @xmath480 .",
    "let @xmath481 , we need to show @xmath482 is in @xmath75 .",
    "let @xmath483 and @xmath484 be the matrix form for @xmath472 and @xmath485 respectively ( i.e. @xmath486 and @xmath487 ) .",
    "note that the rotations are done per embedded vector .",
    "in other words , columns of @xmath483 are permuted independently of each other . by the definition of the rotation matrix , for each column @xmath16 , @xmath488 where the multiplication is in @xmath0 . since @xmath481",
    ", @xmath484 satisfies definition  [ def.relaxed_code_polytope ] for check @xmath489 .",
    "we first verify that @xmath483 satisfies conditions @xmath130 and @xmath131 in definition  [ def.relaxed_code_polytope ] .",
    "note that these two conditions are defined on a column - wise basis .",
    "thus these two conditions are invariant to column - wise permutations . for condition @xmath132 , note that @xmath359 can be obtained by @xmath121 as follows : @xmath490 then , @xmath491 if @xmath492 , provided that @xmath493 .",
    "let @xmath494 be the sub - vector constructed by selecting entries @xmath338 where @xmath495 . combining and",
    ", we deduce that for fixed @xmath16 , @xmath348 and @xmath496 , if @xmath497 is in the vector @xmath498 , then @xmath499 is in the vector @xmath500 and @xmath501 .",
    "this shows that @xmath502 is not changed under rotation .",
    "therefore @xmath472 satisfies condition @xmath132 .",
    "this implies that @xmath503 .",
    "conversely , let @xmath503 , we need to show @xmath504 is in @xmath125 . note that @xmath476 is a permutation matrix and therefore @xmath505 . as in the previous case",
    ", the columns of @xmath483 and @xmath484 are permuted independently . therefore condition @xmath130 and @xmath131 hold for @xmath484 .",
    "we now verify condition @xmath132 .",
    "first , permutation using @xmath506 implies that @xmath501 for all @xmath507 .",
    "second , @xmath121 can be obtained by @xmath359 as follows : @xmath508 thus , for fixed @xmath16 , @xmath348 and @xmath496 , if entry @xmath499 is contained in the vector @xmath500 , then entry @xmath497 is contained in the vector @xmath498 and @xmath501 .",
    "therefore the vector @xmath360 remains unchanged , which implies that condition @xmath132 is satisfied by @xmath484 .      using lemma  [ lemma.rotation_equivalence ] , we can follow exactly the same logic as in the proof of lemma  [ lemma.rotation_equivalence ] .",
    "the details are omitted .",
    "we first prove several lemmas that will be useful for proving the theorem .",
    "[ lemma.mapping_lemma_between_two_embeddings ] for any @xmath509 , @xmath510 .    if @xmath511 , @xmath512 and @xmath513 . if @xmath514 , @xmath515 and @xmath516 .",
    "[ lemma.equiv_convex_hull ] let @xmath335 be the spc code defined by check @xmath318 .",
    "if @xmath517 then @xmath518 where @xmath519 for all @xmath520 .",
    "conversely , if @xmath521 for some @xmath522 , then @xmath523    let @xmath524 , @xmath525 be all codewords in @xmath335 .",
    "let @xmath526 , then there exists a set of coefficients @xmath527 , @xmath525 , satisfying @xmath528 such that @xmath529 .",
    "then , @xmath530 for all @xmath15 . on the other hand , @xmath531 by the definition of convex hull .",
    "using lemma  [ lemma.mapping_lemma_between_two_embeddings ] , @xmath532 thus we conclude @xmath533 .",
    "conversely , if @xmath534 , then there exists a set of coefficients @xmath527 , @xmath525 , satisfying @xmath528 such that @xmath535 . by definition , @xmath536 .",
    "similar to the previous case , it is easy to verify using lemma  [ lemma.mapping_lemma_between_two_embeddings ] that @xmath537 .",
    "[ lemma.equiv_feasibility ] if @xmath538 is feasible for * lp - ft * , then @xmath539 is feasible for * lp - ct*. conversely , if @xmath540 is feasible to * lp - ct * , then @xmath538 is feasible fow * lp - ft*.    for ldpc codes , check @xmath98 selects a sub - vector @xmath541 from @xmath542 ( or @xmath543 from @xmath544 ) that participates in that check",
    ". therefore we apply lemma  [ lemma.equiv_convex_hull ] to each sub - vector of @xmath542 ( and of @xmath544 ) .",
    "in addition , @xmath542 ( or @xmath544 ) is feasible if and only if @xmath545 ( @xmath546 ) for all @xmath98 , where @xmath547 is the spc code defined by the @xmath16-th check .",
    "therefore we conclude that the lemma holds .",
    "[ lemma.equiv_obj ] let @xmath65 , @xmath538 be a vector with non - negative entries and such that @xmath548 .",
    "further , let @xmath539",
    ". then @xmath549).\\ ] ]    for simplicity , we index entries in @xmath542 starting from @xmath44 . by definitions of @xmath542 and @xmath544",
    ", we have @xmath550 and @xmath551 note that @xmath552 for all @xmath553 and @xmath554 $ ] .",
    "then    now we state the proof of theorem  [ theorem.equiv_lp ] :    by lemma  [ lemma.equiv_feasibility ] , @xmath555 is feasible for *",
    "lp - ct*if and only if @xmath538 is feasible for * lp - ft*. by lemma  [ lemma.equiv_obj ] , we can subtract a constant , @xmath556)$ ] , from the objective function of * lp - ct*to obtain the same objective function as * lp - ft*.    we now prove the theorem by contradiction .",
    "suppose @xmath544 is the solutionof * lp - ct * , but @xmath544 is not the solutionof * lp - ft*. then there exists a feasible point @xmath557 that attains a lower cost than @xmath542 .",
    "using lemma  [ lemma.equiv_feasibility ] , we can construct a feasible point for * lp - ct*that attains a fewer cost than @xmath544 .",
    "this contradicts with the assumption that @xmath544 is the solutionof * lp - ct*. similar arguments also hold for the converse statement .",
    "we first restate lemma  [ lemma.equiv_convex_hull ] and lemma  [ lemma.equiv_feasibility ] for the constant - weight embedding :    [ lemma.equiv_relaxed_code_polytope ] let @xmath75 ( resp .",
    "@xmath221 ) be the relaxed code polytope for flanagan s embedding(resp .",
    "the constant - weight embedding ) for check @xmath318 .",
    "if @xmath558 , then @xmath559 where @xmath519 for all @xmath520 .",
    "conversely , if @xmath560 for some @xmath522 , then @xmath561 .    for any value of @xmath562 $ ]",
    ", @xmath563 does not participate in the condition @xmath132 in definition  [ def.cw_code_polytopes ] .",
    "thus @xmath542 satisfies condition @xmath132 in definition  [ def.relaxed_code_polytope ] if and only if @xmath544 satisfies condition @xmath132 in definition  [ def.cw_code_polytopes ] .",
    "further , it is easy to verify that @xmath542 satisfies condition @xmath130 and @xmath131 in definition  [ def.relaxed_code_polytope ] if and only if @xmath544 satisfies condition @xmath130 and @xmath131 in definition  [ def.cw_code_polytopes ] .",
    "[ lemma.equiv_feasibility_relaxed_polytope ] if @xmath538 is feasible for * lp - fr * , then @xmath539 is feasible for * lp - cr*. conversely , if @xmath540 is feasible to * lp - cr * , then @xmath538 is feasible to * lp - fr*.    the proof is the same as for lemma  [ lemma.equiv_feasibility ] except it is based on lemma  [ lemma.equiv_relaxed_code_polytope ]",
    ".    we can prove theorem  [ theorem.equiv_lp_relax ] using lemma  [ lemma.equiv_obj ] and lemma  [ lemma.equiv_feasibility_relaxed_polytope ] .",
    "the logic is the same as that for theorem  [ theorem.equiv_lp ] .",
    "* lp - fr*has the same embedding and objective as * lp - ft*. thus we can follow the same proof as in  ( * ? ? ?",
    "the only difference is in the constraint set .",
    "thus we only need to prove that the `` relative matrix '' ( defined below ) to the all - zeros matrix satisfies the constraint set in * lp - fr*. the rest of the proof is identical to that in  @xcite .",
    "the following definition rephrases eq .",
    "( 19 ) in  @xcite .",
    "[ def.relative ] let @xmath335 be a spc code defined by a length-@xmath4 check @xmath318 .",
    "let @xmath377 and @xmath564 be @xmath565 matrices .",
    "we say that @xmath564 is the `` relative matrix '' for @xmath377 based on a codeword @xmath566 if @xmath567 where the sums are in @xmath0 .",
    "( note that in @xmath0 , @xmath568 means @xmath569 . ) denote this mapping @xmath570 .",
    "note that this is a bijective mapping .",
    "its inverse is given by @xmath571 denote by @xmath572 this inverse mapping .",
    "[ lemma.relative ] let @xmath395 be a valid spc for length-@xmath4 check @xmath318 .",
    "then @xmath573 if and only if @xmath574 .",
    "* we first show that if @xmath573 , then @xmath574 .",
    "in other words , we need to verify that @xmath575 satisfies all three conditions in definition  [ def.relaxed_code_polytope ] .",
    "the first two conditions are obvious .",
    "we focus on the third condition .",
    "let @xmath348 be a non - empty subset of @xmath136 $ ] and let @xmath16 be an integer in @xmath576 $ ] .",
    "let @xmath577 be the set defined in lemma  [ lemma.equiv_integer_constraint ] for the @xmath16-th check entry @xmath578 .",
    "there are two cases : ( i ) @xmath579 and ( ii ) @xmath580 .",
    "+ if @xmath579 then for all @xmath581 , @xmath582\\\\ & = 1 + 0 = 1,\\end{aligned}\\ ] ] where the second equality follows because that the addition in @xmath0 is equivalent to the vector addition of the corresponding binary vectors .",
    "the third equality follows because @xmath581 and @xmath579 .",
    "similarly , for all @xmath583 , @xmath584 .",
    "thus @xmath585 if and only if @xmath581 . + in addition , since @xmath579 , we find that @xmath586 for all @xmath581 .",
    "then , by definition  [ def.relative ] , @xmath587 .",
    "let @xmath588 and @xmath589 , then @xmath590 where the second equality follows because @xmath585 if and only if @xmath411 .",
    "therefore we conclude that @xmath591 .",
    "+ for case ( ii ) , @xmath592 .",
    "using the same argument as above , we can show that @xmath585 if and only if @xmath583 . therefore @xmath593 combining the two cases , we conclude that the vector @xmath594 satisfies the following conditions : @xmath595 we can rephrase this condition by introducing the following notation : let @xmath596 . let @xmath597 be a binary vector for @xmath348 and @xmath395 defined by @xmath598 . by lemma  [ lemma.equiv_integer_constraint ] , @xmath597 is a binary vector with even parity . by its definition , @xmath599 if and only if @xmath415 . thus we can rewrite   as @xmath600 these conditions satisfy the definition of `` relative solution '' defined in  @xcite . when applying lemma  17 in  @xcite to the case of binary single parity - check code , we conclude that @xmath601 if @xmath602 .",
    "this conclude our verification of the third condition of definition  [ def.relaxed_code_polytope ] .",
    "* next we need to show that if @xmath603 , then @xmath604 .",
    "note that in  , @xmath605 is equivalent to @xmath606 for @xmath0",
    ". therefore the proof is identical to the previous case .",
    "we need to prove @xmath607 = \\pr[{\\mathrm{error}}|{{\\boldsymbol}{c}}]$ ] , where @xmath395 is any non - zero codeword .",
    "let @xmath608 then @xmath609 = \\sum_{y\\in { { \\mathcal}{b}}(c)}\\pr[{{\\boldsymbol}{y}}|{{\\boldsymbol}{c}}]$ ] .",
    "we first rephrase the symmetry condition of  @xcite .",
    "this definition introduces a one - to - one mapping from the received vector @xmath73 to a vector @xmath610 such that the following two statements hold :    1 .",
    "@xmath611 = \\pr[{{\\boldsymbol}{y}}^0|{{\\boldsymbol}{0}}]$ ] , 2 .",
    "@xmath612 if and only if @xmath613 .",
    "statement @xmath130 is directly implied by the definition of the symmetry condition .",
    "we show in the following that statement @xmath131 is also true .",
    "once we have both results , @xmath614 & = \\sum_{{{\\boldsymbol}{y}}\\in { { \\mathcal}{b}}({{\\boldsymbol}{c}})}\\pr[{{\\boldsymbol}{y}}|{{\\boldsymbol}{c}}]\\\\ & = \\sum_{{{\\boldsymbol}{y}}^0\\in { { \\mathcal}{b}}({{\\boldsymbol}{0}})}\\pr[{{\\boldsymbol}{y}}^0|{{\\boldsymbol}{c } } ] = \\pr[{\\mathrm{error}}|{{\\boldsymbol}{0}}].\\end{aligned}\\ ] ]      a symmetry condition for rings is defined in  @xcite .",
    "we now rephrase that definition for fields .",
    "( symmetry condition ) for @xmath615 , there exists a bijection @xmath616 such that the channel output probability conditioned on the channel input satisfies @xmath617 for all @xmath618 , @xmath619 .",
    "in addition , @xmath620 is isometric in the sense of  @xcite .",
    "we define the concept of relative matrices for the constant - weight embedding .",
    "let @xmath621 and let @xmath17 be a vector of length @xmath622 .",
    "we say that @xmath177 is the `` relative vector '' for @xmath17 based on @xmath58 if @xmath623 where the sum is in @xmath0 .",
    "this mapping is denoted by @xmath624 .",
    "its inverse is given by @xmath625 denote by @xmath626 this inverse mapping .",
    "we reuse this notation in the context of non - binary vectors and let @xmath627 .",
    "let @xmath407 and @xmath628 be @xmath629 matrices .",
    "we say that @xmath628 is the `` relative matrix '' of @xmath407 based on @xmath395 if for all @xmath16 @xmath630 where the sum is in @xmath0 .",
    "this mapping is denoted by @xmath631 .",
    "its inverse is given by @xmath632 denote by @xmath626 this inverse mapping .",
    "finally , we note that for any vector @xmath252 of length @xmath633 , we can think of this vector as @xmath634 .",
    "then we let @xmath635 where @xmath636 and @xmath637 .",
    "[ lemma.linearity_and_distance ] the relative operation is linear . that is , @xmath638 further , the relative operator is norm preserving .",
    "that is , @xmath639 .",
    "linearity is easy to verify .",
    "we note that @xmath640 permutes the input vector based on @xmath58 , and therefore the norm is preserved .",
    "[ lemma.y_relative ] let @xmath641",
    ". then @xmath642 .    for all @xmath643 , @xmath644 .",
    "therefore @xmath645 this means that @xmath646 satisfying the definition of relative vector in  .",
    "therefore @xmath647 .",
    "[ lemma.relative_code_polytope ] let @xmath395 be a valid spc codeword for length-@xmath4 check @xmath318 .",
    "then @xmath648 if and only if @xmath649 .",
    "we can use the same logic in the proof of lemma  [ lemma.relative ] .",
    "thus we omit the details .    [",
    "lemma.projection_preserving ] suppose a convex set @xmath650 is such that @xmath651 if and only if @xmath652 for some @xmath58 , then @xmath653 .",
    "our proof is by contradiction .",
    "suppose that the projection of @xmath654 onto @xmath650 is @xmath655",
    ". then @xmath656 and @xmath657 .",
    "due to lemma  [ lemma.linearity_and_distance ] , we have @xmath658 this contradicts the fact that @xmath659 is the projection of @xmath228 onto @xmath650 .",
    "[ lemma.quiviter ] in algorithm  [ algorithm.penalized_decoder ] , let @xmath660 , @xmath661 and @xmath662 be the vectors after the @xmath663-th iteration when decoding @xmath73 .",
    "let @xmath664 , @xmath665 and @xmath666 be the vectors after the @xmath663-th iteration when decoding @xmath610 . if @xmath667 , @xmath668 and @xmath669 then @xmath670 , @xmath671 and @xmath672 .",
    "we drop the iterate @xmath673 for simplicity and denote by @xmath674 , @xmath675 and @xmath676 the updated vectors at the @xmath677-th iteration .",
    "let @xmath678 , @xmath679 and @xmath680 . also let @xmath681 be the log - likelihood ratio for the received vector @xmath610 . from algorithm  [ algorithm.penalized_decoder ] , by lemma  [ lemma.y_relative ] , @xmath682 .",
    "then   can be rewritten as @xmath683\\\\ & = { \\pi}_{{\\mathbb{s}}_q'}[{\\mathsf{r}'}_{c_i } ( { { \\boldsymbol}{u}})],\\end{aligned}\\ ] ] @xmath684\\\\ & = { \\pi}_{{\\mathbb{s}}_q'}[{\\mathsf{r}'}_{c_i } ( { { \\boldsymbol}{u}})],\\end{aligned}\\ ] ] where @xmath685 by lemma  [ lemma.projection_preserving ] , @xmath686    let @xmath687 and @xmath688 , then @xmath689 .",
    "in addition , @xmath690 and @xmath691 . by lemma  [ lemma.projection_preserving ] , @xmath692 .",
    "it remains to verify one more equality : @xmath693    [ lemma.equaldecoding ] let @xmath694 be the output of the decoder if @xmath73 is received and @xmath695",
    ". then @xmath696 .",
    "we note that we initialize algorithm  [ algorithm.penalized_decoder ] so that the conditions in lemma  [ lemma.quiviter ] are satisfied . by induction",
    ", we always obtain relative vectors at each iteration .",
    "it is easy to verify that both decoding processes stop at the same iteration .",
    "therefore @xmath696 .",
    "due to lemma  [ lemma.equaldecoding ] , if the decoder recovers a codeword @xmath395 from @xmath73 , it means that the decoded vector @xmath17 is the embedding of @xmath395 in the sense of definition  [ def.constant_weight_embedding ] .",
    "therefore by  , @xmath697 is the embedding of @xmath698 in the sense of definition  [ def.constant_weight_embedding ] .",
    "this means that the decoder can recover @xmath698 from @xmath610 .",
    "one the other hand , if the decoder fails to recover codeword @xmath395 from @xmath73 , then @xmath697 is not a integral vector .",
    "this means that the decoder can not recover @xmath698 from @xmath610 . combining both arguments",
    ", we deduce that the decoder can recover @xmath395 from @xmath73 if and only if it can recover @xmath698 from @xmath610 , which completes the proof .",
    "first note that @xmath699 , therefore @xmath700 as a result , @xmath701 let @xmath702 .",
    "then @xmath703 we first prove the following lemma that is useful in studying the structure of @xmath704 .",
    "[ lemma.binarysum ] for an integer @xmath705 , let @xmath706\\text { and } { { \\mathcal}{k}}\\neq \\emptyset\\}$ ] .",
    "let @xmath707 be arbitrary binary vectors of length @xmath432 that are not equal to @xmath698",
    ". then    1 .",
    "the number of sets @xmath708 such that @xmath709 in @xmath332 is @xmath710 .",
    "2 .   if @xmath711 , the number of sets @xmath708 such that @xmath712 and @xmath709 in @xmath332 is @xmath713 .",
    "we prove both parts of the lemma using inductions .",
    "1 .   proof by induction : when @xmath714 , the statement holds .",
    "assume that the statement holds for @xmath715 .",
    "denote by @xmath716 ( resp .",
    "@xmath717 ) the set of @xmath718 such that @xmath719 ( resp .",
    "@xmath720 ) .",
    "this implies @xmath721 when @xmath722 , we need to consider binary vectors of length @xmath723 .",
    "we use @xmath228 to denote the first @xmath496 bits of the vector .",
    "let @xmath724 be the @xmath723-th bit of the vector . if @xmath725 , then @xmath726 contains the following sets : ( a ) all sets @xmath727 and ( b ) all sets @xmath728 where @xmath727 .",
    "therefore @xmath729 . since @xmath730 is the complement of @xmath731 , @xmath732 .",
    "if @xmath733 , then @xmath734 contains the following sets : ( a ) all sets @xmath727 and ( b ) all sets @xmath728 where @xmath735 . therefore , we get the same result , i.e. @xmath736 combining the two cases , we conclude that @xmath737 which completes the proof .",
    "2 .   proof by induction . when @xmath714 , the statement holds .",
    "assume that the statement holds for @xmath738 .",
    "denote by @xmath739 ( resp .",
    "@xmath740 , @xmath741 , @xmath742 ) the set of @xmath718 such that @xmath743 and @xmath719 ( the resp .",
    "sums equal to @xmath744 , @xmath745 and @xmath746 ) .",
    "note all these sets have @xmath747 elements .",
    "similar to the previous proof , we add one more bit to both @xmath472 and @xmath228 . depending on the combination of these two bits ( @xmath748 , @xmath744 , @xmath745 or @xmath746 ) , the four sets @xmath749 , @xmath750 , @xmath751 and @xmath752 all double in size .",
    "thus the four new sets all have @xmath753 elements .",
    "we now describe the structure of @xmath704 .",
    "[ lemma.rmatrix ] @xmath704 is block diagonal matrix , denoted by @xmath754 where @xmath755    the matrices @xmath133 are in a one - to - one relation with the set @xmath756 . since @xmath757 , @xmath758 , where @xmath759 is the indicator function .",
    "in other words , @xmath760 is the number of sets @xmath761 such that @xmath762 .",
    "similarly , for all @xmath763 , @xmath764 . by lemma  [ lemma.binarysum ] we conclude that @xmath765 and @xmath766 for all @xmath767 .",
    "note that @xmath126 is also a block diagonal matrix . therefore @xmath768",
    "@xmath769    [ lemma.useless_d ] let @xmath770 be an @xmath771 permutation matrix .",
    "let @xmath704 be an @xmath771 matrix whose entries are @xmath772 for all @xmath773 $ ] and some constant @xmath198 , @xmath774 for all @xmath773 $ ] , @xmath775 $ ] and @xmath763 , and some constant @xmath199 .",
    "then , @xmath776 .    without loss of generality ,",
    "let @xmath777 and @xmath778 .",
    "let @xmath779 .",
    "we need to prove that @xmath780 for all @xmath15 and that @xmath781 for all @xmath763 .",
    "let @xmath782 , then @xmath783 .",
    "therefore @xmath784 . since @xmath770 is a permutation matrix ,",
    "there is one @xmath45 in the @xmath16-th column . without loss of generality",
    ". then @xmath786 .",
    "further , @xmath787 . if @xmath788 , then there exists a @xmath789 such that @xmath790 . thus @xmath791 .",
    "if @xmath792 , note that @xmath793 and @xmath794 for all @xmath795 . therefore @xmath796 .    by lemma  [ lemma.useless_d ]",
    "we conclude that @xmath797 for all @xmath126 . as a result , @xmath798 where @xmath124 is the variable degree , i.e , @xmath799 .",
    "then , @xmath800 since @xmath801 and its entries only have two values , we can calculate its inverse explicitly .",
    "we do this next in lemma  [ lemma.invertzplusi ] .",
    "[ lemma.invertzplusi ]",
    "let @xmath704 be a @xmath802 block diagonal matrix denoted by @xmath803 , where each @xmath804 is the same @xmath805 matrix in",
    ". then @xmath806 and @xmath807 where @xmath808 , @xmath809(r - s)}$ ] , @xmath810 and @xmath811 .",
    "it is easy to verify that the product of the two matrices is the identity matrix .    to summarize",
    ", @xmath812 can be obtained by calculating each block multiplication due to the fact that @xmath813 is a block diagonal matrix .",
    "for each block we first calculate @xmath814 , where @xmath196 is the @xmath15-th block of vector @xmath815 .",
    "we then calculate @xmath816 .",
    "this algorithm for @xmath88-update has complexity @xmath817 .",
    "[ lemma.gf4_valid_embeddings ] in @xmath10 , @xmath377 is a valid embedded matrix for the all - ones check if and only if @xmath377 satisfies the first two conditions of definition  [ def.validembedding ] and the rows of @xmath377 have either all odd parity * or * all even parity .",
    "let @xmath818 be the set of binary matrices satisfying conditions in this lemma .",
    "first , we show @xmath819 implies @xmath391 , where @xmath465 is defined in definition  [ def.validembedding ] . since the field under consideration is @xmath10 , @xmath377 has three rows .",
    "denote by @xmath820 the @xmath15-th row of @xmath377",
    ". then @xmath821 and @xmath822 .",
    "if @xmath823 , @xmath824 if @xmath825 , then @xmath826 by the definition of @xmath818 , which means that the overall sum is @xmath44 in @xmath1 .",
    "if both the sums have even parity , then the overall sum is also @xmath44 .",
    "it is easy to verify that the same situation holds for @xmath827 .",
    "thus @xmath391 .",
    "now we show that @xmath391 implies @xmath819 .",
    "let @xmath828 .",
    "we need to show that if @xmath829 has odd ( even ) parities , @xmath830 and @xmath831 must also have odd ( even ) parities .",
    "this can be proved by contradiction .",
    "suppose @xmath829 has odd parity and @xmath830 ( or @xmath831 ) has even parity , then @xmath832 ( or @xmath833 ) does not have even parity , contradicting the assumption that @xmath391 .",
    "similarly , if @xmath829 has even parity , the other two rows must both have even parity .    in @xmath10 , considering the all - ones check ,",
    "the characteristics of the polytope in definition  [ def.relaxed_code_polytope ] can be simplified to the following :    [ def.gf4_polytope ] denote by @xmath834 the relaxed code polytope for @xmath10 for the all - ones checks .",
    "a @xmath835 matrix @xmath836 if the following constraints hold :    1 .   @xmath358 $ ] .",
    "2 .   @xmath837 .",
    "3 .   let @xmath66 be the @xmath15-th row of @xmath377 .",
    "let @xmath832 , @xmath833 and @xmath838",
    ". then @xmath839 , @xmath840 and @xmath841 .",
    "let @xmath465 be defined by lemma  [ lemma.equiv_integer_constraint ] for @xmath10 and by the all - ones check of length @xmath4 .",
    "let @xmath834 be defined by definition  [ def.gf4_polytope ]",
    ". then @xmath842 .",
    "we validated this result numerically using the following approach .",
    "we randomly generated @xmath843 vectors of length @xmath4 where the entries of each vector are i.i.d .",
    "uniformly distributed in @xmath844 $ ] .",
    "we then projected these vectors onto both @xmath834 and @xmath845 using cvx ( cf .",
    "what we observed is that the projections onto these two polytopes are the same for every vector .",
    "therefore we believe that the conjecture should hold .",
    "however , a proof of the conjecture remains open .",
    "in qpsk , the coded symbols are @xmath846 . we use vectors @xmath745 , @xmath744 , @xmath847 and @xmath848 to represent the modulated signals .",
    "let @xmath17 be the modulated vector of length @xmath849 , where @xmath46 is the block length .",
    "then the received signal is @xmath850 . where @xmath851 is i.i.d .",
    "gaussian of variance @xmath852 .",
    "let @xmath853 be the noise spectrum density .",
    "the noise is equivalent to have variance of @xmath854 per dimension .",
    "let @xmath855 be the symbol rate and fix @xmath856 .",
    "let @xmath857 be the ( non - db ) value for @xmath263 , then @xmath858 suppose we use the length-@xmath859 code in @xcite .",
    "] defined in  @xcite which has rate @xmath860 .",
    "then @xmath861db translates into @xmath862 .",
    "x.  zhang and p.  h. siegel , `` efficient iterative lp decoding of ldpc codes with alternating direction method of multipliers , '' in _ ieee int .",
    "inf . theory ( isit ) _ ,",
    "istanbul , turkey , july 2013 , pp .",
    "15011505 .",
    "j.  duchi , s.  shalev - shwartz , y.  singer , and t.  chandra , `` efficient projections onto the @xmath36-ball for learning in high dimensions , '' in _ proc .",
    "int . conf . on machine learning ( icml )",
    "_ , helsinki , finland , july 2008 , pp . 272279 .",
    "s.  boyd , n.  parikh , e.  chu , b.  peleato , and j.  eckstein , `` distributed optimization and statistical learning via the alternating direction method of multipliers , '' _ foundations and trends in machine learning _",
    ", vol .  3 , no .  1 ,",
    "1122 , july 2011 ."
  ],
  "abstract_text": [
    "<S> in this paper , we develop efficient decoders for non - binary low - density parity - check ( ldpc ) codes using the alternating direction method of multipliers ( admm ) . </S>",
    "<S> we apply admm to two decoding problems . </S>",
    "<S> the first problem is linear programming ( lp ) decoding . in order to develop an efficient algorithm , </S>",
    "<S> we focus on non - binary codes in fields of characteristic two . </S>",
    "<S> this allows us to transform each constraint in @xmath0 to a set of constraints in @xmath1 that has a factor graph representation . </S>",
    "<S> applying admm to the lp decoding problem results in two types of non - trivial sub - routines . </S>",
    "<S> the first type requires us to solve an unconstrained quadratic program . </S>",
    "<S> we solve this problem efficiently by leveraging new results obtained from studying the above factor graphs . </S>",
    "<S> the second type requires euclidean projection onto polytopes that are studied in the literature , a projection that can be solved efficiently using off - the - shelf techniques , which scale linearly in the dimension of the vector to project . </S>",
    "<S> admm lp decoding scales linearly with block length , linearly with check degree , and quadratically with field size . </S>",
    "<S> the second problem we consider is a penalized lp decoding problem . </S>",
    "<S> this problem is obtained by incorporating a penalty term into the lp decoding objective . </S>",
    "<S> the purpose of the penalty term is to make non - integer solutions ( pseudocodewords ) more expensive and hence to improve decoding performance . </S>",
    "<S> the admm algorithm for the penalized lp problem requires euclidean projection onto a polytope formed by embedding the constraints specified by the non - binary single parity - check code , which can be solved by applying the admm technique to the resulting quadratic program . </S>",
    "<S> empirically , this decoder achieves a much reduced error rate than lp decoding at low signal - to - noise ratios . </S>"
  ]
}