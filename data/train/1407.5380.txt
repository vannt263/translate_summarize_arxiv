{
  "article_text": [
    "strategic reasoning has been a major research theme in game theory",
    ". however , `` much of game theory is about the question whether strategic equilibria exist '' , as johan van benthem points out ,  _ but there are hardly any explicit languages for defining , comparing , or combining strategies  _ @xcite .",
    "the intrinsic difficulty of modelling strategic reasoning is that reasoning about strategies is not purely deductive but combines temporal reasoning , counterfactual reasoning , reasoning about actions and preferences , and multi - agent interaction .",
    "if any logic is used , such a logic must be able to support these reasoning mechanisms .    in recent years a number of specific logical formalisms have been proposed for specifying strategic behaviour of agents in multi - agent systems  @xcite .",
    "these frameworks offer modelling facilities and inference mechanisms for specifying strategy reasoning in multi - agent systems . at the same time , the conceptually simple , general _ game description language _ ( gdl ) has been developed as a practical language for encoding the rules of arbitrary games so that they can be understood by general game - playing systems , whose task is to learn to play unknown games without human intervention @xcite .    in this paper",
    ", we explore the middle ground between pure game specification languages like gdl on the one hand , and existing expressive formalisms for strategic reasoning on the other hand .",
    "our main contributions can be summarised as follows :    1 .",
    "we show how a simple extension of gdl using a standard modality for linear time suffices to describe strategies in addition to the mere rules of a game , and we present a specific semantics by which formulas in this language can be understood as move recommendations for a player .",
    "we enrich our language by two _ preference _ operators , respectively called prioritised disjunction and prioritised conjunction , and show how to use them to describe strategies that are complete ( i.e. , provide a move recommendation in every state ) and deterministic ( i.e. , move recommendations are always unique ) .",
    "we demonstrate two example methods of implementation : a formalisation of the semantic interpretation of our language in the situation calculus @xcite and a translation of a subset of our language into answer set programming @xcite .",
    "these results are accompanied by a thorough mathematical analysis of the language and its semantics , in particular with regard to our novel preference operators .",
    "the advantage of our framework is to allow for concise but complete representations of games and strategic behaviour of agents so that the approach promises to be practically useful for the design of game - playing agents .",
    "we will use a simple game scenario as a running example to explain the basic concepts and to demonstrate how our language can be used to write strategies for game - playing agents .",
    "our results lay the foundations for a variety of applications of automated reasoning about strategies in ai systems , including the following :    * a general game player can be fed not only with the mere rules of a new game but also with declarative descriptions of tailor - made strategies . *",
    "general game players can use a high - level , declarative representation of their strategies as the basis for learning , maintaining , and reasoning about them . *",
    "players can also use the language and its inference mechanism to represent , revise and reason with their beliefs about their opponents strategies .    the remainder of the paper proceeds as follows . in section  [",
    "se : stg ] we will begin our technical exposition with the definition of a simple state transition semantics for games . in section  [ s : strategies ] , we will then define the semantic concept of a strategy within this framework , and in section  [ s : representation ] we will develop a formal game specification language based on gdl for describing both game rules and strategies in a concise manner . in section  [ s :",
    "combining ] , we will introduce the two preference connectives and show how to use these to combine strategies into more complex ones . in section",
    "[ se : reasoning ] , we demonstrate how to verify if a strategy could bring out an expected outcome with the model - based approach . in section  [",
    "s : computing ] , we will encode the semantic interpretation of our language in conjunction with game rules and strategy rules in the situation calculus and also illustrate how the reasoning problem can be solved with answer set programming .",
    "we conclude with a discussion of related work .",
    "to set the stage for our work , we first define formally a general state transition model for games .",
    "[ de : statetransitiongame ] a _ state transition game _",
    "@xmath0 is a tuple @xmath1 @xmath2 , where    1 .",
    "@xmath3 is a non - empty finite set of players ; 2 .",
    "@xmath4 is a non - empty set of states ( possible worlds ) ; 3 .",
    "@xmath5 , where @xmath6 is a non - empty finite set of _ actions _ for player ; 4 .",
    "@xmath7 , representing the _ initial _ state ; 5 .",
    "@xmath8 is a binary _ legality _ relation , describing what actions are allowed in which states ; 6 .",
    "@xmath9 is an _ update _ function , specifying the state transitions ; 7 .",
    "@xmath10 is a _ goal _ function , specifying the winning states of each agent ; 8 .",
    "@xmath11 , representing the _ terminal _ states .    to keep our formalism as simple as possible , we assume that all actions are performed asynchronously , each by a single player ( although games need not be turn - taking ) .",
    "we also assume that different agents have different actions , that is , @xmath12 for any @xmath13 , but of course two actions may have the same effects .",
    "a sequence @xmath14 is called a _ complete path _ if    1 .",
    "@xmath15 , @xmath16 , and @xmath17 for all @xmath18 ; 2 .",
    "@xmath19 for all @xmath20 ; 3 .",
    "@xmath21 for all @xmath20 ; and 4 .",
    "@xmath22 for all @xmath20 .",
    "any segment @xmath23 , where @xmath24 , of a complete path is called a _",
    "reachable path_. we let @xmath25 denote all reachable paths in a state transition game  @xmath0 .",
    "note that a single state without action can be a reachable path ( i.e. , where @xmath26 ) .",
    "we call such a singleton path @xmath27 a _",
    "reachable state_.    a state - action pair @xmath28 is called a _ reachable legal move _ ( or simply _ a move _ ) in @xmath0 if there is a @xmath29 such that @xmath30 is a reachable path .",
    "the set of all such moves in @xmath0 is denoted by @xmath31 .",
    "more formally , @xmath32 furthermore , the moves for player @xmath33 are denoted by @xmath34 : @xmath35 for convenience , we let @xmath36    to facilitate the presentation of our framework , we will use as our running example a simple two - player game , which we call _ crossdot _ game .    *",
    "( crossdot game )  * [ ex : boxdot1 ] two players take turns in placing either a cross `` @xmath37 '' ( player  1 ) or a dot `` @xmath38 '' ( player  2 ) into an empty box in a line of @xmath39 , where @xmath40 : @xmath41 each box can contain at most one object .",
    "the first player to successfully fill @xmath42 ( @xmath43 ) consecutive boxes will end and win the game , where @xmath42 is arbitrary but fixed .",
    "if all boxes have been filled without a winner , the game ends with a tie .",
    "we assume that the `` @xmath37''-player goes first .",
    "to describe the scenario in terms of the state transition game , let @xmath44 be the players and @xmath45 the set of possible states , where @xmath46 specify whose turn it is ( @xmath47 if it is player @xmath33 s turn ; otherwise @xmath48 ) and @xmath49 indicate the status of the boxes .",
    "the initial state is @xmath50 .",
    "we write @xmath51 to denote the action of player @xmath33 marking the @xmath52th box .",
    "let @xmath53 .",
    "we refrain from explicitly listing the legality relation , the update function , and the terminal and goal states for the players as this is possible but considerably lengthy even for a very simple game like this ; the syntactic _ axiomatision _ of this game given in the following section will be much more concise and practical .",
    "let us just pick some random examples : for and @xmath54 , the state @xmath55 is a terminal state and also a goal state for player 1 . under our assumption that player  1 takes the first move ,",
    "the state - action pair @xmath56 , say , satisfies the legality relation , whereas @xmath57 does not because it is not player  2 s turn at this stage . as an example of the update function we have @xmath58 .    for future reference , by @xmath59",
    "we denote the instance of our game that consists of @xmath39 boxes and has winning length @xmath42 . @xmath60",
    "in a multi - agent game environment , agents strive to achieve their goals . how individual agents act is determined by their _ strategies _ : at a state of a game , the strategies that the agent applies determine which actions the agent will take . for example , a strategy of a player in the game of chess reflects which moves the player would play in certain positions that can be reached according to the standard chess rules . in terms of the state transition game ,",
    "a strategy of a player can be defined as a relation between game states and ( legal ) actions the player will perform .    [ de : strategy ] a _ strategy _",
    "@xmath61 of player @xmath33 is a subset of @xmath62 such that @xmath63 .",
    "intuitively , a strategy of a player specifies which actions the player should take in which states . note that our concept of strategy is significantly different from the ones in the context of alternating - time temporal logic ( atl )  @xcite . in atl ,",
    "a strategy is a function that maps each state ( or a sequence of states ) to an action . in other words ,",
    "a strategy specifies which action has to do exactly in each state or each history of states .",
    "however , our concept of strategy can express a `` rough idea '' of what to do .",
    "a strategy may suggest no action , one action or several actions to do in each state .",
    "a player might apply several strategies in one game .",
    "a single strategy does not necessarily determine the moves for all possible legal positions of a game .",
    "in the later sections , we will further develop a technology to combine and refine strategies in order to generate a strategy with desirable properties .",
    "we say that a strategy @xmath61 is _ valid _ if @xmath64 . a strategy @xmath61 of player  @xmath33 is _ complete _ if for each reachable state @xmath27 , there is a move @xmath65 unless @xmath66 .",
    "in other words , a complete strategy provides the player with a `` complete '' guideline that always provides the player with one or more suggestions how to act when it is his move . a strategy",
    "@xmath61 is _ deterministic _ if for any @xmath67 and @xmath68 , we have @xmath69 . a strategy is _ functional _ if it is complete and deterministic .",
    "an agent with a functional strategy knows precisely what to do in any reachable game state .",
    "for instance , if an agent  @xmath70 has a default action @xmath71 that is always legal in any reachable state , then the following simple strategy for this player is complete and deterministic , hence functional : @xmath72    [ ex : boxdot2]consider an instance , @xmath73 , of the crossdot game .",
    "the following is an example of strategies for player  1 that intuitively says _",
    "`` fill a box next to one you have marked before '' _ : @xmath74 it is easy to see that the strategy is valid but neither complete nor deterministic .",
    "the above example shows that directly representing a strategy in a state transition game requires to list every move that complies with the strategy . in the following ,",
    "we develop a syntactical representation that allows to describe a strategy much more concisely .",
    "we first present a logic - based , general game description language with linear time .    consider a propositional modal language @xmath75 with these components :    * a non - empty finite set @xmath76 of propositional variables ; * a non - empty finite set @xmath3 of agent symbols ; * a non - empty finite set @xmath6 of action symbols for each @xmath70 ; * propositional connectives @xmath77 , @xmath78 , @xmath79 , @xmath80 and @xmath81 ; and @xmath78 are treated as primitives . ]",
    "* pseudo - function symbols @xmath82 , @xmath83 , and @xmath84 ; * modal operator @xmath85 ; * special propositional symbols @xmath86 and @xmath87 .    formulas in @xmath75 are defined as follows : @xmath88 where @xmath89 , @xmath70 and @xmath90 . + note that we overload @xmath3 and @xmath6 as they occur in both syntax and semantics .",
    "they can be distinguished from the context . as in definition",
    "[ de : statetransitiongame ] , we assume that @xmath91 if @xmath13 .",
    "we call @xmath92 , @xmath93 and @xmath94 pseudo - functions because formally each instance @xmath95 , @xmath96 or @xmath97 is taken to be an individual propositional symbol .",
    "this language is a direct adaptation of the general _ game description language _",
    "@xcite and allows to describe games in a compact way . +    [ ex : crossdot3 ]   we use the propositional symbols @xmath98 to represent the fact that box @xmath52 is filled with @xmath33 s marker , where @xmath99 and @xmath100 .",
    "in addition , we use two specific propositional symbols @xmath101 and @xmath102 to represent players turns , respectively . putting all the propositional symbols together , we have @xmath103 . with this",
    ", we are able to describe the game rules in our logical language .",
    "to begin with , the following rules specify the initial game state : @xmath104 the following statement defines the winning conditions : _",
    "player @xmath33 wins if there is @xmath52 such that @xmath105 and @xmath106 , _",
    "i.e. @xmath107 with this , the condition for termination is : @xmath108 as before , let @xmath51 denote the action of player @xmath33 filling box @xmath52 .",
    "legality of the actions of each player @xmath33 can be described thus : @xmath109 the effects of the actions are given by @xmath110 let @xmath111 be the set of axioms ( [ eq:2])([eq:12 ] ) .",
    "@xmath60 +    in the following , we interpret the language based on the state transition model",
    ". give a state transition game @xmath112 ( see definition  [ de : statetransitiongame ] ) , a _ valuation function _",
    "@xmath113 specifies which atom propositions are true at each state .",
    "propositional formulas and their truth values can be defined accordingly .",
    "[ de : linearmodel ] let @xmath112 be a state transition game and @xmath114 a valuation function .",
    "we call the pair @xmath115 a _ state transition model_. let @xmath116 be a reachable path in @xmath0 and @xmath117 a formula .",
    "we say that @xmath118 _ satisfies _",
    "@xmath117 under @xmath119 ( written @xmath120 ) according to the following definition :    ===@xmath121 iff @xmath122 ( @xmath123 ) + @xmath124 iff @xmath125 + @xmath126 iff @xmath127 + @xmath128 iff @xmath129 + @xmath130 iff @xmath131 + @xmath132 iff @xmath133 + @xmath134 iff @xmath135 + @xmath136 iff @xmath137 and @xmath138 + @xmath139 iff @xmath140    it is worth clarifying that in the limit case @xmath141 ( i.e. , @xmath142 ) we have that @xmath124 and @xmath143 hold for any @xmath144 and @xmath117 .",
    "a formula @xmath117 is _ valid _ in model @xmath119 , denoted @xmath145 , if it is satisfied by any reachable path in the game , that is , @xmath146 for all @xmath147 .",
    "let @xmath148 be a set of sentences in @xmath75 , then @xmath119 is a _ model _ of @xmath148 if @xmath145 for all @xmath149 .",
    "+    [ ob : first ] consider the crossdot game @xmath150 introduced in example  [ ex : boxdot1 ] .",
    "let @xmath114 be a valuation function such that for each state @xmath151 , @xmath152 .",
    "let @xmath115 .",
    "then @xmath119 is a model of @xmath111 ( see equations ( [ eq:2])([eq:12 ] ) )",
    ".     given any reachable path @xmath153 , we only have to verify that each axiom in @xmath111 is satisfied by @xmath118 in @xmath119 .",
    "this is straightforward .",
    "consider for instance the proof that @xmath154 for any @xmath70 and @xmath155 : if @xmath156 , this holds trivially because @xmath157 . if @xmath158 , then @xmath126 and by the definition of @xmath114 , @xmath159 , hence @xmath160 for any @xmath70 and @xmath155 .",
    "the other axioms can be verified similarly .",
    "+ in order to develop a syntactical representation for strategies , we introduce the following specific concepts .",
    "let @xmath161 .",
    "we call @xmath118 a _ reachable path starting with the move @xmath162_. the set of all the reachable paths in game @xmath0 that starts with @xmath163 is denoted by @xmath164 . given a state transition model @xmath115 , for any move @xmath165 ,",
    "a formula @xmath117 is _ valid under move ( @xmath166 ) _ , denoted by @xmath167 , if @xmath146 for all reachable path @xmath168 .",
    "[ ex : boxdot3]consider the same instance of the crossdot game @xmath73 as in example  [ ex : boxdot2 ] .",
    "let @xmath119 be the state transition model defined in observation  [ ob : first ] for the case @xmath169 and @xmath54 .",
    "assume that @xmath170 .",
    "it is easy to verify the following :    = @xmath171 + @xmath172 + @xmath173 + @xmath174    @xmath60      we now turn to the syntactical representation of strategies using the language introduced above . for any state transition model and formula @xmath175 ,",
    "let @xmath176 in other words , @xmath177 comprises all moves for player @xmath33 under which @xmath117 is valid .",
    "[ de : strategysemantics ] given a state transition model @xmath119 , let @xmath61 be a strategy of player @xmath33 according to definition  [ de : strategy ] .",
    "a formula @xmath117 in @xmath75 is a _ representation _ of @xmath61 iff @xmath178 .    in the following",
    ", we will call `` strategy '' both a set of moves ( i.e. , a strategy in the sense of definition  [ de : strategy ] ) and its representation ( using  @xmath75 )",
    ". they should be easy to distinguish from the context .",
    "note that a formula @xmath179 can represent different strategies for different players .",
    "for instance , the tautology @xmath180 can be a strategy of player @xmath33 , i.e. , @xmath181 , that allows the player to take any reachable moves at any reachable state .",
    "another example is @xmath182 , where @xmath183 .",
    "if representing a strategy of player  @xmath33 , it means to take @xmath184 only at any reachable state .",
    "however , if representing a strategy of other players rather than @xmath33 , it means to do nothing .    while the language we consider in this paper is propositional and finite , a state transition game can have infinitely many worlds which can not be distinguished by the propositions that hold in them",
    "a strategy that assigns different actions to two indistinguishable worlds can not be described in our language .",
    "however , every strategy that is _ markovian _ in the following sense does have a representation in @xmath75 .",
    "given a state transition model @xmath115 , a strategy @xmath61 is _ markovian _ if for all @xmath185 and @xmath186 such that @xmath187 , @xmath188 .",
    "[ pr : markovian ] given a state transition model @xmath115 of @xmath75 , any markovian strategy @xmath61 of a player has a representation in @xmath75 .    for each @xmath67 ,",
    "since the set @xmath76 of propositional variables is finite , @xmath189 and @xmath190 are both finite .",
    "thus the following is a well - formed propositional formula : @xmath191    again @xmath192 being finite implies the set @xmath193 to be finite even though @xmath61 may be infinite . therefore the following is also a well - formed propositional formula : @xmath194}\\ ] ] now we show @xmath117 is a representation of @xmath61 . obviously , for any @xmath67 , @xmath195 . for",
    "any @xmath196 , where @xmath33 is the player under consideration , assume that @xmath195 . by the construction of @xmath117 ,",
    "there is a move @xmath197 such that @xmath198 it turns out that @xmath199 .",
    "since @xmath61 is markovian , we have @xmath68 .",
    "note that @xmath200 implies @xmath69 by definition  [ de : linearmodel ] . we then have @xmath67 , as desired .",
    "+ note that markovian strategies are history - independent .",
    "if we want to specify strategies in which move choices depend on the history of a game , then we need to extend our language with syntactic means to talk about past states .",
    "this can be done by adding the inverse of the operator @xmath85 , written @xmath201 , to denote that some property holds in `` _ the previous state _ '' .",
    "we leave this extension for future work .",
    "the reader is reminded that formulas in our language have been endowed with two different semantics .",
    "if it is used to represent a property , it has a truth value as normal propositional formula .",
    "if a formula is used to represent a strategy , then it no longer has a truth value but represents a set of moves for a player .",
    "+ the following observation shows how our language can be used to describe a useful strategy for our running example .",
    "compared to its semantical representation ( cf .",
    "example  [ ex : boxdot2 ] ) , the syntactical expression of the strategy is much more compact and meaningful .",
    "strategy @xmath202 from example  [ ex : boxdot2 ] is represented by @xmath203    first we show @xmath204 .",
    "this can be done by verifying @xmath167 one by one for each @xmath205 .",
    "for instance , consider @xmath206 and @xmath207 . then @xmath208 and @xmath209 .",
    "thus @xmath167 .",
    "in order to show that @xmath210 , we can prove that for each reachable move @xmath28 of player 1 , @xmath211 implies @xmath212 .",
    "this can be done by enumerating all reachable moves in @xmath213 .",
    "for instance , let @xmath214 and @xmath215 . obviously , @xmath162 is a reachable move and @xmath216 . to show @xmath217 ,",
    "consider the reachable path @xmath218 , where @xmath219 .",
    "it is easy to verify that @xmath220 while @xmath221 for any @xmath222 .",
    "thus we have @xmath223 .",
    "we then yield that @xmath217 .",
    "other cases can be verified similarly .",
    "+ the above observation shows that we can still use our logical sense to design a strategy despite the significant differences of semantics between a propositional formula and a strategy representation .",
    "when doing so it is important to keep it in mind that a propositional formula bears a very different meaning when understood as a strategy rather than a state description . in the following",
    "we demonstrate the speciality of strategy representation with a few examples based on the crossdot game @xmath224 .    1 .",
    "_ one formula can represent different strategies for different players : _ + @xmath225 + @xmath226 + in other words , if @xmath227 represents a strategy of player 1 , it means that player 1 is to fill the first box with his marker if the box is currently empty or to fill any other empty box if the box has already been filled with a cross whenever it is his turn .",
    "however , if the formula @xmath227 represents a strategy of player 2 , it means player 2 wishes the first box to be filled by player 1 . in this case",
    ", he waits for the states to come and then do whatever is feasible to him .",
    "2 .   _ forcing another player into a particular action : _ + @xmath228 + in general , a player does not have control on the other player s actions . but a player may be able to create a situation in which the opponent has no choice other than the desired action . in the above example , player 1 is enforcing a situation in which player 2 has no other option but to perform @xmath229 when it becomes his turn .",
    "3 .   _ thinking forward : _",
    "+ @xmath230 + this is a strategy for player 2 to try to find an action so that `` _ he can fill box  1 in his next turn as long as player 1 will not fill it beforehand . _ '' note that @xmath231 because he can do nothing to guarantee that @xmath232 is doable in his next turn .",
    "4 .   _ try anything to win the game within one step : _",
    "+ @xmath233 + this is a simple strategy for player 1 that aims to try any available action to win the game in one step .",
    "we have seen from the above examples that even though a strategy rule is written in the syntax of ( temporal ) propositional formulas , its semantics is significantly different from propositional logic therefore we must be very cautious when we start to use the language to design game strategies .    to complete this section ,",
    "we present a property of our strategy representation for later use .",
    "[ le : propertiesofsofphi ] given a state transition model @xmath119 , for each player  @xmath33 ,    1 .",
    "@xmath234 2 .",
    "@xmath235    to prove ( 1 ) , assume that @xmath236 .",
    "it follows that @xmath237 and @xmath238 .",
    "then for each reachable path @xmath168 , we have @xmath239 , which implies @xmath240 and @xmath241 .",
    "it turns out that @xmath242 and @xmath243 .",
    "we get @xmath244 and @xmath245 .",
    "the other direction is similar .    to prove ( 2 ) , assume that @xmath246 . without loss of generality ,",
    "suppose that @xmath244 , which implies @xmath237 and @xmath242 .",
    "hence , @xmath240 for each reachable path @xmath168 .",
    "it follows that @xmath247 .",
    "thus we yield @xmath248 . given that @xmath237 ,",
    "we conclude @xmath249 .",
    "as mentioned in the introduction , the main motivation of this work is to introduce a formal logical language for defining , comparing and combining strategies .",
    "we have provided our formal definition of strategies in both syntactical and semantical levels in the previous sections . to facilitate the composition of strategies , in this section",
    "we extend our language by two specific connectives , called _ prioritised disjunction _ and _ prioritised conjunction _ , respectively .",
    "the idea behind these two new connectives is the following .",
    "the prioritised disjunction `` @xmath250 '' extends the choice of actions such that if a first strategy fails to apply then a second one offers more options , and if that fails too then a third strategy may offer more options still , and so on .",
    "conversely , the prioritised conjunction `` @xmath251 '' narrows down the choice of actions : if a first strategy allows too many options , then a second strategy may be used to constrain these options , a third strategy may narrow down the options even further , and so on  up to the point where the next strategy in line would lead to empty option .",
    "[ de : strategyrule ] the set of _ strategy rules _ is the smallest set such that    1 .   a formula in @xmath75 is a strategy rule ; 2 .",
    "if @xmath252 are strategy rules , then so is @xmath253 ; 3 .",
    "if @xmath254 are strategy rules , then so is @xmath255@xmath256@xmath257@xmath258@xmath256@xmath259 .",
    "note that the new strategy connectives are introduced as macros rather than as additional connectives in the language @xmath75 .",
    "this is so because we do not want to allow the nesting of the strategy connectives with logical connectives ( while nested strategy rules are allowed ) .",
    "for instance , @xmath260 is a syntactically correct strategy rule while @xmath261 is not .      given a strategy @xmath61 , we let @xmath61@xmath262 , i.e. , the set of all the moves at state @xmath263 specified by @xmath61 .    [ de : strategyinterpretation ] let @xmath264 be a strategy rule .",
    "we define @xmath265 recursively on the structure of @xmath264 as follows :    1 .   if @xmath266 , then @xmath267 .",
    "if @xmath268 , then @xmath269 iff there exists @xmath42 ( 1@xmath270 ) such that @xmath271 3 .",
    "if @xmath272@xmath256@xmath257@xmath273@xmath259 , then @xmath269 iff there exists @xmath42 ( 1@xmath270 ) such that 1 .",
    "@xmath274 and 2 .",
    "@xmath275 or @xmath276 .    intuitively , @xmath277 represents a strategy that combines strategies @xmath278 in such a way that a strategy rule @xmath279 becomes applicable only if none of the higher prioritised rules @xmath280 is applicable .",
    "@xmath255@xmath256@xmath257@xmath256@xmath281@xmath256@xmath259 tries to apply as many strategy rules all together as possible but gives higher priority to the left rules than the right rules if conflicts occur .",
    "the following observations show that the connective @xmath250 is indeed a kind of prioritised disjunction and the connective @xmath256 is indeed a kind of prioritised conjunction .    given a state transition model @xmath119 , for each player @xmath33 ,    1 .",
    "@xmath282 2 .",
    "@xmath283 3 .   if @xmath284 , then @xmath285 .",
    "4 .   if @xmath286 , then @xmath287 . 5 .",
    "@xmath288 6 .",
    "@xmath289 7 .",
    "@xmath290 8 .",
    "@xmath291    the proof of ( 1)-(4 ) is straightforward from definition  [ de : strategyinterpretation ] .    to show ( 5 ) , let @xmath292 . if @xmath293 , then by definition  [ de : strategyinterpretation ] , @xmath294 . by lemma",
    "[ le : propertiesofsofphi ] ( 1 ) , this implies @xmath244a contradiction .",
    "hence , @xmath244 .",
    "we have proved @xmath295 .",
    "the other direction follows ( 1 ) .    to show ( 6 ) , let @xmath296 .",
    "suppose that @xmath297 , then by definition  [ de : strategyinterpretation ] , we have @xmath245 , as desired . if , on the other hand , @xmath294 , then by lemma  [ le : propertiesofsofphi ] ( 1 ) we also have @xmath245 .    to show ( 7 ) , assume that @xmath244 . by lemma  [ le : propertiesofsofphi ]",
    "( 2 ) , @xmath249 .",
    "hence , @xmath244@xmath298@xmath299 , which implies @xmath300 .",
    "the other direction follows ( 2 ) .    to show ( 8) ,",
    "assume that @xmath245 .",
    "by lemma  [ le : propertiesofsofphi ] ( 2 ) , @xmath249 .",
    "it follows that @xmath249@xmath301@xmath302 . by definition  [ de : strategyinterpretation ] , we have @xmath303 .",
    "+ note that in the above lemma , only one direction of inclusion in items ( 6 ) and ( 8) holds .",
    "the other direction does not .",
    "for instance , assume that @xmath304 and @xmath305 .",
    "then @xmath306 .",
    "it turns out that @xmath307 .",
    "this shows that @xmath308 . furthermore ,",
    "if @xmath304 and @xmath309 . by lemma  [ le : propertiesofsofphi ]",
    ", we have @xmath249 .",
    "thus @xmath310 , which means that the other direction of item ( 8) does not hold .",
    "the following lemma shows that the prioritised disjunction can be reduced to binary connectives .",
    "interestingly , the prioritised conjunction does not have such a nice property .",
    "given a state transition model @xmath119 , for each player @xmath33 , @xmath311    we will prove the first equation , the other one will be quite similar .",
    "we consider two cases .",
    "if @xmath312@xmath313 then @xmath314    on the other hand , if @xmath312@xmath315 then @xmath316    we remark that the prioritised conjunction can not likewise be reduced to binary connectives . in general",
    "neither @xmath317@xmath256@xmath318@xmath319@xmath273@xmath320@xmath321@xmath322 nor @xmath317@xmath256@xmath318@xmath323@xmath256(@xmath324@xmath325@xmath321@xmath326 is true .",
    "for example , let @xmath327 ; @xmath286 ; and @xmath328",
    ". then @xmath317@xmath256@xmath329@xmath256@xmath330 .",
    "but @xmath331@xmath256@xmath257)@xmath256@xmath332@xmath256@xmath333 .",
    "on the other hand , if @xmath334 and @xmath312 and @xmath335 are as before , then we get @xmath317@xmath256@xmath257@xmath256@xmath336 while @xmath317@xmath256@xmath337@xmath256@xmath338 .    as a remedy",
    ", we may define a prioritised conjunction by the prioritised disjunction as follows : @xmath339 then we extend it to the multi - argument version in the following way : @xmath340 unfortunately the semantics of @xmath341 coincides with @xmath256 in the binary version but not in the multi - argument version .",
    "we will investigate this alternative in our future work .",
    "when we build a software game player , we need to instruct it what to do in each possible situation .",
    "in other words , each player should be equipped with a functional strategy . in the following ,",
    "we demonstrate how to generate a complete and/or deterministic strategy by using our prioritised connectives .",
    "we say that a strategy rule is _ consistent _ for player @xmath33 if it represents a valid strategy ; a rule is _ complete _ for  @xmath33 if it represents a complete strategy for  @xmath33 ; and _ deterministic _ for  @xmath33 if it represents a deterministic strategy for  @xmath33 .",
    "similarly , a strategy rule is _ functional _ if it is complete and deterministic .",
    "note that all these concepts are player - specific .",
    "the following theorems show a number of nice properties of the prioritised connectives , which give us a guideline for how to design a strategy with desired properties . the first result deals with consistency of strategy rules .",
    "given a state transition model @xmath119 ,    1 .",
    "@xmath342 is consistent if and only if there is a @xmath42 ( 1@xmath270 ) such that @xmath279 is consistent .",
    "@xmath255@xmath343@xmath259 is consistent if and only if @xmath255 is consistent .",
    "to prove ( 1 ) , let @xmath344 .",
    "assume that @xmath265 is non - empty for player @xmath33 , then there is @xmath269 such that @xmath345 for some @xmath42 , which means that @xmath279 is consistent for player @xmath33 .",
    "conversely , let @xmath42 be the smallest number such that @xmath346 is non - empty .",
    "this implies that @xmath347 . by the above two lemmas we have @xmath348 , which means that @xmath264 is consistent .    to prove ( 2 )",
    ", we also let @xmath349@xmath343@xmath259 .",
    "obviously if @xmath255 is inconsistent , so is @xmath264 .",
    "assume that @xmath255 is consistent .",
    "then there is @xmath350 .",
    "let @xmath42 be the biggest number such that @xmath351 .",
    "obviously @xmath352 .",
    "by definition  [ de : strategyinterpretation ] we have @xmath353 .",
    "thus @xmath264 is consistent .",
    "+ the second result shows us how to generate a complete or deterministic strategy .",
    "[ pr : pdisjunction ] given a state transition model @xmath119 , for each player @xmath33    1 .",
    "if @xmath255 or @xmath257 is complete , so is @xmath354 .",
    "if @xmath255 is complete , so is @xmath255@xmath343@xmath259 .",
    "if @xmath255 and @xmath257 are deterministic , so is @xmath354 .",
    "4 .   if @xmath255 is deterministic , so is @xmath255@xmath343@xmath259 .",
    "\\(1 ) and ( 4 ) are straightforward from definition  ( [ de : strategyinterpretation ] ) .    to show ( 2 ) , assume that @xmath255@xmath343@xmath259 is incomplete .",
    "then there exists a reachable state @xmath27 such that @xmath317@xmath343@xmath322@xmath355 . by definition  [ de : strategyinterpretation ] , this can happen only if @xmath312@xmath355 , which contradicts the assumption that @xmath255 is complete .    to prove ( 3 ) ,",
    "assume that @xmath356 .",
    "if @xmath312@xmath357 , we have @xmath358 according to definition  [ de : strategyinterpretation ] .",
    "since @xmath255 is deterministic , this implies @xmath69 . on the other hand , if @xmath312@xmath355 , then we have @xmath359@xmath302 , which also implies @xmath69 since @xmath257 is deterministic .     + statement",
    "( 1 ) in the above theorem provides us with an easy way of generating a complete strategy : _ create a trivial complete strategy first and then combine it with other strategies using the prioritised disjunction_. note that creating a trivial complete strategy is rather easy : _ let the agent do anything available_. statement ( 2 ) tells us that once we get a complete strategy , we can further refine the strategy targeting more specific properties , say deterministic thus functional , using the prioritised conjunction without losing its completeness .",
    "statement ( 3 ) shows us another feasible way of generating a functional strategy : instead of creating a complete strategy then refine it into a deterministic one , we can _ devise a set of specific deterministic strategies first and then combine them with the prioritised disjunction targeting a complete strategy_. example [ ex : boxdot5 ] demonstrates how the above mentioned approaches can be applied to the crossdot game . before doing that , let s show another nice property of the prioritised connectives .",
    "[ pr : connectiveproperties1 ] given a state transition model @xmath119 , for each player @xmath33    1 .   if @xmath255 is complete , then @xmath360 .",
    "if @xmath255 is deterministic , then @xmath317@xmath343@xmath361 .    to prove ( 1 )",
    ", we only have to show @xmath362 .",
    "assume that @xmath363 . because @xmath255 is complete , @xmath312@xmath357 .",
    "by definition  [ de : strategyinterpretation ] we have @xmath350 .",
    "to show ( 2 ) , we need to show that @xmath364@xmath343@xmath322 . if @xmath350 , then @xmath312@xmath365 since @xmath255 is deterministic . by definition  [ de : strategyinterpretation ]",
    "it follows that @xmath366@xmath343@xmath322 .",
    "+ combining the two statements of this theorem , we can say that if @xmath255 is functional , then @xmath367@xmath368@xmath317@xmath343@xmath322 @xmath368@xmath312 .",
    "this means that once a strategy is functional , neither extending nor refining it with strategies of lower priority has any effect .",
    "in fact , our goal of introducing the prioritised connectives is to facilitate the design of functional strategies .",
    "once a functional strategy has been obtained , these connectives automatically stop working .",
    "[ ex : boxdot5]consider the crossdot game scenario in example 1 .",
    "we define a few strategy rules for player  @xmath33 as follows :    * fill a box next to a box that contains player @xmath33 s mark : @xmath369 * fill an isolated box ( i.e. , whose immediate neighbours are empty ) : @xmath370 * fill any empty box : @xmath371 * try @xmath372 first .",
    "if this fails , try @xmath373 , then try @xmath374 :",
    "@xmath375    let @xmath115 be the state transition model defined in observation [ ob : first ] . the strategy rule @xmath376 is complete for player @xmath33 .",
    "we first prove that the strategy @xmath374 is complete .",
    "assume an arbitrary reachable state @xmath377 such that @xmath378 ( recall formula  ( [ eq : lw ] ) for the definition of  @xmath379 and the definition of completeness of a strategy in section  [ subse : propertiesofstrategies ] ) .",
    "let @xmath380 .",
    "it follows that @xmath381 . by  ( [ eq:8 ] )",
    ", we know that @xmath382 , hence @xmath383 , which implies @xmath384 . therefore @xmath374 is a complete strategy rule for player @xmath33 . according to theorem  [ pr : pdisjunction ] ( 1 ) , we know that the strategy rule @xmath376 is also complete .",
    "+ a complete strategy for a player gives the player a feasible option ( if any ) for any given situation .",
    "however , a software game player could still be unsure about what to do under a complete strategy if there is more than one option in the same situation .",
    "the prioritised conjunction provides us with a way to narrow down multiple options .",
    "[ ex : ccc ] for our running example game , let @xmath385 where @xmath386 ( with @xmath39 being the overall number of boxes as usual ) , then @xmath387 represents the strategy of @xmath33 to place an object in any box between @xmath388 and a given number @xmath389",
    ". let @xmath390 where @xmath376 is the strategy rule defined in example  [ ex : boxdot5 ] ( cf .",
    "( [ eq : combined ] ) ) .",
    "it is not hard to see that if @xmath376 gives more than one boxes to fill , @xmath391 will choose the left most one .",
    "let @xmath115 be the state transition model defined in observation [ ob : first ] .",
    "the strategy rule @xmath392 is functional for player @xmath33 .    by theorem  [ pr : pdisjunction ]",
    "( 2 ) , @xmath392 is complete because @xmath376 is complete .",
    "we prove that @xmath392 is deterministic .",
    "assume that @xmath393 such that , without loss of generality , @xmath394 .",
    "let @xmath389 be the smallest number ( between @xmath388 and @xmath39 ) such that @xmath395@xmath302@xmath396@xmath302 is not empty .",
    "such a @xmath389 exists because @xmath397@xmath302@xmath398@xmath399 . by definition  [ de : strategyinterpretation ] , we have @xmath400 and @xmath401 , hence @xmath402@xmath302 . hence @xmath403 .",
    "if @xmath404 , then @xmath405",
    ". otherwise , i.e.  if @xmath406 , then @xmath397@xmath407@xmath355 , which implies that neither @xmath408 nor @xmath409 belongs to @xmath410@xmath302 .",
    "note that @xmath410@xmath411 .",
    "thus @xmath412 . by the above assumption",
    ", we have @xmath413 .",
    "we have proved that @xmath392 is deterministic , thus it is functional .",
    "+ to summarise , the prioritised connectives provide a natural way of refining a strategy . if a strategy is too restricted in that it can only be applied to few states , it can be extended using prioritised disjunction .",
    "if , on the other hand , a strategy is too generic in that it leaves too many options , it can be strengthened using prioritised conjunction .",
    "once a strategy has been functional , further extension or refinement using the prioritised disjunction or conjunction take no effect as long as give the existing strategy the highest priority .",
    "knowing how to write strategies for a game - playing agent , we now consider the question whether a strategy meets its goal , for instance , if it is guaranteed to lead to a winning state or to a desirable state given the strategies that the other players use . in this section",
    ", we will demonstrate by using our running example how to reason about strategies within our framework .",
    "we also demonstrate how to design a strategy using the prioritised connectives to meet desired properties .      in order to verify whether a strategy can bring about an expected result for a player in a game",
    ", we assume that the player complies with the strategy all the way through the game and observes the outcome of the game .",
    "let @xmath115 be a state transition model of a game @xmath0 and @xmath61 a strategy of the game for player @xmath33 .",
    "we say that @xmath119 ( or @xmath0 ) _ complies with @xmath61 by player _",
    "@xmath33 if for each reachable move @xmath28 of player @xmath33 in @xmath0 , @xmath67 .",
    "in other words , player @xmath33 follows the strategy @xmath61 whenever he makes a move . and a strategy @xmath61 of player @xmath33 in @xmath119 , let @xmath414 be another state transition model that is exactly the same as @xmath119 except for the legality of actions for player @xmath33 in such a way that the legality relation @xmath415 in @xmath414 is @xmath416 , where @xmath417 is the legality relation in @xmath119 .",
    "we then view @xmath414 as the reduction of @xmath119 once player @xmath33 complies with strategy @xmath61 . ]",
    "the following observation shows that for any crossdot game when @xmath54 and @xmath418 , player 1 wins as long as he plays the strategy @xmath392 all the way through the game .",
    "let @xmath119 be a state transition model for the crossdot game with @xmath54 and @xmath418 .",
    "assume that player @xmath33 takes the first turn .",
    "if @xmath119 complies with the strategy @xmath419 by player @xmath33 , then @xmath420 in other words , player @xmath33 wins as long as he takes the first turn and follows the strategy rule @xmath392 .    without loss of generality , we assume that @xmath421 .",
    "we have to show that @xmath422 for any reachable path @xmath118 . since the definitions of @xmath87 and @xmath94 do not contain @xmath92 , @xmath93 and @xmath85 ( cf",
    ".  formulas  ( [ eq:3 ] ) & ( [ eq:4 ] ) ) , we only need to show for any reachable terminal state @xmath423 ( which is a special case of a reachable path ) @xmath424 . to this end , we assume a complete path @xmath425 , where @xmath15 and @xmath426 .",
    "since player @xmath388 has the first turn and plays with strategy @xmath427 , the action the player takes in the initial state must be @xmath428 , i.e. , @xmath429 .",
    "if player 2 responds with action @xmath229 , i.e. , @xmath430 , player 1 will then take action @xmath431 and win the game at state @xmath432 .",
    "if player 2 responds with any other action , player 1 will take @xmath433 and also will win the game . in any case , @xmath118 ends up with @xmath434 in which player 1 wins .",
    "therefore @xmath424 .",
    "we conclude @xmath435 .     + the strategy @xmath436 seems like a `` smart '' strategy that can guarantee a winning state for the player who takes the first turn when @xmath54",
    ". however it is less mighty when taken by the second player , in which case the strategy can not even compete the following `` trivial '' strategy @xmath437 where @xmath438 was defined in example  [ ex : ccc ] .",
    "[ ob : secondlost ] let @xmath119 be a state transition model for a crossdot game with @xmath54 and @xmath418 . if @xmath119 complies with @xmath439 by player 1 and with @xmath440 by player 2 , then @xmath441     it is not hard to prove that @xmath442 is functional .",
    "since @xmath443 is also functional , there is only one complete path in the game : @xmath444@xmath445 which implies that player 1 takes the left most box , followed by player 2 fills an isolated box and finally player 1 fills the second box and wins .",
    "we can easily verify that @xmath446 is valid with any segment of the path in @xmath119 .",
    "+ the failure of @xmath436 is not because it is not `` smart '' enough but because the @xmath443 strategy requires to fill an isolated box at the first move , which provides the first player with a chance to win .",
    "the examples of strategies we have shown up to now are all from a single player s viewpoint , which is obviously not sufficient .",
    "we should also reason about other players strategies .",
    "from observation  [ ob : secondlost ] we learnt that a player should check for existing threats before applying any `` aggressive '' strategy , like @xmath436 .",
    "the following formula defines a _ defence _ strategy , which says that if my opponent can win by filling box  @xmath52 at next step , then i should mark it now to prevent an immediate loss : @xmath447 where @xmath448 stands for the opponent of @xmath33 .",
    "note that @xmath449 is neither deterministic nor complete . to create a functional strategy with defence , we let @xmath450 obviously , @xmath451 is deterministic .",
    "since @xmath392 is functional , therefore @xmath452 is functional .",
    "the following observation shows that if the second player plays @xmath453 , which means to protect himself before attacking his opponent , then player  1 can not win with the @xmath454 strategy ( cf . equation ( [ eq : fillleft ] ) ) .",
    "[ ob : secondwin ] let @xmath119 be a state transition model for the crossdot game with @xmath54 and @xmath418 . if @xmath119 complies with @xmath439 by player 1 and with @xmath455 by player 2 , then @xmath456    since both players strategies are functional , there is only one complete path in the game .",
    "assume that the complete path is @xmath153 .",
    "the first action taken by player 1 must be @xmath457 .",
    "the first two states in the path is then @xmath458    to know which action player 2 chooses at state @xmath459 , we calculate @xmath460@xmath461 . in fact , we will show that @xmath462@xmath463 .",
    "assume any reachable path @xmath464 .",
    "we verify @xmath465 this is obviously true because if @xmath466 , then @xmath467 is satisfied . for any @xmath468 , @xmath469 is false .    next we show that for any @xmath470 , @xmath471@xmath461 .",
    "let @xmath472 .",
    "it is easy to verify that @xmath473 it follows that @xmath474 note that @xmath475 .",
    "therefore we have @xmath476 which implies @xmath471@xmath461 .",
    "this completes the proof that @xmath477 hence , for the complete path @xmath118 we find that @xmath478 and @xmath479 .",
    "the game continues in the same way until all boxes are filled without a winner .",
    "+ the instances of the crossdot game we considered above are limited to the simple case where @xmath54 . in the following",
    ", we proposed a solution to the game in the general setting where @xmath42 can be any number larger than @xmath480 ( and @xmath481 ) .",
    "consider the following strategies :    * fill a box next to an opponent s box : @xmath482 note that priority is given to the left empty box if exists .",
    "* passive defence : @xmath483 note that we use prioritised conjunction , instead of disjunction , to combine @xmath484 and @xmath485 .",
    "this is because @xmath484 gives arbitrary actions whenever there is no immediate loss for player @xmath33 , in which case @xmath485 takes over .",
    "the following observation shows that such a passive defence strategy guarantees no loss for a player no matter whether it is taken by the first player or the second player , and no matter what the strategy of the other player , for any instance of the crossdot game with @xmath486 and @xmath418 .",
    "let @xmath119 be a state transition model for a crossdot game with @xmath486 and @xmath487 . if @xmath119 complies with @xmath488 by player @xmath33 , then @xmath489 where @xmath448 represents the opponent player of @xmath33 .",
    "in other words , a player never loses as long as he plays the @xmath490 strategy .",
    "obviously we only have to consider the case when @xmath491 because if a strategy can help a player effectively blocking his opponent to own three consecutive boxes , he can also block his opponent to form any longer line of consecutive boxes .",
    "also if we can prove the strategy to be effective for player 2 , it is sufficient to show that it is also effective for player 1 because he can make his first move at random and then copy player 2 s no - loss strategy ( strategy stealing ) .",
    "altogether this allows us to restrict the proof to @xmath491 and @xmath492 .",
    "it is easy to show that @xmath493 is functional . to show @xmath494",
    ", we only have to verify that for any complete path @xmath153 , we have @xmath495 . recall that @xmath423 is a special reachable path that contains only the terminal state @xmath423 . if @xmath423 is a winning state for player 2 or a tie state , we have @xmath495 .",
    "suppose by contradiction that @xmath423 is a winning state of player 1 .",
    "it then turns out @xmath496 is an odd number and there are at least three consecutive crosses in some states along the complete path @xmath118 . in other words",
    ", there must be a cross next to two other crosses .",
    "however , we will show by induction on the length of the path that this can never happen .",
    "more precisely , we claim that _ in each state @xmath497 , each box filled with a cross must be either adjacent to a box with a dot or at an end ( left or right ) of the line , meanwhile the box on its left , if any , must not be empty",
    ". _ note that if the claim is true in @xmath498 , then player 1 can not win in state @xmath423 no matter which action he chooses in state @xmath498 .",
    "obviously the claim holds when @xmath499 because all boxes are empty in the initial state @xmath500 .",
    "now we assume that the claim holds in state @xmath501 where @xmath502 .",
    "we show that the claim also holds at @xmath503 .",
    "suppose that the action @xmath504 that player 1 took in state @xmath501 was @xmath505 , i.e. , @xmath506 .",
    "obviously this action can at most affect satisfaction of the claim on the box itself or its two immediate neighbours , i.e. , @xmath507 , @xmath114 and @xmath508 ( if exists ) .",
    "therefore we only consider the effect of player 1 s action @xmath509 on these three possible boxes .",
    "if box @xmath114 is not at the right end , by the induction assumption , box @xmath508 can never be with a cross in state @xmath501 ; otherwise box @xmath114 were not empty thus @xmath505 were not doable",
    ". therefore box @xmath508 ( if exists ) satisfies the claimed conditions in state @xmath503 .",
    "we then consider satisfaction of boxes @xmath507 and @xmath114 with three cases :    i ) . if box @xmath507 ( if exists ) has been filled with a dot , both boxes @xmath507 and @xmath114 satisfy the conditions of the claim , which remain true in state @xmath503 .",
    "if box @xmath510 has been already filled with a cross before state @xmath501 , by induction assumption , box @xmath507 is either at the left end or next to a box with a dot on its left . in both situations ,",
    "box @xmath507 satisfies the claimed conditions that remain true in state @xmath503 .",
    "after player 1 fills box @xmath114 with a cross in state @xmath501 , player 2 must respond with action @xmath511 by applying @xmath512 in state @xmath513 to prevent an immediate loss unless the box @xmath114 is at the right end or @xmath508 has already occupied by a dot . in both cases ,",
    "box @xmath114 satisfies the claimed conditions in state @xmath503 .",
    "note that the claim guarantees that @xmath512 is not applicable to any other boxes .",
    "if box @xmath507 was empty in state @xmath501 , by the construction of @xmath514 , player 2 must respond with action @xmath515 either because @xmath507 is an immediate loss position or by applying strategy @xmath516 after player 1 fills box @xmath114 .",
    "after @xmath507 filled with a dot , both boxes @xmath507 and @xmath114 satisfy the claim in state @xmath503 .",
    "note that @xmath517 is not applicable to any box other than @xmath507 ( note that @xmath516 gives priority to the left empty box .",
    "we have verified the claim holds in each state @xmath503 @xmath518 , including state @xmath498 , which implies that the player 2 does not lose in state @xmath423 .",
    "+ note that the @xmath484 strategy ( cf . equation ( [ eq : defence ] ) ) plays a crucial role in the solution .",
    "assume that a game gets into the following situation after a few moves : @xmath519 and it is player 2 s turn .",
    "if player 2 does not have the @xmath484 strategy but simply use @xmath516 to black the opponent , he would take action @xmath520 instead of @xmath521 , which gives player 1 a chance to win .",
    "+ the strategy @xmath490 can effectively prevent from losing but it is hard to win because it does not encode any winning strategy .",
    "the reader is invited to extend the strategy with more aggressive rules so that if the other player is `` not that smart '' , it can have a chance to win .",
    "we now turn to the question of how to actually compute with strategy rules . generally speaking , the conceptual simplicity of our language and the fact that it is not tied to a specific action formalism should make it easy to incorporate knowledge of strategies into various methods for the design and analysis of intelligent agents . to illustrate this",
    ", we will adopt here a very general calculus for reasoning about actions , the situation calculus ( see , e.g. , @xcite ) , and show how our strategy representation can be easily integrated .",
    "reasoning problems about strategies can take different forms , and we will specifically consider two of them .",
    "first , we will show how the calculus can be used to infer the possible outcomes of a game given information about the strategies of all players .",
    "second , we will illustrate how players can reason about the strategies of opponents to infer their best course of action .",
    "we will also show how our variant of the situation calculus forms the basis for an encoding of game rules and a restricted class of strategies as answer set programs .",
    "the situation calculus is a formalism for reasoning about actions and change that is based on classical predicate logic with a few pre - defined language elements :    * @xmath522 , a constant denoting the _ initial situation _ ; and @xmath523 , a constructor denoting the situation resulting from doing action  @xmath524 in situation  @xmath525 ; * @xmath526 , a predicate denoting that _ fluent _",
    "@xmath117 ( i.e. , an atomic state feature ) is true in situation  @xmath525 ; * @xmath527 , a predicate denoting that action  @xmath524 is possible in situation  @xmath525 .    for our purpose",
    ", we extend the base language of the situation calculus by the two game - specific predicates @xmath528 and @xmath529 meaning , respectively , that the game is won for player  @xmath530 in situation  @xmath525 and that @xmath525 is a terminal game position . with this , any axiom in our game specification language",
    "can be easily rewritten for the situation calculus similar to an existing mapping of the game description language ( gdl ) into this calculus  @xcite . to this end , let @xmath531 and @xmath61 be two distinct variables ( standing for any action and situation , respectively ) , then a formula @xmath117 in our language @xmath75 can be translated into a situation calculus axiom @xmath532}$ ] by the following inductive definition : @xmath533 } & : = & { { \\mbox{\\sc holds}}}(p , s ) \\\\     { { ( \\neg\\varphi)}^{sc}[{a},{s } ] } & : = & \\neg{{\\varphi}^{sc}[{a},{s } ] } \\\\     { { ( \\varphi\\wedge\\psi)}^{sc}[{a},{s } ] } & : = & { { \\varphi}^{sc}[{a},{s}]}\\wedge{{\\psi}^{sc}[{a},{s } ] } \\\\      { { does(a)}^{sc}[{a},{s } ] } & : = & a = a \\\\      { { legal(a)}^{sc}[{a},{s } ] } & : = & { { \\mbox{\\sc poss}}}(a , s ) \\\\      { { wins(i)}^{sc}[{a},{s } ] } & : = & { { \\mbox{\\sc wins}}}(i , s ) \\\\      { { ( \\bigcirc\\varphi)}^{sc}[{a},{s } ] } & : = & ( \\forall a')\\,{{\\varphi}^{sc}[{a'},{{{\\mbox{\\sc do}}}(a , s ) } ] } \\\\          { { init}^{sc}[{a},{s } ] } & : = & s = s_0 \\\\      { { terminal}^{sc}[{a},{s } ] } & : = & { { \\mbox{\\sc terminal}}}(s )    \\end{array}\\ ] ]    [ ex : boxdot4 ]   recall the specification of the game in example  [ ex : boxdot1 ] . applying the construction from above to formulas  ( [ eq:2])([eq:12 ] ) yields the following , after some slight syntactic simplifications .",
    "@xmath534 @xmath535 @xmath536 @xmath537 @xmath538 @xmath539 @xmath540 @xmath541      as a general logic - based formalism , the situation calculus allows for a straightforward encoding of strategy rules with the help of a direct encoding of their interpretation according to  ( [ eq : sofr ] ) and definition  [ de : strategyinterpretation ] , respectively .",
    "based on the rewriting rules from above , the situation calculus encoding @xmath542}$ ] for a strategy rule @xmath264 over language @xmath75 is inductively obtained as follows , where @xmath531 and @xmath61 are variables . @xmath543}\\ : = \\ { { \\mbox{\\sc poss}}}(a , s)\\wedge{{\\varphi}^{sc}[{a},{s } ] } \\\\ \\\\        { { ( r_1\\ \\triangledown\\ r_2\\,\\triangledown \\ldots\\triangledown\\ r_n)}[{a},{s}]}\\ : = \\\\      \\ \\ \\ \\ \\ \\ { { r_1}[{a},{s } ] } \\\\      \\ \\ \\ \\ \\ \\ \\vee \\\\      \\ \\ \\ \\ \\ \\ { { r_2}[{a},{s}]}\\,\\wedge\\,\\neg(\\exists a')\\,{{r_1}[{a'},{s } ] } \\\\      \\ \\ \\ \\ \\ \\",
    "\\vee\\ \\ldots\\ \\vee \\\\      \\ \\ \\ \\ \\ \\ { { r_n}[{a},{s}]}\\wedge\\,\\neg(\\exists a')\\,({{r_1}[{a'},{s}]}\\vee\\ldots\\vee{{r_{n-1}}[{a'},{s } ] } ) \\\\ \\\\      { { ( r_1\\vartriangle r_2\\vartriangle \\ldots\\vartriangle r_n)}[{a},{s}]}\\ : = \\\\      \\ \\ \\ \\ \\ \\ { { r_1}[{a},{s}]}\\,\\wedge\\,\\neg(\\exists a')\\,({{r_1}[{a'},{s}]}\\wedge { { r_2}[{a'},{s } ] } ) \\\\      \\ \\ \\ \\ \\ \\ \\vee \\\\      \\ \\ \\ \\ \\ \\ { { r_1}[{a},{s}]}\\wedge{{r_2}[{a},{s}]}\\,\\wedge\\,\\neg(\\exists a')\\,({{r_1}[{a'},{s}]}\\wedge { { r_2}[{a'},{s}]}\\wedge { { r_3}[{a'},{s } ] } ) \\\\      \\ \\ \\ \\ \\ \\",
    "\\vee\\ \\ldots\\ \\vee \\\\      \\ \\ \\ \\ \\ \\ { { r_1}[{a},{s}]}\\wedge{{r_2}[{a},{s}]}\\wedge\\ldots\\wedge{{r_n}[{a},{s } ] }    \\end{array}\\ ] ]      the representation of strategy rules in the situation calculus can be used to define a special predicate , which we denote by @xmath544 , whose intended meaning is that it is possible according to some player s strategy to take action  @xmath524 in situation  @xmath525 .",
    "consider , for example , a given set of complete strategy rules @xmath545 for each player , then this can be embedded into a situation calculus encoding of a game as follows : @xmath546}\\vee\\ldots\\vee{{r_n}[{a},{s}]}\\ ] ]    such information about strategies can be used for a variety of purposes .",
    "specifically , as we will briefly illustrate next , it can be used to infer possible outcomes of a game under a given set of strategy rules or help a player to decide on a course of action by reasoning about opponents strategies .    [ [ inferring - possible - outcomes . ] ] inferring possible outcomes .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    based on the predicate @xmath547 , the set of all possible playouts of a game according to players strategies can be recursively defined as follows .",
    "@xmath548 @xmath549 this predicate determines all paths that are reachable if all players follow their given strategy rules .",
    "hence , all possible playouts under these strategies can be determined as all situations  @xmath61 that satisfy @xmath550 .",
    "[ [ reasoning - about - opponents - strategies . ] ] reasoning about opponents strategies .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    another way of using reasoning about strategies is for players to use knowledge or belief about their opponents strategies in order to compute their own best course of actions in response . as an example",
    ", we will consider the encoding of a generalised form of minimax evaluation in the situation calculus . to this end , let us take the perspective of particular player  @xmath33 and assume that this player s belief about the opponents strategy rules is encoded using predicate @xmath547 as above .",
    "let us assume also that @xmath551 expresses the fact that it is player  @xmath33 s turn in situation  @xmath61 .",
    "we can then define recursively the notion of a winning situation for  @xmath33 , represented by predicate @xmath552 , as follows :    @xmath553    @xmath554    @xmath555    according to this definition , a situation is winnable for our player  @xmath33 if he can choose a course of action whenever it is his turn , ( [ eq : winnable2 ] ) , such that if all other players choose their actions according to their strategy , ( [ eq : winnable3 ] ) , then a terminal situation will be reached in which player  @xmath33 has won , ( [ eq : winnable1 ] ) .         ....",
    "action(a(i , j ) ) .    holds(turn(1),0 ) .",
    "legal(a(i , j),t ) : - not holds(p(1,j),t ) , holds(turn(i),t ) ,                    not holds(p(2,j),t ) , not terminal(t ) .",
    "holds(p(i , j ) , t+1 ) : - holds(p(i , j),t ) .",
    "holds(p(i , j ) , t+1 ) : - does(a(i , j ) ) .",
    "holds(turn(1),t+1 ) : - holds(turn(2),t ) .",
    "holds(turn(2),t+1 ) : - holds(turn(1),t ) .",
    "wins(i , t )    : - holds(p(i , j),t ) , ... , holds(p(i , j+k),t ) .",
    "terminal(t ) : - wins(i , t ) .",
    "terminal(t ) : - not freecell(t ) .",
    "freecell(t ) : - not holds(p(1,j ) ) , not holds(p(2,j ) ) .    1 { does(a , t ) : action(a ) } 1 .",
    ": - does(a , t ) , not legal(a , t ) .    : - non_strategic(t ) .",
    "non_strategic(t ) : - does(a , t ) , not strat(a , t ) .",
    "strat(a , t ) : - fill_next(a , t ) .",
    "strat(a , t ) : - not exists_fill_next(t ) , fill_any(a , t ) .",
    "fill_next(a(i , j),t ) : - holds(p(i , j-1),t ) , legal(a(i , j),t ) ,                        not holds(p(1,j),t ) , not holds(p(2,j),t ) .",
    "fill_next(a(i , j),t ) : - holds(p(i , j+1),t ) , legal(a(i , j),t ) ,                        not holds(p(1,j),t ) , not holds(p(2,j),t ) .",
    "exists_fill_next(t ) : - fill_next(a , t ) .",
    "fill_any(a(i , j),t )   : - legal(a(i , j),t ) .",
    "....    under specific conditions , problems that require reasoning about games and strategies can be solved by answer set programming ( asp ) .",
    "this general technique provides a way of computing models for logic programs for which particularly efficient implementations have been developed in the recent past , such as @xcite just to mention one .",
    "asp has been used successfully for reasoning about actions and plan generation ( see , e.g. , @xcite ) as well as for endgame search in general game playing  @xcite . in this section ,",
    "we build on these existing methods and show how asp can be used to compute all possible outcomes of a game under given strategies for the players .",
    "we assume the reader to be familiar with basic notions and notations of asp , as can be found in  @xcite .",
    "the standard use of asp for computing with actions is to replace the branching time structure of the situation calculus by linear time . for deterministic games with complete specification of the initial state and a given time horizon ,",
    "the game rules can be encoded as an asp in such a way that each answer set corresponds to a reachable path and vice versa ( see , e.g. , @xcite ) . for our running example game ,",
    "figure  [ fi : asp ] ( lines  118 ) constitute an asp encoding that follows this principle .",
    "specifically , the so - called _ weight atom _ in clause  16 requires each answer set to include one , and only one , action at each point in time . the so - called _ constraint _ in clause  17 rules out any answer set in which the chosen action is not legal .",
    "a given asp that provides a linear - time encoding of a game can be extended by encodings of strategy rules for the players so that the answer sets comply with the strategies .",
    "this provides a computational method for inferring the possible outcomes of a game under a given set of strategies .",
    "provided it does not include the , any strategy @xmath117 in our language that can be encoded in this linear way according to the following inductive coding scheme .",
    "let @xmath556 be a unique predicate name that stands for ( the satisfaction of )  @xmath117 , then : @xmath557 where necessary , this is accompanied by clauses with head @xmath558 to encode the sub - formulas @xmath559 ( for @xmath560 ) , which are obtained inductively .",
    "clauses  1929 in figure  [ fi : asp ] are an example of applying this encoding in order to constrain the answer sets for our _ crossdot _ game to those where both players  @xmath33 follow the simple strategy @xmath561 ( cf .",
    "example  [ ex : boxdot5 ] ) : constraint  19 in conjunction with clause  20 rejects all answer sets that do not comply with the strategy definition",
    ". clauses  2427 encode the first part of the strategy rule for both players ( in a slightly more compact form than obtained by strictly applying the coding scheme from above ) , and clause  23 , in conjunction with clauses  2829 , encodes the second part .",
    "the encoding scheme from above does not extend to strategies that include the @xmath85-operator since their evaluation requires a counterfactual lookahead .",
    "hence , they can not be directly represented in an asp based on a linear time structure .",
    "there are two conceivable ways to overcome this limitation .    1 .",
    "if the axiomatisation of a game supports the definition of a regression operator similar to the one in the standard situation calculus  @xcite , then any strategy of the form @xmath562 can be regressed to a formula  @xmath563 that is logically equivalent under the game axioms and contains one less occurrence of the @xmath85-operator .",
    "the repeated application of regression will yield a @xmath85-free formula , which then can be encoded in the same way as above .",
    "2 .   alternatively , we can extend the linear time structure to allow for more than one sequence of actions in a single same answer set .",
    "a similar approach has been shown to be practically viable for proving epistemic properties in general games using asps  @xcite .",
    "a detailed formalisation and analysis of either solution goes beyond the scope of this paper and is left for future work .",
    "+ up to now we have demonstrated with two example implementations how our formalism supports automated reasoning . with regard to the efficiency of the implementations , we can consider different aspects regarding both the description of strategies and the problem of reasoning about them .",
    "the complexity of translating a strategy in our language to situation calculus is linear , and so is the translation to asp for @xmath85-free strategy rules .",
    "however , generally speaking it is unrealistic to expect high efficiency for a generic strategy reasoning mechanism because in theory , as an extension of gdl , our language can describe any finite game with perfect information . verifying an arbitrary strategy such as , `` try any possible action to win , '' is equivalent to solving a game and therefore equally complex .",
    "it is well known that the complexity of finding a winning strategy for complex games like japanese go , which can be specified in gdl , is exptime - complete  @xcite .",
    "moreover , the computational complexity of solving a game sometimes is independent of the length of the game description and the strategies that are used to solve the game .",
    "therefore , a complexity analysis for domain - independent strategy reasoning mechanisms can be meaningless .",
    "however , it is possible that certain restrictions on both game descriptions and strategy rules may lead to specific upper bounds for the computational complexity of solving these games .",
    "restrictions on the number of lookahead steps can also affect the complexity of reasoning .",
    "in addition , since our strategies represent some ideas of how to play a game well , it is possible that we express these ideas in our language and design specific algorithms to automatically generate possible moves that correspond to the ideas .",
    "the efficiency of these algorithms is crucial to the design of a game player .",
    "we leave these issues for future investigation .",
    "modelling and specifying strategies is a fundamental research theme in game theory .",
    "researchers in artificial intelligence have recently joined in the research but mostly focus on modelling of strategic reasoning with the help of logical approaches .",
    "a number of logical frameworks have been proposed in the literature for strategy representation and reasoning  @xcite .",
    "most of the frameworks were built on either _ coalition logic _",
    "( cl ) , _ alternating - time temporal logic _ ( atl ) , or",
    "_ propositional dynamic logic _ ( pdl ) .",
    "both coalition logic  @xcite and alternating - time temporal logic  @xcite were developed to model strategic abilities of coalitions in multi - agent systems .",
    "the modality @xmath564 ( or @xmath565 ) expresses that `` a group of agents , @xmath566 , has a joint strategy to bring about @xmath117 no matter what strategies the other agents choose '' . in cl ,",
    "a strategy of a player is simply an action available to the player . in atl ,",
    "a strategy is a function that maps a sequence of states to an action ( in atl ) . in both logics ,",
    "strategies stay on the semantic level without syntactical representation .    a number of extensions of either cl or atl aim to bring strategies to the syntactical level .",
    "@xcite ( @xcite ) proposed an extension of atl , named catl for _ counterfactual atl _",
    ", with a variation to the coalition modality , @xmath567 , representing the counterfactual statement , `` if agent @xmath33 had committed to a strategy @xmath525 , then @xmath117 would hold '' .",
    "strategies in that framework can be explicitly represented on the syntactical level using dynamic logic - like modalities , even though program connectives of dynamic logic are not allowed to be used for combining strategies .",
    "@xcite ( @xcite ) refine the work of catl into an axiomatic logical system with a different semantics .",
    "however , strategies are still restricted to primitive forms , which means that the combination of strategies is not supported .",
    "similar restrictions have also been applied in several other atl- or cl - like logical frameworks for strategic reasoning , such as @xcite .",
    "another approach to strategy representation and reasoning is to treat a strategy as a program so that pdl - style program connectives can be used to combine strategies  @xcite .",
    "van benthem proposed a logical framework , named temporal forcing logic ( tfl ) , with a modality @xmath568\\varphi$ ] , meaning that `` player @xmath33 applies strategy @xmath525 , against any play of the others , to force the game to a state in which @xmath117 holds '' , where a strategy can be defined as any pdl program .",
    "similar proposal can also be found in @xcite .",
    "such an `` intuitive analogue to strategies '' provides a close approximation to strategy representation ; nevertheless , a strategy has essential differences from a program , which requires specific ways of composition and reasoning as we have shown in the previous sections .",
    "we like to stress that our treatment of strategies is different from all of the abovementioned approaches in the following aspects .",
    "firstly , we can use the same propositional formulas for different purposes . a propositional formula with the standard semantics of propositional modal logic can represent properties of the game state and be used in domain - dependent axioms .",
    "but we also represent a strategy with the help of a propositional formula , by endowing the formula with a specific semantics .",
    "this makes strategy design much easier and efficient .",
    "secondly , we view a strategy as a set of possible moves , i.e. , a set of state - action pairs , rather than a function from a state ( or a sequence of states ) to an action . in this sense ,",
    "our strategies represent `` rough ideas '' , which can then be combined and refined .",
    "thirdly , instead of using pdl - style program connectives , we introduced two prioritised connectives for combining strategies , which , as we have seen , provides for a very natural and convenient design of strategies .",
    "we want to mention that the idea of the prioritised disjunction was inspired by @xcite s ( @xcite ) qualitative choice logic ( qcl ) .",
    "qcl contains a non - standard propositional connective @xmath569 with the meaning , `` _",
    "@xmath531 if possible ; but if @xmath531 is impossible then at least @xmath570 _ '' . we found that the semantics of the connective fits strategies very well .",
    "it is an interesting question for future work whether our prioritised conjunction can be integrated into qcl .",
    "in this paper we have introduced a logical language to describe , compose and combine strategies for game - playing agents .",
    "the language derives from the general game description language ( gdl ) and extends it by a single temporal operator @xmath85 and two new prioritised connectives : @xmath250 and @xmath256 .",
    "the basic components of gdl facilitate the representation of initial and terminal conditions , winning criteria and legality of actions ( i.e. , preconditions ) .",
    "the temporal operator allows us to describe the effects of actions .",
    "these form the basic language for describing game- and player - specific strategies .",
    "the newly introduced connectives allow us to combine simple strategies into more complicated and refined ones .",
    "when we use the language to describe a strategy , we endow it with a specific semantics so that we can compose a strategy in a logical way and the actual moves the strategy represents can be generated in an automatic way .",
    "we have thoroughly analysed the properties of the language .",
    "in fact , the nice properties in particular of the new connectives give us great freedom in practice for strategy design : we can start with a strategy that formalises one specific idea .",
    "if it is too restricted , we can extend it with more generic ones using the prioritised disjunction , and if it is too generic , we can refine it with more specific strategies using the prioritised conjunction .",
    "we have shown also how strategies can be embedded into existing methods for the design and analysis of intelligent agents in order to solve problems that involve reasoning about strategies , including the computation of possible outcomes of games under given strategies .",
    "our current implementation for strategy reasoning combines reasoning about actions and change with an encoding of game rules and strategies using answer set programming .",
    "it would be more efficient to develop a specific method of model checking based on the structure of our state transition model and the syntax of strategy composition .",
    "we leave this for future work .",
    "the first author was partially supported by the australian research council through project dp0988750 and national natural science foundation of china through projects 61003203 and 61262029 .",
    "the second author was the recipient of an arc future fellowship ( project number  ft0991348 ) .",
    "he is also affiliated with the university of western sydney .",
    "we thank the anonymous reviewers for their constructive comments and suggestions .",
    "we also thank guifei jiang for her valuable input ."
  ],
  "abstract_text": [
    "<S> as a contribution to the challenge of building game - playing ai systems , we develop and analyse a formal language for representing and reasoning about strategies . </S>",
    "<S> our logical language builds on the existing general game description language ( gdl ) and extends it by a standard modality for linear time along with two dual connectives to express preferences when combining strategies . </S>",
    "<S> the semantics of the language is provided by a standard state - transition model . as such , problems that require reasoning about games </S>",
    "<S> can be solved by the standard methods for reasoning about actions and change . </S>",
    "<S> we also endow the language with a specific semantics by which strategy formulas are understood as move recommendations for a player . to illustrate how our formalism supports automated reasoning about strategies , we demonstrate two example methods of implementation : first </S>",
    "<S> , we formalise the semantic interpretation of our language in conjunction with game rules and strategy rules in the situation calculus ; second , we show how the reasoning problem can be solved with answer set programming . </S>"
  ]
}