{
  "article_text": [
    "the gaudi software architecture@xcite belongs to the blackboard family@xcite : data objects produced by knowledge modules ( called algorithms in gaudi ) are posted to a common `` in - memory data base '' from where other modules can access them and produce new data objects .",
    "this model greatly reduces the coupling between knowledge modules containing the algorithmic code for analysis and reconstruction , since one knowledge module does not need anymore to know which specific module can produce the information it needs nor which protocol it must use to obtain it ( the `` interface explosion '' problem described in component software systems ) .",
    "algorithmic code is known to be the least stable component of software systems and the blackboard approach has been very effective at reducing the impact of this instability , from the zebra system of the fortran days to the infobus architecture for java components .",
    "the trade - off of the data / knowledge objects separation is the need for knowledge objects to identify data objects to be posted on or retrieved from the blackboard .",
    "it is crucial to develop a data model optimized for the required access patterns and yet flexible enough to accommodate the unexpected ones .",
    "the transient data store ( tds ) is the blackboard of the gaudi architecture : a module creates a data object and post it to the tds to allow other modules to access it .    once an object is posted on to the store , the tds takes ownership of it and manages its lifetime according to preset policies , removing , for example , a trackcollection when a new event is read .",
    "the tds also manages the conversion of a data object from / to its persistent form and provides therefore an api to access data stored on persistent media .",
    "storegate ( sg ) , in common with most other existing data models , is basically a dictionary of data objects which manages their memory and oversees conversion to / from persistency .",
    "the sg design process has been informal and iterative .",
    "we released early and often and used developers feedback to adjust our initial design concept .",
    "the result may lack the coherency of a formal top - down design but it follows a few principles which have proved to be useful .",
    "the success of the stl and of other public domain template libraries means that it has become vital to design an open system that can work with generic types that export an interface , in particular the stl containers , rather than forcing data objects to import a common interface .",
    "sg adapts its behavior to the functionality each data object exports .",
    "the only sg - imposed constraint on a data object is to be an stl _ assignable _ type@xcite .",
    "the disadvantage of the data / knowledge objects separation is the need for knowledge objects to identify data objects to be posted on or retrieved from the blackboard .",
    "it is crucial to develop a data model optimized for the required access patterns and yet flexible enough to accommodate the unexpected ones .",
    "sg addresses this problem with a two - step approach : it defines a natural identifier mechanism for data objects and it transparently associates to each data object a default value of this identifier allowing developers to register and retrieve data objects without having to identify them explicitly .",
    "the first component of the identifier is the data object type .",
    "experience shows that hep developers tend to group the objects they work on into collections . as a result",
    "the tds will often contain a single instance of a data object type ( say a trackcollection or several closely related ones ( e.g. a trackcollection for each component of the inner detector ) .",
    "the sg retrieve interface covers these two use cases ( see fig .",
    "[ fig : sgapi ] ) .",
    "type - based identification is not always sufficient .",
    "for example the tds may contain several equivalent instances of a trackcollection produced by alternative tracking algorithms .",
    "therefore we need to add a second component to our identification mechanism : the identifier of the algorithm instance that produced the data object we want . in the spirit of working with user types , the sg will allow developers to augment this history identifier with a generic key type optimized for their access patterns .    ....",
    "//record a trackcollection      trackcollection * ptrackcoll = mytrackmaker.make ( ) ;      statuscode sc = record(ptrackcoll , `` mytrackcollection '' ) ;        //get the default trackcollection       const trackcollection * ptrackcoll ;       sc = sg->retrieve(ptrackcoll ) ;          //get my special trackcollection      trackcollection * pmytrackcoll ;   //non - const access may be restricted      sc = sg->retrieve(pmytrackcoll , `` mytrackcollection '' ) ;          //access all track colls using a pair of stl forward iterators      datahandle < trackcollection > begintrackcolls , endtrackcolls ;      sc = sg->retrieve(begintrackcolls , endtrackcolls ) ; //get all trackcolls     ....      the tds is the main channel of communication among modules .",
    "a data object is often the result of a collaboration among several modules .",
    "sg allows a module to use transparently a data object created by an upstream module or read from disk .",
    "a _ virtual proxy_@xcite defines and hides the cache - fault mechanism : upon request , a missing data object instance can be transparently created and added to the tds , presumably retrieving it from a persistent data - base or , in principle , even reconstructing it on demand .    to ensure reproducibility of data processing , a data object should not be modified after it has been published to the store , we use the same proxy scheme to enforce an `` almost const '' access policy : modules downstream of the publisher are only allowed to retrieve a constant iterator to the published object .",
    "sg supports uni - directional inter - objects relationships , or links , and will support bi - directional links in the future .",
    "a link is a persistable pointer .",
    "if the linked object is a data object then the proxy scheme described above is also used to implement the link .",
    "but typically links will refer to objects that are not data objects but are contained within a data object .",
    "the sg knows how to get to the container and the container knows how to return an element given its index . the job of the link is to find out the value of the index , persistify it and , later on , pass it on to the container and get back the linked object .",
    "in the next section we will discuss how links handle indices into generic containers .",
    "a big advantage that sg has compared to earlier data models implementations is that many compilers are catching up with the iso / ansi c++ standard .",
    "because of that , a new generation of template libraries like boost@xcite and loki@xcite are bringing once - esoteric techniques like template meta - programming into the mainstream .",
    "template meta - programming uses the compiler template expansion to control and generate running code based on static type information . in sg",
    "we have used some of its simpler techniques .",
    "the tds memory management back - end manages the data objects as instances of a dataobject base class .",
    "each class derived from dataobject has a unique classid .",
    "this allows , for example , to use an _",
    "abstract factory_@xcite to create data object instances when reading from disk .",
    "sg wraps each stored data object into a templated dataobject    ....   template < typename dobj >    class databucket : public dataobject { ... } ....    if dobj does not inherit from dataobject we want the developer to define a classid for dobj that we will associate to the data object .    to determine , at compile time , if dobj inherits from dataobject we use the boost type trait boost::is_base_and_derived@xmath0dobj , dataobject@xmath1 , a template that evaluates to true when dobj can be assigned as a dataobject@xcite .    to associate the classid information to a data object type , say vector@xmath0double@xmath1",
    ", we define a classid_traits structure that developers specialize for that data object ( the struct is actually generated using a cpp macro )    ....   template < >    struct classid_traits < vector < double > > {      typedef type_tools::true_tag has_clid_tag ;      static const int i d = 1234 ;      ....     } ; ....    to manage the classids atlas has developed a simple text - based `` database '' that is used both to generate theclassids of new types and to verify at run - time that there are no duplicated classids and no conflicts .",
    "sg allows developers to use generic key types to identify objects of a given type .",
    "a key must of course define an ordering operation . for sg",
    "we also require keys to be persistable . in traditional oo programming these requirements would be expressed as an interface the key class imports .",
    "in generic programming interfaces are rather exported and hence verified by the clients . to this end",
    ", sg provides a keyconcept built using the boost concept_check library ( see fig .  [",
    "fig : keyconcept ] ) .    ....",
    "template < typename t , .... > struct keyconcept {      void constraints ( ) {         boost::function_requires < boost::lessthancomparableconcept < t > > ( ) ;        ....       }    } ; ....    inserting in the storegate api a call to boost::function_requires@xmath0keyconcept@xmath0key@xmath1@xmath1 ( ) we allow the compiler to check whether the template parameter key of a retrieve or register method is valid .      sg handle and link classes use policy classes to configure their behavior at compile time . a policy@xcite is a statically configured _",
    "it can also be seen as a traits class that defines behavior rather than structure .",
    "policies become powerful tools when they are combined : the compiler picks the right combinations and generates the code needed by the application .",
    "for example the element link class template elementlink is implemented as a combination of two policies ( see fig .",
    "[ fig : policies ] ) .    ....",
    "template < typename storable ,             class storagepolicy = dataproxystorage < storable > ,            class indexingpolicy = typename sg::generateindexingpolicy < storable>::type > class elementlink :     public storagepolicy ,    public indexingpolicy   { ... } ....    dataproxystorage wraps the tds back - end api , while indexingpolicy defines the strategy the elementlink uses to find a container element given its identifier , and viceversa .",
    "the type generator template generateindexingpolicy looks at the data object type ( storable ) and tries to provide a reasonable default strategy for that type .",
    "we have defined indexing policy classes that can be used to index elements of all stl containers and to index nodes of an hepmc graph@xcite .",
    "policies are flexible : if a developer introduces a new container type , all they have to do is to provide a matching indexing policy and the compiler will generate the new link type as needed .",
    "after three years of evolution , storegate has achieved a certain maturity .",
    "a lot of broad design principles have been established : work with user types , avoid user - defined keys , define an access control policy . the core data access api has been stable for several releases .",
    "the implementation has been reviewed and reengineered twice to improve robustness , physical design and to meet the strict performance requirement of atlas trigger software@xcite .    in the spirit of the gaudi open project",
    "we have started discussing our work with the lcg community and we hope the storegate ideas and code will be useful to developers inside and outside atlas .",
    "we would like to thank all atlas collaborators who contributed to the design and prototyping of sg .",
    "we are extremely grateful to many colleagues from other experiments who shared their experiences with us : m. frank , v. innocente , r. kennedy , j. kowalkowski , p. mato , m. paterno , s. patton , s. snyder and l. tuura .",
    "m. cattaneo _",
    "et al . _ , `` status of the gaudi event - processing framework '' , chep 2001 : proceedings . edited by h.s .",
    "beijing , china , science press , 2001 . 757p ."
  ],
  "abstract_text": [
    "<S> the atlas collaboration at cern@xcite has adopted the gaudi software architecture which belongs to the blackboard family : data objects produced by knowledge sources ( e.g. reconstruction modules ) are posted to a common in - memory data base from where other modules can access them and produce new data objects . </S>",
    "<S> the storegate has been designed , based on the atlas requirements and the experience of other henp systems such as babar , cdf , cleo , d0 and lhcb , to identify in a simple and efficient fashion ( collections of ) data objects based on their type and/or the modules which posted them to the transient data store ( the blackboard ) . </S>",
    "<S> the developer also has the freedom to use her preferred key class to uniquely identify a data object according to any other criterion . </S>",
    "<S> besides this core functionality , the storegate provides the developers with a powerful interface to handle in a coherent fashion persistable references , object lifetimes , memory management and access control policy for the data objects in the store . </S>",
    "<S> it also provides a handle / proxy mechanism to define and hide the cache fault mechanism : upon request , a missing data object can be transparently created and added to the transient store presumably retrieving it from a persistent data - base , or even reconstructing it on demand . </S>"
  ]
}