{
  "article_text": [
    "network tomography ( network inference ) @xcite is an emerging field in communication networks which studies the estimation and inference of the network structure and dynamics ( e.g. , routing topology , link performance , traffic demands ) based on _ indirect _ measurements when _ direct _ measurements are unavailable or difficult to collect . as modern communication networks ( e.g. ,",
    "the internet , wireless communication networks ) continue to grow in size , complexity , and diversity , scalable and accurate network inference algorithms and tools will become increasingly important for many network design and management tasks .",
    "these include service provision and resource allocation , traffic engineering , network monitoring , application design , etc .    in _ network monitoring _",
    ", such tools can help a network operator obtain routing information and network internal characteristics ( e.g. , loss rate , delay , utilization ) from its network to a set of other collaborating networks that are separated by non - participating autonomous networks .",
    "if the performance of a certain portion of the network experiences sudden , dramatic changes , it can be an indication of failures or anomalies occurred in that portion of the network .",
    "in _ application design _ , such tools can be particularly useful for peer - to - peer ( p2p ) style applications where a node communicates with a set of other nodes ( called _ peers _ ) for file sharing and multimedia streaming .",
    "for example , a node may want to know the routing topology to other nodes so that it can select peers with low or no route overlap to improve resilience against network failures ( e.g. , @xcite ) . as another example , a streaming node using multi - path may want to know both the routing topology and link loss rates so that the selected paths have low loss correlation ( e.g. , @xcite ) .",
    "so far there are two primary approaches to infer the routing topology and link performance of a communication network .",
    "internal - assisted _ approach uses tools based on measurements or feedback messages of the internal nodes ( e.g. , routers ) .",
    "such an approach is limited as today s communication networks are evolving towards more decentralized and private adminstration .",
    "for example , a common approach to infer the routing topology in the internet is to use _",
    "traceroute_. however , an increasing number of routers in the internet will block traceroute requests due to privacy and security concerns .",
    "these routers are known as _ anonymous routers _ @xcite and",
    "their existence makes the routing topology inferred by traceroute inaccurate .",
    "in addition , administrators of different networks normally will not reveal or share their link - level measurement data for us ( e.g. , end hosts ) to derive the link performance .",
    "not depending on extra cooperation from the internal nodes ( except the basic packet forwarding functionality ) , a _ network tomography _ approach utilizes end - to - end packet probing measurements ( such as packet loss and delay measurements ) conducted by the end hosts to infer the routing topology and link performance . under a network tomography approach",
    ", a source node will send probes to a set of destination nodes .",
    "the basic idea is to utilize the correlations among the observed losses and delays of the probes at the destination nodes to infer the routing topology and link performance from the source node to the destination nodes . due to its flexibility and reliability ,",
    "network tomography has attracted many recent studies . both multicast probing based approaches ( e.g. , @xcite , @xcite , @xcite , @xcite , @xcite ) and unicast probing based approaches ( e.g. , @xcite , @xcite , @xcite , @xcite , @xcite )",
    "have been investigated .",
    "the main challenges of existing approaches and techniques include    * * computational complexity * ; * * information fusion * : how to fuse information from different measurements to achieve the best estimation accuracy ; * * probing scalability * ( especially under unicast probing ) ; * * node dynamics * : how to handle dynamic node joining and leaving efficiently .    in this paper",
    "we propose a new , general framework for designing and analyzing topology and link performance inference algorithms using ideas and tools from phylogenetic inference in evolutionary biology .",
    "the framework is built upon additive metrics . under an additive metric",
    "the path metric ( path length ) is expressed as the summation of the link metrics ( link lengths ) along the path .",
    "the basic idea is to use ( estimated ) distances between the terminal nodes ( end hosts ) to infer the routing tree topology and link metrics .",
    "based on the framework we introduce and develop several computationally efficient inference algorithms with provable performance .",
    "the advantages of our framework are summarized as follows .",
    "* the framework is applicable to a variety of measurement techniques , including multicast probing , unicast probing , and traceroute probing .",
    "since a linear combination of different additive metrics is still an additive metric , the framework can flexibly fuse information available from different measurements to achieve better estimation accuracy . *",
    "based on the framework we can design , analyze , and develop distance - based inference algorithms that are _ computationally efficient _",
    "( polynomial - time ) , _ consistent _ ( return correct topology and link performance with an increasing sample size ) , and _ robust _ ( can tolerate a certain level of measurement errors ) .",
    "we organize the paper as follows . in section [ sec : ntmodel ]",
    "we describe the network model and the inference problem . in section [ sec : ntadditive ] we introduce additive metrics on trees , and we discuss how to construct additive metrics and compute / estimate the distances between the terminal nodes from end - to - end measurements . in section",
    "[ sec : ntnj ] we introduce the neighbor - joining ( nj ) algorithm for constructing binary trees from distances . in section",
    "[ sec : ntrnj ] we propose a rooted version of the nj algorithm and extend it to general trees . in section",
    "[ sec : ntsimulation ] we demonstrate the effectiveness of the inference algorithms via model simulation . in section",
    "[ sec : ntmssd ] we extend our framework to infer the routing topology and link performance from multiple source nodes to a single destination node .",
    "we summarize the paper in section [ sec : ntsummary ] .",
    "let @xmath1 denote the topology of the network , which is a directed graph with node set @xmath2 ( end hosts , internal switches and routers , etc . ) and link set @xmath3 ( communication links that join the nodes ) . for any nodes @xmath4 and @xmath5 in the network , if the underlying routing algorithm returns a sequence of links that connect @xmath5 to @xmath4 , we say @xmath5 is _ reachable _ from @xmath4 .",
    "we call this sequence of links a _ path _ from @xmath4 to @xmath5 , denoted by @xmath6 .",
    "we assume that during the measurement period , the underlying routing algorithm determines a unique path from a node to another node that is reachable from it .",
    "hence the _ physical routing topology _ from a source node to a set of destination nodes is a ( directed ) tree . from the physical routing topology",
    ", we can derive a _",
    "logical routing tree _ which consists of the source node , the destination nodes , and the _ branching nodes _ ( internal nodes with at least two outgoing links ) of the physical routing tree ( e.g. , @xcite , @xcite , @xcite ) .",
    "notice that a logical link may comprise more than one consecutive physical links , and the degree of an internal node on the logical routing tree is at least three .",
    "an example is shown in fig . [",
    "fig : physical ] .",
    "for simplicity we use _ routing tree _ to express logical routing tree unless otherwise noted .",
    "suppose @xmath7 is a source node in the network , and @xmath8 is a set of destination nodes that are reachable from @xmath7 .",
    "let @xmath9 denote the routing tree from @xmath7 to nodes in @xmath8 , with node set @xmath10 and link set @xmath11 .",
    "let @xmath12 be the set of terminal nodes , which are nodes of degree one ( e.g. , end hosts ) .",
    "every node @xmath13 has a _",
    "@xmath14 such that @xmath15 , and a set of _ children _",
    "@xmath16 , except that the source node ( root of the tree ) has no parent and the destination nodes ( leaves of the tree ) have no children . for notational simplification",
    ", we use @xmath17 to denote link @xmath18 .",
    "each link @xmath19 is associated with a performance parameter @xmath20 ( e.g. , success rate , delay distribution , utilization , etc . ) .",
    "the * network inference problem * involves using measurements taken at the terminal nodes to infer    * the topology of the ( logical ) routing tree ; * link performance parameters @xmath21 of the links on the routing tree .",
    "we want to point out that the network inference problem is similar to the _",
    "phylogenetic inference problem _ in evolutionary biology .",
    "the phylogenetic inference problem is to determine the evolutionary relationship among a set of species .",
    "such relationship is often represented by a phylogenetic tree , in which the terminal nodes represent extant species and the internal nodes represent extinct common ancestors of the extant species .",
    "many methods have been developed to reconstruct phylogenetic trees from biological information ( e.g. , biomolecular sequence data ) observed at the terminal nodes ( e.g. , @xcite , @xcite ) .",
    "the mathematical models of the two problems are very similar , except that in the network inference problem we can control and observe the source node , while in the phylogenetic inference problem the information of the source node ( the common ancestor of all species ) is lost .",
    "we will use ideas and tools from phylogenetic inference to analyze and solve the network inference problem .",
    "the tool that we will use to analyze and solve the network inference problem is the so - called _ additive tree metric _ @xcite , or _",
    "additive metric _ for short .",
    "we consider trees with internal node degree at least three .",
    "notice that all ( logical ) routing trees have such property .",
    "@xmath22 is an * _ additive metric _ * on @xmath23 if @xmath24    @xmath25 can be viewed as the _ length _ of link @xmath26 , and @xmath27 can be viewed as the _ distance _ between nodes @xmath4 and @xmath5 .",
    "basically , an additive metric associates each link on the tree with a finite positive link length , and the distance between two nodes on the tree is the summation of the link lengths along the path that connects the two nodes .",
    "suppose @xmath9 is a routing tree with source node @xmath7 and destination nodes @xmath8 .",
    "let @xmath28 denote the link lengths of @xmath29 under additive metric @xmath30 .",
    "remember @xmath12 is the set of terminal nodes on the tree .",
    "let @xmath31 denote the distances between the terminal nodes .",
    "buneman @xcite showed that the topology and link lengths of a tree are uniquely determined by the distances between the terminal nodes under an additive metric .",
    "[ theorem : buneman ] there is a one - to - one mapping between @xmath32 and @xmath33 under any additive metric @xmath30 on @xmath29 .    from theorem [ theorem : buneman",
    "] , we know that we can recover the topology and link lengths of a routing tree if we know @xmath34 .",
    "in addition , if there is a one - to - one mapping between the link performance parameters and link lengths ( which will be clear in section [ sec : ntmulticast ] ) , then we can recover the link performance parameters from the link lengths .",
    "the challenges are :    * constructing an additive metric for which we can derive / estimate @xmath34 from measurements taken at the terminal nodes .",
    "we will address this issue in this section .",
    "* developing efficient and effective algorithms to recover the topology and link lengths from the ( estimated ) distances between the terminal nodes .",
    "we will address this issue in sections [ sec : ntnj ] , [ sec : ntrnj ] .",
    "a source node can employ different probing techniques , e.g. , _",
    "multicast _ probing and _ unicast _ probing , to send probes ( packets ) to a set of destination nodes .",
    "for multicast probing , when an internal node on the routing tree receives an packet from its parent , it will duplicate the packet and send a copy of the packet to all its children on the tree .",
    "therefore , the packets received by different destination nodes have exactly the same network experience ( loss , delay , etc . ) in the shared links .    for a ( multicast ) probe sent by source node @xmath7 to the destination nodes in @xmath8 ,",
    "we define a set of _ link state variables _",
    "@xmath35 for all links @xmath19 on the routing tree @xmath29 .",
    "@xmath35 takes value in a state set @xmath36 .",
    "the distribution of @xmath35 is parameterized by @xmath21 , e.g. , @xmath37    the transmission of a probe from @xmath7 to nodes in @xmath8 will induce a set of _ outcome variables _ on the routing tree . for each node @xmath13",
    ", we use @xmath38 to denote the ( random ) outcome of the probe at node @xmath39 .",
    "@xmath40 takes value in an outcome set @xmath41 . by _ causality _ the outcome of the probe at node @xmath39 ( i.e. , @xmath40 ) is determined by the outcome of the probe at node @xmath39 s parent @xmath42 ( i.e. , @xmath43 ) and the link state of @xmath17 ( i.e. , @xmath44 ) : @xmath45    [ assump : independence ] the link states are independent from link to link ( spatial independence assumption ) and are stationary during the measurement period ( stationarity assumption ) .",
    "[ prop : mrf ] under the spatial independence assumption that the link states are independent from link to link , @xmath46 is a markov random field ( mrf ) on @xmath29 .",
    "specifically , for each node @xmath13 , the conditional distribution of @xmath38 given other random variables @xmath47 on @xmath29 is the same as the conditional distribution of @xmath38 given just its neighboring random variables @xmath48 on @xmath29 .    for notational simplification",
    ", we use @xmath49 to represent @xmath50 for any subset @xmath51 .",
    "first we prove by induction that @xmath52 equation ( [ eq : tree ] ) is clearly true for any tree with @xmath53 or @xmath54 .",
    "assume ( [ eq : tree ] ) is true for any tree with @xmath55 .",
    "now consider a tree @xmath56 with @xmath57 .",
    "let @xmath4 be a leaf node of @xmath56 , then by ( [ eq : outcome ] ) and the spatial independence assumption we have @xmath58    @xmath59 is defined on @xmath60 , a tree with @xmath61 nodes . by induction assumption @xmath62 substituting it into ( [ eq : induction ] ) we have shown that equation ( [ eq : tree ] ) holds for @xmath56 with @xmath57 . by induction argument ,",
    "equation ( [ eq : tree ] ) is true for any tree .",
    "now for any @xmath13 , from ( [ eq : tree ] ) we have @xmath63 where @xmath64 is a function that does not depend on @xmath65 .",
    "then @xmath66    therefore @xmath67 is a markov random field on @xmath29 .",
    "< 1.5em - 1.5em plus0em minus0.5em    for an mrf @xmath68 on @xmath29 , we can construct an additive metric as follows . for each link @xmath69",
    ", we define an @xmath70 ( assume @xmath71 ) _ forward link transition matrix _ @xmath72 and an @xmath70 _ backward link transition matrix _",
    "@xmath73 with entries @xmath74    if the link transition matrices are _ invertible _ so that @xmath75 , not equal to a _ permutation matrix _ ( a matrix with exactly one entry in each row and each column being 1 and others being 0 )",
    "so that @xmath76 , and there exists a node @xmath77 with positive marginal distribution , then we can construct an additive metric @xmath78 with link length ( e.g. , @xcite , @xcite ) : @xmath79    for any pair of terminal nodes @xmath80 , the distance between @xmath4 and @xmath5 under additive metric @xmath78 can be computed by @xmath81    we can construct other additive metrics based on the specific network inference problem .",
    "we use link loss inference as the example .",
    "additive metrics based on link utilization inference and link delay inference can be found in @xcite .",
    "+ _ example 1 ( link loss inference ) : _ for this example , the link state variable @xmath82 is a bernoulli random variable which takes value 1 with probability @xmath83 if link @xmath26 is in _ good state _ and the probe can go through the link , and takes value 0 with probability @xmath84 if the probe is lost on the link ( e.g. , @xcite ) .",
    "@xmath83 is called the _ success rate _ or _ packet delivery rate _ of link @xmath26 , and @xmath85",
    "is called the _ loss rate _ of link @xmath26 .",
    "the outcome variable @xmath38 is also a bernoulli random variable , which takes value 1 if the probe successfully reaches node @xmath39 .",
    "since the probe is sent by the source node @xmath7 , we have @xmath86 .",
    "it is clear that for link loss inference @xmath87    if @xmath88 for all links , then we can construct an additive metric @xmath89 with link length @xmath90    notice that there is a one - to - one mapping between the link length and link success rate , hence we can derive the link success rates from the link lengths , and vice versa .    under the spatial independence assumption that the link states are independent from link to link , we have @xmath91 where @xmath92 is the _ nearest common ancestor _ of @xmath4 and @xmath5 on @xmath29 ( i.e. , the ancestor of @xmath4 and @xmath5 that is closest to @xmath4 and @xmath5 on the routing tree ) .",
    "for example , in fig .",
    "[ fig : physical](b ) , the nearest common ancestor of destination nodes 4 and 5 is node 2 , and the nearest common ancestor of destination nodes 4 and 6 is node 1 .",
    "therefore , the distances between the terminal nodes , @xmath93 , can be computed by @xmath94      as in ( [ eq : dmetric0 ] ) and ( [ eq : dmetric1 ] ) , if we know the pairwise joint distributions of the outcome variables at the terminal nodes , then we can construct an additive metric and derive @xmath34 . in actual network inference problems ,",
    "however , the joint distributions of the outcome variables are not given .",
    "we need to estimate the joint distributions based on measurements taken at the terminal nodes .",
    "specifically , the source node will send a sequence of @xmath61 probes , and there are totally @xmath61 outcomes @xmath95 , @xmath96 , one for each probe . for the @xmath97-th probe , only the outcome variables @xmath98 at the terminal nodes can be measured and observed .",
    "we can estimate the joint distributions of the outcome variables using the observed empirical distributions , which will converge to the actual distributions almost surely if the link state processes are stationary and ergodic during the measurement period .",
    "suppose @xmath7 sends a sequence of @xmath61 probes to ( a subset of ) destination nodes in @xmath8 .",
    "for any probed node @xmath4 , let @xmath99 be the measured loss outcome of the @xmath97-th probe at node @xmath4 , with @xmath100 if node @xmath4 successfully receives the probe and @xmath101 otherwise .",
    "we use the empirical distributions of the outcome variables to estimate the distances . for a bernoulli random variable @xmath102 ( as in link loss inference ) ,",
    "the empirical probability that @xmath102 takes value 1 is just the sample mean @xmath103 is the maximum likelihood estimator ( mle ) of @xmath104 for the samples .",
    "] of the samples @xmath105 : @xmath106    we can construct explicit estimators for the distances in ( [ eq : dmetric1 ] ) as follows ( we use @xmath107 over @xmath30 to represent estimated distances ) : @xmath108 where @xmath109    we can derive exponential error bounds for the distance estimators in ( [ eq : emetric1 ] ) using chernoff bounds @xcite .",
    "[ prop : disterror ] for any pair of nodes @xmath110 , a sample size of @xmath61 ( number of probes to estimate @xmath111 ) , and any small @xmath112 : @xmath113 where @xmath114 s are some constants .",
    "we can also construct additive metrics and compute / estimate the distances between the terminal nodes using ( end - to - end ) unicast packet pair probing or traceroute probing , as described in @xcite .",
    "a nice property of additive metrics is that a linear combination of several additive metrics is still an additive metric . in order to fuse information collected from different measurements",
    ", we can construct a new additive metric using a linear ( convex ) combination of additive metrics @xmath115 : @xmath116    the estimated distance between terminal nodes @xmath117 under the new additive metric can be easily computed : @xmath118    in practice we can select the coefficients empirically based on the current network state or to minimize the variance of the estimator @xmath119 .",
    "we have described how to construct additive metrics and estimate the distances between the terminal nodes via end - to - end packet probing measurements . in this section",
    "we introduce the _ neighbor - joining _ ( nj ) algorithm , which is considered the most widely used algorithm for building binary phylogenetic trees from distances ( e.g. , @xcite , @xcite , @xcite ) .",
    "a * _ distance - based tree inference algorithm _ * ( or distance - based algorithm for short ) takes the ( estimated ) distances between the terminal nodes of a tree as the input and returns a tree topology and the associated link lengths . the input distances @xmath120 satisfy : @xmath121    two or more nodes on a tree are called _ * neighbors * _ ( _ * siblings * _ ) , if they are connected via one internal node ( if they have the same parent ) on the tree .",
    "the nj algorithm is an _",
    "agglomerative algorithm_. the algorithm begins with a leaf set including all destination nodes . in each step",
    "it selects two leaf nodes that are likely to be neighbors , deletes them from the leaf set , creates a new node as their parent and adds that node to the leaf set .",
    "the whole process is iterated until there is only one node left in the leaf set , which will be the child of the root ( source node ) .    to avoid trivial cases , we assume @xmath122",
    ". +   +    ( 89,0 ) ( 0,0)(1,0)89     + _ algorithm 1 : neighbor - joining ( nj ) algorithm for binary trees _",
    "+    ( 89,0 ) ( 0,0)(1,0)89     + * input : * estimated distances between the nodes in @xmath12 , @xmath120 .",
    "* @xmath123 , @xmath124 .",
    "* for any pair of nodes @xmath125 , compute @xmath126 * find @xmath127 with the largest @xmath128 ( break the tie arbitrarily ) .",
    "+ create a node @xmath129 as the parent of @xmath130 and @xmath131 .",
    "+ @xmath132 , @xmath133 + @xmath134 , @xmath135 . * compute the link lengths from the distances : @xmath136/2 , \\\\ \\hat{d}(f , j^ * ) = \\frac{1}{|u|}\\sum_{k\\in u } \\big[\\hat{d}(k , j^*)+\\hat{d}(i^*,j^*)-\\hat{d}(k , i^*)\\big]/2.\\end{aligned}\\ ] ] * for each @xmath137 , compute the distance between @xmath39 and @xmath129 : @xmath138 + \\frac{1}{2}\\big[\\hat{d}(k , j^*)-\\hat{d}(f , j^*)\\big].\\end{aligned}\\ ] ] @xmath139 , @xmath140 . * if @xmath141 , for the @xmath142 : @xmath143 , @xmath144 . + otherwise , repeat step 2 .",
    "* output : * tree @xmath145 , and link lengths @xmath146 for all @xmath19 .",
    "+    ( 89,0 ) ( 0,0)(1,0)89     + the nj algorithm has several nice properties :    * it is computationally efficient , with a polynomial - time complexity @xmath147 for ( binary ) trees with @xmath148 terminal nodes ; * it returns the correct tree topology and link lengths if the input distances are _ additive _ ( i.e. , if the input distances are derived from an additive metric without estimation errors ) ; * it is robust : it achieves the optimal @xmath0-_radius _ among all distance - based algorithms for binary trees .",
    "the @xmath0-radius notation was introduced by atteson @xcite .    for a distance - based algorithm ,",
    "we say it has @xmath0-*_radius _ * @xmath149 , if for any tree @xmath56 associated with any additive metric @xmath30 , whenever the input distances between the terminal nodes , @xmath120 , satisfy : @xmath150 the algorithm will return the correct topology of @xmath56 .",
    "an algorithm with larger @xmath0-radius is more robust , because it can tolerate more estimation errors .",
    "@xcite showed that no distance - based algorithm has @xmath0-radius larger than @xmath151 via an example , and proved that the nj algorithm in fact achieves the optimal @xmath0-radius for binary trees .",
    "the nj algorithm achieves the optimal @xmath0-radius @xmath151 for binary trees .",
    "it is not straightforward to extend the nj algorithm for general ( non - binary ) trees .",
    "since most routing trees in communication networks are not binary , we are motivated to design algorithms that can handle general trees .",
    "we first present an algorithm which can be viewed as a _ rooted _ version of the nj algorithm for binary trees . to avoid trivial cases , we assume @xmath122 . +   +    ( 89,0 ) ( 0,0)(1,0)89     + _ algorithm 2 : rooted neighbor - joining ( rnj ) algorithm for binary trees _ +    ( 89,0 ) ( 0,0)(1,0)89     + * input : * estimated distances between the nodes in @xmath12 , @xmath120 .",
    "* @xmath152 , @xmath124 .",
    "+ for any pair of nodes @xmath125 , compute @xmath153 * find @xmath127 with the largest @xmath154 ( break the tie arbitrarily ) .",
    "+ create a node @xmath129 as the parent of @xmath130 and @xmath131 .",
    "+ @xmath155 , + @xmath156 , @xmath157 . *",
    "compute : @xmath158 * for each @xmath159 , compute : @xmath160 + \\frac{1}{2}\\big[\\hat{d}(k , j^*)-\\hat{d}(f , j^*)\\big ] , \\\\",
    "\\hat{\\rho}(k , f ) = & \\frac{1}{2}\\big[\\hat{d}(s , k)+\\hat{d}(s , f)-\\hat{d}(k , f)\\big ] \\nonumber \\\\                  = & \\frac{1}{2}\\big[\\hat{\\rho}(k , i^*)+\\hat{\\rho}(k , j^*)\\big ] .",
    "\\end{split}\\ ] ] @xmath161 . * if @xmath141 , for the @xmath142 : @xmath143 , @xmath144 .",
    "+ otherwise , repeat step 2 .",
    "* output : * tree @xmath145 , and link lengths @xmath146 for all @xmath19 .",
    "+    ( 89,0 ) ( 0,0)(1,0)89     + the major difference between the nj algorithm and the rnj algorithm is the selection of the _ score function _ : the nj algorithm uses the @xmath162 function defined in ( [ eq : njqfun ] ) , which has no simple interpretation ; while the rnj algorithm uses the @xmath163 function in ( [ eq : rnjrhofun ] ) , which has a simple interpretation that we will explain next .    for any pair of nodes @xmath164 , remember @xmath92 is their nearest common ancestor on @xmath29 . under additive metric @xmath30 ,",
    "we know @xmath165 is the distance from the root ( source node @xmath7 ) to @xmath92 .",
    "it is not hard to verify that a pair of nodes @xmath166 with largest @xmath167 must be neighbors ( siblings ) on the tree .",
    "@xmath154 in ( [ eq : rnjrhofun ] ) is the estimated distance from the root to @xmath92 computed from the input distances . if the input distances are close to the true additive distances , then we would expect that the two nodes selected in step 2.1 of algorithm 2 are indeed neighbors .",
    "we provide a sufficient condition for algorithm 2 to return the correct tree topology . from the condition we can establish several nice properties of the algorithm .    [ lemma : rnjbsuff ] for binary trees , a sufficient condition for algorithm 2 to return the correct tree topology is : @xmath168 where @xmath169 means that @xmath92 is descended from @xmath170 .",
    "we prove the lemma by induction on the cardinality of @xmath8 .",
    "+ ( 1 ) if @xmath171 , then clearly algorithm 2 will return the correct tree topology . + ( 2 ) assume algorithm 2 returns the correct tree topology under condition ( [ eq : topocon1 ] ) for @xmath172 .",
    "now consider @xmath173 .",
    "_ * claim 1 .",
    "@xmath174 found in step 2.1 which maximize @xmath154 are siblings ( neighbors ) . * _ + if @xmath130 and @xmath131 are not siblings , then there exists @xmath175 such that either @xmath176 or @xmath177 is descended from @xmath178 . under condition ( [ eq : topocon1 ] ) , this implies either @xmath179 a contradiction to the maximality of @xmath180 .",
    "_ * claim 2 .",
    "condition ( [ eq : topocon1 ] ) is maintained over the nodes in @xmath8 after step 2 . * _ + after step 2 , @xmath174 are deleted from @xmath8 and @xmath129 is added to @xmath8 as a new leaf node .",
    "since @xmath174 are siblings and @xmath129 is their parent , we know that for any @xmath142 , @xmath181    therefore , @xmath182 s.t .",
    "@xmath183 , we have @xmath184 and @xmath185 , which implies @xmath186.\\end{aligned}\\ ] ]    similarly , @xmath187 s.t .",
    "@xmath188 , we can show @xmath189 .    from claims 1 and 2 ,",
    "we know that after one iteration of step 2 , algorithm 2 will correctly find out a pair of siblings , and condition ( [ eq : topocon1 ] ) is maintained for the new set of leaf nodes in @xmath8",
    ". then @xmath190 is decreased by 1 . by induction assumption",
    ", the algorithm will return the correct topology of the remaining part of the tree .",
    "this completes our proof of the lemma .",
    "< 1.5em - 1.5em plus0em minus0.5em    [ prop : rnjbexact ] for binary trees , algorithm 2 will return the correct tree topology and link lengths if the input distances @xmath120 are additive .    if the input distances are additive , then @xmath154 and @xmath191 are the actual distances from @xmath7 to @xmath92 and @xmath170 under an additive metric . in this case , if @xmath92 is descended from @xmath170 , since link lengths are positive , we have @xmath192 , hence condition ( [ eq : topocon1 ] ) holds .",
    "then by lemma [ lemma : rnjbsuff ] , algorithm 2 will return the correct tree topology .",
    "in addition , under additive distances it is clear that the link lengths computed in step 2.2 of algorithm 2 are correct .",
    "< 1.5em - 1.5em plus0em minus0.5em    in practice , the distances between the terminal nodes are estimated from measurements taken at the terminal nodes .",
    "the estimated distances may deviate from the true additive distances due to measurement errors .",
    "nevertheless , we will show that if the estimated distances are close enough to the true distances , then algorithm 2 will return the correct tree topology .",
    "in addition , algorithm 2 achieves the optimal @xmath0-radius among all distance - based algorithms .",
    "[ prop : rnjbapprox ] the rnj algorithm ( algorithm 2 ) achieves the optimal @xmath0-radius @xmath151 for binary trees , i.e. , for any binary tree associated with any additive metric @xmath30 , whenever the input distances @xmath120 satisfy : @xmath193 algorithm 2 will return the correct tree topology .    using lemma [ lemma : rnjbsuff ]",
    "we only need to show that condition ( [ eq : a2radius ] ) implies condition ( [ eq : topocon1 ] ) .",
    "let @xmath194 be the minimum link length on the tree .",
    "if @xmath169 , i.e. , if @xmath92 is descended from @xmath170 , since link lengths @xmath195 @xmath196 , we have @xmath197 then from ( [ eq : rnjrhofun ] ) , ( [ eq : rho ] ) , ( [ eq : a2radius ] ) we have : @xmath198    hence condition ( [ eq : a2radius ] ) indeed implies condition ( [ eq : topocon1 ] ) . since ( [ eq : topocon1 ] ) is a sufficient condition for algorithm 2 to return the correct tree topology , ( [ eq : a2radius ] ) is also a sufficient condition for algorithm 2 to return the correct tree topology .",
    "< 1.5em - 1.5em plus0em minus0.5em      @xmath167 is the distance from the root to the nearest common ancestor of nodes @xmath4 and @xmath5 . for a general routing tree with positive link lengths",
    ", we have several observations of the @xmath199 function .    * if nodes @xmath4 and @xmath5 are neighbors on the tree , then for any other node @xmath39 on the tree we have @xmath200 * if nodes @xmath4 and @xmath5 are neighbors on the tree , then for any other node @xmath39 that is also a neighbor of @xmath4 and @xmath5 we have @xmath201 because @xmath202 . * if nodes @xmath4 and @xmath5 are neighbors on the tree , then for any other node @xmath39 that is not a neighbor of @xmath4 and @xmath5 we have @xmath203 ( where @xmath196 is the minimum link length ) because @xmath92 is descended from @xmath170 and they are separated by at least one link .    therefore , we can determine whether a group of nodes are neighbors on the tree from knowledge of the @xmath199 function under an additive metric .    to extend the rnj algorithm ( algorithm 2 ) for general trees , after we find out two nodes @xmath130 and @xmath131 that are likely to be neighbors in step 2.1 , we need to find out other nodes that are likely to be neighbors of @xmath130 and @xmath131 based on @xmath163 computed from the input distances .",
    "we use the following _ threshold neighbor criterion _ : +   + * threshold neighbor criterion . * + suppose @xmath130 and @xmath131 are neighbors on the tree .",
    "node @xmath39 will be chosen as a neighbor of @xmath130 and @xmath131 if and only if @xmath204 for some threshold @xmath205 .",
    "+ based on observations ( [ eq : obsneighbor ] ) and ( [ eq : obsnonneighbor ] ) , and since @xmath163 is an estimator of @xmath199 with possible estimation errors , we use the middle point @xmath206 as the threshold .",
    "later we will show that such a threshold enables the algorithm to achieve the optimal @xmath0-radius @xmath207 for general trees if the threshold criterion ( [ eq : thresholdcriterion ] ) is used in the algorithm ( see the proof of proposition [ prop : upperboundradius ] ) .",
    "+   +    ( 89,0 ) ( 0,0)(1,0)89     + _ algorithm 3 : rooted neighbor - joining ( rnj ) algorithm for general trees _ +    ( 89,0 ) ( 0,0)(1,0)89     + * input : * estimated distances between the nodes in @xmath12 , @xmath120 ; estimated minimum link length @xmath208 .    *",
    "@xmath152 , @xmath124 .",
    "+ for any pair of nodes @xmath125 , compute @xmath209 * find @xmath127 with the largest @xmath154 ( break the tie arbitrarily ) .",
    "+ create a node @xmath129 as the parent of @xmath130 and @xmath131 .",
    "+ @xmath155 , + @xmath156 , @xmath157 . *",
    "compute : @xmath210 * for every @xmath159 such that @xmath211 : + @xmath212 , + @xmath213 , @xmath214 .",
    "+ compute : @xmath215 * for each @xmath159 , compute : @xmath216 + \\frac{1}{2}\\big[\\hat{d}(k , j^*)-\\hat{d}(f , j^*)\\big ] , \\\\ \\hat{\\rho}(k , f ) = & \\frac{1}{2}\\big[\\hat{d}(s , k)+\\hat{d}(s , f)-\\hat{d}(k , f)\\big ] \\nonumber \\\\                  = & \\frac{1}{2}\\big[\\hat{\\rho}(k , i^*)+\\hat{\\rho}(k , j^*)\\big ] .",
    "\\end{split}\\ ] ] @xmath161 . * if @xmath141 , for the @xmath142 : @xmath143 , @xmath144 .",
    "+ otherwise , repeat step 2 .",
    "_ output : _ tree @xmath145 , and link lengths @xmath146 for all @xmath19 . +    ( 89,0 ) ( 0,0)(1,0)89     +    [ lemma : rnjgsuff ] let @xmath217 be the input parameter .",
    "a sufficient condition for algorithm 3 to return the correct tree topology is : @xmath218",
    "we outline the proof , which is similar to the proof of lemma [ lemma : rnjbsuff ] .",
    "there are three key observations :    * under condition ( [ eq : topocon2 ] ) , @xmath174 found in step 2.1 of algorithm 3 are siblings .",
    "* under condition ( [ eq : topocon2 ] ) , @xmath39 will be selected in step 2.3 if and only if it is a sibling of @xmath130 and @xmath131 .",
    "* condition ( [ eq : topocon2 ] ) is maintained over the nodes in @xmath8 after step 2 .",
    "the lemma then follows by induction on the cardinality of @xmath8 .",
    "< 1.5em - 1.5em plus0em minus0.5em    for general trees , algorithm 3 will return the correct tree topology and link lengths if the input distances @xmath120 are additive .",
    "the proof is similar to the proof of proposition [ prop : rnjbexact ] .    in practice",
    "the input distances may deviate from the true additive distances due to measurement errors .",
    "again we can show that if the input distances are close enough to the true additive distances , then algorithm 3 will return the correct tree topology .",
    "[ prop : rnjgapprox ] for a general tree with additive metric @xmath30 , if the input parameter @xmath219 and the input distances @xmath120 satisfy : @xmath220 then algorithm 3 will return the correct tree topology .",
    "the proof is similar to the proof of proposition [ prop : rnjbapprox ] .",
    "we can show that condition ( [ eq : topocon3 ] ) implies condition ( [ eq : topocon2 ] ) , then the proposition follows by lemma [ lemma : rnjgsuff ] .",
    "< 1.5em - 1.5em plus0em minus0.5em    if the input parameter @xmath221 , then proposition [ prop : rnjgapprox ] says that the rnj algorithm has @xmath0-radius @xmath207 for general trees .",
    "the rnj algorithm ( algorithm 3 ) has @xmath0-radius @xmath207 for general trees when @xmath222 .",
    "we have the following conjecture .",
    "no distance - based algorithm has @xmath0-radius greater than @xmath207 for general trees .",
    "if this is true , then the rnj algorithm ( algorithm 3 ) achieves the optimal @xmath0-radius @xmath207 for general trees when @xmath221 .",
    "we can show that no distance - based algorithm has @xmath0-radius greater than @xmath207 if the threshold ( neighbor ) criterion ( [ eq : thresholdcriterion ] ) is used in the algorithm .",
    "[ prop : upperboundradius ] if the threshold criterion ( [ eq : thresholdcriterion ] ) is used , then no distance - based algorithm has @xmath0-radius greater than @xmath207 for general trees .",
    "suppose @xmath223 is a distance - based algorithm with @xmath0-radius @xmath149 in which the threshold criterion ( [ eq : thresholdcriterion ] ) is used .",
    "let @xmath221 .",
    "therefore , for any tree @xmath56 associated with any additive metric @xmath30 , if the input distances @xmath120 satisfy : @xmath224 then @xmath223 will return the correct topology of @xmath56 .",
    "suppose @xmath130 and @xmath131 are neighbors on @xmath56 , and @xmath39 is a neighbor of them .",
    "then we have @xmath225 . under condition ( [ eq : l_inftyradiusa ] ) we know @xmath226 since the threshold criterion ( [ eq : thresholdcriterion ] ) is used , we need to have @xmath227 to correctly add @xmath39 as a neighbor of @xmath130 and @xmath131 .    now suppose @xmath228 is not a neighbor of @xmath130 and @xmath131 .",
    "then we have @xmath229 . under condition ( [ eq : l_inftyradiusa ] ) we know @xmath230 since the threshold criterion ( [ eq : thresholdcriterion ] ) is used , we need to have @xmath231 to correctly not add @xmath228 as a neighbor of @xmath130 and @xmath131 .    combining ( [ eq : r*con1 ] ) and ( [ eq : r*con2 ] ) we have @xmath232 where the upper bound @xmath207 of @xmath149 is achieved with the threshold @xmath233 .",
    "< 1.5em - 1.5em plus0em minus0.5em      the computational complexity of the rnj algorithm is @xmath234 for a routing tree with @xmath148 destination nodes .",
    "we now show the _ consistency _ of the rnj algorithm for general trees ( algorithm 3 ) , and a similar result holds for binary trees .",
    "let @xmath235 be the inferred tree topology returned by the rnj algorithm with a sample size @xmath61 ( number of probes to estimate the distances between the terminal nodes ) .",
    "let @xmath236 denote the probability of correct topology inference of the rnj algorithm .",
    "[ prop : rnjsamplesize ] let @xmath217 be the input parameter of the rnj algorithm . if @xmath237 where @xmath61 is the sample size and @xmath238 is a constant , then for a routing tree with @xmath148 terminal nodes : @xmath239    by proposition [ prop : rnjgapprox ] we have @xmath240 where @xmath241 .",
    "< 1.5em - 1.5em plus0em minus0.5em    [ prop : rnjlinklength ] if the input distances @xmath120 are consistent ( i.e. , they converge to the true distances in probability in the sample size ) and the rnj algorithm returns the correct tree topology , then the link lengths returned by the rnj algorithm are consistent .",
    "if we use the distance estimators in ( [ eq : emetric1 ] ) , since they satisfy condition ( [ eq : disterror2 ] ) ( by proposition [ prop : disterror ] ) and are consistent , by proposition [ prop : rnjsamplesize ] , the probability of correct topology inference of the rnj algorithm goes to 1 exponentially fast in the sample size .",
    "if the inferred topology is correct , then by proposition [ prop : rnjlinklength ] , the returned link lengths are also consistent . for network inference problems where there is a one - to - one mapping between the link performance parameters and the link lengths ( e.g. , ( [ eq : linkpara1 ] ) ) ,",
    "the link lengths returned by the rnj algorithm provide consistent estimators for the link performance parameters ( e.g. , success rates ) .",
    "in addition to analysis , we demonstrate the effectiveness of the nj algorithm and the rnj algorithm via model simulation . for each experiment",
    ", we first randomly generate the tree topology and select the link success rates in a certain range .",
    "the source node then sends a sequence of probes to the destination nodes .",
    "the destination nodes measure the loss outcomes of the probes .",
    "we consider both random binary trees and general trees ) . ] .",
    "the distances between the terminal nodes are estimated from the empirical distributions of the observed outcomes at the destination nodes as in ( [ eq : emetric1 ] ) .",
    "we then apply both inference algorithms to infer the tree topology and link success rates using the estimated distances between the terminal nodes .",
    "we compare the inferred tree topology with the true tree topology .",
    "if the inferred topology is correct , then we further compare the inferred link success rates @xmath242 s with the true link success rates @xmath83 s .",
    "specifically , for each link @xmath26 , we compute the _ relative error _ of the inferred link success rate ( compared with the true link success rate ) as follows : @xmath243 and we calculate the average relative error among all links on the tree : @xmath244    each experiment is repeated 100 times . for each inference algorithm",
    ", we compute the _ fraction _ of correctly inferred trees among all 100 trials ( which can be viewed as the _ probability _ of correct topology inference of the algorithm ) , as well as the average value of @xmath245 among the correctly inferred trees .",
    "the results are shown in figs .",
    "[ fig : mbn10a90topo]-[fig : mgn10a90link ] .",
    "the @xmath246 axis is in log scale , i.e. , it is @xmath247 for a sample size of @xmath61 probes .",
    "as we expect from our analysis , the nj algorithm and the rnj algorithm are _ consistent _ : the fraction of correctly inferred trees of both algorithms goes to 1 ( exponentially fast ) as we increase the sample size , and the average relative error of the inferred link success rates goes to 0 with an increasing sample size .    for binary trees , we observe that the nj algorithm and the rnj algorithm have very similar performance ; while for general trees , the rnj algorithm has a clear advantage over the nj algorithm in terms of the fraction of correctly inferred trees , implying that the rnj algorithm is more accurate for topology inference of general trees .",
    "we conduct experiments for trees with different sizes and ranges of link success rates , and we observe the same pattern of the results .",
    "in this section we study the network inference problem of estimating the routing topology and link performance from multiple source nodes to a single destination node , in contrast to the single - source multiple - destination network inference problem we have addressed in the previous sections .",
    "again we assume that during the measurement period , the underlying routing algorithm determines a unique path from a node to another node that is reachable from it .",
    "therefore , the _ physical routing topology _ from a set of source nodes to a destination node forms a reversed directed tree . from the physical routing topology",
    ", we can derive a _",
    "logical routing tree _ which consists of the source nodes , the destination node , and the _ joining _ nodes ( internal nodes with at least two incoming links ) of the physical routing tree .",
    "each internal node on the logical routing tree has degree at least three , and a logical link may comprise more than one physical links .",
    "an example is shown in fig .",
    "[ fig : physical2 ] .",
    "let @xmath149 be a destination node ( receiver ) in the network , and @xmath248 be a set of source nodes that will communicate with @xmath149 .",
    "let @xmath249 denote the ( logical ) routing tree from nodes in @xmath248 to @xmath149 , with node set @xmath10 and link set @xmath11 .",
    "let @xmath250 be the set of terminal nodes , which are nodes with degree one .",
    "each node @xmath13 has a _ child _",
    "@xmath251 such that @xmath252 , and a set of parents @xmath253 , except that the destination node has no child and the source nodes have no parents .    for notational simplification",
    ", we use @xmath17 to denote link @xmath254 .",
    "each link @xmath17 is associated with a performance parameter @xmath255 ( e.g. , success rate , delay distribution , utilization , etc . )",
    "that we want to estimate .",
    "the network inference problem involves using measurements taken at the terminal nodes to infer    * the topology of the ( logical ) routing tree ; * link performance parameters @xmath21 of the links on the routing tree .",
    "similar to multicast probing from a source node to a set of destination nodes , we can have _ reverse multicast probing _ from a set of source nodes to a single destination node .",
    "we illustrate the idea of reverse multicast using fig .",
    "[ fig : physical2](b ) as the example .    under a reverse multicast probing ,",
    "source nodes 4 and 5 will send a packet ( probe ) to their child node 2 .",
    "node 2 may receive both packets , or one of them , or none of them ( because of packet loss ) .",
    "if node 2 receives at least one packet from its parents , it will combine ( e.g. , concatenate ) the packets and sends the combined packet ( as a probe ) to its child node 1 .",
    "otherwise , node 2 will send nothing .",
    "similarly , source node 3 will send a packet to its child node 1 .",
    "node 1 combines the packets received from its parents ( if any ) and sends the combined packet to the destination node @xmath149 .",
    "the whole process is like the reverse process of multicasting a probe from node @xmath149 to the other nodes on the routing tree .    for a probe sent from the source nodes in @xmath248 to the destination node @xmath149",
    ", we define a set of _ link state variables _",
    "@xmath35 for all links on the routing tree @xmath256 .",
    "using link loss inference as the example , @xmath82 is a bernoulli random variable which takes value 1 with probability @xmath83 if the probe can go through link @xmath26 , and takes value 0 with probability @xmath84 if the probe is lost on the link .    for each node @xmath39 on the routing tree , we use @xmath38 to denote the ( random ) outcome of the probe sent from node @xmath39 observed by the destination node @xmath149 . for link loss inference , @xmath40 takes value 1 if @xmath149 successfully receives the probe sent from node @xmath39 , and takes value 0 otherwise .",
    "it is clear that for any source node @xmath4 , @xmath257    if @xmath88 for all links , then we can construct an additive metric @xmath89 with link length @xmath258    for any pair of source nodes @xmath259 , let @xmath92 denote their _ nearest common descendant _ on @xmath256 ( i.e. , the descendant of both nodes @xmath4 and @xmath5 that is closest to @xmath4 and @xmath5 on the routing tree ) .",
    "for example , in fig .",
    "[ fig : physical2](b ) , the nearest common descendant of source nodes 4 and 5 is node 2 , and the nearest common descendant of source nodes 3 and 4 is node 1 .    under the spatial independence assumption that the link states are independent from link to link , for any pair of source nodes @xmath4 and @xmath5 , we have @xmath260    therefore , the distances between the terminal nodes , @xmath93 , can be computed by ( @xmath261 ) : @xmath262    we can see that the mathematical model of a reverse multicast probing on a routing tree ( with multiple source nodes and a single destination node ) is similar to the mathematical model of a multicast probing on a routing tree ( with a single source node and multiple destination nodes ) . therefore , the additive - metric framework can be directly applied to analyze and solve the multiple - source single - destination network inference problem .",
    "specifically , we can construct additive metrics , estimate the distances between the terminal nodes from end - to - end measurements , and apply the distance - based algorithms to infer the routing tree topology and the link performance metrics .",
    "although the current internet does not support reverse multicast probing because internal nodes ( routers ) do not combine packets sent from different source nodes to a destination node , reverse multicast can be deployed in wireless networks ( e.g. , @xcite , @xcite ) for efficiently data collecting .",
    "a typical scenario in wireless sensor networks for data collecting is as follows .",
    "a base station ( a receiver ) will first propagate an _",
    "interest message _ into the network via flooding or constrained / directional flooding .",
    "an interest message could be a query message which specifies what the base station wants ( e.g. , temperature statistics ) .",
    "a node , when first receives the interest message from another node , will set that node as its _ child _ and forward the interest message to its own neighbors excluding its child .",
    "hence the interest propagation procedure serves both to disseminate the interest message , and to set up a _ reverse path _ from each node to the base station .",
    "when a sensor node which has the data of interest ( a source node ) receives the interest message , it can send the data back to the base station using the reverse path ( i.e. , it sends the data to its child ) .",
    "assume each source node has a unique i d ( e.g. , the geographical location of the node ) .",
    "the data sent by a source node to the base station also include the source node s i d so the base station knows from where it receives the data .",
    "if each node selects only one node as its child , i.e. , if there is a unique path from a node to the base station , then we know that the routing topology ( undirected version ) from the source nodes to the base station is a tree .",
    "we call it a _ data collecting tree_. each internal node on the tree only needs to maintain the information of a set of parents that it will receive data from , and a child that it will send data to .",
    "suppose _ directed diffusion _",
    "@xcite is applied on the data collecting tree , under which an internal node will aggregate ( e.g. , combine , compress , code , etc . )",
    "the data sent from its parents and then send the aggregated data to its child .",
    "then this process is like a reverse multicast probing process as we described in section [ sec : reversemulticast ] . using the algorithms we have developed in this paper",
    ", the base station can infer : ( 1 ) the topology of the data collecting tree ; ( 2 ) the link performance ( e.g. , packet delivery rate ) of every link on the data collecting tree .",
    "there are several advantages for the base station to do network inference based on the collected data from the sensor nodes .",
    "first , the ( internal ) sensor nodes do not need to measure and infer the link performance which can save their resources ; while normally the base station has sufficient battery and computation power so it is competent for the network inference task .",
    "second , this is a _ passive network monitoring framework _ so no extra probing traffic is generated .",
    "in addition , since the inference is based on real data transmission , the inferred link performance metrics are more accurate and meaningful .",
    "in this paper we address the network inference problem of estimating the routing topology and link performance in a communication network .",
    "we propose a new , general framework for designing and analyzing network inference algorithms based on additive metrics using ideas and tools from phylogenetic inference .",
    "the framework is applicable to a variety of measurement techniques .",
    "based on the framework we introduce and develop several distance - based inference algorithms .",
    "we provide sufficient conditions for the correctness of the algorithms .",
    "we show that the algorithms are computationally efficient ( polynomial - time ) , consistent ( return correct topology and link performance with an increasing sample size ) , and robust ( can tolerate a certain level of measurement errors ) .",
    "in addition , we establish certain optimality properties of the algorithms ( i.e. , they achieve the optimal @xmath0-radius ) and demonstrate their effectiveness via model simulation .",
    "the framework provides powerful tools that enable us to infer and estimate the structure and dynamics of large - scale communication networks .",
    "r. caceres , n. g. duffield , j. horowitz , d. towsley ,  multicast - based inference of network - internal loss characteristics , \" _ ieee transactions on information theory _ , vol .",
    "45 , no . 7 , pp . 2462 - 2480 , nov . 1999 .",
    "y. mao , f. r. kschischang , b. li , s. pasupathy ,  a factor graph approach to link loss monitoring in wireless sensor netowrks , \" _ ieee journal on selected areas in communications _ , vol .",
    "4 , pp . 820 - 829 , april 2005 .",
    "j. ni and s. tatikonda , ",
    "explicit link parameter estimators based on end - to - end measurements , \" _",
    "45th allerton conference on communication , control , and computing _ , monticello ,",
    "illinois , september 2007 .",
    "f. l. presti , n. g. duffield , j. horowitz , d. towsley ,  multicast - based inference of network - internal delay distributions , \" _ ieee / acm transactions on networking _ , vol .",
    "761 - 775 , dec . 2002 .",
    "k. tamura , m. nei , s , kumar ,  prospects for inferring very large phylogenies by using neigbhor - joining mehtod , \" _ proc . of the national academy of sciences",
    "_ , vol . 101 , no . 30 , pp . 11030 - 11035 , july 2004"
  ],
  "abstract_text": [
    "<S> inference of the network structure ( e.g. , routing topology ) and dynamics ( e.g. , link performance ) is an essential component in many network design and management tasks . in this paper </S>",
    "<S> we propose a new , general framework for analyzing and designing routing topology and link performance inference algorithms using ideas and tools from phylogenetic inference in evolutionary biology . </S>",
    "<S> the framework is applicable to a variety of measurement techniques . </S>",
    "<S> based on the framework we introduce and develop several polynomial - time distance - based inference algorithms with provable performance . </S>",
    "<S> we provide sufficient conditions for the correctness of the algorithms . </S>",
    "<S> we show that the algorithms are consistent ( return correct topology and link performance with an increasing sample size ) and robust ( can tolerate a certain level of measurement errors ) . </S>",
    "<S> in addition , we establish certain optimality properties of the algorithms ( i.e. , they achieve the optimal @xmath0-radius ) and demonstrate their effectiveness via model simulation .    network tomography , routing topology inference , link performance estimation , additive metrics , neighbor - joining . </S>"
  ]
}