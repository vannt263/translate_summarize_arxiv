{
  "article_text": [
    "the aim of any notation for software system design must be to faithfully capture the structure and behaviour of the proposed system .",
    "the aim of any tooling that supports such a notation must be that it is reliable and provides useful functionality .",
    "what kind of functionality ?",
    "certainly , the notation must be a good vehicle for communication - other people must be able to understand your ideas expressed in the notation .",
    "however , communication is not sufficient ; the notation must support other useful tasks that contribute to the development of a system .",
    "a design notation must allow a tool to provide feedback on whether the system is likely to work , perhaps even allow a tool to animate parts of the design .",
    "in addition , it should be possible to generate parts of a system from its design .    in recent years",
    "there has been interest in model driven architecture @xcite , software factories @xcite , tool definition languages and domain specific languages .",
    "all of these initiatives aim to provide design notations that achieve the aims outlined above .",
    "these technologies fall broadly into two categories : standard vs. extensible languages .",
    "the design notation is standard .",
    "uml 2.x is an example of this category whereby the notation is standard with some limited scope for extension points . in the case of uml",
    "there is a very large number of different types of design element .",
    "each type of element can be stereotyped by defining properties and changing the iconization .",
    "this is similar to _ annotations _ recently added to java .",
    "the advantages of this approach are that the design notation is completely standard in terms of how it is presented to the user , therefore tools mature quickly , the expertise required to use the technology is relatively low , and information is interoperable between tools .",
    "the disadvantage is that the notation designers must preempt all the element types that will be required , leading to notational bloat , and the scope for notational extension is very limited .",
    "the design notation is user - defined .",
    "there are a number of technologies including microsoft visual studio dsl tools @xcite , gmf @xcite and metaedit+ @xcite that allow a user to define new notation .",
    "the extent to which the notation can be extended differs between technologies : some tooling limits the definition through wizards and some allows arbitrary extension through program - level interfaces . in most cases , the underlying model for the design notation ( the so - called meta - model ) is defined by the user and therefore the data representation is tailored to the application domain .",
    "an advantage of this approach is that both the notation and underlying data representation are a good fit for the application domain , therefore tooling can take advantage of this by supporting the use of the notation .",
    "the main disadvantages of this approach are that the skill levels required to work with technology are relatively high and that the graphical tooling must be developed ( even model - based ) for each new language .",
    "is it possible to achieve the advantages of each approach without the disadvantages ?",
    "analysis of the use of many design notations leads to the conclusion that many features recur while others differ . in most cases",
    "there are package - like and class - like elements with association - like relationships between them .",
    "variations occur due to different categories of these basic features with their own specific properties .",
    "this paper describes an approach to domain specific languages that allows arbitrary extension of a small collection of underlying modelling concepts via access to a self - describing meta - model .",
    "it shows that by adding the notion of _ meta - packages _ to the meta - language , tooling can be designed that offers domain specific languages without wholesale definition of a new language ( such as that required by emf and gmf ) .",
    "the need for dsl tooling is discussed further by fowler @xcite.the result is an extensible modelling notation that reuses the same tooling .",
    "the use of meta - package based technology does not require skills in complete language definition and is not limited to the simple property - based extensions of the standards based approach described above .",
    "in addition , by extending the notion of a package slightly , many new language features can be added .",
    "meta - packages are implemented in xmf - mosaic and have been used on a number of projects including generating code for telecomms applications @xcite .",
    "the screen - shots and code in this paper are taken from a tutorial example that is implemented in xmf - mosaic .",
    "the book @xcite provides a good introduction to meta - modelling concepts .",
    "the rest of this paper is structured as follows : section [ sec : example ] provides the motivation for meta - packages using a simple example ; section [ sec : metapackages ] defines meta - packages and how associated tooling accommodates them ; section [ sec : beandsl ] implements the example dsl using meta - packages ; finally , section [ sec : review ] reviews meta - packages , describes some extensions and discusses related systems .",
    "design notations should support the generation of source code where this is sensible .",
    "the generation of source code from standard modelling notations raises a problem .",
    "one of the merits of a modelling notation is that it abstracts away from implementation details ; however , implementation details are required in order to generate the code . in effect",
    ", an arbitrary number of sub - categories of modelling element needs to be identified and represented in the design .",
    "each category can be defined in terms of properties , structure or behaviour .",
    "standard modelling notations often allow categories to be defined using simple properties .",
    "however , this is not addressing the real issue which is to be able to define new categories of modelling element with their own structure and behaviour .",
    "meta - packages support the definition of new element categories by allowing a standard modelling language to be extended at the meta - level .",
    "this section motivates the definition of meta - packages using a simple example .",
    "java has recently been extended with annotations which can be used to add properties to standard java program elements such as classes .",
    "the motivation for annotations has been the need to _ mark - up _",
    "java components with static information that can be used by tooling .",
    "an example use of annotations is in the implementation of enterprise information systems where java class use annotations to define a mapping to relational database tables .",
    "for example the simple model defined in figure [ fig : orderprocessing1 ] may give rise the to following java code :    .... @entity @table(name=\"order_table \" ) public class order {      private int i d ;    private string address ;      @id    @column(name=\"order_id \" )    public int getid ( ) {      return i d ;    }    public void setid(int i d ) {      this.id = i d ;    }      @column(name=\"shipping_address \" )    public string getaddress ( ) {      return address ;    }    public void setaddress(string address ) {      this.address = address ;    } } ....    in which instances of the class order are to be persisted in a relational database as rows in the table named order_table with columns order_id and shipping_address .",
    "the primary key of this table is order_id .",
    "the tool used to represent the model in figure [ fig : orderprocessing1 ] is standard since it provides tools in the palette to create basic modelling elements : package , class , attribute etc . given a model using this tool , there is no way to distinguish between those model element that will become entity beans and those that will become basic java classes .",
    "figure [ fig : beanmodelling ] shows a tool that provides a new category of modelling element : beans .",
    "the model for the order processing system now includes two different categories of modelling element : classes and attributes , entitybeans and beanattributes .",
    "it is now possible to distinguish between the elements in terms of code generation .",
    "in addition , entitybean will have a property that defines the name of the relational database table used to represent its instances .",
    "in addition to defining new modelling entities , a dsl has semantics .",
    "part of the semantics of a language are the rules that govern correct model formation .",
    "these are expressed at the meta - package level , for example an entitybean is correctly formed when it has at most one bean attribute that is designated as an i d ( the primary key in the table ) .",
    "figure [ fig : dslsemantics ] shows the result of running the well - formedness checks for the meta - package over the instance shown in figure [ fig : beanmodelling ] .",
    "leaves of the tree are constraints that have been applied to the model elements .",
    "triangles represent constraints that are satisfied .",
    "crosses are constraints that have failed .",
    "therefore , in the example model the customer element has oneid ( a single attribute designated as a primary key ) but does not specify a persistent name ( a table in the database ) .",
    "meta - packages provide a mechanism for extending the basic language for class - based modelling shown in figure [ fig : orderprocessing1 ] with _ domain specific _ features such as those shown in figure [ fig : beanmodelling ] .",
    "tooling for standard modelling detects meta - package automatically and extends the functionality appropriately .",
    "meta - packages are a way of defining semantically rich dsls without having to specify associated tooling .",
    "the idea is that there is a single basic meta - package that defines a language .",
    "the concepts in the base meta - package can be extended to produce new meta - packages .",
    "each meta - package is a language and tooling is written against the base meta - package . since all new meta - packages are extensions of the base , the existing tooling will work with any new language . since languages are written at the meta - level , executable meta - modelling allows any new language to have a rich semantics .",
    "this section defines meta - packages and is structured as follows : section [ sub : xcore ] defines the base meta - package called xcore ; section [ sub : tools ] defines a tool model for languages over xcore ; section [ sub : diagrams ] defines a model for tool diagrams ; section [ sub : displays ] defines a model for the display elements on diagrams ; finally , section [ sub : mappings ] defines mappings that ensure the diagrams and model elements are synchronized in the tools .",
    "meta - packages are defined in a meta - circular language defined in figure [ fig : xcore ] .",
    "this language is part of the basic package , called xcore , of the xmf - mosaic modelling tool . in xmf - mosaic , everything is an element . classes are elements with names , constraints , attributes and parents . note that every element has a type ( _ of _ ) which is a class .",
    "a package is a class that contains elements and which has a meta - package .",
    "the idea of the meta - package association is that each element contained by a package is _ of _ some class contained by its meta - package . by default , the meta - package of all packages is xcore .",
    "the semantics of xcore is defined using a collection of constraints . since xcore is self defining these constraints are defines with respect to xcore itself .",
    "the following is an example which states that all elements of an enumerated type must be instances of that type and no other instances exist :    .... context enum    elements->forall(e | e.of = self ) context element    of.of = enum implies      of.elements->includes(self ) ....    xcore supports executable meta - modelling via xmf .",
    "the following operations are used in the rest of this paper :    .... context class    @operation allparents():set(class )      parents->iterate(p p = set { } |         p + p.allparents ( ) )    end context package     @operation modellingelements():set(class )      elements->select(e |        e.iskindof(class ) )    end context element    @operation tag(expected : class):string      if of = expected      then \" \"      else of.name      end    end ....          modelling in xcore - based languages is supported by tooling .",
    "figure [ fig : xcore ] shows an example of a modelling tool that consists of a palette on the left - hand side and a diagram containing modelling elements on the right .",
    "the palette contains buttons for the modelling elements defined in the modelling language .",
    "the tool palette depends on the modelling language s meta - package ; however there is only one tool engine which is parameterized with respect to the meta - package .",
    "figure [ fig : toolmodels ] shows the key elements involved in defining a modelling tool .",
    "a tool associates a package of modelling elements , a diagram and a palette of button groups .",
    "buttons are used to select creation modes .",
    "events on the diagram modify diagram elements and events to the package modify modelling elements .",
    "daemons on both the diagram and the package ensure that events from the model are propagated to the diagram and vice versa .",
    "figure [ fig : toolpalette ] shows the structure of a tool palette .",
    "the palette consists of groups of buttons which are selected in order to determine the creation mode on a diagram .",
    "each group corresponds to a meta - package .",
    "all packages have xcore as a meta - package by default and therefore have the xcore and xmap groups .",
    "if the meta - package of the package associated with a tool is p which inherits from xcore then the palette will have groups named xcore , xmap and p. this leads to the following constraint :    .... context tool    palette.groups.name =     package.metapackage.allparents().name ....    the buttons provided by each group are determined by the language elements defined in the meta - package .",
    "a modelling element is a sub - class of package , class or attribute as defined in xcore .",
    "therefore :    .... context tool    package.metapackage.allparents ( )      ->forall(p |        palette.groups",
    "->exists(g |             g.name = p.name and               p.modellingelements().name =                 g.buttons.name ) ) ....          each tool manages a diagram that consists of nodes and edges .",
    "each node has a display that is used to render the node on the diagram .",
    "each edge has a source and a target node and a collection of labels .",
    "the diagram model is shown in figure [ fig : diagrammodels ] .",
    "the tool requires that the diagram is always synchronized with the package .",
    "therefore the following constraint must always hold :    .... context tool    package.classes()->size =    diagram.nodes()->size ....    the constraint on edges is less easy to define since attributes may be shown on a diagram within classes or as edges .",
    "in addition , inheritance is shown as edges . to make matters more complex",
    "the types of attributes and the target of inheritance edges may be imported from other packages .",
    "figure [ fig : displays ] shows some of the display types that can be used to render nodes on diagrams .",
    "two basic types of display are shown : boxes and text .",
    "package - based diagrams use specializations of these display types to render classes .",
    "a class box consists of a name box and several attribute boxes .",
    "note that attboxes and namebox are derived attributes since they are just specifically identified components of the displays . both attrbute boxes and name boxes",
    "have some text for the name of the element .",
    "they also both have a tag which is used to identify the meta - type of the element if it not class or attribute respectively .",
    "an attribute box has an additional text field for the type of the attribute .",
    "diagram - model synchronization is handled by a collection of mappings associated with a tool .",
    "figure [ fig : mapping ] shows the mapping model for package diagrams .",
    "a mapping has the form a_x_b which associates instances of a with instances of b. each mapping class has a constraint that defines the synchronization requirements .",
    "many of these constraints state commutative properties of the model .",
    "for example :    .... context tool    mapping.package = package and    mapping.diagram = diagram ....    each of the mappings inherit from a class onetoone ( not shown ) which requires that all maplets are unique .",
    "a mapping instance can reference all of the elements in the domain and range of the mapping and also reference all of the associations ( one of which is itself ) .",
    "the following constraints require the onetoone mapping to have unique associations :    .... context onetoone    domain->forall(d |      range->exists(r1 r2 |        map(d , r1 ) and map(d , r2 )           implies r1 = r2 ) )    context onetoone    range->forall(r |      domain->exists(d1 d2 |        map(d1,r ) and map(d , r2 )          implies d1 = d2 ) ) ....    all of the classes in the package must be shown on the diagram and all class nodes on the diagram must correspond to some class in the package :    .... context diagram_x_package    package.classes = classbox_x_classes.class context diagram_x_package    diagram.classboxes =     classbox_x_classes.classbox ....    all the attribute edges must be related and must correspond to an attribute . note that not all attributes need to be shown as edges on the diagram :    .... context diagram_x_package    attedge_x_attributes.attedge =     diagram.attedges context diagram_x_package    attedge_x_attributes.attribute      ->subset(package.classes.attributes ) ....    the name of a class on a diagram must always be synchronized with the name of the corresponding model element . if the element is directly an instance of class then its tag is empty otherwise the tag must be the name of the meta - type :    .... context classbox_x_class    classbox.name = class.name context classbox_x_class    classbox.tag = class.tag ....    all of the attributes in a class box must correspond to some attribute of the associated class .",
    "however , the not all attributes need to be displayed in a class box :    .... context classbox_x_class    attbox_x_attributes.attribute",
    "->subset(class.attributes ) context classbox_x_class    attbox_x_attributes.attbox =    classbox.attboxes ....    attribute boxes offer a name , a type and an optional meta - tag .",
    "the following constraints require that these are always synchronized ( attribute edge tags are specified using similar constraints ) :    .... context attbox_x_attribute    attribute.name = attbox.name context attbox_x_attribute    attribute.type.name = attbox.type context attbox_x_attribute    attribute.tag = attbox.tag ....    finally , any attribute edges that are shown on the diagram must correspond to attributes .",
    "the source of the edge must be a class box that corresponds to the owner of the attribute and the target of the edge must be a class that corresponds to the type of the attribute .",
    "the predicate isclass is not defined but is satisfied isclass(b , c ) when the box b is associated with the class c in the tool :    .... context attedge_x_attribute    isclass(attedge.sourcebox , attribute.owner ) context attedge_x_attribute    isclass(attedge.targetbox , attribute.type ) ....    all of the attributes must be shown as either edges or in boxes :    .... context diagram_x_package    package.classes.attributes =      attedge_x_attributes.attribute +      classbox_x_classes.attbox_x_attributes.attribute ....    other constraints can be defined to require that an attribute edge can not be shown as a boxed attribute .",
    "the previous section has defined the meta - package relationship that allows new class - based dsls to be defined by extending meta - concepts .",
    "existing tooling mechanisms can accommodate the new dsls without any new code being necessary .",
    "this section shows how a new language to support beans for enterprise systems can be defined using the meta - package relationship .",
    "the result of the definition is a new tool as shown in figure [ fig : beanmodelling ] .",
    "this section is defined as follows : section [ sub : abstractsyntax ] describes the abstract syntax for the dsl ; section [ sub : concretesyntax ] describes how concrete syntax can be defined in a number of ways ; section [ sub : constraintchecking ] describes well - formedness semantics for the dsl ; section [ sub : codegeneration ] defines how java code is generated from the dsl .          the first step in dsl definition is to define a new meta - package whose modelling concepts extend those of an existing meta - package .",
    "figure [ fig : beans ] shows the definition of the package named beans .",
    "the concepts are defined as follows :    00.00.0000    a bean container is a specialization of package .",
    "the contents of a bean container may be entity beans and the class beancontainer provides us with a container for bean specific constraints .",
    "an entity bean is a class that has a persistsas property that is used to name the relational database table used to contain all the instances of the class .",
    "a bean attribute is a special type of attribute that names the column in the database table used to contain its values .",
    "a bean attribute can be tagged as being a primary key in the relational table by setting its isid attribute .",
    "a bean attribute may also require a java accessor and updater .",
    "these properties are set via the attribute modifiers of the bean attribute .",
    "the beans package must be designated as a meta - package .",
    "this is done by making it _ inherit from _ xcore as shown in figure [ fig : metapackage2 ] . by default ,",
    "a package inherits from an empty package and is therefore not a meta - package . by making a package inherits from a meta - package , the new package also becomes a meta - package .",
    "the package orderprocessing is to be written in the language defined by beans . by default",
    "the meta - package of a new package is xcore .",
    "figure [ fig : metapackage2 ] shows the meta - package of orderprocessing has been changed to beans .",
    "note that the super - package of orderprocessing has not been changed , so it stays as the default empty package and therefore orderprocessing is not itself a meta - package .",
    "a dsl does not require a concrete syntax , but it is generally important for usability to have one .",
    "dsls that are defined via meta - packages get a concrete diagram syntax for free .",
    "the tooling that is specified in section [ sec : metapackages ] detects the new modelling concepts and provides new palette buttons and labelling as appropriate .",
    "in addition to diagram syntax for a language , textual syntax is often useful .",
    "xmf @xcite has a text language for package definition that supports the declaration of meta - package information .",
    "this is exactly the same as the diagram tooling : the same text processing engine is used even though the language has changed via meta - package extension .",
    "the following shows how the orderprocessing bean container can be defined using xmf package definition :    .... @package orderprocessing     metaclass beancontainer metapackage beans     @class namedelement isabstract      @attribute name : string end    end    @class order metaclass entitybean      @attribute identifier         metaclass beanattribute : integer       end      @attribute address         metaclass beanattribute : string       end      @attribute customer         metaclass beanattribute : customer       end      @attribute product         metaclass beanattribute : product       end    end    @class customer metaclass entitybean       extends namedelement    end    @class product metaclass entitybean       extends namedelement      @attribute amount         metaclass beanattribute : integer       end    end end ....",
    "a problem with the basic text definition shown above is that it does not provide support for setting the new meta - properties such as persistas .",
    "these can be set independently , but it is much better if an entity can be defined as a modular unit .",
    "in addition , the above syntax exposes implementation details about the modelling concepts by requiring their meta - classes to be specified .",
    "xmf supports extensible syntax via syntax - classes @xcite which are normal classes that define grammars for processing text .",
    "this mechanism can be used to define a new concrete syntax for a dsl that translates into the basic definitions given above .",
    "the following is a dsl for beans that has been used to define the order processing system :    .... @beancontainer orderprocessing    entity namedelement      name        ( name )              : string    end    entity order(order_table ) [ namedelement ]      * identifier(order_id )          : integer      address     ( shipping_address ) : string      customer    ( customer_ref )      : customer      product     ( product_ref )       : product    end    entity customer extends namedelement    entity product extends namedelement      amount      ( amount )            : integer    end end ....    the example above hides all of the implementation detail .",
    "this is achieved by defining a new syntax class for beancontainer as shown below :    .... @class beancontainer    @grammar      beancontainer : : = n = name es = entity * {       [ | let p = @package",
    "< n >                     metaclass beancontainer                     metapackage beans end          in < es->iterate(e x = [ | p | ] |                [ | p.add(<e > ) ; < x > | ] ) >          end | ]      }",
    ".      entity : : =        n = name p = persist s = super as = att * {       [ | let c = @class < n >                     metaclass entitybean                    extends < s >                  end          in c.persistas : = < p.lift ( ) > ;                < as->iterate(a x = [ |",
    "c | ] |                   [ | < x>.add(<a > ) | ] ) >             end          | ]      } .",
    "persist : : = ' ( ' name ' ) ' .",
    "super : : = ' [ ' type ' ] ' .",
    "att : : =         i = isid",
    "n = name p = persist ' : ' t = type {        [ | let a = beanattribute(<n.lift()>,<t > )           in a.persistas : = < p.lift ( ) >           end | ]      } .",
    "end end ....",
    "constraint checking involves executable modelling ( being able to attach executable predicate expressions to classes as shown in figure [ fig : xcore ] ) .",
    "elements are well - formed when they satisfy all of the constraints defined by their class .",
    "in addition , containers , such as packages , are well formed when their contents are well - formed .    in order for a bean container to be well - formed , all of the persistent elements must specify a name that can be used in the relational database :    .... context persistent     @constraint hasname      persistas < > \" \"      fail \" must specify a persistent name . \"",
    "end   ....    an entity bean is well formed when there is at most one bean attribute that designates a primary key :    .... context entitybean     @constraint oneid      not @exists a1,a2 in attributes - >            a1 < > a2 and             a1.isid and             a2.isid          end      fail \" can not have multiple ids . \"",
    "end   ....      code generation involves a mapping from a model to source code .",
    "this is the essence of mda in which uml models are translated to code .",
    "however , uml does not allow access to the meta - level and therefore the scope for extending the modelling language with sophisticated translation mechanisms is limited .    to translate from elements in figure [ fig : beans ] to the source code shown in section [ sec : example ] we can also use executable meta - modelling technology .",
    "a code export operation is defined for each class that is to be translated .",
    "xmf provides _ code - template _ technology that makes it easy to generate code @xcite .",
    "the following template :    .... @java(out , leftmargin )    class < n > {     } end ....    writes an empty class definition to the output channel , newlines tab to leftmargin . within the java code template",
    "all text is faithfully written to the output except for expressions delimited by < and > .",
    "such expressions are evaluated and then written to the output channel . in the example above , the generated class will have a name that is the value of the variable n. within expressions , the use of [ and ] delimiters switch back to literal code and nesting of [ , ] and < , > is permitted .",
    "entity beans are translated to code as follows :    .... context entitybean    @operation code(out : outputchannel )      @java(out,7 )        @entity        @table(name=\" < persistas > \" )        public class",
    "< name >   {          < @for a in attributes              when a.iskindof(beanattribute ) do            [ private < a.typename ( ) >",
    "< a.name > ; ]           end ;           @for a in attributes              when a.iskindof(beanattribute ) do            a.code(out )           end >        }      end    end ....    each bean attribute is translated to code as follows :    .... context beanattribute    @operation code(out : outputchannel )      let name = name.tostring ( ) then          name = name.uppercaseinitialletter ( )      in        @java(out,7 )          < if isid then [ @id ] end >          @column(name=\" < persistas > \" )          < if self.canget ( )            then self.getcode(out,name,name )            end >          < if self.canset ( )            then self.setcode(out,name,name )            end >        end      end    end       context beanattribute    @operation getcode(out , name , name )      @java(out,5 )        public < self.typename ( ) > get < name > ( ) {          return < name > ;        }      end    end       context beanattribute    @operation setcode(out , name , name )      @java(out,5 )         public void set < name>(<self.typename ( ) > < name > ) {",
    "this.<name >   = < name > ;        }      end    end ....",
    "this paper has identified two broad approaches to dsls for design notations : standards based and user defined .",
    "standards , notably the uml family , offer mature tooling and interchangeable models , but can be bloated and lack mechanisms for sophisticated extensibility . technologies for user defined notations offer arbitrary flexibility but at a cost of complexity and starting from scratch each time .",
    "meta - packages is an meta - modelling based approach to defining languages that allows tooling to be developed that does not require significant modification each time a new language is developed . since the approach uses true meta - modelling , object - oriented techniques can be used to define semantics for the new language features .",
    "meta - packages have been specified and a simple example dsl for enterprise systems has been described .",
    "meta - packages are an approach rather than a single technology .",
    "the key features are a single meta - circular meta - model ( xcore defined here ) , executable modelling , and the meta - package relationship .",
    "this combination of features guarantees that any tooling based on the base meta - language will work with any new language that is defined .",
    "the xcore language as defined in this paper is rather small .",
    "meta - packages are supported by xmf - mosaic where xcore is much larger , however the principles are the same .",
    "one important feature supported by xmf - mosaic is the ability for diagrams to render element - nodes and slot - edges .",
    "since we advocate a true meta - modelling approach , everything is ultimately an instance of the class element .",
    "packages can contain elements . if diagrams can render elements and represent slot - values via edges then _",
    "any _ package element can be represented on a diagram and related to their owner .",
    "this feature guarantees that any language can be supported by tooling that is parameterized with respect to the base language , even if the element is not a specialization of the basic meta - concepts ( package , class , attribute etc ) .",
    "for example , classes could be extended to represent components with ports .",
    "a port can be represented on a diagram as a basic element with a slot - value edge from the component to the port .",
    "xmf - mosaic is available open - source under epl from the ceteva web - site ( http://www.ceteva.com ) .",
    "virtually all other tools for dsl definition do not implement the golden braid ( meta - model - instance ) @xcite .",
    "for example , gmf models are instances of ecore but can not themselves have instances . the same is true of uml and therefore uml tooling and of visual studio dsl tools .",
    "the golden braid is a key feature in the meta - package approach since it allows tooling to be defined that is reusable with models that can be extended with their own semantics .",
    "n. georgalas , m. azmoodeh , a. clark , a. evans , p. sammut , and j.willans .",
    "mda - driven development of standard - compliant oss components : the oss / j inventory case - study . in 2nd european workshop on mda ,",
    "kent , uk , 2004 .",
    "n. georgalas , m. azmoodeh . using mda in technology - independent specifications of ngoss architectures .",
    "first european workshop on model driven architecture with emphasis on industrial application ( mda - ia 2004 ) , enschede , the netherlands ( march 2004 ) .",
    "georgalas n. , azmoodeh m. and ou s. model driven integration of standards based oss components .",
    "proceedings of the eurescom summit 2005 on ubiquitous services and application , heidelberg , germany ( april 2005 ) .",
    "pierre cointe .",
    "metaclasses are first class : the objvlisp model . in norman",
    "meyrowitz , editor , proceedings of the conference on object - oriented programming systems , languages and applications , pages 156165 .",
    "acm , october 1987 ."
  ],
  "abstract_text": [
    "<S> domain specific languages are used to provide a tailored modelling notation for a specific application domain . </S>",
    "<S> there are currently two main approaches to dsls : standard notations that are tailored by adding simple properties ; new notations that are designed from scratch . </S>",
    "<S> there are problems with both of these approaches which can be addressed by providing access to a small meta - language based on packages and classes . </S>",
    "<S> a meta - modelling approach based on _ meta - packages _ allows a wide range of dsls to be defined in a standard way . </S>",
    "<S> the dsls can be processed using standard object - based extension at the meta - level and existing tooling can easily be defined to adapt to the new languages . </S>",
    "<S> this paper introduces the concept of meta - packages and provides a simple example . </S>"
  ]
}