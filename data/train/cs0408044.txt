{
  "article_text": [
    "one of the most challenging and promising goals of artificial intelligence research is the design of autonomous agents , including robots , that explore partially known environments and that are able to act sensibly under incomplete information . to attain this goal",
    ", the paradigm of cognitive robotics  @xcite is to endow agents with the high - level cognitive capability of reasoning .",
    "exploring their environment , agents need to reason when they interpret sensor information , memorize it , and draw inferences from combined sensor data .",
    "acting under incomplete information , agents employ their reasoning facilities for selecting the right actions . to this end",
    ", intelligent agents form a mental model of their environment , which they constantly update to reflect the changes they have effected and the sensor information they have acquired .",
    "having agents maintain an internal world model is necessary if we want them to choose their actions not only on the basis of the current status of their sensors but also on the basis of what they have previously observed or done .",
    "moreover , the ability to reason about sensor information is necessary if properties of the environment can only be observed indirectly and require the agent to combine observations made at different stages .    while standard programming languages such as java do not provide general reasoning facilities for agents , logic programming ( lp ) constitutes the ideal paradigm for designing agents that are capable of reasoning about their actions  @xcite .",
    "examples of existing lp - systems that have been developed from general action theories are golog  @xcite , based on the situation calculus  @xcite , or the robot control language developed in  @xcite , based on event calculus  @xcite .",
    "however , a disadvantage of both these systems is that knowledge of the current state is represented indirectly via the initial conditions and the actions which the agent has performed up to now . as a consequence ,",
    "each time a condition is evaluated in an agent program the entire history of actions is involved in the computation",
    ". this requires ever increasing computational effort as the agent proceeds , so that this concept does not scale up well to long - term agent control .    having an explicit state representation as a fundamental concept , the fluent calculus  @xcite offers an alternative theory as the formal underpinnings for a high - level agent programming method . in this paper",
    ", we present the logic programming method flux ( for : _ ent eecutor _ ) for the design of intelligent agents that reason about their actions using the fluent calculus . a constraint logic program , flux comprises a method for encoding incomplete states along with a technique of updating these states according to a declarative specification of the elementary actions and sensing capabilities of an agent .",
    "atomic state knowledge is encoded in a list with a tail variable , which signifies the incompleteness of the state .",
    "negative and disjunctive state knowledge is encoded by _ constraints_.",
    "we present a set of constraint handling rules ( chrs )  @xcite for combining and simplifying these constraints . in turn , these rules reduce to standard finite domain constraints when handling variable arguments of individual state components . appealing to their declarative interpretation ,",
    "our chrs are verified against the foundational axioms of the fluent calculus .    with its powerful constraint solver ,",
    "the underlying flux kernel provides general reasoning facilities , so that the agent programmer can focus on specifying the application domain and designing the high - level behavior . allowing for concise programs and supporting modularity",
    ", our method promises to be eminently suitable for programming complex strategies for artificial agents .",
    "thanks to a restricted expressiveness and a sound but incomplete inference engine , reasoning in flux is linear in the size of the internal state representation .",
    "flux therefore exhibits excellent computational behavior .",
    "thanks to the progression principle , flux scales up particularly well to long - term control .    the paper is organized as follows : in section  [ s : fc ] , we recapitulate the basic notions and notations of the fluent calculus as the underlying theory for an lp - based approach to reasoning about actions . in section  [ s :",
    "chr ] , we present a set of chrs for constraints expressing negative and disjunctive state knowledge .",
    "we prove their correctness wrt.the foundational axioms of the fluent calculus . in section  [ s : update ] , the constraint solver is embedded into a logic program for reasoning about actions , which , too , is verified against the underlying semantics of the fluent calculus . in section  [",
    "s : knowledge ] , we integrate state knowledge and sensing into flux .",
    "an example of a flux agent program is given in section  [ s : cleanbot ] , in which we also present the results of experiments showing the computational merits of our approach .",
    "we conclude in section  [ s : disc ] .",
    "the constraint solver , the general flux system , and the example agent program are available for download at our web site www.fluxagent.org .",
    "( 89,42)(0,1 ) ( 2,5)(35,35 ) ( 2,12)(0,7)4(1,0)2.5 ( 6.5,19)(0,7)3(1,0)5 ( 6.5,12)(1,0)2.5 ( 13.5,19)(0,7)3(1,0)5 ( 16,12)(1,0)2.5 ( 20.5,12)(1,0)5 ( 20.5,19)(0,7)3(1,0)2.5 ( 27.5,12)(1,0)5 ( 30,19)(0,7)3(1,0)2.5 ( 34.5,12)(0,7)4(1,0)2.5    ( 9,5)(7,0)4(0,1)2.5 ( 9,9.5)(7,0)3(0,1)2.5 ( 30,9.5)(0,1)5 ( 9,19)(7,0)3(0,1)2.5 ( 30,16.5)(0,1)5 ( 9,23.5)(7,0)4(0,1)5 ( 9,30.5)(7,0)3(0,1)2.5 ( 30,30.5)(0,1)5 ( 30,37.5)(0,1)2.5    ( 5.5,3)(0,0)@xmath0 ( 12.5,3)(0,0)@xmath1 ( 19.5,3)(0,0)@xmath2 ( 26.5,3)(0,0)@xmath3 ( 33.5,3)(0,0)@xmath4    ( 0,8.5)(0,0)@xmath0 ( 0,15.5)(0,0)@xmath1 ( 0,22.5)(0,0)@xmath2 ( 0,29.5)(0,0)@xmath3 ( 0,36.5)(0,0)@xmath4    ( 5.5,29.5)(0,0 ) ( 19.5,8.5)(0,0 ) ( 19.5,22.5)(0,0 ) ( 33.5,22.5)(0,0 )    ( 4,6)(3,2.5 ) ( 4.5,6 ) ( 6.5,6 ) ( 5.5,8.5 )    ( 54,5)(35,35 ) ( 54,12)(0,7)4(1,0)2.5 ( 58.5,19)(0,7)3(1,0)5 ( 58.5,12)(1,0)2.5 ( 65.5,19)(0,7)3(1,0)5 ( 68,12)(1,0)2.5 ( 72.5,12)(1,0)5 ( 72.5,19)(0,7)3(1,0)2.5 ( 79.5,12)(1,0)5 ( 82,19)(0,7)3(1,0)2.5 ( 86.5,12)(0,7)4(1,0)2.5    ( 61,5)(7,0)4(0,1)2.5 ( 61,9.5)(7,0)3(0,1)2.5 ( 82,9.5)(0,1)5 ( 61,19)(7,0)3(0,1)2.5 ( 82,16.5)(0,1)5 ( 61,23.5)(7,0)4(0,1)5 ( 61,30.5)(7,0)3(0,1)2.5 ( 82,30.5)(0,1)5 ( 82,37.5)(0,1)2.5    ( 57.5,3)(0,0)@xmath0 ( 64.5,3)(0,0)@xmath1 ( 71.5,3)(0,0)@xmath2 ( 78.5,3)(0,0)@xmath3 ( 85.5,3)(0,0)@xmath4    ( 52,8.5)(0,0)@xmath0 ( 52,15.5)(0,0)@xmath1 ( 52,22.5)(0,0)@xmath2 ( 52,29.5)(0,0)@xmath3 ( 52,36.5)(0,0)@xmath4    ( 57.5,22.5)(0,0 ) ( 57.5,36.5)(0,0 ) ( 64.5,29.5)(0,0 ) ( 64.5,8.5)(0,0 ) ( 64.5,22.5)(0,0 ) ( 71.5,15.5)(0,0 ) ( 71.5,29.5)(0,0 ) ( 78.5,8.5)(0,0 ) ( 78.5,22.5)(0,0 ) ( 85.5,15.5)(0,0 ) ( 85.5,29.5)(0,0 )    throughout the paper , we will use the following example of an agent in a dynamic environment : consider a cleaning robot which , in the evening , has to empty the waste bins in the hallway and rooms of the floor of an office building .",
    "the robot shall not , however , disturb anyone working in late .",
    "it is equipped with a light sensor which is activated whenever the robot is adjacent to a room that is occupied , without indicating which direction the light comes from .",
    "an instance of this problem is depicted in figure  [ f : crp ] .",
    "the robot can perform three basic actions , namely , cleaning the current location , turning clockwise by  @xmath5  degrees , and moving forward in the current direction to the adjacent cell .",
    "our task is to program the `` cleanbot '' to empty as many bins as possible without risking to burst into an occupied office .",
    "this problem illustrates two challenges raised by incomplete state knowledge : agents have to act cautiously , and they need to interpret and logically combine sensor information acquired over time .",
    "the fluent calculus is an axiomatic theory of actions that provides the formal underpinnings for agents to reason about their actions  @xcite .",
    "formally , it is a many - sorted predicate logic language which includes the two standard sorts of a fluent ( i.e. , an atomic state property ) and a state . for the cleaning robot domain , for example",
    ", we will use these four fluents ( i.e. , mappings into the sort @xmath6 ) : @xmath7 , representing that the robot is at  @xmath8 ; @xmath9 , representing that the robot faces direction  @xmath10 ( denoting , respectively , north , east , south , and west ) ; @xmath11 , representing that the waste bin at  @xmath12 has been emptied ; and @xmath13 , representing that  @xmath12 is occupied .",
    "we make the standard assumption of uniqueness - of - names , @xmath14\\!$].\\ ,    { { \\,\\stackrel{\\mbox{\\rm\\tiny def}}{=}\\,}}\\,\\bigwedge_{i < j } h_i(\\vec x)\\not = h_j(\\vec y)\\,\\wedge\\ ,    \\bigwedge_{i}[h_i(\\vec x)=h_i(\\vec y){\\supset}\\vec x=\\vec y]\\!$ ] . ]",
    "states are built up from fluents ( as atomic states ) and their conjunction , using the binary function @xmath15 along with the constant @xmath16 denoting the empty state .",
    "for example , the term @xmath17 represents a state in which the robot is in square @xmath18 facing north while other fluents may hold , too , summarized in the variable sub - state  @xmath19 . ''",
    "is written in infix notation . throughout the paper , free variables in formulas",
    "are assumed universally quantified .",
    "variables of sorts @xmath20 and @xmath21 shall be denoted , respectively , by the letters  @xmath22 and @xmath19 . ]",
    "a fundamental notion is that of a fluent  @xmath22 to _ hold _ in a state  @xmath19 . for notational convenience ,",
    "the macro @xmath23 serves as an abbreviation for an equational formula which says that  @xmath24 can be decomposed into @xmath22 and some state  @xmath25 : @xmath26 this definition is accompanied by the following foundational axioms of the fluent calculus , which ensure that a state can be identified with the fluents that hold in it .",
    "[ d : fstate ] assume a signature which includes the sorts @xmath20 and @xmath21 such that @xmath20 is a sub - sort of @xmath27 , along with the functions @xmath28 of sorts as above .",
    "foundational axioms @xmath29 of the fluent calculus _ are :    1 .",
    "associativity and commutativity , @xmath30 2 .",
    "empty state axiom , @xmath31 3 .",
    "irreducibility and decomposition , @xmath32 4 .",
    "state equivalence and existence of states , @xmath33 where @xmath34 is a second - order predicate variable of sort @xmath6 .",
    "axioms  ( [ e : ac])([e : decomp ] ) essentially characterize  `` @xmath35 '' as the union operation with  @xmath36 as the empty set of fluents .",
    "associativity allows us to omit parentheses in nested applications of  `` @xmath35 '' .",
    "axiom  ( [ e : stateequiv ] ) says that two states are equal if they contain the same fluents , and second - order axiom  ( [ e : stateexistence ] ) guarantees the existence of a state for any combination of fluents . '' to be non - idempotent @xcite , so that , e.g. , @xmath37 . since this is against the intuition of  `` @xmath35 '' as a reified logical conjunction ,",
    "the new axiomatization , first used in  @xcite , is no longer based on non - idempotence .",
    "in fact , foundational axiom  ( [ e : stateequiv ] ) along with  ( [ e : decomp ] ) and associativity implies that @xmath38 for any  @xmath19 . ]    the foundational axioms of the fluent calculus can be used to draw conclusions from incomplete state specifications and acquired sensor information .",
    "consider , e.g. , the definition of what it means for our cleaning robot to sense light at a location @xmath12 in some state  @xmath19 : @xmath39 suppose that at the beginning the only given unoccupied locations are : the home square of the robot ( axiom  ( [ e:11 ] ) below ) , the squares in the hallway ( axiom  ( [ e : alley ] ) below ) and any location outside the boundaries of the office floor ( axioms  ( [ e : boundx]),([e : boundy ] ) below ) .",
    "suppose further that the robot already went to clean  @xmath40 , @xmath41 , and @xmath42 , sensing light in the last square only ( cf .",
    "figure  [ f : crp ] ) .",
    "thus the current state ,  @xmath43 , satisfies @xmath44 for some @xmath19 , along with the following axioms : @xmath45 from ( [ e : nolight ] ) and ( [ e : lipe ] ) it follows @xmath46 . with regard to  ( [ e : zeta ] ) , the foundational axioms of decomposition  ( [ e : decomp ] ) and irreducibility  ( [ e : irred ] ) along with the axiom of uniqueness - of - names imply @xmath47 on the other hand , ( [ e : light ] ) and ( [ e : lipe ] ) imply @xmath48 again with regard to  ( [ e : zeta ] ) , the foundational axioms of decomposition and irreducibility along with the axiom of uniqueness - of - names imply @xmath49 from  ( [ e : boundy ] ) and  ( [ e : alley ] ) it follows that @xmath50 this disjunction can not be reduced further , that is , at this stage the robot can not decide whether the light in  @xmath51 comes from office  @xmath52 or  @xmath53 ( or both , for that matter ) .",
    "suppose , therefore , the cautious cleanbot goes back , turns east , and continues with cleaning  @xmath54 , which is a hallway location and therefore can not be occupied according to  ( [ e : alley ] ) .",
    "sensing no light there ( cf .",
    "figure  [ f : crp ] ) , the new state is @xmath55 for some @xmath24 that satisfies ( [ e:11])([e : boundy ] ) and  ( [ e : occ ] ) .",
    "we also know that @xmath56 .",
    "from  ( [ e : lipe ] ) , @xmath57 ; hence , decomposition and irreducibility along with the axiom of uniqueness - of - names imply @xmath58 ; hence , from  ( [ e : occ ] ) it follows @xmath59 , that is , now the robot can conclude that  @xmath53 is occupied .",
    "the axiomatic fluent calculus provides the formal underpinnings for an lp - based approach to reasoning about incomplete state specifications . to begin with ,",
    "incomplete states are encoded by open - ended lists of fluents ( possibly containing variables ) :    ....        z = [ f1, ... ,fk | _ ] ....    it is assumed that the arguments of fluents are encoded by integers or symbolic constants , which enables the use of a standard arithmetic solver for constraints on partially known arguments .",
    "negative and disjunctive state knowledge is expressed by the following _ state constraints _ :",
    "@xmath60,z ) : & \\,\\bigvee_{i=1}^n{{\\mbox{\\rm\\em holds\\/}}}(f_i , z ) \\\\ \\end{array}\\ ] ] these state constraints have been carefully designed so as to be sufficiently expressive while allowing for efficient constraint solving .",
    "an auxiliary constraint , written @xmath61 , is used to stipulate that a list of fluents contains no multiple occurrences . as an example",
    ", the following clause encodes the specification of state  @xmath62 of section  [ s : fc ] ( cf.axioms  ( [ e : zeta])([e : light ] ) ) :    ....    zeta(zeta ) : -      zeta = [ at(1,3),facing(1),cleaned(1,1),cleaned(1,2),cleaned(1,3 ) | z ] ,      not_holds(occupied(1,1 ) , z ) ,      not_holds(occupied(1,2 ) , z ) , ... , not_holds(occupied(4,5 ) , z ) ,",
    "not_holds_all(occupied(_,0 ) , z ) , not_holds_all(occupied(_,6 ) , z ) ,      not_holds_all(occupied(0 , _ ) , z ) , not_holds_all(occupied(6 , _ ) , z ) ,      duplicate_free(zeta ) ,      light(1 , 2 , false , zeta ) , light(1 , 3 , true , zeta ) . ....",
    "the auxiliary predicate @xmath63 defines under what circumstances there is light ( @xmath64 ) or no light ( @xmath65 ) in state  @xmath24 at square  @xmath12 ( cf .",
    "axiom  ( [ e : lipe ] ) ) .    ....",
    "light(x , y , percept , z ) : -      xe # = x+1 , xw # = x-1 , yn # = y+1 , ys # = y-1 ,      ( percept = false ,          not_holds(occupied(xe , y ) , z ) , not_holds(occupied(x , yn ) , z ) ,          not_holds(occupied(xw , y ) , z ) , not_holds(occupied(x , ys ) , z )        ; percept = true , or_holds([occupied(xe , y),occupied(x , yn ) ,                                    occupied(xw , y),occupied(x , ys ) ] , z ) ) . ....    here and in the following , we use the standard constraint language of finite domains ( see , e.g. ,  @xcite ) , which includes arithmetic constraints over the integers and symbolic constants , using the equality , inequality , and ordering predicates # = , # ` \\`= , # < , # > along with the arithmetic functions + , - , ; range constraints ( written x::@xmath66 ..",
    "@xmath67 ) ; and logical combinations using ` # /\\ ` and ` # \\/ ` for conjunction and disjunction , respectively .",
    "the state constraints are processed using constraint handling rules  @xcite .",
    "the general form of these rules is @xmath68 where the _ head _ @xmath69 is a sequence of constraints ( @xmath70 ) ; the _ guard _ @xmath71 is a sequence of prolog literals ( @xmath72 ) ; and the _ body _",
    "@xmath73 is a sequence of constraints or prolog literals ( @xmath74 ) .",
    "an empty guard is omitted ; the empty body is denoted by @xmath75 .",
    "the declarative interpretation of such a rule is given by the formula @xmath76\\,)\\ ] ] where @xmath77 are the variables in both guard and head and @xmath78 are the variables which additionally occur in the body .",
    "the procedural interpretation of a chr is given by a transition in a constraint store : if the head can be matched against elements of the constraint store and the guard can be derived , then the constraints which match the head are replaced by the body .      ....",
    "not_holds ( _ , [ ] )          < = > true .",
    "% 1     not_holds(f,[f1|z ] )      < = > neq(f , f1 ) , not_holds(f , z ) .",
    "% 2     not_holds_all ( _ , [ ] )      < = > true .",
    "% 3     not_holds_all(f,[f1|z ] ) < = > neq_all(f , f1 ) , not_holds_all(f , z ) .",
    "% 4       not_holds_all(f , z ) \\",
    "not_holds(g , z )      < = > instance(g , f ) | true .",
    "% 5     not_holds_all(f , z ) \\",
    "not_holds_all(g , z ) < = > instance(g , f ) | true .",
    "% 6       duplicate_free ( [ ] )",
    "< = > true .",
    "% 7     duplicate_free([f|z ] ) < = > not_holds(f , z ) , duplicate_free(z ) .",
    "% 8       neq(f , f1 )      : - or_neq(exists , f , f1 ) .",
    "neq_all(f , f1 ) : - or_neq(forall , f , f1 ) .",
    "or_neq(q , fx , fy ) : - fx = .. [ f|argx ] , fy = .. [ g|argy ] ,                        ( f = g - > or_neq(q , argx , argy , d ) , call(d ) ; true ) .",
    "or_neq(_,[],[],(0#\\=0 ) ) .",
    "or_neq(q,[x|x1],[y|y1],d ) : -       or_neq(q , x1,y1,d1 ) ,       ( q = forall , var(x ) - > ( binding(x , x1,y1,ye ) - >",
    "d=((y#\\=ye)#\\/d1 )                                                    ; d = d1 )                           ; d=((x#\\=y)#\\/d1 ) ) .",
    "binding(x,[x1|argx],[y1|argy],y ) : - x==x1 - > y = y1                                                ; binding(x , argx , argy , y ) .",
    "....    figure  [ f : chr1 ] depicts the first part of the constraint solver , which contains the chrs and auxiliary clauses for the two negation constraints and the constraint on multiple occurrences . in the following ,",
    "these rules are proved correct wrt .",
    "the foundational axioms of the fluent calculus .    to begin with ,",
    "consider the auxiliary clauses , which define a finite domain constraint that expresses the inequality of two fluent terms .",
    "by @xmath79 , inequality of two fluents with arguments @xmath80}$ ] and @xmath81}$ ] is decomposed into the arithmetic constraint @xmath82 .",
    "two cases are distinguished , depending on whether the variables in the first term are existentially or universally quantified . in the latter case ,",
    "a simplified disjunction is generated , where the variables of the first fluent are discarded while possibly giving rise to dependencies among the arguments of the second fluent .",
    "thus @xmath83 reduces to @xmath84 , and @xmath85 reduces to @xmath86 . to formally capture the universal quantification ,",
    "we define the notion of a _ schematic _",
    "fluent @xmath87 where @xmath77 denotes the variable arguments in  @xmath22 and @xmath88 the non - variable arguments .",
    "the following observation implies the correctness of the constraints generated by the auxiliary clauses .",
    "[ o : neq ] consider a set @xmath89 of functions into sort @xmath6 , a fluent @xmath90 , a schematic fluent @xmath91 , and a fluent @xmath92 .",
    "let @xmath93 and @xmath94 , then    1 .   if @xmath95 , then @xmath96\\,\\models\\,{{\\mbox{\\rm\\em neq\\/}}}(f_1,f)$ ] and @xmath96\\,\\models\\,{{\\mbox{\\rm\\em neqall\\/}}}(f_2,f)\\!$ ] ; 2 .   if @xmath97 , then @xmath98 , and @xmath96 $ ] entails @xmath99\\vee              r_{k+1}\\not = t_{k+1}\\vee\\ldots\\vee r_m\\not = t_n\\vee 0\\not=0            \\end{array}\\ ] ]    chrs  14 in figure  [ f : chr1 ] , by which negation constraints are propagated , are then justified  on the basis of their declarative interpretation  by the foundational axioms of the fluent calculus .",
    "[ p : not_holds ] foundational axioms",
    "@xmath29 entail    1 .",
    "@xmath100 ; and 2 .",
    "@xmath101 .    likewise ,",
    "if @xmath102 is a schematic fluent , then @xmath29 entails    1 .",
    "@xmath103 ; and 2 .",
    "@xmath104 .",
    "claim  1 follows by the empty state axiom . for claim  2",
    "we prove that @xmath105 iff @xmath106 .",
    "the `` @xmath107 '' direction follows by the foundational axioms of decomposition and irreducibility .",
    "for the `` @xmath108 '' direction , suppose @xmath109 , then @xmath110 , hence @xmath111 .",
    "likewise , suppose @xmath112 , then @xmath113 for some  @xmath114 , hence @xmath115 , hence @xmath111 .",
    "the proof of  3 and  4 is similar .",
    "chrs 5 and  6 , by which subsumed negative constraints are removed , are correct since @xmath116 implies both @xmath117 and @xmath118 , where @xmath119 is a schematic fluent and @xmath120 is a fluent such that @xmath121 for some  @xmath122 .",
    "finally , chrs  7 and  8 for the auxiliary constraint on multiple occurrences are correct since the empty list contains no duplicate elements and a non - empty list contains no duplicates iff the head does not occur in the tail and the tail itself is free of duplicates .      ....",
    "or_holds([f],z ) < = > f\\=eq ( _ , _ )",
    "| holds(f , z ) .",
    "% 9    or_holds(v , z )    < = > \\+(member(f , v),f\\=eq ( _ , _ ) ) | or_and_eq(v , d ) ,      % 10                                                     call(d ) .                    or_holds(v , [ ] )",
    "< = > member(f , v , w ) , f\\=eq ( _ , _ )",
    "| or_holds(w , [ ] ) .",
    "% 11      or_holds(v , z ) < = > member(eq(x , y),v ) ,                                  % 12                      or_neq(exists , x , y , d ) , \\+ call(d ) | true .",
    "or_holds(v , z ) < = > member(eq(x , y),v , w ) ,                                % 13                      \\+ ( and_eq(x , y , d ) , call(d ) ) | or_holds(w , z ) .",
    "not_holds(f , z )      \\",
    "or_holds(v , z ) < = > member(g , v , w ) ,                 % 14                                           f==g           | or_holds(w , z ) .    not_holds_all(f , z ) \\ or_holds(v ,",
    "z ) < = > member(g , v , w ) ,                 % 15                                           instance(g , f ) | or_holds(w , z ) .",
    "or_holds(v,[f|z ] )         < = > or_holds(v,[],[f|z ] ) .",
    "% 16    or_holds([f1|v],w,[f|z ] ) < = > f1==f - > true ;                          % 17                                 f1\\=f - > or_holds(v,[f1|w],[f|z ] ) ;                                 f1= .. [_|argx ] , f= .. [_|argy ] ,                                  or_holds(v,[eq(argx , argy),f1|w],[f|z ] ) .",
    "or_holds([],w,[_|z ] )      < = > or_holds(w , z ) .",
    "% 18      and_eq([],[],(0#=0 ) ) .",
    "and_eq([x|x1],[y|y1],d ) : - and_eq(x1,y1,d1 ) , d=((x#=y)#/\\d1 ) .",
    "or_and_eq([],(0#\\=0 ) ) .",
    "or_and_eq([eq(x , y)|eq],(d1#\\/d2 ) ) : - or_and_eq(eq , d1 ) , and_eq(x , y , d2 ) .",
    "member(x,[x|t],t ) .",
    "member(x,[h|t],[h|t1 ] ) : - member(x , t , t1 ) .",
    "....    figure  [ f : chr2 ] depicts the second part of the constraint solver , which contains the chrs and auxiliary clauses for disjunctive state knowledge .",
    "the solver employs an extended notion of a disjunctive clause , where each disjunction may include atoms of the form @xmath123 in addition to fluents .",
    "the meaning of such a general disjunctive constraint @xmath124,z)$ ] is @xmath125 this generalization is needed for propagating disjunctions with variables through compound states .",
    "consider , as an example , @xmath126,[f(y)|z])\\!$ ] .",
    "this constraint will be rewritten to @xmath127,[y]),f(1),{{\\mbox{\\rm\\em eq\\/}}}([x],[y]),f(x)],z)\\!$ ] , in accordance with the fact that @xmath128 $ ] entails @xmath129 which follows by the foundational axioms of irreducibility and decomposition .",
    "chr  9 in figure  [ f : chr2 ] simplifies a singleton disjunction according to  ( [ e : or ] ) .",
    "chr  10 reduces a pure equational disjunction to a finite domain constraint .",
    "its correctness follows directly from  ( [ e : or ] ) , too .",
    "chr  11 simplifies a disjunction applied to the empty state .",
    "it is justified by the empty state axiom , which entails @xmath130\\,{\\equiv}\\,\\psi\\ ] ] for any formula  @xmath131 .",
    "chrs  12 and  13 deal with disjunctions which include an equality which is either true under any variable assignment , or false .",
    "if the former , then the entire disjunction is true .",
    "if , on the other hand , the equality is necessarily false , then it is removed from the disjunction .",
    "correctness follows from @xmath132    \\ \\ \\ \\mbox{and}\\ \\ \\",
    "y\\,{\\supset}\\,[(\\vec x=\\vec y\\vee\\psi)\\,{\\equiv}\\,\\psi]\\ ] ] the next two chrs are unit resolution steps : rule  14 says that if a fluent  @xmath22 does not hold , then any disjunction that contains an equal fluent  @xmath133 can be reduced by  @xmath134 .",
    "rule  15 generalizes this to universally quantified negation constraints .",
    "the two chrs are justified , respectively , by @xmath135 \\\\    ( \\forall \\vec x)\\,\\neg{{\\mbox{\\rm\\em holds\\/}}}(f , z ) & \\!\\!\\!{\\supset}\\!\\!\\ ! &      [ ( { { \\mbox{\\rm\\em holds\\/}}}(g , z)\\vee\\psi)\\,{\\equiv}\\,\\psi]\\ \\ \\ \\ \\mbox{if}\\ f\\theta = g\\        \\mbox{for some}\\ \\theta \\end{array}\\ ] ] where @xmath77 are the variables in  @xmath136 .",
    "the last group of chrs , 1618 , encode the propagation of a disjunction through a compound state .",
    "informally speaking , each element in the disjunct is compared to the head of the state and , if the two are unifiable , the respective equational constraint is introduced into the disjunction .",
    "specifically , with the help of the auxiliary ternary constraint @xmath137)\\!$ ] , a disjunction is divided into two parts .",
    "list  @xmath138 contains the fluents that have not yet been evaluated against the head  @xmath22 of the state .",
    "list  @xmath139 contains those fluents that have been evaluated .",
    "thus the meaning of a ternary expression @xmath140)$ ] is @xmath141)\\,\\vee\\,{{\\mbox{\\rm\\em orholds\\/}}}(\\delta_2,z)\\ ] ] in the special case that disjunction  @xmath142 contains a fluent  @xmath119 which is identical to the head  @xmath22 of the state , disjunction  ( [ e : or3 ] ) is necessarily true and , hence , is resolved to @xmath143 by chr  17 .",
    "otherwise , any fluent @xmath119 in  @xmath142 which does not unify with  @xmath22 is propagated without inducing an equality .",
    "any fluent @xmath119 which does unify with @xmath22 extends the disjunction by the equality of the arguments of @xmath119 and @xmath136 .",
    "recall , for example , the constraint @xmath126,[f(y)|z])$ ] mentioned earlier , which is propagated thus : @xmath144,[f(y)|z ] ) \\\\",
    "\\stackrel{\\mbox{\\scriptsize\\tt\\%16}}{\\longrightarrow}\\!\\ ! &    { { \\mbox{\\rm\\em orholds\\/}}}([f(x),f(1)],[\\,],[f(y)|z ] )",
    "\\\\    \\stackrel{\\mbox{\\scriptsize\\tt\\%17}}{\\longrightarrow}\\!\\ ! &    { { \\mbox{\\rm\\em orholds\\/}}}([f(1)],[{{\\mbox{\\rm\\em eq\\/}}}([x],[y]),f(x)],[f(y)|z ] )",
    "\\\\    \\stackrel{\\mbox{\\scriptsize\\tt\\%17}}{\\longrightarrow}\\!\\ ! &    { { \\mbox{\\rm\\em orholds\\/}}}([\\,],[{{\\mbox{\\rm\\em eq\\/}}}([1],[y]),f(1),{{\\mbox{\\rm\\em eq\\/}}}([x],[y]),f(x)],[f(y)|z ] )",
    "\\\\    \\stackrel{\\mbox{\\scriptsize\\tt\\%18}}{\\longrightarrow}\\!\\ ! &    { { \\mbox{\\rm\\em orholds\\/}}}([{{\\mbox{\\rm\\em eq\\/}}}([1],[y]),f(1),{{\\mbox{\\rm\\em eq\\/}}}([x],[y]),f(x)],z ) \\end{array}\\ ] ]    the three rules for propagating a disjunction are justified by the following proposition , where item  1 is for chr  16 , items  24 are for the three cases considered in chr  17 , and item  5 is for chr  18 .",
    "consider a fluent calculus signature with a set @xmath89 of functions into sort @xmath6 .",
    "foundational axioms @xmath29 and uniqueness - of - names @xmath96 $ ] entail each of the following , where @xmath145 is of the form @xmath146)$ ] and @xmath147 is of the form @xmath148 :    1 .",
    "@xmath149,z)]\\!$ ] ; 2 .",
    "@xmath150\\vee\\psi_2\\,{\\equiv}\\,\\top\\!$ ] ; 3 .",
    "@xmath151             \\vee\\psi_2\\,{\\equiv}\\,\\psi_1\\vee[{{\\mbox{\\rm\\em holds\\/}}}(f_1,z)\\vee\\psi_2]\\,)\\!$ ] ; 4 .",
    "@xmath152             \\vee\\psi_2\\,{\\equiv}\\,\\psi_1\\vee[\\vec x=\\vec y\\,\\vee             { { \\mbox{\\rm\\em holds\\/}}}(f(\\vec x),z)\\vee\\psi_2]\\!$ ] ; 5 .",
    "@xmath153,[f|z])\\,\\vee\\,\\psi_2]\\,{\\equiv}\\,\\psi_2\\!$ ] .",
    "claims  1 and  5 are obvious .",
    "claim  2 follows by the definition of @xmath154 .",
    "claims  3 and  4 follow from the foundational axioms of decomposition and irreducibility along with @xmath96\\!$ ] .",
    "the constraint solver constitutes a system for automated reasoning about incomplete states and sensor information . as an example , evaluating the specification from the beginning of section  [ s : chr ] results in    ....   ? - zeta(zeta ) .",
    "zeta=[at(1,3),facing(1),cleaned(1,1),cleaned(1,2),cleaned(1,3 ) | z ]     constraints :   or_holds([occupied(1,4),occupied(2,3 ) ] , z )   ... ....    light at  @xmath51 thus implies that @xmath53 or @xmath52 is occupied , but it does not follow which of the two . adding the information that there is no light in  @xmath54 , the system is able to infer that @xmath53 must be occupied :    ....   ? - zeta(zeta ) , light(2 , 2 , false , zeta ) .",
    "zeta=[at(1,3),facing(1),cleaned(1,1),cleaned(1,2),cleaned(1,3 ) ,         occupied(1,4 ) | z ]     constraints :   not_holds(occupied(2,3 ) , z )   ... ....    although the chrs in the flux constraint system are correct , they may not enable agents to draw all conclusions that follow logically from a state specification if the underlying arithmetic solver trades full inference capabilities for efficiency . in standard implementations",
    "this is indeed the case , because a conjunction or a disjunction is simplified only if one of its equations or disequations is either necessarily true or necessarily false . as a crucial advantage of these concessions",
    "we have designed an efficient inference system : the computational effort of evaluating a new constraint is _ linear _ in the size of the constraint store .",
    "in this section , we embed our constraint solver into a logic program for reasoning about the effects of actions based on the fluent calculus . generalizing previous approaches  @xcite",
    ", the fluent calculus provides a solution to the fundamental frame problem in the presence of incomplete states  @xcite .",
    "the key is a rigorously axiomatic characterization of addition and removal of ( finitely many ) fluents from incompletely specified states .",
    "the following inductive definition introduces the macro equation @xmath155 with the intended meaning that state  @xmath156 is state  @xmath157 minus the fluents in the finite state  @xmath158 : @xmath159 the crucial item is the second one , which defines removal of a single fluent @xmath22 using a case distinction : either @xmath160 equals @xmath157 ( which applies in case @xmath161 ) , or @xmath160 plus @xmath22 equals @xmath162 ( which applies in case @xmath163 ) .",
    "a further macro @xmath164 means that state  @xmath156 is state  @xmath157 minus the fluents in @xmath165 plus the fluents in @xmath166 : @xmath167 where both @xmath168 are finitely many @xmath20 terms connected by  `` @xmath35 '' .    ....",
    "holds(f,[f| _ ] ) .",
    "holds(f , z ) : - nonvar(z ) , z=[f1|z1 ] , f\\==f1 , holds(f , z1 ) .",
    "holds(f,[f|z],z ) .",
    "holds(f , z,[f1|zp ] ) : - nonvar(z ) , z=[f1|z1 ] , f\\==f1 , holds(f , z1,zp ) .",
    "minus(z,[],z ) .",
    "minus(z,[f|fs],zp ) : - ( \\+ not_holds(f , z ) - > holds(f , z , z1 ) ;                             \\+ holds(f , z )      - > z1 = z ;                             cancel(f , z , z1 ) , not_holds(f , z1 ) ) ,                           minus(z1,fs , zp ) .",
    "plus(z,[],z ) .",
    "plus(z,[f|fs],zp ) : - ( \\+ holds(f , z )      - > z1=[f|z ] ;                            \\+ not_holds(f , z ) -",
    "> z1=z ;                            cancel(f , z , z2 ) , z1=[f|z2 ] , not_holds(f , z2 ) ) ,                          plus(z1,fs , zp ) .",
    "update(z1,thetap , thetan , z2 ) : - minus(z1,thetan , z ) , plus(z , thetap , z2 ) .",
    "....    figure  [ f : flux ] depicts a set of clauses which encode the solution to the frame problem on the basis of the constraint solver for the fluent calculus .",
    "the program culminates in the predicate @xmath169 , by which an incomplete state  @xmath157 is updated to  @xmath156 by positive and negative effects @xmath170 and @xmath158 , respectively , according to macro  ( [ e : pm ] ) .",
    "the first two clauses in figure  [ f : flux ] encode macro  ( [ e : holds ] ) .",
    "correctness of this definition follows from the foundational axioms of decomposition and irreducibility .",
    "the ternary @xmath171 means @xmath172 .",
    "the following proposition implies that the corresponding clauses are correct wrt .  the macro definition of fluent removal , under the assumption that lists of fluents are free of duplicates .",
    "axioms @xmath173 entail @xmath174    we distinguish two cases .",
    "suppose @xmath109 , then @xmath23 since @xmath175 .",
    "if @xmath176 , then @xmath177 since @xmath175 ; hence , @xmath178 since @xmath179 .",
    "conversely , if @xmath180 , then @xmath181 .",
    "suppose @xmath182 .",
    "if @xmath23 and @xmath176 , then @xmath183 and @xmath184 ; hence , there is some  @xmath185 such that @xmath186 and @xmath187 .",
    "conversely , if @xmath188 , then @xmath189 and @xmath184 ; hence , @xmath172 .",
    "removal and addition of finitely many fluents is defined recursively in figure  [ f : flux ] . the recursive clause for @xmath190 says that if @xmath191 is unsatisfiable ( that is , @xmath22 is known to hold in  @xmath19 ) , then subtraction of  @xmath22 is given by the definition of the ternary @xmath192 predicate . otherwise , if @xmath23 is unsatisfiable ( that is , @xmath22 is known to be false in  @xmath19 ) , then @xmath193 equals @xmath19 . if , however , the status of the fluent is not entailed by the state specification at hand for  @xmath24 , then partial information of  @xmath22 in @xmath194 may not transfer to the resulting state @xmath193 and , hence , needs to be cancelled .",
    "consider , for example , the partial state specification @xmath195\\ ] ] this formula does not entail @xmath196 nor @xmath197 .",
    "so what can be inferred about the state @xmath198 ?",
    "macro expansion of `` @xmath199 '' implies that @xmath29 and @xmath200 entail @xmath201 .",
    "but it does not follow whether @xmath202 holds in @xmath162 , nor whether @xmath203 does , because @xmath204}\\ \\wedge \\\\    { [ \\,y\\not = a\\,{\\supset}\\,{{\\mbox{\\rm\\em holds\\/}}}(f(y),z_1)\\,]\\ \\wedge } \\\\",
    "{ [ \\,\\neg{{\\mbox{\\rm\\em holds\\/}}}(f(b),z)\\,{\\supset}\\,\\neg{{\\mbox{\\rm\\em holds\\/}}}(f(b),z_1)\\,]}\\ \\wedge \\\\    { [ \\,{{\\mbox{\\rm\\em holds\\/}}}(f(b),z)\\,{\\supset}\\,{{\\mbox{\\rm\\em holds\\/}}}(f(b),z_1)\\ , ] } \\end{array}\\ ] ]    for this reason , all partial information concerning  @xmath22 in the current state  @xmath24 is cancelled in the clause for @xmath190 prior to asserting that @xmath22 does not hold in the resulting state .",
    "the definition of cancellation of a fluent  @xmath22 is given in figure  [ f : cancel ] as an extension of our system of chrs .",
    "in the base case , all negative and disjunctive state information affected by  @xmath22 is resolved via the constraint @xmath205 .",
    "the latter in turn is resolved by the auxiliary constraint @xmath206 , indicating that @xmath24 contains no ( more ) state knowledge which is affected by  @xmath136 . in the recursive clause for @xmath207 ,",
    "each atomic , positive state information that unifies with  @xmath22 is cancelled .    ....",
    "cancel(f , z1,z2 ) : -         var(z1 ) - > cancel(f , z1 ) , cancelled(f , z1 ) , z2=z1         ;         z1=[g|z ] , ( f\\=g - > cancel(f , z , z3 ) , z2=[g|z3 ]                     ;                     cancel(f , z , z2 ) ) .",
    "cancel(f , z ) \\",
    "not_holds(g , z )      < = >               \\+",
    "f\\=g | true .",
    "cancel(f , z ) \\ not_holds_all(g ,",
    "z ) < = >               \\+",
    "f\\=g | true .",
    "cancel(f , z ) \\",
    "or_holds(v , z )       < = > member(g , v ) , \\+ f\\=g | true .",
    "cancel(f , z ) , cancelled(f , z ) < = > true . ....    in a similar fashion , the recursive clause for @xmath208 in figure  [ f : flux ] says that if @xmath23 is unsatisfiable ( that is , @xmath22 is known to be false in  @xmath19 ) , then @xmath22 is added to  @xmath19 ; otherwise , if @xmath191 is unsatisfiable ( that is , @xmath22 is known to hold in  @xmath19 ) , then @xmath209 equals @xmath19 . if the status of the fluent is not entailed by the state specification at hand for  @xmath24 , then all partial information about  @xmath22 in  @xmath24 is cancelled prior to adding @xmath22 to the state and asserting that @xmath22 does not hold in the tail .",
    "the definitions for @xmath190 and @xmath208 imply that a fluent to be removed or added does not hold or hold , respectively , in the resulting state .",
    "moreover , cancellation does not affect the parts of the state specification which do not unify with the fluent in question . hence",
    ", these parts continue to hold in the state resulting from the update .",
    "the correctness of this encoding of update follows from the macros for `` @xmath199 '' and `` @xmath210 '' , which imply that a fluent holds in the updated state just in case it either holds in the original state and is not subtracted , or it is added .",
    "in this section , we extend our basic programming system so as to enable agents to reason about what they know and to infer the results of actions involving sensor information .",
    "reasoning about knowledge is necessary for agents with incomplete information , as they need to select actions according to what they know of the state of the environment .",
    "the formal concept of state knowledge also allows to specify the effects of sensing actions , which , rather than affecting the state itself , provide the agent with more information about it .",
    "adopted from the situation calculus  @xcite , the two standard sorts @xmath211 and @xmath212 ( i.e. , situations ) are used in the fluent calculus to represent , respectively , actions and sequences of actions .",
    "action sequences are rooted in an initial situation , usually denoted by the constant  @xmath213 . the pre - defined function",
    "@xmath214 maps an action and a situation into the situation after the action .",
    "the function symbol @xmath215 is unique to the fluent calculus and links the two key notions of a state and a situation : @xmath216 denotes the state in situation  @xmath217 .",
    "inspired by a model of knowledge in the situation calculus  @xcite , the predicate @xmath218 has been introduced in @xcite .",
    "an instance @xmath219 means that , according to the knowledge of the agent , @xmath24 is a possible state in situation  @xmath217 . as an example , recall the initial state of our cleaning robot as depicted in figure  [ f : crp ] . for the sake of argument",
    ", suppose that the robot is told it would perceive light in  @xmath42 .",
    "the initial knowledge of the cleanbot can then be specified by the following axiom , which defines the _ knowledge state _ in situation  @xmath220 : @xmath221 that is to say , initially possible are all states in which the robot is at a unique position , viz .",
    "@xmath40 , facing a unique direction , viz .",
    "north ( @xmath222 ) , and neither  @xmath18 nor any square in the hallway or outside the boundaries can be occupied .",
    "the possible states are further constrained by the knowledge that there is light at  @xmath42 . on the other hand",
    ", the agent has no further prior knowledge as to which offices are occupied or if any location is cleaned .",
    "a universal property of knowledge is that it is correct . to this end",
    ", a simple foundational axiom stipulates that the actual state is always among the possible ones :    [ d : fknows ] the _ foundational axioms of the fluent calculus for knowledge _ are @xmath29 as in definition  [ d : fstate ] ( cf .",
    "section  [ s : fc ] ) augmented by @xmath223    based on the notion of possible states , a fluent is known to hold in a situation ( or not to hold ) just in case it is true ( false , respectively ) in all possible states in that situation : @xmath224 for example , the axiomatization of the initial knowledge ,  ( [ e : kstate0 ] ) , entails that the cleanbot knows it is at  @xmath18 not facing east , that is , @xmath225 on the other hand , the cleanbot does not know that office  @xmath53 is occupied : @xmath226 this is so because there is a possible state  @xmath227 which satisfies the right hand side of the equivalence in  ( [ e : kstate0 ] ) and in which @xmath228 does not hold .    a supplementary macro defines knowledge of a value of a fluent .",
    "an agent has this knowledge just in case a particular instance of the fluent in question is known : @xmath229 where @xmath230 are the variables in  @xmath22 besides  @xmath231 , and @xmath232 stands for the formula @xmath233 . for example , the axiomatization of the initial knowledge entails that the cleanbot knows which direction it faces , @xmath234 on the other hand , although it knows that some office must be occupied , i.e. , @xmath235 the cleanbot does not know which one , @xmath236 this is so because there exists a possible state  @xmath227 which satisfies the right hand side of the equivalence in  ( [ e : kstate0 ] ) and in which @xmath228 is the only positive instance of this fluent ; and there also exists a possible state in which a different one , viz.@xmath237 , is the only positive instance of this fluent .    while the definitions of knowledge by macros  ( [ e : knows ] ) and  ( [ e : kval ] ) are similar to the approach in the situation calculus  @xcite , a crucial difference is that the latter defines knowledge in terms of possible _",
    "situations_. to this end , the binary relation @xmath238 is used with the intuitive meaning that as far as the agent knows in situation  @xmath217 , it could as well be in situation  @xmath239 .",
    "this allows for a nested definition of @xmath240 , which provides a form of introspection that is not supported in the fluent calculus . on the other hand",
    ", the full expressiveness of modal logic is computationally demanding .",
    "the notion of possible states allows for a straightforward and  based on the results of the previous sections ",
    "tractable implementation of knowledge , which is crucial for practical purposes .",
    "we refer to  @xcite for a more detailed comparison between the two approaches .",
    "the concept of knowing properties of the state is essential for the evaluation of conditions in agent programs under incomplete information . by definition",
    ", a property is known just in case it is true in all possible states . from a computational perspective , it is of course impractical to evaluate a condition by literally checking every possible state , since there is usually quite a number , often even infinitely many of them",
    ". fortunately , our constraint solver provides a feasible alternative . instead of verifying that all states satisfy a property",
    ", we can just as well prove that the _ negation _ of the property is _ unsatisfiable _ under a given knowledge state .",
    "this suggests an elegant way of encoding knowledge in flux using the principle of negation - as - failure . to begin with ,",
    "a knowledge state @xmath241 is identified with the ( incomplete ) state specification @xmath242 .",
    "then a fluent  @xmath22 is known in situation  @xmath243 iff the axiom set @xmath244 is unsatisfiable .",
    "likewise , @xmath22 is known to be false in situation  @xmath243 iff @xmath245 is unsatisfiable .",
    "[ t : knowledge ] let @xmath241 be a knowledge state and @xmath22 a fluent , then @xmath246 and @xmath247    @xmath248 the proof of the second part is similar .",
    "knows(f , z ) : - \\+ not_holds(f , z ) .",
    "knows_not(f , z ) : - \\+ holds(f , z ) .",
    "knows_val(x , f , z ) : - k_holds(f , z ) , \\+ nonground(x ) .",
    "k_holds(f , z ) : - nonvar(z ) , z = [ f1|z1 ] ,                          ( instance(f1 , f ) , f = f1 ; k_holds(f , z1 ) ) . ....",
    "this result is a formal justification of concluding knowledge of  @xmath22 if the constraint solver derives an inconsistency upon asserting state constraint @xmath191 under state specification @xmath242 .",
    "figure  [ f : knowledge ] shows how this is realized in flux by clauses for @xmath249 and @xmath250 as well as for knowing a value of a fluent .",
    "more complex knowledge expressions , such as disjunctive knowledge , can be defined and encoded in a similar fashion .",
    "the clausal definition of @xmath251 uses the auxiliary predicate @xmath252 , which _ matches _ the fluent expression  @xmath22 against all fluents that positively occur in state  @xmath19 . if so doing grounds all variables in  @xmath231 , then a value for these variables is known .",
    "recall , for example , the flux state specification at the beginning of section  [ s : chr ] , encoding state specification  ( [ e : zeta])([e : light ] ) .",
    "we can use flux to show that the robot knows that room  @xmath51 is not occupied , while it does not know that office  @xmath53 is free , nor that it is not so :    ....     ? - zeta(zeta ) ,        knows_not(occupied(1,3 ) , zeta ) ,        \\+ knows(occupied(1,4 ) , zeta ) ,         \\+ knows_not(occupied(1,4 ) , zeta ) .",
    "....    as an example for the flux definition of knowing a value , consider this incomplete state specification :    ....     init(z0 ) : -        z0=[at(x,2),facing(2)|z ] , x#=1 # \\/ x#=2 , duplicate_free(z0 ) . ....",
    "the corresponding axiom in fluent calculus is @xmath253)\\ ] ] it follows that @xmath254 while @xmath255 but @xmath256 :    ....     ? -",
    "init(z0 ) ,        knows_val([d ] , facing(d ) , z0 ) ,        \\+ knows_val([x , y ] , at(x , y ) , z0 ) ,        knows_val([y ] , at(_,y ) , z0 ) .",
    "d = 2     y = 2 ....    in theory , agents using the fluent calculus are logically omniscient .",
    "therefore , the general problem of inferring knowledge under incomplete states is computationally demanding , if not undecidable in the first - order case .",
    "this is so because full theorem proving is required to this end .",
    "the careful design of the state constraints supported in flux and the incomplete constraint solver , however , make the task computationally feasible . since deciding unsatisfiability of a set of constraints is linear in the size of the constraint store",
    ", inferring knowledge in flux is linear in the size of the state description .",
    "the frame problem for knowledge is solved in the fluent calculus by axiomatizing the relation between the possible states before and after an action  @xcite .",
    "the effect of @xmath257 , be it a sensing action or not , on the knowledge of the agent is specified by a so - called _ knowledge update axiom _ , denotes that an action is possible in a state .",
    "macro @xmath258 stands for the formula @xmath259 . ] @xmath260 \\end{array}\\ ] ] where @xmath261 specifies the physical state update while @xmath262 restricts the possible states so as to agree with the actual state @xmath263 on the sensed properties and values  @xmath264 .    as an example , let the three actions of the cleaning robot be denoted by @xmath265 the action preconditions can be axiomatized as @xmath266 in conjunction with the auxiliary axiom @xmath267 }    \\end{array}\\ ] ] that is to say , going forward requires the robot not to face the wall of the building while emptying a waste bin and making a quarter turn clockwise is always possible .",
    "the actions @xmath268 and @xmath269 of our cleanbot involve no sensing . the physical effects of these actions are specified by the following knowledge update axioms : @xmath270 } \\\\ \\\\",
    "\\multicolumn{4}{l}{{{\\mbox{\\rm\\em knows\\/}}}({{\\mbox{\\rm\\em poss\\/}}}({{\\mbox{\\rm\\em turn\\/}}}),s){\\supset } } \\\\",
    "\\multicolumn{4}{l}{\\ \\ \\ [ \\,{{\\mbox{\\rm\\em kstate\\/}}}({{\\mbox{\\rm\\em do\\/}}}({{\\mbox{\\rm\\em turn\\/}}},s),z'){\\equiv } } \\\\      \\ \\ \\ \\ \\ \\ \\ ( \\exists z)\\,(\\!\\!\\!\\!\\ ! &        \\multicolumn{3}{l}{{{\\mbox{\\rm\\em kstate\\/}}}(s , z)\\ \\wedge } \\\\      & ( \\exists d)\\,(\\!\\!\\!\\!\\ ! &        \\multicolumn{2}{l}{\\!{{\\mbox{\\rm\\em holds\\/}}}({{\\mbox{\\rm\\em facing\\/}}}(d),z)\\ \\wedge } \\\\      & & \\multicolumn{2}{l}{\\!z'=z-{{\\mbox{\\rm\\em facing\\/}}}(d)+        { { \\mbox{\\rm\\em facing\\/}}}(d\\,\\mbox{\\rm mod}\\,4 + 1))\\,)\\ , ] }    \\end{array}\\ ] ] thus @xmath25 is a possible state after cleaning or turning , respectively , just in case @xmath25 is the result of cleaning or turning in one of the previously possible states  @xmath19 .",
    "the following knowledge update axiom for  @xmath271 combines the physical effect of going forward with information about whether light is sensed at the new location : @xmath272\\ , ] }    \\end{array}\\ ] ] where the sensed property indicates whether or not the robot perceives a light at its current location : @xmath273 thus axiom  ( [ e : crpkua2 ] ) says that @xmath25 is a possible state after going forward if @xmath25 is the result of doing this action in some previously possible state and there is light at the current location in @xmath25 just in case it is so in the actual state @xmath274 .    as an example of sensing a fluent value rather than a proposition ,",
    "consider the specification of a location sensor . as",
    "a pure sensing action , self - location has no physical effect . in general , this is indicated in a knowledge update axiom by the sub - formula @xmath275 describing the ( empty ) physical effect . for the sake of compactness , this sub - formula has been simplified to @xmath276 in the following axiom : @xmath277 put in words , there exist coordinates @xmath278 such that the robot is at  @xmath12 in all possible states of the successor situation .",
    "( the foundational axiom for knowledge of definition  [ d : fknows ] ( section  [ ss : kfc ] ) then implies that @xmath12 must also be the actual location of the robot . )",
    "updating the knowledge state of a flux agent involves two steps , the physical effect and the sensing result of an action . since knowledge states are identified with ( incomplete ) flux states as discussed in section  [ ss : fluxknows ] , knowledge update according to the physical effect amounts to updating a flux state specification in the way discussed in section  [ s : update ] .",
    "having inferred the physical effect of an action , agents need to evaluate possible sensing results as part of the update . to this end , the sensing outcome of an action is encoded by a ( possibly empty ) list of individual _ sensing results_. the result of sensing a proposition is either of the constants @xmath143 or @xmath279 .",
    "the result of sensing a value is a ground term of the respective sort .",
    "for example , the sensing result for knowledge update axiom  ( [ e : crpkua2 ] ) is encoded by @xmath280 $ ] where @xmath281 , depending on whether light is actually sensed at the new location . the sensing result for knowledge update axiom  ( [ e : kualoc ] ) , on the other hand ,",
    "should be encoded by @xmath282 $ ] where @xmath283 .",
    "based on the notion of sensing results , knowledge update axioms are encoded in flux as definitions of the predicate @xmath284 describing the update of state  @xmath157 to  @xmath156 according to the physical effects of action  @xmath285 and the sensing result  @xmath286 . as an example",
    ", figure  [ f : crpsua ] depicts a flux encoding of the action precondition and knowledge update axioms for the cleaning robot domain .",
    "neither @xmath268 nor @xmath269 provides any sensor data .",
    "the sensing result for action @xmath271 is evaluated with the help of the auxiliary predicate @xmath287 as defined in section  [ s : chr ] .    ....",
    "poss(clean , _ ) .",
    "poss(turn , _ ) .",
    "poss(go , z ) : -                  knows_val([x , y ] , at(x , y ) , z ) ,                  knows_val([d ] , facing(d ) , z ) ,                  adjacent(x , y , d , _ , _ ) ,                 state_update(z1 , clean , z2 , [ ] ) : -                  holds(at(x , y ) , z1 ) ,                  update(z1 , [ cleaned(x , y ) ] , [ ] , z2 ) .",
    "state_update(z1 , turn , z2 , [ ] ) : -                  holds(facing(d ) , z1 ) ,                  ( d#<4 # /\\",
    "d1#=d+1 ) # \\/",
    "( d#=4 # /\\",
    "d1#=1 ) ,                  update(z1 , [ facing(d1 ) ] , [ facing(d ) ] , z2 ) .",
    "state_update(z1 , go , z2 , [ light ] ) : -                  holds(at(x , y ) , z1 ) ,                  holds(facing(d ) , z1 ) ,                  adjacent(x , y , d , x1 , y1 ) ,                  update(z1 , [ at(x1,y1 ) ] , [ at(x , y ) ] , z2 ) ,                  light(x1 , y1 , light , z2 ) .                 adjacent(x , y , d , x1 , y1 ) : -                  [ x , y , x1,y1 ] : : 1 .. 5 , d : : 1 .. 4 ,                  ( d#=1 ) # /\\ ( x1#=x ) # /\\ ( y1#=y+1 )       % north                  # \\/                  ( d#=2 ) # /\\ ( x1#=x+1 ) # /\\ ( y1#=y )       % east                  # \\/                  ( d#=3 ) # /\\ ( x1#=x ) # /\\ ( y1#=y-1 )       % south                  # \\/                  ( d#=4 ) # /\\ ( x1#=x-1 ) # /\\ ( y1#=y ) .",
    "% west ....    consider , for example , the initial flux state for the cleaning robot shown in figure  [ f : init ] .",
    "suppose that when going north twice , the robot senses no light after the first action but after the second one . with the following query the cleanbot computes the knowledge update for this sequence of actions and",
    "the given sensing results :    ....     init(z0 ) : -        z0 = [ at(1,1),facing(1 ) | z ] ,        not_holds(occupied(1,1 ) , z ) ,        not_holds(occupied(2,1 ) , z ) ,          % hallway        ... , not_holds(occupied(4,5 ) , z ) ,     %        consistent(z0 ) .",
    "consistent(z ) : -        holds(at(x , y ) , z , z1 ) , [ x , y ] : : 1 .. 5 , not_holds_all(at ( _ , _ ) , z1 ) ,        holds(facing(d ) , z , z2 ) , [ d ] : : 1 .. 4 , not_holds_all(facing ( _ ) , z2 ) ,        not_holds_all(occupied(_,0 ) , z ) ,        not_holds_all(occupied(_,6 ) , z ) ,        not_holds_all(occupied(0 , _ ) , z ) ,        not_holds_all(occupied(6 , _ ) , z ) ,        duplicate_free(z ) .",
    "....    ....     ? -",
    "init(z0 ) , state_update(z0 , go , z1 , [ false ] ) ,                  state_update(z1 , go , z2 , [ true ] ) .",
    "z0 = [ at(1,1),facing(1 ) | z ]     z1 = [ at(1,2),facing(1 ) | z ]     z2 = [ at(1,3),facing(1 ) | z ]       constraints :     not_holds(occupied(1,3 ) , z )     or_holds([occupied(2,3),occupied(1,4 ) ] , z )     ... ....    thus the agent has evaluated the acquired sensor data and inferred its actual position according to the physical effects of @xmath288 .    as an example for inferring the update when sensing a value of a fluent ,",
    "consider the following flux clause , which encodes knowledge update axiom  ( [ e : kualoc ] ) for action @xmath289 :    ....     state_update(z , sense_loc , z , [ x , y ] ) : - holds(at(x , y ) , z ) . ....",
    "that is , no physical effect affects the state but the sensed value is incorporated into the specification .",
    "suppose , for instance , the agent is uncertain as to whether it moved north or east from its initial location  @xmath40 , while the subsequent position tracking reveals that it is at  @xmath41 :    ....    init(z0 ) : - z0 = [ at(1,1),facing(d ) | _ ] , d#=1 # \\/ d#=2 ,                consistent(z0 ) .      ?",
    "- init(z0 ) , state_update(z0 , go , z1 , [ false ] ) ,                 state_update(z1 , sense_loc , z2 , [ 1,2 ] ) .",
    "z0 = [ at(1,1),facing(1 ) | z ]    z1 = [ at(1,2),facing(1 ) | z ]    z2 = [ at(1,2),facing(1 ) | z ]      constraints :    not_holds(occupied(1,3 ) , z )    ... ....    thus the agent has inferred its actual position and , hence , concluded that it is actually facing north .",
    "incidentally , knowing the location also allows to infer that office  @xmath51 is not occupied , which follows from the observation that no light is sensed after the @xmath271 action .",
    "flux agents rely on knowledge update axioms in order to maintain their internal model of the environment . as this model is usually incomplete ,",
    "the update axioms need to be carefully encoded in flux so as to always lead to a correct resulting knowledge state .",
    "in particular , when specifying an action with conditional effects the programmer needs to define the correct update for any possible knowledge the agent may have concerning the fluents affected by the action .",
    "consider , for example , the action @xmath290 to alter the position of a toggle switch . if  @xmath291 happens to be open ( fluent @xmath292 ) , then it will be closed afterwards ( i.e. , not @xmath293 ) ; otherwise , i.e. , if it is closed beforehand , then it will be open after the action . tacitly assuming that the action is always possible , its conditional effect is specified in the fluent calculus by the following knowledge update axiom : @xmath294\\ , ) \\end{array}\\ ] ]    the flux encoding of this update axiom requires to distinguish three kinds of knowledge states . in case",
    "the current knowledge entails that switch  @xmath291 is open , the resulting knowledge state is obtained through updating by negative effect @xmath295 .",
    "conversely , in case the current knowledge entails that switch  @xmath291 is not open , the resulting knowledge state is obtained through updating by positive effect @xmath296 .",
    "finally , if the current knowledge state does not entail the status of the switch , then this uncertainty transfers to the updated knowledge state .",
    "moreover , possible partial ( e.g. , disjunctive ) information regarding the position of the affected switch is no longer valid and , hence , needs to be cancelled .    ....",
    "state_update(z1 , alter(x ) , z2 , [ ] ) : -        knows(open(x ) , z1 )      - > update(z1 , [ ] , [ open(x ) ] , z2 ) ;        knows_not(open(x ) , z1 ) - > update(z1 , [ open(x ) ] , [ ] , z2 ) ;",
    "cancel(open(x ) , z1 , z2 ) . ....    for example ,    ....     ? - not_holds(open(t1 ) , z0 ) ,        or_holds([open(t2),open(t3 ) ] , z0 ) ,        state_update(z0 , alter(t1 ) , z1 , [ ] ) ,        state_update(z1 , alter(t2 ) , z2 , [ ] ) .",
    "z2 = [ open(t1 ) | z0 ]       constraints :     not_holds(open(t1 ) , z0 ) ....    that is to say , while switch  @xmath297 is known to be open after altering its position , it no longer follows , after altering  @xmath298 , that @xmath299 or @xmath300 is open . ) .",
    "suppose that initially  @xmath299 or  @xmath300 is open .",
    "then it follows that after altering the position of  @xmath298 , if @xmath299 is open then so is  @xmath301 ! this is so because if @xmath299 is open after changing its position , it must have been closed initially , and hence @xmath300 was ( and still is ) open .",
    "the corresponding implication , i.e. , @xmath302 , is not entailed by the updated flux state .",
    "fortunately , obtaining a weaker update specification  just like an incomplete inference engine  is not an obstacle towards sound agent programs .",
    "since flux agents are controlled by what they know of the environment , a sound but incomplete knowledge state suffices to ensure that the agent draws correct conclusions . this is a consequence of the simple fact that everything that is known under a weaker knowledge state is also known under the stronger one . ]",
    "in this section , we show how our lp - based approach to reasoning about actions can be used as the kernel for a high - level programming method for the design of agents that reason about their actions .",
    "these agents use the concept of a state as their mental model of the world when controlling their own behavior .",
    "as they move along , agents constantly update their world model in order to reflect the changes they have effected and the sensor information they have acquired .",
    "thanks to the extensive reasoning facilities provided by the kernel of flux and in particular the constraint solver , the language allows to implement complex strategies with concise and modular programs .",
    "( 220,166)(0,20 ) ( 0,120)(110,50)@xmath303 ( 135,95)(0,0)@xmath304 ( 156,95)(0,0)[l]@xmath305 ( 0,70)(110,50)@xmath306 ( 0,20)(110,50)@xmath307 ( 135,45)(0,0)@xmath304 ( 156,45)(0,0)[l]@xmath29    the general architecture of flux agent programs is depicted in figure  [ f : flux_architecture ] .",
    "every agent program contains the kernel  @xmath308 , which consists of    * the flux constraint system of figure  [ f : chr1 ] and  [ f : chr2 ] plus a constraint solver for finite domains ; * the definition of update of figure  [ f : flux ] and  [ f : cancel ] ; * the definition of knowledge of figure  [ f : knowledge ] ; and * the following definition of execution , by which action  @xmath309 is performed and , simultaneously , the current state  @xmath157 is updated to state  @xmath156 according to the effects and sensing result of performing  @xmath310 : + ....     execute(a , z1 , z2 ) : -        perform(a , y ) , state_update(z1 , a , z2 , y ) .",
    "....    the second part ,  @xmath311 , of a flux agent program contains encodings of the domain axioms .",
    "these include    * action precondition axioms , * update axioms , * domain constraints , and * initial knowledge state .",
    "the domain program for the cleanbot , for example , consists of the precondition and update axioms of figure  [ f : crpsua ] along with the initial knowledge state and domain constraints of figure  [ f : init ] .    on top of this",
    ", the programmer defines the intended behavior of the agent via a control program  @xmath312 .",
    "this program uses the basic predicate @xmath313 for the execution of an action . to this end",
    ", the interaction of the agent with the outside world needs to be defined by the predicate @xmath314 , which causes the physical agent to carry out action  @xmath309 in the environment such that  @xmath315 returns the sensing information acquired by performing this action .",
    "control programs  @xmath303 use the predicate @xmath316 ( and its derivatives @xmath317 and @xmath318 ) to evaluate conditions against the internal world model .",
    "figure  [ f : cleanbot ] depicts a sample control program for our cleaning robot . after the initialization of the world model and the execution of a @xmath268 action at the home square",
    ", the main loop is entered by which the robot systematically explores and cleans the office floor . to this end",
    ", the program employs two parameters containing , respectively , choice points yet to be explored and the current path of the robot .",
    "the latter is used to backtrack from a location once all choices have been considered .",
    "a choice point is a list of directions , which are encoded by @xmath0 ( for north ) to @xmath3 ( for west ) as usual .",
    "the path is represented by the sequence , in reverse order , of the directions the robot took in each step .    ....",
    "main : -",
    "init(z0 ) ,           execute(clean , z0 , z1 ) ,           choicepoints = [ [ 1,2,3,4 ] ] , backtrack = [ ] ,            main_loop(choicepoints , backtrack , z1 ) .",
    "main_loop([choices|choicepoints ] , backtrack , z ) : -           choices = [ direction|directions ] - >           ( go_in_direction(direction , z , z1 )             - > execute(clean , z1 , z2 ) ,                choicepoints1 = [ [ 1,2,3,4 ] , directions | choicepoints ] ,                backtrack1 = [ direction | backtrack ] ,                main_loop(choicepoints1 , backtrack1 , z2 )             ;             main_loop([directions|choicepoints ] , backtrack , z ) )           ;           backtrack(choicepoints , backtrack , z ) .",
    "go_in_direction(d , z1 , z2 ) : -           knows_val([x , y ] , at(x , y ) , z1 ) ,           adjacent(x , y , d , x1 , y1 ) ,           \\+ knows(cleaned(x1,y1 ) , z1 ) ,           knows_not(occupied(x1,y1 ) , z1 ) ,           turn_to_go(d , z1 , z2 ) .          backtrack ( _ , [ ] , _ ) .",
    "backtrack(choicepoints , [ direction|backtrack ] , z ) : -           reverse is ( direction+1 ) mod 4 + 1 ,           turn_to_go(reverse , z , z1 ) ,           main_loop(choicepoints , backtrack , z1 ) .",
    "turn_to_go(d , z1 , z2 ) : -           knows(facing(d ) , z1 ) - > execute(go , z1 , z2 )           ;           execute(turn , z1 , z ) , turn_to_go(d , z , z2 ) . ....    in the main loop , the cleanbot selects the first element of the current choices . if the attempt to go into this direction is successful ( predicate @xmath319 ) , then the robot empties the waste bin at the new location .",
    "a new choice point is created , and the backtrack path is augmented by the direction into which the robot just went . if , on the other hand , the chosen direction can not be taken , then the main loop is called with a reduced list of current choices . in case",
    "no more choices are left , the cleanbot backtracks ( predicate @xmath320 ) .",
    "the auxiliary predicate @xmath321 succeeds if the cleanbot can safely go into direction  @xmath322 from its current location in state  @xmath162 , ending up in state  @xmath323 .",
    "a direction is only explored if the adjacent square is inside of the boundaries .",
    "furthermore , this location must not have been visited already ( that is , it is not known to be cleaned ) , and  most importantly  the adjacent location must _ known _ not to be occupied . by the auxiliary predicate @xmath320 , the robot takes back one step on its current path by reversing the direction .",
    "the program terminates once this path is empty , which implies that the robot has returned to its home after it has visited and cleaned as many locations as possible .",
    "the two auxiliary predicates @xmath324 and @xmath325 in turn call the predicate @xmath326 , by which the robot makes turns until it faces the intended direction , and then moves forward .",
    "the following table illustrates what happens in the first nine calls to the main loop when running the program with the initial state of figure  [ f : init ] and the scenario depicted in figure  [ f : crp ] .    [ cols=\"^,>,>,^ \" , ]     1ex the letters @xmath327 are abbreviations for the actions @xmath288 , @xmath328 , and @xmath329 , respectively . after going north twice to office  @xmath42 ,",
    "the cleanbot can not continue in direction  @xmath0 or  @xmath1 because both office  @xmath53 and office  @xmath52 may be occupied according to the robot s current knowledge .",
    "direction  @xmath2 is not explored since location  @xmath330 has already been cleaned , and direction  @xmath3 is ruled out as @xmath331 is outside of the boundaries .",
    "hence , the cleanbot backtracks to  @xmath330 and continues with the next choice there , direction  @xmath332 , which brings it to location  @xmath54 .",
    "from there it goes north , and so on .",
    "( 40,40)(0,3 ) ( 2,5)(35,35 ) ( 2,12)(0,7)4(1,0)2.5 ( 6.5,19)(0,7)3(1,0)5 ( 6.5,12)(1,0)2.5 ( 13.5,19)(0,7)3(1,0)5 ( 16,12)(1,0)2.5 ( 20.5,12)(1,0)5 ( 20.5,19)(0,7)3(1,0)2.5 ( 27.5,12)(1,0)5 ( 30,19)(0,7)3(1,0)2.5 ( 34.5,12)(0,7)4(1,0)2.5    ( 9,5)(7,0)4(0,1)2.5 ( 9,9.5)(7,0)3(0,1)2.5 ( 30,9.5)(0,1)5 ( 9,19)(7,0)3(0,1)2.5 ( 30,16.5)(0,1)5 ( 9,23.5)(7,0)4(0,1)5 ( 9,30.5)(7,0)3(0,1)2.5 ( 30,30.5)(0,1)5 ( 30,37.5)(0,1)2.5    ( 5.5,3)(0,0)@xmath0 ( 12.5,3)(0,0)@xmath1 ( 19.5,3)(0,0)@xmath2 ( 26.5,3)(0,0)@xmath3 ( 33.5,3)(0,0)@xmath4    ( 0,8.5)(0,0)@xmath0 ( 0,15.5)(0,0)@xmath1 ( 0,22.5)(0,0)@xmath2 ( 0,29.5)(0,0)@xmath3 ( 0,36.5)(0,0)@xmath4    ( 5.5,29.5)(0,0 ) ( 19.5,8.5)(0,0 ) ( 19.5,22.5)(0,0 ) ( 33.5,22.5)(0,0 )    ( 8,34.5)(7,0)5 ( 15,27.5)(7,0)4 ( 8,20.5)(7,0)2 ( 8,13.5)(7,0)5 ( 8,6.5)(7,0)2 ( 29,6.5)(0,7)3    ( 33.5,8.5)(0,0 ) * ? *    ( 4,6)(3,2.5 ) ( 4.5,6 ) ( 6.5,6 ) ( 5.5,8.5 ) ( 5.5,9.5)(0,-1)2.5    figure  [ f : final_state ] depicts the knowledge state at the time the program terminates . back home , the cleanbot has acquired knowledge of all four occupied offices . moreover",
    ", it has emptied all waste bins but the ones in these four offices and the bin in office  @xmath333 .",
    "this office has not been visited because the robot can not know that it is not occupied  the light sensors have been activated at both surrounding locations , @xmath334 and  @xmath335 !      the semantics of a flux agent program",
    "is given as a combination of the fluent calculus and the standard semantics of logic programming .",
    "we assume the reader to be familiar with the basic notion of a computation tree for constraint logic programs ( see , e.g. , @xcite ) .",
    "let @xmath336 be the computation tree for an agent program @xmath337 along with a query @xmath338 .",
    "tree  @xmath336 determines a particular action sequence as follows .",
    "let an _ execution node _ be any node in  @xmath336 which starts with the atom  @xmath339 .",
    "let @xmath340 be the ordered sequence of all execution nodes occurring in  @xmath341 t , then this tree is said to _ generate _ the action sequence @xmath342 this sequence is to be used when proving formal properties of the agent program with the help of the fluent calculus and the axiomatization  @xmath305 of the application domain . for example , a program can be called _ sound _ if the domain axiomatization entails that all actions are possible in the situation in which they are executed .",
    "formally , @xmath343    domain - dependent requirements are proved in a similar fashion .",
    "the program for the cleanbot , for example , can be shown to admit a finite computation tree ; hence to terminate .",
    "other properties are that the cleanbot will always end up in its home  @xmath40 , it will never enter an office which is occupied ( provided its light sensor functions correctly ) , and it always cleans all locations in the hallway .",
    "the formal proofs of these properties are not deep but tedious , which is why we refrain from giving them here .      to illustrate the computational merits of flux ,",
    "we have compared it to golog @xcite , an agent programming language with similar purposes .",
    "the cleanbot domain requires a variant of golog which supports incomplete states and sensing  @xcite . in this system , incompletely specified initial situations are encoded by sets of ( propositional ) prime implicates . to decide whether a property is known to hold after a sequence of actions , the property is _ regressed _ to the initial situation .",
    "if the resulting formula is entailed by the initial prime implicates , then the original property is known to hold in the respective situation .",
    "acquired sensor information is regressed , too , and the result is added to the initial set of prime implicates .",
    "( 90,72 ) ( 50,36)(0,0 )    we have re - implemented the strategy of figure  [ f : cleanbot ] for the cleanbot as a golog program and ran a series of experiments with square office floors of different size . for simplicity ,",
    "no initial information about unoccupied cells besides  ( 1,1 ) and the two adjacent ones were given to the robot .",
    "figure  [ f : fluxgolog1 ] depicts the results of five sets of experiments .",
    "the given runtimes ( seconds cpu time of a 1733  mhz processor ) are the average of 10  runs with randomly chosen occupied cells .",
    "the dominance of flux has two main reasons :    1 .",
    "since prime implicates can be used to encode arbitrary propositional formulas , the complexity of inferring knowledge in the golog system of  @xcite is exponential .",
    "in contrast , the restricted first - order state representation and the incomplete inference engine of flux allows for inferring knowledge in linear time .",
    "2 .   in flux ,",
    "the world model is _ progressed _ whenever an action is performed , and the new model is directly used to decide whether a property is currently known .",
    "the golog system of  @xcite , on the other hand , is _ regression - based _ , so that deciding whether a property is known in a situation requires to regress the property through the previously performed actions .",
    "consequently , the computational behavior of the golog program worsens the longer the program runs .",
    "this can be clearly seen from the graphs in figure  [ f : fluxgolog2 ] , which depict the average time for action selection at different stages of the execution of the cleanbot program .",
    "3 .   to solve the frame problem ,",
    "flux uses state update axioms , which specify the effects of an action on an entire state .",
    "when progressing a state through an update axiom , the large body of unaffected knowledge simply remains in the constraint store .",
    "this is what makes up an efficient solution to the frame problem even in the presence of incomplete states .",
    "( 102,72 ) ( 51,36)(0,0 )",
    "we have presented the logic programming method flux for the design of logically reasoning agents .",
    "the agents use a system of constraint handling rules and finite domain constraints to reason about actions in the presence of incomplete states .",
    "both the constraint solver and the logic program for state update have been formally verified against the action theory of the fluent calculus .",
    "thanks to a carefully chosen expressiveness , the flux kernel exhibits excellent computational behavior .",
    "the closest related work is the programming language golog  @xcite for dynamic domains , which is based on the situation calculus and successor state axioms as a solution to the frame problem  @xcite .",
    "the main differences are :    1 .",
    "golog defines a special programming language for strategies , while flux strategies are standard logic programs .",
    "2 .   with the exception of  @xcite ,",
    "existing implementations of golog apply the principle of negation - as - failure to state specifications and , hence , are restricted to complete state knowledge and deterministic actions . with its underlying constraint solver , flux provides a natural way of representing and reasoning with incomplete states as well as nondeterministic actions .",
    "the logic programs for golog described in the literature all apply the principle of regression to evaluate conditions in agent programs .",
    "while this is efficient for short action sequences , the computational effort increases with the number of performed actions . with the progression principle ,",
    "flux programs scale up well to the control of agents over extended periods .",
    "moreover , progression through state update axioms in flux provides an efficient solution to the frame problem , because unaffected state knowledge simply remains in the constraint store .",
    "golog includes the concept of nondeterministic programs as a means to define a search space for a planning problem . to find a plan ,",
    "such a program is executed `` off - line '' with the aim to find a run by which the planning goal is attained .",
    "a similar concept can be added to flux , allowing agents to interleave planning with program execution  @xcite .",
    "we are conducting experiments where flux is applied to the high - level control of a real robot , whose task is to collect and deliver in - house mail in an office floor  @xcite . to this end , the logic programming system has been extended by a solution to the qualification problem  @xcite in the fluent calculus which accounts for unexpected failure of actions  @xcite .",
    "future work will include the gradual extension of the expressiveness of flux , e.g. , by constraints for exclusive disjunction , without loosing the computational merits of the approach .",
    "the author wants to thank stephan schiffel for his help with the experiments and matthias fichtner , axel gromann , yves martin , and the anonymous reviewers for valuable comments on an earlier version .",
    "parts of the work reported in this paper have been carried out while the author was a visiting researcher at the university of new south wales in sydney , australia .",
    "\\1989 . a simple solution to the yale shooting problem . in _ proceedings of the international conference on principles of knowledge representation and reasoning ( kr )",
    "_ , r.  brachman , h.  levesque , and r.  reiter , eds .",
    "morgan kaufmann , toronto , canada , 1120 .                  ,",
    "levesque , h. , lin , f. , marcu , d. , reiter , r. , and scherl , r. 1994 . a logical approach to high - level robot programming  a progress report . in _ control of the physical world by intelligent agents , papers from the aaai",
    "fall symposium _ , b.  kuipers , ed .",
    "new orleans , la , 109119 .",
    "\\2001 . addressing the qualification problem in flux . in _ proceedings of the german annual conference on artificial intelligence ( ki )",
    "_ , f.  baader , g.  brewka , and t.  eiter , eds .",
    "lnai , vol .",
    "springer , vienna , austria , 290304 .",
    "epistemological problems of artificial intelligence . in _ proceedings of the international joint conference on artificial intelligence ( ijcai ) _ , r.  reddy , ed . mit press , cambridge , ma , 10381044 .",
    "the frame problem in the situation calculus : a simple solution ( sometimes ) and a completeness result for goal regression . in _ artificial intelligence and mathematical theory of computation _",
    ", v.  lifschitz , ed . academic press , 359380",
    ".            \\2000 .",
    "high - level robot control through logic . in _ proceedings of the international workshop on agent theories architectures and languages ( atal ) _ , c.  castelfranchi and y.  lesprance , eds .",
    "lncs , vol .",
    "springer , boston , ma , 104121 .",
    "representing the knowledge of a robot . in _ proceedings of the international conference on principles of knowledge representation and reasoning ( kr )",
    "_ , a.  cohn , f.  giunchiglia , and b.  selman , eds .",
    "morgan kaufmann , breckenridge , co , 109120 .",
    "programming of reasoning and planning agents with flux . in _ proceedings of the international conference on principles of knowledge representation and reasoning ( kr )",
    "_ , d.  fensel , d.  mcguinness , and m .- a .",
    "williams , eds .",
    "morgan kaufmann , toulouse , france , 435446 ."
  ],
  "abstract_text": [
    "<S> flux is a programming method for the design of agents that reason logically about their actions and sensor information in the presence of incomplete knowledge . </S>",
    "<S> the core of flux is a system of constraint handling rules , which enables agents to maintain an internal model of their environment by which they control their own behavior . </S>",
    "<S> the general action representation formalism of the fluent calculus provides the formal semantics for the constraint solver . </S>",
    "<S> flux exhibits excellent computational behavior due to both a carefully restricted expressiveness and the inference paradigm of progression .    </S>",
    "<S> [ firstpage ] </S>"
  ]
}