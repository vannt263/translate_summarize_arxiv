{
  "article_text": [
    "this document explains how to use the following software tools for automatic differentiation ( ad ) to generate first - order derivative code for a small example problem .",
    "* adifor 2.0 revision d ( http://www.mcs.anl.gov/adifor ) * adic 1.1 ( http://www.mcs.anl.gov/adic ) * adol - c 1.8 ( http://www.math.tu-dresden.de/wir/project/adolc ) * tapenade 1.0-alpha ( http://www-sop.inria.fr/tropics )    the document does not describe the ad algorithms used by these software tools .",
    "various publications cover the theoretical foundations of the algorithms referenced in our discussion . for an introduction and more advanced issues we point the reader to @xcite .",
    "three workshops have been dedicated to ad , and the proceedings @xcite contain numerous references to other ad - related papers that have appeared in scientific journals and proceedings of international conferences . a large variety of successful applications of ad software to real - world applications",
    "are discussed there as well .",
    "for information on how to obtain , install , and use the ad tools discussed in this document , visit the web sites listed in section 1 .",
    "the examples in this document are discussed in the context of the computer environment found on a laptop computer , specifically an intel pentium system running mandrake linux version 8.1 .",
    "adifor , adic , and tapenade are installed in the directory /home",
    "/ uwe / adtools . the adol - c library and",
    "include files are assumed to be in the same directory as the source files .",
    "adifor , adic , and tapenade are available on the web and can be accessed online by using the corresponding web servers .",
    "visit    * http://www.mcs.anl.gov/autodiff/adiforserver for adifor , * http://www.mcs.anl.gov/autodiff/adicserver for adic , and * http://tapenade.inria.fr:8080/tapenade/index.jsp for tapenade .",
    "all source files presented in this document can be downloaded from    http://www-unix.mcs.anl.gov/~naumann/ad_tools.html .",
    "the makefiles have to be adapted to the user s environment .",
    "we have selected a variant of the bratu problem @xcite to illustrate the use of source transformation ad tools .",
    "the code in appendix [ app:1 ] models the thermal explosion of solid fuels , which can be described by the system of differential equations @xmath0 where @xmath1 and @xmath2 the problem has been discretized by using step size @xmath3 as @xmath4 / 12\\ ] ] for @xmath5 with @xmath6 and @xmath7 of interest are the derivatives of the component functions @xmath8 with respect to the current state @xmath9 as well as the parameters @xmath10 and @xmath11    we consider the following problems :    1 .",
    "adifor 1 .",
    "use the forward vector mode to compute the jacobian of @xmath12 with respect to @xmath13 and the parameters @xmath10 and @xmath14 . in our implementation",
    ", @xmath12 is represented by the variable f , @xmath13 is represented by x , and @xmath10 and @xmath14 are combined into the parameter vector prm .",
    "all three program variables are declared as arrays of double - precision floating - point numbers , namely , * double precision x(7 ) , prm(2 ) , f(dim ) in fortran and * double x[7 ] , prm[2 ] , f[7 ] in c. + ( see section  [ ssec : adifor ] . ) 2 .",
    "use curtis - powell - reid @xcite seeding to compute the compressed jacobian in forward vector mode ( see section  [ sssec : cpr ] ) .",
    "3 .   use the sparslinc library to compute the sparse jacobian by sparse forward mode ( see section  [ sssec : sparslinc ] ) .",
    "adol - c 1 .",
    "use one of the easy - to - use drivers to compute the jacobian of @xmath12 with respect to @xmath13 and the parameters @xmath10 and @xmath14 .",
    "2 .   compute the sparsity structure of the jacobian .",
    "3 .   use the low - level routines for forward and reverse mode to compute the jacobian of @xmath12 with respect to @xmath13 and the parameters @xmath10 and @xmath14 .",
    "+ ( see section  [ ssec : adolc ] . )",
    "compute the jacobian of @xmath12 with respect to @xmath13 in forward vector mode ( see section  [ ssec : adic ] ) .",
    "tapenade 1 .",
    "compute the jacobian of @xmath12 with respect to both @xmath13 and the parameters @xmath10 and @xmath14 in reverse mode ( see section  [ ssec : tapenade ] ) .",
    "adifor generates a differentiated version of the subroutine expl ( ... ) with the following header .    ....",
    "subroutine g_expl(g_p _ , dim , parmax , x , g_x , ldg_x , prm , g_prm ,        + ldg_prm , f , g_f , ldg_f )          integer dim , parmax          double precision x(dim ) , prm(parmax )          double precision f(dim )            integer g_pmax _          parameter ( g_pmax _ = 9 )          integer g_p _ , ldg_x , ldg_prm , ldg_f          double precision g_x(ldg_x , dim ) , g_prm(ldg_prm , parmax ) ,        +     g_f(ldg_f , dim ) ....    the parameter g_pmax _ is the maximal number of directional derivatives that can be computed .",
    "its value is set by using ad_pmax in explosion.adf .",
    "the parameter is required because of the lack of dynamic memory allocation in fortran  77 .",
    "the derivative components of all scalar program variables are allocated as vectors of length g_pmax_. for example , in order to compute the jacobian matrix of f with respect to x , the value of g_pmax _ must be at least equal to 7 , so that the derivative components of x can accommodate the identity in @xmath15    the actual number of directional derivatives g_p _ must be less than or equal to g_pmax_. the parameter g_p _ determines the upper bound for the loops that compute the values of the derivative components .    to compute the jacobian of f with respect to both x and prm",
    ", we set g_pmax _ to be greater than or equal to the sum of the numbers of elements in both vectors , that is , @xmath16 .",
    "consequently , g_x contains the first dim columns of the seed matrix and g_prm its last parmax columns .",
    "the argument g_f is the transpose of the @xmath17-jacobian , where @xmath18 must be initialized to 9 .",
    "all this is done in the driver routine , which is shown in appendix  [ app : adf1driver ] .",
    "the  dense : \" section of the makefile in appendix  [ app : adfmake ] builds an executable that produces the following result .",
    "+    .... -1.88   1.01   0 .     0 .     0 .",
    "0 .     0 .",
    "0.21 -0.48   1.01 -1.87   1.01   0 .",
    "0 .     0 .     0 .",
    "0.39 -1.78   0 .     1.01 -1.87   1.01   0 .     0",
    ".     0 .",
    "0.48 -2.69   0 .",
    "0 .     1.01 -1.87   1.01   0",
    ".     0 .    0.55 -3.49   0 .",
    ".     1.01 -1.87   1.01   0 .",
    "0.48 -2.69   0 .     0 .",
    ".     1.01 -1.87   1.01 0.39 -1.78   0",
    ".     0 .     0 .",
    ".     1.01 -1.88 0.21 -0.48 ....    @xmath19 +   + the output has been formatted for better readability .",
    "it shows the full @xmath20 jacobian evaluated at the argument : +    ....        x(1 ) = 1.72        x(2 ) = 3.45        x(3 ) = 4.16        x(4 ) = 4.87        x(5 ) = 4.16        x(6 ) = 3.45        x(7 ) = 1.72          prm(1 ) = 1.3        prm(2 ) = 0.245828 ....      the full jacobian computed in the preceding section is sparse , and its sparsity pattern can be visualized as follows .",
    "@xmath21 here , @xmath22 stands for a nonzero entry , and blanks represent _ structural _ zero entries in the jacobian . in other words",
    ", no dependence exists between the corresponding dependent and independent variables .",
    "curtis - powell - reid ( cpr ) @xcite seeding is based on the idea that certain columns of the jacobian can be merged to share storage .",
    "for example , column 1 and column 7 could share one column , thus resulting in a compressed version of the jacobian .",
    "this implies that the sparsity pattern must be known in advance in order to exploit matrix compression techniques .",
    "recall that the derivative code generated by adifor always loops over the derivative components of all _ active _ variables .",
    "many of them are equal to zero , leading to predictably trivial multiplications that one would like to avoid .",
    "therefore , instead of computing the jacobian as a jacobian times identity matrix product , one could try to compute a compressed jacobian using a seed matrix with fewer columns than the identity .",
    "since the number of independent variables is often very large , the size of the seed matrix can become much smaller , leading to a decreased complexity of the forward vector mode jacobian computation .    in cpr seeding",
    ", one considers the column incidence graph of the jacobian to try to determine a minimal vertex coloring .",
    "whenever two vertices share the same color , the corresponding columns can be stored in the same column of the compressed jacobian . in our example",
    ", the column incidence graph has the following structure .",
    "unfortunately , since the vertex coloring problem is known to be np - complete in general , the use of heuristics is essential .",
    "the coloring in the example graph has been found  by inspection . \"",
    "different colors are represented by different vertex shapes .",
    "the number @xmath23 of different colors used determines the number of columns in the cpr seed matrix .",
    "its rows are cartesian basis vectors in @xmath24 .",
    "whenever two vertices share the same color , the corresponding rows in the seed matrix contain the same cartesian basis vector .",
    "this leads to the following seed matrix for our example . @xmath25",
    "the  compressed : \" section of the makefile in appendix  [ app : adfmake ] builds an executable that produces output similar to the following . +    ....",
    "-1.88   1.01   0 .     0.21 -0.48   1.01 -1.87   1.01   0.39 -1.78   1.01   1.01 -1.87   0.48 -2.69 -1.87   1.01   1.01   0.55 -3.49   1.01 -1.87   1.01   0.48 -2.69   1.01   1.01 -1.87   0.39 -1.78 -1.88   0",
    ".     1.01   0.21 -0.48 ....    @xmath19 + it shows the compressed @xmath26 jacobian evaluated at the current argument .",
    "the reconstruction of the original jacobian is a simple substitution process as described in ( * ? ? ?",
    "* chapter 7 ) .",
    "we compute the jacobian of f with respect to x. the sparsity pattern of the jacobian need not be known a priori .",
    "derivative components are sparse vectors of ( index , value ) pairs . the computational overhead of sparse vector arithmetic results from the index calculations .",
    "structural sparsity of the extended jacobian ( * ? ? ?",
    "* chapter 2 ) is exploited by avoiding trivial multiplications by zero .",
    "the decision about when to apply runtime sparsity methods depends on the problem structure .",
    "the use of sparslinc with our example can be described by the following steps :    1 .",
    "use the file explosion.cmp without change .",
    "2 .   add the entry ad_flavor = sparse to explosion.adf .",
    "3 .   write driver program as shown in appendix  [ app : sparslinc ] .",
    "4 .   generate g_explosion.f by calling adifor2.1 ad_script = explosion.adf , and copy it from output_files to the current directory . 5 .",
    "compile g_explosion.f and the driver program .",
    "link with reqadintrinsics - linux86.o , libadintrinsics - linux86.a , and",
    "run the executable .",
    "let us have a closer look at the driver program .",
    "the differentiated subroutine    g_expl(dim , parmax , x , g_x , prm , f , g_f )    is generated in g_explosion.f , where g_x and f_x are integer arrays of dimension dim containing pointers to the corresponding sparse derivative objects .",
    "seeding g_x is performed in the driver by    ....",
    "do 10 i=1,dim          g_x(i)=0          call dspsd(g_x(i),i,1.d0,1 )   10    continue ....",
    "notice that g_x(i ) must be initialized properly before calling dspsd .",
    "the call initializes the sparse derivative object pointed at by g_x(i ) as ( i,1.d0 ) . consequently , after executing this loop , g_x contains the sparse identity in @xmath27    the sparse derivative components are extracted by    ....        do 30 i=1,dim          g_f(i)=0          call dspxsq(indvec , valvec , dim , g_f(i),outlen , info )   30    continue ....    where indvec is the index vector and valvec the corresponding value vector making up the sparse representation of the derivative object pointed at by g_f(i ) .",
    "the parameter outlen is the number of nonzero entries in the i_th _ row of the jacobian .",
    "consequently , the outlen first entries of indvec and valvec define the nonzero entries in the i_th _ row of the jacobian as index value pairs ( indvec(j ) , valvec(j ) ) .",
    "the  sparse : \" section of the makefile in appendix  [ app : adfmake ] builds an executable that produces output similar to the following .",
    "+    .... ( 1 , -1.88 ) ( 2 ,   1.01 ) ( 1 ,   1.01 ) ( 2 , -1.87 ) ( 3 ,   1.01 ) ( 2 ,   1.01 ) ( 3 , -1.87 ) ( 4 ,   1.01 ) ( 3 ,   1.01 ) ( 4 , -1.87 ) ( 4 ,   1.01 ) ( 4 ,   1.01 ) ( 5 , -1.87 ) ( 6 ,   1.01 ) ( 5 ,   1.01 ) ( 6 , -1.87 ) ( 7 ,   1.01 ) ( 6 ,   1.01 ) ( 7 , -1.88 ) ....    @xmath19 +   + the sparse jacobian is given by sparse row vectors whose nonzero entries are represented by ( index , value ) pairs .",
    "the reconstruction of the full jacobian is straightforward .",
    "refer to @xcite for further information on how to use sparslinc .",
    "all files involved in using adic with the c version of our example problem are shown in appendix  [ app : adic ] .",
    "the jacobian of f with respect to x is computed in forward vector mode .",
    "adic uses the derived data type deriv_type to associate derivative components with active variables .",
    "the data type inactivedouble is used to indicate that some floating - point variable is not active .",
    "the call of ad_ad_init(dim ) causes the derivative code to use only the first dim elements of the derivative components .",
    "the latter are vectors of length grad_max ( see appendix  [ app : adic ] ) .",
    "the vector x is declared to contain the dim independent variables by calling    ....",
    "ad_ad_setindeparray(x , dim ) ;        ad_ad_setindepdone ( ) ; ....    the function value components of deriv_type variables are accessed by means of the macro deriv_val .",
    "adic generates a differentiated version of the subroutine explosion and names it ad_explosion .",
    "the argument list remains unchanged because all ad - related information is encapsulated in the new data type deriv_type .",
    "if the function returns a double , however , the differentiated function becomes a procedure , and the returned value becomes the first argument .",
    "the derivative components of scalar variables of this type can be extracted by calling the routine ad_ad_extractgrad .",
    "the actual function value can be extracted with ad_ad_extractval . in the example",
    "we call ad_ad_extractgrad(jac , f[i ] ) inside a loop over the dim elements of the vector of dependent variables f. the auxiliary variable jac is declared as a passive vector of size dim and contains the i_th _ row of the jacobian .",
    "a makefile is provided to build the executable explosion.ad in order to compute the first seven columns of the jacobian shown in section  [ ssec : adifor ] .",
    "the ad - tool adol - c is based on operator overloading . using this technique",
    ", one can log for each operation during the program execution the operator and the variables that are involved .",
    "hence , one obtains a new internal representation of the function evaluation . based on the generated execution log , adol - c computes the desired derivatives .",
    "to apply adol - c for derivative calculations , one first has to modify the evaluation program to record the internal representation called tape .",
    "this modification starts with including header - file(s ) that introduce the new data types and functions . here",
    ", the easiest way is to simply include adolc.h .",
    "second , one has to define the part of the program for which one wants to compute the derivatives .",
    "from now on , this part is called the active section .",
    "the statement trace_on(tag,_keep _ ) ; determines the beginning of the active section , the statement trace_off(_file _ ) ; the end of the active section .",
    "the parameter tag identifies the function to be differentiated .",
    "hence , several function representations can be kept at the same time .",
    "because of the shortness of this introduction , the optional parameters keep and file are not explained here but are explained in the documentation @xcite .",
    "third , one has to change the types of the independents to adoubles and mark them as independents using the overloaded operator @xmath28 .",
    "similarly , one must mark the dependents using the overloaded operator @xmath29 .",
    "finally , all variables that lie on the way from the independents to the dependents must be declared as adoubles .",
    "this step includes the generation of a new function explosion_ad , which contains the same source code as before but in the interface the double - variables have to be changed to adouble - variables .",
    "the required modification of the original source code is illustrated by appendix  [ app : adolc ] .",
    "after the tapes are generated during the execution of the active section , the required derivative objects can be calculated . for that purpose adol - c",
    "provides a variety of easy - to - use drivers : gradient ( .. ) , jacobian ( .. ) , hessian ( .. ) , vec_jac ( .. ) computing the product vector times jacobian , computing the product jacobian times vector , and so on . moreover , adol - c supplies routines evaluating the taylor coefficient vectors and their jacobians with respect to the current state vector of solution curves defined by ordinary differential equations .",
    "furthermore , there are drivers for derivative tensors and for the differentiation of implicit and inverse functions .    if one wants to compute the jacobian of @xmath12 with respect to @xmath13 and the parameters @xmath10 and @xmath14 , one has to declare a variable storing the derivative information    where myalloc is provided by adol - c to allocate a two - dimensional array .",
    "then , the statement    causes the computation of the jacobian of the function representation contained in the tape with the number tag at the point v. for a consistency check , the second and third parameter determine the number of dependents and independents , respectively .",
    "hence , only the two statements given above have to be inserted after trace_off ( ) in order to compute the jacobian of @xmath12 .",
    "adol - c provides for the computation of sparsity patterns the driver    if one sets rb and cb to null , jac_pat computes the sparsity structure of the complete jacobian at the point where the tape was generated and stores it in the unsigned int - array jsp .",
    "the corresponding statements that have to be added to the source code are shown in appendix d. if a certain block structure of the jacobian is known , the unsigned int - vectors rb and cb can be applied to describe a compressed form of the independent and dependent variables .",
    "arbitrarily high - order derivatives can be calculated by using the low - level functions of adol - c for the forward and reverse mode of ad .",
    "these routines are explained in detail in a short reference available from the adol - c web page . in this article , only the computation of first - order derivatives is sketched . if one wants the full jacobian , it is preferable to use vector modes of ad . for that purpose ,",
    "adol - c provides the drivers fov_forward ( ... ) and fov_reverse ( ... ) . here ,",
    "fov stands for first - order vector .",
    "the other acronyms of the low - level routines have a corresponding meaning .",
    "the statement    computes the derivative object y @xmath30x for x @xmath31 .",
    "the statement    computes the derivative object z @xmath32 u@xmath33 for u @xmath34 . to prepare this reverse sweep",
    ", one has to call an appropriate forward routines , the choice of which is described in detail by the short reference mentioned above .",
    "the code segments required for computing the full jacobian with the low - level routines are contained in appendix d.      our last example uses the alpha version of tapenade  1.0 to illustrate the use of reverse - mode ad for computing the jacobian of f with respect to x and prm .",
    "all files needed to run the example are described in appendix  [ app : tapenade ] .",
    "the makefile in appendix  [ app : tapenademake ] can be used to generate the executable explosion.ad . running the latter results in the computation of the full jacobian as in section  [ ssec : adifor ] but this time using the reverse mode of ad .",
    "the following command - line parameters are used to call tapenade :    *  -head \" : the name of the head routine *",
    " -vars \" : the names of the independent variables *  -cl \" : switch indicating that reverse , or cotangent linear , mode is used    it generates derivative code in explcl.f , which must be compiled together with the driver program shown in appendix  [ app : tapenadedriver ] and linked with the routines for storing and restoring the values of the tape as described in ( * ? ? ?",
    "* chapter 2 ) .",
    "the current version of tapenade does not provide the reverse vector mode .",
    "hence , the jacobian must be computed as a sequence of jacobian transposed times vector products .",
    "this computation is done in the driver program by successively initializing the derivative components g_f of f as the cartesian basis vectors in @xmath27 thus , the jacobian is accumulated row by row at a computational complexity proportional to the number of dependent variables .",
    "this feature becomes particularly interesting in the case of large , single gradients .",
    "refer to @xcite for further details on reverse - mode ad .",
    "....        subroutine bratu(dim , parmax , x , prm , f )        integer     dim     , parmax c      independent variables        double precision x(dim ) , prm(parmax ) c      dependent variables        double precision f(dim ) c        integer",
    "i              double precision h          h = 2.0/(dim+1 )        f(1 ) = -2*x(1)+h*h*prm(1)/12.0*(1 + 10*exp(x(1)/(1.0+prm(2)*x(1 ) ) ) )         f(2 ) = x(1)+h*h*prm(1)/12.0*exp(x(1)/(1.0+prm(2)*x(1 ) ) )           do 1 i=2,dim-1          f(i-1 ) = f(i-1)+x(i)+h*h*prm(1)/12.0*exp(x(i)/(1.0+prm(2)*x(i ) ) )           f(i ) = f(i)-2*x(i)+h*h*prm(1)/1.2*exp(x(i)/(1.0+prm(2)*x(i ) ) )           f(i+1 ) = x(i)+h*h*prm(1)/12.0*exp(x(i)/(1.0+prm(2)*x(i ) ) )       1 continue",
    "f(dim-1 ) = f(dim-1)+x(dim)+h*h*prm(1)/12.0*exp(x(dim)/(1.0       *            + prm(2)*x(dim ) ) )         f(dim ) = f(dim)-2*x(dim )         f(dim ) = f(dim)+h*h*prm(1)/12.0*(1 + 10*exp(x(dim)/(1.0",
    "*          + prm(2)*x(dim ) ) ) )         end ....",
    "the following files can be downloaded from    http://www-unix.mcs.anl.gov/~naumann/ad_tools.html    .... explosion.adf                   explosion.cmp                   explosion.driver.compressed.f    explosion.driver.f           explosion.driver.sparse.f    explosion.f explosion.sparse.adf makefile ....      the composition file lists the names of all files containing subroutines subject to differentiation . in our simple example",
    "there is just explosion.f .",
    "the makefile can be used for computing the full , compressed , and sparse jacobians using adifor  2.0 .",
    "it also ensures a proper cleanup of all files that are generated automatically during this process .    ....",
    "ad_lib=/home / uwe / adtools / adifor2/adifor2.0d.lib    dense :        adifor2.1 ad_script = explosion.adf      cp output_files / g_explosion.f .",
    "g77 -g -c g_explosion.f explosion.driver.f      g77 -g -o explosion.ad.dense -l$(ad_lib)/lib * .o \\      $ ( ad_lib)/lib / reqadintrinsics - linux86.o \\      -ladintrinsics - linux86     compressed :       adifor2.1 ad_script = explosion.adf      cp output_files / g_explosion.f .",
    "g77 -g -c g_explosion.f explosion.driver.compressed.f      g77 -g",
    "-o explosion.ad.compressed -l$(ad_lib)/lib * .o \\      $ ( ad_lib)/lib / reqadintrinsics - linux86.o \\",
    "-ladintrinsics - linux86     sparse :       adifor2.1 ad_script = explosion.sparse.adf      cp output_files / g_explosion.f .",
    "g77 -g -c g_explosion.f explosion.driver.sparse.f      g77 -g -o explosion.ad.sparse -l$(ad_lib)/lib * .o \\      $ ( ad_lib)/lib / reqadintrinsics - linux86.o \\      -ladintrinsics - linux86 \\",
    "-lsparslinc - linux86    clean :        rm -fr output_files      rm -fr ad_cache      rm * .o      rm g _ *      rm explosion.ad . *      rm * \\~ ....        the jacobian of the output variable f with respect to the two input variables x and prm of the top - level routine expl is computed .",
    "the parameter ad_pmax must be set to the total number of independent variables , that is , 9 ] .    ....",
    "ad_prog = explosion.cmp ad_top   = expl ad_pmax = 9 ad_ivars= x prm ad_dvars= f ....      ....        program main        implicit none c   c      example : explosion equation c      driver for computing jacobian c        integer dim , parmax , n        parameter ( dim=7 , parmax=2 , n=9 )          integer i , j c      independent variables           double precision x(dim ) , prm(parmax ) c      derivative components of independent variables           double precision g_x(n , dim )        double precision g_prm(n , parmax ) c      dependent variables        double precision f(dim ) c      derivative components of dependent variables        double precision g_f(n , dim )    c      initialization of input variables        x(1 ) = 1.72          x(2 ) = 3.45          x(3 ) = 4.16          x(4 ) = 4.87          x(5 ) = 4.16          x(6 ) = 3.45         x(7 ) = 1.72         prm(1 ) = 1.3          prm(2 ) = 0.245828     c      seeding ( identity )        do 20 i=1,n          do 10 j=1,parmax            if ( i.eq.j+dim ) then              g_prm(i , j)=1.0            else              g_prm(i , j)=0.0            endif   10      continue   20    continue          do 40 i=1,n          do 30 j=1,dim            if ( i.eq.j ) then              g_x(i , j)=1.0            else              g_x(i , j)=0.0            endif   30      continue   40    continue    c      call differentiated subroutine        call g_expl(n , dim , parmax , x , g_x , n , prm , g_prm , n , f , g_f , n ) ;        c      print jacobian        do 60 i=1,dim          do 50 j=1,n            print * , \" f ' ( \" , i , \" , \" , j , \" ) = \" , g_f(j , i )   50      continue   60    continue          end ....        this is the same as in the dense case .      ....",
    "program main        implicit none c   c      example : explosion equation c      driver for computing compressed jacobian c        integer dim , parmax , n        parameter ( dim=7 , parmax=2 , n=5 )          integer i , j c      independent variables           double precision x(dim ) , prm(parmax ) c      derivative components of independent variables           double precision g_x(n , dim )        double precision g_prm(n , parmax ) c      dependent variables        double precision f(dim ) c      derivative components of dependent variables        double precision g_f(n , dim )    c      initialization of input variables        x(1 ) = 1.72          x(2 ) = 3.45          x(3 ) = 4.16          x(4 ) = 4.87          x(5 ) = 4.16          x(6 ) = 3.45         x(7 ) = 1.72         prm(1 ) = 1.3          prm(2 ) = 0.245828     c      seeding ( cpr )        do 20 i=1,n          do 10 j=1,parmax            g_prm(i , j)=0.0   10      continue   20    continue          g_prm(n-1,1)=1.0        g_prm(n,2)=1.0          do 40 i=1,n          do 30 j=1,dim            g_x(i , j)=0.0   30      continue   40    continue          g_x(1,1)=1.0        g_x(1,4)=1.0        g_x(1,7)=1.0        g_x(2,2)=1.0        g_x(2,5)=1.0        g_x(3,3)=1.0        g_x(3,6)=1.0    c      call differentiated subroutine        call g_expl(n , dim , parmax , x , g_x , n , prm , g_prm , n , f , g_f , n ) ;        c      print compressed jacobian        do 60 i=1,dim          do 50 j=1,n            print * , \" f ' ( \" , i , \" , \" , j , \" ) = \" , g_f(j , i )   50      continue   60    continue          end ....        in order to make adifor generate derivative code that can use the sparse forward mode provided by sparslinc , the parameter ad_flavor must be set to sparse .    ....",
    "ad_prog = explosion.cmp ad_flavor = sparse ad_top   = expl ad_pmax = 9 ad_ivars= x   ad_dvars= f ....      ....        program main        implicit none c   c      example : explosion equation c      driver for computing sparse jacobian using sparslinc c        integer dim , parmax , n        parameter ( dim=7 , parmax=2 , n=9 )          integer i , j c      independent variables           double precision x(dim )   c      passive inputs        double precision prm(parmax ) c      pointers to sparse derivative components of   c      independent variables           integer g_x(dim ) c      dependent variables        double precision f(dim ) c      pointers to sparse derivative components of   c      dependent variables           integer g_f(dim )    c      ( index , value ) pairs        integer indexes(dim )         double precision values(dim )    c      values used in extraction routine        integer outlen , info        c      initialization of input variables        x(1 ) = 1.72          x(2 ) = 3.45          x(3 ) = 4.16          x(4 ) = 4.87          x(5 ) = 4.16          x(6 ) = 3.45         x(7 ) = 1.72         prm(1 ) = 1.3          prm(2 ) = 0.245828     c      initialization of sparse data structures        call xspini     c      seeding ( sparse identity )        do 10 i=1,dim          g_x(i)=0          g_f(i)=0          call",
    "dspsd(g_x(i),i,1.d0,1 )   10    continue    c      call differentiated subroutine          call g_expl(dim , parmax , x , g_x , prm , f , g_f )    c      extract derivative components        do 30 i=1,dim          call dspxsq(indexes , values , dim , g_f(i),outlen , info )          if ( info.eq.0 ) then            do 20 j=1,outlen              print * , \" indexes ( \" , i , \" , \" , j , \" ) = \" , indexes(j )              print * , \" values ( \" , i , \" , \" , j , \" ) = \" , values(j )   20        continue          endif   30    continue          end ....",
    "the following files can be downloaded from    http://www-unix.mcs.anl.gov/~naumann/ad_tools.html    ....",
    "explosion.c    explosion.driver.c    explosion.init    makefile ....      ....",
    "ad_inc = -i$(adic)/include -i . ad_lib = -l$(adic)/lib/$(adic_arch )    all :      adic -d gradient -i explosion.init      g++",
    "-g -o explosion.ad $ ( ad_inc ) $ ( ad_lib ) \\      explosion.ad.c explosion.driver.c \\      -ladintrinsics - c -laif_grad -lm    clean :      rm explosion.ad *       rm ad_deriv.h      rm * \\~ ....    the environment variable adic must be set to the directory in which adic has been installed .      .... [ source_files ]    explosion.c    [ gradient ]    grad_max=7 ....    the script file specifies the input files ( only one in this case ) and a variety of other parameters that can be looked up in @xcite .",
    "the definition of grad_max , the length of the derivative components , is important .",
    "its default value is 5 , which would cause trouble in our case where dim=@xmath35 refer to @xcite for other ways to set the value of grad_max .",
    ".... # include \" ad_deriv.h \" # include",
    "< stdio.h > # include < iostream > # include < stdlib.h >               extern void ad_explosion(int , deriv_type * , deriv_type * , deriv_type * ) ;    void main ( ) {    int i , j ;    int dim=7 ;                       int parmax=2 ;                   // independent variables    deriv_type * x = new deriv_type[dim ] ;    deriv_type * prm = new deriv_type[parmax ] ;    // independent variables    deriv_type * f = new deriv_type[dim ] ;     // independent variables    inactivedouble * jac = new inactivedouble[dim ] ;      ad_ad_init(dim ) ;      ad_ad_setindeparray(x , dim ) ;    ad_ad_setindepdone ( ) ;      deriv_val(x[0 ] ) = 1.72 ;     deriv_val(x[1 ] ) = 3.45 ;     deriv_val(x[2 ] ) = 4.16 ;     deriv_val(x[3 ] ) = 4.87 ;     deriv_val(x[4 ] ) = 4.16 ;     deriv_val(x[5 ] ) = 3.45 ;    deriv_val(x[6 ] ) = 1.72 ;    deriv_val(prm[0 ] ) = 1.3 ;     deriv_val(prm[1 ] ) = 0.245828 ;      ad_explosion(dim , x , prm , f ) ;       for ( i=0;i < dim;i++ ) {      ad_ad_extractgrad(jac , f[i ] ) ;      for ( j=0;j < dim;j++ )         cout < < \" f ' [ \" < < i+1 < < \" , \" < < j+1 < < \" ] = \" < < jac[j ] < < endl ;    }      ad_ad_final ( ) ; } ....",
    ".... # include < adolc.h > # include < sparse / sparse.h > # include < stdio.h > # include < iostream > # include < stdlib.h >               extern void explosion_ad(int , adouble * , adouble * , adouble * ) ;    void main ( ) {    int i , j ;    int dim=7 ;                       int parmax=2 ;                   int tag = 1 ;       // independent variables ( passiv )    double * v = new double[dim+parmax ] ;    // dependent variables ( passiv )    double * fp = new double[dim ] ;        // independent variables ( active )    adouble * x = new adouble[dim ] ;    adouble * prm = new adouble[parmax ] ;    //",
    "dependent variables ( active )    adouble * f = new adouble[dim ] ;         v[0 ] = 1.72 ;     v[1 ] = 3.45 ;     v[2 ] = 4.16 ;     v[3 ] = 4.87 ;     v[4 ] = 4.16 ;     v[5 ] = 3.45 ;    v[6 ] = 1.72 ;    v[7 ] = 1.3 ;     v[8 ] = 0.245828 ;       trace_on(tag ) ;      for(j=0;j < dim;j++ )        x[j ] < < = v[j ] ;      for(j=0;j < parmax;j++ )        prm[j ] < < = v[j ] ;        explosion_ad(dim , x , prm , f ) ;         for(j=0;j < dim;j++ )        f[j ] > > = fp[j ] ;      trace_off ( ) ;      } ....      ....    // sparsity pattern declarations    int option[3 ] ;            unsigned int * * jsp = new unsigned int*[dim ] ;      for(j=0;j <",
    "dim;j++ )      jsp[j ] = new unsigned int[dim+parmax ] ;    option[0 ] = 0 ; // automatic detection for ad mode    option[1 ] = 0 ; // save propagation of bit - pattern    option[2 ] = 0 ; // no output      ...      // sparsety pattern computation after trace_off      jac_pat(tag , dim , dim+parmax , v , null , null , jsp , option ) ; ....      ....    // calculate jacobian using forward mode driver    double * * x = myalloc(dim+parmax , dim+parmax ) ;             //",
    "calculate jacobian using reverse mode driver    double * * u = myalloc(dim , dim ) ;         ...      // use low level routines to compute jacobian    // forward :      for ( j=0;j < dim+parmax;j++ )     {     for ( i=0;i < dim+parmax;i++ )        x[j][i ] = 0.0 ;     x[j][j ] = 1.0 ;    }        // reverse    for ( j=0;j < dim;j++ )     {     for ( i=0;i < dim;i++ )        u[j][i ] = 0.0 ;     u[j][j ] = 1.0 ;    }      // prepare reverse sweep with appropriate forward sweep    zos_forward(tag , dim , dim+parmax,1,v , fp ) ;",
    "the following files can be downloaded from                          integer dim , parmax ,",
    "n        parameter ( dim=7 , parmax=2 , n=9 )          integer i , j c      independent variables           double precision x(dim ) , prm(parmax ) c      derivative components of independent variables           double precision g_x(dim )        double precision g_prm(parmax ) c      dependent variables        double precision f(dim ) c      derivative components of dependent variables        double precision g_f(dim ) c      the whole jacobian matrix        double precision jac(dim , n )        c      compute jacobian as sequence of jacobian transposed c      times vector products        do 40 i=1,dim          do 10 j=1,dim            g_f(j)=0.d0            g_x(j)=0.d0   10      continue          g_f(i)=1.d0          g_prm(1)=0.d0          g_prm(2)=0.d0          call explcl(dim , parmax , x , g_x , prm , g_prm , f , g_f ) ;          do 20 j=1,dim            jac(i , j)=g_x(j )   20      continue          do 30 j=1,parmax            jac(i , j+dim)=g_prm(j )   30      continue   40    continue"
  ],
  "abstract_text": [
    "<S> we give a gentle introduction to using various software tools for automatic differentiation ( ad ) . </S>",
    "<S> ready - to - use examples are discussed , and links to further information are presented . </S>",
    "<S> our target audience includes all those who are looking for a straightforward way to get started using the available ad technology . </S>",
    "<S> the document is dynamic in the sense that its content will be updated as the ad software evolves .    </S>",
    "<S> argonne national laboratory + 9700 south cass avenue + argonne , il 60439    ' '' ''     + [ 1ex ] anl / mcs - tm-254 , revision a +    ' '' ''    by + [ 3ex ]    _ uwe naumann and andrea walther _   + [ 1ex ] naumann@mcs.anl.gov awalther@math.tu-dresden.de    mathematics and computer science division    technical memorandum no . </S>",
    "<S> 254 , revision a    july 2003    argonne national laboratory , with facilities in the states of illinois and idaho , is owned by the united states government and operated by the university of chicago under the provisions of a contract with the department of energy .    </S>",
    "<S> disclaimer    this report was prepared as an account of work sponsored by an agency of the united states government . </S>",
    "<S> neither the united states government nor any agency thereof , nor the university of chicago , nor any of their employees or officers , makes any warranty , express or implied , or assumes any legal liability or responsibility for the accuracy , completeness , or usefulness of any information , apparatus , product , or process disclosed , or represents that its use would not infringe privately owned rights . </S>",
    "<S> reference herein to any specific commercial product , process , or service by trade name , trademark , manufacturer , or otherwise , does not necessarily constitute or imply its endorsement , recommendation , or favoring by the united states government or any agency thereof . </S>",
    "<S> the views and opinions of document authors expressed herein do not necessarily state or reflect those of the united states government or any agency thereof .    </S>",
    "<S> available electronically at http://www.doe.gov/bridge    available for a processing fee to u.s . </S>",
    "<S> dept . of energy and its contractors , in paper , from :    u.s . </S>",
    "<S> department of energy + office of scientific and techdnical information + p.o . </S>",
    "<S> box 62 + oak ridge , tn 37831 - 0062 + phone : ( 865 ) 576 - 8401 + fax : ( 865 ) 576 - 5728 + email : reports@adonis.osti.gov    * an introduction to using software tools + for automatic differentiation * + [ 2ex ] by + [ 2ex ] uwe naumann and andrea walther </S>"
  ]
}