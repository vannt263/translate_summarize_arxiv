{
  "article_text": [
    "software reliability engineering is an established area of software engineering research and practice that is concerned with the improvement and measurement of reliability . for the analysis typically stochastic",
    "software reliability models are used .",
    "they model the failure process of the software and use other software metrics or failure data as a basis for parameter estimation .",
    "the models are able ( 1 ) to estimate the current reliability and ( 2 ) to predict future failure behaviour .",
    "there are already several established models .",
    "the most important ones has been classified by miller as exponential order statistic ( eos ) models in @xcite .",
    "he divided the models on the highest level into deterministic and doubly stochastic eos models arguing that the failure rates either have a deterministic relationship or are again randomly distributed .",
    "for the deterministic models , miller presented several interesting special cases .",
    "the well - known jelinski - moranda model @xcite , for example , has _",
    "constant rates_. he also stated that _ geometric rates _ are possible as documented by nagel @xcite .    this geometric sequence ( or progression ) between failure rates of faults",
    "was also observed in projects of the communication networks department of the siemens ag . in several older projects",
    "which were analysed , this relationship fitted well to the data .",
    "therefore , a software reliability model based on a geometric sequence of failure rates is proposed .    [",
    "[ problem . ] ] problem . + + + + + + + +    the problem which software reliability engineering still faces is the need for accurate models for different environments and projects",
    ". detailed models with a geometric sequence of failure rates have to our knowledge not been proposed so far .",
    "[ [ contribution . ] ] contribution .",
    "+ + + + + + + + + + + + +    we describe a detailed and practical software reliability model that was motivated out of practical experience and contains a geometric sequence of failure rates which was also suggested by theoretical results .",
    "a detailed comparison shows that this model has a constantly good performance over several projects , although other models perform better in specific projects .",
    "hence , we validated the general assumption that a geometric sequence of failure rates is a reasonable model for software .",
    "[ [ outline . ] ] outline .",
    "+ + + + + + + +    we first describe important aspects of the model in sec .",
    "[ sec : description ] . in sec .",
    "[ sec : evaluation ] the model is evaluated using several defined criteria , most importantly its predictive validity in comparison with established models .",
    "we offer final conclusions in sec .",
    "[ sec : conclusions ] .",
    "related work is cited where appropriate .",
    "the core of the proposed model is a geometric sequence for the failure rates of the faults .",
    "this section describes this and other assumptions in more detail , introduces the main equations and the time component of the model and gives an example of how the parameters of the model can be estimated .",
    "the main theory behind this model is the ordering of the faults that are present in the software based on their failure rates .",
    "the term failure rate describes in this context the probability that an existing fault will result in an erroneous behaviour of the system during a defined time slot or while executing an average operation .",
    "in essence , we assign each fault a time - dependent probability of failure and combine those probabilities to the total failure intensity .",
    "the ordering implies that the fault with the highest probability of triggering a failure comes first , then the fault with the second highest probability and so on .",
    "the probabilities are then arranged on a logarithmic scale to attain an uniform distribution of the points on the @xmath0-axis . the underlying assumption being that there are numerous faults with low failure rates and only a small number of faults with high failure rates . in principle",
    ", we assume an infinite number of faults because of imperfect debugging and updates .",
    "as mentioned above , the logarithmic scale distributes the data points in approximately the same distance from each other .",
    "therefore , this distance is approximated by a constant factor between the probabilities .",
    "then we can use the following geometric sequence ( or progression ) for the calculation of the failure rates : @xmath1 where @xmath2 is the failure rate of the @xmath3-th fault , @xmath4 the failure rate of the first fault , and @xmath5 is a project - specific parameter .",
    "it is assumed that @xmath5 is an indicator for the complexity of a system that may be related to the number of different branches in a program . in past projects of siemens @xmath5",
    "was calculated to be between @xmath6 and @xmath7 .",
    "the parameter @xmath5 is multiplied and not added because the distance is only constant on a logarithmic scale .    the failure occurrence of a fault is assumed to be geometrically distributed .",
    "therefore , the probability that a specific fault occurred by time @xmath8 is the following : @xmath9 we denote with @xmath10 the random variable of the failure time of the fault @xmath11 .    in summary",
    ", the model can be described as the sum of an infinite number of geometrically distributed random variables with different parameters which in turn are described by a geometric sequence .",
    "the two equations that are typically used to describe a software reliability model are the mean number of failures @xmath12 and the failure intensity @xmath13 .",
    "the mean value function needs to consider the expected value over the indicator functions of the faults : @xmath14}(x_a ) } \\right ) \\\\       & = \\sum_{a=1}^\\infty{e(i_{[0,t]}(x_a))}\\\\       & = \\sum_{a=1}^\\infty{p(x_a \\leq t)}\\\\       & = \\sum_{a=1}^\\infty{1 - ( 1 - p_a)^t}. \\end{array } \\label{eq : fischer_mean_new}\\ ] ]    this gives us a typical distribution as depicted in fig .",
    "[ fig : typical_curve ] .",
    "note that the distribution is actually discrete which is not explicitly shown because of the high values used on the @xmath0-axis .",
    "we can not differentiate the mean value equation directly to get the failure intensity .",
    "however , we can use the probability density function ( pdf ) of the geometric distribution to derive this equation .",
    "the pdf of a single fault is @xmath15 therefore , to get the number of failures that occur at a certain point in time @xmath8 , we have to sum up the pdf s of all the faults : @xmath16    an interesting quantity is typically the time that is needed to reach a certain reliability level .",
    "based on the failure intensity objective that is anticipated for the release , this can be derived using the equation for the failure intensity .",
    "rearranging eq .",
    "[ eq : failure_intensity ] gives : @xmath17 what we need , however , is the further required time @xmath18 to determine the necessary length of the test or field trial .",
    "we denote the failure intensity objective @xmath19 and use the following equation to determine @xmath18 : @xmath20 finally , the result needs to be converted into calendar time to be able to give a date for the end of the test or field trial .      in the proposed model time",
    "is measured in incidents , each representing a usage task of the system . to convert these incidents into calendar time it is necessary to introduce an explicit time component .",
    "this contains explicit means to convert from one time format into another .",
    "there are several possibilities to handle time in reliability models .",
    "the preferable is to use execution time directly .",
    "this , however , is often not possible .",
    "subsequently , a suitable substitute must be found . with respect to testing",
    "this could be the number of test cases , for the field use the number of clients and so forth .",
    "[ fig : times ] shows the relationships between different possible time types .",
    "the first possibility is to use in - service time as a substitute .",
    "this requires knowledge of the number of users and the average usage time per user .",
    "then the question arises how this relates to the test cases in system testing .",
    "a first approximation is the average duration of a test case .",
    "the number of incidents is , opposed to the in - service time , a more task - oriented way to measure time .",
    "the main advantage of using incidents , apart from the fact that they are already in use at siemens , is that in this way , we can obtain very intuitive metrics , e.g. , the average number of failures per incident .",
    "there are usually some estimations of the number of incidents per client and data about the number of sold client licenses .",
    "however , the question of the relation to test cases is also open . a first cut would be to assume a test case is equal to an incident . a test case , however , has more `` time value '' than one incident because it is generally directed testing , i.e. , cases with a high probability of failure are preferred .",
    "in addition , a test case is usually unique in function or parameter set while the normal use of a product often consists of similar actions .",
    "when we do not follow the operational profile this should be accounted for .",
    "a possible extension of the model is proposed in @xcite but needs further investigation .",
    "there are two techniques for parameter determination currently in use .",
    "the first is prediction based on data from similar projects .",
    "this is useful for planing purposes before failure data is available .",
    "however , estimations should also be made during test , field trial , and operation based on the sample data available so far .",
    "this is the approach most reliability models use and it is also statistically most advisable since the sample data comes from the population we actually want to analyse . techniques such as maximum likelihood estimation or least squares estimation are used to fit the model to the actual data .",
    "[ [ maximum - likelihood . ] ] maximum likelihood .",
    "+ + + + + + + + + + + + + + + + + + +    the maximum likelihood method essentially uses a likelihood function that describes the probability of a certain number of failures occurring up to a certain time .",
    "this function is filled with sample data and then optimised to find the parameters with the maximum likelihood .",
    "the problem with this is that the likelihood function of this model gets extremely complicated .",
    "essentially , we have an infinite number of random variables that are geometrically distributed , but all with different parameter @xmath21 . even if we constrain ourselves to a high number @xmath22 of variables under consideration it still results in a sum of @xmath23 different products .",
    "this requires to sum up every possible permutation in which @xmath0 failures have occurred up to time @xmath8 .",
    "the number of possibilities is @xmath23 .",
    "each summand is a product of a permutation in which different faults resulted in failures .",
    "@xmath24 where @xmath25 .",
    "an efficient method to maximise this function has not been found .",
    "[ [ least - squares . ] ] least squares .",
    "+ + + + + + + + + + + + + +    for the least squares method an estimate of the failure intensity is used and the relative error to the estimated failure intensity from the model is minimised .",
    "we use the estimate of the mean number of failures for this because it is the original part of the model .",
    "therefore , the square function to be minimised in our case can be written as follows : @xmath26 ^ 2},\\ ] ] where @xmath27 is the number of measurement points , @xmath28 is the measured value for the cumulated failures , and @xmath29 is the time at measurement @xmath30 .    this function is minimised using the simplex variant of nelder and mead @xcite .",
    "we found this method to be usable for our purpose .",
    "we describe several criteria that are used to assess the proposed model .",
    "the criteria that we use for the evaluation of the fischer - wagner model are derived from musa et al .",
    "we assess according to five criteria , four of which can mainly be applied theoretically , whereas one criterion is based on practical applications of the models on real data .",
    "the first criterion is the _ capability _ of the model .",
    "it describes whether the model is able to yield important quantities .",
    "the criterion _ quality of assumptions _",
    "is used to assess the plausibility of the assumptions behind the model .",
    "the cases in which the model can be used are evaluated with the criterion _",
    "applicability_. furthermore , _",
    "simplicity _ is an important aspect for the understandability of the model .",
    "finally , the _ predictive validity _ is assessed by applying the model to real failure data and comparing the deviation .",
    "the main purpose of a reliability model is to aid managers and engineers in planning and managing software projects by estimating useful quantities about the software reliability and the reliability growth .",
    "following @xcite such quantities , in approximate order of importance , are    1 .",
    "current reliability , 2 .   expected date of reaching a specified reliability , 3 .",
    "human and computer resource and cost requirements related to the achievement of the objective .",
    "furthermore , it is a valuable part of a reliability model if it can predict quantities early in the development based on software metrics and/or historical project data .",
    "the model yields the current reliability as current failure intensity and mean number of failures .",
    "it is also able to give predictions based on parameters from historical data .",
    "furthermore , the expected date of reaching a specified reliability can be calculated .",
    "human and computer resources are not explicitly incorporated .",
    "there is an explicit concept of time but , it is not as sophisticated as , for example , in the musa - okumoto model @xcite .      as far as possible",
    ", each assumption should be tested by real data .",
    "at least it should be possible to argue for the plausibility of the assumption based on theoretical knowledge and experience .",
    "also the clarity and explicitness of the assumptions are important .",
    "the main assumption in the proposed model is that the failure rates of the faults follow a geometric sequence .",
    "the intuition is that there are many faults with low failure rates and only a small number of faults with high failure rates .",
    "this is in accordance with software engineering experience and supported by @xcite .",
    "moreover , the geometric sequence as relationship between different faults has been documented in a nasa study @xcite .",
    "furthermore , an assumption is that the occurrence of a failure is geometrically distributed .",
    "the geometric distribution fits because it can describe independent events .",
    "we do not consider continuous time but discrete incidents .",
    "finally , the infinite number of faults makes sense when considering imperfect debugging , i.e. , fault removal can introduce new faults or the old faults are not completely removed .",
    "it is important for a general reliability model to be applicable to software products in different domains and of different size .",
    "also varying project environments or life cycle phases should be feasible",
    ". there are four special situations identified in @xcite that should be possible to handle .    1 .",
    "software evolution 2 .",
    "classification of severity of failures into different categories 3 .",
    "ability to handle incomplete failure data with measurement uncertainties 4 .",
    "operation of the same program on computers of different performance    all real applications of the proposed model have been in the telecommunications area .",
    "however , it was used for software of various sizes and complexities . moreover , during the evaluation of the predictive validity we applied it also to other domains ( see sec .",
    "[ sec : validity ] ) . in principle , the model can be used before and during the field trial .",
    "software evolution is hence not explicitly incorporated .",
    "a classification of failures is possible but has not been used so far .",
    "moreover , the performance of computers is not a strong issue in this domain .",
    "a model should be simple enough to be usable in real project environments : it has to be simple to collect the necessary data , easy to understand the concepts and assumptions , and the model should be implementable in a tool .    while the concepts themselves are not difficult to understand , the model in total is rather complicated because it not only involves failures but also faults .",
    "furthermore , for all these faults the failure is geometrically distributed but each with a different probability .",
    "a main criticism is also that the assumed infinite number of faults make the model difficult to handle . in practical applications of the model and when building a tool , an upper bound of the number of faults must be introduced to be able to calculate model values .",
    "this actually introduces a third model parameter in some sense .",
    "the two parameters , however , can be interpreted as direct measures of the software .",
    "the parameter @xmath4 is the failure probability of the most probable fault and @xmath5 can be seen as a measure of system complexity .",
    "the most important and `` hardest '' criterion for the evaluation of a reliability model is its predictive validity .",
    "a model has to be a faithful abstraction of the real failure process of the software and give valid estimations and predictions of the reliability .",
    "for this we follow again @xcite and use the _ number of failures approach_.      we assume that there have been @xmath31 failures observed at the end of test time ( or field trial time ) @xmath32 .",
    "we use the failure data up to @xmath33 to estimate the parameters of the mean number of failures @xmath12 .",
    "the substitution of the estimates of the parameters yields the estimate of the number of failures @xmath34 .",
    "the estimate is compared with the actual number at @xmath31 .",
    "this procedure is repeated with several @xmath35s .    for a comparison we can plot the relative error @xmath36 against the normalised test time @xmath37 .",
    "the error will approach @xmath38 as @xmath35 approaches @xmath32 .",
    "if the points are positive , the model tends to overestimate and accordingly underestimate if the points are negative .",
    "numbers closer to @xmath38 imply a more accurate prediction and , hence , a better model .      as comparison models we apply four",
    "well - known models : musa basic , musa - okumoto , littlewood - verall , and nhpp .",
    "all these models are implemented in the tool smerfs @xcite that was used to calculate the necessary predictions .",
    "we describe each model in more detail in the following .",
    "[ [ musa - basic . ] ] musa basic .",
    "+ + + + + + + + + + +    the musa basic execution time model assumes that all faults are equally likely to occur , are independent of each other and are actually observed .",
    "the execution times between failures are modelled as piecewise exponentially distributed .",
    "the intensity function is proportional to the number of faults remaining in the program and the fault correction rate is proportional to the failure occurrence rate .    [",
    "[ musa - okumoto . ] ] musa - okumoto .",
    "+ + + + + + + + + + + + +    the musa - okumoto model , also called logarithmic poisson execution time model , was first described in @xcite .",
    "it also assumes that all faults are equally likely to occur and are independent of each other .",
    "the expected number of faults is a logarithmic function of time in this model , and the failure intensity decreases exponentially with the expected failures experienced .",
    "finally , the software will experience an infinite number of failures in infinite time .",
    "[ [ littlewood - verall - bayesian . ] ] littlewood - verall bayesian .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + +    this model was proposed for the first time in @xcite .",
    "the assumptions of the littlewood - verall bayesian model are that successive times between failures are independent random variables each having an exponential distribution .",
    "the distribution for the @xmath39-th failure has a mean of @xmath40 .",
    "the @xmath41s form a sequence of independent variables , each having a gamma distribution with the parameters @xmath42 and @xmath43 .",
    "@xmath43 has either the form : @xmath44 ( linear ) or @xmath45 ( quadratic ) .",
    "we used the quadratic version of the model .",
    "[ [ nhpp . ] ] nhpp .",
    "+ + + + +    various models based on a non - homogeneous poisson process are described in @xcite .",
    "the particular model used also assumes that all faults are equally likely to occur and are independent of each other .",
    "the cumulative number of faults detected at any time follows a poisson distribution with mean @xmath46 .",
    "that mean is such that the expected number of faults in any small time interval about @xmath8 is proportional to the number of undetected faults at time @xmath8 .",
    "the mean is assumed to be a bounded non - decreasing function with @xmath46 approaching the expected total number of faults to be detected as the length of testing goes to infinity .",
    "it is possible to use nhpp on time - between - failure data as well as failure counts .",
    "we used the time - between - failure version in our evaluation .",
    "we apply the reliability models to several different sets of data to compare the predictive validity .",
    "the detailed results for all of these projects can be found in @xcite .",
    "we describe only the combined results in the following .",
    "the used data sets come ( 1 ) from the _ the data & analysis center for software ( dacs ) _ of the us - american department of defence and ( 2 ) from the telecommunication department of siemens .",
    "the dacs data has already been used in several evaluations of software reliability models .",
    "hence , this ensures the comparability of our results . in particular , we used the projects 1 , 6 , and 40 and their failure data from system tests measured in execution time .",
    "the siemens data gives additional insights and analysis of the applicability of the model to these kind of projects .",
    "we mainly analyse two data sets containing the failure data from the field trial of telecommunication software and a web application .",
    "the siemens data contains no execution time but calendar time can be used as approximation because of constant usage during field trial .",
    "all these projects come from different domains with various sizes and requirements to ensure a representative evaluation .",
    "the usage of the number of failures approach for each project resulted in different curves for the predictive validity over time . for a better general comparison we combined the data into one plot which can be found in fig .",
    "[ fig : total ] .",
    "this combination is straight - forward as we only considered relative time and relative errors . to avoid",
    "that strongly positive and strongly negative values combined give very small errors we use medians instead of average values .",
    "the plot shows that with regard to the analysed projects the littlewood - verall model gives very accurate predictions , also the nhpp and the proposed model are strong from early on .",
    "however , for an accurate interpretation we have to note that the data of the littlewood - verall model for one of the siemens projects was not incorporated into this comparison because its predictions were far off with a relative error of about 6 .",
    "therefore , the model has an extremely good predictive validity if it gives reasonable results but unacceptable predictions for some projects .",
    "a similar argument can be made for the nhpp model which made the weakest predictions for one of the dacs projects .",
    "the proposed model can not reach the validity of these models for particular projects , but has a more constant performance over all projects .",
    "this is important because it is difficult to determine which of the models gives accurate predictions in the early stages of application since there is only a small amount of data .",
    "using the littlewood - verall or nhpp model could lead to extremely bad predictions in some cases .",
    "we conclude with a summary of our investigations and give some directions for future work .",
    "we propose a software reliability model that is based on a geometric series of the failure rates of faults .",
    "this basis is suggested from the theory by miller in @xcite as well as from practice in nagel et al .  in @xcite and siemens projects .",
    "the model has a state - of - the - art parameter determination approach and a corresponding prototype implementation of it .",
    "several data sets from dacs and siemens are used to evaluate the predictive validity of the model in comparison to well - established models .",
    "we find that the proposed model often has a similar predictive validity as the comparison models and outperforms most of them",
    ". however , there is always one of the models that performs better than ours .",
    "nevertheless , we are able to validate the assumption that a geometric sequence of failure rates of faults is a reasonable model for software reliability .",
    "the early estimation of the model parameters is always a problem in reliability modelling .",
    "therefore , we plan to evaluate the correlation with other system parameters .",
    "for example the parameter @xmath5 of the model is supposed to represent the complexity of the system .",
    "therefore , one or more complexity metrics of the software code could be used for early prediction .",
    "this needs extensive empirical analysis but could improve the estimation in the early phases significantly .",
    "furthermore , a time component that also takes uncertainty into account would be most accurate .",
    "the musa basic and musa - okumoto models were given such components ( see @xcite ) .",
    "they model the usage as a random process and give estimates about the corresponding calendar time to an execution time .",
    "further applications with other data sets and comparison with other types of prediction techniques , such as neural networks , are necessary to evaluate the general applicability and predictive validity of the proposed model .",
    "finally , we plan to use the model in an economics models for software quality @xcite and work further on a possibility to estimate the test efficiency using the proposed model .",
    "some early ideas are presented in @xcite ."
  ],
  "abstract_text": [
    "<S> software reliability models are an important tool in quality management and release planning . </S>",
    "<S> there is a large number of different models that often exhibit strengths in different areas . </S>",
    "<S> this paper proposes a model that is based on a geometric sequence ( or progression ) of the failure rates of faults . </S>",
    "<S> this property of the failure process was observed in practice at siemens among others and led to the development of the proposed model . </S>",
    "<S> it is described in detail and evaluated using standard criteria . </S>",
    "<S> most importantly , the model performs constantly well over several projects in terms of its predictive validity . </S>"
  ]
}