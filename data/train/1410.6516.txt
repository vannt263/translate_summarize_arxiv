{
  "article_text": [
    "the _ coalition structure generation _ problem is a fundamental problem in multi - agent systems research .",
    "it involves partitioning the set of agents into mutually disjoint coalitions so that the total reward from the resulting coalitions is maximized .",
    "most of the literature on this topic assumes that the agents can split into teams ( or _ coalitions _ ) in any way they like . in practice",
    ", however , some coalition structures may be inadmissible due to various constraints present in the problem domain .",
    "this paper considers one such class of problems , known as _ graph - restricted games _",
    "@xcite . here",
    ", we are given a graph in which every node represents an agent , and every edge can be interpreted as a communication channel , or a trust relationship , which facilitates the cooperation between its two ends .",
    "a coalition is then feasible if and only if it induces a connected subgraph of @xmath0 .",
    "the intuition here is that any two agents can not belong to the same coalition unless they are able to communicate with one another , either directly through an edge , or indirectly through ( some of ) the other members of the coalition who collectively form a path between the two agents . following convention",
    ", we will assume that @xmath0 is connected .",
    "is not connected , the coalition structure generation problem can be decomposed into smaller independent sub - problems , each having a connected graph . ]    to the best of our knowledge , the two state - of - the - art algorithms for solving the coalition structure generation problem in graph - restricted games are : ( i ) a tree - search algorithm called @xmath1 @xcite , and ( ii ) a dynamic - programming algorithm called @xmath2 @xcite .",
    "each algorithm has its relative strengths and weakness compared to the other .",
    "in particular ,    * @xmath1 is superior in that it is an anytime algorithm ",
    "its solution quality improves monotonically as computation time increases . as such",
    ", it can return a valid solution even if it was unable to run to completion , e.g. , due to a failure or due to time constraints .",
    "@xmath2 , on the other hand , is not an anytime algorithm , and so does not return interim solutions .",
    "another advantage of @xmath1 is that it applies a branch - and - bound technique , which enables it to exploit the specifics of any given problem instance , resulting in ( possibly significant ) speedups .",
    "this is not possible with @xmath2 due to the absence of any such a branch - and - bound technique .",
    "finally , @xmath1 uses very little memory compared to @xmath2 ; the latter requires storing in memory the solutions of different sub - problems , the number of which may be exponential ( depending on the density of the graph ) .",
    "* on the other hand , @xmath2 is superior in terms of the computational complexity .",
    "for instance , given a complete graph of @xmath3 agents , @xmath2 runs in @xmath4 , while @xmath1 runs in @xmath5 .",
    "this is because the latter depends heavily on the branch - and - bound technique which , in the worst case , may fail to prune even a single solution , resulting in a brute - force search .",
    "since @xmath2 and @xmath1 have their own strengths and weaknesses relative to each other , it is desirable to develop an algorithm that has the best of both .",
    "perhaps a promising direction is to combine @xmath2 with @xmath1 , following the steps of @xcite , who handled the general ( not graph - restricted ) coalition structure generation problem by combining a dynamic programming algorithm @xcite with a depth - first search algorithm @xcite , thus obtaining the best of both . in our case , however , @xmath1 and @xmath2 are built on entirely different search - space representations ( see section  [ sec : relatedwork ] ) , which makes it hard to combine the two algorithms elegantly and efficiently .    with this in mind",
    ", the contribution of this paper are as follows :    * we develop @xmath6a new depth - first search algorithm specifically designed to be compatible with @xmath2 . *",
    "we show how to modify both @xmath6 and @xmath2 such that they complement one another when merged into a single hybrid algorithm , called @xmath7 .",
    "* we empirically evaluate @xmath7 in randomly - generated super - subadditive settings , and show that it significantly outperforms its constituent parts .",
    "the remainder of the paper is structured as follows .",
    "the main notation is introduced in section  [ sec : preliminaries ] .",
    "the existing dynamic - programming algorithm@xmath2and the existing tree - search algorithm@xmath1are described in section  [ sec : relatedwork ] .",
    "our new tree - search algorithm@xmath6is introduced in section  [ sec : tsp ] .",
    "the hybrid algorithm@xmath7is introduced in section  [ sec : d - tsp ] .",
    "finally , section  [ sec : conclusions ] concludes the paper and discusses future directions .",
    "a graph - restricted game is a tuple , @xmath8 , where @xmath9 is the set of agents , @xmath10 is a characteristic function that evaluates each coalition of agents , and @xmath11 is a graph whose set of nodes is @xmath9 , and whose set of edges , @xmath12 , specifies which agents are connected to each other",
    ". the number of agents in @xmath9 will be denoted by @xmath3 .",
    "for every coalition , @xmath13 , let @xmath14 denote the set of partitions of @xmath15 , also known as coalition structures over @xmath15 .",
    "given our focus on characteristic function games , the value of a partition is simply the sum of the values of the coalitions therein .",
    "more formally , for every @xmath13 , and every @xmath16 , the value of partition @xmath17 is : @xmath18 we will denote by @xmath19 an optimal partition of @xmath15 , and by @xmath20 the value of such a partition .",
    "more formally , @xmath21 in a graph - restricted game , @xmath8 , we say that a coalition , @xmath13 , is _ connected in @xmath0 _ if and only if @xmath15 induces a connected subgraph of @xmath0 .",
    "moreover , for every @xmath13 , we will denote by @xmath22 the set of all non - empty subsets of @xmath15 that are each connected in @xmath0 .",
    "similarly , we will denote by @xmath23 the set of every partition in @xmath14 whose coalitions are connected in @xmath0 .",
    "more formally , @xmath24 .",
    "then , given @xmath8 , the coalition structure generation problem is to find an optimal partition of @xmath9 , defined as follows : @xmath25 next , we define _ weakly super - subadditive games_. to this end , recall that a game @xmath26 is _ weakly superadditive _ if : @xmath27 for any two disjoint coalitions @xmath28",
    "( i.e. , merging any two coalitions is never harmful ) .",
    "conversely , a game @xmath26 is _ weakly subadditive _ if : @xmath29 for any two disjoint coalitions @xmath28",
    "( i.e. , merging any two coalitions is never beneficial ) . finally , recall that a game @xmath26 is the _ sum _ of two games , @xmath30 and @xmath31 , if @xmath32 for all @xmath13 . in this case , we write : @xmath33 .",
    "now , we are ready to introduce the following definition .",
    "a game @xmath26 is ( weakly ) super - subadditive if it is the sum of two games : a ( weakly ) superadditive game , denoted by @xmath34 , and a ( weakly ) subadditive game , denoted by @xmath35 .",
    "the intuition is that @xmath34 represents the rewards from cooperation , which is assumed to increase ( weakly ) with the size of the coalition . on the other hand",
    ", @xmath35 represents the coordination costs , which are also assumed to increase ( weakly ) with the size of the coalition .",
    "this section is divided into two subsections .",
    "the first describes the @xmath1 algorithm of @xcite , while the second describes the @xmath2 algorithm of @xcite .",
    "@xcite proposed the @xmath1 algorithm .",
    "it is based on _",
    "edge contraction_a basic operation in graph theory which involves : ( i ) _ removing _ an edge from a graph , and ( ii ) _ merging _ the two nodes that were previously joined by that edge . in our context of graph - restricted games , since every node represents an agent ( i.e. , a singleton coalition ) , _ `` merging the two nodes '' _ corresponds to _ merging the two coalitions _ that were represented by those nodes .",
    "an example is illustrated in figure  [ fig : bistaffa](a ) .",
    "taking the entire graph into consideration , the contraction of an edge can be interpreted as a transition from one coalition structure to another .",
    "for instance , the contraction of the edge @xmath36 in figure  [ fig : bistaffa](b ) corresponds to the transition from @xmath37 to @xmath38 . based on this observation",
    ", the algorithm repeats the process of contracting different edges , in order to eventually visit all coalition structures . during this process , to ensure that each coalition structure is visited no more than once , the algorithm marks all previously - contracted edges to avoid contracting them again in the future . in figure",
    "[ fig : bistaffa ] , the marked edges are illustrated as dashed lines .",
    "here , it is important to note that the contraction of an edge may result in merging other edges . in figure",
    "[ fig : bistaffa](b ) for example , contracting @xmath36 results in merging @xmath39 with @xmath40 , as well as merging @xmath41 with @xmath42 .",
    "whenever this happens , if one of the merged edges happens to be dashed , the edge that results from the merger must also be dashed , again see figure  [ fig : bistaffa](b ) .",
    "this ensures that the agents appearing at the two ends of a dashed edge never appear together in the same coalition .",
    "figure  [ fig : bistaffa](c ) illustrates the sequence in which the algorithm visits all possible coalition structures given the graph @xmath11 where @xmath43 and @xmath44 .",
    "each coalition structure is represented as a node in the illustrated search tree , and the numbers on the edges represent the order in which the algorithm visits the different coalition structures .",
    "to speed up the search , a branch - and - bound technique is used whenever the algorithm visits a node  i.e .",
    ", a partition , @xmath17in the search tree .",
    "the purpose of this technique is to determine whether it is worthwhile to search @xmath45the sub - tree rooted at @xmath17 .",
    "the general idea is to compute an upper bound , denoted @xmath46 , on the values of all partitions in @xmath45 .",
    "then , if this upper bound was not greater than the value of the best partition found so far , then the algorithm avoids searching @xmath45 .",
    "bistaffa et al .",
    "proposed a way of computing @xmath46 for cases where the game under consideration is weakly super - subadditive ( see section  [ sec : preliminaries ] for more details ) .",
    "in particular , it is possible to compute an upper bound @xmath47 based on the following observations :    * every coalition structure in @xmath45 is the result of merging some ( if not all ) of the coalitions in @xmath17 that are connected via solid edges . here , the only constraint is that agents appearing at the two ends of a dashed edge must not appear together in the same coalition . *",
    "merging coalitions in @xmath17 can never improve solution quality in a weakly subadditive game .",
    "thus , @xmath48 .",
    "* merging coalitions in @xmath17 can never reduce solution quality in a weakly superadditive game .",
    "thus , no solution in @xmath45 can be better than the solution obtained by : ( i ) removing all dashed edges , and ( ii ) merging all coalitions in @xmath17 that are connected via solid edges .",
    "let us denote this solution as @xmath49 .",
    "then , @xmath50 .    based on the above observations",
    ", we can establish the following upper bound on solution quality : @xmath51 .",
    "this concludes our description of bistaffa et al.s algorithm .",
    "more details can be found in @xcite .",
    "@xcite proposed a dynamic - programming algorithm called @xmath2 . before explaining how this algorithm works , let us first briefly describe how dynamic programming works for general games , rather than graph - restricted games . here",
    "is the main idea : to compute an optimal partition of the set of agents , @xmath9 :    * first , compute an optimal partition of each strict subset of @xmath9 . * after that , examine all the possible ways of splitting @xmath9 into two halves , and replace one of the halves with its optimal partition . more specifically , for every non - empty subset @xmath52 , split @xmath9 into two halves , @xmath53 and @xmath54 , and replace @xmath54 with @xmath55 . clearly , the union @xmath56 is a partition of @xmath9 , and the value of this union is @xmath57 .",
    "furthermore , the best such union ( i.e. , the one with the largest value ) is an optimal partition of @xmath9 .",
    "importantly , the above process can be carried out recursively , as captured by the following formula :    @xmath58    having described a general dynamic programming formula , we now explain how @xmath2 speeds up this formula when the game is restricted by a graph .",
    "the main idea is to use a _ pseudotree_. basically , given a graph @xmath11 , the pseudotree of @xmath0 , denoted by @xmath59 , is a rooted tree such that : ( i ) the set of nodes of @xmath59 is the set of agents , and ( ii ) any two agents who share an edge in @xmath0 appear on the same branch in @xmath59 ( an example is illustrated in figure  [ fig : vinyals ] ) .",
    "let us now explain how @xmath2 uses the pseudotree to speed up the formula . to this end , let @xmath60 denote the agent at the @xmath61 position of the breadth - first order of nodes in @xmath59 . in figure",
    "[ fig : vinyals](b ) for example , that order is : @xmath62 , and so @xmath63 while @xmath64 .",
    "now , the broad idea behind @xmath2 is to start with the last agent in the breadth - first order , @xmath65 , and then move to @xmath66 , then @xmath67 and so on until it reaches @xmath68 .",
    "let @xmath69 denote the agent at which @xmath2 has reached in the breadth - first order at any point in time during execution .",
    "then , for each @xmath69 , the algorithm solves the following sub - problems :    @xmath70    the pseudo code of @xmath2 is shown in algorithm  [ alg : dype ] . for a proof of the correctness of this algorithm ,",
    "see @xcite .     and its corresponding pseudotree @xmath59.,width=340 ]     + @xmath71 ; + ( ) @xmath72 @xmath73 ; +   + @xmath74 ; + @xmath75 ;",
    "as mentioned earlier in the introduction , @xcite developed an algorithm for general coalition structure generation problems , which combined a tree - search algorithm with a dynamic - programming algorithm , resulting in a combination that is superior to both its constituent parts .",
    "so why not develop a similar hybrid algorithm for graph - restricted games ?",
    "perhaps the most natural starting point would be to try and combine @xmath1an existing tree - search algorithm  with @xmath2an existing dynamic - programming algorithm .",
    "unfortunately , however , as we have seen in the above section , both algorithms are based on very different ideas ; one is based on _ edge contraction _ , while the other is based on a _",
    "pseudo tree_. as such , the two seem incompatible , or at least hard to combine smoothly . with this in mind ,",
    "our goal in this section is to develop a tree - search algorithm that can be combined with @xmath2 .",
    "we build our algorithm around the pseudotree representation used by @xmath2 ; the hypothesis here is that if the two algorithms were built around the same representation , it should be possible to combine the two smoothly and effectively .",
    "based on this , we call our algorithm @xmath6 , where ts stands for tree - search , and p stands for pseudotree .    the pseudo code of @xmath6 can be found in algorithm  [ alg : tsp : main ] . in more detail ,",
    "the algorithm takes as input a graph - restricted game , @xmath8 , and a pseudotree @xmath59 .",
    "first , in lines 1 to 4 , it initializes @xmath76the current best solution  to either be equal to @xmath77 or @xmath78 , whichever has higher value . after that , in line  5 , it uses the parameter @xmath79 to iterate over the agents in a breadth - first order in @xmath59 , starting with @xmath80 , and ending with @xmath65.[multiblock footnote omitted ] let us denote by @xmath81 the agents who is just before @xmath79 in the breadth - first order .",
    "now , for every @xmath79 , the algorithm enumerates all the coalitions that are each connected in @xmath0 , and contain every agent in @xmath82 but do not contain @xmath79 ( line  6 ) . for every such coalition , @xmath15",
    ", the algorithm sets the current partition , @xmath83 , to be equal to @xmath84 ( line  7 ) .",
    "finally , in line  8 , it used the function @xmath85 to search through the coalition structures that are supersets of @xmath83 , i.e. , the coalition structure that contain @xmath15 .",
    "basically , this recursive function generates different partitions while trying to avoid the unpromising ones using a branch - and - bound technique .",
    "next , we explain how this function works .",
    "+   + @xmath76 ;    the pseudo code of @xmath85 is given in algorithm  [ alg : tsp : search ] .",
    "here , @xmath86 denotes the agents that are not in @xmath83 ( line  1 of algorithm  [ alg : tsp : search ] ) , while @xmath87 denotes the first agent in the breadth - first order who is not in @xmath83 ( line  2 ) . then , out of all the connected coalitions that can be added to @xmath83 , the algorithm always starts by adding to @xmath83 a coalition containing @xmath87 ( lines 3 and 4 ) .",
    "now if the new @xmath83 is a coalition structure over @xmath9 , then the algorithm updates @xmath76the best solution found so far ( lines 5 to 7 ) .",
    "otherwise , it computes an upper bound on the value of every partition of @xmath9 that is a superset of the new @xmath83 ( line  9 ) .",
    "based on this upper bound , the algorithm determines whether it is worthwhile to consider adding more coalitions to the new @xmath83 ( line  10 ) .",
    "if so , then it makes a recursive call with the new @xmath83 ( line  11 ) .",
    "the function @xmath88which computes the aforementioned upper bound  can be specified based on any additional domain knowledge .",
    "for instance , if the game is known to be super - subadditive , then this function may return : @xmath89 .",
    "@xmath90 ; + @xmath91 ; + ( ) @xmath92 @xmath93 @xmath94 ; + ( ) @xmath95 @xmath96 @xmath97 ; +   @xmath76 ;",
    "in this section , we present @xmath7a hybrid algorithm that combines @xmath2 with @xmath6 in a way that obtains the best features of both .",
    "first , we introduce the necessary modifications of each algorithm ( subsections [ sec : dype * ] and [ sec : tsp * ] ) , and then show how to combine the modified versions ( subsection  [ sec : dypesubsection ] ) .      in this subsection , we modify @xmath2 such that it becomes an anytime algorihtm , i.e. , it does not only return a solution _ after _ termination , but also returns interim solutions _ during _ execution .",
    "this clearly adds more resilience against failure .",
    "for example , if the algorithm runs out of memory during execution , then instead of wasting all the effort that the algorithm has put before the failure , it would at least return a valid solution using all the sub - problems that it has already solved .    before introducing our modifications ,",
    "let us first revisit @xmath2 and analyze the way it works .",
    "looking at algorithm  [ alg : dype ] , one can see that @xmath2 ultimately boils down to the following main steps :    * * step 1 : * with @xmath69 running from @xmath65 to @xmath80 , solve the following sub - problems : @xmath99 such that @xmath100 and @xmath101 and @xmath102 is connected ( lines 1 to 8 of algorithm  [ alg : dype ] ) . *",
    "* step 2 : * for each subset @xmath72 , compute the value of the best coalition structure containing @xmath53 ( lines 10 and 11 of algorithm  [ alg : dype ] ) .",
    "the problem with the above process is that @xmath2 does not examine a single coalition structure over @xmath9 until it has finished step  1a step which involves solving sub - problems the number of which may be exponential ( depending on the topology of the graph ) .",
    "let us now consider a sample subset that the algorithm encounters during step  2 , given a problem of @xmath103 agents .",
    "let this subset be @xmath104 .",
    "when the algorithm encounters this particular @xmath53 , it will compute the value of the best coalition structure containing @xmath105 , using the already - computed solutions to the following sub - problems : @xmath106 where @xmath107 is a connected component in the sub - graph induced by @xmath108 ( see line  11 of algorithm  [ alg : dype ] ) .",
    "our critical observation is that the solutions to the aforementioned sub - problems were all computed when @xmath2 finished dealing with @xmath109 in step  1 .",
    "more specifically , at that moment , @xmath2 has already solved the following sub - problems :    * @xmath99 where @xmath102 is connected and @xmath110 and @xmath111 ; * @xmath99 where @xmath102 is connected and @xmath112 and @xmath113 ; * @xmath99 where @xmath102 is connected and @xmath114 and @xmath115 ; * @xmath99 where @xmath102 is connected and @xmath116 and @xmath117 .",
    "the above sub - problems surely include every @xmath106 where @xmath107 is a connected component in the sub - graph induced by @xmath108 .",
    "in other words , after solving the above sub - problems , @xmath2 had all the information needed to compute the value of the best coalition structure containing @xmath105 .",
    "this suggests that @xmath2 can be modified such that it examines certain coalition structures _ during _ step  1 , not _ after _",
    "step  1 .    based on the above observation",
    ", we modify @xmath2 such that , instead of following the above two steps , it follows txhis one :    * * step 1 : * with @xmath69 running from @xmath65 to @xmath80 : * * * step 1.1 : * solve the following sub - problems : @xmath99 such that @xmath100 and @xmath101 and @xmath102 is connected . * * * step 1.2 : * for each subset @xmath118 such that @xmath119 and @xmath120 , compute the value of the best coalition structure containing @xmath53 .    one can easily see that , with the above steps , the algorithm will never consider the same @xmath53 more than once . moreover , whenever a certain @xmath53 is encountered , all relevant sub - problems of @xmath54 have already been solved , including every @xmath106 where @xmath107 is a connected component in the sub - graph induced by @xmath54 .",
    "we call the modified version @xmath98 . the pseudo code is provided in algorithm  [ alg : dype * ] . as can be seen , this an anytime algorithm , unlike @xmath2",
    ".    @xmath121 ; + @xmath76 ;      our goal in this subsection is to modify @xmath6 such that it can take advantage of any solutions to sub - problems that were already computed by @xmath98 .",
    "to this end , let us first analyze how @xmath6 works . looking at algorithm  [ alg : tsp : main ] , one can see that @xmath6 ultimately boils down to the following main steps :    * * step  1 : * with @xmath79 running from @xmath80 to @xmath65 , set the _ current partition _",
    "@xmath83 to be equal to some @xmath84 , where @xmath15 is a connected coalition that contains does not contain @xmath79 , but contains all of : @xmath123 ( lines 5 to 7 of algorithm  [ alg : tsp : main ] ) .",
    "denotes the agent just before @xmath79 in the breadth - first order of agents in the pseudo tree @xmath124 . ] * * * step  1.1 : * keep adding different coalitions to @xmath83 , thus obtaining different coalition structures over @xmath9 ( line  8 of algorithm  [ alg : tsp : main ] ) . any coalition added",
    "to @xmath83 must contain @xmath87the first agent in the breadth - first order who is not already in @xmath83 ( see line  2 of algorithm  [ alg : tsp : search ] ) . every time a new coalition is added to @xmath83 , a branch - and - bound technique",
    "is used to check whether the coalitions that are in @xmath83 are promising ( lines 9 to 11 of algorithm  [ alg : tsp : search ] ) .    during the above process , for any given @xmath83 , the algorithm will try all possible coalition structures that are supersets of @xmath83 , except those that are deemed unpromising by the branch - and - bound technique . in other words",
    ", it will try adding to @xmath83 every promising partition of @xmath125 .",
    "importantly , however , if we were to run @xmath98 in parallel with @xmath6 , then the latter algorithm may be able to construct an optimal partition of @xmath125 easily using the partial results of the former .",
    "this is based on the following two observations :    * @xmath126 .",
    "this is simply because @xmath87 is by definition the first agent in the breadth - first order who is not in @xmath83 . *",
    "if the current @xmath69 happens to be before @xmath87 in the breadth - first order , then @xmath98 has already computed all relevant sub - problems @xmath99 such that @xmath127 ( see sectino  [ sec : dype * ] for more details ) .",
    "based on the above observations , we propose a modified version of @xmath6 , called @xmath122 , which works as follows . whenever @xmath69 happens to be before @xmath87 in the breadth - first order ,",
    "@xmath122 does not try the different partitions of @xmath128 , but instead computes the value of an optimal such partition as follows : @xmath129 now , if @xmath130 happens to be greater than @xmath131the value of the current best solution , then @xmath122 needs to compute a coalition structure @xmath132 because it is better than @xmath76 .",
    "this computation can be done as follows .",
    "first , the algorithm sets @xmath76 to be equal to @xmath133 , and then iteratively replaces every @xmath134 with @xmath135 and @xmath136 .",
    "this is done until @xmath137 for all @xmath134 .      in this subsection , we introduce @xmath7 , an algorithm that runs both @xmath98 and @xmath122 in parallel , such that they aid each other during the search .",
    "basically , @xmath7 is based on the following observations :    * @xmath98 solves sub - problems in the following sequence ( see sectino  [ sec : dype * ] for more details ) . with @xmath69 running from @xmath65 to @xmath80 * * it solves the sub - problems : @xmath99 such that @xmath100 and @xmath101 and @xmath102 is connected ( see lines 2 and 3 of algorithm  [ alg : dype * ] ) .",
    "* * it searches all coalition structures containing a connected coalition @xmath15 where : @xmath138 * we deliberately designed @xmath122 such that it searches coalition structures in the following sequence . with @xmath79 running from @xmath80 to @xmath65 ,",
    "it searches all coalition structures containing a connected coalition @xmath15 where : @xmath139 .",
    "note that @xmath69 runs from @xmath65 to @xmath80 , while @xmath79 runs from @xmath80 to @xmath65 .",
    "thus , based on the above observations , when the position of @xmath69 becomes smaller than that of @xmath79 , the algorithms @xmath98 and @xmath122 would have jointly searched the entire space , at which case @xmath7 terminates .",
    "our aim was to develop a coalition structure generation problem for graph - restricted games .",
    "our inspiration came from an algorithm for general coalition structure generation problems , which combined a dynamic - programming algorithm with a tree - search algorithm , resulting in a combination that is superior to both its constituent parts @xcite . following these guidelines",
    ", we developed a tree - search algorithm , called @xmath6 to be compatible with an existing dynamic - programming algorithm , called @xmath2 @xcite .",
    "after that , we showed how to modify the two algorithms such that they are compatible with each other .",
    "specifically , we modified @xmath2 to make an anytime algorithm that returns interim solutions , and modified @xmath6 such that it solutions to sub - problems that were computed by @xmath2 at any point in time .",
    "after that , we showed that the modified version of @xmath2 gradually covers the search space from a certain direction , while the modified version of @xmath6 gradually covers the search space from the opposite direction ; the two algorithms terminate when they meet each other somewhere in the middle .",
    "this way , the portion searched by each algorithm will naturally reflect its relative strength on the problem instance at hand .",
    "our future work involves evaluating @xmath7 empirically on a wider range of graph - restricted games ."
  ],
  "abstract_text": [
    "<S> two fundamental algorithm - design paradigms are _ tree search _ and _ dynamic programming_. the techniques used therein have been shown to complement one another when solving the complete set partitioning problem , also known as the _ coalition structure generation _ </S>",
    "<S> problem @xcite . inspired by this observation </S>",
    "<S> , we develop in this paper an algorithm to solve the coalition structure generation problem on graphs , where the goal is to identifying an optimal partition of a graph into connected subgraphs . </S>",
    "<S> more specifically , we develop a new depth - first search algorithm , and combine it with an existing dynamic programming algorithm due to @xcite . </S>",
    "<S> the resulting hybrid algorithm is empirically shown to significantly outperform both its constituent parts when the subset - evaluation function happens to have certain intuitive properties . </S>"
  ]
}