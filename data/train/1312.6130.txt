{
  "article_text": [
    "the distinction between default negation and strong negation has been useful in answer set programming . in particular",
    ", it yields an elegant solution to the frame problem .",
    "the fact that block @xmath0 stays at the same location @xmath1 by inertia can be described by the rule l ion(b , l , t+1)ion(b , l , t ) ,  ion(b , l , t+1 ) along with the rule that describes the uniqueness of location values @xcite , ion(b , l_1,t)ion(b , l , t ) ,  ll_1  . here ` @xmath2 ' is the symbol for strong negation that represents explicit falsity while ` @xmath3 ' is the symbol for default negation ( negation as failure ) .",
    "rule  ( [ inertia - on - sneg ] ) asserts that without explicit evidence to the contrary , block @xmath0 remains at location @xmath1 .",
    "if we are given explicit conflicting information about the location of @xmath0 at time @xmath4 then this conclusion will be defeated by rule  ( [ unique - on - sneg ] ) , which asserts the uniqueness of location values .",
    "an alternative representation of inertia , which uses choice rules instead of strong negation , was recently presented by @xcite  [ @xcite ] . instead of rule",
    ", they use the choice rule \\{ion(b , l , t+1 ) } ion(b , l , t )  , which states that `` if @xmath0 is at @xmath1 at time @xmath5 , then decide arbitrarily whether to assert that @xmath0 is at @xmath1 at time @xmath4 . '' instead of rule  , they write weaker rules for describing the functional property of @xmath6 : @xmath7 which can be also combined into one rule : @xmath8 in the absence of additional information about the location of block @xmath0 at time @xmath4 , asserting @xmath9 is the only option , in view of the existence of location constraint .",
    "but if we are given conflicting information about the location of @xmath0 at time @xmath4 then not asserting @xmath9 is the only option , in view of the uniqueness of location constraint .",
    "rules  , , and together can be more succinctly represented in the language of  @xcite by means of intensional functions .",
    "that is , the three rules can be replaced by one rule \\{iloc(b , t+1)=l}iloc(b , t)=l  , where @xmath10 is an intensional function constant ( the rule reads , `` if block @xmath0 is at location @xmath1 at time @xmath5 , by default , the block is at @xmath1 at time @xmath4 '' ) .",
    "in fact , corollary  2 of @xcite tells us how to eliminate intensional functions in favor of intensional predicates , justifying the equivalence between   and the set of rules  , , and .",
    "the translation allows us to compute the language of  @xcite using existing asp solvers , such as smodels and gringo .",
    "however , dlv can not be used because it does not accept choice rules . on the other hand ,",
    "all these solvers accept rules   and , which contain strong negation .",
    "the two representations of inertia involving intensional predicate @xmath6 do not result in the same answer sets . in the first representation , which uses strong negation ,",
    "each answer set contains only one atom of the form @xmath11 for each block @xmath0 and each time @xmath5 ; for all other locations @xmath12 , negative literals @xmath13 belong to the answer set . on the other hand",
    ", such negative literals do not occur in the answer sets of a program that follows the second representation , which yields fewer ground atoms .",
    "this difference can be well explained by the difference between the symmetric and the asymmetric views of predicates that lifschitz described in his message to texas action group , titled `` choice rules and the belief - based view of asp '' :     _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ the way i see it , in asp programs we use predicates of two kinds , let s call them `` symmetric '' and `` asymmetric . ''",
    "the fact that an object @xmath14 does not have a property  @xmath15 is reflected by the presence of @xmath16 in the answer set if @xmath15 is `` symmetric , '' and by the absence of @xmath17 if @xmath15 is `` asymmetric . '' in the second case , the strong negation of @xmath15 is not used in the program at all . _",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    according to these terminologies , predicate @xmath6 is symmetric in the first representation , and asymmetric in the second representation .",
    "this paper presents several technical results that help us understand the relationship between these two views . in this regard",
    ", it helps us to understand strong negation as a way of expressing intensional boolean functions .",
    "* our first result provides an alternative account of strong negation in terms of boolean intensional functions .",
    "for instance , can be identified with @xmath18 and can be identified with @xmath19 under complete interpretations , we show that minimizing both positive and negative literals in the traditional answer set semantics is essentially the same as ensuring the uniqueness of boolean function values under the functional stable model semantics . in this sense , strong negation can be viewed as a mere disguise of boolean functions . *",
    "we show how non - boolean intensional functions can be eliminated in favor of boolean functions .",
    "combined with the result in the first bullet , this tells us a new way of turning the language of @xcite into traditional answer set programs with strong negation , so that system dlv , as well as smodels and gringo , can be used for computing the language of @xcite . as an example , it tells us how to turn   into the set of rules   and .",
    "* @xcite [ @xcite ] recently proposed `` two - valued logic programs , '' which modifies the traditional stable model semantics to represent complete information without distinguishing between strong negation and default negation . using our result that views strong negation in terms of boolean functions , we show that two - valued logic programs are in fact a special case of the functional stable model semantics in which every function is boolean .    while the main results are stated for the language of  @xcite , similar results hold with the language of  @xcite based on the relationship between the two languages studied in  @xcite .",
    "furthermore , we note that the complete interpretation assumption in the first bullet can be dropped if we instead refer to the language of  @xcite , at the price of introducing partial interpretations .    the paper is organized as follows . in section  [ sec : preliminaries ] we review the two versions of the stable model semantics , one that allows strong negation , but is limited to express intensional predicates only , and the other that allows both intensional predicates and intensional functions . as a special case of the latter we also present multi - valued propositional formulas under the stable model semantics .",
    "section  [ sec : sneg - bf ] shows how strong negation can be viewed in terms of boolean functions .",
    "section  [ sec : nonbool - sneg ] shows how non - boolean functions can be eliminated in favor of boolean functions .",
    "section  [ sec : tvlp ] shows how lifschitz s two - valued logic programs can be viewed as a special case of the functional stable model semantics .",
    "section  [ sec : sneg - cabalar ] shows how strong negation can be represented in the language of @xcite .",
    "this review follows  @xcite .",
    "a _ signature _ is defined as in first - order logic , consisting of _ function constants _ and _ predicate constants_. function constants of arity @xmath20 are also called _ object constants_. we assume the following set of primitive propositional connectives and quantifiers : @xmath21 .",
    "the syntax of a formula is defined as in first - order logic .",
    "we understand @xmath22 as an abbreviation of @xmath23 .",
    "the stable models of a sentence @xmath24 relative to a list of predicates @xmath25 are defined via the _ stable model operator with the intensional predicates @xmath26 _ , denoted by @xmath27 $ ] .",
    "let @xmath28 be a list of distinct predicate variables @xmath29 of the same length as  @xmath26 .",
    "by @xmath30 we denote the conjunction of the formulas @xmath31 , where @xmath32 is a list of distinct object variables of the same length as the arity of @xmath33 , for all @xmath34 . by @xmath35",
    "we denote the conjunction of the formulas @xmath36 for all @xmath34 , and @xmath37 stands for @xmath38 . for any first - order sentence @xmath24 ,",
    "expression @xmath39 $ ] stands for the second - order sentence @xmath40 where @xmath41 is defined recursively :    * @xmath42 for any list @xmath43 of terms ; * @xmath44 for any atomic formula  @xmath24 ( including @xmath45 and equality ) that does not contain members of  @xmath26 ; * @xmath46 ;   @xmath47 ; * @xmath48 ; * @xmath49 ;  @xmath50 .    a model of a sentence @xmath24 ( in the sense of first - order logic ) is called _",
    "@xmath26-stable _ if it satisfies @xmath27 $ ] .",
    "the traditional stable models of a logic program @xmath51 are identical to the herbrand stable models of the _ fol - representation _ of @xmath51 ( i.e. , the conjunction of the universal closures of implications corresponding to the rules ) .    for program @xmath51 that contains three rules @xmath52 the fol - representation @xmath24 of @xmath51 is p(a)q(b)x((p(x)q(x))r(x ) ) and @xmath53 $ ] is @xmath54 which is equivalent to first - order sentence l x(p(x ) x = a ) x(q(x ) x = b ) x ( r(x ) ( p(x ) q(x ) ) ) ( see @xcite , example  3 ) .",
    "the stable models of @xmath24 are any first - order models of ( [ ex3f - comp ] ) .",
    "the only herbrand stable models of @xmath24 is @xmath55 .",
    "@xcite [ @xcite ] incorporate strong negation into the stable model semantics by distinguishing between intensional predicates of two kinds , _ positive _ and _ negative_. each negative intensional predicate has the form @xmath56 , where @xmath15 is a positive intensional predicate and ` @xmath57  ' is a symbol for strong negation . in this sense , syntactically @xmath2 is not a logical connective , as it can appear only as a part of a predicate constant .",
    "an interpretation of the underlying signature is _ coherent _ if it satisfies the formula @xmath58 , where  @xmath32 is a list of distinct object variables , for each negative predicate  @xmath56 .",
    "we consider coherent interpretations only .",
    "[ ex : bw - sneg0 ] the following is a representation of the blocks world in the syntax of logic programs : & & ion(b_1,b , t ) , ion(b_2,b , t ) & ( b_1b_2 ) + ion(b ,",
    "l , t+1 ) & & imove(b , l , t ) + & & imove(b , l , t ) , ion(b_1,b , t ) + & & imove(b , b_1,t ) , imove(b_1,l , t ) + ion(b , l,0 ) & &  ion(b , l,0 ) + ion(b , l,0 ) & &  ion(b , l,0 ) + imove(b , l , t ) & &  imove(b , l , t ) + imove(b , l , t ) & &  imove(b , l , t ) + ion(b , l , t+1)&&ion(b , l , t ) ,  ion(b , l , t+1 ) + ion(b , l , t ) & & ion(b , l_1,t ) & ( ll_1 )  . here",
    "@xmath6 and @xmath59 are intensional predicate constants , @xmath0 , @xmath60 , @xmath61 are variables ranging over the blocks , @xmath1 , @xmath62 are variables ranging over the locations ( blocks and the table ) , and @xmath5 is a variable ranging over the timepoints .",
    "the first rule asserts that at most one block can be on another block .",
    "the next three rules describe the effect and preconditions of action @xmath59 .",
    "the next four rules describe that fluent @xmath6 is initially exogenous , and action @xmath59 is exogenous at each time .",
    "the next rule describes inertia , and the last rule asserts that a block can be at most at one location .",
    "the functional stable model semantics is defined by modifying the semantics in the previous section to allow `` intensional '' functions @xcite . for predicate symbols ( constants or variables ) @xmath63 and @xmath64 , we define @xmath65 as .",
    "we define @xmath66 as @xmath67 if @xmath63 and @xmath64 are predicate symbols , and @xmath68 if they are function symbols .",
    "let @xmath69 be a list of distinct predicate and function constants and let @xmath70 be a list of distinct predicate and function variables corresponding to  @xmath69 .",
    "we call members of @xmath69 _ intensional _ constants .",
    "by @xmath71 we mean the list of the predicate constants in @xmath69 , and by @xmath72 the list of the corresponding predicate variables in @xmath70 .",
    "we define @xmath73 as @xmath74 and @xmath75 $ ] as @xmath76 where @xmath77 is defined the same as the one in section  [ ssec : review - sneg ] except for the base case :    * when @xmath24 is an atomic formula , @xmath78 is @xmath79 , where @xmath80 is obtained from @xmath24 by replacing all intensional ( function and predicate ) constants in it with the corresponding ( function and predicate ) variables .",
    "if @xmath81 contains predicate constants only , this definition of a stable model reduces to the one in  @xcite , also reviewed in section  [ ssec : review - sneg ] .    according to  @xcite , a _ choice formula _",
    "@xmath82 is an abbreviation of the formula @xmath83 , which is also strongly equivalent to @xmath84 . a formula @xmath85 , where @xmath43 contains an intensional function constant and @xmath86 does not , represents that @xmath43 takes the value @xmath86 by default , as the following example demonstrates .",
    "[ ex : f=1 ] let @xmath87 be @xmath88 , which stands for @xmath89 , and @xmath90 be an interpretation such that @xmath91 .",
    "let s assume that we consider only interpretations that map numbers to themselves .",
    "@xmath90 is an @xmath92-stable model of @xmath87 : @xmath93 is equivalent to @xmath94 , is equivalent to @xmath22 . ]",
    "which is further equivalent to @xmath95 under the assumption @xmath90 .",
    "it is not possible to satisfy this formula by assigning @xmath96 a different value from @xmath97 . on the other hand , @xmath98 such that @xmath99 is not @xmath92-stable since @xmath93 is equivalent to @xmath100 under @xmath98 , so that it is possible to satisfy this formula by assigning @xmath96 a different value from @xmath101 .",
    "if we let @xmath102 be @xmath103 , then @xmath98 is a @xmath92-stable of @xmath102 , but @xmath90 is not : @xmath104 is equivalent to @xmath105 under @xmath98 , so that @xmath96 has to map to @xmath106 as well .",
    "this example illustrates the nonmonotonicity of the semantics .",
    "[ ex : bw - func ] the blocks world can be described in this language as follows . for readability , we write in a logic program like syntax : @xmath107 here @xmath10 is a function constant .",
    "the last rule is a default formula that describes the commonsense law of inertia .",
    "the stable models of this program are the models of @xmath108 $ ] , where @xmath24 is the fol - representation of the program .",
    "the following is a review of the stable model semantics of multi - valued propositional formulas from  @xcite , which can be viewed as a special case of the functional stable model semantics in the previous section .",
    "the syntax of multi - valued propositional formulas is given in  @xcite .",
    "multi - valued propositional signature _ is a set @xmath109  of symbols called _ constants _ , along with a nonempty finite set  @xmath110 of symbols , disjoint from @xmath109 , assigned to each constant  @xmath64 .",
    "we call @xmath110 the _ domain _ of  @xmath64 .",
    "a _ boolean _",
    "constant is one whose domain is the set  @xmath111 .",
    "an _ atom _ of a signature  @xmath109 is an expression of the form @xmath112 ( `` the value of  @xmath64 is  @xmath113 '' ) where @xmath114 and @xmath115 .",
    "a _ ( multi - valued propositional ) formula _ of  @xmath109 is a propositional combination of atoms .",
    "a _ ( multi - valued propositional ) interpretation _ of  @xmath109 is a function that maps every element of  @xmath109 to an element of its domain .",
    "an interpretation  @xmath116 _ satisfies _ an atom @xmath112 ( symbolically , @xmath117 ) if @xmath118 .",
    "the satisfaction relation is extended from atoms to arbitrary formulas according to the usual truth tables for the propositional connectives .",
    "@xmath116 is a _ model _ of a formula if it satisfies the formula .",
    "the reduct @xmath119 of a multi - valued propositional formula @xmath24 relative to a multi - valued propositional interpretation @xmath116 is the formula obtained from @xmath24 by replacing each maximal subformula that is not satisfied by @xmath116 with @xmath45 .",
    "interpretation @xmath116 is a _ stable model _ of @xmath24 if @xmath116 is the only interpretation satisfying @xmath119 .",
    "[ ex6 ] consider a multi - valued propositional signature @xmath120 , where @xmath121 and @xmath122 .",
    "the following is a multi - valued propositional formula @xmath24 : + @xmath123 consider an interpretation @xmath116 such that @xmath124 , @xmath125 and @xmath126 .",
    "the reduct @xmath119 is + @xmath127 and @xmath116 is the only interpretation of @xmath109 that satisfies @xmath119 .",
    "similar to example  [ ex : f=1 ] , consider the signature @xmath128 such that @xmath129 .",
    "let @xmath90 be an interpretation such that @xmath130 , and @xmath98 be such that @xmath131 .",
    "recall that @xmath132 is shorthand for @xmath133 .",
    "the reduct of this formula relative to @xmath90 is @xmath134 , and @xmath90 is the only model of the reduct . on the other hand ,",
    "the reduct of @xmath132 relative to @xmath98 is @xmath135 and @xmath98 is not its unique model . also",
    ", the reduct of @xmath136 relative to @xmath90 is @xmath137 and @xmath90 is not a model .",
    "the reduct of @xmath136 relative to @xmath98 is @xmath138 , and @xmath98 is the only model of the reduct .",
    "multi - valued propositional formulas can be identified with a special case of first - order formulas as follows .",
    "let @xmath24 be a multi - valued propositional formula of signature  @xmath109 .",
    "we identify @xmath109 with a first - order signature @xmath139 that consists of    * all symbols from @xmath109 as object constants , and * all symbols from @xmath110 where @xmath64 is in @xmath109 as object constants .",
    "we may view multi - valued propositional interpretations of @xmath109 as a special case of first - order interpretations of  @xmath139 .",
    "we say that a first - order interpretation @xmath116 of @xmath139 _ conforms _ to @xmath109 if    * the universe of @xmath116 is the union of @xmath110 for all @xmath64 in @xmath109 ; * @xmath140 for every @xmath64 in @xmath109 ; * @xmath141 for every @xmath113 in @xmath110 where @xmath142 .",
    "[ prop : mvpf - fo ] for any multi - valued propositional formula @xmath24 of signature @xmath109 such that for every @xmath142 , an interpretation @xmath116 of @xmath109 is a multi - valued propositional stable model of @xmath24 iff @xmath116 is an interpretation of @xmath139 that conforms to @xmath109 and satisfies @xmath143 $ ] .",
    "given a traditional propositional logic program @xmath51 of a signature @xmath109 @xcite , we identify @xmath109 with the multi - valued propositional signature whose constants are the same symbols from @xmath109 and every constant is boolean .",
    "by @xmath144 we mean the multi - valued propositional formula that is obtained from @xmath51 by replacing negative literals of the form @xmath56 with @xmath145 and positive literals of the form @xmath15 with @xmath146 .",
    "we say that a set @xmath147 of literals from  @xmath109 is _ complete _ if , for each atom @xmath148 , either @xmath14 or @xmath149 is in @xmath147 . we identify a complete set of literals from @xmath109 with the corresponding multi - valued propositional interpretation .",
    "[ thm : sneg - bool - prop ] a complete set of literals is an answer set of @xmath51 in the sense of  @xcite iff it is a stable model of @xmath144 in the sense of  @xcite .",
    "the theorem tells us that checking the minimality of positive and negative literals under the traditional stable model semantics is essentially the same as checking the uniqueness of corresponding function values under the stable model semantics from  @xcite .",
    "[ ex : simple ] consider the program that describes a simple transition system consisting of two states depending on whether fluent @xmath15 is true or false , and an action that makes @xmath15 true ( subscripts @xmath20 and @xmath150 represent time stamps ) .",
    "+ & p_0 & &  p_0 & p_1 & & a + & p_0 & &  p_0 + & & & & p_1 & & p_0 ,  p_1 + & a & &  a & p_1 & & p_0 ,  p_1  .",
    "+ & a & &  a the program has four answer sets , each of which corresponds to one of the four edges of the transition system . for instance , @xmath151 is an answer set .",
    "this program can be encoded in the input languages of gringo and dlv . in the input language of dlv , which allows disjunctions in the head of a rule ,",
    "the four rules in the first column can be succinctly replaced by + @xmath152    according to theorem  [ thm : sneg - bool - prop ] , the stable models of this program are the same as the stable models of the following multi - valued propositional formula ( written in a logic program style syntax ; ` @xmath153 ' represents default negation ) : +    2 @xmath154    @xmath155      in certain cases , strong negation can be replaced by default negation , and furthermore the expression can be rewritten in terms of choice rules , which often yields a succinct representation .    the following theorem , which extends the _ theorem on double negation _ from  @xcite to allow intensional functions , presents a condition under which equivalent transformations in classical logic preserve stable models .",
    "[ thm : dneg ] let @xmath24 be a sentence , let @xmath81 be a list of predicate and function constants , and let @xmath116 be a ( coherent ) interpretation .",
    "let @xmath80 be the sentence obtained from @xmath24 by replacing a subformula @xmath156 with @xmath157 such that @xmath158 .",
    "then @xmath159 \\text { iff } i\\models\\sm[f';\\ { \\bf c}]\\ .\\ ] ]    we say that an interpretation is _ complete _ on a predicate @xmath15 if it satisfies .",
    "it is clear that , for any complete interpretation @xmath116 , we have @xmath160 iff @xmath161 .",
    "this fact allows us to use theorem  [ thm : dneg ] to replace strong negation occurring in @xmath162 with default negation .",
    "* example  [ ex : simple ] continued *     _ each answer set of the first program in example  [ ex : simple ] is complete . in view of theorem  [ thm : dneg ] , the first two rules can be rewritten as  @xmath163  and@xmath164 ,  which can be further abbreviated as choice rules @xmath165 and @xmath166 . consequently , the whole program can be rewritten using choice rules as + _",
    "2 @xmath167    @xmath168    similarly , since @xmath169 iff @xmath170 , in view of theorem  [ thm : dneg ] , the first rule of the second program in example  [ ex : simple ] can be rewritten as and further as @xmath171 .",
    "this transformation allows us to rewrite the whole program as +    2 @xmath172    @xmath173    where @xmath174 ranges over @xmath175 .",
    "this program represents the transition system more succinctly than program  .",
    "theorem  [ thm : sneg - bool - prop ] can be extended to the first - order case as follows .",
    "let @xmath92 be a function constant .",
    "a first - order formula is called _",
    "@xmath92-plain _ if each atomic formula    * does not contain @xmath92 , or * is of the form @xmath176 where @xmath43 is a tuple of terms not containing @xmath92 , and @xmath63 is a term not containing @xmath92 .",
    "for example , @xmath177 is @xmath92-plain , but each of @xmath178 , @xmath179 , and @xmath180 is not @xmath92-plain .    for a list @xmath69 of predicate and function constants ,",
    "we say that a first - order formula @xmath24 is @xmath69-plain if @xmath24 is @xmath92-plain for each function constant @xmath92 in @xmath69 .",
    "roughly speaking , @xmath81-plain formulas do not allow the functions in @xmath81 to be nested in another predicate or function , and at most one function in @xmath81 is allowed in each atomic formula .",
    "for example , @xmath181 is not @xmath182-plain , and neither is @xmath183 .",
    "let @xmath24 be a formula whose signature contains both positive and negative predicate constants @xmath15 and",
    "@xmath56 . formula @xmath184 is obtained from @xmath24 as follows :    * in the signature of @xmath24 , replace @xmath15 and @xmath56 with a new intensional function constant @xmath0 of arity @xmath185 , where @xmath185 is the arity of @xmath15 ( or @xmath56 ) , and add two non - intensional object constants @xmath186 and @xmath187 ; * replace every occurrence of @xmath188 , where @xmath43 is a list of terms , with @xmath189 , and then replace every occurrence of @xmath190 with @xmath191 .    by @xmath192 ( `` boolean constraint on @xmath0 '' )",
    "we denote the conjunction of the following formulas , which asserts that @xmath0 is a boolean function :  , @xmath193 where @xmath32 is a list of distinct object variables .",
    "[ thm : sneg - bool - fo ] let @xmath69 be a set of predicate and function constants , and let @xmath24 be a @xmath69-plain formula",
    ". formulas ( ( p ( ) b ( ) ) ( p ( ) b ( ) ) ) , and @xmath192 entail @xmath194 \\lrar \\sm[f^{(p,\\sneg\\ p)}_{~~b};\\ b,\\bc]\\ .\\ ] ]    if we drop the requirement that @xmath24 be @xmath69-plain , the statement does not hold as in the following example demonstrates .    [ ex : cplain ] take @xmath69 as @xmath182 and let @xmath24 be @xmath195 .",
    "@xmath184 is @xmath196 .",
    "consider the interpretation @xmath116 whose universe is @xmath197 such that @xmath116 contains @xmath198 and with the mappings @xmath199 .",
    "@xmath116 certainly satisfies @xmath192 and ( [ pb ] ) .",
    "@xmath116 also satisfies @xmath200 $ ] but does not satisfy @xmath201 $ ] : we can let @xmath116 be @xmath202 to satisfy both @xmath203 and @xmath204 , which is @xmath205    note that any interpretation that satisfies both and @xmath192 is complete on @xmath15 .",
    "theorem  [ thm : sneg - bool - fo ] tells us that , for any interpretation @xmath116 that is complete on @xmath15 , minimizing the extents of both @xmath15 and @xmath56 has the same effect as ensuring that the corresponding boolean function @xmath0 have a unique value .",
    "the following corollary shows that there is a 11 correspondence between the stable models of @xmath24 and the stable models of @xmath184 . for any interpretation @xmath116 of the signature of @xmath24 that is complete on @xmath15 , by @xmath206",
    "we denote the interpretation of the signature of @xmath184 obtained from @xmath116 by replacing the relation @xmath207 with function @xmath208 such that @xmath209 ( notice that we overloaded the symbols @xmath186 and @xmath187 : object constants on one hand , and truth values on the other hand . ) since @xmath116 is complete on @xmath15 and coherent , @xmath208 is well - defined .",
    "we also require that @xmath206 satisfy  ( [ f1 ] ) .",
    "consequently , @xmath206 satisfies @xmath192 .",
    "[ cor : bfelim ] let @xmath69 be a set of predicate and function constants , and let @xmath24 be a @xmath69-plain sentence .",
    "( i ) an interpretation @xmath116 of the signature of @xmath24 that is complete on  @xmath15 is a model of @xmath210 $ ] iff @xmath206 is a model of .",
    "( ii ) an interpretation @xmath211 of the signature of @xmath184 is a model of iff @xmath212 for some model @xmath116 of .",
    "the other direction , eliminating boolean intensional functions in favor of symmetric predicates , is similar as we show in the following .",
    "let @xmath24 be a @xmath213-plain formula such that every atomic formula containing @xmath0 has the form @xmath191 or @xmath189 , where @xmath43 is any list of terms ( not containing members from @xmath213 ) .",
    "formula @xmath214 is obtained from @xmath24 as follows :    * in the signature of @xmath24 , replace @xmath0 with predicate constants @xmath15 and @xmath56 , whose arities are the same as that of @xmath0 ; * replace every occurrence of @xmath191 , where @xmath43 is any list of terms , with @xmath190 , and @xmath189 with @xmath188 .",
    "[ thm : sneg - boolfunc - pred ]",
    "let @xmath69 be a set of predicate and function constants , let @xmath0 be a function constant , and let @xmath24 be a @xmath215-plain formula such that every atomic formula containing @xmath0 has the form @xmath191 or @xmath216 . formulas  ( [ pb ] ) and @xmath192 entail @xmath217 \\lrar \\sm[f^{~b}_{(p,\\sneg\\ p)};\\",
    "p,\\sneg p , \\bc]\\ .\\ ] ]    the following corollary shows that there is a 11 correspondence between the stable models of @xmath24 and the stable models of @xmath214 . for any interpretation @xmath116 of the signature of @xmath24 that satisfies @xmath192 , by @xmath218",
    "we denote the interpretation of the signature of @xmath214 obtained from @xmath116 by replacing the function @xmath208 with predicate @xmath207 such that @xmath219    [ cor : sneg - boolfunc - pred ] let @xmath69 be a set of predicate and function constants , let @xmath0 be a function constant , and let @xmath24 be a @xmath215-plain sentence such that every atomic formula containing @xmath0 has the form @xmath191 or @xmath216 .",
    "( i ) an interpretation @xmath116 of the signature of @xmath24 is a model of @xmath220 $ ] iff @xmath218 is a model of .",
    "( ii ) an interpretation @xmath211 of the signature of @xmath214 is a model of iff @xmath221 for some model @xmath116 of .",
    "an example of this corollary is shown in the next section .",
    "in this section , we show how to eliminate non - boolean intensional functions in favor of boolean intensional functions . combined with the method in the previous section , it gives us a systematic method of representing non - boolean intensional functions using strong negation .",
    "let @xmath24 be an @xmath92-plain formula .",
    "formula @xmath222 is obtained from @xmath24 as follows :    * in the signature of @xmath24 , replace @xmath92 with a new boolean intensional function @xmath0 of arity @xmath223 where @xmath185 is the arity of @xmath92 ; * replace each subformula @xmath224 with @xmath225 .    by @xmath226",
    ", we denote the following formulas that preserve the functional property : @xmath227 @xmath228 where @xmath32 is a @xmath185-tuple of variables and all variables in @xmath32 , @xmath229 , and @xmath230 are pairwise distinct .",
    "note that @xmath226 is not a constraint as in similar theorems .",
    "if we replace ( [ ueb1 ] ) with @xmath231 ( calling this set @xmath232 ) , we can see that this will not work .",
    "consider the counterexample @xmath24 where + @xmath24 is @xmath233 .",
    "+ @xmath78 is @xmath234 .",
    "+ @xmath222 is @xmath235 + @xmath236 is @xmath237 + clearly the interpretation mapping @xmath92 to @xmath150 is a stable model for @xmath24 .",
    "however , the analogous interpretation that maps @xmath238 to @xmath186 and @xmath239 to @xmath187 for all @xmath240 is not a stable model of @xmath222 ; we can let @xmath241 be mapped to @xmath186 and thus we see the existence of an @xmath96 such that @xmath242 and @xmath243 are satisfied .",
    "[ thm : mvfelim ] for any @xmath92-plain formula @xmath24 , @xmath244 and @xmath245 entail @xmath246\\ \\lrar\\ \\sm[f^f_b \\land\\i{ue}_b;\\ b , { \\bf c}]\\ .\\ ] ]    by @xmath247 , we denote the interpretation of the signature of @xmath222 obtained from @xmath116 by replacing the mapping @xmath248 with the mapping @xmath208 such that @xmath249    [ cor : mvfelim ] let @xmath24 be an @xmath92-plain sentence .",
    "( i ) an interpretation @xmath116 of the signature of @xmath24 that satisfies @xmath250 is a model of @xmath251 $ ] iff @xmath247 is a model of @xmath252 $ ] .",
    "( ii ) an interpretation @xmath211 of the signature of @xmath222 that satisfies @xmath250 is a model of @xmath252 $ ] iff @xmath253 for some model @xmath116 of @xmath251 $ ] .",
    "* example  [ ex : bw - func ] continued *   _ in the program in example  [ ex : bw - func ] , we eliminate non - boolean function @xmath10 in favor of boolean function @xmath6 as follows .",
    "the last two rules are @xmath254 .",
    "@xmath255 for this program , it is not difficult to check that the last rule is redundant . indeed , since the second to the last rule is the only rule that has @xmath256 in the head , one can check that any model that does not satisfy @xmath257 is not stable even if we drop the last rule .",
    "corollary  [ cor : sneg - boolfunc - pred ] tells us that this program can be represented by an answer set program containing strong negation ( with the redundant rule dropped ) . & & ion(b_1,b , t ) , ion(b_2,b , t ) & ( b_1 b_2 ) + ion(b , l , t+1 ) & & imove(b , l , t ) + & & imove(b , l , t ) , ion(b_1,b , t ) + & & imove(b , b_1,t ) , imove(b_1,l , t ) + \\{ion(b , l,0 ) } + \\{imove(b , l , t ) } + \\{ion(b , l , t+1 ) } & & ion(b , l , t ) + ion(b ,",
    "l , t ) & & ion(b , l_1,t ) & ( ll_1 )  .",
    "+ let us compare this program with program  .",
    "similar to the explanation in example  [ ex : simple ] ( continued ) , the 5th and the 7th rules of   can be represented using choice rules , which are the same as the 5th and the 6th rules of  .",
    "the 6th and the 8th rules of   represent the closed world assumption . we can check that adding these rules to extends the answer sets of in a conservative way with the definition of the negative literals .",
    "this tells us that the answer sets of the two programs are in a 1 - 1 correspondence . _    as the example explains , non - boolean functions can be represented using strong negation by composing the two translations , first eliminating non - boolean functions in favor of boolean functions as in corollary  [ cor : mvfelim ] and then eliminating boolean functions in favor of predicates as in corollary  [ cor : sneg - boolfunc - pred ] . in the following we state",
    "this composition .",
    "let @xmath24 be an @xmath92-plain formula where @xmath92 is an intensional function constant .",
    "formula @xmath258 is obtained from @xmath24 as follows :    * in the signature of @xmath24 , replace @xmath92 with two new intensional predicates @xmath15 and @xmath56 of arity @xmath223 where @xmath185 is the arity of @xmath92 ; * replace each subformula @xmath224 with @xmath259 .    by @xmath260",
    ", we denote the following formulas that preserve the functional property : @xmath261 where @xmath32 is an @xmath185-tuple of variables and all variables in @xmath262 are pairwise distinct .",
    "[ thm : composition2 ] for any @xmath263-plain formula @xmath24 , formulas @xmath264 entail @xmath265\\lrar\\sm[f^f_p\\land\\i{ue}_{p};\\ p , \\sneg p , { \\bf c}]\\ .\\ ] ]    by @xmath266 , we denote the interpretation of the signature of @xmath267 obtained from @xmath116 by replacing the function @xmath248 with the relation @xmath207 that consists of the tuples @xmath268 for all @xmath269 from the universe of @xmath116 .",
    "we then also add the set @xmath270 that consists of the tuples @xmath271 for all @xmath272 from the universe of @xmath116 that do not occur in the set @xmath207 .",
    "[ cor : composition2cor ] let @xmath24 be an @xmath273-plain sentence .",
    "( i ) an interpretation @xmath116 of the signature of @xmath24 that satisfies @xmath245 is a model of @xmath274 $ ] iff @xmath266 is a model of .",
    "( ii ) an interpretation @xmath211 of the signature of  @xmath258 that satisfies @xmath275 is a model of @xmath276 $ ] iff @xmath277 for some model @xmath116 of @xmath274 $ ] .    theorem  [ thm : composition2 ] and corollary  [ cor : composition2cor ] are similar to theorem  8 and corollary  2 from  @xcite .",
    "the main difference is that the latter statements refer to the constraint called @xmath278 that is weaker than  @xmath260 .",
    "for instance , the elimination method from  @xcite turns the blocks world in example  [ ex : bw - func ] into almost the same program as   except that the last rule is turned into the constraint @xmath279 : ion(b , l , t)ion(b , l_1,t)ll_1  .",
    "it is clear that the stable models of @xmath280 are under the symmetric view , and the stable models of @xmath281 are under the asymmetric view . to see how replacing @xmath254 by @xmath279 turns the symmetric view to the asymmetric view , first observe that adding ( [ uec - ex ] ) to program   does not affect the stable models of the program . let s call this program @xmath51 .",
    "it is easy to see that @xmath51 is a conservative extension of the program that is obtained from @xmath51 by deleting the rule with @xmath282 in the head .",
    "@xcite  [ @xcite ] presented a high level definition of a logic program that does not contain explicit default negation , but can handle nonmonotonic reasoning in a similar style as in reiter s default logic . in this section",
    "we show how his formalism can be viewed as a special case of multi - valued propositional formulas under the stable model semantics in which every function is boolean .",
    "let @xmath109 be a signature in propositional logic .",
    "a _ two - valued rule _ is an expression of the form l_0 l_1 ,  , l_n : f where @xmath283 are propositional literals formed from @xmath109 and @xmath24 is a propositional formula of signature @xmath109 .    a _ two - valued program _",
    "@xmath51 is a set of two - valued rules .",
    "an interpretation @xmath116 is a function from @xmath109 to @xmath175 .",
    "the _ reduct _ of a program @xmath51 relative to an interpretation @xmath116 , denoted @xmath284 , is the set of rules @xmath285 corresponding to the rules  ( [ liftvrule ] ) of @xmath51 for which @xmath286 .",
    "interpretation @xmath116 is a stable model of @xmath51 if it is a minimal model of @xmath284 .",
    "[ ex : tv ] l a   :  a , a :  a , b a  :   the reduct of this program relative to @xmath287 consists of rules @xmath14 and @xmath288 .",
    "interpretation @xmath287 is the minimal model of the reduct , so that it is a stable model of the program .    as described in @xcite ,",
    "if @xmath24 in every rule  ( [ liftvrule ] ) has the form of conjunctions of literals , then the two - valued logic program can be turned into a traditional answer set program containing strong negation when we consider complete answer sets only .",
    "for instance , program  ( [ tv - example ] ) can be turned into @xmath289 this program has two answer sets , @xmath287 and @xmath290 , and only the complete answer set @xmath287 corresponds to the stable model found in example  [ ex : tv ] .",
    "given a two - valued logic program @xmath51 of a signature @xmath109 , we identify @xmath109 with the multi - valued propositional signature whose constants are from @xmath109 and the domain of every constant is boolean values @xmath175 . for any propositional formula @xmath291 , @xmath292 is obtained from  @xmath291 by replacing every negative literal @xmath293 with @xmath294 and every positive literal @xmath295 with @xmath296 . by @xmath297 we denote the multi - valued propositional formula which is defined as the conjunction of @xmath298 for each rule  ( [ liftvrule ] ) in  @xmath51 .    for any interpretation @xmath116 of @xmath109",
    ", we obtain the multi - valued interpretation @xmath299 from @xmath116 as follows . for each atom @xmath295 in @xmath109 , @xmath300    [ thm : liftvtrans ] for any two - valued logic program @xmath51 ,",
    "an interpretation @xmath116 is a stable model of @xmath51 in the sense of @xcite iff @xmath299 is a stable model of @xmath297 in the sense of @xcite .",
    "* example  [ ex : tv ] continued *     consider extending the rules to contain variables .",
    "it is not difficult to see that the translation @xmath297 can be straightforwardly extended to non - ground programs .",
    "this accounts for providing the semantics of the first - order extension of two - valued logic programs .",
    "there are other stable model semantics of intensional functions . theorem  5 from  @xcite states that the semantics by @xcite  [ @xcite ] coincides with the semantics by @xcite  [ @xcite ] on @xmath69-plain formulas .",
    "thus several theorems in this note stated for the bartholomew - lee semantics hold also under the cabalar semantics .",
    "a further result holds with the cabalar semantics since it allows functions to be partial .",
    "this provides extensions of theorem  [ thm : sneg - bool - fo ] and corollary  [ cor : bfelim ] , which do not require the interpretations to be complete .",
    "below we state this result . due to lack of space , we refer the reader to @xcite for the definition of @xmath301 , which is the second - order expression used to define the cabalar semantics .",
    "similar to @xmath192 in section  [ ssec : sneg - bool - fo ] , by @xmath302 we denote the conjunction of the following formulas : , @xmath303 where @xmath32 is a list of distinct object variables .",
    "is true if @xmath304 is undefined .",
    "see  @xcite for more details . ]",
    "[ thm : sneg - bool - fo - c ] let @xmath69 be a set of predicate constants , and let @xmath24 be a formula . formulas @xmath305 and @xmath302 entail @xmath194 \\lrar \\cbl[f^{(p,\\sneg\\ p)}_{~~b};\\ b,\\bc]\\ .\\ ] ]    the following corollary shows that there is a 11 correspondence between the stable models of @xmath24 and the stable models of @xmath184 .. ] for any interpretation @xmath116 of the signature of @xmath24 , by @xmath206 we denote the interpretation of the signature of @xmath184 obtained from @xmath116 by replacing the relation @xmath207 with function @xmath208 such that @xmath306 since @xmath116 is coherent , @xmath208 is well - defined .",
    "we also require that @xmath206 satisfy  ( [ fc1 ] ) .",
    "consequently , @xmath206 satisfies @xmath302 .",
    "[ cor : bfelim - c ] let @xmath24 be a sentence , and let @xmath69 be a set of predicate constants .",
    "( i ) an interpretation @xmath116 of the signature of @xmath24 is a model of @xmath210 $ ] iff @xmath206 is a model of .",
    "( ii ) an interpretation @xmath211 of the signature of @xmath184 is a model of iff @xmath212 for some model @xmath116 of .",
    "in this note , we showed that , under complete interpretations , symmetric predicates using strong negation can be alternatively expressed in terms of boolean intensional functions in the language of @xcite .",
    "they can also be expressed in terms of boolean intensional functions in the language of @xcite , but without requiring the complete interpretation assumption , at the price of relying on the notion of partial interpretations .",
    "system cplus2asp  @xcite turns action language @xmath307 + into answer set programs containing asymmetric predicates . the translation in this paper that eliminates intensional functions in favor of symmetric predicates provides an alternative method of computing @xmath307 + using asp solvers .",
    "* acknowledgements : * we are grateful to vladimir lifschitz for bringing attention to this subject , to gregory gelfond for useful discussions related to this paper , and to anonymous referees for useful comments .",
    "this work was partially supported by the national science foundation under grant iis-0916116 and by the south korea it r&d program mke / kiat 2010-td-300404 - 001 .",
    "joseph babb and joohyung lee .",
    ": computing action language c+ in answer set programming . in _ proceedings of international conference on logic programming and nonmonotonic reasoning ( lpnmr ) _ , 2013 .",
    "to appear .",
    "michael bartholomew and joohyung lee .",
    "stable models of formulas with intensional functions . in _ proceedings of international conference on principles of knowledge representation and reasoning ( kr ) _ , pages 212 , 2012 .",
    "paolo ferraris , joohyung lee , vladimir lifschitz , and ravi palla .",
    "symmetric splitting in the general theory of stable models . in _ proceedings of international joint conference on artificial intelligence ( ijcai ) _ ,",
    "pages 797803 .",
    "aaai press , 2009 ."
  ],
  "abstract_text": [
    "<S> the distinction between strong negation and default negation has been useful in answer set programming . </S>",
    "<S> we present an alternative account of strong negation , which lets us view strong negation in terms of the functional stable model semantics by bartholomew and lee . </S>",
    "<S> more specifically , we show that , under complete interpretations , minimizing both positive and negative literals in the traditional answer set semantics is essentially the same as ensuring the uniqueness of boolean function values under the functional stable model semantics . </S>",
    "<S> the same account lets us view lifschitz s two - valued logic programs as a special case of the functional stable model semantics . </S>",
    "<S> in addition , we show how non - boolean intensional functions can be eliminated in favor of boolean intensional functions , and furthermore can be represented using strong negation , which provides a way to compute the functional stable model semantics using existing asp solvers . </S>",
    "<S> we also note that similar results hold with the functional stable model semantics by cabalar . </S>"
  ]
}