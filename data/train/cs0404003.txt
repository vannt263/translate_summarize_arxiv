{
  "article_text": [
    "deductive database technology represents an important step towards the goal of developing highly - declarative database programming languages .",
    "several approaches for the inclusion of update capabilities in deductive languages have been proposed . in general , all those proposals are based on including in rules , in addition to usual atoms , special atoms denoting updates . in most of those proposals ,",
    "an update execution consists of a query component , identifying the data to be modified , and an update component , performing the actual modification on the selected data .",
    "a way to classify deductive update languages is with respect to the approach adopted for handling possible interferences between the query and update component of the same update execution . in particular ,",
    "updates can be performed as soon as they are generated , as side - effect of the query evaluation , thus , by applying an _ immediate _ semantics .",
    "languages based on an immediate semantics include @xmath2 @xcite , tl @xcite , dl @xcite , dlp @xcite , statelog @xcite .",
    "the immediate semantics is in contrast with the _ deferred update semantics _ ,",
    "by which updates are not applied as soon as they are generated during the query evaluation ; rather , they are executed only when the query evaluation is completed .",
    "languages based on a deferred semantics include u - datalog @xcite , update calculus @xcite , and ultra @xcite .",
    "other languages , such as transaction logic @xcite , provide both policies .    in this paper",
    ", we consider u - datalog , a language based on a deferred semantics . even if more expressive and flexible frameworks exist ( see for example @xcite ) , the choice of u - datalog is motivated by the fact that it represents an immediate extension of datalog to deal with updates .",
    "this aspect makes this language quite suitable for analyzing properties related to logical update languages @xcite . in u - datalog ,",
    "updates are expressed by introducing constraints inside datalog rules .",
    "for example , @xmath3 states that in the new state @xmath4 must be true where @xmath5 states that in the new state @xmath4 must be false .",
    "thus , u - datalog programs are formally modeled as constraint logic programming ( clp ) programs @xcite .    in clp ,",
    "any answer to a given goal ( called a _ query _",
    ", in the database context ) contains a set of constraints , constraining the resulting solution . in u - datalog",
    ", each solution contains a substitution for the query variables and a set of updates .",
    "the execution of a goal is based on a deferred semantics .",
    "in particular , given a query , all the solutions are generated in the so - called _ marking phase _ , using a clp answering mechanism .",
    "all the updates , contained in the various solutions , are then executed in the _ update phase _ , by using an operational semantics .",
    "the set of all updates generated during the marking phase forms a constraint theory which can be inconsistent . from a logical point of view",
    ", this means that the update set contains constraints of the form @xmath3 , @xmath5 , requiring the insertion and the deletion of the same fact .",
    "the u - datalog computational model rejects any form of conflict , both locally , i.e. , inside a single solution , and globally , from different solutions .",
    "thus , the set of updates to be executed is always consistent .    besides the marking and",
    "update semantics phases , it is often useful to devise an additional semantics , known as _ compositional semantics _ @xcite .",
    "this semantics , which is orthogonal with respect to the one defined above , characterizes the semantics of the intensional database independently from the semantics of the extensional one and is based on the notion of open programs @xcite .",
    "the compositional semantics is quite important in the context of deductive databases since it provides a theoretical framework for analyzing the properties of intensional databases .",
    "indeed , it is always recursion free , even if it is not always finite .",
    "therefore , when it is finite , it also represents a useful pre - compilation technique for intensional databases .",
    "however , since this semantics is usually expensive to compute , it is mainly used for analysis purposes .",
    "even if u - datalog allows us to easily specify updates and transactions , its expressive power is limited since no negation mechanism is provided , even if , due to update inconsistency , some limited form of negation on the extensional database is provided .",
    "this kind of negation is obviously not sufficient to support a large variety of user requests . in this paper",
    "we provide an operational mechanism handling negated atoms in u - datalog programs , providing a marking phase and a compositional semantics .",
    "the proposed extension is based on the notion of stratification , first proposed for logic programming and deductive databases @xcite .",
    "this extension is not , however , a straightforward extension of previously defined stratification - based semantics for two main reasons .",
    "first of all , u - datalog rules are not range restricted @xcite but are required to be _ safe through query invocation _ , for the formal definition of this property .",
    "] resulting in a non - ground semantics .",
    "note that , even if this is a typical assumption in a real context , most of the other deductive update languages require range restricted rules or interpret free variables as _ generation of new values _",
    "a second difference is that an atom may fail not only because an answer substitution can not be found but also because it generates an inconsistent set of updates .    in the following ,",
    "we first introduce u - datalog in section [ sec : u - datalog ] and we extend it to deal with negation in section [ sec : neg ] .",
    "finally , in section [ sec : concl ] we present some conclusions and outline future work . due to space limitations , we assume the reader to be aware of the basic notions of ( constraint ) logic programming @xcite and deductive databases @xcite . for additional details on u - datalog , see @xcite .",
    "[ sec : u - datalog ]      a u - datalog database consists of : ( i ) an extensional database ( or simply database ) @xmath6 , that is , a set of ground atoms ( _ extensional atoms _ ) ; ( ii ) an intensional database @xmath7 ( or simply program ) , that is , a set of rules of the form : +    @xmath8    where @xmath9 , @xmath10 are atoms , @xmath11 are equality constraints , i.e. constraints of type @xmath12 ( denoted by @xmath13 ) , where @xmath14 is a variable and @xmath15 is a term , and @xmath16 are _ update constraints _ ( denoted by @xmath17 ) , also called _",
    "update atoms_. an update constraint is an extensional atom preceded by the symbol @xmath18 , to denote an insertion , or by the symbol @xmath19 , to denote a deletion .    in the following ,",
    "the set of extensional predicates is denoted by @xmath20 , the set of intensional predicates is denoted by @xmath21 , and the herbrand universe is denoted by @xmath22 @xcite .",
    "moreover , a conjunction of equality and update constraints is simply called _ constraint_. ' in other contexts . ] as usual in deductive databases , @xmath20 and @xmath21 are disjoint .",
    "note that a u - datalog program can be seen as a clp program where constraints are represented by equalities and update atoms .",
    "a u - datalog transaction is a goal . in order to guarantee a finite answer to each goal and the generation of a set of ground updates",
    ", we assume that rules are _ safe through query invocation_. this means that , given a u - datalog database @xmath7 and a goal @xmath23 , each variable appearing in the head or in the update constraint of a rule , used in the evaluation of the goal , either appears in an atom contained in the body of the same rule , or is bound by a constant present in the goal . in this case , @xmath23 is _ admissible _ for @xmath7 .",
    "[ exe : syntax ] the following program is a u - datalog intensional database :    @xmath24 + @xmath25 + @xmath26    an atom @xmath27 is true if ` @xmath28 ' is a manager of ` @xmath29 ' .",
    "an atom @xmath30 is true if ` @xmath28 ' is a ( possibly indirect ) manager of ` @xmath29 ' . as a side effect",
    ", it requires the removal of ` @xmath28 ' from department a. an atom @xmath31 is true if ` @xmath29 ' has at least one manager and , as side effect , requires the insertion of ` @xmath29 ' in department @xmath32 . at the same time",
    ", it requires the deletions of all the ( possibly indirect ) managers of ` @xmath29 ' from department a. @xmath33      u - datalog constraints are interpreted over the herbrand universe @xmath22 . in this domain",
    ", equalities have the usual meaning : @xmath34 is interpreted as the atom @xmath35 and @xmath36 is interpreted as the negated atom @xmath37 . if a constraint @xmath38 is @xmath39-solvable , i.e. if @xmath40 , there exists at least one substitution that makes the constraint true .",
    "thus , for no atom both an insertion and a deletion are simultaneously required . when this is not true , updates are said to be _",
    "inconsistent_. the execution of ground inconsistent update atoms ( e.g. , @xmath41 ) may lead to different extensional databases , with respect to the chosen execution order .",
    "the generation of inconsistent updates is avoided as follows : ( i ) _ locally _ : a solution containing an inconsistent set of updates ( i.e. , an unsolvable set of constraints ) is not included in the resulting set of solutions for the given goal ; ( ii ) _ globally _ : if an inconsistency is generated due to two consistent solutions , the goal aborts , no update is executed , and the database is left in the state it had before the goal evaluation .",
    "the semantics of u - datalog programs is given in two main steps .",
    "in the first step , all solutions for a given goal are determined by applying a clp evaluation method ( _ marking phase _ ,",
    "see section [ ssec : marking ] ) .",
    "each solution contains a set of bindings for the query variables and a set of consistent update atoms . in the second step ( _ update phase _ , see section [ ssec : update ] ) , the updates gathered in the various solutions are executed only if they are consistent .    besides the marking and the update semantics ,",
    "an additional semantics is sometimes introduced in the database context , which is called _ compositional semantics _ ( see section [ ssec : comp ] ) .",
    "such semantics characterizes the intensional database independently from the semantics of the extensional one .",
    "the compositional semantics is quite important in the context of deductive databases since it provides a theoretical framework for analyzing the properties of intensional databases .",
    "[ ssec : comp ]    since the extensional database is the only time - variant component of a u - datalog database , for analysis purposes , it is useful to define the semantics of a u - datalog intensional database independently from the current extensional database .",
    "such semantics is called _ compositional semantics _ and is always represented by a recursion free set of rules . therefore ,",
    "when it is finite , or when an equivalent finite set of rules can be detected , it also represents a useful pre - compilation technique for intensional databases .",
    "the compositional semantics can be defined assuming the intensional database to be an _",
    "open program _",
    "@xcite , i.e. , a program where the knowledge regarding some predicates is assumed to be incomplete .",
    "under this meaning , a u - datalog intensional database can be seen as a program that is open with respect to the extensional predicates .",
    "the semantics of an open program is a set of rules , whose bodies contain just open predicates . in order to define the compositional semantics of a u - datalog intensional database , we introduce the following set : +    @xmath42    in the previous expression",
    ", @xmath43 denotes a list of distinct variables .",
    "similarly to @xcite , we now introduce an _ unfolding operator_. such operator , given programs @xmath44 and @xmath45 , replaces an atom @xmath35 , appearing in the body of a rule in @xmath44 , with the body of a rule defining @xmath46 in @xmath45 .",
    "let @xmath44 and @xmath45 be u - datalog programs . then to represent the conjunction of constraints @xmath47 , where @xmath48 is clear from the context .",
    "the symbol @xmath49 denotes syntactic equality . ]",
    "@xmath50=@xmath51 a renamed rule + @xmath52 + @xmath53 , which share no variables , + @xmath54 + @xmath55 + @xmath56 is @xmath39-solvable@xmath57 @xmath58    the compositional semantics of a u - datalog intensional database @xmath7 is obtained by repeatedly applying the unfolding operator until no new rules are generated .",
    "the compositional semantics @xmath59 of @xmath7 with respect to @xmath20 is defined as the least fixpoint of @xmath60 @xmath58    the previous definition is based on the following result , taken from @xcite .",
    "@xmath61 is continuous .",
    "@xmath58    for any extensional database @xmath6 , for any admissible goal @xmath23 , the evaluation of @xmath23 in @xmath62 generates the same answer constraints than the evaluation of @xmath23 in @xmath63.@xmath58    note that @xmath64 is always recursion free .",
    "if @xmath7 is a recursive program then @xmath64 in general is not finite . however , under specific assumptions , it is equivalent to a finite set of rules ( see section [ ssec:8 ] ) .      the answers to a u - datalog query can be computed in a top - down or in an equivalent bottom - up style @xcite . here",
    ", we introduce only the bottom - up semantics .",
    "the constrained herbrand base @xmath65 for a u - datalog program is defined as the set of _ constrained _ atoms of the form @xmath66 where @xmath67 are update atoms , @xmath68 are equality constraints , @xmath69 , and @xmath43 is a tuple of distinct variables .",
    "an interpretation is any subset of the constrained herbrand base .",
    "given a u - datalog database @xmath70 , operator @xmath71 is defined as follows : is the set of all the subsets of the constrained herbrand base @xmath72 . ]",
    "@xmath73=@xmath74 a renamed rule + @xmath75 + @xmath76 which share no variables + @xmath77 + @xmath78 + @xmath79 is @xmath80-solvable } .",
    "let @xmath81 be a u - datalog database .",
    "@xmath82 is continuous and admits a unique least fixpoint @xmath83 and @xmath84 .",
    "such fixpoint represents the bottom - up semantics of @xmath81 . ,",
    "@xmath85 , @xmath86 . ] @xmath58    given @xmath87 and a goal @xmath88 , the _ solutions _ or _",
    "answer constraints _ for @xmath23 are all constraints @xmath89 such that @xmath90 ( @xmath91 ) , @xmath92 , @xmath93 , and @xmath94 is @xmath80-solvable .",
    "let @xmath95 . in this case , we write @xmath96 , where @xmath97 denotes the result of the application of the equalities specified in @xmath98 to @xmath99 .",
    "we assume that @xmath98 is restricted to the variables of @xmath23 .",
    "note that @xmath99 has to be consistent .",
    "[ edb ] consider @xmath100 and the intensional database of example [ exe : syntax ] .",
    "transaction @xmath101 evaluated in @xmath102 computes the consistent solution @xmath103 @xmath104 .",
    "the additional solution @xmath105 is not consistent and therefore is discarded by the marking phase.@xmath33      the _ update phase _ atomically executes the updates collected by the marking phase . updates gathered by the different solutions for a given predicate are executed only if no inconsistency arises .",
    "this guarantees that only order independent executions are performed .",
    "formally , let @xmath106 .",
    "let @xmath107 be the current database state .",
    "if @xmath108 is a consistent and ground set of updates , the new database @xmath109 is computed as follows : @xmath110 . in this case",
    ", we say that @xmath23 _ commits _ , returning the tuple @xmath111 .",
    "if @xmath108 is inconsistent or contains at least one non - ground update atom , we let @xmath112 and say that @xmath23 _ aborts_. in this case , the evaluation returns the tuple @xmath113 .",
    "consider @xmath107 as in example [ edb ] and the intensional database of example [ exe : syntax ] .",
    "the execution of transaction @xmath114 generates the new extensional database @xmath115 @xmath116 @xmath33",
    "[ sec : neg ]    since solutions containing inconsistent updates are not returned by the marking phase , the u - datalog semantics models some kind of negation .",
    "this form of negation is however very weak with respect to the ability to model arbitrary negation .",
    "indeed , it has been proved that , with respect to the returned substitutions , u - datalog is equivalent to datalog extended with negation on extensional predicates and open with respect to a subset of extensional predicates @xcite . in the following , in order to increase the expressive power of u - datalog , we introduce _ negated atoms _ in the bodies of u - datalog rules .",
    "the resulting language is called u - datalog@xmath117 . then",
    ", we assign a semantics to such language when the considered programs are stratified .",
    "a stratified u - datalog@xmath117 program is defined as follows .",
    "[ strati ] a u - datalog@xmath117 program @xmath7 is stratified if it is possible to find a sequence @xmath118 @xmath119 , @xmath120 ( @xmath91 ) , ( also called stratification ) such that the following conditions hold ( in the following , we denote with @xmath121 the set of predicates defined in @xmath122 ) :    1 .   @xmath123 is a partition of the rules of @xmath7 .",
    "each @xmath122 is called `` stratum '' .",
    "2 .   for each predicate @xmath124",
    ", all the rules defining @xmath125 in @xmath7 are in @xmath126 .",
    "3 .   if @xmath127 , @xmath128 , then @xmath129 with @xmath130 .",
    "4 .   if @xmath131 , @xmath128 , then @xmath132 with @xmath133 . @xmath58",
    "the previous definition can be extended to deal with a u - datalog database @xmath134 . in this case , all extensional facts belong to the first level .    in order to assign a semantics to stratified u - datalog@xmath117 programs ,",
    "we assume that each rule in the program is safe through query invocation . due to the introduction of negation",
    ", the notion of safety is extended by requiring that each variable appearing in a rule head , in a negated literal contained in a rule body , or in an update atom also appears in a positive literal in the rule body or is bound by a constant present in the goal .",
    "the main differences between the bottom - up semantics we are going to present and the bottom - up semantics defined for stratified datalog@xmath117 programs @xcite are the following . due to the condition of safety through query invocation , the semantics of a u - datalog@xmath117 program may contain non - ground constrained atoms that , however , will be made ground by the goal .",
    "thus , negated atoms can not be used , as usually done , as conditions to be satisfied by a solution .",
    "indeed , some variables inside the generated solutions may be made ground by the goal . a solution to this problem is to explicitly represent , during the bottom - up computation , the solutions for which a negated atom @xmath135 is true . in this way",
    ", we maintain all the conditions that the solutions have to satisfy but the check will be executed only when a match with a query goal is performed . to represent such solutions , the underlying constraint theory must be extended to deal with inequality constraints of type @xmath136 , where @xmath14 is a variable and @xmath29 is a constant .",
    "for example , if @xmath137 is the only solution for @xmath138 , then @xmath136 is the solution for @xmath139 .",
    "a second aspect is related to the semantics of @xmath135 with respect to the updates collected by @xmath140 .",
    "@xmath140 , in fact , can also fail due to the generation of inconsistent updates . thus , all solutions containing inconsistent updates represent solutions for @xmath135 .",
    "solutions for @xmath135 in a database @xmath141 are therefore obtained by evaluating @xmath140 in @xmath142 , and complementing not only the computed constraints but also the constraints which ensure the consistency of the updates generated by evaluating @xmath140 .    finally , we assume that the derivation of @xmath143 does not generate any update .",
    "this assumption is motivated by the fact that the evaluation of @xmath135 should be considered as a test with respect to the bindings generated by positive atoms .    in the following , we present the marking phase and the compositional semantics for stratified u - datalog@xmath144 programs .",
    "note that no modification to the update phase is required .",
    "proofs of the presented results can be found in @xcite .      as a natural extension of the constraints domain presented in @xcite , the constrained herbrand base for u - datalog@xmath117 ( denoted by @xmath145 )",
    "consists of constrained literals of the form @xmath146 , where @xmath147 is a conjunction of equality and inequality constraints , @xmath148 is a conjunction of update atoms , and @xmath149 is a literal .",
    "if @xmath149 is a negated atom , @xmath150 is empty . in the following ,",
    "the set of all conjunctions of equalities and inequalities constraints , constructed on the herbrand universe @xmath22 , is denoted by @xmath151 .",
    "[ def : tpneg ] let @xmath152 be a u - datalog@xmath117 database .",
    "the bottom - up operator @xmath153 is defined as follows :    @xmath154=@xmath155 a renamed rule + @xmath156 + @xmath157 which share no variables + @xmath158 + @xmath159 + @xmath160 is @xmath80-solvable } .    before introducing the fixpoint semantics",
    ", we define an operator @xmath161 which performs the negation of a constraint belonging to @xmath162 .",
    "let @xmath163 .",
    "@xmath164 is defined as follows : @xmath165    for example , if @xmath166 , then @xmath167 .",
    "operator @xmath161 is used to define an additional operator @xmath168 , which takes a set @xmath169 of constrained positive literals and returns the set @xmath9 of constrained negative literals , belonging to the complement of @xmath169 .",
    "this operator is used to make explicit the constraints for negative literals at the end of the computation of the positive literals of each stratum .",
    "[ def : comp ] @xmath170 is defined as follows :    * @xmath171 if there does not exist any @xmath172 . *",
    "@xmath173 iff @xmath174 are the only ( renamed apart ) constrained atoms for @xmath46 in @xmath169 , @xmath175 , denotes the projection of constraint @xmath176 onto the variables in @xmath14 ( thus , all the other variables are eliminated by applying a variable elimination algorithm @xcite ) . ]",
    "@xmath177 ( @xmath91 ) , @xmath178 , and @xmath179 is @xmath22-solvable .",
    "@xmath58    in the previous definition , @xmath180 is the set of _ minimal _ defined as follows : @xmath181 if @xmath182 constraints which implies that @xmath183 is a consistent set of updates .",
    "for example ,",
    "@xmath184 @xmath185 @xmath186 . of course",
    ", if @xmath187 is an inconsistent set of update atoms , no solution is generated and @xmath188 .",
    "we also assume that all redundant constrained literals contained in @xmath189 are removed .    in the previous definition , operator @xmath161",
    "is applied to computed constraints and to the constraints which make satisfiable the updates generated by the corresponding positive atom . such solutions have been restricted to the head variables since all the other variables are not needed to define the solutions for the negated atom .",
    "the fixpoint of @xmath190 is computed as follows .",
    "first , the fixpoint of a given stratum is computed .",
    "then , all the facts that have not been derived are made explicitly false .",
    "this corresponds to locally apply the cwa .",
    "note that , due to stratification , this approach is correct since each predicate is completely defined in one stratum .",
    "let @xmath191 be a stratified u - datalog@xmath192 database .",
    "let @xmath193 be a stratification for @xmath81 .",
    "the bottom - up semantics of @xmath81 is defined as @xmath194 where the sequence @xmath195 is computed as follows : + @xmath196 + @xmath197 @xmath58    let @xmath81 be a stratified u - datalog@xmath192 database .",
    "@xmath198 can be computed in a finite number of steps.@xmath58    due to some basic results presented in @xcite , the bottom - up semantics of a stratified u - datalog@xmath117 database is independent from the chosen stratification .",
    "the answers to a given u - datalog@xmath117 goal are computed as described for u - datalog programs in subsection [ ssec : marking ] , by replacing @xmath87 with @xmath199 .",
    "[ ex:1 ] consider the extensional database @xmath6 of example [ edb ] and the u - datalog@xmath117 program @xmath7 obtained by adding the following rules to the ones presented in example [ exe : syntax ] :    @xmath200 + @xmath201    an atom @xmath202 is now true if ` @xmath29 ' belongs to department b and if there exists at least one employee in department a. in this case , it removes all managers of ` @xmath29 ' belonging to department a. it is also true if ` @xmath29 ' belongs to department @xmath140 and it has no manager . in this case",
    ", the evaluation removes all managers of ` @xmath29 ' belonging to department a and makes ` @xmath29 ' manager of itself .",
    "a possible stratification for @xmath191 is the following : @xmath203 @xmath204 , @xmath205 @xmath199 is computed as follows : +    @xmath206=@xmath207 + @xmath208 + @xmath209 @xmath210 @xmath211 + @xmath212 + @xmath213 +   + @xmath214 + @xmath215 + @xmath216 ; @xmath217 + @xmath218 + @xmath219 +   + @xmath220 +   + @xmath221 + @xmath222 + @xmath223 +   + @xmath224 + @xmath225 + @xmath226 + @xmath227 +    note that rule r5 does not provide any additional answer for predicate @xmath228 .",
    "indeed , @xmath229 generates the constraint @xmath230 and @xmath231 generates the constraint @xmath232 .",
    "thus , the whole constraint is inconsistent.@xmath233      the compositional semantics for u - datalog programs ( section [ ssec : compo ] ) was defined by using an unfolding operator which replaces the atom @xmath35 in the body of a rule with the body of a rule defining @xmath46 .",
    "problems arise when unfolding negated atoms .",
    "suppose we want to unfold @xmath37 , then the disjunction of the bodies of _ all _ the rules that define predicate @xmath46 in the compositional semantics has to be negated .",
    "suppose the following rules represent the compositional semantics of a predicate @xmath46 : + @xmath234    since @xmath35 is true ( due to the cwa ) if and only if @xmath235 is true , @xmath37 has to be unfolded with the negation of @xmath236 ( since @xmath237 )",
    ". corresponds to the syntactic transformation performed in the clark s completion approach @xcite . however , while clark s completion is used as a logical theory , our resulting unfolded program is evaluated by using a bottom - up stratified semantics .",
    "therefore , we can prove that @xmath44 and its unfolded version are equivalent w.r.t answer constraints ( see theorem [ pippo ] ) .",
    "moreover , since we deal with stratified programs , no @xmath238 in the formula @xmath239 can be equal to @xmath240 , since no cycle through negation arises in predicate definition .",
    "thus , @xmath241 is always _ consistent _ @xcite . ]",
    "a problem arises when there exists an infinite set of rules defining @xmath35 in the compositional semantics . in this case , the unfolding operator can not be applied since it is not effective . in order to solve this problem , a weaker notion of compositionality can be introduced , based on the restriction of the set of extensional databases with respect to which the intensional database can be composed .",
    "the additional information available on the considered extensional database has to guarantee that the result of the unfolding operator , which unfolds all the positive literals in the rule bodies , is finite .",
    "gabbrielli et al . in @xcite showed that , when the herbrand universe @xmath22 is finite , it is possible to compute a t - stable semantics of a logic program @xmath7 , which is finite and gives the same answer constraints of @xmath7 when composed with any extensional database defined on @xmath22 .",
    "intuitively , the t - stable semantics iterates the unfolding operator as many times as the new unfolded rules may give different results on the finite domain @xmath39 .    under these hypothesis , the compositional semantics for a stratified u - datalog@xmath192 program corresponds to an unfolding semantics computed in two steps :    1 .",
    "in the first step , all positive literals in the rule bodies are unfolded , by computing the t - stable semantics according to the algorithm given in @xcite and the unfolding operator presented in section [ ssec : compo ] . at this stage ,",
    "negative literals are left unchanged .",
    "2 .   in the second step , negative literals are unfolded . due to the finite domain assumption and results presented in @xcite ,",
    "the set of rules required to unfold negative literals is finite .",
    "the result is a recursion free program written in an _ extended _ u - datalog@xmath117 language which characterizes the semantics of the intensional database w.r.t.@xmath242 the extensional one .      in order to compute the compositional semantics of a program @xmath7 ,",
    "we first unfold positive literals by dealing with negative literals as if they were extensional predicates .",
    "this means that negative literal are not unfolded . to this purpose ,",
    "the techniques presented in @xcite are applied to obtain a finite set of rules , denoted by @xmath243 .",
    "the basic idea of the t - stable semantics is illustrated by the following example .",
    "[ ex:3 ] consider rules r1 and r2 presented in example [ exe : syntax ] and suppose that @xmath244 . after two iterations of the unfolding operator presented in section [ ssec : compo ] , we obtain the following rules ( call them @xmath245 ) :    @xmath246 + @xmath247    at the third iteration of the unfolding operator we also obtain the rule    @xmath248=@xmath249 + @xmath250    which can not infer different results on any database defined on two elements , since @xmath251 computes the transitive closure of relation @xmath252 .",
    "thus , @xmath245 corresponds to the t - stable semantics of the previous rules .",
    "now suppose that @xmath253 .",
    "the t - stable semantics @xmath254 is computed as follows ( in the following , @xmath255 denotes the set of rules contained in stratum @xmath256 of @xmath254 ) :    @xmath257=@xmath258=@xmath259 + @xmath260 + @xmath261=@xmath262 + @xmath250 + @xmath263 + @xmath264 + @xmath265 + @xmath266 + @xmath250 + @xmath267 + @xmath268 + @xmath269 @xmath33    by results presented in @xcite and @xcite , we can state the following results .",
    "+    let @xmath80 be the fixed and finite herbrand universe .",
    "let @xmath254 the t - stable semantics computed as described in @xcite , depending on the cardinality of @xmath80 .",
    "for any extensional database @xmath6 , @xmath270 is equivalent to @xmath271 .",
    "moreover , @xmath254 admits the same stratification of @xmath7 and preserves goal admissibility.@xmath58      after constructing @xmath243 , negative literals have to be unfolded . in order to unfold a negated literal @xmath37 , the disjunction of the bodies of _ all _ the rules defining predicate @xmath46 in @xmath243",
    "has to be negated .",
    "this approach should be applied stratum by stratum , generating in a finite number of steps a set of rules not containing negative literals .",
    "note that , due to stratification conditions , the unfolding of @xmath272 is required only in rules belonging to levels higher than the level where @xmath46 is defined .",
    "the resulting set of rules corresponds to the compositional semantics of @xmath7 .",
    "however , unfortunately , the negated disjunction of the bodies defining @xmath46 is , in general , a first order formula , which can not be represented in u - datalog@xmath117 , as the following example shows .",
    "[ ex : pluto ] consider the intensional predicate @xmath46 defined by the rule @xmath273 @xmath274 , where @xmath241 and @xmath125 are extensional predicates .",
    "the previous rule is logically equivalent to the following first order formula : @xmath275 . by assuming that @xmath276 is the only rule defining @xmath46 , by cwa",
    ", we obtain that @xmath277 . but",
    "@xmath278 is logically equivalent to @xmath279 , which can always be transformed in prenex disjunctive normal form @xcite obtaining @xmath280 .",
    "@xmath33    from the previous example it follows that , in order to unfold negative literals , the u - datalog@xmath117 syntax has to be extended to deal with first order formulas . as shown in the example , the variables which become quantified after negation , correspond to _ local variables _ of the original rule , i.e. , body variables not appearing in the rule head .",
    "after this extension , the syntax of a u - datalog@xmath117 rule , hereafter called _ extended u - datalog@xmath192 _ rule , becomes the following : +    @xmath281    where @xmath9 is an atom , @xmath17 is an update constraint , @xmath13 is a conjunction of equality constraints , @xmath282 is a conjunction of positive literals , @xmath283 is a first order formula in prenex disjunctive normal form , where @xmath284 is a sequence of quantified variables , not appearing in @xmath9 or in @xmath282 , each @xmath285 is a conjunction of equality and inequality constraints , each @xmath286 is a conjunction of literals .",
    "intuitively , @xmath287 is generated by the unfolding of positive literals whereas the first order formula @xmath288 is generated by the unfolding of negative literals .",
    "of course , we still assume that rules are stratified .",
    "an extended u - datalog rule body is true in a given interpretation if there exist some bindings for the positive literals and some bindings for the free variables of the quantified formula which make the rule body true in the given interpretation .",
    "formally , the truth of an extended u - datalog rule body can be defined as follows .",
    "let @xmath289 where @xmath290 .",
    "let @xmath291 be the free variables of @xmath292 .",
    "let @xmath293 .",
    "@xmath294 is true in @xmath295 with answer constraint @xmath296 if there exist @xmath297 @xmath298 , and @xmath299 ( @xmath300 ) , such that @xmath301 , @xmath302 , @xmath303 is @xmath304-solvable , and @xmath305 .",
    "means that for any assignment of values to quantified variables , satisfying @xmath306 , it is possible to find some constrained literals in @xmath295 unifying with those in @xmath292 , such that the resulting constraint is @xmath80-solvable . ]",
    "@xmath58    the bottom - up operator of an extended u - datalog@xmath117 program can be now defined as follows ( in the following , @xmath307 denotes the body of a rule @xmath276 ) .",
    "let @xmath152 be an extended u - datalog@xmath192 database .",
    "the bottom - up operator @xmath308 is defined as follows :    @xmath309=@xmath310 a renamed rule + @xmath311 + @xmath312 is an answer constraint for @xmath307 in @xmath295 } @xmath58    let @xmath80 be a finite domain .",
    "@xmath313 is a continuous operator.@xmath58    given an extensional database @xmath6 and an extended u - datalog@xmath117 program @xmath7 , the semantics of @xmath314 is obtained as the least fixpoint of @xmath315 , denoted by @xmath316 . due to",
    "the presence of a first order formula in rule bodies , a new safeness through query invocation property has to be stated .",
    "let @xmath44 be an extended datalog@xmath117 program .",
    "@xmath44 is _ safe through query invocation _ if each non - quantified variable , appearing in a rule head , in an update atom , or in a negated atom , also appears in a positive literal of the rule body or is bound by a constant present in the goal.@xmath58    the unfolding operator we are going to define works stratum by stratum .",
    "first , positive literals in the rule bodies of each stratum are unfolded by using operator @xmath317 .",
    "then , the negative literals contained in the @xmath318-th stratum of @xmath317 are unfolded by using an operator @xmath319 and the rules resulting from the completed unfolding of strata @xmath320 .",
    "the result is an extended u - datalog@xmath117 program equivalent to @xmath7 but not containing positive or negative intensional literals .    before presenting the unfolding operator",
    ", we define the operator @xmath319 which unfolds the negative literals of a u - datalog@xmath117 program @xmath7 , by using the rules of an extended u - datalog@xmath117 program @xmath321 . in order to define function @xmath319",
    ", we need an operator , @xmath322 , which takes the disjunction of a set of ( extended ) u - datalog@xmath117 rule bodies defining a predicate @xmath46 , performs its logical negation and returns the resulting first order formula in prenex disjunctive normal form .",
    "such formula is then used to construct the unfolded rule .",
    "information on the head variables of each rule defining @xmath46 is useful to understand which are the local variables , that is , the variables which have to be quantified . in performing negation ,",
    "also constraints which make the update atoms satisfiable have to be considered , similarly to what has been done for operator @xmath168 ( see definition [ def : comp ] ) .",
    "let @xmath323 is an extended u - datalog@xmath117 program}. let @xmath7 be a stratified u - datalog@xmath117 intensional database .",
    "the unfolding operator @xmath324 is defined as follows :    @xmath319=@xmath325=@xmath326 a renamed rule + @xmath327 + for all @xmath328 ( @xmath329 ) , consider the body of all the rules @xmath330 ( @xmath331 ) +  defining @xmath328 in @xmath321 + @xmath332 + @xmath333 + @xmath334 + @xmath335 + @xmath336=@xmath337 + @xmath338 + @xmath339 is @xmath340-solvable @xmath341 @xmath58    by using operator @xmath319 , the compositional semantics is defined as follows .",
    "[ compo ] let @xmath7 be a stratified u - datalog@xmath117 program .",
    "suppose that @xmath7 , and therefore @xmath254 , admits a stratification with @xmath342 strata @xmath343 .",
    "let @xmath255 be the set of rules contained in stratum @xmath256 of @xmath254 .",
    "the compositional semantics @xmath344 is defined as follows ( see subsection [ ssec : comp ] for the definition of @xmath345 ) :    @xmath346    [ pippo ] @xmath344 is safe through query invocation and for each admissible goal @xmath23 and for each extensional database edb , the answer constraints for @xmath23 in @xmath347 are the same than the ones in @xmath348.@xmath58    consider the program @xmath7 and its stratification , as presented in example [ ex:1 ] , and its positive unfolding @xmath254 , as presented in example [ ex:3 ] .",
    "the compositional semantics of @xmath7 is constructed as follows :    @xmath349=@xmath350 @xmath351=@xmath352 + @xmath353 @xmath354 = @xmath355 + @xmath356 + @xmath357 + @xmath358    the second rule for predicate @xmath228 derives from the unfolding of predicate @xmath359 .",
    "the formula is the simplified result of the application of the @xmath360 operator to the disjunction of the bodies of the rules defining @xmath361 .",
    "@xmath33    it is important to remark that the compositional semantics has not to be considered as an alternative semantics w.r.t .",
    "the marking phase semantics . indeed , the computation of the compositional semantics can be quite expensive .",
    "however , since the compositional semantics is recursion free and has to be computed just once ( unless the herbrand domain changes ) it can be meaningfully used in some cases as a precompilation technique .",
    "in this paper we have introduced negation inside u - datalog rules and proposed a stratification - based approach to assign a semantics to such programs .",
    "we have also introduced a weaker concept of compositionality and presented a finite and effectively computable compositional semantics for u - datalog@xmath192 programs . by results presented in @xcite , it is quite immediate to prove that , with respect to the returned answers , u - datalog@xmath117 is equivalent to stratified datalog@xmath117 , open with respect to a subset of extensional predicates @xcite .",
    "the presented results can be extended to deal with other datalog - like update languages safe through query invocation .",
    "future work includes the introduction of negation in other u - datalog extensions @xcite and the definition of static analysis techniques for u - datalog@xmath192 , similarly to those proposed for u - datalog @xcite ."
  ],
  "abstract_text": [
    "<S> u - datalog has been developed with the aim of providing a set - oriented logical update language , guaranteeing update parallelism in the context of a datalog - like language . in u - datalog , updates are expressed by introducing constraints ( @xmath0 , to denote insertion , and @xmath1 , to denote deletion ) inside datalog rules . a u - datalog program can be interpreted as a clp program . in this framework , </S>",
    "<S> a set of updates ( constraints ) is satisfiable if it does not represent an inconsistent theory , that is , it does not require the insertion and the deletion of the same fact . </S>",
    "<S> this approach resembles a very simple form of negation . </S>",
    "<S> however , on the other hand , u - datalog does not provide any mechanism to explicitly deal with negative information , resulting in a language with limited expressive power . in this paper </S>",
    "<S> , we provide a semantics , based on stratification , handling the use of negated atoms in u - datalog programs and we show which problems arise in defining a compositional semantics .    </S>",
    "<S> [ firstpage ] </S>"
  ]
}