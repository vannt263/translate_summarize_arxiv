{
  "article_text": [
    "many problems in program analysis reduce to undecidable problems about context - free languages .",
    "for example , checking safety properties of multithreaded recursive programs reduces to checking emptiness of the intersection of context - free languages @xcite . checking reachability for recursive counter programs relies on context - free languages to describe valid control flow paths .",
    "we study underapproximations of these problems , with the intent of building tools to find bugs in systems .",
    "in particular , we study underapproximations in which one or more context - free languages arising in the analysis are replaced by their subsets in a way that ( ) the resulting problem after the replacement becomes decidable and ( ) the subset preserves `` many '' strings from the original language . condition ( ) ensures that we have an algorithmic check for the underapproximation .",
    "condition ( ) ensures that we are likely to retain behaviors that would cause a bug in the original analysis .",
    "we show in this paper an underapproximation scheme using _ bounded languages _",
    "a language @xmath0 is _ bounded _ if there exist @xmath6 and finite words @xmath7 such that @xmath0 is a subset of the regular language @xmath8 .",
    "in particular , context - free bounded languages ( hereunder bounded languages for short ) have stronger properties than general context - free languages : for example , it is decidable to check if the intersection of a context - free language and a bounded language is non - empty @xcite . for our application to verification",
    ", these decidability results ensure condition ( ) above .",
    "the key to condition ( ) is the following _ parikh - boundedness _ property : for every context - free language @xmath0 , there is a bounded language @xmath9 such that the parikh images of @xmath0 and @xmath10 coincide .",
    "( the _ parikh image _ of a word @xmath11 maps each symbol of the alphabet to the number of times it appears in @xmath11 , the parikh image of a language is the set of parikh images of all words in the language . )",
    "a language @xmath10 meeting the above conditions is called a _",
    "parikh - equivalent bounded subset _ of @xmath0 .",
    "intuitively , @xmath10 preserves `` many '' behaviors as for every string in @xmath0 , there is a permutation of its symbols that matches a string in @xmath10 .    the parikh - boundedness property was first proved in @xcite , however , the chain of reasoning used in these papers made it difficult to see how to explicitly construct the parikh - equivalent bounded subset .",
    "our paper gives a direct and constructive proof of the theorem .",
    "we identify three two contributions in this paper .    *",
    "explicit construction of parikh - equivalent bounded subsets . *",
    "our constructive proof falls into two parts .",
    "first , using newton s iteration @xcite on the semiring of languages , we construct , for a given context - free language @xmath0 , a finite sequence of linear substitutions which denotes a parikh - equivalent ( but not necessarily bounded ) subset of @xmath0 .",
    "( a linear substitution maps a symbol to a language defined by a _ linear _ grammar , that is , a context - free grammar where each rule has at most one non - terminal on the right - hand side . )",
    "the parikh equivalence follows from a convergence property of newton s iteration .",
    "second , we provide a direct constructive proof that takes as input such a sequence of linear substitutions , and constructs by induction a parikh - equivalent bounded subset of the language denoted by the sequence .",
    "* reachability analysis of multithreaded programs with procedures .",
    "* using the above construction , we obtain a semi - algorithm for reachability analysis of multithreaded programs with the intent of finding bugs . to check",
    "if configuration @xmath12 of a recursive 2-threaded program is reachable , we construct the context - free languages @xmath13 and @xmath14 respectively given by the execution paths whose last configurations are @xmath15 and @xmath16 , and check if either @xmath17 or @xmath18 is non - empty , where @xmath19 and @xmath20 are two parikh - equivalent bounded subsets of @xmath21 and @xmath22 , respectively . if either intersection is non - empty , we have found a witness trace .",
    "otherwise , we construct @xmath23 and @xmath24 in order to exclude , from the subsequent analyses , the execution paths we already inspected . we continue by rerunning the above analysis on @xmath25 and @xmath26 .",
    "if @xmath12 is reachable , the iteration is guaranteed to terminate ; if not , it could potentially run forever .",
    "moreover , we show our technique subsumes and generalizes context - bounded reachability @xcite .",
    "* reachability analysis of programs with counters and procedures .",
    "* we also show how to underapproximate the set of reachable states of a procedural program that manipulates a finite set of counters .",
    "this program is given as a counter automaton @xmath27 ( see @xcite for a detailed definition ) together with a context - free language @xmath0 over the transitions of @xmath27 .",
    "our goal is to compute the states of @xmath27 that are reachable using a sequence of transitions in @xmath0 .",
    "a possibly non terminating algorithm to compute the reachable states of @xmath27 through executions in @xmath0 is to ( 1 ) find a parikh - equivalent bounded subset @xmath10 of @xmath0 ; ( 2 ) compute the states that are reachable using a sequence of transitions in @xmath10 ( as explained in @xcite , this set is computable if @xmath28 some restrictions on the transitions of @xmath27 ensures the set is presburger definable and @xmath29 @xmath10 is bounded , i.e. @xmath30 ) ; and ( 3 ) rerun the analysis using for @xmath31 so that runs already inspected are omitted in every subsequent analyses . again , every path in @xmath0 is eventually covered in the iteration .    in @xcite , we provide detailed proofs and one more applications of our result",
    ".    * related work .",
    "* bounded languages have been recently proposed by kahlon for tractable reachability analysis of multithreaded programs @xcite .",
    "his observation is that in many practical instances of multithreaded reachability , the languages are actually bounded .",
    "if this is true , his algorithm checks the emptiness of the intersection ( using the algorithm in @xcite ) .",
    "in contrast , our results are applicable even if the boundedness property does not hold .    for multithreaded reachability ,",
    "_ context - bounded reachability _",
    "@xcite is a popular underapproximation technique which tackles the undecidability by limiting the search to those runs where the active thread changes at most @xmath32 times .",
    "our algorithm using bounded languages _ subsumes _ context - bounded reachability , and can capture unboundedly many synchronizations in one analysis .",
    "we leave the empirical evaluation of our algorithms for future work .",
    "an alphabet is a finite non - empty set of symbols .",
    "we use the letter @xmath33 to denote some alphabet .",
    "we assume the reader is familiar with the basics of language theory ( see @xcite ) .",
    "the concatenation @xmath34 of two languages @xmath35 is defined using word concatenation as @xmath36 .",
    "an _ elementary bounded language _ over @xmath33 is a language of the form @xmath8 for some @xmath37 .",
    "* vectors . * for @xmath38 , we write @xmath39 and @xmath40 for the set of @xmath41-dim vectors ( or simply vectors ) of integers and naturals , respectively .",
    "we write @xmath42 for the vector @xmath43 and @xmath44 the vector @xmath45 such that @xmath46 if @xmath47 and @xmath48 otherwise .",
    "_ addition _ on @xmath41-dim vectors is the componentwise extension of its scalar counterpart , that is , given @xmath49 @xmath50 .",
    "given @xmath51 and @xmath52 , we write @xmath53 as the @xmath54-times sum @xmath55",
    ".    * parikh image . *",
    "give @xmath33 a fixed linear order : @xmath56 .",
    "the parikh image of a symbol @xmath57 , written @xmath58 , is @xmath44 .",
    "the parikh image is extended to words of @xmath59 as follows : @xmath60 and @xmath61 . finally , the parikh image of a language on @xmath59 is the set of parikh images of its words .",
    "we also define , using vector addition , the operation @xmath62 on sets of parikh vectors as follows : given @xmath63 , let @xmath64 .",
    "thus , @xmath65 maps @xmath66 to @xmath67 . when it is clear we omit the subscript in @xmath65 .",
    "we also define the inverse of the parikh image @xmath68 as follows : given a subset @xmath69 of @xmath70 , @xmath71 is the set @xmath72 . when it is clear from the context we generally omit the subscript in @xmath65 and @xmath73 .",
    "the following lemma gives the properties of @xmath74 and @xmath75 we need in the sequel .",
    "for every @xmath76 we have @xmath77 .",
    "+ let @xmath78 , for every @xmath79 we have :    additivity of @xmath74 : :    @xmath80 ; monotonicity of @xmath81 : :    @xmath82 implies    @xmath83 ; extensivity of @xmath81 : :    @xmath84 ; idempotency of @xmath81 : :    @xmath85 ; structure - semipreservation of @xmath81 : :    @xmath86 ; preservation of @xmath74 : :    @xmath87 .",
    "[ lem : additiveinsertion ]    for the first statement we first observe that @xmath74 is a surjective function , for each vector of @xmath40 there is a word that is mapped to that vector .",
    "next , @xmath88 for the additivity , the monotonicity , the extensivity and the idempotency properties , we simply show the equivalence given below .",
    "hence the properties immediately follows by property of galois connection ( we refer the reader to @xcite for detailed proofs ) .",
    "we show that for every @xmath89 we have : @xmath90 iff @xmath91 .",
    "@xmath92 for structure semipreservation , we prove that @xmath93 for @xmath94 as follows : @xmath95 the result generalizes to languages in a natural way .",
    "finally , the preservation of @xmath74 is proved as follows : @xmath96    * context - free languages . * a _ context - free grammar _",
    "@xmath97 is a tuple @xmath98 where @xmath99 is a finite non - empty set of variables ( non - terminal letters ) , @xmath33 is an alphabet of terminal letters and @xmath100 a finite set of productions ( the production @xmath101 may also be noted @xmath102 ) .",
    "given two strings @xmath103 we define the relation @xmath104 , if there exists a production @xmath105 and some words @xmath106 such that @xmath107 and @xmath108 .",
    "we use @xmath109 for the reflexive transitive closure of @xmath110 .",
    "a word @xmath111 is recognized by the grammar @xmath97 from the state @xmath112 if @xmath113 .",
    "given @xmath114 , the language @xmath115 is given by @xmath116 .",
    "a language @xmath0 is _ context - free _ ( written cfl ) if there exists a context - free grammar @xmath117 and an initial variable @xmath118 such that is @xmath119 .",
    "a _ linear grammar _",
    "@xmath97 is a context - free grammar where each production is in @xmath120 .",
    "a language @xmath0 is _ linear _ if @xmath121 for some linear grammar @xmath97 and initial variable @xmath122 of @xmath97 .",
    "a cfl @xmath0 is _ bounded _ if it is a subset of some elementary bounded language",
    ".    * proof plan . *",
    "the main result of the paper is the following .",
    "[ theo - main ] for every cfl @xmath0 , there is an effectively computable cfl @xmath10 such that @xmath28 @xmath1 , @xmath29 @xmath123 , and @xmath124 @xmath10 is bounded .",
    "we actually solve the following related problem in our proof .    given a cfl @xmath0 ,",
    "compute an elementary bounded language @xmath125 such that @xmath126 .",
    "[ pb : elembounded ]    if we can compute such a @xmath125 , then we can compute the cfl @xmath127 which satisfies conditions @xmath28 to @xmath124 of the th .",
    "[ theo - main ] .",
    "thus , solving pb .",
    "[ pb : elembounded ] proves the theorem constructively .",
    "we solve pb .",
    "[ pb : elembounded ] for a language @xmath0 as follows : ( 1 ) we find an @xmath10 such that @xmath1 , @xmath128 , and @xmath10 has a `` simple '' structure ( sect .  [ sec - representation ] ) and ( 2 ) then show how to find an elementary bounded @xmath125 with @xmath129 , assuming this structure ( sect .",
    "[ sec - construction ] ) . observe that if @xmath1 and @xmath123 , then for every elementary bounded @xmath125 , we have @xmath129 implies @xmath130 as well .",
    "so the solution @xmath125 for @xmath10 in step ( 2 ) is a solution for @xmath0 as well .",
    "section  [ sec - applications ] provides applications of the result for program analysis problems .",
    "section  [ sec - applications ] provides an application of the result for multithreaded program analysis and compares it with an existing technique .",
    "our proof to compute the above @xmath10 relies on a fixpoint characterization of cfls and their parikh image .",
    "accordingly , we introduce the necessary mathematical notions to define and study properties of those fixpoints",
    ".    * semiring .",
    "* a _ semiring _",
    "@xmath131 is a tuple @xmath132 , where @xmath133 is a set with @xmath134 , @xmath135 is a commutative monoid with neutral element @xmath136 , @xmath137 is a monoid with neutral element @xmath138 , @xmath136 is an annihilator w.r.t .",
    "@xmath139 , @xmath140 for all @xmath141 , and @xmath139 distributes over @xmath142 , @xmath143 , and @xmath144 .",
    "we call @xmath145 the _ combine _ operation and @xmath146 the _ extend _ operation . the natural order relation @xmath147 on a semiring @xmath131 is defined by @xmath148 .",
    "the semiring @xmath131 is _ naturally ordered _ if @xmath147 is a partial order on @xmath133 .",
    "the semiring @xmath149 is _ commutative _ if @xmath150 for all @xmath151 , _ idempotent _ if @xmath152 for all @xmath153 , _ complete _ if it is naturally ordered and @xmath147 is such that @xmath154-chains @xmath155 have least upper bounds .",
    "finally , the semiring @xmath131 is _ @xmath154-continuous _ if it is naturally ordered , complete and for all sequences @xmath156 with @xmath157 , @xmath158 .",
    "we define two semirings we shall use subsequently .",
    "_ language semiring .",
    "_ : :    let    @xmath159    denote the idempotent @xmath154-continuous semiring of    languages .",
    "the natural order on @xmath160 is given by set    inclusion ( viz .",
    "@xmath161 ) .",
    "_ parikh semiring .",
    "_ : :    the tuple    @xmath162    is the idempotent @xmath154-continuous commutative semiring    of parikh vectors .",
    "the natural order is again given by    @xmath161 .    * valuation , partial order , linear form , monomial and polynomial ( transformation ) . * a _ valuation",
    "_ @xmath163 is a mapping @xmath164 .",
    "we denote by @xmath165 the set of all valuations and by @xmath166 the valuation which maps each variable to @xmath136 .",
    "+ the operations @xmath142 , @xmath139 are naturally extended to valuations .",
    "the _ partial order _",
    "@xmath147 on @xmath131 can be lifted to a partial order on valuations , to this end we stack a point above @xmath147 ( viz .",
    "@xmath167{\\stackrel{.}{\\sqsubseteq}}}$ ] ) to denote the pointwise inclusion , given by @xmath168{\\stackrel{.}{\\sqsubseteq}}}\\vbf'$ ] if and only if @xmath169 for every @xmath114 .",
    "+ a _ linear form _ is a mapping @xmath170 satisfying @xmath171 for every @xmath172 and @xmath173 .",
    "+ a _ monomial _ is a mapping @xmath174 described by a finite expression @xmath175 where @xmath176 , @xmath177 and @xmath178 such that @xmath179 for @xmath180 .",
    "the empty monomial is given by an empty expression coincides with @xmath138 .",
    "+ a _ polynomial _ is a finite combination of monomials : @xmath181 where @xmath176 and @xmath182 are monomials .",
    "the set of polynomials w.r.t .",
    "@xmath131 and @xmath99 will be denoted by @xmath183 $ ] .",
    "the empty polynomial is given by an empty combination of monomials and coincides with @xmath136 .",
    "+ finally , a _",
    "polynomial transformation _",
    "@xmath184 is a mapping @xmath185 described by the set @xmath186 \\mid x\\in \\mathcal{x}}$ ] of polynomials : hence , for every valuation @xmath180 , @xmath187 is a valuation that assigns each variable @xmath118 to @xmath188 .",
    "* differential .",
    "* for every @xmath114 , let @xmath189 denote the linear form defined by @xmath190 for every @xmath191 : @xmath189 is the _ dual variable _ associated with the variable @xmath122 .",
    "let @xmath192 denote the set @xmath193 of dual variables .",
    "let @xmath194 $ ] be a polynomial and let @xmath114 be a variable .",
    "the _ differential w.r.t . @xmath122 _ of @xmath195 is the mapping @xmath196 that assigns to every valuation @xmath163 the linear form @xmath197 defined by induction as follows : @xmath198 then , the _ differential _ of @xmath195 is defined by @xmath199 consequently , the linear form @xmath200 is a polynomial of the following form : @xmath201 where each @xmath202 and @xmath203 .",
    "we extend the definition of differential on polynomial transformation .",
    "hence , @xmath204 is defined for every @xmath205 and every variable @xmath122 as follows : @xmath206    * least fixpoint . *",
    "recall that a mapping @xmath207 is monotone if @xmath208 implies @xmath209 , and continuous if for any infinite chain @xmath210 we have @xmath211 .",
    "the definition can be extended to mappings @xmath212 from valuations to valuations in the obvious way ( componentwise ) .",
    "then we may formulate the following proposition ( cf .",
    "@xcite ) .    let @xmath184 be a polynomial transformation .",
    "the mapping induced by @xmath184 is monotone and continuous .",
    "hence , by kleene s theorem , @xmath184 has a unique least fixpoint @xmath213 .",
    "further , @xmath213 is the supremum ( w.r.t .",
    "@xmath214 ) of the kleene s iteration sequence given by @xmath215 , and @xmath216 .    *",
    "valuation , polynomial . * in what follows ,",
    "let @xmath99 be a finite set of variables and @xmath217 be an @xmath154-continuous semiring .    a _ valuation _",
    "@xmath163 is a mapping @xmath164 .",
    "we denote by @xmath165 the set of all valuations and by @xmath166 the valuation which maps each variable to @xmath136 .",
    "we define @xmath167{\\stackrel{.}{\\sqsubseteq}}}\\subseteq \\ring^\\mathcal{x}\\times \\ring^\\mathcal{x}$ ] as the order given by @xmath168{\\stackrel{.}{\\sqsubseteq}}}\\vbf'$ ] if and only if @xmath169 for every @xmath114 .",
    "a _ monomial _ is a mapping @xmath174 given by a finite expression @xmath218 where @xmath176 , @xmath177 and @xmath219 such that @xmath220 for @xmath180 .",
    "+ a _ polynomial _ is a finite combination of monomials : @xmath181 where @xmath176 and @xmath182 are monomials .",
    "the set of polynomials w.r.t .",
    "@xmath131 and @xmath99 will be denoted by @xmath183 $ ] . finally , a _ polynomial transformation _",
    "@xmath184 is a mapping @xmath221 described by the set @xmath186 \\mid x\\in \\mathcal{x}}$ ] of polynomials : hence , for every vector @xmath180 , @xmath187 is a valuation of each variable @xmath118 to @xmath188 .",
    "* least fixpoint . * recall that a mapping @xmath222 is monotone if @xmath223 implies @xmath209 , and continuous if for any infinite chain @xmath210 we have @xmath211 .",
    "the definition can be extended to mappings @xmath212 in the obvious way ( using @xmath167{\\stackrel{.}{\\sqsubseteq}}}$ ] ) .",
    "then we may formulate the following proposition ( cf .",
    "@xcite ) .    let @xmath184 be a polynomial transformation .",
    "the mapping induced by @xmath184 is monotone and continuous and @xmath184 has a unique least fixpoint @xmath213 .",
    "fixpoints of polynomial transformations relates to cfls as follows . given a grammar @xmath117 , let @xmath224 be the valuation which maps each variable @xmath118 to the language @xmath115",
    "we first characterize the valuation @xmath224 as the least fixpoint of a polynomial transformation @xmath184 defined as follows : each @xmath225 of @xmath184 is given by the combination of @xmath226 s for @xmath227 where @xmath226 is interpreted as a monomial on the semiring @xmath160 . from @xcite we know that @xmath228 .",
    "let @xmath229 where @xmath230 .",
    "it defines the polynomial transformation @xmath184 on @xmath231 such that @xmath232 and @xmath233 , and @xmath224 is the least fixpoint of @xmath184 in the language semiring .",
    "we now recall the iteration sequence of @xcite whose limit is the least fixpoint of @xmath184 . in some cases , the iteration sequence converges after a finite number of iterates while the kleene iteration sequence does not .",
    "* newton s iteration sequence . * given a polynomial transformation @xmath184 on a @xmath154-continuous semiring @xmath131 , _",
    "newton s iteration sequence _ is given by the following sequence : @xmath234 the limit of which coincides with @xmath213 ( see @xcite for further details ) .",
    "we naturally extend the definition of the parikh image to a valuation @xmath235 as the valuation of @xmath236 defined for each variable @xmath122 by : @xmath237 .",
    "the following lemma relates polynomial transformations on @xmath160 and @xmath238 .",
    "let @xmath239 $ ] , that is a polynomial over the semiring @xmath160 and variables @xmath99 .",
    "define @xmath240 , we have @xmath241 $ ] .",
    "[ lem : fppoly ]    by induction on the structure of @xmath242 .",
    "the polynomial @xmath242 is given by @xmath243 .",
    "hence , @xmath244 where each @xmath245 is of the form @xmath246 with @xmath247 , @xmath248 .",
    "let @xmath249 be a monomial , we have : @xmath250    we now prove a commutativity results on polynomials and the parikh mapping .",
    "let @xmath239 $ ] , for every valuation @xmath251 , we have : @xmath252 [ lem : piffip ]    first , the definition of @xmath253 shows that for every @xmath251 : @xmath254 the inclusion @xmath255 is clear since @xmath168{\\stackrel{.}{\\sqsubseteq}}}\\phi(\\vbf)$ ] , every function occuring in the above expression is monotone and the functional composition preserves monotonicity . for the reverse inclusion , we first show that for every @xmath256{\\stackrel{.}{\\sqsubseteq}}}\\phi(\\vbf)$ ] we have @xmath257 .",
    "that is @xmath258 .",
    "@xmath239 $ ] shows that @xmath259 for some monomial @xmath260 , that is @xmath261 .",
    "we have , @xmath262{\\stackrel{.}{\\sqsubseteq}}}\\phi(\\vbf)$}\\\\      & \\owns x & \\text{def.\\ of $ x$}\\end{aligned}\\ ] ] the following reasoning concludes the proof : @xmath263    here follows a commutativity result between the differential and the parikh image .",
    "for every @xmath239 $ ] , every valuation @xmath264 , every @xmath114 we have : @xmath265 [ lem : deriv ]    first it is important to note that lemma  [ lem : fppoly ] shows that @xmath253 and @xmath242 are of the same form .",
    "then the proof falls into four parts according to the definition of the differential w.r.t . @xmath122 .",
    "@xmath266 or @xmath267 . in this case",
    ", we find that @xmath268 , hence that @xmath269 .",
    "since @xmath253 is of the above form , we find that @xmath270 .",
    "so @xmath272 .",
    "@xmath273    @xmath274",
    "so @xmath253 is of the form @xmath275 .",
    "the induction hypothesis shows the rest .",
    "@xmath276 this case is treated similarly .",
    "this result generalizes to the complete differential : @xmath277    we note that the previous results also generalizes to polynomial transformation in a natural way . in the next subsection , thanks to the previous results , we show that newton s iteration sequence on the language semiring reaches a stable parikh image after a finite number of steps .",
    "this result is crucial in order to achieve the goal of this section : compute a sublanguage @xmath10 of @xmath0 such that @xmath123 .      given a polynomial transformation @xmath184 , we now characterize the relationship between the least fixpoints @xmath278 taken over the language and the parikh semiring , respectively .",
    "either fixpoint is given by the limit of a sequence of _ iterates _ which is defined by newton s iteration scheme @xcite .",
    "our characterization operates at the level of those iterates : we inductively relate the iterates of each iteration sequence ( over the parikh and language semirings ) .",
    "we use newton s iteration instead of the usual kleene s iteration sequence because newton s iteration is guaranteed to converge on the parikh semiring in a finite number of steps , a property that we shall exploit .",
    "kleene s iteration sequence , on the other hand , may not converge . due to lack of space , we refer the reader to @xcite for newton s iteration scheme definition .",
    "we first extend the definition of the parikh image to a valuation @xmath279 as the valuation of @xmath236 defined for each variable @xmath122 by : @xmath237 .",
    "then , given @xmath280 , a polynomial transformation , we define a polynomial transformation @xmath281 such that : for every @xmath118 we have @xmath282 . lemma .",
    "[ lem : parikhcoincidence ] relates the iterates for @xmath283 and @xmath284 using the parikh image mapping .",
    "let @xmath285 and @xmath286 be newton s iteration sequences associated with @xmath287 and @xmath288 , respectively .",
    "for every @xmath289 , we have @xmath290 . [",
    "lem : parikhcoincidence ]    * base case .",
    "@xmath291 * this case is trivially solved using part ( 2 ) of lem .",
    "[ lem : fppoly ] .    * inductive case . @xmath292 * @xmath293    in @xcite , the authors show that newton s iterates converges after a finite number of steps when defined over a commutative @xmath154-continuous semiring .",
    "this shows , in our setting , that @xmath286 stabilizes after a finite number of steps .",
    "let @xmath286 be newton s iteration sequence associated to @xmath288 and let @xmath294 be the number of variables in @xmath99 . for every @xmath295 , we have @xmath296 .",
    "hence , for every @xmath295 , @xmath297 .",
    "[ lem : newtonparikh ]    @xmath298    transitivity of the equality shows the remaining result .",
    "we know newton s iteration sequence @xmath299 , whose limit is @xmath283 , may not converge after a finite number of iterations .",
    "however , using lem .",
    "[ lem : newtonparikh ] , we know that the parikh image of the iterates stabilizes after a finite number of steps .",
    "precisely , if @xmath294 is the number of variables in @xmath99 , then the language given by @xmath300 is such that @xmath301 .",
    "moreover because @xmath299 is an ascending chain , for each variable @xmath118 , we have that @xmath302 is a sublanguage of @xmath303 such that @xmath304 .",
    "we now show that newton s iterates can be effectively represented as a combination of linear grammars and homomorphisms .",
    "a _ substitution _ @xmath305 from alphabet @xmath306 to alphabet @xmath307 is a function which maps every word over @xmath306 to a set of words of @xmath308 such that @xmath309 and @xmath310 .",
    "@xmath311 is a substitution such that for each word @xmath312 , @xmath313 is a singleton .",
    "we define the substitution @xmath314}\\colon \\sigma_1\\cup\\set{a}\\rightarrow \\sigma_1\\cup\\set{b}$ ] which maps @xmath315 to @xmath316 and leaves all other symbols unchanged .",
    "+ we show below that the iterates @xmath317 have a `` nice '' representation .",
    "let us leave for a moment newton s iteration sequence and turn to our initial problem as stated in pb .",
    "[ pb : elembounded ] .",
    "let @xmath0 be a context - free language , our goal is to compute a sublanguage @xmath10 such that @xmath123 ( then we solve pb .  [",
    "pb : elembounded ] on instance @xmath10 instead of @xmath0 because it is equivalent ) .",
    "below we give an effective procedure to compute such a @xmath10 based on the previously defined iteration sequences and the convergence results .",
    "given a grammar @xmath117 , let @xmath224 be the valuation which maps each variable @xmath118 to the language @xmath115 .",
    "we first characterize the valuation @xmath224 as the least fixpoint of a polynomial transformation @xmath184 which is defined using @xmath97 as follows : each @xmath225 of @xmath184 is given by the combination of @xmath226 s for @xmath227 where @xmath226 is now interpreted as a monomial on the semiring @xmath160 .",
    "let @xmath229 be the context - free grammar with the production : @xmath318 it defines the following polynomial transformation on @xmath231 where @xmath319 and @xmath320 .",
    "it is well known that @xmath228 ( see for instance @xcite ) . to evaluate",
    "@xmath213 one can evaluate newton s iteration sequence @xmath321 for @xmath184 .",
    "however , a transfinite number of iterates may be needed before reaching @xmath213 .",
    "we now observe that , by the result of lem .",
    "[ lem : newtonparikh ] , if we consider the iteration sequence @xmath317 up to iterate @xmath294 where @xmath294 equals to the number of variables in @xmath99 then the language given by @xmath300 is such that @xmath301 .",
    "moreover because @xmath321 is an ascending chain we find that : for each variable @xmath322 , @xmath323 is a sublanguage of @xmath324 such that @xmath325 .",
    "we now explain how to turn this theoretical result into an effective procedure .",
    "our first step is to define an effective representation for the iterates @xmath317 .",
    "our definition is based on the one that was informally introduced in example 3.1 , part ( 2 ) of @xcite . to this end , we start by defining how to represent the differential @xmath326 used in the definition of newton s iteration sequence as the language generated by a linear grammar .",
    "we define @xmath163 to be the valuation which maps each variable @xmath118 to @xmath327 where @xmath327 is a new symbol w.r.t .",
    "we first observe that @xmath328 is a polynomial transformation on the set of dual variables @xmath192 such that the linear form associated to @xmath122 is a polynomial of the form : @xmath329 where each @xmath330 and @xmath331 .",
    "moreover , @xmath225 is a sum of monomials @xmath332 .",
    "hence , we define the linear grammar @xmath333 . for the variable @xmath122 ,",
    "the set of productions @xmath334 is : @xmath335 we are able to prove that :    let @xmath163 be the valuation which maps each variable @xmath114 to @xmath327 : @xmath336 [ lem : lingcoincideiterates ]    we show by induction the following equivalence .",
    "let @xmath118 , @xmath337 : @xmath338    * base case .",
    "@xmath339 * in this case , the following equivalence has to be established : @xmath340    * inductive case . @xmath341 * @xmath342    ( contd from the previous example ) the differential of @xmath184 is given by : @xmath343    the grammar @xmath344 is given by @xmath345 where @xmath334 is such that : @xmath346    * @xmath32-fold composition . *",
    "we effectively compute and represent each iterate as the valuation which maps each variable @xmath122 to the language generated by a @xmath32-fold composition of a substitution .",
    "since the substitution maps each symbol onto a language which is linear , it is effectively represented and manipulated as a linear grammar . to formally define the representation we need to introduce the following definitions .",
    "let @xmath347 be a linear grammar and let @xmath6 , define @xmath348 to be the set of symbols @xmath349 . given a language @xmath0 on alphabet @xmath350",
    ", we define @xmath351 $ ] to be @xmath352_{x\\in \\mathcal{x}}}(l)$ ] . for @xmath353 , we define @xmath354 as the substitution which maps each @xmath355 onto @xmath356 $ ] and leaves @xmath33 unchanged . for @xmath357 the substitution @xmath358 maps each @xmath359 on @xmath360 and leaves @xmath33 unchanged .",
    "let @xmath361 be such that @xmath362 we define @xmath363 to be @xmath364 .",
    "hence , @xmath365 is such that : @xmath366 .",
    "finally , the _ @xmath32-fold composition _ of a linear grammar @xmath344 and initial variable @xmath122 is given by @xmath367 .",
    "lemma  [ lem - bnusubst ] relates @xmath32-fold compositions with @xmath368 .",
    "moreover we characterize the complexity of computing @xmath344 given a polynomial transformation @xmath184 the size of which is defined to be the number of bits needed to write the set @xmath369 where each @xmath370 is a string of symbols .    given a polynomial transformation @xmath184 , there is a polynomial time algorithm to compute a linear grammar @xmath344 such that for every @xmath176 , every @xmath118 we have @xmath371 .",
    "[ lem - bnusubst ]    there exists an effectively computable linear grammar @xmath344 such that for every @xmath176 , every @xmath118 we have @xmath371 .",
    "[ lem - bnusubst ]    by induction on @xmath32 .",
    "* base case . @xmath339",
    "* definition of the iteration sequence shows that @xmath372 which in turn equals @xmath373 by definition .    *",
    "inductive case .",
    "@xmath341 * first , let us define @xmath374 to be the substitution which maps @xmath327 onto @xmath375 .",
    "hence we have @xmath376}(\\sigma^{k+1}(v_x^{k+1}))&\\text{def.\\ of $ \\sigma^{k+1}$}\\\\ & = \\sigma_0^k\\comp \\sigma^{k+1}(v_x^{k+1})&\\text{by above}\\\\ & = \\sigma_0^{k+1}(v_x^{k+1})\\end{aligned}\\ ] ]    we refer the reader to our technical report @xcite for the polynomial time construction of @xmath344 given @xmath184 . however , let us give a sample output of the construction .",
    "let @xmath184 be a polynomial transformation on @xmath231 where @xmath319 and @xmath320 .",
    "the construction outputs @xmath377 where @xmath334 is given by : @xmath346 we have that @xmath378 and @xmath379 .",
    "[ lem - bnusubst ] completes our goal to define a procedure to effectively compute and represent the iterates @xmath368 .",
    "this sequence is of interest since , given a cfl @xmath0 and @xmath300 the @xmath294-th iterate ( where @xmath294 equals the number of variables in the grammar of @xmath0 so that @xmath380 ) , if @xmath125 is a solution to pb .",
    "[ pb : elembounded ] for the instance @xmath300 , @xmath125 is also a solution to pb .",
    "[ pb : elembounded ] for @xmath0 .",
    "let us conclude this section on a complexity note .",
    "below we show that the linear grammar @xmath344 given in lem .",
    "[ lem - bnusubst ] is computable in polynomial time in the size of @xmath184 which is to be defined . to start with",
    "we define the size of a monomial which is intuitively the length of the `` string '' that defines the monomial .",
    "formally , let @xmath249 be a monomial its size denoted , @xmath381 , is given by @xmath382 if @xmath249 is the empty monomial ; @xmath383 if @xmath384 or @xmath385 and by @xmath386 if @xmath387 .",
    "the above definition naturally extends to polynomials by summing the sizes of the monomials .",
    "the empty polynomial has size zero .    in what follows",
    "we show that the derivative of a monomial as a polynomial of some form .",
    "let @xmath388 be a monomial where each @xmath389 , let @xmath118 and @xmath251 .",
    "we have @xmath390 coincide with the polynomial given by :    1 .",
    "apply the inductive definition of a derivative on @xmath249 which is given by @xmath391 where @xmath392 if @xmath393 and @xmath394 otherwise . above",
    "we abusively wrote @xmath395 which in fact denotes @xmath395 if @xmath396 and @xmath397 otherwise .",
    "2 .   turn the result into a polynomial , that is a finite combination of monomials , by distributing @xmath398 over @xmath399 ( in the inductive part of point ( 1 ) ) .",
    "[ lem - derivmono ]    in the rest of this section , we identify @xmath390 with the polynomial of lem .",
    "[ lem - derivmono ] .",
    "let @xmath400 , and @xmath401 .",
    "we have @xmath402 and @xmath403 . [ lem - sizemono ]    * @xmath404 . * @xmath405 which concludes the case .    * @xmath406 . *",
    "induction hypothesis shows that @xmath407 where @xmath408 and @xmath409 . hence by lem",
    ".  [ lem - derivmono ] , the distributivity of @xmath398 over @xmath399 , the size of @xmath395 bounded by 1 show that @xmath402 and @xmath410 .    the size of @xmath411 is bounded by @xmath412 ( where @xmath32 is the size of the monomial ) .",
    "[ coro - sizemono ]    let us extend this reasoning to polynomials and polynomial transformations .",
    "let @xmath413 .",
    "the definition of differential shows that @xmath414 where each @xmath415 is a polynomial as shown by lem .",
    "[ lem - derivmono ] .",
    "let @xmath416 , we have that @xmath417 is bounded by @xmath418 .",
    "this result follows from coro .",
    "[ coro - sizemono ] and the fact that @xmath419 .",
    "let us now extend our result to the differential in each variable .",
    "the definition of derivative shows that @xmath420 the definition of which is given above .",
    "let @xmath421 , we find that @xmath422 is bounded by @xmath423 .",
    "finally we extend the result to polynomial transformation using the equality @xmath424 .",
    "let us now characterize the time complexity of the algorithm that computes for @xmath328 .",
    "let @xmath184 and @xmath163 be respectively a polynomial transformation and a valuation over @xmath99 .",
    "define @xmath425 .",
    "the size of @xmath133 is given by the sum of the size of each of its member .",
    "the size of @xmath426 is given by the sum of the length of each @xmath427 .",
    "if @xmath133 is of finite size then @xmath328 is computable in time polynomial in the size of each @xmath370 , @xmath99 and the size of @xmath133 .",
    "remark that we could generalize and drop the finiteness requirement for @xmath133 .",
    "for example , regular languages or context - free languages would be admissible candidates for each element of @xmath133 because they come with a finite representation and decision procedure for the tests / operations we need to compute the differential .",
    "we showed above how to compute @xmath344 from @xmath328 and @xmath184 .",
    "so we conclude that @xmath344 is computable in time polynomial in the size of each @xmath370 , @xmath99 and the size of @xmath133 .",
    "we now show how , given a @xmath32-fold composition @xmath10 , to compute an elementary bounded language @xmath125 such that @xmath428 , that is we give an effective procedure to solve pb .  [ pb : elembounded ] for the instance @xmath10 .",
    "this will complete the solution to pb .",
    "[ pb : elembounded ] , hence the proof of th .",
    "[ theo - main ] . in this section ,",
    "we give an effective construction of elementary bounded languages that solve pb .  [ pb : elembounded ] first for regular languages , then for linear languages , and finally for a linear substitution .",
    "we start with lem .",
    "[ lem : powerl ] the proof of which is given in @xcite but also in @xcite .",
    "first we need to introduce the notion of semilinear sets .",
    "a set @xmath429 is a _ linear set _ if there exist @xmath430 and @xmath431 such that @xmath432 : @xmath433 is called the constant of @xmath27 and @xmath434 the periods of @xmath27 .",
    "semilinear set _",
    "@xmath133 is a finite union of linear sets : @xmath435 where each @xmath436 is a linear set .",
    "parikh s theorem ( cf .",
    "@xcite ) shows that the parikh image of every cfl is a semilinear set that is effectively computable .",
    "let @xmath0 and @xmath125 be respectively a cfl and an elementary bounded language over @xmath33 such that @xmath126 .",
    "there is an effectively computable elementary bounded language @xmath437 such that @xmath438 for all @xmath439 .",
    "[ lem : powerl ]    by parikh s theorem , we know that @xmath440 is a computable semilinear set .",
    "let us consider @xmath441 such that @xmath442 for @xmath443 .",
    "let @xmath444 , we see that @xmath437 is an elementary bounded language .",
    "let @xmath445 be a natural integer .",
    "we have to prove that @xmath446 .",
    "@xmath447 we conclude from the preservation of @xmath74 and the hypothesis @xmath448 that by property of @xmath74 and @xmath448 we find that : @xmath449 @xmath450 let us consider @xmath451 . for every @xmath452 and @xmath453 ,",
    "there exist some positive integers @xmath454 and @xmath455 , with @xmath456 such that @xmath457 we define a new variable for each @xmath452 : @xmath458 . + for each @xmath452 , we also consider @xmath459 a word of @xmath460 such that @xmath461 if @xmath462 and @xmath463 else .",
    "let @xmath464 . clearly , @xmath465 and @xmath466 . for each @xmath443",
    ", @xmath126 shows that there is @xmath467 such that @xmath468 .",
    "let @xmath469 .",
    "we find that @xmath470 , @xmath471 and we can easily verify that @xmath472 .    * regular languages.*the construction of an elementary bounded language that solves pb .",
    "[ pb : elembounded ] for a regular language @xmath0 is known from @xcite ( see also @xcite , lem .",
    "the construction is carried out by induction on the structure of a regular expression for @xmath0 .",
    "assuming @xmath473 , the base case ( a symbol or @xmath474 ) is trivially solved .",
    "note that if @xmath475 then every elementary bounded language @xmath125 is such that @xmath476 .",
    "the inductive case falls naturally into three parts .",
    "let @xmath477 and @xmath478 be regular languages , and @xmath479 and @xmath480 the inductively constructed elementary bounded languages such that @xmath481 and @xmath482 .",
    "concatenation : :    for the instance @xmath483 , the elementary bounded    language @xmath484 is such that    @xmath485 ; union : :    for @xmath486 , the elementary bounded language    @xmath487 suffices ; kleene star : :    let us consider @xmath477 and @xmath479 ,    lem .  [ lem : powerl ] shows how to effectively compute an elementary    bounded language @xmath437 such that for every    @xmath439 , @xmath488 .",
    "let us prove that @xmath437 solves pb .",
    "[ pb : elembounded ] for the    instance @xmath489 .",
    "in fact , if @xmath11 is a word of    @xmath489 , there exists a @xmath439 such that    @xmath490 .",
    "then , we can find a word @xmath491 in    @xmath492 with the same parikh image as    @xmath11 .",
    "this proves that    @xmath493 .",
    "the other    inclusion holds trivially .    for every regular language @xmath494",
    ", there is an effective procedure to compute an elementary bounded language @xmath125 such that @xmath495 .",
    "[ prop : regular ]    * linear languages.*we now extend the previous construction to the case of linear languages . recall that linear languages are used to represent the iterates @xmath368 .",
    "lemma  [ prop : linear ] gives a characterization of linear languages based on regular languages , homomorphism , and some additional structures .",
    "( from @xcite ) for every linear language @xmath0 over @xmath33 , there exist an alphabet @xmath27 and its distinct copy @xmath496 , an homomorphism @xmath497 and a regular language @xmath494 over @xmath27 such that @xmath498 where @xmath499 and @xmath500 denotes the reverse image of the word @xmath11 .",
    "moreover there is an effective procedure to construct @xmath311 , @xmath27 , and @xmath494 .",
    "[ prop : linear ]    assume the linear language @xmath0 is given by linear grammar @xmath117 and a initial variable @xmath501 .",
    "we define the alphabet @xmath27 to be @xmath502 .",
    "we define the regular language @xmath494 as the language accepted by the automaton given by @xmath503 where : @xmath504 .",
    "next we define the homomorphism , @xmath311 which , for each @xmath505 , maps @xmath506 and @xmath507 to @xmath226 and @xmath508 , respectively . by construction and induction on the length of a derivation",
    ", it is easily seen that the result holds .",
    "next , we have a technical lemma which relates homomorphism and the parikh image operator .",
    "let @xmath79 be two languages and a homomorphism @xmath509 , we have : @xmath510 [ lem : homomorph ]    it suffices to show that the result holds for @xmath511 replaced by @xmath161 .",
    "let @xmath512 .",
    "we know that there exists @xmath513 such that @xmath514 .",
    "the equality @xmath515 shows that there exists @xmath516 such that @xmath517 .",
    "it is clear by property of homomorphism that @xmath518 .",
    "the next result shows that an elementary bounded language that solves pb .  [ pb : elembounded ] can be effectively constructed for every linear language @xmath0 that is given by @xmath311 and @xmath494 such that @xmath519 .    for every linear language @xmath498 where @xmath311 and @xmath494 are given",
    ", there is an effective procedure which solves pb .",
    "[ pb : elembounded ] for the instance @xmath0 , that is a procedure returning an elementary bounded @xmath125 such that @xmath126 .",
    "[ prop : linbounded ]    since @xmath494 is a regular language , we can use the result of prop .  [",
    "prop : regular ] to effectively compute the set @xmath520 of words such that for @xmath521 we have @xmath522 .",
    "also , we observe that for every language @xmath523 we have @xmath524 .",
    "@xmath525 which concludes the proof since @xmath526 if @xmath527 .",
    "* linear languages with substitutions.*our goal is to solve pb .  [ pb : elembounded ] for @xmath32-fold compositions , for languages of the form @xmath528 .",
    "[ prop : linbounded ] gives an effective procedure for the case @xmath529 since @xmath530 is a linear language .",
    "[ prop : subst ] generalizes to the case @xmath531 : given a solution to pb .",
    "[ pb : elembounded ] for the instance @xmath532 , there is an effective procedure for pb .",
    "[ pb : elembounded ] for the instance @xmath533 .",
    "let    1 .",
    "@xmath0 be a cfl over @xmath33 ; 2 .",
    "@xmath125 an elementary bounded language such that @xmath126 ; 3 .",
    "@xmath305 and @xmath534 be two substitutions over @xmath33 such that for each @xmath535 , ( i ) @xmath536 and @xmath537 are respectively a cfl and an e.b . and ( ii ) @xmath538 .",
    "then , there is an effective procedure that solves pb .  [ pb : elembounded ] for the instance @xmath539 , by returning an elementary bounded language @xmath437 such that @xmath540 .",
    "[ prop : subst ]    let @xmath541 be the words such that @xmath542 .",
    "let @xmath543 for each @xmath544 . since @xmath536 is a cfl so is @xmath545 by property of the substitutions and the closure of cfls by finite concatenations .",
    "for the same reason , @xmath546 is an elementary bounded language .",
    "next , lem .",
    "[ lem : powerl ] where the elementary bounded language is given by @xmath546 , shows that we can construct an elementary bounded language @xmath547 such that for all @xmath439 , @xmath548 .",
    "define @xmath549 that is an elementary bounded language .",
    "we have to prove the inclusion @xmath550 since the reverse one trivially holds .",
    "so , let @xmath551 . since @xmath552 , there is a word @xmath553 such that @xmath554 .",
    "then we have @xmath555 for each @xmath544 , we have @xmath556 , so we can find @xmath557 such that @xmath558 .",
    "definition of @xmath437 also shows that @xmath471 . moreover @xmath559 finally , @xmath471 and @xmath560 and @xmath558 , which in turn equals @xmath561 , prove the inclusion .",
    "we use the above result inductively to solve pb .",
    "[ pb : elembounded ] for @xmath32-fold composition as follows : fix @xmath0 to be @xmath532 , @xmath125 to be the solution of pb .",
    "[ pb : elembounded ] for the instance @xmath0 , @xmath305 to be @xmath562 and @xmath534 a substitution which maps every @xmath563 to the solution of pb .",
    "[ pb : elembounded ] for the instance @xmath564 .",
    "then @xmath437 is the solution of pb .",
    "[ pb : elembounded ] for the instance @xmath528 .",
    "let us now solve pb .  [",
    "pb : elembounded ] where the instance is given by a @xmath32-fold composition . given a cfl @xmath565 where @xmath117 is a grammar and @xmath566 an initial variable",
    ", we compute the linear grammar @xmath344 and the @xmath32-fold composition @xmath567 as defined in sec .",
    "[ subsec : representation ] . with the result of prop .",
    "[ prop : linbounded ] , we find a valuation @xmath568 such that for every variable @xmath122 , ( 1 ) @xmath569 is an elementary bounded language and ( 2 ) @xmath570 .",
    "the above reasoning is formally explained in alg .",
    "[ alg : boundedsequence ] .",
    "let @xmath571 be @xmath572 $ ] let @xmath573 be the substitution which maps each @xmath359 on the elementary bounded language @xmath574 where @xmath575 and leaves each letter of @xmath33 unchanged    we now prove the following invariants for alg .",
    "[ alg : boundedsequence ] .    in alg .",
    "[ alg : boundedsequence ] , for every @xmath118 ,    * for every @xmath576 , @xmath577 is an elementary bounded language on @xmath578 such that @xmath579 ;",
    "* @xmath580 is an elementary bounded language on @xmath59 such that @xmath581 .    * by induction on @xmath32 : + * base case .",
    "@xmath582 * alg .",
    "[ alg : boundedsequence ] assumes that @xmath569 is an elementary bounded language , so is @xmath571 by line  [ alg : bnmoins1 ] .",
    "it remains to prove that @xmath583 , which is equivalent , by definition of @xmath584 and @xmath571 , to @xmath585\\cap \\tilde{b}[v_\\mathcal{x}^{n-1}](x))=\\pi(l_x(\\tilde{g})[v_\\mathcal{x}^{n-1}])$ ] . by property of the symbol - to - symbol substitution @xmath586}$ ] , the equality reduces to @xmath587 which holds by assumption of alg .",
    "[ alg : boundedsequence ] .",
    "+ * inductive case . @xmath588 * at line  [ alg : biplus1 ] , we see that we can apply the result of prop .",
    "[ prop : subst ] because ( 1 ) @xmath589 is a cfl ( cfls are closed by context - free substitutions ) , ( 2 ) @xmath590 is an elementary bounded language ( induction hypothesis ) , ( 3 ) for every variable @xmath591 , @xmath592 is a cfl , @xmath593 is an elementary bounded language and @xmath594 .",
    "hence , the proposition shows that @xmath595 is an elementary bounded language and @xmath596 . *",
    "the above invariant for @xmath357 shows that , for every variable @xmath118 , ( 1 ) @xmath597 is an elementary bounded language , and ( 2 ) @xmath598 .",
    "we conclude from line  [ alg : bx ] and prop .",
    "[ prop : subst ] that @xmath599 , and that @xmath581 by lem .",
    "[ lem - bnusubst ] .    referring to our initial problem",
    ", we finally find that :    let @xmath125 be the valuation returned by alg .",
    "[ alg : boundedsequence ] , @xmath125 is a valuation in @xmath231 such that for every @xmath600 .",
    "in fact , for @xmath601 , @xmath602 is the solution of pb .  [",
    "pb : elembounded ] for the instance @xmath0 .",
    "this concludes the proof of th .",
    "[ theo - main ] . in what follows ,",
    "we show two applications of th .",
    "[ theo - main ] in software verification .",
    "due to lack of space we refer to reader to @xcite for details .",
    "we thus have an effective construction of an elementary bounded language that solves pb .",
    "[ pb : elembounded ] for @xmath32-fold composition , hence a constructive proof for th .",
    "[ theo - main ]",
    ".    * iterative algorithm .",
    "* we conclude this section by showing a result related to the notion of progress if the result of th .",
    "[ theo - main ] is applied repeatedly .    given a cfl @xmath0 ,",
    "define two sequences @xmath603 , @xmath604 such that ( 1 ) @xmath605 , ( 2 ) @xmath547 is elementary bounded and @xmath606 , ( 3 ) @xmath607 . for every @xmath5",
    ", there exists @xmath608 such that @xmath609 .",
    "moreover , given @xmath610 , there is an effective procedure to compute @xmath611 for every @xmath612 .",
    "[ lem : progress ]    let @xmath5 and let @xmath613 be its parikh image .",
    "we conclude form @xmath614 that there exists a word @xmath615 such that @xmath616 .",
    "two cases arise : either @xmath617 and we are done ; or @xmath618 . in that case",
    "@xmath619 shows that @xmath620 .",
    "intuitively , at least one word with the same parikh image as @xmath11 has been selected by @xmath621 and then removed from @xmath610 by definition of @xmath622 . repeatedly applying the above reasoning shows that at each iteration there exists a word @xmath623 such that @xmath624 , @xmath625 and @xmath626 since @xmath627 . because there are only finitely many words with parikh image @xmath628",
    "we conclude that there exists @xmath629 , such that @xmath630 .",
    "the effectiveness result follows from the following arguments : ( 1 ) as we have shown above ( our solution to pb .",
    "[ pb : elembounded ] ) , given a cfl @xmath0 there is an effective procedure that computes an elementary bounded language @xmath125 such that @xmath631 ; ( 2 ) the complement of @xmath125 is a regular language effectively computable ; and ( 3 ) the intersection of a cfl with a regular language is again a cfl that can be effectively constructed ( see @xcite ) .",
    "intuitively this result shows that given a context - free language @xmath0 , if we repeatedly compute and remove a parikh - equivalent bounded subset of @xmath0 ( @xmath632 is effectively computable since @xmath125 is a regular language ) , then each word @xmath11 of @xmath0 is eventually removed from it .",
    "we now demonstrate two applications of our construction .",
    "the first application gives a semi - algorithm for checking reachability of multithreaded procedural programs @xcite .",
    "the second application computes an underapproximation of the reachable states of a recursive counter machine .",
    "we now give an application of our construction that gives a semi - algorithm for checking reachability of multithreaded procedural programs @xcite .",
    "* multithreaded reachability . *",
    "a common programming model consists of multiple recursive threads communicating via shared memory .",
    "formally , we model such systems as pushdown networks @xcite .",
    "let @xmath294 be a positive integer , a _",
    "pushdown network _ is a triple @xmath633 where @xmath97 is a finite non - empty set of _ globals _ , @xmath634 is the _ stack alphabet _ , and for each @xmath635 , @xmath636 is a finite set of _ transition rules _ of the form @xmath637 for @xmath638 , @xmath639 , @xmath640 .    a _",
    "local configuration _ of @xmath641 is a pair @xmath642 and a _ global configuration _ of @xmath641 is a tuple @xmath643 , where @xmath644 and @xmath645 are individual stack content for each thread . intuitively , the system consists of @xmath294 threads , each of which have its own stack , and the threads can communicate by reading and manipulating the global storage represented by @xmath646 .",
    "we define the local transition relation of the @xmath647-th thread , written @xmath648 , as follows : @xmath649 iff @xmath650 in @xmath636 and @xmath651 .",
    "the transition relation of @xmath641 , denoted @xmath652 , is defined as follows : @xmath653 iff @xmath654 . by @xmath655 , @xmath656 ,",
    "we denote the reflexive and transitive closure of these relations .",
    "moreover , we define the global reachability relation @xmath657 as a reachability relation where all the moves are made by a single thread : @xmath658 iff @xmath659 for some @xmath635 .",
    "the relation @xmath657 holds between global configurations reachable from each other in a single _ context_. furthermore we denote by @xmath660 , where @xmath661 , the reachability relation within @xmath662 contexts : @xmath663 is the identity relation on global configurations , and @xmath664 .",
    "let @xmath665 and @xmath666 be two global configurations , the _ reachability problem _ asks whether @xmath667 holds .",
    "an instance of the reachability problem is denoted by a triple @xmath668 .",
    "a _ pushdown system _ is a pushdown network where @xmath669 , namely @xmath670 .",
    "pushdown acceptor _ is a pushdown system extended with an initial configuration @xmath671 , labeled transition rules of the form @xmath672 for @xmath673 defined as above and @xmath674 .",
    "a pushdown acceptor is given by a tuple @xmath675 .",
    "the language of a pushdown acceptor is defined as expected where the acceptance condition is given by the empty stack .    in what follows",
    ", we reduce the reachability problem for a pushdown network of @xmath294 threads to a language problem for @xmath294 pushdown acceptors .",
    "the pushdown acceptors obtained by reduction from the pushdown network settings have a special global @xmath676 that intuitively models an inactive state .",
    "the reduction also turns the globals into input symbols which label transitions .",
    "the firing of a transition labeled with a global models a context switch .",
    "when such transition fires , every pushdown acceptor synchronizes on the label .",
    "the effect of such a synchronization is that exactly one acceptor will change its state from inactive to active by updating the value of its global ( i.e. from @xmath676 to some @xmath644 ) and exactly one acceptor will change from active to inactive by updating its global from some @xmath646 to @xmath676 .",
    "all the others acceptors will synchronize and stay inactive .",
    "given an instance of the reachability problem , that is a pushdown network @xmath677 with @xmath294 threads , two global configurations @xmath665 and @xmath666 ( assume wlog that @xmath666 is of the form @xmath678 ) , we define a family of pushdown acceptors @xmath679 , where :    * @xmath680 , @xmath634 is given as above , and @xmath681 , * @xmath682 is the smallest set such that : * * @xmath683 in @xmath682 if @xmath650 in @xmath636 ; * * @xmath684 for @xmath685 , @xmath644 , @xmath686 ; * * @xmath687 for @xmath685 , @xmath644 , @xmath686 ; * * @xmath688 for @xmath644 , @xmath686 . *",
    "let @xmath689 , @xmath690 is given by @xmath691 if @xmath692 ; @xmath693 else .",
    "let @xmath294 be a positive integer , and @xmath668 be an instance of the reachability problem with @xmath294 threads , one can effectively construct cfls @xmath694 ( as pushdown acceptors ) such that @xmath695 iff @xmath696 .",
    "[ prop : cflencoding ]    the converse of the proposition is also true , and since the emptiness problem for intersection of cfls is undecidable @xcite , so is the reachability problem .",
    "we will now compare two underapproximation techniques .",
    "the context - bounded switches for the reachability problem @xcite and the bounded languages for the emptiness problem that is given below .",
    "let @xmath697 be context - free languages , and consider the problem to decide if @xmath698 .",
    "we give a decidable sufficient condition : given an elementary bounded language @xmath125 , we define the _ intersection modulo @xmath125 _ of the languages @xmath699 as @xmath700 .",
    "clearly , @xmath701 implies @xmath702 .",
    "below we show that the problem @xmath703 is decidable .",
    "we conclude from @xmath710 that @xmath711 and @xmath712 for every @xmath713 , hence there exist @xmath714 such that @xmath715 by definition of @xmath125 .",
    "then , we find that @xmath716 , hence that @xmath717 for every @xmath713 by above and finally that @xmath718 .",
    "for the other implication , consider @xmath719 a vector of @xmath720 and let @xmath715 .",
    "for every @xmath713 , we will show that @xmath721 . as @xmath722 , there exists a word @xmath723 such that @xmath724 and @xmath725 .",
    "we conclude from @xmath724 , that @xmath726 and finally that , @xmath727 belongs to @xmath728 .    the class of cfls is effectively closed under inverse homomorphism and intersection with a regular language @xcite .",
    "moreover , given a cfl , we can compute its parikh image which is a semilinear set .",
    "finally , we can compute the semilinear sets @xmath729 and the emptiness of the intersection of semilinear sets is decidable @xcite .    while lem .",
    "[ lem : capcfleb ] shows decidability for every elementary bounded language , in practice , we want to select @xmath125 `` as large as possible '' .",
    "we select @xmath125 using th .",
    "[ theo - main ] .",
    "we first compute for each language @xmath611 the elementary bounded language @xmath730 such that @xmath606 .",
    "finally , we choose @xmath731 .    by repeatedly selecting and removing a bounded language @xmath125 from each @xmath611 where @xmath713 we obtain a sequence @xmath732 of languages such that @xmath733 . the result of lem .",
    "[ lem : progress ] shows that for each word @xmath712 , there is some @xmath662 such that @xmath734 , hence that the above sequence is strictly decreasing , that is @xmath735 , and finally that if @xmath736 then the iteration is guaranteed to terminate .        * comparison with context - bounded reachability . * a well - studied under - approximation for multithreaded reachability",
    "is given by context - bounded reachability @xcite .",
    "given a pushdown network , global configurations @xmath665 and @xmath666 , and a number @xmath739 , the _ context - bounded reachability problem _ asks whether @xmath740 holds , i.e. if @xmath666 can be reached from @xmath665 in @xmath32 context switches .",
    "this problem is decidable @xcite .",
    "context - bounded reachability has been successfully used in practice for bug finding .",
    "we show that underapproximations using bounded languages ( lem .",
    "[ lem : capcfleb ] ) subsumes the technique of context - bounded reachability in the following sense .",
    "let @xmath641 be a pushdown network , @xmath741 global configurations of @xmath641 , and @xmath694 cfls over alphabet @xmath33 such that @xmath695 iff @xmath742 . for each @xmath739",
    ", there is an elementary bounded language @xmath743 such that @xmath744 only if @xmath745 . also , @xmath746 only if @xmath747 .",
    "consider all sequences @xmath748 of @xmath32 or fewer switches . by the cfl encoding ( prop .",
    "[ prop : cflencoding ] ) each of these sequences corresponds to a word in @xmath749 . if @xmath750 , then there is a word @xmath751 and @xmath752 . define @xmath743 to be @xmath753 where @xmath754 is an enumeration of all strings in @xmath749 .",
    "we conclude from @xmath752 and the definition of @xmath743 that @xmath755 , hence that @xmath745 since @xmath751 . for the other direction we conclude from @xmath745 that @xmath756 , hence that @xmath695 .    however , underapproximation using bounded languages can be more powerful than context - bounded reachability in the following sense .",
    "there is a family @xmath757 of pushdown network reachability problems such that @xmath758 but @xmath759 for each @xmath32 , but there is a single elementary bounded @xmath125 such that @xmath760 for each @xmath32 , where again @xmath761 are cfls such that @xmath762 iff @xmath763 ( as in prop .",
    "[ prop : cflencoding ] ) .    for clarity",
    ", we describe the family of pushdown networks as a family of two - threaded programs whose code is shown in fig .",
    "[ fig - pushfamily ] .",
    "the programs in the family differs from each other by the value to which @xmath764 is instantiated : @xmath765 .",
    "each program has two threads .",
    "thread one maintains a local counter @xmath766 starting at @xmath767 . before each increment to @xmath766 ,",
    "thread one sets a global @xmath768 .",
    "thread two resets @xmath768 .",
    "the target configuration @xmath769 is given by the exit point of @xmath770 .",
    "we conclude from the program code that hitting the exit point of @xmath770 requires @xmath771 to hold . for every instance",
    ", @xmath769 is reachable , but it requires at least @xmath32 context switches .",
    "thus , there is no fixed context bound that is sufficient to check reachability for every instance in the family .",
    "in contrast , the elementary bounded language given by @xmath772 is sufficient to show reachability of the target for * every * instance in the family .          in verification",
    ", counting is a powerful abstraction mechanism .",
    "often , counting abstractions are used to show decidability of the verification problem .",
    "counting abstractions have been applied on a wide range of applications from parametrized systems specified as concurrent java programs to cache coherence protocols ( see @xcite ) and to programs manipulating complex data structures like lists ( see for instance @xcite ) . in those works , counting not only implies decidability , it also yields precise abstractions of the underlying verification problem .",
    "however , in those works recursion ( or equivalently the call stack ) is not part of the model .",
    "one option is to abstract the stack using additional counters , hence abstracting away the stack discipline . because counting abstractions for the stack yields too much imprecision",
    ", we prefer to use a precise model of the call stack and perform an underapproximating analysis .",
    "this is what is defined below for a model of recursive programs that manipulate counters .    *",
    "counter machine : syntax and semantics .",
    "@xmath294-dimensional counter machine _ @xmath773 consists of the finite non - empty sets @xmath774 and @xmath775 of locations and transitions , respectively ; two mappings @xmath776 and @xmath777 , and a family @xmath778 of semilinear ( or _ presburger definable _ ) sets over @xmath779 .",
    "a _ @xmath69-configuration _ @xmath780 consists of a location @xmath781 and a vector @xmath782 ; we define @xmath783 as the set of @xmath69-configurations . for each transition @xmath784",
    ", its semantics is given by the reachability relation @xmath785 over @xmath783 defined as @xmath786 iff @xmath787 , @xmath788 , and @xmath789 .",
    "the reachability relation is naturally extended to words of @xmath790 by defining @xmath791 and @xmath792 .",
    "also , it extends to languages as expected .",
    "finally , we write @xmath793 for a counter machine @xmath69 with an initial set @xmath794 of configurations .",
    "note that semilinear sets carry over subsets of @xmath783 using a bijection from @xmath774 to @xmath795 .    * computing the reachable configurations . *",
    "let @xmath796 and @xmath794 , we define the set of configurations @xmath797(d)$ ] as @xmath798 . given a @xmath294-dim counter machine @xmath799 , a semilinear set @xmath800 of configurations and a cfl @xmath801 ( encoding execution paths ) , we want to underapproximate @xmath802(d)$ ] : the set of @xmath69-configurations reachable from @xmath800 along words of @xmath0 .",
    "our underapproximation computes the set @xmath803(d)$ ] where @xmath10 is a parikh - equivalent bounded subset @xmath0 such that @xmath804 where @xmath805 .",
    "we will construct , given @xmath806 , @xmath0 and @xmath125 ( we showed above how to effectively compute such a @xmath125 ) , a pair @xmath807 such that the set of @xmath69-configurations reachable from @xmath800 along words of @xmath808 can be constructed from the set of @xmath809-configurations reachable from @xmath810 . without loss of generality , we assume @xmath69 is such that @xmath774 is a singleton .",
    "( one can encode locations using counters . )",
    "let @xmath799 a @xmath811-dim counter machine with @xmath812 and @xmath805 such that @xmath126 .",
    "let @xmath311 be the homomorphism that maps some fresh symbols @xmath707 to the words @xmath708 , respectively .",
    "we compute the language @xmath813 .",
    "let @xmath814 , and note that @xmath133 is a semilinear set . for clarity ,",
    "we first consider a linear set @xmath815 where @xmath816 denotes the constant and @xmath817 the set of periods of @xmath815 and @xmath818 .",
    "let @xmath819 . in the following , for every pair of vectors @xmath820 and @xmath821 ,",
    "we denote by @xmath822 the vector @xmath823 .",
    "the machine @xmath824 is defined in fig .",
    "[ fig : cntauto ] .          between @xmath847 and @xmath848 ,",
    "@xmath824 non - deterministically picks values for all the additional counters which we denote @xmath849 .",
    "when @xmath824 fires @xmath850 , we have for all @xmath851 and @xmath852 : @xmath853 and @xmath854 .",
    "below , for every @xmath851 , we denote by @xmath855 the common value of the counters @xmath856 .",
    "then , @xmath824 simulates the behavior of @xmath69 for the sequence of transitions given by @xmath857 the parikh image of which is @xmath858 .",
    "let us define the set @xmath810 of configurations of @xmath859 as @xmath860 .",
    "a sufficient condition for the set of reachable configurations of @xmath824 starting from @xmath810 to be effectively computable is that for each @xmath845 in @xmath861 ( i.e. the loops in fig .",
    "[ fig : cntauto ] ) , it holds that @xmath862 is computable and presburger definable .",
    "given @xmath845 the problem of deciding if @xmath862 is presburger definable is undecidable @xcite .",
    "however , there exist some subclasses @xmath666 of presburger definable sets such that if @xmath863 then @xmath862 is presburger definable and effectively computable , hence the set of reachable configurations of @xmath807 can be computed by quantifier elimination in presburger arithmetic .",
    "a known subclass is that of guarded command presburger relations .",
    "an @xmath294-dimensional _ guarded command _ is given by the closure under composition of @xmath864 ( increment ) , @xmath865 ( decrement ) and @xmath866 ( @xmath382-test ) for @xmath867 .",
    "hence , we find that the set @xmath871(d')$ ] of reachable configurations of @xmath807 is presburger definable , effectively computable and relates to @xmath803(d)$ ] for the bounded language @xmath10 as follows",
    ".      we can easily compute the intersection of the two semilinear sets @xmath133 and @xmath875 over @xmath876 , because of the way we have carried the notion of semilinear set over @xmath876 .",
    "we take a bijection @xmath877 from @xmath878 to @xmath795 , so a configuration @xmath879 is represented by @xmath880 with @xmath881 . hence , the intersection consists of all the vectors of @xmath133 with the composant of @xmath882 equal to one and the others equal to zero .",
    "[ lem : progress ] shows that by iterating the construction we obtain a semi - algorithm for a context - free language .",
    "p.  cousot .",
    "_ mthodes itratives de construction et dapproximation de points fixes doprateurs monotones sur un treillis , analyse smantique de programmes ( in french)_. thse dtat s sciences mathmatiques , universit scientifique et mdicale de grenoble , march 1978 ."
  ],
  "abstract_text": [
    "<S> we show a new and constructive proof of the following language - theoretic result : for every context - free language @xmath0 , there is a _ bounded _ context - free language @xmath1 which has the same parikh ( commutative ) image as @xmath0 </S>",
    "<S> . bounded languages , introduced by ginsburg and spanier , are subsets of regular languages of the form @xmath2 for some @xmath3 . </S>",
    "<S> in particular bounded subsets of context - free languages have nice structural and decidability properties . </S>",
    "<S> our proof proceeds in two parts . </S>",
    "<S> first , using newton s iterations on the language semiring , we construct a context - free subset @xmath4 of @xmath0 that can be represented as a sequence of substitutions on a linear language and has the same parikh image as @xmath0 . </S>",
    "<S> second , we inductively construct a parikh - equivalent bounded context - free subset of @xmath4 .    as an application of this result in model checking , </S>",
    "<S> we show how to underapproximate the reachable state space of multithreaded procedural programs . the bounded language constructed above </S>",
    "<S> provides a decidable underapproximation for the original problem . </S>",
    "<S> we show two applications of this result in model checking : to underapproximate the reachable state space of multithreaded procedural programs and to underapproximate the reachable state space of recursive counter programs . </S>",
    "<S> the bounded language constructed above provides a decidable underapproximation for the original problems . by iterating the construction </S>",
    "<S> , we get a semi - algorithm for the original problems that constructs a sequence of underapproximations such that no two underapproximations of the sequence can be compared . </S>",
    "<S> this provides a progress guarantee : every word @xmath5 is in some underapproximation of the sequence , and hence , a program bug is guaranteed to be found . in particular , we show that verification with bounded languages generalizes context - bounded reachability for multithreaded programs . </S>"
  ]
}