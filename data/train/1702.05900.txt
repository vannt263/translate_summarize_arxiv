{
  "article_text": [
    "given a set @xmath7 of points in the plane , a euclidean @xmath8-spanner for @xmath7 is an undirected graph @xmath9 , where there is a @xmath8-spanning path in @xmath9 between any two points in @xmath7 . a path between points @xmath10 and",
    "@xmath11 is a @xmath8-spanning path if its length is at most @xmath8 times the euclidean distance between @xmath10 and @xmath11 ( i.e. , @xmath12 ) .",
    "the most known algorithm for computing @xmath8-spanner is probably the _ path - greedy _ spanner .",
    "given a set @xmath7 of @xmath3 points in the plane , the path - greedy spanner algorithm creates a @xmath8-spanner for @xmath7 as follows .",
    "it starts with a graph @xmath9 having a vertex set @xmath7 , an empty edge set @xmath13 and @xmath14 pairs of distinct points sorted in a non - decreasing order of their distances .",
    "then , it adds an edge between @xmath10 and @xmath11 to the set @xmath13 if the length of the shortest path between @xmath10 and @xmath11 in @xmath9 is more than @xmath12 , see algorithm  [ alg : pathgreedy ] for more details .",
    "it has been shown in  @xcite that for every set of points , the path - greedy spanner has @xmath15 edges , a bounded degree and total weight @xmath16 , where @xmath17 is the weight of a minimum spanning tree of @xmath7 .",
    "the main weakness of the path - greedy algorithm is its time complexity  the naive implementation of the path - greedy algorithm runs in near - cubic time . by performing @xmath18 shortest path queries , where each query uses dijkstra s shortest path algorithm",
    ", the time complexity of the entire algorithm reaches @xmath19 , where @xmath3 is the number of points in @xmath7 .",
    "therefore , researchers in this field have been trying to improve the path - greedy algorithm time complexity . for example , the _ approximate - greedy _ algorithm generates a graph with the same theoretical properties as the path - greedy spanner in @xmath6 time  @xcite .",
    "however , in practice there is no correlation between the expected and the unsatisfactory resulting spanner as shown in  @xcite .",
    "moreover , the algorithm is complicated and difficult to implement .",
    "another attempt to build a @xmath8-spanner more efficiently is introduced in  @xcite .",
    "this algorithm uses a matrix to store the length of the shortest path between every two points . for each pair of points",
    ", it first checks the matrix to see if there is a @xmath8-spanning path between these points . in case",
    "the entry in the matrix for this pair indicates that there is no @xmath8-spanning path , it performs a shortest path query and updates the matrix .",
    "the authors in  @xcite have conjectured that the number of performed shortest path queries is linear .",
    "this has been shown to be wrong in  @xcite , as the number of shortest path queries may be quadratic .",
    "in addition , bose et al .",
    "@xcite have shown how to compute the path - greedy spanner in @xmath20 time .",
    "the main idea of their algorithm is to compute a partial shortest path and then extend it when needed .",
    "however , the drawback of this algorithm is that it is complex and difficult to implement . in  @xcite ,",
    "alewijnse et al .",
    "compute the path - greedy spanner using linear space in @xmath21 time by utilizing the path - greedy properties with respect to the well separated pair decomposition ( wspd ) . in  @xcite ,",
    "alewijnse et al .",
    "compute a @xmath8-spanner in @xmath22 expected time by using bucketing for short edges and by using wspd for long edges .",
    "their algorithm is based on the assumption that the path - greedy spanner consists of mostly short edges .    a set @xmath7 of points in the plane and a constant @xmath23 a @xmath8-spanner @xmath24 for @xmath7 sort the @xmath18 pairs of distinct points in non - decreasing order of their distances and",
    "store them in list @xmath25 @xmath26 @xmath27 length of the shortest path in @xmath9 between @xmath10 and @xmath11 @xmath28 @xmath29    additional effort has been put in developing algorithms for computing @xmath8-spanner graphs , such as @xmath30-graph algorithm  @xcite , sink spanner , skip - list spanner  @xcite , and wspd - based spanners  @xcite . however , none of these algorithms produces a @xmath8-spanner as good as the path - greedy spanner in all aspects : size , weight and maximum degree , see  @xcite .    therefore , our goal is to develop a simple and efficient algorithm that achieves both the theoretical and practical properties of the path - greedy spanner . in this paper",
    "we introduce the @xmath0-greedy algorithm that constructs such a spanner for a set of @xmath3 points in the plane in @xmath4 time .",
    "moreover , we show that for a set of @xmath3 points placed independently at random in a unit square the expected running time of the @xmath0-greedy algorithm is @xmath6 .",
    "in this section we describe the @xmath0-greedy algorithm ( section  [ sec : algdes ] ) for a given set @xmath7 of points in the plane , and two real numbers @xmath8 and @xmath0 , such that @xmath31 .",
    "then , in section  [ subsec : sr ] we prove that the resulting graph is indeed a @xmath8-spanner with bounded degree . throughout this section",
    "we assume that @xmath32 ( for example , @xmath33 or @xmath34 ) , except in lemma  [ lemma : equal ] , where we consider the case that @xmath35 .      for each point",
    "@xmath36 we maintain a collection of cones @xmath37 with the property that for each point @xmath38 that lies in @xmath37 there is a @xmath8-spanning path between @xmath10 and @xmath11 in the current graph .",
    "the main idea of the @xmath0-greedy algorithm is to ensure that two cones of a constant angle with apexes at @xmath10 and @xmath11 are added to @xmath37 and to @xmath39 , respectively , each time the algorithm runs a shortest path query between points @xmath10 and @xmath11 .",
    "the algorithm starts with a graph @xmath9 having a vertex set @xmath7 , an empty edge set , and an initially empty collection of cones @xmath37 for each point @xmath36 .",
    "the algorithm considers all pairs of distinct points of @xmath7 in a non - decreasing order of their distances . if @xmath40 or @xmath41 , then there is already a @xmath8-spanning path that connects @xmath10 and @xmath11 in @xmath9 , and there is no need to check this pair",
    ". otherwise , let @xmath42 be the length of the shortest path that connects @xmath10 and @xmath11 in @xmath9 divided by @xmath43 .",
    "let @xmath44 denote the cone with apex at @xmath10 of angle @xmath30 , such that the ray @xmath45 is its bisector .",
    "the decision whether to add the edge @xmath46 to the edge set of @xmath9 is made according to the value of @xmath42 .",
    "if @xmath47 , then we add the edge @xmath48 to @xmath9 , a cone @xmath49 to @xmath37 , and a cone @xmath50 to @xmath39 , where @xmath51 .",
    "if @xmath52 , then we do not add this edge to @xmath9 , however , we add a cone @xmath49 to @xmath37 and a cone @xmath50 to @xmath39 , where @xmath53 .    -greedy algorithm .",
    "( a ) @xmath54 ; ( b ) @xmath55 and @xmath56 ; ( c )  @xmath57 and @xmath47 . , scaledwidth=80.0% ]    in algorithm  [ alg : deltagreedy ] , we give the pseudo - code description of the @xmath0-greedy algorithm . in figure",
    "[ fig : c_p ] , we illustrate a cone collection @xmath37 of a point @xmath10 and how it is modified during the three scenarios of the algorithm .",
    "the figure contains the point @xmath10 , its collection @xmath37 colored in gray , and three points @xmath58 , @xmath59 , and @xmath60 , such that @xmath61 .",
    "point @xmath58 lies in @xmath37 representing the first case , where the algorithm does not change the spanner and proceeds to the next pair without performing a shortest path query .",
    "the algorithm runs a shortest path query between @xmath10 and @xmath59 , since @xmath55 ( for the purpose of illustration assume @xmath62 ) .",
    "figure  [ fig : c_p](b ) describes the second case of the algorithm , where the length of the shortest path between @xmath10 and @xmath59 is at most @xmath63 .",
    "in this case the algorithm adds a cone to @xmath37 without updating the spanner .",
    "figure  [ fig : c_p](c ) describes the third case of the algorithm , where the length of the shortest path between @xmath10 and @xmath60 is more than @xmath64 . in this case",
    "the algorithm adds a cone to @xmath37 and the edge @xmath65 to the spanner .",
    "a set @xmath7 of points in the plane and two real numbers @xmath8 and @xmath0 s.t . @xmath31 a @xmath8-spanner for @xmath7",
    "sort the @xmath18 pairs of distinct points in non - decreasing order of their distances ( breaking ties arbitrarily ) and store them in list @xmath25 @xmath26 / * e is the edge set * / @xmath66 / * @xmath37 is set of cones with apex at @xmath10 * / @xmath67 / * g is the resulting @xmath8-spanner * / [ alg : edgeiteration ] [ alg : shortestpath ] @xmath68 length of the shortest path in @xmath9 between @xmath10 and @xmath11 divided @xmath43 [ stepaddingedges ] @xmath69 @xmath70 @xmath71 / * @xmath72 * / [ alg : addconesp ] @xmath73 cone of angle @xmath74 with apex at @xmath10 and bisector @xmath75 @xmath76 cone of angle @xmath74 with apex at @xmath11 and bisector @xmath77    @xmath78 @xmath79 @xmath29      in this section we analyze several properties of the @xmath0-greedy algorithm , including the spanning ratio and the degree of the resulting graph .    the following lemma is a generalization of lemma  6.4.1 . in  @xcite .",
    "[ lemma : theta ] let @xmath8 and @xmath0 be real numbers , such that @xmath80 .",
    "let @xmath10 , @xmath11 , and @xmath81 be points in the plane , such that    1 .",
    "@xmath82 , 2 .",
    "@xmath83 , 3 .",
    "@xmath84 , where @xmath30 is the angle @xmath85  @xmath86i.e .",
    ", @xmath87 .    then @xmath88 .",
    "let @xmath89 be the orthogonal projection of @xmath81 onto segment @xmath90 . then , @xmath91 , @xmath92 , and @xmath93 .",
    "thus , @xmath94 . by triangle inequality @xmath95",
    "[ lemma : shortest - path ] the number of shortest path queries performed by @xmath0-greedy algorithm for each point is @xmath97 .",
    "clearly , the number of shortest path queries performed for each point is at most @xmath98 .",
    "thus , we may assume that @xmath99 .",
    "consider a point @xmath100 and let @xmath48 and @xmath101 be two pairs of points that @xmath0-greedy algorithm has run shortest path queries for .",
    "assume w.l.o.g .",
    "that the pair @xmath101 has been considered before the pair @xmath48 , i.e. , @xmath102 . let @xmath42 be the length of the path computed by the shortest path query for @xmath101 divide by @xmath103 . if @xmath56 , then the cone added to the collection @xmath37 has an angle of at least @xmath104 .",
    "otherwise , the algorithm adds the edge @xmath101 to @xmath9 and a new cone to the collection of cones @xmath37 , where the angle of this cone is @xmath105 .",
    "thus , after the shortest path query performed for the pair @xmath101 , the collection @xmath37 contains a cone @xmath106 , where @xmath30 is at least @xmath107 .",
    "the @xmath0-greedy algorithm performs a shortest path query for @xmath48 only if @xmath108 and @xmath109 .",
    "thus , the angle @xmath85 is at least @xmath104 , and we have at most @xmath110 shortest path queries for a point .",
    "let us consider the case where @xmath111 and @xmath112 .",
    "the equation @xmath113 implies that @xmath114 .",
    "then , we have @xmath115 thus , we have @xmath116 .    for @xmath117 , where @xmath118 is a fixed integer , the number of shortest path queries performed by @xmath0-greedy algorithm for each point is @xmath119 .    as in lemma",
    "[ lemma : shortest - path ] , let us consider the case where @xmath111 and @xmath112 .",
    "then , we have @xmath120 @xmath121 thus , we have @xmath122 .",
    "the running time of @xmath0-greedy algorithm is @xmath123 .",
    "first , the algorithm sorts the @xmath18 pairs of distinct points in non - decreasing order of their distances , this takes @xmath4 time . a shortest path query",
    "is done by dijkstra s shortest path algorithm on a graph with @xmath124 edges and takes @xmath125 time . by lemma  [ lemma : shortest - path ]",
    "each point performs @xmath97 shortest path queries .",
    "therefore , we have that the running time of @xmath0-greedy algorithm is @xmath126 .",
    "[ lemma : cone ] the number of cones that each point has in its collection along the algorithm is constant depending on @xmath8 and @xmath0 ( @xmath97 ) .",
    "as shown in lemma  [ lemma : shortest - path ] , the number of shortest path queries for each point is @xmath97 .",
    "the subsequent step of a shortest path query is the addition of two cones , meaning that for each point @xmath10 the number of cones in the collection of cones @xmath37 is @xmath97 .",
    "the additional space for each point @xmath10 for the collection @xmath37 is constant .",
    "[ lemma : spanner ] the output graph @xmath29 of @xmath0-greedy algorithm ( algorithm  [ alg : deltagreedy ] ) is a @xmath8-spanner for @xmath7 ( for @xmath127 ) .",
    "let @xmath29 be the output graph of the @xmath0-greedy algorithm . to prove that @xmath9 is a @xmath8-spanner for @xmath7 we show that for every pair @xmath128 , there exists a @xmath8-spanning path between them in @xmath9 .",
    "we prove the above statement by induction on the rank of the distance @xmath43 , i.e. , the place of @xmath48 in a non - decreasing distances order of all pairs of points in @xmath7 .",
    "* base case : * let @xmath129 be the first pair in the ordered list ( i.e. , the closest pair ) .",
    "the edge @xmath48 is added to @xmath13 during the first iteration of the loop in step  [ stepaddingedges ] of algorithm  [ alg : deltagreedy ] , and thus there is a @xmath8-spanning path between @xmath10 and @xmath11 in @xmath9 .",
    "* induction hypothesis : * for every pair @xmath130 that appears before the pair @xmath48 in the ordered list , there is a @xmath8-spanning path between @xmath81 and @xmath131 in @xmath9 .    *",
    "the inductive step : * consider the pair @xmath48 .",
    "we prove that there is a @xmath8-spanning path between @xmath10 and @xmath11 in @xmath9 .",
    "if @xmath108 and @xmath109 , we check whether there is a @xmath0-spanning path in @xmath9 between @xmath10 and @xmath11 .",
    "if there is a path which length is at most @xmath132 , then @xmath133 , meaning there is a @xmath8-spanning path between @xmath10 and @xmath11 in @xmath9 . if there is no path of length of at most @xmath134 , we add the edge @xmath135 to @xmath9 , which forms a @xmath8-spanning path .",
    "consider that @xmath40 or @xmath41 , and assume w.l.o.g .",
    "that @xmath41 .",
    "let @xmath101 be the edge handled in step  [ alg : edgeiteration ] in algorithm  [ alg : deltagreedy ] when the cone containing @xmath11 has been added to @xmath37 ( step  [ alg : addconesp ] in algorithm  [ alg : deltagreedy ] ) . notice that @xmath136 .",
    "step  [ alg : shortestpath ] of algorithm  [ alg : deltagreedy ] has computed the value @xmath42 for the pair @xmath101 . in the algorithm",
    "there are two scenarios depending on the value of @xmath42 .",
    "the first scenario is when @xmath47 , then the algorithm has added the edge @xmath101 to @xmath9 and a cone @xmath137 to @xmath37 , where @xmath138 .",
    "thus , the angle between @xmath48 and @xmath139 is less than @xmath140 .",
    "hence , @xmath141 and by the induction hypothesis there is a @xmath8-spanning path between @xmath81 and @xmath11 . consider the shortest path between @xmath10 and @xmath11 that goes through the edge @xmath101 . the length of this path is at most @xmath142 . by lemma  [ lemma : theta ]",
    ", we have @xmath143 for @xmath144 . therefore , we have a @xmath8-spanning path between @xmath10 and @xmath11 .",
    "the second scenario is when @xmath56 , then the algorithm has added a cone @xmath137 to @xmath37 , where @xmath145 .",
    "thus , the angle between @xmath48 and @xmath139 is less than @xmath146 .",
    "hence , @xmath141 and by the induction hypothesis there is a @xmath8-spanning path between @xmath81 and @xmath11 .",
    "consider the shortest path between @xmath10 and @xmath11 that goes through @xmath81 .",
    "the length of this path is at most @xmath147 . by lemma",
    "[ lemma : theta ] , we have @xmath148 .",
    "therefore , we have a t - spanning path between @xmath10 and @xmath11 .",
    "the @xmath0-greedy algorithm computes a @xmath8-spanner for a set of points @xmath7 with the same properties as the path - greedy @xmath8-spanner , such as degree and weight , in @xmath126 time .    clearly , the degree of the @xmath0-greedy is at most the degree of the path - greedy @xmath0-spanner .",
    "the edges of the @xmath0-greedy spanner satisfy the @xmath0-leap frog property , thus , the weight of the @xmath0-greedy is as path - greedy @xmath8-spanner .",
    "hence , we can pick @xmath0 close to @xmath8 , such that we will have the required bounds .",
    "[ lemma : equal ] if @xmath149 , the result of the @xmath0-greedy algorithm is identical to the result of the path - greedy algorithm .",
    "assume towards contradiction that for @xmath149 the resulting graph of the @xmath0-greedy algorithm , denoted as @xmath29 , differs from the result of the path - greedy algorithm , denoted as @xmath150 . assuming the same order of the sorted edges ,",
    "let @xmath48 be the first edge that is different in @xmath9 and @xmath151 .",
    "notice that @xmath0-greedy algorithm decides to add the edge @xmath48 to @xmath9 when there is no @xmath8-spanning path between @xmath10 and @xmath11 in @xmath9 .",
    "since until handling the edge @xmath48 the graphs @xmath9 and @xmath151 are identical , the path - greedy algorithm also decides to add the edge @xmath48 to @xmath151 .",
    "therefore , the only case we need to consider is @xmath152 and @xmath153 .",
    "the @xmath0-greedy algorithm does not add an edge @xmath48 to @xmath9 in two scenarios :    * there is a @xmath8-spanning path between @xmath10 and @xmath11 in the current graph @xmath9     which contradicts that the path - greedy algorithm adds the edge @xmath48 to @xmath151 ; * @xmath40 or @xmath41     the @xmath0-greedy algorithm does not perform a shortest path query between @xmath10 and @xmath11 .",
    "assume w.l.o.g . , @xmath41 , and let @xmath101 be the edge considered in step  [ alg : edgeiteration ] in algorithm  [ alg : deltagreedy ] when the cone containing @xmath11 has been added to @xmath37 .",
    "the angle of the added cone is @xmath154 , where @xmath42 is the length of the shortest path between @xmath10 and @xmath81 divided @xmath103 .",
    "thus , we have @xmath83 and @xmath155 , where @xmath156 is the angle @xmath157 . then , by lemma  [ lemma : theta ] , @xmath88 , and since there is a path from @xmath10 to @xmath81 of length at most @xmath158 , we have that there is @xmath8-spanning path between @xmath10 and @xmath11 in the current graph .",
    "this is in contradiction to the assumption that the path - greedy algorithm adds the edge @xmath48 to @xmath159 .",
    "in this section we show how a small modification in the implementation improves the running time of the @xmath0-greedy algorithm . this improvement yields an expected @xmath6 time for random point sets .",
    "the first modification is to run the shortest path query between points @xmath10 to @xmath11 up to @xmath132 .",
    "that is , running dijkstra s shortest path algorithm with source @xmath10 and terminating as soon as the minimum key in the priority queue is larger than @xmath132 .",
    "let @xmath7 be a set of @xmath3 points in the plane uniformly distributed in a unit square . to prove that @xmath0-greedy algorithm computes a spanner for @xmath7 in expected @xmath6 time , we need to show that :    * each point runs a constant number of shortest path queries    follows from lemma  [ lemma : shortest - path ] ; * the expected number of points visited in each query is constant   the fact that the points are randomly chosen uniformly in the unit square implies that the expected number of points at distance of at most @xmath81 from point @xmath10 is @xmath160 .",
    "a shortest path query from a point @xmath10 to a point @xmath11 terminates as soon as the minimum key in the priority queue exceeds @xmath132 , thus , it is expected to visit @xmath161 points .",
    "+ by lemma  [ lemma : shortest - path ] the number of shortest path queries performed by the algorithm for a point @xmath10 is @xmath97 .",
    "each such query defines a cone with apex at @xmath10 of angle @xmath162 , such that no other shortest path query from @xmath10 will be performed to a point in this cone . by picking @xmath163 and @xmath164 , we have that the expected number of points around each point in a distance of @xmath81 is @xmath165 .",
    "+ assume we partition the plane into @xmath166 equal angle cones with apex at point @xmath10 .",
    "the probability that there exists a cone that does not contain a point from the set of points of distance @xmath167 is at most @xmath168 .",
    "let @xmath169 be the set of points that @xmath10 computed a shortest path query to , and let @xmath170 be the farthest point in @xmath169 from @xmath10 .",
    "then , the expected euclidean distance between @xmath10 and @xmath11 is less than @xmath167 . thus , the expected number of points visited by the entire set of shortest path queries from a point is @xmath171 ; * the next pair to be processed can be obtained in expected @xmath172 time without sorting all pairs of distinct points    even - though this is quite straight forward , for completeness we give a short description how this can be done .",
    "divide the unit square to @xmath173 grid cells of side length @xmath174 .",
    "a hash table of size @xmath175 is initialized , and for each non - empty grid cell ( at most @xmath3 such cells ) we map the points in it to the hash table .",
    "in addition , we maintain a minimum heap @xmath176 for each point @xmath36 ( initially empty ) , and one main minimum heap @xmath177 that contains the top element of each @xmath176 .",
    "each heap @xmath176 contains a subset of the pairs that include @xmath10 . for each point @xmath36 ,",
    "all the cells of distance at most @xmath167 from @xmath10 are scanned ( using the hash table ) to find all the points in these cells , where @xmath166 is a parameter that we fix later .",
    "all the points found in these cells are added to @xmath176 according to their euclidean distance from @xmath10 .",
    "+ the heap @xmath177 holds the relevant pairs in an increasing order , therefore the pairs are extracted from the main heap @xmath177 . after extracting the minimum pair in @xmath177 that belongs to a point @xmath10",
    ", we add to @xmath177 the next minimum in @xmath176 . to insure the correctness of the heaps , when needed we increase the distance to the scanned cells .",
    "observe that there may be a pair @xmath48 such that @xmath178 , where the pair @xmath179 is the top pair in @xmath177 .",
    "this can occur only when the pair @xmath48 has not been added to @xmath176 nor @xmath180 , and this happens when @xmath40 or @xmath41 . however , in this case we do not need to consider the pair @xmath48 .",
    "+ notice that the only cells that are not contained in @xmath37 are scanned to add more pairs to @xmath176 .",
    "thus , points that are in @xmath37 are ignored .    therefore , the total expected running time of the algorithm is @xmath181 . since both @xmath8 and @xmath182",
    "are constants bigger than one , the expected running time of the @xmath0-greedy algorithm is @xmath183 .",
    "a very nice outcome of @xmath0-greedy algorithm and its analysis can be seen when @xmath0 is equal to @xmath8 .",
    "assume that @xmath0-greedy algorithm ( for @xmath5 ) has computed a shortest path query for two points @xmath10 and @xmath11 and the length of the received path is @xmath184 . if the probability that @xmath185 is low ( e.g , less than 1/2 ) , for some constant @xmath186 , then @xmath0-greedy algorithm computes the path - greedy spanner with linear number of shortest path queries .",
    "thus @xmath0-greedy algorithm computes the path - greedy spanner for a point set uniformly distributed in a square in expected @xmath6 time .",
    "not surprisingly our experiments have shown that this probability is indeed low ( less than 1/100 ) , since most of the shortest path queries are performed on pairs of points placed close to each other ( with respect to euclidean distance ) , and thus with a high probability their shortest path contains a constant number of points . moreover",
    ", it seems that for a  real - life \" input this probably is low .",
    "thus , there is a very simple algorithm to compute the path - greedy spanner in expected @xmath4 time for real - life inputs , based on the @xmath0-greedy algorithm    for real - life input we mean that our analysis suggests that in the current computers precision ( memory ) one can not create an instance of points set with more than 1000 points , where the path - greedy spanner based on the @xmath0-greedy algorithm has more than @xmath4 constructing time .",
    "in this section we discuss the experimental results by considering the properties of the graphs generated by different algorithms and the number of shortest path queries performed during these algorithms .",
    "we have implemented the path - greedy , @xmath0-greedy , gap - greedy , @xmath30-graph , path - greedy on @xmath30-graph algorithms .",
    "the path - greedy on @xmath30-graph @xmath8-spanner , first computes a @xmath30-graph @xmath187-spanner , where @xmath188 , and then runs the path - greedy @xmath189-spanner on this @xmath187-spanner .",
    "the shortest path queries criteria is used for an absolute running time comparison that is independent of the actual implementation .",
    "the known theoretical bounds for the algorithms can be found in table  [ table : bounds ] .",
    ".theoretical bounds of different @xmath8-spanner algorithms [ cols=\"<,<,<,<,<,<,<\",options=\"header \" , ]      all the algorithms mentioned above were implemented in java using jgrapht and jgraph libraries .",
    "the experiments were performed on an intel  xeon cpu e5 - 2680 v2 @xmath190 2.80 ghz ( 2 processors ) and 128 gb ram on windows server 2012 standard os using ecj for compilation .",
    "the sample point sets were generated by java.util.random pseudo random number generator .",
    "the experiments indicate that the @xmath0-greedy algorithm achieves good results in practice as expected .",
    "the outcome of the @xmath0-greedy algorithm for all values of @xmath0 , that have been checked , is roughly the same as the results of the path - greedy algorithm for all parameters .",
    "compared to other algorithms , the @xmath0-greedy graphs are superior to the graphs produced by the @xmath191-gap algorithm , and are as good as path - greedy on @xmath30-graph , with significantly a lower number of shortest path queries .",
    "the theoretical complexity of the path - greedy on @xmath30-graph is @xmath4 , same as the @xmath0-greedy algorithm .",
    "however in practice the @xmath0-greedy algorithm computes considerably less shortest path queries .",
    "hence , the @xmath0-greedy algorithm has the same results in weight , size and degree as the path - greedy on @xmath30-graph algorithm with better running time .",
    "in addition , farshi and gudmundsson in  @xcite have implemented various spanner algorithms and shown that the path - greedy algorithm for @xmath192 and for @xmath193 on random graphs are almost identical to ours experimental results in weight , size and degree .",
    "moreover , they have shown that path - greedy spanner is the highest quality geometric spanner in terms of edge count , degree and weight .",
    "they have presented the results for @xmath192 and for @xmath193 on random point set with 8000 points .",
    "moreover , they have shown that the @xmath30-graph spanner achieves in practice the best results after the path - greedy spanner for all parameters that have been tested ( size , weight and degree ) comparing to other spanners that they have implemented ( such as the approximate - greedy , the wspd - spanner , skip - list and sink - spanner ) .",
    "our experiments show that the @xmath0-greedy spanner achieves better results than the @xmath30-graph spanner .",
    "thus , combining this with the results in  @xcite , we conclude that the @xmath0-spanner achieves the highest quality geometric spanner with respect to @xmath30-graph , approximate - greedy , the wspd - spanner , skip - list , sink - spanner , and gap - greedy spanners .",
    "the experiments reinforce the analysis that picking @xmath0 very close to @xmath8 ( for example @xmath194 ) , the results are very close to the path - greedy spanner , and the number of the performed shortest paths queries is still small . moreover , the experiments show that the number of shortest path queries is linear while selecting @xmath195 and obtaining the @xmath0-greedy spanner identical to the path - greedy @xmath8-spanner .",
    "the experiments presented in this paper were performed on set of points placed independently at random in a unit square .",
    "however , we conjecture that the @xmath0-greedy algorithm computes a @xmath8-spanner in expected @xmath196 time for almost all realistic inputs , that is , the @xmath0-greedy algorithm computes a @xmath8-spanner in expected @xmath196 time for point sets that are not deliberately hand - made to cause a higher number of shortest path queries .",
    "we would like to thank rachel saban for implementing the algorithms ."
  ],
  "abstract_text": [
    "<S> we introduce a new geometric spanner , @xmath0-_greedy _ , whose construction is based on a generalization of the known _ path - greedy _ and _ gap - greedy _ spanners . </S>",
    "<S> the @xmath0-greedy spanner combines the most desirable properties of geometric spanners both in theory and in practice . </S>",
    "<S> more specifically , it has the same theoretical and practical properties as the path - greedy spanner : a natural definition , small degree , linear number of edges , low weight , and strong @xmath1-spanner for every @xmath2 . </S>",
    "<S> the @xmath0-greedy algorithm is an improvement over the path - greedy algorithm with respect to the number of shortest path queries and hence with respect to its construction time . </S>",
    "<S> we show how to construct such a spanner for a set of @xmath3 points in the plane in @xmath4 time .    </S>",
    "<S> the @xmath0-greedy spanner has an additional parameter , @xmath0 , which indicates how close it is to the path - greedy spanner on the account of the number of shortest path queries . </S>",
    "<S> for @xmath5 the output spanner is identical to the path - greedy spanner , while the number of shortest path queries is , in practice , linear .    </S>",
    "<S> finally , we show that for a set of @xmath3 points placed independently at random in a unit square the expected construction time of the @xmath0-greedy algorithm is @xmath6 . </S>",
    "<S> our analysis indicates that the @xmath0-greedy spanner gives the best results among the known spanners of expected @xmath6 time for random point sets . </S>",
    "<S> moreover , the analysis implies that by setting @xmath5 , the @xmath0-greedy algorithm provides a spanner identical to the path - greedy spanner in expected @xmath6 time . </S>"
  ]
}