{
  "article_text": [
    "stochastic partition processes on a product space have found many real - world applications , such as relational modeling  @xcite , community detection  @xcite , collaborative filtering  @xcite , and random forests  @xcite . by tailoring the product space into rectangular regions ,",
    "the partition model aims to fit data using these `` blocks '' such that the data within each block exhibit certain types of homogeneity .",
    "as one can choose an arbitrarily fine resolution of partition , the data can be fitted reasonably well .",
    "the cost of data fitness is that the partition model may cause unnecessary dissections in sparse regions .",
    "compared to regular - grid partitions , the mondrian process ( mp )  @xcite is a hierarchical partition process which has been more parsimonious for data fitting .",
    "however , the strategy of recursively cutting the space still can not avoid unnecessary dissections in sparse regions .",
    "take community detection for example , where a `` block '' corresponds to a community : when tailoring a block out of the relational matrix , cutting - based models will unavoidably separate some uninvolved users . as a result ,",
    "some meaningless communities are generated as an undesired by - product ( see figure  [ fig : motivation ] for an illustration ) .    instead of `` cutting '' , we propose a bounding - based partition process , named stochastic patching process ( spp ) , to alleviate the above limitation .",
    "spp attaches patches on a multi - dimensional array to enclose dense regions . in this way",
    ", `` significant '' regions of the space can be comprehensively modeled .",
    "each patch can be generated by an outer product of multiple binary vectors , with a segment of consecutive `` 1 '' entries to indicate the initial and terminal positions of the patch .",
    "as patches are independently generated , the layout of patches can be quite flexible .",
    "this improves its expressiveness to describe those regions with complicated patterns . as a result , spp is able to use fewer blocks ( thus a more parsimonious expression of model ) than those cutting - based partition models to achieve similar modeling capability .",
    "an important property of spp is self - consistency .",
    "this means that , by restricting the patches generated from an spp on a multi - dimensional array @xmath0 to its sub - array @xmath1 , the resulting patches are distributed as if they are directly generated on @xmath1 through another spp ( given the same budget ) .",
    "the property will be verified in three steps : ( 1 ) the number distribution of nonempty patches is self - consistent ; ( 2 ) the position distribution of a nonempty patch is self - consistent ; ( 3 ) based on the above , the self - consistency of spp can be verified .",
    "this property suggests that spp can be extended to infinite multi - dimensional arrays according to the kolmogorov extension theorem  @xcite .",
    "the merit of spp can be seen in many applications . in this paper",
    "we investigate its merit in relational modeling , where patches can be viewed as communities while the `` price '' of a patch ( cost per unit area ) can be viewed as interacting intensity within the community .",
    "an mcmc based approximate inference method is proposed for the spp relational model .",
    "in particular , conditional - sequential monte carlo  @xcite is adopted to sample completely new patches in each iteration .",
    "the experimental results on a number of real - world relational data sets demonstrate that spp can achieve parsimonious partitions with competitive performance compared to the state - of - the - arts .",
    "stochastic partition processes partition a product space into blocks .",
    "a popular application of such processes is modeling relational data such that the intensity of interactions is homogeneous within each block . in terms of partitioning strategy ,",
    "state - of - the - art stochastic partition processes can be roughly categorized into regular - grid partitions and flexible axis - aligned partitions .",
    "a regular - grid stochastic partition process is constituted by two separate partition processes on each dimension of the multi - dimensional array .",
    "the resulting orthogonal interactions between two dimensions will exhibit regular grids , which can represent interacting intensities .",
    "typical regular - grid partition models include the infinite relational model ( irm )  @xcite and the infinite extension of mixed - membership stochastic blockmodels  @xcite .",
    "regular - grid partition models are widely used in real - world applications for modeling graph data  @xcite .    to our knowledge , only the mondrian process ( mp )  @xcite and the rectangular tiling process ( rtp )",
    "@xcite can produce flexible axis - aligned partitions on a product space .",
    "mp recursively generates axis - aligned cuts on a unit hypercube and partitions the space in a hierarchical fashion known as @xmath2d - tree ( @xcite also considers a tree - consistent partition model but it is not bayesian nonparametric ) .",
    "different from the hierarchical partitioning strategy , rtp generates a flat partition structure on a two - dimensional array by assigning each entry to an existing block or a new block in sequence , without violating the rectangular restriction on the blocks .",
    "we consider a projective system of stochastic partitions : let @xmath3 be a family of measurable spaces , where @xmath4 is the partition space , @xmath5 is a @xmath6-algebra on @xmath4 , and @xmath7 denotes the collection of all finite sub - arrays of the infinite @xmath8-dimensional array @xmath9 . for each @xmath10 , @xmath11 is a probability measure on @xmath5 .",
    "@xmath7 is a partially ordered set ; while @xmath12 the projection @xmath13 restricts the partition @xmath14 on @xmath0 into @xmath1 , by keeping @xmath14 s entries within @xmath1 unchanged and removing the remaining entries . for @xmath15 , the pre - image under projection",
    "is defined as @xmath16 and the projection also satisfies @xmath17 .",
    "this family defines the projective limit measurable space @xmath18 .    for a set of probability spaces @xmath19 such that projection @xmath20 and @xmath21 holds for all @xmath15 .",
    "then @xmath11 can be uniquely extended to measure @xmath22 on @xmath23 as the projective limit measurable space .",
    "the kolmogorov extension theorem provides us a constructive way to extend spp to the infinite @xmath8-dimensional array @xmath9 , which will be discussed in section  [ sec : sc ] .",
    "the aldous  hoover theorem  @xcite provides the theoretical foundation to model exchangeable multi - dimensional arrays conditioned on a stochastic partition model .",
    "a random 2-dimensional array is called separately exchangeable if its distribution is invariant under separate permutations of rows and columns .",
    "[ theoremgraphon ] a random array @xmath24 is separately exchangeable if and only if it can be represented as follows : there exists a random measurable function @xmath25 ^ 3 \\mapsto \\mathcal{x}$ ] such that @xmath26 , where @xmath27 and @xmath28 are , respectively , two sequences and an array of i.i.d .",
    "uniform random variables in @xmath29 $ ] .",
    "relational modeling based on a stochastic partition model is a typical application of the aldous  hoover theorem . by defining @xmath30 , every exchangeable array",
    "can be represented by a random graph function  @xcite . the spp relational model introduced in section  [ sec : rm ] is implicitly built on this theorem .",
    "spp is defined on a measurable space @xmath31 .",
    "each element in @xmath4 denotes a partition @xmath32 , constituted by a collection of rectangular _ nonempty _ patches @xmath33 with corresponding costs @xmath34 , where @xmath35 indexes the patch number in @xmath32 .",
    "in particular , a patch is defined by an outer product @xmath36 , where @xmath37 ( @xmath38 denotes the length of the @xmath39th dimension in @xmath1 ) is a position indicator vector for the @xmath39th dimension of @xmath40 , with the constraint that @xmath41 only comprises a segment of @xmath42 consecutive `` 1 '' entries which starts at an initial position @xmath43 .",
    "given an array @xmath1 and a budget @xmath44 , we can sample a random partition from an spp : @xmath45 .",
    "we assume that the costs of patches are _ i.i.d . _",
    "sampled from the same exponential distribution , which implies there exists a homogeneous poisson process on the time ( cost ) line .",
    "the generating time of each patch is uniform in @xmath46 $ ] and the number of patches has a poisson distribution .",
    "we represent a random partition as @xmath47 , which is generated as follows :    1 .",
    "sample the number of candidate patches @xmath48 , where @xmath49 ; 2 .   sample @xmath50 _ i.i.d .",
    "_ candidate patches . for @xmath51 ,",
    "@xmath52 1 .",
    "sample the initial position @xmath53 of the @xmath54th candidate uniformly from @xmath55 ; 2 .",
    "if @xmath56 , the side - length @xmath57 increments from 0 to 1 with probability @xmath58 ; otherwise @xmath57 increments from 0 to 1 with probability @xmath59 , where @xmath60 $ ] ; 3 .",
    "if @xmath57 has incremented from 0 to 1 , generate the side - length using the distribution @xmath61 where @xmath62 ; 3 .   remove all empty patches and retain @xmath63 _ nonempty _ patches @xmath64 .",
    "sample @xmath65 _ i.i.d .",
    "_ time points uniformly in @xmath46 $ ] and index them to satisfy @xmath66 .",
    "set the cost of @xmath40 as @xmath67 ( @xmath68 ) and the rate we will show that such rate is useful when we use @xmath40 and @xmath69 as the priors of a community and the intensity of interactions within the community ( large communities have relatively weak interactions ) . ] of @xmath40 as @xmath70 .",
    "we use the initial position @xmath71 and the side - length @xmath72 of @xmath40 in the @xmath39th dimension to determine the position indicator vector @xmath37 , which further constitutes @xmath40 .",
    "thus , given @xmath63 , all patches are _ i.i.d . _ generated and the layout of patches can be quite flexible .",
    "patches can be overlapped or even contained by others . in the two - dimensional case",
    ", a partition sampled from an spp has the following interpretation : @xmath1 can be viewed as a piece of cloth while @xmath40 can be viewed as a patch ; the material of @xmath40 has rate ( price ) @xmath69 and the number of `` patches '' on the `` cloth '' is determined by @xmath73 and the budget @xmath44  this is where the name of `` stochastic patching process '' comes from .",
    "spp has some favorable properties for being used to manipulate the prior partition via the hyper - parameters .",
    "given array @xmath1 , one can use the budget @xmath44 to control the expected `` volume '' covered by the patches on @xmath1 ( overlapped parts are counted separately ) . given array @xmath1 and budget @xmath44 ,",
    "the expected volume is a fixed constant , @xmath74 , and the expected number of patches @xmath75 and the expected volume of each patch @xmath76 can be balanced through @xmath77 .",
    "formally , we have the following property ( see appendix for the proof ) .",
    "let @xmath78 , the expected volume of all patches is a constant in terms of the budget @xmath44 and the volume of the array @xmath1 , that is , @xmath79 .",
    "figure  [ fig : thetainfluence ] gives an illustration of the above property based on a toy two - dimensional array , with fixed value of @xmath44 but two different values of @xmath77 .",
    "we can see that , in both cases , the volumes ( black areas ) covered by the patches are similar while the number of nonempty patches varies inversely to the average side - length of patch  a larger ( smaller ) value of @xmath77 results in a longer ( shorter ) expected side - length and a smaller ( larger ) number of nonempty patches .    due to such a flexible layout of patches , spp is parsimonious to model multi - dimensional arrays , especially in sparse scenarios  spp is able to describe `` significant '' parts of the array ( e.g. active communities in a social network ) through small patches ; after patching these `` significant '' parts , the rest are usually large and irregular sparse areas which may be neglected .",
    "section  [ sec : spp ] has defined spp on a finite array given a budget . to further extend spp to the infinite array",
    "@xmath9 , an essential property of spp is self - consistency .",
    "that is to say , while restricting an spp on a finite @xmath8-dimensional array @xmath0 , say @xmath80 , to its sub - array @xmath1 , @xmath81 , the resulting patches restricted to @xmath1 are distributed as if they are directly generated on @xmath1 through @xmath82 .",
    "a typical application scenario is social network , where @xmath1 and @xmath0 successively represent two snapshots of a growing network .",
    "the self - consistency property is verified in three steps : ( 1 ) the number distribution of nonempty patches is self - consistent ; ( 2 ) the position distribution of a nonempty patch is self - consistent ; ( 3 ) spp is self - consistent . following the notations used in sections  [ sub : kolmogorov ] and  [ sec : spp ] , we use @xmath13 to denote the projection that restricts @xmath83 to @xmath1 by keeping @xmath14 s entries in @xmath1 unchanged and removing the rest .",
    "an `` empty patch '' is referred to the case @xmath84 ( @xmath85 ) , where @xmath86 denotes the volume of the candidate patch .",
    "[ expectednumber ] while restricting @xmath80 to @xmath1 , @xmath81 , the time points of nonempty patches crossing into @xmath1 from @xmath0 follows the same poisson process for generating the time points of nonempty patches in @xmath82 .",
    "according to the definition , the candidate patches sampled from @xmath80 ( or @xmath82 ) follows a homogeneous poisson process with intensity @xmath87 ( or @xmath73 ) . since there exists possibility to generate empty patches , we use intensity @xmath88 for thinning the poisson process to generate nonempty patches .",
    "given the same budget @xmath44 , proposition  [ expectednumber ] holds if we can prove the following equality of the two poisson process intensities @xmath89    due to the independence of dimensions , we have @xmath90 .",
    "w.l.o.g , we assume that the two arrays , @xmath1 and @xmath0 , have the same shape apart from the @xmath91th dimension where @xmath0 has one additional column ( the general case of more columns follows by induction )",
    ". then we can discuss two cases : @xmath1 and @xmath0 1 ) share the terminal boundary or 2 ) share the initial boundary in the @xmath91th dimension .",
    "( [ eq : poissonrateequality ] ) can be proved in both cases ( see appendix for the complete proof ) .    because of the same poisson process intensity in eq .",
    "( [ eq : poissonrateequality ] ) , the following equality also holds @xmath92      [ expecteddistribution ] while restricting @xmath80 to @xmath1 , @xmath81 , the marginal probability of the pre - images of a nonempty patch @xmath93 in @xmath0 ( given the patches in @xmath0 crossing into @xmath1 that are nonempty ) equals to the probability of @xmath93 directly sampled from @xmath82 ( given the patches in @xmath1 that are nonempty ) , that is @xmath94 .",
    "w.l.o.g , we assume that the two arrays , @xmath1 and @xmath0 , have the same shape apart from the @xmath91th dimension where @xmath0 has one additional column ( the general case follows by induction ) . for dimensions @xmath95 ,",
    "it is obvious that the law of patches is consistent under projection because the projection is the identity .",
    "given the same budget @xmath44 , proposition  [ expecteddistribution ] holds if we can prove the following equality @xmath96 where @xmath97 indicates the initial position , @xmath98 , and the side - length , @xmath99 , of the @xmath91th side of @xmath93 ; @xmath100 means that there is at least one `` 1 '' entry in @xmath101 .",
    "( [ eq_position ] ) involves four cases in total : @xmath1 and @xmath0 1 ) share the initial boundary or 2 ) share the terminal boundary in the @xmath91th dimension ; in each case , there are two sub - cases regarding whether the terminal position ( for case 1 ) or the initial position ( for case 2 ) of the @xmath91th side of @xmath93 locates at the boundary of @xmath1 .",
    "we can prove that eq .",
    "( [ eq_position ] ) holds in all cases .",
    "consider all @xmath8 dimensions we have @xmath94 ( see appendix for the complete proof ) .",
    "now we are ready to prove @xmath102 .",
    "@xmath103 where @xmath104 and @xmath105 in the step marked by @xmath106 are obtained by applying propositions  [ expectednumber ] and  [ expecteddistribution ] , respectively .",
    "according to the kolmogorov extension theorem ( see section  [ sub : kolmogorov ] ) , we have the following result .",
    "the probability measure @xmath11 on a measurable space @xmath107 of spp , @xmath108 , can be uniquely extended to @xmath22 on @xmath23 as the projective limit measurable space .",
    "a typical application of spp is relational modeling . given the relational data as an asymmetric matrix @xmath109 , with @xmath110 indicating the relation from node @xmath111 to node @xmath112 , the patches @xmath33 with different rates @xmath113 of a partition @xmath114 are used for modeling communities with different intensities of relations . because @xmath33 can be overlapped , the intensity of relations in an overlapped part on @xmath115 is synthesized by the rates of the involved patches ( see figure  [ sppdecomposition ] ) .",
    "the generative process of an spp relational model is as follows : ( 1 ) generate a partition @xmath114 ; ( 2 ) for @xmath116 , generate row index @xmath117 of @xmath115 ; ( 3 ) for @xmath118 , generate column index @xmath119 of @xmath115 ; ( 4 ) for @xmath120 , generate relational data @xmath121 , where @xmath122 is a selected function for mapping the aggregated rate from @xmath123 to @xmath124 as intensity of relations and @xmath125 is a scaling parameter .",
    "while here we instantiate an spp relational model with binary interactions ( bernoulli likelihood ) , other types of relations ( e.g. , categorical likelihood ) can also be plugged in .",
    "actually , spp and the mapping function @xmath126 play together as the role of random function @xmath127 defined in section  [ sub : graphon ] .",
    "the uniformly exchanged row and column indices ( @xmath117 and @xmath119 ) resemble the row and column indices ( @xmath128 and @xmath129 ) which are uniformly sampled in @xmath130 $ ] .",
    "by re - arranging the rows and columns of @xmath115 according to the inferred indices , the spp relational model is expected to uncover homogeneous interactions in @xmath115 as compact patches .",
    "relational data @xmath115 , budget @xmath44 , hyper - parameters @xmath131 , iteration time @xmath132 @xmath65 , @xmath133 , @xmath134 and @xmath135 sample @xmath63 ; sample @xmath136 ; //",
    "metropolis - hastings sample @xmath137 ; //",
    "c - smc ( algorithm [ patch_pg ] ) sample @xmath138 ; //",
    "multiple - try metropolis    the joint probability of the data @xmath139 , the number of nonempty patches @xmath65 , the variables of the nonempty patches @xmath140 , and the indices @xmath141 gives @xmath142 where @xmath143 refers to the probability of @xmath144 and @xmath145 denotes the parameter of the bernoulli likelihood ; @xmath146 denotes the probability of row and column indices ; @xmath147 ( where @xmath148 ^ 2 $ ] ) denotes the joint probability of the number and the time points of the nonempty patches .",
    "we adopt mcmc methods for sampling the posteriors of @xmath65 , @xmath133 , @xmath134 and @xmath135 . by an abuse of notation , in the following @xmath149",
    "is used to represent the case that the likelihood is updated by replacing @xmath150 with @xmath151 , keeping the other variables unchanged .",
    "also , we use @xmath152 to denote the likelihood computed excluding the @xmath2th patch . the sampling algorithm is outlined in algorithm  [ detailinference ] .",
    "relational data @xmath115 , hyper - parameters @xmath77 , current patches @xmath33 , number of particles @xmath153 , maximum length of the sequence in c - smc @xmath154 new position of patch @xmath155 sample random initial positions for @xmath156 ; set @xmath157 and @xmath158 ; sample @xmath159 from @xmath160 ; update weight @xmath161 according to eq .",
    "( [ pg_weight_update ] ) ; normalize @xmath162 and obtain @xmath163 ; resample indices @xmath164 from @xmath165 ;",
    "@xmath166 , assign @xmath167 ; sample @xmath168 from @xmath169 and let @xmath170 ;    [ [ eq_samplingntau ] ] sample @xmath65 + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we use a similar strategy of  @xcite for updating @xmath65 .",
    "first , we use probability @xmath171 ( or @xmath172 ) to choose proposing adding ( or removing ) a nonempty patch .",
    "the proposal probability of adding a nonempty patch is @xmath173 where @xmath174 denotes a newly added patch ; the proposal probability of deleting an existing patch is @xmath175 we accept adding or removing a patch with a ratio of @xmath176 or @xmath177 , where @xmath178 @xmath179 it is worth noting that in the proposal of adding a new nonempty patch , it is generated by following step 2 ( a ) and ( b ) of `` alternative construction of spp '' in appendix .    [ [ eq_samplingpik ] ] sample @xmath34 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for the @xmath2th patch , @xmath180 , a new @xmath181 is sampled from the proposal distribution , which is a truncated exponential distribution @xmath182 $ ] .",
    "we then accept @xmath181 with a ratio of @xmath183 , where @xmath184    [ [ eq_samplinguk ] ] sample @xmath185 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a straightforward way to update @xmath185 is to use the metropolis - hastings ( mh ) algorithm .",
    "since mh only proposes local changes to update the current positions of @xmath33 in each iteration , the sampler can explore limited space in @xmath4 given a reasonable sampling budget . to overcome this problem",
    ", we adopt conditional - sequential monte carlo  @xcite ( c - smc ) for sampling completely new positions of @xmath33 in each iteration .",
    "the description of the c - smc sampler for @xmath40 is shown in algorithm  [ patch_pg ] .",
    "c - smc works similarly as smc to propose high dimensional variables ( @xmath186 in our case ) at each stage of the sequence , except for clamping the first particle as the current patch @xmath157 ( where @xmath187 represents the patch updated at the @xmath111th stage ) .",
    "the advantage of c - smc for our problem is that it is able to propose a completely new candidate patch to replace the current one with high acceptance ratio .",
    "the key connection between c - smc and patch sampling is to view the generative process of a patch ( introduced in section  [ sec : spp ] ) as a sequence of state variables ( similar as  @xcite using c - smc for sampling a tree ) . starting from a randomly chosen initial position , the patch undergoes entry - wise growing in both directions of row and column .",
    "let @xmath160 denote the proposal distribution of the @xmath188th particle at the @xmath111th stage , @xmath160 is set as the conditional distribution of @xmath159 given @xmath189 under the generative prior , in both directions of row and column . as a result ,",
    "the weight @xmath161 for the @xmath188th particle at the @xmath111th stage is updated as @xmath190 where @xmath191 and @xmath192 refer to the row and column indices whose likelihoods are influenced by the particle updating .",
    "although the complexity of the c - smc sampler ( algorithm [ patch_pg ] ) is higher than the mh algorithm , c - smc can propose completely new patches with high acceptance ratio .",
    "this ability enables it to fast explore the partition space @xmath4 . in this sense",
    ", c - smc can provide a much better approximation to the posterior distribution of the patches .",
    "[ [ eq_samplingruv ] ] sample @xmath193 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    to cooperate with the c - smc sampler for higher acceptance ratio , we adopt the multiple - try metropolis method  @xcite for sampling the row and column indices of the relational data ( please refer to appendix for details ) .      [ cols=\"<,^,^,^,^,^\",options=\"header \" , ]     [ rm_dataset ]    we empirically test the spp relational model ( spp - rm ) for link prediction .",
    "we compare spp - rm with four state - of - the - arts : ( 1 ) irm  @xcite ( regular grids ) ; ( 2 ) lfrm  @xcite ( plaid grids ) ; ( 3 ) mp relational model ( mp - rm )  @xcite ( hierarchical @xmath2d - tree ) ; ( 4 ) matrix tile analysis relational model ( mta - rm )  @xcite ( noncontiguous tiles ) .",
    "all these models except mp - rm can be represented as a ( weighted ) sum of outer products of binary latent feature ( community ) vectors ( see figure  [ fig : models ] ) . for irm and lfrm",
    ", we adopt the collapsed gibbs sampling algorithms for inference ; for mp - rm , we adopt the reversible - jump mcmc algorithm for inference  @xcite ; for mta - rm , we adopt the iterative conditional modes algorithm used in  @xcite .    *",
    "data sets * : five social network data sets are used : digg , flickr  @xcite , gplus  @xcite , and facebook , twitter  @xcite .",
    "we extract a subset of nodes ( top 1000 active nodes based on their interactions with others ) from each data set for constructing the relational data matrix .    *",
    "experimental setting * : we set the hyper - parameters for each method as follows : in irm , we let @xmath194 be sampled from a gamma prior @xmath195 and the row and column partitions be sampled from two independent dirichlet processes ; in lfrm , we let @xmath194 be sampled from a gamma prior @xmath196 . as the budget parameter of mp - rm is hard to sample  @xcite , we set it to @xmath197 , which suggests that around @xmath198 blocks would be generated . for parametric model mta - rm",
    ", we simply set the number of tiles to 16 ; in spp - rm , we set @xmath199 and @xmath200 , which leads to an expectation of 12.5 patches .",
    "we use @xmath201 particles in algorithm  [ patch_pg ] and set the maximum length of the sequence to @xmath202 ( half number of rows / columns ) .",
    "the reported performance is averaged over 10 randomly selected hold - out test sets ( @xmath203 ) .    * results * : table  [ rm_dataset ] reports the performance comparison results on the five data sets .",
    "we can see that spp - rm consistently outperforms the other four methods in all cases , with around 0.01 improvement compared to the runner - up in prediction auc .",
    "the overall results validate that spp - rm is effective in relational modeling due to its flexibility via attaching patches to dense regions .",
    "figure  [ partiiongraph ] ( rows 1@xmath2045 ) illustrates the visual patterns of the partition results . as expected , our bounding - based method spp - rm indeed focuses on describing dense regions of relational data matrices with fewer patches , while the two representative cutting - based methods , irm and mp - rm , cut sparse regions into more blocks .",
    "an interesting observation of spp - rm is that overlapped patches are very useful in describing inter - community interactions ( e.g. , patches in digg , flickr , and gplus ) and community - in - community interactions ( e.g. , upper - right corner in flickr and gplus ) .",
    "thus , in addition to improved performance , spp - rm also produce parsimonious partitions .    figure  [ partiiongraph ] ( rows 6@xmath2047 ) plot the average performance versus the wall - clock time for investigating the convergence behavior of the compared methods .",
    "irm and lfrm converge fastest because of efficient collapsed gibbs sampling .",
    "mta - rm also converges fast because it is trained using a simple iterative algorithm .",
    "although spp - rm takes longer time for each sampling epoch compared to the other methods , it usually can obtain competitive performance in few iterations , thanks to the c - smc sampler .",
    "a parsimonious partition process , named stochastic patching process ( spp ) , is proposed . instead of the cutting - based strategy , we adopt a bounding - based strategy to attach _ i.i.d . _",
    "rectangular patches to model dense data regions in the space such that it can avoid unnecessary dissections in sparse regions .",
    "we apply spp to relational modeling and find that spp can achieve clear performance gain with fewer patches ( blocks ) compared to the state - of - the - art relational modeling methods .",
    "we thank the anonymous meta - reviewer of icml-16 for his / her constructive and very detail comments , which helped us to significantly improve the manuscript .",
    "an alternative construction of spp which is equivalent to the one introduced in section 3 is as follows :    1 .",
    "sample the number of _ nonempty _ patches @xmath205 , where @xmath206 $ ] ; 2 .   given @xmath65 , sample _ i.i.d .",
    "_ _ nonempty _ patches @xmath207 . for @xmath208 ,",
    "@xmath52 1 .",
    "sample the initial position @xmath71 of @xmath40 from @xmath209 in proportion to @xmath210 ; 2 .",
    "sample the side - length @xmath72 using the distribution @xmath211 where @xmath212 ; 3 .",
    "sample @xmath65 _ i.i.d .",
    "_ time points uniformly in @xmath46 $ ] and index them to satisfy @xmath213 .",
    "set the cost of @xmath40 as @xmath214 and the rate of @xmath40 as @xmath70 , where @xmath215 .    in this way , one can directly sample _ nonempty _ patches through thinning the poisson process which is used for generating candidate patches .",
    "@xmath216 , we have the probability of side - length @xmath217 as @xmath218.\\end{aligned}\\ ] ] according to the thinning property of the poisson process , we thus have the following expected number of nonempty patches : @xmath219.\\end{aligned}\\ ] ]    for the expectation of side - length @xmath220 , we need to consider its all possible initial positions @xmath221 : @xmath222 for convenience of notation , we let @xmath223    in the case of @xmath224 ( the initial position is on the boundary of @xmath1 ) , we have @xmath225 according to step 2(a ) in `` alternative construction of spp '' ; and the expected side - length is @xmath226 .",
    "\\end{split}\\ ] ] to simplify the above equation , we can compute @xmath227 to cancel out many terms and obtain the following equation @xmath228 . \\ ] ] thus we have @xmath229    similarly , in the case of @xmath230 ( the initial position is not on the boundary of @xmath1 ) , we have @xmath231    now the expectation of @xmath220 becomes @xmath232\\\\ = & \\frac{n_x^{(d)}}{\\theta+(1-\\theta)n_x^{(d)}}. \\end{split}\\ ] ]    by combining eq .",
    "( [ eq_nonintensity ] ) and eq .",
    "( [ expecedlength ] ) , we can obtain the expected volume of all patches : @xmath233 \\cdot \\frac{n_x^{(d)}}{\\theta+(1-\\theta)n_x^{(d ) } } = \\tau\\cdot\\prod_{d=1}^d n_x^{(d)},\\ ] ] which concludes the proof .",
    "according to the definition , the candidate patches sampled from @xmath80 ( or @xmath82 ) follows a homogeneous poisson process with intensity @xmath87 ( or @xmath73 ) . since there exists possibility to generate empty patches , we use intensity @xmath88 for thinning the poisson process to generate nonempty patches .",
    "given the same budget @xmath44 , proposition  [ expectednumber ] holds if we can prove the following equality of the two poisson process intensities @xmath234 due to the independence of dimensions , @xmath235 can be rewritten as @xmath236 assuming @xmath237 , we have @xmath238.\\end{aligned}\\ ] ]    w.l.o.g , we assume that the two arrays , @xmath1 and @xmath0 , have the same shape apart from the @xmath91th dimension where @xmath0 has one additional column ( the general case of more columns follows by induction ) , then @xmath239 .",
    "there are two cases to consider : ( 1 ) @xmath1 and @xmath0 share the terminal boundary in the @xmath91th dimension ; ( 2 ) @xmath1 and @xmath0 share the initial boundary in the @xmath91th dimension . in either case , by independence of dimensions , we have @xmath240    in case ( 1 ) where @xmath1 and @xmath0 share the terminal boundary in the @xmath91th dimension , we have @xmath241,\\end{aligned}\\ ] ] where the first term @xmath242 corresponds to the case that the initial position is on the boundary of @xmath0 and @xmath243 ( otherwise @xmath244 will not cross into @xmath1 ) ; while the second term @xmath245 corresponds to the cases that the initial position is not on the boundary of @xmath0 . by combining eqs .",
    "( [ eq_dimensiondecomposition ] ) , ( [ eq_nonemptypatch ] ) , ( [ eq_nonemptypatch2 ] ) and ( [ eq_patchcross ] ) , we have @xmath246 thus we have @xmath247 .    in case",
    "( 2 ) where @xmath1 and @xmath0 share the initial boundary in the @xmath91th dimension , we have @xmath248.\\end{aligned}\\ ] ] the conclusion can be similarly derived .    because of the same poisson process intensity eq .",
    "( [ eq : poissonrateequality1 ] ) , the following equality also holds @xmath249",
    "w.l.o.g , we assume that the two arrays , @xmath1 and @xmath0 , have the same shape apart from the @xmath91th dimension where @xmath0 has one additional column ( the general case follows by induction ) . for dimensions @xmath95 ,",
    "it is obvious that the law of patches are consistent under projection because the projection is the identity .",
    "given the same budget @xmath44 , proposition  [ expecteddistribution ] holds if we can prove the following equality @xmath250 where @xmath97 indicates the initial position , @xmath98 , and the side - length , @xmath99 , of the @xmath91th side of @xmath93 ; @xmath251 means that there is at least one `` 1 '' entry in @xmath97 as @xmath93 is a _ nonempty _ patch .",
    "there are two cases to consider : ( 1 ) @xmath1 and @xmath0 share the initial boundary in the @xmath91th dimension ; ( 2 ) @xmath1 and @xmath0 share the terminal boundary in the @xmath91th dimension . in each case , there are two cases ( denoted as a & b in the following ) regarding whether the terminal / initial ( for case 1/2 , respectively ) position locates at the boundary of @xmath1 . in total",
    "we have four cases to discuss as follows .    in case",
    "( 1 ) where @xmath1 and @xmath0 share the initial boundary , @xmath252 implies the condition of @xmath253 because @xmath254 would lead to @xmath255 .",
    "thus , the left term of eq .",
    "( [ eq19 ] ) can be expressed as @xmath256 for convenience of notation , we let @xmath257 , specifically @xmath258 if @xmath259 ; @xmath260 if @xmath261 .    [ case 1.a ] for @xmath262 , @xmath263    [ case 1.b ] for @xmath264 , @xmath265    in case ( 2 ) where @xmath1 and @xmath0 share the terminal boundary , @xmath252 implies the condition of @xmath266 because @xmath267 would lead to @xmath268 .",
    "thus , the left term of eq .",
    "( [ eq19 ] ) can be expressed as @xmath269 given the condition of @xmath266 and the assumption @xmath270 , we have @xmath271 and @xmath272    [ case 2.a ] for @xmath273 , we have @xmath274 , @xmath275 where @xmath276 if @xmath277 ; @xmath278 if @xmath279 .",
    "[ case 2.b ] for @xmath280 , we have @xmath281 , @xmath282    consider all @xmath8 dimensions , for each case , we have @xmath94 .",
    "@xmath284    we can obtain eq .",
    "( [ app2 ] ) from eq .",
    "( [ app1 ] ) because @xmath285 which indicates @xmath286 we can obtain eq .",
    "( [ app3 ] ) from eq .",
    "( [ app2 ] ) because of independence of patches .",
    "( [ app4 ] ) is derived from eq .",
    "( [ app3 ] ) by applying proposition 2 and eq .",
    "( [ app5 ] ) is derived from eq .",
    "( [ app4 ] ) by applying proposition 3 .",
    "the prior distributions of @xmath134 and @xmath287 are discrete uniform distributions over all the @xmath288 permutations . to cooperate with the c - smc sampler for higher acceptance ratio",
    ", we adopt the multiple - try metropolis method  @xcite for sampling the row and column indices of the relational data . for each @xmath117",
    ", we propose an exchange between @xmath117 and @xmath289 proposal rows @xmath290 , which are randomly chosen .",
    "the detail for sampling @xmath134 is summarized in algorithm  [ mtm_ranks ] ( sampling @xmath135 is similar ) .",
    "relational data @xmath115 , number of proposals @xmath289 , @xmath291 , @xmath134 and @xmath135 new assignments of @xmath134 propose @xmath289 independent proposal indices @xmath290 for exchanging with @xmath117 ; compute the weights @xmath292 as @xmath293 sample @xmath294 from @xmath290 with probability in proportional to @xmath292 ; suppose @xmath117 and @xmath294 are exchanged ; propose @xmath295 new independent proposal indices @xmath296 and set @xmath297 for exchanging with @xmath294 ; compute the weights @xmath298 as @xmath299 accept the exchange between @xmath117 and @xmath294 with the ratio @xmath300"
  ],
  "abstract_text": [
    "<S> stochastic partition models tailor a product space into a number of rectangular regions such that the data within each region exhibit certain types of homogeneity . due to constraints of partition strategy </S>",
    "<S> , existing models may cause unnecessary dissections in sparse regions when fitting data in dense regions . to alleviate this limitation , we propose a parsimonious partition model , named stochastic patching process ( spp ) , to deal with multi - dimensional arrays . </S>",
    "<S> spp adopts a `` bounding '' strategy to attach rectangular patches to dense regions . </S>",
    "<S> spp is self - consistent such that it can be extended to infinite arrays . </S>",
    "<S> we apply spp to relational modeling and use mcmc sampling for approximate inference . in particular , conditional - smc is adopted to sample new patches . </S>",
    "<S> the experimental results validate its merit compared to the state - of - the - arts . </S>"
  ]
}