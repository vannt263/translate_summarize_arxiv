{
  "article_text": [
    "consider the _ collatz map _",
    "@xmath5 defined by @xmath6 given @xmath1 , define the _ total stopping time _ to be the smallest @xmath2 for which @xmath3 .",
    "the _ collatz conjecture _ claims that every @xmath1 has a finite total stopping time ; it has been verified for inputs as high as @xmath7 by oliveira e silva [ 1 ] , and a generalization of the conjecture by kurtz and simon was shown to be recursively undecidable [ 2 ] . if we define the _ stopping time _ to be the smallest @xmath2 for which @xmath8 , the claim that every @xmath1 has a finite stopping time is equivalent to the collatz conjecture .",
    "the _ trajectory _ for an input @xmath1 is the sequence @xmath9 we can categorize the possible behaviors of the trajectory as follows [ 3 ] :    a.   _ convergent trajectory _ : @xmath3 for some positive integer @xmath2 . b.   _ non - trivial cyclic trajectory _ : @xmath10 becomes periodic and @xmath11 for any positive @xmath2 . c.   _ divergent trajectory _ : @xmath12 .",
    "the iterative nature of the problem and the complexity of behavior that arises from the simple premises of the collatz conjecture suggest the use of cellular automata to mimic computation .",
    "notable instances of using deterministic computational models to simulate the behavior of the collatz map include de mol s 2-tag system using a set of three production rules over an alphabet of three symbols to mimic the collatz map [ 4 ] , michel s two one - tape turing machines [ 5 ] whose halting problems depend on generalizations of the collatz problem , and bruschi s two one - dimensional cellular automata that calculate trajectories using _ tagging _ operations to detect parity [ 6 ] . in this paper , we demonstrate one three - dimensional and two two - dimensional cellular automata that also mimic the behavior of the collatz map but whose evolution laws operate independent of parity , depending solely on local relationships between digits of the iterates .",
    "we find that our automata have the potential to compute trajectories more efficiently than do current methods both by bypassing computation of large parts of trajectories and by verifying an arbitrary number of inputs in parallel .",
    "this ca acts upon an three - dimensional grid of cubical cells in two layers indexed by 0 and 1 , respectively .",
    "each cell in the bottom layer is in one of four states represented in figure  [ fig : basethreerules ] by the corresponding colors in parentheses ` 0 ` ( light gray ) , ` 1 ` ( gray ) , ` dark gray ` , and ` empty ` ( white) and each cell in the top layer is in one of four states also represented in figure  [ fig : basethreerules ] by the corresponding colors in parentheses ` odd - normal ` ( gray ) , ` odd - special ` ( odd - normal with a cross ) , ` even ` ( light gray ) , and ` unknown - parity ` ( black ) . in the planes of each layer ,",
    "rows are indexed top to bottom by @xmath13 and columns right to left by @xmath14 , where row @xmath15 and column @xmath16 of the bottom layer lie respectively beneath row @xmath15 and column @xmath16 of the top layer .",
    "we denote a cell in row @xmath15 and column @xmath16 of layer @xmath2 by the ordered triple @xmath17 and its state at time period @xmath18 by @xmath19 .    as shown in figure  [ fig : ca3bottom ] , given a cell in the bottom row ( dark gray ) , the neighborhood of that cell is the set of cells labeled b - f ( light gray ) , where cell b lies directly under cell f. as shown in figure  [ fig : ca3top ] , given a cell in the bottom row ( dark gray ) , the neighborhood of that cell is the set of cells labeled d , g , h ( dark gray ) . in other words ,",
    "the neighborhood of cell @xmath20 is the set of cells @xmath21 , while the neighborhood of cell @xmath22 is the set of cells @xmath23 .",
    "if input @xmath1 has ternary representation @xmath24 , the ca is initialized as follows : for @xmath15 from @xmath25 to @xmath26 and an arbitrary @xmath2 , we have @xmath27 . all cells in the top layer",
    "are set to state ` unknown - parity ` , and all other cells in the bottom layer are set to state ` empty ` .        for simplicity ,",
    "the rules in figure  [ fig : basethreerules ] are presented in two dimensions : rules of categories 1a through 1c represent transformation of the bottom layer , while rules of categories 1d through 1 g represent transformation of the top layer .",
    "a rule in category 1a , 1b , or 1c is represented as a @xmath28 grid with an arrow directed at a @xmath29 grid ( for convenience , the @xmath28 grids of rules in figure  [ fig : basethreerules ] that involve the same @xmath29 grid are grouped together ) .",
    "they correspond , respectively , to the bottom and top halves of the configuration in figure  [ fig : ca3bottom ] .",
    "specifically , in the @xmath30 grid , the bottom - left square corresponds to @xmath31 in figure  [ fig : ca3bottom ] , the cell that is evolving , and its color denotes the future state into which that cell evolves given the states in its neighborhood .",
    "if this cell has coordinates @xmath20 , proceeding clockwise , the grid s other cells correspond to the current states of cells b@xmath32 , c@xmath33 , and d@xmath34 respectively . in the @xmath35 grid , the left and right cells correspond to cells @xmath36 and @xmath37 , respectively .",
    "for example , the first rule in category 1c of figure  [ fig : basethreerules ] should be interpreted to mean that @xmath38 if @xmath39 , @xmath40 , @xmath41 , @xmath42 , and @xmath43 .",
    "a rule in category 1d , 1e , or 1f is represented as an l - shaped collection of three cells , corresponding to the configuration in figure  [ fig : ca3top ] .",
    "specifically , the upper - right square in each rule corresponds to cell @xmath31 in figure  [ fig : ca3top ] , that is , the cell that is evolving , and the color of the square denotes the future state into which that cell evolves given the state in its neighborhood . if this cell has coordinates @xmath22 , the cells to its left , right , and bottom correspond to current states of cells @xmath44 and @xmath45 , respectively .",
    "for example , the first rule in category 1e of figure  [ fig : basethreerules ] should be interpreted to mean that @xmath46 if @xmath47 and @xmath48 .",
    "if a cell s neighborhood corresponds to that of any of the evolution laws ( figure  [ fig : basethreerules ] ) , then its state becomes the state of the cell in that evolution law corresponding to cell @xmath31 .    if the neighborhood of a cell in the top layer does not correspond to any evolution law , then that cell s state becomes ` unknown - parity ` .    if the neighborhood of a cell in the bottom layer does not correspond to any evolution law , then that cell s state becomes ` empty ` .",
    ", height=144 ]    in figure  [ fig : ca1inaction ] , if we treat the non - empty cells in each row as ternary digits , the ca gives a sequence of iterates : @xmath49 as we will prove , ca1 thus mimics the following modified collatz map @xmath50 defined by @xmath51    for every @xmath52 , there exists some @xmath15 so that after @xmath15 iterations of ca1 , the states of cells not in the state of ` empty ` in row @xmath2 of the bottom layer correspond to the ternary digits of @xmath53 , where @xmath1 is the input , for all @xmath54 .    in base three ,",
    "parity of a number is the same as the parity of the sum of that number s digits .",
    "so whereas the bottom layer of the ca represents transformations of the iterates , the upper layer serves to add digits @xmath55 to determine parity .",
    "as we shall show , the latter goes about doing this by computing successive partial sums , starting with the most significant digits .    in other words ,",
    "given an iterate @xmath56 , after @xmath15 generations have elapsed for the ca , the cell above the cell representing @xmath57 will have state equal to the parity of @xmath58 , so after @xmath59 generations , the state of the cell above @xmath60 will be the parity of the iterate .",
    "we claim that the rules in categories 1d , 1e , and 1f are exhaustive and properly determine the parity of an iterate in this way .",
    "we will denote cell @xmath61 to be the cell that is evolving .",
    "if @xmath62 , the ca is determining the parity of the leading digit @xmath20 , so @xmath63 is simply the parity of @xmath64 , which can take on three possible values`0 ` , ` 1 ` , ` 2`giving the three evolution laws in category 1f .    otherwise , if @xmath65 , the ca is calculating the parities of partial sums of the @xmath2 significant digits , and there are three possible states for @xmath20`0 ` , ` 1 ` , ` 2` and two for @xmath66`odd - normal ` , ` even`making for the six evolution laws in categories 1e . in each case , @xmath67 in the sense of adding parities so that the sum of state ` even ` and ` 1 ` is ` odd - normal ` and the sum of ` odd ` and ` 1 ` is ` even ` , for example .",
    "if @xmath68 , the ca has reached the right end of the iterate .",
    "if the iterate is odd and the coordinates of the units digit are @xmath69 , the ca sets the state of @xmath70 to ` odd - special ` to signal the ca to append a 1 to the iterate ( see below ) , giving the first rule in category 1d .",
    "the last two rules in this category tell the ca to leave all top - layer cells in row @xmath15 to the right of @xmath71 ( for odd iterates , to the right of @xmath22 ) in state ` unknown - parity ` .    therefore , the rules in categories 1d to 1 g properly determine the parity of iterates .",
    "it suffices to show that the rules in categories 1a to 1c are exhaustive and properly mimic the collatz map in the bottom layer .",
    "in particular , we will show that if @xmath72 is even and cell @xmath73 has state @xmath74 for @xmath75 , then if @xmath76 , cell @xmath77 will eventually have state @xmath78 for @xmath79 .",
    "if @xmath10 is odd and if @xmath76 , cell @xmath80 has state @xmath78 for @xmath79 .    in our proof , we will denote the cell in the bottom - left of each evolution law in figure  [ fig : basethreerules ] , that is , the cell that is evolving , by @xmath20 .",
    "we will continue to denote the current iterate by @xmath81 and the iterate in the preceding row by @xmath82 .    if @xmath83 , the ca is determining the rightmost digits of the iterate on row @xmath15 .",
    "the first and last rows of category 1b in figure  [ fig : basethreerules ] represent the two possible cases for @xmath84 for when the previous iterate is even or odd , respectively . in the former case",
    ", the ca should mimic division by two so that @xmath85 . in the latter case",
    ", the ca should mimic @xmath86 .",
    "when @xmath87 as in the last rule of category 1b , the ca effectively treats the empty cell @xmath32 as being in state ` 1 ` so that @xmath88 , meaning the state of @xmath20 , the units digit of the new iterate will be ` 2 ` .",
    "the digit @xmath89 must then satisfy @xmath90 , giving the second row of rules in category 1b .    if @xmath39 , the ca is determining the leftmost digits of the iterate on row @xmath15 .",
    "by the above discussion of the process by which the ca determines parity , cell @xmath91 must be in state ` unknown - parity ` .",
    "furthermore , @xmath92 can not exceed @xmath93 .",
    "otherwise , if we denote @xmath94 to be the iterate in row @xmath95 and @xmath96 the iterate in row @xmath15 , then if @xmath82 is even , @xmath97 , and if it is odd , @xmath98 , both contradictions ! in fact , for there to be no such contradictions when @xmath93 is ` 1 `  or  ` 2 ` , @xmath92 must be strictly less than @xmath93 .",
    "this gives exactly one possibility for each choice of @xmath93 from @xmath99 , and in each case , it is clear that because @xmath34 represents the leftmost digit , @xmath38 , giving the rules in category 1c .",
    "if none of the cells in the neighborhood of @xmath61 are ` empty ` , the ca is determining the inner digits of the iterate , so @xmath100 and @xmath101 must be ` even ` or ` odd - normal ` as in the rules in category 1a .",
    "first note that multiplication by two in base three involves carries of at most one .",
    "therefore , for every pair @xmath102 , @xmath103 , where @xmath104 , giving the 18 possible neighborhoods in category 1a . in each of these cases",
    ", @xmath105 satisfies @xmath106 giving the evolution laws in category 1a .",
    "this cellular automaton acts on a two - dimensional infinite grid of square cells each in one of five possible states represented in figure  [ fig : basefourlaws ] by the corresponding colors in parentheses`0 ` ( white ) , ` 1 ` ( light gray ) , ` 2 ` ( dark gray ) , ` 3 ` ( black ) , and ` empty ` ( white ) .",
    "additionally , states ` 0 ` through ` 3 ` each have an additional attribute of either ` -odd ` or ` -even ` , indicated by a circle or a square within the cell , respectively ( e.g. a state of ` 0-odd ` is a white cell containing a circle ) .",
    "let the rows be indexed top to bottom by @xmath13 and the columns right to left by @xmath14 , and denote the cell in the @xmath15th row and @xmath16th column by @xmath61 and its state in time period @xmath18 by @xmath107 .",
    "as shown in figure  [ fig : basefourneighbor ] , the neighborhood of cell @xmath61 ( white ) is the set of cells @xmath108 ( dark gray ) .        if input @xmath1 has quaternary representation @xmath109 and the smallest @xmath15 for which @xmath110 is @xmath111 , then the ca is initialized as follows : for an arbitrary @xmath2 and @xmath15 from @xmath111 to @xmath26 , we have @xmath112 and @xmath113 for all @xmath114 .        in figure  [",
    "fig : basefourlaws ] , each @xmath28 grid represents one evolution law , with each cell playing the same role as it does in figure  [ fig : basefourneighbor ] . in other words , the bottom - left cell in each @xmath28 grid represents the cell that is transforming , and its color represents the future state into which it evolves given the states of its neighborhood .",
    "the colors of the remaining three cells represent the current states of the neighborhood that determine the state into which the bottom - left cell evolves .",
    "for example , the first of eight evolution laws in category 2b should be interpreted to mean that @xmath115 if @xmath116 , @xmath117 and @xmath118 .    if a cell s neighborhood corresponds to one of the evolution laws ( figure  [ fig : basefourlaws ] ) , then that cell s state becomes the state of the cell as described in the evolution law .    if a cell s neighborhood does not correspond to any evolution law , then that cell s state becomes ` empty ` .    ,",
    "height=115 ]    in figure  [ fig : ca2inaction ] , if we treat the non - empty cells in each row as quaternary digits , ca2 gives a sequence of iterates : @xmath119 as we will prove , because ca2 mimics the following modified collatz map @xmath120 defined by @xmath121 where @xmath122 is the largest power of four dividing @xmath94 , by eliminating trailing zeroes .",
    "for every @xmath52 , there exists some @xmath15 so that after @xmath15 iterations of ca2 , the states of cells not in the state of ` empty ` in row @xmath2 correspond to the quaternary digits of @xmath123 , where @xmath1 is the input , for all @xmath54 .",
    "although parity in base four is given by the parity of the units digit , each digit must be represented by two states depending on the parity of the iterate for the ca to know whether to mimic @xmath124 or @xmath125 .",
    "the former function is equivalent to @xmath126 and thus to multiplying by two and removing the resulting trailing zero ; the latter function is equivalent to @xmath127 and thus , roughly speaking , to subtracting the iterate from a copy of itself shifted left one place and right - appended with a digit of 1 .",
    "we will denote the cell in the bottom - left of each evolution law in figure  [ fig : basefourlaws ] , that is , the cell that is evolving , by @xmath61 , the current iterate by @xmath128 , and the iterate in the preceding row by @xmath129 .",
    "we first prove that the rules in categories 2a to 2c are exhaustive in mimicking @xmath124 .",
    "note again that multiplication by two involves carries of at most one .    if @xmath130 as in the rules in category 2c , the ca is determining the rightmost digits of the iterate on row @xmath15 .",
    "by design , @xmath131 is necessarily nonzero , so for the iterate in row @xmath95 to be even , @xmath132 , giving the first rule in category 2c . here ,",
    "@xmath133 . there are then four choices ` 0- ` , ` 1- ` , ` 2- ` , ` 3-even` for @xmath134 , represented by @xmath135 in the last four rules of category 2c , and because there is a carry of one from multiplying @xmath131 by 2 , @xmath136 .    if @xmath116 as in the rules in category 2b , the ca is determining the leftmost digits of the iterate on row @xmath15 .",
    "if @xmath137 , there are three possible states for cell @xmath138 , namely ` 1- ` , ` 2- ` , ` 3-even ` , and in each of these cases , there are @xmath139 , where @xmath104 , giving the first six evolution laws in category 2b . in these rules ,",
    "the state into which cell @xmath61 evolves is chosen so that @xmath140 . if @xmath141 , then the cell to the left of this should be empty to mark the end of the iterate , giving the last rule in category 2b .",
    "if none of the cells in the neighborhood of @xmath61 are in state ` empty ` as in the rules in category 2a , the ca is determining the inner digits of the iterate .",
    "cells @xmath142 and @xmath138 can be in any of four states , namely ` 0- ` , ` 1- ` , ` 2- ` , or ` 3-even ` , and for each of these 16 cases , @xmath139 where @xmath104 , giving the 32 evolution laws in category 2a . in these rules , the state into which cell @xmath61 evolves is chosen so that @xmath143    we next prove that the rules in 2d to 2h are exhaustive in mimicking @xmath125 .    if @xmath130 as in the rules in category 2f , the ca is determining the rightmost digits of the iterate on row @xmath15 .",
    "because the iterate on row @xmath95 must be odd , there are two choices for @xmath131 ` 1-odd ` or ` 3-odd` represented by cell @xmath144 in the two rules of category 2f s right column ( figure  [ fig : basefourlaws ] ) . if @xmath145 , @xmath146 so that @xmath147 , but if @xmath148 , @xmath149 so that @xmath115 because ca2 deletes trailing zeroes .    in the former case in which @xmath150 has been determined ,",
    "the ca then turns to evolution laws in category 2d to determine the inner digits of the iterate on row @xmath15 . in the latter case",
    "in which @xmath150 has not been determined , there are four possible values for @xmath134 , namely ` 0- ` , ` 1- ` , ` 2- ` , ` 3-odd ` , giving the four evolution laws of category 2f s left column . by our interpretation of @xmath0 as @xmath151 ,",
    "the state into which cell @xmath61 evolves is chosen so that @xmath152 if @xmath153 ; otherwise , @xmath115 because ca2 deletes trailing zeroes .",
    "proceeding as above , the ca turns to evolution laws in category 2d to determine the iterate s inner digits if @xmath150 has been determined ; otherwise , the above process is repeated until @xmath150 is found .    if @xmath116 as in the rules in categories 2e and 2h , the ca is determining the leftmost digits of the iterate on row @xmath15 .",
    "observe that beyond the parity of this iterate , the rules in these categories are the same .    in this case , if @xmath137 , @xmath138 can be in any of three different states , namely ` 1- ` , ` 2- ` , ` 3-odd ` , and @xmath144 can be any base - four digit in either parity .",
    "certainly the state into which @xmath61 evolves , if not ` empty ` , must have the same parity as @xmath144 ( e.g. if @xmath118 , @xmath154 for some digit @xmath1 ) . in particular , @xmath155 , where @xmath156 equals 1 if @xmath157 and 0 otherwise ( see discussion of category 2d and 2 g rules below ) .    on the other hand ,",
    "if @xmath158 , @xmath142 must be in state @xmath159 as well , and @xmath160 can be any nonzero digit in either parity . here @xmath160 must be @xmath161 : otherwise , if we denote @xmath123 to be the iterate in row @xmath95 and @xmath96 to be that in row @xmath15 , we have that @xmath162 .",
    "therefore , @xmath115 .",
    "if none of the cells in the neighborhood of @xmath61 are in state ` empty ` as in the rules in category 2d and 2 g , the ca is determining the inner digits of the iterate on row @xmath15 .",
    "observe again that beyond the parity of this iterate , the rules in these categories are the same .",
    "each cell in the neighborhood can be any base - four digit , and the state of @xmath144 can have either the ` odd ` or ` even ` attribute , giving 64 evolution laws for both category 2d and 2 g . because @xmath163 , @xmath164 , where @xmath104 .",
    "certainly if @xmath165 , the subtraction @xmath166 was performed with a borrowing from @xmath135 , so in this case , @xmath167 .    if @xmath168 and @xmath169 , then @xmath170 .",
    "call this digit @xmath171 of the iterate on row @xmath95 . because @xmath168 , @xmath172 and there had to be a borrowing so that @xmath173 .",
    "continuing thus , we arrive at a contradiction , as the units digit of the iterate on row @xmath95 is nonzero .",
    "so if @xmath174 , the subtraction @xmath166 was performed with no borrowing from @xmath135 , meaning @xmath175 .",
    "this cellular automaton , most efficient and most easily implementable ca , acts on an infinite two - dimensional grid of square cells , each of which can take on one of three states  represented in figure  [ fig : basetwolaws ] by the corresponding colors in parentheses ` 0 ` ( dark gray ) , ` 1 ` ( light gray ) , or ` empty ` ( white ) .",
    "the initial state of the ca is defined to be such that all cells are in the state of `` empty . ''    again , let the rows be indexed top to bottom by @xmath13 and the columns right to left by @xmath14 , and denote the cell in the @xmath15th row and @xmath16th column by @xmath61 and its state in time period @xmath18 by @xmath107 .",
    "as shown in figure  [ fig : basetwoneighbor ] , the neighborhood of cell @xmath61 ( white ) is the set of cells @xmath176 ( dark gray ) .",
    "if input @xmath1 has binary representation @xmath177 and the smallest @xmath15 for which @xmath110 is @xmath111 , then the ca is initialized as follows : for an arbitrary @xmath2 and @xmath15 from @xmath111 to @xmath26 , we have @xmath112 and @xmath113 for all @xmath114 .        in figure",
    "[ fig : basetwolaws ] , each group of five cells represents one evolution law , with each cell playing the same role as it does in figure  [ fig : basetwoneighbor ] . in other words ,",
    "the bottom - left cell in each rule represents the cell that is transforming , and its color represents the future state into which it evolves given the states of its neighborhood .",
    "the colors of the remaining four cells represent the current states of the neighborhood that determine the state into which the bottom - left cell evolves .",
    "for example , the first of six evolution laws in category 3c should be interpreted to mean that @xmath178 if @xmath116 , @xmath179 and @xmath180 , and @xmath170 .    if a cell s neighborhood corresponds to one of the evolution laws ( figure  [ fig : basetwolaws ] ) , then that cell s state becomes the state of the cell as described in the evolution law .    if a cell s neighborhood does not correspond to any evolution law , then that cell s state becomes ` empty ` .",
    ", height=76 ]    in figure  [ fig : ca3inaction ] , if we treat the non - empty cells in each row as quaternary digits , ca3 gives a sequence of iterates : @xmath181 as we will prove , because ca3 mimics the following modified collatz map @xmath50 defined by @xmath182 where @xmath183 is the largest power of four dividing @xmath94 , by eliminating trailing zeroes .",
    "for every @xmath52 , there exists some @xmath15 so that after @xmath15 iterations of ca3 , the states of cells not in the state of ` empty ` in row @xmath2 correspond to the bits of @xmath184 , where @xmath1 is the input , for all @xmath54 .    like in base four , parity in binary is given by the parity of the units digit , but unlike ca2 , ca3 can mimic @xmath124 simply by representing trailing zeroes in an iterate as cells in the ` empty ` state .",
    "what remains is for the ca to mimic @xmath125 .",
    "this function is equivalent to @xmath185 and thus , roughly speaking , to adding the iterate to a copy of itself shifted left one place and right - appended with a digit of 1 .",
    "we will denote the cell in the bottom - left of each evolution law in figure  [ fig : basetwolaws ] , that is , the cell that is evolving , by @xmath61 , the current iterate by @xmath186 , and the iterate in the preceding row by @xmath187 .",
    "we will prove that the rules in categories 3a to 3d are exhaustive in mimicking @xmath125 .",
    "again , multiplication by two involves carries of at most one .    if @xmath130 but @xmath188 as in the rules in category 3b , the ca is determining the rightmost digits of the iterate on row @xmath15 . by design ,",
    "@xmath131 must be 1 , giving the first rule in category 2c . here , @xmath189 .",
    "there are then two choices ` 0 ` , ` 1` for @xmath134 , represented by @xmath135 in the next two rules in category 2c s left column . in these two cases , the state into",
    "which @xmath61 evolves is chosen so that @xmath190 if @xmath191 and , because ca3 treats trailing zeroes as empty cells , ` empty ` otherwise .    in the former case in which the position of @xmath192 has been determined",
    ", the ca then turns to evolution laws in category 3a to determine the inner digits of the iterate on row @xmath15 . in the latter case",
    "in which @xmath150 has not been determined , there are two possible values for @xmath134 , namely ` 0 ` , ` 1 ` , giving the bottom two evolution laws in category 3b . by our interpretation of @xmath0 as @xmath193 ,",
    "the state into which cell @xmath61 evolves is chosen so that @xmath194 where @xmath168 if @xmath195 and @xmath196 otherwise ( see discussion of category 3a rules below ) , provided that @xmath197 ; if not , @xmath115 because ca3 treats trailing zeroes as ` empty ` .",
    "again , in the former case in which the position of @xmath150 has been determined , the ca then turns to rules in category 3a to determine inner digits . in the latter case",
    "in which @xmath150 has not been determined , there are two possible values for @xmath198 , namely ` 0 ` , ` 1 ` , giving the top two evolution laws in category 3b s right column .",
    "the state into which @xmath61 evolves , either ` empty ` or ` 1 ` , is determined in the same way as above .",
    "one more , the ca turns to evolution laws in category 2d to determine the iterate s inner digits if @xmath150 has been determined ; otherwise , the above process is repeated until the position of @xmath150 is found .    if @xmath116 as in the rules in categories 3c and 3d , the ca is determining the leftmost digits of the iterate on row @xmath15 .    in this case , if @xmath137 , it represents @xmath199 and thus must be ` 1 `",
    "there are only two cases in which at least one of cells @xmath200 and @xmath144 is ` empty ` : i ) the iterate on row @xmath95 is of the form @xmath201 so that @xmath202 and the iterate on row @xmath15 is thus 1 , ii ) the iterate on row @xmath95 is @xmath203 so that the iterate on row @xmath15 is also 1 .",
    "these cases give rise to the first two rules of category 3d , respectively , where @xmath204 is ` empty ` rather than ` 0 ` because ca3 deletes trailing zeroes . the last rule of 3d then accounts for the case in which the iterate on row @xmath15 is 1 .",
    "beyond these two cases , if neither cell @xmath200 nor cell @xmath144 is in the ` empty ` state , there are two possible states for each , giving the first four rules in category 3c . here",
    ", the state into which @xmath61 evolves is again chosen so that @xmath205 where @xmath168 if @xmath195 and @xmath196 otherwise .",
    "on the other hand , if @xmath158 , @xmath206 represents @xmath199 .",
    "there are two possible non - empty states for cell @xmath207 ` 0 ` , ` 1` giving the last two rules in category 3c . in the former case ,",
    "@xmath61 must represent @xmath161 ; otherwise , if we denote this iterate to be @xmath96 and the preceding iterate to be @xmath94 , @xmath208 , a contradiction .",
    "therefore @xmath209 . in the latter case",
    ", @xmath144 must represent @xmath161 for the same reason , so @xmath178 .    finally ,",
    "if none of the cells in the neighborhood of @xmath61 are in state ` empty ` as in the rules in category 3a , the ca is determining the inner digits of the iterate .",
    "each of the cells in the neighborhood can be in any of two possible states , giving the sixteen rules in this category . because @xmath210 , @xmath211 , where @xmath104 .",
    "@xmath212 implies the addition @xmath213 was performed with a carry over to @xmath135 , so @xmath214 . on the other hand",
    ", @xmath215 implies there was no carry , and @xmath216 .",
    "call the _ @xmath1-efficiency _ of any of the above cas the number of iterates that have been computed by the ca upon reaching 1 given input @xmath1 , divided by the total stopping time of that input .",
    "the average @xmath1-efficiency over all @xmath1 such that @xmath217 was determined to be roughly 69.4% , 63.7% , and 32.2% for ca1 , ca2 , and ca3 , respectively .",
    "in addition , observe that it is not necessary to initialize any of these cas with only one input .",
    "in fact , these cas are able to compute the trajectories of an arbitrary number of inputs at a time . as an example , in the case of ca3 , let the set of inputs be @xmath218 , where input @xmath219 has binary representation @xmath220 such that the smallest @xmath15 for which @xmath110 is some @xmath221 .",
    "the ca is initialized as follows : pick an arbitrary @xmath222 . for all @xmath16 such that @xmath223 , let @xmath224 , where @xmath225 is chosen so that the trajectories of @xmath220 and @xmath226 do not collide on the grid . then for each @xmath16 such that @xmath227 , let@xmath228 for @xmath229 .",
    "let @xmath113 for all other pairs @xmath230 .",
    "note however , that the difficulty in initializing a ca to compute multiple trajectories in parallel this way lies in the unpredictability of the behavior of @xmath225 : it is not certain how large the space between two inputs must be for their trajectories not to collide .    as a workaround , if we place each iterate whose trajectory we want to compute on its own grid and , roughly speaking , stack those grids on top of one another to form an arbitrarily high three - dimensional grid of cubical cells , then this ca can verify multiple inputs in parallel .        in conclusion , we have found three cas that mimic the behavior of the collatz map in bases two , three , and four , and streamline the process of verification of the collatz conjecture by bypassing calculation of certain parts of the trajectory . beyond speeding the progress towards potentially finding a counterexample ,",
    "this work affords insights into the distribution of the @xmath231 residues of iterates , which may justify the existing heuristic probabilistic argument that trajectories tend to decrease [ 7 ] .",
    "topics for further study include applying the parallel computing model we propose to similar iterative computations , exploring whether it is possible to create evolution laws that depend entirely on digits from the previous iterate , and exploring other potentially viable radices for new cas . with regards to the latter",
    ", it is known that the distribution of @xmath232 is closely related to the `` sorting properties '' of the collatz map , that is , whether the function distributes odd iterates equally among the residues @xmath231 [ 3 ] .",
    "if no reasonable ca exists in base 3/2 , it could still be worth exploring possible cas for computing @xmath233 .",
    "implementations in java of ca2 and ca3 can be found at www.sitanchen.com/collatz4.html and www.sitanchen.com/collatz.html , respectively .",
    "21 oliveira e silva , t. ( 2010 ) .",
    "empirical verification of the @xmath0 and related conjectures . in `` _",
    "_ the ultimate challenge : the @xmath0 problem _ _ , '' ( edited by jeffrey c. lagarias),189 - 207 .",
    "kurtz , s. , simon , j. ( 2007 ) the undecidability of the generalized collatz problem .",
    "_ theory and applications of models of computation _",
    ", 4484 , 542 - 53 .",
    "lagarias , jeffrey c. ( 1985 ) .",
    "the 3x+1 problem and its generalizations . _ american mathematical monthly _ , 92 , 3 - 23 . de mol , liesbeth .",
    "tag systems and collatz - like functions .",
    "_ theoretical computer science _ , 390.1 , 92 - 101 .",
    "michel , pascal .",
    "small turing machines and generalized busy beaver competition .",
    "_ theoretical computer science _ 326.1 - 3 , 45 - 56 .",
    "bruschi , mario .",
    "two cellular automata for the @xmath0 map .",
    "_ arxiv_. retrieved 29 nov .",
    "2009 , from http://arxiv.org/ps_cache/nlin/pdf/0502/0502061v1.pdf ."
  ],
  "abstract_text": [
    "<S> the collatz , or @xmath0 , conjecture claims that for every positive integer @xmath1 , there exists some @xmath2 such that @xmath3 , where @xmath4 is the collatz map . </S>",
    "<S> we present three cellular automata ( ca ) that transform the global problem of mimicking the collatz map in bases 2 , 3 , and 4 into a local one of transforming the digits of iterates . </S>",
    "<S> the cas streamline computation first by bypassing calculation of certain parts of trajectories : the binary ca bypasses division by two altogether . </S>",
    "<S> in addition , they allow for multiple trajectories to be calculated simultaneously , representing both a significant improvement upon existing sequential methods of computing the collatz map and a demonstration of the efficacy of using a massively parallel approach with cellular automata to tackle iterative problems like the collatz conjecture </S>",
    "<S> . +   + _ keyphrases _ : collatz conjecture , massively parallel , deterministic computational model , cellular automata </S>"
  ]
}