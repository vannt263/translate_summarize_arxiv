{
  "article_text": [
    "exceptions form a _ computational effect _ , in the sense",
    "that a syntactic expression @xmath0 is not always interpreted as a function @xmath1 : for instance a function which raises an exception has to be interpreted as a function @xmath2 where @xmath3 is the set of exceptions . in a computer language",
    "usually exceptions differ from errors in the sense that it is possible to recover from an exception while this is impossible for an error ; thus , exceptions have to be both raised and handled . besides , the theory of _ diagrammatic logics _ forms a new paradigm for understanding the nature of computational effects ; in this paper , diagrammatic logics are applied to the denotational semantics of exceptions .    to our knowledge ,",
    "the first categorical treatment of computational effects is due to moggi @xcite ; this approach relies on _ monads _ , it is implemented in the programming language haskell @xcite .",
    "the examples proposed by moggi include the states monad @xmath4 where @xmath5 is the set of states and the exceptions monad @xmath6 where @xmath3 is the set of exceptions .",
    "later on , using the correspondence between monads and algebraic theories , plotkin and power proposed to use _ lawvere theories _ for dealing with the operations and equations related to computational effects , for instance the lookup and update operations for states and the raising and handling operations for exceptions @xcite . in the framework of lawvere theories ,",
    "an operation is called _ algebraic _ when it satisfies some relevant genericity properties ; the operations lookup and update for states and the operation for raising exceptions are algebraic in this sense , while the operation for handling exceptions is not @xcite .",
    "this difficulty can be overcome , as for instance in @xcite .",
    "nevertheless , from these points of view the handling of exceptions is inherently different from the updating of states .    in this paper",
    "we use another method for dealing with computational effects .",
    "this method has been applied to a parametrization process in @xcite and to the states effect in @xcite .",
    "it has led to the discovery of a duality between states and exceptions , briefly presented in @xcite .",
    "our approach also provides a notion of _ sequential product _",
    ", which is an alternative to the strength of a monad for imposing an evaluation order for the arguments of a @xmath7-ary function @xcite . with this point of view",
    "the fact that the handling operation for exceptions is not algebraic , in the sense of lawvere theories , is not an issue .",
    "in fact , the duality between the exceptions effect and the states effect @xcite implies that catching an exception is dual to updating a state .",
    "it should be noted that we distinguish the private operation of catching an exception from the public operation of handling it ( also called `` try / catch '' ) , which encapsulates the catching operation .",
    "our idea is to look at an effect as an apparent mismatch between syntax and semantics : there is one logic which fits with the syntax , another one which fits with the semantics , and a third one which reconciles syntax and semantics .",
    "this third logic classifies the language features and their properties according to the way they interact with the effect ; we call this kind of classification a _ decoration_. for this conciliation , as the features of the different logics are quite different in nature , we will use morphisms from the decorated logic to each of the two other logics , in a relevant category .",
    "this approach thus requires a robust framework for dealing with logics and morphisms between them .",
    "this is provided by the category of _ diagrammatic logics _",
    "the main ingredient for defining this category is the notion of categorical _ fraction _ , as introduced in @xcite for dealing with homotopy theory .",
    "fractions are defined with respect to an _",
    "adjunction_. the syntactic aspect of logics is obtained by assuming that this adjunction is induced by a morphism of _ limit sketches _",
    "@xcite , which implies that the adjunction connects _ locally presentable _ categories . for each diagrammatic logic",
    "we define _ models _ as relevant morphisms , _ inference rules _ as fractions and _ inference steps _ as composition of fractions .",
    "thus , diagrammatic logics are defined from well - known categorical ingredients ; their novelty lies in the importance given to fractions , in the categorical sense , for formalizing logics .",
    "the category of diagrammatic logics is introduced in section  [ sec : dialog ] . in section  [ sec : expl ] we look at exceptions from an _ explicit _ point of view , by introducing a type of exceptions in the return type of operations which may raise exceptions . with this explicit point of view",
    "we formalize ( by definition  [ defi : expl - model ] ) the intended semantics of exceptions as provided in the documentation of the computer language java @xcite and reminded in appendix  [ app : java ] .",
    "we also introduce the distinction between the core operations and their encapsulation : typically , between the catching and the handling of exceptions .",
    "this explicit point of view is expressed in terms of a diagrammatic logic denoted @xmath8 : the intended semantics of exceptions can be seen as a model with respect to @xmath8 .",
    "then in section  [ sec : deco ] we look at exceptions from a _ decorated _ point of view , which fits with the syntax much better than the explicit point of view , since the return type of operations does not mention any type of exceptions .",
    "the key point in this logic is that the operations and equations are decorated according to their interaction with exceptions .",
    "this decorated point of view corresponds to another diagrammatic logic denoted @xmath9 .",
    "we build a morphism of diagrammatic logics from @xmath9 to @xmath8 , called the _ expansion _ , from which our main result ( theorem  [ thm : deco - model ] ) follows : the intended semantics of exceptions can also be seen as a model with respect to @xmath9 .",
    "@xmath10^{\\txt{expansion } }        \\ar@{~>}[d]_(.4){\\txt{model}}_(.7){\\txt{(section~\\ref{sec : deco } ) } } &     { \\mathcal{l}}_{\\mathit{expl}}\\ar@{~>}[d]^(.4){\\txt{model}}^(.7){\\txt{(section~\\ref{sec : expl } ) } } \\\\",
    "\\txt{semantics } \\ar@{=}[r]_{\\txt{(theorem~\\ref{thm : deco - model } ) } } &        \\txt{semantics } \\\\     } \\ ] ] then we prove some properties of exceptions using the rules of the decorated logic and the duality between exceptions and states .",
    "we conclude in section  [ sec : conc ] with some remarks and guidelines for future work .",
    "this paper relies on the robust algebraic framework provided by the category of diagrammatic logics @xcite . in section  [ subsec : dialog - adjoint ] we provide an informal description of diagrammatic logics which should be sufficient for understanding most of sections  [ sec : expl ] and  [ sec : deco ] .",
    "let us also mention the paper @xcite for a detailed presentation of a simple application of diagrammatic logics .",
    "precise definitions of diagrammatic logics and their morphisms are given in section  [ subsec : dialog - dialog ] ; these definitions rely on the categorical notions of fractions and limit sketches .      in this section",
    "we give an informal description of diagrammatic logics and their morphisms ; the formal definitions will be given in section  [ subsec : dialog - dialog ] . in order to define a diagrammatic logic we have to distinguish its _ theories _ , which are closed under deduction , from its _ specifications _ , which are presentations of theories . on the one hand ,",
    "each specification generates a theory , by applying the _ inference rules _ of the logic : the specification is a family of axioms and the theory is the family of theorems which can be proved from these axioms , using the inference system of the logic . on the other hand ,",
    "each theory can be seen as a ( `` large '' ) specification .",
    "then , clearly , a _",
    "morphism _ of logics has to map specifications to specifications and theories to theories , in some consistent way .",
    "the diagrammatic logics we are considering in this paper are variants of the equational logic : their specifications are made of ( some kinds of ) sorts , operations and equations .",
    "each sort , operation or equation can be seen as a specification , hence every morphism of logics has to map it to a specification .",
    "however it is not required that a sort be mapped to a sort , an operation to an operation or an equation to an equation .",
    "thanks to this property , rather subtle relations between logics can be formalized by morphisms of diagrammatic logics . this is the case for the expansion morphism , see figure  [ fig : expansion ] .",
    "a diagrammatic logic is a left adjoint functor @xmath11 from a category @xmath12 of specifications to a category @xmath13 of theories , with additional properties that will be given in section  [ subsec : dialog - dialog ] .",
    "each specification generates a theory thanks to this functor @xmath11 and each theory can be seen as a specification thanks to the right adjoint functor @xmath14 .",
    "in addition , it is assumed that the canonical morphism @xmath15 is an isomorphism in @xmath13 , so that each theory @xmath16 can be seen as a presentation of itself .",
    "the fact that indeed the functor @xmath11 describes an _ inference system _ is due to additional assumptions on the adjunction @xmath17 , which are given in the next section .",
    "although this point will not be formalized , in order to understand the definition of the models of a specification it may be helpful to consider that one is usually interested in two kinds of theories : the theories @xmath18 which are generated by a `` small '' ( often finite ) specification @xmath19 , and the `` large '' theories @xmath16 which are provided by set theory , domain theory and other mathematical means , to be used as interpretation domains",
    ". however , formally this distinction is useless , and the _ models _ of any specification @xmath19 with values in any theory @xmath16 are defined as the morphisms from @xmath18 to @xmath16 in @xmath13 .",
    "thanks to the adjunction @xmath17 , there is an alternative definition which has a more constructive flavour : the _ models _ of @xmath19 with values in @xmath16 are the morphisms from @xmath19 to @xmath20 in @xmath12 .",
    "the definition of _ morphisms _ between diagrammatic logics derives in an obvious way from the definition of diagrammatic logics : a morphism @xmath21 is made of two functors @xmath22 and @xmath23 with relevant properties .    in this paper",
    "we consider several diagrammatic logics which are variants of the equational logic : the specifications are defined from sorts , operations and equations , and the inference rules are variants of the usual equational rules .",
    "exceptions form a _ computational effect _",
    ", in the sense that a syntactic expression @xmath0 may be interpreted as a function @xmath2 ( where @xmath3 is the set of exceptions ) instead of being interpreted as a function @xmath1 .",
    "we will define a logic @xmath9 for dealing with the syntactic expressions and another logic @xmath8 for dealing with exceptions in an explicit way by adding a sort of exceptions ( also denoted @xmath3 ) .",
    "the key feature of this paper is the _ expansion _",
    "morphism form the logic @xmath9 to the logic @xmath8 , which maps a syntactic expression @xmath0 to the expression @xmath24 in a consistent way .",
    "the notion of diagrammatic logic is an algebraic notion which captures some major properties of logics and which provides a simple and powerful notion of morphism between logics .",
    "each diagrammatic logic comes with a notion of models and it has a sound inference system .",
    "a category is _ locally presentable _ when it is equivalent to the category @xmath25 of set - valued models , or _",
    "realizations _ , of a limit",
    "sketch @xmath26 @xcite .",
    "the category @xmath25 has colimits and there is a canonical contravariant functor @xmath27 from @xmath26 to @xmath25 , called the _ contravariant yoneda functor _ associated with @xmath26 , such that @xmath28 generates @xmath25 under colimits , in the sense that every object of @xmath25 may be written as a colimit over a diagram with objects in @xmath28 .",
    "each morphism of limit sketches @xmath29 gives rise , by precomposition with @xmath30 , to a functor @xmath31 , which has a left adjoint @xmath32 @xcite .",
    "let @xmath27 and @xmath33 denote the contravariant yoneda functors associated with @xmath26 and @xmath34 , respectively .",
    "then @xmath32 extends @xmath30 , which means that @xmath35 up to a natural isomorphism .",
    "we call such a functor @xmath32 a _ locally presentable functor_. then the three following properties are equivalent : the counit @xmath36 is a natural isomorphism ; the right adjoint @xmath37 is full and faithful ; the left adjoint @xmath32 is ( up to an equivalence of categories ) a _ localization _ , i.e.",
    ", it consists of adding inverses to some morphisms from @xmath25 , constraining them to become isomorphisms in @xmath38 @xcite .",
    "then it can be assumed that @xmath30 is also a localization : it consists of adding inverses to some morphisms from @xmath26 .",
    "[ defi : dialog - dialog ] a _ diagrammatic logic _ is a locally presentable functor which is a localization , up to an equivalence of categories .",
    "it follows that a diagrammatic logic is a left adjoint functor such that its counit is a natural isomorphism : these properties have been used in section  [ subsec : dialog - adjoint ] .",
    "[ defi : dialog - logic - model ] let @xmath39 be a diagrammatic logic with right adjoint @xmath40 .",
    "* the category of _ @xmath11-specifications _ is @xmath12 . *",
    "the category of _ @xmath11-theories _ is @xmath13 .",
    "* a _ model _ of a specification @xmath19 with values in a theory @xmath16 is a morphism from @xmath18 to @xmath16 in  @xmath13 , or equivalently ( thanks to the adjunction ) a morphism from @xmath19 to @xmath20 in @xmath12 .",
    "the _ bicategory of fractions _ associated to @xmath11 has the same objects as @xmath12 and a morphism from @xmath41 to @xmath42 in this bicategory is a _ fraction _",
    "@xmath43 , which means that it is a cospan @xmath44 in @xmath12 such that @xmath45 is invertible in @xmath13",
    ". then @xmath46 is called the _ numerator _ and @xmath47 the _ denominator _ of the fraction @xmath48 .",
    "it follows that we can define @xmath49 .",
    "the composition of consecutive fractions is defined as the composition of cospans , using a pushout in @xmath12 .",
    "[ defi : dialog - logic - rule ] let @xmath39 be a diagrammatic logic with right adjoint @xmath40 .",
    "* a _ rule _ with _ hypothesis _",
    "@xmath50 and _ conclusion _ @xmath51 is a fraction from @xmath51 to @xmath50 with respect to @xmath11 . *",
    "an _ instance _ of a specification @xmath52 in a specification @xmath19 is a fraction from @xmath52 to @xmath19 with respect to @xmath11 . *",
    "the _ inference step _ applying a rule @xmath53 to an instance @xmath54 of @xmath50 in @xmath19 is the composition of fractions @xmath55 ; it yields an instance of @xmath51 in @xmath19 .",
    "[ defi : dialog - logic - proof ] let @xmath39 be a diagrammatic logic with right adjoint @xmath40 .",
    "* each morphism of limit sketches @xmath56 which gives rise to the adjunction @xmath17 and which is a localization is called an _ inference system _ for @xmath11 . *",
    "then a rule @xmath48 is _ elementary _ if @xmath46 and @xmath47 are the images , by the canonical contravariant functor @xmath27 , of arrows @xmath57 and @xmath58 in @xmath59 such that @xmath60 is invertible in @xmath61 ; otherwise the rule @xmath48 is _",
    "derivable_.    [ rem : fractions ] an inference rule is usually written as a fraction @xmath62 , it is indeed related to a categorical fraction , as follows ( however from the categorical point of view the numerator is on the conclusion side and the denominator on the hypothesis side ! ) .",
    "first let us remark that each @xmath63 can be seen as a specification , as well as @xmath51 , and that the common parts in the @xmath63 s and in @xmath51 are indicated by using the same names .",
    "then let @xmath50 be the vertex of the colimit of the @xmath63 s , amalgamated according to their common names .",
    "the fraction @xmath64 is defined as the pushout of @xmath50 and @xmath51 over their common names .",
    "then the rule @xmath62 corresponds to the categorical fraction @xmath65 ( see example  [ exam : dialog - meq ] ) . in an inference system @xmath56 for a logic @xmath11 , the limit sketch @xmath59 describes the syntax and the morphism @xmath30 provides the inference rules of @xmath11 .",
    "thus , the description of a diagrammatic logic via one of its inference systems can be done algebraically by defining @xmath30 or the image of @xmath30 by the canonical funtor @xmath27 ( examples can be found in @xcite ) .",
    "a diagrammatic logic can also be defined more traditionally by giving a grammar and a family of rules . moreover ,",
    "when the logic is simple enough , it may be sufficient in practice to describe its theories .",
    "[ exam : dialog - meq ] the monadic equational logic @xmath66 can be defined from its theories .",
    "a monadic equational theory is a category where the axioms hold only up to some congruence relation .",
    "precisely , a _",
    "monadic equational theory _ is a directed graph ( its vertices are called _ types _ and its edges are called _ terms _ ) with an _ identity _",
    "term @xmath67 for each type @xmath68 and a _ composed _",
    "term @xmath69 for each pair of consecutive terms @xmath70 ; in addition it is endowed with _ equations _",
    "@xmath71 that form an equivalence relation on parallel terms which is a _ congruence _ with respect to the composition and such that the associativity and identity axioms hold up to congruence .",
    "the category of sets forms a @xmath66-theory @xmath72 where types , terms and equations are the sets , functions and equalities .",
    "we can look at a rule , for instance the transitivity rule for equations @xmath73 , as a categorical fraction @xmath65 , as follows .",
    "@xmath74^{f } \\ar@/_/[r]_{h } & y \\\\ \\\\",
    "\\ar@{}[r]|{f\\equiv h } & \\\\   }   & \\xymatrix@=2pc{\\ar[r]^{{\\sigma } } & \\\\ }   & \\xymatrix@r=.2pc { x \\ar@/^/[r]^{f } \\ar[r]|{\\,g\\ , } \\ar@/_/[r]_{h } & y \\\\ \\\\",
    "\\ar@{}[r]|{f\\equiv g,\\ , g\\equiv h,\\ , f\\equiv h } & \\\\   }    & \\xymatrix@=2pc { & \\ar[l]_{\\tau } \\\\",
    "}   & \\xymatrix@r=.2pc { x \\ar@/^/[r]^{f } \\ar[r]|{\\,g\\ , } \\ar@/_/[r]_{h } & y \\\\ \\\\",
    "\\ar@{}[r]|{f\\equiv g,\\ , g\\equiv h } & \\\\   }     \\\\ \\cline{1 - 1 } \\cline{3 - 3 } \\cline{5 - 5 }   \\end{array}\\ ] ]    [ rem : doctrines ] diagrammatic logics generalize _ @xmath3-doctrines _ , in the sense of @xcite .",
    "let @xmath3 be a type of sketch , determined by what sorts of cones and cocones are allowed in the sketch .",
    "then @xmath3 determines a type of category , required to have all ( co)limits of the sorts of ( co)cones allowed by @xmath3 , and it determines a type of functor , required to preserve that sorts of ( co)limits . following @xcite , the _ @xmath3-doctrine _ is made of these sketches , categories and functors .",
    "each @xmath3-doctrine corresponds to a diagrammatic logic @xmath75 , where @xmath76 is the category of @xmath3-sketches ( with the morphisms of @xmath3-sketches ) , @xmath77 is the category of @xmath3-categories and @xmath3-functors , and @xmath78 is the left adjoint functor which maps each @xmath3-sketch to its _",
    "theory_. for instance the @xmath3-doctrine made of finite products sketches , cartesian categories and functors preserving finite products corresponds to the equational logic .",
    "an important feature of diagrammatic logics is their simple and powerful notion of morphism , which is a variation of the notion of morphism in an arrow category .",
    "[ defi : dialog - morphism ] given diagrammatic logics @xmath39 and @xmath79 , a _ morphism of diagrammatic logics _",
    "@xmath80 is made of two locally presentable functors @xmath81 and @xmath82 such that the square of left adjoints @xmath83 is induced by a commutative square of limit sketches .",
    "it follows that the right adjoints form a commutative square and that the left adjoints form a square which is commutative up to a natural isomorphim .",
    "this means that a morphism from @xmath11 to @xmath84 maps ( in a coherent way ) each specification of @xmath11 to a specification of @xmath84 and each proof of @xmath11 to a proof of @xmath84 .",
    "moreover , it is sufficient to check that each elementary specification ( i.e. , each specification in the image of the functor @xmath27 ) of @xmath11 is mapped to a specification of @xmath84 and that each elementary proof ( i.e. , each inference rule ) of @xmath11 is mapped to a proof of @xmath84 .",
    "the next result is the key point for proving theorem  [ thm : deco - model ] ; its proof is a straightforward application of the properties of adjunctions .",
    "[ prop : deco - morphism ] let @xmath85 be a morphism of diagrammatic logics and let @xmath86 be the right adjoint of @xmath87 .",
    "let @xmath19 be a @xmath11-specification and @xmath88 a @xmath84-theory .",
    "then there is a bijection , natural in @xmath19 and @xmath88 : @xmath89",
    "in this section we define a denotational semantics of exceptions which relies on the semantics of exceptions in java .",
    "syntax is introduced in section  [ subsec : expl - sig ] as a signature @xmath90 . the fundamental distinction between ordinary and exceptional values",
    "is discussed in section  [ subsec : expl - sem ] .",
    "sections  [ subsec : expl - expl ] and  [ subsec : expl - spec ] are devoted to the definitions of a logic with an explicit type of exceptions and a specification @xmath91 for exceptions with respect to this logic .",
    "then in section  [ subsec : expl - model ] the denotational semantics of exceptions is defined as a model of this specification .",
    "this is extended to higher - order constructions in section  [ subsec : expl - lambda ] .",
    "we often use the same notations for a feature in a signature and for its interpretation .",
    "so , the syntax of exceptions corresponds to the signature @xmath90 , while the semantics of exceptions is defined as a model of a specification @xmath91 .",
    "but the signature underlying @xmath91 is different form @xmath90 : this mismatch is due to the fact that the exceptions form a computational effect .",
    "the whole paper can be seen as a way to reconcile both points of view .",
    "this can be visualized by figure  [ fig : expl - syn - sem ] , with the signature for exceptions @xmath90 on one side and the specification @xmath91 with its model @xmath92 on the other side ; the aim of section  [ sec : deco ] will be to fill the gap between @xmath90 and @xmath91 by introducing new features in the middle , see figure  [ fig : deco - syn - sem ] .",
    "@xmath93^{m_{\\mathit{expl } } } \\\\ \\\\ \\\\    & & { \\theta}_{{\\mathit{expl } } }   \\\\      }   \\\\",
    "\\hline   \\end{array}\\ ] ]      the syntax for exceptions in computer languages depends on the language : the keywords for raising exceptions may be either ` raise ` or ` throw ` , and for handling exceptions they may be either ` handle ` , ` try - with ` or ` try - catch ` , for instance . in this paper",
    "we rather use ` throw ` and ` try - catch ` .",
    "more precisely , the syntax of our language may be described in two parts : a _ pure _ part and an _ exceptional _ part .",
    "the pure part is a signature @xmath94 .",
    "the interpretation of the pure operations should neither raise nor handle exceptions .",
    "for simplicity we assume that the pure operations are either constants or unary ; general @xmath7-ary operations will be mentioned in section  [ sec : conc ] .",
    "the signature @xmath90 for exceptions is made of @xmath94 together with the types and operations for raising and handling exceptions . in order to deal with several types of exceptions which can be parameterized",
    ", we introduce a set of indices @xmath95 and for each index @xmath96 we choose a pure type @xmath97 called the _ type of parameters _ for the exceptions of index @xmath98 .",
    "the new operations in @xmath90 are the operations for raising and handling operations , as follows .",
    "[ defi : expl - sig ] let @xmath94 be a signature . given a set of indices @xmath95 and a type @xmath97 of @xmath94 for each @xmath96 , the _ signature for exceptions _ @xmath90 is made of @xmath94 together with , for each @xmath96 : a _ raising _ ( or _ throwing _ ) operation for each type @xmath99 in @xmath94 : @xmath100 and a _ handling _ ( or _ try - catch _ ) operation for each @xmath90-term @xmath0 , each non - empty list of indices @xmath101 in @xmath95 and each family of @xmath90-terms @xmath102 ,  , @xmath103 : @xmath104    [ rem : meaning ] the precise meaning of these operations is defined in section  [ subsec : expl - model ] . roughly speaking , relying for instance on java",
    "see appendix  [ app : java ] , raising an exception signals an error , which may be `` catched '' by an exception handler , so that the evaluation may go on along another path . for raising an exception , @xmath105 turns some parameter of type @xmath97 into an exception of index @xmath98 , in such a way that this exception is considered as being of type @xmath99 . for handling an exception ,",
    "the evaluation of @xmath106 begins with the evaluation of @xmath107 ; if the result is not an exception then it is returned ; if the result is an exception of index @xmath98 then this exception is catched , which means that its parameter is recovered and @xmath108 is applied to this parameter ; otherwise the exception is returned , which usually produces an error message like `` uncaught exception  '' .",
    "the evaluation of @xmath109 for any @xmath110 is similar ; it is checked whether the exception returned by @xmath107 has index @xmath111 or @xmath112  or @xmath113 in this order , so that whenever @xmath114 with @xmath115 the clause @xmath116 is never executed .      in order to express the denotational semantics of exceptions ,",
    "a major point is the distinction between two kinds of values : the ordinary ( or non - exceptional ) values and the exceptions .",
    "it follows that the operations may be classified according to the way they may , or may not , interchange these two kinds of values : an ordinary value may be _ tagged _ for constructing an exception , and later on the tag may be cleared in order to recover the value ; then we say that the exception gets _",
    "untagged_. let us introduce a set @xmath3 called the _ set of exceptions_. for each set @xmath68 we consider the disjoint union @xmath117 .",
    "the denotational semantics of exceptions relies on the following facts .",
    "each type @xmath68 in @xmath90 is interpreted as a set  @xmath68 .",
    "each term @xmath0 is interpreted as a function @xmath2 , and whenever @xmath107 is pure this function has its image in @xmath99 .",
    "the fact that a term @xmath0 is not always interpreted as a function @xmath1 implies that the exceptions form a _",
    "computational effect_.    [ defi : expl - fcts ] for each set @xmath68 , an element of @xmath117 is an _ ordinary value _ if it is in @xmath68 and an _ exceptional value _ if it is in @xmath3 .",
    "a function @xmath2 or @xmath118 _ raises an exception _ if there is some @xmath119 such that @xmath120 and @xmath107 _ recovers from an exception _ if there is some @xmath121 such that @xmath122 . a function @xmath118 _ propagates exceptions _ if @xmath123 for every @xmath121 .",
    "clearly , a function @xmath118 which propagates exceptions may raise an exception but can not recover from an exception .",
    "such a function @xmath107 is characterized by its restriction @xmath124 .",
    "in addition , every function @xmath125 can be extended in a unique way as a function @xmath118 which propagates exceptions ; then @xmath126 is the composition of @xmath127 with the inclusion of @xmath99 in @xmath128 .",
    "[ rem : ppg ] an important feature of a language with exceptions is that the interpretation of every term is a function which propagates exceptions ; _ this function may raise exceptions but it can not recover from an exception . _ indeed , the _ catch _ block in a _ try - catch _",
    "expression may recover from exceptions which are raised inside the _ try _ block , but if an exception is raised before the _ try - catch _",
    "expression is evaluated , this exception is propagated .",
    "thus , the _ untagging _ functions that will be introduced in section  [ subsec : expl - expl ] in order to recover from exceptions are not the interpretation of any term of the signature @xmath90 .",
    "in fact , this is also the case for the _ tagging _ functions that will be used for raising exceptions .",
    "these tagging and untagging functions are called the _ core _ functions for exceptions ; they are _ private _ in the sense that they do not appear in @xmath90 , but they are used for defining the _ public _ operations for raising and handling exceptions which are part of @xmath90 .",
    "let us define a logic with a type of exceptions by describing its theories .",
    "[ defi : expl - dialog ] a theory of the _ explicit logic for exceptions _",
    "@xmath8 is a monadic equational theory ( as in example  [ exam : dialog - meq ] ) with a distinguished type @xmath3 called the _ type of exceptions _ and with a cocone @xmath129 for each type @xmath68 , which satisfies the coproduct universal property up to congruence : for every cocone @xmath130 there is a term @xmath131}:x+e\\to y$ ] , unique up to equations , such that @xmath131}\\circ { \\mathit{normal}}_x \\equiv f$ ] and @xmath131}\\circ { \\mathit{abrupt}}_x \\equiv k$ ] .",
    "[ defi : expl - set ]",
    "let @xmath3 denote a set , then @xmath132 denotes the @xmath8-theory where types , terms and equations are the sets , functions and equalities , where @xmath3 is the set of exceptions and where for each set @xmath68 the cocone @xmath133 is the disjoint union .    [",
    "rem : expl - empt ] in addition , it can be assumed that there is an initial type @xmath134 ( up to congruence ) in each explicit theory , hence a unique term @xmath135}}_x:{\\mathbb{0}}\\to x$ ] for each type @xmath68 such that the cocone @xmath136}}_x)$ ] is a coproduct up to congruence .",
    "in order to express the meaning of the raising and handling operations we introduce new operations ( called the _ core",
    "_ operations ) and equations in such a way that the functions for raising and handling exceptions are now defined in terms of the core operations .",
    "[ defi : expl - spec ] let @xmath94 be a signature . given a set of indices @xmath95 and a type @xmath97 in @xmath94 for each @xmath96 , the _ explicit specification for exceptions _",
    "@xmath91 is the @xmath8-specification made of @xmath94 together with for each @xmath96 : an operation @xmath137 called the _",
    "exception constructor _ or the _ tagging _ operation of index @xmath98 and an operation @xmath138 called the _ exception recovery _ or the _ untagging _ function of index @xmath98 , together with the equations @xmath139 and @xmath140 for all @xmath141 .",
    "then for each @xmath96 the raising and handling functions are respectively defined using these two core operations as follows : the _ raising _ function @xmath142 for each type @xmath99 in @xmath94 is : @xmath143 and the _ handling _ function : @xmath144 for each term @xmath24 , each non - empty list of indices @xmath101 and each terms @xmath145 for @xmath146 is defined in two steps :    ( try ) : :    the function @xmath147 is    defined for any function @xmath148 by :    @xmath149 } \\circ f\\ ] ] ( catch ) : :    the function    @xmath150    is obtained by setting @xmath151 in the family of functions    @xmath152    ( for @xmath153 ) which are defined recursively by :    @xmath154 } \\circ c_{i_p } & \\mbox { when } p\\leq n \\\\",
    "\\end{cases}\\ ] ]    when @xmath155 we get simply : @xmath156 } \\circ c_i                \\bigr ] } \\circ f\\ ] ] which can be illustrated as follows , with @xmath157 on the left and @xmath158 on the right : @xmath159_{{\\mathit{normal } } } \\ar[rrrd]^{{\\mathit{normal } } } & & & \\\\    x \\ar[r]^{f } &       y+e \\ar[rrr]^(.4){{\\left [ { \\mathit{normal}}| k   \\right ] } } &      \\ar@{}[ul]|(.4){= } \\ar@{}[dl]|(.4){= } & & y+e \\\\     & e \\ar[u]^{{\\mathit{abrupt } } } \\ar[rrru]_{k } & & & \\\\    } \\qquad       \\xymatrix@c=2pc@r=1.5pc {    & p_i \\ar[d]_{{\\mathit{normal } } } \\ar[rrrd]^{g } & & & \\\\    e \\ar[r]^(.4){c_i } &       p_i+e         \\ar[rrr]^(.4){{\\left [ g|{\\mathit{abrupt}}\\right ] } } &      \\ar@{}[ul]|(.4){= } \\ar@{}[dl]|(.4){= } & & y+e \\\\     & e \\ar[u]^{{\\mathit{abrupt } } } \\ar[rrru]_{{\\mathit{abrupt } } } & & & \\\\    } \\ ] ]    about the handling function @xmath109 , it should be noted that each @xmath160 may itself raise exceptions and that the indices @xmath161 form a list : they are given in this order and they need not be pairwise distinct .",
    "it is assumed that this list is non - empty because it is the usual choice in programming languages , however it would be easy to drop this assumption .      as usual , a _ @xmath162-algebra _",
    "@xmath163 , for any signature @xmath162 , is made of a set @xmath164 for each type @xmath68 in @xmath162 and a function @xmath165 for each operation @xmath166 .",
    "as in definition  [ defi : expl - spec ] , let @xmath94 be a signature and let @xmath91 be the explicit specification for exceptions associated to a family of pure types @xmath167 .",
    "[ defi : expl - mod ] given a @xmath94-algebra @xmath168 , the _ model of exceptions _ @xmath92 of @xmath91 extending @xmath168 has its values in @xmath132 ; it coincides with @xmath168 on @xmath94 , it interprets the type @xmath3 as the disjoint union @xmath169 and the tagging operations @xmath137 as the inclusions .",
    "it follows that the interpretation of the tagging operation maps a non - exceptional value @xmath170 to an exception @xmath171 ( for clarity we keep the notation @xmath172 instead of @xmath173 ) .",
    "then , because of the equations , the interpretation of the untagging operation @xmath174 must proceed as follows : it checks whether its argument @xmath175 is in the image of @xmath176 , if this is the case then it returns the parameter @xmath170 such that @xmath177 , otherwise it propagates the exception  @xmath175 .",
    "it is easy to check that the next definition corresponds to the description of the mechanism of exceptions in java : see remark  [ rem : meaning ] and appendix  [ app : java ] .",
    "[ defi : expl - model ] given a signature @xmath94 and a @xmath94-algebra @xmath168 , the _ intended semantics of exceptions _ is the model @xmath92 of the specification @xmath91 extending @xmath168 .",
    "[ rem : expl - model ] let @xmath90 be the signature for exceptions as in definition  [ defi : expl - sig ] .",
    "it follows from definition  [ defi : expl - model ] that the intended semantics of exceptions can not be seen as a @xmath90-algebra . indeed ,",
    "although there is no type of exceptions in @xmath90 , the operation @xmath178 in @xmath90 has to be interpreted as a function @xmath179 , where the set of exceptions @xmath3 is usually non - empty .      definition  [ defi : expl - model ] can easily be extended to a functional language . in order to add higher - order features to our explicit logic ,",
    "let us introduce a functional type @xmath180 for each types @xmath181 and @xmath182 .",
    "then each @xmath183 gives rise to @xmath184 , which does not raise exceptions .",
    "it follows that @xmath185 , which is the intended meaning of exceptions in functional languages like ml @xcite .",
    "according to definition  [ defi : expl - model ] , the intended semantics of exceptions can be defined in the explicit logic as a model @xmath92 of the explicit specification @xmath91 . however , by introducing a type of exceptions , the explicit logic does not take into account the fact that the exceptions form a computational effect : the model @xmath92 can not be seen as an algebra of the signature @xmath90 for exceptions ( definition  [ defi : expl - sig ] ) since ( denoting @xmath68 for @xmath186 for each type @xmath68 ) the operation @xmath178 is interpreted as a function from @xmath187 to @xmath128 instead of from @xmath187 to @xmath99 : this is a fundamental remark of moggi in @xcite .    in this section",
    "we build another logic @xmath9 , called the _ decorated _ logic for exceptions , and a decorated specification @xmath188 for exceptions which reconciles the syntax and the semantics : @xmath188 fits with the syntax since it has no type of exceptions , and it provides the intended semantics because this semantics can be seen as a model @xmath189 of @xmath188 . in the decorated logic",
    "the terms and the equations are classified , or _ decorated _ , and their interpretation depends on their decoration .",
    "the decorated logic is defined in section  [ subsec : deco - deco ] . in section  [ subsec : deco - spec ]",
    "we define the decorated specification @xmath188 and the model @xmath189 of @xmath188 and we prove that @xmath189 provides the intended semantics of exceptions . besides , we show in section  [ subsec : deco - app ] that it is easy to relate the decorated specification @xmath188 to the signature for exceptions @xmath90 ; for this purpose we introduce a logic @xmath190 , called the _ apparent _ logic , which is quite close to the monadic equational logic .",
    "this is illustrated by figure  [ fig : deco - syn - sem ] , which extends figure  [ fig : expl - syn - sem ] by filling the gap between syntax and semantics .",
    "this is obtained by adding two morphisms of logic , @xmath191 on the syntax side and @xmath192 on the semantics side .",
    "the rules of the decorated logic are used for proving some properties of exceptions in section  [ subsec : deco - proof ] .",
    "the decorated logic is extended to higher - order features in section  [ subsec : deco - lambda ] .",
    "@xmath193 & \\\\    & \\txt { \\textbf{semantics } } \\ar@{<=>}[r ] & \\txt { \\textbf{semantics } } \\\\    \\qquad\\quad { \\mathcal{l}}_{\\mathit{app } } &       { \\mathcal{l}}_{\\mathit{deco}}\\ar[l]_{f_{d } } \\ar[r]^{f_{e } } &       { \\mathcal{l}}_{\\mathit{expl}}\\\\ \\\\    { \\mathit{sig}}_{\\mathit{exc}}\\subseteq { \\sigma}_{\\mathit{app } } &       { \\sigma}_{\\mathit{deco}}\\ar@{|->}[l]_{f_{d } } \\ar@{|->}[r]^{f_{e } } \\ar[ddd]_{m_{\\mathit{deco } } } &       { \\sigma}_{\\mathit{expl}}\\ar[ddd]^{m_{\\mathit{expl } } } \\\\ \\\\ \\\\    & { \\theta}_{{\\mathit{deco } } } &    { \\theta}_{{\\mathit{expl } } } \\ar@{|->}[l]_{g_{e } } \\\\      }   \\\\",
    "\\hline    \\end{array}\\ ] ]      here we define the decorated logic for exceptions @xmath9 , by giving its syntax and its inference rules , and we define a morphism from @xmath9 to @xmath8 for expliciting the meaning of the decorations .",
    "the syntax of @xmath9 consists in types , terms and equations , like @xmath66 in example  [ exam : dialog - meq ] , but with three kinds of terms and two kinds of equations .",
    "the terms are decorated by @xmath194 , @xmath195 and @xmath196 used as superscripts , they are called respectively _ pure _ terms , _ propagators _ and _ catchers_. the equations are denoted by two distinct relational symbols , @xmath197 for _ strong _ equations and @xmath198 for _ weak _ equations .",
    "the _ expansion _ functor is the locally presentable functor @xmath199 defined in figure  [ fig : expansion ] by mapping each elementary decorated specification ( type , decorated term , decorated equation ) to an explicit specification .",
    "note : in the explicit specifications the type of exceptions @xmath3 may be duplicated for readability , and the superscript @xmath200 stands for any decoration .",
    "thus , the expansion provides a meaning for the decorations :    @xmath194 : :    a _ pure _ term may neither raise exceptions nor recover form    exceptions , @xmath195 : :    a _ propagator _ may raise exceptions but is not allowed to recover from    exceptions , @xmath196 : :    a _ catcher _ may raise exceptions and recover form exceptions . @xmath201",
    ": :    a _ strong _ equation is an equality of functions both on ordinay values    and on exceptions @xmath202 : :    a _ weak _ equation is an equality of functions only on ordinay values ,    maybe not on exceptions .",
    "[ rem : for - short ] it happens that the image of a decorated term by the expansion morphism can be characterized by a term , so that we can say `` for short '' that the expansion of a catcher @xmath203 `` is '' @xmath204 , the expansion of a propagator @xmath205 `` is '' @xmath206 where @xmath207 , and the expansion of a pure term @xmath208 `` is '' @xmath125 . in a similar way",
    ", we say that the expansion of a type @xmath182 `` is '' @xmath182 .",
    "this is stated in the last column of figure  [ fig : expansion ] .",
    "however this may lead to some misunderstanding . indeed , while the image of a specification by the expansion morphism must be a specification , the image of a type does not have to be a type and the image of a term does not have to be a term .",
    "@xmath209^{{\\mathit{normal } } }   \\\\",
    "z+e    \\\\ e \\ar[u]_{{\\mathit{abrupt } } }   \\\\ }   & \\xymatrix@r=.5pc { \\\\   z   \\\\ } \\\\ \\hline   \\mbox{catcher } &   \\xymatrix@r=.5pc { \\\\   x \\ar[r]^{f^{{(2 ) } } } & y \\\\ } &   \\xymatrix@r=.5pc { x \\ar[d ] & y \\ar[d ] \\\\",
    "x+e \\ar[r]^{f } & y+e   \\\\ e \\ar[u ] & e \\ar[u ] \\\\ } & \\xymatrix@r=.5pc@c=3pc { \\\\",
    "x+e \\ar[r]^{f } & y+e \\\\ }    \\\\",
    "\\hline   \\mbox{propagator } &   \\xymatrix@r=.5pc { \\\\   x \\ar[r]^{f^{{(1 ) } } } & y \\\\ } &   \\xymatrix@r=.5pc { x \\ar[d ] & y \\ar[d ] \\\\ x+e \\ar[r]^{f } & y+e   \\\\",
    "e \\ar[u ] \\ar[r]_{{\\mathit{id } } } \\ar@{}[ru]|{\\equiv } & e \\ar[u ] \\\\ } & \\xymatrix@r=.5pc@c=5pc { \\\\   x \\ar[r]^{f_1=f\\;\\circ\\;{\\mathit{normal } } } & y+e \\\\ }    \\\\",
    "\\hline   \\mbox{pure term } &   \\xymatrix@r=.5pc { \\\\   x \\ar[r]^{f^{{(0 ) } } } & y \\\\ } &   \\xymatrix@r=.5pc { x \\ar[d ] \\ar[r]^{f_0 } \\ar@{}[rd]|{\\equiv } & y \\ar[d ] \\\\",
    "x+e \\ar[r]^(.6){f } & y+e   \\\\ e \\ar[u ] \\ar[r]_{{\\mathit{id } } } \\ar@{}[ru]|{\\equiv } & e \\ar[u ] \\\\ } & \\xymatrix@r=.5pc@c=5pc { \\\\   x \\ar[r]^{f_0 } & y \\\\ }    \\\\",
    "\\hline   \\mbox{strong equation } &   \\begin{array}{l } f^{{(d)}}{\\equiv}g^{{(d ) } } : \\\\",
    "\\qquad x \\to y \\end{array } & \\begin{array}{l } f\\equiv g : \\\\     \\qquad x+e \\to y+e \\end{array } &   f\\equiv g \\\\",
    "\\hline   \\mbox{weak equation } &   \\begin{array}{l } f^{{(d)}}{\\sim}g^{{(d ) } } : \\\\    \\qquad x \\to y \\end{array } & \\begin{array}{l } f\\circ{\\mathit{normal}}_x \\equiv g\\circ{\\mathit{normal}}_x : \\\\",
    "\\qquad x \\to y+e \\end{array } &   f_1\\equiv g_1 \\\\ \\hline   \\end{array}\\ ] ]    @xmath210      +   +   +   +   +   +   +   +   +   +   +   +   +   +   +   +   +   +    @xmath210    the rules of @xmath9 are given in figure  [ fig : rules ] .",
    "the decoration properties are often grouped with other properties : for instance , `` @xmath211 '' means `` @xmath212 and @xmath213 and @xmath214 '' ; in addition , the decoration @xmath196 is usually dropped , since the rules assert that every term can be seen as a catcher . according to definition  [ defi : dialog - morphism ] , the expansion morphism maps each inference rule of @xmath8 to a proof in @xmath8",
    "; this provides the meaning of the decorated rules :    \\(a ) the first part of the decorated monadic equational rules for exceptions are the rules for the monadic equational logic ; this means that the catchers satisfy the monadic equational rules with respect to the strong equations .",
    "\\(b ) the second part of the decorated monadic equational rules for exceptions deal with the conversions between decorations and with the equational - like properties of pure operations , propagators and weak equations .",
    "every strong equation is a weak one while every weak equation between propagators is a strong one .",
    "weak equations do not form a congruence since the substitution rule holds only when the substituted term is pure .",
    "\\(c ) the rules for the propagation of exceptions build a propagator @xmath215 from any catcher @xmath216 .",
    "the expansion of @xmath215 is defined as @xmath217}:x+e\\to y+e$ ] : it coincides with the expansion of @xmath216 on @xmath68 and it propagates exceptions without catching them , otherwise .",
    "\\(d ) the rules for a decorated initial type @xmath134 together with the rules in ( b ) imply that every propagator from @xmath134 to any @xmath68 is strongly equivalent to @xmath135}}_x$ ] .",
    "the expansion of @xmath134 and @xmath135}}_x^{{(0)}}$ ] are the initial type @xmath134 and the term @xmath135}}_x$ ] , respectively , as in remark  [ rem : expl - empt ] .",
    "\\(e ) the pure coproduct ( @xmath218}}_x$ ] ) has decorated coproduct properties which are given by the rules for the case distinction with respect to @xmath219 .",
    "the expansion of @xmath220}^{{(2 ) } } : x\\to y$ ] is the case distinction @xmath221 } : x+e\\to y+e$ ] with respect to @xmath117 ( where @xmath222 is identified with @xmath3 , so that @xmath223 ) .",
    "this can be illustrated as follows , by a diagram in the decorated logic ( on the left ) or in the explicit logic ( on the right ) ; more details are given in remark  [ rem : expansion ] .",
    "@xmath224_(.4){{\\mathit{id}}^{{(0 ) } } } \\ar[rrrd]^{g^{{(1 ) } } } & & & \\\\    x \\ar[rrr]^(.4){{\\left [ g|k \\right]}^{{(2 ) } } } &      \\ar@{}[ul]|(.4){{\\sim } } \\ar@{}[dl]|(.4){{\\equiv } } & & y \\\\     { \\mathbb{0}}\\ar[u]^{{{\\left [ \\ , \\right]}}^{{(0 ) } } } \\ar[rrru]_{k^{{(2 ) } } } & & & \\\\    }",
    "\\qquad\\qquad \\xymatrix@c=2pc@r=1.5pc {    x \\ar[d]_{{\\mathit{normal } } } \\ar[rrrd]^{g_1 } & & & \\\\    x+e \\ar[rrr]^(.4){{\\left [ g_1| k   \\right ] } } &      \\ar@{}[ul]|(.4){\\equiv } \\ar@{}[dl]|(.4){\\equiv } & & y+e \\\\     e \\ar[u]^{{\\mathit{abrupt } } } \\ar[rrru]_{k } & & & \\\\    } \\ ] ]    \\(f ) the rules for a constitutive coproduct build a catcher from a family of propagators .",
    "whenever @xmath225 is a constitutive coproduct the family @xmath226 is a coproduct with respect to the explicit logic .",
    "[ rem : expansion ] let us give some additional information on the expansion of the decorated rules ( e ) in figure  [ fig : rules ] , i.e. , the decorated rules for case distinction with respect to @xmath219 . according to the definition of the expansion morphism on specifications ( figure  [ fig : expansion ] ) since the cocone @xmath227}}_x^{{(0)}})$ ]",
    "is made of pure terms , we can say `` for short '' that its expansion `` is '' simply @xmath228}}_{x,0})$ ] . however in order to check that the decorated rules ( e ) in figure  [ fig : rules ] are mapped by the expansion morphism to explicit proofs we have to take into account another coproduct in the explicit logic .",
    "rules ( e ) state that _ for each propagator @xmath229 and each catcher @xmath230 there is a catcher @xmath231 ( @xmath232 is denoted @xmath220 } $ ] in figure  [ fig : rules ] ) such that @xmath233 and @xmath234}}_x { \\equiv}k$ ] , and that in addition @xmath232 is , up to strong equivalence , the unique catcher satisfying these conditions . _",
    "thus , according to figure  [ fig : expansion ] , the expansion of these rules must be such that _ for each terms @xmath235 and @xmath223 there is a term @xmath236 such that @xmath237 and @xmath238 , and that in addition @xmath232 is , up to equivalence , the unique term satisfying these conditions .",
    "_ clearly , this is satisfied when @xmath239}$ ] is obtained by case distinction with respect to the coproduct @xmath129 .",
    "it follows that we can also say , `` for short '' , that the image of the coproduct @xmath240}}_x)$ ] by the expansion morphism `` is '' the coproduct @xmath129 , as in diagram  ( [ diag : expansion ] ) .",
    "the decorated rules are now used for proving a lemma that will be used in section  [ subsec : deco - spec ] .",
    "[ lem : coprod - cotu ] for each propagator @xmath229 we have @xmath241}}_x { \\equiv}{{\\left [ \\ , \\right]}}_y$ ] and @xmath242}}_y \\right]}$ ] .    in these",
    "proofs the labels refer to the kind of rules which are used : either @xmath243 , @xmath244 , @xmath245 or @xmath246 .",
    "first , let us prove that @xmath241}}_x { \\equiv}{{\\left [ \\ , \\right]}}_y$ ] :    this first result is the unique non - obvious part in the proof of @xmath247}}_y \\right]}$ ] :    [ rem : sketches ] the morphism of limit sketches @xmath56 which induces the decorated logic is easily guessed .",
    "this is outlined below , more details are given in a similar exercice in @xcite .",
    "the description of @xmath59 can be read from the second column of figure  [ fig : expansion ] .",
    "there is in the limit sketch @xmath59 a point for each elementary decorated specification and an arrow for each morphism between the elementary specifications , in a contravariant way .",
    "for instance @xmath59 has points _ type _ and _ catcher _ , and it has arrows _ source _ and _ target _ from _ catcher _ to _ type _ , corresponding to the morphisms from the decorated specification @xmath182 to the decorated specification @xmath203 which map @xmath182 respectively to @xmath68 and @xmath99 . as usual , some additional points , arrows and distinguished cones are required in @xmath59 .",
    "the description of @xmath30 can be read from figure  [ fig : rules ] .",
    "the morphism @xmath30 adds inverses to arrows in @xmath59 corresponding to the inference rules , in a way similar to example  [ exam : dialog - meq ] but in a contravariant way .",
    "[ rem : dual ] in the short note @xcite it is checked that , from a denotational point of view , the functions for tagging and untagging exceptions are respectively _ dual _ , in the categorical sense , to the functions for looking up and updating states .",
    "this duality relies on the fact that the states are _ observed _ thanks to the lookup operations while dually the exceptions are _ constructed _ thanks to the tagging operations .",
    "thus , the duality between states and exceptions stems from the duality between the comonad @xmath248 ( for some fixed @xmath5 ) and the monad @xmath117 ( for some fixed @xmath3 ) .",
    "it happens that this duality also holds from the decorated point of view .",
    "most of the decorated rules for exceptions are dual to the decorated rules for states in @xcite .",
    "for instance , the unique difference between the monadic equational rules for exceptions ( parts ( a ) and ( b ) of figure  [ fig : rules ] ) and the dual rules for states in @xcite lies in the congruence rules for the weak equations : for states the replacement rule is restricted to pure @xmath108 , while for exceptions it is the substitution rule which is restricted to pure @xmath107 .",
    "the rules for a decorated initial type and for a constitutive coproduct ( parts ( d ) and ( f ) of figure  [ fig : rules ] ) are respectively dual to the rules for a decorated final type and the rules for an observational product in @xcite . the rules for the propagation of exceptions and for the case distinction with respect to @xmath219 ( parts ( c ) and ( e ) of figure  [ fig : rules ] ) are used only for the construction of the handling operations from the untagging operations",
    "; these rules have no dual in @xcite for states .",
    "[ rem : monad ] for a while , let us forget about the three last families of rules in figure  [ fig : rules ] , which involve some kind of decorated coproduct .",
    "then any monad @xmath249 on any category @xmath250 provides a decorated theory @xmath251 , as follows .",
    "the types are the objects of @xmath250 , a pure term @xmath208 is a morphism @xmath0 in @xmath250 , a propagator @xmath205 is a morphism @xmath252 in @xmath250 , a catcher @xmath203 is a morphism @xmath253 in @xmath250 .",
    "the conversion from pure to propagator uses the unit of @xmath249 and the conversion from propagator to catcher uses the multiplication of @xmath249 .",
    "composition of propagators is done in the kleisli way .",
    "a strong equation @xmath254 is an equality @xmath255 in @xmath250 and a weak equation @xmath256 is an equality @xmath257 in @xmath250 , where @xmath258 is the unit of the monad .",
    "it is easy to check that the decorated monadic equational rules of @xmath9 are satisfied , as well as the rules for the propagation of exceptions if @xmath259 for each @xmath260 .",
    "let us define a decorated specification @xmath188 for exceptions , which ( like @xmath91 in section  [ subsec : expl - spec ] ) defines the raising and handling operations in terms of the core tagging and untagging operations .",
    "[ defi : deco - spec ] let @xmath94 be a signature .",
    "given a set of indices @xmath95 and a type @xmath97 in @xmath94 for each @xmath96 , the _ decorated specification for exceptions _",
    "@xmath188 is the @xmath9-specification made of @xmath94 with its operations decorated as pure together with , for each @xmath96 , a propagator @xmath261 and a catcher @xmath262 with the weak equations @xmath263 and @xmath264}}\\circ t_j : p_j \\to p_i $ ] for all @xmath141 .",
    "then for each @xmath96 the _ raising _ propagator @xmath265 for each type @xmath99 in @xmath94 is : @xmath266}}_y \\circ t_i\\ ] ] and the _ handling _ propagator @xmath267 for each propagator @xmath205 , each non - empty list of indices @xmath101 and each propagators @xmath268 for @xmath146 is defined as : @xmath269 from a catcher @xmath270 which is defined as follows in two steps :    ( try ) : :    the catcher @xmath271 is defined    for any catcher @xmath272 by :    @xmath273}^{{(2)}}\\circ f^{{(1)}}\\ ] ] ( catch ) : :    the catcher    @xmath274    is obtained by setting @xmath151 in the family of catchers    @xmath275    ( for @xmath153 ) which are defined recursively by :    @xmath276}}_y^{{(0 ) } } & \\mbox { when } p = n+1 \\\\          { \\left [ \\ ; g_p^{{(1)}}\\;|\\ ; k_{p+1}^{{(2)}}\\ ; \\right]}^{{(2)}}\\circ c_{i_p}^{{(2 ) } } &                \\mbox { when } p\\leq n \\\\",
    "\\end{cases}\\ ] ]    [ rem : try ] let @xmath277 and @xmath278 .",
    "then @xmath232 is a propagator and @xmath279 is a catcher , and the definition of @xmath232 is given in terms of @xmath279 , as @xmath280 .",
    "the expansions of @xmath232 and @xmath279 are functions from @xmath117 to @xmath128 which coincide on @xmath68 but differ on @xmath3 : while @xmath232 propagates exceptions , @xmath279 catches exceptions according to the pattern @xmath281 .    since @xmath282}}_y$ ]",
    ", by lemma  [ lem : coprod - cotu ] we have @xmath283 } { \\equiv}g_n$ ] .",
    "it follows that when @xmath155 and 2 we get respectively : @xmath284 }         \\circ f \\;\\right )   } \\\\ \\label{eq : deco - handle - two } { \\mathit{try}\\{f\\}\\,{\\mathit{catch}\\,\\{i\\!{\\rightarrow}\\ !",
    "! h\\ } } } \\;{\\equiv}\\ ;       { \\blacktriangledown       \\left(\\ ;        { \\bigl [ { \\mathit{id}}\\;|\\ ;         { \\left [ g \\;|\\ ;           h",
    "\\circ c_j \\right ] }         \\circ c_i \\bigr ] }       \\circ f\\;\\right )   } \\end{gathered}\\ ] ] when @xmath155 this can be illustrated as follows , with @xmath285 on the left and @xmath158 on the right : @xmath286_(.4){{\\mathit{id}}^{{(0 ) } } } \\ar[rrrd]^{{\\mathit{id}}^{{(0 ) } } } & & & \\\\    x \\ar[r]^(.4){f^{{(1 ) } } } &       y \\ar[rrr]^(.4){{\\left [ { \\mathit{id}}|k \\right]}^{{(2 ) } } } &      \\ar@{}[ul]|(.4){{\\sim } } \\ar@{}[dl]|(.4){{\\equiv } } & & y \\\\     & { \\mathbb{0}}\\ar[u]^{{{\\left [ \\ , \\right]}}^{{(0 ) } } } \\ar[rrru]_{k^{{(2 ) } } } & & & \\\\    } \\qquad   \\xymatrix@c=2.5pc@r=1.5pc {    & p_i \\ar[d]_(.4){{\\mathit{id}}^{{(0 ) } } } \\ar[rrrd]^{g^{{(1 ) } } } & & & \\\\    e \\ar[r]^(.4){c_i^{{(2 ) } } } &       p_i          \\ar[rrr]^(.4){{\\left [ g|{{\\left [ \\ , \\right]}}\\right]}^{{(2 ) } } } &      \\ar@{}[ul]|(.4){{\\sim } } \\ar@{}[dl]|(.4){{\\equiv } } & & y \\\\     & { \\mathbb{0}}\\ar[u]^{{{\\left [ \\ , \\right]}}^{{(0 ) } } } \\ar[rrru]_{{{\\left [ \\ , \\right]}}^{\\mathit{pure } } } & & & \\\\    } \\ ] ]    [ lem : ss ] let @xmath94 be a signature , @xmath95 a set and @xmath97 a type in @xmath94 for each @xmath96 .",
    "let @xmath91 be the corresponding explicit specification for exceptions ( definition  [ defi : expl - spec ] ) and @xmath188 the corresponding decorated specification for exceptions ( definition  [ defi : deco - spec ] ) .",
    "then @xmath287 .",
    "this is easy to check : in definition  [ defi : expl - spec ] @xmath91 is described as a colimit of elementary specifications , and @xmath288 , as any left adjoint functor , preserves colimits .",
    "[ prop : deco - expand ] the functor @xmath199 defined in figure  [ fig : expansion ] is locally presentable and it determines a morphism of logics @xmath289 .    the fact that @xmath290 is locally presentable is deduced from its definition in figure  [ fig : expansion ] .",
    "it has been checked that @xmath290 maps each decorated inference rule to an explicit proof , thus it can be extended as @xmath291 in such a way that the pair @xmath292 is a morphism of logics .",
    "[ defi : deco - expand ] the morphism @xmath289 is called the _ expansion _ morphism .      following definition  [ defi : expl - model ] ,",
    "the intended semantics of exceptions is a model with respect to the explicit logic .",
    "theorem  [ thm : deco - model ] will prove that the intended semantics of exceptions can also be expressed as a model with respect to the decorated logic .",
    "[ defi : deco - set ] for any set @xmath3 , called the _ set of exceptions _ , we define a decorated theory @xmath293 as follows .",
    "a type is a set , a pure term @xmath208 is a function @xmath0 , a propapagator @xmath205 is a function @xmath24 , and a catcher @xmath203 is a function @xmath204 .",
    "it follows that in @xmath293 every pure term @xmath0 gives rise to a propagator @xmath294 and that every propagator @xmath24 gives rise to a catcher @xmath295:x+e\\to y+e$ ] . by default",
    ", @xmath107 stands for @xmath296 .",
    "the equations are defined when both members are catchers , the other cases follow thanks to the conversions above .",
    "a strong equation @xmath71 is the equality of functions @xmath297 and a weak equation @xmath298 is the equality of functions @xmath299 .",
    "[ lem : tt ] let @xmath300 be the right adjoint to @xmath301",
    ". then @xmath302 .",
    "the morphism of limit sketches @xmath303 , corresponding to the locally presentable functor @xmath301 , is deduced from figure  [ fig : expansion ] . by definition of @xmath300",
    "we have @xmath304 .",
    "the lemma follows by checking that the definition of @xmath293 ( definition  [ defi : deco - set ] ) is precisely the description of @xmath305 .    our main result is the next theorem , which states that the decorated point of view provides exactly the semantics of exceptions defined as a model of the explicit specification for exceptions in definition  [ defi : expl - model ] .",
    "thus the decorated point of view _ is _ an alternative to the explicit point of view , as it provides the intended semantics , but it is also closer to the syntax since the type of exceptions is no longer explicit .    to prove this , the key point is the existence of the expansion morphism from the decorated to the explicit logic . within the category of diagrammatic logics ,",
    "the proof is simple : it uses the fact that the expansion morphism , like every morphism in this category , is a left adjoint functor .",
    "[ thm : deco - model ] the model @xmath189 of the specification @xmath188 with values in the theory @xmath293 in the decorated logic provides the intended semantics of exceptions .",
    "according to definition  [ defi : expl - model ] , the intended semantics of exceptions is the model @xmath92 of @xmath91 with values in @xmath132 in the explicit logic .",
    "in addition , @xmath189 is a model of @xmath188 with values in @xmath293 in the decorated logic .",
    "furthermore , we know from lemmas  [ lem : ss ] and  [ lem : tt ] that @xmath287 and @xmath306 , where @xmath307 is right adjoint to @xmath288 . thus , it follows from proposition  [ prop : deco - morphism ] that there is a bijection between @xmath308 and @xmath309 . finally , it is easy to check that @xmath189 corresponds to @xmath92 in this bijection .",
    "the signature @xmath90 from definition  [ defi : expl - sig ] can easily be recovered from the decorated specification @xmath188 by dropping the decorations and forgetting the equations .",
    "more formally , this can be stated as follows .",
    "let us introduce a third logic @xmath190 , called the _ apparent _ logic , by dropping all the decorations from the decorated logic ; thus , the apparent logic is essentially the monadic equational logic with an empty type .",
    "the fact of dropping the decorations is a morphism of logics @xmath310 .",
    "therefore , we can form the apparent specification @xmath311 which contains the signature for exceptions @xmath90 .",
    "note that , as already mentioned in remark  [ rem : expl - model ] , the intended semantics of exceptions can not be seen as a set - valued model of @xmath312 .      according to theorem  [ thm : deco - model ] , the intended semantics of exceptions can be expressed as a model in the decorated logic .",
    "now we show that the decorated logic can also be used for proving properties of exceptions in a concise way . indeed , as for proofs on states in @xcite , we may consider two kinds of proofs on exceptions : the _ explicit _ proofs involve a type of exceptions , while the _ decorated _ proofs do not mention any type of exceptions but require the specification to be decorated , in the sense of section  [ sec : deco ] .",
    "in addition , the expansion morphism , from the decorated logic to the explicit logic , maps each decorated proof to an explicit one . in this section we give some decorated proofs for exceptions , using the inference rules of section  [ subsec : deco - deco ] .",
    "we know from @xcite that the properties of the core tagging and untagging operations for exceptions are dual to the properties of the lookup and update operations for states .",
    "thus , we may reuse the decorated proofs involving states from @xcite . starting from any one of the seven equations for states in @xcite we can dualize this equation and derive a property about raising and handling exceptions .",
    "this is done here for the _ annihilation catch - raise _ and for the _ commutation catch - catch _ properties .    on states , the _ annihilation lookup - update",
    "_ property means that updating any location with the content of this location does not modify the state . a decorated proof of this property is given in @xcite . by duality",
    "we get the following _ annihilation untag - tag _ property ( lemma  [ lem : ci - ti ] ) , which means that tagging just after untagging , both with respect to the same index , returns the given exception",
    ". then this result is used in proposition  [ prop : hi - ri ] for proving the _ annihilation catch - raise _ property : catching an exception and re - raising it is like doing nothing .    [",
    "lem : ci - ti ] for each @xmath96 : @xmath313    [ prop : hi - ri ] for each propagator @xmath205 and each @xmath96 : @xmath314    by equation  ( [ eq : deco - handle - one ] ) and definition  [ defi : deco - spec ] we have @xmath315}}_y \\circ t_i \\circ c_i   \\right ] } \\circ f )   } $ ] . by lemma  [ lem : ci - ti ]",
    "@xmath316}}_y \\circ t_i \\circ c_i   \\right ] } { \\equiv}{\\left [   { \\mathit{id}}_y | { { \\left [ \\ , \\right]}}_y   \\right ] } $ ] , and the unicity property of @xmath317}}_y   \\right]}$ ] implies that @xmath317}}_y   \\right ] } { \\equiv}{\\mathit{id}}_y $ ] . thus @xmath318 .",
    "in addition , since @xmath319 and @xmath107 is a propagator we get @xmath320 . finally , the transitivity of @xmath197 yields the proposition .    on states ,",
    "the _ commutation update - update _ property means that updating two different locations can be done in any order . by duality",
    "we get the following _ commutation untag - untag _ property , ( lemma  [ lem : cj - ci ] ) which means that untagging with respect to two distinct exceptional types can be done in any order . a detailed decorated proof of the commutation update - update property is given in @xcite .",
    "the statement of this property and its proof use _ semi - pure products _ , which were introduced in @xcite in order to provide a decorated alternative to the strength of a monad .",
    "dually , for the commutation untag - untag property we use _ semi - pure coproducts _ , thus generalizing the rules for the coproduct @xmath219 .",
    "the _ coproduct _ of two types @xmath321 and @xmath322 is defined as a type @xmath323 with two pure coprojections @xmath324 and @xmath325 , which satisfy the usual categorical coproduct property with respect to the pure morphisms .",
    "then the _ semi - pure coproduct _ of a propagator @xmath326 and a catcher @xmath327 is a catcher @xmath131}^{{{(2)}}}:a+b\\to c$ ] which is characterized , up to strong equations , by the following decorated version of the coproduct property : @xmath131 }",
    "\\circ { q}_1 { \\sim}f $ ] and @xmath131 } \\circ { q}_2 { \\equiv}k $ ] .",
    "then as usual , the coproduct @xmath328 of a propagator @xmath329 and a catcher @xmath330 is the catcher @xmath331}:a+b\\to c+d$ ] .",
    "whenever @xmath107 and @xmath108 are propagators it can be proved that @xmath332 } } { \\equiv}{\\left [ f|g \\right]}$ ] ; thus , up to strong equations , we can assume that in this case @xmath333}:a+b \\to c$ ] is a propagator ; it is characterized , up to strong equations , by @xmath333 } \\circ { q}_1 { \\equiv}f$ ] and @xmath333 } \\circ { q}_2 { \\equiv}g$ ] .",
    "[ lem : cj - ci ] for each @xmath334 with @xmath335 : @xmath336    [ prop : hj - hi ] for each @xmath337 with @xmath338 : @xmath339    according to equation  ( [ eq : deco - handle - two ] ) : @xmath340 }         \\circ c_i \\right ] }       \\circ f ) } $ ] .",
    "thus , the result will follow from @xmath341 } \\circ c_i { \\equiv}{\\left [ h \\;|\\ ;   g \\circ c_i \\right ] }   \\circ c_j $ ] .",
    "it is easy to check that @xmath341 }    { \\equiv}{\\left [ g \\;|\\ ; h \\right ] } \\circ ( { \\mathit{id}}_{p_i } + c_j ) $ ] , so that @xmath341 } \\circ c_i { \\equiv}{\\left [ g \\;|\\ ; h \\right ] } \\circ ( { \\mathit{id}}_{p_i } + c_j )",
    "\\circ c_i \\;.$ ] similarly @xmath342 } \\circ c_j { \\equiv}{\\left [ h \\;|\\ ; g \\right ] } \\circ ( { \\mathit{id}}_{p_j } + c_i ) \\circ c_j $ ] hence @xmath342 } \\circ c_j { \\equiv}{\\left [ g \\;|\\ ; h \\right ] } \\circ ( c_i + { \\mathit{id}}_{p_j } ) \\circ c_j \\;.$ ] then the result follows from lemma  [ lem : cj - ci ] .      we know from section  [ subsec : expl - lambda ] that we can add higher - order features in our explicit logic .",
    "this remark holds for the decorated logic as well .",
    "let us introduce a functional type @xmath343 for each types @xmath181 and @xmath182 and each decoration @xmath200 for terms .",
    "the expansion of @xmath344 is @xmath180 , the expansion of @xmath345 is @xmath346 and the expansion of @xmath347 is @xmath348 .",
    "then each @xmath349 gives rise to @xmath350 , and a major point is that @xmath351 is pure for every decoration @xmath200 of @xmath352 .",
    "informally , we can say that the abstraction moves the decoration from the term to the type .",
    "this means that the expansion of @xmath353 is @xmath354 , as required : for instance when @xmath355 is a propagator the expansion of @xmath353 is @xmath356 , as in section  [ subsec : expl - lambda ] . besides , it is easy to prove in the decorated logic that whenever @xmath107 is pure we get @xmath357 .",
    "it follows that this occurs when @xmath107 is a lambda abstraction : @xmath358 , as expected in functional languages .",
    "we have presented three logics for dealing with exceptions : the _ apparent _ logic @xmath190 ( section  [ subsec : deco - app ] ) for dealing with the syntax , the _ explicit _ logic @xmath8 ( section  [ subsec : expl - expl ] ) for providing the semantics of exceptions as a model in a transparent way , and the _ decorated _ logic @xmath9 ( section  [ subsec : deco - deco ] ) for reconciling syntax and semantics .",
    "these logics are related by morphisms of logics @xmath310 and @xmath289 .",
    "a similar approach can be used for other exceptions @xcite .",
    "future work include the following topics .    * dealing with @xmath7-ary operations involving exceptions .",
    "we can add a cartesian structure to our decorated logic thanks to the notion of _ sequential product _ from @xcite .",
    "this notion is based on the _ semi - pure products _ , which are dual to the semi - pure coproducts used in section  [ subsec : deco - proof ] .",
    "* adding higher - order features .",
    "this has been outlined in sections  [ subsec : expl - lambda ] and  [ subsec : deco - lambda ] , however a more precise comparison with @xcite remains to be done .",
    "* deriving a decorated operational semantics for exceptions by directing the weak and strong equations . * using a proof assistant for decorated proofs .",
    "thanks to the morphism @xmath191 , checking a decorated proof can be split in two parts : first checking the undecorated proof in the apparent logic , second checking that the decorations can be added .",
    "this separation simplifies the definition of the formalization towards a proof assistant : first formalize the syntactic rules of the language , second add computational effects . * combining computational effects .",
    "since an effect is based on a span of logics , the combination of effects might be based on the composition of spans .    * acknowledgment . * we are indebted to olivier laurent for pointing out the extension of our approach to functional languages .",
    "00    csar domnguez , dominique duval .",
    "diagrammatic logic applied to a parameterization process .",
    "mathematical structures in computer science 20 , p.  639 - 654",
    "( 2010 ) .",
    "csar domnguez , dominique duval .",
    "a parameterization process : from a functorial point of view .",
    "international journal of foundations of computer science 23 , p.  225 - 242",
    "( 2012 ) .",
    "jean - guillaume dumas , dominique duval , laurent fousse , jean - claude reynaud . a duality between exceptions and states . mathematical structures in computer science 22 , p.  719 - 722",
    "( 2012 ) .",
    "jean - guillaume dumas , dominique duval , laurent fousse , jean - claude reynaud . decorated proofs for computational effects : states .",
    "accat 2012 .",
    "electronic proceedings in theoretical computer science 93 , p.  45 - 59",
    "( 2012 ) .",
    "jean - guillaume dumas , dominique duval , jean - claude reynaud .",
    "cartesian effect categories are freyd - categories .",
    "journal of symbolic computation 46 , p.  272 - 293",
    "( 2011 ) .",
    "dominique duval .",
    "diagrammatic specifications .",
    "mathematical structures in computer science 13 , p.  857 - 890",
    "( 2003 ) .",
    "charles ehresmann .",
    "esquisses et types de structures algbriques . bull .",
    "iai xiv ( 1968 ) .",
    "p. gabriel and f. ulmer .",
    "lokal prsentierbar kategorien",
    ". springer lecture notes in mathematics 221 ( 1971 ) .",
    "peter gabriel , michel zisman .",
    "calculus of fractions and homotopy theory .",
    "springer ( 1967 ) .",
    "james gosling , bill joy , guy steele , gilad bracha . the java language specification , third edition .",
    "addison - wesley longman ( 2005 ) .",
    "docs.oracle.com/javase/specs/jls/se5.0/jls3.pdf .",
    "robin milner , mads tofte , robert harper , david macqueen .",
    "the definition of standard ml , revised edition . the mit press ( 1997 ) .",
    "the haskell programming language .",
    "www.haskell.org/haskellwiki/monad .",
    "martin hyland , john power .",
    "the category theoretic understanding of universal algebra : lawvere theories and monads . electronic notes in theoretical computer science 172 , p.  437 - 458",
    "( 2007 ) .",
    "paul blain levy .",
    "monads and adjunctions for global exceptions .",
    "mfps 2006 .",
    "electronic notes in theoretical computer science 158 , p.  261 - 287",
    "( 2006 ) .",
    "eugenio moggi .",
    "notions of computation and monads .",
    "information and computation 93(1 ) , p.  55 - 92",
    "( 1991 ) .",
    "gordon d. plotkin , john power .",
    "notions of computation determine monads .",
    "fossacs 2002 .",
    "springer - verlag lecture notes in computer science 2303 , p.  342 - 356",
    "( 2002 ) .",
    "gordon d. plotkin , john power .",
    "algebraic operations and generic effects . applied categorical structures 11(1 ) , p.  69 - 94",
    "( 2003 ) .",
    "gordon d. plotkin , matija pretnar .",
    "handlers of algebraic effects .",
    "esop 2009 .",
    "springer - verlag lecture notes in computer science 5502 , p.  80 - 94",
    "( 2009 ) .",
    "jon g. riecke , hayo thielecke .",
    "typed exceptions and continuations can not macro - express each other .",
    "icalp 1999 springer - verlag lecture notes in computer science 1644 , p.  635 - 644",
    "( 1999 ) .",
    "lutz schrder , till mossakowski . generic exception handling and the java monad .",
    "amast 2004 .",
    "springer - verlag lecture notes in computer science 3116 , p.  443 - 459 ( 2004 ) .",
    "philip wadler .",
    "the essence of functional programming .",
    "popl 1992 .",
    "acm press , p.  1 - 14",
    "( 1992 ) .",
    "charles wells .",
    "sketches : outline with references .",
    "http://www.cwru.edu/artsci/math/wells/pub/papers.html ( 1994 ) .",
    "definition  [ defi : expl - model ] relies on the following description of the handling of exceptions in java ( * ? ? ?",
    "14 ) .    * a try statement without a finally block is executed by first executing the try block . then there is a choice : 1 .",
    "[ tc - one ] if execution of the try block completes normally , then no further action is taken and the try statement completes normally .",
    "2 .   [ tc - two ] if execution of the try block completes abruptly because of a throw of a value @xmath359 , then there is a choice : 1 .",
    "if the run - time type of @xmath359 is assignable to the parameter of any catch clause of the try statement , then the first ( leftmost ) such catch clause is selected .",
    "the value @xmath359 is assigned to the parameter of the selected catch clause , and the block of that catch clause is executed . 1 .",
    "[ tc - i ] if that block completes normally , then the try statement completes normally ; 2 .",
    "[ tc - ii ] if that block completes abruptly for any reason , then the try statement completes abruptly for the same reason . 2 .",
    "if the run - time type of @xmath359 is not assignable to the parameter of any catch clause of the try statement , then the try statement completes abruptly because of a throw of the value @xmath359 .",
    "[ tc - three ] if execution of the try block completes abruptly for any other reason , then the try statement completes abruptly for the same reason .    in fact , points  [ tc - i ] and  [ tc - ii ] can be merged .",
    "our treatment of exceptions is similar to the one in java when execution of the try block completes normally ( point  [ tc - one ] ) or completes abruptly because of a throw of an exception of constructor @xmath96 ( point  [ tc - two ] ) : indeed , in our framework there is no other reason for the execution of a try block to complete abruptly ( point  [ tc - three ] ) .",
    "thus , the description can be simplified as follows .    *",
    "a try statement without a finally block is executed by first executing the try block .",
    "then there is a choice : 1 .",
    "[ new - tc - one ] if execution of the try block completes normally , then no further action is taken and the try statement completes normally .",
    "[ new - tc - two ] if execution of the try block completes abruptly because of a throw of a value @xmath359 , then there is a choice : 1 .",
    "if the run - time type of @xmath359 is assignable to the parameter of any catch clause of the try statement , then the first ( leftmost ) such catch clause is selected .",
    "the value @xmath359 is assigned to the parameter of the selected catch clause , the block of that catch clause is executed , and the try statement completes in the same way as this block .",
    "if the run - time type of @xmath359 is not assignable to the parameter of any catch clause of the try statement , then the try statement completes abruptly because of a throw of the value @xmath359 ."
  ],
  "abstract_text": [
    "<S> * abstract . * the exceptions form a computational effect , in the sense that there is an apparent mismatch between the syntax of exceptions and their intended semantics . </S>",
    "<S> we solve this apparent contradiction by defining a logic for exceptions with a proof system which is close to their syntax and where their intended semantics can be seen as a model . </S>",
    "<S> this requires a robust framework for logics and their morphisms , which is provided by diagrammatic logics .    </S>",
    "<S> * keywords . * computational effects . </S>",
    "<S> semantics of exceptions . </S>",
    "<S> adjunction . </S>",
    "<S> categorical fractions . </S>",
    "<S> limit sketches . </S>",
    "<S> diagrammatic logics . </S>",
    "<S> morphisms of logics . </S>",
    "<S> decorated proof system . </S>"
  ]
}