{
  "article_text": [
    "_ rules _ are widely used in knowledge engineering ( ke ) and knowledge representation ( kr ) as a powerful way of modeling knowledge . in the broadest sense , a rule could be any statement which says that a certain conclusion must be valid whenever a certain premise is satisfied , _ i.e. _  any statement that could be read as a sentence of the form  if .. then .. \" .",
    "rules have been successfully applied in the fields of logic programming ( lp ) and deductive databases @xcite .",
    "rules play also a role in the _ semantic web _ architecture .",
    "interest in this area has grown rapidly over recent years as testified by the rules interchange format ( rif ) activity at w3c .",
    "rules from the rif perspective would allow the integration , transformation and derivation of data from numerous sources in a distributed , scalable , and transparent manner . because of the great variety in rule languages and rule engine technologies , rif consists of a core language to be used along with a set of standard and non - standard extensions .",
    "these extensions need not all be combinable into a single unified language . as for the expressive power ,",
    "two directions are followed : monotonic extensions towards full first order logic ( fol ) and non - monotonic ( nm ) extensions based on the lp tradition .",
    "the debate around a rif has taken a long time also due to the controversial issue of having rules on top or aside ontologies @xcite .",
    "there is a consensus now on the fact that rules complement and extend ontologies .",
    "indeed , rules can be used in combination with ontologies , or as a means to specify ontologies .",
    "they are also frequently applied over ontologies , to draw inferences , express constraints , specify policies , react to events , discover new knowledge , transform data , etc . in particular , rif rules can refer to rdf and owl facts . since the design of owl has been based on the @xmath0 family of very expressive _ description logics _",
    "( dls ) ( see chapter [ ol - book - chapter - description - logics ] for an introduction ) , the nm dialects of rif will most likely be inspired by those hybrid kr systems that integrate dls and lp .",
    "such rule formalisms are of interest to this chapter",
    ". we shall refer to them as _ onto - relational rule languages _ from now on .",
    "apart from the specific ontology language , the integration of ontologies and rules is already present in existing knowledge bases ( kbs ) .",
    "notably the cyc kb consists of terms ( which constitute the vocabulary , _ i.e. _  the ontology ) and assertions which relate those terms and include both simple ground assertions and rules @xcite .",
    "the acquisition of rules for very large kbs like cyc is a very demanding ke activity . indeed , according to an estimate from the cyc project , human experts produce rules at the rate of approximately three per hour but can evaluate an average of twenty rules per hour .",
    "also , for untrained knowledge engineers , while rule authoring may be very difficult , rule reviewing is feasible ( although still difficult ) . a partial automation of the rule authoring task , _",
    "e.g._by applying _ machine learning _ ( ml ) algorithms ( see chapter [ ol - book - chapter - machine - learning ] for an introduction ) , can be of help even though the automatically produced rules are not guaranteed to be correct .",
    "in fact , of those rules , some will turn out to be correct , and some will be found to need editing to be assertible . yet , as mentioned above , rule reviewing is less critical than rule authoring . in order to partially automate the authoring of onto - relational rules , the bunch of ml techniques collectively known under the name of _ inductive logic programming _ ( ilp ) @xcite seems particularly promising for the following reasons .",
    "ilp was born at the intersection of ml and lp @xcite , and is widely recognized as a major approach to _ relational learning",
    "apart from the kr framework of lp , the distinguishing feature of ilp , also with respect to other ml forms , is the use of prior domain knowledge in the form of a logical theory during the induction process . in this chapter",
    "we take a critical look at ilp proposals for learning relational rules while having an ontology as the background theory .",
    "these proposals try to overcome the difficulties of accommodating ontologies in relational learning .",
    "the work of @xcite on using semantic meta - knowledge from cyc as inductive bias in an ilp system is another attempt at solving this problem though more empirically .",
    "conversely , we promote an extension of relational learning , called _ onto - relational learning _ ( orl ) , which accounts for ontologies in a clear , elegant and well - founded manner by resorting to onto - relational rule languages . in this chapter , for the sake of illustration , we provide details of a specific orl solution to the problem of learning rule - based definitions of dl concepts and roles with ilp . the chapter is organized as follows .",
    "section [ sect : pre ] is devoted to preliminaries on lp and its applications to databases and ontologies as well as on ilp .",
    "section [ sect : ilp4sw - today ] provides a state - of - the - art survey of ilp proposals for learning onto - relational rules .",
    "section [ sect : learning - fwk ] describes in depth the most powerful of these proposals .",
    "section [ sect : concl ] concludes the chapter with final remarks and outlines directions of future work .",
    "logic programming ( lp ) is rooted into a fragment of clausal logics ( cls ) known as horn clausal logic ( hcl ) @xcite .",
    "the basic element in cls is the _ atom _ of the form @xmath1 such that each @xmath2 is a predicate symbol and each @xmath3 is a term .",
    "a _ term _ is either a constant or a variable or a more complex term obtained by applying a functor to simpler term .",
    "constant , variable , functor and predicate symbols belong to mutually disjoint alphabets .",
    "literal _ is an atom either negated or not .",
    "a _ clause _ is a universally quantified disjunction of literals .",
    "usually the universal quantifiers are omitted to simplify notation .",
    "alternative notations are a clause as set of literals and a clause as an implication .",
    "a _ program _ is a set of clauses .",
    "hcl admits only so - called definite clauses .",
    "definite clause _ is an implication of the form    @xmath4    where @xmath5 and @xmath6 are atoms , _",
    "i.e. _  a clause with exactly one positive literal .",
    "the right - hand side @xmath7 and the left - hand side @xmath8 of the implication are called _ head _ and _ body _ of the clause , respectively .",
    "note that the body is intended to be an existentially quantified conjunctive formula @xmath9 .",
    "furthermore definite clauses with @xmath10 and @xmath11 are called _ rules _ and _ facts _ respectively .",
    "the model - theoretic semantics of hcl is based on the notion of _ herbrand interpretation _ , _",
    "i.e. _  an interpretation in which all all constants and function symbols are assigned very simple meanings .",
    "this allows the symbols in a set of clauses to be interpreted in a purely syntactic way , separated from any real instantiation .",
    "the corresponding proof - theoretic semantics is based on the _ closed world assumption _ ( cwa ) , _ i.e. _  the presumption that what is not currently known to be true , is false .",
    "deductive reasoning with hcl is formalized in its proof theory . in clausal logic _",
    "resolution _ comprises a single inference rule which , from any two clauses having an appropriate form , derives a new clause as their consequence .",
    "resolution is sound : every resolvent is implied by its parents .",
    "it is also refutation complete : the empty clause is derivable by resolution from any set @xmath12 of horn clauses if @xmath12 is unsatisfiable .",
    "_ negation as failure _ ( naf ) is related to the cwa , as it amounts to believing false every predicate that can not be proved to be true .",
    "clauses with naf literals in the body are called _ normal clauses_. the concept of a _ stable model _ , or _",
    "answer set _ , is used to define a declarative semantics for normal logic programs @xcite . according to this semantics",
    ", a logic program may have several alternative models ( but possibly none ) , each corresponding to a possible view of the reality .",
    "also based on the stable model ( answer set ) semantics , _ answer set programming _ ( asp ) is an alternative lp paradigm oriented towards difficult search problems @xcite .",
    "definite clauses played a prominent role in the rise of deductive databases @xcite .",
    "more precisely , functor - free non - recursive definite clauses are at the basis of the language datalog for deductive databases @xcite .",
    "generally , it is denoted by datalog@xmath13  where @xmath14 is treated as naf .",
    "the restriction of datalog to only positive rules ( _ i.e. _ , rules without naf literals ) is denoted by datalog .",
    "based on the distinction between extensional and intensional predicates , a datalog  program @xmath15 can be divided into two parts .",
    "extensional part _ , denoted as @xmath16 , is the set of facts of @xmath15 involving the extensional predicates , whereas the _ intensional part _",
    "@xmath17 is the set of all other clauses of @xmath15 .",
    "the main reasoning task in datalog  is _ query answering_. a _ query _ @xmath18 to a datalog  program @xmath15 is a datalog  clause of the form    @xmath19    where @xmath10 , and @xmath6 is a datalog  atom .",
    "an _ answer _ to a query @xmath18 is a substitution @xmath20 for the variables of @xmath18 .",
    "an answer is correct with respect to the datalog  program @xmath15 if @xmath21 .",
    "the _ answer set _ to a query @xmath18 is the set of answers to @xmath18 that are correct w.r.t . @xmath15 and such that @xmath22 is ground .",
    "in other words the answer set to a query @xmath18 is the set of all ground instances of @xmath18 which are logical consequences of @xmath15 .",
    "answers are computed by refutation .",
    "disjunctive datalog ( denoted as datalog@xmath23 ) is a variant of datalog  where disjunctions may appear in the rule heads @xcite .",
    "therefore datalog@xmath23  can not be considered as a fragment of hcl .",
    "advanced versions ( datalog@xmath24 ) also allow for negation in the bodies , which can be handled according to a semantics for negation in cls .",
    "defining the semantics of a datalog@xmath24  program is complicated by the presence of disjunction in the rules heads because it makes the underlying disjunctive logic programming inherently nonmonotonic , _",
    "i.e. _  new information can invalidate previous conclusions . among the many alternatives ,",
    "one widely accepted semantics for datalog@xmath24  is the extension of the stable model semantics to the disjunctive case .",
    "the integration of lp and ontologies follows the tradition of kr research on so - called _ hybrid systems _ , _",
    "i.e. _  those systems which are constituted by two or more subsystems dealing with distinct portions of a single kb by performing specific reasoning procedures @xcite .",
    "the motivation for investigating and developing such systems is to improve on two basic features of kr formalisms , namely _ representational adequacy _ and _ deductive power _ , by preserving the other crucial feature , _",
    "i.e. _  _ decidability_. indeed dls and cls are fol fragments incomparable as for the expressiveness @xcite and the semantics @xcite but combinable at different degrees of integration : tight , loose , full .",
    "the semantic integration is _ tight _ when a model of the hybrid kb is defined as the union of two models , one for the dl part and one for the cl part , which share the same domain . in particular , combining dls with cls in a tight manner can easily lead to undecidability if the interaction scheme between the dl and the cl part of a hybrid kb does not solve the semantic mismatch between dls and cls @xcite .",
    "this requirement is known as _ dl - safety _ @xcite . with respect to this property",
    ", the hybrid kr system carin  @xcite is _ unsafe _ because the interaction scheme is left unrestricted .",
    "conversely , @xmath25-log  @xcite guarantees a _",
    "safe _ interaction scheme by means of syntactic restrictions . finally , @xmath26+log@xmath24",
    "@xcite+log@xmath24  to the original name @xmath26+log  in order to emphasize the nm features of the language . ] is _ weakly dl - safe _ because it relaxes the condition of dl - safety .",
    "the distinguishing features of these three kr frameworks are summarized in table [ tab : kr - comp ] and further discussed in section [ sect : carin ] , [ sect : al - log ] , and [ sect : dl+log ] respectively .    [ cols=\">,<,<,<\",options=\"header \" , ]",
    "in ke , ontology evolution is the timely adaptation of an ontology to changed business requirements , to trends in ontology instances and patterns of usage of the ontology - based application , as well as the consistent management / propagation of these changes to dependent elements @xcite . as opposed to ontology modification",
    ", ontology evolution must preserve the consistency of the ontology . according to @xcite",
    "one can distinguish between conceptual , specification and representation changes . in this section",
    "we consider the conceptual changes of a @xmath26  ontology due to extensional knowledge ( _ i.e. _ , facts of the instance level of the ontology ) previously unknown but classified which may become available . in particular , we consider the task of defining new concepts or roles which provide the intensional counterpart of such extensional knowledge and show how this task can be reformulated as an orl problem @xcite .",
    "for example , the new facts ` loner(joe ) ` , ` loner(mary ) ` , and ` loner(paul ) ` concerning known individuals may raise the need for having a definition of the concept ` loner ` in the ontology .",
    "one such definition can be learned from these facts together with prior knowledge about ` joe ` , ` mary ` and ` paul ` , _",
    "i.e. _  facts concerning them and already available in the ontology .",
    "a crucial requirement is that the definition must be expressed as a @xmath26  formula or similar . in the following we",
    "provide the means for learning rule - based definitions of @xmath26  concepts / roles in the kr framework of @xmath26+log@xmath13 .",
    "we assume that a @xmath26  ontology @xmath27 is integrated with a datalog@xmath13  database @xmath15 to form a @xmath26+log@xmath13  kb @xmath28 .",
    "the problem of inducing rule - based definitions of @xmath26  concepts / roles that do not occur in @xmath28 can be formalized as follows .",
    "[ def : learning - problem ] given :    * a @xmath26+log@xmath13  kb @xmath28 ( _ background theory _ ) * a @xmath26  predicate name @xmath2 ( _ target predicate _ ) * a set @xmath29 of @xmath26  assertions that are either true or false for @xmath2 ( _ examples _ ) * a set @xmath30 of @xmath26+log@xmath13  definitions for @xmath2 ( _ language of hypotheses _ )    the problem of building a rule - based definition of @xmath2 is to induce a set @xmath31 ( _ hypothesis _ ) of @xmath26+log@xmath13  rules from @xmath32 and @xmath28 such that :    completeness : :    @xmath33 covers    @xmath34 w.r.t .",
    "@xmath28 consistency : :    @xmath35 does not    cover @xmath34 w.r.t . @xmath28 .",
    "the _ background theory _",
    "@xmath28 in definition [ def : learning - problem ] can be split into an intensional part @xmath36 ( _ i.e. _ , the tbox @xmath37 plus @xmath17 ) and an extensional part @xmath38 ( _ i.e. _ , the abox @xmath39 plus @xmath16 ) .",
    "also we denote by @xmath40 , @xmath41 , and @xmath42 the sets of concept , role and datalog  predicate names occurring in @xmath28 , respectively .",
    "note that @xmath43 .",
    "[ ex : shiq+log - kb ] suppose we have a @xmath26+log@xmath13  kb @xmath28 ( adapted from @xcite ) built upon the alphabets @xmath44 , @xmath45 , and @xmath46 and consisting of the following intensional knowledge @xmath36 :    mm = mmmmmm = mm = @xmath47 $ ] ` rich`@xmath48`unmarried ` @xmath49 ` wants - to - marry^{-}.\\top ` + @xmath50 $ ] ` wants - to - marry ` @xmath51 ` loves ` + @xmath52 $ ] ` rich(x ) ` @xmath53 ` famous(x ) ` , ` \\negscientist(x ) ` + @xmath54 $ ] ` happy(x ) ` @xmath53 ` famous(x ) ` , ` wants - to - marry(y , x ) `    and the following extensional knowledge @xmath38 :    mm = mmmmmm = mm = ` unmarried(mary ) ` + ` unmarried(joe ) ` + ` famous(mary ) ` + ` famous(paul ) ` + ` famous(joe ) ` + ` scientist(joe ) ` + ` meets(mary , paul , italy ) ` + ` meets(mary , joe , germany ) ` + ` meets(joe , mary , italy ) `    that concerns the individuals ` mary ` , ` joe ` , ` paul ` , ` italy ` , and ` germany ` .",
    "the _ hypothesis language _",
    "@xmath30 in definition [ def : learning - problem ] is given as a set of declarative bias constraints .",
    "it allows for the generation of @xmath26+log@xmath13  rules starting from three disjoint alphabets @xmath55 , @xmath56 , and @xmath57 .",
    "also we distinguish between @xmath58 and @xmath59 in order to specify which datalog  predicates can occur in positive and negative literals , respectively .",
    "more precisely , we consider @xmath26+log@xmath13  rules of the form @xmath60 where @xmath61 , @xmath62 and each @xmath63 , @xmath64 , @xmath65 is an atom with @xmath66 , @xmath67 , and @xmath68",
    ". the admissible rules must be compliant with the following restrictions :    datalog - safeness : :    every variable occurring in ( [ eq : hypothesis - syntax ] ) must appear in at    least one of the atoms    @xmath69 ; weak @xmath26-safeness : :    every head variable of ( [ eq : hypothesis - syntax ] ) must appear in at    least one of the atoms    @xmath70 .    which also guarantee that the conditions of linkedness and connectedness , usually assumed in ilp , are satisfied .    [",
    "ex : hyp - lang2 ] suppose that the target predicate is the @xmath26  concept ` loner ` .",
    "if @xmath71 is defined over @xmath72 , then the following @xmath26+log@xmath13  rules    mmmmmm = mmmmmm = mm = @xmath73 ` loner(x ) ` @xmath53 ` famous(x ) ` + @xmath74 ` loner(x ) ` @xmath53 ` famous(x ) ` , ` unmarried(x ) ` + @xmath75 ` loner(x ) ` @xmath53 ` famous(x ) ` , @xmath14`happy(x ) `    belong to @xmath71 and represent hypotheses of a definition for ` loner ` .    [ ex : hyp - lang3 ] suppose now that the @xmath26  role ` likes ` is the target predicate and the set @xmath76 provides the building blocks for the language @xmath77 .",
    "the following @xmath26+log@xmath13  rules    mmmmmm = mmmmmm = mm = @xmath78 ` likes(x , y ) ` @xmath53 ` meets(x , z , y ) ` + @xmath79 ` likes(x , y ) ` @xmath53 ` meets(x , z , y ) ` , ` happy(x ) ` + @xmath80 ` likes(x , y ) `",
    "@xmath53 ` meets(x , z , y ) ` , ` rich(z ) `    belonging to @xmath77 can be considered hypotheses of a definition for ` likes ` .",
    "the _ set @xmath32 of examples _ in definition [ def : learning - problem ] contains assertions of the kind @xmath81 where @xmath2 is the target predicate and @xmath82 is a tuple of individuals occurring in the abox @xmath39 . note that , when @xmath2 is a role name , the tuple @xmath82 is a pair @xmath83 of individuals .",
    "we assume @xmath84 . however , a possibly incomplete description of each @xmath85 is in @xmath28 .",
    "[ ex : observations2 ] with reference to example [ ex : hyp - lang2 ] , suppose that the following concept assertions :    mmmmmm = mmmmmm = mm = @xmath86 ` loner(mary ) ` + @xmath87 ` loner(joe ) ` + @xmath88 ` loner(paul ) `    are examples for the target predicate ` loner ` .",
    "[ ex : observations3 ] with reference to example [ ex : hyp - lang3 ] , the following role assertions :    mmmmmm = mmmmmm = mm = @xmath89 ` likes(mary , italy ) ` + @xmath90 ` likes(mary , germany ) ` + @xmath91 ` likes(joe , italy ) `    can be assumed as examples for the target predicate ` likes ` .      in order to solve the learning problem in hand with the ilp methodological approach",
    ", the language @xmath30 of hypotheses needs to be equipped with ( i ) a _ coverage relation _ which defines the mappings from @xmath30 to the set @xmath32 of examples , and ( ii ) a _ generality order _ @xmath92 such that @xmath93 is a search space .",
    "the definition of a _ coverage relation _ depends on the representation choice for examples .",
    "the normal ilp setting is the most appropriate to the learning problem in hand and can be extended to the @xmath26+log@xmath13  framework depicted in definition [ def : learning - problem ] as follows .",
    "[ def : coverage_int1 ] we say that a rule @xmath94 _ covers _ ( does not cover , resp . )",
    "an example @xmath95 w.r.t .",
    "a background theory @xmath28 iff @xmath96 ( @xmath97 , resp . ) .",
    "note that the coverage test can be reduced to query answering w.r.t .",
    "a @xmath26+log@xmath24  kb , which in turn can be reformulated as a satisfiability problem of the kb .",
    "[ ex : coverage - test2 ] with reference to example [ ex : hyp - lang2 ] and [ ex : observations2 ] , the rule @xmath73 covers the example @xmath86 because all nm - models for @xmath98 do satisfy ` famous(mary ) ` .",
    "it covers also @xmath87 and @xmath88 for analogous reasons .",
    "the rule @xmath74 covers only @xmath86 and @xmath87 whereas @xmath75 covers @xmath87 and @xmath88 .",
    "[ ex : coverage - test3 ] with reference to example [ ex : hyp - lang3 ] and [ ex : observations3 ] , the rule @xmath78 covers the example @xmath89 because all nm - models for @xmath99 do satisfy ` meets(mary , z , italy ) ` .",
    "it covers also @xmath90 and @xmath91 for analogous reasons .",
    "the rule @xmath79 covers only @xmath89 and @xmath90 whereas @xmath80 covers only @xmath89 and @xmath91 .    the definition of a _ generality order _ for hypotheses in @xmath30 must consider the peculiarities of the chosen @xmath30 .",
    "generalized subsumption , subsequently extended in @xcite to deal with naf literals , is suitable for the problem in hand and can be adapted to the case of @xmath26+log@xmath13  rules . in the following",
    "we provide a characterization of the resulting generality order , denoted by @xmath100 , that relies on the reasoning tasks known for @xmath26+log@xmath24and from which a test procedure can be derived .",
    "[ def : k - subsumption-2 ] let @xmath101 be two @xmath26+log@xmath13  rules standardized apart , @xmath36 a @xmath26+log@xmath13  kb , and @xmath102 a skolem substitution for @xmath103 with respect to @xmath104 .",
    "we say that @xmath105 is _ more general than _",
    "@xmath103 w.r.t .",
    "@xmath36 , denoted by @xmath106 , iff there exists a ground substitution @xmath20 for @xmath105 such that ( i ) @xmath107 and ( ii ) @xmath108 . we say that @xmath105 is _ strictly more general than _",
    "@xmath103 w.r.t .",
    "@xmath36 , denoted by @xmath109 , iff @xmath106 and @xmath110 .",
    "we say that @xmath105 is _ equivalent to _",
    "@xmath103 w.r.t .",
    "@xmath36 , denoted by @xmath111 , iff @xmath106 and @xmath112 .",
    "[ ex : generality - test2 ] let us consider the rules reported in example [ ex : hyp - lang2 ] up to variable renaming :    mmmmmm = mmmmmm = mm = @xmath73 ` loner(a ) ` @xmath53 ` famous(a ) ` + @xmath74 ` loner(x ) ` @xmath53 ` famous(x)`,`unmarried(x ) `    in order to check whether @xmath113 holds , let @xmath114 a skolem substitution for @xmath74 with respect to @xmath115 and @xmath116 a ground substitution for @xmath73 .",
    "the condition ( i ) is immediately verified .",
    "the condition    \\(ii ) @xmath117    is a ground query answering problem in @xmath26+log@xmath13 .",
    "it can be easily proved that all nm - models for @xmath118 satisfy @xmath119 .",
    "thus , it is the case that @xmath113",
    ". the viceversa does not hold .",
    "also , @xmath120 and @xmath75 is incomparable with @xmath74 .",
    "[ ex : generality - test3 ] with reference to example [ ex : hyp - lang3 ] , it can be proved that @xmath121 and @xmath122 .",
    "conversely , the rules @xmath79 and @xmath80 are incomparable . note that    mmmmmm = mmmmmm = mm = @xmath123 ` likes(x , y ) ` @xmath53 ` meets(x , z , y ) ` , ` loves(x , z ) ` + @xmath124 ` likes(x , y ) ` @xmath53 ` meets(x , z , y ) ` , ` wants - to - marry(x , z ) `    also belong to @xmath77 .",
    "it can be proved that @xmath125 , @xmath126 , and @xmath127 .",
    "note that the decidability of @xmath128 follows from the decidability of @xmath26+log@xmath13 .",
    "also it can be proved that @xmath128 is a quasi - order ( _ i.e. _ , it is a reflexive and transitive relation ) for @xmath26+log@xmath13  rules , therefore the space @xmath129 can be searched by refinement operators like the following one able to traverse the hypothesis space top down .",
    "[ def : ref - op-1 ] let @xmath30 be a @xmath26+log@xmath13  hypothesis language built out of the three finite and disjoint alphabets @xmath130 , @xmath131 , and @xmath132 .",
    "we define a _ downward refinement operator _",
    "@xmath133 for @xmath134 such that , for each @xmath94 , the set @xmath135 contains all @xmath136 that can be obtained from @xmath137 by applying one of the following refinement rules :    @xmath138 : :    @xmath139    if    +    1 .",
    "@xmath140    2 .   @xmath141    3 .",
    "@xmath142    @xmath143 : :    @xmath144    if    +    1 .",
    "@xmath145    2 .",
    "it does not exist any @xmath146    such that @xmath147    3 .",
    "@xmath142    @xmath148 : :    @xmath149    if    +    1 .",
    "@xmath150    2 .",
    "@xmath151    @xmath152 : :    @xmath153    if    +    1 .",
    "@xmath154    2 .",
    "@xmath155    3 .",
    "@xmath156    all the rules of @xmath133 are correct , _",
    "i.e. _  the @xmath157 s obtained by applying any of the rules of @xmath133 to @xmath94 are such that @xmath158 .",
    "this can be proved intuitively by observing that they act only on @xmath159 .",
    "thus condition ( i ) of definition [ def : k - subsumption-2 ] is satisfied .",
    "furthermore , it is straightforward to notice that the application of any of the rules of @xmath133 to @xmath137 reduces the number of models of @xmath137 . in particular , as for @xmath148 , this intuition follows from the semantics of dls . so condition ( ii ) also is fulfilled .",
    "[ ex : ref - op-2 ] with reference to example [ ex : hyp - lang2 ] , applying @xmath138 to    mmmmmm = mmmmmm = mm = @xmath160 ` loner(x ) ` @xmath53    produces @xmath73 which can be further specialized by means of @xmath143 and @xmath152 .",
    "note that no other refinement rule can be applied to @xmath73 and that @xmath74 and @xmath75 are among the refinements of @xmath73 .",
    "[ ex : ref - op-3 ] with reference to example [ ex : hyp - lang3 ] , applying @xmath138 to    mmmmmm = mmmmmm = mm = @xmath161 ` likes(x , y ) ` @xmath53    produces @xmath78 which can be further specialized into @xmath79 , @xmath80 , @xmath123 and @xmath124 by means of @xmath162 and @xmath143 .",
    "note that no other refinement rule can be applied to @xmath78 and that @xmath124 can be also obtained as refinement from @xmath123 via @xmath148 .",
    "mmm = mmm = mmm = mmm = mmm * function * or - foil(@xmath28 , @xmath2 , @xmath163 , @xmath164 , @xmath30 ) : @xmath165 + 1 .",
    "@xmath166 + 2 .",
    "* while * @xmath167 * do * + 3 .",
    "@xmath168 ; + 4 .",
    "@xmath169 + 5 .",
    "* while * @xmath170 * do * + 6 .",
    "@xmath171 ; + 7 . @xmath172 or - foil - choosebest@xmath173 ; + 8 .",
    "@xmath174 ; + 9 .",
    "* endwhile * + 10 .",
    "@xmath175 ; + 11 .",
    "@xmath176 ; + 12 .",
    "@xmath177 + 13 .",
    "* endwhile * + 14 . *",
    "return * @xmath165    the ingredients identified in the previous section are the starting point for the definition of ilp algorithms .",
    "figure [ fig : foil - like - algo ] reports the main procedure of a foil - like algorithm , named or - foil , for learning onto - relational rules . in or - foil , analogously to foil , the outer loop ( steps 2 - 12 ) corresponds to a variant of the sequential covering algorithm , _",
    "i.e. _ , it learns new rules one at a time , removing the positive examples covered by the latest rule before attempting to learn the next rule ( steps 11 - 12 ) .",
    "the hypothesis space search performed by or - foil  is best understood by viewing it hierarchically .",
    "each iteration through the outer loop ( steps 2 - 13 ) adds a new rule to its disjunctive hypothesis @xmath165 .",
    "the effect of each new rule is to generate the current disjunctive hypothesis ( _ i.e. _ , to increase the number of instances it classifies as positive ) , by adding a new disjunct .",
    "viewed at this level , the search is a bottom - up search through the space of hypotheses , beginning with the most specific empty disjunction ( step 1 ) and terminating when the hypothesis is sufficiently general to cover all positive training examples ( step 13 ) . the inner loop ( steps 5 - 9 ) performs a more fine - grained search to determine the exact definition of each new rule .",
    "this loop searches a second hypothesis space , consisting of conjunctions of literals , to find a conjunction that will form the body of the new rule . within this space",
    ", it conducts a top - down , hill - climbing search , beginning with the most general preconditions possible ( step 3 ) , then refining the rule ( step 6 ) until it avoids all negative examples . to select the most promising specialization from the candidates",
    "generated at each iteration , or - foil - choosebest ( called at step 7 ) considers the performance of each candidate over @xmath32 and chooses the one which maximizes the _ information gain_. this measure is computed according to the following formula @xmath178 where @xmath2 is the number of distinct variable bindings with which positive examples covered by the rule @xmath137 are still covered by @xmath179 and @xmath180 is the confidence degree .",
    "thus , the gain is positive iff @xmath179 is more informative in the sense of shannon s information theory ( _ i.e. _  iff the confidence degree increases ) .",
    "if there are some literals to add which increase the confidence degree , the information gain tends to favor the literals that offer the best compromise between the confidence degree and the number of examples covered .",
    "one may think to use the confidence degree defined for @xmath26-foil  ( see chapter [ ol - book - chapter - concept - learning ] for more details ) which takes owa into account .",
    "indeed , many individuals may be available which can not be classified as instances of the target concept nor of its negation .",
    "this requires a different setting able to deal with unlabeled individuals .",
    "[ ex : foil - like - algo-2 ] with reference to example [ ex : ref - op-2 ] and example [ ex : coverage - test2 ] , we suppose that    mm = mmmmmm = mm = @xmath181 + @xmath182    the outer loop of or - foil  starts from @xmath160 which is further refined through the iterations of the inner loop , more precisely it is first specialized into @xmath73 which in turn , since it covers negative examples , is then specialized into @xmath74 and @xmath75 out of which the rule @xmath75 is added to @xmath183 the hypothesis because it does not cover negative examples . at this point",
    "the algorithm stops because @xmath183 covers both positive examples .",
    "[ ex : ex : foil - like - algo-3 ] following example [ ex : ref - op-3 ] and example [ ex : coverage - test3 ] , we assume that @xmath184 and @xmath185 . at the end of the first iteration , @xmath80 is included into @xmath186 since it does not cover negative examples but only one positive example .",
    "building rules within ontologies poses several challenges not only to kr researchers investigating suitable hybrid dl - cl formalisms but also to the ml community which has been historically interested in application areas where the knowledge acquisition bottleneck is particularly severe .",
    "in particular , orl may open up new opportunities for ke because it will make systems available to support the knowledge engineer in her most demanding task , _ i.e. _  defining rules that extend or complement an ontology .",
    "thus , orl may produce time and cost savings in ke . in this chapter",
    ", we have revised the ml literature addressing the problem of learning onto - relational rules .",
    "very few ilp works have been found that propose a solution to this problem @xcite .",
    "they adopt carin-@xmath187 , @xmath25-log  and @xmath188+log  as kr framework , respectively .",
    "note that matching table [ tab : ilp - comp ] against table [ tab : kr - comp ] one may figure out what is the state - of - the - art and what are the directions of research on onto - relational rules from the ml viewpoint .",
    "also he / she can get suggestions on what is the most appropriate among these ilp frameworks to be implemented for a certain intended application .",
    "the specific solution illustrated in section [ sect : learning - fwk ] takes advantage from an augmented expressive power thanks to the chosen @xmath26+log@xmath24  instantiation @xcite .",
    "it supports the evolution of ontologies with the creation of a concept / role , change operations which both boil down to the addition of new rules to the input kb .",
    "from the comparative analysis of the ilp frameworks reviewed in section [ sect : ilp4sw - today ] , a common feature emerges : all proposals resort to buntine s generalized subsumption and extend it in a non - trivial way .",
    "this choice is due to the fact that , among the semantic generality orders in ilp , generalized subsumption applies only to definite clauses , therefore suits well the hypothesis language in all three frameworks .",
    "following these guidelines , new ilp frameworks can be designed to deal with more or differently expressive hybrid dl - cl languages according to the dl chosen ( _ e.g. _ , learning carin-@xmath189 rules ) , or the clausal language chosen ( _ e.g. _ , learning recursive carin  rules ) , or the integration scheme ( _ e.g. _ , learning carin  rules with @xmath26-literals in the head ) .",
    "an important requirement will be the definition of a _",
    "generality relation for hypotheses to take into account the background knowledge .",
    "of course , generalized subsumption may turn out to be not suitable for all cases , _",
    "e.g. _  for the case of learning @xmath26+log@xmath23  rules @xcite .",
    "also it would be interesting to investigate how the nature of rules ( _ i.e. _ , the intended context of usage ) may impact the learning process as for the scope of induction and other variables in the learning problem statement .",
    "for example , the problem of learning @xmath25-log  rules for classification purposes differ greatly from the apparently similar learning problem faced in @xcite . finally , it is worthy to consider hybrid kr formalisms with loose and full integration scheme .    besides theoretical issues",
    ", most future work will have to be devoted to implementation and application .",
    "when moving to practice , issues like efficiency and scalability become of paramount importance .",
    "these concerns may drive the attention of ilp research towards less expressive hybrid kr frameworks in order to gain in tractability , _",
    "e.g. _  instantiations of @xmath26+log@xmath24  with dl - lite @xcite .",
    "applications can come out of some of the many use cases for semantic web rules specified by the rif w3c working group .",
    "j.  cabral , r.c .",
    "kahlert , c.  matuszek , m.j .",
    "witbrock , and b.  summers . converting semantic meta - knowledge into inductive bias . in s.",
    "kramer and b.  pfahringer , editors , _ inductive logic programming _ , volume 3625 of _ lecture notes in computer science _ , pages 3850 . springer , 2005 .",
    "d.  calvanese , m.  lenzerini , r.  rosati , and g.  vetere .",
    "-lite : practical reasoning for rich dls . in v.",
    "haarslev and r.  mller , editors , _ proc . of the 2004 int .",
    "workshop on description logics _ ,",
    "volume 104 of _ ceur workshop proceedings_. ceur-ws.org , 2004 .",
    "w.  drabent , t.  eiter , g.  ianni , t.  krennwallner , t.  lukasiewicz , and j.  maluszynski .",
    "hybrid reasoning with rules and ontologies . in f.",
    "bry and j.  maluszynski , editors , _ semantic techniques for the web , the rewerse perspective _ , volume 5500 of _ lncs _ , pages 149 .",
    "springer , 2009 .",
    "a.m. frisch .",
    "sorted downward refinement : building background knowledge into a refinement operator for inductive logic programming . in s.",
    "deroski and p.  flach , editors , _ inductive logic programming _ , volume 1634 of _ lecture notes in artificial intelligence _ , pages 104115 .",
    "springer , 1999 .",
    "lisi and f.  esposito .",
    "efficient evaluation of candidate hypotheses in @xmath25-log . in r.",
    "camacho , r.  king , and a.  srinivasan , editors , _ inductive logic programming _ , volume 3194 of _ lecture notes in artificial intelligence _ , pages 216233 .",
    "springer , 2004 .",
    "lisi and f.  esposito .",
    "foundations of onto - relational learning . in f.",
    "elezn and n.  lavra , editors , _ inductive logic programming _ , volume 5194 of _ lecture notes in artificial intelligence _ , pages 158175 .",
    "springer , 2008 .",
    "lisi and f.  esposito .",
    "learning @xmath188+log rules for ontology evolution . in a.",
    "gangemi , j.  keizer , v.  presutti , and h.  stoermer , editors , _ semantic web applications and perspectives ( swap2008 ) _ , volume 426 of _ ceur workshop proceedings_. ceur-ws.org , 2008 .",
    "lisi and d.  malerba . bridging the gap between horn clausal logic and description logics in inductive learning . in a.",
    "cappelli and f.  turini , editors , _",
    "ai*ia 2003 : advances in artificial intelligence _ ,",
    "volume 2829 of _ lecture notes in artificial intelligence _ ,",
    "pages 4960 .",
    "springer , 2003 .",
    "lisi and d.  malerba . ideal refinement of descriptions in @xmath25-log . in t.",
    "horvath and a.  yamamoto , editors , _ inductive logic programming _ , volume 2835 of _ lecture notes in artificial intelligence _ , pages 215232 .",
    "springer , 2003 .",
    "marek and m.  truszczynski .",
    "stable models and an alternative logic programming paradigm . in k.r .",
    "apt , v.w .",
    "marek , m.  truszczynski , and d.s .",
    "warren , editors , _ the logic programming paradigm : a 25-year perspective _ , pages 169181 .",
    "springer , 1999 .",
    "r.  rosati .",
    "semantic and computational advantages of the safe integration of ontologies and rules . in f.  fages and s.",
    "soliman , editors , _ principles and practice of semantic web reasoning _ , volume 3703 of _ lecture notes in computer science _ , pages 5064 .",
    "springer , 2005 .",
    "r.  rosati .",
    "@xmath26+log : tight integration of description logics and disjunctive datalog . in p.",
    "doherty , j.  mylopoulos , and c.a .",
    "welty , editors , _ proc . of tenth international conference on principles of knowledge representation and reasoning _ , pages 6878 .",
    "aaai press , 2006 .",
    "r.  rosati . on combining description logic ontologies and nonrecursive datalog rules .",
    "in d.  calvanese and g.  lausen , editors , _ web reasoning and rule systems _ , volume 5341 of _ lecture notes in computer science _ , pages 1327 .",
    "springer , 2008 .    c.  rouveirol and v.  ventos . towards learning in carin-@xmath187 . in j.",
    "cussens and a.  frisch , editors , _ inductive logic programming _ , volume 1866 of _ lecture notes in artificial intelligence _",
    ", pages 191208 .",
    "springer , 2000 .",
    "e. ruckhaus , v. kolovski , b. parsia , and b. cuenca  grau .",
    "integrating datalog with owl : exploring the @xmath25-log approach . in s. etalle and m. truszczynski , editors , _ logic programming _ ,",
    "volume 4079 of _ lecture notes in computer science _ , pages 455456 .",
    "springer , 2006 .    c.  sakama .",
    "nonmonotonic inductive logic programming . in t.",
    "eiter , w.  faber , and m.  truszczynski , editors , _ logic programming and nonmonotonic reasoning _ , volume 2173 of _ lecture notes in computer science _ , pages 6280 .",
    "springer , 2001 .",
    "l.  stojanovic , a.  maedche , b.  motik , and n.  stojanovic .",
    "user - driven ontology evolution management . in a.  gmez - prez and v.r .",
    "benjamins , editors , _ knowledge engineering and knowledge management .",
    "ontologies and the semantic web _ ,",
    "volume 2473 of _ lncs _ , pages 285300 .",
    "springer , 2002 ."
  ],
  "abstract_text": [
    "<S> rules complement and extend ontologies on the semantic web . we refer to these rules as onto - relational since they combine dl - based ontology languages and knowledge representation formalisms supporting the relational data model within the tradition of logic programming and deductive databases . </S>",
    "<S> rule authoring is a very demanding knowledge engineering task which can be automated though partially by applying machine learning algorithms . in this chapter </S>",
    "<S> we show how inductive logic programming ( ilp ) , born at the intersection of machine learning and logic programming and considered as a major approach to relational learning , can be adapted to onto - relational learning . for the sake of illustration </S>",
    "<S> , we provide details of a specific onto - relational learning solution to the problem of learning rule - based definitions of dl concepts and roles with ilp .    ,    inductive logic programming , rule languages and systems , integration of rules and ontologies , deductive databases . </S>"
  ]
}