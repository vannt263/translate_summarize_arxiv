{
  "article_text": [
    "backdoors are small sets of variables of a sat or csp instance that represent `` clever reasoning shortcuts '' through the search space .",
    "backdoor sets were originally introduced by williams , gomes , and selman  ( @xcite ) as a tool for the analysis of decision heuristics in propositional satisfiability . since then",
    ", backdoor sets have been widely used in the areas of propositional satisfiability  @xcite , and also for material discovery @xcite , abductive reasoning  @xcite , argumentation  @xcite , quantified boolean formulas  @xcite , and planning  @xcite .",
    "a backdoor set is defined with respect to some fixed _ base class _ for which the computational problem under consideration is polynomial - time tractable ( alternatively , it can be defined with respect to a polynomial - time subsolver ) .",
    "the size of the backdoor set can be seen as a distance measure that indicates how far the instance is from the target class .",
    "one distinguishes between strong and weak backdoor sets ; the latter applies only to satisfiable instances .",
    "once a strong backdoor set of size @xmath0 is identified , one can decide the satisfiability of the instance by deciding the satisfiability of at most @xmath1 `` easy '' instances that belong to the tractable base class , where @xmath2 denotes the size of the domain for the variables ; for sat we have @xmath3 .",
    "each of the easy instances is obtained by one of the @xmath1 possible instantiations of the @xmath0 variables in the backdoor set .",
    "hence , the satisfiability check is _ fixed - parameter tractable _ for the combined parameter backdoor size and domain size ( @xmath4 ) .",
    "a similar approach works for weak backdoor sets , where the computation of a certificate for satisfiability ( i.e. , a satisfying assignment ) is fixed - parameter tractable for the combined parameter ( @xmath4 ) .",
    "the fixed - parameter tractability of using the backdoor set for deciding satisfiability or the computation of a certificate for satisfiability triggers the question of whether _ finding _ a backdoor set of size at most @xmath0 is also fixed - parameter tractable . in particular",
    ", for every base class @xmath5 one can ask whether the detection of a strong or weak backdoor set into @xmath5 of size at most @xmath0 is fixed - parameter tractable for parameter  @xmath0 ( possibly in combination with restrictions on the input or other parameters ) .",
    "a systematic study of the parameterized complexity of backdoor set detection was initiated by  @xcite for sat , who showed that the detection of strong backdoor sets into the classes horn and 2cnf is fixed - parameter tractable , but the detection of weak backdoor sets into any of these two classes is @xmath6}}$]hard ( and hence unlikely to be fixed - parameter tractable ) . since then",
    ", the parameterized complexity of backdoor set detection has become an active research topic as outlined in a survey @xcite .    in this work ,",
    "we provide two significant extensions to the exciting research on fixed - parameter tractable backdoor set detection .",
    "first , we introduce _ heterogeneous _ base classes , which can be composed of several homogeneous base classes .",
    "we show that heterogeneous base classes are particularly well - suited for strong backdoor sets , since they allow that different instantiations of the backdoor variables result in instances that belong to different base classes , which leads to arbitrary reductions in the size of a strong backdoor set even compared to the smallest strong backdoor set for each individual homogeneous base class . this is in contrast to weak backdoor sets , where the size of a weak backdoor set into a heterogeneous base class is equal to the size of the smallest backdoor set into any of the individual base classes . here",
    "we show that also the complexity of weak backdoor set detection into heterogeneous base classes is tight to its complexity on the individual base classes .",
    "second , we extend the scope of backdoor set detection from sat to csp , considering target classes that are defined by tractable constraint languages in terms of certain _ closure properties under polymorphisms_.    [ [ heterogeneous - base - classes ] ] heterogeneous base classes + + + + + + + + + + + + + + + + + + + + + + + + + +    consider the following sat instance @xmath7 where @xmath8 and @xmath9 .",
    "it is easy to see that any strong backdoor set into horn needs to contain at least one of the variables @xmath10 or @xmath11 from each clause @xmath12 , hence such a backdoor set must be of size @xmath13 ; on the other hand , any strong backdoor set into 2cnf must contain at least @xmath14 variables from the clause @xmath15 ; hence such a backdoor must be of size at @xmath13 as well .",
    "however , @xmath16 $ ] is horn , and @xmath17 $ ] is a 2cnf , hence the singleton @xmath18 constitutes a strong backdoor set into the _ `` heterogeneous '' _ base class @xmath19 .",
    "this example shows that by considering heterogeneous base classes we can access structural properties of instances that are not accessible by backdoor sets into homogeneous base classes . identifying a base class with a class of instances that are solvable by a particular polynomial - time subsolver , one can consider a heterogeneous base class as a `` portfolio subsolver , '' where for each instance the best suitable subsolver from the portfolio is chosen .",
    "[ [ sat - backdoor - sets ] ] sat backdoor sets + + + + + + + + + + + + + + + + +    a natural question at this point is whether the fixed - parameter tractability results for the detection of strong backdoor sets into individual base classes can be extended to more powerful heterogeneous base classes . in this work ,",
    "we completely characterize the complexity landscape for heterogeneous base classes obtained arbitrary combinations of the well - known schaefer classes  @xcite , in the following denoted by @xmath20 ( for horn formulas ) , @xmath21 ( for anti - horn formulas ) , @xmath22 ( for 2-cnf formulas ) , @xmath23 ( for zero valid formulas ) , and @xmath24 ( for one valid formulas ) .",
    "to state the classification , we briefly introduce some terminology .",
    "we say that a pair @xmath25 of schaefer classes is a _ bad pair _ if @xmath26 and @xmath27 .",
    "let @xmath5 be a class of cnf - formulas such that @xmath28 for some subset @xmath29 of the schaefer classes .",
    "our main result for sat backdoor sets ( theorem  [ the : sat - dico ] ) is that strong @xmath5backdoor detection is fixed parameter tractable if and only if @xmath29 does not contain a bad pair of schaefer classes , otherwise it is @xmath6}}$]-hard . on the other hand ,",
    "detecting weak backdoors is always @xmath6}}$]-hard for any choice of @xmath5 , and we show this by building on the known hardness results for when @xmath5 is a singleton set ( theorem  [ wbd : w - hard ] ) .",
    "we also show that strong @xmath5backdoor detection as well as weak @xmath5backdoor detection are fixed - parameter tractable for the combined parameter @xmath0 and the maximum length @xmath30 of a clause of the input formula ( theorem  [ the : sat - clause - sb ] and  [ the : sat - clause - wb ] ) .",
    "these fpt algorithms formalize the intuition that all the hardness results in the previous classification result exploit clauses of unbounded length .",
    "[ [ csp - backdoor - sets ] ] csp backdoor sets + + + + + + + + + + + + + + + + +    the identification of tractable classes of csp instances has been subject of extensive studies . a prominent line of research , initiated by @xcite in his seminal paper on boolean csp , is to identify tractable classes by restricting the relations that may appear in constraints to a prescribed set , a constraint language . today , many constraint languages have been identified that give rise to tractable classes of csps @xcite ; typically such languages are defined in terms of certain _ closure properties _ , which ensure that the relations are closed under pointwise application of certain polymorphisms of the domain .",
    "for instance , consider a csp instance whose relations are closed under a constant function @xmath31 for some @xmath32 ( such a function is a polymorphism of the relations in the instance ) . then note that every relation is either empty or forced to contain the tuple @xmath33 .",
    "thus , given a particular instance , we may either declare it unsatisfiable ( if it contains a constraint over the empty relation ) , or satisfy it trivially by setting every variable to @xmath2 .",
    "further examples of polymorphisms for which closure properties yield tractable csp are min , max , majority , affine , and malcev polymorphisms @xcite .",
    "we study the problem of finding strong and weak backdoor sets into tractable classes of csp instances defined by certain polymorphisms .",
    "our main result for csp backdoors ( theorem  [ the : fpt - csp ] ) establishes fixed - parameter tractability for a wide range of such base classes .",
    "in particular , we show that the detection of strong and weak backdoor sets is fixed - parameter tractable for the combined parameter backdoor size , domain size , and the maximum arity of constraints .",
    "in fact , this result entails _ heterogeneous _ base classes , as different instantiations of the backdoor variables can lead to reduced instances that are closed under different polymorphisms ( even polymorphisms of different type ) .",
    "we complement our main result with hardness results that show that we loose fixed - parameter tractability when we omit either domain size or the maximum arity of constraints from the parameter ( theorems  [ the : domain ] and [ the - arity2 ] ) .",
    "hence , theorem  [ the : fpt - csp ] is tight in a certain sense .",
    "[ [ related - work ] ] related work + + + + + + + + + + + +    recently , two papers dealing with strong backdoor set detection for the constraint satisfaction problem have appeared  @xcite , which nicely supplement ( however are mostly orthogonal to ) the results in this paper . @xcite",
    "show @xmath6}}$]-hardness for strong backdoor set detection parameterized by the size of the backdoor set even for csp - instances with only one constraint ( however with unbounded domain and unbounded arity ) .",
    "they also give a fixed - parameter algorithm for strong backdoor set detection parameterized by the size of the backdoor set and the maximum arity of any constraint , if the base class is `` h - helly '' for any fixed integer @xmath34 and under the additional assumption that the domain is a finite subset of the natural numbers , which comes with a fixed ordering .",
    "however , as is also mentioned in  @xcite , the `` h - helly '' property is rather restrictive and orthogonal to our approach of considering the domain as an additional parameter .",
    "@xcite show fixed - parameter tractability of strong backdoor detection parameterized by the size of the backdoor to a very general family of heterogeneous base classes , i.e. , base classes defined as all csp - instances obtained from the disjoint union of tractable , finite , and semi - conservative constraint languages .",
    "these base classes are orthogonal to the base classes considered in this paper .",
    "they are more general in the sense that their allow for the csp - instance to consists of the disjoint union of different tractable classes , and they are more specific in the sense that they only consider finite and semi - conservative constraint languages , which also restricts the csp - instances to bounded domain and bounded arity .",
    "[ [ sat ] ] sat + + +    a _ literal _ is a propositional variable @xmath35 or a negated variable @xmath36 .",
    "we also use the notation @xmath37 and @xmath38 .",
    "a _ clause _ is a finite set of literals that does not contain a complementary pair @xmath35 and @xmath36 .",
    "a propositional formula in conjunctive normal form , or _ cnf formula _ for short , is a set of clauses . for a clause @xmath15",
    "we write @xmath39 or @xmath40 , and for a cnf formula @xmath41 we write @xmath42 .    for a set @xmath43 of propositional variables we denote by @xmath44 the set of all mappings from @xmath43 to @xmath45 , the truth assignments on @xmath43 .",
    "we denote by @xmath46 the set of literals corresponding to the negated variables of @xmath43 .",
    "for @xmath47 we let @xmath48 and @xmath49 be the sets of literals set by @xmath50 to @xmath51 and @xmath52 , respectively . given a cnf formula @xmath41 and a truth assignment @xmath47 we define @xmath53={\\{\\,}\\newcommand{\\sm}{\\;{:}\\;}\\newcommand{\\se}{\\,\\}}c\\setminus \\text{false}(\\tau ) \\sm c\\in f,\\ c\\cap\\text{true}(\\tau)= \\emptyset\\,\\}$ ] . if @xmath54 and @xmath55 , we simply write @xmath56 $ ] instead of @xmath53 $ ] .    a cnf formula @xmath41 is _ satisfiable _ if there is some @xmath57 with @xmath53=\\emptyset$ ] , otherwise @xmath41 is _",
    "unsatisfiable_.    [ [ csp ] ] csp + + +    let @xmath58 be a set and @xmath59 and @xmath60 be natural numbers .",
    "an @xmath59-ary relation on @xmath58 is a subset of @xmath61 . for a tuple @xmath62 ,",
    "we denote by @xmath63 $ ] , the @xmath64-th entry of @xmath65 , where @xmath66 . for two tuples @xmath62 and @xmath67",
    ", we denote by @xmath68 , the concatenation of @xmath65 and @xmath69 .",
    "an instance of a _ constraint satisfaction problem _ ( csp ) @xmath70 is a triple @xmath71 , where @xmath72 is a finite set of variables over a finite set ( domain ) @xmath58 , and @xmath15 is a set of constraints .",
    "a _ constraint _ @xmath73 consists of a _ scope _ , denoted by @xmath74 , which is an ordered list of a subset of @xmath72 , and a relation , denoted by @xmath75 , which is a @xmath76-ary relation on @xmath58 . to simplify notation",
    ", we sometimes treat ordered lists without repetitions , such as the scope of a constraint , like sets . for a variable @xmath77 and a tuple @xmath78 ,",
    "we denote by @xmath79 $ ] , the @xmath64-th entry of @xmath65 , where @xmath64 is the position of @xmath80 in @xmath74 . for a csp instance @xmath81",
    "we sometimes denote by @xmath82 , @xmath83 , @xmath84 , and @xmath85 , its set of variables @xmath72 , its domain @xmath58 , its set of constraints @xmath15 , and the maximum arity of any constraint of @xmath70 , respectively .",
    "let @xmath86 and @xmath87 .",
    "for a constraint @xmath73 , we denote by @xmath88 $ ] , the constraint whose scope is @xmath89 and whose relation contains all @xmath90)|$]-ary tuples @xmath65 such that there is a @xmath76-ary tuple @xmath91 with @xmath79=t'[v]$ ] for every @xmath92)$ ] and @xmath93=\\tau(v)$ ] for every @xmath94 .",
    "we denote by @xmath95 $ ] the csp instance with variables @xmath96 , domain @xmath58 , and constraints @xmath97 $ ] , where @xmath97 $ ] contains a constraint @xmath88 $ ] for every @xmath73 .",
    "a _ solution _ to a csp instance @xmath70 is a mapping @xmath98 such that @xmath99,\\dotsc,\\tau[v_{|v(c)|}]}\\rangle } \\in r(c)$ ] for every @xmath73 with @xmath100 .",
    "[ [ backdoors ] ] backdoors + + + + + + + + +    backdoors are defined relative to some fixed class @xmath5 of instances of the problem under consideration ( i.e. , sat or csp ) .",
    "one usually assumes that the problem is tractable for instances from @xmath5 , as well as that the recognition of @xmath5 is tractable .    in the context of sat",
    ", we define a _ strong _ _ @xmath5-backdoor set _ of a cnf formula @xmath41 to be a set @xmath101 of variables such that @xmath53\\in { \\mathcal{c}}$ ] for each @xmath102 .",
    "a _ weak _ _",
    "@xmath5-backdoor set _ of @xmath41 is a set @xmath101 of variables such that @xmath53 $ ] is satisfiable and @xmath53\\in { \\mathcal{c}}$ ] holds for some @xmath102 . if we know a strong @xmath5-backdoor set of @xmath41 , we can decide the satisfiability of @xmath41 by checking the satisfiability of @xmath103 `` easy '' formulas @xmath53 $ ] that belong to @xmath5 .",
    "thus sat decision is fixed - parameter tractable in the size @xmath0 of the backdoor .",
    "similarly , in the context of csp , we define a _ strong _ _ @xmath5-backdoor set _ of a csp instance @xmath81 as a set @xmath101 of variables such that @xmath95\\in { \\mathcal{c}}$ ] for every @xmath104 .",
    "we also call a strong @xmath5backdoor a _ strong backdoor set into @xmath5_. a _ weak _ _",
    "@xmath5-backdoor set _ of @xmath70 is a set @xmath101 of variables such that @xmath95 $ ] is satisfiable and @xmath95\\in { \\mathcal{c}}$ ] holds for some @xmath104 . if we know a strong @xmath5-backdoor set of @xmath70 of size @xmath0 , we can reduce the satisfiability of @xmath70 to the satisfiability of @xmath1 csp instances in @xmath5 where @xmath105 . thus deciding the satisfiability of a csp instance is fixed - parameter tractable in the combined parameter @xmath106 .",
    "the challenging problem is  for sat and for csp  to find a strong , or weak @xmath5backdoor set of size at most @xmath0 if one exists .    for each class @xmath5 of sat or csp instances , we define the following problem .    the problem weak @xmath5backdoor detection is defined similarly .    [",
    "[ parameterized - complexity ] ] parameterized complexity + + + + + + + + + + + + + + + + + + + + + + + +    we provide basic definitions of parameterized complexity ; for an in - depth treatment we refer to the recent monograph @xcite .",
    "a problem is _ parameterized _ if each problem instance @xmath107 is associated with a nonnegative integer @xmath0 , the parameter .",
    "a parameterized problem is _ fixed - parameter tractable _ ( or _ fpt _ , for short ) if there is an algorithm , @xmath108 , a constant @xmath109 , and a computable function @xmath110 , such that @xmath108 solves instances of input size @xmath59 and parameter @xmath0 in time @xmath111 .",
    "fixed - parameter tractability extends the conventional notion of polynomial - time tractability , the latter being the special case where @xmath110 is a polynomial .",
    "the so - called weft - hierarchy @xmath112}}\\subseteq { \\text{\\normalfont w[2 ] } } \\subseteq \\dots$ ] contains classes of parameterized decision problems that are presumed to be larger than fpt .",
    "it is believed that problems that are hard for any of the classes in the weft - hierarchy are not fixed - parameter tractable .",
    "the classes are closed under _ fpt - reductions _ that are fixed - parameter tractable many - one reductions , which map an instance @xmath35 with parameter @xmath0 of one problem to a decision - equivalent instance @xmath113 with parameter @xmath114 of another problem , where @xmath115 for some computable function @xmath110 .",
    "for instance , the following problem is well - known to be @xmath6}}$]complete @xcite .",
    "schaefer s base classes @xcite give rise to classes of cnf formulas defined in terms of syntactical properties of clauses .. ]    a clause is    * _ horn _ if it contains at most one positive literal , * _ anti - horn _ if it contains at most one negative literal , * _ 2cnf _ if it contains at most two literals , * _ 0-valid _ if it contains at least one negative literal , and * _ 1-valid _ if it contains at least one positive literal .",
    "a cnf formula is _ horn _ , _ anti - horn _ , etc .  if it contains only horn , anti - horn , etc.clauses .",
    "we denote the respective classes of cnf formulas by horn , horn@xmath116 , 2cnf , 0-val , and 1-val .",
    "strong @xmath5backdoor detection is polynomial for 0-val and 1-val , and fpt for the remaining schaefer classes @xcite .",
    "these fpt algorithms are based on constant - size obstruction sets . for a clause @xmath109 , we say that a set @xmath43 of variables is a @xmath5-obstruction for @xmath109 if @xmath117 and @xmath118 for all literals @xmath119 .",
    "a horn - obstruction contains two variables occurring positively in the clause , a horn@xmath116-obstruction contains two variables occurring negatively in the clause , and a 2cnf - obstruction contains three variables occurring positively or negatively in the clause .",
    "it is well - known that , for @xmath120 , every strong @xmath5-backdoor set contains a variable from each @xmath5-obstruction for each clause in the formula @xcite . in this section ,",
    "we focus on algorithms for finding strong backdoors into heterogeneous base classes .",
    "these algorithms also use these obstruction sets for branching , but the heterogeneity of the base class makes it significantly more challenging to design the fpt algorithms .",
    "the results in this subsection are as follows .",
    "first , in theorem  [ the : sat - fpt - krom ] , we show that if @xmath121 , strong @xmath122backdoor detection is fixed - parameter tractable for parameter @xmath0 . in theorem  [ the : sat - fpt - horn - zval ] ,",
    "we show that strong @xmath123backdoor detection and strong @xmath124backdoor detection are fixed - parameter tractable for parameter @xmath0 .",
    "finally , in theorem  [ the : sat - fpt - triple ] , we show that strong @xmath125backdoor detection and strong @xmath126backdoor detection are fixed - parameter tractable for parameter @xmath0 . in contrast ,",
    "theorem  [ the : sat - bp - w2 ] captures a condition for hardness of the strong backdoor detection problem , which is complementary to all the cases in the first three results .",
    "together , and combined with known results in the literature , these theorems give us a complete complexity classification , which is summarized in theorem  [ the : sat - dico ] .",
    "our hardness results rely on the fact that the clauses have unbounded length .",
    "theorem  [ the : sat - clause - sb ] shows that if we consider the maximum length of any clause as an additional parameter , then the problem of finding a strong heterogeneous backdoor becomes fixed - parameter tractable for any combination of the schaefer classes .",
    "our first tractability result is for strong @xmath122backdoor detection , where @xmath121 . before formally stating the algorithm",
    ", we provide a brief intuition for the branching rules .",
    "typically , we branch on an obstructing clause ( or a pair of obstructing clauses ) , a situation that occurs in one of two flavors :    1 .",
    "either there is a clause @xmath15 that is not in @xmath122 , or , 2 .",
    "there is a pair of clauses @xmath15 and @xmath127 , where @xmath128 and @xmath129 .    consider the case when @xmath130 . in scenario",
    "( 1 ) , the formula has a clause @xmath15 of length at least three with only positive literals .",
    "if this clause has more than @xmath131 literals , then there is no strong backdoor of size @xmath0 to @xmath132 .",
    "otherwise , the clause has at most @xmath131 literals on which we can branch exhaustively . in scenario ( 2 ) , we know that @xmath15 has at most two literals and any strong backdoor set that does not contain a variable form @xmath15 must reduce @xmath127 to a clause with at most two literals .",
    "hence , we can branch on the variables in @xmath15 and any subset of three variables in @xmath127 .",
    "consider the case when @xmath133 . in scenario",
    "( 1 ) above , the formula has a clause @xmath15 of length at least three with at least two positive literals , say @xmath35 and @xmath134 .",
    "let @xmath135 be any other literal in @xmath15 .",
    "it is clear that any strong backdoor set must contain one of @xmath35 , @xmath134 or @xmath135 , and we branch accordingly . in scenario",
    "( 2 ) , we know that @xmath15 has at most two literals and @xmath127 contains at least two positive literals . because every strong backdoor set that does not contain a variable form @xmath15 must reduce @xmath127 to a clause with at most two literals , we can branch on the variables in @xmath15 and any subset of three variables in @xmath127 .",
    "the intuitive explanations for @xmath24 and @xmath21 are analogous .",
    "note that the criteria described above need to be refined further at internal nodes of the branching process .",
    "we now turn to a formal description of the algorithm , proof of correctness , and running time .    [ the : sat - fpt - krom ] let @xmath121 .",
    "then , strong @xmath136backdoor detection is fixed - parameter tractable for parameter @xmath0 .",
    "the algorithm uses a depth - bounded search tree approach to find a strong @xmath122-backdoor set of size at most @xmath0 .",
    "let @xmath41 be any cnf - formula with variables @xmath72 .",
    "we construct a search tree @xmath137 , for which every node is labeled by a set @xmath101 of at most @xmath0 variables of @xmath72 .",
    "additionally , every leaf node has a second label , which is either yes or no .",
    "@xmath137 is defined inductively as follows .",
    "the root of @xmath137 is labeled by the empty set .",
    "furthermore , if @xmath65 is a node of @xmath137 , whose first label is @xmath101 , then the children of @xmath65 in @xmath137 are obtained as follows .",
    "if for every assignment @xmath102 , @xmath53 \\in { \\textup{2cnf}}\\cup { \\mathcal{c}}$ ] , then @xmath101 is a strong @xmath122-backdoor set of size at most @xmath0 , and hence @xmath65 becomes a leaf node , whose second label is yes . otherwise , i.e. , if there is an assignment @xmath102 such that @xmath53 \\notin { \\textup{2cnf}}\\cup { \\mathcal{c}}$ ] , we consider two cases :    1 .",
    "@xmath138 , then @xmath65 becomes a leaf node , whose second label is no , 2 .",
    "otherwise , i.e. , if @xmath139 , then we again distinguish two cases : 1 .   there is a clause @xmath140 $ ] with @xmath141 , then we again distinguish two cases : 1 .   if @xmath142 , then let @xmath143 be a subset of @xmath15 with @xmath144 and @xmath145",
    "then , for every @xmath80 in @xmath146 , @xmath65 has a child whose first label is @xmath147 .",
    "2 .   if @xmath148 , then we again distinguish two cases : 1 .",
    "@xmath149 , then @xmath65 becomes a leaf node , whose second label is no , 2 .",
    "otherwise , i.e. , if @xmath150 , then for every two element subset @xmath143 of @xmath15 , @xmath65 has a child whose first label is @xmath151 .",
    "2 .   otherwise , there is a clause @xmath15 in @xmath53 $ ] with @xmath152 and a clause @xmath127 in @xmath53 $ ] with @xmath153 .",
    "let @xmath143 be the set of variables containing the ( at most ) two variables from @xmath15 plus any three element subset of variables from @xmath127 .",
    "then , for every @xmath80 in @xmath143 , @xmath65 has a child whose first label is @xmath147 .",
    "if @xmath137 has a leaf node , whose second label is yes , then the algorithm returns the first label of that leaf node .",
    "otherwise the algorithm returns no .",
    "this completes the description of the algorithm .",
    "we now show the correctness of the algorithm .",
    "first , suppose the search tree @xmath137 built by the algorithm has a leaf node @xmath65 whose second label is yes . here ,",
    "the algorithm returns the first label , say @xmath101 of @xmath65 . by definition of @xmath137",
    ", we obtain that @xmath154 and for every assignment @xmath102 , it holds that @xmath53 \\in { \\textup{2cnf}}\\cup    { \\mathcal{c}}$ ] , as required .",
    "now consider the case where the algorithm returns no .",
    "we need to show that there is no set @xmath101 of at most @xmath0 variables of @xmath41 such that @xmath53 \\in { \\textup{2cnf}}\\cup { \\mathcal{c}}$ ] for every assignment @xmath50 of the variables of @xmath101 .",
    "assume , for the sake of contradiction that such a set @xmath101 exists .",
    "observe that if @xmath137 has a leaf node @xmath65 whose first label is a set @xmath155 with @xmath156 , then the second label of @xmath65 must be yes .",
    "assume for a contradiction that this is not the case , then either case ( 1 ) or case ( 2.a.ii.a ) applied for @xmath65 .",
    "in the former case @xmath155 is not a strong @xmath122-backdoor set for @xmath41 and @xmath157 .",
    "hence , @xmath158 contradicting our assumption that @xmath101 is a strong @xmath122-backdoor set for @xmath41 . in the later case",
    ", we obtain that there is an assignment @xmath159 and a clause @xmath140 $ ] such that ( 1 ) @xmath160 , ( 2 ) @xmath161 and ( 3 ) @xmath162 .",
    "it follows from ( 3 ) that @xmath101 misses at least @xmath163 literals from @xmath15 .",
    "hence , there is an assignment @xmath164 that is compatible with @xmath50 such that @xmath165 $ ] contains a clause @xmath166 with @xmath167 .",
    "hence , @xmath168 and because @xmath166 , we obtain from ( 1 ) and ( 2 ) that @xmath169 .",
    "hence , @xmath170 , contradicting our assumption that @xmath101 is a strong @xmath122-backdoor set for @xmath41 .",
    "it hence remains to show that @xmath137 has a leaf node whose first label is a set @xmath155 with @xmath156 .",
    "this will complete the proof about the correctness of the algorithm .",
    "we will show a slightly stronger statement , namely , that for every natural number @xmath135 , either @xmath137 has a leaf whose first label is contained in @xmath101 or @xmath137 has an inner node of distance exactly @xmath135 from the root whose first label is contained in @xmath101 .",
    "we show the latter by induction on @xmath135 .",
    "the claim obviously holds for @xmath171 .",
    "so assume that @xmath137 contains a node @xmath65 at distance @xmath135 from the root of @xmath137 whose first label , say @xmath155 , is a subset of @xmath101 .",
    "if @xmath65 is a leaf node of @xmath137 , then the claim is shown .",
    "otherwise , there is an assignment @xmath159 such that @xmath53 \\notin { \\textup{2cnf}}\\cup { \\mathcal{c}}$ ] and one of the cases ( 2.a.i ) , ( 2.a.ii.b ) , and ( 2.b ) applies to @xmath65 .    1 .   in this case",
    "there is a clause @xmath140 $ ] with @xmath160 , @xmath142 and a set of three literals @xmath172 with @xmath145 such that @xmath65 has one child whose first label is @xmath173 for every @xmath174 . it remains to show that @xmath175 .",
    "assume not , and let @xmath176 be an assignment compatible with @xmath50 that does not satisfy any literal of @xmath15 .",
    "then , @xmath177 $ ] contains a superset of @xmath143 as a clause and hence @xmath177 \\notin { \\textup{2cnf}}\\cup { \\mathcal{c}}$ ] .",
    "2 .   in this case",
    "there is a clause @xmath140 $ ] with @xmath160 , @xmath178 and @xmath65 has one child whose first label is @xmath179 for every two element subset @xmath143 of @xmath15 . it remains to show that @xmath180 .",
    "assume not , and let @xmath176 be an assignment compatible with @xmath50 that does not satisfy any literal of @xmath15 .",
    "then , @xmath181 \\in f[\\tau^*]$ ] and because @xmath182|>2 $ ] and @xmath181 \\notin { \\mathcal{c}}$ ] , also @xmath177 \\notin { \\textup{2cnf}}\\cup { \\mathcal{c}}$ ] .",
    "3 .   in this case",
    "there is a clause @xmath15 in @xmath53 $ ] with @xmath183 and a clause @xmath127 in @xmath53 $ ] with @xmath184 and a set @xmath143 of variables containing all variables from @xmath15 a subset of variables of @xmath127 such that @xmath65 has one child whose first label is @xmath173 for every @xmath185 .",
    "it remains to show that @xmath175 .",
    "assume not , and let @xmath176 be an assignment compatible with @xmath50 that does not satisfy any literal of @xmath127 .",
    "then , @xmath177 $ ] contains the clause @xmath15 together with a subclause @xmath186 of @xmath127 containing at least three literals . because @xmath187 and @xmath188 , we obtain that @xmath177 \\notin { \\textup{2cnf}}\\cup { \\mathcal{c}}$ ] .",
    "this concludes our proof concerning the correctness of the algorithm .",
    "the running time of the algorithm is obtained as follows .",
    "let @xmath137 be a search tree obtained by the algorithm .",
    "then the running time of the depth - bounded search tree algorithm is @xmath189 times the maximum time that is spend on any node of @xmath137 .",
    "according to the three branching rules given in ( 2.a.i ) , ( 2.a.ii.b ) , and ( 2.b ) we obtain that @xmath190 can be bounded by the maximum of the following recurrence relations : ( 1 ) @xmath191 ( 2.a.i ) , ( 2 ) @xmath192 for any @xmath193 ( 2.a.ii.b ) , and ( 3 ) @xmath194 ( 2.b ) . in case of ( 1 ) @xmath195 is at most @xmath196 , in case of ( 2 ) the maximum of @xmath197 is obtained for @xmath195 by setting @xmath198 , and in case of ( 3 ) @xmath195 is at most @xmath199 .",
    "it follows that @xmath200 .",
    "furthermore , the time required for any node @xmath65 of @xmath137 is at most @xmath201 . putting everything together , we obtain @xmath202 , as the total running time of the algorithm .",
    "this shows that strong @xmath203backdoor detection is fixed - parameter tractable parameterized by @xmath0 .",
    "we now turn to the case when the base classes are either @xmath204 or @xmath124 .    as before , in scenario ( 1 ) , the length of an obstructing clause must be bounded in a yes - instance .",
    "indeed , consider a clause @xmath15 that is not in @xmath123 .",
    "such a clause has only positive literals , and any strong backdoor must contain all these literals but one .",
    "therefore , if the clause has more than @xmath205 literals , we reject the instance , otherwise the clause length is bounded , allowing for a bounded branching strategy .    in scenario",
    "( 2 ) , on the other hand , we have a pair of obstructing clauses , say @xmath206 , and @xmath207 .",
    "now , note that @xmath15 can have only one literal by definition .",
    "let @xmath143 be any subset of two positive literals from @xmath127 .",
    "note that any strong backdoor must intersect either @xmath143 or the unique literal in @xmath15 , which again leads us to a feasible branching step .",
    "we now turn to a formal description of the algorithm .    [ the : sat - fpt - horn - zval ] strong @xmath123backdoor detection and strong @xmath124backdoor detection are fixed - parameter tractable for parameter @xmath0 .",
    "we only give the proof for the class @xmath123 , as the proof for the class @xmath124 is analogous .",
    "the algorithm uses a depth - bounded search tree approach to find a strong @xmath208-backdoor set of size at most @xmath0 .",
    "let @xmath41 be any cnf - formula with variables @xmath72 .",
    "we construct a search tree @xmath137 , for which every node is labeled by a set @xmath101 of at most @xmath0 variables of @xmath72 .",
    "additionally , every leaf node has a second label , which is either yes or no .",
    "@xmath137 is defined inductively as follows .",
    "the root of @xmath137 is labeled by the empty set .",
    "furthermore , if @xmath65 is a node of @xmath137 , whose first label is @xmath101 , then the children of @xmath65 in @xmath137 are obtained as follows .",
    "if for every assignment @xmath102 , @xmath53 \\in { \\textup{horn}}\\cup { \\textup{0-val}}$ ] , then @xmath101 is a strong @xmath123-backdoor set of size at most @xmath0 , and hence @xmath65 becomes a leaf node , whose second label is yes . otherwise , i.e. , if there is an assignment @xmath102 such that @xmath53 \\notin { \\textup{horn}}\\cup { \\textup{0-val}}$ ] , we consider two cases :    1 .",
    "@xmath138 , then @xmath65 becomes a leaf node , whose second label is no , 2 .   otherwise , i.e. , if @xmath139 , then we again distinguish two cases : 1 .",
    "there is a clause @xmath140 $ ] with @xmath209 , then we again distinguish two cases : 1 .",
    "@xmath210 , then @xmath65 becomes a leaf node , whose second label is no , 2 .",
    "otherwise , i.e. , if @xmath211 , then for every variable @xmath80 of @xmath15 , @xmath65 has a child whose first label is @xmath212 .",
    "2 .   otherwise , there is a clause @xmath15 in @xmath53 $ ] with @xmath213 and a clause @xmath127 in @xmath53 $ ] with @xmath214 .",
    "let @xmath143 be the set of variables containing the one variable from @xmath15 plus any two variables corresponding to two positive literals from @xmath127 .",
    "then , for every @xmath80 in @xmath143 , @xmath65 has a child whose first label is @xmath147 .",
    "if @xmath137 has a leaf node , whose second label is yes , then the algorithm returns the first label of that leaf node .",
    "otherwise the algorithm returns no .",
    "this completes the description of the algorithm .",
    "we now show the correctness of the algorithm . first , suppose the search tree @xmath137 built by the algorithm has a leaf node @xmath65 whose second label is yes . here",
    ", the algorithm returns the first label , say @xmath101 of @xmath65 . by definition of @xmath137",
    ", we obtain that @xmath154 and for every assignment @xmath102 , it holds that @xmath53 \\in { \\textup{horn}}\\cup { \\textup{0-val}}$ ] , as required .    now consider the case where the algorithm returns no .",
    "we need to show that there is no set @xmath101 of at most @xmath0 variables of @xmath41 such that @xmath53 \\in { \\textup{horn}}\\cup { \\textup{0-val}}$ ] for every assignment @xmath50 of the variables of @xmath101 .",
    "assume , for the sake of contradiction that such a set @xmath101 exists .",
    "observe that if @xmath137 has a leaf node @xmath65 whose first label is a set @xmath155 with @xmath156 , then the second label of @xmath65 must be yes .",
    "assume for a contradiction that this is not the case , then either case ( 1 ) or case ( 2.a.i ) applied for @xmath65 .",
    "in the former case @xmath157 and hence @xmath158 and @xmath155 is not a strong @xmath123-backdoor set for @xmath41 , contradicting our assumption that @xmath101 is a strong @xmath123-backdoor set for @xmath41 . in the later case",
    ", we obtain that there is an assignment @xmath159 and a clause @xmath140 $ ] with @xmath215 such that @xmath216 .",
    "hence , @xmath101 misses at least @xmath217 literals from @xmath15 .",
    "consequently , for any assignment @xmath218 that is compatible with @xmath50 and does not satisfy any literal from @xmath15 , @xmath165 $ ] contains a subclause of @xmath15 that contains at least @xmath217 literals .",
    "it follows that @xmath165 \\notin { \\textup{horn}}\\cup { \\textup{0-val}}$ ] , contradicting our assumption that @xmath101 is a strong @xmath123-backdoor set for @xmath41 .",
    "it hence remains to show that @xmath137 has a leaf node whose first label is a set @xmath155 with @xmath156 .",
    "this will complete the proof about the correctness of the algorithm .",
    "we will show a slightly stronger statement , namely , that for every natural number @xmath135 , either @xmath137 has a leaf whose first label is contained in @xmath101 or @xmath137 has an inner node of distance exactly @xmath135 from the root whose first label is contained in @xmath101 .",
    "we show the latter by induction on @xmath135 .",
    "the claim obviously holds for @xmath171 .",
    "so assume that @xmath137 contains a node @xmath65 at distance @xmath135 from the root of @xmath137 whose first label , say @xmath155 , is a subset of @xmath101 .",
    "if @xmath65 is a leaf node of @xmath137 , then the claim is shown .",
    "otherwise , there is an assignment @xmath159 such that @xmath53 \\notin { \\textup{horn}}\\cup { \\textup{0-val}}$ ] and one of the cases ( 2.a.ii ) and ( 2.b ) applies to @xmath65 .    1",
    ".   in this case",
    "there is a clause @xmath140 $ ] with @xmath215 and @xmath65 has one child whose first label is @xmath219 for every variable @xmath220 . it remains to show that @xmath221 .",
    "assume not , and let @xmath176 be an assignment compatible with @xmath50 that does not satisfy any literal of @xmath15 .",
    "then , @xmath181 \\in f[\\tau^*]$ ] and because @xmath182|>1 $ ] and @xmath181 \\notin { \\textup{0-val}}$ ] , also @xmath177 \\notin { \\textup{horn}}\\cup { \\textup{0-val}}$ ] .",
    "2 .   in this case",
    "there is a clause @xmath15 in @xmath53 $ ] with @xmath222 and a clause @xmath127 in @xmath53 $ ] with @xmath223 and a set @xmath143 of variables containing all variables from @xmath15 and a subset of two variables from @xmath127 that correspond to two positive literals such that @xmath65 has one child whose first label is @xmath173 for every @xmath185 .",
    "it remains to show that @xmath224 .",
    "assume not , and let @xmath176 be an assignment compatible with @xmath50 that does not satisfy any literal of @xmath127 .",
    "then , @xmath177 $ ] contains the clause @xmath15 together with a subclause @xmath186 of @xmath127 containing at least two positive literals . because @xmath225 and @xmath226 , we obtain that @xmath177 \\notin { \\textup{2cnf}}\\cup { \\mathcal{c}}$ ] .",
    "this concludes our proof concerning the correctness of the algorithm .",
    "the running time of the algorithm is obtained as follows .",
    "let @xmath137 be a search tree obtained by the algorithm .",
    "then the running time of the depth - bounded search tree algorithm is @xmath189 times the maximum time that is spend on any node of @xmath137 .",
    "according to the two branching rules given in ( 2.a.ii ) and ( 2.b ) we obtain that @xmath190 can be bounded by the maximum of the following recurrence relations : ( 1 ) @xmath227 for any @xmath228 ( 2.a.ii ) and ( 2 ) @xmath191 ( 2.b ) . in case of ( 1 ) the maximum of @xmath103 is obtained for @xmath195 by setting @xmath229 , and in case of ( 2 ) @xmath195 is at most @xmath196 .",
    "it follows that @xmath230 .",
    "furthermore , the time required for any node @xmath65 of @xmath137 is at most @xmath201 . putting everything together ,",
    "we obtain @xmath231 , as the total running time of the algorithm .",
    "this shows that strong @xmath123backdoor detection is fixed - parameter tractable parameterized by @xmath0 .    in our next result",
    ", we consider heterogeneous base classes comprised of three schaefer s classes , namely @xmath125 and @xmath126 .",
    "we refer the reader to figure  [ fig : branching_triples ] for an overview of the branching strategies employed here .",
    "[ the : sat - fpt - triple ] strong @xmath125backdoor detection and strong @xmath126backdoor detection are fixed - parameter tractable for parameter @xmath0 .",
    "we only give the proof for the class @xmath125 , since the proof for the class @xmath126 is analogous .",
    "the algorithm uses a depth - bounded search tree approach to find a strong @xmath125-backdoor set of size at most @xmath0 .",
    "let @xmath41 be any cnf - formula with variables @xmath72 .",
    "we construct a search tree @xmath137 , for which every node is labeled by a set @xmath101 of at most @xmath0 variables of @xmath72 .",
    "additionally , every leaf node has a second label , which is either yes or no .",
    "@xmath137 is defined inductively as follows .",
    "the root of @xmath137 is labeled by the empty set .",
    "furthermore , if @xmath65 is a node of @xmath137 , whose first label is @xmath101 , then the children of @xmath65 in @xmath137 are obtained as follows .",
    "if for every assignment @xmath102 , @xmath53 \\in { \\textup{2cnf}}\\cup { \\textup{horn}}\\cup { \\textup{0-val}}$ ] , then @xmath101 is a strong @xmath125-backdoor set of size at most @xmath0 , and hence @xmath65 becomes a leaf node , whose second label is yes . otherwise , i.e. , if there is an assignment @xmath102 such that @xmath53 \\notin { \\textup{2cnf}}\\cup { \\textup{horn}}\\cup { \\textup{0-val}}$ ] , we consider two cases :    1 .",
    "@xmath138 , then @xmath65 becomes a leaf node , whose second label is no , 2 .",
    "otherwise , i.e. , if @xmath139 , then we again distinguish two cases : 1 .   there is a clause @xmath140 $ ] with @xmath232 , then we again distinguish two cases : 1 .",
    "@xmath149 , then @xmath65 becomes a leaf node , whose second label is no , 2 .",
    "otherwise , i.e. , if @xmath150 , , then for every two element subset @xmath143 of @xmath15 , @xmath65 has a child whose first label is @xmath151 .",
    "2 .   there is a clause @xmath140 $ ] with @xmath233 and @xmath234 , we again distinguish two cases : 1 .",
    "there is a clause @xmath235 $ ] with @xmath236 ( note that @xmath237 ) .",
    "let @xmath143 be a set of variables containing all variables of @xmath15 ( at most two ) plus three variables of @xmath127 of which two correspond to positive literals in @xmath127 .",
    "then , for every @xmath80 in @xmath143 , @xmath65 has a child whose first label is @xmath147 .",
    "otherwise , there are clauses @xmath238 $ ] with @xmath239 and @xmath240 .",
    "let @xmath143 be a set of variables containing all variables of @xmath241 ( at most two ) and three variables of @xmath242 .",
    "then , for every @xmath80 in @xmath143 , @xmath65 has a child whose first label is @xmath147 .",
    "3 .   there is a clause @xmath140 $ ] with @xmath233 and @xmath243 . in this case",
    "also @xmath225 and hence the case is covered by case ( 2.b ) .",
    "4 .   the cases ( 2.a ) , ( 2.b ) , and ( 2.c )",
    "completely cover all possible cases , because if none of these cases apply then @xmath53 \\in { \\textup{0-val}}$ ] , which contradicts the choice of @xmath50 .",
    "to see this assume there is a clause @xmath140 $ ] with @xmath244 .",
    "because of the cases ( 2.b ) and ( 2.c ) , we obtain that @xmath245 .",
    "furthermore , because of case ( 2.a ) , we obtain that @xmath246 .",
    "hence , @xmath247 but such a clause can not exist .    if @xmath137 has a leaf node , whose second label is yes , then the algorithm returns the first label of that leaf node .",
    "otherwise the algorithm returns no .",
    "this completes the description of the algorithm .",
    "node[above ] @xmath248 ( 2,0 ) ;    ( 2,0 )  ( 3,3 ) ( 2,0 ) ",
    "( 3,-3 ) ( 2,0 ) ",
    "( 3,0 ) ; ( 3,3 ) ",
    "node[above ] there is a clause @xmath140 $ ] node[below ] @xmath232 ( 8,3 ) ; ( 3,0 ) ",
    "node[above ] there is a clause @xmath140 $ ] node[below ] @xmath233 and @xmath249 ( 8,0 ) ; ( 3,-3 ) ",
    "node[above ] there is a clause @xmath140 $ ] node[below ] @xmath233 and @xmath225 ( 8,-3 ) ;    ( 9,4 ) ",
    "node[above ] @xmath250 node[below ] say no .",
    "( 12,4 ) ; ( 9,2.5 ) ",
    "node[above ] @xmath251 node[below ] branch .",
    "( 12,2.5 ) ;    ( 9,1 ) ",
    "node[above ] @xmath252 , @xmath236 node[below ] branch .",
    "( 12,1 ) ; ( 9,-1.5 ) ",
    "node[above ] @xmath253 and @xmath254 .",
    "node[below ] branch .",
    "( 16,-1.5 ) ;    at ( 12,-0.75 ) @xmath255 with ;    ( 9,-3 )  node[above ] @xmath256 and @xmath249 .",
    "node[below ] implies @xmath225 , subsumed above .",
    "( 14,-3 ) ;    ( 8,3 )  ( 9,4 ) ( 8,3 ) ",
    "( 9,2.5 ) ( 8,0 ) ",
    "( 9,1 ) ( 8,0 ) ",
    "( 9,-1.5 ) ( 8,-3 ) ",
    "( 9,-3 ) ;    we now show the correctness of the algorithm .",
    "first , suppose the search tree @xmath137 built by the algorithm has a leaf node @xmath65 whose second label is yes . here ,",
    "the algorithm returns the first label , say @xmath101 of @xmath65 .",
    "by definition of @xmath137 , we obtain that @xmath154 and @xmath101 is a strong @xmath125-backdoor set of @xmath41 , as required .",
    "now consider the case where the algorithm returns no .",
    "we need to show that there is no set @xmath101 of at most @xmath0 variables of @xmath41 such that @xmath53 \\in { \\textup{2cnf}}\\cup { \\textup{horn}}\\cup { \\textup{0-val}}$ ] for every assignment @xmath50 of the variables of @xmath101 .",
    "assume , for the sake of contradiction that such a set @xmath101 exists .",
    "observe that if @xmath137 has a leaf node @xmath65 whose first label is a set @xmath155 with @xmath156 , then the second label of @xmath65 must be yes .",
    "assume for a contradiction that this is not the case , then either case ( 1 ) or case ( 2.a.i ) applied for @xmath65 .",
    "in the former case @xmath155 is not a strong @xmath125-backdoor set for @xmath41 and @xmath157 .",
    "hence , @xmath158 contradicting our assumption that @xmath101 is a strong @xmath125-backdoor set for @xmath41 . in the later case",
    ", we obtain that there is an assignment @xmath159 and a clause @xmath140 $ ] such that @xmath257 and @xmath162 .",
    "consequently , @xmath101 misses at least three literals from @xmath15 .",
    "hence , there is an assignment @xmath218 that is compatible with @xmath50 such that @xmath165 $ ] contains a clause @xmath166 with @xmath167 .",
    "clearly , @xmath258 and because @xmath15 contained only positive literals ( because @xmath259 ) also @xmath260 . hence , @xmath261 contradicting our assumption that @xmath101 is a strong @xmath122-backdoor set for @xmath41 .",
    "it hence remains to show that @xmath137 has a leaf node whose first label is a set @xmath155 with @xmath156 .",
    "this will complete the proof about the correctness of the algorithm .",
    "we will show a slightly stronger statement , namely , that for every natural number @xmath135 , either @xmath137 has a leaf whose first label is contained in @xmath101 or @xmath137 has an inner node of distance exactly @xmath135 from the root whose first label is contained in @xmath101 .",
    "we show the latter by induction on @xmath135 .",
    "the claim obviously holds for @xmath171 .",
    "so assume that @xmath137 contains a node @xmath65 at distance @xmath135 from the root of @xmath137 whose first label , say @xmath155 , is a subset of @xmath101 .",
    "if @xmath65 is a leaf node of @xmath137 , then the claim is shown .",
    "otherwise , there is an assignment @xmath159 such that @xmath53 \\notin { \\textup{2cnf}}\\cup { \\textup{horn}}\\cup { \\textup{0-val}}$ ] and one of the cases ( 2.a.ii ) , ( 2.b.i ) , and ( 2.b.ii ) applies to @xmath65 .    1 .   in this case",
    "there is a clause @xmath140 $ ] with @xmath262 and @xmath65 has one child whose first label is @xmath179 for every two element subset @xmath143 of @xmath15 . it remains to show that @xmath180 .",
    "assume not , and let @xmath176 be an assignment compatible with @xmath50 that does not satisfy any literal of @xmath15 .",
    "then , @xmath181 \\in f[\\tau^*]$ ] and because @xmath182|>2 $ ] and @xmath181 $ ] contains only positive literals , also @xmath177 \\notin { \\textup{2cnf}}\\cup { \\textup{horn}}\\cup { \\textup{0-val}}$ ] .",
    "2 .   in this case",
    "there are clauses @xmath263 $ ] with @xmath264 and @xmath265 , and @xmath65 has a child whose first label is @xmath173 for every variable in @xmath143 , where @xmath143 is the set of variables containing all variables of @xmath15 and three variables of @xmath127 of which two correspond to positive literals of @xmath127 .",
    "it remains to show that @xmath266 .",
    "assume not and let @xmath176 be an assignment compatible with @xmath50 , which does not satisfy any literal of @xmath127 .",
    "then , @xmath177 $ ] contains @xmath15 as well as a subclause @xmath186 of @xmath127 of length at least three , which contains at least two positive literals . then ,",
    "@xmath267 and because @xmath225 , we obtain that @xmath177 \\notin { \\textup{2cnf}}\\cup      { \\textup{horn}}\\cup { \\textup{0-val}}$ ] , as required .",
    "3 .   in this case",
    "there are clauses @xmath268 $ ] @xmath239 and @xmath240 , and @xmath65 has a child whose first label is @xmath173 for every variable in @xmath143 , where @xmath143 is the set of variables containing all variables of @xmath241 and three variables of @xmath242 .",
    "it remains to show that @xmath266 .",
    "assume not and let @xmath176 be an assignment compatible with @xmath50 , which does not satisfy any literal of @xmath242 .",
    "then , @xmath177 $ ] contains @xmath241 as well as a subclause @xmath127 of @xmath242 of length at least three . because @xmath239 it follows that @xmath269 . because also @xmath168 , we obtain that @xmath177 \\notin { \\textup{2cnf}}\\cup { \\textup{horn}}\\cup { \\textup{0-val}}$ ] , as required .",
    "this concludes our proof concerning the correctness of the algorithm .",
    "the running time of the algorithm is obtained as follows .",
    "let @xmath137 be a search tree obtained by the algorithm .",
    "then the running time of the depth - bounded search tree algorithm is @xmath189 times the maximum time that is spend on any node of @xmath137 .",
    "according to the three branching rules given in ( 2.a.ii ) , ( 2.b.i ) , and ( 2.b.ii ) we obtain that @xmath190 can be bounded by the maximum of the following recurrence relations : ( 1 ) @xmath192 for any @xmath193 ( 2.a.ii ) , ( 2 ) @xmath194 ( 2.b.i ) , and ( 3 ) @xmath194 ( 2.b.ii ) . in case of ( 2 ) and ( 3 ) @xmath195",
    "is at most @xmath199 and in case of ( 1 ) the maximum of @xmath197 is obtained for @xmath195 by setting @xmath198 .",
    "it follows that @xmath200 .",
    "furthermore , the time required for any node @xmath65 of @xmath137 is at most @xmath201 . putting everything together , we obtain @xmath202 , as the total running time of the algorithm .",
    "this shows that strong @xmath125backdoor detection is fixed - parameter tractable parameterized by @xmath0 .",
    "we say that a pair @xmath25 of schaefer classes is a _ bad pair _ if @xmath26 and @xmath27 .",
    "our next result establishes hardness for the case when the base class contains a bad pair .    [ the : sat - bp - w2 ] for every @xmath270 that contains at least one bad pair of schaefer classes",
    ", it holds that strong @xmath5backdoor detection is @xmath6}}$]hard , where @xmath28 .",
    "we give a parameterized reduction from the @xmath6}}$]complete hitting set problem .",
    "given an instance @xmath271 for hitting set , construct a formula @xmath41 as follows .",
    "the variables of @xmath41 are @xmath272 . for each set @xmath273 , there is one clause @xmath274 . there is also one clause @xmath275 .",
    "this completes the description of the reduction .",
    "we claim that @xmath276 has a hitting set of size at most @xmath0 if and only if the formula @xmath41 has a strong @xmath5-backdoor set of size at most @xmath0 .",
    "suppose @xmath277 , @xmath278 , is a hitting set . to show that @xmath43 is also a strong @xmath5-backdoor set , consider any assignment @xmath47 .",
    "if @xmath279 for some @xmath280 , then @xmath50 satisfies the clause @xmath281 .",
    "thus , @xmath53 \\in    { \\mathcal{c}}$ ] since each clause in @xmath53 $ ] contains no negative literal and at least one positive literal and is hence in @xmath282 .",
    "if @xmath283 for all @xmath280 , then all clauses @xmath284 , are satisfied by @xmath50 since @xmath43 is a hitting set .",
    "the only remaining clause is @xmath20 and @xmath23 since it has no positive literal and at least one negative literal .",
    "for the other direction , suppose that @xmath43 is a strong @xmath5-backdoor set of size at most @xmath0 .",
    "obtain @xmath285 from @xmath43 by replacing each @xmath286 for any @xmath64 with @xmath287 by some variable from @xmath41 .",
    "the set @xmath285 is also a strong @xmath5-backdoor set of size at most @xmath0 .",
    "therefore , the assignment @xmath288 with @xmath283 for all @xmath289 must satisfy all clauses @xmath290",
    ". otherwise , @xmath53 $ ] contains both a long clause containing only positive and a long clause containing only negative literals and hence @xmath53    \\notin \\bigcup_{s \\in s } s$ ] .",
    "thus , @xmath285 is a hitting set for @xmath276 of size at most @xmath0 .",
    "we now summarize our results in the following theorem .",
    "[ the : sat - dico ] let @xmath270 and @xmath28 .",
    "then , strong @xmath5backdoor detection is fixed parameter tractable if and only if @xmath29 does not contain a bad pair of schaefer classes , otherwise it is @xmath6}}$]-hard .",
    "if @xmath29 contains a bad pair then the result follows from theorem  [ the : sat - bp - w2 ] .",
    "so assume that @xmath29 does not contain a bad pair , we distinguish the following cases :    * if @xmath291 , then the theorem follows from known results , see , for example ,  @xcite . *",
    "if @xmath292 , then either @xmath293 in which case the result follows from theorem  [ the : sat - fpt - krom ] , or @xmath294 or @xmath295 in which case the result follows from theorem  [ the : sat - fpt - horn - zval ] . *",
    "if @xmath296 , then either @xmath293 and hence @xmath297 or @xmath298 in which case the result follows from theorem  [ the : sat - fpt - triple ] , or @xmath299 in which case @xmath29 contains at least one bad pair , and the result follows from theorem  [ the : sat - bp - w2 ] . *",
    "if @xmath300 , then @xmath29 contains at least one bad pair , and the result follows from theorem  [ the : sat - bp - w2 ] .",
    "it is crucial for these hardness proofs that clauses have unbounded length . indeed , if clause - lengths are bounded or if we add the maximum clause length to the parameter , then strong backdoor detection becomes fpt for any combination of schaefer classes .",
    "[ the : sat - clause - sb ] let @xmath5 be a class of cnf - formulas such that @xmath28 for some @xmath270 .",
    "then , strong @xmath5backdoor detection is fixed - parameter tractable for the combined parameter @xmath0 and the maximum length @xmath30 of a clause of the input formula .",
    "the algorithm uses a depth - bounded search tree approach to find a strong @xmath5-backdoor set of size at most @xmath0 .",
    "let @xmath41 be any cnf - formula with variables @xmath72 and let @xmath30 be the maximum length of any clause of @xmath41 .    we construct a search tree @xmath137 , for which every node is labeled by a set @xmath101 of at most @xmath0 variables of @xmath72 . additionally , every leaf node has a second label , which is either yes or no .",
    "@xmath137 is defined inductively as follows .",
    "the root of @xmath137 is labeled by the empty set .",
    "furthermore , if @xmath65 is a node of @xmath137 , whose first label is @xmath101 , the children of @xmath65 in @xmath137 are obtained as follows .",
    "if for every assignment @xmath102 , it holds that @xmath53 \\in { \\mathcal{c}}$ ] , then @xmath101 is a strong @xmath5-backdoor set of size at most @xmath0 , and hence @xmath65 becomes a leaf node , whose second label is yes .",
    "otherwise , i.e. , if there is an assignment @xmath102 such that @xmath53 \\notin { \\mathcal{c}}$ ] , we consider two cases : ( 1 ) if @xmath138 , then @xmath65 becomes a leaf node , whose second label is no , and ( 2 ) if @xmath139 , then for every @xmath301 and every variable @xmath80 that occurs in some clause @xmath302 , @xmath65 has a child whose first label is @xmath147 .",
    "if @xmath137 has a leaf node , whose second label is yes , then the algorithm returns the first label of that leaf node .",
    "otherwise the algorithm returns no .",
    "this completes the description of the algorithm .",
    "we now show the correctness of the algorithm .",
    "first , suppose the search tree @xmath137 built by the algorithm has a leaf node @xmath65 whose second label is yes . here ,",
    "the algorithm returns the first label , say @xmath101 of @xmath65 .",
    "by definition of @xmath137 , we obtain that @xmath154 and the set @xmath101 is a strong @xmath5backdoor set of @xmath41 , as required .",
    "now consider the case where the algorithm returns no .",
    "we need to show that there is no strong @xmath5backdoor set of size at most @xmath0 for @xmath41 .",
    "assume , for the sake of contradiction that such a set @xmath101 exists .",
    "observe that if @xmath137 has a leaf node @xmath65 whose first label is a set @xmath155 with @xmath156 , then the second label of @xmath65 must be yes .",
    "this is because , either @xmath303 in which case the second label of @xmath65 must be yes , or @xmath157 in which case @xmath304 and by the definition of @xmath101 it follows that the second label of @xmath65 must be yes .",
    "it hence remains to show that @xmath137 has a leaf node whose first label is a set @xmath155 with @xmath156 .",
    "this will complete the proof about the correctness of the algorithm .",
    "we will show a slightly stronger statement , namely , that for every natural number @xmath135 , either @xmath137 has a leaf whose first label is contained in @xmath101 or @xmath137 has an inner node of distance exactly @xmath135 from the root whose first label is contained in @xmath101 .",
    "we show the latter by induction on @xmath135 .",
    "the claim obviously holds for @xmath171 .",
    "so assume that @xmath137 contains a node @xmath65 at distance @xmath135 from the root of @xmath137 whose first label , say @xmath155 , is a subset of @xmath101 .",
    "if @xmath65 is a leaf node of @xmath137 , then the claim is shown .",
    "otherwise , there is an assignment @xmath159 such that @xmath53 \\notin { \\mathcal{c}}$ ] .",
    "let @xmath176 be any assignment of the variables in @xmath101 that agrees with @xmath50 on the variables in @xmath155 and let @xmath301 be such that @xmath177 \\in s$ ] . because @xmath101 is a strong @xmath5-backdoor set , @xmath305 clearly exists . by definition of the search tree @xmath137",
    ", @xmath65 has a child @xmath69 for every variable @xmath80 contained in some clause @xmath140 $ ] with @xmath302 .",
    "we claim that @xmath306 and hence @xmath65 has a child , whose first label is a subset of @xmath101 , as required . indeed ,",
    "suppose not .",
    "then @xmath307 $ ] a contradiction to our assumption that @xmath177 \\in s$ ] .",
    "this concludes our proof concerning the correctness of the algorithm .",
    "the running time of the algorithm is obtained as follows .",
    "let @xmath137 be a search tree obtained by the algorithm .",
    "then the running time of the depth - bounded search tree algorithm is @xmath189 times the maximum time that is spend on any node of @xmath137 .",
    "since the number of children of any node of @xmath137 is bounded by @xmath308 ( recall that @xmath30 denotes the maximum length of any clause of @xmath41 ) and the longest path from the root of @xmath137 to some leaf of @xmath137 is bounded by @xmath205 , we obtain that @xmath309 . furthermore , the time required for any node @xmath65 of @xmath137 is at most @xmath201 . putting everything together , we obtain @xmath310 , as the total running time of the algorithm .",
    "this shows that strong @xmath5backdoor detection is fixed - parameter tractable parameterized by @xmath0 , @xmath30 .",
    "it turns out that the complexity of finding weak backdoors into heterogeneous classes is tightly tied into the complexity of finding weak backdoors into the individual base classes .",
    "let us briefly consider the intuition for this scenario before stating the result .",
    "suppose we are given algorithms for finding weak backdoors into base classes @xmath311 and @xmath312 .",
    "observe that a cnf - formula has a weak backdoor of size at most @xmath0 into @xmath313 if , and only if , it has a weak backdoor of size at most @xmath0 into at least one of @xmath311 or @xmath312 .",
    "thus , if we have a positive algorithmic result for the weak backdoor question with respect to the individual base classes , then these algorithms can be easily combined to obtain an algorithm for finding weak backdoors into the corresponding heterogeneous base class . on the other hand , a hardness result for even one of the involved classes can usually be leveraged to obtain a hardness result for the entire heterogeneous problem , by adding gadgets that isolate the issue to only one of the base classes , typically the one that was hard to begin with .",
    "in particular , we obtain the following result .",
    "[ wbd : w - hard ] let @xmath270 and @xmath28 . then",
    ", weak @xmath5backdoor detection is @xmath6}}$]-hard .    before we proceed further ,",
    "we introduce the notion of an obstruction which we will use in the proof .",
    "specifically , for @xmath314 , we say that a clause @xmath15 is an @xmath29-obstruction to @xmath315 if @xmath316 and @xmath317 . for any pair of schaefer classes @xmath29 and @xmath315 , it is easy to construct examples of @xmath29-obstructions to @xmath315 . in particular , we have :    1 .",
    "@xmath318 is an horn obstruction to 2cnf , and also a 0-valid obstruction to 2cnf .",
    "@xmath319 is an anti - horn obstruction to 2cnf , and also a 1-valid obstruction to 2cnf .",
    "3 .   @xmath320 is a 0-valid obstruction to horn .",
    "@xmath321 is an @xmath43-obstruction to horn for all @xmath322 2cnf , anti - horn , 1-valid @xmath323 .",
    "5 .   @xmath324 is a 1-valid obstruction to anti - horn .",
    "@xmath325 is an @xmath43-obstruction to anti - horn for all @xmath322 2cnf , horn , 0-valid @xmath323 .",
    "@xmath326 is an @xmath43-obstruction to 0-valid for all @xmath322 2cnf , 1-valid , horn , anti - horn @xmath323 .",
    "@xmath327 is an @xmath43-obstruction to 1-valid for all @xmath322 2cnf , 0-valid , horn , anti - horn @xmath323 .",
    "we are now ready to describe our reduction towards theorem  [ wbd : w - hard ] .",
    "if @xmath328 , then the result follows directly from  ( * ? ? ?",
    "* proposition 1 ) .",
    "otherwise , let @xmath329 .",
    "we reduce an instance @xmath330 of weak @xmath29backdoor detection to weak @xmath5backdoor detection . to this end , for all @xmath331 such that @xmath332 , introduce @xmath333 variable - disjoint copies of a @xmath29-obstruction to @xmath315 ( using fresh variables for each obstruction , and in particular , disjoint from @xmath334 .",
    "we use @xmath335 to denote the formula obtained from @xmath41 after adding these obstructions to @xmath41 , and the reduced instance is given by @xmath336 .    in the forward direction , if @xmath43 is a weak backdoor to @xmath29 for @xmath41 , and if @xmath337 is such that @xmath53 \\in s$ ] , then observe that @xmath338 \\in s$ ] , since all the added obstructions ( which are unaffected by @xmath50 ) were in @xmath29 by definition .",
    "it is also easy to see that any satisfying assignment for @xmath339 can be easily extended to an assignment involving the new variables that satisfy all the obstructions ( recall that the obstructions were variable disjoint , and therefore can be easily satisfied independently ) .    on the other hand ,",
    "let @xmath43 be a weak backdoor to @xmath5 for @xmath335 .",
    "since @xmath43 has at most @xmath0 variables , for any @xmath337 , @xmath338 $ ] contains at least one @xmath315-obstructing clause for each @xmath331 such that @xmath340 .",
    "therefore , @xmath338 $ ] must necessarily belong to @xmath29 , and therefore @xmath341 is easily checked to be a weak backdoor to @xmath29 for @xmath41 , as desired .     * * * maybe give a proof that weak @xmath342backdoor detection is w[2]-hard .",
    "* we need a proof for the parameterized hardness of weak backdoor detection when parameterized only by the backdoor set size .",
    "i guess we can adapt the hardness proof for weak backdoor set detection for a single schaefer class to combination of schaefer classes ! *    on the other hand , as with the strong backdoors , we do obtain tractability when we have bounded clause lengths .",
    "we establish this formally below .",
    "[ the : sat - clause - wb ] let @xmath5 be a class of cnf - formulas such that @xmath28 for some @xmath270 .",
    "then , weak @xmath5backdoor detection is fixed - parameter tractable for the combined parameter @xmath0 and the maximum length @xmath30 of a clause of the input formula .",
    "the algorithm uses a depth - bounded search tree approach to find a weak @xmath5-backdoor set of size at most @xmath0 .",
    "let @xmath41 be any cnf - formula with variables @xmath72 and let @xmath30 be the maximum length of any clause of @xmath41 .    we construct a search tree @xmath137 , for which every node is labeled by a set @xmath101 of at most @xmath0 variables of @xmath72 . additionally , every leaf node has a second label , which is either yes or no .",
    "@xmath137 is defined inductively as follows .",
    "the root of @xmath137 is labeled by the empty set .",
    "furthermore , if @xmath65 is a node of @xmath137 , whose first label is @xmath101 , the children of @xmath65 in @xmath137 are obtained as follows .",
    "if there is an assignment @xmath102 , such that @xmath53 \\in    { \\mathcal{c}}$ ] and @xmath53 $ ] is satisfiable , then @xmath101 is a weak @xmath5-backdoor set of size at most @xmath0 , and hence @xmath65 becomes a leaf node , whose second label is yes .",
    "otherwise , i.e. , for every assignment @xmath102 either @xmath53 \\notin { \\mathcal{c}}$ ] or @xmath53 \\in { \\mathcal{c}}$ ] but @xmath53 $ ] is not satisfiable , we consider two cases : ( 1 ) @xmath138 , then @xmath65 becomes a leaf node , whose second label is no , and ( 2 ) @xmath139 , then for every assignment @xmath102 such that @xmath53 \\notin    { \\mathcal{c}}$ ] , for every @xmath301 , and every variable @xmath80 that occurs in some clause @xmath302 , @xmath65 has a child whose first label is @xmath147 .",
    "if @xmath137 has a leaf node , whose second label is yes , then the algorithm returns the first label of that leaf node .",
    "otherwise the algorithm returns no .",
    "this completes the description of the algorithm .",
    "we now show the correctness of the algorithm .",
    "first , suppose the search tree @xmath137 built by the algorithm has a leaf node @xmath65 whose second label is yes . here ,",
    "the algorithm returns the first label , say @xmath101 of @xmath65 .",
    "by definition of @xmath137 , we obtain that @xmath154 and the set @xmath101 is a weak @xmath5backdoor set of @xmath41 , as required .",
    "now consider the case where the algorithm returns no .",
    "we need to show that there is no weak @xmath5backdoor set of size at most @xmath0 for @xmath41 .",
    "assume , for the sake of contradiction that such a set @xmath101 exists .",
    "observe that if @xmath137 has a leaf node @xmath65 whose first label is a set @xmath155 with @xmath156 , then the second label of @xmath65 must be yes .",
    "this is because , either @xmath303 in which case the second label of @xmath65 must be yes , or @xmath157 in which case @xmath304 and by the definition of @xmath101 it follows that the second label of @xmath65 must be yes .",
    "it hence remains to show that @xmath137 has a leaf node whose first label is a set @xmath155 with @xmath156 .",
    "this will complete the proof about the correctness of the algorithm .",
    "we will show a slightly stronger statement , namely , that for every natural number @xmath135 , either @xmath137 has a leaf whose first label is contained in @xmath101 or @xmath137 has an inner node of distance exactly @xmath135 from the root whose first label is contained in @xmath101 .",
    "we show the latter by induction on @xmath135 .",
    "the claim obviously holds for @xmath171 .",
    "so assume that @xmath137 contains a node @xmath65 at distance @xmath135 from the root of @xmath137 whose first label , say @xmath155 , is a subset of @xmath101 .",
    "if @xmath65 is a leaf node of @xmath137 , then the claim is shown .",
    "because @xmath101 is a weak @xmath5backdoor set for @xmath41 , there is an assignment @xmath176 such that @xmath177 \\in    { \\mathcal{c}}$ ] and @xmath177 $ ] is satisfiable . in particular",
    ", there is some @xmath301 such that @xmath177 \\in s$ ] .",
    "let @xmath159 be the assignment that agrees with @xmath343 on the variables of @xmath155 . because @xmath65 is not a leaf node",
    ", there is a clause @xmath344 $ ] with @xmath302 such that @xmath65 has a child @xmath69 for every @xmath220 .",
    "we claim that @xmath306 and hence @xmath65 has a child , whose first label is a subset of @xmath101 , as required . indeed ,",
    "suppose not .",
    "then @xmath307 $ ] a contradiction to our assumption that @xmath177 \\in s$ ] .",
    "this concludes our proof concerning the correctness of the algorithm .",
    "the running time of the algorithm is obtained as follows .",
    "let @xmath137 be a search tree obtained by the algorithm .",
    "then the running time of the depth - bounded search tree algorithm is @xmath189 times the maximum time that is spend on any node of @xmath137 .",
    "since the number of children of any node of @xmath137 is bounded by @xmath345 ( recall that @xmath30 denotes the maximum length of any clause of @xmath41 ) and the longest path from the root of @xmath137 to some leaf of @xmath137 is bounded by @xmath205 , we obtain that @xmath346 . furthermore , the time required for any node @xmath65 of @xmath137 is at most @xmath201 . putting everything together , we obtain @xmath347 , as the total running time of the algorithm .",
    "this shows that weak @xmath5backdoor detection is fixed - parameter tractable parameterized by @xmath0 , @xmath30 .",
    "we close this section by noting that backdoor sets with _ empty clause detection _",
    ", as proposed by @xcite can be considered as backdoor sets into the heterogeneous base class obtained by the union of a homogeneous base class @xmath5 and the class of all formulas that contain the empty clause .",
    "the detection of strong backdoor sets with empty clause detection is not fixed - parameter tractable for many natural base classes , including horn and 2cnf @xcite .",
    "in this section we provide a very general framework that will give rise to a wide range of heterogeneous base classes  for  csp .    given a @xmath0-ary relation @xmath348 over some domain @xmath58 and a function @xmath349 , we say that @xmath348 is _ closed under @xmath350 _ , if for all collections of @xmath59 tuples @xmath351 from @xmath348 , the tuple @xmath352,\\dotsc , t_n[1 ] ) ,    \\dotsc,\\phi(t_1[k],\\dotsc , t_n[k])}\\rangle}$ ] belongs to @xmath348 .",
    "the function @xmath350 is also said to be a _ polymorphism of @xmath348_. we denote by @xmath353 the set of all functions @xmath350 such that @xmath348 is closed under @xmath350 .",
    "let @xmath81 be a csp instance and @xmath73 .",
    "we write @xmath354 for the set @xmath355 and we write @xmath356 for the set @xmath357 .",
    "we say that @xmath70 is closed under a polymorphism @xmath350 if @xmath358 .",
    "* a polymorphism @xmath359 is _ constant _ if there is a @xmath32 such that for every @xmath360 , it holds that @xmath361 ; * a polymorphism @xmath362 is _ idempotent _ if for every @xmath32 it holds that @xmath363 ; * a polymorphism @xmath362 is _ conservative _ if for every @xmath364 it holds that @xmath365 ; * a polymorphism @xmath366 is a _ min_/_max",
    "_ polymorphism if there is an ordering of the elements of @xmath58 such that for every @xmath367 , it holds that @xmath368 or @xmath369 , respectively ; * a polymorphism @xmath370 is a _ majority _ polymorphism if for every @xmath367 it holds that @xmath371 ; * a polymorphism @xmath370 is an _ minority _ polymorphism if for every @xmath367 it holds that @xmath372 ; * a polymorphism @xmath370 is a",
    "_ polymorphism if for every @xmath367 it holds that @xmath373 .",
    "we say a polymorphism @xmath350 is _ tractable _ if every csp instance closed under @xmath350 can be solved in polynomial time .",
    "it is known that every constant , min / max , majority , minority , and malcev polymorphism is tractable  @xcite .",
    "we denote by @xmath374 , @xmath375 , @xmath376 , @xmath377 , @xmath375 , and @xmath378 the class of csp instances @xmath70 for which @xmath356 contains a constant , a min , a max , a majority , a minority , or a malcev polymorphism , respectively .",
    "let @xmath379 be a predicate for the polymorphism @xmath350 .",
    "we call @xmath379 a _ nice polymorphism property _ if the following conditions hold .",
    "* there is a constant @xmath380 such that for all finite domains @xmath58 , all polymorphisms @xmath350 over @xmath58 with property @xmath381 are of arity at most @xmath380 . * given a polymorphism @xmath350 and a domain @xmath58 , one can check in polynomial time whether @xmath379 holds on all of the at most @xmath382 tuples over @xmath58 , * every polymorphism with property @xmath381 is tractable .",
    "every nice polymorphism property @xmath381 gives rise to a natural base class @xmath383 consisting of all csp - instances @xmath70 such that @xmath356 contains some polymorphism @xmath350 with @xmath379 .",
    "thus @xmath374 , @xmath375 , @xmath376 , @xmath377 , @xmath375 , and @xmath378 are the classes @xmath383 for @xmath384constant , min , max , majority , minority , malcev@xmath323 , respectively .    in terms of the above definitions we can state the results of @xcite and @xcite as follows .",
    "[ pro : schaefer - nice ] constant , min , max , majority , minority , and malcev are nice polymorphism properties .    in the next sections",
    "we will study the problems strong @xmath383backdoor detection for nice polymorphism properties @xmath381 .",
    "in this section we will show that both strong @xmath383backdoor detection and weak @xmath383backdoor detection parameterized by the size of the backdoor set , the size of the domain , and the maximum arity of the csp instance are fixed - parameter tractable for any nice property  @xmath381 .",
    "we start by giving the tractability results for strong backdoor sets .",
    "[ the : fpt - csp ] let @xmath381 be a nice polymorphism property .",
    "then strong @xmath383backdoor detection is fixed - parameter tractable for the combined parameter size of the backdoor set , size of the domain , and the maximum arity of the given csp instance .",
    "let @xmath381 be a nice property , and let @xmath385 with @xmath81 be an instance of strong @xmath383backdoor detection .",
    "let @xmath386 be the set of all polymorphisms on @xmath58 that have property @xmath381 .",
    "then , @xmath386 can be constructed in fpt - time with respect to the size of the domain , because there are at most @xmath387 @xmath380-ary polymorphisms on @xmath58 and for each of them we can test in polynomial time , @xmath388 , whether it satisfies property @xmath381 .",
    "the algorithm uses a depth - bounded search tree approach to find a strong @xmath383-backdoor set of size at most @xmath0 .",
    "we construct a search tree @xmath137 , for which every node is labeled by a set @xmath101 of at most @xmath0 variables of @xmath72 .",
    "additionally , every leaf node has a second label , which is either yes or no .",
    "@xmath137 is defined inductively as follows .",
    "the root of @xmath137 is labeled by the empty set .",
    "furthermore , if @xmath65 is a node of @xmath137 , whose first label is @xmath101 , then the children of @xmath65 in @xmath137 are obtained as follows . if for every assignment @xmath104 there is a polymorphism @xmath389 such that @xmath95 $ ]",
    "is closed under @xmath350 , then @xmath101 is a strong @xmath386-backdoor set of size at most @xmath0 , and hence @xmath65 becomes a leaf node , whose second label is yes .",
    "otherwise , i.e. , if there is an assignment @xmath104 such that @xmath95 $ ] is not closed under any polymorphism @xmath390 , we consider two cases : ( 1 ) @xmath138 , then @xmath65 becomes a leaf node , whose second label is no , and ( 2 ) @xmath139 , then for every polymorphism @xmath390 and every variable @xmath80 in the scope of some constraint @xmath391 $ ] that is not closed under @xmath350 , @xmath65 has a child whose first label is @xmath147 .",
    "if @xmath137 has a leaf node , whose second label is yes , then the algorithm returns the first label of that leaf node .",
    "otherwise the algorithm return no .",
    "this completes the description of the algorithm .",
    "we now show the correctness of the algorithm .",
    "first , suppose the search tree @xmath137 built by the algorithm has a leaf node @xmath65 whose second label is yes . here",
    ", the algorithm returns the first label , say @xmath101 of @xmath65 . by definition",
    ", we obtain that @xmath154 and for every assignment @xmath104 , it holds that @xmath95 $ ] is closed under some polymorphism in @xmath386 , as required .",
    "now consider the case where the algorithm returns no .",
    "we need to show that there is no set @xmath101 of at most @xmath0 variables of @xmath70 such that @xmath392 ) \\cap p \\neq \\emptyset$ ] for every assignment @xmath50 of the variables of @xmath101 .",
    "assume , for the sake of contradiction that such a set @xmath101 exists .",
    "observe that if @xmath137 has a leaf node @xmath65 whose first label is a set @xmath155 with @xmath156 , then the second label of @xmath65 must be yes .",
    "this is because , either @xmath303 in which case the second label of @xmath65 must be yes , or @xmath157 in which case @xmath304 and by the definition of @xmath101 it follows that the second label of @xmath65 must be yes .",
    "it hence remains to show that @xmath137 has a leaf node whose first label is a set @xmath155 with @xmath156 .",
    "this will complete the proof about the correctness of the algorithm .",
    "we will show a slightly stronger statement , namely , that for every natural number @xmath135 , either @xmath137 has a leaf whose first label is contained in @xmath101 or @xmath137 has an inner node of distance exactly @xmath135 from the root whose first label is contained in @xmath101 .",
    "we show the latter by induction on @xmath135 .",
    "the claim obviously holds for @xmath171 .",
    "so assume that @xmath137 contains a node @xmath65 at distance @xmath135 from the root of @xmath137 whose first label , say @xmath155 , is a subset of @xmath101 .",
    "if @xmath65 is a leaf node of @xmath137 , then the claim is shown .",
    "otherwise , there is an assignment @xmath393 such that @xmath95 $ ] is not closed under any polymorphism from @xmath386 .",
    "let @xmath394 be any assignment of the variables in @xmath101 that agrees with @xmath50 on the variables in @xmath155 and let @xmath390 be such that @xmath395 $ ] is closed under @xmath350 . because @xmath101 is a strong @xmath386-backdoor set , the polymorphism @xmath350 clearly exists . by definition of the search tree @xmath137",
    ", @xmath65 has a child @xmath69 for every variable @xmath80 in the scope of some constraint @xmath391 $ ] that is not closed under @xmath350 .",
    "we claim that @xmath396 and hence @xmath65 has a child , whose first label is a subset of @xmath101 , as required . indeed ,",
    "suppose not . then @xmath397 $ ] a contradiction to our assumption that @xmath395 $ ] is closed under @xmath350 .",
    "this concludes our proof concerning the correctness of the algorithm .",
    "the running time of the algorithm is obtained as follows .",
    "let @xmath137 be a search tree obtained by the algorithm .",
    "then the running time of the depth - bounded search tree algorithm is @xmath189 times the maximum time that is spend on any node of @xmath137 .",
    "since the number of children of any node of @xmath137 is bounded by @xmath398 ( recall that @xmath85 denotes the maximum arity of any constraint of @xmath70 ) and the longest path from the root of @xmath137 to some leaf of @xmath137 is bounded by @xmath205 , we obtain that @xmath399 .",
    "furthermore , the time required for any node @xmath65 of @xmath137 is at most @xmath400)||p|\\textup{check\\_poly}(c,\\phi))$ ] , where @xmath401 is the time required to compute @xmath95 $ ] for some assignment @xmath50 of at most @xmath0 variables and @xmath402 is the time required to check whether a constraint @xmath109 of @xmath95 $ ] preserves the polymorphism @xmath390 . observe that @xmath401 and @xmath403)|$ ] are polynomial in the input size .",
    "the same holds for @xmath402 , because @xmath350 is a @xmath380-ary polymorphism .",
    "now , the total running time required by the algorithm is the time required to compute the set @xmath386 plus the time required to compute @xmath137 .",
    "putting everything together , we obtain @xmath404 , r as the total running time of the algorithm , where @xmath59 denotes the input size of the csp instance .",
    "this shows that strong @xmath383backdoor detection is fixed - parameter tractable parameterized by @xmath0 , @xmath85 , and @xmath405 .",
    "because of proposition  [ pro : schaefer - nice ] , we obtain .",
    "let @xmath5 be a base class consisting of the union of some of the classes @xmath375 , @xmath376 , @xmath377 , @xmath375 , and @xmath378 .",
    "then strong @xmath5backdoor detection is fixed - parameter tractable for the combined parameter size of the backdoor set , size of the domain , and the maximum arity of the given csp instance .",
    "we are now ready to provide analogous results for weak backdoor sets .",
    "the proof is very similar to the case of strong backdoor sets , however , it becomes slightly simpler , because we do not need to consider different polymorphisms for different assignments ( since there is only one assignment , required for a weak backdoor set ) .",
    "we can hence branch on the possible polymorphisms before we start the depth - bounded search tree procedure , which also results in a slight improvement in the running time of the algorithm .    [ the : fpt - csp - weak ] let @xmath381 be a nice polymorphism property .",
    "then weak @xmath383backdoor detection is fixed - parameter tractable for the combined parameter size of the backdoor set , size of the domain , and the maximum arity of the given csp instance .",
    "let @xmath381 be a nice property , and let @xmath385 with @xmath81 be an instance of weak @xmath383backdoor detection .",
    "let @xmath386 be the set of all polymorphisms on @xmath58 that have property @xmath381 .",
    "then , @xmath386 can be constructed in fpt - time with respect to the size of the domain , because there are at most @xmath387 @xmath380-ary polymorphisms on @xmath58 and for each of them we can test in polynomial time , @xmath388 , whether it satisfies property @xmath381 .",
    "the algorithm uses a depth - bounded search tree approach to find a weak @xmath406-backdoor set of size at most @xmath0 for every @xmath390 .",
    "the algorithm works by constructing a search tree @xmath407 for every polymorphism @xmath390 . in @xmath407",
    "every node is labeled by a set @xmath101 of at most @xmath0 variables of @xmath72 .",
    "additionally , every leaf node has a second label , which is either yes or no .",
    "@xmath407 is defined inductively as follows .",
    "the root of @xmath407 is labeled by the empty set .",
    "furthermore , if @xmath65 is a node of @xmath407 , whose first label is @xmath101 , then the children of @xmath65 in @xmath407 are obtained as follows .",
    "if there is an assignment @xmath104 such that @xmath95 $ ] is closed under @xmath350 and @xmath95 $ ] has a solution , then @xmath101 is a weak @xmath386-backdoor set of size at most @xmath0 , and hence @xmath65 becomes a leaf node , whose second label is yes .",
    "otherwise , i.e. , for every assignment @xmath104 either @xmath95 $ ] is not closed under @xmath350 or @xmath95 $ ] has no solution , we consider two cases : ( 1 ) @xmath138 , then @xmath65 becomes a leaf node , whose second label is no , and ( 2 ) @xmath139 , then for every assignment @xmath104 @xmath65 has the following children : for every every variable @xmath80 in the scope of some constraint @xmath408 $ ] that is not closed under @xmath350 , @xmath65 has a child whose first label is @xmath147 .",
    "if there is a @xmath390 such @xmath407 has a leaf node , whose second label is yes , then the algorithm returns the first label of that leaf node .",
    "otherwise the algorithm return no .",
    "this completes the description of the algorithm .",
    "we now show the correctness of the algorithm .",
    "first , suppose there is a @xmath390 such that the search tree @xmath407 built by the algorithm has a leaf node @xmath65 whose second label is yes . here ,",
    "the algorithm returns the first label , say @xmath101 of @xmath65 . by the construction of @xmath407",
    ", we obtain that @xmath154 and there is an assignment @xmath104 such that @xmath95 $ ] is closed @xmath350 and @xmath95 $ ] has a solution , as required .",
    "now consider the case where the algorithm returns no .",
    "we need to show that there is no weak @xmath386backdoor set of size at most @xmath0 for @xmath70 .",
    "assume , for the sake of contradiction that such a set @xmath101 exists . because @xmath101 is a weak @xmath386backdoor set for @xmath70 there must exists a polymorphism @xmath390 and an assignment @xmath104 such that @xmath95 $ ] is closed under @xmath350 and @xmath409 has a solution .",
    "observe that if @xmath407 has a leaf node @xmath65 whose first label is a set @xmath155 with @xmath156 , then the second label of @xmath65 must be yes . this is because , either @xmath303 in which case the second label of @xmath65 must be yes , or @xmath157 in which case @xmath304 and by the definition of @xmath101 it follows that the second label of @xmath65 must be yes .    it hence remains to show that @xmath407 has a leaf node whose first label is a set @xmath155 with @xmath156 .",
    "this will complete the proof about the correctness of the algorithm .",
    "we will show a slightly stronger statement , namely , that for every natural number @xmath135 , either @xmath407 has a leaf whose first label is contained in @xmath101 or @xmath407 has an inner node of distance exactly @xmath135 from the root whose first label is contained in @xmath101 .",
    "we show the latter by induction on @xmath135 .",
    "the claim obviously holds for @xmath171 .",
    "so assume that @xmath407 contains a node @xmath65 at distance @xmath135 from the root of @xmath407 whose first label , say @xmath155 , is a subset of @xmath101 .",
    "if @xmath65 is a leaf node of @xmath407 , then the claim is shown .",
    "otherwise , for every assignment @xmath393 either @xmath95 $ ] is not closed under @xmath350 or @xmath95 $ ] has no solution .",
    "let @xmath410 be the restriction of @xmath50 to @xmath155 .",
    "because @xmath95 $ ] and hence also @xmath411 $ ] has a solution , we obtain that @xmath411 $ ] is not closed under the polymorphism @xmath350 . by the definition of the search tree @xmath407",
    ", it holds that @xmath65 has a child @xmath69 whose first label is @xmath173 , for every variable @xmath80 in the scope of some constraint @xmath412 $ ] that is not closed under @xmath350 .",
    "we claim that @xmath396 and hence @xmath65 has a child , whose first label is a subset of @xmath101 , as required . indeed ,",
    "suppose not .",
    "then @xmath408 $ ] a contradiction to our assumption that @xmath95 $ ] is closed under @xmath350 .",
    "this concludes our proof concerning the correctness of the algorithm .",
    "the running time of the algorithm is obtained as follows .",
    "let @xmath407 be a search tree obtained by the algorithm .",
    "then the running time of the depth - bounded search tree algorithm is @xmath413 times the maximum time that is spend on any node of @xmath407 .",
    "since the number of children of any node of @xmath407 is bounded by @xmath414 ( recall that @xmath85 denotes the maximum arity of any constraint of @xmath70 ) and the longest path from the root of @xmath407 to some leaf of @xmath407 is bounded by @xmath205 , we obtain that @xmath415 . furthermore , the time required for any node @xmath65 of @xmath137 is at most @xmath400)|\\textup{check\\_poly}(c,\\phi)\\textup{check\\_sol}({i}[\\tau],\\phi))$ ] , where @xmath401 is the time required to compute @xmath95 $ ] for some assignment @xmath50 of at most @xmath0 variables , @xmath402 is the time required to check whether a constraint @xmath109 of @xmath95 $ ] preserves the polymorphism @xmath350 , and @xmath416,\\phi)$ ] is the time required to solve @xmath95 $ ] given that it is closed under the polymorphism @xmath350 . observe that @xmath401 and @xmath403)|$ ] are polynomial in the input size . the same holds for @xmath402 and @xmath416,\\phi)$ ] , because @xmath350 is a @xmath380-ary tractable polymorphism .",
    "now , the total running time required by the algorithm is the time required to compute the set @xmath386 plus the time required to compute @xmath407 for every @xmath390 . putting everything together , we obtain @xmath417 , as the total running time of the algorithm , where @xmath59 denotes the input size of the csp instance .",
    "this shows that weak @xmath383backdoor detection is fixed - parameter tractable parameterized by @xmath0 , @xmath85 , and @xmath405 .",
    "because of proposition  [ pro : schaefer - nice ] , we obtain .",
    "let @xmath5 be a base class consisting of the union of some of the classes @xmath375 , @xmath376 , @xmath377 , @xmath375 , and @xmath378 .",
    "then weak @xmath5backdoor detection is fixed - parameter tractable for the combined parameter size of the backdoor set , size of the domain , and the maximum arity of the given csp instance .",
    "in this section we show our parameterized hardness results for strong @xmath383backdoor detection and weak @xmath383backdoor detection .",
    "in particular , we show that strong @xmath383backdoor detection and weak @xmath383backdoor detection are hard parameterized by the size of the backdoor set even for csp instances of boolean domain and for csp instances with arity two .",
    "we start by showing hardness for csp instances with boolean domain .",
    "let @xmath362 be an @xmath59-ary polymorphism over @xmath58 and @xmath30 a natural number .",
    "we say a sequence of @xmath30-ary tuples @xmath418 is an _ obstruction _ for @xmath350 if @xmath419 .",
    "we say that a polymorphism is _ obstructable _ if it has an obstruction .",
    "observe that all tractable polymorphisms are also obstructable because every csp instance is closed under any polymorphism that is not obstructable .",
    "for a sequence @xmath29 of tuples , we denote by @xmath420 , the set of pairwise distinct tuples in @xmath29 .",
    "we call an obstruction @xmath418 of @xmath350 _ minimal _ if @xmath421 is minimal over all obstructions of @xmath350 . for a polymorphism @xmath350 , we denote by @xmath422 a minimal obstruction of @xmath350 and by @xmath423 the arity of the tuples in the minimal obstruction @xmath422 .    [ the : domain ] let @xmath381 be a nice polymorphism property such that all polymorphisms @xmath350 with @xmath379 are idempotent",
    ". then , strong @xmath383backdoor detection and weak @xmath383backdoor detection are @xmath6}}$]hard parameterized by the size of the backdoor set , even for csp instances over the boolean domain .",
    "we show the theorem via an fpt - reduction from hitting set .",
    "let @xmath424 be an instance of hitting set .",
    "we construct a csp instance @xmath425 such that @xmath426 has a hitting set of size at most @xmath0 if and only if @xmath70 has a strong @xmath383-backdoor set of size at most @xmath0 .",
    "let @xmath386 be the set of all polymorphisms on @xmath45 that have property @xmath381 .",
    "then , @xmath386 can be constructed in polynomial time , because there are at most @xmath427 @xmath380-ary polymorphisms on @xmath45 and for each of them we can test in polynomial time , whether it satisfies property @xmath381 .",
    "the variables of @xmath70 are @xmath428 .",
    "furthermore , for every polymorphism @xmath390 with @xmath429 , for some natural number @xmath59 , and @xmath430 with @xmath431 , @xmath15 contains a constraint @xmath432 with scope @xmath433 whose relation contains the row @xmath434 , \\dotsc , t_i[r(\\phi ) ] , \\underbrace{{\\langle{i\\mod 2 , \\dotsc , i\\mod        2}\\rangle}}_{|f| \\text{times}}\\ ] ] for every @xmath64 in @xmath66 .",
    "this completes the construction of @xmath70 .",
    "observe that @xmath70 is satisfiable , because the first rows of every constraint of @xmath70 are pairwise compatible .",
    "in particular , set all the variables of the form @xmath435 to zero , and set all remaining variables according to their first - row constraints  note that these rows are the same for different @xmath436 associated with the same polymorphism @xmath350 , while on the other hand , for different polymorphisms @xmath437 , the associated variables are different and there is no cause for conflict .",
    "suppose that @xmath426 has a hitting set @xmath101 of size at most @xmath0 .",
    "we claim that @xmath438 is a strong @xmath383-backdoor set of @xmath70 .",
    "we start by showing that @xmath439 is a strong @xmath386-backdoor set of @xmath70 .",
    "let @xmath440 be an assignment of the variables in @xmath101 and @xmath390 be a polymorphism that maximizes @xmath441 over all polymorphisms in @xmath386 .",
    "we claim that @xmath95 $ ] is closed under @xmath350 and hence @xmath439 is a strong @xmath383-backdoor set of @xmath70 .",
    "because @xmath101 is a hitting set of @xmath426 , it follows that every relation of @xmath95 $ ] contains at most half of the tuples of the corresponding relation in @xmath70 .",
    "furthermore , because @xmath350 is idempotent ( and hence every tuple is mapped to itself ) , it holds that @xmath442 .",
    "it follows that every relation of @xmath95 $ ] contains at least @xmath51 tuple less than the corresponding relation in @xmath70 .",
    "because of the choice of @xmath350 , we obtain that every constraint @xmath391 $ ] contains less than @xmath441 tuples , and hence @xmath95 $ ] is closed under @xmath350 .",
    "hence , @xmath438 is a strong @xmath383-backdoor set of @xmath70 , as required . towards showing that @xmath439 is also a weak @xmath386-backdoor set of @xmath15",
    "consider the assignment @xmath443 .",
    "it follows from the above argumentation that @xmath97 $ ] is closed under the polymorphism @xmath350 .",
    "furthermore , @xmath95 $ ] is satisfiable , because the first row of every constraint of @xmath15 is also contained in every constraint of @xmath95 $ ] and these rows are pairwise compatible .    for the reverse direction",
    ", suppose that @xmath70 has a strong @xmath383-backdoor set @xmath101 of size at most @xmath0 . because for every @xmath444 it holds that the set of constraints @xmath445 is not closed under any polymorphism in @xmath386 , we obtain that @xmath101 has to contain at least @xmath51 variable from @xmath446 for every @xmath444 .",
    "since the only variables that are shared between @xmath446 and @xmath447 for distinct @xmath448 are the variables in @xmath449 , it follows that @xmath426 has a hitting set of size at most @xmath154 , as required .    because all min , max , majority , affine and malcev polymorphisms can be defined via nice properties and are idempotent",
    ", we obtain .    for every @xmath450 , @xmath376 , @xmath377 , @xmath375 , @xmath451 , strong @xmath5backdoor detection and weak @xmath5backdoor detection are @xmath6}}$]hard parameterized by the size of the backdoor set , even for csp instances over the boolean domain .    in the following",
    "we show that hardness also holds if we drop the restriction on the domain of the csp instance but instead consider only csp instances of arity @xmath217 . to do",
    "so we need the following lemma .",
    "[ lem : undom - rel ] for every @xmath452 and every @xmath453 , there is a @xmath217-ary csp instance @xmath454 with @xmath0 constraints , each containing the all @xmath52 tuple , such that @xmath455 but for every assignment @xmath50 of at least one variable of @xmath454 , it holds that @xmath456 \\in { \\mathcal{c}}$ ] .    the proof of this lemma is inspired by the proof of  ( * ? ? ?",
    "* lemma 3 ) . for every @xmath5 as in the statement of the lemma",
    ", @xmath454 has variables @xmath457 and contains a constraint @xmath11 with scope @xmath458 for every @xmath459 .    if @xmath460 , the domain of @xmath454 is @xmath461 , and for every @xmath459 the relations @xmath462 are defined as follows : @xmath463 , @xmath464 , @xmath465 , and for every @xmath466 , @xmath467 .",
    "clearly , the instance is binary and every relation contains the all @xmath52 tuple .",
    "we first show that @xmath454 is not closed under any majority polymorphism @xmath350 . from @xmath468 and @xmath469",
    ", we obtain @xmath470 and from @xmath471 , we obtain @xmath472 . finally , from @xmath462 with @xmath473 , we obtain @xmath474 if and only if @xmath475 .",
    "this chain implies @xmath476 in contradiction to @xmath477 . on the other hand , for any assignment @xmath50 that sets at least @xmath51 variable of @xmath454",
    ", it holds that at least one relation of @xmath456 $ ] contains at most @xmath217 tuples . this relation",
    "is then closed under any majority polymorphism and breaks the above chain of implications .",
    "if @xmath478 , the domain of @xmath454 is @xmath479 , and for every @xmath459 the relations @xmath462 are defined as follows : @xmath480 for every @xmath481 and @xmath482 .",
    "clearly , the instance is binary and every relation contains the all @xmath52 tuple .",
    "let @xmath350 be a max polymorphism .",
    "then , for every @xmath483 , the relation @xmath484 implies @xmath485 , but the relation @xmath486 implies @xmath487 , a contradiction .",
    "hence , the set of all relations @xmath488 is not closed under any max polymorphism . on the other hand , for any assignment @xmath50 that sets at least @xmath51 variable of @xmath454 , it holds that at least one relation of @xmath456 $ ] contains at most @xmath217 tuples that agree on ( at least ) one coordinate . this relation",
    "is then closed under any max polymorphism and breaks the above chain of implications .",
    "if @xmath489 , we can use the same set of relations .",
    "if @xmath489 , the domain of @xmath454 is @xmath490 , and for every @xmath459 the relations @xmath462 are defined as follows : @xmath491 , @xmath492 for every @xmath493 , and @xmath494 .",
    "clearly , the instance is binary and every relation contains the all @xmath52 tuple .",
    "let @xmath350 be a minority polymorphism .",
    "then , @xmath495 implies @xmath496 , which together with the relations @xmath484 , for every @xmath497 implies @xmath498 .",
    "in particular , we obtain @xmath499 , which contradicts relation @xmath486 .",
    "hence , the set of all relations @xmath488 is not closed under any minority polymorphism . on the other hand , for any assignment @xmath50 that sets at least @xmath51 variable of @xmath454 , it holds that at least one relation of @xmath456 $ ] contains at most @xmath217 tuples . this relation",
    "is then closed under any minority polymorphism and breaks the above chain of implications .",
    "if @xmath500 , we can use the same set of relations .",
    "[ the - arity2 ] for every @xmath450 , @xmath376 , @xmath377 , @xmath375 , @xmath451 , strong @xmath5backdoor detection and weak @xmath5backdoor detection are @xmath6}}$]-hard even for csp instances with arity @xmath217 .",
    "the proof of the theorem is inspired by the proof of  ( * ? ? ?",
    "* theorem 6 ) .",
    "we show the theorem via a fpt - reduction from hitting set .",
    "let @xmath424 be an instance of hitting set .",
    "we construct a csp instance @xmath81 of arity @xmath217 such that @xmath426 has a hitting set of size at most @xmath0 if and only if @xmath70 has a strong @xmath5-backdoor set of size at most @xmath0 .",
    "the variables of @xmath70 are @xmath501 .",
    "furthermore , for every @xmath444 with @xmath431 , let @xmath502 be the csp instance obtained from @xmath503 ( see lemma  [ lem : undom - rel ] ) , where for every @xmath64 with @xmath504 , we replace the scope of the constraint @xmath11 with @xmath505 and adapt @xmath503 in such a way that for distinct @xmath448 , @xmath503 and @xmath506 have no common domain value .",
    "then , the constraints of @xmath70 is the union of the constraints of @xmath502 over every @xmath444 .",
    "this completes the construction of @xmath70 .",
    "clearly , @xmath70 has arity @xmath217 and is satisfiable , e.g. , by the all @xmath52 assignment .",
    "suppose that @xmath426 has a hitting set @xmath101 of size at most @xmath0 .",
    "we claim that @xmath438 is a strong @xmath5-backdoor set of @xmath70 .",
    "we start by showing that @xmath439 is a strong @xmath5-backdoor set of @xmath70 .",
    "let @xmath440 be an assignment of the variables in @xmath101 .",
    "then , it follows from lemma  [ lem : undom - rel ] that the constraints of @xmath507 $ ] are in @xmath5 .",
    "in particular , there is a polymorphism @xmath350 ( which is either min , max , majority , minority or malcev , depending on @xmath5 ) such that the constraints of @xmath507 $ ] are closed under @xmath350 . because for every distinct @xmath448 , @xmath507 $ ] and @xmath508 $ ] do not have a common domain value , it follows that there is a polymorphism ( which is a combination of the polymorphisms for each @xmath507)$ ] ) such that @xmath95 $ ] is closed under @xmath350 and @xmath350 is a min , max , majority , minority , or malcev polymorphism ( depending on @xmath5 ) .",
    "hence , @xmath95 \\in { \\mathcal{c}}$ ] , as required . towards showing that @xmath439 is also a weak @xmath5-backdoor set of @xmath15 consider the assignment @xmath443 .",
    "it follows from the above argumentation that @xmath95 \\in { \\mathcal{c}}$ ] .",
    "furthermore , @xmath95 $ ] is satisfiable , because every constraint of @xmath95 $ ] still contains the all @xmath52 tuple .    for the reverse direction , suppose that @xmath70 has a strong @xmath5-backdoor set @xmath101 of size at most @xmath0 . because for every @xmath444 it holds that the set of constraints of @xmath502 is not in @xmath5",
    ", we obtain that @xmath101 has to contain at least @xmath51 variable from @xmath509 for every @xmath444 .",
    "since the only variables that are shared between @xmath509 and @xmath510 for distinct @xmath448 are the variables in @xmath449 , it follows that @xmath426 has a hitting set of size at most @xmath154 , as required .",
    "in this section we draw a comparison between our notion of backdoor sets , and the approach recently introduced by  @xcite  ( @xcite ) , which we will call the _ partition backdoor set _ approach .",
    "the main difference is that the partition backdoor set approach considers a backdoor with respect to a subset of constraints that is tractable ( because it is closed under some tractable polymorphism ) .",
    "in particular , @xcite  ( @xcite ) define partition backdoor sets as follows .",
    "let @xmath381 be a nice polymorphism property .",
    "a @xmath381-partition backdoor of a csp instance @xmath81 is a set @xmath101 of variables , such that there is a partition of @xmath15 into @xmath511 and @xmath512 for which the following holds :    * @xmath513 , and * if @xmath381 is characterized using only idempotent polymorphisms , then @xmath101 is the set of all variables in the scope of the constraints of @xmath512 , while if @xmath381 is characterized using only conservative polymorphisms , then the variables of @xmath101 are a vertex cover of the primal graph of @xmath511 .",
    "note that the primal graph of a set @xmath15 of constraints is the graph , whose vertices are all the variables appearing in the scope of the constraints in @xmath15 and that has an edge between two variables if and only if they appear together in the scope of at least one constraint in @xmath15 .",
    "they show that given a csp instance and a partition @xmath514 as defined above , then the detection and evaluation of @xmath381-partition backdoor sets are fixed - parameter tractable    * in the size of the domain and the number of variables in @xmath511 , if @xmath381 is characterized using only idempotent polymorphisms ; * in the size of the domain and the vertex cover of the primal graph of @xmath511 , if @xmath381 is characterized using only conservative polymorphisms .",
    "observe that the above tractability results only hold when the partition @xmath514 is given as a part of the input , if it is not then the detection of partition backdoors is shown to be fixed - parameter intractable ( for most combinations of parameters ) .    apart from the complexity of detecting and evaluating backdoors it is also important that the backdoor sets are as small as possible over a wide variety of csp instances . in the following",
    "we will observe that our backdoor sets are always at most as large as partition backdoors and we exhibit csp instances where our backdoors have size one but the size of a smallest partition backdoor set grows with the number of variables of the csp instance .",
    "let @xmath381 be a nice polymorphism property .",
    "then , for every csp instance @xmath70 the size of a smallest strong @xmath381-backdoor set of @xmath70 is at most the size of a smallest @xmath381-partition backdoor set of @xmath70 .",
    "this follows from the observation that any @xmath381-partition backdoor set is also a strong @xmath381-backdoor set .    for any nice property @xmath381 and any natural number @xmath59 ,",
    "there is a csp instance that has a strong / weak @xmath383-backdoor set of size one , but the size of a smallest @xmath381-partition backdoor set is @xmath13 .",
    "let @xmath381 be a nice property and let @xmath81 be a csp instance such that :    * no constraint of @xmath70 is closed under a polymorphism with property @xmath381 ; * all constraints of @xmath70 share a common variable , say @xmath35 , such that for any assignment @xmath50 of @xmath35 , the csp instance @xmath95 $ ] is closed under some polymorphisms with property @xmath381 .",
    "it is straightforward to check that for any number of variables @xmath59 , such a csp instance using @xmath59 variables can be easily constructed for every nice property @xmath381 that contains at least one polymorphism .",
    "furthermore , the variable @xmath35 is a strong @xmath383-backdoor set of @xmath70 .",
    "however , because no constraint of @xmath70 is closed under any polymorphism from @xmath381 it follows that every partition backdoor has to contain at least all but @xmath51 variable from every constraint of @xmath70 .",
    "we have introduced heterogeneous base classes and have shown that strong backdoor sets into such classes can be considerably smaller than strong backdoor sets into homogeneous base classes ; nevertheless , the detection of strong backdoor sets into homogeneous base classes is still fixed - parameter tractable in many natural cases .",
    "hence , our results push the tractability boundary considerably further .",
    "our theoretical evaluation entails hardness results that establish the limits for tractability .",
    "our main result in the context of sat ( theorem  [ the : sat - dico ] ) provides a complete complexity classification for strong backdoor set detection to heterogeneous base classes composed of the well - known schaefer classes .",
    "we observe that the hardness results rely on clauses of unbounded length . in a follow - up result",
    ", we also show that strong as well as weak backdoor set detection into any combination of the schaefer classes is fixed - parameter tractable for the combined parameter backdoor set size and the maximum length of the clauses ( theorem  [ the : sat - clause - sb ] ) .",
    "our main result for csp backdoors ( theorem  [ the : fpt - csp ] ) establishes fixed - parameter tractability for a wide range of heterogeneous base classes composed of possibly infinitely many tractable polymorphisms .",
    "in particular , we show that the detection of strong as well as weak backdoor sets is fixed - parameter tractable for the combined parameter backdoor size , domain size , and the maximum arity of constraints .",
    "in fact , this result entails _ heterogeneous _ base classes , as different instantiations of the backdoor variables can lead to reduced instances that are closed under different polymorphisms ( even polymorphisms of different type ) .",
    "we complement our main result with hardness results that show that we loose fixed - parameter tractability when we omit either domain size or the maximum arity of constraints from the parameter ( theorems  [ the : domain ] and [ the - arity2 ] )",
    ".    it would be interesting to extend our line of research to the study of backdoor sets into heterogeneous base classes composed of homogeneous classes defined by global properties , in contrast to the schaefer classes for sat , and polymorphism - based classes for csp .",
    "gaspers is the recipient of an australian research council discovery early career researcher award ( project number de120101761 ) .",
    "nicta is funded by the australian government as represented by the department of broadband , communications and the digital economy and the australian research council through the ict centre of excellence program .",
    "misra is supported by the inspire faculty scheme , dst india ( project dsto-1209 ) .",
    "ordyniak acknowledges support from the employment of newly graduated doctors of science for scientific excellence ( cz.1.07/2.3.00/30.0009 ) .",
    "ordyniak and szeider were supported by the european research council , grant reference 239962 ( complex reason ) and the austrian science funds ( fwf ) , project i836-n23 ( algorithms and complexity of constraint languages ) and project p26696 ( exploiting new types of structure for fixed parameter tractability ) .",
    "ivn is supported by a royal society university research fellowship .",
    "christian bessiere , clment carbonnel , emmanuel hebrard , george katsirelos , and toby walsh . detecting and exploiting subproblem tractability . in francesca",
    "rossi , editor , _ ijcai 2013 , proceedings of the 23rd international joint conference on artificial intelligence , beijing , china , august 3 - 9 , 2013_. ijcai / aaai , 2013 .",
    "clment carbonnel , martin  c. cooper , and emmanuel hebrard . on backdoors",
    "to tractable constraint languages . in barry osullivan , editor , _ principles and practice of constraint programming - 20th international conference ,",
    "cp 2014 , lyon , france , september 8 - 12 , 2014 . proceedings _ ,",
    "volume 8656 of _ lecture notes in computer science _ , pages 224239 .",
    "springer , 2014 .",
    "bistra  n. dilkina , carla  p. gomes , and ashish sabharwal .",
    "tradeoffs in the complexity of backdoor detection . in _ principles and practice of constraint programming - cp 2007 , 13th international conference ,",
    "cp 2007 , providence , ri , usa , september 23 - 27 , 2007 , proceedings _",
    ", volume 4741 of _ lecture notes in computer science _ , pages 256270 .",
    "springer verlag , 2007 .",
    "bistra  n. dilkina , carla  p. gomes , and ashish sabharwal .",
    "backdoors in the context of learning . in oliver",
    "kullmann , editor , _ theory and applications of satisfiability testing - sat 2009 , 12th international conference , sat 2009 , swansea , uk , june 30 - july 3 , 2009 .",
    "proceedings _ , volume 5584 of _ lecture notes in computer science _ , pages 7379 .",
    "springer verlag , 2009 .",
    "robert ganian , m.  s. ramanujan , and stefan szeider .",
    "discovering archipelagos of tractability for constraint satisfaction and counting .",
    "accepted at _",
    "soda 2016 , the acm - siam symposium on discrete algorithms , 2016 _ , _ corr _ , abs/1507.02479 , 2015 .",
    "url http://arxiv.org/abs/1507.02479 .",
    "serge gaspers and stefan szeider .",
    "backdoors to satisfaction . in hans",
    "l. bodlaender , rod downey , fedor  v. fomin , and dniel marx , editors , _ the multivariate algorithmic revolution and beyond - essays dedicated to michael r. fellows on the occasion of his 60th birthday _ ,",
    "volume 7370 of _ lecture notes in computer science _ , pages 287317 .",
    "springer verlag , 2012 .",
    "serge gaspers and stefan szeider .",
    "strong backdoors to bounded treewidth sat . in _",
    "54th annual ieee symposium on foundations of computer science , focs 2013 , 26 - 29 october , 2013 , berkeley , ca , usa _ , pages 489498 .",
    "ieee computer society , 2013 .",
    "pawel  m. idziak , petar markovic , ralph mckenzie , matthew valeriote , and ross willard .",
    "tractability and learnability arising from algebras with few subpowers .",
    "_ siam journal on computing _ , 390 ( 7):0 30233037 , 2010 .",
    "doi : 10.1137/090775646 .",
    "stephan kottler , michael kaufmann , and carsten sinz . a new bound for an np - hard subclass of 3-sat using backdoors . in hans",
    "kleine bning and xishun zhao , editors , _ theory and applications of satisfiability testing - sat 2008 , 11th international conference , sat 2008 , guangzhou , china , may 12 - 15 , 2008 . proceedings _ , volume 4996 of _ lecture notes in computer science _",
    ", pages 161167 .",
    "springer verlag , 2008 .",
    "martin kronegger , sebastian ordyniak , and andreas pfandler .",
    "backdoors to planning . in carla",
    "e. brodley and peter stone , editors , _ proceedings of the twenty - eighth aaai conference on artificial intelligence , july 27 -31 , 2014 , qubec city , qubec , canada .",
    "_ , pages 23002307 .",
    "aaai press , 2014 .",
    "martin kronegger , sebastian ordyniak , and andreas pfandler .",
    "variable - deletion backdoors to planning . in _ proceedings of the twenty - ninth aaai conference on artificial intelligence ,",
    "january 25 -30 , 2015 , austin texas , austin , usa . _ , pages 23002307 .",
    "aaai press , 2014 .",
    "ronan lebras , richard bernstein , carla  p. gomes , bart selman , and r.  bruce van dover .",
    "crowdsourcing backdoor identification for combinatorial optimization . in francesca",
    "rossi , editor , _ ijcai 2013 , proceedings of the 23rd international joint conference on artificial intelligence , beijing , china , august 3 - 9 , 2013_. ijcai / aaai , 2013 .",
    "naomi nishimura , prabhakar ragde , and stefan szeider .",
    "detecting backdoor sets with respect to horn and binary clauses . in _ proceedings of sat 2004 ( seventh international conference on theory and applications of satisfiability testing , 1013 may , 2004 , vancouver , bc , canada ) _ , pages 96103 , 2004 .",
    "andreas pfandler , stefan rmmele , and stefan szeider .",
    "backdoors to abduction . in _ proceedings of ijcai 2013 ,",
    "the 23th international joint conference on artificial intelligence , august 39 , 2013 , beijing , china _ , 2013 .",
    "yongshao ruan , henry  a. kautz , and eric horvitz .",
    "the backdoor key : a path to understanding problem hardness . in deborah",
    "l. mcguinness and george ferguson , editors , _ proceedings of the 19th national conference on artificial intelligence , 16th conference on innovative applications of artificial intelligence _ , pages 124130 .",
    "aaai press / the mit press , 2004 .",
    "marko samer and stefan szeider .",
    "fixed - parameter tractability . in armin",
    "biere , marijn heule , hans van maaren , and toby walsh , editors , _ handbook of satisfiability _ , chapter  13 , pages 425454 .",
    "ios press , 2009 .",
    "ryan williams , carla gomes , and bart selman .",
    "backdoors to typical case complexity . in georg",
    "gottlob and toby walsh , editors , _ proceedings of the eighteenth international joint conference on artificial intelligence , ijcai 2003 _ , pages 11731178 .",
    "morgan kaufmann , 2003 .",
    "ryan williams , carla gomes , and bart selman . on the connections between backdoors , restarts , and heavy - tailedness in combinatorial search . in",
    "_ informal proc . of the sixth international conference on theory and applications of satisfiability testing , s. margherita ligure - portofino , italy ,",
    "may 5 - 8 , 2003 ( sat 2003 ) _ , pages 222230 , 2003 ."
  ],
  "abstract_text": [
    "<S> in this paper we extend the classical notion of strong and weak backdoor sets by allowing that different instantiations of the backdoor variables result in instances that belong to different base classes ; the union of the base classes forms a heterogeneous base class . </S>",
    "<S> backdoor sets to heterogeneous base classes can be much smaller than backdoor sets to homogeneous ones , hence they are much more desirable but possibly harder to find . </S>",
    "<S> we draw a detailed complexity landscape for the problem of detecting strong and weak backdoor sets into heterogeneous base classes for sat and csp . </S>"
  ]
}