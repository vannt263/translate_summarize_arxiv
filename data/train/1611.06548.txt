{
  "article_text": [
    "computing an upper bound for real roots of a polynomial is an important problem in computational algebra .",
    "it has numerous applications ( for instance root separation , to mention just one ) .",
    "thus , in recent decades there has been intensive effort to find such bounds . given a univariate polynomial @xmath0 $ ] with a positive leading coefficient ,",
    "a good bound for its positive roots is the one obtained in @xcite : @xmath1 a nave , straightforward implementation of this bound clearly has a time complexity of @xmath2 .",
    "@xcite proposed a geometric approach to computing this bound and presented a very smart algorithm that runs in linear time ( with respect to the degree of a polynomial ) .",
    "unfortunately their algorithm turns out to be incorrect .",
    "the aim of this note is to explain the source of errors as well as to propose a possible corrections so that the resulting algorithm accurately computes the hong s bound and still works in linear time .    for the sake of clarity , in this paper",
    "we adopt the notation of @xcite , much to a discomfort of the author , who is more used to a different notational convention . thus ,",
    "with every nonzero term @xmath3 of a polynomial @xmath4 , we associate a pair @xmath5 , where @xmath6 denotes a logarithm of base  @xmath7 .",
    "we interpret these pairs as points in the real plane  @xmath8 .",
    "a point @xmath9 is said to be _ positive _ if @xmath10 , otherwise it is called _",
    "negative_. the set of positive points with absciss greater or equal to some fixed integer  @xmath11 is denoted @xmath12 the absciss of the points  @xmath13 for @xmath14 , being exponents of  @xmath15 in the original polynomial , are non - negative integers .",
    "thus , if  @xmath13 is a positive point , then  @xmath13 and  @xmath16 are respectively the left - most and right - most points of the convex hull @xmath17 of  @xmath18 .",
    "consequently , they split the boundary of @xmath17 into two chains of points : the _ lower hull _ @xmath19 and the _ upper hull _",
    "if  @xmath21 is a point positioned to the left of  @xmath18 , then there is a unique line that passes through  @xmath21 and at least one point of  @xmath18 and such that all points of  @xmath18 are on or above it .",
    "this line is called the _ lower tangent _ and denoted @xmath22 .",
    "the left - most point of the intersection @xmath23 is called the _ point of tangency _ of @xmath22 .",
    "the algorithm of mehlhorn and ray keeps track of the following data during execution :    * @xmath24 is the maximal slope of lower tangents computed so far ; * @xmath25 is the lower tangent to @xmath17 with the slope  @xmath24 ; * @xmath26 is the point of tangency of  @xmath25 ; * @xmath27 is the lower hull of  @xmath18 .    in what follows",
    "we preserve this notation .",
    "the algorithm presented in ( * ? ? ? * section  3 ) suffers from two interconnected problems :      the variable  @xmath26that stores the point of tangency of the lower tangent with a maximal slope  is initialized at the beginning of the algorithm ( * ? ? ? * algorithm  1 , line  2 ) by setting @xmath28 , but it is * never lowered*. hence it stays at  @xmath16 throughout the whole process . indeed , analyzing the algorithm , we see that :    * in line  15 , @xmath26 is being passed over by setting @xmath29 ; * for @xmath10 , the variable  @xmath26 is not set in the pseudo - code , but according to the description ( * ? ? ?",
    "* , line @xmath30 ) it is again set @xmath29 ; * in line  10 , a new  @xmath26 is searched to the * right * of  @xmath31 .",
    "the claim ( * ? ? ? * , line @xmath32 ) :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` the tangent point  @xmath26 of @xmath33 can not lie to the left of  @xmath31 '' _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    is false .",
    "it would be true if the lower hull of positive points has not changed since we found  @xmath31 .",
    "but not without this assumption . if the lower hull has changed , looking for the point of tangency , we must scan the entire lower hull starting from its beginning , not from the previously obtained point  @xmath31 .",
    "we show an explicit example .",
    "take a polynomial : @xmath34 for @xmath35 , the polynomial has two negative coefficients and so the hong s bound equals twice the maximum of two minimums : @xmath36{\\frac14 } , \\sqrt[5]{\\frac14 } , \\sqrt[8]{\\frac18 } \\right\\ }     = \\sqrt[3]{\\frac14}\\\\ \\text{for } a_4 & :    \\min_{\\substack{i > 4\\\\ a_i > 0 } } \\left ( \\frac{2}{a_i } \\right)^{\\frac1{i-4 } }     = \\min \\left\\ { \\frac12 , \\sqrt[4]{\\frac14 } \\right\\ }     = \\frac12\\end{aligned}\\ ] ] thus , the maximum is reached for a pair of coefficients  @xmath37 and @xmath38{\\sfrac14 } = \\sqrt[3]{2}\\approx 1.2599.\\ ] ] let us analyze what the algorithm of mehlhorn and ray does in this case .",
    "ignore for a moment issue  1 .",
    "the coefficients of  @xmath39 correspond to points ( see figure  [ fig_points ] ) : @xmath40 the lower hull @xmath41 of @xmath42 is just a line segments connecting  @xmath43 with  @xmath44 .",
    "the lower tangent @xmath45 to the convex hull of  @xmath46 and passing through  @xmath47 is a line  @xmath48 with a slope @xmath49 .",
    "the point of tangency of  @xmath50 is @xmath51 .",
    "( if we did not ignore issue  1 here , the algorithm would incorrectly pick up @xmath52 and so  @xmath53 would be @xmath54 , which is evidently not minimal . )",
    "the point  @xmath47 is negative , thus the lower hull of positive points stays intact and we have @xmath55 .",
    "the next point to consider is  @xmath56 .",
    "it is positive , hence the algorithm updates the lower hull .",
    "now , @xmath57 is a line segment with endpoints  @xmath56 and  @xmath44 .",
    "the point  @xmath43 is removed from the lower hull .",
    "finally , we consider the point  @xmath58 .",
    "it is negative again .",
    "the lower tangent @xmath59 is a line  @xmath60 that passes through the newly added point  @xmath56 .",
    "it has a slope of  @xmath61 .",
    "it is now evident that in order to find the tangent point , we must scan the lower hull * from the beginning * , not from the point @xmath51 .",
    "not only the point  @xmath43 was removed from the lower hull , but scanning the points to the right of it would result in picking up a point  @xmath44 and the resulting line would have a slope  @xmath62 .",
    "all in all , the algorithm computes @xmath63 and returns @xmath64 , which is not the correct hong s bound for  @xmath39 .",
    "it should be noted that , if we take @xmath65 in the above polynomial , then the hong s bound is obtained not from the pair @xmath66 but from @xmath67 .",
    "this shows that if the lower hull of the set of positive points is rebuilt , we cannon a priori exclude any of the points .",
    "all the point of the new lower hull must be scanned to obtain the lower tangent .",
    "configuration of points corresponding to the polynomial @xmath68 .",
    "positive points are marked by filled dots , negative ones by empty dots .",
    "thick lines correspond to lower hulls , dashed lines to lower tangents . ]",
    "the algorithm of mehlhorn and ray can be simply corrected to evade the pitfalls mention in the previous section .",
    "the most direct approach is to update the point of tangency  @xmath26 , when the lower hull of the positive points changes .",
    "a straightforward , but rather nave , solution is to set  @xmath26 to the first point of  @xmath27 .",
    "the corresponding part of the algorithm would then read : unfortunately , these modifications blow the time complexity of the algorithm up to @xmath2 , which is the time complexity of the most direct evaluation of hong s bound",
    ".    one may observe that if a positive point  @xmath13 lies on or above the line  @xmath69 , then it will never become a tangent point and consequently the point  @xmath26 may be left intact in this case . indeed , suppose that  @xmath13 is on or above  @xmath69 and take a subsequent negative point  @xmath70 , @xmath71 . as explained in ( * ? ? ?",
    "* section  3.2 ) , without loss of generality , we may assume that  @xmath70 lies below  @xmath69 , since otherwise it would not contribute to the hong s bound .",
    "but now  @xmath70 is under and  @xmath13 above a previously computed lower tangent  @xmath69 .",
    "therefore , a line through  @xmath70 and  @xmath13 is definitely not the lower tangent @xmath72 .",
    "thus we may improve upon the previous solution treating positive points as follows ( this code replaces ( * ? ? ?",
    "* algorithm  1 , lines 1920 ) ) :    regrettably even the improved version still has a quadratic time - complexity . in order to recover the linear time complexity , we need to reshape the algorithm more seriously and separate the phase of building of the lower hulls from computation of the lower tangent of a maximal slope .",
    "the algorithm we are going to present is a two - pass process .",
    "the first pass scans the points in the decreasing order of indices ( i.e. right - to - left ) and is used to build and store all the lower hulls .",
    "subsequently , in the second pass the algorithm goes through the points left - to - right and computes the sought hong s bound .",
    "as said , we are going to store all intermediate lower hulls  @xmath19 .",
    "if we did it navely and store them as a list of lists , then we would end up with a space complexity of @xmath2 .",
    "reading and writing this data would need @xmath2 time .",
    "we can evade this trap , observing that if  @xmath13 is a positive point , then @xmath19 is a chain of the form @xmath73 and its `` tail '' @xmath74 is a lower hull of  @xmath75 . consequently , we may store all the lower hulls as a single array of indices , call it  @xmath76 . for a positive point",
    "@xmath13 we set @xmath77 = j$ ] to be the index of the * second * point ( the first one is of course  @xmath13 ) of the lower hull @xmath19 .",
    "hence the lower hull of  @xmath18 equals @xmath78 } , p_{v[v[i ] ] } , \\dotsc \\bigr).\\ ] ] on the other hand , for a negative point  @xmath13 , we let @xmath77 $ ] be the index of the * first * point of @xmath19 , or in other words the index of the first positive coefficient of  @xmath39 to the right of  @xmath79 .          1",
    ".   set @xmath82 , it will store the index of the last visited positive point , and initialize @xmath83 : = -1 $ ] ; 2 .",
    "iterate over the coefficients of  @xmath39 in decreasing order of indices @xmath84 ; 1 .",
    "if @xmath85 , then the lower hull @xmath19 does not change , hence set @xmath77 : = k$ ] and reiterate the main loop ; 2 .",
    "if @xmath10 , then 1 .   scan the lower hull @xmath86 } , p_{v[v[k ] ] } , \\dotsc \\bigr)\\ ] ] to find the point of tangency of @xmath87 as explained in section  2 of @xcite ; 2 .",
    "let @xmath88 be the abscissa of the point found in the previous step , set @xmath77 : = j$ ] ; 3 .",
    "update @xmath89 ;      1 .",
    "let @xmath90 be the lowest index of a negative coefficient of  @xmath39 ; 2 .   scan the lower hull @xmath91 } , p_{v[v[j ] ] } , \\dotsc \\bigr)$ ] to find the tangent point @xmath70 of @xmath92 , set @xmath93 , @xmath94 and",
    "let  @xmath95 be the slope of  @xmath96 ; 3 .",
    "iterate over the coefficients of  @xmath39 in an increasing order of indices starting from  @xmath97 : 1 .   if @xmath10 , then : 1 .   set @xmath98",
    "if @xmath99 , then this point gets removed from the lower hull in the next step , hence set @xmath26 to the first point of @xmath100 , which is either @xmath101 if @xmath101 is positive or @xmath102}$ ] if @xmath101 is negative , and let  @xmath25 be a line parallel to  @xmath103 but passing through  @xmath26 ; 3 .",
    "otherwise pass over : @xmath104 and @xmath105 ; 2 .",
    "if @xmath85 , then : 1 .   if  @xmath13 lies on or above  @xmath103 , then ignore it , setting @xmath104 , @xmath98 and @xmath105 , reiterate the main loop ; 2 .   otherwise , when  @xmath13 lies below  @xmath103 , the let  @xmath106 be the abscissa of  @xmath26 and scan the `` tail '' of the lower hull @xmath19 consisting of points @xmath107 } , p_{v[v[k ] ] } , \\dotsc ) $ ] to find the tangent point  @xmath108 of @xmath109 ; 3 .   if the slope of @xmath109 is greater than  @xmath110 , set @xmath111 , @xmath112 and @xmath24 the slope of  @xmath25 ; 4 .",
    "return @xmath113 .",
    "the corrected algorithm was implemented in a computer algebra system @xcite , both to test it correctness and evaluate its speed .",
    "the code can be downloaded from authors home page at http://z2.math.us.edu.pl/perry/papersen.html .",
    "it was executed on randomly generated polynomials of varying degrees and the average computation times were compared with running times of a direct implementation of the hong s bound .",
    "figure  [ fig_graph ] and table  [ tab_times ] summarize the results .    .[tab_times]running time of a sage implementation of a proposed linear - time algorithm ( middle column ) against a direct quadratic - time implementation ( right column ) .",
    "the times are in second for 10 polynomials [ cols= \" > , > , < , > , < \" , ]"
  ],
  "abstract_text": [
    "<S> we show that a linear - time algorithm for computing hong s bound for positive roots of a univariate polynomial , described by k.  mehlhorn and s.  ray in an article `` faster algorithms for computing hong s bound on absolute positiveness '' , is incorrect . </S>",
    "<S> we present a corrected version . </S>"
  ]
}