{
  "article_text": [
    "let @xmath0 and @xmath1 be two graphs . packing @xmath1 into @xmath2 is to find vertex - disjoint subgraphs each of which is isomorphic to @xmath1 .",
    "covering every subgraph isomorphic to @xmath1 in @xmath2 is to find a set @xmath3 such that @xmath4 has no subgraph isomorphic to @xmath1 . in @xmath2",
    "the largest number of vertex - disjoint subgraphs that are each isomorphic to @xmath1 is related to the smallest number of vertices that cover all subgraphs that are each isomorphic to @xmath1 .",
    "packing and covering problems are dual and manifest some properties of the subgraph @xmath1 .",
    "let @xmath10 denote the smallest number of vertices of a cover .",
    "if in arbitrary graph @xmath2 we have @xmath11 where @xmath12 is the largest number of vertex - disjoint subgraphs that are each isomorphic to @xmath1 , then @xmath1 has the _ erds - psa _ property [ 1 ] .",
    "cycle has the _ erds - psa _ property and packing cycle has been studied in related work [ 2][3 ] .",
    "packing and covering also give rise to some rather difficult problems in computer science .",
    "packing the simple subgraph of a single edge into arbitrary graph is called matching . matching problem is to find the largest number of independent edges and has been proved a np - complete problem in computational complexity .",
    "many other packing problems are also np - complete or np - hard . since it is difficult to deal with these problems , packing vertex - disjoint graphs of other sorts such as trees were not sufficiently discussed in literature . however",
    ", packing vertex - disjoint trees has its applications in data encryption and in communication networks .",
    "the distributed multi - cast routing in the current internet can be modeled as a tree packing problem .",
    "the multi - cast routers ( vertices of the graph ) can be divided into independent groups ( trees ) for efficient data transmission and interconnection of networks [ 4 ] .",
    "emergence of new networking design [ 5 ] also take advantage of the content - distributed groups ( trees ) to disseminate content and ensure no matter which groups are choose each group contains a fixed source router ( covering problem ) .    in this paper ,",
    "we are primarily concerned with the perfect binary tree packing problem , which includes the kind of graph into which we can pack the tree , in this kind of graph the relation between the largest number of vertex - disjoint subgraphs isomorphic to the tree and the smallest number of vertices that cover all subgraphs isomorphic to the tree , the computational complexity of such vertex - disjoint tree packing into an arbitrary graph , and the applicable approximation algorithms for these problems . for the perfect binary tree @xmath13 with @xmath14 ,",
    "we give the 2-connected graph @xmath2 that has the order of @xmath15 ( @xmath16 is a positive integer ) and can be constructed from the longest cycle @xmath17 contained in @xmath2 .",
    "we prove that in @xmath2 the largest number @xmath18 of vertex - disjoint subgraphs isomorphic to @xmath13 is equal to the smallest number @xmath19 of vertices that cover all subgraphs isomorphic to @xmath13 .",
    "cycles have the _ erds - psa _ property . but",
    "perfect binary trees do not have such property that is also proved in this paper .",
    "for the perfect binary tree @xmath20 with @xmath21 , we give the 3-connected graph @xmath2 which can be generated from a minor of @xmath2 isomorphic to the complete graph @xmath22 .",
    "the kind of @xmath6-connected graph , generated from @xmath23 as a minor , also have the largest packing subgraph number equal to the smallest covering vertex number .",
    "karp in [ 6 ] proposed that matching problem is np - complete . based on this , we prove that perfect binary tree packing problem is np - hard .",
    "since distributed algorithms such as dijkstra algorithm in the current internet have been widely applied in communication networks , we propose distributed approximation algorithms for packing @xmath9 into an arbitrary graph .",
    "a key process in the algorithm is to detect the blocks of a connected graph .",
    "the @xmath13 packing algorithm has complexity of @xmath24 and the @xmath20 packing algorithm has complexity of @xmath25 .",
    "the remainder of this paper is organized as follows . in section 2 ,",
    "we give the lemmas and theorems about packing @xmath8-order perfect binary tree into @xmath6-connected graph . in section 3",
    ", we prove the computational complexity and propose approximation algorithms for packing @xmath9 into an arbitrary graph .",
    "let @xmath26 denote the @xmath8-order perfect binary tree .",
    "[ section ]    let @xmath16 be a positive integer , @xmath27 be a path of length @xmath15 and @xmath28 be a cycle of length @xmath15 .",
    "then    \\(i ) at most @xmath29 vertex - disjoint subgraphs isomorphic to @xmath13 can be packed into @xmath27 ; at least @xmath29 vertices of @xmath27 suffice to meet all its subgraphs isomorphic to @xmath13 ;    \\(ii ) at most @xmath29 vertex - disjoint subgraphs isomorphic to @xmath13 can be packed into @xmath28 ; at least @xmath29 vertices of @xmath28 suffice to meet all its subgraphs isomorphic to @xmath13 .",
    "the path @xmath27 can be expressed as a sequence of its vertices , i.e. @xmath30 . in the same way @xmath28",
    "is expressed as @xmath31 .",
    "we choose the three consecutive points @xmath32 , @xmath33 and @xmath34 where @xmath35 to be a group .",
    "then we can divide @xmath27 or @xmath28 into @xmath29 groups . in order to pack as many vertex - disjoint subgraphs isomorphic to @xmath13 as possible , we choose the subgraph @xmath36 and get total @xmath29 such subgraphs .",
    "the covering problem also needs deliberate selection of a vertex set . due to the symmetric property of the path and cycle",
    ", we just have to decide the distance between two adjacent cover points .",
    "we choose the set @xmath37 as a cover .",
    "the vertex @xmath33 covers three subgraphs isomorphic to @xmath13 : @xmath38 , @xmath39 and @xmath40 .",
    "so , the cover set contains @xmath29 vertices .",
    "[ lemma]theorem    let a 2-connected graph @xmath2 contains a cycle @xmath28 of length @xmath15 , which is the longest among all its cycles .",
    "let the length of @xmath2-path be three or a multiple of three and the ends of @xmath2-path be in the vertex set covering all @xmath2 s subgraphs isomorphic to @xmath13 .",
    "then in @xmath2 the largest number @xmath18 of vertex - disjoint subgraphs isomorphic to @xmath13 is equal to the smallest number @xmath19 of vertices that cover all subgraphs isomorphic to @xmath13 .",
    "according to the property of 2-connected graphs [ 2 ] , we can reconstruct the 2-connected graph @xmath2 in this way : ( i ) to find in @xmath2 a cycle @xmath17 ; ( ii)to add @xmath17-paths to @xmath17 to form a graph @xmath1 ; ( iii ) to add @xmath1-paths successively to @xmath1 until we get @xmath2 . following this way",
    ", we can construct the 2-connected graph that meets the requirements in the theorem .",
    "we need ( i)find the longest cycle @xmath17 whose length is @xmath15 ; ( ii)find each @xmath17-path @xmath41 whose ends are in the covering vertex set @xmath5 and get @xmath42 ; ( iii)find possible @xmath7-paths whose ends are also in @xmath5 .",
    "@xmath28 is expressed as the vertex sequence @xmath31 .",
    "then we consider four cases :    case 1 : two adjacent vertices of @xmath28 can not be ends of a @xmath28-path , because lemma 2.1 proves that the vertices @xmath32 and @xmath33 are not both in the covering set of @xmath28 . according to lemma 2.1 , @xmath32 and @xmath34 also have no @xmath28-path between them .",
    "therefore this case can be reduced to the lemma 2.1(ii ) and we have @xmath43 .",
    "case 2 : the vertices @xmath32 and @xmath44 can be the ends of a @xmath28-path whose length is exactly three . however , in this case we can pack no independent subgraph isomorphic to @xmath13 , and the path contains no vertex in @xmath5 .",
    "so we have @xmath43 .",
    "case 3 : the vertices @xmath32 and @xmath45 can be the ends of a @xmath28-path whose length are either 3 or 6 . if the length of the path equals to 3 , then no independent subgraph isomorphic to @xmath13 can be packed and we have @xmath43 . if the length of the path equals to 6 , we have @xmath46 . if there are @xmath47 independent @xmath28-paths between @xmath32 and @xmath44",
    "each of which has a length of 6 , then we have @xmath48 .",
    "the only trouble in this case is the situation in which @xmath32 and @xmath45 are the ends of a @xmath28-path @xmath49 , and @xmath44 and @xmath50 are the ends of another @xmath28-path @xmath51 . but this trouble can not happen because of the requirement of the longest cycle @xmath28 .",
    "in this situation the distance between @xmath32 and @xmath50 on the cycle is 9 , but we can find a path @xmath41 between @xmath32 and @xmath50 as @xmath52 whose length @xmath53 . this contradicts the the requirement of the longest cycle .",
    "case 4 : the vertices @xmath32 and @xmath54 can be the ends of a @xmath28-path whose length is @xmath55 where @xmath56 .",
    "we still have @xmath57 in this case",
    ". we may consider whether we can add a path with one end in the @xmath28-path and another end in @xmath28 .",
    "this path , if we can add it , does not have the length more than 3 or else it will contradict the longest cycle . hence , such path does not enlarge the number @xmath18 or @xmath19 .",
    "[ lemma]theorem    the perfect binary tree does not have the erds - psa property .",
    "we illustrate this with the opposing example in 2-connected graph .",
    "theorem 2.2 requires the ends of a @xmath28-path to belong to the covering vertex set .",
    "we consider that the ends of a @xmath28-path are not in the cover .",
    "let @xmath18 denote the largest number of vertex - disjoint subgraphs isomorphic to @xmath13 and @xmath19 denote the smallest number of vertices that cover all subgraphs isomorphic to @xmath13 . to construct a 2-connected graph , we choose @xmath33 and @xmath58 as the ends of @xmath59 independent @xmath28-paths whose length are all three .",
    "both @xmath33 and @xmath58 are not in the covering vertex set",
    ". then we have @xmath60 and @xmath61 .",
    "obviously , @xmath19 can not be bounded by @xmath18 since @xmath59 can be any positive integer .",
    "let @xmath2 and @xmath1 be two graphs . if @xmath1 can be obtained from @xmath2 by contracting some edges of @xmath2 , we call @xmath1 a minor of @xmath2 and write @xmath62 .    according to the theorem about connectivity [ 7 ]",
    ", any 3-connected graph can be finally changed into @xmath22 by a series of contraction . in other words ,",
    "any 3-connected graph can be generated from @xmath22 . in order to find the kind of 3-connected graph into which we can pack @xmath20 trees independently , we need build the elementary structure that contains a subgraph isomorphic to @xmath20 .",
    "the following lemma works on this .",
    "generated from @xmath22,title=\"fig:\",width=529 ] +    [ lemma]lemma    the simplest 3-connected graph that contains a subgraph isomorphic to @xmath20 can be obtained from @xmath22 by a series of anti - contraction .",
    "let @xmath63 be the vertex set of @xmath22 .",
    "the anti - contraction is to divide one vertex into two to form a new graph whose minor is still @xmath22 .",
    "we do three times of anti - contraction as follows :    \\(i ) we divide @xmath64 into two vertices @xmath64 and @xmath65 . to keep @xmath66",
    ", we add the new edges @xmath67 and @xmath68 .",
    "we call this new graph @xmath69 and have @xmath70 .",
    "\\(ii ) we divide @xmath71 into two vertices @xmath71 and @xmath72 . to keep @xmath73",
    ", we add the new edges @xmath74 and @xmath75 .",
    "we call this new graph @xmath76 and have @xmath77 .",
    "\\(iii ) we divide @xmath78 into two vertices @xmath78 and @xmath79 . to keep @xmath80",
    ", we add the new edges @xmath81 , @xmath82 .",
    "we call this new graph @xmath83 as show in figure 1 and have @xmath84 .    to make the structure as simple as possible , we ensure the number of vertices of degree 3 as many as possible after doing the anti - contraction . in this simplest graph , we can find several subgraphs isomorphic to @xmath20 . for example , let @xmath64 be the root , then @xmath85 and @xmath65 are the offsprings of @xmath64 , @xmath79 and @xmath72 are offsprings of @xmath85 , and @xmath78 and @xmath71 are the offsprings of @xmath65 .",
    "[ lemma]lemma    let @xmath2 be a 3-connected graph with @xmath86 and @xmath16 be a positive integer .",
    "then @xmath2 can be generated from @xmath83 so that independent subgraphs isomorphic to @xmath20 can be packed into @xmath2 .",
    "@xmath2 can be generated from @xmath83 after @xmath29 steps . in step",
    "@xmath87 ( @xmath88 ) , we add a component to graph @xmath89 and get @xmath90 . the component is a graph isomorphic to @xmath83 .",
    "let @xmath91 be the vertex set of a subgraph @xmath92 contained in @xmath89 .",
    "@xmath92 is isomorphic to @xmath83 .",
    "let @xmath93 be the vertex of @xmath94 isomorphic to @xmath83 .",
    "then we have @xmath95 .",
    "we add new edge set @xmath96 to @xmath97 and get @xmath98 .",
    ", title=\"fig:\",width=340 ] +    [ lemma]theorem    in the 3-connected graph @xmath99 , the largest number @xmath18 of vertex - disjoint subgraphs isomorphic to @xmath20 is equal to the smallest number @xmath19 of vertices that cover all subgraphs isomorphic to @xmath20 .",
    "consider the case in the figure 2 . according to lemma 2.4 and lemma 2.5 , we can pack two vertex - disjoint perfect binary trees @xmath100 and @xmath101 into the graph where    @xmath102",
    "@xmath103    @xmath104    @xmath105    in figure 2 all the subgraphs isomorphic to @xmath20 come from two parts : ( i)the subgraphs isomorphic to @xmath83 contains several subgraphs isomorphic to @xmath20 ; ( ii)because the edge set    @xmath106 exists in the graph , the tree that we pack may contain vertices from different subgraphs isomorphic to @xmath83 .",
    "for example , the tree @xmath107 could be    @xmath108    @xmath109 .    these trees make it difficult to decide the number @xmath19 .",
    "but there are two special vertices in the graph .",
    "a 7-order perfect binary tree has three levels .",
    "no matter which subgraph is packed , the vertex @xmath110 or @xmath111 must be at the second level ( between the root level and leaf level ) because of their degree @xmath112 larger than other vertices .",
    "if we choose @xmath110 and @xmath111 as the covering vertices , they can cover all the subgraphs isomorphic to @xmath20 .",
    "hence , we have @xmath57 .      [ lemma]proposition    in the 3-connected graph @xmath99 , the largest number @xmath18 of vertex - disjoint subgraphs isomorphic to @xmath20 is equal to the smallest number @xmath19 of vertices that cover all subgraphs isomorphic to @xmath20 .    the @xmath6-connected graph that contains a subgraph isomorphic to @xmath9",
    "can be generated from @xmath23 by doing the anti - contraction successively .",
    "suppose we get the elementary structure @xmath1 , and we add the graph @xmath113 isomorphic to @xmath1 as a component to the new graph @xmath114 .",
    "then we can add a edge between the corresponding vertices of the two components .",
    "the number of edges we add is @xmath115 and ensure that new graph is still @xmath6-connected . in this new graph , we can also find two vertices respectively in each component .",
    "the two vertices have the degree larger than other vertices .",
    "they must be at the second level of a perfect binary tree .",
    "so the two vertices can cover all the subgraphs isomorphic to @xmath9 .",
    "[ section ]      according to [ 6 ] , matching problem is np - complete .",
    "matching problem is to find largest number of vertex - disjoint edges in an arbitrary graph .",
    "suppose we have an algorithm @xmath116 to deal with the problem on packing @xmath13 into an arbitrary graph @xmath2 .",
    "we change @xmath2 into its line graph @xmath7 whose",
    "one vertex represents a edge of @xmath2 and one edge represent that two edges are incident with a same vertex of @xmath2 . by using the algorithm @xmath116 ,",
    "if we find in @xmath2 a independent subgraph isomorphic to @xmath13 , then we can find an independent edge in @xmath7 .",
    "therefore , we can use @xmath116 to deal with the matching problem , and according to [ 8][9 ] , it means that packing @xmath13 into an arbitrary graph is harder than the matching problem .",
    "let @xmath116 be the algorithm to deal with the problem on packing @xmath13 into an arbitrary graph .",
    "suppose we have an algorithm @xmath117 to deal with the problem on packing @xmath20 into an arbitrary graph .",
    "we regard each structure of one vertex and its two incident edges of @xmath2 as a vertex of @xmath7 .",
    "an edge of @xmath7 represents that one edge of the structure in @xmath2 is incident with the vertex of another structure in @xmath2 . by using the algorithm @xmath117 ,",
    "if we find in @xmath2 a independent subgraph isomorphic to @xmath20 , then we can find in @xmath7 an independent subgraphs isomorphic to @xmath13 .",
    "therefore we can use @xmath117 to deal with the problem on packing @xmath13 into an arbitrary graph and @xmath117 is harder than @xmath116 . since @xmath116 is np - complete , @xmath117 is np - hard .    in order to apply the packing in the communication network , we design distributed algorithms .",
    "a vertex of a graph represents a network node such as a router in the internet .",
    "the edge between two vertices represents the connection or link between two nodes .",
    "each node maintains a routing table .",
    "according to properties of connectivity of arbitrary graph [ 2 ] , the graph can be constructed with several blocks and the single path between every two blocks .",
    "thus , before packing we need first detect all the blocks of the graph .",
    "let @xmath118 be an arbitrary graph with @xmath119 and @xmath120 .",
    "let @xmath121 be the routing table of @xmath122 and @xmath123 be the degree of @xmath122 .",
    "@xmath121 recorded at most @xmath123 sequences of vertices each of which represent a independent path to other vertices .",
    "let the set @xmath124 be the neighbors of @xmath122 , and @xmath125 be the possible independent paths recorded in @xmath121 .",
    "let @xmath126 be the possible blocks in graph @xmath2 , @xmath127 be the path between @xmath128 and @xmath129 , and vertices @xmath130 and @xmath131 be any two different vertices of @xmath2 .",
    "the block detection algorithm is as below :          1 .",
    "every vertex @xmath122 experiences at most @xmath134 steps to record the possible independent paths @xmath125 in its routing table . in each step , there are two actions : refreshing and broadcasting . during step 1 ,",
    "@xmath122 records @xmath123 paths to other vertices at most 1-hop distance away , and broadcasts @xmath121 to @xmath124 . during step 2 , @xmath122 receives @xmath135 , refreshes @xmath121 to be @xmath123 paths to other vertices at most 2-hop distance away , and broadcast new @xmath121 to to @xmath124 . during step @xmath136 ( @xmath137 ) , @xmath122 receives new tables from its neighbors , refreshes @xmath121 to be @xmath138 ( @xmath139 ) paths to other vertices at most @xmath136-hop distance away by deleting the path that has more than one joint vertices with another path ( the only joint vertex , if it exists , must be a end of a recorded path ) .",
    "2 .   compute the number of independent paths between two different vertices @xmath130 and @xmath131 : search @xmath140 and find if @xmath131 appears in @xmath140 and how many times it appears .",
    "there are @xmath138 ( @xmath141 ) paths in @xmath140 .",
    "after @xmath138 times of search , the number @xmath142 of independent paths can be obtained .",
    "3 .   for @xmath143 and @xmath144 ,",
    "if @xmath145 , undo ; else if @xmath146 and @xmath147 and @xmath148 , undo ; else if @xmath146 and @xmath149 and @xmath150 , then put @xmath130 into @xmath151 ; else if @xmath146 and @xmath149 and @xmath152 , then put @xmath130 into @xmath151 and put @xmath131 into @xmath153 ; else if @xmath154 , then put both @xmath130 and @xmath131 into @xmath151 ; else if @xmath146 and @xmath155 , then @xmath130 and @xmath131 are both on the path between @xmath128 and @xmath129 and put @xmath130 and @xmath131 into @xmath156 .",
    "4 .   end .",
    "complexity analysis : the algorithmic executing time is consumed by two processes : ( i)each vertex experience at most @xmath134 steps to get its final routing table and the whole network experience at most @xmath134 steps because the vertices work independently at same time ; ( ii)for every vertex couple of @xmath130 and @xmath131 , @xmath130 has to do at most @xmath157 ( @xmath158 ) times of search and there are total @xmath159 couples .",
    "so , we have @xmath160 and the algorithm complexity is @xmath24 .          1 .",
    "run algorithm 3.3 to do the block detection .",
    "2 .   find the longest cycle in each block : ( i)choose @xmath161 ( @xmath162 , because the worst case is that a block contains all @xmath134 vertices ) vertices as the beginning vertices to form a cycle ; ( ii)from the beginning vertex @xmath130 , the longest cycle @xmath163 can be obtained by using the distributed algorithm to find longest - distance between any two vertices ; ( iii)cancel the vertices on @xmath163 whose degree are equal to 2 ; choose next beginning vertex @xmath131 from the remaining vertices on @xmath163 and do the longest cycle @xmath164search again ; ( iv)if @xmath165 , then cancel @xmath130 , or else cancel @xmath131 .",
    "3 .   pack @xmath13 into the longest cycle @xmath166 in block @xmath167 .",
    "let @xmath41 be a @xmath166-path .",
    "if @xmath168 , then pack @xmath13 into @xmath41 ; else undo .",
    "if @xmath169 , then pack @xmath13 into @xmath133 ; else undo .",
    "complexity analysis : algorithm 3.3 has the complexity of @xmath24 .",
    "it takes the complexity of @xmath24 to do the longest cycle search . in the worst case",
    ", a block contains all @xmath134 vertices each of which has a degree larger than 2 .",
    "we need @xmath159 times of cycle length comparison .",
    "so , algorithm 3.4 has the complexity of @xmath24 .          1 .",
    "run algorithm 3.3 to do the block detection .",
    "2 .   in each block , find vertex - disjoint subgraphs isomorphic to @xmath22 and judge whether the subgraphs isomorphic to @xmath83 can be constructed by searching the neighbors of the subgraphs isomorphic to @xmath22 .",
    "pack @xmath20 into the subgraphs isomorphic to @xmath83 .",
    "4 .   end .",
    "this work is supported by the national high - tech research and development program of china ( 863 ) under grant no .",
    "2011aa010701 , and partially supported by the national basic research program of china ( 973 program ) under grant 2013cb329100 and 2013cb329102 ."
  ],
  "abstract_text": [
    "<S> let @xmath0 and @xmath1 be two graphs . packing problem is to find in @xmath2 the largest number of independent subgraphs each of which is isomorphic to @xmath1 . </S>",
    "<S> let @xmath3 . </S>",
    "<S> if the graph @xmath4 has no subgraph isomorphic to @xmath1 , @xmath5 is a cover of @xmath2 . </S>",
    "<S> covering problem is to find the smallest set @xmath5 . </S>",
    "<S> the vertex - disjoint tree packing was not sufficiently discussed in literature but has its applications in data encryption and in communication networks such as multi - cast routing protocol design . in this paper </S>",
    "<S> , we give the kind of @xmath6-connected graph @xmath7 into which we can pack independently the subgraphs that are each isomorphic to the @xmath8-order perfect binary tree @xmath9 . </S>",
    "<S> we prove that in @xmath7 the largest number of vertex - disjoint subgraphs isomorphic to @xmath9 is equal to the smallest number of vertices that cover all subgraphs isomorphic to @xmath9 . </S>",
    "<S> then , we propose that @xmath9 does not have the _ erds - psa _ property . </S>",
    "<S> we also prove that the @xmath9 packing problem in an arbitrary graph is np - hard , and propose the distributed approximation algorithms .    </S>",
    "<S> packing , covering , perfect binary tree , vertex - disjoint </S>"
  ]
}