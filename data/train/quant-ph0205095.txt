{
  "article_text": [
    "since shor discovered a polynomial time algorithm for factorization on a quantum computer  @xcite , a lot of effort has been directed towards building a working quantum computer . despite all these efforts , it is still extremely difficult to control even a few qubits .",
    "it is thus of great interest to study exactly how few qubits are needed to factor an @xmath0-bit number .",
    "quantum factorization consists of classical preprocessing , a quantum algorithm for order - finding and classical postprocessing  @xcite ( fig .",
    "[ circuit ] ) . we will concentrate on the quantum part of factorization and consider classical parts as being free as long as they are computable in polynomial time .",
    "the only use of quantum computation in shor s algorithm is to find the order of @xmath4 modulo @xmath5 , where @xmath5 is an @xmath0-bit integer that we want to factor .",
    "the order @xmath6 of @xmath4 modulo @xmath5 is the least positive integer such that @xmath7mod @xmath8 .    for completeness",
    ", we now give the full algorithm for factoring @xmath5 as given in  @xcite :    1 .   if @xmath5 is even , return the factor 2 .",
    "classically determine if @xmath9 for @xmath10 and @xmath11 and if so return the factor @xmath12 ( this can be done in polynomial time ) .",
    "3 .   choose a random number @xmath4 such that @xmath13 .",
    "using euclid s algorithm , determine if gcd(@xmath14)@xmath15 and if so , return the factor gcd(@xmath14 ) .",
    "4 .   use the order - finding quantum algorithm to find the order @xmath6 of @xmath4 modulo @xmath5 .",
    "if @xmath6 is odd or @xmath6 is even but @xmath16mod @xmath8 , then go to step ( iii ) . otherwise , compute gcd(@xmath17 ) and gcd(@xmath18 ) . test to see if one of these is a non - trivial factor of @xmath5 , and return the factor if so .",
    "it can be shown that with probability at least one half , @xmath6 will be even and @xmath19mod @xmath8  @xcite . the quantum part of the algorithm ( step 4 ) is known to be computable in polynomial time on a quantum computer .",
    "using classical techniques , it is straigthforward to build the order - finding circuit ( fig .",
    "[ circuit ] ) using a polynomial number of elementary gates and a linear number of qubits  @xcite .",
    "because the depth of the circuit is related to its running time , it is desirable to minimize this depth , and much progress has been made in that direction  @xcite .",
    "we propose to take the problem from the other side : by how much can the number of qubits be reduced for factorization in polynomial time ? answering this question would give insights on the size of a quantum computer useful for factorization .",
    "we thus introduce a new order - finding circuit focused on reducing the number of qubits while still using only a polynomial number of elementary quantum gates .",
    "we also somewhat try to minimize the depth of the circuit , but very little parallelization is available since we avoid using any unnecessary qubit .",
    "the circuit for factorization that will be discussed here was inspired in part by a circuit from vedral , barenco and ekert  @xcite . to reduce the number of qubits",
    ", we use a variant of a quantum addition algorithm described by draper  @xcite ( fig .",
    "[ draperadd ] ) .",
    "other techniques used to reduce the number of qubits are the hardwiring of classical values and the sequential computation of the fourier transform .",
    "the quantum addition of figure  [ draperadd ] takes as input @xmath0 qubits representing a number @xmath4 , and @xmath0 more qubits containing the quantum fourier transform of an other number @xmath20 , denoted by @xmath21 . after the addition",
    ", the first register keeps the same value @xmath4 but the bottom register now contains the quantum fourier transform of @xmath22mod  @xmath23 , denoted by @xmath24 .",
    "adding together two quantum registers is , however , more than we ask for .",
    "we are trying to find the period of the function @xmath25mod  @xmath5 where @xmath4 is a classical random number smaller than @xmath5 .",
    "since @xmath4 is classical , we only need to be able to add a classical value to a quantum register .",
    "we can thus change the qubits representing @xmath4 in figure  [ draperadd ] to classical bits .",
    "the controlled gates are then classically controlled , and since we know what @xmath4 is beforehand , we might as well precompute the product of all gates on each single qubit and apply only one gate for every single qubit . these are one - qubit gates , which also makes them easier to implement .",
    "since the addition takes place in the fourier space , we will call this circuit the @xmath26 gate where @xmath4 is the classical value added to the quantum register ( fig .  [ phiadd ] ) . notice the thick black bar on the right , used to distinguish the gate from its unitary inverse . in order to prevent overflow",
    ", we need @xmath27 qubits for the quantum register instead of @xmath0 , so that @xmath21 is effectively the qft of an ( @xmath27)-qubit register containing a @xmath0-bit number ( thus the most significant qubit before the qft preceding the addition is always @xmath28 ) .",
    "if we apply the unitary inverse of the @xmath26 gate with input @xmath21 , we get either @xmath29 if @xmath30 , or @xmath31 if @xmath32 .",
    "thus if @xmath32 , the most significant qubit of the result is always @xmath33 , whereas it is always @xmath28 if @xmath34 .",
    "this reverse @xmath26 gate can be useful for subtraction and comparison purposes ( fig .",
    "[ phiminus ] ) and we use a black bar on the left to distinguish it from the regular gate . the unitary inverse of a circuit is obtained by applying the unitary inverse of each elementary gate in reverse order .",
    "now that we have a @xmath26 gate , we can use it to build a modular adder gate ( fig .",
    "[ ccaddmod ] ) . for future use , two control qubits",
    "are included in the circuit .",
    "for the modular adder gate , we need to compute @xmath35 and subtract @xmath5 if @xmath36 . however , it is not so easy to implement this operation in a reversible way .",
    "the input to the @xmath37 gate is @xmath21 with @xmath38 , and the classical number @xmath4 that we add is also smaller than @xmath5 .",
    "we begin by applying a @xmath26 gate to the register @xmath21 .",
    "the quantum register now contains @xmath24 with no overflow because we were careful enough to put an extra qubit in state @xmath28 along with the value @xmath20 before applying the qft .",
    "we next run a reverse @xmath39 to get @xmath40 .",
    "if @xmath41 , we did not have to subtract @xmath5 but now we can determine if @xmath41 by checking the most significant bit of @xmath42",
    ". however , to access this most significant bit we need to inverse the qft on the whole register containing @xmath40 .",
    "we can then use this qubit as the controlling qubit of a controlled - not gate acting on an ancillary qubit .",
    "it is then possible to reapply the qft and use this ancilla as a control qubit for a @xmath39 controlled gate , so that if @xmath41 we add back the value @xmath5 that we subtracted earlier .",
    "we now have @xmath43mod @xmath8 in the register , and we are done except for the ancilla which is now a junk bit .",
    "we have to restore it to @xmath28 somehow , otherwise the computation will not be clean and the algorithm will not workmod  @xmath5 but the period of the garbage bits can be something else . ] .",
    "restoring the ancilla to @xmath28 is no easy task if we do not want to waste qubits .",
    "we can still do it by using the identity :    @xmath44    hence , we only have to compare @xmath45mod  @xmath5 with the value @xmath4 using essentially the same trick as before .",
    "we run an inverse @xmath26 followed by an inverse qft to get the most significant qubit of @xmath22mod @xmath46 .",
    "this qubit is @xmath28 if @xmath22mod @xmath47 .",
    "we apply a not gate on this qubit and use it as the controlling qubit of a controlled - not gate targeting the ancilla .",
    "the ancilla is thus restored to @xmath28 and we can apply a not gate again on the control wire , followed by a qft and a @xmath26 gate on the quantum register . after this , we have a clean computation of @xmath22mod  @xmath5 in the fourier space .",
    "again , what we need exactly is a doubly controlled version of the @xmath37 gate . in order to reduce the complexity of the circuit",
    ", we will doubly control only the @xmath26 gates instead of all the gates ( fig .",
    "[ ccaddmod ] ) .",
    "if the @xmath26 gates are not performed , it is easy to verify that the rest of the circuit implements the identity on all qubits because @xmath38 .",
    "the next step is to use the doubly controlled @xmath37 gate to build a controlled multiplier gate that we will call @xmath48 ( fig .",
    "[ cmul ] ) .",
    "this gate takes three inputs , @xmath49 , and its output depends on the qubit @xmath50 . if @xmath51 , the output is @xmath52 .",
    "if @xmath53 , then the input is unchanged and stays @xmath49 .",
    "this gate is very straightforward to implement using doubly controlled @xmath37 gates .",
    "we use the identity :    @xmath54    thus we only need @xmath0 successive doubly controlled modular adder gates , each of them adding a different value @xmath55 with @xmath56 to get the @xmath48 gate .",
    "we now have a controlled gate that takes @xmath57 to @xmath58 .",
    "what we would need instead is a controlled gate that takes @xmath59 to @xmath60 .",
    "this can however be obtained by a clever trick from reversible computing that uses two controlled multiplication gates ( fig  [ ctrlu ] ) .",
    "we first apply the @xmath48 gate to @xmath61 .",
    "we follow with a swap between the two registers if the qubit @xmath51 ( that is effectively a controlled - swap on the registers ) .",
    "we only need to control - swap @xmath0 qubits , not @xmath27 .",
    "indeed , the most significant qubit of @xmath62 will always be 0 since we were careful to include one extra qubit to store the overflow in the @xmath26 gate .",
    "we then finish with the inverse of a @xmath63 circuit .",
    "the value @xmath64 , which is the inverse of @xmath4 modulo @xmath5 , is computable classically in polynomial time using euclid s algorithm and it always exists since gcd@xmath65 .",
    "the fact that we apply the inverse of the circuit means that the circuit effectively takes @xmath49 to @xmath66 .",
    "the resulting gate will be called @xmath67-@xmath68 for controlled-@xmath68 .",
    "it does nothing if @xmath53 but if @xmath69 , then the two registers take the following values :    @xmath70    since the bottom register returns to @xmath28 after the computation , we can consider this extra register as being part of the @xmath67-@xmath68 gate , thus the gate effectively takes @xmath59 to @xmath60 .",
    "this is exactly the gate we need to run the quantum order - finding circuit ( fig  [ circuit ] ) . of course",
    ", we do nt need to apply @xmath67-@xmath68 @xmath0 times to get @xmath71-@xmath72 because we can directly run @xmath67-@xmath73 ( where @xmath74 in computed classically ) which is the same as @xmath71-@xmath72 since :    @xmath75          an advantage of using the @xmath67-@xmath76 gates for shor s algorithm is the fact that we do nt really need the total @xmath77 controlling qubits .",
    "in fact , it can be shown that only one controlling qubit is sufficient  @xcite .",
    "this is possible because the controlled-@xmath78 gates all commute and the inverse qft can be applied semi - classically . indeed , we can get all the bits of the answer sequentially as in figure  [ trick ] .",
    "each measured bit dictates which unitary transformation we have to apply after every controlled-@xmath78 step before the next measurement .",
    "this simulates the inverse qft followed by a measurement on all qubits as in figure  [ circuit ] .",
    "we save an important number of qubits this way , and in fact we need only a total of @xmath1 qubits to factor an @xmath0-bit number as we will show in the complexity analysis section .",
    "the implementation of the exact @xmath79 on @xmath0 qubits requires @xmath80 operations  @xcite ( fig .  [ qft ] ) .",
    "however , in physical implementations , there will always be a threshold for the precision of the gates .",
    "since many phase shifts will be almost negligible , we will in practice ignore the ones with @xmath81 greater than a certain threshold @xmath82 .",
    "this approximate @xmath79 is in fact very close to the exact @xmath79 even with @xmath82 logarithmic in @xmath0 .",
    "in fact , it has been shown  @xcite that the error introduced by ignoring all gates with @xmath83 is proportional to @xmath84.we can thus choose @xmath85 .",
    "the implementation of the approximate @xmath79 on @xmath0 qubits requires @xmath86 gates .",
    "there seems to be no obvious way to reduce the depth of either the exact @xmath79 and the approximate @xmath79 on @xmath0 qubits below @xmath87 without using extra qubits  @xcite .",
    "the depth of the qft on @xmath27 qubits is thus @xmath87 with the little parallelization available without extra qubits .",
    "the controlled - swap on one qubit is very easy to implement ( fig .",
    "[ cswap ] ) . only two controlled - not and one toffoli are needed to perform the swap on two qubits controlled by a third .",
    "thus , @xmath87 gates are needed to control - swap @xmath0 qubits , that is , swap @xmath0 qubits with @xmath0 others with one control qubit .",
    "we now analyze the complexity of the given circuit for performing factorization of an @xmath0-bit number @xmath5 .",
    "the analysis keeps track of the number of qubits , the order of the number of gates and the order of the depth of the circuit . for the depth of the circuit",
    ", we consider that it will be possible to apply simultaneously different quantum gates that act on different qubits of the quantum computer .",
    "however , we consider impossible to have one qubit controlling many operations in the same step",
    ". the circuit uses only single qubit gates , up to doubly controlled conditionnal phase shifts and up to doubly controlled not gates .",
    "these gates can be implemented using a constant number of single qubit gates and controlled - nots  @xcite , so they can all be considered as elementary quantum gates .",
    "the @xmath26 circuit ( fig .  [ phiadd ] ) , where @xmath4 is a classical value , requires @xmath27 qubits and @xmath87 single qubit gates in constant depth .",
    "the number of qubits is @xmath27 because we need an extra qubit to prevent overflows .",
    "when a control qubit is added to the circuit , the depth becomes @xmath87 since the conditional phase shifts have to be done sequentially .",
    "indeed , the control qubit has to control each phase shift one at a time .",
    "the doubly controlled @xmath37 circuit ( fig .  [ ccaddmod ] ) requires @xmath88 qubits .",
    "it also requires @xmath89 gates , but has a depth of only @xmath87 regardless of @xmath82 because the qfts can be somewhat parallelized .",
    "the @xmath48 circuit is only @xmath0 doubly controlled @xmath37 circuits .",
    "it thus takes @xmath1 qubits , @xmath90 gates and a depth of @xmath80 to implement the @xmath48 circuit .",
    "two of these circuits along with the controlled - swap are needed for the @xmath67-@xmath68 circuit .",
    "the controlled - swap on @xmath0 qubits requires only @xmath87 gates and depth , so the @xmath67-@xmath68 circuit requires @xmath1 qubits , @xmath90 gates and a depth of @xmath80 again .    for the whole order - finding circuit , that is , the whole quantum part of shor s algorithm , we need @xmath77 of these @xmath67-@xmath68 circuits .",
    "the quantum resources needed are thus @xmath1 qubits , @xmath91 gates and a depth of @xmath3 .",
    "if we decide to use the exact @xmath79 in the additions , then we would have @xmath92 . as we argued earlier ,",
    "this would not be clever because the implementation is sure to have hardware errors anyway .",
    "we thus should use the approximate @xmath79 with @xmath93 ) , so that the number of gates is in @xmath94 for any @xmath95 polynomial in @xmath96 .",
    "this result of @xmath1 qubits is slightly better than previous circuits for factorization .",
    "vedral , barenco and ekert published a circuit of @xmath97 qubits and @xmath3 elementary gates for modular exponentiation  @xcite .",
    "it is mentionned that this number can be easily reduced to @xmath98 qubits with basic optimization and further reduced to @xmath99 if unbounded toffoli gates ( @xmath0-controlled nots ) are available .",
    "beckman , chan , devabhaktoni and preskill provided an extended analysis  @xcite of modular exponentiation , with a circuit of @xmath100 qubits using elementary gates and @xmath101 if unbounded toffoli gates are available .",
    "zalka also described a method for factorization with @xmath102 qubits using only elementary gates  @xcite .",
    "the availability of unbounded toffoli gates will of course depend on the physical implementation of the quantum computer , but it is assumed throughout our design and analysis that such gates can not be considered elementary . for that matter , if we do not restrict the type and size of the quantum gates in any way , order - finding can be achieved with @xmath27 qubits by directly using controlled multiplication gates  @xcite .    of the @xmath1 qubits used in the circuit provided here , one is used as an ancilla for modular addition , one is used to prevent addition overflows and @xmath0 are used as an ancillary register to get modular multiplication from successive additions .",
    "an order - finding circuit using elementary gates and less than @xmath103 qubits is not ruled out yet , but it seems that a different method would have to be used for modular multiplication to get such a circuit .",
    "fifteen is the smallest number on which shor s algorithm can be applied .",
    "the circuit for factorization of @xmath104 uses eleven qubits as given here .",
    "however , the classical computation performed to build it gives a lot of information on the order of the number @xmath4 .",
    "indeed , for any @xmath105 , the order of @xmath4 is either two or four .",
    "most of the multiplications in the circuit are simply the identity and can be removed , which amounts to many unused qubits .",
    "the number 15 was factored using nmr with seven qubits in an impressive display of quantum control by vandersypen , steffen , breyta , yannoni , sherwood and chuang  @xcite .",
    "the importance of reducing the number of qubits versus reducing the depth of a quantum computation is not clear as quantum computers of useful size are not yet available .",
    "we have to keep in mind that error correction will most probably have to be used on quantum computers , which will create an overhead in the number of qubits used  @xcite .",
    "it is however sensible to minimize the number of qubits before applying error correction if qubits are hard to come by .",
    "putting together several tricks , we have developed a circuit for the quantum part of the factorization algorithm , that is , the order - finding algorithm , while focusing on reducing the number of qubits .",
    "the number of qubits needed is @xmath1 and the depth is @xmath3 .",
    "this circuit uses slightly less qubits than those previously known if restricted to elementary gates .",
    "it is also completely general and does not rely on any properties of the number to be factored .    given the values @xmath4 and @xmath5 , this circuit gives the order @xmath6 of @xmath4 modulo @xmath5 with good probability .",
    "many runs of this algorithm may be needed to factor a number .",
    "also , the randomly chosen value @xmath4 is hardwired in the circuit and there is a probability ( about one half ) that it will be necessary to choose a new value @xmath4 and run a new order - finding algorithm on it .",
    "this is not a problem if the quantum computer is a physical device where the gates are interactions controlled by a classical computer such as laser pulses on trapped ions , nmr and most implementation proposals .",
    "indeed , the circuit can easily be classically computed .",
    "a quantum computer consisting of a physical system controlled by a classical computer is the most conceivable option at this point .",
    "the author is very grateful to michel arsenault for many helpful comments and corrections , and would also like to thank jos manuel fernandez , christof zalka and anne broadbent .",
    "this work was supported in part by cse of canada , and the author acknowledges support from nserc of canada .",
    "r. cleve and j. watrous ( 2000 ) , _ fast parallel circuits for the quantum fourier transform _ , proceedings 41st annual symposium on foundations of computer science ( focs00 ) , pp .",
    "526 - 536 . also on quant - ph/0006004 .",
    "a. barenco , c. bennett , r. cleve , d.p .",
    "divincenzo , n. margolus , p. shor , t. sleator , j.a .",
    "smolin , and h. weifurter ( 1995 ) , _ elementary gates for quantum computation _ , phys .",
    "a , 52 , pp .",
    "3457 - 3467 .",
    "also on quant - ph/9503016 .",
    "vandersypen , m. steffen , g. breyta , c.s .",
    "yannoni , m.h .",
    "sherwood , and i.l .",
    "chuang ( 2001 ) , _ experimental realization of shor s quantum factoring algorithm using magnetic resonance _ , nature , 414 , pp .",
    "883 - 887 ."
  ],
  "abstract_text": [
    "<S> we try to minimize the number of qubits needed to factor an integer of @xmath0 bits using shor s algorithm on a quantum computer . </S>",
    "<S> we introduce a circuit which uses @xmath1 qubits and @xmath2 elementary quantum gates in a depth of @xmath3 to implement the factorization algorithm . </S>",
    "<S> the circuit is computable in polynomial time on a classical computer and is completely general as it does not rely on any property of the number to be factored . </S>"
  ]
}