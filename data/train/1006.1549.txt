{
  "article_text": [
    "quantum information theory aims to harness the quantum nature of information carriers in order to develop more efficient algorithms and more secure communication protocols  @xcite .",
    "unfortunately , counterintuitive laws of quantum mechanics make the development of new quantum information processing procedures highly non - trivial task .",
    "this can be seen as one of the reasons why only few truly quantum algorithms were proposed  @xcite .",
    "the laws of quantum mechanics are in many cases very different from those we know from the classical world .",
    "that is why one needs to seek for the novel methods for describing information processing which involves quantum elements .",
    "to this day several formal models were proposed for the description of quantum computation process  @xcite .",
    "the most popular of them is the quantum circuit model @xcite , which is tightly connected to the physical operations implemented in a laboratory .",
    "it allows to operate with the basic ingredients of quantum information processing ",
    "namely qubits , unitary evolution operators and measurements .",
    "however , it does not provide too much flexibility concerning operations on more sophisticated elements required to develop scalable algorithms and protocols _ eg . _  quantum registers or classical controlling operations .",
    "another model widely used in the study of theoretical aspects of quantum information processing is the quantum turing machine  @xcite .",
    "this model is mainly used in the analysis of quantum complexity problems  @xcite . its main advantage",
    "it that it provides method of comparing efficiency of classical and quantum algorithms .",
    "unfortunately quantum turing machine , in analogy to its classical counterpart , operates on very basic data and thus it can not be easily used to construct quantum algorithms .",
    "both quantum circuit model and quantum turing machine share some serious drawbacks concerning lack of support for high - level programming and very limited flexibility .",
    "these problems were addressed in the recent research in the area of quantum programming languages  @xcite .",
    "quantum programming languages are based on the quantum random access machine ( qram ) model .",
    "qram is equivalent , with respect to its computational power , to the quantum circuit model or quantum turing machine .",
    "however , it has strictly distinguished two parts : quantum and classical .",
    "the quantum part is responsible for performing parts of a algorithm which can not be computed efficient by a classical machine .",
    "the classical part is used to control quantum computation .",
    "this model is used as a basis for most quantum programming languages  @xcite .    among high - level programming languages designed for quantum computers we can distinguish imperative and functional languages . the later",
    "are seen by many researchers as a means of providing robust and scalable methods for developing quantum algorithms  @xcite .",
    "we , however , focus on the imperative paradigm as it provides more straightforward way of implementing high - level quantum programming concepts .",
    "this paper is organized as follows . in section [ sec : qram ] we briefly describe the qram model of quantum computer and introduce the quantum pseudocode , which was designed to describe this model . in section  [ sec : basic ] we introduce high - level programming structures used in quantum programming languages .",
    "these structure are based on the qram model of quantum computer . in section  [ sec : qo ] the implementation of presented concepts is described and ` quantum - octave `  package is presented . in section  [ sec : apps ] implementation of quantum algorithms using ` quantum - octave `  package is presented .",
    "also the analysis of quantum errors is provided in the case of quantum search algorithm .",
    "finally section  [ sec : summary ] summarize the presented work and provides reader with some concluding remarks .",
    "quantum random access machine is interesting for us since it provides convenient model for developing quantum programming languages .",
    "however , these languages and basic concepts used to develop them are our main area of interest .",
    "for this reason here we provide only the very basic introduction to the qram model . detailed description of this model is given in @xcite and @xcite together with the description of hybrid architecture used in quantum programming .",
    "as in many situations in quantum information science , the qram models is based on the concepts developed to describe classical computational process  in this case on the random access machine ( ram ) model .",
    "the classical model of random access machine ( ram ) is the example of more general register machines @xcite .",
    "the random access machine consists of an unbounded sequence of memory registers and finite number of arithmetic registers .",
    "each register may hold an arbitrary integer number .",
    "the programme for the ram is a finite sequence of instructions @xmath0 . at each step of execution register",
    "@xmath1 holds an integer @xmath2 and the machine executes instruction @xmath3 , where @xmath4 is the value of the programme counter .",
    "arithmetic operations are allowed to compute the address of a memory register .    despite the difference in the construction between turing machine and ram",
    ", it can be easily shown that turing machine can simulate any ram machine with polynomial slow - down only  @xcite .",
    "the main advantage of the ram models is its resemblance with the real - world computers .",
    "quantum random access machine ( qram ) model is build as an extension of the classical ram model .",
    "its main goal is to provide the ability to exploit quantum resources .",
    "moreover , it can be used to perform any kind of classical computation .",
    "the qram allows us to control operations performed on quantum registers and provides the set of instructions for defining them .",
    "schematic presentation of such architecture is provided in figure  [ fig : qram ] .",
    "the quantum part of qram model is used to generate probability distribution .",
    "this is achieved by performing measurement on quantum registers .",
    "the obtained probability distribution has to be analysed using a classical computer .",
    "quantum algorithms are , in most of the cases , described using the mixture of quantum gates , mathematical formulas and classical algorithms . the first attempt to provide a uniform method of describing quantum algorithms",
    "was made in @xcite , where the author introduces a high - level notation based on the notation known from computer science textbooks @xcite .    in @xcite knill",
    "introduced the first formalized language for description of quantum algorithms .",
    "moreover , it was tightly connected with the model of quantum random access machine .    quantum pseudocode proposed by knill @xcite",
    "is based on conventions for classical pseudocode proposed in ( * ? ? ?",
    "* chapter 1 ) .",
    "classical pseudocode was designed to be readable by professional programmers , as well as people who had done a little programming .",
    "quantum pseudocode introduces operations on quantum registers .",
    "it also allows to distinguish between classical and quantum registers . in quantum pseudocode",
    "quantum registers are distinguished with an underline .",
    "they can be introduced by applying quantum operations to classical registers or by calling a subroutine which returns a quantum state . in order to convert a quantum register into a classical register measurement operation",
    "has to be performed .",
    "the example of quantum pseudocode is presented in listing [ lst : qpc - example ] .",
    "it shows the main advantage of qram model over quantum circuits model  the ability to incorporate classical control into the description of quantum algorithm .",
    ".... % { \\bf procedure : } { \\sc fourier}($\\underline{a},d$)\\\\ { \\bf input : } a quantum register $ \\underline{a}$ with $ d$ qubits .",
    "qubits are numbered form 0 to $ d-1$.\\\\ { \\bf output : } the amplitudes of $ \\underline{a}$ are fourier transformed over $ \\",
    "\\z_{2^d}$.\\\\ % c : assign value to classical variable $ \\omega \\leftarrow e^{i2\\pi/2^d}$ c : perform sequence of gates for   $ i = d-1 $ to $ i=0 $    for $ j = d-1 $ to $ j = i+1 $    % \\underline{\\bf if}% $ \\underline{a_j}$ % \\underline{\\bf then}% $ \\mathcal{r}_{\\omega^{2^{d - i-1+j}}}(\\underline{a_i})$     c : number of loops executing phase depends on     c : the required accuracy of the procedure    $ \\mathcal{h}(\\underline{a_i})$    c : change the order of qubits for $ j = 0 $ to $ j=\\frac{d}{2}-1 $    $ \\mathcal{swap}(\\underline{a_j},\\underline{a_{d - a - j}})$ ....    operation @xmath5 executes a quantum hadamard gate on a quantum register @xmath6 and @xmath7 performs swap gate between @xmath6 and @xmath8 .",
    "operation @xmath9 executes a quantum gate @xmath10 is defined as @xmath11 on the quantum register @xmath6 .",
    "using conditional construction    ....   % \\underline{\\bf if}% $ \\underline{a_j}$ % \\underline{\\bf then}% $ \\mathcal{r}_{\\phi}(\\underline{a_i})$ ....    it is easy to define controlled phase shift gate .",
    "similar construction exists in qcl quantum programming language  @xcite . in section  [ sec : qo ] we describe implementation of this construction in ` quantum - octave ` .",
    "the measurement of a quantum register can be indicated using an assignment    ....   $ a_j \\leftarrow \\underline{a_j}$. ....      taking into account qram model we can formulate basic requirements which have to be fulfilled by any quantum programming language @xcite .    * * completeness : * language must allow to express any quantum circuit and thus enable the programmer to code every valid quantum programme written as a quantum circuit . * * extensibility : * language must include , as its subset , the language implementing some high level classical computing paradigm .",
    "this is important since some parts of quantum algorithms ( for example shor s algorithm ) require non - trivial classical computation . *",
    "* separability : * quantum and classical parts of the language should be separated .",
    "this allows to execute any classical computation on purely classical machine without using any quantum resources .",
    "* * expressivity : * language has to provide high level elements for facilitating the quantum algorithms coding . * * independence : * the language must be independent from any particular physical implementation of a quantum machine",
    ". it should be possible to compile a given programme for different architectures without introducing any changes in its source code .",
    "quantum memory is a set of qubits indexed by integer numbers .",
    "quantum register is a set of indices pointing to distinct qubits .",
    "we will denote those registers as @xmath12 or in case of single qubits as @xmath13 .",
    "the state of a quantum memory is a quantum state of size equal to the number of qubits . in the case of ` quantum - octave `",
    "we operate on density matrices ( although some operations on state vectors are allowed ) .",
    "we will denote the state of the quantum memory by @xmath14 .    following operations on quantum memory",
    "are allowed :    * allocation of new register of size @xmath15 : @xmath16 where @xmath17 denotes tensor product , @xmath18 the  column vector and @xmath19 the  dual vector .",
    "* deallocation of a register indexed by register @xmath20 : @xmath21 where @xmath22 denotes partial trace of @xmath14 with regard to the subsystem indexed by  @xmath20 .",
    "* unitary evolution @xmath23 of the quantum memory : @xmath24 * application of quantum channel @xmath25 on the quantum memory : @xmath26 * measurement in the computational basis : @xmath27 where @xmath1 enumerates the states of computational basis .    for a solid introduction to quantum computation",
    "the reader may refer to book by nielsen and chuang @xcite , where all the needed notions are explained in detail .    in quantum computation ,",
    "construction of the unitary gate is the essential part of quantum algorithm ( program ) design process .",
    "it is a  difficult task to write a  quantum program using only elementary set of gates _ ie . _",
    "cnot and one qubit rotations .",
    "therefore it is desirable to introduce some techniques that facilitate the process of composition of complex quantum gates .",
    "some of those techniques are presented below .",
    "we will refer to implementation of those techniques in ` quantum - octave `  which is described in details in section  [ sec : qo ] .",
    "given one - qubit unitary gate @xmath28 , quantum register @xmath20 , and size of the gate @xmath29 we can construct composed gate @xmath30 according to the formula : @xmath31      given one - qubit unitary gate @xmath28 , quantum register @xmath32 we call control , and quantum register @xmath33 we call target , and size of the gate @xmath29 we can construct controlled gate @xmath34 according to the formula : @xmath35 we assume that @xmath36 . sometimes we will omit the size parameter  @xmath29 .",
    "one of high - level technique used in quantum programming are quantum conditions  @xcite .",
    "the main idea behind quantum conditions is construction of quantum gates controlled by predicates on control registers .",
    "the if - then - else structure controlled by a quantum variable and acting on a quantum variable was introduced in qcl @xcite .    in figure",
    "[ fig : simple - conditional ] the realisation of this concept is presented .",
    "if qubit @xmath37 is in the state @xmath38 the @xmath39 gate is applied to qubit @xmath40 , otherwise the gate @xmath41 is applied .",
    "we may write this circuit in the following way : @xmath42    c|m.3    .... { } qbit $ q_1 , q_2 $    if ( $ q_1 $ ) then    $ \\mathcal{g}_1(q_2 $ ) else    $ \\mathcal{g}_2(q_2 $ ) ....    &   +    for a  given control register @xmath32 , target register @xmath33 and two quantum gates @xmath39 and @xmath41 , we may define quantum condition in the more general way , namely @xmath43 where @xmath44 denotes the power set .      one may consider the relation between the state of quantum register and the value of the classical variable . by @xmath45_{r}}$ ] we will denote a numerical value of ordered ( in ascending order ) elements of the register @xmath46 in regard to register @xmath20 , for example the value of @xmath47_{\\{2,4,7,9\\}}}$ ] is 10 . by @xmath48",
    "$ ] we will denote the value of the register in order to use it as argument for arithmetic comparison . for example @xmath48<4",
    "$ ] means : `` all those values of @xmath20 that are less than four . ''",
    "code and circuit in figure  [ fig : condition - lt ] show the idea and the implementation of conditional operation controlled by expression ` less than ' operating on classical constant and quantum register .",
    "pseudocode & ` quantum - octave `   +    .... { } qnibble $ r$ qbit $ q_1 , q_2 $    if ( $ r<4 $ ) then    $ \\mathcal{g}_1(q_2)$ else    $ \\mathcal{g}_2(q_1)$ ....    &    .... { } r = newregister(4 ) ; q1=newregister(1 ) ; q2=newregister(1 ) ;    qif ( ...      qrlt(qureg(q1),4 ) , ...",
    "{ g1,qureg(q2 ) } , ...      { g2,qureg(q1 ) } ) ....     +   +   +    in the general case , gate implementing any relation ( marked as @xmath49 ) can be constructed in the following  way : @xmath50\\circledast n}(g_1{r_t})else(g_2{r_t})=&&\\\\ \\nonumber      \\prod_{i\\in\\mathcal{f } } \\left(not_{i}g_{2{r_t|r_c}}not_{i}\\right )       \\prod_{i\\in\\mathcal{t } } \\left(not_{i}g_{1{r_t|r_c}}not_{i}\\right),\\end{aligned}\\ ] ] where sets @xmath51 and @xmath52 are defined as follows : @xmath53_{r_{c}}}\\circledast n\\ } , \\\\ \\mathcal{f}=\\mathcal{p}(r_c)\\setminus\\{x|x\\in \\mathcal{p}(r_{c})\\wedge \\neg({[[x]]_{r_{c}}}\\circledast n)\\}.\\end{aligned}\\ ] ] note that @xmath54    in ` quantum - octave `  standard arithmetic relations @xmath55 are implemented .",
    "we may consider more complicated expression on quantum registers .",
    "for example logical operators and quantum pointers .",
    "logical operators allow to apply an controlled operation to the target register only if a  given logical expression on control registers is true .",
    "a  quantum pointer allows to apply controlled gate on the target register selected by the state of the control register .",
    "the gate that implements logical expression ( denoted here by @xmath56 ) is constructed according to the following equation : @xmath57\\circledast_1 n_1 \\diamond [ r_{c_2}]\\circledast_2 n_2}(g_1{r_t})else(g_2{r_t})= \\nonumber \\\\",
    "= \\prod_{i\\in\\mathcal{f } } \\left(not_{i}g_{2{r_t|r_c}}not_{i}\\right )       \\prod_{i\\in\\mathcal{t } } \\left(not_{i}g_{1{r_t|r_c}}not_{i}\\right),\\end{aligned}\\ ] ] where sets @xmath51 and @xmath52 are defined as follows : @xmath58_{r_{c_1}}}\\circledast_1 n_1 \\diamond { [ [ x_2]]_{r_{c_2}}}\\circledast_2 n_2\\right)\\ } , \\\\",
    "\\mathcal{f}=\\mathcal{p}(r_c)\\setminus\\{x_1\\cup x_2|x_1\\subseteq r_{c_1 } , x_2\\subseteq r_{c_2 } \\\\ \\nonumber \\wedge \\neg \\left({[[x_1]]_{r_{c_1}}}\\circledast_1 n_1 \\diamond { [ [ x_2]]_{r_{c_2}}}\\circledast_2 n_2\\right)\\}\\end{aligned}\\ ] ] and @xmath59 .",
    "an example of quantum conditional gate controlled by logical expression defined on quantum registers is presented in figures  [ fig : condition - and ] and  [ fig : condition - or ] .",
    "pseudocode & ` quantum - octave ` +    .... { } qbit $ q_1 , q_2 , q_3 , q_4 $    if ( $ q_1 $ and $ q_2 $ ) then    $ \\mathcal{g}_1(q_3)$ else    $ \\mathcal{g}_2(q_4)$ ....    &    .... { } q1=newregister(1 ) ; q2=newregister(1 ) ; q3=newregister(1 ) ; q4=newregister(1 ) ;    qif ( ...      qrand ( ...          qreq(qureg(q1),1 ) , ...",
    "qreq(qureg(q2),1 ) ) , ..      { g1,qureg(q3 ) } , ...      { g2,qureg(q4 ) } ) ....     +   +   +     pseudocode & ` quantum - octave ` +    .... { } qbit $ q_1 , q_2 , q_3 , q_4 $    if ( $ q_1 $ or $ q_2 $ ) then    $ \\mathcal{g}_1(q_3)$ else    $ \\mathcal{g}_2(q_4)$ ....    &    .... { } q1=newregister(1 ) ; q2=newregister(1 ) ; q3=newregister(1 ) ; q4=newregister(1 ) ;    qif ( ...      qror ( ...",
    "qreq(qureg(q1),1 ) , ...          qreq(qureg(q2),1 ) ) , ..      { g1,qureg(q3 ) } , ...      { g2,qureg(q4 ) } ) ....     +   +   +      in analogy to the concept of pointers and indirect addressing in classical programming , one may introduce quantum pointers .",
    "the idea is to use control register to control on which of the target registers an operation should be applied .",
    "let us assume that one has the @xmath15-bit control register and a set of @xmath60-bit target registers .",
    "the control register stores the address of target register to which given unitary operation shall be applied . in order to visualise the use of a  quantum pointer",
    "an example is shown in figure  [ fig : quantum - pointer ] .",
    "pseudocode & ` quantum - octave ` +    .... { } qreg[2 ] $ q_1 $ qnibble $ q_2 $    if(*$q_1 $ ) then    $ \\mathcal{g}(q_2)$ ....    &    .... { } q1=newregister(2 ) ; q2=newregister(4 ) ;    qpointer(g , qureg(q1),qureg(q2 ) ) ....     +   +   +    formally , a quantum pointer controlled by register @xmath32 with target @xmath33 is constructed in the following way : @xmath61})=",
    "\\prod_{i\\in\\mathcal{p}(r_c ) } \\left(not_{r_c\\setminus i}g_{{{[[i]]_{r_c}}|r_c}}not_{r_c\\setminus i}\\right).\\end{aligned}\\ ] ]",
    "package ` quantum - octave ` @xcite provides a quantum programming , simulation and analysis language implemented as a  library of functions for gnu octave  @xcite .",
    "gnu octave is computer algebra system ( cas ) and high level programming language designed primarily to perform numerical calculations . the basic data structure in octave is a matrix ( integer , real or complex ) , therefore it is a natural choice as a basis for the implementation of quantum programming language .",
    "gnu octave supports sparse matrices and distributed computing in shared and distributed memory models .",
    "gnu octave is a very flexible and easily extendible tool .",
    "it is also free software and it can be used in a wide range of operating systems .      the main goal of the design of ` quantum - octave `  is to provide a flexible and useful tool for simulation of quantum information processing .",
    "therefore it is based on gnu octave a high - level scientific programming language .",
    "this allows for a seamless integration of very efficient matrix operations and numerical procedures with the library of specialized functions provided by ` quantum - octave ` . as",
    "gnu octave is to large extent compatible with matlab , provided functions can be also used to simulate and analyse quantum algorithms in matlab .",
    "one of the unique features of ` quantum - octave `  is its ability to operate on both pure and mixed quantum states .",
    "it allows to perform unitary as well as non - unitary evolution represented by quantum channels .",
    "quantum gates can be constructed by the user in various ways : by calling provided subroutines , by building their own subroutines , by using quantum control structures .",
    "additionally the user can build and use quantum channels or use those already provided .",
    "most of the ` quantum - octave `  functions operate on quantum registers and therefore the quantum operations build with their use are re - allocable .    a good illustration of those features is presented in the following listing  [ lst : qft : qo ] that contains the implementation of quantum fourier transform in ` quantum - octave ` .",
    "it can be compared to pseudo code version of the same procedure listed in listing  [ lst : qpc - example ] .",
    ".... { } function ret = dft(gatesize )    n = gatesize ;    cir = id(n ) ;    for i=[1:n ]      for j=[1:i-1 ]        cir = circuit(cir , cphase(pi/(2^(i - j)),j , i , gatesize ) ) ;      endfor      cir = circuit(cir , productgate(h , i , gatesize ) ) ;    endfor      ret = cir = circuit(cir , flip(n ) ) ; endfunction ....    package ` quantum - octave ` can operate on sparse and full matrices depending on users choice .",
    "sparse matrices need much less memory to store but operations on them may be slower .",
    "full matrices tend to consume huge memory space , but operations on them are generally faster . in case of full matrices",
    "it should be possible to operate on states of size up to ten qubits on a  contemporary workstation .",
    "sparse matrices should allow to simulate the quantum systems of up to 20 qubits .    although ` quantum - octave `  is not , strictly speaking , a  programming language ready to program real quantum devices , with some effort it can be transformed in such a way that it would be able to compile a high level programs to some sort of quantum assembler .",
    "one should note that broad range of functions allowing the analysis of states is implemented in the package .",
    "those function are described in the following section .",
    "package ` quantum - octave ` is designed to allow the user to operate on different levels of abstraction .",
    "user can prepare complex gates and quantum channels from basic primitives such as single qubit rotations , controlled gates , single qubit channels .",
    "most of the functions that form this library operate on quantum registers , which makes the preparation of quantum gates and channels very `` natural '' .",
    "the library is implemented in such a  way that depending of user s choice it may operate on full or sparse matrices .    `",
    "quantum - octave ` can work in two modes : as a library or as a programming language / simulator .",
    "library mode is the default . to switch to language / simulator mode one has call quantum_octave_init ( ) function . in case of the second mode ` quantum - octave ` allocates and manages an  internal quantum state and maintains the quantum registers .",
    "such functions as evolve ( ) , applychannel ( ) , measurecompbasis ( ) operate directly on the internal state .",
    "listings of deustch s [ lst : deutsch ] and grover s [ lst : grover ] algorithms show use of language / simulation mode .",
    "following conventions are used in ` quantum - octave ` .    * _ quantum register _ is horizontal integer vector containing indices of qubits starting from one . *",
    "_ ket _ is vertical complex vector .",
    "* _ bra _ is horizontal complex vector . * _ density matrix _ is complex square matrix always of dimension @xmath15-th power of two by @xmath15-th power of two . * _ binary string _ is 0,1-horizontal vector , that encodes a  binary number .",
    "order of bits is from msb to lsb . *",
    "_ size _ of the gate or channel is always given in terms of a number of qubits it acts on .",
    "if size is written in square brackets it means that it can be omitted if the gate or channel acts on the whole system and ` quantum - octave ` was initialised .",
    "package ` quantum - octave ` supplies set of elementary gates known in quantum computation .",
    "* sx , sy , sz ",
    "return one - qubit pauli operators sx ",
    "@xmath62 , sy  @xmath63 , sz  @xmath64 . *",
    "id(n )  returns identity matrix : @xmath65 . *",
    "roty(a ) , rotz(a ) , rotx(a )  return rotation matrix by angle a around appropriate axis .",
    "* qft(n )  returns quantum fourier transform on n qubits .",
    "* swap(size , qubits )  returns swap gate of a given size that swaps qubits given as two - element vector . *",
    "qubitpermutation(permutation )  returns unitary gate that performs given permutation .",
    "* h  returns one - qubit hadamard gate .",
    "* phase(p0,p1 )  returns one - qubit phase gate , with @xmath66 phase parameters .      following functions are essential to prepare a  quantum state and to implement a  quantum algorithm , protocol or game .",
    "* ket(binvec )  returns ket for given binary string . *",
    "ketn(int , size )  returns a ket of size @xmath67 for given integer number . * state(pure_state )  returns density matrix for a  given ket . *",
    "mixstates(a1,mixed_state1,[a2 , + mixed_state2 ,  ] )  returns convex + combination of density matrices with coefficients a1 , a2 ,  . * productgate(gate , targetreg[,size ] )  returns a  controlled gate of a  given size that applies given gate on target register .",
    "[ equ : productgage ] .",
    "* controlledgate(gate , controlreg , + targetreg[,size ] )  returns a controlled gate of given size that applies gate on specified target register and is controlled by control register .",
    "[ equ : controlledgate ] .",
    "the functions listed below implement quantum conditional operations , quantum expressions and pointers .",
    "they are useful to simplify the implementation .",
    "* qif(expression , ifpart , elsepart , + size )  returns quantum gate of given size , controlled by expression that applies ifpart if expression is true and elsepart if expression is false .",
    "ifpart and elsepart are cellarrays in the form : \\{gate , target_register}. see eq .",
    "[ equ : quantumif ] .",
    "* qreq(register , integer )  returns expression : @xmath68 register@xmath69 $ ] equals integer . see eq .",
    "[ equ : quantumif - relation ] . * qrne(register , integer )  returns expression : @xmath68 register@xmath69 $ ] not equal integer .",
    "* qrge(register , integer )  returns expression : @xmath68 register@xmath69 $ ] is greater or equal to integer . *",
    "qrgt(register , integer )  returns expression : @xmath68 register@xmath69 $ ] is greater than integer . *",
    "qrle(register , integer )  returns expression : @xmath68 register@xmath69 $ ] is lesser or equal to integer . *",
    "qrlt(register , integer )  returns expression : @xmath68 register@xmath69 $ ] is lesser than integer .",
    "* qrin(register , set )  returns expression : @xmath68register@xmath69 $ ] is in set . *",
    "qror(expr1,expr2 )  returns logical or on expressions expr1 and expr2 .",
    "[ equ : quantumif - expression ] . * qrand(expr1,expr2 )  returns logical and on expressions expr1 and expr2 . *",
    "qpointer(gate , contrregister , + targteregister[,size ] )  returns quantum gate of given size , controlled by controll register that applies gate on target register . see eq .",
    "[ equ : quantumif - pointer ] .",
    "the following group of functions allows to control the evolution of quantum states and introduces the application of channels and measurement .",
    "* evolve(evolution[,state ] )  applies unitary evolution to  the state , returns the result of the evolution .",
    "[ equ : unitaryevolution ] .",
    "* channel(name , p )  returns kraus operators acting on one qubit , parametrised by p allowed names are : `` depolarizing '' , `` amplitudedamping '' , , `` bitflip '' , `` phaseflip '' and `` bitphaseflip '' . *",
    "localchannel(kraus , targetreg [ , chsize ] )  returns a channel being the extension of defined by kraus operators channel , acting on target register . * applychannel(elements[,state ] )  applies on  the  state non unitary evolution defined by set of kraus operators ( elements ) , returns the result of  the  evolution .",
    "[ equ : krausevolution ] .",
    "* ptrace(state , targetreg )  returns reduced density matrix for the state with target register traced out .",
    "[ equ : traceevolution ] . * circuit(gate [ , gate ] )  returns circuit composed of the sequence of gates .",
    "* measurecompbasis([state ] )  returns the probability distribution of the @xmath64 measurement on the given state . *",
    "isunitary(gate )  returns true if the gate is unitary , otherwise returns false .",
    "* ischannel(operators )  returns true if the operators form valid quantum channel , otherwise returns false . *",
    "collapse(distribution )  chooses and returns a  basis state at random according to distribution .",
    "following functions allows to control the quantum heap and configure the behaviour of the library .",
    "* quantum_octave_init ( )  initialises the simulated system , creates quantum state with zero qubits allocated and empty list of registers . * set_quantum_octave_sparse([true | false ] )  switches on or off use of sparse matrices by all ` quantum - octave ` functions . *",
    "newregister(size )  creates new register of given size , allocates qubits on quantum heap , returns register i d . *",
    "clearregister(regid )  removes regid register from quantum heap .",
    "traces out appropriate qubits from the internal state . *",
    "qureg(regid )  returns quantum register to  which regid points . *",
    "getstate ( )  returns the internal quantum state .      some of the states commonly used in quantum algorithms are implemented in the library as separate functions .",
    "* ghz(n )  returns greenberger - horne - zeilinger state for n qubits : @xmath70 . *",
    "phip  returns bell @xmath71 state : @xmath72 .",
    "* phim  returns bell @xmath73 state : @xmath74 . *",
    "psip  returns bell @xmath75 state : @xmath76 . *",
    "psim  returns bell @xmath77 state : @xmath78 . * maximallymixed(n )  return density matrix maximally mixed state : @xmath79 . * wernersinglet(a )  returns 2-qubit werner state : @xmath80 .",
    "package ` quantum - octave ` provides standard functions for analysis of quantum states , widely used in quantum information literature . among them",
    "the most important are :    * negativity(state , qubits )  computes negativity of the state in respect to qubits . *",
    "entropy(state )  computes von neuman entropy of the state . *",
    "concurrence(state )  computes concurrence of the state . * fidelity(rho , sigma )  computes fidelity between density matrices rho and sigma .",
    "* fidelitypuremixed(psi , rho )  computes fidelity between ket psi and density matrix sigma . *",
    "tracenorm(state )  computes trace norm of the state .",
    "* partialtranspose(state , targetreg )  returns matrix being partial transposition of state matrix in  regard to  target register .",
    "the next section presents the applications of ` quantum - octave ` and various programming techniques for solutions of quantum programming problems .",
    "in what follows the applications of ` quantum - octave ` and various high - level programming techniques are discussed .",
    "it is shown how quantum processes , such as algorithms may be implemented , simulated and analysed with this tool .",
    "one of the simplest quantum algorithms is deutsch s algorithm .",
    "although it may seem trivial , this algorithm shows two very important features of quantum computation .",
    "the first one is taht by taking the advantage of a superposition one can compute any binary function for all its arguments in one step .",
    "the second features is is that it is only possible to  retrieve information about property of a  function and not on its values .",
    "let us assume that we have a black box that is usually called the oracle .",
    "this box computes a function @xmath81 .",
    "we do not know if that function is constant @xmath82 or injective @xmath83 .",
    "in classical case we have to ask the oracle twice to check which kind the function @xmath84 is .",
    "but in quantum case it is possible to solve this problem asking the oracle only once .",
    "the algorithm goes as follows :    1 .",
    "prepare the state : @xmath85 .",
    "2 .   apply the hadamard @xmath86 gate on the state @xmath87 , you will get @xmath88 3 .",
    "apply the gate @xmath89 on the state @xmath90 ; you will get : @xmath91 4 .",
    "apply @xmath92 on the state @xmath93 ; you will get : @xmath94 5 .",
    "measure state of the first qubit , you will get @xmath95 in case of constant function , @xmath38 for injective function .    quantum circuit representation of deutsch s algorithm is presented in figure  [ fig : deustch ] .",
    "the @xmath96 gate provide a reversible implementation of function @xmath84 and the symbol   denotes a measurement .",
    "the implementation of deutsch s algorithm presented in listing  [ lst : deutsch ] is an introductory example of application of ` quantum - octave `  for simulation of a  quantum algorithm with all basic steps of computation : initialization of the quantum computer , unitary evolution and measurement .    below we describe simulation steps ( compare with circuit in figure  [ fig : deustch ] ) .",
    "numbers on the left refer to the line numbers in listing  [ lst : deutsch ] .    5 : :    : initialisation of the simulator , 7 , 8 : :    : allocation of registers , 10 - 17 : :    : definition of all four possible oracles , 19 : :    : application of @xmath97 on second qubit , 20 : :    : application of @xmath98 , 21 : :    : application of the oracle , 22 : :    : application of @xmath92 , 24 : :    : tracing out of second register , 26 : :    : return the probability distribution of the measurement outcome .",
    ".... { } # input : identifier of the function # output : state after execution of deutsch 's algorithm function ret = deutsch(num )      # initialize the simulation      quantum_octave_init ( ) ;      # declare and allocate registers          r1=newregister(1 ) ;      r2=newregister(1 ) ;      # declare functions      f{1}=id(2 ) ;      f{2}=productgate(sx , qureg(r2 ) ) ;      f{3}=qif(qreq(qureg(r1),1 ) , ...",
    "{ sx , qureg(r2 ) } , ...",
    "{ id , qureg(r2 ) } ) ;      f{4}=qif(qreq(qureg(r1),0 ) , ...",
    "{ sx , qureg(r2 ) } , ...",
    "{ id , qureg(r2 ) } ) ;      # do the algorithm      evolve(productgate(sx , qureg(r2 ) ) ) ;      evolve(productgate(h,[qureg(r1),qureg(r2 ) ] ) ) ;         evolve(f{num } ) ;       evolve(productgate(h , qureg(r1 ) ) ) ;         # throw away second register    clearregister(qureg(r2 ) ) ;      # return the outcome      ret = measurecompbasis ( ) ; endfunction ....      to illustrate more advanced usage of the presented concepts we use the quantum algorithm for searching a unordered database .",
    "the algorithms was proposed by grover  @xcite and its detailed description and analysis can be found in @xcite .",
    "here we present the implementation of grover s algorithm which presents the features of ` quantum - octave `  related to the observation of quantum errors .",
    "we show the propagation of initial errors during the execution of the algorithm .",
    "grover s search algorithm is one of the most important quantum algorithms .",
    "this is especially true since many algorithmic problems can be reduced to exhaustive search .",
    "however , like in the case of any quantum procedure , the efficiency of the algorithm depends on the ability to avoid errors during the procedure .",
    "thus , it is important how quantum errors affect the executions of the algorithm .",
    "let @xmath99 be a  set and let @xmath100 , such that @xmath101 for some marked @xmath102 .    for the simplicity",
    "we assume that @xmath99 is a set of binary strings of length @xmath15 .",
    "therefore @xmath103 and @xmath104 .",
    "we can map the set @xmath99 to the set of states over @xmath105 in the natural way as @xmath106    the goal of the algorithm is to find the marked element .",
    "this is achieved by the amplification of the appropriate amplitude  @xcite .",
    "the grover s algorithm is composed of two main procedures : the oracle and the diffusion .    [ [ oracle ] ] oracle + + + + + +    by oracle we understand a function that marks one defined element . in the case of this algorithm , the marking of the element is done by negation of the amplitude of the state that we search for .    with the use of elementary quantum gates",
    "the oracle can be constructed using an ancilla @xmath107 in the following way :",
    "@xmath108 if the register @xmath107 is prepared in the state : @xmath109 then by substitution , equation [ equ : oracle1 ] is re - transformed to : @xmath110 and by tracing out the ancilla we get : @xmath111 thus the oracle marks a given state by inverting its amplitude .",
    "[ [ sec : diffusion ] ] diffusion + + + + + + + + +    the operator @xmath112 rotates any state around the state @xmath113 @xmath112 may written in the following form : @xmath114    [ [ grover - iteration ] ] grover iteration",
    "+ + + + + + + + + + + + + + + +    the first step of the algorithm is to apply hadamard gate @xmath115 on all the qubits .",
    "then we apply gate @xmath116 several times .",
    "[ [ number - of - iterations ] ] number of iterations + + + + + + + + + + + + + + + + + + + +    application of diffusion operator on the base state @xmath117 gives @xmath118 application of this operator on any state gives @xmath119 where @xmath120 is arithmetic mean of coefficients @xmath121 .",
    "@xmath122-fold application of grover s iteration @xmath28 on initial state @xmath123 leads to @xcite : @xmath124 with real coefficients : @xmath125 where @xmath126 is an angle that fulfils the relation : @xmath127 therefore the coefficients @xmath128 are periodic functions of @xmath122 .",
    "after several iterations amplitude of @xmath129 rises and others drop .",
    "the influence of the marked state @xmath130 on the state of the register is that the initial state @xmath123 evolves towards the marked state .",
    "the @xmath129 attains its maximum after approximately @xmath131 steps .",
    "then it begins to fall .",
    "thus , the number of steps needed to transfer the initial state towards the marked state is of @xmath132 . in the classical case",
    "the number of steps is of @xmath133 .",
    "[ [ measurement ] ] measurement + + + + + + + + + + +    the last step of the grover s algorithm is the measurement .",
    "probability of obtaining of the proper result is @xmath134 .",
    "there a  exists very nice graphical interpretation of grover s algorithm .",
    "let @xmath135 denotes the sum of states orthogonal to the state we are searching for @xmath130 @xmath136 and for consistence we will write @xmath137 . then , on the plane spanned by @xmath135 and  @xmath138 , we can observe of evolution of the state vector .",
    "by putting values from equation [ equ : grover2 ] into equation [ equ : grover1 ] we get following relation : @xmath139 exemplar behaviour of this equation for @xmath140 states is presented in figure  [ fig : grover : wiz ] .     and @xmath138 .",
    "vector @xmath141 is flat superposition of all the possible states . ]",
    "listing  [ lst : grover ] presents the implementation of function grover .",
    "we will apply quantum noise at the end of each grover iteration and observe its influence on its efficiency .    to simulate this behaviour",
    "we will insert the code from listing  [ lst : grover : noise ] after line 21 of the implementation .    .... { } # function implementing grover 's algorithm # input : number we are looking for , size of the system # output : probability distribution after   #                    execution of the algorithm function ret = grover(num , s )      # initialize the simulation      quantum_octave_init ( ) ;      # allocate register      r1=newregister(s ) ;      # number of elements      n=2^length(qureg(r1 ) )      # calculate number of iterations      k = floor((pi/4)*sqrt(n ) ) ;      # prepare the system in flat superposition of base states      evolve(productgate(h , qureg(r1 ) ) ) ;      # grover iterations      for i = 1:k          # ask the oracle          evolve(oracle(num , qureg(r1 ) ) ) ;          # diffuse          evolve(diffuse(qureg(r1 ) ) ) ;      endfor      # return probability distribution of base states      ret = measurecompbasis ( ) ; endfunction    # function implementing oracle   # input : number to mark , size of the system # output : gate implementing oracle of the size 2^l function ret = oracle ( num , register )      l = length(register ) ;      ret = id(l ) ;      ret(num+1,num+1 ) = -1 ; endfunction    # function implementing oracle   # input : register on which implement diffusion # output : diffusion gate of the size 2^l function ret = diffuse(register )      l = length(register ) ;      ret = circuit ( ...                      productgate(h , register , l ) , ...",
    "( 2*ketn(0,l)*bran(0,l ) - id(l ) ) , ...",
    "productgate(h , register , l ) ...                  ) ; endfunction ....    .... { } applychannel (      localchannel (          channel(channelname , p),qureg(r1 )      ) ) ; ....    [ [ simulation - results ] ] simulation results + + + + + + + + + + + + + + + + + +    the results of the simulation of noisy grover s algorithm acting on system of size from three to six qubits when system is affected by noise modelled with depolarizing channel are shown in figure  [ fig : grover : depolarizing_channel ] . one may observe that rate of successful application of the algorithm drops quickly with raising amount of noise .",
    "this effect is more significant for larger systems .",
    "this result clearly indicates that it is not possible to successfully implement grover s algorithm in presence of large amounts of noise if no error correction scheme is applied .",
    "on probability of successful finding of sought element in grover s algorithm implemented with 3 , 4 , 5 and 6 qubits . ]",
    "we have introduced an original solution to the problem of simulation of quantum processes .",
    "this solution is provided by ` quantum - octave ` , a  library that is build upon gnu octave high level programming language , which provides high - level quantum programming structures .",
    "although strictly speaking , ` quantum - octave `  is not a  programming language but a  library , together with gnu octave , it is very convenient and flexible tool .",
    "programs written in quantum programming languages , such as qcl , can be easily rewritten using this library , thanks to the use of quantum memory , registers and routines .",
    "scalable programs can be easily implemented in ` quantum - octave ` , so the programmer does not have to think about details of the implementation .",
    "we acknowledge the financial support by the polish ministry of science and higher education under the grant number n519 012 31/1957 and by the polish research network lfppi .",
    "the numerical calculations presented in this work were performed on the ` leming ` server of the institute of theoretical and applied informatics of the polish academy of sciences ."
  ],
  "abstract_text": [
    "<S> we present a basic high - level structures used for developing quantum programming languages . </S>",
    "<S> the presented structures are commonly used in many existing quantum programming languages and we use quantum pseudo - code based on qcl quantum programming language to describe them .    </S>",
    "<S> we also present the implementation of introduced structures in gnu octave language for scientific computing . </S>",
    "<S> procedures used in the implementation are available as a package ` quantum - octave ` , providing a library of functions , which facilitates the simulation of quantum computing . </S>",
    "<S> this package allows also to incorporate high - level programming concepts into the simulation in gnu octave and matlab . as such it connects features unique for high - level quantum programming languages , with the full palette of efficient computational routines commonly available in modern scientific computing systems .    to present the major features of the described package we provide the implementation of selected quantum algorithms . </S>",
    "<S> we also show how quantum errors can be taken into account during the simulation of quantum algorithms using ` quantum - octave`package . </S>",
    "<S> this is possible thanks to the ability to operate on density matrices .    </S>",
    "<S> = 1    quantum information , quantum programming , models of quantum computation </S>"
  ]
}