{
  "article_text": [
    "in a parameterized problem , we are given an instance @xmath9 , where @xmath3 is a secondary measurement , called as the _",
    "parameter_. the central question in parameterized complexity is whether a parameterized problem admits an algorithm with running time @xmath10 , called a _ fixed parameter tractable algorithm _ ( shortly , an _ fpt algorithm _ ) , where @xmath5 is a function depending on the parameter @xmath3 alone and @xmath11 is the input size . a parameterized problem admitting such an algorithm is said to be _ fixed - parameter tractable _ , or _ fpt _ in short . as we study a parameterized problem when its unparameterized decision version is np - hard , the function @xmath5 is super - polynomial in general . for many natural parameterized problems ,",
    "the function @xmath5 is overwhelming  @xcite or even non - explicit  @xcite , especially when the algorithm is indicated by a meta - theorem .",
    "therefore , a lot of research effort focus on designing an fpt algorithm with affordable super - exponential part in the running time .",
    "we are especially interested in solving a parameterized problem in _ single - exponential _ fpt time , that is , in time @xmath12 for some constant @xmath13 .",
    "one of techniques to handle parameterized problems is the _",
    "kernelization algorithm_. a kernelization algorithm takes an instance @xmath14 and outputs an instance @xmath15 in time polynomial in @xmath16 satisfying that ( 1 ) @xmath9 is a yes - instance if and only if @xmath17 is a yes - instance , ( 2 ) @xmath18 , and @xmath19 for some function @xmath20 . the reduced instance is called a _ kernel _ and the function @xmath20 is called the _ size _ of the kernel .",
    "a parameterized problem is said to admit a _ polynomial kernel _ if there is a kernelization algorithm that reduces the input instance into an instance with size bounded by a polynomial function @xmath21 in @xmath3 .",
    "graph modification problems are typically formulated as follows : given an input graph @xmath2 and a fixed set @xmath22 of elementary operations and a graph property @xmath23 , the objective is to transform @xmath2 into a graph @xmath24 by applying at most @xmath3 operations from @xmath22 .",
    "vertex deletion , edge deletion / addition or contraction are examples of such elementary operations .",
    "the graph property @xmath23 having treewidth or pathwidth at most @xmath25 has received in - depth attention as many problems become tractable on graphs of small treewidth .",
    "the celebrated courcelle s theorem  @xcite implies that every graph property expressible in monadic second order logic of the second type ( @xmath26 ) can be verified in time @xmath27 , when the input @xmath1-vertex graph has treewidth at most @xmath25 .",
    "furthermore , having small treewidth frequently facilitates the design of a dynamic programming algorithm whose running time is much faster than that of the all - round algorithm from the courcelle s meta - theorem .",
    "therefore , it is reasonable to measure how close an instance is from `` an island of tractability within an ocean of intractable problems ''  @xcite .    in the context of treewidth",
    ", the vertex deletion problems for the special cases of @xmath28 and @xmath29 correspond to the well - known vertex cover and feedback vertex set problems respectively .",
    "generally , for fixed @xmath25 , the treewidth-@xmath25 vertex deletion can be solved in time @xmath30 implied by courcelle s meta - theorem  @xcite .",
    "as the function @xmath5 subsumed in the meta theorem is gigantic , it is natural to ask whether the exponential function in the running time can be rendered realistic .",
    "recent endeavor pursuing this question culminated in establishing that for fixed @xmath25 , the treewidth-@xmath25 vertex deletion can be solved in single - exponential fpt time  @xcite .    as for pathwidth",
    ", pathwidth-@xmath0 vertex deletion was first studied by philip , raman , villanger  @xcite , and later cygan , pilipczuk , pilipczuk , wojtaszczyk  @xcite showed that pathwidth-1 vertex deletion can be solved in time @xmath31 and it admits a quadratic kernel . using the general method developed for treewidth-@xmath25 vertex deletion  @xcite",
    ", the pathwidth-@xmath25 vertex deletion problem also admits a single - exponential fpt algorithm .",
    "[ [ linear - rankwidth . ] ] linear rankwidth .",
    "_ rankwidth _ was introduced by oum and seymour  @xcite for efficiently approximating _",
    "cliquewidth_. compared to cliquewidth , there are some containment relations , called _ vertex - minors _ and _ pivot - minors _",
    "@xcite , where the rankwidth of a graph does not increase when taking those relations . with these relations ,",
    "rankwidth has been intensively studied to extend results for treewidth and graph minors  @xcite .",
    "_ linear rankwidth _ is a linearized variation of rankwidth as pathwidth is the linearized variant of treewidth .",
    "while treewidth and pathwidth are small only on sparse graphs , dense graphs may have small rankwidth or linear rankwidth .",
    "for instance , complete graphs , complete bipartite graphs , and threshold graphs  @xcite have linear rankwidth at most @xmath0 even though they have unbounded treewidth .",
    "linear rankwidth is deeply related to _",
    "matroid pathwidth _ , also known as _ trellis - width _ , introduced by kashyap  @xcite .",
    "matroid pathwidth has been studied in some matroid theory literature  @xcite .",
    "kashyap  @xcite showed that it is np - hard to compute the matroid pathwidth of a binary matroid given with its matrix representation . from the relation between a binary matroid and its fundamental graph due to oum  @xcite",
    ", one can also deduce that it is np - hard to compute the linear rankwidth of a graph .",
    "recently , jeong , kim , and oum  @xcite showed that for fixed @xmath3 , there is a cubic - time algorithm to test whether an input graph has linear rankwidth at most @xmath3 or not , and output such an ordering if one exists .",
    "ganian  @xcite pointed out that some np - hard problems , such as computing pathwidth , can be solved in polynomial time on graphs of linear rankwidth at most @xmath0 .",
    "generally , the meta - theorem by courcelle , makowsky , and rotics  @xcite states that for every graph property @xmath23 expressible in monadic second order logic of the first type ( @xmath32 ) and fixed @xmath3 , there is a cubic - time algorithm for testing whether a graph of rankwidth at most @xmath3 has property @xmath23 .",
    "as rankwidth is always less than or equal to linear rankwidth , those problems are tractable on graphs of bounded linear rankwidth as well .",
    "in the same context , it is natural to ask whether there is an fpt algorithm for the ( linear ) rankwidth-@xmath25 vertex deletion problem , that is a problem asking whether for a given graph @xmath2 and a positive integer @xmath3 , @xmath2 contains a vertex subset of size at most @xmath3 whose deletion makes @xmath2 a graph of ( linear ) rankwidth at most @xmath25 .",
    "it is only known that for fixed @xmath25 , both problems are fpt from the meta - theorem on graphs of bounded rankwidth  @xcite .",
    "we discuss it in more detail in section  [ sec : remark ] .",
    "however , as the function of @xmath3 obtained from the meta - theorem is enormous , it is interesting to know whether there is a single - exponential fpt algorithm for both problems , like treewidth-@xmath25 vertex deletion .",
    "also , to the best of our knowledge , there was no known previous result whether the ( linear ) rankwidth-@xmath25 vertex deletion problem admits a polynomial kernel for fixed integer @xmath25 .",
    "[ [ our - contributions . ] ] our contributions .    in this paper",
    ", we show that the linear rankwidth-@xmath0 vertex deletion problem admits a single - exponential fpt algorithm and a polynomial kernel .",
    "this is a first step towards a goal of investigating whether the ( linear ) rankwidth-@xmath25 vertex deletion problem admits a single - exponential fpt algorithm or has a polynomial kernel .",
    "[ thm : main1 ] the lrw1-vertex deletion problem can be solved in time @xmath33 , and also can be solved in time @xmath7 .",
    "[ thm : main2 ] the lrw1-vertex deletion problem has a kernel with @xmath34 vertices .",
    "we note that several graph classes with a certain path - like structure have been studied for parameterized vertex deletion problems .",
    "such classes include graphs of pathwidth-@xmath0  @xcite , proper interval graphs  @xcite , unit interval graphs  @xcite , and interval graphs  @xcite . a common approach in the previous work was to use the characterization of the structures obtained after removing small obstructions .",
    "we also characterize graphs excluding small obstructions for graphs of linear rankwidth at most @xmath0 .",
    "we investigate a new class of graphs , called _ necklace graphs _ , which are close to graphs of linear rankwidth at most @xmath0 .",
    "briefly speaking , necklace graphs , when viewed locally , are graphs of linear rankwidth at most @xmath0 , but they may have long induced cycles . in section  [ sec : necklacegraph ] , we show that every connected graph having no obstructions of size at most @xmath35 for graphs of linear rankwidth at most @xmath0 is either a graph of linear rankwidth at most @xmath0 or a necklace graph ( theorem  [ thm : mainlrw ] ) . combining a simple branching algorithm and a polynomial - time algorithm to find a minimum deleting set on necklace graphs , we obtain an fpt algorithm for lrw1-vertex deletion with running time @xmath36 in the beginning of section  [ sec : fptthreaddel ] .",
    "one might ask whether the polynomial factor @xmath37 can be reduced .",
    "this running time appears as we start with finding obstructions of size at most @xmath35 .",
    "indeed , we can improve it using a dynamic programming algorithm to find an induced subgraph of fixed size in a graph of bounded cliquewidth .",
    "if the rankwidth of a given graph is more than @xmath38 , then the instance is trivially a no - instance because rankwidth can be decreased by at most @xmath0 when removing a vertex . using the approximation algorithm due to oum  @xcite",
    ", we can decide whether a given graph has rankwidth at most @xmath38 and if so , outputs a rank - decomposition of width at most @xmath39 and also a @xmath40-cliquewidth expression , in time @xmath41 .",
    "then we develop a branching algorithm using the cliquewidth expression , and finally achieve an fpt algorithm with running time @xmath41 .",
    "in section  [ sec : lowerbound ] , we prove that the running time of our algorithms can not be reduced to @xmath8 under a reasonable assumption .",
    "there is no @xmath8-time algorithm for lrw1 vertex deletion , unless exponential time hypothesis ( eth ) fails .    in section  [ sec : polykerthreaddel ]",
    ", we obtain a polynomial kernel for the lrw1-vertex deletion problem .",
    "we start with hitting obstructions of size at most @xmath35 using the sunflower lemma , and taking a minimum deleting set on the remaining necklace graph .",
    "the union of two sets will have size bounded by a polynomial function in @xmath3 , and its removal makes an input graph into a graph of linear rankwidth at most @xmath0 .",
    "graphs of linear rankwidth at most @xmath0 can be seen as graphs obtained by connecting certain blocks , called _",
    "thread blocks _ , like a path ( theorem  [ thm : structurethread ] ) .",
    "the main difficulty for reducing the remaining part is to shrink a large thread block , and we can resolve this issue using the set obtained by the sunflower lemma .",
    "we remark that a similar idea was used by fomin , saurabh , and villanger  @xcite to obtain a polynomial kernel for the proper interval vertex deletion problem .",
    "we conclude the paper with further discussions in section  [ sec : remark ] .",
    "in this paper , all graphs are finite and undirected , if not mentioned . for a graph @xmath2 ,",
    "we denote by @xmath42 and @xmath43 the vertex set and the edge set of a graph @xmath2 , respectively .",
    "let @xmath2 be a graph .",
    "for @xmath44 , let @xmath45 denote the neighborhood of @xmath46 .",
    "let @xmath47 be a subset of @xmath42 .",
    "we denote by @xmath48 $ ] the subgraph of @xmath2 induced on @xmath47 and we define @xmath49 $ ] . for short",
    "we write @xmath50 instead of @xmath51 for @xmath44 . a vertex @xmath52 of @xmath2",
    "is called a _ pendant vertex _ if @xmath53 .",
    "the subset of vertices @xmath54 is the set of all vertices of @xmath47 that have a neighbor in @xmath55 .",
    "a graph @xmath56 is an _ induced subgraph _ of a graph @xmath2 if @xmath57 $ ] for some @xmath58 . for a set @xmath59 of graphs ,",
    "a graph @xmath2 is _ @xmath59-free _ if @xmath2 has no induced subgraph isomorphic to a graph in @xmath59 .",
    "a vertex @xmath52 of @xmath2 is called a _ cut vertex _ if the removal of @xmath52 from @xmath2 strictly increases the number of connected components . a maximal connected subgraph of a graph without a cut vertex",
    "is called a _ block_. note than an edge can be a block .",
    "the path on the vertex set @xmath60 and the edge set @xmath61 will be denoted by @xmath62 , and the cycle on the vertex set @xmath60 and the edge set @xmath63 will be denoted by @xmath64 .",
    "the length of a path is defined as the number of edges in the path . for @xmath65 , we denote by @xmath66 the chordless cycle of length @xmath1 .",
    "a graph @xmath2 is _ distance - hereditary _ if for every connected induced subgraph @xmath56 of @xmath2 and @xmath67 , the distance between @xmath52 and @xmath25 in @xmath56 is the same as the distance between @xmath52 and @xmath25 in @xmath2 .",
    "for instance the cycle @xmath68 of length @xmath69 is not distance - hereditary , as @xmath70 and @xmath71 have distance @xmath72 in the graph , but they have distance @xmath73 in @xmath74 .",
    "a _ star _ is a tree with a distinguished vertex adjacent to all other vertices .",
    "complete graph _ is a graph with all possible edges .",
    "an ordering on a finite set @xmath47 is a bijective mapping @xmath75 , and we write @xmath76 if @xmath77 , and @xmath78 as the inverse bijective mapping . for an @xmath79-matrix @xmath80 and @xmath81 , let @xmath82 $ ] be the submatrix of @xmath80 whose rows and columns are indexed by @xmath83 and @xmath84 , respectively .",
    "when we analyze the running time of an algorithm , we agree that @xmath85 and @xmath86 if @xmath2 is an input graph .",
    "the _ adjacency matrix _ of a graph @xmath2 , which is a @xmath87-matrix over the binary field , will be denoted by @xmath88 .",
    "the _ width _ of an ordering @xmath89 of the vertex set of a graph @xmath2 is @xmath90),\\ ] ] where the rank of a matrix is computed over the binary field .",
    "the _ linear rankwidth _ of a graph @xmath2 is defined as the minimum width over all orderings of @xmath42 .",
    "ganian  @xcite first characterized graphs of linear rankwidth at most @xmath0 , and he called them _",
    "thread graphs_. later , adler , farley , and proskurowski  @xcite gave an easier way to define a thread graph , using a notion of _ thread blocks_. we follow the definition of thread blocks given by adler , farley , and proskurowski , and provide a unified way to define classes of graphs including thread graphs .",
    "a graph @xmath2 with at least @xmath72 vertices is called a _ thread block _ if there is an ordering @xmath89 of @xmath42 and a function @xmath91 satisfying that    1 .",
    "@xmath92 and @xmath93 , 2 .   for @xmath94 with @xmath95 , @xmath96 if and only if @xmath97 and @xmath98 .",
    "a thread block is a _",
    "canonical thread block _ if it satisfies on the top of the previous two conditions and the following third condition :    1 .",
    "@xmath99 if @xmath100 .",
    "the third condition implies that every canonical thread block has no pendant vertex adjacent to its first vertex @xmath101 .",
    "it will guarantee a unique decomposition of a thread graph into thread blocks .",
    "we say that @xmath89 and @xmath102 are the _ ordering _ and _ labeling _ of @xmath2 respectively , and say that @xmath101 and @xmath103 are the _ first and last _ vertices of @xmath2 , respectively",
    ". see figure  [ fig : threadblock ] for an example .",
    "let @xmath104 be a digraph .",
    "a set @xmath105 of thread blocks is said to be _ mergeable with @xmath106 _ if    1 .   for every arc @xmath107 of @xmath108",
    ", @xmath109 is a thread block whose first and last vertices are @xmath46 and @xmath110 , respectively , and 2 .   for two distinct arcs @xmath111 of @xmath108 , @xmath112 .    for a digraph @xmath104 and a set of thread blocks @xmath113 mergeable with @xmath106",
    ", we define @xmath114 as the graph @xmath2 with the vertex set @xmath115 and the edge set @xmath116 .",
    "we say that @xmath106 is the _ underlying digraph _ of @xmath2 and that @xmath117 is a _ thread decomposition _ of @xmath2 .",
    "we say that @xmath117 is a _ canonical thread decomposition _ of @xmath2 if every thread block of @xmath118 is a canonical thread block .",
    "a connected graph @xmath2 is a _ thread graph _ if @xmath2 is either an one vertex graph or @xmath119 for some directed path @xmath120 and some set of thread blocks @xmath121 mergeable with @xmath120 .",
    "a graph is a _ thread graph _ if each of its connected components is a thread graph .",
    "see figure  [ fig : threadgraph ] for an example of a connected thread graph , and its canonical thread decomposition .",
    "it is not hard to observe that every connected thread graph admits a canonical thread decomposition ; one can obtain a canonical thread decomposition from any thread decomposition by rearranging pendant vertices adjacent to a vertex in the underlying digraph . in lemma  [ lem :",
    "splittreetothreadblock ] , we will give a polynomial - time algorithm that given a connected thread graph , outputs its canonical thread decomposition .",
    "the following structural properties of thread graphs will be used in later sections .",
    "[ lem : structure ] let @xmath65 be an integer , and let @xmath2 be a connected thread graph such that @xmath2 admits a canonical thread decomposition @xmath122 where @xmath123 and @xmath124",
    ". then the following are satisfied .    1 .   for every @xmath125",
    ", @xmath52 has a neighbor in @xmath120 .",
    "vertices @xmath126 are cut vertices of @xmath2 . moreover , every cut vertex of @xmath2 is contained in @xmath120 .",
    "3 .   for each @xmath127",
    ", @xmath128 is exactly the union of the set of all pendant vertices adjacent to @xmath129 and the vertex set of the block of @xmath2 containing @xmath130 .",
    "\\(1 ) let @xmath131 be the thread block containing @xmath52 .",
    "depending on the label of @xmath52 in @xmath131 , @xmath52 is adjacent to at least one of @xmath132 .",
    "\\(2 ) the first statement came from the definition of a connected thread graph that for @xmath133 with @xmath134 , @xmath135 .",
    "that is , for each @xmath136 , all paths from @xmath137 to @xmath129 must pass through @xmath138 , and it implies that @xmath138 is a cut vertex of @xmath2 . if @xmath125 , then by the statement ( 1 ) , every vertex of @xmath139 has a neighbor in @xmath120 and thus @xmath139 is connected .",
    "it implies that every cut vertex of @xmath2 is contained in @xmath120 .",
    "\\(3 ) let us fix @xmath140 and let @xmath89 and @xmath102 be the ordering and labeling of @xmath131 , respectively .",
    "let @xmath58 be the vertex set containing all pendant vertices adjacent to @xmath129 and the vertex set of the block of @xmath2 containing @xmath141 and @xmath129 .",
    "we need to prove that @xmath142 .    to prove that @xmath143 , let @xmath144 .",
    "observe that by construction of @xmath2 and the fact that @xmath145 , if @xmath52 is not a pendant vertex and satisfies @xmath146 , then @xmath147 .",
    "so , let us assume that @xmath52 is not a pendant vertex and has a neighbor in @xmath120 other than @xmath138 and @xmath129 .",
    "if @xmath52 is adjacent to some vertex @xmath148 of @xmath120 with @xmath149 , then it contradicts the fact that @xmath129 separates @xmath138 and @xmath148 in @xmath2 by ( 2 ) . similarly ,",
    "if @xmath52 is adjacent to some vertex @xmath148 of @xmath120 with @xmath150 , then it contradicts the fact that @xmath138 separates @xmath148 and @xmath129 in @xmath2 by ( 2 ) .",
    "thus , we have @xmath146 and @xmath147 . finally by construction , as @xmath151 is a canonical thread decomposition , the pendant vertices adjacent to @xmath129 belong to @xmath131 .",
    "we conclude that @xmath143 .",
    "we verify that @xmath152 .",
    "let @xmath153 . if @xmath154 , then @xmath52 is contained in @xmath47 .",
    "if @xmath155 , then by definition of a canonical thread block , there exists @xmath156 with @xmath157 .",
    "so , @xmath52 is contained in a cycle of length @xmath158 together with @xmath132 , and thus , @xmath145 .",
    "if @xmath159 and there exists @xmath95 with @xmath98 , then similarly we have @xmath145 , and if there are no such a vertex @xmath25 , then @xmath52 is a pendant vertex adjacent to @xmath129 , that is also contained in @xmath47 .           that are distance - hereditary .",
    "]    let @xmath160 be the house , gem , domino graphs respectively , which are depicted in figure  [ fig : obsdh ] . the induced subgraph obstructions for graphs of linear rankwidth at most @xmath0 consist of the set of induced subgraph obstructions for distance - hereditary graphs  @xcite , that are @xmath161 , @xmath162 , @xmath163 , and induced cycles of length at least @xmath69 , and the set of 14 induced subgraph obstructions for graphs of linear rankwidth at most @xmath0 that are distance - hereditary , depicted in figure  [ fig : obslrw1 ]  @xcite .",
    "we define that    * @xmath164 is the union of @xmath165 and the set of @xmath166 graphs in figure  [ fig : obslrw1 ] .    [ thm : structurethread ] for a graph @xmath2 , the following are equivalent .",
    "* @xmath2 has linear rankwidth at most @xmath0 .",
    "* @xmath2 is a thread graph .",
    "* @xmath2 has no induced subgraph isomorphic to a graph in @xmath164 .",
    "we often use the term ` thread graphs ' for graphs of linear rankwidth at most @xmath0 . for a graph @xmath2 and @xmath58 , @xmath47 is called a _",
    "lrw1-deletion set _ if @xmath167 is a graph of linear rankwidth at most @xmath0 .",
    "it is known that one can recognize graphs of linear rankwidth at most @xmath0 in time @xmath168 using split decompositions  @xcite .",
    "furthermore , we can easily obtain a canonical thread decomposition of a graph of linear rankwidth at most @xmath0 from its split decomposition , but for our knowledge , it was not stated anywhere . in this subsection",
    ", we clarify a procedure to obtain a thread decomposition .",
    "this will be especially used in the kernelization algorithm in section  [ sec : polykerthreaddel ] .",
    "we use graph - labelled trees introduced by gioan and paul  @xcite , which are convenient forms of split decompositions . a triple @xmath169 of a tree @xmath170 and a set of graphs @xmath171 and a set of functions @xmath172",
    "is called a _",
    "graph - labelled tree _",
    "if    * for every node @xmath52 of degree @xmath3 in @xmath170 , @xmath173 is a connected graph on @xmath3 vertices , called _ marker vertices _ , * @xmath174 is a bijection from the edges of @xmath170 incident with @xmath52 to the marker vertices of @xmath173 .",
    "let @xmath52 be a leaf of @xmath170 .",
    "a node or a leaf @xmath175 different from @xmath52 is called _ @xmath52-accessible _ if for every edges @xmath107 and @xmath176 on the path from @xmath175 to @xmath52 in @xmath170 , @xmath177 is adjacent to @xmath178 in @xmath179 .",
    "the _ accessibility graph _ of a graph - labelled tree @xmath180 is the graph @xmath181 whose vertex set is the set of all leaves of @xmath170 , and @xmath182 if and only if @xmath110 is @xmath46-accessible .",
    "we say that @xmath180 is a graph - labelled tree of @xmath181 .",
    "we give two operations on a graph - labelled tree to define a _ reduced graph - labelled tree_. a _ split _ of a graph @xmath2 is a vertex partition @xmath183 of @xmath2 such that @xmath184 , and there exist @xmath185 where the set of edges incident with both @xmath186 and @xmath187 is exactly @xmath188",
    ". a connected graph is _ degenerate _ if every vertex partition @xmath183 with @xmath184 is a split .",
    "it is known that every degenerate graph is either a complete graph or a star graph .",
    "a node in a graph - labelled tree is called a _ clique node _ ( or a _ star node _ ) if a complete graph ( or a star graph , respectively ) is assigned to the node . a graph without splits is called a _",
    "prime graph_.    let @xmath180 be a graph - labelled tree of a graph @xmath2 .",
    "let @xmath52 be a node of @xmath170 such that @xmath173 admits a split @xmath189 . for each @xmath190",
    ", let @xmath191 be the graph obtained from @xmath192 $ ] by adding a new vertex @xmath193 that is adjacent to all vertices in @xmath194 .",
    "then the _ node - split _ operation on the node @xmath52 with respect to @xmath189 consists of substituting @xmath52 by two adjacent nodes @xmath195 , respectively labelled by @xmath196 , such that for each @xmath190 , @xmath197 the _ node - join _ operation is the reverse operation of the node - split operation ; if @xmath198 is an edge of @xmath170 , then the _ node - join _ operation on @xmath198 consists of contracting @xmath198 into a new node @xmath175 labelled by the graph @xmath199 where @xmath199 is the graph obtained from the disjoint union of @xmath173 and @xmath200 by deleting @xmath201 and @xmath202 and adding all edges between @xmath203 and @xmath204 .",
    "we say that a star node @xmath52 is _ oriented towards a node @xmath205 _ of @xmath170 if the edge @xmath206 such that @xmath207 is the center of @xmath173 is on the path in @xmath170 between @xmath205 and @xmath52 .    a graph - labelled tree is _ reduced _ if    1 .",
    "every node is either prime or degenerate , and 2 .",
    "it contains no edge that connects two degenerate nodes where the node - join operation on this edge results in another degenerate node .",
    "cunningham showed the uniqueness of a reduced graph - laballed tree of a connected graph .",
    "moreover , it can be computed in time @xmath208 .",
    "[ thm : cunningham ] every connected graph @xmath2 admits a unique reduced graph - labelled tree , and it can be computed in time @xmath208 .    for a connected graph @xmath2 ,",
    "we denote by @xmath209 the unique reduced graph - labelled tree obtained from theorem  [ thm : cunningham ] .",
    "we call it the _ split tree _ of @xmath2",
    ". the following characterization of graphs of linear rankwidth @xmath0 is crucial .",
    "we give an example of the split tree of a connected thread graph in figure  [ fig : splittree ] .",
    "= [ circle , draw , solid , fill = black , inner sep=0pt , minimum width=3pt ]    ( 30 - 40,40 ) ellipse ( 14 and 15 ) ; ( a1 ) [ v ] at ( 30 - 40,50 ) ; ( a3 ) [ v ] at ( 20 - 40,40 ) ; ( a4 ) [ v ] at ( 40 - 40,40 ) ; ( a1)(a3)(a4)(a1 ) ;    ( a5 ) [ v ] at ( 20 - 50,40 ) ; ( a6 ) [ v ] at ( 30 - 40,60 ) ; ( a5)(a3 ) ; ( a6)(a1 ) ;    ( 30 - 40 , 67 ) node@xmath210 ;    ( 30,40 ) ellipse ( 14 and 15 ) ;    ( b1 ) [ v ] at ( 30,50 ) ; ( b3 ) [ v ] at ( 20,40 ) ; ( b4 ) [ v ] at ( 40,40 ) ; ( b1)(b3)(b4 ) ;    ( b6 ) [ v ] at ( 30,60 ) ; ( b6)(b1 ) ;    ( 30 , 67 ) node@xmath211 ;    ( 30 + 40,40 ) ellipse ( 14 and 15 ) ;    ( c1 ) [ v ] at ( 30 + 40,50 ) ; ( c3 ) [ v ] at ( 20 + 40,40 ) ; ( c4 ) [ v ] at ( 40 + 40,40 ) ; ( c1)(c3)(c4)(c1 ) ;    ( c6 ) [ v ] at ( 30 + 40,60 ) ; ( c6)(c1 ) ;    ( 30 + 40 , 67 ) node@xmath210 ;    ( 30 + 80,40 ) ellipse ( 14 and 15 ) ;    ( d1 ) [ v ] at ( 30 + 80,50 ) ; ( d3 ) [ v ] at ( 20 + 80,40 ) ; ( d4 ) [ v ] at ( 40 + 80,40 ) ; ( d3)(d1)(d4 ) ; ( d6 ) [ v ] at ( 30 + 80,60 ) ; ( d6)(d1 ) ;    ( 30 + 120,40 ) ellipse ( 14 and 15 ) ;    ( e1 ) [ v ] at ( 30 + 120,50 ) ; ( e3 ) [ v ] at ( 20 + 120,40 ) ; ( e4 ) [ v ] at ( 40 + 120,40 ) ; ( e1)(e4)(e3 ) ; ( e6 ) [ v ] at ( 30 + 120,60 ) ; ( e6)(e1 ) ;    ( 30 + 120 , 67 ) node@xmath212 ;    ( 30 + 160,40 ) ellipse ( 14 and 15 ) ;    ( f1 ) [ v ] at ( 30 + 160,50 ) ; ( f3 ) [ v ] at ( 20 + 160,40 ) ; ( f4 ) [ v ] at ( 40 + 160,40 ) ; ( f1)(f3)(f4)(f1 ) ; ( f6 ) [ v ] at ( 30 + 160,60 ) ; ( f6)(f1 ) ;    ( 30 + 160 , 67 ) node@xmath210 ;    ( 30 + 200,40 ) ellipse ( 14 and 15 ) ;    ( g1 ) [ v ] at ( 30 + 200,50 ) ; ( g3 ) [ v ] at ( 20 + 200,40 ) ; ( g4 ) [ v ] at ( 40 + 200,40 ) ; ( g1)(g3)(g4 ) ; ( g6 ) [ v ] at ( 30 + 200,60 ) ; ( g6)(g1 ) ;    ( 30 + 200 , 67 ) node@xmath211 ;    ( 30 + 240,40 ) ellipse ( 14 and 15 ) ;    ( h1 ) [ v ] at ( 30 + 240,50 ) ; ( h2 ) [ v ] at ( 30 + 240,30 ) ; ( h3 ) [ v ] at ( 20 + 240,40 ) ; ( h4 ) [ v ] at ( 40 + 240,40 ) ; ( h3)(h1)(h4 ) ; ( h1)(h2 ) ; ( h6 ) [ v ] at ( 30 + 240,60 ) ; ( h7 ) [ v ] at ( 30 + 240,20 ) ; ( h6)(h1 ) ; ( h7)(h2 ) ;    ( 30 + 240 , 10 ) node@xmath212 ;    ( a4)(b3 ) ; ( b4)(c3 ) ; ( c4)(d3 ) ; ( d4)(e3 ) ; ( e4)(f3 ) ; ( f4)(g3 ) ; ( g4)(h3 ) ;    ( 30 + 265 , 40 ) node@xmath213 ;    [ thm : charlrw1split ] a connected graph @xmath2 with the split tree @xmath180 is a graph of linear rankwidth at most @xmath0 if and only if every graph in @xmath171 is degenerate and the tree obtained from @xmath170 by removing all its leaves is a path .",
    "thus , one can recognize graphs of linear rankwidth at most @xmath0 in time @xmath208 .",
    "[ lem : splittreetothreadblock ] given a connected graph @xmath2 of linear rankwidth at most @xmath0 , we can output a canonical thread decomposition @xmath214 in time @xmath208 .    using the algorithm in theorem  [ thm : cunningham ] , we compute a split tree of @xmath2 in time @xmath168 .",
    "let @xmath215 be the obtained split tree of a connected thread graph @xmath2 . by theorem  [ thm : charlrw1split ] ,",
    "the tree obtained from @xmath170 by removing all its leaves is a path and each @xmath173 is degenerate , that is , either a star node or a clique node .",
    "let @xmath216 be the path @xmath217 obtained from @xmath170 by removing all its leaves , and we give a direction on edges so that it is the directed path from @xmath70 to @xmath218 .",
    "note that for each leaf @xmath52 in @xmath170 with the neighbor @xmath25 , there exists a unique marker vertex @xmath175 in @xmath200 such that @xmath219 .",
    "we denote by @xmath220 .",
    "we choose the sequence @xmath221 of all star nodes such that    * @xmath222 , * for each @xmath223 , there is a leaf @xmath224 of @xmath170 such that @xmath225 is the center of @xmath226 .",
    "we choose a leaf @xmath227 of @xmath170 that is adjacent to @xmath70 , and choose a leaf @xmath228 of @xmath170 that is adjacent to @xmath218 .",
    "it is not hard to check that @xmath229 .",
    "also , from the accessibility among nodes of @xmath170 , one can observe that @xmath230 are cut vertices of @xmath2 , and thus @xmath231 is an induced path of @xmath2 .",
    "let @xmath232 , and we regard it as a directed path from @xmath233 to @xmath234 .",
    "now , we construct a set of thread blocks @xmath235 where @xmath236 is a canonical thread decomposition of @xmath2 . for each node @xmath237 , let @xmath238 be the set of all leaves in @xmath170 that are adjacent to @xmath52 . for convenience ,",
    "let @xmath239 and @xmath240 .",
    "for each @xmath241 , we define the following :    1 .",
    "let @xmath242 $ ] .",
    "we take an ordering @xmath243 of @xmath244 such that @xmath224 and @xmath245 are the first and last vertices , and @xmath246 if there is a directed path from the neighbor of @xmath52 to the neighbor of @xmath25 in @xmath216 .",
    "we take an arbitrary ordering for the leaves that have the same neighbor in @xmath170 , except @xmath245 .",
    "this can be done in time @xmath247 .",
    "3 .   from the definition of @xmath248 , it is not hard to check that for @xmath249 with @xmath246 , @xmath96 if and only if * @xmath250 , or the neighbor of @xmath52 is either a clique node or a star node oriented towards @xmath218 , and * @xmath251 , or the neighbor of @xmath25 is either a clique node or a star node oriented towards @xmath70 .",
    "+ note that the vertices in @xmath252 are pendant vertices adjacent to @xmath245 in @xmath2 . following the above observations",
    ", we give a labeling @xmath253 on @xmath244 such that for @xmath254 with the neighbor @xmath255 in @xmath170 , @xmath256 it takes @xmath247 time .",
    "it is not hard to verify that @xmath243 and @xmath253 are proper ordering and labeling of @xmath257 using accessibility among nodes of @xmath170 .",
    "moreover , as @xmath258 does not contain a vertex in @xmath259 , which is a pendant vertex adjacent to @xmath224 if exists , @xmath257 is a canonical thread block whose first and last vertices are @xmath224 and @xmath245 , respectively , with the ordering @xmath243 and the labeling @xmath253 . + we return @xmath260 .",
    "note that @xmath230 are cut vertices of @xmath2 .",
    "thus , it is straightforward to check that    1 .",
    "@xmath261 for every pair @xmath262 with @xmath134 , 2 .",
    "@xmath263 and @xmath264 .",
    "we conclude that @xmath236 is the canonical thread decomposition of @xmath2 , and it can be computed in time @xmath168 .",
    "we generalize the construction of thread graphs from directed paths to directed cycles .",
    "a connected graph @xmath2 is called a _ necklace graph _ if @xmath265 for some directed cycle @xmath266 and some set of thread blocks @xmath267 mergeable with @xmath266 .",
    "see figure  [ fig : necklace ] for an example of a necklace graph .",
    "let @xmath268 the main result of this section is the following .",
    "[ thm : mainlrw ] every connected @xmath269-free graph is either a connected thread graph or a necklace graph whose underlying cycle has length at least @xmath270 .    assuming that @xmath2 is not a thread graph , to prove theorem  [ thm : mainlrw ]",
    ", we recursively find an underlying cycle @xmath266 of length @xmath271 and a set of thread blocks @xmath272 such that @xmath273 . at each recursion step",
    ", we assume that @xmath274 and prove that    1 .   if @xmath45 contains two vertices of distance at least @xmath73 in @xmath2 , then @xmath2 contains a graph in @xmath269 or an induced cycle of length @xmath102 with @xmath275 , 2 .",
    "if every pair of vertices of @xmath45 are at distance at most @xmath72 , then @xmath45 is contained in the union of two consecutive thread blocks of @xmath276 , and then either @xmath2 contains a graph in @xmath269 or it is a necklace graph with @xmath266 as the underlying cycle .",
    "we need some preliminary lemmas .",
    "[ lem : excludecycle8 ] let @xmath2 be a necklace graph whose underlying cycle @xmath266 has length @xmath277 .",
    "the distance in @xmath2 between any pair of vertices is at most @xmath278 .    observe that when merging the ( directed ) cycle @xmath266 with a set of thread blocks @xmath272 to obtain @xmath273 , the distance between any two vertices of @xmath266 in @xmath266 is the same as the distance in @xmath2 ( viewed as an undirected cycle ) .",
    "as the distance between any pair of vertices in an induced cycle of length @xmath277 is at most @xmath279 , the statement follows from the fact that every vertex in @xmath2 either belongs to @xmath266 or has a neighbor in @xmath266 .",
    "[ lem : pathtoobs ] let @xmath280 be an integer .",
    "let @xmath2 be a graph and let @xmath281 such that @xmath139 is an induced path @xmath282 , and @xmath52 is adjacent to both @xmath283 and @xmath284 in @xmath2",
    ". then @xmath2 contains an induced subgraph isomorphic to @xmath161 , @xmath162 , @xmath163 , or an induced cycle of length at least @xmath69 .",
    "let @xmath285 be the sequence of integers such that @xmath286 are all neighbors of @xmath52 on @xmath120 . if @xmath287 for some @xmath288 , then @xmath289 is an induced cycle of length at least @xmath69 .",
    "we may assume that @xmath290 for all @xmath288 .",
    "if @xmath291 for some @xmath292 , then @xmath293 $ ] is isomorphic to @xmath163 .",
    "if one of @xmath294 and @xmath295 is @xmath0 and the other value is @xmath72 for some @xmath292 , then @xmath293 $ ] is isomorphic to @xmath161 .",
    "so we may assume that @xmath296 for all @xmath288 .",
    "since @xmath280 , @xmath2 has an induced subgraph isomorphic to @xmath162 .",
    "[ lem : extendthread ] let @xmath2 be a connected thread graph and @xmath281 such that @xmath139 admits a canonical thread decomposition @xmath297 where @xmath298 and @xmath299 . if @xmath300 , then there exists a set @xmath301 of thread blocks mergeable with @xmath120 such that @xmath302 is a canonical thread decomposition of @xmath2 .    since @xmath2 is a connected thread graph",
    ", @xmath2 admits a canonical thread decomposition @xmath303 with a directed path @xmath304 and a mergeable set of thread blocks @xmath305 .",
    "we first show that @xmath306 should be contained in @xmath304 . by lemma  [ lem : structure ]",
    ", it is enough to show that they are cut vertices of @xmath2 .",
    "note that @xmath307 and @xmath308 are still cut vertices of @xmath2 as @xmath300 .",
    "we claim that @xmath71 is also a cut vertex of @xmath2 .",
    "suppose that @xmath71 is not a cut vertex of @xmath2 .",
    "this implies that there is a path from @xmath307 to @xmath308 in @xmath309 .",
    "we take a shortest path @xmath216 among such paths .",
    "if it has length @xmath72 , then @xmath310 induces a subgraph isomorphic to @xmath311 or @xmath312 depending on the adjacency between @xmath71 and the middle vertex of @xmath216 .",
    "if it has length at least @xmath73 , then by lemma  [ lem : pathtoobs ] , @xmath313 $ ] contains an induced subgraph in @xmath164 , which contradicts to our assumption .",
    "thus , @xmath71 is also a cut vertex of @xmath2 .",
    "since @xmath306 are cut vertices of @xmath2 , by ( 2 ) of lemma  [ lem : structure ] , we have @xmath314 .",
    "if @xmath315 is a directed path in @xmath304 , then for each @xmath316 , we take the subgraph @xmath317 of @xmath2 induced on the union of the set of all pendant vertices adjacent to @xmath129 and the vertex set of the block of @xmath2 containing @xmath130 . by ( 3 ) of lemma  [ lem : structure ] , @xmath318 and @xmath319 are the canonical thread blocks listed in @xmath305 .",
    "now , we assume that @xmath320 is a directed path in @xmath304 . in this case , for each @xmath321 , the subgraph @xmath322 of @xmath2 induced on the union of the set of all pendant vertices adjacent to @xmath141 and the vertex set of the block of @xmath2 containing @xmath130 is a canonical thread block listed in @xmath305 .",
    "then we obtain @xmath317 from @xmath322 by removing all pendant vertices adjacent to @xmath138 and adding all pendant vertices adjacent to @xmath129 .",
    "it is not hard to observe that @xmath317 is a canonical thread block whose first and last vertices are @xmath132 , respectively ; we can take a reverse ordering for vertices in the block containing @xmath132 , and replace each label @xmath323 with @xmath324 and each label @xmath324 with @xmath323 .",
    "now , we set @xmath325 .",
    "we claim that @xmath326 . as each thread block",
    "@xmath131 or @xmath317 in @xmath301 satisfies that @xmath327 or @xmath328 , we have that    * @xmath329 , and * @xmath330 .    as @xmath151 is a canonical thread decomposition of @xmath139 and @xmath331 , by ( 3 ) of lemma  [ lem : structure ] ,",
    "every vertex of @xmath2 is either a pendant vertex adjacent to one of @xmath332 , or contained in a block containing two consecutive vertices @xmath132 .",
    "it implies that @xmath333 , and we have    * @xmath334 and @xmath335 .",
    "therefore , we conclude that @xmath326 .",
    "let @xmath2 be a connected @xmath269-free graph and suppose that @xmath2 is not a thread graph . by theorem  [ thm : structurethread ]",
    ", @xmath2 contains an induced cycle of length at least @xmath270 .",
    "let @xmath266 be a shortest cycle among induced cycles of length at least @xmath270 in @xmath2 . for convenience ,",
    "let @xmath336 .",
    "we regard @xmath266 as a directed cycle on vertex set @xmath337 ( with @xmath277 ) , where for each @xmath338 , @xmath339 is an arc .",
    "we prove by induction on @xmath340 that @xmath2 is a necklace graph whose underlying cycle is @xmath266 .",
    "we may assume that @xmath341 .",
    "clearly , @xmath139 is again @xmath269-free graph and @xmath266 is a shortest cycle among induced cycles of length at least @xmath270 in @xmath139 . by the induction hypothesis",
    ", @xmath139 is a necklace graph whose underlying cycle is @xmath266 and thereby has a canonical thread decomposition @xmath342 where @xmath343 .",
    "we claim that all vertices of @xmath344 have pairwise distance at most @xmath72 in @xmath139 .",
    "suppose that there are two vertices @xmath345 that have distance at least @xmath73 in @xmath139 .",
    "by lemma  [ lem : excludecycle8 ] , the distance in @xmath139 between @xmath46 and @xmath110 is at most @xmath278 . we take a shortest path @xmath216 from @xmath46 to @xmath110 in @xmath139",
    ". then by lemma  [ lem : pathtoobs ] , @xmath346 $ ] contains an induced subgraph isomorphic to either @xmath161 , @xmath162 , @xmath163 , or an induced cycle @xmath347 of length @xmath348 with @xmath349 .",
    "as @xmath266 was selected as a smallest induced cycle of length @xmath277 , if there is an induced cycle @xmath347 , then it has length at most @xmath35 .",
    "this contradicts the assumption that @xmath2 is @xmath269-free .",
    "thus , all vertices of @xmath344 have pairwise distance at most @xmath72 in @xmath139 .",
    "it implies that @xmath350 for some @xmath351 .",
    "let us consider @xmath352 $ ] .",
    "observe that @xmath353 is a thread graph .",
    "the facts that @xmath2 is @xmath354-free and that @xmath52 does not belong to a cycle of @xmath2 of length @xmath69 or more ( see paragraph above ) , imply that @xmath56 is @xmath355-free and thereby a thread graph ( theorem  [ thm : structurethread ] ) . by construction @xmath353",
    "is a thread graph with a canonical thread decomposition @xmath356 where @xmath357 and @xmath120 is the directed path @xmath358 .",
    "so we apply lemma  [ lem : extendthread ] on @xmath56 and @xmath353 .",
    "let @xmath359 be the resulting canonical thread decomposition of @xmath56 .",
    "then @xmath360 is a canonical thread decomposition of @xmath2 .",
    "in this section , we give two single - exponential fpt algorithms for the lrw1-vertex deletion problem . both fpt algorithms",
    "are based on branching algorithms that reduce an input graph to a @xmath269-free graph .",
    "we first show that one can easily find a minimum lrw1-deletion set  in a @xmath269-free graph .",
    "it implies that there is an fpt algorithm with running time @xmath36 with a simple branching algorithm .",
    "next , we provide a way to reduce the polynomial factor @xmath37 into @xmath361 using an algorithm to find a fixed subgraph on graphs of bounded cliquewidth .",
    "we prove the following .",
    "[ prop : nltothread2 ] given a @xmath269-free graph @xmath2 , we can compute a minimum lrw1-deletion set of @xmath2 in time @xmath362 .",
    "we observe that every necklace graph can be turned into a thread graph by removing a vertex on the underlying cycle .",
    "[ lem : nltothread ] let @xmath2 be a connected necklace graph with the underlying directed cycle @xmath266 . for each @xmath363 , @xmath139 is a thread graph .",
    "let @xmath266 be the directed cycle on vertex set @xmath337 , where for each @xmath338 , @xmath339 is an arc . and let @xmath364 be the set of thread blocks mergeable with @xmath266 such that @xmath365 . because of the symmetry , it is sufficient to show that @xmath366 is a thread graph . as the pendent vertices of @xmath2 that are adjacent to @xmath70 become isolated vertices after removing @xmath70 , we may assume that @xmath2 has no pendent vertices adjacent to @xmath70 . for each @xmath351",
    ", let @xmath248 and @xmath367 be the ordering and labeling of @xmath191 , respectively .",
    "suppose that @xmath368 .",
    "since @xmath369 has no pendant vertices adjacent to @xmath70 , the vertex @xmath370 is labelled either @xmath371 or @xmath323 .",
    "let @xmath372 be the restriction of @xmath373 on @xmath374 , and for each @xmath375 , let @xmath376 it is easy to check that @xmath377 is a thread block with the ordering @xmath372 and labeling @xmath378 . if @xmath379 , then we can regard @xmath380 as the last thread block of @xmath366 .",
    "similarly , if @xmath381 , then we can regard @xmath382 as the first thread block of @xmath366 . otherwise , we regard @xmath383 as the first thread block .",
    "let @xmath384 and @xmath385 .",
    "we conclude that @xmath366 is a thread graph with the underlying directed path @xmath120 where @xmath386    let @xmath2 be a @xmath269-free graph and let @xmath3 be the minimum size of a lrw1-deletion set of @xmath2 . by theorem  [ thm : mainlrw ] , each connected component of @xmath2 is either a thread graph or a necklace graph . for each component @xmath56 of @xmath2 , we can test whether @xmath56 is a thread graph or not in time @xmath387 using theorem  [ thm : charlrw1split ] . by lemma  [ lem : nltothread ] ,",
    "it is enough to remove exactly one vertex to make each necklace component a thread graph .",
    "thus , @xmath3 is equal to the number of its necklace components .",
    "moreover , in each necklace component @xmath56 , we can identify a vertex @xmath52 on the underlying cycle by testing whether @xmath353 is a thread graph for every vertex @xmath52 in @xmath56 .",
    "it takes a @xmath388 time .",
    "therefore , we can find a minimum lrw1-deletion set of @xmath2 in time @xmath389 .",
    "we give an fpt algorithm using a simple branching algorithm .",
    "[ thm : algorithm1 ] the lrw1-vertex deletion problem can be solved in time @xmath33 .",
    "let @xmath390 be an instance of the lrw1-vertex deletion problem where @xmath2 is a graph on @xmath1 vertices .",
    "first recursively find an induced subgraph of @xmath2 isomorphic to a graph in @xmath269 and branch by removing one of the vertices in the subgraph . because the maximum size of graphs in @xmath269 is @xmath35",
    ", we can find such a vertex subset in time @xmath391 if exists . in the end",
    ", we transform the instance @xmath390 into at most @xmath392 sub - instances @xmath393 such that each sub - instance consists of a @xmath269-free graph @xmath394 and a remaining budget @xmath395 .",
    "thus , this branching step takes a time @xmath36 .",
    "clearly , @xmath396 is a yes - instance if and only if one of sub - instances @xmath393 is a yes - instance .",
    "let @xmath393 be a sub - instance obtained from the branching algorithm .",
    "since @xmath394 is @xmath269-free , using the algorithm in proposition  [ prop : nltothread2 ] , we can compute a minimum lrw1-deletion set of @xmath394 and decide whether @xmath393 is a yes - instance in time @xmath397 . by checking all sub - instances",
    ", we can decide whether @xmath390 is a yes - instance in time @xmath36 .",
    "theorem  [ thm : algorithm1 ] already gives a single - exponential fpt algorithm for the lrw1-vertex deletion problem , but the polynomial factor @xmath37 makes it impractical . in the next subsection",
    ", we give an algorithm with better polynomial factor , using the branching algorithm based on a cliquewidth expression .",
    "the _ cliquewidth _ of a graph @xmath2 is the minimum number of labels needed to construct @xmath2 using the following four operations :    1 .",
    "creation of a new vertex @xmath52 with label @xmath398 ( denoted by @xmath399 ) .",
    "disjoint union of two labeled graphs @xmath2 and @xmath56 ( denoted by @xmath400 ) .",
    "3 .   joining by an edge each vertex with label @xmath398 to each vertex with label @xmath401 ( @xmath134 , denoted by @xmath402 ) .",
    "4 .   renaming label @xmath398 to @xmath401 ( denoted by @xmath403 ) .",
    "every graph can be defined by an algebraic expression using these four operations .",
    "such an expression is called a _ @xmath3-expression _ if it uses at most @xmath3 different labels .",
    "thus , the cliquewidth of @xmath2 is the minimum @xmath3 for which there exists a @xmath3-expression defining @xmath2 .",
    "= [ sibling distance=30 mm ] = [ sibling distance=15 mm ] child node @xmath404 child node @xmath405 child node @xmath406 child node @xmath404 child node @xmath407 child node @xmath404 child node @xmath408 child node @xmath409 child node @xmath410 child node @xmath404 child node @xmath411 child node @xmath412 child node @xmath413 ;    for instance , the cycle @xmath414 of length @xmath69 admits the following @xmath73-expression : @xmath415 we can represent this expression as a tree - structure , depicted in figure  [ fig : c5expression ] .",
    "we call this tree the _ labelled tree induced by the @xmath3-expression of @xmath2_.    as we need the relation between rankwidth and linear rankwidth , we define rankwidth .",
    "a tree is _ subcubic _ if it has at least two vertices and every inner vertex has degree  @xmath73 .",
    "a pair @xmath416 is called a _",
    "rank - decomposition _ of a graph @xmath2 if @xmath170 is a subcubic tree and @xmath211 is a bijection from the vertices of @xmath2 to the leaves of @xmath170 . for each edge @xmath206 in @xmath170 , @xmath417 induces a partition @xmath418 of the leaves of @xmath170 .",
    "the _ width _ of an edge @xmath206 is defined as @xmath419)$ ] .",
    "the _ width _ of a rank - decomposition @xmath420 is the maximum width over all edges of @xmath170 .",
    "the _ rankwidth _ of @xmath2 is the minimum width over all rank - decompositions of @xmath2 . if @xmath421 , then @xmath2 admits no rank - decomposition and it has rankwidth @xmath422 .",
    "the following approximation algorithm was given by oum  @xcite .",
    "[ thm : approxcw ] given a graph @xmath2 and positive integer @xmath3 , one can output a rank - decomposition of width at most @xmath423 of @xmath2 or confirm that the rankwidth of @xmath2 is larger than @xmath3 in time @xmath7 .",
    "moreover , given a rank - decomposition of a graph @xmath2 of width @xmath3 , one can output a @xmath424-expression of @xmath2 in time @xmath425 .",
    "remark that the rankwidth of a graph can be decreased by at most @xmath0 when removing a vertex , and the rankwidth of a graph is at most its linear rankwidth .",
    "thus , if a given graph has rankwidth larger than @xmath38 , then we can not make it a graph of linear rankwidth at most @xmath0 by removing at most @xmath3 vertices .",
    "therefore , using the algorithm in theorem  [ thm : approxcw ] , we can assume that the instance is given with a @xmath40-expression , and we can use it to find an induced subgraph of constant size .",
    "[ prop : inducedoncw ] let @xmath56 be a graph on @xmath426 vertices .",
    "given a graph @xmath2 with its @xmath3-expression , one can test whether @xmath2 contains an induced subgraph isomorphic to @xmath56 in time @xmath427 , and output a vertex set inducing @xmath56 if exists , in the same time complexity .",
    "let @xmath428 be the vertices of @xmath56 and @xmath429 be the edges of @xmath56 .",
    "let @xmath430 be the given @xmath3-expression defining @xmath2 , and let @xmath170 be the labelled rooted tree induced by @xmath430 .",
    "for every node @xmath205 of @xmath170 , let @xmath431 be the graph defined at node @xmath205 , and for each @xmath432 , let @xmath433 $ ] be the subgraph of @xmath431 induced on the vertices with label @xmath398 .    for every node @xmath205 and every vector @xmath434 , we define the following value :    * @xmath435 = 1 $ ] if there exists an injective mapping @xmath436 from @xmath437 to @xmath438 such that * * for each @xmath439 , @xmath440)$ ] , * * for each @xmath441 with @xmath442 , we have @xmath443 , @xmath444 , and @xmath445 , * * for each @xmath441 with @xmath446 , @xmath443 and @xmath444 , we have @xmath447 , * @xmath435 = 0 $ ] , otherwise",
    ".    the values @xmath448 $ ] will capture all possible inequivalent subgraphs of @xmath56 at @xmath431 , where two subgraphs are equivalent if their corresponding vertices are in the same labels .",
    "a vector @xmath449 is _ complete _ if for each @xmath351 and @xmath450 , @xmath193 and @xmath451 are non - zero .",
    "one can observe that @xmath2 contains an induced subgraph isomorphic to @xmath56 if and only if there is a complete vector @xmath52 such that @xmath452=1 $ ] .",
    "a vector @xmath453 is called a _ sub - vector _ of @xmath454 if for each @xmath455 and @xmath456 , @xmath457 and @xmath458 .",
    "now , we present how the values of @xmath459 $ ] are computed . at each node @xmath205 , we compute the value @xmath435 $ ] as follows .    1 .   ( creation of a new vertex @xmath25 with label @xmath398 ) each vertex of @xmath56",
    "can be mapped to @xmath25 .",
    "thus , for each vector @xmath460 where exactly one of @xmath461 is @xmath398 and @xmath462 for all @xmath463 , we assign @xmath464:=1 $ ] and for all other vectors , assign @xmath464:=0 $ ] .",
    "2 .   ( disjoint union node with two children @xmath465 ) we take all possible two sub - vectors @xmath466 and @xmath467 of @xmath454 such that",
    "* for each @xmath455 , if @xmath468 is non - zero , then exactly one of @xmath469 and @xmath470 is equal to @xmath468 , and the same thing holds for @xmath471 , @xmath472 , and @xmath473 .",
    "+ we assign @xmath464:=1 $ ] if there exist such @xmath195 where @xmath474=c[t_2 , v_2]=1 $ ] , and @xmath464:=0 $ ] otherwise .",
    "this formula holds because @xmath431 contains a subgraph @xmath475 if and only if there is a vertex partition @xmath476 and @xmath477 of @xmath475 with no edges between @xmath476 and @xmath477 such that @xmath478 $ ] is a subgraph of @xmath479 and @xmath480 $ ] is a subgraph of @xmath481 ( @xmath476 or @xmath477 may be an empty set ) .",
    "this also implies that for a vector @xmath52 with @xmath482 and @xmath483 , it suffices to consider a pair @xmath484 which satisfies either of the following : @xmath485 , or @xmath486 .",
    "+ note that there are at most @xmath487 possible pair of vectors .",
    "thus , we need @xmath487 iterations to compute @xmath488 $ ] for fixed @xmath52 . in total , we need @xmath489 iterations to compute @xmath488 $ ] for all @xmath52 .",
    "( join node with the child @xmath490 such that each vertex with label @xmath398 is joined to each vertex with label @xmath401 ) if there are @xmath491 and @xmath463 where @xmath483 with @xmath492 , @xmath493 and @xmath462 , then we assign @xmath488:=0 $ ] .",
    "this correctly assigns the value as two vertices with labels @xmath398 and @xmath401 should be adjacent at this join node .",
    "we can check it in time @xmath494 .",
    "now , we assume that the given vector @xmath52 satisfies that for all @xmath491 and @xmath463 with @xmath483 with @xmath492 and @xmath493 , we have @xmath482 .",
    "+ we take all sub - vectors @xmath495 of @xmath454 such that for @xmath463 , * @xmath496 if @xmath483 with @xmath492 , @xmath493 , and @xmath482 , and * @xmath497 otherwise .",
    "+ then we assign @xmath464:=1 $ ] if there exists such @xmath498 where @xmath499=1 $ ] , and @xmath464:=0 $ ] otherwise .",
    "this formula holds because @xmath431 contains a subgraph @xmath475 if and only if @xmath500 contains a subgraph @xmath501 where @xmath475 is obtained from @xmath501 by adding edges between @xmath502)$ ] and @xmath503)$ ] .",
    "+ note that there are at most @xmath504 possible sub - vectors .",
    "thus , we need @xmath505 iterations to compute @xmath488 $ ] for all @xmath52 .",
    "4 .   ( renaming label @xmath398 to @xmath401 )",
    "if there is @xmath506 with @xmath507 , then we assign @xmath488:=0 $ ] .",
    "this correctly assigns the value as there is no vertex with label @xmath398 at this node .",
    "we can check it in time @xmath508 .",
    "we assume that the given vector @xmath52 satisfies that for all @xmath506 , @xmath509 .",
    "+ for each vector @xmath454 , we take all sub - vectors @xmath510 of @xmath454 such that for @xmath506 , * @xmath511 if @xmath512 , and * @xmath513 otherwise .",
    "+ we assign @xmath464:=1 $ ] if there exists such @xmath498 where @xmath499=1 $ ] , and @xmath464:=0 $ ] otherwise .",
    "this formula trivially holds as we just change the labels on vertices .",
    "+ note that there are @xmath514 possible vectors .",
    "thus , we need @xmath515 iterations to compute @xmath488 $ ] for all @xmath52 .",
    "finally , we can test whether @xmath2 contains an induced subgraph isomorphic to @xmath56 by checking whether there is a complete vector @xmath52 such that @xmath452=1 $ ] .",
    "thus , we can find an induced subgraph of @xmath2 isomorphic to @xmath56 in time @xmath427 , if exists .",
    "also , if we find such a vector @xmath52 , then we can track which vertices are contributed to make the vector @xmath52 , and thus , we can compute a vertex set inducing @xmath56 in the same time complexity .",
    "now , we give a second fpt algorithm for the lrw1-vertex deletion problem .",
    "[ thm : algorithm2 ] the lrw1-vertex deletion problem can be solved in @xmath7 time .",
    "all procedures in the algorithm will be same as in theorem  [ thm : algorithm1 ] except the refined branching algorithm .",
    "let @xmath390 be an instance where @xmath2 is a graph on @xmath1 vertices . using the algorithm in theorem  [ thm : approxcw ]",
    ", we can decide whether the rankwidth of @xmath2 is at most @xmath38 in time @xmath7 .",
    "if the rankwidth of the input graph is more than @xmath38 , then we can not make it a graph of linear rankwidth at most @xmath0 by removing at most @xmath3 vertices .",
    "thus , we say that it is a no - instance in this case .",
    "otherwise , the algorithm outputs a @xmath40-expression @xmath430 of @xmath2 .",
    "let @xmath170 be the labelled rooted tree induced by @xmath430 .",
    "for convenience let @xmath516 .",
    "let us fix a graph @xmath56 in @xmath269 .",
    "note that @xmath517 . using the algorithm in proposition  [ prop : inducedoncw ]",
    ", we can test whether @xmath2 contains an induced subgraph isomorphic to @xmath56 and outputs a vertex set inducing @xmath56 if exists , in time @xmath518 .",
    "if there is such a vertex set @xmath47 , then branch by removing one of the vertices @xmath52 in @xmath47 and decrease @xmath3 by @xmath0 . note that we can obtain the cliquewidth expression for @xmath519 from @xmath430 just by removing the node introducing @xmath52 .",
    "we recurse this branching algorithm until there are no such vertex sets @xmath47 . combining the remaining steps described in the proof of theorem  [ thm : algorithm1 ] ,",
    "it is easy to verify that the lrw1-vertex deletion problem can be solved in time @xmath7 .",
    "in this section , we show that the algorithm in theorem  [ thm : main1 ] is best possible in some sense . our lower bound is based on a well - known complexity hypothesis formulated by impagliazzo , paturi , and zane  @xcite .    *",
    "exponential time hypothesis ( eth ) .",
    "* there is a constant @xmath520 such that 3-cnf - sat with @xmath1 variables and @xmath521 clauses can not be solved in time @xmath522 .",
    "we use the known lower bound for the vertex cover problem .",
    "[ thm : vclow ] there is no @xmath8-time algorithm for vertex cover , unless eth fails .",
    "we show the following .",
    "there is no @xmath8-time algorithm for lrw1 vertex deletion , unless eth fails .",
    "for contradiction , suppose there exists an algorithm for solving the lrw1-vertex deletion problem in time @xmath8 .",
    "let @xmath390 be an instance of the vertex cover problem .",
    "we construct a graph @xmath394 from @xmath2 as follows :    1 .   for every vertex @xmath281 ,",
    "add a pendant vertex @xmath498 adjacent to @xmath52 , and 2 .   for every edge @xmath198 in @xmath2 , we replace it with two vertex disjoint paths of length 2 from @xmath52 to @xmath25 .",
    "let @xmath394 be the resulting graph .",
    "note that for each edge @xmath198 in @xmath2 , @xmath523 and two disjoint paths of length @xmath72 from @xmath52 to @xmath25 in @xmath394 form an induced subgraph isomorphic to @xmath311 .",
    "we have @xmath524 .",
    "we claim that @xmath2 has a vertex set @xmath47 of size at most @xmath3 such that @xmath167 has no edges if and only if @xmath394 has a lrw1-deletion set  of size at most @xmath3 .",
    "suppose that @xmath2 has a vertex set @xmath47 of size at most @xmath3 such that @xmath167 has no edges .",
    "it is easy to confirm that @xmath525 is a disjoint union of stars , which has linear rankwidth at most @xmath0 .",
    "for the converse direction , suppose that @xmath394 has a lrw1-deletion set  @xmath47 of size at most @xmath3 .",
    "if @xmath47 contains a vertex of degree @xmath0 , then we can replace it with its neighbor .",
    "we may assume that @xmath47 has no pendant vertices of @xmath394 .",
    "let @xmath198 be an edge of @xmath2 and @xmath526 be the vertices of degree @xmath72 that are adjacent to @xmath52 and @xmath25 in @xmath394 .",
    "as @xmath47 does not contain pendant vertices of @xmath394 , we have @xmath527 , otherwise , @xmath394 contains an induced subgraph isomorphic to @xmath311 . for each edge @xmath198 , if @xmath47 contains one of @xmath526 , then we replace it with one of @xmath52 and @xmath25",
    ". let @xmath528 be the resulting set .",
    "then @xmath529 and @xmath530 contains at least one of @xmath52 and @xmath25 for each edge @xmath198 of @xmath2 .",
    "we conclude that @xmath2 has a vertex set @xmath47 of size at most @xmath3 such that @xmath167 has no edges .",
    "therefore , using the algorithm for the lrw1-vertex deletion problem , we can decide whether @xmath390 is a yes - instance of the vertex cover problem , in time @xmath8 , which is not possible unless eth fails by theorem  [ thm : vclow ] .",
    "in this section , we show the following .",
    "[ thm : main22 ] the lrw1-vertex deletion problem has a kernel with @xmath34 vertices .",
    "we use the sunflower lemma to find a hitting set for obstructions of small size with a special property .",
    "it consists in finding a subset @xmath170 with size bounded by @xmath531 for some function @xmath5 whose removal turns @xmath2 into a graphs of linear rankwidth at most @xmath0 with the property that for every set @xmath58 of size at most @xmath3 , the following are equivalent ( lemma  [ lem : shrink ] ) :    * @xmath47 is a minimal vertex set such that @xmath167 has no obstructions in @xmath269 .",
    "* @xmath47 is a minimal vertex set such that @xmath532\\setminus s$ ] has no obstructions in @xmath269 .",
    "this property implies that if there is a minimal lrw1-deletion set @xmath47 , then each vertex of @xmath533 should be used to remove at least one long induced cycle .",
    "it will be used to find an irrelevant vertex in a large thread block in @xmath534 .",
    "moreover , we can preprocess the instance so that there is no small obstruction containing exactly one vertex of @xmath170 .",
    "this will be used to bound the length of the sequence of thread blocks in each connected component .",
    "let @xmath396 be an instance of lrw@xmath0-vertex deletion .",
    "we start with an easy reduction rule .",
    "[ rule : threadcomponent ] if @xmath2 has a connected component that has linear rankwidth at most @xmath0 , then we remove it from @xmath2 .",
    "let @xmath171 be a family of subsets over a set @xmath535 .",
    "a subset @xmath536 is called _ a hitting set _ of @xmath171 if for every set @xmath537 , @xmath538 . for a graph @xmath2 and a family of graphs @xmath171 , a set @xmath58",
    "is also called _ a hitting set _ for @xmath171 if for every induced subgraph @xmath56 of @xmath2 that is isomorphic to a graph in @xmath171 , @xmath539 .",
    "the following lemma can be obtained from the sunflower lemma .",
    "[ lem : fomin ] let @xmath171 be a family of sets of size at most @xmath540 over a set @xmath535 , and let @xmath3 be a positive integer .",
    "then in time @xmath541 , we can find a nonempty set @xmath542 such that    1 .",
    "for every @xmath536 of size at most @xmath3 , @xmath543 is a minimal hitting set of @xmath171 if and only if @xmath543 is a minimal hitting set of @xmath544 , and 2 .",
    "@xmath545 .",
    "using proposition  [ prop : nltothread2 ] and lemma  [ lem : fomin ] , we identify a vertex set @xmath170 of @xmath2 with size polynomial in @xmath3 that allows us to forget about small obstructions .",
    "[ lem : shrink ] let @xmath390 be an instance of lrw@xmath0-vertex deletion .",
    "there is a polynomial time algorithm that either concludes that @xmath390 is a no - instance or finds a non - empty set @xmath546 such that    1 .",
    "@xmath534 has linear rankwidth at most @xmath0 , 2 .   for every set @xmath58 of size at most @xmath3 ,",
    "@xmath47 is a minimal hitting set for @xmath269 in @xmath2 if and only if it is a minimal hitting set for @xmath269 contained in @xmath532 $ ] , and 3 .",
    "@xmath547 .",
    "let @xmath171 be the set of vertex sets @xmath47 of @xmath2 such that @xmath48 $ ] is isomorphic to a graph in @xmath269 .",
    "since the maximum size of a set in @xmath59 is @xmath35 , using lemma  [ lem : fomin ] , we can find a subset @xmath548 of @xmath59 such that    1 .   for every vertex subset @xmath549 of size at most @xmath3",
    ", @xmath550 is a minimal hitting set of @xmath171 if and only if @xmath550 is a minimal hitting set of @xmath544 , and 2 .",
    "@xmath551 .",
    "let @xmath552 . from the condition 1",
    ", @xmath553 has no induced subgraph isomorphic to a graph in @xmath269 and by theorem  [ thm : mainlrw ] , @xmath553 is a necklace graph . using the algorithm in proposition  [ prop : nltothread2 ]",
    ", we can find a minimum lrw1-deletion set @xmath554 of @xmath553 in polynomial time .",
    "if @xmath555 , then we conclude that @xmath390 is a no - instance .",
    "otherwise , we add @xmath554 to @xmath556 , increasing its size by at most @xmath3 .",
    "we conclude that @xmath557 is a required set .",
    "let us fix a subset @xmath170 of @xmath42 obtained by lemma  [ lem : shrink ] .",
    "we preprocess using the following reduction rule .",
    "[ rule : onevertex ] let @xmath558 such that for every @xmath559 , there exists an induced subgraph @xmath56 of @xmath2 isomorphic to a graph in @xmath269 with @xmath560 .",
    "if @xmath561 , then @xmath396 is a no - instance ; otherwise , remove @xmath535 from @xmath2 and reduce @xmath3 by @xmath562 , and use @xmath563 instead of @xmath170 .",
    "it can be done in polynomial time because we only need to look at obstructions of @xmath269 in @xmath2 .",
    "[ lem : oneintersect ] reduction rule  [ rule : onevertex ] is safe .",
    "we claim that every minimal lrw1-deletion set in @xmath2 contains @xmath535 .",
    "let @xmath47 be a minimal lrw1-deletion set in @xmath2 .",
    "then there exists a vertex subset @xmath564 such that @xmath528 is a minimal hitting set for graphs of @xmath269 in @xmath532 $ ] . from the property of @xmath170",
    ", @xmath528 is also a minimal hitting set for graphs of @xmath269 in @xmath2 , and we must have @xmath565 as @xmath528 hits the sets @xmath566 for each @xmath559 .",
    "it implies that if @xmath567 , then @xmath396 is a no - instance . otherwise , since @xmath535",
    "is always contained in any minimal lrw1-deletion set of @xmath2 , we have that @xmath390 is a yes - instance if and only if @xmath568 is a yes - instance .    from now on",
    ", we assume that @xmath2 is reduced under reduction rules  [ rule : threadcomponent ] and [ rule : onevertex ] .",
    "a vertex @xmath52 of @xmath2 is called _ irrelevant _ if @xmath396 is a yes - instance if and only if @xmath569 is a yes - instance . for convenience ,",
    "let @xmath570 .",
    "we first show that if a thread block in @xmath534 is large , then we can always find an irrelevant vertex in there .",
    "[ prop : irrelevant ] if @xmath534 contains a thread block of size at least @xmath571 , then we can find an irrelevant vertex in polynomial time .",
    "we use the following lemma .",
    "[ lem : diamond ] let @xmath2 be a graph and let @xmath572 be an induced path of length @xmath158 in @xmath2 .",
    "if two distinct vertices @xmath573 in @xmath574 are adjacent to @xmath307 and @xmath308 , then @xmath309 contains an induced subgraph isomorphic to a graph in @xmath269 .",
    "see figure  [ fig : lemma65 ] for the following cases . if @xmath70 is adjacent to @xmath575 but not adjacent to @xmath576 , then @xmath577 is an induced path of length @xmath73 and @xmath575 is adjacent to its end vertices . by lemma  [ lem : pathtoobs ] , @xmath578 $ ] has an induced subgraph isomorphic to a graph in @xmath269 .",
    "considering all symmetric cases , we may assume that for each @xmath579 , @xmath52 is adjacent to both @xmath573 or neither of them .",
    "depending on the adjacency between @xmath580 and @xmath581 , and the adjacency between @xmath575 and @xmath576 , we have one of the @xmath582 graphs in @xmath269 , which are @xmath583 .    .",
    "]    suppose that @xmath534 contains a thread block of size at least @xmath571 .",
    "we can find such a thread block @xmath584 and compute its ordering @xmath89 and labeling @xmath102 in polynomial time using the algorithm in lemma  [ lem : splittreetothreadblock ] .",
    "let @xmath585 be the first and last vertices of @xmath584 and let @xmath586 be the ordering obtained from @xmath89 by removing @xmath46 and @xmath110 .",
    "we mark some vertices of @xmath584 as follows .",
    "we set @xmath587 .    1 .   for each vertex @xmath52 of @xmath170",
    ", choose the first @xmath588 vertices @xmath589 of @xmath586 that are neighbors of @xmath52 with @xmath590 , and choose the last @xmath588 vertices @xmath589 of @xmath586 that are neighbors of @xmath52 with @xmath591 , and add them to @xmath592 .",
    "2 .   for each pair of two vertices @xmath52 , @xmath498 in @xmath170 , choose @xmath588 common neighbors of @xmath52 and @xmath498 in @xmath584 , and add them to @xmath592 .",
    "3 .   choose the first @xmath588 vertices @xmath589 of @xmath586 with @xmath590 , and choose the last @xmath588 vertices @xmath589 of @xmath586 with @xmath591 , and add them to @xmath592 .    in each case ,",
    "if there are at most @xmath38 such vertices , then we add all of them to @xmath592 .",
    "then @xmath593 since @xmath594 , there exists a vertex @xmath25 in @xmath595 .",
    "we claim that @xmath25 is an irrelevant vertex .",
    "if @xmath390 is a yes - instance , then @xmath596 is clearly a yes - instance .",
    "suppose that there is a vertex set @xmath597 with @xmath598 such that @xmath599 is a thread graph .",
    "we may assume that @xmath600 is not a thread graph .",
    "so , @xmath600 has an induced subgraph containing @xmath25 that is isomorphic to a graph in @xmath164 .",
    "let @xmath601 be a minimal hitting set for @xmath269 in @xmath2 . from the property of the set @xmath170",
    ", @xmath83 is a minimal hitting set for @xmath269 in @xmath532 $ ] , which implies that @xmath602 .",
    "thus @xmath600 must have an induced cycle of length at least @xmath270 that contains @xmath25 .",
    "let @xmath266 be an induced cycle of length at least @xmath270 containing @xmath25 in @xmath600 .",
    "we will find an induced subgraph of @xmath599 that is isomorphic to a graph in @xmath269 , which leads to a contradiction .",
    "let @xmath603 be the consecutive vertices on @xmath266 . to apply lemma  [ lem : diamond ]",
    ", we find two vertices that are adjacent to @xmath307 and @xmath71 .",
    "these cases are depicted in figure  [ fig : irrelevant ] .    1 .",
    "@xmath604 . )",
    "since @xmath307 and @xmath71 have a common neighbor @xmath25 in @xmath605 , @xmath592 contains at least @xmath588 common neighbors of @xmath307 and @xmath71 . since @xmath598 , there exist two vertices @xmath606 that are common neighbors of @xmath307 and @xmath71 .",
    "2 .   ( case 2 .",
    "one of @xmath307 and @xmath71 is contained in @xmath170 . ) from the symmetry , we may assume that @xmath607 and @xmath608 .",
    "since @xmath609 , @xmath71 is contained in @xmath584 .",
    "if @xmath157 and @xmath610 , then @xmath592 contains the first @xmath588 vertices @xmath589 of @xmath586 that are neighbors of @xmath307 with @xmath590 .",
    "we choose two vertices of them that are not in @xmath550 . in case",
    "when @xmath98 and @xmath611 , we use the last @xmath588 vertices @xmath589 of @xmath586 that are neighbors of @xmath307 with @xmath591 to identify two vertices similarly .",
    "3 .   ( case 3 .",
    "neither @xmath307 nor @xmath71 is contained in @xmath170 . ) since @xmath609 , @xmath307 and @xmath71 are contained in @xmath584 .",
    "if @xmath612 , then @xmath613 , @xmath614 and it implies that @xmath615 , which is a contradiction . also , @xmath616 can not happen",
    "thus , both of @xmath307 and @xmath71 appear either before @xmath25 in @xmath89 or after @xmath25 in @xmath89 . by the symmetry",
    ", we may assume that @xmath307 and @xmath71 appear before @xmath25 in @xmath89 .",
    "so , @xmath613 , @xmath617 , and @xmath98 .",
    "since @xmath592 contains the last @xmath588 vertices @xmath589 of @xmath586 with @xmath591 , there exist two vertices @xmath573 from those @xmath588 vertices that are not in @xmath550 and @xmath266 .    in all cases , @xmath599 has an induced subgraph isomorphic to a graph in @xmath269 by lemma  [ lem : diamond ] .",
    "it contradicts to the assumption that @xmath618 is a lrw1-deletion set of @xmath2 .",
    "therefore , @xmath600 is a thread graph , and we conclude that @xmath396 is a yes - instance .    in the next lemma , we show that if a vertex @xmath52 in @xmath170 has neighbors on @xmath619 distinct blocks in a connected component of @xmath534 , then we can find a subgraph @xmath56 isomorphic to one of @xmath620 such that @xmath621 , which is not possible by reduction rule  [ rule : onevertex ] .",
    "using it , whenever a connected component of @xmath534 has a long sequence of thread blocks , we can identify a sequence of consecutive thread blocks not touched by any obstruction in @xmath269 .",
    "this allows us to contract one of these thread blocks to a vertex .",
    "[ lem : reducelength ] if @xmath534 has a connected component with at least @xmath622 thread blocks , then we can in polynomial time transform @xmath2 into a graph @xmath394 with @xmath623 such that @xmath396 is a yes - instance if and only if @xmath624 is a yes - instance .",
    "suppose that @xmath534 has a connected component @xmath56 such that @xmath56 consists of at least @xmath625 thread blocks .",
    "we can find such a connected component in polynomial time using the algorithm in lemma  [ lem : splittreetothreadblock ] , if exists .",
    "let @xmath626 be the sequence of thread blocks of @xmath56 .",
    "we claim that every vertex @xmath52 of @xmath170 has neighbors in at most @xmath582 thread blocks of @xmath56 . for contradiction ,",
    "suppose that there is a vertex @xmath52 in @xmath170 having neighbors in at least @xmath619 thread blocks .",
    "then there are three thread blocks @xmath627 having a neighbor of @xmath52 in @xmath2 such that @xmath628 and @xmath629 . for each @xmath630",
    ", let @xmath631 be a neighbor of @xmath52 in @xmath632 . since each thread block consists of at least two vertices , we can choose a neighbor @xmath633 of @xmath631 in @xmath632 for each @xmath630 . depending on the adjacency between @xmath52 and the vertices @xmath634 , we have an induced subgraph isomorphic to a graph in @xmath635 such that it has exactly one vertex of @xmath170 .",
    "this contradicts to the assumption that @xmath396 is an instance reduced by reduction rule  [ rule : onevertex ] .",
    "now , for each vertex @xmath52 of @xmath170 , we mark the thread blocks @xmath584 of @xmath56 containing a neighbor of @xmath52 .",
    "since the number of thread blocks in @xmath56 is at least @xmath636 and @xmath637 , there exist @xmath638 and @xmath639 such that @xmath640 are non - marked thread blocks .",
    "let @xmath641 be the two end vertices of @xmath642 .",
    "we transform the graph @xmath2 into a graph @xmath394 by removing the thread block @xmath643 and adding a new vertex @xmath589 that are adjacent to @xmath644 .",
    "let @xmath475 be the connected component of @xmath645 that is modified from the connected component @xmath56 of @xmath534 .",
    "since we remove at least two vertices from @xmath2 and add one vertex , we have @xmath623 .",
    "we show that @xmath396 is a yes - instance if and only if @xmath646 is a yes - instance .",
    "suppose that @xmath2 has a minimal thread vertex set @xmath550 .",
    "we first assume that @xmath550 contains a vertex @xmath647 in @xmath643 .",
    "since @xmath550 is a minimal lrw1-deletion set and all small obstructions of @xmath269 are contained in @xmath648 , @xmath647 hits an induced cycle of length at least @xmath270 in @xmath2 , and the cycle must pass through the vertices @xmath46 and @xmath110 .",
    "thus , @xmath649 is a lrw1-deletion set of @xmath394 with size at most @xmath650 .",
    "assume that @xmath651 .",
    "we may assume that @xmath652 is not a thread graph .",
    "then @xmath652 must have an induced cycle @xmath266 of length at least @xmath270 intersecting the new vertex @xmath589 .",
    "the cycle obtained from @xmath266 by replacing @xmath589 with the edge @xmath107 is also an induced cycle of length at least @xmath270 in @xmath600 .",
    "it contradicts to the assumption that @xmath600 is a thread graph .",
    "now suppose that @xmath394 has a minimal lrw1-deletion set @xmath550 .",
    "if @xmath653 , then @xmath589 hits an induced cycle of length at least @xmath270 in @xmath394 because of the minimality of @xmath550 and the distance from @xmath46 to the end vertices of @xmath654 and @xmath655 . because @xmath46 hits all induced cycles of length at least @xmath270 in @xmath2 having a vertex of @xmath643 , @xmath656 is again a lrw1-deletion set of @xmath2 .",
    "assume that @xmath657 .",
    "we may assume that @xmath600 is not a thread graph .",
    "so , @xmath600 has an induced cycle @xmath266 of length at least @xmath270 passing through @xmath46 and @xmath110 .",
    "let @xmath658 be the cycle obtained from @xmath266 by replacing the edge @xmath107 with the vertex @xmath589 .",
    "this cycle @xmath658 clearly exists in @xmath652 and it has length at least @xmath270 because it should contain at least one vertex from the thread blocks @xmath659 with @xmath660 .",
    "this contradicts to the assumption that @xmath652 is a thread graph .",
    "we conclude that @xmath390 is a yes - instance if and only if @xmath646 is a yes - instance .",
    "we bound the number of connected components using the following lemma .",
    "[ lem : reducecomponent1 ]    1 .",
    "the graph @xmath534 has at most @xmath661 connected components containing at least two vertices .",
    "2 .   if @xmath534 has at least @xmath662 isolated vertices , then we can find an irrelevant vertex in polynomial time .",
    "\\(1 ) by reduction rule  [ rule : threadcomponent ] , each connected component @xmath56 of @xmath534 contains a vertex that has a neighbor in @xmath170 .",
    "let @xmath663 be the set of connected components of @xmath534 which consist of at least two vertices , and suppose that @xmath664 .",
    "since every connected component of @xmath56 has a vertex having a neighbor in @xmath170 , there exists a vertex @xmath665 such that @xmath175 has neighbors in three distinct connected components of @xmath663 .",
    "since each connected component of @xmath663 has at least two vertices , @xmath2 has a vertex set @xmath47 where @xmath48 $ ] is isomorphic to a graph in @xmath635 and @xmath666 .",
    "it contradicts to the assumption that @xmath396 is reduced by reduction rule  [ rule : onevertex ] .",
    "\\(2 ) suppose that @xmath534 has at least @xmath662 isolated vertices .",
    "let @xmath47 be the union of isolated vertices in @xmath534 .",
    "we may assume that every vertex in @xmath47 has a neighbor in @xmath170 .",
    "we define a set @xmath592 to identify an irrelevant vertex . for each pair of two vertices in @xmath170 , choose @xmath588 common neighbors in @xmath47 , and add them to @xmath592 .",
    "if there are at most @xmath38 common neighbors , then we add all of them into @xmath592 .",
    "since @xmath667 , there is a vertex @xmath25 in @xmath668 .",
    "we claim that @xmath25 is an irrelevant vertex of the problem .",
    "if @xmath396 is a yes - instance , then there exists a vertex subset @xmath550 of size at most @xmath3 in @xmath2 such that @xmath600 is a thread graph . since @xmath599 is also a thread graph",
    ", @xmath596 is a yes - instance .",
    "suppose that @xmath596 is a yes - instance .",
    "we choose a minimal vertex set @xmath550 in @xmath669 such that @xmath598 and @xmath599 is a thread graph .",
    "we may assume that @xmath600 is not a thread graph .",
    "let @xmath601 be a hitting set for @xmath269 in @xmath532 $ ] .",
    "then by the property of @xmath170 , @xmath83 also hits all induced subgraphs in @xmath2 that are isomorphic to a graph of @xmath269 .",
    "since @xmath550 already hits all small obstructions in @xmath2 , there exists an induced cycle @xmath266 of length at least @xmath270 in @xmath600 containing @xmath25 .",
    "let @xmath573 be the neighbors of @xmath25 on the cycle @xmath266 . since @xmath573 have @xmath588 common neighbors in @xmath592 , we may choose two vertices @xmath670 that are common neighbors of @xmath575 and @xmath576 . by lemma  [ lem : diamond ]",
    ", we have that @xmath599 has an induced subgraph isomorphic to a graph in @xmath269 , which implies that @xmath599 is not a thread graph .",
    "it is a contradiction , and we conclude that @xmath390 is a yes - instance .",
    "let us now piece everything together and analyze the kernel size .",
    "let @xmath396 be an instance of lrw1-vertex deletion . by reduction rule  [ rule :",
    "threadcomponent ] , we may safely assume that @xmath2 has no connected components that are thread graphs . then using the algorithm in lemma  [ lem : shrink ] , in polynomial time ,",
    "either we conclude that @xmath390 is a no - instance or find a non - empty set @xmath546 stated in lemma  [ lem : shrink ] .",
    "we apply reduction rule  [ rule : onevertex ] .",
    "[ lem : oneintersect ] guarantees that for every vertex set @xmath58 such that @xmath48 $ ] is isomorphic to a graph in @xmath635 , @xmath671 .    combining proposition  [ prop : irrelevant ] and lemma  [ lem : reducelength ]",
    ", we can assume that every connected component of @xmath534 has size at most @xmath672 ( otherwise the instance can be reduced in polynomial time ) .",
    "note that for each connected component @xmath56 of @xmath534 , there exists a vertex in @xmath56 that has a neighbor in @xmath170 .",
    "therefore , by lemma  [ lem : reducecomponent1 ] , the number of non - trivial components of @xmath534 is at most @xmath661 and the number of isolated vertices in @xmath534 is at most @xmath673 .",
    "it follows that @xmath674",
    "we consider the problem linear rankwidth-@xmath25 vertex deletion when @xmath675 .",
    "a next step is to investigate the problem for bigger @xmath25 , or for any fixed @xmath25 .",
    "a closely related problem is rankwidth-@xmath25 vertex deletion , which asks whether @xmath2 has a vertex subset of size at most @xmath3 such that @xmath167 has rankwidth at most @xmath25 .",
    "( linear ) rankwidth-@xmath25 vertex deletion is fixed - parameter tractable for the following reason .",
    "note that any yes - instance has rankwidth at most @xmath676 .",
    "having bounded ( linear ) rankwith can be characterized by a finite list of forbidden vertex - minors  @xcite . from  @xcite , having a vertex - minor can be expressed in @xmath677 , i.e. , monadic second order logic without edge set quantification where we can express the parity of @xmath678 for a vertex set @xmath550 .",
    "fixed - parameter tractability follows as a consequence of courcelle , makowsky , rotics  @xcite .    as for rankwidth",
    ", this result can be turned into a constructive algorithm as  @xcite provides an explicit upper bound on the size of vertex - minor obstructions for rankwidth at most @xmath3 for fixed @xmath3 . however , the exponential blow - up in the running time is huge with respect to both @xmath25 and @xmath3 .",
    "it is a challenging question whether a reasonable dependency on @xmath3 can be achieved .",
    "a single - exponential time would be ideal , which was achievable for its treewidth counterpart .",
    "a first realistic goal is to consider the case when @xmath675 , that is , the distance - hereditary vertex deletion .",
    "we leave it as an open question whether this problem can be solved in time @xmath679 time for some constant @xmath13 . for linear rankwidth",
    ", there is no known upper bound on the size of vertex - minor obstructions for linear rankwidth at most @xmath3 , and thus , obtaining such an upper bound is an interesting open question .",
    "the third author would like to thank sang - il oum for suggesting the refined branching algorithm using cliquewidth .",
    "i.  adler , m.  m. kant , and o.  kwon .",
    "linear rank - width of distance - hereditary graphs . in _",
    "graph - theoretic concepts in computer science - 40th international workshop , wg 2014 , nouan - le - fuzelier , france , june 25 - 27 , 2014 . revised selected papers _ ,",
    "pages 4255 , 2014 .",
    "unit interval editing is fixed - parameter tractable . in m.",
    "m. halldrsson , k.  iwama , n.  kobayashi , and b.  speckmann , editors , _ automata , languages , and programming _ , volume 9134 of _ lecture notes in computer science _ , pages 306317 .",
    "springer berlin heidelberg , 2015 .",
    "v.  chvtal and p.  l. hammer .",
    "aggregation of inequalities in integer programming . in _ studies in integer programming ( proc .",
    "workshop , bonn , 1975 ) _ , pages 145162 . ann . of discrete math .",
    "1 . north - holland , amsterdam , 1977 .",
    "f.  v. fomin , d.  lokshtanov , n.  misra , and s.  saurabh .",
    "planar f - deletion : approximation , kernelization and optimal fpt algorithms . in _",
    "53rd annual ieee symposium on foundations of computer science , focs 2012 , new brunswick , nj , usa , october 20 - 23 , 2012 _ , pages 470479 , 2012 .            s.  gaspers and s.  szeider .",
    "backdoors to satisfaction . in _ the multivariate algorithmic revolution and beyond - essays dedicated to michael r. fellows on the occasion of his 60th birthday _ , pages 287317 , 2012 .",
    "j.  jeong , e.  j. kim , and s.  oum .",
    "constructive algorithm for path - width of matroids . in r.",
    "krauthgamer , editor , _ proceedings of the twenty - seventh annual acm - siam symposium on discrete algorithms , soda 2016 , arlington , va , usa , january 10 - 12 , 2016 _ , pages 16951704 .",
    "siam , 2016 .",
    "m.  m. kant , e.  j. kim , o.  kwon , and c.  paul . . in t.",
    "husfeldt and i.  kanj , editors , _ 10th international symposium on parameterized and exact computation ( ipec 2015 ) _ , volume  43 of _ leibniz international proceedings in informatics ( lipics ) _ , pages 138150 , dagstuhl , germany , 2015 .",
    " leibniz - zentrum fuer informatik .",
    "e.  j. kim , a.  langer , c.  paul , f.  reidl , p.  rossmanith , i.  sau , and s.  sikdar .",
    "linear kernels and single - exponential algorithms via protrusion decompositions . in _",
    "automata , languages , and programming - 40th international colloquium , icalp 2013 , riga , latvia , july 8 - 12 , 2013 , proceedings , part i _ , pages 613624 , 2013 .",
    "g.  philip , v.  raman , and y.  villanger . a quartic kernel for pathwidth - one vertex deletion . in d.",
    "thilikos , editor , _ graph theoretic concepts in computer science _ ,",
    "volume 6410 of _ lecture notes in computer science _ ,",
    "pages 196207 .",
    "springer berlin heidelberg , 2010 .",
    "r.  van bevern , c.  komusiewicz , h.  moser , and r.  niedermeier .",
    "measuring indifference : unit interval vertex deletion . in",
    "_ graph - theoretic concepts in computer science _ , volume 6410 of _ lecture notes in comput",
    "_ , pages 232243 .",
    "springer , berlin , 2010 ."
  ],
  "abstract_text": [
    "<S> _ linear rankwidth _ is a linearized variant of rankwidth , introduced by oum and seymour [ approximating clique - width and branch - width . , 96(4):514528 , 2006 ] . </S>",
    "<S> motivated from recent development on graph modification problems regarding classes of graphs of bounded treewidth or pathwidth , we study the linear rankwidth-@xmath0 vertex deletion problem ( shortly , lrw1-vertex deletion ) . in the lrw1-vertex deletion problem , given an @xmath1-vertex graph @xmath2 and a positive integer @xmath3 , we want to decide whether there is a set of at most @xmath3 vertices whose removal turns @xmath2 into a graph of linear rankwidth at most @xmath0 and find such a vertex set if one exists . while the meta - theorem of courcelle , makowsky , and rotics implies that lrw1-vertex deletion can be solved in time @xmath4 for some function @xmath5 , it is not clear whether this problem allows a running time with a modest exponential function .    </S>",
    "<S> we first establish that lrw1-vertex deletion can be solved in time @xmath6 . </S>",
    "<S> the major obstacle to this end is how to handle a long induced cycle as an obstruction . to fix this issue </S>",
    "<S> , we define _ necklace graphs _ and investigate their structural properties . </S>",
    "<S> later , we reduce the polynomial factor by refining the trivial branching step based on a cliquewidth expression of a graph , and obtain an algorithm that runs in time @xmath7 . we also prove that the running time can not be improved to @xmath8 under the exponential time hypothesis assumption . </S>",
    "<S> lastly , we show that the lrw1-vertex deletion problem admits a polynomial kernel . </S>"
  ]
}