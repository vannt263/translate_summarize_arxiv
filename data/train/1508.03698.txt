{
  "article_text": [
    "comparison based sorting algorithms is one of the most studied area in theoretical computer science .",
    "however , the majority of the efforts have been focused on the uniform comparison cost model .",
    "arbitrary non - uniform cost models can make trivial problems non - trivial , like finding the minimum @xcite .",
    "thus it makes sense to consider a more structured cost .",
    "for example , a common cost model is the monotone cost model . as shown in @xcite",
    "the best one can do is to get an algorithm that is within a logarithmic factor of a cost optimal algorithm .",
    "however , the 1-@xmath0 cost model in this paper is not monotonic .",
    "this model has comparison cost of 1 or @xmath0 .",
    "a pair with cost @xmath0 is considered a `` forbidden pair '' .",
    "the set of pairs with comparison cost 1 , defines an undirected graph , @xmath2 , where @xmath1 is the set of keys and @xmath11 represents the allowed comparisons .",
    "we call @xmath12 the comparison graph . define @xmath13 to be the set of forbidden pairs .",
    "let @xmath14 and @xmath15 .",
    "an example of a problem that uses this model is the nuts and bolts problem .",
    "this is strictly not a sorting problem rather a matching one . in this problem one",
    "is given two sets of elements , a set of nuts and a set bolts .",
    "elements in each set have distinct sizes and for each nut it is guaranteed that there exists a unique bolt of same size .",
    "matching is performed by comparing a nut with a bolt .",
    "however , pairs of nuts or pairs of bolts can not be compared .",
    "so in this case @xmath16 is a complete bipartite graph with edges from the set of nuts @xmath17 to the set of bolts @xmath18 .",
    "this problem has been solved in the mid 1990s @xcite .",
    "the existence of a @xmath19 time deterministic algorithm was proved for it using the theory on bipartite expanders @xcite .",
    "the problem of sorting with forbidden pairs is still open for the most part .",
    "it is closely related to the problem of partial sorting under a relation determining oracle . in this model",
    "we are given a set @xmath20 of elements and a oracle @xmath21 which is used to determine the relations between pairs of elements in @xmath20 .",
    "the goal is to determine all the valid relations .",
    "number of queries made to @xmath21 is defined as the _ query complexity_. since there are @xmath22@xcite labelled posets with @xmath3 elements , it immediately follows that the information theoretic bound ( itb ) for the query complexity is @xmath23 .",
    "this is has been investigated for width bounded posets in @xcite , where the authors show that if @xmath20 has width at most @xmath24 then the itb for the query complexity is @xmath25 .",
    "they presented a query optimal algorithm for width bounded posets whose total complexity is @xmath26 .",
    "their main contributions were on developing an efficient data structure which was use to store a poset as disjoint chains and queries unknown relations using a weighted binary search method .",
    "this algorithm can be generalized for any poset with an additional @xmath27 factor added to the the query complexity .",
    "their results were the first major extension in this line of research after the seminal work by faigle and tur@xmath28n@xcite which showed existence of such an algorithm .",
    "although an efficient implementation of it were not known at the time .",
    "another similar problem is the _",
    "local sorting _ problem . in this problem",
    "@xmath1 is an ordered set and for each @xmath29 we want to determine their relative order .",
    "the problem is to determine if this can be done without resorting to sorting the entire set @xmath1 , since the itb for this problem is @xmath30 in the standard comparison tree model ( where @xmath31 is the maximum degree of @xmath12 ) .",
    "currently no non - trivial deterministic algorithm is known for this problem .",
    "however , there is a randomized algorithm which makes optimal number of comparison with high probability @xcite .",
    "the query model used in this paper differs from @xcite in following manner : we do nt charge for checking whether an edge exists but we only charge for the comparisons made . the number of comparisons made or rather asked to the oracle is naturally defined as the _ comparison complexity _ or the _ probe complexity_. however , no non - trivial itb for the probe complexity is known in the standard decision tree model .",
    "we believe that the model is too weak for this purpose .",
    "for example , given a comparison graph @xmath12 the number of different acyclic orientations of @xmath12 gives an upper bound on the number of possible answers .",
    "given the fact that it does not take any comparisons to identify @xmath12 ( up to isomorphism ) and @xmath12 has at most @xmath32@xcite number of acyclic orientations the itb of @xmath19 in the standard comparison tree model is too week for this problem .",
    "the matter is further complicated if one is also given the guarantee that the graph @xmath12 is _",
    "we say @xmath12 is sortable @xmath12 can be totally sorted .",
    "this restriction further reduces the number of possible answers for graphs with small number of edges .",
    "for example if @xmath12 has @xmath33 edges then we can determine the unique total order by just making one comparison .",
    "since any acyclic orientation of the edges of @xmath12 must give a hamiltonian path and @xmath12 has @xmath33 edges , the edges must link consecutive vertices in the unknown order . a solitary probe",
    "is then used to determine the direction of this ordering . in this paper",
    "we take @xmath12 to be arbitrary and not necessarily sortable . hence by sorting @xmath12 we mean determining the orientations of the edges of @xmath12 such that the resulting partial order ( which is unique ) has the maximum number relations .    in this paper",
    "we propose the first non - trivial deterministic algorithm under the probe complexity model as well as a randomized algorithm .",
    "the results are expressed in terms of @xmath3 and @xmath4 . expressing the results in terms",
    "the number of forbidden edges fits naturally with the problem .",
    "first of all @xmath4 and @xmath24 are related .",
    "let @xmath34 be the poset found after sorting @xmath12 .",
    "we have @xmath35 .",
    "hence , @xmath36 .",
    "although we can not directly compare the probe complexity used in this paper with the query complexity in @xcite but it gives a better sense of the relatedness of the two models .",
    "secondly , in the absence of any other structural properties of the input graph @xmath12 , @xmath4 gives a good indication of how difficult it is to sort @xmath12 .",
    "for example , when @xmath37 , it is easy to see that one can sort in @xmath19 total time . to do this we pick an arbitrary pair of non - adjacent vertices and take out one of them , removing it from the graph .",
    "we do the same thing with the remaining graph until the graph remaining is a clique .",
    "it is clear that we had to take out at most @xmath38 vertices .",
    "then we sort this graph with @xmath39 comparisons and merge the vertices we had remove previously by probing all the remaining undirected edges , which is at most @xmath19 . on the other extreme , if @xmath40 then it can be shown that we need to make @xmath41 probes to determine the partial order , since the complete bipartite graph @xmath42 with @xmath43 has many acyclic orientations@xcite .",
    "so in this case one has to probe most of the allowed edges .    in the context of randomized algorithms",
    ", this problem has been studied in @xcite .",
    "the authors in @xcite proposed a randomized algorithm that sorts @xmath12 with a probe complexity of @xmath44 with high probability . ] .",
    "however their implementation uses as a sub - routine a poly - time uniform sampling algorithm to sample points from a convex polytope@xcite .",
    "the authors did not discuss the exact bound on the total complexity in their paper . at each step",
    "the algorithm either finds a _ balancing edge _ revealing whose orientation is guaranteed to reduce the number of linear extension of the current partial order by a constant fraction .",
    "the pair of vertices incident to this edge is referred to as a _ balancing pair_. ] or finds a subset of elements that can be sorted quickly . for an arbitrary @xmath12",
    "it is not guaranteed that a _ balancing edge _ always exists . however , when @xmath12 is the complete graph there always exists a _ balancing edge _ that reduces the number of linear extension at - least by a factor of @xmath45 @xcite .",
    "the main contributions of this paper are as follows :    * given a comparison graph @xmath12 we propose a deterministic algorithm that sort @xmath12 with @xmath5 probes .",
    "the total complexity of our algorithm is @xmath6 , where @xmath46 $ ] is the exponent in the complexity of matrix multiplication .",
    "we use only elementary methods in our algorithm .",
    "we start by finding a set of large enough cliques in @xmath12 and use its elements to determine a good pivot .",
    "this is then applied recursively to induced subgraphs of @xmath12 to generate a collection of partial orders .",
    "we then merge these partial orders in the final step .",
    "* we propose a randomized algorithm which sorts @xmath12 with @xmath47 probes with high probability .",
    "we use a random graph model for this purpose .",
    "the method uses only elementary techniques and unlike in @xcite has a total run time of @xmath48 in the worst case .",
    "* when @xmath12 is a random graph with edge probability @xmath10 we show that one can sort @xmath12 with high probability using only @xmath9 probes .",
    "the rest of this paper is organized as follows : in section 1.2 we introduce some definitions and lemmas for later use .",
    "section 2 details the proposed deterministic algorithm . in section 3",
    "we introduce the randomized algorithm and its extension to random graphs .",
    "recall @xmath2 is the input graph on the set @xmath1 of elements to be sorted .",
    "a pair of vertices @xmath49 can be compared if @xmath29 , otherwise , we say the pair is forbidden and is in @xmath13 .",
    "the graph @xmath12 is given to us by our adversary .",
    "let @xmath50 be the graph after @xmath51-edges have been oriented and @xmath52 be the associated partial order .",
    "we denote the degree of a vertex @xmath53 by @xmath54 and @xmath55 is the number of vertices that are not adjacent to @xmath53 .",
    "the set of neighbors of a vertex @xmath53 is denoted by @xmath56 .",
    "we use the notation @xmath57 we denote the set of edges between the sets of vertices @xmath58 .",
    "we also define the little-@xmath59 notation to remove any ambiguity from our exposition .    if @xmath60 then @xmath61 but @xmath62 .    let @xmath63 be a finite set of non - negative monotonically increasing functions in @xmath64 such that :    1 .",
    "@xmath65 2 .   @xmath66    if @xmath67 then @xmath68 .",
    "see appendix .",
    "let @xmath69 where @xmath70 for some @xmath71 and @xmath72 .",
    "then , @xmath73 .",
    "see appendix .",
    "first we look at a simple case where @xmath74 .",
    "we will use some of the main ideas from this algorithm to extend it to the general case .",
    "this initial algorithm will have a worse probe complexity than the main algorithm .",
    "assume @xmath75 for some constant @xmath76 .",
    "let @xmath77 for some constant @xmath78 . then @xmath79 .",
    "we choose @xmath80 .",
    "this is obvious from the fact that @xmath81 .",
    "let @xmath82 and @xmath83 $ ] be the induced subgraph generated by @xmath84 .",
    "we have @xmath85 and if @xmath86 then @xmath87 .",
    "there exists a subset @xmath88 such that @xmath89 and @xmath90 $ ] is a complete graph .    let us construct @xmath91 explicitly .",
    "we start with @xmath92 , where @xmath93 is an arbitrary vertex in s. we pick successive vertices from @xmath84 iteratively .",
    "let @xmath53 be last vertex to be added to @xmath91 .",
    "since @xmath94 has at least @xmath95 neighbors , whenever we pick a neighbor of @xmath53 from @xmath84 to add to @xmath91 we loose at most @xmath96 vertices ( which include the vertex we picked ) .",
    "hence if we pick neighbors of @xmath53 the size of @xmath91 is at least @xmath97 .",
    "clearly the above procedure runs in @xmath98 time and makes no comparisons .",
    "now we are ready to describe our algorithm .",
    "the main algorithm is recursive and we have two levels of recursion .",
    "we shall break the algorithm into several steps .",
    "given the input graph @xmath12 , let @xmath91 be a clique , with @xmath89 ( claim 1 ) .",
    "let @xmath99 .",
    "note that @xmath100 .",
    "now we sort @xmath91 using @xmath101 comparisons as @xmath90 $ ] is a complete graph .",
    "we can use a standard comparison based sorting algorithms for this purpose .",
    "now we have two possibilities :    * if @xmath102 '' is not an algorithmic test .",
    "we use it in this algorithm to establish a framework for the second algorithm , which uses a traditional test . ] , then we probe all edges of @xmath103 $ ] and @xmath104 $ ] , where @xmath104 $ ] is the induced bipartite graph generated by the sets @xmath105 and @xmath91 .",
    "then we take the transitive closure of the resulting relations , which does not need any additional probes .",
    "it can be easily seen that the number of probe made in the previous step is @xmath106 . for the sake of contradiction if we assume that it is not so then @xmath107 for some @xmath108 . which implies @xmath109 , since @xmath110 .",
    "but then , @xmath111 , which is not true according to our earlier assumption .",
    "so , in this case we would have sorted @xmath1 by making only @xmath106 probes .",
    "* otherwise @xmath112 , for some constant @xmath113 . in this case",
    "we recursively partition @xmath105 based on elements from @xmath91 .",
    "we call this the partition step",
    ".      we will recursively partition both @xmath91 and @xmath105 . to keep track of the current partition depth we rename @xmath91 to @xmath114 and @xmath105 to @xmath115 .",
    "we pick @xmath116 the median of @xmath114 ( after @xmath114 is sorted ) .",
    "since @xmath117 we have @xmath118 .",
    "so @xmath116 will be comparable to all but at most @xmath78 elements of @xmath115 .",
    "let,@xmath119 and @xmath120 .",
    "note @xmath121 .",
    "now let @xmath122 be the subset of @xmath123 whose elements are @xmath124 and the set @xmath125 accounts for the rest of @xmath126 .",
    "let @xmath127 and @xmath128 be the elements of @xmath114 that are @xmath129 and @xmath130 to @xmath116 respectively .",
    "we recursively partition the sets @xmath122 and @xmath125 using the medians of @xmath127 and @xmath128.the @xmath18-sets are kept for later processing .",
    "we rename the sets @xmath122 and @xmath125 to @xmath131 and @xmath132 .",
    "so , the pairs @xmath133 and @xmath134 are processed as above generating the sets @xmath135 and @xmath136 .",
    "we continue doing this until the size of the @xmath91-set is @xmath137 , where @xmath138 is some constant . at this point",
    "we do nt know the size of the @xmath105-set paired with it .",
    "there are two cases we need to consider :    1 .",
    "@xmath102 then we probe all the edges of @xmath103 $ ] and @xmath139 $ ] which uses at most @xmath140 number of comparisons .",
    "2 .   @xmath112 .",
    "then we have @xmath112 for constant @xmath113 .",
    "hence the graph @xmath103 $ ] can have at most @xmath141 missing edges .",
    "this satisfies our initial premise that the number of missing edges in @xmath103 $ ] is linear in the number of vertices .",
    "hence we can apply our initial strategy recursively .",
    "that is we first find a large enough clique ( which according to claim 3 must exist ) and then use it to partition the rest of the set @xmath105 .",
    "let us visualize using a partial recursion tree @xmath142 ( see fig.1 below ) .",
    "we shall call @xmath142 the partial recursion tree for reasons soon to be clear . at the root we have the pair @xmath143 .",
    "it has two children node @xmath133 and @xmath134 each having two children of their own and so on .",
    "now at each level , the size of the @xmath91-set gets halved .",
    "so , the number of levels in @xmath142 is at most @xmath144 .",
    "however , the @xmath105-sets need not get divided with equal proportions .",
    "so , at the frontier ( the deepest level ) we will have nodes of the above two types , depending on the size of their corresponding @xmath105-sets .",
    "let the collection of these frontier nodes be partitioned in two sets @xmath145 and @xmath146 corresponding to case 1 and case 2 respectively .",
    "we can conclude that the total number of probes needed to compute all relations in @xmath145 is @xmath106 .",
    "this follows from lemma 1 .",
    "here we can map the size of the @xmath105-sets of the nodes in the collection @xmath145 to the functions @xmath147 . we know that the total elements in the union of these @xmath105-sets is @xmath148 .",
    "the total number of probes will be @xmath149 in worst case .",
    "what is the total number of probes on the internal nodes of @xmath142 ?",
    "we know that in the internal nodes we compare the median of the @xmath91-set with the elements of the @xmath150-set , which takes @xmath151 probes .",
    "since union of these @xmath150-sets can not exceed the total number of vertices in @xmath12(@xmath3 ) , at each level of @xmath142 we do at most @xmath152 probes , totaling to @xmath101 probes over all the internal nodes .",
    "unlike the nodes in @xmath145 , the nodes in @xmath146 recursively calls the initial strategy using the input graph @xmath103 $ ] .",
    "let the probe complexity of our initial strategy be @xmath153 .",
    "then the recursion for @xmath154 is as follows : @xmath155 here we assume that the nodes in @xmath146 are indexed according to some arbitrary order .",
    "we can solve this recurrence using lemma 2 giving @xmath156 , since @xmath157 .",
    "note here that @xmath158 is bounded by a constant since the size of @xmath105-sets are in @xmath159 .",
    "we call @xmath160 the full tree .",
    "all leaf nodes in @xmath160 are in @xmath145 .",
    "it is straightforward to show that @xmath160 has @xmath161 levels . since any of the leaf nodes of @xmath142 has @xmath162 ( where @xmath163 ) , its subtree in @xmath160 can have at most @xmath164 levels , and any of its leaves having at most @xmath165 levels and so on for some constant @xmath166 .",
    "the shaded boxes represents the @xmath145-nodes and the blue rectangles the @xmath146-nodes .",
    "the outer dashed triangle represents the full tree @xmath160 .",
    "the tree @xmath160 is created during the partitioning step and in the merge step we start from the deepest leaves of @xmath160 and move upwards.,width=415 ]      once we have completed building @xmath160 we proceed with the final stage of our algorithm . recall that during the forward partition step we had generated many of these @xmath18-sets in the internal nodes of @xmath160 .",
    "now we start from the leaves of @xmath160 and proceed upwards .",
    "each pair of leaf nodes @xmath167 sharing a common parent @xmath10 , sends a partial order to it them ( computed as in case 1 ) . when we merge this two partial orders we know that no extra probe is needed since they have already been split by the median of the @xmath91-set of @xmath10 .",
    "what remains is to probe all edges between the @xmath18-set in @xmath10 and elements in this partial order ( which constitutes the set of elements @xmath168 of the node @xmath10 ) as well as the edges in @xmath169 $ ] .",
    "then we pass the resulting partial order to the parent of @xmath10 , and so on .",
    "since the size of the @xmath18-sets are bounded by @xmath78 ( at any level in @xmath160 ) , total number of probes we make is then @xmath170 .",
    "the sum is taken over all the nodes in that level .",
    "hence this is bounded by @xmath171 , so at each level we do at most @xmath152 probes in the backward merging step . since there are at most @xmath161 levels , it totals to @xmath172 additional probes . adding this to the probe cost of partitioning in the forward step",
    "does not effect the total probe complexity , which was @xmath106 .",
    "the final step is to compute the transitive closure of the resulting set of relations , which can be done without any additional probing . since computing the transitive closure is equivalent to boolean matrix multiplication@xcite the total complexity is @xmath48 .",
    "we will define the sets @xmath173 and @xmath84 analogously to section 2.1 .",
    "we have , @xmath174 for some constant @xmath78 . with @xmath175 ,",
    "we get @xmath176 where @xmath177 .",
    "hence @xmath178 .",
    "now we will apply claim 1 successively to construct a `` big - enough '' set @xmath88 which we will use to find an approximate median of @xmath1 .",
    "@xmath91 consists of disjoint subsets @xmath179 such that @xmath180 $ ] is a clique .",
    "let us define @xmath181 .",
    "we construct the first clique @xmath182 using the method detailed in claim 1 .",
    "there are two cases :    1 .",
    "@xmath183 : in this case we can show that @xmath184 .",
    "we take the first @xmath185 elements and keep the rest for the second round .",
    "now we construct the second clique @xmath186 from @xmath187 which has at least @xmath188 vertices .",
    "we let @xmath189 .",
    "hence @xmath91 has at least @xmath190 vertices .",
    "@xmath191 : in this case we have @xmath192 .",
    "again we take @xmath193 discarding some vertices if necessary .",
    "similarly we construct @xmath194 .",
    "it can be shown that @xmath195 and we keep @xmath196 vertices in @xmath186 and the rest are discarded to be processed the next round . in general for the @xmath197 clique @xmath198 we have @xmath199 .",
    "now we let @xmath200 .",
    "we will show that @xmath201 for some constant @xmath202 .",
    "we let @xmath203 .",
    "then we have + @xmath204 + since @xmath191 .",
    "hence , @xmath205 , giving @xmath206 . now for each @xmath179 ( @xmath207 ) we keep a subset @xmath208 of size @xmath209 and throw away the rest .",
    "clearly , for each @xmath51 , the induced sub - graph @xmath210 $ ] is also a clique .",
    "let @xmath211 .",
    "we also have @xmath212 .",
    "we shall compute an approximate median with respect to all the vertices ( the set @xmath1 ) and not just the set @xmath84 .",
    "we will find a median element that divides the set @xmath1 in constant proportions .",
    "this can be done easily using the set @xmath105 . for each @xmath208",
    "we find its median using @xmath213 probes since @xmath210 $ ] is a complete graph .",
    "let this median be @xmath214 and @xmath215 be the set of these @xmath216 medians .",
    "since @xmath217 , @xmath218 .",
    "we define the upper set of @xmath219 with respect to a set @xmath220 ( @xmath221 may not be a member of @xmath150 ) as @xmath222 .",
    "similarly we define the lower set @xmath223 .",
    "we want to compute the sets @xmath224 and @xmath225 .",
    "however , @xmath221 may not be neighbors of all the elements in @xmath105 .",
    "so we compute approximate upper and lower sets by probing all the edges in @xmath226 .",
    "these sets are denoted by @xmath227 and @xmath228 respectively .",
    "it is easy to see that there exists some @xmath219 which divides @xmath105 into sets of roughly equal sizes ( their sizes are a constant factor of each other ) .",
    "in fact the median of @xmath215 is such an element .",
    "however the elements in @xmath215 may not all be neighbors of each other hence we will approximate @xmath221 using the ranks of the elements in @xmath215 with respect to the set @xmath105 ( which is @xmath229 ) .",
    "next we prove that the element @xmath230 is an approximate median of @xmath215 , picked using the above procedure , is also an approximate median of @xmath105 .",
    "the element @xmath230 picked as described above is an approximate median of @xmath105 .",
    "first we show that the median of @xmath215 is an approximate median of @xmath105",
    ". this can be easily verified .",
    "let us take the elements in @xmath215 in sorted order @xmath231 , so the median of @xmath215 is @xmath232 .",
    "now @xmath233 . since , the sets @xmath234 are disjoint and @xmath235 , we have @xmath236 ( ignoring the floor ) .",
    "similarly we can show that @xmath237 .",
    "hence @xmath232 is an approximate median of @xmath105 .",
    "now we show that @xmath238 .",
    "consider the sorted order of elements in @xmath215 according to @xmath239 .",
    "since each element in @xmath219 has at most @xmath240 missing neighbors in @xmath105 , we have @xmath241 .",
    "so the rank of an element in the sorted order is at most @xmath240 less than its actual rank .",
    "thus an element @xmath230 picked as the median of @xmath215 using its approximate rank @xmath229 can not be more than @xmath240 apart from @xmath232 in the sorted order of @xmath105 .",
    "hence ,    @xmath242    whenever @xmath243 .",
    "in an identical manner we can show that @xmath244 .",
    "hence , @xmath230 is an approximate median of @xmath105 .",
    "when @xmath183 we just take @xmath230 as the median with the higher @xmath245 value , which guarantees @xmath246 whenever @xmath247 .",
    "so we take @xmath243 to cover both the cases .",
    "it immediately follows that @xmath230 is also an approximate median of @xmath1 with both @xmath248 and @xmath249 lower bounded by @xmath250 .",
    "lastly , we note that the above process of computing an approximate median makes @xmath251 probes .",
    "this follows from the fact that computing the medians makes @xmath252 probes in total and for each of the @xmath253 medians we make @xmath152 probes .",
    "now that we have computed an approximate median of @xmath1 we proceed with an recursive approach .",
    "let @xmath230 be the median .",
    "as in section 3.1 we partition @xmath1 into three sets @xmath254 , @xmath255 and @xmath18 .",
    "the @xmath254 and @xmath255 are the upper and lower sets with respect to @xmath230 .",
    "@xmath18 is the set of vertices that do not fall into either , that is , they are non - neighbors of @xmath230 .",
    "since @xmath256 we have @xmath257 .",
    "we recursively proceed to partially sort the sets @xmath254 and @xmath255 with the corresponding graphs @xmath258 $ ] and @xmath259 $ ] and keep @xmath18 for later processing ( as we did in the merging step previously ) . like before we can imagine a recursion tree @xmath142 .",
    "let @xmath260 be the set forbidden edges in @xmath261 $ ] .",
    "we take @xmath262 and @xmath263 . for each node @xmath264",
    "there are two cases :    * when @xmath265 , we recursively sort @xmath20 . in this case",
    "we can guarantee that the approximate median @xmath266 of @xmath20 will satisfy equation ( 1 ) . that is",
    "both @xmath267 and @xmath268 is @xmath269 .",
    "* otherwise we probe all edges in @xmath261 $ ] . in this case",
    "@xmath20 will become a leaf node in @xmath142 .",
    "it can be easily seen that the depth of the recursion tree is bounded by @xmath38 since at each internal node @xmath20 of @xmath142 we pass sets of constant proportions ( where the size of the larger of the two set is upper bounded by @xmath270 ) to its children nodes .      in this step",
    "we start with the leaves of @xmath142 and proceed upwards .",
    "a parent node @xmath20 gets two partial orders from its left and right children respectively .",
    "then it probes all the edges between its @xmath18-set and these partial orders to generate a new partial order and pass it on to its own parent .",
    "this step works exactly as the `` merge step '' of the previous algorithm . only difference is that the @xmath18-sets here may not be of constant size but of size @xmath271",
    ".      we can determine the probe complexity by looking at the recursion tree @xmath142 .",
    "first we compute it for the forward partition step . at each internal node of",
    "@xmath142 we compute a set of medians and pick one element from it appropriately chosen .",
    "then we partition the set of elements at the node by probing all edges between the selected element and rest of the elements in the node . as mentioned before this only takes @xmath272 probes for some internal node @xmath20 .",
    "we assume that all the leaves of @xmath142 are at the same depth , otherwise we can insert internal dummy nodes and make it so . at each level of @xmath142",
    "the sum total of all the vertices in every node is @xmath273 and the sum total of the forbidden edges is @xmath274 .",
    "hence we do @xmath275 probes at any internal level of @xmath142 .",
    "so for a total of @xmath276 internal levels in @xmath142 the number of probes done is @xmath277 in the forward partition step .",
    "if @xmath20 is a leaf node then we probe all edges in @xmath261 $ ] .",
    "there are at most @xmath278 edges in @xmath261 $ ] . since @xmath20 is a leaf node , according equation 1 , @xmath279 .",
    "hence we make @xmath280 probes .",
    "summing this over all the leaves gives a total of @xmath281 probes .",
    "hence the total probe complexity during the forward step is @xmath282 .",
    "now we look at the merging step .",
    "merging happens only at the internal nodes .",
    "lets look at an arbitrary internal level of @xmath142 . at each node @xmath20 of this level",
    "we probe all the edges in @xmath283 and in @xmath284 $ ] .",
    "note that we do not have to make any probes between @xmath254 and @xmath255 as they were already separated by the approximate median @xmath285 .",
    "hence the total number of probes made in this node is @xmath286 .",
    "summing over all the nodes at any given level gives us @xmath281 as the probe complexity per level .",
    "so the total probe complexity in the merging stage is @xmath287 .",
    "hence , combining the probes made during the partition step and the merge step we see that the total probes needed to sort @xmath1 is @xmath288 .",
    "now we look at the total complexity of the previous procedure . again",
    "the analysis is divided into forward step and the merge step . in the forward step at each node",
    "@xmath20 we perform @xmath289 operations .",
    "this includes computing the degrees , finding the cliques , computing the approximate median .",
    "so at any level of @xmath142 , regardless of it being an internal level or not , we perform @xmath98 operations . hence it totals to @xmath290 operations in the forward step .",
    "however this is a conservative estimate and we can remove the @xmath291 factor as argued below : we can define the recurrence for the forward computation as , @xmath292    this follows from the previous discussion . if we do nt recurse on a node we guarantee that @xmath293 for that node .",
    "hence , we have @xmath294 using the akra - bazzi method@xcite . in the merge step ,",
    "we only make @xmath295 comparisons at any given node .",
    "we compute transitive closures only at the leaves .",
    "however for any leaf @xmath20 we have @xmath279 .",
    "hence computing the transitive closure of @xmath261 $ ] takes @xmath296 time .",
    "hence , the total complexity of the above procedure is @xmath6 . we summarize the results in this section with the following theorem :    given a graph @xmath297 of @xmath3 vertices having @xmath4 forbidden edges",
    ", one can compute the partial order of @xmath1 with @xmath298 comparisons and in total @xmath6 time .",
    "follows from the discussions in this section .",
    "in this section we look at a more direct way of sorting by making random probes .",
    "the proposed method is inspired by the literature on two - step oblivious parallel sorting @xcite algorithms , in particular on a series of studies by bollobs and brightwell showing certain sparse graphs can be used to construct efficient sorting networks @xcite .",
    "it was shown that if a graph satisfies certain properties then probing its edges and taking the transitive closure of the resulting set would yield large number of relations .",
    "then we just probe the remaining edges that are not oriented , which is guaranteed ( with high probability ) to be a `` small '' set .",
    "the main idea is as follows : let @xmath299 be a collection of undirected graphs on @xmath3 vertices having certain properties . a transitive orientation of a graph @xmath300 is an ordering of @xmath1 and the induced orientation of the edges of @xmath301 based on that ordering .",
    "let @xmath302 be an ordering on @xmath1 and @xmath303 be the partial order generated by this ordering @xmath302 on @xmath301 .",
    "it is a partial order since @xmath301 may not be sortable .",
    "let @xmath304 and @xmath305 be the number of incomparable pairs in @xmath306 .",
    "we want @xmath301 to be such that @xmath307 is small .",
    "if that is the case then @xmath306 will have many relations and if @xmath301 is sparse then we can probe all the edges of @xmath301 and afterwards we will be left with probing only a small number of pairs .",
    "these are pairs which were not oriented during the first round of probing and after the transitive closure computation .",
    "a graph @xmath301 is _ useful _ to our purpose if every transitive orientation of @xmath301 results in many relations .",
    "we want to find a collection @xmath299 such that every graph in it is useful with high probability .",
    "we extend the results in @xcite to show that a collection of certain conditional random graphs are useful , with high probability . in our case",
    "this random graph will be a spanning subgraph of the input graph @xmath12 .",
    "here we recall an important result from @xcite which we will use in our proof .",
    "if @xmath12 is any graph on @xmath3 vertices and @xmath12 satisfies the following property :    1 .",
    "any two subsets @xmath308 of vertices having size @xmath309 have at least one edge between them .",
    "then , the number of incomparable pairs in @xmath310 is at most @xmath311 for any @xmath302 .    the input graph @xmath12 is chosen by our adversary .",
    "however , we show that any random spanning subgraph of @xmath12 with an appropriate edge probability will satisfy q1 with high probability .",
    "let @xmath312 be a random spanning subgraph of @xmath12 , where @xmath312 has the same vertex set as @xmath12 and a pair of vertices in @xmath312 has an edge between them with probability @xmath10 if they are adjacent in @xmath12 , otherwise they are also non - adjacent in @xmath312 .",
    "all we need to prove is that any random spanning subgraph @xmath312 given @xmath12 with @xmath3-vertices and edge probability @xmath10 will satisfy q1 with high probability .",
    "since @xmath12 has at most @xmath4 forbidden edges any two subsets of vertices @xmath308 ( not necessarily distinct ) of size @xmath309 must have at least @xmath313 edge between them .",
    "let , @xmath314 be the event that the pair @xmath315 is bad ( they have no edges between them ) , then the probability @xmath316 that there exists a bad pair is :    @xmath317    where the sum is taken over all such @xmath318 pairs of subsets , and the number of edges between the two sets @xmath150 and @xmath18 in @xmath12 is @xmath319 .",
    "so we have , @xmath320    hence @xmath321 as @xmath322 whenever @xmath323 . given @xmath324 it is always possible to find appropriate values for @xmath10 and @xmath309 as functions of @xmath4 and @xmath325 such that @xmath326 .",
    "given some value for the pair @xmath327 , we see that in the first round we make @xmath328 probes with high probability and in the second round @xmath311 probes again with high probability .",
    "so the total probe complexity is @xmath329 . with some further algebra",
    "it can be shown that this is @xmath8 .",
    "we summarize this section with the following theorem :    given a graph @xmath12 on @xmath3 vertices and @xmath4 forbidden edges one can determine the partial order on @xmath12 with high probability in two steps by probing only @xmath8 edges in total and in @xmath48 time",
    ".    follows from the preceding discussions .",
    "the above technique can easily be extended for the case when the input graph is random .",
    "let @xmath330 be the input graph having @xmath3-vertices and an uniform edge probability @xmath10 .",
    "for such a graph we can use equation ( 3 ) to bound @xmath316 as follows :    @xmath331    hence , we can choose any @xmath332 such that @xmath321 as @xmath322 .",
    "let @xmath333 .",
    "using theorem 2 we have @xmath334 . since @xmath330 has @xmath335 edges ( with high probability ) the critical value of @xmath10 when @xmath336 is @xmath337 .",
    "let this be @xmath338 .",
    "hence if @xmath339 , we can sort by making only @xmath44 comparisons .",
    "since given @xmath330 we can construct an induced subgraph @xmath340 and use it as the random graph in our previous construction .",
    "otherwise we just probe all the edges which makes @xmath328 comparisons .",
    "thus we can sort @xmath330 with at most @xmath9 comparisons with high probability .",
    "hence , we get an elementary technique to sort a random graph with at most @xmath44 comparisons .",
    "the algorithm in @xcite has a slightly better bound of @xmath341 comparisons .",
    "however , the total runtime of the algorithm in @xcite is only polynomially bounded when @xmath10 is small . in our algorithm",
    "we need compute the transitive closure only twice making it run in @xmath48 total time .",
    "in this paper we study the problem of sorting under non - uniform comparison costs , where costs are either 1 or @xmath0 .",
    "this cost structure is non - monotone resulting in additional complexity .",
    "the results presented here only uses elementary techniques , yet achieving non - trivial bounds on probe complexity .",
    "further , we present strong evidence that the complexity of sorting @xmath1 is dependent on certain properties of the input graph , in particular the number of forbidden edges @xmath4 .",
    "we derive an non - trivial upper bound @xmath342 for the probe complexity .",
    "the total complexity of our algorithm is bounded by @xmath6 .",
    "since the lower bound for the total complexity of the problem is @xmath23 , module fast matrix multiplication , the proposed algorithm is almost optimal in terms of the total complexity .",
    "we also present a randomized algorithm for the problem which uses @xmath8 probes with high probability .",
    "when the input graph is random this algorithm requires only @xmath44 probes again with high probability .    4    huang , z. , kannan , s. , khanna , s. ( 2011 , october ) .",
    "algorithms for the generalized sorting problem . in foundations of computer science ( focs ) ,",
    "2011 ieee 52nd annual symposium on ( pp .",
    "738 - 747 ) .",
    "cardinal , j. , fiorini , s. ( 2013 ) . on generalized comparison - based sorting problems . in space - efficient data structures , streams , and algorithms ( pp .",
    "164 - 175 ) .",
    "springer berlin heidelberg .",
    "bollobs , b. , brightwell , g. ( 1988 ) .",
    "transitive orientations of graphs .",
    "siam journal on computing , 17(6 ) , 1119 - 1133 .",
    "charikar , m. , fagin , r. , guruswami , v. , kleinberg , j. , raghavan , p. , sahai , a. ( 2000 , may ) .",
    "query strategies for priced information . in proceedings of the thirty - second annual acm symposium on theory of computing ( pp .",
    "582 - 591 ) .",
    "kahn , j. , saks , m. ( 1984 ) .",
    "balancing poset extensions .",
    "order , 1(2 ) , 113 - 126 .",
    "fredman , m. l. ( 1976 ) .",
    "how good is the information theory bound in sorting ? .",
    "theoretical computer science , 1(4 ) , 355 - 361 .",
    "alon , n. , blum , m. , fiat , a. , kannan , s. , naor , m. , ostrovsky , r. ( 1994 , january ) . matching nuts and bolts . in soda ( pp .",
    "690 - 696 ) .",
    "gupta , a. , kumar , a. ( 2001 , october ) .",
    "sorting and selection with structured costs . in foundations of computer science , 2001 .",
    "42nd ieee symposium on ( pp .",
    "416 - 425 ) .",
    "komls , j. , ma , y. , szemerdi , e. ( 1998 ) . matching nuts and bolts in o",
    "( n log n ) time .",
    "siam journal on discrete mathematics , 11(3 ) , 347 - 372 .",
    "ajtai , m. , komls , j. , steiger , w. , szemerdi , e. ( 1989 ) . almost sorting in one round .",
    "advances in computer research , 5 , 117 - 125 .",
    "bollobs , b. , rosenfeld , m. ( 1981 ) .",
    "sorting in one round .",
    "israel journal of mathematics , 38(1 - 2 ) , 154 - 160 .",
    "bollobs , b. , brightwell , g. ( 1987 ) . graphs whose every transitive orientation contains almost every relation .",
    "israel journal of mathematics , 59(1 ) , 112 - 128 .",
    "kahn , j. , kim , j. h. ( 1995 ) .",
    "entropy and sorting .",
    "journal of computer and system sciences , 51(3 ) , 390 - 399 .",
    "janson , s. ( 2004 ) .",
    "large deviations for sums of partly dependent random variables .",
    "random structures & algorithms , 24(3 ) , 234 - 248 .",
    "angelov , stanislav , keshav kunal , and andrew mcgregor .",
    "`` sorting and selection with random costs . ''",
    "latin 2008 : theoretical informatics .",
    "springer berlin heidelberg , 2008 .",
    "48 - 59 .",
    "chatterji s.d.(1966 ) the number of topologies of @xmath3 points , kent state university , nasa technical report .",
    "daskalakis , c. , karp , r. m. , mossel , e. , riesenfeld , s. j. , verbin , e. ( 2011 ) . sorting and selection in posets .",
    "siam journal on computing , 40(3 ) , 597 - 622 .",
    "u. faigle and gy .",
    "( 1988 ) `` sorting and recognition problems for ordered sets , '' siam j. comput .",
    "17(1 ) : 100113 .",
    "kahale , n. , schulman , l. j. ( 1996 ) .",
    "bounds on the chromatic polynomial and on the number of acyclic orientations of a graph .",
    "combinatorica , 16(3 ) , 383 - 397 .",
    "goddard , wayne , et al .",
    "`` optimal randomized algorithms for local sorting and set - maxima . ''",
    "siam journal on computing 22.2 ( 1993 ) : 272 - 283 .",
    "dyer , m. , frieze , a. , kannan , r. ( 1991 ) . a random polynomial - time algorithm for approximating the volume of convex bodies .",
    "journal of the acm ( jacm ) , 38(1 ) , 1 - 17 .",
    "akra , m. , bazzi , l. ( 1998 ) . on the solution of linear recurrence equations .",
    "computational optimization and applications , 10(2 ) , 195 - 210 .",
    "savage , j. e. ( 2008 ) .",
    "models of computation : exploring the power of computing . cc-3.0 . by - nc - nd , electronic edition .",
    "now we prove @xmath345 : assume that @xmath346 , then there exists some constant @xmath347 such that , @xmath348 whenever @xmath349 .",
    "now let @xmath350 whenever @xmath351 . since , @xmath352 we can pick this @xmath353 s arbitrarily and independent of each other .",
    "now , for @xmath354 ( where @xmath355 ) we have ,            let as assume @xmath357 for some @xmath358 . otherwise we are done .",
    "so , the recurrence becomes , @xmath360 . using master theorem",
    "we see that the case 3 applies here , which gives , @xmath361 ."
  ],
  "abstract_text": [
    "<S> in this paper we study the problem of sorting under non - uniform comparison costs , where costs are either 1 or @xmath0 . </S>",
    "<S> if comparing a pair has an associated cost of @xmath0 then we say that such a pair can not be compared ( forbidden pairs ) . </S>",
    "<S> along with the set of elements @xmath1 the input to our problem is a graph @xmath2 , whose edges represents the pairs that we can compare incurring an unit of cost . given a graph with @xmath3 vertices and @xmath4 forbidden edges we propose the first non - trivial deterministic algorithm which makes @xmath5 comparisons with a total complexity of @xmath6 , where @xmath7 is the exponent in the complexity of matrix multiplication . </S>",
    "<S> we also propose a simple randomized algorithm for the problem which makes @xmath8 probes with high probability . </S>",
    "<S> when the input graph is random we show that @xmath9 probes suffice , where @xmath10 is the edge probability .    </S>",
    "<S> , random graphs , complexity </S>"
  ]
}