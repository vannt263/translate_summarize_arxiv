{
  "article_text": [
    "traditional sorting is about learning a linear order .",
    "its complexity is often measured by the number of pairwise comparisons a sorting algorithm needs on average , which is known to be @xmath3 .",
    "it is a straightforward generalization to ask for algorithms which learn a _ partial _ order by pairwise comparisons , a task that could be termed _",
    "partial sorting_. let us designate the set of all strict partial orders on @xmath4 by @xmath5 .",
    "this set has @xmath6 many elements ( cf .",
    "@xcite ) , and each pairwise comparison of elements of @xmath0 has at most three possible results . a trivial lower bound for the expected number of comparisons needed to learn some @xmath7 is therefore @xmath8 , since in a rooted tree with @xmath9 leaves in which each node has at most @xmath10 children , the average leaf - root - distance is at least @xmath11 .    in this paper , a lower bound of @xmath12",
    "is proved , which is larger than the above by a factor of @xmath13 . in other words ,",
    "any learning algorithm for large posets must expect to compare at least about half of all pairs .",
    "moreover , it will be shown that there are indeed algorithms whose expected running time is just @xmath14 .",
    "both results use the fact that for ( very ) large @xmath0 , almost all posets have a specific three - leveled shape .    to underline the asymptotic nature of the results presented below , figure  [ fig : strat ] shows as a contrast the optimal poset learning strategy for @xmath15 which has been determined by a recursive computer search .",
    "each node is a possible state ( up to ( dual ) isomorphisms ) , and the node s diagram shows all relations ( like in a hasse diagram ) and all incomparabilities ( represented by dotted lines ) known in that state .",
    "the edges show which states can arise from which others , where loops indicate dualization . those states",
    "in which there is only one possible type of comparison are framed with thinner lines , so the other nodes already determine the actual strategy .",
    "its average running time is @xmath16 comparisons , compared to @xmath17 pairs and a trivial lower bound of @xmath18 comparisons .",
    "the optimal strategy for @xmath19 takes @xmath20 comparisons on average , while @xmath21 and @xmath22 .",
    "given @xmath23 and @xmath24 , the _ pairwise comparison _",
    "@xmath25 determines @xmath26 , that is , provides the information whether @xmath27 , @xmath28 , or neither .",
    "let us define the _ covering _ and _ anti - covering _ relations of @xmath29 by @xmath30 where @xmath31 and @xmath32 .",
    "we consider algorithms which learn a partial order @xmath23 given a number @xmath33 and an _ oracle _ for @xmath29 , which is just a subroutine that performs a pairwise comparison in @xmath29 .",
    "the algorithms can learn @xmath29 only through oracle calls , each of which is assumed to take constant time .",
    "for any such algorithm @xmath34 , let @xmath35 be the number of pairwise comparisons the algorithm needs until it knows @xmath29 .",
    "then @xmath36 is the expected number of pairwise comparisons for that algorithm . finally , let @xmath37 or @xmath38 .",
    "@xmath39 for all @xmath34 and @xmath29 .",
    "_ assume that @xmath34 claims to know @xmath29 but has not compared the pair @xmath40 .",
    "if @xmath41 , put @xmath42 , while if @xmath43 , put @xmath44 .",
    "then @xmath45 is a partial order that would erroneously be recognized as @xmath29 by @xmath34 .       for @xmath46 , for example",
    ", the average cardinality of @xmath47 is about @xmath48 which is smaller than the trivial lower bound of @xmath49 .",
    "but for @xmath50 it is about @xmath51 which improves the trivial lower bound of @xmath52 .",
    "for the rest of this section , assume that @xmath0 is a multiple of @xmath53 .",
    "let @xmath54 be the set of all ordered partitions @xmath55 of @xmath0 with @xmath56 and @xmath57 .",
    "put @xmath58 , where @xmath59 is the set of all @xmath23 which fulfil ( i ) @xmath60 or @xmath61 or @xmath62 for all @xmath63 , and ( ii ) @xmath64 and @xmath65 for all @xmath66 . in particular , these posets consist of a lower level @xmath67 of @xmath68 minimal elements , an antichain @xmath69 of size @xmath70 building the middle level , and an upper level @xmath71 of @xmath68 maximal elements , and no @xmath71-element covers an @xmath67-element .",
    "moreover , ( i ) and ( ii ) imply that @xmath72 .",
    "[ lem:3 ] @xmath73 .",
    "_ let @xmath74 .",
    "improving upon the original asymptotics of kleitman and rothschild @xcite , brightwell , prmel , and steger @xcite showed that for some @xmath75 , @xmath76 , where @xmath77 and @xmath78 is the set of all @xmath23 with @xmath79 and @xmath80 for all @xmath81 . on the other hand , it is easy to see that @xmath82 and @xmath83 . hence @xmath84 .",
    "because @xmath85 implies @xmath86 , it follows that @xmath87 has a lower bound of @xmath1 .",
    "table  [ tab:1 ] compares @xmath88 with @xmath89 for some small values of @xmath0 ( based on numbers from @xcite ) .",
    ".comparison of lower bounds for @xmath87 for small @xmath0 [ cols= \" < , < , < , < , < , < , < , < \" , ]",
    "consider the algorithm @xmath90 listed in figure  [ fig : alg ] which learns a partial order on @xmath91 .",
    "if @xmath91 is a multiple of @xmath53 , the strategy of @xmath90 first assumes that @xmath29 is a member of @xmath92 .",
    "if the assumption is true , @xmath90 will determine the corresponding level partition @xmath55 in @xmath93 expected time so that it can afterwards compare exactly the @xmath88 pairs in @xmath94 .",
    "in the asymptotically unlikely case that @xmath95 it will detect that fact and perform a comparison of all pairs .",
    "nput :  racle @xmath97 for pairwise comparisons in a partial order @xmath29 on @xmath91 + output:@xmath29 +  1  put @xmath98 +  2find largest @xmath99 with @xmath100 +   +  3 @xmath101 from @xmath102 to @xmath103 * do * +  4  put @xmath104 and @xmath105 +  5 assume = @xmath106 , @xmath107 , + and @xmath108 +   +  6 @xmath109 from @xmath110 to @xmath103 * do * +  7  * call * @xmath111 +  8 , for some @xmath112 , either +  9  = @xmath113 , or + 10 @xmath114 , or + 11 ( @xmath115 , @xmath116 , but not @xmath117 ) , or + 12 ( @xmath118 , @xmath119 , but not @xmath120 ) + 13  * then * add @xmath101 to @xmath69 and continue in main loop + 14 @xmath121 + 15 @xmath122 and @xmath123  * then * add @xmath101 to @xmath67 and continue in main loop + 16 @xmath122 and @xmath124 add @xmath101 to @xmath71 and continue in main loop +   + 17 @xmath101 is maximal ( @xmath125  @xmath123 for no @xmath109 )  * then * add @xmath101 to @xmath71 + 18 @xmath101 is minimal ( @xmath125  @xmath124 for no @xmath109 ) add @xmath101 to @xmath67 +   + 19 all @xmath126  * call * @xmath127 + 20 the calls so far did not determine @xmath29 uniquely + 21  * then  for * all remaining pairs @xmath128  * call * @xmath127 + 22 compute and print @xmath29 .",
    "let @xmath131 , where @xmath132 is the set of all @xmath23 with @xmath79 .",
    "we may assume that @xmath133 for some @xmath134 , since by lemma  [ lem:3 ] , @xmath135 is true with a probability converging to 1 as @xmath96 .",
    "note that @xmath136 is an upper bound for the probability that at some point in @xmath90 , either @xmath137 , @xmath138 , or @xmath139 .",
    "conditional to @xmath133 , the event @xmath140 has probability @xmath141 independently for all @xmath142 .",
    "hence one can estimate the expected number of pairwise comparisons in iteration @xmath101 of the main loop as follows .",
    "\\(i ) assume that @xmath143 .",
    "for @xmath144 and @xmath145 , the disjunction in lines 912 is violated with probability at most @xmath146 .",
    "hence iteration @xmath101 takes an expected number of at most @xmath147     < 2\\frac{(\\textstyle\\frac 1 2-\\alpha_n)^{-2}+n(\\textstyle\\frac 1 2+\\alpha_n)^r}{\\textstyle\\frac 1 2+\\alpha_n}\\ ] ] pairwise comparisons in this case .",
    "\\(ii ) assume that , on the other hand , @xmath148 . for @xmath149 , the probability that both the conditions of lines 1516 are violated is at most @xmath146 so that in this case iteration @xmath101 takes an expected number of at most @xmath150     < 2\\frac{(\\textstyle\\frac 1 2-\\alpha_n)^{-2}+n(\\textstyle\\frac 1 2+\\alpha_n)^m}{\\textstyle\\frac 1 2+\\alpha_n}\\ ] ]    we have seen that , given @xmath10 and @xmath151 , iteration @xmath101 takes in both cases an expected number of at most @xmath152 pairwise comparisons , where @xmath153 and @xmath154 . at the beginning of iteration @xmath101 , for @xmath155 , the probability that @xmath156 and @xmath157 is at most @xmath158 and so is the probability that @xmath159 and @xmath160 . in contrast , the probability that @xmath161 is at most @xmath162 . in all , iteration @xmath101 takes an expected number of at most @xmath163 pairwise comparisons , so that the total expected number of comparisons in lines 118 is @xmath164 .",
    "if @xmath165 then @xmath29 is uniquely determined in line 20 , hence the expected number of comparisons in lines 1921 is @xmath166 , proving the theorem .",
    "10 brightwell , g. , prmel , h.j . , and steger , a. ( 1996 ) the average number of linear extensions of a partial order , _ j.  combin .",
    "theory ser .",
    "a _ * 73 * , 193206 .",
    "heitzig , j.  and reinhold , j.  ( 2000 ) the number of unlabeled orders on fourteen elements , _ order _ * 17 * , 333341 .",
    "kleitman , d.j .  and rothschild , b.l .",
    "( 1975 ) asymptotic enumeration of partial orders on a finite set , _ trans .",
    "_ * 205 * , 205220 ."
  ],
  "abstract_text": [
    "<S> the expected number of pairwise comparisons needed to learn a partial order on @xmath0 elements is shown to be at least @xmath1 , and an algorithm is given that needs only @xmath2 comparisons on average . </S>",
    "<S> in addition , the optimal strategy for learning a poset with four elements is presented .       </S>",
    "<S> * key words : * algorithm , average - case , oracle , poset , sorting . </S>"
  ]
}