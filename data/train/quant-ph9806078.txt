{
  "article_text": [
    "over the past decade there has been steady progress in the development of quantum algorithms .",
    "most attention has focused on the quantum algorithms for finding the factors of a composite integer  @xcite and for finding an item in an unsorted database  @xcite .",
    "these successes have inspired several researchers to look for quantum algorithms that can solve other challenging problems , such as decision problems  @xcite or combinatorial search problems  @xcite , more efficiently than their classical counterparts .",
    "the class of np - complete problems includes the most common computational problems encountered in practice  @xcite .",
    "in particular , it includes scheduling , planning , combinatorial optimization , theorem proving , propositional satisfiability and graph coloring .",
    "in addition to their ubiquity , np - complete problems share a fortuitous kinship : any np - complete problem can be mapped into any other np - complete problem using only polynomial resources  @xcite .",
    "thus , any quantum algorithm that speeds up the solution of one np - complete problem immediately leads to equally fast quantum algorithms for all np - complete problems ( up to the polynomial cost of translation ) .",
    "unfortunately , np - complete problems appear to be even harder than the integer factorization problem . whereas , classically , the best known algorithm for the latter problem scales only sub - exponentially  @xcite , np - complete problems are widely believed to be exponential  @xcite .",
    "thus , the demonstration that shor s quantum algorithm  @xcite can factor an integer in a time that is bounded by a polynomial in the `` size '' of the integer ( i.e. , the number of bits needed to represent that integer ) , while remarkable , does not lead to a polynomial - time quantum algorithm for np - complete problems , the existence of which being considered as highly improbable  @xcite .",
    "moreover , it has proven to be very difficult to adapt shor s algorithm to other computational applications .    by contrast , the unstructured quantum search algorithm  @xcite can be adapted quite readily to the service of solving np - complete problems . as a candidate solution to an np - complete problem",
    "can be tested for correctness in polynomial time , one simply has to create a `` database '' consisting of all possible candidate solutions and apply the unstructured quantum search algorithm .",
    "unfortunately , the speedup afforded by this algorithm is only @xmath6 where @xmath7 is the number of candidate solutions to be tested . for a typical np - complete problem in which one has to find an assignment of one of @xmath8 values to each of @xmath9 variables , the number of candidate solutions , @xmath10 , grows exponentially with @xmath9 .",
    "a classical algorithm would therefore take a time @xmath11 to find the solution whereas the unstructured quantum search algorithm would take @xmath12 .",
    "although this is an impressive speedup , one would still like to do better .    while there is now good evidence that for unstructured problems , the quantum search algorithm is optimal  @xcite , these results have raised the question of whether faster quantum search algorithms might be found for problems that possess _ structure _",
    "it so happens that np - complete problems have such structure in the sense that one can often build up complete solutions ( i.e. , value assignments for all the variables ) by extending _ partial _ solutions ( i.e. , value assignments for a subset of the variables ) .",
    "thus , rather than performing an unstructured quantum search amongst _ all _ the candidate solutions , in an np - complete problem , we can perform a quantum search amongst the _ partial _ solutions in order to narrow the subsequent quantum search amongst their descendants .",
    "this is the approach presented in this paper and which allows us to find a solution to an np - complete problem in a time that grows , on average , as @xmath13 for the hardest problems , where @xmath4 is a constant depending on the problem instance considered .",
    "our improved quantum search algorithm works by _ nesting _ one quantum search within another .",
    "specifically , by performing a quantum search at a carefully selected level in the tree of partial solutions , we can narrow the effective quantum search amongst the candidate solutions so that the net computational cost is minimized .",
    "the resulting algorithm is the quantum counterpart of a _ classical _ nested search algorithm which scales as @xmath14 , giving a square root speedup overall .",
    "the nested search procedure mentioned here corresponds to a _",
    "single _ level of ( classical or quantum ) nesting , but it can be extended easily to several nesting levels .",
    "thus , our result suggests a systematic technique for translating a nested classical search algorithm into a quantum one , giving rise a square - root speedup , which can be useful to accelerate _ efficient _ classical algorithms ( rather than a simple exhaustive search , of no practical use ) .",
    "we believe this technique is applicable in all structured quantum searches .",
    "the outline of the paper is as follows .",
    "section  [ sect_nested_class ] introduces a simple classical tree search algorithm that exploits problem structure to localize the search for solutions amongst the candidates .",
    "this is not intended to be a sophisticated classical tree search algorithm , but rather is aimed at providing a baseline against which our quantum algorithm can be compared . in section  [ sect_unstruc_qu ] ,",
    "we outline the standard unstructured quantum search algorithm  @xcite .",
    "we focus especially on the algorithm based on an arbitrary unitary search operator  @xcite , as this is a key for implementing quantum nesting .",
    "finally , section  [ sect_nested_quant ] describes the quantum tree search algorithm based on nesting , which is a direct quantum analog of the classical search algorithm appearing in section  [ sect_nested_class ] .",
    "the quantum search algorithm with several levels of nesting is also briefly discussed .",
    "we conclude by showing that the expected time to find a solution grows as @xmath13 , that is , as the square root of the classical time for problem instances in the hard region .",
    "the constant @xmath5 , depending on the problem considered , is shown to decrease with an increasing nesting depth ( i.e. , an increasing number of nesting levels ) .",
    "many hard computational problems , such as propositional satisfiability , graph coloring , scheduling , planning , and combinatorial optimization , can be regarded as examples of so - called `` constraint satisfaction problems '' .",
    "constraint satisfaction problems consist of a set of variables , each having a finite set of domain values , together with a set of logical relations ( or `` constraints '' ) amongst the variables that are required to hold simultaneously .",
    "a solution is defined by a complete set of variable / value assignments such that every variable has some value , no variable is assigned conflicting values , and all the constraints are satisfied .    in such constraint satisfaction problems ,",
    "there is often a degree of commonality between different non - solutions .",
    "one typically finds , for example , that certain combinations of assignments of values to a subset of the variables are inconsistent ( i.e. , violate one or more of the constraints ) and can not , therefore , participate in any solution .",
    "these commonalities ( several non - solutions sharing the same ancestor that is inconsistent ) can be exploited to focus the search for a solution .",
    "thus , a classical _ structured _ search algorithm can find a solution to a constraint satisfaction problem in fewer steps than that required by a unstructured search by avoiding regions of the search space that can be guaranteed to be devoid of solutions . before investigating whether the problem structure can be exploited in a quantum search ( see sec .",
    "[ sect_nested_quant ] ) , we need to understand the circumstances under which knowledge of problem structure has the potential to be useful , classically .",
    "the key idea is that one can obtain complete solutions to a constraint satisfaction problem by systematically extending partial solutions , i.e. variable / value assignments that apply only to a subset of the variables in the problem .",
    "not all partial solutions are equally desirable however .",
    "a partial solution is `` good '' if it is consistent with all the constraints against which it may be tested .",
    "conversely a partial solution is `` nogood '' if it violates one or more such constraints .",
    "sophisticated search algorithms work by incrementally extending good partial solutions and systematically terminating nogood partial solutions .",
    "this induces a natural tree - like structure on the search space of partial solutions .",
    "0.25 cm    [ fig_tree ] -0.25 cm    to give a concrete example of a tree search problem , we consider the _ graph coloring problem _ as pictured in fig .",
    "[ fig_tree ] .",
    "we have a graph that consists of @xmath9 nodes connected by @xmath15 edges , with @xmath16 .",
    "each node must be assigned a color ( out of @xmath8 possible colors ) , so that any two nodes connected by an edge have different colors .",
    "more generally , for a constraint satisfaction problem , we are given a set of @xmath9 variables ( @xmath17 ) to which we must assign a value out of @xmath8 possible values .",
    "this assignment must satisfy simultaneously a set of constraints , each involving @xmath18 variables .",
    "the resulting number of _ nogood _ ground instances ( roughly proportional to the number of constraints ) is denoted by @xmath19 . in the particular case of the graph coloring problem , the size of the constraints @xmath20 since each edge imposes a constraint on the colors assigned to the pair of nodes it connects .",
    "the number of nogood ground instances @xmath21 because each edge contributes exactly @xmath8 nogoods and there are a total of @xmath15 edges ( for each edge , @xmath8 pairs of identical colors are forbidden ) .    the search tree corresponding to this constraint satisfaction problem is also shown in fig",
    ".  [ fig_tree ] .",
    "the @xmath22-th level of the search tree enumerates all possible _ partial _ solutions involving a specific subset of @xmath22 , out of the total @xmath9 , variables . the branching ratio in this tree , i.e. the number of children per node , is equal to @xmath8 , the number of domain values of a variable . for a hard instance of the problem ,",
    "the number of steps required to find a good assignment at the bottom of the tree ( or decide that there is no possible assignment satisfying all the constraints ) scales as @xmath10 , i.e. , of the order of the entire space of candidate solutions must be explored .",
    "remarkably , many of the properties of search trees can be understood without precise knowledge of the constraints .",
    "specifically , it has been found empirically that the difficulty of solving a particular instance of a constraint satisfaction problem can be approximately specified by four parameters : the number of variables , @xmath9 , the number of values per variable , @xmath8 , the number of variables per constraint , @xmath18 , and the total number of assignments of the individual constraints that are nogood , @xmath19  @xcite .",
    "clearly , if @xmath19 is small , there are generally many solutions satisfying the few constraints , so that the problem is easy to solve .",
    "conversely , if @xmath19 is large , the problem is in general overconstrained , and it is easy to find that it admits no solution .",
    "the problem is maximally hard in an intermediate range of values for @xmath19 . in an effort to understand the observed variation in difficulty across different instances of np - complete problems for fixed @xmath9 and @xmath8",
    ", it has been shown that the cost of finding a solution ( or proving none exists ) depends essentially on the parameter @xmath23 which characterizes the average number of constraints _ per variable _",
    "specifically , the problem solving difficulty exhibits a ubiquitous easy - hard - easy pattern , with the most difficult problem instances clustered around a critical value of @xmath24 given , approximately , by @xmath25 assuming @xmath26 for simplicity .",
    "this phenomenon , akin to a _ phase transition _ in physical systems  @xcite , persists across many different sophisticated algorithms . the average case complexity for a fixed @xmath24 is therefore believed to be a more informative measure of computational complexity than either worst case or average case complexity .",
    "is that worst case analyses can be misleading because they tend to focus on atypical problem instances .",
    "similarly , average case analyses can be misleading because they are sensitive to the choice of the ensemble of problem instances over which the average is computed .",
    "such an ensemble may contain for example an exceedingly large number of easy instances . ]",
    "it is the measure that we will use in the rest of this paper for estimating the scaling of the complexity of our improved quantum search algorithm ( as well as the corresponding classical search algorithm ) .",
    "let us describe a simple classical algorithm for a tree search problem that exploits the structure of the problem by use of nesting . as pictured in fig .",
    "[ fig_tree ] , the key idea is to perform a preliminary search through a space of _ partial _ solutions in order to avoid a search through the entire space at the bottom of the tree . by definition , a partial solution at level @xmath22 in the tree assigns values to a subset of @xmath22 so - called _ primary _ variables ( @xmath27 ) , which we denote as @xmath28 .",
    "the subset of _ secondary _ variables ( @xmath29 ) , denoted as @xmath30 , corresponds to the variables to which we assign a value only when extending the partial solutions ( i.e. , when considering the descendants of the partial solutions ) .",
    "in general , any partial solution can be tested against a part of the constraints , namely just those constraints involving the primary variables @xmath28 . a partial solution that satisfies all these ( testable )",
    "constraints can be viewed as a _",
    "could - be _ solution in the sense that all solutions at the bottom of the tree ( at level @xmath9 ) must be descendants of could - be s .",
    "a classical search can be speeded up by terminating search along paths that are _ not _ descendants of a could - be , thereby avoiding to search through the entire space .",
    "the following algorithm can be used :    * find a could - be solution at level @xmath22 in the tree . for this purpose , choose repeatedly a random partial solution at level @xmath22 , until it satisfies the testable constraints . * for each could - be solution , check exhaustively ( or by use of a random search ) all its descendants at the bottom of the tree ( level @xmath9 ) for the presence of a possible solution .",
    "this is clearly not a sophisticated algorithm",
    ". it amounts to nesting the search for a successful descendant at level @xmath9 into the search for a could - be at level @xmath22 .",
    "nevertheless , it does exploit the problem structure by using the knowledge gleaned from the search at level @xmath22 to focus the search at level @xmath9 . by finding a quantum analog of this algorithm ( cf .",
    "[ sect_nested_quant ] ) , we will , therefore , be able to address the impact of problem structure on quantum search .",
    "let us estimate the expected cost of running this algorithm .",
    "this cost consists essentially of three components : @xmath31 , the cost of finding a consistent partial solution ( a could - be ) at level @xmath22 in the tree , @xmath32 , the cost of the subsequent search among its descendants at level @xmath9 , and @xmath33 , the number of repetitions of this whole procedure before finding a solution .",
    "the search space for partial solutions ( assignment of the primary variables @xmath28 ) is of size @xmath34 . assuming that there are @xmath35 could - be solutions at level @xmath22 ( i.e. , partial solutions that can lead to a solution ) , the probability of finding one of them by using a random search is thus @xmath36 .",
    "thus , one needs of the order of @xmath37 iterations to find one could - be solution .",
    "the descendants of a could - be are obtained by assigning a value to the subset of _ secondary _ variables @xmath30 , of size @xmath38 ( each could - be has @xmath39 descendants ) .",
    "thus , searching through the entire space of descendants of a could - be requires on average @xmath40 iterations .",
    "if the problem admits a single solution , this whole procedure needs to be repeated @xmath35 times , on average , since we have @xmath35 could - be solutions . more generally , if the number of solutions of the problem is given by @xmath41 , this procedure must only be repeated @xmath42 times in order to find a solution with a probability of order 1 .",
    "thus , the total number of iterations required to find a solution of an average instance is approximately equal to @xmath43 this corresponds to an improvement over a naive _ unstructured _ search algorithm .",
    "indeed , the cost of a naive algorithm that does not exploit structure is simply @xmath44 , where @xmath45 is the dimension of the total search space .    the first term in the numerator of eq .",
    "( [ eq_tc ] ) corresponds to the search for could - be solutions in a space of partial solutions of size @xmath46 ( shaded area at level @xmath22 in fig .",
    "[ fig_tree ] ) , while the second term corresponds to the search for actual solutions among all the descendants of the @xmath35 could - be solutions , each of them having @xmath39 descendants ( shaded area at level @xmath9 in fig .",
    "[ fig_tree ] ) .",
    "the denominator in eq .",
    "( [ eq_tc ] ) accounts for a problem admitting more than one solution .",
    "we will see in sec .",
    "[ sect_nested_quant ] that the quantum counterpart of eq .",
    "( [ eq_tc ] ) involves taking the square root of @xmath31 , @xmath32 , and @xmath33 , which essentially results in quantum - mechanical square - root speedup over this classical algorithm .    to make the estimate of this classical average - case complexity more quantitative ,",
    "let @xmath47 be the probability that a partial solution at level @xmath22 is `` good '' ( i.e. , that it satisfies all the testable constraints ) .",
    "in appendix  [ app_p(i ) ] , we provide an asymptotic estimate of @xmath47 for an average instance of a large problem ( @xmath48 ) with a fixed value of the parameter @xmath24 .",
    "recall that , if we want to preserve the difficulty while considering the limit of large problems , @xmath24 must be kept constant .",
    "this is necessary for the complexity measure that we consider in this paper , as mentioned before .",
    "thus , by making use of this asymptotic estimate of @xmath47 , we can approximate the expected number of could - be solutions at the @xmath22th level , @xmath49 , and the expected number of solution at the bottom of the tree , @xmath50 .",
    "therefore , the average search time of the classical algorithm to find the first solution is approximately equal to @xmath51 this is essentially the cost for finding one solution ( which basically requires checking all the partial solutions for a could - be , and subsequently checking the descendants of all these could - be solutions ) divided by the expected number of solutions . )",
    "is the number of solutions at the bottom of the tree . for a problem of maximum difficulty ( @xmath52 ) ,",
    "it is shown in appendix  [ app_p(i ) ] that @xmath53 , i.e. , the problem admits a single solution on average . ]",
    "equation  ( [ eq_tclass ] ) yields an approximate cost measure for our classical nested search algorithm as a function of the level of the `` cut '' , @xmath22 .",
    "an important question now is where to cut the search tree ?",
    "if one cuts the tree too high ( searching for could - be solutions at small @xmath22 ) , one is unlikely to learn anything useful as most partial solutions will probably be `` goods '' , allowing for little discrimination between solutions and non - solutions .",
    "in other words , the second term in the numerator of eq .",
    "( [ eq_tclass ] ) dominates since @xmath47 is close to 1 , i.e. , there are many could - be solutions at level @xmath22 . searching for",
    "could - be solutions is thus fast ( the space of primary variables is of size @xmath54 only ) , but those partial solutions are of little use for singling out the actual solutions .",
    "the cost of the search among the descendants of those partial solutions is then high .",
    "conversely , if one cuts the tree too deep ( searching for could - be solutions at large @xmath22 ) , although this would enhance discrimination between solutions and non - solutions , the search space for the primary variables would be almost as large as the entire space .",
    "then , the first term dominates the scaling as the search for could - be solutions becomes time - consuming .",
    "it is therefore apparent that , for a typical problem instance , there ought to be an optimal level at which to cut .    we can estimate the optimal level by finding the value of @xmath22 that minimizes the classical computation time @xmath55 for a given value of @xmath9 , @xmath8 , @xmath19 , and @xmath18 , using the functional form for @xmath47 .",
    "this is done in appendix  [ app_classcomplexity ] , where we estimate the _ asymptotic _ behavior of the location of the optimal cut level as a function of @xmath24 , as larger problems are considered ( @xmath48 ) .",
    "we then calculate the corresponding asymptotic scaling of @xmath56 for large problems .",
    "the result is that the computation cost of running the classical nested search algorithm scales as @xmath57 for a search space of dimension @xmath58 , where @xmath4 is a constant depending on the problem considered .",
    "( more generally , this constant also depends on the number of nesting levels , but we have considered a single level of nesting in this section . ) as we will see , the structured quantum search algorithm that we present in sect .",
    "[ sect_nested_quant ] has a computational cost of order of @xmath59 , in agreement with the idea that a square root speedup is the best that can be achieved by quantum mechanics .",
    "the focus of this paper , however , is to show explicitly _ how _ a quantum algorithm can be implemented that reaches this maximum speedup over the classical algorithm discussed above .",
    "interestingly enough , the quantum complexity of our nested algorithm scales then as a power of the dimension of the search space @xmath58 that is less than 1/2 . structured",
    "quantum search therefore offers a significant speedup over both structured classical search and unstructured quantum search .",
    "let us first review the standard _ unstructured _ quantum search algorithm  @xcite . consider a hilbert space of dimension @xmath1 in which each basis @xmath60 state ( @xmath61 ) corresponds to a candidate solution of a search problem .",
    "any search problem can be recast as the problem of finding the value(s ) of @xmath62 at which an `` oracle '' function @xmath63 is equal to one ( this function being zero elsewhere ) .",
    "we start the quantum search process from an arbitrary basis state @xmath64 , and the goal is to reach a solution ( or target ) basis state @xmath65 , with @xmath66 , in a shortest computation time .",
    "more precisely , if there is a single solution ( or target state ) , the goal is to reach a state that has an amplitude of order  1 in @xmath65 , so that a measurement of this state gives the solution with probability of order  1 .",
    "( if there are @xmath33 solutions , the goal is to reach a superposition of the states @xmath65 , each with an amplitude of order @xmath67 . )",
    "the quantum search algorithm we discuss below is in fact an immediate extension of the original one  @xcite , where an arbitrary unitary transformation is used instead of the walsh - hadamard transformation  @xcite .",
    "assume that we have at our disposal a quantum circuit that performs a particular unitary operation @xmath68 .",
    "if this operation connects the starting state @xmath64 to the target state @xmath65 , i.e. , @xmath69 , then this operation can be used classically to find the target .",
    "indeed , if we measure the system after applying @xmath68 , the probability of obtaining the solution @xmath65 is obviously @xmath70 .",
    "thus , on average , we need to repeat this experiment @xmath71 times to find the solution with probability of order 1 .",
    "we will show now that , using a quantum algorithm , it is possible to reach the target state @xmath65 in a number of steps of order @xmath72 only , which represents a huge speedup provided that @xmath73 ( this corresponds to the situation of interest where the search space is very large ) .    the idea behind a quantum search algorithm is to _ postpone _ the measurement , and keep a superposition of quantum states throughout the algorithm . only at the end",
    ", a measurement is performed .",
    "let us define the unitary operation @xmath74 where @xmath75 and @xmath76 are projection operators on @xmath64 and @xmath65 , respectively .",
    "the two unitary operators @xmath77 and @xmath78 perform a controlled - phase operation : applying @xmath79 ( or @xmath80 ) on a state @xmath60 flips its phase if @xmath81 ( or @xmath82 ) , and leaves it unchanged otherwise .",
    "note that the target state @xmath65 is of course not available ( it is what we are searching for ) .",
    "instead , we have at our disposal the quantum circuit ( or `` oracle '' ) that computes the function @xmath63 , and we can use it to implement the circuit for @xmath80 .",
    "thus , we have @xmath83 for all state @xmath60 .",
    "the circuit for @xmath79 does not require the function @xmath63 and is trivial .",
    "the principle at the heart of quantum search is to apply the operation @xmath84 repeatedly in order to _ amplify _ the target component @xmath65 , starting from @xmath85 .",
    "this quantum _ amplitude amplification _",
    "@xcite can be understood by noting that , after applying @xmath68 to the starting state @xmath64 , the repeated applications of @xmath84 essentially rotate this state into the target state @xmath65 at an angular velocity that is _ linear _ in the number of iterations . more specifically , using @xmath86 , we can see that @xmath84 preserves the two - dimensional subspace spanned by @xmath85 and @xmath65 , namely @xmath87 therefore , in the case where @xmath88 , the states @xmath85 and @xmath65 are almost orthogonal , and @xmath84 tends to a rotation matrix of angle @xmath89 .",
    "indeed , keeping only the first - order terms in @xmath90 , we obtain @xmath91 we can then easily approximate the operation of @xmath92 in the subspace spanned by @xmath85 and @xmath65 : @xmath93 implying that the amplitude of the target state @xmath65 after @xmath31 iterations is @xmath94 these last expressions are only asymptotically valid , at the limit of small @xmath95 .",
    "the exact expressions for eqs .",
    "( [ eq_9 ] ) and ( [ eq_10 ] ) in terms of chebyshev polynomials can be found in appendix  [ app_chebyshev ] .",
    "consider first the case of a small rotation angle . from eq .",
    "( [ eq_10 ] ) , we see that if we iterate the application of @xmath84 on @xmath85 , the amplitude of @xmath65 grows _ linearly _ with the number of iterations @xmath31 provided that the total angle @xmath96 : @xmath97 consequently , if we measure the system after @xmath31 iterations , the probability @xmath98 of finding the solution grows _ quadratically _ with @xmath31 , as @xmath99 .",
    "this is a great improvement compared to the linear scaling of the classical algorithm consisting in repeating @xmath31 times the measurement of @xmath85 , namely @xmath100 .",
    "this is the quadratic amplification effect provided by quantum mechanics .",
    "now , consider the goal of reaching the target state @xmath65 using this operator @xmath84 . from eq .",
    "( [ eq_sinus ] ) we see that , starting from the state @xmath85 , we need to apply @xmath84 until we have rotated it by an angle of about @xmath101 in order to reach @xmath65 . at this time only , one measures the system and gets the desired solution with a probability of order 1 . the number of iterations required to rotate @xmath85 into the solution @xmath65 is thus @xmath102 and scales as the _ square root _ of the classical time .",
    "it is worth noting that the amplitude of any state @xmath60 orthogonal to the target @xmath65 is given by @xmath103 so that @xmath104 for small angles .",
    "thus , the amplitude of non - solutions is _ not _ amplified by applying @xmath84 repeatedly , so that the quantum search algorithm selectively amplifies the solutions only .",
    "thus , we have described here a general technique for achieving a quantum - mechanical square - root speedup of a search algorithm relying on _ any _ unitary transformation @xmath68",
    "the quantum search algorithm can be simply viewed as a rotation from @xmath85 to @xmath65 based on the repeated operation of @xmath84 , followed by a measurement . in the above discussion , the search operator @xmath68 can be arbitrary , _ provided _ it connects @xmath64 and @xmath65 . in the case of",
    "an _ unstructured _ search problem , as we have no _ a  priori _ knowledge about where the solution is located , the most natural choice for @xmath68 is the walsh - hadamard transformation @xmath105",
    "@xcite : @xmath106 where @xmath107 , with @xmath108 ( @xmath109 ) being the binary digits of @xmath62 ( @xmath110 ) . is a power of 2 for simplicity . ]",
    "indeed , @xmath111 does not bias the search towards a particular candidate solution since @xmath112 has the same ( squared ) amplitude in all the candidate solutions , so that the search starts from a uniform distribution of all states . applying @xmath111 to an arbitrary state @xmath64 , we see that @xmath113 for all possible target state @xmath65 .",
    "thus , according to eq .",
    "( [ eq_quant - r ] ) , the number of iterations in the quantum search algorithm relying on @xmath105 is @xmath114  @xcite , whereas a classical search algorithm obviously requires @xmath2 steps .",
    "when there are multiple target states ( the problem admits several solutions ) , it can be shown that the quantum computation time becomes @xmath115 , where @xmath33 is the number of solutions  @xcite .",
    "the classical counterpart is then simply @xmath116 .    for a _ structured _ search problem , however , it is natural to use the knowledge of the structure in order to choose a better @xmath68",
    ". indeed , if we have partial knowledge about where the solutions are , we can exploit it to _ bias _ the search in such a way that @xmath85 has larger amplitudes in states which are more probable to be solutions .",
    "this is the focus of the present paper .",
    "it has been shown recently that an arbitrary ( non - uniform ) initial amplitude distribution can be used as well with the standard quantum search algorithm , resulting in a @xmath115 quantum computation time  @xcite .",
    "this seems to indicate that the scaling remains in @xmath114 even if we use our knowledge about the problem by biasing the initial distribution .",
    "in contrast , we will show in sec .",
    "[ sect_nested_quant ] that the use of a _ nested _ quantum search algorithm can result in a power law in @xmath1 with an exponent that is _ smaller _ than 1/2 .",
    "the key idea is that @xmath68 is not fixed _ a priori _ , but is rather obtained `` dynamically '' by the quantum algorithm itself , depending on the particular instance . in short , the standard search algorithm is used to _ construct _ an effective search operator @xmath68 ( or a non - uniform initial distribution ) which , itself , is nested within another quantum search algorithm . in other words",
    ", we apply quantum search `` recursively '' : the operator @xmath117 resulting from the nested search algorithm based on @xmath105 is used as a better search operator @xmath68 for a quantum search at an upper level of hierarchy .",
    "assume that the hilbert space of our search problem is the tensor product of two hilbert spaces @xmath118 and @xmath119 .",
    "as before , @xmath28 denotes the set of primary variables , that is , the variables to which we assign a value in the first stage .",
    "the partial solutions correspond to definite values for these variables .",
    "thus , @xmath118 represents the search space for partial solutions ( of dimension @xmath46 ) .",
    "the set of secondary variables , characterizing the extensions of partial solutions , is denoted by @xmath30 , and the corresponding hilbert space @xmath119 is of dimension @xmath39 .",
    "let us briefly describe the quantum algorithm with a single nesting level ( the counterpart of the classical algorithm of sect .",
    "[ sect_nested_class ] ) :    * the first stage ( i ) consists in constructing a superposition ( with equal amplitudes ) of all the could - be solutions at level @xmath22 by use of the standard unstructured search algorithm based on @xmath105 . * then ( ii ) , one performs a subsequent quantum search in the subspace of the descendants of _ all _ the could - be partial solutions , simultaneously .",
    "this second stage is achieved by using the standard quantum search algorithm with , as an input , the _ superposition _ of could - be solutions resulting from the first stage . the overall yield of stages ( i ) and ( ii ) is a superposition of all states where the solutions have been partially amplified with respect to non - solutions . * the final procedure ( iii )",
    "consists of nesting stages ( i ) and ( ii) using them as a search operator @xmath68inside a higher - level quantum search algorithm until the solutions get maximally amplified , at which point a measurement is performed .",
    "this is summarized in fig .",
    "[ fig_idea ] .",
    "0.25 cm    [ fig_idea ] -0.25 cm    let us now follow in more details the evolution of the quantum state by applying this quantum nested algorithm , and estimate the number of iterations required .",
    "the starting state of the search is denoted as @xmath120 , where @xmath64 ( lying in @xmath118 ) and @xmath121 ( lying in @xmath119 ) are just the initial state of two different parts of the same , single , quantum register which is large enough to hold all the potential solutions in the total search space ( i.e .. all the @xmath10 leaf nodes of the search tree at level @xmath9 ) .",
    "register @xmath28 stores the starting state at an intermediate level @xmath22 in the tree , while register @xmath30 stores the continuation of that state at level @xmath9 .",
    "in other words , @xmath28 holds partial solutions and @xmath30 their elaboration in the leaves of the tree .",
    "\\(i ) the first stage of the algorithm consist in a standard quantum search for _ could - be _ partial solutions @xmath122 at level  @xmath22 , that is , states in subspace @xmath118 that do not violate any ( testable ) constraint .",
    "we start from state @xmath64 in subspace @xmath118 , and apply a quantum search based on the walsh - hadamard transformation @xmath105 since we do not have _ a priori _ knowledge about the location of could - be solutions . using @xmath123",
    "we can perform an amplification of the components @xmath122 based on @xmath124 where @xmath125 the states @xmath122 correspond to the could - be partial solutions in @xmath118 ( assignment of the primary variables that could lead to a solution ) , and belong to the subset @xmath126 .",
    "we assume that there are @xmath35 could - be partial solutions , with @xmath127 . the quadratic amplification of these could - be solutions , starting from @xmath64 , is reflected by @xmath128 for small rotation angle .",
    "thus , applying @xmath84 sequentially , we can construct a superposition of all the could - be solutions @xmath122 , each with an amplitude of order @xmath129 .",
    "the required number of iterations of @xmath84 scales as @xmath130 this amplitude amplification process can equivalently be described in the joint hilbert space @xmath131 , starting from the product state @xmath120 , where @xmath121 denotes an arbitrary starting state in @xmath119 , and applying @xmath132 sequentially : @xmath133 here and below , we use the convention that the left ( right ) term in a tensor product refers to subspace @xmath28 ( @xmath30 ) .",
    "\\(ii ) the second stage of the algorithm is a standard quantum search for the secondary variables @xmath30 in the subspace of the `` descendants '' of the could - be solutions that have been singled out in stage ( i ) .",
    "as before , we can use the search operator @xmath105 that connects extended could - be solutions @xmath134 to the actual solutions or target states @xmath135 in the joint hilbert space : @xmath136 note that , this matrix element is non - vanishing only for could - be states @xmath122 that lead to an actual solution . define the operator @xmath137 , with @xmath138 where @xmath139 is the set of solutions @xmath135 at the bottom of the tree , and @xmath140 , i.e. , the problem admits @xmath41 solutions .",
    "we can apply the operator @xmath141 sequentially in order to amplify a target state @xmath135 , namely @xmath142 for small rotation angle .",
    "note that , for a could - be state @xmath122 that does not lead to a solution ( @xmath143 ) , we have @xmath144 for all @xmath62 , so that @xmath145 , and the matrix element is not amplified by @xmath32 compared to the case @xmath146 . in other words ,",
    "no amplification occurs in the space of descendants of could - be partial solutions that do not lead to an actual solution .",
    "thus , eq .  ( [ eq_2ndstep_pre ] ) results in @xmath147 assuming that , among the descendants of each could - be solution @xmath134 , there is either zero or one solution , we need to iterate @xmath141 of the order of @xmath148 times in order to maximally amplify each solution .",
    "we then obtain a superposition of the solution states @xmath135 , each with an amplitude @xmath129 .",
    "this can also be seen by combining eqs .",
    "( [ eq_1ststep ] ) and ( [ eq_2ndstep ] ) , and using the resolution of identity @xmath149 : @xmath150 thus , applying the operator @xmath92 followed by the operator @xmath151 connects the starting state @xmath120 to each of the solutions @xmath135 of the problem with a matrix element of order @xmath152 .",
    "\\(iii ) the third stage consists in using the operator @xmath153 resulting from steps ( i ) and  ( ii ) as a search operator for a higher - level quantum search algorithm , in order to further amplify the superposition of @xmath41 target ( or solution ) states @xmath135 .",
    "the goal is thus to construct such a superposition where each solution has an amplitude of order @xmath154 .",
    "as before , we can make use of the operator @xmath155 where @xmath79 , @xmath156 , and @xmath80 are defined in eqs .",
    "( [ eq_defini_s ] ) , ( [ eq_defini_s ] ) , and ( [ eq_defin_i_t ] ) , in order to perform amplification according to the relation @xmath157 for small rotation angle .",
    "the number of iterations of @xmath158 required to maximally amplify the solutions is thus of the order of @xmath159 this completes the algorithm . at this point",
    ", it is sufficient to perform a measurement of the amplified superposition of solutions .",
    "this yields one solution @xmath135 with a probability of order 1 .",
    "0.25 cm    [ fig_algo ] -0.25 cm    in fig .",
    "[ fig_algo ] , the quantum network that implements this nested quantum search algorithm is illustrated .",
    "clearly , a sequence of two quantum search circuits ( a search in the @xmath28 space followed by a search in the @xmath30 space ) is _ nested _ into a global search circuit in the whole hilbert space @xmath160 .",
    "this can be interpreted as a `` dynamical '' choice of the search operator @xmath68 that is used in the global quantum search .",
    "this quantum nesting is distinct from a procedure where one would try to choose an optimum @xmath68 before running the quantum search by making use of the structure _ classically _ ( making several classical queries to the oracle ) in order to speedup the resulting quantum search . here , no measurement is involved and structure is used at the quantum level .",
    "let us estimate the total number of iterations , or more precisely the number of times that a controlled - phase operator ( @xmath80 , which flips the phase of a solution , or @xmath161 , which flips the phase of a could - be partial solution ) is used .",
    "since we need to repeat @xmath33 times the operation @xmath158 , which itself requires applying @xmath31 times @xmath84 and @xmath32 times @xmath141 , we obtain for the quantum computation time @xmath162 this expression is the quantum counterpart of eq .",
    "( [ eq_tc ] ) , and has the following interpretation .",
    "the first term in the numerator corresponds to a quantum search for the could - be partial solutions in space of size @xmath46 .",
    "the second term is associated with a quantum search of actual solutions in the space of all the descendants of the @xmath35 could - be solutions ( each of them has a subspace of descendants of size @xmath39 ) .",
    "the denominator accounts for the fact that the total number of iterations decreases with the square root of the number of solutions of the problem @xmath41 , as in the standard quantum search algorithm .",
    "let us now estimate the scaling of the computation time required by this quantum nested algorithm for a large search space ( @xmath48 ) .",
    "remember that @xmath9 is the number of variables ( number of nodes for the graph coloring problem ) and @xmath8 is the number of values ( colors ) per variable .",
    "as before , if we `` cut '' the tree at level @xmath22 ( i.e. , assigning a value to @xmath22 variables out of @xmath9 defines a partial solution ) , we have @xmath34 and @xmath38 . also , we have @xmath49 , and @xmath50 , where @xmath47 is the probability of having a partial solution at level @xmath22 that is `` good '' in a tree of height @xmath9 .",
    "( the quantity @xmath163 is thus the probability of having a solution in the total search space . )",
    "we can reexpress the computation time as a function of @xmath22 , @xmath164 which is the quantum counterpart of eq .",
    "( [ eq_tclass ] ) . in order to determine the scaling of @xmath165",
    ", we use the asymptotic estimate of @xmath47 that is derived in appendix  [ app_p(i ) ] , namely @xmath166 eq .",
    "( [ eq_p(i ) ] ) is a good approximation of @xmath47 in the asymptotic regime , i.e. , when the dimension of the problem @xmath9 ( or the number of variables ) tends to infinity .",
    "remember that , in order keep the difficulty constant when increasing the size of the problem , we need to choose the number of constraints @xmath167 when @xmath48 .",
    "( where @xmath15 being the number of edges and @xmath8 the number of colors ) , it implies that the number of edges must grow linearly with the number of nodes for a fixed number of colors in order to preserve the difficulty .",
    "in other words , the average connectivity must remain constant . ]",
    "the constant @xmath24 corresponds to the average number of constraints _ per variable _ , and is a measure of the difficulty of the problem .",
    "the difficulty is maximum when @xmath24 is close to a _ critical _",
    "value @xmath168 , where @xmath18 is the size of the constraint ( i.e. , number of variables involved in a constraint ) .",
    "note that @xmath169 , implying that the number of solutions at the bottom of the tree is @xmath170 .",
    "thus , if @xmath171 , we have @xmath172 , so that the problem admits of the order of @xmath173 solutions .",
    "this corresponds indeed to the hardest case , where one is searching for a single solution in the entire search space . when @xmath174 , however , there are less constraints and the problem admits more than one solution , on average .",
    "if @xmath175 , the problem is overconstrained , and it typically becomes easier to check the nonexistence of a solution .",
    "now , plugging eq .",
    "( [ eq_p(i ) ] ) into eq .  ( [ eq_t(i ) ] )",
    ", we obtain for the quantum computation time @xmath176 defining the _ reduced _ level on the tree as @xmath177 , i.e. , the fraction of the height of the tree at which we exploit the structure of the problem , we have @xmath178 where @xmath179 .",
    "now , we want to find the value of @xmath62 that minimizes the computation time @xmath180 , so we have to solve @xmath181 for large @xmath9 ( or large @xmath182 ) , this equation asymptotically reduces to @xmath183 the solution @xmath62 ( with @xmath184 ) corresponds therefore to the reduced level for which @xmath180 grows asymptotically ( @xmath48 ) with the smallest power in @xmath8 . note that this optimum @xmath62 is such that both terms in the numerator of eq .",
    "( [ eq_t_q(i ) ] ) grow with the same power in @xmath8 ( for large @xmath9 ) .",
    "this reflects that there is a particular fraction @xmath62 of the height of the tree where it is optimal to `` cut '' , i.e. , to look at partial solutions .",
    "the optimum computation time can then be written as @xmath185 where the constant @xmath4 is defined as the solution @xmath62 of eq .",
    "( [ eq_equationforx ] ) .",
    "note that , for a search with several levels of nesting , the constant @xmath186 , as we shall see in sect .",
    "[ sect_multi ] .",
    "equation  ( [ eq_t(x)_solution ] ) implies that the scaling of the quantum search in a space of dimension @xmath58 is essentially @xmath187 modulo the denominator ( which simply accounts for the number of solutions ) .",
    "in contrast , the standard _ unstructured _ quantum search algorithm applied to this problem corresponds to @xmath188 , with a computation time scaling as @xmath189 .",
    "this means that exploiting the structure in the quantum algorithm results in a decrease of the power in @xmath8 by a coefficient @xmath5 : the power @xmath190 of the standard quantum search is reduced to @xmath191 for this nested quantum search algorithm .",
    "consider this result at @xmath52 , i.e. , when the difficulty of the problem is maximum for a given size @xmath9 .",
    "this is the most interesting case since when @xmath174 , the problem becomes easier to solve classically . for @xmath52 ,",
    "the nested algorithm essentially scales as @xmath192 where @xmath193 with @xmath62 being the solution of @xmath194 , and @xmath58 is the dimension of the search space .",
    "this represents a significant improvement over the scaling of the unstructured quantum search algorithm , @xmath195 .",
    "nevertheless , it must be emphasized that the speedup with respect to the computation time @xmath196 of the classical nested algorithm presented in section  [ sect_nested_class ] is exactly a square root ( cf .",
    "appendix  [ app_classcomplexity ] ) .",
    "this implies that this nested quantum search algorithm is the _ optimum _ quantum version of this particular classical non - deterministic algorithm .    for the graph coloring problem ( @xmath20 )",
    ", we must solve the linear equation of second order @xmath197 , whose solution is simply @xmath198 .",
    "( when @xmath199 , the solution for @xmath62 increases , and tends to 1 for large @xmath18 . )",
    "this means that the level on the tree where it is optimal to use the structure is at about 62% of the total height of the tree , i.e. , when assigning values to about 62% of the @xmath9 variables . in this case , the computation time of the nested algorithm scales as @xmath200 , which is clearly an important computational gain compared to @xmath201 .",
    "consider the regime where @xmath202 , i.e. , there are fewer constraints and therefore more than one solution on average , so that the problem becomes easier to solve . for a given @xmath18 , the solution @xmath62 of eq .",
    "( [ eq_equationforx ] ) increases when @xmath24 decreases , and tends asymptotically to 1 for @xmath203 .",
    "this means that we recover the _ unstructured _ quantum search algorithm in the limit where @xmath203 .",
    "the denominator in eq .",
    "( [ eq_t(x)_solution ] ) increases , and it is easy to check that the computation time @xmath204 decreases when @xmath24 decreases .",
    "as expected , the computation time of the nested algorithm approaches @xmath205 as @xmath24 tends to 0 ( or @xmath206 ) , that is , it reduces to the time of the standard unstructured quantum search algorithm at the limit @xmath203 .      the quantum algorithm described in sect .",
    "[ sect_core ] relies on a single level of nesting .",
    "indeed , the search at the bottom of the tree ( level @xmath9 ) is speeded up by making use of a search at level @xmath22 which determines the partial solutions which are `` good '' .",
    "only the candidate solutions which are descendants of these partial solutions are examined in the search at level @xmath9 .",
    "it should be realized that these `` good '' partial solutions at level @xmath22 are selected , themselves , by a _",
    "naive _ search : stage ( i ) indeed amounts to use the standard unstructured search based on @xmath105 . in the corresponding classical nested algorithm , this amounts to select a random partial solution at level @xmath22 and check whether it is good .",
    "it is natural that both the classical and the quantum algorithms could be improved further if the search for good partial solutions at level @xmath22 itself was made faster by making use of the structure of the upper part of the tree ( by examining partial solutions at level @xmath207 , with @xmath208 , and considering only the descendants of the `` good '' ones ) .",
    "this leads to the notion of a search with several levels of nesting ( i.e. , a nesting depth larger than one ) .    in order to analyze the scaling achieved by several levels of nesting ,",
    "let us consider a search at level @xmath22 which corresponds to the @xmath31-th nesting level .",
    "we suppose that this search relies itself on a search at level @xmath207 , where @xmath209 , which corresponds therefore to the @xmath210-th nesting level .",
    "let @xmath211 and @xmath212 , where @xmath213 and @xmath214 denote the reduced level on the tree at the @xmath31-th and @xmath210-th nesting level , respectively .",
    "assume that the quantum computation cost at level @xmath207 is given by @xmath215 where @xmath216 is the scaling coefficient at the @xmath210-th level of nesting ( level @xmath207 in the tree ) .",
    "using the structure at level @xmath207 , the quantum computation cost at level @xmath22 can be written as @xmath217 by optimizing @xmath207 so that @xmath218 is minimum , as before , we obtain @xmath212 , where @xmath214 is a solution of @xmath219 with @xmath220 . defining the scaling coefficient @xmath221 by @xmath222 we see that the corresponding computation cost at level @xmath22 is given by @xmath223 thus , to determine the cost of the global algorithm , we need to solve the set of recurrence equations  ( [ eq_rec1])-([eq_rec2 ] ) for @xmath224 , where @xmath7 is the nesting depth ( @xmath225 corresponds to the algorithm described in sect .",
    "[ sect_core ] ) .",
    "the boundary conditions are @xmath226 ( the upper level is a search for solutions at the bottom of the tree , i.e. , at level @xmath9 ) and @xmath227 ( the innermost search at the @xmath7-th level of nesting is supposed to be a naive search ) .",
    "these two conditions , together with the @xmath228 recurrence relations , uniquely determine the variables @xmath229 and @xmath230 .",
    "the overall scaling of the quantum search algorithm is @xmath231 , i.e. , it is governed by @xmath232 ( the constant that was denoted as @xmath5 in the previous sections ) .",
    "note that this entire calculation is also valid for a classical nested search with several levels of nesting , except for the square root .",
    "thus , the speedup of the multi - nested quantum search algorithm remains a square root if compared with the corresponding multi - nested classical search algorithm .",
    "we show in table  [ table1 ] the values of the @xmath213 s and @xmath221 s for an average instance of maximum difficulty ( @xmath52 ) of the graph coloring problem ( @xmath20 ) .",
    "the scaling coefficient @xmath232 decreases with an increasing nesting depth @xmath7 , implying that the speedup over an unstructured search improves by adding further nesting levels .",
    "it should be emphasized , however , that the formalism used to estimate the scaling throughout this paper can not be used for a large nesting depth @xmath7 .",
    "indeed , the derivation of @xmath47 essentially neglects the correlations between partial solutions at any level in the tree which arise because of their sharing a same ancestor .",
    "thus , our cost estimate for the multi - nested algorithm is only valid provided that @xmath233 ( the fact that @xmath234 when @xmath235 is meaningless ) .",
    "there is considerable interest in the possibility of using quantum computers to speedup the solution of np - complete problems given the importance of these problems in complexity theory and their ubiquity amongst practical computational applications .",
    "this paper presents an attempt in this direction by showing that nesting the standard quantum search algorithm results in a faster quantum algorithm for structured search problems such as the constraint satisfaction problem than heretofore known .",
    "the key innovation is to cast the construction of solutions of the problem as a quantum search through a tree of partial solutions , which narrows a subsequent quantum search at the next level in the search tree .",
    "the corresponding computation time scales exponentially , but with a reduced coefficient that depends on the number of nesting levels and on the problem .",
    "the speedup that is achieved is a square root over the computation time of a corresponding classical nested search algorithm , which represents therefore the appropriate benchmark .",
    "nevertheless , it is an exponential improvement with respect to the time needed to solve the problem by use of the standard unstructured quantum search algorithm .",
    "njc is supported in part by the nsf under grant nos .",
    "phy 94 - 12818 and phy 94 - 20470 , and by a grant from darpa / aro through the quic program ( # daah04 - 96 - 1 - 3086 ) .",
    "cpw is supported by the nasa / jpl center for integrated space microsystems ( grant 277 - 3r0u0 - 0 ) and nasa advanced concepts ( grant 233 - 0nm71 - 0 ) .",
    "njc is _ collaborateur scientifique _ of the belgian national fund for scientific research .",
    ".reduced level @xmath213 on the tree and corresponding scaling coefficient @xmath221 at the @xmath31-th level of nesting for the graph coloring problem ( @xmath20 ) at @xmath52 .",
    "the variable @xmath7 denotes the nesting depth , and @xmath232 governs the scaling of the overall quantum ( or classical ) algorithm . [ cols=\"<,^,^,^,^,^,^,^,^\",options=\"header \" , ]",
    "let us derive an approximate functional form for @xmath47 , the probability that a node at level @xmath22 in the search tree is `` good '' .",
    "the derivation is complicated by the fact that the same problem instance can be easy or hard depending on the _ order _ in which the variables are assigned values .",
    "this is because it is possible that the constraints are such that a particular variable can only take one possible value . if this variable is examined early in the search process , the recognition that the value is highly constrained would permit a large fraction of the search space to be avoided .",
    "conversely , if this variable is examined late in the search process , much of the tree might already have been developed , resulting in relatively little gain .",
    "however , the algorithm described in sec .  [ sect_nested_class ] is a naive algorithm that does _ not _ optimize the order in which the variables are assigned values .",
    "thus , we can compute the probability @xmath47 for an average tree having a _ random _ variable ordering .    the simplest way to do",
    "this is to consider a _ lattice _ of partial solutions rather than a _ tree _ of partial solutions , because a lattice of partial solutions effectively encodes all possible variable orderings . in particular",
    ", the @xmath22th level of a lattice of partial solutions represents all possible subsets of @xmath22 variables out of @xmath9 variables , assigned values in all possible combinations .",
    "thus , in a lattice there are @xmath236 nodes at level @xmath22 rather than the @xmath54 nodes in a tree .",
    "so each level of the lattice encodes the information contained in @xmath237 different trees .",
    "as each constraint involves exactly @xmath18 variables , and each variable can be assigned any one of its @xmath8 allowed values , there are exactly @xmath238 `` ground instances '' of each constraint . moreover , as each constraint involves a different combination of @xmath18 out of a possible @xmath9 variables , there can be at most @xmath239 constraints .",
    "each ground instance of a constraint may be `` good '' or `` nogood '' , so the number of ground instances that are `` nogood '' , @xmath19 , must be such that @xmath240 .",
    "if @xmath19 is small the problem typically has many solutions .",
    "if @xmath19 is large the problem typically has few , or perhaps no , solutions .",
    "the exact placement of the @xmath19 nogoods is , of course , important in determining the their ultimate pruning power .",
    "thus to estimate @xmath47 in an _ average _ tree , we calculate the corresponding probability that a node in the lattice ( which implicitly incorporates _ all _ trees ) is `` nogood '' , conditional on there being @xmath19 `` nogoods '' at level @xmath18 . for a node at level @xmath22 of the lattice to be `` good '' it must not sit above any of the @xmath19 `` nogoods '' at level @xmath18 .",
    "a node at level @xmath22 of the lattice sits above @xmath241 nodes at level @xmath18 .",
    "thus , out of a total possible pool of @xmath242 nodes at level @xmath18 , we must exclude @xmath241 of them .",
    "however , we can pick the @xmath19 nogoods from amongst the remaining nodes in any way whatsoever .",
    "hence the probability that a node is `` good '' at level @xmath22 , given that there are @xmath19 `` nogoods '' at level @xmath18 , is given by the ratio of the number of ways to pick the `` nogoods '' such that a particular node at level @xmath22 is `` good '' , to the total number of ways of picking the @xmath19 `` nogoods '' . as a consequence , the probability for a partial solution to be good at level @xmath22 in a tree of height @xmath9 and branching ratio @xmath8 can be approximated as  @xcite @xmath243 where @xmath18 is the size of the constraint ( i.e. , number of variables involved in a constraint ) and @xmath19 is the number of `` nogood '' ground instances ( or number of constraints ) .",
    "this approximation essentially relies on the assumption that the partial solutions at a given level are uncorrelated .",
    "now , we are interested in obtaining an asymptotic expression for @xmath47 for large problems , i.e. , when the number of variables @xmath48 .",
    "recall that to scale a constraint satisfaction problem up , however , it is not sufficient to increase only @xmath9 .",
    "in addition , we ought also to increase the number of constraints so as to preserve the `` constrainedness - per - variable '' , @xmath244 .",
    "thus , when we consider scaling our problems up , as we must do to assess the asymptotic behavior of the classical and quantum structured search algorithms , we have @xmath48 and scale @xmath167 , keeping @xmath24 , @xmath8 and @xmath18 constant .",
    "we now make the assumption that @xmath245 and @xmath246 , which is justified in the asymptotic regime . using stirling formula",
    ", we have @xmath247 for large @xmath248 and @xmath7 , provided that @xmath249 .",
    "this allows us to reexpress eq .",
    "( [ eq_colin_tad ] ) as @xmath250 now , assuming that @xmath251 and @xmath252 , and reusing eq .",
    "( [ eq_approxbinom ] ) , we have @xmath253 for large @xmath22 and @xmath9 .",
    "finally , assuming for simplicity that @xmath254 and @xmath255 , we obtain @xmath256 where @xmath244 measures the difficulty of the problem and @xmath168 is the critical value around which the problem is the most difficult .",
    "plugging eq .",
    "( [ eq_p(i)_app ] ) into eq .",
    "( [ eq_tclass ] ) , we obtain an approximate expression of the classical computation time needed to solve an average instance with fixed @xmath24 @xmath257 where the denominator is simply the expected number of solutions .",
    "let us now find the level @xmath22 where it is optimum to `` cut '' the tree .",
    "the value of @xmath22 which minimizes @xmath55 corresponds , for large @xmath9 , to the situation where both terms in the numerator grow with the same power of @xmath8 , i.e. , the solution of the equation @xmath258 .",
    "then , one can show that the computation time approximately scales as @xmath259 where the scaling coefficient @xmath260 with @xmath177 , the fraction of the height at which one cuts the tree , being the solution of eq .",
    "( [ eq_equationforx ] ) such that @xmath261 . for problems of maximum difficulty ( @xmath52 ) , i.e. , problems which admit a single solution on average , the classical time scales thus as @xmath262 for a search space of dimension @xmath58 .",
    "this represents a significant improvement over a classical search that does not exploit the structure , i.e. , @xmath263 .",
    "the unstructured quantum search algorithm is based on iterating @xmath31 times the operator @xmath264 where @xmath90 is a c - number ( with @xmath265 ) .",
    "the iterated operator can be written exactly as @xmath266 where @xmath267 is the chebyshev polynomial of the second kind . by making use of @xmath268 , @xmath269 , and @xmath270 , it is easy to check that , for @xmath271 , eq .",
    "( [ eq_chebyshev ] ) @xmath272 is indeed consistent with eq .",
    "( [ eq_defq_app ] ) .",
    "now , using the recursion formula for chebyshev polynomials , @xmath273 we can verify easily that the product of @xmath84 and @xmath92 , as defined by eq .",
    "( [ eq_chebyshev ] ) , yields @xmath274 . indeed ,",
    "@xmath275 we can use eq .",
    "( [ eq_chebyshev ] ) to calculate the exact amplitude of the target state @xmath65 after @xmath31 iterations , that is @xmath276 equivalently , we can write @xmath277 by using the recursion formula @xmath278 where @xmath279 is the chebyshev polynomial of the first kind .",
    "note that , at the limit of @xmath280 , it is easy to show that @xmath281 and @xmath282 , so that we obtain @xmath283 in agreement with eq .",
    "( [ eq_10 ] ) .",
    "thus , the second term in eq .",
    "( [ eq_c9 ] ) mainly contributes to the amplitude of the target state @xmath65 at the limit of small @xmath95 .",
    "p. w. shor , _ algorithms for quantum computation : discrete logarithms and factoring _ , in proc .",
    "35th annual symposium on foundations of computer science , edited by s. goldwasser , ( ieee computer society press , new york , 1994 ) , pp .",
    "124 - 134 .",
    "p. w. shor , siam journal on computing , * 26 * , 1484 ( 1997 ) .",
    "l. k. grover , _ a fast quantum mechanical algorithm for database search _ , in : proc .",
    "28th annual symposium on the theory of computing , ( acm press , new york , 1996 ) , pp .",
    "212 - 219 .",
    "l. k. grover , _ quantum mechanics helps in searching for a needle in a haystack _ , phys .",
    "lett . * 79 * , 325 ( 1997 ) .",
    "e. farhi and s. gutmann , _ quantum computation and decision trees _ , los - alamos e - print quant - ph/9706062 , to appear in phys .",
    "a ( 1998 ) . t. hogg , _ highly structured searches with quantum computers _ , phys .",
    "lett . * 80 * , 2473 ( 1998 ) .",
    "m. r. garey and d. s. johnson , _ computers and intractability : a guide to the theory of np - completeness _ , ( w. h. freeman , san francisco , 1979 ) .",
    "a. lenstra and h. lenstra , _ the development of the number field sieve _ , lectures notes in mathematics * 1554 * , ( springer verlag , new york , 1993 ) .    c. h. bennett , e. bernstein , g. brassard , and u. vazirani , _ strengths and weaknesses of quantum computing _",
    ", siam journal on computing * 26 * , 1510 ( 1997 ) . ; also in los - alamos e - print quant - ph/9701001 .",
    "m. boyer , g. brassard , p. hoyer , and a. tapp , _",
    "tight bounds on quantum searching _ , in : proc .",
    "4th workshop on physics and computation , edited by t. toffoli , m. biafore , and j. leao , ( new england complex systems institute , boston , 1996 ) , p. 36 ; also in los - alamos e - print quant - ph/9605034 .",
    "c. zalka , _",
    "grover s quantum searching algorithm is optimal _ , los - alamos e - print quant - ph/9711070 .",
    "t. hogg , _ a framework for structured quantum search _ , los - alamos e - print quant - ph/9701013 , to appear in physica d ( 1998 ) .",
    "e. farhi and s. gutmann , _ quantum mechanical square root speedup in a structured search problem _ , los - alamos e - print quant - ph/9711035 .",
    "l. k. grover , _ quantum search on structured problems _ , proc .",
    "1st nasa int . conf . on quantum computing and quantum communications",
    "; also in los - alamos e - print quant - ph/9802035 .      p. cheeseman , b. kanefsky , and w. m. taylor , _ where the really hard problems are _ , in proc . of international joint conference on artificial intelligence ( ijcai91 ) , sydney , ( morgan kauffman , 1991 ) , pp",
    "331 - 337 .",
    "c. p. williams and t. hogg , _ using deep structure to locate hard problems _ , in proc .",
    "10th national conf . on artificial intelligence",
    "( aaai92 ) , ( aaai press , menlo park , ca , 1992 ) , pp . 472 - 477 . c. p. williams and t. hogg ,",
    "_ extending deep structure _ , in proc .",
    "11th national conf . on artificial intelligence",
    "( aaai93 ) , ( aaai press , menlo park , ca , 1993 ) , pp . 152 - 157 .    s. kirkpatrick and b. selman , _ critical behavior in the satisfiability of random boolean expressions _ , science * 264 * , 1297 ( 1994 ) . c. p. williams and t. hogg ,",
    "_ expected gains from parallelizing constraint solving for hard problems _ , in proc .",
    "12th national conf . on artificial intelligence",
    "( aaai94 ) , ( aaai press , menlo park , ca , 1994 ) , pp .",
    "1310 - 1315 ."
  ],
  "abstract_text": [
    "<S> a quantum algorithm is known that solves an unstructured search problem in a number of iterations of order @xmath0 , where @xmath1 is the dimension of the search space , whereas any classical algorithm necessarily scales as @xmath2 . </S>",
    "<S> it is shown here that an improved quantum search algorithm can be devised that exploits the structure of a tree search problem by _ nesting _ this standard search algorithm . the number of iterations required to find the solution of an average instance of a constraint satisfaction problem scales as @xmath3 , with a constant @xmath4 depending on the nesting depth and the problem considered . </S>",
    "<S> when applying a single nesting level to a problem with constraints of size  2 such as the graph coloring problem , this constant @xmath5 is estimated to be around  0.62 for average instances of maximum difficulty . </S>",
    "<S> this corresponds to a square - root speedup over a classical nested search algorithm , of which our presented algorithm is the quantum counterpart . </S>"
  ]
}