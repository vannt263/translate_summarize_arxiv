{
  "article_text": [
    "abstract argumentation @xcite is at the heart of many advanced argumentation systems  @xcite and is concerned with finding jointly acceptable arguments by taking only their inter - relationships into account .",
    "efficient solvers for abstract argumentation are thus an important development , a fact that is also witnessed by a new competition which takes place in 2015 for the first time  @xcite .    to date , several approaches for implementing abstract argumentation exist , many of them following the so - called reduction - based ( see @xcite ) paradigm : hereby , existing efficient software which has originally been developed for other purposes is used .",
    "prominent examples for this approach are ( i ) the csp - based system conarg  @xcite , ( ii ) sat - based approaches ( e.g.  @xcite ) and ( iii ) systems which rely on answer - set programming ( asp ) ; see @xcite for a comprehensive survey .",
    "in fact , asp @xcite is particularly well - suited since asp systems by default enumerate all solutions of a given program , thus enabling the enumeration of extensions of an abstract argumentation framework in an easy manner .",
    "moreover , disjunctive asp is capable of expressing problems being even complete for the 2nd level of the polynomial hierarchy .",
    "in fact , several semantics for abstract argumentation like preferred , semi - stable  @xcite , or stage  @xcite are of this high complexity @xcite .",
    "one particular candidate for an asp reduction - based system is aspartix @xcite . here ,",
    "a fixed program for each semantics is provided and the argumentation framework under consideration is just added as an input - database . the program together with the input - database is then handed over to an asp system of choice in order to calculate the extensions .",
    "this makes the aspartix approach easy to adapt and an appealing rapid - prototyping method .",
    "the proposed encodings in aspartix for the high - complexity semantics mentioned above come , however , with a certain caveat .",
    "this stems from the fact that encodings for such complex programs have to follow a certain saturation pattern , where restricted use of cyclic negation has to be taken care of ( we refer to @xcite for a detailed discussion ) .",
    "the original encodings followed the definition of the semantics quite closely and thus resulted in quite complex and tricky loop - techniques which are a known feature for asp experts , but hard to follow for asp laymen .",
    "moreover , experiments in other domains indicated that such loops also potentially lead to performance bottlenecks .    in this work",
    ", we thus aim for new and simpler encodings for the three semantics of preferred , semi - stable , and stage extensions . to this end , we provide some alternative characterizations for these semantics and design our new encodings along these characterizations in such a way that costly loops are avoided . instead we make use of the asp language feature of conditional literals in disjunction  @xcite .",
    "moreover , we perform exhaustive experimental evaluation against the original aspartix - encodings , the conarg system , and another asp - variant @xcite which makes use of the asp front - end _ metasp _",
    "@xcite , where the required maximization is handled via meta - programming .",
    "our results show that the new asp encodings not only outperform the previous variants , but also makes aspartix more powerful than conarg .",
    "the novel encodings together with the benchmark instances are available under http://dbai.tuwien.ac.at / research / project / argumentation/% systempage/#conditional[http://dbai.tuwien.ac.at / research / project / argumentation/% systempage/#conditional ] .",
    "[ [ acknowledgements ] ] acknowledgements + + + + + + + + + + + + + + + +    this work has been funded by the austrian science fund ( fwf ) through projects y698 and i1102 , by the german research foundation ( dfg ) through project ho 1294/11 - 1 , and by academy of finland through grants 251170 coin and 284591 .",
    "first , we recall the main formal ingredients for argumentation frameworks  @xcite and survey relevant complexity results ( see also  @xcite ) .    [ def : af ]",
    "an _ argumentation framework ( af ) _ is a pair @xmath0 where @xmath1 is a set of arguments and @xmath2 is the attack relation .",
    "the pair @xmath3 means that @xmath4 attacks @xmath5 .",
    "an argument @xmath6 is _ defended _ by a set @xmath7 if , for each @xmath8 such that @xmath9 , there exists a @xmath10 such that @xmath11 .",
    "we define the _ range of @xmath12 _ ( w.r.t .",
    "@xmath13 ) as @xmath14 .",
    "semantics for argumentation frameworks are given via a function @xmath15 which assigns to each af @xmath0 a set @xmath16 of extensions .",
    "we shall consider here for @xmath15 the functions @xmath17 , @xmath18 , @xmath19 , @xmath20 , and @xmath21 which stand for stable , admissible , preferred , stage , and semi - stable semantics respectively .",
    "[ def : semantics ] let @xmath0 be an af .",
    "a set @xmath22 is _ conflict - free ( in @xmath23 ) _ , if there are no @xmath24 , such that @xmath3 .",
    "@xmath25 denotes the collection of conflict - free sets of @xmath23 . for a conflict - free set @xmath26",
    ", it holds that    * @xmath27 , if @xmath28 ; * @xmath29 , if each @xmath30 is defended by @xmath12 ; * @xmath31 , if @xmath29 and there is no @xmath32 with @xmath33 ; * @xmath34 , if @xmath29 and there is no @xmath32 with @xmath35 ; * @xmath36 , if there is no @xmath37 in @xmath23 , such that @xmath35 .",
    "[ example : af ] consider the af @xmath38 with @xmath39 and @xmath40 , @xmath41 , @xmath42 , @xmath43 , @xmath44 , @xmath45 , @xmath46 , @xmath47 , and the graph representation of @xmath48 :    node[arg](a)@xmath4 + + ( 1,0 ) node[arg , inner sep=3](b)@xmath5 + + ( 1,.4 ) node[arg](c)@xmath49 + + ( 0,-0.8 ) node[arg , inner sep=2.8](d)@xmath50 + + ( 1,0.4 ) node[arg](e)@xmath51 + + ( 1,0 ) node[arg , inner sep=1.8](f)@xmath52 ; ; ( a ) edge ( b ) ( c ) edge ( b ) ( b ) edge ( d ) ( d ) edge ( e ) ( c ) edge ( e ) ( e ) edge ( f ) ; ( c ) edge ( d ) ( d ) edge ( c ) ;    we have @xmath53 .",
    "the admissible sets of @xmath48 are @xmath54 , @xmath55 , @xmath56 , @xmath57 , @xmath58 , @xmath59 , @xmath60 , @xmath61 , and @xmath62,@xmath63 .",
    "we recall that each af @xmath48 possesses at least one preferred , semi - stable , and stage extension , while @xmath64 might be empty .",
    "however , it is well known that @xmath65 implies @xmath66 as also seen in the above example .",
    "next , we provide some alternative characterisations for the semantics of our interest .",
    "they will serve as the basis of our encodings .",
    "the alternative characterisation for preferred extensions relies on the following idea .",
    "an admissible set @xmath12 is preferred , if each other admissible set @xmath67 ( which is not a subset of @xmath12 ) is in conflict with @xmath12 .",
    "[ prop:2 ] let @xmath38 be an af and @xmath22 be admissible in @xmath48 .",
    "then , @xmath68 if and only if , for each @xmath69 such that @xmath70 , @xmath71 .",
    "let @xmath72 and assume there exists an admissible ( in @xmath48 ) set @xmath70 , such that @xmath73 .",
    "it is well known ( see , e.g. @xcite , lemma 1 ) that if two sets @xmath74 defend themselves in an af @xmath48 , then also @xmath75 defends itself in @xmath48 .",
    "it follows that @xmath76 and by assumption @xmath77 .",
    "thus , @xmath78 . for the other direction , let @xmath72 but @xmath78 .",
    "hence , there exists an @xmath79 such that @xmath80 .",
    "clearly , @xmath81 but @xmath82 .",
    "we turn to semi - stable and stage semantics . in order to verify",
    "whether a candidate extension @xmath12 is a stage ( resp .",
    "semi - stable ) extension of an af @xmath48 , we check whether for any set @xmath83 such that @xmath84 there is no conflict - free ( resp .",
    "admissible ) set @xmath67 such that @xmath85 .",
    "we also show that is sufficient to check this for minimal such sets @xmath83 .",
    "observe that the above check is trivially true if @xmath12 is already stable , mirroring the observation that @xmath66 whenever @xmath65 .",
    "let @xmath38 be an af and @xmath22 .",
    "a _ cover _ of @xmath12 in @xmath48 is any @xmath86 such that @xmath87 .",
    "the set of covers of @xmath12 in @xmath48 is denoted by @xmath88 .",
    "[ prop:1 ] let @xmath38 be an af and @xmath89 ( resp .",
    "the following propositions are equivalent : ( 1 ) @xmath12 is a stage ( resp .  semi - stable ) extension of @xmath48 ; ( 2 ) for each @xmath91 , there is no @xmath92 such that @xmath93 ( resp .",
    "@xmath69 ; ( 3 ) for each @xmath83 with @xmath94 , there is no @xmath95 , such that @xmath93 ( resp .",
    "@xmath69 ) .",
    "we give the proof for stage extensions .",
    "the result for semi - stable proceeds analogously .",
    "( 1)@xmath96(3 ) : suppose there is an @xmath83 with @xmath94 , such that some @xmath95 is conflict - free in @xmath48 . by definition ,",
    "hence , @xmath98 .",
    "( 2)@xmath96(1 ) : suppose @xmath98 .",
    "thus there exists @xmath99 with @xmath100 .",
    "let @xmath101 .",
    "it follows that @xmath102 .",
    "( 3)@xmath96(2 ) is clear .    finally , we turn to the complexity of reasoning in afs for two major decision problems . for a given af @xmath38 and an argument @xmath103 , credulous reasoning under @xmath15",
    "denotes the problem of deciding whether there exists an @xmath104 s.t .",
    "skeptical acceptance under @xmath15 is the problem of deciding whether for all @xmath104 it holds that @xmath105 .",
    "credulous reasoning for preferred semantics is @xmath106-complete , while credulous reasoning for semi - stable and stage semantics is @xmath107-complete . for preferred ,",
    "semi - stable , and stage semantics skeptical reasoning is @xmath108-complete  @xcite .",
    "we give an overview of the syntax and semantics of disjunctive logic programs under the answer - sets semantics  @xcite .",
    "we fix a countable set @xmath109 of _ ( domain ) elements _ , also called _ constants _ ; and suppose a total order @xmath110 over the domain elements .",
    "atom _ is an expression @xmath111 , where @xmath112 is a _ predicate _ of arity @xmath113 and each @xmath114 is either a variable or an element from @xmath109 .",
    "an atom is _ ground _ if it is free of variables .",
    "@xmath115 denotes the set of all ground atoms over @xmath109",
    ". a _ ( disjunctive ) rule _",
    "@xmath116 is of the form @xmath117 with @xmath118 @xmath119 , @xmath120 , where @xmath121 are literals , and `` @xmath122 '' stands for _",
    "default negation_. the _ head _ of @xmath116 is the set @xmath123 = @xmath124 and the _ body _ of @xmath116 is @xmath125 @xmath126 @xmath127 .",
    "furthermore , @xmath128 = @xmath129 and @xmath130 = @xmath131 .",
    "a rule @xmath116 is _ normal _ if @xmath132 and a _ constraint _ if @xmath133 .",
    "a rule @xmath116 is _ safe _ if each variable in @xmath116 occurs in @xmath128 .",
    "a rule @xmath116 is _ ground _ if no variable occurs in @xmath116 .",
    "a _ fact _ is a ground rule without disjunction and empty body",
    ". an _ ( input ) database _ is a set of facts .",
    "a program is a finite set of disjunctive rules . for a program @xmath134 and an input database @xmath135",
    ", we often write @xmath136 instead of @xmath137 . if each rule in a program is normal ( resp .",
    "ground ) , we call the program normal ( resp .  ground ) . for any program @xmath134 , let @xmath138 be the set of all constants appearing in @xmath134 .",
    "@xmath139 is the set of rules @xmath140 obtained by applying , to each rule @xmath141 , all possible substitutions @xmath15 from the variables in @xmath116 to elements of @xmath142 .",
    "an _ interpretation _",
    "@xmath143 _ satisfies _ a ground rule @xmath116 iff @xmath144 whenever @xmath145 and @xmath146 .",
    "@xmath147 satisfies a ground program @xmath134 , if each @xmath141 is satisfied by @xmath147 . a non - ground rule @xmath116 ( resp .",
    ", a program @xmath134 ) is satisfied by an interpretation @xmath147 iff @xmath147 satisfies all groundings of @xmath116 ( resp . , @xmath139 ) .",
    "@xmath148 is an _ answer set _ of @xmath134 iff it is a subset - minimal set satisfying the _ gelfond - lifschitz reduct _ @xmath149 . for a program @xmath134",
    ", we denote the set of its answer sets by @xmath150 .",
    "modern asp solvers offer additional language features . among them",
    "we make use of the _ conditional literal _  @xcite . in the head of a disjunctive rule",
    "literals may have conditions , e.g.  consider the head of rule `` @xmath151 '' . intuitively , this represents a head of disjunctions of atoms @xmath152 where also @xmath153 is true .      for our novel encodings",
    "we utilize basic encodings for afs , conflict - free sets , and admissible sets from  @xcite .",
    "an af is represented as a set of facts .",
    "let @xmath0 be an af .",
    "we define @xmath154 .    in the following definition we first formalize the correspondence between an extension , as subset of arguments , and an answer set of an asp encoding ;",
    "then we extend it to the one between sets of extensions and answer sets respectively .",
    "[ def : correspondence ] let @xmath155 be a collection of sets of domain elements and let @xmath156 be a collection of sets of ground atoms .",
    "we say that @xmath157 and @xmath158 correspond to each other , in symbols @xmath159 , iff @xmath160 .",
    "we say that @xmath161 and @xmath162 correspond to each other , in symbols @xmath163 , iff ( i ) for each @xmath157 , there exists an @xmath158 , such that @xmath164 ; and ( ii ) for each @xmath158 , there exists an @xmath157 , such that @xmath159 .",
    "it will be convenient to use the following notation and result later in  .",
    "let @xmath165 be sets of ground atoms .",
    "we say that @xmath147 and @xmath166 are equivalent , in symbols @xmath167 , iff @xmath168 .",
    "lmalmaequiv [ th : equiv ] let @xmath165 , and @xmath169 .",
    "if @xmath167 and @xmath164 , then @xmath170 .",
    "in   we see the asp encoding for conflict - free sets , while   shows defense of arguments .",
    "the encoding for admissible sets is given by @xmath171 .",
    "the following has been proven in  ( * ? ? ?",
    "* proposition 3.2 ) .",
    "[ prop : partition ] for any af @xmath0 , and any @xmath172 , @xmath173 is a partition of @xmath1 .    ....",
    "in(x ) : - arg(x ) , not out(x).\\label{line : cf - r1} out(x ) : - arg(x ) , not in(x).\\label{line : cf - r2} : - att(x , y ) , in(x ) , in(y).\\label{line : cf-3} ....    ....",
    "defeated(x ) : - in(y ) , att(y , x).\\label{line : adm - r4} undefended(x ) : - att(y , x ) , not defeated(y).\\label{line : adm - r5} : - in(x ) , undefended(x).\\label{line : adm - r6} ....    correctness of the encodings @xmath174 and @xmath175 was proven in  @xcite .",
    "[ th : cf ] [ th : adm ] for any af @xmath23 , we have ( i ) @xmath176 , and ( ii ) @xmath177 .    next , we characterize the encoding @xmath178 ( ) , which , given a module computing some extension @xmath12 ( via @xmath179 ) of an af @xmath180 , returns its range @xmath181 ( via @xmath182 ) and also collects the arguments not contained in the range .",
    "we indicate via @xmath183 that @xmath12 is not stable , i.e.   @xmath184 .    ....",
    "range(x ) : - in(x).\\label{line : rng - r1} range(y ) : - in(x),att(x , y).\\label{line : rng - r2} out_of_range(x ) : -   not range(x),arg(x).\\label{line : rng - r3} unstable : -   out_of_range(x),arg(x).\\label{line : rng - r4} ....    lmaproprange [ prop:5 ] let @xmath0 be an af , and @xmath185 be a program not containing the predicates @xmath186 , @xmath187 and @xmath183 .",
    "let @xmath188 and @xmath7 s.t .",
    "@xmath164 . furthermore let @xmath189 and @xmath190 then , @xmath191 , if and only if @xmath192 .    ....",
    "eq_upto(y ) : - inf(y ) , in(y ) , inn(y ) .",
    "eq_upto(y ) : - inf(y ) , out(y ) , outn(y ) .",
    "eq_upto(y ) : - succ(z , y ) , in(y ) , inn(y ) , eq_upto(z ) .",
    "eq_upto(y ) : - succ(z , y ) , out(y ) , outn(y ) , eq_upto(z ) .",
    "eq : - sup(y ) , eq_upto(y ) .   ....    the preferred , semi - stable  @xcite and stage semantics  @xcite utilize the so - called _",
    "saturation technique_. we sketch here the basic ideas .",
    "intuitively , in the saturation technique encoding for preferred semantics we make a first guess for a set of arguments in the framework , and then we verify if this set is admissible ( via module @xmath193 ) . to verify",
    "if this set is also subset maximal admissible , a second guess is carried out via a disjunctive rule .",
    "if this second guess corresponds to an admissible set that is a proper superset of the first one , then the first one can not be a preferred extension . using the saturation technique",
    "now ensures that if all second guesses `` fail '' to be a strictly larger admissible set of the first guess , then there is one answer - set corresponding to this preferred extension .",
    "usage of default negation within the saturation technique for the second guess is restricted , and thus a loop - style encoding is employed that checks if the second guess is admissible and a proper superset of the first guess .",
    "roughly , a loop construct in asp checks a certain property for the least element in a set ( here we use the predicate @xmath194 ) , and then checks this property `` iteratively '' for each ( immediate ) successor ( via predicate @xmath195 ) . if the property holds for the greatest element ( @xmath196 ) , it holds for all elements . in",
    "we illustrate loop encodings , where we see a partial asp encoding used for preferred semantics in  @xcite that derives * eq * if the first and second guesses are equal , i.e.  the predicates corresponding to the guesses via @xmath197 , resp .",
    "@xmath198 , and @xmath199 , resp .",
    "@xmath200 , are true for the same constants . another variant of asp encodings for preferred , semi - stable and stage semantics is developed by  @xcite .",
    "there so - called meta - asp encodings are used , which allow for minimizing statements w.r.t .",
    "subset inclusion directly in the asp language  @xcite .",
    "for instance , @xmath193 can then be augmented with a minimizing statement on the predicate * out * , to achieve an encoding of preferred semantics .",
    "here we present our new encodings for preferred , semi - stable , and stage semantics via the novel characterizations .",
    "the encoding for preferred semantics is given by @xmath201 , where @xmath202 is provided in  .",
    "we first give the intuition of the program .",
    "a candidate @xmath12 for being preferred in an af @xmath38 is computed by the program @xmath175 via the @xmath197 predicate , and is already known admissible .",
    "if all arguments in @xmath1 are contained in @xmath12 we are done . ] .",
    "otherwise , the remainder of the program @xmath202 ( ) is used to check whether there exists a set @xmath69 such that @xmath70 and not in conflict with @xmath12 .",
    "we start to build @xmath67 by guessing some argument not contained in @xmath12 ( ) and then in we repeatedly add further arguments to @xmath67 unless the set defends itself ( otherwise we eventually derive @xmath203 ) .",
    "then , we check whether @xmath67 is conflict - free ( ) and @xmath67 is not in conflict with @xmath12 ( ) . if we are able to reach this point without deriving @xmath203 , then the candidate @xmath12 can not be an answer - set ( ) . this is in line with proposition  [ prop:2 ] , which states that in this case @xmath12 is not preferred . by inspecting   we also see important differences w.r.t .  the encodings for preferred semantics of  @xcite .",
    "in our new encodings , the `` second guess '' via predicate @xmath204 is constructed through conditional disjunction instead of simple disjunction .",
    "usage of the former allows to construct the witness set already with defense of arguments in mind .",
    "furthermore loops , such as the one shown in   that checks if the second guess is equal to first one or a loop construct that checks if every argument is defended , can be avoided , since these checks are partially incorporated into   of   and into simpler further checks .",
    ".... nontrivial : - out(x).\\label{line : pr - r01} witness(x):out(x ) : - nontrivial.\\label{line : pr - r02} spoil | witness(z):att(z , y ) : - witness(x ) , att(y , x).\\label{line : pr - r03} spoil : - witness(x ) , witness(y ) , att(x , y).\\label{line : pr - r4} spoil : - in(x ) , witness(y ) , att(x , y).\\label{line : pr - r5} witness(x ) : - spoil , arg(x).\\label{line : pr - r6} : -   not spoil , nontrivial.\\label{line : pr - r7} ....    correctness of this new encoding is stated and proved in the following proposition .",
    "[ prop : pref ] for any af @xmath23 , we have @xmath205 .    according to  , we have to prove ( i ) and ( ii ) . with line numbers we refer here to the asp encoding shown in .",
    "we employ the _ splitting theorem _  @xcite in order to get a characterisation of @xmath206 , in which the sub - programs @xmath202 and @xmath175 are considered separately .",
    "the splitting set is @xmath207 @xmath208 @xmath209 , @xmath210 , @xmath197 , @xmath198 , @xmath211 , @xmath212 , and we obtain @xmath213    [ [ proof - i . ] ] proof ( i ) .",
    "+ + + + + + + + + +    we prove that each preferred extension @xmath214 has a corresponding answer - set @xmath215 . from",
    "we know that @xmath215 if @xmath216 , for some @xmath217 .",
    "moreover @xmath214 implies @xmath218 , hence by there is @xmath219 s.t .",
    "@xmath170 . in the following we distinguish between two complementary cases .    in case @xmath220 ,",
    "the set @xmath221 is the only preferred one , since it is trivially admissible and it can not be contained in another set of arguments .",
    "we show @xmath222 is a subset - minimal model of @xmath223 .",
    "the subset - minimality is evident .",
    "then , @xmath224 for any @xmath6 by , hence @xmath166 satisfies the rule at .",
    "since @xmath225 , @xmath166 satisfies the rules at lines [ line : pr - r02 ] , and [ line : pr - r7 ] .",
    "every other rule is satisfied because @xmath226 for any @xmath227 .    in case",
    "@xmath228 we can build an interpretation @xmath147 and prove that @xmath147 is an answer - set by contraposition , i.e. if there is an @xmath229 which satisfies @xmath230 , then @xmath231 .",
    "we define @xmath232 .",
    "we have @xmath164 since @xmath167 .",
    "the set @xmath147 satisfies @xmath230 ( got from @xmath233 by just removing the rule at  ) , as @xmath234 and @xmath147 contains all the heads of the rules in @xmath230 .",
    "notice that @xmath235 guarantees that the head of the rule at   is non - empty .",
    "now we describe the necessary shape of @xmath236 , in order to prove the main assertion next .",
    "@xmath236 must contain @xmath237 because of the rule at  .",
    "indeed @xmath238 for some @xmath239 , since @xmath240 with @xmath241 and @xmath26 ( since @xmath218 ) , which implies the existence of @xmath239 ( we can not have simultaneously @xmath228 , @xmath26 and @xmath221 ) , which implies @xmath242 by  .",
    "we have @xmath243 , otherwise also @xmath244 would be in @xmath236 ( because of the rule at  ) , making @xmath236 equal to @xmath147 , but they are different by assumption .",
    "now we show that , given @xmath236 , it is possible to find a set @xmath245 s.t . @xmath246 and @xmath247 , which implies @xmath231 by  .",
    "we define @xmath248 , and we show all the required properties :    , otherwise we would have two arguments @xmath249 attacking each other , meaning @xmath250 @xmath251 , which implies @xmath252 and @xmath253 for some rule @xmath116 in the grounding of the rule at  , since @xmath243 . , otherwise it would be possible to find two atoms @xmath254 [ @xmath255 in this proof , the square brackets are used to point out an immediate implication of the statement preceding them .",
    "usually the statement is about the framework @xmath23 and the implication about an interpretation , or the other way around . ] and @xmath256 [ @xmath257 for which there is no @xmath258 [ @xmath259 s.t . @xmath260",
    "[ @xmath261 , thus violating the rule at  , since @xmath243 . . indeed",
    "if we assume @xmath262 , then for every @xmath254 we have @xmath263 ( by definition of @xmath264 ) , which corresponds to @xmath265 ( @xmath266 ) , implying @xmath224 ( by  ) , making it impossible for @xmath236 to satisfy the rule at  , since @xmath267 . .",
    "the sets @xmath264 and @xmath12 are conflict - free , so we have to show that there can not be attack relations between the two sets : an argument @xmath263 can not attack an argument @xmath268 , otherwise we would have @xmath269 , @xmath270 , @xmath271 @xmath272 @xmath236 , which implies @xmath252 and @xmath253 for some rule in the grounding of the rule at  , since @xmath243 ; an argument @xmath268 can not attack an argument @xmath263 , otherwise an argument @xmath10 should attack @xmath5 by admissibility of @xmath12 , thus violating the previous point .    [ [ proof - ii . ] ] proof ( ii ) . + + + + + + + + + + +    we prove that each @xmath273 corresponds to an @xmath214 . from",
    "we see that @xmath273 only if @xmath216 for some @xmath219 .",
    "we have @xmath167 , because @xmath234 , and @xmath147 does not have any additional ground atom @xmath270 , since @xmath197 does not appear in the head of any rule of @xmath202 . by",
    "there exists @xmath218 s.t .",
    "@xmath266 , hence @xmath159 by  .",
    "we show that @xmath12 is also preferred in @xmath23 , by distinguishing between two complementary cases .",
    ": we have @xmath274 for any @xmath6 , otherwise the rule at would be violated . by proposition[prop : partition ] this implies @xmath275 for every @xmath6 , and the same is true for @xmath166 ( @xmath276 ) , which we know to be admissible .",
    "hence , @xmath221 and @xmath277 .",
    ": we prove that @xmath12 is preferred by contraposition , i.e. if @xmath231 then @xmath147 is not a subset - minimal model of @xmath230 .",
    "we have that @xmath147 must have a clear shape in order to satisfy @xmath230 .",
    "in particular @xmath234 . then @xmath278 because of the rule at   hence , @xmath279 for each @xmath280 because of the rule at  .",
    "summing up we have @xmath281 .",
    "finally we show that @xmath282 , since we are able to build an interpretation @xmath229 satisfying the reduct @xmath230 .",
    "we remind that @xmath231 means that there exists @xmath283 s.t .",
    "we use @xmath285 to build the interpretation @xmath286 .",
    "we have @xmath229 , because it does not contain @xmath203 and @xmath287 . in the following",
    "we show that @xmath236 is a model of the reduct , because it contains @xmath166 and it satisfies each rule in @xmath288 .",
    "@xmath236 satisfies the rule at  , because there exists @xmath254 s.t .",
    "@xmath289 , for some @xmath290 ( the element @xmath4 exists because @xmath285 is a proper superset of @xmath12 ) .",
    "if @xmath290 , then @xmath291 , then @xmath292 ( @xmath159 ) , then @xmath293 ( @xmath167 ) , then @xmath294 ( by  ) , then @xmath289 ( @xmath295 ) . summing up , if @xmath296 , then @xmath289 , and @xmath254 by definition . ]",
    "since @xmath285 is admissible , for each @xmath297 [ @xmath254 ] attacked by @xmath8 [ @xmath299 there exists @xmath300 [ @xmath258 ] attacking @xmath5 [ @xmath302 . hence @xmath236 satisfies the rule at  , even though @xmath243 .",
    "@xmath236 does not contain the body of any rule in the grounding of the rule at  , otherwise @xmath285 would not be conflict free . @xmath236 does not contain the body of any rule in the grounding of the rule at  , otherwise @xmath285 would not be conflict free , since @xmath284 .",
    "@xmath236 does not contain the body of any rule in the grounding of the rule at  , because it does not contain @xmath203 .",
    "@xmath303      [ [ semi - stable - semantics ] ] semi - stable semantics + + + + + + + + + + + + + + + + + + + + +    the encoding for semi - stable semantics is given by @xmath304 , with @xmath305 shown in .",
    "we first give the intuition .",
    "a candidate @xmath12 for being semi - stable is computed by the program @xmath306 via the @xmath197 predicate and is known admissible .",
    "the module @xmath178 computes the range and derives @xmath183 iff the extension is not stable . if @xmath12 is stable , we are done .",
    "otherwise the remainder of the program @xmath305 is used to check whether an admissible cover @xmath67 of a superset of the range @xmath307 exists .",
    "starting from @xmath307 ( ) , a superset is achieved by adding at least one element out of it ( ) . then a cover is found ( ) , which is admissible ( ) . if we are able to reach this point without deriving @xmath203 ( that is always a possibility for satisfying the constraints ) , then the candidate @xmath12 can not be an answer - set ( ) .",
    "this is in line with , which states that in this case @xmath12 is not semi - stable .",
    "here we state the correctness of the encoding , a full proof is given in the online appendix ( appendix a ) .    ....",
    "larger_range(x):out_of_range(x ) : - unstable.\\label{line : sm - r1} larger_range(x ) : - range(x ) , unstable.\\label{line : sm - r2} witness(x ) | witness(z):att(z , x ) : - larger_range(x ) , unstable.\\label{line : sm - r3} spoil : - witness(x ) , witness(y ) , att(x , y ) , unstable.\\label{line : sm - r4} spoil | witness(z):att(z , y ) : - witness(x ) , att(y , x ) , unstable.\\label{line : sm - r5} witness(x ) : - spoil , arg(x ) , unstable.\\label{line : sm - r6} larger_range(x ) : - spoil , arg(x ) , unstable.\\label{line : sm - r7} : - not spoil , unstable.\\label{line : sm - r8} ....    proppropsemicorrectness [ prop : semi ] for any af @xmath0 , we have @xmath308 .    [",
    "[ stage - semantics ] ] stage semantics + + + + + + + + + + + + + + +    the encoding for stage semantics is given by @xmath309 , where @xmath310 is the rule at of .",
    "the only differences w.r.t .",
    "the encoding for semi - stable semantics are : ( i ) it employs @xmath174 instead of @xmath175 , thus the candidate sets are only conflict - free ; and ( ii ) it lacks the rule at , hence it considers all the conflict - free covers of the candidate set , which is still in line with .",
    "a proof sketch for the forthcoming correctness result is given in the online appendix ( appendix a ) .",
    "proppropstagecorrectness for any af @xmath0 , we have @xmath311 .",
    "we tested the novel encodings ( new ) extensively and compared them to the original ( original ) and metasp ( meta ) encodings as well as to the system conarg  @xcite .",
    "for the novel and original encodings we used _",
    "clingo 4.4 _ and for the metasp encodings we used _",
    "gringo3.0.5/clasp3.1.1 _ all from the potassco group . as benchmarks",
    ", we considered a collection of frameworks which have been used by different colleagues for testing before consisting of structured and randomly generated afs , resulting in 4972 frameworks .",
    "in particular we used parts of the instances federico cerutti provided to us which have been generated towards an increasing number of sccs  @xcite .",
    "further benchmarks were used to test the system _ dynpartix _ and we included the instances provided by the iccma 2015 organizers .",
    "the full set is available at http://dbai.tuwien.ac.at/research/project/argumentation/systempage/#conditional .    for each framework",
    "the task is to enumerate all solutions .",
    "the computation has been performed on an intel xeon e5 - 2670 running at 2.6ghz . from the 16 available cores we used only every fourth core to allow a better utilization of the cpu s cache .",
    "we applied a 10 minutes timeout , allowing to use at most 6.5 gb of main memory .",
    "it turns out that for each semantics the new encodings significantly outperform the original ones as well as the system conarg .",
    "furthermore , there is a clear improvement to the metasp encodings , as illustrated in fig .",
    "[ fig : runtimes ] which shows the cactus plots of the required runtime to solve frameworks ( x - axis ) with the respective timeout ( y - axis ) for the three discussed semantics .",
    "while for preferred and semi - stable semantics the novel encodings are able to solve more than 4700 instances ( out of 4972 ) , one can observe a different trend for stage semantics .",
    "there , the new encodings return the best result with 2501 solved instances .",
    "table  [ tab : summary ] gives a summary of the test results , where _ usc _ denotes the unique solver contribution , i.e.   the number of afs which could only be solved by the particular solver , _ solved _ gives the number of solved instances by the solver , and _ med _ is the median of the computation time of the solver .",
    ".summary of test results.[tab : summary ] [ cols=\"<,<,<,>,<,<,<,>,<,<,<,>\",options=\"header \" , ]     interestingly , conarg is able to solve 60 ( resp .",
    "50 ) instances for preferred ( resp .",
    "semi - stable ) semantics which are not solvable by the other systems . however , the novel encodings are able to uniquely solve 101 ( resp .",
    "82 ) instances for preferred ( resp .",
    "stage ) semantics .",
    "the original encodings have no _ unique solver contribution _ for all of the considered semantics , thus it is save to replace them with the new encodings .",
    "the entries for the median also show that all the novel encodings perform much faster than the other systems , except for semi - stable where conarg has the lowest median . however , here conarg is able to solve about 1300 instances less than the novel encodings .",
    "another interesting observation is that the grounding size of all new encodings is significantly smaller than of both the original and the metasp encodings .",
    "in this work , we have developed novel asp encodings for computationally challenging problems arising in abstract argumentation .",
    "our new encodings for preferred , semi - stable , and stage semantics avoid complicated loop constructs present in previous encodings .",
    "in addition to being more succinct , our empirical evaluation showed that a significant performance boost was achieved compared to the earlier asp encodings , and that our encodings outperform the state - of - the - art system conarg . from an asp perspective ,",
    "our results indicate that loops in saturation encodings ( as used in the previous encodings in @xcite ) are a severe performance bottleneck which should be avoided .    in future work , we plan to compare our results also with the systems cegartix @xcite and argsemsat @xcite .",
    "furthermore , we also aim for finding better asp encodings for the ideal  @xcite and eager semantics  @xcite .",
    "constraint - based computational framework for argumentation systems . in _ proceedings of the 23rd",
    "ieee international conference on tools with artificial intelligence ( ictai 2011 ) _ , t.  m. khoshgoftaar and x.  h. zhu , eds .",
    "ieee computer society press , 605612 .            ,",
    "giacomin , m. , and vallati , m. 2014 . solving argumentation problems using sat . in _ proceedings of the 5th international conference on computational models of argument ( comma 2014 ) _ ,",
    "s.  parsons , n.  oren , c.  reed , and f.  cerutti , eds .",
    "faia , vol . 266 .",
    "ios press , 455456 .    , oren , n. , strass , h. , thimm , m. , and vallati , m. 2014 .",
    "a benchmark framework for a computational argumentation competition . in _ proceedings of the 5th international conference on computational models of argument ( comma 2014 ) _ , s.  parsons , n.  oren , c.  reed , and f.  cerutti , eds .",
    "faia , vol . 266 .",
    "ios press , 459460 .                ,",
    "dvok , w. , linsbichler , t. , and woltran , s. 2014 .",
    "characteristics of multiple viewpoints in abstract argumentation . in _ proceedings of the 14th international conference on principles of knowledge representation and reasoning ( kr 2014 ) _ , c.  baral , g.  de giacomo , and t.  eiter , eds .",
    "aaai press , 7281 .        ,",
    "gaggl , s.  a. , wallner , j.  p. , and woltran , s. 2013 . making use of advances in answer - set programming for abstract argumentation systems . in _ proceedings of the 19th international conference on applications of declarative programming and knowledge management ( inap 2011 ) , revised selected papers _",
    ", h.  tompits , s.  abreu , j.  oetsch , j.  phrer , d.  seipel , m.  umeda , and a.  wolf , eds .",
    "lnai , vol .",
    "springer , 114133 .",
    "\\2011 . argumentation and answer set programming . in _ logic programming , knowledge representation , and nonmonotonic",
    "reasoning : essays in honor of michael gelfond _ ,",
    "m.  balduccini and t.  c. son , eds .",
    "lncs , vol .",
    "springer , 164180 .    ,",
    "cerutti , f. , and giacomin , m. 2014 .",
    "argumentation frameworks features : an initial study . in _ proceedings of the 21st european conference on artificial intelligence ( ecai 2014 ) _",
    ", t.  schaub , g.  friedrich , and b.  osullivan , eds .",
    "faia , vol .",
    "ios press , 11171118 ."
  ],
  "abstract_text": [
    "<S> the design of efficient solutions for abstract argumentation problems is a crucial step towards advanced argumentation systems . </S>",
    "<S> one of the most prominent approaches in the literature is to use answer - set programming ( asp ) for this endeavor . in this paper , we present new encodings for three prominent argumentation semantics using the concept of conditional literals in disjunctions as provided by the asp - system clingo . </S>",
    "<S> our new encodings are not only more succinct than previous versions , but also outperform them on standard benchmarks .    </S>",
    "<S> # 1    [ firstpage ]    answer - set programming , abstract argumentation , implementation , aspartix </S>"
  ]
}