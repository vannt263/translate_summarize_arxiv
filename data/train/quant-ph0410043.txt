{
  "article_text": [
    "david deutsch designed a quantum algorithm , which evaluates whether the two outputs of a boolean function is the same or not using only one function evaluation @xcite .",
    "deutsch - jozsa generalized the deutsch s algorithm for more general case such as whether the boolean function is constant or balanced @xcite .",
    "deutsch - jozsa algorithm had been proposed to show an exponential speed - up in quantum machine than the classical machines .",
    "the most important contribution in this area has been achieved when peter shor discovered a polynomial - time quantum algorithm for factoring and computing discrete logarithms , which is exponentially faster than the classical best known algorithm @xcite . because this quantum factoring algorithm works in polynomial time compared to exponential time in classical method",
    ", many researchers started to find other applications .",
    "lov grover discovered a quantum database search algorithm , which is quadratic faster than classical database search algorithm @xcite .",
    "meanwhile , database search algorithm is one of the most widely used algorithm in the computer applications , the impact is so huge and more researchers are interested in other applications of quantum database search algorithm .",
    "this research also focuses on the applications of grover database search algorithm .    in this research",
    ", we assume that there is a promise in the boolean function as it has a weight @xmath4 or @xmath5 .",
    "initially , for better understanding , we formulate the problem for some special weight cases such as @xmath18 or @xmath19 , by applying @xmath11 many grover operations . here the quantum algorithm presented is of randomized in nature , but the success probability is arbitrarily close to unity .",
    "next we consider the general case to distinguish functions having weight either @xmath4 or @xmath5 and we also consider a deterministic algorithm .",
    "this requires changes in the very last two grover operations with phase conditions .",
    "briefly , from @xmath20 to @xmath21 steps , the original grover operators are used , but , in the last two steps , two different grover operators are used with the phase conditions .",
    "also we found that the phase conditions depending on the required number of grover operations .",
    "meanwhile , because quantum counting algorithm was already proposed , we compared two methods . since the quantum counting method requires more grover iterations to find period information , we can conclude that our method is faster than this method .",
    "a boolean function @xmath22 on @xmath3 variables may be viewed as a mapping from @xmath23 into @xmath24 .",
    "a boolean function @xmath0 is constant if @xmath25 for all @xmath26 , @xmath27 .",
    "that means @xmath1 is either @xmath28 or @xmath29 .",
    "a boolean function @xmath0 is balanced if @xmath30 .",
    "given a promise that the function @xmath0 is either constant or balanced , one may ask for an algorithm , that can exactly answer which case it is . note",
    "that throughout this document we consider that any boolean function @xmath0 is available in the form of an oracle ( black box ) only , where one can apply an input to the black box to get the output .",
    "a classical algorithm needs to check the function for @xmath31 inputs in the worst case to decide whether the function is constant or balanced .",
    "( 25,9 ) ( 1.3,7.6)(0,0)[bl ] @xmath32 ( 1.3,4.6)(0,0)[bl ] @xmath33 ( 10,4)(5,5 ) ( 3,5)(1,0)2 ( 3.6,7.6)(1,1)0.8 ( 3.4,8.5)(0,0)[bl ] @xmath3 ( 5,4.5)(1,1 ) ( 4.8,4.6)(0,0)[bl ] @xmath34 ( 6,5)(1,0)4 ( 15,5)(1,0)7 ( 3,8)(1,0)2 ( 5,7.5)(2,1 ) ( 4.8,7.6)(0,0)[bl ] @xmath35 ( 7,8)(1,0)3 ( 15,8)(1,0)2 ( 17,7.5)(2,1 ) ( 16.8,7.6)(0,0)[bl ] @xmath35 ( 19,8)(1,0)1 ( 20,7.5)(1,1 ) ( 19.75,7.6)(0,0)[bl ] @xmath36 ( 21,8)(1,0)1    ( 9.9,4.9)(0,0)[bl ] @xmath37 ( 9.9,7.9)(0,0)[bl ] @xmath38 ( 14,7.9)(0,0)[bl ] @xmath38 ( 12.2,4.9)(0,0)[bl ] @xmath39 ( 11.7,6.5)(0,0)[bl ] @xmath40    ( 4,2)(0,0)[bl ] @xmath41 ( 9,2)(0,0)[bl ] @xmath41 ( 16,2)(0,0)[bl ] @xmath41 ( 19.5,2)(0,0)[bl ] @xmath41 ( 4,0.5)(0,0)[bl ] @xmath42 ( 9,0.5)(0,0)[bl ] @xmath43 ( 16,0.5)(0,0)[bl ] @xmath44 ( 19.5,0.5)(0,0)[bl ] @xmath45    it is known that given a classical circuit for @xmath0 , there is a quantum circuit of comparable efficiency which performs a transformation @xmath40 that takes input like @xmath46 and produces the output @xmath47 .",
    "given such a @xmath40 , deutsch - jozsa  @xcite provided a quantum algorithm that can solve this problem in constant time , indeed , in a single evaluation of @xmath40 . the circuit for their algorithm is given in fig .  [ fig1 ] .",
    "_ deutsch - jozsa algorithm @xcite _ [ algo : deutsch_jozsa_algorithm ]    [ cols= \" < ,",
    "< \" , ]      we analyze the quantum counting algorithm for three purposes .",
    "first , when a weight @xmath16 is given , how we can check the correctness of the given weight with how much time complexity .",
    "second , when two weights are given , how we can decide the real weight with how much time complexity .",
    "third , when @xmath3 possible weights are given , how we can find the real weight with how much time complexity .",
    "if a weight is given as @xmath16=sin@xmath48 , how can we check whether this is correct or incorrect and what about time complexity ? let @xmath49 . if @xmath0 were an integer , there would be two possibilities : either @xmath50 ( which happens if @xmath51 or @xmath52 ) , in which case @xmath53 , or @xmath54 , in which case @xmath55 , where @xmath56 and @xmath57 are complex numbers of norm @xmath58 @xcite .",
    "in other words , if we assume the value of @xmath59 as @xmath60 , the measured value of @xmath61 should be @xmath11 . as a result",
    ", we can easily check whether the given weight is correct or not by measuring @xmath62 .",
    "if the measured value is @xmath11 , the given weight is correct , otherwise incorrect . in this case , the time complexity is @xmath63 .",
    "meanwhile , because we already know the value of @xmath64 in the initial time , we can find the smallest integer value of @xmath59 as @xmath65 .",
    "if @xmath64 is @xmath66 , then @xmath59 is just @xmath67 .",
    "therefore , the time complexity of this case is @xmath68 when @xmath64 is @xmath66 .      from the previous section",
    ", we can know that when @xmath71(@xmath72 ) is given , we can find the required number @xmath59 for @xmath69(@xmath70 ) and the expected measured value as @xmath73(@xmath74 ) .",
    "however , when we want to decide which weight is real one , @xmath73 and @xmath74 should be different because they are the clues to distinguish . therefore , we need to find the integer value @xmath59 , which will be used for both two cases .",
    "two values of @xmath59 are @xmath75 and @xmath76 .",
    "because we need to execute the algorithm only once , @xmath77 and @xmath78 should be the same .",
    "hence , @xmath79 should be equal to @xmath80 and our job is to find suitable @xmath73 and @xmath74 . meanwhile ,",
    "if @xmath81 and @xmath82 , @xmath59 should be @xmath83 . considering the time complexity , we need to find the smallest integer value of @xmath59 by @xmath84 , where @xmath85 is the least common integer multiplier",
    ". then , @xmath86 and @xmath87 .",
    "finally , with the value of @xmath88 , we evaluate the algorithm , and if the measured value of @xmath61 is @xmath73 , we can say that the weight is @xmath69 .",
    "if the measured value of @xmath61 is @xmath74 , we can say that the weight is @xmath70 .",
    "time complexity of this case is @xmath89 , where @xmath90 is @xmath91 and @xmath92 is @xmath93 .",
    "now we need to compare our method and the above method based on quantum counting when @xmath94 .",
    "if @xmath95 and @xmath96 , our method , algorithm [ algo : randomized_weight_decision_algorithm ] and [ algo : sure_success_weight_decision_algorithm ] can decide which one is real one in @xmath11 many steps . on the other hand ,",
    "the method based on quantum counting needs @xmath59 as @xmath97 and if @xmath61 is @xmath11 , the real weight is @xmath69 and if @xmath98 @xmath99 , the real weight is @xmath70 . from this analysis , we can know that the method based on quantum counting is less efficient than our method because the quantum counting method needs to exploit some period , which requires several grover operations .",
    "we can extend the previous result to a more general case .",
    "when @xmath3 possible weights are given .",
    "can we decide which weight is real one ?",
    "the most important thing in this problem is to find the smallest integer value of @xmath100 .",
    "then , as the same method in the previous section , @xmath101 should be @xmath102 . from this analysis",
    ", we can find the real weight from the measured value @xmath61 as if @xmath61 is @xmath101 then the real weight is @xmath103 . in this case , the time complexity is @xmath104 .",
    "in this work , we have investigated the application of grover operators to distinguish weight of boolean function when two weights are given .",
    "firstly , when we assume that the weight is the number of solutions , we found that algorithm [ algo : randomized_weight_decision_algorithm ] can find the exact weight with almost certainty .",
    "secondly , by exploiting the sure success grover search method , we found a sure success weight decision algorithm , algorithm [ algo : sure_success_weight_decision_algorithm ] , with modification of the last two grover operations with phase conditions .",
    "lastly , we have compared the proposed method to the quantum counting algorithm . because the quantum counting algorithm needs period information , which requires more grover operations ,",
    "our method is more efficient than the quantum counting method .    on the other hand , until this work",
    ", we assume that two weights are given such as @xmath4 and @xmath5 .",
    "how about other cases such as @xmath69 and @xmath70 , where @xmath105 ?",
    "moreover , when three or more weights are given , can we find the exact weight with the similar approach ?",
    "this may be attempted using the brief idea presented in subsection  [ difwt ] .",
    "+ * acknowledgment : * samuel l. braunstein currently holds a royal society - wolfson research merit award .",
    "byung - soo choi is supported by the ministry of information & communication of korea ( it national scholarship program ) .",
    "l.  grover . a fast quantum mechanical algorithm for database search . in _ proceedings of 28th annual symposium on the theory of computing ( stoc )",
    "_ , may 1996 , pages 212219 .",
    "available at xxx.lanl.gov/quant-ph/9605043 ."
  ],
  "abstract_text": [
    "<S> by the weight of a boolean function @xmath0 , denoted by @xmath1 , we mean the number of inputs for which @xmath0 outputs @xmath2 . given a promise that an @xmath3-variable boolean function ( available in the form of a black box and the output is available in constant time once the input is supplied ) is of weight either @xmath4 or @xmath5 @xmath6 , we present a detailed study of quantum algorithms to find out which one actually it is . to solve this problem we apply the grover s operator .    </S>",
    "<S> first we consider the restricted problem . given a promise that an @xmath3-variable boolean function is of weight either @xmath7 or @xmath8 ( @xmath9 means the nearest integer corresponding to the real value @xmath10 ) , </S>",
    "<S> we show that one can suitably apply grover s operator for @xmath11-many iterations to decide which case this is with a probability almost unity for large @xmath3 and @xmath11 in @xmath12 . on the other hand , </S>",
    "<S> the best known probabilistic classical algorithm has a success probability close to @xmath13 ( from above ) after @xmath11 many steps when @xmath11 is large . </S>",
    "<S> we further show that the best known probabilistic classical algorithm can achieve a success probability almost unity only after @xmath14 many iterations where @xmath15 . </S>",
    "<S> this indicates a quadratic speed up ( and also agrees to the quadratic speed up by the use of grover s algorithm in database search ) on time complexity in the quantum domain with respect to the best known result in the classical domain .    </S>",
    "<S> second , we modify the basic randomized algorithm into a sure success algorithm , which can distinguish boolean functions of weights @xmath4 or @xmath5 for any @xmath16 , @xmath17 . to do that we have exploited a sure success grover search algorithm , which modifies the very last operation . for the weight decision problem , we show that the very last two operations should be changed to distinguish any weight with certainty and found the phase conditions for the last two operations .    as quantum counting methods exist , which can count the number of solutions , here we compare our method with that . since the quantum counting method needs to exploit period information , which requires many grover operations , we have found that our method is faster than the quantum counting method .    </S>",
    "<S> * keywords : * quantum algorithm , boolean function , grover s operator , weight decision problem . </S>"
  ]
}