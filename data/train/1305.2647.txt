{
  "article_text": [
    "a _ graph _ @xmath0 consists of a _ _ vertex set  _ _ @xmath1 and an _ _ edge set  _ _ @xmath2 , where each edge corresponds to a pair @xmath3 of vertices .",
    "if the edges are ordered pairs of vertices ( i.e. , the pair @xmath3 is different from the pair @xmath4 ) , then we call the graph _ directed _ or _ _  digraph _ _ ; otherwise , we call it _ undirected_.",
    "if @xmath3 is an edge in a digraph , we say that @xmath3 _ leaves _ vertex @xmath5 and _ enters _ vertex @xmath6 . in a digraph ,",
    "the _ out - degree _ of a vertex is the number of edges leaving it , and the _ in - degree _ of a vertex is the number of edges entering it .",
    "a vertex in a digraph is a _ source _ if no edges enter it , and a _ sink _ if no edges leave it .",
    "a _ path _ from vertex @xmath7 to vertex @xmath8 in a graph @xmath0 is a sequence of its vertices @xmath9 $ ] such that @xmath10 for @xmath11 .",
    "@xmath12 is an _ acyclic graph",
    "_ if there is no closed path @xmath13 $ ] in @xmath12 .",
    "a two - terminal directed acyclic graph ( _ st - dag _ ) has only one source @xmath14 and only one sink @xmath15 . in an st - dag ,",
    "every vertex lies on some path from @xmath14 to @xmath15 .",
    "a graph @xmath16 is a _ subgraph _ of @xmath17 if @xmath18 and @xmath19 .",
    "a graph @xmath20 is _ homeomorphic _ to a graph @xmath21 ( a _ homeomorph _ of @xmath21 ) if @xmath12 can be obtained by subdividing edges of @xmath22 with new vertices .",
    "we consider a _ labeled graph _ which has labels attached to its edges .",
    "each path between the source and the sink ( a _ sequential path _ ) in an st - dag can be presented by a product of all edge labels of the path .",
    "we define the sum of edge label products corresponding to all possible sequential paths of an st - dag @xmath12 as the _ canonical expression _ of @xmath12 .",
    "an algebraic expression is called an _ st - dag expression _ ( a _ factoring of an st - dag _ in @xcite ) if it is algebraically equivalent to the canonical expression of an st - dag . an st - dag expression",
    "consists of terms ( edge labels ) , the operators @xmath23 ( disjoint union ) and @xmath24 ( concatenation , also denoted by juxtaposition when no ambiguity arises ) , and parentheses .",
    "we define the _ complexity of an algebraic expression _ in two ways .",
    "the complexity of an algebraic expression is ( i ) the total number of terms in the expression including all their appearances ( _ the first complexity characteristic _ ) or ( ii ) the number of plus operators in the expression ( _ the second complexity characteristic _ ) .",
    "we will denote the first and the second complexity characteristic of an st - dag expression by @xmath25 and @xmath26 , respectively , where @xmath27 is the number of vertices in the graph ( the _ size of the graph _ ) .",
    "an equivalent expression with the minimum complexity is called an _ optimal representation of the algebraic expression_.    a _ series - parallel _ _ graph _ is defined recursively as follows :    \\(i ) a single edge @xmath28 is a series - parallel graph with source @xmath29 and sink @xmath5 .",
    "\\(ii ) if @xmath30 and @xmath31 are series - parallel graphs , so is the graph obtained by either of the following operations :    \\(a ) parallel composition : identify the source of @xmath30 with the source of @xmath31 and the sink of @xmath30 with the sink of @xmath31 .",
    "\\(b ) series composition : identify the sink of @xmath30 with the source of @xmath31 .",
    "as shown in @xcite and @xcite , a series - parallel graph expression has a representation in which each term appears only once .",
    "we proved in kol that this representation is an optimal representation of the series - parallel graph expression from the perspective of the first complexity characteristic .",
    "for example , the st - dag expression of the series - parallel graph presented in figure [ fig1 ] is @xmath32 .",
    "since it is a series - parallel graph , the expression can be reduced to @xmath33 , where each term appears once .",
    "( 5,4)(-3.5,0 )    ( 1,3)(3,0)4",
    "( 1,3)(1,0)3 ( 2.5,3.3)(0,0)@xmath34    ( 4,3)(5.5,5)(7,3 ) ( 7.085,3)(3,-2)0 ( 5.5,4.3)(0,0)@xmath35    ( 4,3)(5.5,1)(7,3 ) ( 7.085,3)(3,2)0 ( 5.5,2.3)(0,0)@xmath36    ( 7,3)(8.5,5)(10,3 ) ( 10.085,3)(3,-2)0 ( 8.5,4.3)(0,0)@xmath37    ( 7,3)(8.5,1)(10,3 ) ( 10.085,3)(3,2)0 ( 8.5,2.3)(0,0)@xmath38    ( 1,3)(4,-2)(7,3 ) ( 7.085,3)(4,3)0 ( 4,0.8)(0,0)@xmath39    the notion of a _ fibonacci graph _ ( @xmath40 ) was introduced in @xcite .",
    "a fibonacci graph has vertices @xmath41 and edges @xmath42this graph is illustrated in figure [ fig2 ] .",
    "( 5,2)(-0.9,-0.5 )    ( 0,0)(1.5,0)9    ( 0,-0.3)(0,0)1 ( 1.5,-0.3)(0,0)2 ( 3,-0.3)(0,0)3 ( 4.5,-0.3)(0,0)4 ( 7.5,-0.3)(0,0)n-3 ( 9,-0.3)(0,0)n-2 ( 10.5,-0.3)(0,0)n-1 ( 12,-0.3)(0,0)n    ( 0,0)(1.5,0)8(1,0)1.5    ( 0.75,0.2)(0,0)@xmath43 ( 2.25,0.2)(0,0)@xmath44 ( 3.75,0.2)(0,0)@xmath45 ( 8.25,0.2)(0,0)@xmath46 ( 9.75,0.2)(0,0)@xmath47 ( 11.25,0.2)(0,0)@xmath48    ( 0,0)(1.5,2)(3,0 ) ( 1.5,0)(3,2)(4.5,0 ) ( 3,0)(4.5,2)(6,0 ) ( 4.5,0)(6,2)(7.5,0 ) ( 6,0)(7.5,2)(9,0 ) ( 7.5,0)(9,2)(10.5,0 ) ( 9,0)(10.5,2)(12,0 )    ( 3.085,0)(1.5,0)7(3,-2)0    ( 1.5,1.3)(0,0)@xmath49 ( 3,1.3)(0,0)@xmath50 ( 9,1.3)(0,0)@xmath51 ( 10.5,1.3)(0,0)@xmath52    ( 5.55,-0.2)(0.2,0)6    as shown in @xcite , an st - dag is series - parallel if and only if it does not contain a subgraph homeomorphic to the _ forbidden subgraph _ positioned between vertices @xmath53 and @xmath54 of the fibonacci graph shown in figure [ fig2 ] .",
    "thus , fibonacci graphs are of interest as through  non - series - parallel st - dags .",
    "notice that fibonacci graphs of size @xmath55 or @xmath56 are series - parallel .",
    "mutual relations between graphs and algebraic expressions are discussed in @xcite , @xcite , @xcite , @xcite , @xcite , @xcite , @xcite , @xcite , @xcite , @xcite , and other works .",
    "specifically , @xcite , @xcite , and @xcite consider the correspondence between series - parallel graphs and read - once functions .",
    "a boolean function is defined as _ read - once _ if it may be computed by some formula in which no variable occurs more than once ( _ read - once formula _ ) . on the other hand",
    ", a series - parallel graph expression can be reduced to the representation in which each term appears only once .",
    "hence , such a representation of a series - parallel graph expression can be considered to be a read - once formula ( boolean operations are replaced by arithmetic ones ) .",
    "an expression of a homeomorph of the forbidden subgraph belonging to any non - series - parallel st - dag has no representation in which each term appears once .",
    "for example , consider the subgraph positioned between vertices @xmath53 and @xmath54 of the fibonacci graph shown in figure [ fig2 ] .",
    "possible optimal representations of its expression are @xmath57 or @xmath58 . for this reason , an expression of a non - series - parallel st - dag can not be represented as a read - once formula .",
    "however , for arbitrary functions , which are not read - once , generating the optimum factored form is np - complete @xcite .",
    "some heuristic algorithms developed in order to obtain good factored forms are described in @xcite , @xcite and other works .",
    "therefore , generating an optimal representation for a non - series - parallel st - dag expression is a highly complex problem .",
    "the problem of factoring boolean functions into shorter , more compact formulae is one of the basic operations in algorithmic logic synthesis since compactification saves money . in logic synthesis ,",
    "one standard measure of the complexity of a logic circuit is the number of terms .",
    "computation time also depends on the number of terms .",
    "however , computation time is determined by the number of operations on terms as well .",
    "for this reason , the number of plus operators is another important characteristic of a logic circuit .",
    "besides , the number of plus operators characterizes the number of computation levels in a logic circuit ( its branching out  degree ) .",
    "our intention in this paper is to simplify the expressions of fibonacci graphs ( we denote them by @xmath59 ) and eventually find their optimal representations .",
    "in @xcite we presented a heuristic algorithm with that end in view and analyzed obtained expressions from the perspective of the first complexity characteristic .",
    "here we describe the number of methods for generating fibonacci graph expressions and carry out their comparative analysis from the perspective of both the first and the second complexity characteristics .",
    "this section considers three quite natural methods for generating expressions of fibonacci graphs .",
    "this method is based directly on the definition of an st - dag expression as the canonical expression of the st - dag .",
    "[ th_seq_exp]for an @xmath27-vertex @xmath40 :    \\1 .",
    "the number of sequential paths @xmath60 is defined recursively as follows : @xmath61    \\2 .",
    "the total number of terms @xmath25 in the expression @xmath59 derived by the sequential paths method is defined recursively as follows : @xmath62    \\3 .",
    "the number of plus operators @xmath26 in the expression @xmath59 derived by the sequential paths method is defined recursively as follows : @xmath63    \\1 .",
    "initial statements @xmath64 and @xmath65 follow clearly .",
    "all sequential paths in a fibonacci graph ( see figure [ fig2 ] ) subdivide into two groups .",
    "paths of the first group start from the edge labeled @xmath43 ; paths of the second group start from the edge labeled @xmath49 .",
    "paths of the first group are all sequential paths of the @xmath40 positioned between vertices @xmath55 and @xmath27 and are supplemented by an edge labeled @xmath43 .",
    "this graph includes @xmath66 vertices , and , for this reason , the number of sequential paths in this graph , and by extension , in the first group , is equal to @xmath67 . by analogy ,",
    "the number of sequential paths in the second group is equal to @xmath68 .",
    "hence , the proof of the statement is complete .",
    "initial statements @xmath69 and @xmath70 follow clearly . consider the case of @xmath71 . as was mentioned above",
    ", each sequential path of an @xmath27-vertex @xmath40 is a sequential path of an @xmath66-vertex @xmath40 or an @xmath72-vertex @xmath40 which is supplemented by one edge .",
    "that is , each sequential path in an @xmath66-vertex @xmath40 and an @xmath72-vertex @xmath40 corresponds to an additional term in @xmath73 .",
    "hence , @xmath74    \\3 . initial statements @xmath75 and @xmath76 follow clearly .",
    "consider the case of _ _  _ _ @xmath71 .",
    "taking into consideration ( [ fgf1 ] ) and the obvious equality @xmath77 for @xmath78 , formula ( [ fgf2 ] ) follows immediately .",
    "the number of sequential paths @xmath60 in an @xmath27-vertex @xmath40 is equal to the fibonacci number @xmath79 @xmath80 .",
    "the following explicit formula for @xmath79 and , consequently , for @xmath60 is obtained by the method for linear recurrence relations solving @xcite ( henceforth , the method @xcite):@xmath81 \\text{\\allowbreak } .",
    "\\label{fgf9}\\ ] ]    using ( [ fgf1 ] ) and  ( [ fgf7 ] ) the following recurrence for @xmath25 is derived:@xmath82    [ cor_seq_exp]for an @xmath27-vertex @xmath40 :    \\1 . the total number of terms @xmath25 in the expression @xmath59 derived by the sequential paths method is expressed explicitly as follows : @xmath83 .\\ ] ]    \\2 .",
    "the number of plus operators @xmath26 in the expression @xmath59 derived by the sequential paths method is expressed explicitly as follows : @xmath84 -1.\\ ] ]    \\1 . the proof is based on relation ( [ fg_fig8 ] ) and on the method @xcite .",
    "the proof follows immediately from ( [ fgf9 ] ) and the above mentioned equality @xmath77 .    for @xmath85 ,",
    "the corresponding algebraic expression is @xmath86it contains @xmath87 products ( that correspond to @xmath87 sequential paths of the graph ) , @xmath88 terms and @xmath89 plus operators .",
    "the expression @xmath59 will be implemented in this and in other methods by a linked list of the following characters : terms @xmath90 and @xmath91 , parentheses @xmath92 and @xmath93 , and a sign @xmath94 .",
    "terms @xmath90 and @xmath91 conditionally considered as alone characters can be presented as character sequences consisting of characters @xmath95 or @xmath96 and digits of number @xmath97 .",
    "we propose the following recursive algorithm which realizes the sequential paths method :    @xmath98    1 .",
    "@xmath99 @xmath97 @xmath100 @xmath27 2 .   @xmath101\\longleftarrow a_{i}$ ] 3 .",
    "[ seqp3]@xmath102 4 .",
    "@xmath99 @xmath97 @xmath100 @xmath66 5 .",
    "@xmath101\\longleftarrow b_{i}$ ] 6 .",
    "[ seqp6]@xmath103 7 .",
    "[ seqp7]@xmath104 8 .",
    "[ seqp8]@xmath105 @xmath106 * *  * * @xmath107 9 .   [ seqp9]@xmath108 10 .",
    "[ seqp10]@xmath109    given integers @xmath97 and @xmath110 and an auxiliary array @xmath111 of size @xmath66 , this procedure generates a linked list @xmath112 which implements the expression of an @xmath27-vertex @xmath40 derived by the sequential paths method .",
    "array @xmath111 is used to accumulate a product of terms corresponding to a current sequential path .",
    "integer @xmath97 is a number of a given vertex which edges labeled @xmath90 and @xmath91 leave , and @xmath110 is a subscript of an element in @xmath111 . the procedure is invoked with @xmath113 and an empty list @xmath112 .",
    "the procedure generates all admissible for our problem combinations of @xmath114 @xmath115 and @xmath91 @xmath116  after @xmath97 reaches @xmath117 ( line [ seqp7 ] ) a current combination has been composed and content of the first @xmath110 elements of @xmath111 is copied at the end of @xmath112 ( line seqp10 ) .",
    "if a derived product is not the first one in the expression , i.e. , @xmath112 is not an empty list , then a sign @xmath94 is inserted before the product ( lines [ seqp8]-[seqp9 ] ) .",
    "the running time of this algorithm consists of two components .    in the general case of the recursion , the running time , as follows from lines [ seqp3 ] and [ seqp6 ] ,",
    "is @xmath118 , i.e. , the time complexity increases as fibonacci numbers ( see ( [ fgf9 ] ) ) .    however , in the base case of the recursion , the time expenses are not constant but are proportional to the size of a part of the expression copied from @xmath111 to @xmath112 .",
    "therefore , this component of the algorithm s running time is determined by the size of all the generated expression including all terms and plus operators . as follows from theorem [ th_seq_exp ] and corollary [ cor_seq_exp ] ,",
    "the total number of terms is the most significant part of the expression s size and , therefore , it states the complexity of the time @xmath119 for copying all parts of the expression from @xmath111 to @xmath112 .",
    "that is , by corollary [ cor_seq_exp ] , @xmath120 .",
    "thus , the total running time of the algorithm is@xmath121    the algorithm uses only a @xmath122-size additional array and so , the amount of memory it requires is determined by the size of the derived expression and is also @xmath123 .",
    "an expression is derived by utilizing the well - known depth first search algorithm @xcite and by using intermediate subexpressions which are accumulated in st - dag s vertices .",
    "a subexpression which is accumulated in vertex @xmath97 of the st - dag corresponds to its subgraph which is positioned between vertices @xmath97 and @xmath27 .",
    "the following recursive procedure is used :    1 .",
    "[ 1dfs]the subexpression accumulated in vertex @xmath27 ( see figure [ fig2 ] ) is equal to @xmath53 .",
    "2 .   the subexpression accumulated in vertex @xmath66 is equal to @xmath124 .",
    "3 .   the subexpression accumulated in vertex @xmath97 ( @xmath125 ) is equal to @xmath126 where @xmath127 and @xmath128 are subexpressions accumulated in vertices @xmath129 and @xmath130 , respectively .",
    "4 .   the subexpression accumulated in vertex @xmath53 is the resulting expression .",
    "the special case of a subgraph consisting of a single vertex is considered in line [ 1dfs ] of the recursive procedure .",
    "it is clear that such a subgraph can be connected to other subgraphs only serially .",
    "for this reason , it is accepted that its subexpression is @xmath53 , so that , when it is multiplied by another subexpression , the final result is not influenced .",
    "[ th_dfs_exp]for an @xmath27-vertex @xmath40 :    \\1 .",
    "the total number of terms @xmath25 in the expression @xmath59 derived by the dfs method is defined recursively as follows : @xmath131    \\2 .",
    "the number of plus operators @xmath26 in the expression @xmath59 derived by the dfs method is defined recursively as follows : @xmath132    \\1 .",
    "initial statements @xmath69 and @xmath70 follow clearly .",
    "the resulting expression @xmath59 is equal to @xmath133 where @xmath134 and @xmath135 are subexpressions accumulated in vertices @xmath55 and @xmath56 , respectively ( see figure [ fig2 ] and the dfs recursive procedure ) .",
    "@xmath134 is the symbolic expression of the @xmath40 which is positioned between vertices @xmath55 and @xmath27 .",
    "this graph includes @xmath66 vertices and , for this reason , the total number of terms in @xmath134 is equal to @xmath136 . by analogy , the total number of terms in @xmath137 is equal to @xmath138 .",
    "terms @xmath43 and @xmath49 are two additional terms in @xmath59 .",
    "hence , the proof of the statement is complete .",
    "this second proof is analogous to the first one .",
    "the expression @xmath139 includes all plus operations of @xmath134 and @xmath137 and one additional plus operation .",
    "as follows from theorems [ th_seq_exp ] and [ th_dfs_exp ] , a method s evaluation depends on the kind of complexity that has been chosen .",
    "if methods are compared by means of the second complexity characteristic , then sequential paths and dfs methods are equivalent .",
    "however , from the perspective of the first complexity characteristic , the dfs method is more efficient .",
    "[ col_dfs_exp]for an @xmath27-vertex @xmath40 :    \\1 .",
    "the total number of terms @xmath25 in the expression @xmath59 derived by the dfs method is expressed explicitly as follows : @xmath140 -2.\\ ] ]    \\2 .",
    "the number of plus operators @xmath26 in the expression @xmath59 derived by the dfs method is expressed explicitly as follows : @xmath84 -1.\\ ] ]    \\1 .",
    "the proof uses the recurrence obtained in theorem th_dfs_exp and is based on the method @xcite .",
    "the proof follows immediately from corollary [ cor_seq_exp ] and the equivalence of sequential paths and dfs methods from the perspective of the second complexity characteristic .    for @xmath85 ,",
    "the corresponding algebraic expression is @xmath141it contains @xmath142 terms and @xmath89 plus operators .",
    "hence , this algorithm optimizes prefix parts of all subexpressions . in principle",
    ", the dfs method can be applied by traversing the st - dag in the opposite direction .",
    "in such a case , suffix parts of subexpressions are optimized .",
    "expression complexity characteristics will be the same .",
    "we propose the following recursive algorithm which realizes the dfs  method in accordance with the above procedure :     @xmath143    1 .",
    "@xmath99 @xmath97 @xmath100 @xmath66 2 .",
    "[ dfsd2]@xmath144 3 .",
    "@xmath99 @xmath97 @xmath100 @xmath72 4 .",
    "@xmath145 5 .",
    "@xmath146 6 .",
    "@xmath147 7 .",
    "[ dfsd7]@xmath148 8 .",
    "@xmath99 @xmath97 @xmath100 @xmath149 9 .",
    "@xmath150 10 .",
    "@xmath151 11 .",
    "@xmath152 12 .",
    "[ dfsd12]@xmath153 13 .",
    "@xmath104 14 .",
    "@xmath105 @xmath97 @xmath154 @xmath66 15 .",
    "[ dfsd15]@xmath155 16 .",
    "@xmath156 17 .",
    "[ dfsd17]@xmath157    the algorithm generates a linked list @xmath112 which implements an expression of a subgraph positioned between vertices @xmath97 and @xmath27 .",
    "parameter @xmath97 is substituted by @xmath53 initially , for deriving the expression of an @xmath27-vertex @xmath158 .",
    "recursive calls in lines [ dfsd2 ] and [ dfsd7 ] of the algorithm generate expressions for subgraphs with sources @xmath129 and @xmath130 , respectively . the first expression is presented as list @xmath112 and the second one is presented as an additional list @xmath159 .",
    "after corresponding insertions of terms @xmath90 and @xmath91 , parentheses and a sign @xmath94 , these lists are concatenated in @xmath160 time into the unified list @xmath112 ( line dfsd12 ) by assigning the address of the first element in @xmath159 to the pointer in the last element of @xmath112 . in the base cases of the recursion ,",
    "@xmath161 consists of the single term @xmath124 ( line [ dfsd15 ] ) or is an empty list ( line [ dfsd17 ] ) .",
    "thus , the running time of the algorithm is @xmath162 , i.e. , its complexity increases as fibonacci numbers and @xmath163 .    the amount of memory that requires the algorithm is determined only by the size of the derived expression and is also @xmath164 .",
    "the following algorithm realizes the dfs method applied in the opposite direction :    @xmath165    1 .",
    "@xmath99 @xmath97 @xmath100 @xmath66 2 .",
    "@xmath166 3 .",
    "@xmath99 @xmath97 @xmath100 @xmath72 4 .",
    "@xmath167 5 .",
    "@xmath168 6 .",
    "@xmath169 7 .",
    "@xmath170 8 .",
    "@xmath99 @xmath97 @xmath100 @xmath149 9 .",
    "@xmath171 10 .",
    "@xmath172 11 .",
    "@xmath173 12 .",
    "@xmath153 13 .",
    "@xmath104 14 .",
    "@xmath105 @xmath97 @xmath154 @xmath66 15 .",
    "@xmath174 16 .",
    "@xmath156 17 .",
    "@xmath157    it is clear that time and space expenses of this algorithm are the same as of the previous one and are @xmath123 .      while the dls method is similar to the dfs method they differ in the fact that an st - dag expression in the dls method is derived by using special subexpressions such as @xmath175 which are related to corresponding closed graph segments",
    "the following recursive procedure is used :    1 .",
    "the subexpression accumulated in vertex @xmath27 is equal to @xmath53 .",
    "2 .   the subexpression accumulated in vertex @xmath66 is equal to @xmath124 .",
    "3 .   the subexpression accumulated in vertex @xmath72 is equal to @xmath176 .",
    "4 .   the subexpression accumulated in vertex @xmath97 ( @xmath177 ) is equal to @xmath178 where @xmath128 and @xmath179 are subexpressions accumulated in vertices @xmath130 and @xmath180 , respectively .",
    "the subexpression accumulated in vertex @xmath53 is the resulting expression .",
    "[ th_dls_exp]for an @xmath27-vertex @xmath40 :    \\1 .",
    "the total number of terms @xmath25 in the expression @xmath59 derived by the dls method is defined recursively as follows : @xmath181    \\2 .",
    "the number of plus operators @xmath26 in the expression @xmath59 derived by the dls method is defined recursively as follows : @xmath182    \\1 .",
    "initial statements @xmath69 , @xmath70 , and @xmath183 follow clearly .",
    "the resulting expression @xmath59 is equal to @xmath184 , where @xmath137 and @xmath185 are subexpressions accumulated in the vertices @xmath56 and @xmath54 , respectively ( see figure [ fig2 ] and the dls recursive procedure ) .",
    "@xmath137 is the symbolic expression of the @xmath40 which is positioned between vertices @xmath56 and @xmath27 .",
    "this graph includes @xmath72 vertices , and for this reason , the total number of terms in @xmath137 is equal to @xmath138 . by analogy ,",
    "the total number of terms in @xmath185 is equal to @xmath186 .",
    "terms @xmath43 , @xmath44 , @xmath49 , @xmath43 , and @xmath50 are five additional terms in @xmath59 .",
    "hence , the proof of the statement is complete .",
    "this second proof is analogous to the first one .",
    "the expression @xmath184 includes all plus operations of @xmath135 and @xmath185 and two additional plus operations .",
    "as follows from theorems [ th_seq_exp ] , [ th_dfs_exp ] , and th_dls_exp , the dls method is more efficient than sequential paths and dfs methods from the perspective of both complexity characteristics .",
    "[ cor_dls_exp]for an @xmath27-vertex @xmath40 :    \\1 .",
    "the total number of terms @xmath25 in the expression @xmath59 derived by the dls method is expressed explicitly as follows : @xmath187    or@xmath188 -5.\\end{aligned}\\ ] ]    \\2 .",
    "the number of plus operators @xmath26 in the expression @xmath59 derived by the dls method is expressed explicitly as follows : @xmath189    or@xmath190 -2.\\end{aligned}\\ ] ]    the proof of corollary [ cor_dls_exp ] uses the recurrences obtained in theorem [ th_dls_exp ] and is based on the method @xcite .    for @xmath85 ,",
    "the corresponding algebraic expression is @xmath191it contains @xmath192 terms and @xmath193 plus operators .    like the dfs method",
    ", the dls method can be employed by traversing the @xmath40 in the opposite direction .",
    "the algorithms which realize the method applied in both the direct and the opposite directions are similar to the above algorithms for the dfs method ( section [ dfs_anal ] ) .",
    "complexities of running time and memory required by these algorithms are defined as in the previous methods by the same recurrences as the expression size and , by corollary [ cor_dls_exp ] , are about @xmath194 .",
    "this method is based on the idea of _ reduction_. a _ series reduction _ at vertex @xmath5 is possible when @xmath195 is the unique edge entering @xmath5 , and @xmath196 is the unique edge leaving @xmath5 : then @xmath34 and @xmath35 are replaced by @xmath197 .",
    "a _ parallel reduction _ at vertices @xmath5 , @xmath6 replaces two or more edges @xmath198 joining @xmath5 to @xmath6 by a single edge @xmath3 .",
    "a _ node reduction _ at @xmath5 can occur when @xmath5 has in - degree or out - degree @xmath53 ( a node reduction is a generalization of a series reduction ) .",
    "suppose @xmath5 has in - degree @xmath53 , and let @xmath195 be the edge entering @xmath5 .",
    "let @xmath199 be the edges leaving @xmath5 .",
    "replace @xmath200 by @xmath201 , where @xmath202 .",
    "we call such a reduction a _ fork reduction_. the case where @xmath5 has out - degree @xmath53 is symmetric : here @xmath203 , @xmath204 , and @xmath205 .",
    "we call such a reduction a _ joint reduction_.    the algorithm for generating an st - dag expression from a sequence of series , parallel , and node reductions is proposed in @xcite . from a sequence of series ,",
    "parallel , and node reductions , reducing an arbitrary st - dag @xmath12 to a single edge , an expression of this st - dag can be obtained as follows .",
    "we denote , for the sake of brevity , the label of every edge @xmath206 before every reduction as @xmath206 .",
    "then , the new label for the edge resulting from a series reduction of @xmath34 and @xmath35 is @xmath207 . for a parallel reduction , the new edge",
    "is labeled @xmath208 . the new label for each edge resulting from a node reduction",
    "is @xmath209 for a fork reduction or @xmath210 for a joint reduction .",
    "node reductions are used until series and parallel reductions are possible . ultimately , the single edge to which @xmath12 is reduced has a label giving an expression of @xmath12 .    in relation to a fibonacci graph that has more than @xmath56 vertices ,",
    "this algorithm is transformed to the following special procedure .    1 .",
    "a fork reduction is done at the second vertex ( from the left ) ( see figure [ fig2 ] ) or a joint reduction is done at the last but one vertex ( from the left ) .",
    "a parallel reduction is done at the first and the second vertices ( from the left ) in the case of preceding fork reduction or at the last but one and the last vertices ( from the left ) in the case of preceding joint reduction .",
    "if the resulting reduced @xmath40 contains more than three vertices , then we return to step @xmath53 of this algorithm .",
    "otherwise , it is a series - parallel graph which is reduced to a single edge by a series reduction at the second vertex and a parallel reduction at the source and the sink .",
    "the single edge is labeled by the resulting expression .",
    "the example of the reduction process in relation to a @xmath211-vertex @xmath40 is shown in figure [ fg_fig4 ] .",
    "( 5,2)(-7,-0.5 )    ( -4,0)(0,0)initial fibonacci graph    ( 0,0)(1.5,0)6    ( 0,-0.3)(0,0)1 ( 1.5,-0.3)(0,0)2 ( 3,-0.3)(0,0)3 ( 4.5,-0.3)(0,0)4 ( 6,-0.3)(0,0)5 ( 7.5,-0.3)(0,0)6    ( 0,0)(1.5,0)5(1,0)1.5    ( 0.75,-0.2)(0,0)@xmath43 ( 2.25,-0.2)(0,0)@xmath44 ( 3.75,-0.2)(0,0)@xmath45 ( 5.25,-0.2)(0,0)@xmath212 ( 6.75,-0.2)(0,0)@xmath213    ( 0,0)(1.5,2)(3,0 ) ( 1.5,0)(3,2)(4.5,0 ) ( 3,0)(4.5,2)(6,0 ) ( 4.5,0)(6,2)(7.5,0 )    ( 3.085,0)(1.5,0)4(3,-2)0    ( 1.5,1.3)(0,0)@xmath49 ( 3,1.3)(0,0)@xmath50 ( 4.5,1.3)(0,0)@xmath214 ( 6,1.3)(0,0)@xmath215    ( 5,2)(-7,0.5 )    ( -4,1.5)(0,0)joint reduction at vertex 5    ( 0,0)(1.5,0)5    ( 0,-0.3)(0,0)1 ( 1.5,-0.3)(0,0)2 ( 3,-0.3)(0,0)3 ( 4.5,-0.3)(0,0)4 ( 6,-0.3)(0,0)6    ( 0,0)(1.5,0)4(1,0)1.5    ( 0.75,-0.2)(0,0)@xmath43 ( 2.25,-0.2)(0,0)@xmath44 ( 3.75,-0.2)(0,0)@xmath45 ( 5.25,-0.2)(0,0)@xmath216    ( 0,0)(1.5,2)(3,0 ) ( 1.5,0)(3,2)(4.5,0 ) ( 3,0)(4.5,2)(6,0 ) ( 4.5,0)(5.25,1)(6,0 )    ( 3.085,0)(1.5,0)3(3,-2)0    ( 1.5,1.3)(0,0)@xmath49 ( 3,1.3)(0,0)@xmath50 ( 4.5,1.3)(0,0)@xmath217 ( 5.25,0.75)(-1,-0.2)@xmath215    ( 5,2)(-7,1.5 )    ( -4,1.5)(0,0)parallel reduction at vertices 4 and 6    ( 0,0)(1.5,0)5    ( 0,-0.3)(0,0)1 ( 1.5,-0.3)(0,0)2 ( 3,-0.3)(0,0)3 ( 4.5,-0.3)(0,0)4 ( 6,-0.3)(0,0)6    ( 0,0)(1.5,0)4(1,0)1.5    ( 0.75,-0.2)(0,0)@xmath43 ( 2.25,-0.2)(0,0)@xmath44 ( 3.75,-0.2)(0,0)@xmath45 ( 5.25,-0.9)(0,0)@xmath218    ( 5,-0.7)(1,2)0.3    ( 0,0)(1.5,2)(3,0 ) ( 1.5,0)(3,2)(4.5,0 ) ( 3,0)(4.5,2)(6,0 )    ( 3.085,0)(1.5,0)3(3,-2)0    ( 1.5,1.3)(0,0)@xmath49 ( 3,1.3)(0,0)@xmath50 ( 4.5,1.3)(0,0)@xmath217    ( 5,2)(-7,2.5 )    ( -4,1.7)(0,0)fork reduction at vertex 2 ( -4,1.2)(0,0)parallel reduction at vertices 1 and 3    ( 0,0)(1.5,0)4    ( 0,-0.3)(0,0)1 ( 1.5,-0.3)(0,0)3 ( 3,-0.3)(0,0)4 ( 4.5,-0.3)(0,0)6    ( 0,0)(1.5,0)3(1,0)1.5    ( 0.75,-0.9)(0,0)@xmath219 ( 2.25,-0.2)(0,0)@xmath45 ( 3.75,-0.9)(0,0)@xmath218    ( 0.5,-0.7)(1,2)0.3 ( 3.5,-0.7)(1,2)0.3    ( 0,0)(1.5,2)(3,0 ) ( 1.5,0)(3,2)(4.5,0 )    ( 3.085,0)(1.5,0)2(3,-2)0    ( 1.5,1.3)(0,0)@xmath220 ( 3,1.3)(0,0)@xmath217    ( 5,2)(-7,4 )    ( -4,1.7)(0,0)fork reduction at vertex 3 ( -4,1.2)(0,0)parallel reduction at vertices 1 and 4    ( 0,0)(2.25,0)3    ( 0,-0.3)(0,0)1 ( 2.25,-0.3)(0,0)4 ( 4.5,-0.3)(0,0)6    ( 0,0)(2.25,0)2(1,0)2.25    ( 0.2,-0.9)(0,0)@xmath221 ( 3.8,-0.9)(0,0)@xmath218    ( 0.5,-0.7)(1,2)0.3 ( 3.5,-0.7)(1,2)0.3    ( 0,0)(2.25,2)(4.5,0 )    ( 4.585,0)(1.5,0)1(3,-2)0    ( 2.25,1.3)(0,0)@xmath222    ( 5,2)(-7,5.5 )    ( -4,1.7)(0,0)series reduction at vertex 4 ( -4,1.2)(0,0)parallel reduction at vertices 1 and 6    ( 0,0)(4.5,0)2    ( 0,-0.3)(0,0)1 ( 4.5,-0.3)(0,0)6    ( 0,0)(4.5,0)1(1,0)4.5    ( 2.25,0.4)(0,0)@xmath223 )    ( 5,6)(-7,0.5 )    it is clear ( see figure [ fg_fig4 ] ) that if the @xmath40 contains @xmath27 vertices , then the number of applied node reductions is equal to @xmath224 .",
    "thus , the reduction method applied to an @xmath27-vertex @xmath40 includes @xmath225 possible reduction processes that are due to different numbers and execution orders of fork and joint reductions . in the case of @xmath226",
    "the @xmath27-vertex @xmath40 is a series - parallel graph and node reductions are not done .",
    "our intention is to find reduction processes which lead to expression representation @xmath59 with a minimum complexity .",
    "we propose the following algorithm :    1 .",
    "@xmath227 2 .",
    "[ r2]@xmath99 @xmath228 @xmath229 @xmath55 @xmath154 @xmath230 3 .",
    "[ r3]@xmath231 4 .",
    "@xmath104 5 .",
    "@xmath232[r5]@xmath233 6 .",
    "@xmath99 @xmath234 7 .",
    "@xmath235 8 .",
    "@xmath104 9 .",
    "[ r9]@xmath236 10 .",
    "[ r10]@xmath237 @xmath238 @xmath239 @xmath240 @xmath241 @xmath242 11 .",
    "@xmath233 12 .",
    "@xmath99 @xmath234 13 .",
    "@xmath243 * *  * * @xmath244 * *  * * @xmath245 * *  * * @xmath246 * *  * * @xmath247 14 .",
    "@xmath248 15 .",
    "@xmath104 16 .",
    "@xmath243 * *  * * @xmath249 * *  * * @xmath245 * *  * * @xmath246 * *  * * @xmath247 17 . [",
    "r17]@xmath250 18 .",
    "[ r18]@xmath237 @xmath238 @xmath239 19 . @xmath251 * *  * * @xmath244 * *  * * @xmath252 * *  * * @xmath246 * *  * * @xmath247 20 .",
    "[ r20]@xmath248 21 .",
    "[ r21]@xmath237 @xmath241 @xmath239 22 . @xmath251 * *  * * @xmath249 * *  * * @xmath252 * *  * * @xmath246 * *  * * @xmath247 23 .",
    "[ r23]@xmath250    lines [ r2 ] and [ r3 ] of the algorithm determine the numbers of fork and joint reductions to be applied for even @xmath228 ( odd @xmath27 ) . for odd @xmath228 ( even @xmath27 ) there are two possible values for the numbers of fork and joint reductions .",
    "these values are determined in lines [ r5]-[r9 ] by function @xmath253 which generates randomly @xmath53 or @xmath55 .",
    "the @xmath254 loop in lines [ r10]-[r17 ] repeatedly applies a pair of node and parallel reductions .",
    "a kind of a node reduction ( fork or joint ) is also determined by function @xmath253 . after all possible joint or all possible fork reductions are done , the remaining fork ( lines [ r18]-[r20 ] ) or remaining joint ( lines [ r21]-[r23 ] ) reductions , respectively , are applied .",
    "we define this algorithm as the _ optimal reduction method_. @xmath255    [ th_fg_red_min]the minimum complexity representation ( for terms and for plus operators ) among all possible expression representations @xmath59 derived by the reduction method for an @xmath27-vertex @xmath40 ( @xmath256 ) is achieved by the optimal reduction method .",
    "actually , as follows from lines [ r2]-[r9 ] of the optimal decomposition method , we should prove that the minimum complexity representation ( for terms and for plus operators ) is achieved if and only if ( i ) the number of applied fork reductions is equal to the number of applied joint reductions for odd @xmath27 ; ( ii ) the numbers of fork reductions and joint reductions are distinguished by one for even @xmath27 .",
    "the initial number of terms on the graph edges is equal to the number of edges .",
    "the initial number of plus operators is equal to @xmath230 .",
    "each pair of node and parallel reductions leads to an increase in the total number of terms and plus operators on the graph edges .",
    "this follows from the fact that each node reduction leads to duplicate copies of corresponding terms and subexpressions and to new plus operators .",
    "we should find the numbers of terms and plus operators on the single edge to which the @xmath40 is reduced and analyze how these numbers increase in comparison to with their initial values .",
    "the following basic points are used .",
    "the increment value of the total number of terms and plus operators on the left side of the @xmath40 increases as the number of fork reductions increases ; the increment value on the right side of the @xmath40 increases as the number of joint reductions increases .",
    "indeed , the current increment depends only on the duplicate subexpression that labels the appointed edge .",
    "this edge is positioned between the first and the second vertices in the case of a fork reduction , or between the last but one and the last vertices in the case of a joint reduction .",
    "the increment of the first complexity characteristic is equal to the total number of terms in the duplicate subexpression .",
    "the increment of the second complexity characteristic is equal to the number of plus operators in this subexpression with an additional plus operator added . in the next step of the reduction algorithm , the above mentioned edge",
    "is the result of parallel reduction at two edges .",
    "one of these edges is labeled by the subexpression including the duplicate subexpression of the previous step ( see figure fg_fig4 ) .",
    "hence , the size of the duplicate subexpression for the next reduction increases and , therefore , the increment value increases .",
    "the above mentioned increment values from the left side and from the right side of the @xmath40 are independent , i.e. , the increment value after a current fork reduction does not depend on the number of already applied joint reductions and vice versa .",
    "we prove the stronger statement which asserts that the above mentioned duplicate subexpressions determining the increments are independent . in every reduction step ,",
    "we conditionally denote the edge labels of the reduced @xmath40 as the edge labels of the initial @xmath40 shown in figure [ fig2 ] . in such a case , in each reduction step , edges leaving the source of the reduced @xmath40 are labeled @xmath43 and @xmath49 , respectively , and edges entering the sink of the reduced @xmath40 are labeled @xmath124 and @xmath257 , respectively .",
    "hence , @xmath43 is a current duplicate subexpression before a fork reduction and @xmath124 is a current duplicate subexpression before a joint reduction .",
    "the new ( after a fork and parallel reduction ) @xmath43 depends only on the old ( before a fork reduction ) @xmath43 , @xmath44 , and @xmath49 .",
    "the new ( after a joint and parallel reduction ) @xmath124 depends only on the old ( before a joint reduction ) @xmath124 , @xmath258 , and @xmath257 .",
    "labels @xmath44 and @xmath259 are initial terms always . they do not change and depend on nothing .",
    "the new @xmath49 depends only on the old @xmath43 and @xmath50 .",
    "the new @xmath260 depends only on the old @xmath124 and @xmath261 .",
    "labels @xmath50 and @xmath261 are also initial terms always , and depend on nothing .",
    "for this reason , the new @xmath43 in no step depends on the old @xmath124 and @xmath257 and the new @xmath124 in no step depends on the old @xmath43 and @xmath49 . on the other hand ,",
    "the @xmath59 accumulation takes place only in @xmath43 and @xmath262 , and in @xmath124 and @xmath257 .",
    "the pair of the fork and parallel reductions influences only the new @xmath43 and @xmath49 , and the pair of the joint and parallel reductions influences only the new @xmath124 and @xmath257 .",
    "all the above holds for all reduction steps including the last one , when @xmath263 and @xmath124 draw closer to one another .",
    "figure [ fg_fig5 ] , where the reduction method is applied to a @xmath264-vertex @xmath40 , illustrates this phenomenon .",
    "two possible algorithms in which either the fork reduction comes first ( and the joint reduction follows ) or the joint reduction comes first ( and the fork reduction follows ) are illustrated .",
    "as shown , both algorithms lead to the same result .",
    "labels on edges @xmath265 and @xmath266 of the resulting @xmath56-edge st - dag have no common terms .",
    "that is , @xmath43 does not depend on joint reductions and @xmath124 does not depend on fork reductions .",
    "therefore , duplicate subexpressions from the left side and from the rightside are independent , and , thus , corresponding increment values are independent as well .",
    "( 5,2)(-4,-0.5 )    ( 0,0)(1.5,0)5    ( 0,-0.3)(0,0)1 ( 1.5,-0.3)(0,0)2 ( 3,-0.3)(0,0)3 ( 4.5,-0.3)(0,0)4 ( 6,-0.3)(0,0)5    ( 0,0)(1.5,0)4(1,0)1.5    ( 0.75,-0.2)(0,0)@xmath43 ( 2.25,-0.2)(0,0)@xmath44 ( 3.75,-0.2)(0,0)@xmath45 ( 5.25,-0.2)(0,0)@xmath212    ( 0,0)(1.5,2)(3,0 ) ( 1.5,0)(3,2)(4.5,0 ) ( 3,0)(4.5,2)(6,0 )    ( 3.085,0)(1.5,0)3(3,-2)0    ( 1.5,1.3)(0,0)@xmath49 ( 3,1.3)(0,0)@xmath50 ( 4.5,1.3)(0,0)@xmath214    ( 1.5,-1.2)(-1,-1)1.5 ( 4.5,-1.2)(1,-1)1.5    ( -2,-1.3)(0,0)fork red . at vertex 2 ( -2,-1.8)(0,0)par",
    ". red . at vertices 1 and 3 ( 8,-1.3)(0,0)joint red . at vertex 4 ( 8,-1.8)(0,0)par .",
    "red . at vertices 3 and 5    ( 5,2)(-8.5,2.5 )    ( 0,0)(1.5,0)4    ( 0,-0.3)(0,0)1 ( 1.5,-0.3)(0,0)2 ( 3,-0.3)(0,0)3 ( 4.5,-0.3)(0,0)5    ( 0,0)(1.5,0)3(1,0)1.5    ( 0.75,-0.2)(0,0)@xmath43 ( 2.25,-0.2)(0,0)@xmath44 ( 3.75,-0.9)(0,0)@xmath267    ( 3.5,-0.7)(1,2)0.3    ( 0,0)(1.5,2)(3,0 ) ( 1.5,0)(3,2)(4.5,0 )    ( 3.085,0)(1.5,0)2(3,-2)0    ( 1.5,1.3)(0,0)@xmath49 ( 3,1.3)(0,0)@xmath268    ( 1.5,-2.2)(-1,-1)1.5    ( 3.5,-2.6)(0,0)fork red . at vertex 2 ( 3.5,-3.1)(0,0)par .",
    "red . at vertices 1 and 3    ( 5,2)(-1,0.5 )    ( 0,0)(1.5,0)4    ( 0,-0.3)(0,0)1 ( 1.5,-0.3)(0,0)3 ( 3,-0.3)(0,0)4 ( 4.5,-0.3)(0,0)5    ( 0,0)(1.5,0)3(1,0)1.5    ( 0.75,-0.9)(0,0)@xmath219 ( 2.25,-0.2)(0,0)@xmath45 ( 3.75,-0.2)(0,0)@xmath212    ( 0.5,-0.7)(1,2)0.3    ( 0,0)(1.5,2)(3,0 ) ( 1.5,0)(3,2)(4.5,0 )    ( 3.085,0)(1.5,0)2(3,-2)0    ( 1.5,1.3)(0,0)@xmath220 ( 3,1.3)(0,0)@xmath214    ( 3,-2.2)(1,-1)1.5    ( 1,-2.6)(0,0)joint red . at vertex 4 ( 1,-3.1)(0,0)par .",
    "red . at vertices 3 and 5    ( 5,2)(-4.75,4 )    ( 0,0)(2.25,0)3    ( 0,-0.3)(0,0)1 ( 2.25,-0.3)(0,0)3 ( 4.5,-0.3)(0,0)5    ( 0,0)(2.25,0)2(1,0)2.25    ( 1.125,-0.2)(0,0)@xmath219 ( 3.375,-0.2)(0,0)@xmath267    ( 0,0)(2.25,2)(4.5,0 )    ( 4.585,0)(1.5,0)1(3,-2)0    ( 2.25,1.3)(0,0)@xmath269    ( 5,4.5)(-7,0.5 )",
    "the increment value related to the @xmath97-th fork reduction in the @xmath158 is equal to the increment value related to the @xmath97-th joint reduction in the @xmath40 .",
    "this follows from the symmetrical structure of an @xmath40 and from independence of fork and joint reductions .    as noted above , if the @xmath40 contains @xmath27 vertices , then the number of applied node reductions is equal to @xmath224 . since in each step ,",
    "two kinds of node reductions are possible , initially , the potential number of possible node reductions is equal to @xmath270 ( @xmath228 fork and @xmath228 joint reductions ) . hence , we can present the reduction procedure as follows .",
    "there are two equal stacks @xmath271 and @xmath272 ( figure [ fg_fig6 ] ) .",
    "each of them contains @xmath228 elements .",
    "the size of an element in each stack increases from top to bottom .",
    "the elements of the same level in @xmath271 and @xmath272 are of equal size . here",
    "a @xmath273 operation on @xmath271 corresponds to a fork reduction and a @xmath273 operation on @xmath272 corresponds to a joint reduction .",
    "the size of a stack element corresponds to an increment value .",
    "we should put out @xmath228 elements from two stacks .",
    "it is clear that for even @xmath228 ( odd @xmath27 ) the total size of pulled out elements will be minimum if and only if a @xmath273 operation is done @xmath274 times on each stack . for odd @xmath228 ( even @xmath27 ) , in order to ensure the minimum total size , a @xmath273 operation should be done @xmath275 times on @xmath276 and @xmath277 times on @xmath272 , or vice versa .",
    "thus , the proof of the theorem is complete .",
    "( 12,5)(0,0.8 )    ( 2,5)(0,1)(5,1)(3,5)(2,5 ) ( 1.75,4.5)(3.25,4.5 ) ( 1.5,4)(3.5,4 ) ( 1.25,3.5)(3.75,3.5 ) ( 2.5,3)(2.5,2 ) ( 0.25,1.5)(4.75,1.5 )    ( 2.5,4.75)(0,0)el .",
    "1 ( 2.5,4.25)(0,0)elem . 2 ( 2.5,3.75)(0,0)element 3 ( 2.5,1.25)(0,0)element @xmath228    ( 2.5,0.5)(0,0)@xmath271    ( 12,0)(-8,0.3 )    ( 2,5)(0,1)(5,1)(3,5)(2,5 ) ( 1.75,4.5)(3.25,4.5 ) ( 1.5,4)(3.5,4 ) ( 1.25,3.5)(3.75,3.5 ) ( 2.5,3)(2.5,2 ) ( 0.25,1.5)(4.75,1.5 )    ( 2.5,4.75)(0,0)el .",
    "1 ( 2.5,4.25)(0,0)elem . 2 ( 2.5,3.75)(0,0)element 3 ( 2.5,1.25)(0,0)element @xmath228",
    "( 2.5,0.5)(0,0)@xmath272    the expression representation @xmath59 derived by the reduction method does not depend on the execution order of fork and joint reductions and depends only on their number .",
    "the proof is similar to point 2 in the proof of theorem [ th_fg_red_min ] . as noted , the @xmath59 accumulation takes place only in @xmath43 and @xmath49 , and in @xmath124 and @xmath257 , i.e. , on edges leaving the source and entering the sink of the current reduced @xmath40 .",
    "accumulation processes on these pairs of edges are independent .",
    "as shown in figure [ fg_fig5 ] , in the last reduction steps , when the source and the sink draw closer to one another , edge labels of the resulting @xmath56-edge st - dag do not depend also on the order of the execution of reductions .    the number of possible reduction processes included by the optimal reduction method applied to an @xmath27-vertex @xmath40 is equal to@xmath278for odd @xmath27 and @xmath279for even @xmath27 .",
    "the different reduction processes are due to different execution orders of fork and joint reductions .",
    "it may be noted that each pair of a fork and a parallel reduction corresponds to two parallel recursion steps of the dfs method , each of which is executed by traversing the @xmath40 in opposite directions .",
    "these steps are equivalent to an ordinary @xmath59 accumulation step on two edges , leaving the source of the current reduced @xmath40 . by analogy , each pair of a joint and a parallel reduction corresponds to two parallel recursion steps of the direct dfs method .",
    "they are equivalent to an ordinary @xmath59 accumulation step on two edges , entering the sink of the current reduced @xmath40 .",
    "hence , the reduction process in an @xmath40 can be conditionally presented as four parallel dfs processes on four subgraphs of this @xmath40 .",
    "the corresponding four subexpressions are linked in the final step of the reduction procedure ( see figure [ fg_fig4 ] ) .",
    "the resulting expression is constructed from the following three elements : four subexpressions which are obtained by applying the dfs method to four corresponding subgraphs of the @xmath40 ; one additional term @xmath280 ( @xmath281 determines the place where the @xmath40 is decomposed into subgraphs , and depends on the number of fork and joint reductions ) ; and one additional plus operation .    if only fork or only joint reductions are applied to a fibonacci graph",
    ", then the reduction method gives the dfs method .",
    "hence , the dfs method is a special ( worst from the perspective of the complexity ) case of the reduction method .",
    "the optimal reduction method is equivalent to applying the dfs method to four subgraphs which are revealed by decomposing the @xmath40 in the middle .",
    "this results in the following correlations between the reduction method and the dfs method : @xmath282@xmath283here @xmath284 and @xmath285 are the first complexity characteristics of @xmath59 which is derived by the optimal reduction method and the dfs method , respectively , for an @xmath27-vertex @xmath40 ; @xmath286 and @xmath287 are the second complexity characteristics of @xmath59 which is derived by the optimal reduction method and the dfs methods , respectively , for an @xmath27-vertex @xmath40 .",
    "[ th_red_exp]for an @xmath27-vertex @xmath40 :    \\1 .",
    "the total number of terms @xmath25 in the expression @xmath59 derived by the optimal reduction method is defined recursively as follows : @xmath2882 .",
    "the number of plus operators @xmath26 in the expression @xmath59 derived by the optimal reduction method is defined recursively as follows : @xmath289    \\1 .",
    "initial statements @xmath69 , @xmath70 , @xmath183 , @xmath290 , @xmath291 can be checked . for @xmath292",
    ", we consider odd and even @xmath27 and use formulae ( fgf3 ) and ( [ fgf5 ] ) .",
    "\\(i ) odd @xmath27@xmath293(ii ) even @xmath27@xmath2942 .",
    "the proof is analogous and is based on formulae ( [ fgf4 ] ) and ( fgf6 ) .",
    "as follows from theorems [ th_seq_exp ] , [ th_dfs_exp ] , [ th_dls_exp ] , and [ th_red_exp ] , the optimal decomposition method is more efficient than all the methods presented in section [ simple ] from the perspective of both complexity characteristics .",
    "[ cor_red_exp]for an @xmath27-vertex @xmath40 :    \\1 .",
    "the total number of terms @xmath25 in the expression @xmath59 derived by the optimal reduction method is expressed explicitly as follows : @xmath295 \\left ( i% \\sqrt{\\frac{\\sqrt{5}-1}{2}}\\right ) ^{n}-7\\quad \\\\ ( n & > & 1)\\end{aligned}\\ ] ]    or@xmath296 \\left ( \\sqrt{\\frac{\\sqrt{5}-1}{2}}\\right ) ^{n}-7 \\\\ ( n & > & 1).\\end{aligned}\\ ] ]    \\2 .",
    "the number of plus operators @xmath26 in the expression @xmath59 derived by the optimal reduction method is expressed explicitly as follows : @xmath297 \\left ( i\\sqrt{\\frac{\\sqrt{5}-1}{2}}% \\right ) ^{n}-3\\quad \\\\ (",
    "n & > & 1)\\end{aligned}\\ ] ]    or@xmath298 \\left ( \\sqrt{\\frac{\\sqrt{5}-1}{2}}\\right ) ^{n}-3 \\\\ ( n & > & 1).\\end{aligned}\\ ] ]    the proof of corollary [ cor_red_exp ] uses the recurrences obtained in theorem [ th_red_exp ] and is based on the method @xcite .    for @xmath85 ,",
    "the algebraic expression derived by the optimal reduction method is @xmath299it contains @xmath300 terms and @xmath301 plus operators .",
    "as noted above , the optimal reduction method is equivalent to applying the dfs method to four subgraphs which are revealed by decomposing an @xmath27-vertex @xmath40 in the middle .",
    "the dfs method has to be employed twice in the direct and twice in the opposite direction .",
    "for this reason , we will implement the optimal reduction method using the algorithms presented in section dfs_anal as its base .",
    "@xmath302    1 .",
    "@xmath99 @xmath71 2 .",
    "[ redo2]@xmath303 3 .",
    "@xmath99 @xmath304 4 .",
    "@xmath145 5 .",
    "@xmath146 6 .",
    "[ redo6]@xmath305 7 .   @xmath99 @xmath306 8 .",
    "@xmath150 9 .",
    "@xmath151 10 .",
    "@xmath153 11 .",
    "@xmath307 12 .",
    "[ redo12]@xmath308 13 .",
    "@xmath99 @xmath309 14 .",
    "@xmath150 15 .",
    "@xmath151 16 .",
    "@xmath153 17 .",
    "@xmath310 18 .",
    "[ redo18]@xmath311 19 .",
    "@xmath99 @xmath312 20 .",
    "@xmath150 21 .",
    "@xmath151 22 .",
    "@xmath153 23 .",
    "@xmath104 24 .",
    "@xmath105 @xmath27 @xmath154 @xmath55 25 .",
    "@xmath313 26 .",
    "@xmath156 27 .",
    "@xmath157    for even @xmath27 , the number of joint reductions implemented by this algorithm will be greater than the number of fork reductions by one .",
    "hence , there exists the second version of the algorithm with another choice of the middle of the graph for even @xmath27 which implements the greater number of fork reductions .",
    "both realizations give the same expression for odd @xmath27 .    running times of procedures for the dfs method applied to an @xmath314-vertex @xmath40 ( lines [ redo2 ] , [ redo6 ] , [ redo12 ] , [ redo18 ] ) are , as follows from section [ dfs_anal ] , @xmath315 .",
    "other operations of the algorithm are performed in @xmath160 time .",
    "thus , the running time of the algorithm is @xmath316 .",
    "the amount of memory that requires the algorithm is determined only by the size of the derived expression and , by corollary [ cor_red_exp ] , is also @xmath317 .",
    "this method is based on revealing subgraphs in the initial graph .",
    "the resulting expression is produced by a special composition of subexpressions describing these subgraphs .",
    "consider the @xmath27-vertex @xmath40 presented in figure [ fig2 ] .",
    "denote by @xmath318 a subexpression related to its subgraph ( which is an @xmath40 as well ) having a source @xmath319 ( @xmath320 ) and a sink @xmath321 ( @xmath322 , @xmath323 ) .",
    "if @xmath324 , then we choose any _ decomposition vertex _",
    "@xmath325 ( @xmath326 ) in a subgraph , and , in effect , split it at this vertex ( figure [ fg_fig7 ] ) .",
    "otherwise , we assign final values to @xmath327 .",
    "as follows from the @xmath40 structure , any path from vertex @xmath319 to vertex @xmath321 passes through vertex @xmath97 or avoids it via edge @xmath328 .",
    "therefore , @xmath329 can be generated by the following recursive procedure ( _ decomposition procedure _ ) :    1 .",
    "[ 1]@xmath330 @xmath331 2 .",
    "[ 2]@xmath330 @xmath332 3 .",
    "[ 3]@xmath330 @xmath333 4 .",
    "[ 4]@xmath334    ( 5,2)(-0.5,-0.4 )    ( 0,0)(1.5,0)10    ( 0,-0.3)(0,0)p ( 1.5,-0.3)(0,0)p+1 ( 6,-0.3)(0,0)i-1 ( 7.4,-0.3)(0,0)i ( 9,-0.3)(0,0)i+1 ( 12,-0.3)(0,0)q-1 ( 13.5,-0.3)(0,0)q    ( 0,0)(1.5,0)9(1,0)1.5    ( 0.75,0.2)(0,0)@xmath335 ( 6.75,0.2)(0,0)@xmath336 ( 8.25,0.2)(0,0)@xmath337 ( 12.75,0.2)(0,0)@xmath338    ( 0,0)(1.5,2)(3,0 ) ( 1.5,0)(3,2)(4.5,0 ) ( 3,0)(4.5,2)(6,0 ) ( 4.5,0)(6,2)(7.5,0 ) ( 6,0)(7.5,2)(9,0 ) ( 7.5,0)(9,2)(10.5,0 ) ( 9,0)(10.5,2)(12,0 ) ( 10.5,0)(12,2)(13.5,0 )    ( 1.5,1.3)(0,0)@xmath339 ( 7.2,1.3)(0,0)@xmath340 ( 12,1.3)(0,0)@xmath341    ( 3.085,0)(1.5,0)8(3,-2)0    ( 3.2,-0.2)(0.2,0)6 ( 10.05,-0.2)(0.2,0)6    ( 7.5,-0.7)(0,0.2)12(0,1)0.1    lines [ 1 ] and [ 2 ] contain conditions of exit from the recursion .",
    "the special case when a subgraph consists of a single vertex is considered in line [ 1 ] .",
    "it is clear that such a subgraph can be connected to other subgraphs only serially . for this reason",
    ", it is accepted that its subexpression is @xmath53 , so that when it is multiplied by another subexpression , the final result is not influenced .",
    "line [ 2 ] describes a subgraph consisting of a single edge .",
    "the corresponding subexpression consists of a single term equal to the edge label .",
    "the general case is processed in lines [ 3 ] and [ 4 ] .",
    "the procedure , @xmath342 , in line [ 3 ] chooses an arbitrary decomposition vertex @xmath97 on the interval @xmath343 so that @xmath344 .",
    "a current subgraph is decomposed into four new subgraphs in line [ 4 ] .",
    "subgraphs described by subexpressions @xmath345 and @xmath346 include all paths from vertex @xmath319 to vertex @xmath321 passing through vertex @xmath97 .",
    "subgraphs described by subexpressions @xmath347 and @xmath348 include all paths from vertex @xmath319 to vertex @xmath321 passing through edge @xmath328 .",
    "@xmath349 is the expression of the initial @xmath27-vertex @xmath40 ( @xmath350 ) .",
    "hence , the decomposition procedure is initially invoked by substituting parameters @xmath53 and @xmath27 instead of @xmath319 and @xmath321 , respectively .",
    "in @xcite we proved the following theorem that determines an optimal location of the decomposition vertex @xmath97 in an arbitrary interval @xmath343 of a fibonacci graph from the perspective of the first complexity characteristic .",
    "[ th_fg - n/2]the representation with a minimum total number of terms among all possible representations of @xmath59 derived by the decomposition method is achieved if and only if in each recursive step @xmath97 is equal to @xmath351 for odd @xmath352 and to @xmath353 or @xmath354 for even @xmath352 , i.e. , when @xmath97 is a middle vertex of the interval @xmath343 .",
    "such a decomposition method is called _",
    "optimal_.    the following theorem for the second complexity characteristic",
    "is proven in @xcite .",
    "[ th_fg - n/2_p]the representation with a minimum number of plus operators among all possible representations of @xmath59 derived by the decomposition method can be achieved by the optimal decomposition method .",
    "it can be easily shown that for an @xmath27-vertex @xmath40 :    \\1 .",
    "the total number of terms @xmath25 in the expression @xmath59 derived by the optimal decomposition method is defined recursively as follows : @xmath355    \\2 .",
    "the number of plus operators @xmath26 in the expression @xmath59 derived by the optimal decomposition method is defined recursively as follows : @xmath356for large @xmath27@xmath357    by the _ master theorem _ @xcite recurrences like @xmath358where @xmath359 and @xmath360 are constants , and @xmath361 is interpreted as either @xmath362 or @xmath363 , can be bounded asymptotically as follows : @xmath364if @xmath365 for some constant @xmath366 .    therefore , @xmath25 and @xmath26 are @xmath367 .    for @xmath85 ,",
    "the possible algebraic expression derived by the optimal decomposition method is @xmath368it contains @xmath369 terms and @xmath370 plus operators .",
    "we conjecture that the optimal decomposition method provides an optimal representation ( for both our complexity characteristics ) of an algebraic expression related to a fibonacci graph .",
    "as shown in @xcite , the optimal decomposition method is not always the only one that provides an expression for a fibonacci graph with a minimum number of plus operators .",
    "there exist _ special values of _",
    "@xmath27 when an @xmath27-vertex fibonacci graph has several expressions with the same minimum number of plus operators ( among expressions derived by the decomposition method ) .",
    "these special values are grouped as follows : @xmath371 in the general view , they can be presented in the following way : @xmath372here @xmath373 is a number of a group of special numbers ; @xmath374 is a special number of the @xmath373-th group ; @xmath375 and @xmath376 are the first value and the last value , respectively , in the @xmath373-th group .",
    "for all these values of @xmath27 , not only the values of @xmath97 which are mentioned in theorem [ th_fg - n/2 ] , provide a minimum number of plus operators in @xmath59 .",
    "it can be shown that if @xmath377 or @xmath378 in every recursive step ( the same value in each step ) then the decomposition method turns out to be the dls method .",
    "if @xmath97 is an arbitrary number in the first recursive step , and in all subsequent steps @xmath379 or @xmath380 ( the same value in each step ) then the decomposition method may be interpreted as the reduction method . specifically , if @xmath97 in the first step is the same as @xmath97 in all following steps , then the decomposition method coincides with the dfs method .",
    "we propose the following recursive algorithm which realizes the optimal decomposition  method in accordance with the above procedure and theorem th_fg - n/2 :     @xmath381    1 .",
    "@xmath99 @xmath382 2 .",
    "[ deco2]@xmath383 3 .",
    "@xmath99 @xmath384 4 .",
    "@xmath145 5 .",
    "@xmath146 6 .",
    "[ deco6]@xmath385 7 .",
    "@xmath99 @xmath386 8 .",
    "@xmath150 9 .",
    "@xmath151 10 .",
    "@xmath153 11 .",
    "@xmath307 12 .",
    "[ deco12]@xmath387 13 .",
    "@xmath99 @xmath388 14 .",
    "@xmath150 15 .",
    "@xmath151 16 .",
    "@xmath153 17 .",
    "@xmath389 18 .",
    "[ deco18]@xmath390 19 .",
    "@xmath99 @xmath391 20 .",
    ". @xmath151 22 .",
    "@xmath153 23 .",
    "@xmath104 24 .",
    "@xmath105 @xmath392 @xmath154 @xmath53 25 .",
    "@xmath393 26 .",
    "@xmath156 27 .",
    "@xmath157    the algorithm is initially invoked by substituting @xmath53 and @xmath27 instead of @xmath319 and @xmath321 , respectively , for deriving the expression of an @xmath27-vertex @xmath40 .",
    "four recursive calls ( lines [ deco2 ] , [ deco6 ] , [ deco12 ] , deco18 ) include a middle of the interval @xmath343 in their parameter list ( @xmath394 is a number of the decomposition vertex while its another possible number is @xmath395 ) .",
    "hence , the running time of the algorithm is @xmath396 .",
    "the amount of memory that requires the algorithm is determined only by the size of the derived expression and , thus , is also @xmath397 .",
    "as follows from the previous section , the decomposition method is based on splitting an @xmath40 in each recursive step into two parts via decomposition vertex @xmath97 and edge @xmath328 .",
    "the gd method entails splitting an @xmath40 in each recursive step into an arbitrary number of parts ( we will denote this number by @xmath398 ) via _ decomposition vertices _",
    "@xmath399 and edges @xmath400 , respectively .",
    "an example for @xmath401 is illustrated in figure [ fg_fig8 ] .",
    "( 5,2)(-0.5,-0.4 )    ( 0,0)(1.5,0)10    ( 0,-0.3)(0,0)p ( 4.35,-0.3)(0,0)i@xmath402 ( 8.85,-0.3)(0,0)i@xmath403 ( 13.5,-0.3)(0,0)q    ( 0,0)(1.5,0)9(1,0)1.5    ( 0,0)(1.5,2)(3,0 ) ( 1.5,0)(3,2)(4.5,0 ) ( 3,0)(4.5,2)(6,0 ) ( 4.5,0)(6,2)(7.5,0 ) ( 6,0)(7.5,2)(9,0 ) ( 7.5,0)(9,2)(10.5,0 ) ( 9,0)(10.5,2)(12,0 ) ( 10.5,0)(12,2)(13.5,0 )    ( 4.1,1.3)(0,0)@xmath404 ( 8.6,1.3)(0,0)@xmath405    ( 3.085,0)(1.5,0)8(3,-2)0    ( 1.7,-0.2)(0.2,0)6 ( 6.2,-0.2)(0.2,0)6 ( 10.7,-0.2)(0.2,0)6    ( 4.5,-0.7)(0,0.2)12(0,1)0.1 ( 9,-0.7)(0,0.2)12(0,1)0.1    in all cases when @xmath406 , the decomposition procedure used in the previous section is transformed to the more complex form .",
    "specifically , for @xmath401 , the general line of the new decomposition procedure , corresponding to line [ 4 ] of the decomposition procedure with @xmath407 is presented as : @xmath408the sum above consists of four parts , with each part including three subexpressions corresponding to the three parts of a split subgraph .",
    "hence , a current subgraph is decomposed into twelve new subgraphs .",
    "suppose that an @xmath40 is split into approximately equal parts in each recursive step ( distances between decomposition vertices are equal or approximately equal ) .",
    "it will be the _ uniform gd method_.    the following theorem is proven in @xcite .",
    "[ th_gd]for an @xmath27-vertex @xmath40 , both the total number of terms @xmath25 and the number of plus operators @xmath26 in the expression @xmath59 derived by the uniform gd method ( the @xmath40 is split into @xmath398 parts ) are @xmath409 .",
    "as follows from theorem [ th_gd ] , @xmath25 and @xmath26 reach the minimum complexity among @xmath410 when @xmath407 . substituting @xmath55 for @xmath398",
    "gives @xmath411 ( we have the optimal decomposition method in this case ) .",
    "further , the complexity increases with the increase in @xmath398 .",
    "for example , we have @xmath412 for @xmath401 , @xmath413 for @xmath414 , etc . in the extreme case , when @xmath415 , all inner vertices ( from @xmath55 to @xmath66 ) of an @xmath27-vertex @xmath40 are decomposition vertices .",
    "the single recursive step is executed in this case , and all revealed subgraphs are individual edges ( labeled @xmath34 with index ) connected by additional edges ( labeled @xmath35 with index ) .",
    "that is , in this instance , the uniform gd method is reduced to the sequential paths method .",
    "substituting @xmath416 for @xmath398 gives @xmath417    these results do not contradict our conjecture that the optimal decomposition method provides an optimal representation . at least , it is the best one among uniform gd methods ( asymptotically ) .",
    "various algorithms generating an algebraic expression for a fibonacci graph were proposed .",
    "complexities of representations derived by sequential paths , dfs , dls , and reduction methods increase exponentially as the number of the graph s vertices increases . the generalized decomposition ( gd ) method has algorithms generating representations with polynomial complexity .",
    "specifically , the decomposition method provides an algorithm for constructing the expression with @xmath411 complexity .",
    "the methods we considered are closely related one to another .",
    "the gd method encompasses the widest class of algorithms , and among them , all algorithms of the decomposition method .",
    "one of them , the optimal decomposition method , is assumed to be the best , from the perspective of complexity .",
    "the decomposition algorithms class comprises as subclasses reduction algorithms , two dls algorithms , etc .",
    "the subclass of reduction algorithms includes the optimal reduction method , two dfs algorithms , etc .",
    "the dfs method is the worst among reduction algorithms and is assumed to be the worst among decomposition algorithms .",
    "the sequential paths method is a special case of the gd method , but it does not belong to the class of decomposition algorithms .",
    "it generates an expression with the maximum complexity .",
    "the different methods relationship is illustrated in figure [ fg_fig2 ] .",
    "m. korenblit and v. e. levit , _ on algebraic expressions of series - parallel and fibonacci graphs _ , in : discrete mathematics and theoretical computer science , proc .",
    "conf . , dmtcs 2003 , lncs * 2731 * , springer , 2003 , 215224 ."
  ],
  "abstract_text": [
    "<S> the paper investigates relationship between algebraic expressions and graphs . </S>",
    "<S> we consider a digraph called a fibonacci graph which gives a generic example of non - series - parallel graphs . </S>",
    "<S> our intention in this paper is to simplify the expressions of fibonacci graphs and eventually find their shortest representations . with that end in view </S>",
    "<S> , we describe the number of methods for generating fibonacci graph expressions and carry out their comparative analysis .    </S>",
    "<S> keywords : fibonacci graph , series - parallel graph , two - terminal directed acyclic graph , reduction . </S>"
  ]
}