{
  "article_text": [
    "the   specification  @xcite defines several   services to forward events generated on _ update _ regions to a set of _ subscription _ regions .",
    "for example , consider a simulation of vehicles moving on a two - dimensional terrain .",
    "each vehicle may be interested in events happening inside its area of interest ( e.g. , its field of view ) that might be approximated with a rectangular region centered at the vehicle position .",
    "this kind of problem also arises in the context of massively multiplayer online games , where the game engine must send updates only to players that might be affected by game events , in order to reduce computation cost and network traffic . in this paper",
    "we assume that a region corresponds to a single _ extent _ in   terminology ) , that is , a @xmath0-dimensional rectangle ( @xmath0-rectangle ) in a @xmath0-dimensional routing space .",
    "spatial data structures that can solve the region intersection problem have been developed over the years ; examples include the @xmath1-@xmath0 tree  @xcite and r - tree  @xcite . however , it turns out that simpler , less efficient solutions are actually preferred in practice and widely deployed in   implementations .",
    "the reason is that efficient spatial data structures tend to be complex to implement , and therefore their theoretical performance is affected by high constant factors .",
    "the increasingly large size of computer simulations employing   techniques is posing a challenge to the existing solutions .",
    "as the number of regions increases , so does the execution time of the   service . given the current trend in microprocessor design where a single cpu contains multiple independent execution units , significant improvements could be achieved if the existing   matching algorithms were capable of taking advantage of the computational power provided by multi - core processors .",
    "there are two opportunities for parallelizing   algorithms .",
    "the first is based on the observation that the problem of identifying whether two @xmath0-rectangles intersect can be reduced to @xmath0 independent intersection problems among one - dimensional segments ( details will be given in section  [ sec : ddm - algorithms ] ) .",
    "therefore , given an algorithm that can identify intersections among two sets of segments , we can execute @xmath0 instances in parallel , each computing the intersections among the projections of the extents along each dimension .",
    "the extent intersections can be easily computed from the segments overlap information .",
    "the idea above can be regarded as the `` low hanging fruit '' which is easy to get , but does not solve the problem in the long run .",
    "in fact , the number of cores in modern processors is often larger than the number of dimensions of most routing spaces ; this gap is likely to increase ( e.g. , the tilera tile - gx8072 processor  @xcite offers 72 general - purpose cores on the same chip , connected through an on - chip mesh network ) . here comes the second parallelization opportunity : distribute the regions to the available cores so that each core can work on a smaller problem .",
    "this is quite difficult to achieve on the existing   algorithms , since they are either inefficient ( and therefore there is little incentive in splitting the workload ) , or inherently sequential ( and therefore there is no easy way to achieve parallelism over the set of extents ) .    in this paper",
    "we describe the   algorithm for solving the one - dimensional segment intersection problem .",
    "the algorithm uses a simple implementation of the interval tree data structure based on an augmented balanced search tree .",
    "experimental performance measures indicate that the sequential version of   is competitive in the sequential case with the best algorithm used for  , namely sort - based matching .",
    "we also observed good scalability of the parallel implementation of   on shared - memory architectures .",
    "an important feature of   is that it can be used to efficiently update overlap information in a dynamic setting , that is , in case extents can be moved or resized dynamically .",
    "this paper is organized as follows . in section  [ sec : related - work ] we briefly review the state of the art and compare   with existing solutions to the   matching problem . in section  [ sec : ddm - algorithms ]",
    "we describe three commonly used algorithms for  : brute force , grid - based and sort - based matching . in section",
    "[ sec : parallel - ddm ] we describe   and analyze its computational cost . in section  [ sec : experimental - evaluation ]",
    "we experimentally evaluate the performance of the sequential version of   compared with brute force and sort - based matching ; additionally , we study the scalability of a parallel implementation of   on a multicore processor . finally , conclusions and future works will be discussed in section  [ sec : conclusions ] .",
    "matching can be considered as an instance of the more general problem of identifying intersecting pairs of ( hyper-)rectangles in a multidimensional metric space . well known space - partitioning data structures such as @xmath1-@xmath0 trees  @xcite and r - trees  @xcite can be used to efficiently store volumetric objects and identify intersections with a query object . however , spatial data structures are quite complex to implement and , although asymptotically efficient , they can be slower than less efficient but simpler solutions in many real - world situations  @xcite . in  @xcite",
    "the authors describe a rectangle - intersection algorithm in two - dimensional space that uses only simple data structures ( arrays ) , and can enumerate all @xmath1 intersections among @xmath2 rectangles @xmath3 time and @xmath4 space .",
    "the usage of interval trees for   was first proposed in  @xcite where the authors used a different and more complex data structure than the one proposed here ( see section  [ sec : parallel - ddm ] ) . in their case , the performance evaluation on very small instances shows mixed results .",
    "@xcite is a widely used algorithm for enumerating all intersections among subscription and update extents , with particular emphasis on distributed simulation applications based on the high level architecture ( hla ) specification .",
    "first sorts the endpoints , and then scans the sorted set ( details will be given in section  [ sec : sort - based ] ) .",
    "is extended in  @xcite to work efficiently on a dynamic scenario where extents can be moved or resized dynamically .    despite its simplicity and efficiency , has the drawback that its sequential scan step is intrinsically serial and can not be easily parallelized .",
    "this can be a serious limitation when dealing with a large number of extents on multicore processors .    in  @xcite",
    "the authors propose a binary partition - based matching algorithm that has good performances in some settings , but suffers from a worst case cost of @xmath5 where @xmath6 is the total number of subscription and update regions .",
    "moreover , the extension of this algorithm to the dynamic scenario seems impractical .",
    "layer et al .",
    "@xcite describe the binary interval search ( bits ) algorithm .",
    "bits can be used to efficiently count the number of intersections between two sets @xmath7 and @xmath8 of intervals in time @xmath9 . to do so",
    ", bits performs a preprocessing phase in which two sorted arrays @xmath10 and @xmath11 are created in time @xmath12 .",
    "@xmath10 contains the starting points of all intervals in @xmath8 , while @xmath11 contains the ending points . the number of intervals in @xmath8 that intersect a given query interval @xmath13 $ ] can be computed by subtracting from @xmath14 the number of intervals which do _ not _ intersect @xmath15 .",
    "bits uses two binary searches in @xmath10 and @xmath11 to compute the number of intervals in @xmath8 whose ending point precedes @xmath16 , and those whose starting point follows @xmath17 .",
    "while bits can be easily parallelized by executing the binary searches in parallel , it must be observed that the problem of enumerating all intersections can not be easily handled by bits without substantial modifications which significantly increase its computational cost .",
    "in this section we define the   problem and describe three well known solution algorithms that have been thoroughly investigated .",
    "let @xmath18 and @xmath19 be two sets of rectangular regions in @xmath0-dimensional space ( @xmath0-rectangles , also called _ extents _ ) .",
    "@xmath20 is the set of _ subscription extents _ , while @xmath21 is the set of _ update extents_. each extent @xmath22 has an integer attribute @xmath23 representing its index in the set it belongs to , e.g. , @xmath24 and @xmath25 .",
    "the goal of a   matching algorithm is to identify all intersections between a subscription and an update extent , that is , enumerating the content of the subset of @xmath26 defined as @xmath27     dimensions ]    figure  [ fig : ddm_example ] shows an example in @xmath28 dimensions with three subscription extents @xmath29 and two update extents @xmath30 .",
    "we observe that @xmath31 overlaps with @xmath32 and @xmath33 , while @xmath34 overlaps with @xmath35 and @xmath33 .",
    "the preferred way of storing the intersections uses a @xmath36 binary matrix @xmath37 , where each element @xmath38 if and only if @xmath39 intersects @xmath40 . in the case of figure",
    "[ fig : ddm_example ] we have @xmath41 since the number of intersections is generally much smaller than @xmath42 , matrix @xmath37 tends to be sparse and can be stored in compressed form to reduce the memory requirement .",
    "it is important to observe that any   algorithm that enumerates all @xmath43 intersections requires time at least @xmath44 ; we say that the time complexity of   matching algorithms is _ output - sensitive _ , since it depends on the size of the output as well as on the size of the input .",
    "since @xmath45 , in the worst case we have that any algorithm has a worst - case complexity of @xmath46 .",
    "every algorithm that stores the result into an uncompressed intersection matrix requires time @xmath46 to initialize the matrix , regardless of the number of intersections . despite this",
    ", it makes sense to try to improve the efficiency of overlap identification , since in practice this is the slower step of the   problem .",
    "* return * @xmath47    testing whether two @xmath0-rectangles intersect is a key operation .",
    "when @xmath48 the problem is reduced to testing whether two segments @xmath49 $ ] , @xmath50 $ ] intersect , that can be done in time @xmath51 using algorithm  [ alg : intersect1d ] .    for the general case @xmath52 we observe that two @xmath0-dimensional extents @xmath39 and @xmath40 intersect if and only if all their projections along each dimension intersect . looking again at figure  [ fig : ddm_example ] , we see that the projections of @xmath32 and @xmath34 intersect along dimension 1 but not along dimension 2 ; therefore , @xmath32 and @xmath34 can not intersect . on the other hand , the projections of @xmath35 and @xmath34 intersect along both dimensions , and in fact these rectangular regions intersect in the plane .    since dealing with segments is easier than dealing with @xmath0-rectangles , it is common practice in the   research community to define efficient algorithms for the one - dimensional case , and use them to solve the general higher dimensional case . according to the discussion above , an algorithm that enumerates all intersections among two sets of @xmath2 and @xmath53 segments in time @xmath54",
    "can be immediately extended to an @xmath55 algorithm for @xmath0-rectangles .",
    "for this reason in the rest of this paper we will consider the case @xmath48 only .",
    "@xmath56 , @xmath57 let @xmath37 be an @xmath36 intersection matrix @xmath58 * return * @xmath37    the most direct approach for solving the segment intersection problem is region - based matching , also called   approach shown in algorithm  [ alg : brute - force ] . the   algorithm tests all @xmath42 subscription - update pairs , and records intersection information in matrix @xmath37 .",
    "the   algorithm requires time @xmath46 , and is therefore not very efficient ; despite this , it is appealing due to its simplicity .",
    "furthermore , can be trivially parallelized since all iterations are independent ( it is an example of _ embarrassingly parallel _ computation ) .",
    "when @xmath59 processors are available , the amount of work performed by each processor is @xmath60 .       dimensions . ]    the   matching algorithm proposed by boukerche and dzermajko  @xcite is an improved solution to the @xmath0-rectangle intersection problem .",
    "it works by partitioning the routing space into a grid of @xmath0-dimensional cells .",
    "each extent is mapped to the grid cells it overlaps with .",
    "the events produced by an update extent @xmath40 are sent to all subscriptions that share at least one cell in common with @xmath40 .",
    "the   approach is more scalable than  ; furthermore , its performance can be tuned by choosing a suitable cell size .",
    "unfortunately , it has some drawbacks : matching may report spurious overlaps , that is , may deliver events to subscribers which should not receive them .",
    "this situation is illustrated in figure  [ fig : ddm_example_grid ] : the extent @xmath31 and @xmath35 share the dashed cell but do not overlap ; therefore , @xmath35 will receive spurious notifications from @xmath31 that will need to be filtered out at the receiving side .",
    "the problem of spurious events can be mitigated by applying the brute force algorithm to each grid cell .",
    "if the routing space is partitioned into @xmath61 cells and all extents are evenly distributed over the grid , each cell will have @xmath62 subscription extents and @xmath63 update extents .",
    "therefore , the brute force approach applied to each cell requires @xmath64 operations ; since there are @xmath61 cells , the overall complexity becomes @xmath65 . in conclusion , in the ideal case the   matching can reduce the workload by a factor @xmath61 with respect to  .",
    "unfortunately , when cells are small ( and therefore @xmath61 is large ) each extent is mapped to a larger number of cells , which increases the computation time .",
    "the   algorithm proposed by raczy et al .",
    "@xcite is a simple and very efficient solution to the   matching problem .",
    "@xmath56 , @xmath57 let @xmath37 be an @xmath36 intersection matrix let @xmath66 be a vector with @xmath67 elements insert @xmath68 and @xmath69 in @xmath66 sort @xmath66 in nondecreasing order @xmath70 [ alg : sbm - loop ] @xmath71 @xmath72 extents in @xmath73 overlap @xmath22 @xmath74 @xmath75 @xmath76",
    "@xmath77 @xmath78 extents in @xmath79 overlap @xmath22",
    "@xmath80 @xmath81 @xmath76 * return * @xmath37    in its basic version , is illustrated in algorithm  [ alg : sort - based ] .",
    "given a set @xmath20 of @xmath2 subscription intervals , and a set @xmath21 of @xmath53 update intervals , the algorithm sorts the endpoints in nondecreasing order in the array @xmath66 .",
    "then , the algorithm performs a scan of the sorted vector ; two sets @xmath79 and @xmath73 are used to keep track of the active subscription and update intervals at every point @xmath59 .",
    "each time the upper bound of an interval @xmath22 is encountered , the intersection matrix @xmath37 is updated appropriately , depending on whether @xmath22 is a subscription or update extent .    as can be seen , uses only simple data structures .",
    "if we ignore the time needed to initialize the matrix @xmath37 , algorithm  [ alg : sort - based ] requires time @xmath82 to sort the vector @xmath66 , then time @xmath83 to scan the sorted vector . during the scan phase",
    ", total time @xmath46 is spent to transfer the information from the sets _ subscriptionset _ and _ updateset _ to the intersection matrix @xmath37 , assuming that the sets above are implemented as bitmaps  @xcite .",
    "the overall computational cost is @xmath84 , and therefore asymptotically not better than  ; however , the term @xmath46 comes from simple operations on bitmaps , hence   is very efficient in practice  @xcite .    while   is very fast , it has the drawback of not being easily parallelizable .",
    "in fact , while parallel algorithms for sorting the array @xmath66 are known  @xcite , the scan step is affected by loop - carried dependencies , since the content of _ subscriptionset _ and _ updateset _ depend on their values at the previous iteration .",
    "this dependency can not be easily removed .",
    "given the widespread availability of multi- and many - core processors , this limitation can not be ignored .    in the next section",
    "we introduce the   algorithm for computing intersections among two sets of intervals .",
    "uses an augmented avl tree data structure to store the intervals .",
    "the performance of   depends on the number of intersections ; however we will show that   is faster than   in the scenarios considered in the literature .",
    "furthermore , can be trivially parallelized , hence further performance improvements can be obtained on shared - memory multi - core processors .",
    "is a   matching algorithm for one dimensional segments based on the _ interval tree _ data structure .",
    "an interval tree stores a dynamic set of @xmath2 intervals , and supports insertions , deletions , and queries to get the list of segments intersecting with a given interval @xmath15",
    ".    different implementations of the interval tree are possible .",
    "priority search trees  @xcite support insertions and deletions in time @xmath85 , and can report all @xmath1 intersections with a given query interval in time @xmath86 .",
    "for the experimental evaluation described in section  [ sec : experimental - evaluation ] we implemented the simpler but less efficient variant based on augmented avl trees  @xcite , described in  ( * ? ? ?",
    "* chapter 14.3 ) .",
    "we did so in order to trade a slight decrease in asymptotic efficiency for a simpler and more familiar data structure .",
    "it should be observed that   is not tied to any specific implementation of interval tree , therefore any data structure can be used as a drop - in replacement inside the algorithm .",
    "each node @xmath87 of the avl tree holds an interval @xmath88 ; intervals are sorted according to their lower bounds , and ties are broken by comparing upper bounds .",
    "node @xmath87 includes two additional fields @xmath89 and @xmath90 , representing the maximum value of the upper bound and minimum value of the lower bound , respectively , of all intervals stored in the subtree rooted at @xmath87 .",
    "we have chosen avl trees over other balanced search trees , such as red - black trees  @xcite , because avl trees are more rigidly balanced and therefore allow faster queries .",
    "figure  [ fig : interval_tree ] shows an example of interval tree with @xmath91 intervals . insertions and deletions are handled with the usual rules of avl trees , with the additional requirement to propagate updates of the @xmath92 and @xmath93 attributes up to the root .",
    "since the height of an avl tree is @xmath85 , insertions and deletions in the augmented data structure still require @xmath85 time in the worst case .",
    "the storage requirement is @xmath4 .",
    "* return *    @xmath94 , @xmath95 @xmath76    function @xmath96 , described in algorithm  [ alg : query ] , is used to update matrix @xmath37 with all intersections of the update extent @xmath15 with the segments stored in the subtree rooted at node @xmath87 .",
    "the function is invoked as @xmath97 .",
    "the basic idea is very similar to a conventional item lookup in a binary search tree , the difference being that at each node @xmath87 both the @xmath90 and @xmath89 fields are used to drive the exploration of the tree ; also , the search might proceed on both the left and right child of node @xmath87 .",
    "algorithm  [ alg : query ] can identify all @xmath1 intersections between @xmath15 and all @xmath2 intervals stored in the tree @xmath22 in time @xmath98 .",
    "@xmath56 , @xmath57 let @xmath37 be an @xmath36 intersection matrix @xmath99 * return * @xmath37    the complete   matching procedure can now be easily described in algorithm  [ alg : itm ] .",
    "first , an interval tree @xmath22 is created from the subscription extents in @xmath20 .",
    "then , for each update extent @xmath100 , function interval - query is invoked to identify all subscriptions that intersect @xmath40 .    [",
    "[ asymptotic - running - time ] ] asymptotic running time + + + + + + + + + + + + + + + + + + + + + + +    if there are @xmath2 subscription and @xmath53 update extents , the interval tree of subscriptions can be created in time @xmath101 and requires space @xmath4 ; the total query time is @xmath102 , @xmath45 being the number of intersections involving all subscription and all update intervals .",
    "note that we can assume without loss of generality that @xmath103 ( if this is not the case , we can switch the role of @xmath20 and @xmath21 ) .    [ [ parallelizing ] ] parallelizing   + + + + + + + + + + + + + +    algorithm  [ alg : itm ] can be trivially parallelized , since all @xmath53 queries on @xmath22 are independent .",
    "note that function interval - query modifies the intersection matrix @xmath37 passed as parameter ; however , each invocation of interval - query modifies a different column of @xmath37 , therefore no conflicts arise . in section  [ sec : experimental - evaluation ] we will illustrate the results of experimental investigations on the scalability of the parallel implementation of  .    [ [ dynamic - interval - management ] ] dynamic interval management + + + + + + + + + + + + + + + + + + + + + + + + + + +    another interesting feature of   is that it can easily cope with _ dynamic _ intervals . in most applications , extents can move and grow / shrink dynamically ; if an update extent , say @xmath40 , changes its position or size , then it is necessary to recompute column @xmath104 of matrix @xmath37 .",
    "the brute force approach applied to @xmath40 alone gives an @xmath4 algorithm , since it is only necessary to identify overlaps between @xmath40 and all @xmath2 subscription segments .",
    "an extension of   capable of updating intersection information efficiently has been proposed  @xcite , with an asymptotic cost that depends on various factors ( e.g. , upper bound of the dimension , maximum bound shift in a region modification ) . on the other hand ,",
    "we can use two interval trees @xmath105 and @xmath106 , holding the set of update and subscription extents , respectively , to recompute the intersections efficiently .",
    "if an update extent @xmath40 is modified , we can identify the subscriptions overlapping @xmath40 in time @xmath107 by performing a query on @xmath106 .",
    "similarly , if a subscription extent @xmath39 changes , the list of intersections can be recomputed in time @xmath108 using @xmath105 .",
    "maintenance of both @xmath105 and @xmath106 does not affect the asymptotic cost of  .",
    "the performance of a   service can be influenced by many different factors , including : ( _ i _ ) the computational cost of the   matching algorithm ; ( _ ii _ ) the memory footprint ; ( _ iii _ ) the communication overhead of the parallel / distributed architecture where the simulation is executed and ( _ iv _ ) the cost of sending and discarding irrelevant events at the destination , if any .",
    "the communication overhead depends on the hardware platform over which the simulation model is executed , and also on the implementation details of the communication protocol used by the simulation middleware .",
    "therefore , factor ( _ iii _ ) above is likely to equally affect any   algorithm in the same way .",
    "the cost of discarding irrelevant notifications applies only to approximate matching algorithms , such as   matching , that can report spurious intersections ( unless spurious intersections are cleaned up at the sender side ) .",
    "the  , and   algorithms do not suffer from this problem since they never return spurious intersections .",
    "besides , in  @xcite and  @xcite the authors show that for relevant cases the   algorithm has better performance than   matching . therefore , in the performance evaluation study we focused on the exact matching algorithms above , where only factors ( _ i _ ) and ( _ ii _ ) should be considered .",
    "j.  rosenberg , `` geographical data structures compared : a study of data structures supporting region queries , '' _ computer - aided design of integrated circuits and systems , ieee transactions on _ , vol .  4 , no .  1 ,",
    "pp . 5367 , 1985 .",
    "m.  petty and a.  mukherjee , `` experimental comparison of d - rectangle intersection algorithms applied to hla data distribution , '' in _ proceedings of the 1997 distributed simulation symposium _",
    ", 1997 , pp . 1326 .",
    "f.  devai and l.  neumann , `` a rectangle - intersection algorithm with limited resource requirements , '' in _ proc .",
    "10th ieee int . conf . on computer and information technology _ ,",
    "cit 10.1em plus 0.5em minus 0.4em washington , dc , usa : ieee computer society , 2010 , pp .",
    "23352340 .",
    "a.  boukerche and c.  dzermajko , `` performance comparison of data distribution management strategies , '' in _ proc .",
    "5th ieee int .",
    "workshop on distributed simulation and real - time applications _ ,",
    "ds - rt 01.1em plus 0.5em minus 0.4emwashington , dc , usa : ieee computer society , 2001 , pp .",
    "67.              d.  t. marr , f.  binns , d.  l. hill , g.  hinton , d.  a. koufaty , a.  j. miller , and m.  upton , `` hyper - threading technology architecture and microarchitecture , '' _ intel technology journal _ , vol .  6 , no .  1 , feb .",
    "2002 .",
    "l.  bononi , m.  bracuto , g.  dangelo , and l.  donatiello , `` a new adaptive middleware for parallel and distributed simulation of dynamically interacting systems , '' in _ proc .",
    "8th ieee int . symp . on distributed simulation and real - time applications_.1em plus",
    "0.5em minus 0.4emwashington , dc , usa : ieee computer society , 2004 , pp . 178187 ."
  ],
  "abstract_text": [
    "<S> identifying intersections among a set of @xmath0-dimensional rectangular regions ( @xmath0-rectangles ) is a common problem in many simulation and modeling applications . since algorithms for computing intersections over a large number of regions </S>",
    "<S> can be computationally demanding , an obvious solution is to take advantage of the multiprocessing capabilities of modern multicore processors . </S>",
    "<S> unfortunately , many solutions employed for the data distribution management service of the high level architecture are either inefficient , or can only partially be parallelized . in this paper </S>",
    "<S> we propose the interval tree matching ( itm ) algorithm for computing intersections among @xmath0-rectangles . </S>",
    "<S> itm is based on a simple interval tree data structure , and exhibits an embarrassingly parallel structure . </S>",
    "<S> we implement the itm algorithm , and compare its sequential performance with two widely used solutions ( brute force and sort - based matching ) . </S>",
    "<S> we also analyze the scalability of itm on shared - memory multicore processors . </S>",
    "<S> the results show that the sequential implementation of itm is competitive with sort - based matching ; moreover , the parallel implementation provides good speedup on multicore processors .    </S>",
    "<S> data distribution management ; high level architecture ; parallel algorithms ; interval tree </S>"
  ]
}