{
  "article_text": [
    "given two sets @xmath10 and @xmath6 , _ the assignment problem _ aims to optimally assign each object of one set to at least one object of the other set .",
    "the assignment problem has applications in various fields such as computational biology @xcite , pattern recognition @xcite , computer vision @xcite , music information retrieval @xcite , and computational music theory @xcite .",
    "let @xmath10 and @xmath6 be two sets with @xmath18 , eiter and mannila @xcite proposed an @xmath15 algorithm for the assignment problem between @xmath10 and @xmath6 by reducing it to the minimum - weight perfect matching problem in a bipartite graph .    in this paper",
    ", we consider the generalized assignment between @xmath10 and @xmath6 , called ga problem , where each point @xmath19 is assigned to at least @xmath4 and at most @xmath5 points in @xmath6 , and each point @xmath20 is assigned to at least @xmath8 and at most @xmath9 points in @xmath10 , such that sum of the matching costs is minimized .",
    "we also present an @xmath15 time algorithm for a special case of the ga problem , where each object must be matched to at least one object .",
    "schrijver @xcite solved the ga problem in strongly polynomial time .",
    "we present a new algorithm which computes a generalized assignment between @xmath10 and @xmath6 in @xmath13 time using @xmath14 space . in section [ preliminaries ]",
    ", we review the basic hungarian algorithm and some preliminary definitions . in section [ newalgorithms ]",
    ", we present our new algorithms .",
    "given an undirected bipartite graph @xmath21 , a _ matching _ in @xmath22 is a subset of the edges @xmath23 , such that each vertex @xmath24 is incident to at most one edge of @xmath25 .",
    "let @xmath26 denote the weight of the edge @xmath27 , the weight of the matching @xmath25 is the sum of the weights of all edges in @xmath25 , hence @xmath28 a _ max - weight matching _",
    "@xmath25 is a matching that for any other matching @xmath29 , we have @xmath30 .    a path with the edges alternating between @xmath25 and @xmath31 is called an _ alternating path_. each vertex @xmath32 that is incident to an edge in @xmath25",
    "is called a _ matched vertex _ ; otherwise it is a _",
    "free vertex_. an alternating path that its both endpoints are free is called an _ augmenting path_. note that if the @xmath25 edges of an augmenting path is replaced with the @xmath31 ones , its size increases by @xmath33 .    a _ vertex labeling _ is a function @xmath34 that assigns a label to each vertex @xmath35 . a vertex labeling that in which @xmath36 for all @xmath37 and @xmath38 is called a _",
    "feasible labeling_. the equality graph of a feasible labeling @xmath39 is a graph @xmath40 such that @xmath41 .",
    "the _ neighbors _ of a vertex @xmath42 is defined as @xmath43 .",
    "consider a set of the vertices @xmath44 , the neighbors of @xmath45 is @xmath46 .",
    "[ lem1 ] consider a feasible labeling @xmath39 of an undirected bipartite graph @xmath47 and @xmath48 with @xmath49 , let @xmath50 if the labels of the vertices of @xmath22 is updated such that : @xmath51 then @xmath52 is also a feasible labeling such that @xmath53 .",
    "* proof . *",
    "note that @xmath39 is a feasible labeling , so we have @xmath54 for each edge @xmath27 of @xmath55 . after the update",
    "four cases arise :    * @xmath56 and @xmath57 . in this case",
    "@xmath58 * @xmath59 and @xmath60 .",
    "we have @xmath61 * @xmath59 and @xmath57 .",
    "we see that @xmath62 * @xmath56 and @xmath60 . in this situation",
    "we have @xmath63 two cases arises : * * @xmath64 .",
    "so @xmath65 hence , @xmath66 . * * @xmath67 .",
    "obviously @xmath68",
    "if @xmath39 is a feasible labeling and @xmath25 is a perfect matching in @xmath69 , then @xmath25 is a max - weight matching @xcite .    *",
    "* suppose that @xmath29 is a perfect matching in @xmath22 , since each vertex is incident to exactly one edge of @xmath29 we have : @xmath70 so , @xmath71 is an upper bound for each perfect matching .",
    "now assume that @xmath25 is a perfect matching in @xmath69 : @xmath72 it is obvious that @xmath25 is an optimal matching .    in the following ,",
    "we briefly describe the basic hungarian algorithm which computes a max - weight perfect matching in an undirected bipartite graph @xmath21 with @xmath73 .",
    "it is obvious that for computing the minimum cost many to many matching using the hungarian algorithm we must weight each edge @xmath74 by @xmath75 .",
    "find an initial feasible labeling @xmath39 and a matching @xmath25 in @xmath69 let @xmath76 @xmath77 @xmath78    select a free vertex @xmath79 and set @xmath80 , @xmath81 @xmath82=l(a_i)+l(b_j)-weight(a_i , b_j)$ ] @xmath83 $ ] @xmath84 update the labels according to lemma [ lem1 ] @xmath82=slack[j]-\\alpha_l$ ] select @xmath85 ( @xmath86 is matched to a vertex @xmath87 , extend the alternating tree ) @xmath88 .",
    "@xmath82=\\min ( l(z)+l(b_j)-weight(z , b_j),slack[j])$ ]    @xmath89 @xmath25    in lines @xmath90 and @xmath91 , we label all vertices of @xmath6 with zero and each vertex @xmath3 with @xmath92 to get an initial feasible labeling . note that @xmath25 can be empty . in each iteration of the while loop of lines @xmath93 ,",
    "two free nodes @xmath94 and @xmath95 are matched , so it iterates @xmath14 times . using the array @xmath96 $ ]",
    ", we can run each iteration of this loop in @xmath97 time .",
    "the repeat loop runs at most @xmath14 times until finding a free node @xmath95 . in line @xmath98",
    ", we can compute the value of @xmath99 by : @xmath100,\\ ] ] in @xmath14 time . after computing @xmath99 and updating the labels of the vertices",
    ", we must also update the values of the slacks .",
    "this can be done using : @xmath101=slack[j]-\\alpha_l.\\ ] ] in line @xmath102 , we update the feasible labeling @xmath39 such that @xmath103 . in line @xmath104 of algorithm",
    "[ basichungarian ] , when a vertex is moved form @xmath105 to @xmath45 the values of @xmath96 $ ] must be updated .",
    "this is done in @xmath14 time .",
    "@xmath14 vertices are moved from @xmath105 to @xmath45 , so it takes the total time of @xmath97 .",
    "the value of @xmath99 may be computed at most @xmath14 times in @xmath14 , so running each iteration takes at most @xmath97 time .",
    "so , the time complexity of the basic hungarian algorithm is @xmath15 .",
    "in this section , we describe our new algorithm which is based on the well known hungarian algorithm .",
    "consider two sets @xmath0 and @xmath106 with @xmath107 .",
    "let @xmath108 and @xmath109 denote the demand sets of @xmath10 and @xmath6 , respectively .",
    "let @xmath110 and @xmath111 be the capacity sets of @xmath10 and @xmath6 , respectively . without loss of generality , we assume that @xmath112 .",
    "the input of our algorithm is the complete bipartite graph that is constructed as follows .",
    "consider the complete bipartite graph @xmath113 where @xmath114 and @xmath115 ( see figure [ fig:1 ] ) .",
    "complete connection _ between two sets is a connection that in which each element of one set is connected to all elements of the other set .",
    "we show each set of the vertices by a rectangle and the complete connection between them by a line connecting the two corresponding rectangles .",
    "given @xmath116 and @xmath117 , there exists a complete connection between @xmath10 and @xmath6 such that the weight of @xmath118 is equal to the cost of matching the point @xmath94 to @xmath95 for all @xmath119 and @xmath120 .",
    "let @xmath121 and @xmath122 , each point of @xmath10 is connected to the all points of @xmath123 such that the weight of @xmath124 is equal to the weight of @xmath125 .",
    "there exists also a complete connection between the sets @xmath6 and @xmath126 such that the weight of @xmath127 is equal to the weight of @xmath125 .",
    "let @xmath10 and @xmath6 be two sets with @xmath18 , a generalized assignment between @xmath10 and @xmath6 can be computed in @xmath13 time .",
    "* we apply our new algorithm , algorithm [ gaa ] , on our bipartite graph @xmath22 .",
    "let @xmath128 and @xmath129 denote the capacity and the demand of the vertex @xmath86 ; so for all @xmath17 we have @xmath130 , @xmath131 , @xmath132 , and @xmath133 .    in our algorithm ,",
    "a vertex @xmath134 is free to another vertex @xmath135 when @xmath134 is not matched with @xmath135 in @xmath25 and has at least one empty capacity .",
    "so , @xmath3 and @xmath136 are called free vertices to a vertex @xmath137 that are not matched with it in @xmath25 , if @xmath138 and @xmath139 , respectively .",
    "also the vertices @xmath95 and @xmath140 are free to another vertex that is not incident in @xmath25 to them , when @xmath141 and @xmath142 , respectively .",
    "we save the current number of the vertices that are matched to the vertices of @xmath10 , @xmath6 , @xmath126 , and @xmath123 in the arrays @xmath143 $ ] , @xmath144 $ ] , @xmath145 $ ] , and @xmath146 $ ] , respectively ; for example @xmath147 $ ] shows the number of the nodes that are matched to @xmath94 .",
    "the initial values of the arrays is @xmath148 ; when a new point is matched to their representing node their values are increased by @xmath33 .",
    "assume that @xmath149 returns the number of the vertices that are matched to @xmath86 so far .",
    "so @xmath150 $ ] , @xmath151 $ ] , @xmath152 $ ] , and finally @xmath153 $ ] .",
    "note that the procedures @xmath154 and @xmath155 return @xmath156 if @xmath86 is free and @xmath86 is matched , respectively .",
    "therefor , for example in the augmenting path @xmath157 , the vertex @xmath158 is free to @xmath137 , @xmath137 is matched to @xmath159 , and @xmath160 is free to @xmath159 .",
    "now we change the basic hungarian algorithm as follows .",
    "find an initial feasible labeling @xmath39 and a matching @xmath25 in @xmath69 let @xmath161 @xmath162 @xmath163@xmath164 let @xmath165    select @xmath166 with @xmath154 set @xmath167 @xmath82=\\min(l(u)+l(b_j)-weight(u , b_j))$ ]    @xmath168=\\min(l(u)+l(b'_j)-weight(u , b'_j))$ ]    @xmath169,\\min_{b'_j \\notin t}slack[j+t])$ ] @xmath84 select @xmath170    ( @xmath135 is matched to some vertices @xmath87 ) @xmath171 @xmath82=\\min ( l(z)+l(b_j)-weight(z , b_j),slack[j])$ ] @xmath168=\\min ( l(z)+l(b'_j)-weight(z , b'_j),slack[j+t])$ ]    @xmath89    we first label the vertices of our bipartite graph @xmath22 using an initial feasible labeling in lines @xmath172 . in each iteration of our algorithm",
    ", @xmath173 increases by @xmath33 .",
    "so , our algorithm has @xmath97 iterations with @xmath97 time and runs in @xmath13 time .",
    "now we present an @xmath15 algorithm for the limited - capacity assignment problem , where each object must be assigned to at least one point of the other set and the capacity of each object is limited .",
    "let @xmath10 and @xmath6 be two sets with @xmath18 , a limited - capacity assignment between @xmath10 and @xmath6 can be computed in @xmath15 time .",
    "* we use the bipartite complete graph that is constructed for the generalized assignment problem .",
    "we modify the ga algorithm as following .",
    "find an initial feasible labeling @xmath39 and a matching @xmath25 in @xmath69 let @xmath161 @xmath162 @xmath163@xmath164 let @xmath165    select @xmath174 with @xmath154 set @xmath167    @xmath82=\\min(l(u)+l(b_j)-weight(u , b_j))$ ]    @xmath168=\\min(l(u)+l(b'_j)-weight(u , b'_j))$ ]    @xmath169,\\min_{b'_j \\notin t}slack[j+t])$ ]    @xmath84 select @xmath170    ( @xmath135 is matched to some vertices @xmath87 ) @xmath171 @xmath82=\\min ( l(z)+l(b_j)-weight(z , b_j),slack[j])$ ]    @xmath168=\\min ( l(z)+l(b'_j)-weight(z , b'_j),slack[j+t])$ ]    @xmath89    select @xmath175 with @xmath154 set @xmath167 @xmath176=\\min(l(u)+l(a_i)-weight(a_i , u))$ ] @xmath177=\\min(l(u)+l(a'_i)-weight(a'_i , u))$ ]    @xmath178,\\min_{a'_i \\notin t}slack[i+s])$ ]    @xmath84 select @xmath170    ( @xmath135 is matched to some vertices @xmath87 ) @xmath171 @xmath176=\\min ( l(z)+l(a_i)-weight(a_i , z),slack[i])$ ] @xmath177=\\min ( l(z)+l(a'_i)-weight(a'_i , u),slack[i+s])$ ]    @xmath89",
    "in this paper , we presented an @xmath13 time and @xmath14 space algorithm for computing a generalized assignment between @xmath10 and @xmath6 with total cardinality @xmath179 .",
    "in fact , we modified the basic hungarian algorithm to get a new algorithm , called the generalized assignment algorithm .",
    "then , we construct a bipartite graph @xmath22 and apply our new algorithm on @xmath22 .",
    "we also improved an @xmath15 algorithm for the limited - capacity assignment problem ."
  ],
  "abstract_text": [
    "<S> let @xmath0 and @xmath1 be two sets of objects with @xmath2 , _ the generalized assignment problem _ assigns each element @xmath3 to at least @xmath4 and at most @xmath5 elements in @xmath6 , and each element @xmath7 to at least @xmath8 and at most @xmath9 elements in @xmath10 for all @xmath11 and @xmath12 . in this paper , we present an @xmath13 time and @xmath14 space algorithm for this problem using the well known hungarian algorithm </S>",
    "<S> . we also present an @xmath15 algorithm for a special case of the generalized assignment , called _ the limited - capacity assignment problem _ </S>",
    "<S> , where @xmath16 for all @xmath17 .    </S>",
    "<S> generalized assignment problem , limited - capacity assignment problem , hungarian method , complete bipartite graph , objects with demands and capacities </S>"
  ]
}