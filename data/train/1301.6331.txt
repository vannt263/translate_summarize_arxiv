{
  "article_text": [
    "in distributed storage systems ( dss ) , it is desirable that data be reliably stored over a network of nodes in such a way that a user ( _ data collector _ ) can retrieve the stored data even if some nodes fail .",
    "to achieve such a resilience against node failures , dss introduce data redundancy based on different coding techniques .",
    "for example , erasures codes are widely used in such systems : when using an @xmath0 code , data to be stored is first divided into @xmath1 blocks ; subsequently , these @xmath1 information blocks are encoded into @xmath2 blocks stored on @xmath2 distinct nodes in the system .",
    "in addition , when a single node fails , the system reconstructs the data stored in the failed node to keep the required level of redundancy .",
    "this process of data reconstruction for a failed node is called _ node repair process _  @xcite . during a node repair process , the node which is added to the system to replace the failed node downloads data from a set of appropriate and accessible nodes .",
    "there are two important goals that guide the design of codes for dss : reducing the _ repair bandwidth _ ,",
    "i.e. the amount of data downloaded from system nodes during the node repair process , and achieving _ locality _ , i.e. reducing the number of nodes participating in the node repair process .",
    "these goals underpin the design of two families of codes for dss called _ regenerating codes _ ( see  @xcite and references therein ) and _ locally repairable codes _ ( see  @xcite ) , respectively .",
    "in this paper we focus on the locally repairable codes ( lrcs ) .",
    "recently , these codes have drawn significant attention within the research community .",
    "oggier et al .",
    "@xcite presents coding schemes which facilitate local node repair . in  @xcite ,",
    "gopalan et al . establishes an upper bound on the minimum distance of scalar lrcs , which is analogous to the singleton bound .",
    "the paper also showes that pyramid codes , presented in @xcite , achieve this bound with information symbols locality .",
    "subsequently , the work by prakash et al .",
    "extends the bound to a more general definition of scalar lrcs  @xcite .",
    "( han and lastras - montano  @xcite provide a similar upper bound which is coincident with the one in  @xcite for small minimum distances , and also present codes that attain this bound in the context of reliable memories . ) in @xcite , papailiopoulos and dimakis generalize the bound in @xcite to vector codes , and present locally repairable coding schemes which exhibits mds property at the cost of small amount of additional storage per node .",
    "the main contributions of our paper are as follows .",
    "first , in section  [ sec : preliminaries ] , we generalize the definition of _ scalar _ locally repairable codes , presented in  @xcite to _ vector _ locally repairable codes . for such codes , every node storing @xmath3 symbols from a given field @xmath4 , can be locally repaired by using data stored in at most @xmath5 other nodes from a group of nodes of size @xmath6 , which we call a _ local group _",
    ", where @xmath2 is the number of system nodes , and @xmath5 and @xmath7 are the given locality parameters .",
    "subsequently , in section  [ sec : vectorlrc ] , we derive an upper bound on the minimum distance @xmath8 of the vector codes that satisfy a given locality constraint , which establishes a trade off between node failure resilience ( i.e. , @xmath8 ) and per node storage @xmath3 .",
    "the bound presented in  @xcite can be considered as a special case of our bound with @xmath9 .",
    "further , we present an explicit construction for lrcs which attain this bound on minimum distance . this construction is based on maximum rank distance ( mrd ) gabidulin codes , which are a rank - metric analog of reed - solomon codes .",
    "scalar _ and _ vector _ lrcs that are obtained by this construction are the first explicit optimal locally repairable codes with @xmath10 . finally , in section  [ sec : discussion ] , we discuss how the scalar and vector codes obtained by this construction can be used for constructions of repair bandwidth efficient lrcs .",
    "we conclude the paper with section  [ sec : conclusions ] .",
    "let @xmath11 be the size of a file @xmath12 to be stored in a dss with @xmath2 nodes .",
    "all data symbols belong to a finite field @xmath4 .",
    "each node stores @xmath3 symbols over @xmath4 .",
    "we generalize the definition of _ scalar _ locally repairable codes , presented in  @xcite to _ vector _ locally repairable codes , where each node @xmath13 , @xmath14 stores a vector @xmath15 of length @xmath3 over @xmath4 .",
    "first , we provide an alternate definition of the minimum distance of a vector code  @xcite .",
    "[ def : dmin ] the minimum distance @xmath8 of a vector code @xmath16 of dimension @xmath11 is defined as @xmath17 : h({{\\bf x}}_{{{\\cal a } } } ) < \\mathcal{m}}|{{\\cal a}}|,\\ ] ] where @xmath18 $ ] and @xmath19 .",
    "it follows from the definition of @xmath8 that the system can tolerate any @xmath20 node failures , or equivalently , a data collector can reconstruct the original data @xmath12 by contacting any set of @xmath21 storage nodes in the dss .",
    "we are interested in ensuring this property of the dss for its entire life span through the course of multiple failures and repairs .",
    "[ def : vectorlrc ] we say that a vector code @xmath16 has @xmath22 _ locality _ if for each node @xmath13 , @xmath14 , storing vector @xmath15 ( of length @xmath3 ) , there exists a set of nodes @xmath23 such that    * @xmath24 * @xmath25 * minimum distance of @xmath26 is at least @xmath7 .",
    "note that the last two properties imply that each element @xmath27 can be written as a function of a set of at most @xmath5 elements in @xmath23 ( not containing @xmath28 ) and that @xmath29 .",
    "codes that satisfy these properties are called @xmath30 _ locally repairable codes _ ( lrcs ) .",
    "note , that these codes are generalizations of vector lrcs given in  @xcite , which considered only the @xmath9 case .",
    "@xmath31 locally repairable codes are named as scalar @xmath22 locally repairable codes .",
    "prakash et al .",
    "@xcite provided the following upper bound on the minimum distance of an @xmath31 lrc : @xmath32    it was established in  @xcite that a family of pyramid codes , presented in  @xcite attains this bound and has _ information locality _ , i.e. only information symbols satisfy the locality constraint .",
    "however , an explicit construction of optimal scalar lrcs with _ all - symbols locality _ is known only for the case @xmath33",
    "the _ existence _ of optimal scalar codes with all - symbols locality is shown for the case when @xmath34 and field size @xmath35  @xcite . in this paper",
    ", we provide an explicit construction of optimal scalar lrcs with all - symbols locality without the restriction @xmath34 .",
    "the following upper bound on the minimum distance of @xmath36 lrcs and construction of codes that attain this bound was presented in  @xcite : @xmath37    in the sequel , we generalize this bound for any @xmath38 and present @xmath39 lrcs that attain this bound .      for the construction presented in this paper we propose a precoding of the file with maximum rank distance codes  @xcite .",
    "let @xmath40 be an extension field of @xmath41 .",
    "since @xmath40 can be also considered as an @xmath42-dimensional vector space over @xmath41 , any element @xmath43 can be represented as the vector @xmath44 , such that @xmath45 , for a fixed basis @xmath46 of the field extension .",
    "similarly , any vector @xmath47 @xmath48 can be represented by an @xmath49 matrix @xmath50 $ ] over @xmath41 , where each entry @xmath51 of @xmath52 is expanded as a column vector @xmath53 .",
    "the _ rank _ of a vector @xmath54 , denoted by @xmath55 , is defined as the rank of the @xmath49 matrix @xmath56 over @xmath41 .",
    "similarly , for two vectors @xmath57 , the _ rank distance _ is defined by @xmath58 .",
    "an @xmath59_{q^m}$ ] @xmath60 is a linear block code over @xmath40 of length @xmath61 , dimension @xmath62 and minimum rank distance @xmath63 .",
    "a rank - metric code that attains the singleton bound @xmath64 in rank - metric is called _ maximum rank distance _ ( mrd ) code . for @xmath65 ,",
    "a construction of mrd codes was presented by gabidulin  @xcite . in the similar way as reed - solomon codes ,",
    "gabidulin codes can be obtained by evaluation of polynomials , however , for gabidulin codes the special family of polynomials , called _",
    "linearized polynomials _ , is used :    a linearized polynomial @xmath66 over @xmath40 of @xmath67degree @xmath68 has the form @xmath69 , where @xmath70 , and @xmath71 .",
    "note , that evaluation of a linearized polynomial is an @xmath72linear transformation from @xmath40 to itself , i.e. , for any @xmath73 and @xmath74 , we have @xmath75  @xcite .    a codeword in an @xmath76_{q^m}$ ] gabidulin code @xmath77 , @xmath65 , is defined as @xmath78 , where @xmath66 is a linearized polynomial over @xmath40 of @xmath67degree @xmath79 with the coefficients given by the information message , and @xmath80 are linearly independent over @xmath41  @xcite .",
    "an mrd code @xmath81 with minimum distance @xmath63 can correct any @xmath82 erasures , which we will call _ rank erasures_. an algorithm for erasures correction of gabidulin codes can be found e.g. in  @xcite .      a linear @xmath83 $ ] _ array code _",
    "@xmath16 of dimensions @xmath84 over @xmath41 is defined as a linear subspace of @xmath85 .",
    "its minimum distance @xmath8 is defined as the minimum hamming distance over @xmath86 , when we consider the codewords of @xmath16 as vectors of length @xmath2 over @xmath87 .",
    "an array code @xmath16 is called a _",
    "maximum distance separable _",
    "( mds ) code if @xmath88 , where @xmath89 .",
    "constructions for mds array codes can be found e.g. in  @xcite .",
    "note , that an mrd code ( in the matrix representation ) is also an mds array code .",
    "regenerating codes are a family of codes for distributed storage that allow for efficient repair of failed nodes .",
    "when using such codes we assume that a data collector can reconstruct the original file by downloading the data stored in any set of @xmath1 out of @xmath2 nodes .",
    "when a node fails , its content can be reconstructed by downloading @xmath90 symbols from any @xmath91 , @xmath92 , surviving nodes . given a file size @xmath93 , a trade - off between storage per node @xmath3 and _ repair bandwidth _",
    "@xmath94 can be established .",
    "two classes of codes that achieve two extreme points of this trade - off are known as _",
    "minimum storage regenerating ( msr ) _ codes and _ minimum bandwidth regenerating ( mbr ) _ codes .",
    "the parameters @xmath95 for msr and mbr codes are given by @xmath96 , @xmath97 , respectively  @xcite .",
    "in this section , we first derive an upper bound on the minimum distance of @xmath30 locally repairable codes .",
    "next , we propose a general code construction which attains the derived bound on @xmath8 . our approach is to apply a two - stage encoding , where we use gabidulin codes ( a rank - metric analog of reed - solomon codes ) along with mds array codes .",
    "this construction can be viewed as a generalization of the construction proposed in  @xcite .",
    "we state a generic upper bound on the minimum distance @xmath8 of an @xmath30 code @xmath16 .",
    "this bound generalizes the bound given in @xcite for lrcs with a single local parity ( @xmath98 ) to lrcs with multiple local parities ( @xmath99 ) .",
    "[ thm : dmin ] let @xmath16 be an @xmath30 lrc .",
    "then , it follows that @xmath100    we follow the proof technique of @xcite . in particular",
    ", the proof involves construction of a set of nodes @xmath101 for a locally repairable dss such that total entropy of the symbols stored in @xmath101 is less than @xmath11 and @xmath102 then follows from definition  [ def : dmin ] and .",
    "see  @xcite for the detailed proof .",
    "remarkably , the theorem above establishes a trade - off between node failure resilience ( i.e. , @xmath8 ) and per node storage @xmath3 , where @xmath3 can be increased to obtain higher @xmath8 .",
    "this is of particular interest in the design of codes having both locality and strong resilience to node failures .",
    "for the special case of @xmath9 , this bound matches with the bound  ( [ eq : dimitrisbound ] ) presented in  @xcite . for the case of @xmath103 ,",
    "the bound reduces to @xmath104 , which is coincident with the bound  ( [ scalarupperbound ] ) presented in  @xcite .",
    "in this subsection we present a construction of an @xmath39 lrc which attains the bound given in theorem  [ thm : dmin ] .",
    "* construction i. * consider a file @xmath12 over @xmath105 of size @xmath106 .",
    "we encode the file in two steps before storing it on dss .",
    "first , the file is encoded using a gabidulin code .",
    "the codeword of the gabidulin code is then partitioned into local groups and each local group is then encoded using an mds array code over @xmath107 .    in particular ,",
    "let @xmath108 be the positive integers such that @xmath109 , and let @xmath77 be an @xmath110_{q^m}$ ] gabidulin code .",
    "we assume in this construction that @xmath111 .",
    "we denote by @xmath112 the number of local groups in the system .    * if @xmath113 then a codeword @xmath114 is first partitioned into @xmath115 disjoint groups , each of size @xmath116 , and each group is stored on a different set of @xmath5 nodes , @xmath3 symbols per node . in other words ,",
    "the output of the first encoding step generates the encoded data stored on @xmath117 nodes , each one containing @xmath3 symbols of a ( folded ) gabidulin codeword .",
    "second , we generate @xmath118 parity nodes per group by applying an @xmath119 $ ] mds array code over @xmath41 on each local group of @xmath5 nodes , treating these @xmath5 nodes as input data blocks ( of length @xmath3 ) for the mds array code . at the end of the second round of encoding",
    ", we have @xmath120 nodes , each storing @xmath3 symbols over @xmath121 , partitioned into @xmath122 local groups , each of size @xmath123 . *",
    "if @xmath124 , for @xmath125 , then a codeword @xmath114 is first partitioned into @xmath126 disjoint groups of size @xmath116 and one additional group of size @xmath127 , the first @xmath128 groups are stored on @xmath129 nodes , and the last group is stored on @xmath130 nodes , each one containing @xmath3 symbols of a ( folded ) gabidulin codeword .",
    "second , we generate @xmath118 parity nodes per group by applying an @xmath119 $ ] mds array code over @xmath131 on each of the first @xmath128 local groups of @xmath5 nodes and by applying a @xmath132 $ ] mds array code over @xmath131 on the last local group . at the end of the second round of encoding",
    ", we have @xmath133 nodes , each storing @xmath3 symbols over @xmath121 , partitioned into @xmath122 local groups , @xmath128 of which of size @xmath123 and one group of size @xmath134 .",
    "we denote the obtained code by @xmath135 .",
    "[ rm : linearized property ] note , that since an mds array code from construction i is defined over @xmath41 , any symbol of any node of @xmath135 can be written as @xmath136 , where @xmath137 , @xmath138 are @xmath139 symbols of the same group of @xmath140 , and @xmath141 , are linearly independent over @xmath41 evaluation points .",
    "hence , _ any _ @xmath142 symbols inside a group of @xmath135 are evaluations of @xmath66 in @xmath143 linearly independent over @xmath41 points .",
    "( if there is a group with @xmath144 elements we have the same result substituting @xmath5 with @xmath130 ) .",
    "thus , _ any _ @xmath145 _ node _ erasures in a group correspond to @xmath146 _ rank _ erasures .",
    "moreover , if we take any @xmath139 symbols of @xmath135 from every group ( and @xmath147 symbols from the smallest group , if it exists ) , we obtain a gabidulin codeword , for a corresponding choice of evaluation points for a gabidulin code , which encodes the given data @xmath11 .",
    "[ trm : vector_optimality ] let @xmath135 be the @xmath30 locally repairable code @xmath135 obtained by construction i. then , for @xmath148 , s.t .",
    "@xmath111 ,    * if @xmath149 then @xmath135 attains the bound  ( [ eq : upp_bound ] ) . * if @xmath150 , then @xmath135 attains the bound  ( [ eq : upp_bound ] ) .",
    "the proof is based on remark  [ rm : linearized property ] and the observation that any @xmath151 node erasures correspond to at most @xmath152 rank erasures which can be corrected by the gabidulin code @xmath77 . see the details in appendix  [ ap : appendix ] .",
    "next , we write the conditions for the construction of @xmath8-optimal code @xmath135 in terms of the given system parameters @xmath153 .",
    "[ cor.parameters ] let @xmath135 be a code obtained by construction  i.    * if @xmath154 , then @xmath135 is optimal , with the length of the corresponding gabidulin code equal to @xmath155 and the field size @xmath156 . * if @xmath157 then @xmath135 is optimal , with the length of the corresponding gabidulin code equal to @xmath158 and the field size @xmath156 .    for the case @xmath103 construction i provides @xmath8-optimal scalar lrcs . note that this is the first explicit construction of optimal scalar locally repairable codes with @xmath10 .",
    "the required field size @xmath159 for the proposed construction should satisfy @xmath65 , for any choice of @xmath160 .",
    "so we can assume that @xmath161 , for @xmath61 given in theorem  [ cor.parameters ] .",
    "note that we can reduce the field size to @xmath162 by stacking  @xcite of @xmath3 independent optimal scalar lrcs , obtained by construction i.    we illustrate the construction of @xmath135 in the following examples .",
    "first we consider the scalar case .",
    "consider the following system parameters : @xmath163 let @xmath164 .",
    "first , @xmath165 symbols over @xmath166 are encoded into a codeword @xmath140 of a @xmath167_{2^{11}}$ ] gabidulin code @xmath77 .",
    "this codeword is partitioned into three groups , two of size @xmath168 and one of size @xmath169 , as follows : @xmath170 .",
    "then , by applying a @xmath171 $ ] mds code in the first two groups and a @xmath172 $ ] mds code in the last group we add one parity to each group .",
    "the symbols of @xmath140 with three new parities @xmath173 are stored on 14 nodes as shown in fig  [ fig : construction1 ] .",
    "lrc for @xmath174 and @xmath175 . ]    by theorem  [ thm : dmin ] , the minimum distance @xmath8 of this code is at most @xmath168",
    ". by remark  [ rm : linearized property ] , any @xmath169 node erasures correspond to at most @xmath176 rank erasures and then can be corrected by @xmath77 , hence @xmath177 .",
    "in addition , when a single node fails , it can be repaired by using the data stored on other nodes from the same group .",
    "next , we illustrate construction i for a vector lrc .",
    "we consider a dss with the following parameters : @xmath178 by  ( [ eq : upp_bound ] ) we have @xmath179 .",
    "let @xmath180 and @xmath181 be a codeword of an @xmath182_{q^{36}}$ ] code @xmath183 , which is obtained by encoding @xmath184 symbols over @xmath185 of the original file .",
    "the gabidulin codeword is then divided into three groups @xmath186 , @xmath187 , and @xmath188 .",
    "encoded symbols in each group are stored on three storage nodes as shown in fig .",
    "[ fig : construction ] . in the second stage of encoding ,",
    "a @xmath189 $ ] mds array code over @xmath131 is applied on each local group to obtain @xmath190 parity nodes per local group .",
    "the coding scheme is illustrated in fig .",
    "[ fig : construction ] .",
    "locally repairable code with @xmath191 and @xmath192 . ]    by remark  [ rm : linearized property ] , any @xmath168 node failures correspond to at most @xmath193 rank erasures in the corresponding codeword of @xmath183 .",
    "since the minimum rank distance of @xmath81 is @xmath194 , these node erasures can be corrected by @xmath81 , and thus the minimum distance of @xmath195 is exactly @xmath196 .    the efficiency of the decoding of the codes obtained by construction i depends on the efficiency of the decoding of the mds codes and the gabidulin codes .",
    "in this section , we discuss the hybrid codes which for a given locality parameters minimize the repair bandwidth . these codes are based on a combination of locally repairable codes with regenerating codes .    in a nave repair process for a locally repairable code ,",
    "a newcomer contacts @xmath5 nodes in its local group and downloads all the data stored on these nodes . following the line of work of bandwidth efficient repair in dss given by  @xcite",
    ", we allow a newcomer to contact @xmath197 nodes in its local group and to download only @xmath198 symbols stored in these nodes in order to repair the failed node .",
    "the motivation behind this is to lower the repair bandwidth for a lrc .",
    "so the idea here is to apply a regenerating code in each local group .",
    "( we note that , in a parallel and independent work , kamath et al .",
    "@xcite also proposed utilizing regenerating codes in the context of lrcs . )    in particular , by applying an @xmath199 msr code in each local group instead of an mds array code in the second step of construction i we obtain a code , denoted by msr - lrc , which has the maximal minimum distance ( since an msr code is also an mds array code ) , the local minimum storage per node , and the minimized repair bandwidth .",
    "( the details of this construction can be found in  @xcite . )    in addition , the optimal scalar codes obtained by construction i can be used for construction of mbr - lrcs ( codes with an mbr code in each local group ) as it has been shown by kamath et al .",
    "we presented a novel construction for ( scalar and vector ) locally repairable codes .",
    "this construction is based on maximum rank distance codes .",
    "we derived an upper bound on minimum distance for vector lrcs and proved that our construction provides optimal codes for both scalar and vector cases .",
    "we also discussed how the codes obtained by this construction can be used to construct repair bandwidth efficient lrcs .",
    "99 [ 1]#1 url@samestyle [ 2]#2 [ 2]l@#1=l@#1#2    a.  g.  dimakis , p.  godfrey , m.  wainwright and k.  ramachandran , `` network coding for distributed storage system , '' _ ieee trans . on inform .",
    "56 , no .  9 , pp .  4539 - 4551 , sep .  2010 .",
    "y.  wu and a.  g.  dimakis ,  reducing repair traffic for erasure coding - based storage via interference alignment \" , in _ proc . of ieee isit _",
    "n.  b.  shah , k.  v.  rashmi , p.  v.",
    "kumar and k.  ramchandran ,  explicit codes minimizing repair bandwidth for distributed storage \" , in _ proc . of ieee itw _ , jan",
    ". 2010 .    c.  suh and k.  ramchandran ,",
    " exact - repair mds codes for distributed storage using interference alignment \" , in _ proc . of ieee isit _ , jul . 2010 .",
    "k.  v.  rashmi , n.  b.  shah and p.  v.  kumar ,  optimal exact - regenerating codes for distributed storage at the msr and mbr point via a product - matrix construction \" , _ ieee trans . on inform .",
    "57 , no .",
    "57 , pp .",
    "5227 - 5239 , aug .",
    "i.  tamo , z.  wang , and j.  bruck ,  zigzag codes : mds array codes with optimal rebuilding , \" _ corr _ , vol .",
    "abs/1112.0371 , dec . 2011 .",
    "a.  datta and f.  oggier ,  an overview of codes tailor - made for networked distributed data storage , \" _",
    "abs/1109.2317 , sep .",
    "a.  g.  dimakis , k.  ramchandran , y.  wu , and c.  suh ,  a survey on network codes for distributed storage , \" proceedings of the ieee , mar .",
    "p.  gopalan , c.  huang , h.  simitchi and s.  yekhanin , `` on the locality of codeword symbols , '' _ ieee trans . on inform .",
    "58 , no .  11 , pp .  6925 - 6934 , nov .  2012",
    ".    d.  s.  papailiopoulos and a.  g.  dimakis , `` locally repairable codes , '' in _ proc . of ieee isit _ , jul",
    ". 2012 .",
    "n.  prakash , g.  m.  kamath , v.  lalitha , and p.  v. kumar , `` optimal linear codes with a local - error - correction property , '' in _ proc . of ieee isit _ , jul .",
    "f.  e.  oggier and a. datta , `` homomorphic self - repairing codes for agile maintenance of distributed storage systems , '' _ corr _ , vol .",
    "abs/1107.3129 , jul .",
    "f.  e.  oggier and a. datta , `` self - repairing codes for distributed storage - a projective geometric construction , '' _ corr _ , vol .",
    "abs/1105.0379 , may 2011 .    c.  huang , h.  simitci , y.  xu , a.  ogus , b.  calder , p.  gopalan , j.  li , and s.  yekhanin,erasure coding in windows azure storage , \" _ in proc .",
    "usenix annual technical conference ( atc ) _ , apr . 2012 .",
    "m.  sathiamoorthy , m.  asteris , d.  papailiopoulos , a.  g.  dimakis , r.  vadali , s.  chen , and d.  borthakur ,  xoring elephants : novel erasure codes for big data , \" _",
    "abs/1301.3791 , jan .",
    "2013 .    c.  huang , m.  chen , and j.  li , `` pyramid code : flexible schemes to trade space for access efficiency in reliable data storage systems , '' in _ proc . of 6th ieee nca _ , mar .",
    "j.  han and l.a .",
    "lastras - montano , `` reliable memories with subline accesses , '' in _ proc . of ieee isit 2007 _ , jun .",
    "g   m.  kamath , n.  prakash , v.  lalitha , and p.  v.  kumar , `` codes with local regeneration,''_corr _ , vol .",
    "abs/1211.1932 , nov .",
    "h.  d.  l.  hollmann , `` storage codes  coding rate and repair locality,''_corr _ , vol .",
    "abs/1301.4300 , jan .",
    "e   m.  gabidulin , `` theory of codes with maximum rank distance , '' _ problems of information transmission _ , vol .",
    "21 , pp .  1 - 12 , jul .",
    "r.  m.  roth , `` maximum - rank array codes and their application to crisscross error correction , '' _ ieee trans . on inform .",
    "37 , pp .",
    "328 - 336 , mar .",
    "f. j. macwilliams and n. j. a. sloane , _ the theory of error - correcting codes _ , north - holland , 1978 .",
    "gabidulin and n.i .",
    "pilipchuk , `` error and erasure correcting algorithms for rank codes , '' _ designs , codes and cryptography _ , vol .",
    "105122 , 2008 .",
    "m.  blaum , j.  brady , j.  bruck , and j.  menon , `` evenodd : an efficient scheme for tolerating double disk failures in raid architectures , '' _ ieee trans . on computers _ ,",
    "2 , pp . 192202 , feb .",
    "m.  blaum and r.  m.  roth ,  on lowest density mds codes \" , _ ieee trans .",
    "inform . theory _",
    "45 , pp . 4659 , 1999 .",
    "y.  cassuto and j.  bruck,cyclic low - density mds array codes \" , in _ proc . of ieee isit _ , jul .",
    "n.  silberstein , a.  s.  rawat and s.  vishwanath , `` error resilience in distributed storage via rank - metric codes , '' in _ proc . of 50th allerton _",
    ", available in _ http://arxiv.org/abs/1202.0800_ , oct .",
    "a.  s.  rawat , o.  o.  koyluoglu , n.  silberstein , and s.  vishwanath , ",
    "optimal locally repairable and secure codes for distributed storage systems \" , _ corr _ , vol .",
    "abs/1210.6954 , oct .",
    "to prove that @xmath135 attains the bound  ( [ eq : upp_bound ] ) we need to show that any @xmath200 node erasures can be corrected by @xmath135 . for this purpose",
    "we will prove that any @xmath201 erasures of @xmath135 correspond to at most @xmath152 rank erasures of the underlying gabidulin code and thus can be corrected by the code @xmath77 .",
    "here , we point out the the worst case erasure pattern is when the erasures appear in the smallest possible number of groups and the number of erasures inside a local group is maximal .        1",
    ".   let @xmath211",
    ". then @xmath212 and @xmath213 .",
    "* if @xmath214 then @xmath215 and @xmath216 .",
    "in this case by  ( [ eq : bound_rewrite ] ) we have @xmath217 .",
    "hence , in the worst case we have @xmath218 groups with all the erased nodes and one additional group with @xmath118 erased nodes , which by remark  [ rm : linearized property ] corresponds to @xmath139 rank erasures in @xmath218 groups of the corresponding gabidulin codeword . since by  ( [ eq : rank_erasures ] ) , @xmath219 ,",
    "this erasures can be corrected by the gabidulin code . * if @xmath220 , @xmath221 then @xmath222 and @xmath223 .",
    "then by  ( [ eq : bound_rewrite ] ) we have @xmath224 .",
    "hence , in the worst case we have @xmath225 groups with all the erased nodes and one additional group with @xmath226 erased nodes , which by remark  [ rm : linearized property ] corresponds to @xmath227 rank erasures that can be corrected by the gabidulin code . * if @xmath228 then @xmath229 and @xmath223 .",
    "then by  ( [ eq : bound_rewrite ] ) we have @xmath230 .",
    "hence , in the worst case we have @xmath225 groups with all the erased nodes and one additional group with @xmath231 erased nodes , which corresponds to @xmath232 rank erasures that can be corrected by the gabidulin code .",
    "2 .   let @xmath233 .",
    "then , @xmath234 and @xmath235 . * if @xmath220 then @xmath222 and @xmath223 .",
    "then by  ( [ eq : bound_rewrite ] ) , we have @xmath236 .",
    "hence , in the worst case we have @xmath218 groups with all the erased nodes and one additional group with @xmath237 erased nodes ( or @xmath134 erased nodes in the smallest group , @xmath225 groups with all the erased nodes and one group with @xmath226 erased nodes ) .",
    "this by remark  [ rm : linearized property ] corresponds to @xmath238 rank erasures that can be corrected by the gabidulin code . *",
    "if @xmath228 then @xmath229 and @xmath223 .",
    "then by  ( [ eq : bound_rewrite ] ) we have @xmath239 .",
    "hence , in the worst case we have @xmath218 groups with all the erased nodes and one additional group with @xmath240 erased nodes ( or @xmath134 erased nodes in the smallest group , @xmath225 groups with all the erased nodes and one group with @xmath231 erased nodes ) .",
    "this by remark  [ rm : linearized property ] corresponds to @xmath241 rank erasures that can be corrected by the gabidulin code ."
  ],
  "abstract_text": [
    "<S> this paper presents a new explicit construction for locally repairable codes ( lrcs ) for distributed storage systems which possess all - symbols locality and maximal possible minimum distance , or equivalently , can tolerate the maximal number of node failures . </S>",
    "<S> this construction , based on maximum rank distance ( mrd ) gabidulin codes , provides new optimal vector and scalar lrcs . </S>",
    "<S> in addition , the paper also discusses mechanisms by which codes obtained using this construction can be used to construct lrcs with efficient repair of failed nodes by combination of lrc with regenerating codes . </S>"
  ]
}