{
  "article_text": [
    "distributed coverage of any polygonal region has been an important area of research over the past few years .",
    "applications of covering a free space can be found in the areas like automated humanitarian demining , lawn mowing and milling @xcite , sweeping @xcite , terrain mapping , space explorations , aerial reconnaissance , search and rescue of victims @xcite etc .",
    "coverage of a particular region requires the robots to scan or pass over a designated region .",
    "when the robots cover or pass all the parts of that region , coverage is said to be complete . high quality coverage guarantees exhaustive coverage with minimum repetition . each robot in a swarm , distributedly and simultaneously covering different parts of the area also minimizes time and cost of the work while increasing overall performance .",
    "+ in this paper , one of such coverage problems is addressed .",
    "we consider a problem for painting a known rectangular region without any obstacle .",
    "the overall painting will be performed by a swarm of autonomous mobile robots .",
    "we assume that a set of @xmath0 swarm robots are initially deployed within the given rectangular region .",
    "the robots can be located at any place within that region .",
    "these robots are assigned the responsibility to paint the whole region . here , the proposed algorithm will be executed by each of the robots , to solve this problem collectively .",
    "we assume that the robots will work in a completely distributed environment .",
    "painting a region is same as covering or scanning the region . from now on ,",
    "the two words _ coverage _ and _ painting _ will be used interchangeably .",
    "+ in this paper , the robots follow a basic model for computation which is known as _ wait_-_observe_-_compute_-_move _ model @xcite or corda model @xcite .",
    "the algorithms based on this basic _ wait_-_observe_-_compute_-_move _ model consists of a sequence of computational cycles . in every computational cycle ,",
    "a robot executes the following four steps : + * wait * : a robot is initially in a waiting or idle state , but can not stay infinitely idle .",
    "+ * observe * : at any point of time a robot observes the positions of all other robots , asynchronously and independently from the other robots .",
    "+ * compute * : depending on the observations made in the previous step , the robot calculates its destination point based on its own position and the current locations of the other robots , etc . + * move * : the robot moves towards the computed destination .",
    "+ the robots also use the _ direction - only _ model in which directions of both axes are common to all the robots , but the positive orientation of the axes are different .",
    "the robots follow _ asynchronous _ model in which they do not share any common clock and operate on independent computational computational cycles of variable length .",
    "the robots virtually divides the whole rectangular region into a number of non - overlapping cells ( sub - region ) .",
    "then each cell is assigned to a distinct robot which will be responsible for painting that particular cell .",
    "when each of the robots completes painting the cell assigned to it , the whole area will be painted or covered . using the player / stage robotic simulator",
    "we have designed a controller program that simulates the proposed algorithm .",
    "each robot will execute the controller program repeatedly until all the robots completes their assigned job .",
    "+ most of the previous works consider the presence of obstacles within the area to be covered .",
    "although , all these algorithms are also applicable for the areas without obstacle , using these algorithms for a region without obstacle makes the solution unnecessarily complicated .",
    "our proposed algorithm shows that the coverage problem without any obstacle can be solved in a more realistic way using robots of simple nature .",
    "we assume that there is neither any central authority nor any external control over the robots .",
    "moreover , during execution of the proposed algorithm robots do not need to communicate among themselves .",
    "each robot assumes a local co - ordinate system and all the computations carried out by the robots are according to their respective local co - ordinate system .",
    "further , to provide a more realistic solution to the painting problem , we assume that a robot can be in two different states , _ active _ state and _ sleep _ state .",
    "however , from a sleep state a robot becomes active within a finite amount of time .",
    "+ in section  [ liturature ] , we discuss the related research work done in this area . section  [ modelassump ] introduces the problem definitions , models and assumptions for the solution of the problem .",
    "section  [ covalgo ] is having two subsections . in the first sub - section",
    ", the painting algorithm is discussed and in the second sub - section the correctness of the algorithm is established .",
    "the simulation of the proposed algorithm is discussed in section  [ simulation ] and we conclude our study in section  [ conclusion ] .",
    "over last few years a large amount of research work has been reported on multi - robot coverage problem @xcite , @xcite , @xcite , @xcite , @xcite , @xcite , @xcite , @xcite .",
    "different approaches are followed to cover a given region with or without obstacles within it .",
    "most of the related works consider the boustrophedon decomposition @xcite approach , which divides the target space into sub - regions called cells where each cell can be covered by the robots with simple back - and - forth motions .",
    "different approaches are followed to define these cells .",
    "for example , canny et al . , @xcite defined the cells by sweeping a slice ( a one dimensional line ) through the configuration space .",
    "+ latimer et al .",
    ", @xcite introduced a multi - robot coverage algorithm based on the same planer cell - based approach for a single robot .",
    "robots move in a team , they communicate their state and share information . the robots in a team move by maintaining an horizontal formation , like a rake .",
    "the central issue of this paper is when to divide and merge teams so that all the cells in the region are covered .",
    "this is solved by critical point detection method . whenever the team detects any obstacle in the slice , it is unable to continue as one unit .",
    "thus , a critical point is detected at that point and the cell is divided into sub - cells .",
    "depending on the types of critical points , the team is also divided into sub - teams to cover the sub - cells .",
    "after covering the sub - cells adjacent to the obstacle the sub - teams rejoins . in a team",
    "based approach communication , coordination and synchronization are required among the team members , which make the robot more complex . however , in this approach repeated coverage may occur @xcite .",
    "+ rekletis et al . , @xcite , @xcite , used same planar cell - based decomposition and also provided extensions to handle how teams of robots cover a single cell and how are they re - allocated among different cells . considering _ communication _ among robots as a key issue ,",
    "two algorithms were proposed .",
    "( i ) _ team - based coverage _ for restricted communication and ( ii ) _ distributed coverage _ for unrestricted communication . in @xcite , the communication among the robots",
    "is restricted to their line - of - sight . in this paper , the robots in a team are categorized as explorers and coverers .",
    "the basic idea is that , when two explorers ( while moving along upper and lower boundaries of the region ) loose their line - of - sight due to the presence of an obstacle determines the position of the critical point . at this point two sub - cells , adjacent to the obstacle , are generated which are then covered by the two sub - teams . once again",
    "two robots in each of these sub - teams will be categorized as explorers",
    ". such form of coverage requires the coverers to move in team formations , which may be accomplished in a variety of ways @xcite .",
    "the coverers may cover some region previously covered by the explorers resulting repeated coverage .",
    "moreover , maintaining the line - of - sight communication among the explorers or coverers introduces considerable amount of complexity .",
    "+ in unrestricted communication , the area to be covered is divided into a number of virtual strips equal to the number of robots .",
    "the robots are deployed at regular intervals along one side of the region to be covered and they start exploration of strip boundaries using the cycle algorithm developed in single - robot morse decomposition @xcite .",
    "same cycle algorithm is used for coverage also . during exploration",
    ", the robot gathers the knowledge of critical points and steiner points ( points that represent strip boundaries ) . depending on that",
    ", the robot builds a _ global reeb graph _ , which is shared and updated by all the robots .",
    "after completion of exploration , robots immediately start coverage of known strips and update the _ reeb graph _ accordingly . if a robot is unable to reach any space within its strip , it re - allocates the unreachable part to other robots by calling an auction mechanism .",
    "it selects the robot which can explore the unreachable part at a lower estimated cost .",
    "this algorithm is efficient but complex .",
    "moreover , the deployment mechanism of the robots is not realistic .",
    "+ kong et al . , @xcite uses the boustrophedon decomposition approach .",
    "the robots are initially distributed inside a region and each one is allocated a virtually bounded cell of that region .",
    "the region is divided into several fixed width cells .",
    "the robots determine whether the cell being covered is divided into disconnected parts due to the obstacles .",
    "each robot uses an _",
    "adjacency graph _ that represents its current cell and the adjacent cells to be covered .",
    "the graph also represents the disconnected parts of a cell due to the presence of any obstacle . during execution of the algorithm ,",
    "new cells are added to the _ adjacency graph_. when a robot completes covering a cell , it shares the new graph information among all the robots .",
    "a robot can communicate graph information to all other robots without any restriction . upon receiving the graph information other robots update their own graph .",
    "a robot then selects the next uncovered cell in its _",
    "adjacency graph_. the algorithm is good for coverage but maintaining and sharing information of all covered / uncovered cells among all the robots requires large amount of memory , making the robots no more oblivious .",
    "+ most of the previous works consider the presence of obstacles within the area to be covered .",
    "none of the above mentioned algorithms is based on corda model @xcite .",
    "all the robots are assumed to be _ synchronous _ and _ active _ throughout the process .",
    "the robots agree on the direction and orientation of the axes .",
    "deployment of robots within the region is also not random .",
    "communication among robots is absolutely necessary in all these approaches .",
    "repeated coverage are likely to occur due to loss of the communication among the robots . in the team",
    "based approaches , communication , coordination and synchronization among the team members involves great complexity . in @xcite , @xcite , maintaining the graphs requires large amount of memory and some times a centralized control on robots is also required . +",
    "our proposed algorithm shows that the coverage problem without any obstacle can be solved in a more realistic way using simple robots instead of the complicated one .",
    "the robots actually work in a totally distributed way , independently from other robots .",
    "they are distributed randomly within the region to be covered .",
    "the robots do not communicate among themselves .",
    "each robot does all the computations based on the information gathered with respect to its local co - ordinate system .",
    "we assume that the local co - ordinate systems agree on the direction but orientation .",
    "we also consider the corda model , a standard computational model for distributed robot system .",
    "our algorithm is based on _ asynchronous _ model , where robots may not be active always and operates on independent computational cycles of variable lengths .",
    "we assume that a robot can be in two different states , _ active _ state and _ sleep _ state .",
    "however , from a sleep state a robot becomes active within a finite amount of time .",
    "this guarantees the finite time completion of the painting task .",
    "before going to describe the algorithm , let us discuss the assumptions and the models used .",
    "we also introduce the terminologies used in this paper . + our problem is to paint a given rectangular region by a swarm of @xmath0 robots .",
    "these robots are initially deployed randomly within the rectangular region , which is to be painted .",
    "robots may occupy any position within the region .",
    "we assume that no two robots occupy the same position .",
    "the robots we consider here are relatively weak , simple and assumed to have the following characteristics",
    "@xcite :    1 .   _",
    "identical and homogeneous _ - all the robots are identical in all respect , specially , they have the same computational capability .",
    "all the robots are assumed to be point robots with unlimited visibility .",
    "however , we assume that each of them is having a sensing zone of radius @xmath1 ( @xmath1 is small ) . that is , if a robot is required to carry out some job related to a particular position ( collection of information about that position , or painting that position etc . ) , instead of actually reaching the position , the robot can also carry out the job from a distance of @xmath1 away from it . in case of painting , as if , each of the robot is carrying a paint brush of length @xmath1 .",
    "so , while painting , if a robot moves in a straight line , a rectangular strip of width @xmath2 about that line will be painted as shown in the fig .",
    "[ fig:0 ] .",
    "autonomous _ - there is neither any central authority nor any external control over the robots .",
    "thus the robots work in completely distributed manner , asynchronously and independently from other robots .",
    "they do not even communicate among themselves .",
    "+    3 .   _",
    "mobile _ - all robots are allowed to move on a plane .",
    "_ computation model _ - here we follow the basic _ observe_-_compute_-_move _ @xcite model . a computational _ cycle _",
    "is defined to be a sequence of _ observe _ , _ compute _ and _ move _ steps .",
    "each of the robots executes same instructions in all the computational cycles .",
    "once a robot completes one computational cycle , it starts executing the next one .",
    "the actions taken by a robot in _ compute _ and _ move _ steps , entirely depend on the observations made in _ observe _ step . in some situations ,",
    "an observation might lead a robot not to change its position in _ move _ step . in such cases",
    "the robot seems to be idle , though it is actually executing all the three steps .",
    "_ oblivious _ or _ memoryless _ - robots do not retain any information gathered in the previous computational cycle . in every computational cycle ,",
    "a robot starts computing from very beginning depending only on the positions of the other robots observed at that computational cycle .",
    "the robots can have two states : _ active _ and _ sleep_. in _ active _ state , the robots are alive and executing continuously the computational cycles . in _",
    "sleep _ state , robot is not active and doing nothing .",
    "this state is like _ power off _ state .",
    "it is assumed that a robot can not _ sleep _ infinitely and it would become active within a finite amount of time .",
    "we also assume that change of state of a robot takes place independent of the other robots .",
    "+ the _ painting _ operation considered here is assumed to be an _",
    "atomic _ operation .",
    "once a robot starts painting the assigned cell , it completes its job without any further interruption . during painting , a robot can not switch over to the _ sleep _ state also .",
    "+ the models considered here are as follows :    * asynchronous model : * robots operate on independent cycles of variable lengths",
    ". they do not share any common clock @xcite .",
    "+     and @xmath3 are just the reverse of that of the robots @xmath4 and @xmath5,title=\"fig:\",width=302,height=132 ] +    * direction only : * directions of both axes are common to all the robots , but the positive orientation of the axes may be different @xcite . here , we assume that x - axes of the robots are parallel to the known common reference line .",
    "therefore , the direction of x - axis is common to all the robots but the robots may have different views of the positive orientation of the axis . however , it is assumed that the direction of the positive y - axis is @xmath6 counterclockwise to the positive direction of the x - axis .",
    "thus , direction of y - axis is also common to all the robots , except possibly the positive orientation .",
    "each robot has its local co - ordinate system .",
    "all the robots would assume that they occupy the position @xmath7 with respect to their local co - ordinate system .",
    "further , we assume that these various co - ordinate systems might not share a common scale .",
    "[ fig:1 ] shows the local co - ordinate systems of four robots @xmath8 , @xmath4 , @xmath3 , and @xmath5 , and the common reference line @xmath9 .",
    "the first part of this section describes the proposed algorithm .",
    "the correctness of the algorithm is established in the second part .",
    "it is assumed that the region to be painted is a rectangular region and no obstacles are there within the region .",
    "further , we assume that all the @xmath0 robots are enclosed within the region . without loss of generality",
    ", we assume that the common reference line be parallel to one side of the rectangular region . + the algorithm completes the painting job in two phases . in",
    "phase i _ , a robot calculates the strip to be painted by it and moves to the starting position where from it can start painting . in this phase , as soon as a robot @xmath10 becomes alive it performs the following computational cycle _ observe - compute - move_. after completing one such computational cycle , the robot @xmath10 would again start another cycle and continue in this way until it reaches to the starting position for painting or it goes to _ sleep _ state again .",
    "after completion of _ phase - i _ , a robot starts _ phase - ii _ in which it actually paints the assigned strip . + * algorithm _ paint _ * + the following steps are executed by the robot @xmath10 .",
    "+    * phase - i : * + observe + compute + move + ( the robot @xmath10 is alive and the robot has not yet reached the starting position for painting ) + * phase - ii : * the robot paints its assigned strip .",
    "+    * phase - i : * in this phase the robot calculates its strip and moves to the starting position for painting .",
    "let us discuss the steps in details : + * observe * + according to the local co - ordinate system , the robot @xmath10 first observes the positions of all other robots .",
    "let the co - ordinates of other robots be @xmath11 , @xmath12 , @xmath13 , @xmath14 , whereas , its own co - ordinate be @xmath15 .",
    "it is to be noted here that some of these @xmath16 , @xmath17 values might be negative also .",
    "+ * compute * + : + according to the values of @xmath18-co - ordinates , the robot @xmath10 orders all the robots ( including itself ) so that the robot having the largest value of @xmath18 co - ordinate will have the highest rank , that is , @xmath0 . without loss of generality , let us assume that after sorting the co - ordinates of @xmath0 robots be @xmath19 , @xmath20 , @xmath13 , @xmath21 , so that @xmath22 @xmath23 @xmath24 @xmath23 @xmath25 @xmath23 @xmath13 @xmath23 @xmath26 .",
    "the robot having the co - ordinate @xmath27 have the rank @xmath28 and from now on the robot will be mentioned as @xmath29 , @xmath30 . in case of a tie ,",
    "the values of @xmath31 -co - ordinate of the robots are to be considered .",
    "the robot having lower @xmath31-co - ordinate would have the lower rank . as we have assumed that no two robots can occupy the same position , two robots having the same @xmath18-co - ordinate can not have identical @xmath31-co - ordinate .",
    "+ in this way , the robot @xmath10 would determine its own rank .",
    "let the rank of @xmath10 be @xmath32 .",
    "from now on @xmath10 and @xmath33 will be used interchangeably .",
    "+   + according to the local co - ordinate system of @xmath10 , let the upper boundary of the region to be painted be at a vertical distance @xmath34 and the lower boundary be at @xmath35 . since all the robots are enclosed within the area , @xmath36 and @xmath37 .",
    "the whole rectangular area will be divided into @xmath0 equal horizontal strips of height @xmath38 .",
    "the top most ( according to the local co - ordinate system of @xmath10 ) strip will be considered as the @xmath39 strip and the bottom most one will be considered as the first strip . now the robot @xmath33 will identify the @xmath40 strip by computing its upper and lower boundary as @xmath41 and @xmath42 .",
    "the @xmath40 strip will be colored by @xmath33 .",
    "each robot would start the coloring from the bottom left corner of the assigned strip .",
    "accordingly the robot would compute its destination .",
    "+ on the way towards their destination , robots maintain their relative ranking .",
    "it means , while moving , robots should not cross vertically any other robot even if their routes do not intersect each other . in other words , to reach the destination , if a robot is going to gain a vertical height higher(lower ) than a robot of higher(lower ) rank ( that is , it is crossing another robot which would affect the relative ranking ) , it would stop at an @xmath43 ( pre - defined small quantity ) distance from that height and would wait for that other robot to move on .",
    "+     w.r.t robot r , where @xmath44 is the actual destination , width=264,height=113 ]    due to the rule stated above , the robot @xmath10 may need to take a halt before reaching its final destination , the bottom - left corner of the assigned strip . in this _ compute _ step , the robot @xmath10 should verify this situation and if required , it would recalculate the position of the halt .",
    "we call this as the _ secondary _ destination .",
    "suppose , to reach the final destination @xmath44 , @xmath10 has to vertically cross another robot @xmath45 which is at a point ( @xmath46 , @xmath22 ) as shown in fig .",
    "[ fig : com ] . according to the given rule",
    ", @xmath10 would stop at a vertical height of @xmath47 .",
    "therefore , the modified destination of @xmath10 would be ( @xmath48 , @xmath49 ) .",
    "[ fig : com ] shows two possible cases . in fig .",
    "[ fig : com](a ) , to reach the destination @xmath44 , the robot @xmath10 has to move in the vertically downward direction and then it requires to cross @xmath45 .",
    "therefore , its secondary destination would be ( @xmath48 , @xmath50 ) . in fig .",
    "[ fig : com](b ) , to reach the destination @xmath44 , the robot @xmath10 has to move in the vertically upward direction and then it requires to cross @xmath45 .",
    "therefore , its secondary destination would be ( @xmath48 , @xmath51 ) .",
    "+ this _ compute _ step is terminated as soon as the robot computes its destination , final or secondary . + * move * + after identifying the assigned strip , the robot would start moving towards its destination point , the bottom left corner point of the assigned strip . actually the robots do not need to reach the exact height of its destination due to its sensing ability .",
    "it is sufficient to reach a height , which is at a distance @xmath1 ( above / below ) away from the final destination ( as discussed in section [ modelassump ] ) .",
    "+ it is to be noted here that , though the final destination of a robot is the bottom left corner point of the assigned strip , sometimes , to preserve the relative ranking , robots may need to wait at certain height for some other robot to move on .",
    "+ a robot would always move in vertical direction first , after acquiring the vertical height of the final destination , the robot would then move along horizontal direction to reach the final destination . thus , to reach the secondary destination , a robot moves only in vertical direction .",
    "+ depending on whether a robot reaches its final or secondary destination , the following two courses of actions would be taken by the robot : + ( i ) as soon as a robot reaches the secondary destination , this _ move _ state terminates .",
    "that is , the current computational cycle will be terminated and the robot will again start a new computational cycle with _ observe _ state .",
    "+ ( ii ) once the robot reaches its final destination before starting the painting in _ phase - ii _ , it would check whether there is any other robot present in its assigned strip or not .",
    "there may be two possible cases : + _ case i : the robot finds another robot in its own strip _",
    "+ if the robot @xmath10 finds another robot , say @xmath45 , present in its assigned strip , it would wait for that other robot to move on .",
    "it will keep on executing the sequence of _ observe - compute - move _ steps until the strip become empty .",
    "in this situation , there will not be any movement of the robot as it has already reached its _ final _ destination .",
    "+ _ case ii : the strip is empty _",
    "+ if there is no other robot in the strip and the strip is empty , the robot would go to _ phase - ii _ for painting .",
    "+ at any point of time , if the robot @xmath10 finds another robot @xmath45 at the same vertical height ( which might occur at the starting time , if initially they are at the same height ) , then depending on the rank of @xmath45 and that of itself , @xmath10 decides its next course of action as follows : + * case a :* the rank of @xmath10 is greater than that of @xmath45 and the destination of @xmath10 is in the positive direction , w.r.t .",
    "its local co - ordinate system .",
    "+   + * case b :* the rank of @xmath10 is less than that of @xmath45 and the destination of @xmath10 is in the negative direction , w.r.t .",
    "its local co - ordinate system .",
    "+ for both the cases a and b , @xmath10 would break the tie and would move first towards its destination point . + * case c :* the rank of @xmath10 is greater than that of @xmath45 and the destination of @xmath10 is in the negative direction , w.r.t .",
    "its local co - ordinate system . + * case d :* the rank of @xmath10 is less than that of @xmath45 and the destination of @xmath10 is in the positive direction , w.r.t .",
    "its local co - ordinate system .",
    "+ for both the cases c and d , @xmath10 will wait for @xmath45 to move first towards its destination point .",
    "+ * phase - ii : * in this phase the robot start painting the assigned area . as painting is considered as an _ atomic _ operation , the robot would complete the job successfully without any interruption and at the end , it would generate a signal that its job is done .",
    "* observation 1 : * _ throughout the process , relative ranking of the robots computed by several robots are same upto a reversal of order . in other words",
    ", if the robots @xmath8 and @xmath4 compute the rank of a robot @xmath10 as @xmath28 and @xmath52 respectively , then either @xmath53 or @xmath54 and this would remain same throughout the algorithm . _",
    "+         + _ proof _ : if the orientations of the local axes of @xmath8 and @xmath4 are identical then the ranking of the robots would be same .",
    "otherwise , if the orientations are reverse , then the relative ordering would be same but in reverse order .",
    "thus @xmath55 .",
    "[ fig:2 ] shows that the relative ranking of the robots with respect to two different robots having opposite orientation of their axes , are just the reverse . in this figure ,",
    "an example of five robots are shown . here , robots a and e are having opposite orientations of their axes",
    ". positions of all the robots and the relative ranking of all the robots with respect to robots a and e are shown in the figure . +",
    "a robot computes the ranks of all other robots w.r.t .",
    "their vertical distances from its local @xmath31-axis .",
    "so the relative ranking of the robots would remain same throughout the algorithm as the vertical movement of the robots is so restricted that none of the robots would vertically cross any other robot .",
    "if two robots are starting from the same vertical height , their relative ranking will be determined by their @xmath31-coordinates . in case of such a tie ,",
    "the robots start moving towards their destination following the rule given in _",
    "_ step , which retains their relative ranking .",
    "once a robot starts moving , this tie will be broken and this situation will never occur again .",
    "+ * observation 2 : * _ the assignments of cells ( for painting ) to the robots as computed by different robots are same and it would remain same throughout the whole process . _ + _ proof _ : it is obvious when the orientations of the local axes of the robots are same .",
    "let @xmath8 and @xmath4 be two robots whose axes are oriented just in opposite direction .",
    "let @xmath8 computes the rank of a robot @xmath10 as @xmath32 and assigns the @xmath40 cell to @xmath10 .",
    "now , @xmath4 would compute the rank of @xmath10 as @xmath56 and it would assign the same cell to @xmath10 which according to local co - ordinate system of @xmath4 is considered to be @xmath56 . the position of the cells are fixed and the relative ranking of the robots remain same throughout the algorithm .",
    "hence , assignment of strips to the robots remains invariant with respect to any computational cycle .",
    "+ * observation 3 : * _ the movements of robots are collision free . _ + _ proof _ : throughout the algorithm , two robots can never be at the same vertical height at the same time , except possibly , at the starting time . if initially the robots are at the same height , the tie will be broken by the rules given in _ move _ step .",
    "once the tie is broken , they will never be at the same height again , during their vertical movement .",
    "+        after computing the destination , each robot would first move vertically to reach the height of the final destination .",
    "once they reach that height , they start moving horizontally .",
    "thus , if the destinations of two robots are at different heights , the question of collision during their horizontal movements does not arise at all .",
    "+        there is one special case where the final destinations may have same vertical heights for two different robots . as shown in fig .",
    "[ fig:12 ] , two robots @xmath8 and @xmath4 are assigned to paint two consecutive strips , @xmath57 and @xmath58 respectively .",
    "let us assume @xmath8 and @xmath4 have opposite orientation of their local axes as shown in the figure .",
    "the bottom - left corner point of the strip @xmath57 , w.r.t .",
    "@xmath8 is the point @xmath44 .",
    "whereas , the bottom left corner point of the strip @xmath58 is at @xmath59 according to @xmath4 .",
    "this shows that the final destination of both the robots @xmath8 and @xmath4 are at the same vertical height .",
    "therefore , their horizontal movement will be along the same line @xmath60 , which may cause collision .",
    "however , due to their sensing ability ( as discussed in section [ modelassump ] ) , @xmath8 would start its job from the point @xmath61 and @xmath4 from @xmath62 , which are at a @xmath1 distance away from the line @xmath60 .",
    "thus , here also , the two robots will not move along the same horizontal line to reach their destination for starting the job .",
    "+ there will not be any collision in _ phase - ii _ also . before starting the actual painting in _ phase - ii _",
    ", a robot verify whether the strip is empty or not .",
    "if it finds another robot in that strip it will wait till it becomes empty .",
    "once the strip becomes empty there is no possibility of any other robot to enter the strip again .",
    "this is due to the fact that none of the robots vertically cross any other robot . + * observation 4 : * _ the four rules stated in the _ move _ step lead to take the robots a non - conflicting decision regarding tie - breaking . _",
    "+ if at the initial situation , two robots are at the same height ( but definitely in two different positions ) , the robot having the higher rank would start moving first , if their destinations are in the positive direction . if their destinations are in the negative direction , then the robot having the lower rank would start moving first .",
    "if their destinations are in opposite direction , then there would nt be any restriction in vertical movement .",
    "+ consider fig .",
    "[ fig:4 ] where both @xmath8 and @xmath4 having same orientation . @xmath63 and @xmath64 are the destinations of robots @xmath8 and @xmath4 respectively .",
    "according to both the robots the rank of @xmath8 is less than the rank of robot @xmath4 . in fig .",
    "[ fig:4](a ) both of their destinations are in the positive direction then as per rule , the higher ranked robot @xmath4 will move first . in fig .",
    "[ fig:4](b ) both of their destinations are in the negative direction . as per rule",
    ", the lower ranked robot @xmath8 will move first .",
    "+         + consider fig .",
    "[ fig:5 ] where both @xmath8 and @xmath4 having opposite orientation . according to the local coordinate system of @xmath8 and @xmath4 ,",
    "both will rank itself as lower . due to",
    "opposite orientation ,",
    "if the destinations are in positive direction according to @xmath8 then it is in negative direction according to @xmath4 and vise versa . in fig .",
    "[ fig:5](a ) , both the destinations are in positive direction w.r.t @xmath8 .",
    "so , according to @xmath8 , the higher ranked robot @xmath4 will move first .",
    "but according to @xmath4 the destinations are in negative direction , so as per rule the lower ranked robot @xmath4 will move first .",
    "this shows that the same decision will be taken by @xmath8 and @xmath4 . +        similarly , in fig .",
    "[ fig:5](b ) , both the destinations are in negative direction w.r.t @xmath8 .",
    "so , according to @xmath8 , the lower ranked robot @xmath8 will move first . but now according to @xmath4 the destinations are in positive direction , so as per rule higher ranked robot will move first which is @xmath8 according to the local coordinate system of @xmath4 .",
    "so , in both the cases same robot will move , and the tie will be broken without any conflict . + * observation 5 : * _ the process would start within finite amount of time . _",
    "+ _ proof _ : according to our assumption , a robot can not be in _ sleep _ state for an infinite amount of time . once they become _ alive _ , they start moving provided their movement would not affect the relative ranking . only in case of a tie , i.e. , if initially the robots are at the same height , there will be an inter - dependency among these robots . if a particular robot does not move first all other have to wait for it and so on .",
    "the robot having the highest rank and the lowest rank usually does not have any restriction on their movement and thus as soon as they become live the process would start .",
    "we can think of an extreme situation when all the robots are at the same height .",
    "we can subdivide this situation into following two cases : + * case-1 : * all the robots are at a same height and they are along a boundary of the region . in this case , if a robot identify itself ( according to its local co - ordinate system ) ( 1 ) at the lower boundary of the region and having the highest rank , or ( 2 ) at the upper boundary of the region and having the lowest rank , then the robot will not have any restriction on its movement and it would break the initial barrier .",
    "we call these robots as _ tie - breaking _ robots .",
    "if the robots are on the upper boundary , the left - most one and if they are on the lower boundary , the right - most one will be the _ tie - breaking _ robot . +",
    "* case-2 : * all the robots are at a same height from the common reference line but they are not along any boundary of the region . here , both",
    "the robots having lowest rank and highest rank will not have any restriction on their movement and they would break the initial barrier . fig .",
    "[ fig:6 ] shows both the cases where the tie - breaking robots either having highest or lowest rank . +",
    "once a robot break the initial barrier , all other robots start moving in turn .",
    "thus , within finite amount of time the process would start . +",
    "* result * _ the painting will be completed within a finite amount of time_. + _ proof _ : combining all the above observations , and the fact that a robot can not be in sleep state for an infinite amount of time and the painting operation is an atomic operation , we can conclude that painting will be completed successfully within finite amount of time .",
    "the simulation has been conducted based on variety of co - ordinates and orientations of the robots using the player / stage multi - robot simulation software .",
    "the player ( version 3.2.2 ) and stage ( version 3.0.2 ) softwares have been configured on ubuntu 10.04 ( lucid lynx ) platform with support of intel core2duo processor with @xmath65 ghz speed and 2.00 gb ram . +",
    "some robots are deployed randomly inside a priori known bounded rectangular region .",
    "the initial location of these robots are generated randomly with respect to the global co - ordinate system keeping in mind that all of them should be located inside the rectangular region . during the execution of the algorithm ,",
    "a robot acts with respect to its own local co - ordinate system .",
    "the dimension of the rectangular area is fixed and known . moreover ,",
    "the orientation of the robots are also randomly selected .",
    "the orientation of any robot may be either positive or negative ( w.r.t . the global co - ordinate system ) and is represented by @xmath66 or @xmath0 accordingly . in the tables given below , a robot is represented as ( @xmath67 , @xmath68 , @xmath69 ) , where @xmath70 is its coordinate and @xmath69 is its orientation . in the simulation , all robots",
    "are assumed to start execution of the algorithm at the same time .",
    "+        at first , a robot detects the boundary walls and all other robots within the area .",
    "it calculates its rank based on the positions of the other robots .",
    "next , the robot calculates its assigned cell to be painted and the corresponding starting location .",
    "finally it moves to that starting location , where it can start painting .",
    "[ fig:16 ] shows the robots ( initial positions of these robots are shown in fig .",
    "[ fig:3 ] ) at their final locations from where they start painting . the actual painting operation is not simulated as it is implied that once a robot reaches its final destination , it would be able to complete the painting within finite amount of time by following simple back and forth motion .",
    "+ the total time of completion of the whole job is calculated as the sum of the time taken by the last robot to reach its final destination and the actual painting time required by the robots to paint the respective strips .",
    "thus , @xmath71 = @xmath72 + @xmath73 , where @xmath72 represents the time taken to complete _ phase - i _ and @xmath73 is that of _ phase - ii_. @xmath73 can be estimated as @xmath74 , where @xmath75 and @xmath76 are the length and breadth of the rectangular area respectively , @xmath0 is the total number of robots and @xmath77 represents the velocity of the robots",
    ". +          the robots used in this simulation are all green in color and having @xmath78 dimension .",
    "the robots are equipped with the following devices :    * infrared laser sensors : attached at the left and right side of the robot with sensing range upto @xmath79 units , @xmath80 scan lines and @xmath81 field of view and @xmath80 samples . *",
    "the blobfinders : attached at the left and right side of the robot and capable to recognize two colors red and green and image of size 160 x 120 square unit .",
    "it is having a sensing range of 40 unit and @xmath81 field of view .",
    "the world or environment of the simulation is considered as rectangular in shape with length as @xmath82 units and breadth as @xmath79 units .",
    "the whole rectangular area is bounded by a red colored boundary with the width of @xmath83 unit .",
    "+ each robot executes a controller program which implements the proposed algorithm .",
    "the controller program is written in c++ programming language .",
    "it uses the @xmath84 library to communicate with the stage .",
    "the controller program sequentially performs the _ observe - compute - move _ steps . in the controller program ,",
    "each of the robot is programmed as a thread .",
    "each thread independently and individually executes the controller program .",
    "we have performed different tests by varying the ( i ) total number of robots , ( ii ) initial positions of the robots and ( iii ) orientations of the robots . in all the tests ,",
    "the controller program was successfully completed within a finite amount of time .",
    "all the robots successfully reached their final destinations without any collision .",
    "[ table:1 ]    [ cols=\"^,^,^,^,^ \" , ]     [ table:3 ]",
    "this paper presents a completely distributed _ painting _ algorithm to paint a priori known rectangular area by @xmath0 no of simple , identical , autonomous , memoryless , mobile robots , each having their own co - ordinate systems .",
    "the robots are deployed randomly inside the rectangular area .",
    "this algorithm is based on standard corda model and _ asynchronous _ timing model .",
    "there is neither any central authority nor any external control over the robots .",
    "there is no communication among the robots .",
    "the algorithm guarantees complete coverage of the region without any repeated coverage and collision .",
    "+ the same algorithm can be used to paint any other polygonal region , provided the region is convex . in that case , all the cells may have the same height but their area will be different .",
    "there are several scope of future research directions for this problem .",
    "some are as follows : +    * * environment : * the area is free of obstacles .",
    "the size and shape of the area may vary .",
    "they may be convex or concave .",
    "the area may or may not contain obstacles . moreover , the shape and size of the obstacles may vary . * * visibility : * the robots could have limited range of visibility .",
    "they can view upto a certain distance . *",
    "* model : * we have considered _ direction - only _ and _ asynchronous _ models .",
    "other models related to direction , orientation and timing may be used to solve similar problems .",
    "daniel p. stormont .",
    "autonomous rescue robot swarms for first responders , _ in the proceedings of the ieee international conference on computational intelligence for homeland security and personal safety _ , pages 151 - 157 , 2005 .",
    "paola flochinni , giuseppe prencipe , nicola santoro and peter widmayer .",
    "distributed coordination of a set of autonomous mobile robots , _ in the proceedings of the ieee intelligent vehicles symp _ , pages 480 - 485 , 2000 .",
    "ioannis rekletis , vincent lee - shue , new ai peng and howie choset .",
    "limited communication , multi - robot team based coverage , _ in the proceedings of the ieee international conference on robotics & automation _ , pages 3462 - 3468 , 2004 .",
    "daisuke kurabayashi , jun ota , tamio arai and eiichi yoshida .",
    "an algorithm of dividing a work area to multiple mobile robots , _ in the proceedings of the ieee / rsj international conference on intelligent robots & systems _ , pages 286 - 291 , 1995 .",
    "agusti solanas and miguel angel garcia .",
    "coordinated multi - robot exploration through unsupervised clustering of unknown space , _ in the proceedings of the ieee / rsj international conference on intelligent robots & systems _ , pages 717 - 721 , 2004 .",
    "sumiaki ichikawa and fumio hara .",
    "characteristics of object - searching and object - fetching behaviors of multi - robot system using local communication , _ in the proceedings of the ieee international conference on systems , man , & cybernetics _ , pages 775 - 781 , 1999 .",
    "dewitt latimer iv , siddhartha srinivasa , , vincent lee - shue , samuel sonne , howie choset and aaron hurst . toward sensor based coverage with robot teams , _ in the proceedings of the ieee international conference on robotics & automation _",
    ", pages 961 - 967 , 2002 .",
    "chan sze kong , new ai peng and ioannis rekletis .",
    "distributed coverage with multi - robot system , _ in the proceedings of the ieee international conference on robotics & automation _ ,",
    "pages 2423 - 2429 , 2006 .",
    "university , kolkata in 2006 .",
    "she is pursuing her ph .",
    "d. at the department of information technology , national institute of technology , durgapur .",
    "currently , she is an assistant professor of department of information technology , national institute of technology , durgapur , west bengal .",
    "her research interests include swarm robotics , distributed algorithms etc . +      her ph.d . in computer science from indian statistical institute , kolkata , in 1997 . in 1998 , she visited university of florida as a post doctoral fellow . during 1999 to 2005 she was attached with indian statistical institute first as a research associate and then as the principal investigator of a project under the women scientists scheme of the department of science and technology , government of india . currently , she is an associate professor at birla institute of technology , mesra , kolkata campus .",
    "her current research interests include swarm intelligence , graph and combinatorial algorithms , parallel and distributed computing , sensor networks , etc ."
  ],
  "abstract_text": [
    "<S> this paper presents a distributed painting algorithm for painting a priori known rectangular region by swarm of autonomous mobile robots . </S>",
    "<S> we assume that the region is obstacle free and of rectangular in shape . </S>",
    "<S> the basic approach is to divide the region into some cells , and to let each robot to paint one of these cells . </S>",
    "<S> assignment of different cells to the robots is done by ranking the robots according to their relative positions . in this algorithm , </S>",
    "<S> the robots follow the basic _ wait_-_observe_-_compute_-_move _ model together with the _ asynchronous _ timing model . </S>",
    "<S> this paper also presents a simulation of the proposed algorithm . </S>",
    "<S> the simulation is performed using the player / stage robotic simulator on ubuntu 10.04 ( lucid lynx ) platform .    </S>",
    "<S> * keywords :* distributed coverage , painting , robot swarm , unlimited visibility . </S>"
  ]
}