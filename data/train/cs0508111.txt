{
  "article_text": [
    "[ sec : motivation ]    the relationship between abstract interpretation  @xcite and partial evaluation  @xcite has received considerable attention ( see for example @xcite and their references ) . in order to motivate and illustrate our proposal for an integration of abstract interpretation and partial evaluation , we use the running example of fig .  [ lst : running - ex ] .",
    "it is a simple ciao program which uses peano s arithmetic .",
    "we use the ciao  assertion language in order to provide precise descriptions on the initial call patterns . in our case , the ` entry ` declaration is used to inform that all calls to the only exported predicate ( i.e. , ` main/2 ` ) will always be of the form @xmath0 with @xmath1 ground and @xmath2 a variable .",
    "the predicate ` main/2 ` performs two calls to predicate ` formula/2 ` , which contains mode tests ` ground(x ) ` and ` var(w ) ` on its input arguments .",
    "a call ` formula(x , w ) ` returns @xmath3 .",
    "predicate ` two/1 ` returns the natural number 2 in peano s arithmetic .",
    "a call ` minus(a , b , c ) ` returns @xmath4 .",
    "however , if the result becomes a negative number , @xmath5 is left as a free variable .",
    "this indicates that the result is not valid . in turn , a call ` twice(a , b ) ` returns @xmath6 .",
    "prior to computing the result , this predicate checks whether @xmath7 is valid , i.e. , not a variable , and simply returns a variable otherwise .    : - module(_,[main/1],[assertions ] ) .",
    "+ : - entry main(s(s(s(l))),r ) : ( ground(l),var(r ) ) .",
    "+ main@xmath8(x , x2):- formula@xmath9(x , x1 ) , formula@xmath10(x1,x2 ) .",
    "+ formula@xmath11(x , w):- ground@xmath12(x),var@xmath13(w),two@xmath14(t),minus@xmath15(t , x , x2),twice@xmath16(x2,w ) . + two@xmath17(s(s(0 ) ) ) .",
    "+ minus@xmath18(0,x , x ) .",
    "+ minus@xmath19(s(x),s(y),r):- minus@xmath20(x , y , r ) .",
    "+ minus@xmath21(s(_x),0,_r ) .",
    "+ twice@xmath22(x,_y):- var@xmath23(x ) .",
    "+ twice@xmath24(x , y):- ground@xmath25(x ) , tw@xmath26(x , y ) .",
    "+ tw@xmath27(0,0 ) .",
    "+ tw@xmath28(s(x),s(s(nx))):- tw@xmath29(x , nx ) .    by observing the behaviour of the program",
    "it can be seen that for initial queries satisfying the ` entry ` declaration , all calls to the tests ` ground_{2,1}(x ) ` and ` var_{2,2}(w ) ` will definitely succeed , even if we do not know the concrete values of variable @xmath1 at compile time .",
    "also , the calls to ` ground_{8,1}(x ) ` will succeed , while the calls to ` var_{7,1}(x ) ` will fail .",
    "this shows the benefits of ( 1 ) _ exploiting abstract information in order to abstractly execute certain atoms , which in turn may allow unfolding of other atoms_. however , the use of an abstract domain which captures groundness and freeness information will in general not be sufficient to determine that in the second execution of ` formula/2 ` the tests ` ground_{2,1}(x ) ` and ` var_{2,2}(w ) ` will also succeed .",
    "the reason is that , on success of ` minus_{2,4}(t , x , x2 ) ` , @xmath30 can not be guaranteed to be ground since ` minus_6/3 ` succeeds with a free variable on its third argument position .",
    "it can be observed , however , that for all calls to ` minus/3 ` in executions described by the ` entry ` declaration , such third clause for ` minus/3 ` is useless .",
    "it will never contribute to a success of ` minus/3 ` since such predicate is always called with a value greater than zero on its second argument .",
    "unfolding can make this explicit by fully unfolding calls to ` minus/3 ` since they are sufficiently instantiated ( and as a result the `` dangerous '' third clause is disregarded ) .",
    "it allows concluding that in our particular context , all calls to ` minus/3 ` succeed with a ground third argument .",
    "this shows the importance of ( 2 ) _ performing unfolding steps in order to prune away useless branches , which will result in improved success information_. by the time execution reaches ` twice_{2,5}(x2,w ) ` , we hopefully know that @xmath30 is ground . in order to determine that",
    ", upon success of ` twice_{2,5}(x2,w ) ` ( and thus on success of ` formula_{1,1}(x , w ) ` ) , @xmath31 is ground , we need to perform a fixpoint computation .",
    "since , for example , the success substitution for ` formula_{1,1}(x , x1 ) ` is indeed the call substitution for ` formula_{1,2}(x1,x2 ) ` , the success of the second test ` ground_{2,1}(x ) ` ( i.e. , the one reachable from ` formula_{1,2}(x1,x2 ) ` ) can not be established unless we propagate success substitutions .",
    "this illustrates the importance of ( 3 ) _ propagating ( abstract ) success information , performing fixpoint computations when needed , which simultaneously will result in an improved unfolding_. finally , whenever we call ` formula(x , w ) ` , @xmath31 is a variable , a property which can not be captured if we restrict ourselves to downwards - closed domains .",
    "this indicates ( 4 ) _ the usefulness of having information on non _ downwards - closed _",
    "properties_.    throughout the paper we show that the framework we propose is able to eliminate all calls to mode tests ` ground/1 ` and ` var/1 ` , and predicates ` two/1 ` and ` minus/3 ` are both fully unfolded and no longer appear in the residual code .",
    "we have used _ sharing ",
    "freeness _ as abstract domain instead of one based on , say regular types , for two reasons . first , to illustrate how non - downwards closed information , including freeness and definite independence , can be correctly exploited by our algorithm in order to optimize the program , and second , to show how unfolding can be of great use in order to improve the accuracy of analyses apparently unrelated to partial deduction , such as the classical _ sharing ",
    "[ ex : sp ] the results obtained by ciaopp  which implements abstract interpretation with specialized definitions  are both the following specialized code and an accurate analysis for such program ( rules are renamed using the prefix @xmath32 ) .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ sp_main@xmath33(s(s(s(0))),0 ) .",
    "+ sp_main@xmath34(s(s(s(s(b)))),a ) : - sp_tw@xmath35(b , c ) , sp_formula@xmath36(c , a ) .",
    "+ sp_tw@xmath34(0,0 ) .",
    "+ sp_tw@xmath37(s(a),s(s(b ) ) ) : - sp_tw@xmath38(a , b ) .",
    "+ sp_formula@xmath39(0,s(s(s(s(0 ) ) ) ) ) .",
    "+ sp_formula@xmath40(s(a),s(s(s(s(s(s(b ) ) ) ) ) ) ) : - sp_tw@xmath41(a , b ) .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in this case , the success information for ` sp_main(x , x2 ) ` guarantees that @xmath30 is definitely ground on success .",
    "note that this is equivalent to proving @xmath42 .",
    "furthermore , our system is able to get to that conclusion even if the ` entry ` only informs about @xmath43 being any possible ground term and @xmath30 a free variable .",
    "the above results can not be achieved unless all four points mentioned before are available in a program analysis / specialization system .",
    "for example , if we use traditional partial deduction  @xcite ( pd ) with the corresponding  and  rules followed by abstract interpretation and _ abstract specialization _ as described in  @xcite we only obtain a comparable program after four iterations of the : `` pd + abstract interpretation + abstract specialization '' cycle .",
    "if we keep on adding more calls to formula , every time more iterations are necessary to obtain results comparable to ours . this shows the importance of achieving an algorithm which is able to _ interleave _ pd , with abstract interpretation , extended with abstract specialization , in order to communicate the accuracy gains achieved from one to the other as soon as possible . in any case",
    ", iterating over `` pd + analysis '' is not a good idea from the efficiency point of view .",
    "also , sometimes partially evaluating a partially evaluated program can degrade the quality of the residual program .",
    "the remaining of the paper is organized as follows .",
    "section  [ sec : prel - notat ] recalls some preliminary concepts . in sect .",
    "[ sec : unfold - with - abstr ] , we present abstract unfolding which already integrates abstract executability .",
    "section  [ sec : spec - defin ] introduces our notion of specialized definition and embeds it within an abstract partial deducer . in sect .",
    "[ sec : effic - prop - abstr ] , we propose our scheme for abstract interpretation with specialized definitions . finally , sect .",
    "[ sec : disc - relat - work ] compares to related work and sect .",
    "[ sec : benefits - or - our ] concludes .",
    "[ sec : prel - notat ]    very briefly ( see for example  @xcite for details ) , an _ atom _",
    "@xmath7 is a syntactic construction of the form @xmath44 , where @xmath45 , with @xmath46 , is a predicate symbol and @xmath47 are terms .",
    "a _ clause _ is of the form @xmath48 where its head @xmath49 is an atom and its body @xmath50 is a conjunction of atoms .",
    "a _ definite program _ is a finite set of clauses .",
    "a _ goal _ ( or query ) is a conjunction of atoms .",
    "let @xmath51 be a goal of the form @xmath52 , @xmath53 .",
    "the concept of _ computation rule _ , denoted by @xmath54 , is used to select an atom within a goal for its evaluation .",
    "the operational semantics of definite programs is based on derivations  @xcite .",
    "let @xmath55 be a renamed apart clause in @xmath56 such that @xmath57 .",
    "then @xmath58 is _ derived _ from @xmath51 and @xmath5 via @xmath54 . as customary , given a program @xmath56 and a goal @xmath51 , an _ sld derivation _ for @xmath59 consists of a possibly infinite sequence @xmath60 of goals , a sequence @xmath61 of properly renamed apart clauses of @xmath56 , and a sequence @xmath62 of mgus such that each @xmath63 is derived from @xmath64 and @xmath65 using @xmath66 .",
    "a derivation step can be non - deterministic when @xmath67 unifies with several clauses in @xmath56 , giving rise to several possible sld derivations for a given goal .",
    "such sld derivations can be organized in _",
    "sld trees_. a finite derivation @xmath68 is called _ successful _ if @xmath69 is empty . in that case @xmath70 is called the computed answer for goal @xmath51 . such a derivation",
    "is called _ failed _ if it is not possible to perform a derivation step with @xmath69 .",
    "given an atom @xmath7 , an _ unfolding rule _",
    "@xcite computes a set of finite sld derivations @xmath71",
    "( i.e. , a possibly incomplete sld tree ) of the form @xmath72 with computed answer substitution @xmath73 for @xmath74 whose associated _ resultants _ ( or residual rules ) are @xmath75 .",
    "the following standard operations are used in the paper to handle keyed - tables : @xmath76 initializes a table @xmath77 .",
    "@xmath78 adds @xmath79 associated to @xmath80 to @xmath77 and deletes previous information associated to @xmath80 , if any .",
    "@xmath81 returns true iff @xmath80 is currently stored in the table . finally , @xmath81 returns the information associated to @xmath80 in @xmath77 . for simplicity ,",
    "we sometimes consider tables as sets and we use the notation @xmath82 to denote that there is an entry in the table t with the corresponding @xmath80 and associated @xmath79 .",
    "abstract interpretation @xcite provides a general formal framework for computing safe approximations of programs behaviour .",
    "programs are interpreted using values in an _ abstract domain _ ( @xmath83 ) instead of the _ concrete domain _ ( @xmath84 ) .",
    "the set of all possible abstract values which represents @xmath83 is usually a complete lattice or cpo which is ascending chain finite .",
    "values in the abstract domain @xmath85 and sets of values in the concrete domain @xmath86 are related via a pair of monotonic mappings @xmath87 : the _ abstraction _ function @xmath88 which assigns to each ( possibly infinite ) set of concrete values an abstract value , and the _ concretization _ function @xmath89 which assigns to each abstract value the ( possibly infinite ) set of concrete values it represents . the operations on the abstract domain @xmath90 that we will use in our algorithms are :    * @xmath91 performs the abstract restriction ( or projection ) of a substitution @xmath92 to the set of variables in the expression @xmath93 , denoted @xmath94 ; * @xmath91 extends the substitution @xmath92 to the variables in the set @xmath94 ; * @xmath95 obtains the description which results from adding the abstraction of the unification @xmath96 to the substitution @xmath92 ; * @xmath97 performs the abstract conjunction ( @xmath98 ) of two substitutions ; * @xmath97 performs the abstract disjunction ( @xmath99 ) of two substitutions .",
    "in our algorithms we also use @xmath100 which adapts and projects the information in an abstract atom @xmath101 to the variables in the clause @xmath102 .",
    "an _ abstract atom _ of the form @xmath103 is a concrete atom @xmath51 which comes equipped with an _ abstract substitution _",
    "@xmath104 which is defined over @xmath105 and provides additional information on the context in which the atom will be executed at run - time .  can be defined in terms of the operations above as : @xmath100 = @xmath106(@xmath107 .",
    "finally , the most general substitution is represented as @xmath108 , and the least general ( empty ) substitution as @xmath109 .",
    "we now present an extension of sld semantics which exploits abstract information . this will provide the means to overcome difficulties ( 1 ) and ( 2 ) introduced in section  [ sec : motivation ] .",
    "the extended semantics handles abstract goals of the form @xmath103 , i.e. , a concrete goal @xmath51 comes equipped with an abstract substitution @xmath104 defined over @xmath105 .",
    "the first rule corresponds to a derivation step .",
    "[ def : der - step - abs ] let @xmath103 be an abstract goal where @xmath110 .",
    "let @xmath54 be a computation rule and let @xmath111@xmath67 .",
    "let @xmath55 be a renamed apart clause in @xmath56 .",
    "then the abstract goal @xmath112 is _ derived _ from @xmath103 and @xmath5 via @xmath54 if @xmath113 @xmath114 , where : @xmath115    an important difference between the above definition and the standard derivation step is that the use of abstract ( call ) substitutions allows imposing further conditions for performing derivation steps , in particular , @xmath116 can not be @xmath109 .",
    "this is because if @xmath117 and @xmath118 then the head of the clause @xmath5 is incompatible with @xmath104 and the unification @xmath119 will definitely fail at run - time .",
    "thus , abstract information allows us to remove useless clauses from the residual program .",
    "this produces more efficient resultants and increases the accuracy of analysis for the residual code .",
    "[ ex : derive ] consider the abstract atom @xmath120 , which appears in the analysis of our running example ( c.f . fig .",
    "[ fig : aog ] ) .",
    "we abbreviate as @xmath121 the successive application of @xmath122 functors @xmath123 to variable @xmath43 . the notation @xmath124 ( resp .",
    "@xmath125 ) indicates that variable @xmath43 is ground ( resp . a free variable ) . after applying a derivation step ,",
    "we obtain the derived abstract goal : + @xmath126 + where the abstract description has been extended with updated information about the freeness of the newly introduced variables .",
    "in particular , both t and x2 are v.    the second rule we present makes use of the availability of abstract substitutions to perform _ abstract executability _",
    "@xcite during resolution .",
    "this allows replacing some atoms with simpler ones , and , in particular , with the predefined atoms _ true _ and _ false _ , provided certain conditions hold .",
    "we assume the existence of a predefined _ abstract executability table _ which contains entries of the form @xmath127 which specify the behaviour of external procedures : builtins , libraries , and other user modules .",
    "for instance , for predicate @xmath128 contains the information @xmath129 . for @xmath130",
    ", it contains @xmath131 .",
    "[ def : abs - ex - true ] let @xmath103 be an abstract goal where @xmath110 .",
    "let @xmath54 be a computation rule and let @xmath111@xmath67 .",
    "let @xmath132 be a renamed apart entry in the abstract executability table .",
    "then , the goal @xmath112 is _ abstractly executed _ from @xmath103 and @xmath132 via @xmath54 if @xmath133 and @xmath134 , where @xmath135    [ ex : aexec ] from the derived goal in ex .",
    "[ ex : derive ] , we can apply twice the above rule to abstractly execute the calls to ground and var and obtain :    @xmath136    since both calls succeed by using the abstract executability table described above and the information in the abstract substitution .",
    "[ def : aunfold ] let @xmath137 be an abstract atom and @xmath56 a program .",
    "we define @xmath138 as the set of _ resultants _ associated to a finite ( possibly incomplete ) sld tree computed by applying the rules of definitions [ def : der - step - abs ] and [ def : abs - ex - true ] to @xmath137 .",
    "the so - called _ local control _ of pd ensures the termination of the above process . for this purpose",
    ", the unfolding rule must incorporate some mechanism to stop the construction of sld derivations ( we refer to @xcite for details ) .",
    "[ ex : aunfold ] consider an unfolding rule @xmath139 based on homeomorphic embedding @xcite to ensure termination and the initial goal in ex .",
    "[ ex : derive ] .",
    "the derivation continuing from ex .",
    "[ ex : aexec ] performs several additional derivation steps and abstract executions and branches ( we do not include them due to space limitations and also because it is well understood ) .",
    "the following resultants are obtained from the resulting tree :    ....        formula(s(s(s(s(0),s(s(s(s(0 ) ) ) ) ) .",
    "formula(s(s(s(s(s(a))))),s(s(s(s(s(s(b ) ) ) ) ) ) ) : - tw(a , b ) ....    which will later be filtered and renamed resulting in rules 4 and 5 of ex .",
    "[ ex : sp ] .",
    "it is important to note that sld resolution with abstract substitutions is not restricted to the left - to - right computation rule .",
    "however , it is well - known that non - leftmost derivation steps can produce incorrect results if the goal contains _ impure _ atoms to the left of @xmath67 .",
    "more details can be found , e.g. , in  @xcite .",
    "also , abstract execution of non - leftmost atoms can be incorrect if the abstract domain used captures properties which are not downwards closed .",
    "a simple solution is to only allow leftmost abstract execution for non - downwards closed domains ( and non - leftmost for derivation steps ) .",
    "[ sec : spec - defin ]    [ 1 ]    @xmath140 ; @xmath141 ( @xmath142 ) @xmath143 specialized_definition@xmath144 @xmath145 @xmath146 @xmath147 @xmath148 @xmath149 @xmath150 @xmath151 ( @xmath152 ) @xmath153 @xmath154 ( @xmath155 ) @xmath156 @xmath157 @xmath158@xmath159 @xmath160 @xmath161 @xmath162 @xmath163 @xmath164 @xmath165    we now define an abstract partial deduction ( apd ) algorithm whose execution can later be _ interleaved _ in a seamless way with a state - of - the - art abstract interpreter . for this",
    "it is essential that the apd process can generate residual code _",
    "online_. thus , we need to produce a residual , specialized definition for a call pattern as soon as we finish processing it .",
    "this will make it possible for the analysis algorithm to have access to the improved definition .",
    "this may increase the accuracy of the analyzer and addresses the difficulty ( 2 ) described in sect .",
    "[ sec : motivation ] .",
    "typically , pd is presented as an iterative process in which partial evaluations are computed for the new generated atoms until they _ cover _ all calls which can appear in the execution of the residual program .",
    "this is formally known as the _ closedness _ condition of pd @xcite . in order to ensure termination of this global process",
    ", the so - called _ global _ control defines a @xmath166 operator ( see @xcite ) which guarantees that the number of sld trees computed is kept finite , i.e. , it ensures the finiteness of the set of atoms for which partial evaluation is produced .",
    "however , the residual program is not generated until such iterative process terminates .",
    "algorithm  [ algo : pd - with - spec - defs ] presents an apd algorithm .",
    "the main difference with standard algorithms is that the resultants computed by  ( l26 ) are added to the program during execution of the algorithm ( l30 ) rather than in a later code generation phase . in order to avoid conflicts among the new clauses and the original ones , clauses for specialized definitions",
    "are renamed with a fresh predicate name ( l29 ) prior to adding them to the program ( l30 ) .",
    "the algorithm uses two global data structures .",
    "the _ specialization table _ contains entries of the form @xmath167 .",
    "the atom @xmath168 provides the link with the clauses of the specialized definition for @xmath101 .",
    "the _ generalization table _ stores the results of the  function and contains entries @xmath169 where @xmath170 is a generalization of @xmath101 .",
    "computation is initiated by procedure partial_evaluation_with_spec_defs ( l1 - 4 ) which initializes the tables and calls process_call_pattern for each abstract atom @xmath171 in the initial set to be partially evaluated .",
    "the task of process_call_pattern is , if the atom has not been processed yet ( l6 ) , to compute a specialized definition for it ( l7 ) and then process all clauses in its specialized definition by means of calls to process_clause ( l9 - 11 ) .",
    "procedure process_clause traverses clause bodies , processing their corresponding atoms by means of calls to process_call_pattern , in a depth - first , left - to - right fashion .",
    "the order in which pending call patterns ( atoms ) are handled by the algorithm is usually not fixed in pd algorithms .",
    "they are often all put together in a set .",
    "the reason for this presentation is to be as close as possible to our analysis algorithm which enforces a depth - first , left - to - right traversal of program clauses . in this regard ,",
    "the relevant point to note is that this algorithm does not perform success propagation yet ( difficulty 3 ) . in l16",
    ", it becomes apparent that the atom(s ) in @xmath172 will be analyzed with the same call pattern @xmath104 as @xmath173 , which is to their left in the clause .",
    "this , on one hand , may clearly lead to substantial precision loss .",
    "for instance , the abstract pattern @xmath174 which is necessary to obtain the last two resultants of ex .",
    "[ ex : sp ] can not be obtained with this algorithm . in particular",
    ", we can not infer the groundness of @xmath175 which , in turn , prevents us from abstractly executing the next call to @xmath128 and , thus , from obtaining this optimal specialization . on the other hand , this lack of success propagation makes it difficult or even impossible to work with non downwards closed domains , since @xmath104 may contain information which holds before execution of the leftmost atom @xmath173 but which can be uncertain or even false after that .",
    "in fact , in our example @xmath104 contains the info @xmath176 , which becomes false after execution of @xmath177 , since now @xmath175 is ground .",
    "this problem is solved in the algorithm we present in the next section , where analysis information flows from left to right , adding more precise information and eliminating information which is no longer safe or even definitely wrong . for the integration",
    "we propose , the most relevant part of the algorithm comprises l20 - 31 , as it is the code fragment which is _ directly _ executed from our abstract interpreter .",
    "the remaining procedures ( l1-l19 ) will be overridden by more accurate ones later .",
    "the procedure of interest is specialized_definition .",
    "as it is customary , it performs ( l21 ) a generalization of the call @xmath101 using the abstract counterpart of the @xmath178 operator , denoted by @xmath166 , and which is in charge of ensuring termination at the global level .",
    "the result of the generalization , @xmath170 , is inserted in the generalization table @xmath179 ( l22 ) .",
    "correctness of the algorithm requires that @xmath180 .",
    "if @xmath170 has been previously treated ( l23 ) , then its specialized definition @xmath181 is looked up in @xmath182 ( l24 ) and returned .",
    "otherwise , a specialized definition @xmath183 is computed for it by using the @xmath139 operator of def .",
    "[ def : aunfold ] ( l26 ) .",
    "as already mentioned , the specialized definition @xmath183 for the abstract atom @xmath184 is used to extend the original program @xmath56 .",
    "first , the atom @xmath168 is renamed by using @xmath185 which returns an atom with a fresh predicate name , @xmath181 , and optionally filters constants out ( l27 ) .",
    "then , function @xmath186 is applied to rename the clause heads using atom @xmath168 ( l29 ) .",
    "@xmath187 returns @xmath188 where @xmath189 .",
    "finally , the program @xmath56 is extended with the new , _ renamed _",
    "specialized definition , @xmath190 .",
    "three calls to specialized_definition appear ( within an oval box ) during the analysis of our running example in fig .",
    "[ fig : aog ] from the following abstract atoms , first @xmath191 , then @xmath192 and finally @xmath193 .",
    "the output of such executions is used later ( with the proper renaming ) to produce the resultants in ex .",
    "[ ex : sp ] .",
    "for instance , the second clause obtained from the first call to specialized_definition is    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ sp_main@xmath34(s(s(s(s(b)))),a ) : - tw@xmath35(b , c),formula@xmath36(c , a ) . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    where only the head is renamed .",
    "the renaming of the body literals is done in a later code generation phase as already mentioned , alg .",
    "[ algo : pd - with - spec - defs ] is not able to obtain such abstract atoms due to the absence of success propagation .",
    "[ sec : effic - prop - abstr ]    we now present our final algorithm for abstract interpretation with specialized definitions .",
    "this algorithm extends both the apd algorithm  [ algo : pd - with - spec - defs ] and the abstract interpretation algorithms in @xcite . w.r.t .",
    "algorithm  [ algo : pd - with - spec - defs ] , the main improvement is the addition of success propagation .",
    "unfortunately , this requires computing a global fixpoint .",
    "it is an important objective for us to be able to compute an accurate fixpoint in an efficient way .",
    "w.r.t the algorithms in @xcite , the main improvements are the following .",
    "( 1 ) it deals directly with non - normalized programs .",
    "this point , which does not seem very relevant in a pure analysis system , becomes crucial when combined with a specialization system in order to profit from constants propagated by unfolding .",
    "( 2 ) it incorporates a hardwired efficient graph traversal strategy which eliminates the need for maintaining priority queues explicitly  @xcite .",
    "( 3 ) the algorithm includes a widening operation for calls , , which limits the amount of multivariance in order to keep finite the number of call patterns analyzed .",
    "this is required in order to be able to use abstract domains which are infinite , such as regular types .",
    "( 4 ) it also includes a number of simplifications to facilitate understanding , such as the use of the keyed - table adt , which we assume encapsulates proper renaming apart of variables and the application of renaming transformations when needed .    in order to compute and propagate success substitutions , algorithm  [ algo : ai - with - spec - defs ] computes a _ program analysis graph _ in a similar fashion as state of the art analyzers such as the ciaopp  analyzer  @xcite .",
    "for instance , the analysis graph computed by algorithm  [ algo : ai - with - spec - defs ] for our running example is depicted in fig .",
    "[ fig : aog ] .",
    "the graph has two sorts of nodes .",
    "those which correspond to atoms are called `` or - nodes '' .",
    "for instance , the node @xmath194 indicates that when the atom @xmath195 is called with description @xmath196 the answer ( or success ) substitution computed is @xmath197 . those nodes which correspond to rules are called `` and - nodes '' . in fig .",
    "[ fig : aog ] , they appear within a dashed box and contain the head of the corresponding clause . each and - node has as children as many or - nodes as literals there are in the body . if a child or - node is already in the tree , it is no further expanded and the currently available answer is used .",
    "for instance , the analysis graph in figure  [ fig : aog ] contains three occurrences of the abstract atom @xmath192 ( modulo renaming ) , but only one of them has been expanded .",
    "this is depicted by arrows from the two non - expanded occurrences of @xmath198 to the expanded one .",
    "more information on the efficient construction of the analysis graph can be found in  @xcite .    [ 1 ]    @xmath199 ; @xmath200 @xmath140 ; @xmath141 ( @xmath201,j , entry}$ ] ) @xmath202 @xmath203 @xmath204 @xmath205 specialized_definition@xmath206 @xmath207 @xmath147 @xmath148 @xmath208 @xmath209~b_{k},k,1)$ ] @xmath210 @xmath211 ) @xmath212 @xmath213 @xmath214 @xmath148 process_call_pattern(@xmath215,k , i}$ ] ) @xmath216 @xmath148 @xmath217 @xmath218~r , k , i+1)$ ] @xmath219 @xmath220 process_call_pattern(@xmath221,k , i}$ ] ) @xmath216 @xmath148 @xmath217 @xmath222 @xmath148 @xmath223 @xmath224 @xmath225 @xmath226 @xmath227 @xmath228 @xmath229 @xmath230 ( @xmath231 ) @xmath232,k , i}$ ] @xmath233 ( @xmath234~b , k , i$ ] ) @xmath235~b , k , i)$ ] ( @xmath236 )    the program analysis graph is implicitly represented in the algorithm by means of two data structures , the _ answer table _ ( ) and the _ dependency table _ ( ) .",
    "the answer table contains entries of the form @xmath237 which are interpreted as the answer ( success ) pattern for @xmath184 is @xmath238 .",
    "for instance , there exists an entry of the form @xmath239 associated to the atom discussed above .",
    "dependencies indicate direct relations among or - nodes .",
    "an or - node @xmath240 _ depends on _ another or - node @xmath241 iff in the body of some clause for @xmath240 there appears the or - node @xmath241 .",
    "the intuition is that in computing the answer for @xmath240 we have used the answer pattern for @xmath241 . in our algorithm",
    "we store _ backwards _ dependencies , i.e. , for each or - node @xmath241 we keep track of the set of or - nodes which depend on it .",
    "that is to say , the keys in the dependency table are or - nodes and the information associated to each node is the set of other nodes which depend on it , together with some additional information required to iterate when an answer is modified ( updated ) .",
    "each element of a _",
    "dependency set _ for an atom @xmath242 is of the form @xmath243 ~k , i}$ ] .",
    "it should be interpreted as follows : the or - node @xmath244 through the literal at position @xmath245 depends on the or - node @xmath242 .",
    "also , the remaining information @xmath246 $ ] informs that the head of this clause is @xmath247 and the substitution ( in terms of all variables of clause @xmath248 ) just before the call to @xmath242 is @xmath249 .",
    "such information avoids reprocessing atoms in the clause @xmath248 to the left of position @xmath250 .",
    "for instance , the dependency set for @xmath251 is @xmath252 2,2}\\}$ ] .",
    "it indicates that the or - node @xmath253 is only used , via literal ( 2,2 ) , in the or - node @xmath191 ( see example  [ ex : sp ] ) .",
    "thus , if the answer pattern for @xmath251 is ever updated , then we must reprocess the or - node @xmath254 from position 2,2 .",
    "algorithm  [ algo : ai - with - spec - defs ] proceeds as follows .",
    "the procedure abs_int_with_spec_defs initializes the four tables used by the algorithm and calls process_call_pattern for each abstract atom in the initial set .",
    "the function process_call_pattern applies , first of all ( l7 ) , the  function to @xmath101 taking into account the set of entries already in .",
    "this returns a substitution @xmath249 s.t .",
    "the most precise  function possible is the identity function , but it can only be used with abstract domains with a finite number of abstract values .",
    "this is the case with _ sharing ",
    "and thus we will use the identity function in our example .",
    "if the call pattern @xmath256 has not been processed before , it places ( l9 ) @xmath109 as initial answer in for @xmath101 and sets to empty ( l10 ) the set of or - nodes in the graph which depend on @xmath256 .",
    "it then computes ( l11 ) a specialized definition for @xmath256 .",
    "we do not show in algorithm  [ algo : ai - with - spec - defs ] the definition of specialized_definition , since it is identical to that in algorithm  [ algo : pd - with - spec - defs ] . in the graph",
    ", we show within an oval box the calls to specialized_definition which appear during the execution of the running example ( see the details in sect .",
    "[ sec : spec - defin ] ) .",
    "the clauses in the specialized definition are linked to the box with a dotted arc .",
    "then it launches ( l13 - 15 ) calls to process_clause for the clauses in the specialized definition w.r.t .",
    "which @xmath256 is to be analyzed . only after this , the _ parent _ or - node is added ( l16 - 17 ) to the dependency set for @xmath256 .",
    "the function process_clause performs the success propagation and constitutes the core of the analysis .",
    "first , the current answer ( @xmath257 ) for the call to the literal at position @xmath245 of the form @xmath258 is ( l24 and l29 ) conjoined ( ) , after being extended ( ) to all variables in the clause , with the description @xmath259 from the program point immediately before @xmath50 in order to obtain the description @xmath260 for the program point after @xmath50 .",
    "if @xmath50 is not the last literal , @xmath216 is taken as the ( improved ) calling pattern to process the next literal in the clause in the recursive call ( l25 ) .",
    "this corresponds to left - to - right success propagation and is marked in fig .",
    "[ fig : aog ] with a dashed horizontal arrow .",
    "if we are actually processing the last literal , @xmath260 is ( l30 ) adapted ( ) to the initial call pattern @xmath261 which started process_clause , obtaining @xmath262 .",
    "this value is ( l32 ) disjoined ( ) with the current answer , @xmath263 , for @xmath261 as given by . if the answer changes , then its dependencies , which are readily available in , need to be recomputed ( l36 ) using process_update .",
    "this procedure restarts the processing of all body postfixes which depend on the calling pattern for which the answer has been updated by launching new calls to process_clause .",
    "there is no need of recomputing answers in our example .",
    "the procedure remove_previous_deps eliminates ( l42 ) entries in for the clause postfix which is about to be re - computed .",
    "we do not present its definition here due to lack of space .",
    "note that the new calls to process_clause may in turn launch calls to process_update . on termination of the algorithm a global fixpoint",
    "is guaranteed to have been reached .",
    "note that our algorithm also stores in the dependency sets calls from the initial entry points ( marked with the value @xmath264 in l5 ) .",
    "these do not need to be reprocessed ( l40 ) but are useful for determining the specialized version to use for the initial queries after code generation .",
    "termination of algorithm  [ algo : ai - with - spec - defs ] comprises several levels .",
    "first , termination of the algorithm requires the local termination of the process of obtaining a specialized definition .",
    "this corresponds to ensuring termination of function specialized_definition in algorithm  [ algo : pd - with - spec - defs ] .",
    "second , we need to guarantee that the number of call patterns for which a specialized definition is computed is finite .",
    "this corresponds to global termination of specialization algorithms . in terms of our algorithm",
    ", this is equivalent to having a finite number of entries in",
    ". the  function should be able to guarantee it .",
    "third , it is required that the set of call patterns for which an answer pattern is to be computed be finite .",
    "this corresponds to control of multivariance in context - sensitive analysis . in terms of our algorithm",
    ", this is equivalent to having a finite number of entries in",
    ". the  function should be able to guarantee it .",
    "fourth and final , it is required that the computation of the answer pattern for each entry in needs a finite number of iterations .",
    "this is guaranteed since we consider domains which are ascending chain finite .",
    "another way of looking at this problem is that , intuitively , the combined effect of terminating  and  operators guarantee that the set of specialized definitions which algorithm  [ algo : ai - with - spec - defs ] will compute for an initial set of atoms is finite .",
    "these two problems have received considerable attention by the pd community ( see , e.g. , @xcite ) . since algorithm  [ algo : ai - with - spec - defs ] performs analysis of the program composed of the set of specialized definitions , once we have guaranteed the finiteness of the program to be analyzed , a terminating  together with an abstract domain which is ascending chain finite guarantee termination of the whole process .",
    "[ sec : disc - relat - work ]    we have presented a generic framework for the analysis and specialization of logic programs which is currently the basis of the analysis / specialization system implemented in the ciaopp   preprocessor .",
    "we argue that , in contrast to other approaches , the fact that our method can be used both as a specializer and analyzer gives us more accuracy and efficiency than the individual techniques .",
    "indeed , the versatility of our framework ( and of our implementation ) can be seen by recasting well - known specialization and analysis frameworks as instances in which the different parameters : unfolding rule , widen call rule , abstraction operator , and analysis domain , take the following values .",
    "[ [ polyvariant - abstract - interpretation ] ] polyvariant abstract interpretation : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    our algorithm can behave as the analysis algorithm described in @xcite for polyvariant static analysis by defining a @xmath166 operator which returns always the base form of an expression ( i.e. , it loses all constants ) and an @xmath139 operator which performs a single derivation step ( i.e. , it returns the original definition ) .",
    "thus , the resulting framework would always produce a residual program which coincides with the original one and can be analyzed with any abstract domain of interest .",
    "[ [ multivariant - abstract - specialization ] ] multivariant abstract specialization : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the specialization power of the framework described in @xcite can be obtained by using the same @xmath166 described in the above point plus an @xmath139 operator which always performs a derive step followed by zero or more abstract execution steps .",
    "it is interesting to note that in the original framework abstract executability is performed as an offline optimization phase while it is performed online in our framework .    [",
    "[ classical - partial - deduction ] ] classical partial deduction : + + + + + + + + + + + + + + + + + + + + + + + + + + + +    our method can be used to perform classical pd in the style of @xcite by using an abstract domain with the single abstract value @xmath108 and the identity function as   rule .",
    "this corresponds to the @xmath265 domain of  @xcite in which an atom with variables represents all its instances .",
    "let us note that , in spite of the fact that the algorithm follows a left - to - right computation flow , the process of generating specialized definitions ( as discussed in section  [ sec : unfold - with - abstr ] ) can perform _ non - leftmost _ unfolding steps and achieve optimizations as powerful as in pd .",
    "[ [ abstract - partial - deduction ] ] abstract partial deduction : + + + + + + + + + + + + + + + + + + + + + + + + + + +    several approaches have been proposed which extend pd by using abstract substitutions  @xcite . in essence ,",
    "such approaches are very similar to the abstract partial deduction with call propagation shown in algorithm  [ algo : pd - with - spec - defs ] .",
    "though all those proposals identify the need of propagating success substitutions , they either fail to do so or propose means for propagating success information which are not fully integrated with the apd algorithm and , in our opinion , do not fit in as nicely as the use of and  or trees . also , these proposals are either strongly coupled to a particular ( downward closed ) abstract domain , i.e. , regular types , as in @xcite or do not provide the exact description of operations on the abstract domain which are needed by the framework , other than general correctness criteria  @xcite .",
    "however , the latter allow conjunctive pd , which is not available in our framework .    [ [ the - approach - in ] ] the approach in  @xcite : + + + + + + + + + + + + + + + + + + + + + + + +    was a starting step towards our current framework .",
    "there , the introduction of unfolding steps directly in the and  or graph was proposed in order to achieve transformations as powerful as those of pd while at the same time propagating abstract information .",
    "in contrast , we now resort to augmented sld semantics for the specialization side of the framework while using and - or semantics for the analysis side of the framework .",
    "this has both conceptual , the hybrid approach we propose provides satisfactory answers to the four issues raised in section  [ sec : motivation ] , and practical advantages , since the important body of work in control of pd is directly applicable to the specialization side of our framework .",
    "[ sec : benefits - or - our ]    we have proposed a novel scheme for a seamless integration of the techniques of abstract interpretation and partial deduction .",
    "our scheme is parametric w.r.t .  the abstract domain and the control issues which guide the partial deduction process .",
    "existing proposals for the integration use abstract interpretation as a _ means _ for improving partial evaluation rather than as a _ goal _",
    ", at the same level as producing a specialized program .",
    "this implies that , as a result , their objective is to yield a set of atoms which determines a partial evaluation rather than to compute a safe approximation of its success . unlike them ,",
    "a main objective of our work is to improve success information by analyzing the specialized code , rather than the original one .",
    "we achieve this objective by smoothly _ interleaving _ both techniques which improves success information  even for abstract domains which are not related directly to partial evaluation .",
    "moreover , with more accurate success information , we can improve further the quality of partial evaluation . the overall method thus yields not only a specialized program but also a safe approximation of its behaviour .",
    "the authors would like to thank john gallagher and michael leuschel for useful discussions on the integration of abstract interpretation and partial deduction .",
    "this work was funded in part by the information society technologies programme of the european commission , future and emerging technologies under the ist-2001 - 38059 _ asap _ project and by the spanish ministry of science and education under the mcyt tic 2002 - 0055 _ cubico _ project .",
    "manuel hermenegildo is also supported by the prince of asturias chair in information science and technology at unm.2                                                  g.  puebla , m.  hermenegildo , and j.  gallagher .",
    "n integration of partial evaluation in a generic abstract interpretation framework . in _ proc . of pepm99",
    "_ , number ns-99 - 1 in brisc series , pages 7585 .",
    "university of aarhus , denmark , 1999 ."
  ],
  "abstract_text": [
    "<S> the relationship between abstract interpretation and partial deduction has received considerable attention and ( partial ) integrations have been proposed starting from both the partial deduction and abstract interpretation perspectives . in this work </S>",
    "<S> we present what we argue is the first fully described generic algorithm for efficient and precise integration of abstract interpretation and partial deduction . taking as starting point state - of - the - art algorithms for context - sensitive , polyvariant abstract interpretation and ( abstract ) partial deduction , we present an algorithm which combines the best of both worlds . </S>",
    "<S> key ingredients include the accurate success propagation inherent to abstract interpretation and the powerful program transformations achievable by partial deduction . in our algorithm , </S>",
    "<S> the calls which appear in the analysis graph are not analyzed w.r.t .  the original definition of the procedure but w.r.t . </S>",
    "<S> _ specialized definitions _ of these procedures . </S>",
    "<S> such specialized definitions are obtained by applying both unfolding and abstract executability . </S>",
    "<S> our framework is parametric w.r.t .  </S>",
    "<S> different control strategies and abstract domains . different combinations of such parameters correspond to existing algorithms for program analysis and specialization . </S>",
    "<S> simultaneously , our approach opens the door to the efficient computation of strictly more precise results than those achievable by each of the individual techniques . </S>",
    "<S> the algorithm is now one of the key components of the ciaopp   analysis and specialization system . </S>"
  ]
}