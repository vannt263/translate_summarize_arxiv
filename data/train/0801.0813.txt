{
  "article_text": [
    "in the last few years , there has been some interest in the semantics of quantum programming languages .",
    "@xcite gave a denotational semantics for a flow - chart language , but this language did not include higher - order types .",
    "several authors defined quantum lambda calculi @xcite as well as quantum process algebras @xcite , which had higher - order features and a well - defined operational semantics , but lacked denotational semantics . @xcite gave a categorical model for a higher - order quantum lambda calculus , but omitted all the non - linear features ( i.e. , classical data ) .",
    "meanwhile , abramsky and coecke @xcite developed categorical axiomatics for hilbert spaces , but there is no particular language associated with these models .    in this paper , we give the first categorical semantics of an unabridged quantum lambda calculus , which is a version of the language studied in @xcite .    for the purposes of the present paper , an understanding of the precise mechanics of quantum computation is not required .",
    "we will focus primarily on the type system and language , and not on the structure of the actual `` built - in '' quantum operations ( such as unitary operators and measurements ) . in this sense , this paper is about the semantics of a generic call - by - value linear lambda calculus , which is parametric on some primitive operations that are not further explained .",
    "it should be understood , however , that the need to support primitive quantum operations motivates particular features of the type system , which we briefly explain now .",
    "the first important language feature is linearity .",
    "this arises from the well - known _ no - cloning _",
    "property of quantum computation , which asserts that quantum data can not be duplicated @xcite .",
    "so if @xmath1 is a variable representing a quantum bit , and @xmath2 is a variable representing a classical bit , then it is legal to write @xmath3 , but not @xmath4 . in order to keep track of duplicability at higher - order types we use a type system based on linear logic .",
    "we use the duplicability operator `` @xmath0 '' to mark classical types . in the categorical semantics ,",
    "this operator gives rise to a comonad as in the work of @xcite and @xcite .",
    "another account of mixing copyable and non - copyable data is  @xcite , where the copyability is internal to objects .",
    "a second feature of quantum computation is its probabilistic nature .",
    "quantum physics has an operation called measurement , which converts quantum data to classical data , and whose outcome is inherently probabilistic . given a quantum state @xmath5 , a measurement will yield output @xmath6 with probability @xmath7 and @xmath8 with probability @xmath9 . to model this probabilistic effect in our call - by - value setting ,",
    "our semantics requires a computational monad in the sense of @xcite .",
    "the coexistence of the computational monad @xmath10 and the duplicability comonad @xmath0 in the same category is what makes our semantics interesting and novel .",
    "it differs from the work of @xcite , who considered a monad and a comonad one two different categories , arising from a single adjunction .",
    "the computational aspects of linear logic have been extensively explored by many authors , including @xcite .",
    "however , these works contain explicit lambda terms to witness the structural rules of linear logic , for example , @xmath11 .",
    "by contrast , in our language , structural rules are implicit at the term level , so that @xmath12 is regarded as a subtype of @xmath13 and one writes @xmath14 . as we have shown in @xcite ,",
    "linearity information can automatically be inferred by the type checker .",
    "this allows the programmer to program as in a non - linear language .",
    "this use of subtyping is the main technical complication in our proof of well - definedness of the semantics .",
    "this is because one has to show that the denotation is independent of the choice of a potentially large number of possible derivations of a given typing judgment .",
    "we are forced to introduce a church - style typing system , and to prove that the semantics finally does not depend on the additional type annotations .",
    "another technical choice we made in our language concerns the relation between the exponential @xmath15 and the pairing operation .",
    "linear logic only requires @xmath16 and not the opposite implication .",
    "however , in our programming language setting , we find it natural to identify a classical pair of values with a pair of classical values , and therefore we will have an isomorphism @xmath17 .",
    "the plan of the paper is the following .",
    "first , we describe the lambda calculus and equational axioms we wish to consider .",
    "then , we develop a categorical model , called linear category for duplication , which is inspired by @xcite and @xcite .",
    "we then show that the language is an internal language for the category , thus obtaining soundness and completeness .",
    "we will describe a linear typed lambda calculus with higher - order functions and pairs .",
    "the language is designed to manipulate both classical data , which is duplicable , and quantum data , which is non - duplicable . for simplicity",
    ", we assume the language is strictly linear , and not affine linear as in @xcite .",
    "this means duplicable values are both copyable and discardable , whereas non - duplicable values must be used once , and only once .",
    "the set of types is given as follows : @xmath18 .",
    "here @xmath19 ranges over type constants . while the remainder of this paper does not depend on the choice of type constants , in our main application  @xcite this",
    "is intended to include a type @xmath20 of quantum bits , and a type @xmath21 of classical bits .",
    "@xmath22 stands for functions from @xmath13 to @xmath23 , @xmath24 for pairs , @xmath25 for the unit type , and @xmath26 for duplicable objects of types @xmath13 .",
    "we denote @xmath27 with @xmath28 @xmath15 s by @xmath29 .",
    "the intuitive definition of @xmath26 is the key to the spirit in which we want the language to be understood : the @xmath15 on @xmath26 is understood as specifying a property , rather than additional structure , on the elements of @xmath13 .",
    "therefore , we will have @xmath30 .",
    "whether or not a given value of type @xmath13 is also of type @xmath12 should be something that is inferred , rather than specified in the code .    since a term of type @xmath26",
    "can always be seen as a term of type @xmath13 , we equip the type system with a subtyping relation as follows : provided that @xmath31 , @xmath32{\\nbang{n}{\\alpha}\\subtype\\nbang{m}{\\alpha } } { } \\qquad \\infer[(\\putype),]{\\nbang{n}{\\putype}\\subtype\\nbang{m } { \\putype } } { } \\\\ \\infer[(\\loli ) , ] {    \\nbang{n}{(a'\\loli b)}\\subtype\\nbang{m}{(a\\loli b ' ) } } {    a\\subtype a ' & b\\subtype b ' } \\qquad \\infer[(\\tensor).]{\\    \\nbang{n}{(a\\tensor b)}\\subtype\\nbang{m}{(a'\\tensor b')}. } {    a\\subtype a ' & b\\subtype b ' } \\end{array}\\ ] ] this relation encapsulates the main properties terms should satisfy with respect to duplicability .",
    "the language consists of the following typed terms , divided into on the one hand , and general terms , or , on the other .",
    "both share a subset of the values , the .",
    "@xmath33    { \\it value}\\ v , w & : : = & u\\bor \\prodterm{v , w } \\bor         \\lettermx{x^a}{v}{w}\\bor        \\nletprodterm{x^a , y^b}{n}{v}{w}\\bor\\\\ & &        \\letunitterm{v}{w } ,        \\\\[2ex ]    { \\it term}\\ m , n & : : = & u        \\bor\\prodterm{m , n}\\bor ( mn ) \\bor        \\nletprodterm{x^a , y^b}{n}{m}{n}\\bor        \\letunitterm{m}{n } , \\end{array}\\ ] ] where @xmath28 is an integer , @xmath34 ranges over a set of constant terms , @xmath35 over a set of term variables and @xmath19 over a set of constant types .",
    "we abbreviate @xmath36 by @xmath37 , @xmath38 by @xmath39 and we omit numerical indexes when they are null .",
    "note that the above terms carry church - style type annotations , as well as integer superscripts ; we call these terms .",
    "we also define a notion of as terms with no index : @xmath40 the erasure operation @xmath41 is defined as the operation of removing the types and integers attached to a given indexed term . if @xmath42 , we say that @xmath43 is an    finally , we define an @xmath19-equivalence on terms , denoted by @xmath44 , in the usual way ( see for example @xcite ) .",
    "before we formally present the type system , let us informally motivate our choice of typing rules .",
    "one non - obvious choice we had to make is for the interaction of pairs and duplicability . unlike previous works with comonads @xcite , we want to think of the type @xmath45 as a type of pairs of elements of type @xmath13 and @xmath23 :",
    "we want to use the same operation to access the components as one would use for a pair of type @xmath24 , without having to use a dereliction operation",
    ".    this immediately raises a concern : consider a pair of elements @xmath46 of type @xmath45 .",
    "are @xmath35 and @xmath47 duplicable ? in the usual linear logic interpretation , they are not .",
    "having a infinite supply of pair of shoes does not mean one has an infinite supply of right shoes : we can not discard the left shoes . on the other hand ,",
    "in our interpretation of `` classical '' data as residing in `` classical '' memory and therefore being duplicable , if the string @xmath46 is duplicable , then so should be the elements @xmath35 and @xmath47 .",
    "in other words , we want the duplication to `` permeate '' the pairing .",
    "the choice of such a `` permeable '' pairing is more or less forced on us by our desire to have no explicit term syntax for structural rules .",
    "consider the following untyped terms , which can be typed if @xmath48 is of type @xmath49 : @xmath50 first , we expect these two terms to be axiomatically equal .",
    "term   should be of type @xmath51 , regardless of the permeability of the pairing : if @xmath52 is duplicable , so should be @xmath53 .",
    "now , consider the term   with a non - permeable pairing . in the naive type system ,",
    "@xmath54 ends up being of type @xmath55 , and the variables @xmath47 and @xmath56 in the final recombination end up being respectively of type @xmath23 and @xmath57 .",
    "it is not possible to make @xmath53 of the duplicable type @xmath58 .",
    "we therefore choose a permeable pairing , which will be reflected , albeit subtly , in the typing rule @xmath59 and @xmath60 in the following section .",
    "a typing judgment is a tuple @xmath61 , where @xmath62 is an indexed term , @xmath13 is a type , and @xmath63 is a typing context . to each constant term @xmath34",
    "we assign a type @xmath64 .",
    "a is a typing judgment that can be derived from the typing rules in table  [ table : typrules ] .",
    "we use the notation @xmath65 for a context where all variables have a type of the form @xmath26 .",
    "finally , when we write a context @xmath66 , we assume the contexts @xmath67 and @xmath63 to be disjoint .    [",
    "table : typrules ]    the following lemmas are proved by structural induction on terms or type derivations as appropriate .",
    "[ lem : duplicvalue ] if @xmath68 is a value such that @xmath69 is a valid typing judgment , then @xmath70 for some context @xmath71 .",
    "[ lem : termvar ] consider the following valid typing judgment : @xmath72 .",
    "then for every free instance @xmath73 in @xmath62 , @xmath74 .    in a typing judgment @xmath61 , a term variable @xmath75 is called if @xmath76 .",
    "[ lem : dummydup ] any dummy variable @xmath35 in @xmath77 satisfies @xmath78 , for some @xmath13 .",
    "conversely , if @xmath79 is valid and if @xmath76 , then for all types @xmath13 the typing judgment @xmath80 is valid .",
    "typing derivations are not unique _ per se_.",
    "however for a given valid typing judgement @xmath61 two typing derivations will only differ with respect to the placement of , namely the unused variables in context .",
    "[ lem : typecastvalue ] suppose @xmath61 is a valid typing judgment , and suppose @xmath81 and @xmath74",
    ". then there exists a canonical valid typing judgment @xmath82 such that @xmath83 .",
    "moreover , if @xmath62 is a value , so is @xmath84 .    by induction on @xmath62 .",
    "we will denote this @xmath84 with @xmath85 .",
    "if @xmath86 or @xmath87 , we omit them for clarity .",
    "[ def : subst ] given two valid typing judgments @xmath88 and @xmath89 where @xmath68 is a value , we define the ( with capture avoiding ) @xmath90:b$ ] as follows : we replace each free instance @xmath73 ( where @xmath74 from lemma  [ lem : termvar ] ) in @xmath62 by @xmath91 .",
    "[ lem : valuesubstisvalue ] in definition  [ def : subst ] , @xmath90:b$ ] is well - typed . also , if @xmath62 is a value , so is @xmath92 $ ] .",
    "proof by structural induction on @xmath62 , using lemmas  [ lem : termvar ] and  [ lem : typecastvalue ] .",
    "we define an equivalence relation on ( indexed ) typing judgments .",
    "we write @xmath93 , or simply @xmath94 , to indicate that @xmath61 and @xmath95 are equivalent .",
    "axiomatic equivalent is defined as the reflexive , symmetric , transitive , and congruence closure of the rules from tables  [ table : eqaxrules ] , so long as both sides of the equivalences are well - typed .",
    "the symbol `` @xmath96 '' is a place holder for @xmath35 , @xmath97 , or @xmath46 .",
    "[ table : eqaxrules ]    the equivalences of table  [ table : eqaxderived ] are derivable .",
    "[ table : eqaxderived ]    the following result stipulates that all the indexations of a given erasure live in the same axiomatic class .",
    "in other words , the axiomatic equivalence class of a term is independent of its indexation .",
    "[ the : eraseimpliesax ] if @xmath83 and if @xmath98 are valid typing judgments , then @xmath94 .",
    "the actual proof is long and technical , and is omitted here for space reasons .",
    "we proceed by first defining a special subset of terms , called _ neutral _",
    "terms , for which the theorem is obvious .",
    "we then prove that every term is axiomatically equivalent to a neutral term via a series of rewrite systems .",
    "as it was advertised , the structure of the categorical semantics will closely follow the one proposed by bierman  @xcite , but with the added twist of a computational monad  la moggi  @xcite . indeed ,",
    "since one has tensor product and a tensor unit , one can expect the categorical model to be symmetric monoidal . since one can construct candidate maps for building a comonad , a comonoid structure for each @xmath26 and coherence maps for the comonad",
    ", we have a linear category .",
    "finally , the computational aspect will be taken care by moggi s computational monad .      in his ph.d .",
    "thesis , bierman  @xcite gives the definition of a .",
    "we prefer here the terminology given in @xcite , and use the concept of .",
    "[ def : lincate ] let @xmath99 be a symmetric monoidal category  @xcite , where @xmath100 , @xmath101 , @xmath102 and @xmath103 are the usual associativity , left unit , right unit and symmetry morphisms .",
    "let @xmath104 be a monoidal comonad  @xcite , where @xmath105 , @xmath106 , @xmath107 and @xmath108 .",
    "we say that @xmath109 is a  @xcite provided that    1 .",
    "each object in @xmath110 of the form @xmath111 is equipped with a commutative comonoid @xmath112 , where @xmath113 and @xmath114 ; 2 .",
    "@xmath115 and @xmath116 are monoidal natural transformations ; 3 .",
    "@xmath117 and @xmath118 are @xmath109-coalgebra morphisms ; 4 .",
    "every map @xmath119 is a comonoid morphism @xmath120 .",
    "the equations for @xmath121@xmath122 are to be found in table  [ table : eqlinexpcom ] .",
    "[ table : eqlinexpcom ]      to capture the computational effect of the probabilistic measurement , we use the notion of , as in @xcite . recall that a over a category @xmath110 is a triple @xmath123 where @xmath124 is a functor , @xmath125 and @xmath126 are natural transformations and such that @xmath127 and @xmath128 . given a map @xmath129",
    ", we define the map @xmath130 by @xmath131 .",
    "[ def : strongmonad ] a over a monoidal category @xmath110 is a monad @xmath123 together with a natural transformation @xmath132 , called the , subject to a number of coherence conditions .    if the category @xmath110 is symmetric , the tensorial strength @xmath48 induces two natural transformations @xmath133 , namely @xmath134 note that @xmath135 and @xmath136 might not be equal : the map @xmath135 `` evaluates '' the first variable and then the second one .",
    "the map @xmath136 does the opposite .",
    "the strength is called if @xmath137 .",
    "[ lem : strongmonadmonoidal ] if @xmath138 is a strong monad on a symmetric monoidal category @xmath110 , then @xmath139 and @xmath140 are monoidal monad .",
    "[ def : texponential ] a symmetric monoidal category @xmath141 together with a strong monad @xmath123 is said to have  @xcite , or , if it is equipped with a bifunctor @xmath142 , and a natural isomorphism @xmath143    the map @xmath144 induces a natural transformation @xmath145 defined by @xmath146 .",
    "a comonad @xmath147 on some category is said to be if @xmath148 is an isomorphism .",
    "a monoidal comonad @xmath104 is if @xmath149 and @xmath150 are isomorphisms .",
    "[ def : idempcanon ] given a monoidal category @xmath141 with an idempotent , strong monoidal comonad @xmath147 , a bifunctor @xmath151 , we define a by induction : for all objects @xmath13 , the arrows @xmath152 , @xmath153 , @xmath119 , @xmath154 and @xmath150 are canonical .",
    "all are also canonical .",
    "an expansion of an arrow @xmath155 is defined to be either @xmath156 or any of @xmath157,@xmath158 , @xmath159 , @xmath160 , @xmath161 , where @xmath162 is an expansion of @xmath156 and @xmath163 ranges over the objects of the category .",
    "finally , compositions of canonical arrows are also canonical .",
    "[ the : ciposet ] given a category @xmath110 with the structure in definition  [ def : idempcanon ] , if @xmath164 are two canonical arrows with respect to duplication , then they are equal .",
    "we now have enough background to define a candidate for the categorical model of the language we describe in section  [ sec : language ] .",
    "a is a category @xmath110 with the following structure :    * a symmetric monoidal structure @xmath165 ; * an idempotent , strongly monoidal , linear exponential comonad @xmath166 @xmath167 ; * a strong monad @xmath168 ; * a kleisli exponential @xmath169 .",
    "the is defined to be the kleisli category @xmath170 , as defined in  @xcite .",
    "a linear category for duplication gives rise to a double adjunction here the left adjunction arises from the co - kleisli category @xmath171 of the comonad @xmath109 .",
    "it is as in the linear - non - linear models of @xcite , and @xmath171 is a category of classical ( non - quantum ) values .",
    "the right adjunction arises from the kleisli category @xmath172 of the computational monad @xmath10 , as in @xcite . here",
    "@xmath172 is a category of ( effectful ) quantum computations .",
    "[ table : yaqmap ]    [ def : yaq ] we can define a category @xmath173 as follows : objects are types , and arrows @xmath174 are axiomatic classes of valid typing judgments of the form @xmath175 , where @xmath68 is a value .",
    "we define the composition of arrows @xmath175 and @xmath176 to be @xmath177 .",
    "the identity on @xmath13 is set to be the arrow @xmath178 .",
    "[ lem : yaq ] the category @xmath173 is well - defined .",
    "the composition of two arrows yields an arrow axiomatically equivalent to a value due to axiom @xmath179 and lemma  [ lem : valuesubstisvalue ] .",
    "composition is associative due to axiom @xmath180 .",
    "the arrow @xmath178 is indeed the identity on @xmath13 due to axioms @xmath181 and @xmath182 .",
    "[ lem : promote ] given a valid typing judgment @xmath183 where @xmath68 is a value , there exists a canonical value @xmath184 such that @xmath185 and such that @xmath186 .",
    "we denote this @xmath184 by @xmath187 .    by induction on @xmath68 .",
    "[ lem : bangexaq ] if @xmath188 , and if @xmath189 and @xmath190 , then @xmath191 .    by induction on @xmath192 .",
    "if we define @xmath193 and @xmath194 , together with the maps and the operations on maps defined in table  [ table : yaqmap ] , @xmath173 is a linear category for duplication .",
    "the proof is mainly a long list of verifications .",
    "it uses theorem  [ the : eraseimpliesax ] , lemmas  [ lem : yaq ] , [ lem : promote ] and  [ lem : bangexaq ] .",
    "the lambda - calculus defined in section  [ sec : language ] is thought as a lambda - calculus .",
    "using moggi s technique , we split the interpretation of the language into the interpretation of the in a linear category for duplication @xmath110 and the interpretation of the , i.e. general terms , in its kleisli category @xmath172 . without loss of generality , for notation purposes",
    ", we assume the category to be strictly monoidal .",
    "we define an to be a map @xmath195 that assigns to each constant type @xmath19 an object @xmath196 .",
    "each type @xmath13 is interpreted as an object of @xmath110 : @xmath197 , @xmath198 , @xmath199 , @xmath200 and @xmath201 .    given a valid subtyping @xmath202 , there exists a canonical arrow @xmath203 in @xmath110 with respect to duplication , as defined in definition  [ def : idempcanon ] .",
    "moreover , this arrow is unique by theorem  [ the : ciposet ] .",
    "we extend the map @xmath195 to interpret @xmath202 as this unique arrow and we denote it by @xmath204 .",
    "we use the following straightforward shortcut definitions , where @xmath205 are types and @xmath63 , @xmath67 and @xmath206 are typing contexts :    * @xmath207 . * given @xmath208 and @xmath209 , we define the map @xmath210 . *",
    "given a natural transformation @xmath211 , if @xmath212 we define @xmath213 .",
    "[ def : langdenot ] the map @xmath195 is said to be an if moreover it assigns to each constant term @xmath214 an arrow @xmath215 in @xmath110 .    given a linear category for duplication @xmath110 , it is possible to interpret the typing derivation of a well - typed value as a map in @xmath110 and the typing derivation of a valid computation as a map in the kleisli category @xmath172 .",
    "we define them inductively .    *",
    "if @xmath216 is a value with typing derivation @xmath217 , its @xmath218 is an arrow @xmath219 ; * if @xmath220 is a term with typing derivation @xmath217 , its @xmath221 is an arrow @xmath222 .",
    "table  [ table : modelcorevaluejudg ] formulates the definition in the simple case where the contexts @xmath63 , @xmath223 and @xmath224 contain only one variable .",
    "one can easily extend this to the general setting .",
    "[ table : modelvaluejudg ] [ table : modelcorevaluejudg ] [ table : modelcompjudg ]    as we already noted in section  [ sec : typjudg ] , a valid typing judgment does not have a unique typing tree _ per se_.",
    "however the following result holds :    given a valid typing judgment with two typing derivations @xmath217 and @xmath225 , for any interpretation @xmath195 we have @xmath226 ( and @xmath227 if the typing judgment is a value ) .    the proof is done by showing that given any typing judgment @xmath61 with denotation @xmath156 one can factor @xmath156 as @xmath228 , where @xmath229 is the denotation of @xmath230 , where @xmath231 and @xmath232 is the set of dummy variables .    [",
    "def : typjudgdenot ] given a interpretation @xmath195 of the language in a category @xmath110 , we define the denotation of a valid typing judgment @xmath61 with typing derivation @xmath217 to be @xmath233 and @xmath234 if @xmath62 is a value .",
    "[ lem : valuemonad ] suppose that @xmath183 is a valid typing judgment where @xmath68 is a value",
    ". then @xmath235 .",
    "proof by induction on @xmath68 , using lemma  [ lem : strongmonadmonoidal ] , the bifunctoriality of @xmath236 and the equations for strong monadicity in definition  [ def : strongmonad ] .      the axiomatic equivalence and the categorical semantics are two faces of the same coin .",
    "indeed , as we will prove in this section , two terms in the same axiomatic equivalence class have the same denotation .",
    "a corollary is that the indexation of terms does not influence the denotation .",
    "this proves semantically the fact that it is safe to work with untyped terms . an alternate justification of",
    "this fact is of course the operational semantics , which was given in @xcite .",
    "[ lem : denottypecast ] suppose @xmath237 . then @xmath238 .",
    "if @xmath239 is a value , from lemma  [ lem : typecastvalue ] , @xmath240 is a value .",
    "then @xmath241 .",
    "proof by structural induction on @xmath62 .",
    "[ lem : substitution ] given two valid typing judgments @xmath242 and @xmath243 , the typing judgment @xmath244:b$ ] is valid .",
    "let @xmath245 be @xmath246:b}^c$ ] and @xmath247 be @xmath248:b}^v$ ] , in the case where @xmath249 is a value .",
    "then they are defined by +    proof by induction on @xmath62 , using lemma  [ lem : duplicvalue ] , lemma  [ lem : valuemonad ] and the naturality of @xmath144 .",
    "[ the : aximpliesdenot ] if @xmath93 then @xmath250 ( and @xmath251 if @xmath62 is a value ) for every interpretation @xmath195 .",
    "proof by induction on @xmath94 , using lemmas  [ lem : denottypecast ] and  [ lem : substitution ] .",
    "[ cor : erasuredenot ] if @xmath83 and if @xmath98 are valid typing judgments , then @xmath252 ( and @xmath253 if @xmath62 is a value ) .",
    "corollary of theorems  [ the : eraseimpliesax ] and  [ the : aximpliesdenot ] .",
    "the category @xmath173 being a linear category for duplication , one can interpret the language in it .",
    "this section states that the defined lambda - calculus is an of linear categories for duplication .",
    "since the category @xmath173 is a monoidal category , one can w.l.o.g .",
    "generalize the notion of pairing to finite tensor products of terms .",
    "then the following results are true :    [ lem : yaqcomplete ] in @xmath173 , a valid typing judgment @xmath254 has for computational denotation @xmath255 . if @xmath239 is a value , the value interpretation is @xmath256 .",
    "proof by structural induction on @xmath62 and @xmath68 .    in @xmath173 ,",
    "@xmath195 being the identity , one has @xmath257 and @xmath258 .",
    "corollary of lemma  [ lem : yaqcomplete ]",
    "as noted in the introduction , this paper is mostly concerned with the categorical requirements for modeling a generic call - by - value linear lambda calculus , i.e. , its type system ( which includes subtyping ) and equational laws .",
    "we have not yet specialized the language to a particular set of built - in operators , for example , those that are required for quantum computation .    however , since the quantum lambda calculus @xcite is the main motivation behind our work , we will comment very briefly on what additional properties would be required to interpret its primitives .",
    "the quantum lambda calculus is obtained by instantiating and extending the call - by - value language of this paper with the following primitive types , constants , and operations :    [ cols= \" < , < \" , ]     here , @xmath259 ranges over a set of built - in unitary operations . in the intended semantics , @xmath260 , while @xmath261 is empty .",
    "@xmath262 creates a new qubit , and @xmath263 measures a qubit .",
    "the denotational semantics of these operations is already well - understood in the absence of higher - order types .",
    "they can all be interpreted in the category @xmath264 of superoperators from @xcite .",
    "the part that is not yet well - understood is how these features interact with higher - order types .    in light of our present work",
    ", we can conclude that a model of the quantum lambda calculus consists of a linear category for duplication @xmath265 , such that the associated category of computations @xmath170 contains the category @xmath264 of @xcite as a full monoidal subcategory . to construct an actual instance of such a model",
    "is still an open problem .",
    "we have developed a call - by - value , computational lambda - calculus for manipulating duplicable and non - duplicable data , together with an axiomatic equivalence relation on typed terms .",
    "we use a subtyping relation in order to have implicit promotion , dereliction , copying and discarding .",
    "then we developed categorical model for the language , inspired by the work of @xcite and @xcite .",
    "we finally showed that the model is sound and complete with respect to the axiomatic equivalence .",
    "benton , n. : a mixed linear and non - linear logic : proofs , terms and models ( extended abstract ) . in : proceedings of csl94 , selected papers .",
    "volume 933 of lecture notes in computer science .",
    "( 1994 ) 121135      benton , n. , bierman , g. , hyland , m. , de  paiva , v.c.v . :",
    "linear lambda - calculus and categorical models revisited . in : proceedings of csl92 , selected papers .",
    "volume 702 of lecture notes in computer science ."
  ],
  "abstract_text": [
    "<S> we give a categorical semantics for a call - by - value linear lambda calculus . </S>",
    "<S> such a lambda calculus was used by selinger and valiron as the backbone of a functional programming language for quantum computation . </S>",
    "<S> one feature of this lambda calculus is its linear type system , which includes a duplicability operator `` @xmath0 '' as in linear logic . </S>",
    "<S> another main feature is its call - by - value reduction strategy , together with a side - effect to model probabilistic measurements . </S>",
    "<S> the `` @xmath0 '' operator gives rise to a comonad , as in the linear logic models of seely , bierman , and benton . </S>",
    "<S> the side - effects give rise to a monad , as in moggi s computational lambda calculus . </S>",
    "<S> it is this combination of a monad and a comonad that makes the present paper interesting . </S>",
    "<S> we show that our categorical semantics is sound and complete . </S>"
  ]
}