{
  "article_text": [
    "quantum computation makes it possible to achieve polynomial complexity for many classical problems that are believed to be hard @xcite . to preserve coherence , quantum operations need to be protected by quantum error correcting codes ( qeccs ) @xcite . with error probabilities in elementary gates below a certain threshold ,",
    "one can use multiple layers of encoding ( concatenation ) to reduce errors at each level and ultimately make arbitrarily - long quantum computation possible @xcite .",
    "the actual value of the threshold error probability strongly depends on the assumptions of the error model and on the chosen architecture , and presently varies from @xmath3 for a chain of qubits with nearest - neighbor couplings @xcite and @xmath4 for qubits with nearest - neighbor couplings in two dimensions @xcite , to @xmath5 with postselection @xcite , or even above @xmath6 if additional constraints on errors are imposed @xcite .",
    "the quoted estimates have been made using stabilizer codes , an important class of codes which originate from additive quaternary codes , and have a particularly simple structure based on abelian groups @xcite .",
    "recently , a more general class of codeword stabilized ( cws ) quantum codes was introduced in refs .",
    "this class includes stabilizer codes , but is more directly related to non - linear classical codes .",
    "this direct relation to classical codes is , arguably , the most important advantage of the cws framework . specifically , the classical code associated with a given cws quantum code has to correct certain error patterns induced by a graph associated with the code .",
    "the graph also determines the graph state @xcite serving as a starting point for an encoding algorithm exploiting the structure of the classical code @xcite . with the help of powerful techniques from the theory of classical codes , already several new families of non - additive codes",
    "have been discovered , including codes with parameters proven to be superior to any stabilizer code @xcite .",
    "both classical additive codes and additive quantum codes can be corrected by first finding the syndrome of a corrupted vector or quantum state , respectively , and then looking up the corresponding error ( coset leader ) in a precomputed table @xcite .",
    "this is not the case for non - linear codes .",
    "in fact , even the notions of a syndrome and a coset become invalid for general non - linear codes . furthermore , since quantum error correction must preserve the original quantum state in all intermediate measurements , it is more restrictive than many classical algorithms .",
    "therefore , the design of a useful cws code must be complemented by an efficient quantum error correction algorithm .",
    "the goal of this work is to address this important unresolved problem for binary cws codes .",
    "first , we design a procedure to _ detect _ an error in a narrower class , the _ union stabilizer _ ( ust ) codes , which possess some partial group structure @xcite .",
    "then , for a general cws code and a set of graph - induced maps of correctable errors forming a group , we construct an auxiliary ust code which is the union of the images of the original cws code shifted by all the elements of the group .",
    "finally , we construct abelian groups associated with correctable errors located on certain _ index sets _ of qubits .",
    "the actual error is found by first applying error - detection to locate the index set with the relevant auxiliary ust code , then using a collection of smaller ust codes to pinpoint the error in the group .",
    "since we process large groups of errors simultaneously , we make a significant reduction of the number of measurements compared with the brute force error correction for non - linear ( quantum or classical ) codes .",
    "more precisely , we consider an arbitrary distance-@xmath7 cws code @xmath8 that uses @xmath0 qubits to encode a hilbert space of dimension @xmath9 and can correct all @xmath1-qubit errors , where @xmath10 . in sec .",
    "[ sec : background ] we give a brief overview of the notations and relevant facts from the theory of quantum error correction . then in sec .",
    "[ sec : generic ] , we construct a reference recovery algorithm that deals with errors individually .",
    "this algorithm requires up to @xmath11 measurements , where @xmath12 is the total number of errors of size up to @xmath1 ( this bound is tight for non - degenerate codes ) .",
    "each of these measurements requires up to @xmath13 two - qubit gates . in order to eventually reduce the overall complexity",
    ", we consider the special case of ust codes in sec .",
    "[ sec : ust - measurement ] .",
    "here we design an error - detecting measurement for a ust code with a translation set of size @xmath9 that requires @xmath14 two - qubit gates to identify a single error .",
    "our error grouping technique presented in sec .",
    "[ sec : clusters ] utilizes such a measurement to check for several errors at once . for",
    "additive cws codes the technique reduces to stabilizer - based recovery [ sec .",
    "[ sec : additive ] ] . in the case of generic cws codes",
    "[ sec : generic - cws ] ] , we can simultaneously check for all errors located on size-@xmath1 qubit clusters ; graph - induced maps of these errors form groups of size up to @xmath15 .",
    "searching for errors in blocks of this size requires up to @xmath16 measurements to locate the cluster , plus up to @xmath17 additional measurements to locate the error inside the group . in sec .",
    "[ sec : conclusions ] we discuss the obtained results and outline the directions of further study . finally ,",
    "in appendix  [ app : orthogonality ] we consider some details of the structure of corrupted spaces for the codes discussed in this work .",
    "note that some of the reported results have been previously announced in ref .",
    "throughout the paper , @xmath18 denotes the complex hilbert space that consists of all possible states @xmath19 of a single qubit , where @xmath20 and @xmath21 correspondingly , we use the space @xmath22 to represent any @xmath0-qubit state .",
    "also , @xmath23 denotes the pauli group of size @xmath24 , where @xmath25 , @xmath26 , @xmath27 are the usual ( hermitian ) pauli matrices and @xmath28 is the identity matrix .",
    "the members of this group are called pauli operators ; the operators in ( [ eq : pauli - group ] ) with @xmath29 form a basis of the vector space that consists of all operators acting on @xmath0-qubit states .",
    "the _ weight _",
    "@xmath30 of a pauli operator @xmath31 is the number of terms in the tensor product  ( [ eq : pauli - group ] ) which are not a scalar multiple of identity .",
    "up to an overall phase , a pauli operator can be specified in terms of two binary strings , @xmath32 and @xmath33 , @xmath34 hermitian operators in @xmath35 have eigenvalues equal to @xmath36 or @xmath37 .",
    "generally , unitary operators ( which can be outside of the pauli group ) which are also hermitian , i.e. , all eigenvalues are @xmath38 , will be particularly important in the discussion of measurements .",
    "we will call these operators _ measurement operators_. indeed , for such an operator @xmath39 , a measurement gives a boolean outcome and can be constructed with the help of a single ancilla , two hadamard gates , and a controlled @xmath39 gate @xcite ( see fig .",
    "[ fig : measurementm ] ) .",
    "the algebra of measurement operators is related to the algebra of projection operators discussed in @xcite , but the former operators , being unitary , are more convenient in circuits .     with all eigenvalues @xmath38 .",
    "the first hadamard gate prepares the ancilla in the state @xmath40 , hence @xmath41 .",
    "the controlled-@xmath39 gate returns @xmath42 .",
    "the second hadamard gate finishes the incomplete measurement , @xmath43 , where we used the projector identities  ( [ eq : projector - identities ] ) .",
    "if the outcome of the ancilla measurement is @xmath44 , the result is the projection of the initial @xmath0-qubit state @xmath45 onto the @xmath46 eigenspace of @xmath39 ( @xmath47 ) , otherwise it is the projection onto the @xmath37 eigenspace of @xmath39 ( @xmath48 ) . for an input state @xmath49 with ancilla in the state @xmath50 , the circuit returns @xmath51 . ]    a measurement of an observable defined by a pauli operator @xmath39 will be also called pauli measurement @xcite . for lack of a better term , other measurements will be called _ non - pauli _ ; typically the corresponding circuits are much more complicated than those for pauli measurements .",
    "we say that a state @xmath52 is stabilized ( anti - stabilized ) by a measurement operator @xmath39 if @xmath53 ( @xmath54 . the corresponding projectors onto the positive and negative eigenspace are denoted by @xmath55 and @xmath56 , respectively ; they satisfy the identities @xmath57    we say that a space @xmath58 is stabilized by a set of operators @xmath59 if each vector in @xmath58 is stabilized by each operator in @xmath59 .",
    "we use @xmath60 to denote the maximum space stabilized by @xmath59 , and @xmath61 to denote the corresponding orthogonal complement . for a set @xmath59 of measurement operators ,",
    "each state in @xmath61 is anti - stabilized by some operator in @xmath59 .",
    "when discussing complexity , we will quote the two - qubit complexity which just counts the total number of two - qubit gates .",
    "thus , we ignore any communication overhead , as well as any overhead associated with single - qubit gates .",
    "for example , the complexity of the measurement in fig .",
    "[ fig : measurementm ] is just that of the controlled-@xmath39 gate operating on @xmath62 qubits @xcite .",
    "for all circuits we discuss , the total number of gates ( single- and two - qubit ) is of the same order in @xmath0 as the two - qubit complexity .",
    "a general @xmath0-qubit quantum code @xmath58 encoding @xmath9 quantum states is a @xmath9-dimensional subspace of the hilbert space @xmath63 .",
    "let @xmath64 be an orthonormal basis of the @xmath9-dimensional code @xmath58 and let @xmath65 be some set of pauli errors .",
    "the overall phase of an error [ @xmath66 in eq .",
    "( [ eq : pauli - group ] ) ] is irrelevant and will be largely ignored .",
    "the code detects all errors @xmath67 if and only if @xcite @xmath68 where @xmath69 only depends on the error @xmath31 , but is independent of the basis vectors @xcite .",
    "the code has distance @xmath7 if it can detect all pauli errors of weight @xmath70 , but not all errors of weight @xmath7 .",
    "such a code is denoted by @xmath8 .",
    "the necessary and sufficient condition for correcting errors in @xmath71 is that all non - trivial combinations of errors from @xmath71 are detectable .",
    "this gives @xcite @xmath72 where @xmath73 and , again , @xmath74 is the same for all basis states @xmath75 , @xmath76 .",
    "a distance-@xmath7 code corrects all errors of weight @xmath77 such that @xmath78 , that is , @xmath79 .",
    "the code is _ non - degenerate _ if linearly independent errors from @xmath80 produce corrupted spaces @xmath81 whose intersection is trivial ( equals to @xmath82 ) ;",
    "otherwise the code is _ degenerate _",
    "@xcite . a stricter condition that the code is _ pure _ ( with respect to @xmath71 )",
    "requires that the corrupted spaces @xmath83 and @xmath84 be mutually orthogonal for all linearly independent correctable errors @xmath85 , @xmath86 .    for a degenerate code",
    ", we call a pair of correctable errors @xmath87 _ mutually - degenerate _ if the corrupted spaces @xmath83 and @xmath84 coincide .",
    "such errors belong to the same _ degeneracy class_. for recovery , one only needs to identify the degeneracy class of the error that happened .",
    "the operators like @xmath88 , connecting mutually - degenerate correctable errors @xmath85 and @xmath89 , have no effect on the code and can be ignored .    as shown in appendix  [ app : orthogonality ] , for all codes discussed in this work , any two correctable errors @xmath85 , @xmath89 yield corrupted spaces @xmath83 , @xmath84 that are either identical or orthogonal .",
    "then , errors from different degeneracy classes take the code to corrupted spaces that are mutually orthogonal .",
    "also , for these codes , a non - degenerate code is always pure . in terms of the error correction condition  ( [ sncondtion - correcting ] )",
    ", we have @xmath90 for errors @xmath85 , @xmath89 in different degeneracy classes and @xmath91 for errors in the same degeneracy class .",
    "stabilizer codes @xcite are a well known family of quantum error - correcting codes that are analogous to classical linear codes .",
    "an @xmath92 $ ] stabilizer code maps a @xmath93-dimensional @xmath94-qubit state space into a @xmath93-dimensional subspace of an @xmath0-qubit state space .",
    "the code is defined as the space stabilized by an abelian subgroup of the @xmath0-qubit pauli group , @xmath95 , with @xmath96 hermitian generators , @xmath97 .",
    "for such a space to exist , it is necessary that @xmath98 .",
    "the abelian group @xmath99 is called the _ stabilizer _ of @xmath58 .",
    "explicitly , @xmath100 the code @xmath58 is stabilized by @xmath99 iff it is stabilized by all @xmath96 generators @xmath101 . in other words , it is an intersection of subspaces stabilized by @xmath102 , @xmath103    the _ normalizer _ of @xmath99 in @xmath104 , denoted as @xmath105 , is the group of all pauli operators @xmath106 which fix @xmath99 under conjugation ( @xmath107 for all @xmath108 ) .",
    "the term _ normalizer _ reflects the fact that these operators commute with @xmath99 @xcite .",
    "it is possible to construct @xmath109 logical operators @xmath110 , @xmath111 , @xmath112 , with the usual commutation relations , that together with the generators of @xmath99 generate the normalizer ( modulo an overall phase factor ) @xcite . the @xmath113 generators @xmath102 of the stabilizer , along with the @xmath94 operators @xmath111 , generate a subgroup @xmath114 of @xmath104 which becomes a maximal abelian subgroup when including the generator @xmath115 .",
    "the group @xmath99 stabilizes a unique state latexmath:[\\[|s\\rangle\\equiv    operators @xmath110 acting on @xmath117 generate the basis of the code , @xmath118    generally , each detectable pauli error @xmath119 that acts non - trivially on the code anti - commutes with at least one generator @xmath101 , and errors from different degeneracy classes anti - commute with different subsets of @xmath99 .",
    "we can thus identify a degeneracy class by the set of generators @xmath102 which anti - commute with it .",
    "the corrupted code space @xmath120 is anti - stabilized by those generators @xmath101 that anti - commute with @xmath121 .",
    "indeed , @xmath122 which means that the measurement @xmath101 of gives @xmath37 . by measuring all @xmath101",
    ", we get the _ syndrome _ that consists of @xmath96 numbers @xmath36 or @xmath37 .",
    "there are in total @xmath123 possible syndromes identifying different error degeneracy classes , including the trivial error @xmath124 which corresponds to the all - one syndrome vector .",
    "any two corrupted spaces @xmath125 and @xmath126 are mutually orthogonal or identical .",
    "the whole @xmath127-dimensional @xmath0-qubit state space @xmath63 is thus divided into @xmath128 orthogonal @xmath93-dimensional subspaces @xmath129 , @xmath130 the representatives of different error classes can be chosen to commute with each other and with the logical operations @xmath131 .",
    "these representatives form an abelian group @xcite @xmath132 whose generators @xmath133 can be chosen to anti - commute with only one of the generators of the stabilizer each , @xmath134 ( this follows from proposition 10.4 in ref .",
    "altogether , the generators @xmath135 can be regarded as a set of pauli operators forming the basis of the cosets of the normalizer @xmath105 of the code @xmath58 in @xmath104 .",
    "* example 1 . *",
    "the @xmath136 $ ] stabilizer code is defined by the generators @xmath137 for this code , the logical operators can be taken as @xmath138 a basis of the code space is ( up to normalization ) latexmath:[\\[|\\bar{0}\\rangle = \\prod_{i=1}^{4}{(\\openone+g_{i})}|00000\\rangle , \\quad    basis states are stabilized by the generators @xmath101 .",
    "the corresponding stabilizer group is @xmath140 .",
    "the group of equivalence classes of correctable errors is generated by the representatives ( note the mixed notation , e.g. , @xmath141 ) @xmath142 the @xmath143 are chosen to commute with the logical operators and also to satisfy @xmath144 .",
    "note that the operators of weight one forming the correctable error set do not by themselves form a group .",
    "the generators @xmath133 can be used to map correctable errors to the corresponding group elements with the same syndrome .",
    "this gives , e.g. , @xmath145 , @xmath146 , @xmath147 .",
    "@xmath148      the decomposition  ( [ eq : subspace - decomposition ] ) can be viewed as a constructive definition of the abelian group @xmath149 of all _ translations _ of the original stabilizer code @xmath58 in @xmath104 .",
    "( in the following , this stabilizer code is denoted @xmath150 . )",
    "any two non - equivalent translations @xmath151 belong to different cosets of the normalizer @xmath152 of the code @xmath153 in @xmath104 and , therefore , yield mutually orthogonal shifts@xmath154 a union stabilizer code @xcite ( ust ) is a direct sum@xmath155 of @xmath9 shifts of the code @xmath153 by non - equivalent translations @xmath156 , @xmath157 .",
    "the basis of the code defined by ( [ eq : ust - defined ] ) is the union of the sets of basis vectors of all @xmath158 . as a result ,",
    "the dimension of @xmath58 is @xmath159 .",
    "this code is then denoted @xmath160 , where @xmath7 is the distance of the new code .",
    "generally , this distance does not exceed the distance of the original code with respect to the same error set , @xmath161 .",
    "however , if the code @xmath58 is degenerate and the original code @xmath153 is one - dimensional , this need not be true .      the unique state @xmath117 defined by eq .",
    "( [ eq : stabilized - state ] ) itself forms a single - state stabilizer code @xmath162 $ ] .",
    "its stabilizer @xmath163 has exactly @xmath0 mutually commuting generators .",
    "note that for stabilizer states we follow the convention that the distance @xmath164 is given by the minimum weight of the non - trivial elements of the stabilizer @xmath99 . generally , such a state stabilized by an abelian subgroup in @xmath104 of order @xmath165 ( which does not include @xmath166 ) is called a _ stabilizer state _ @xcite .    a _ graph state",
    "@xcite is a stabilizer state of a group whose @xmath0 mutually commuting generators @xmath167 are defined by a ( simple ) @xmath0-vertex graph @xmath168 with an adjacency matrix @xmath169 .",
    "specifically , the generators are @xmath170 where @xmath171 , @xmath172 denotes the @xmath75th row of the adjacency matrix @xmath173 .",
    "a graph state can be efficiently generated @xcite by first initializing every qubit in the state @xmath174 ( e.g. , applying the hadamard gate on @xmath175 ) , and then using a controlled-@xmath27 gate @xmath176 on every pair @xmath177 of qubits corresponding to an edge of the graph @xmath178 , @xmath179 where @xmath180 is a state with all @xmath0 qubits in state @xmath175 .",
    "any stabilizer state is locally clifford - equivalent ( lc - equivalent ) to a graph state @xcite .",
    "that is , any stabilizer state can be transformed into a graph state by individual discrete rotations of the qubits .",
    "this defines the canonical form of a stabilizer state .",
    "vertices and ( b ) @xmath181 vertices . ]",
    "* example 2 . *",
    "consider the ring graph for @xmath182 [ fig .",
    "[ fig : tria](a ) ] which defines the stabilizer generators @xmath183 , @xmath184 , @xmath185 .",
    "the corresponding stabilizer state @xmath186 is an equal superposition of all @xmath187 states [ result of the hadamard gates in eq .",
    "( [ stabilizedstate ] ) ] , taken with positive or negative signs depending on the number of pairs of ones at positions connected by the edges of the graph [ result of the gates @xmath188 . in the following expressions we omitted normalization for clarity : @xmath189      codeword stabilized ( cws ) codes @xcite represent a general class of non - additive quantum codes that also includes stabilizer codes .",
    "they can be viewed as ust codes originating from a stabilizer state .",
    "any cws code is locally clifford - equivalent to a cws code which originates from a graph state @xcite .",
    "specifically , a cws code @xmath8 in _ standard form _",
    "@xcite is defined by a graph @xmath168 with @xmath0 vertices and a classical code @xmath190 containing @xmath9 binary codewords @xmath191 .",
    "the originating stabilizer state is the graph state @xmath117 defined by @xmath168 , and the _ codeword operators _ [ translations in eq .",
    "( [ eq : ust - defined ] ) ] have the form @xmath192 , @xmath157 . for a cws code in standard form",
    "we use the notation @xmath193 .    an important observation made in ref .",
    "@xcite is that a single qubit error @xmath25 , @xmath27 , or @xmath26 acting on a code state @xmath194 is equivalent ( up to a phase ) to an error composed only of @xmath27 operators .",
    "this establishes the following mapping between multi - qubit errors and classical binary errors .",
    "first , let @xmath195 be an error acting on the @xmath75th qubit of @xmath196 .",
    "then we see that @xmath197 where the term @xmath198 consists only of operators @xmath27 .",
    "the general mapping of an error @xmath199 from the error set @xmath200 to a classical error vector in @xmath201 is defined as @xmath202 where @xmath203 is the @xmath204th component of the vector @xmath205 .",
    "we will refer to both the binary vector @xmath206 and the operator @xmath207 as the _ graph image _ of the pauli operator @xmath31 .",
    "theorem 3 from ref .",
    "@xcite establishes the correspondence between the error - correcting properties of a quantum code @xmath58 and those of the corresponding classical code @xmath190 .",
    "it states that a cws code ( in standard form ) given by a graph @xmath168 and word operators @xmath208 detects errors in the set @xmath71 if and only if the classical code @xmath190 detects errors from the set @xmath209 , and for each @xmath67 , @xmath210 the code @xmath58 is non - degenerate ( and also pure , see appendix  [ app : orthogonality ] ) iff condition  ( [ bei11 ] ) is satisfied for all errors in @xmath71 @xcite . for a degenerate code , condition  ( [ bei12 ] ) needs to be ensured for errors that do not satisfy eq .  ( [ bei11 ] ) .",
    "the beauty of the cws construction is that , for a given code in standard form , we no longer need to worry about possible degeneracies .",
    "the classical error patterns induced by the function @xmath211 also separate the errors into corresponding degeneracy classes @xcite .",
    "the cws framework is general enough to also include all stabilizer codes @xcite .",
    "specifically , a stabilizer code @xmath92 $ ] with the stabilizer @xmath212 and logical operators @xmath213 , @xmath131 , corresponds to a cws code with the stabilizer @xmath214 and the codeword operator set @xmath215 forming a group of size @xmath216 .",
    "generally , an lc transformation is required to obtain standard form of this code .",
    "conversely , an additive cws code @xmath217 where the codeword operators form an abelian group ( in which case @xmath216 with integer @xmath94 ) is a stabilizer code @xmath92 $ ] @xcite . in sec .",
    "[ sec : conversion ] we show that the @xmath96 generators @xmath102 of the stabilizer can be obtained from the graph - state generators @xmath167 [ eq .  ( [ eq : canonical - generators ] ) ] by a symplectic gram - schmidt orthogonalization procedure @xcite which has no effect on the codeword operators .",
    "* example 3 . *",
    "consider a non - degenerate cws code @xmath218 .",
    "the corresponding ring graph is illustrated in fig .",
    "[ fig : tria](b ) ( ref .  @xcite ) .",
    "the @xmath219 generators of the stabilizer @xmath99 are @xmath220 and its four cyclic permutations .",
    "the corresponding stabilizer state has a structure similar to eq .",
    "( [ eq : s3 ] ) , but with more terms .",
    "word operators have the form @xmath221 , with the classical codewords @xmath222    @xmath223    * example 4 . * to express the @xmath136 $ ] stabilizer code",
    "[ see example 1 ] as a @xmath224 cws code in standard form , we explicitly construct alternative generators @xmath167 of the stabilizer @xmath225 [ eq .  ( [ eq : stab1 ] ) ] to contain only one @xmath25 operator each .",
    "we obtain @xmath226 and its four cyclic permutations .",
    "this does not require any qubit rotations due to a slightly unconventional choice of the logical operators in eq .",
    "( [ eq : logical513 ] ) .",
    "the corresponding graph is the ring @xcite , see fig .",
    "[ fig : tria](b ) .",
    "the codeword operators are @xmath227 , which by eq .",
    "( [ eq : logical513 ] ) correspond to classical binary codewords @xmath228 .",
    "note that the error map induced by the graph is different from the mapping to group elements in example 1 ; in particular , @xmath229 , @xmath230 , @xmath231.@xmath223",
    "in this section we construct a generic recovery algorithm which can be adapted to any non - additive code . to our best knowledge ,",
    "such an algorithm has not been explicitly constructed before .",
    "the basic idea is to construct a non - pauli measurement operator @xmath232 , where @xmath233 is the projector onto the code @xmath58 spanned by the orthonormal basis @xmath234 .",
    "the measurement operator is further decomposed using the identity @xmath235    we use the graph state encoding unitary @xmath236 from eq .",
    "( [ stabilizedstate ] ) and the following decomposition @xcite of the standard - form basis of the cws code in terms of the graph state @xmath117 and the classical states @xmath237 : @xmath238 the measurement operator @xmath239 is rewritten as a product @xmath240 where the measurement operator @xmath241 stabilizes the orthogonal complement of the classical state @xmath242 .",
    "the components of the binary vector @xmath243 are the respective complements of @xmath244 , @xmath245 .",
    "the operator in the parentheses in eq .",
    "( [ eq : factorizationmirror1 ] ) is the @xmath246-controlled @xmath27 gate ( the @xmath27-operator is applied to the @xmath0-th qubit only if all the remaining qubits are in state @xmath247 ) .",
    "it can also be represented as @xmath0-qubit controlled phase gate @xmath248 with @xmath249 , where the operator @xmath250 projects onto the state @xmath251 .",
    "this can be further decomposed as a product of two hadamard gates and an @xmath246-controlled cnot gate [ fig .",
    "[ fig : cz - decomposition ] ] which for @xmath252 can be implemented in terms of one ancilla and @xmath253 three - qubit toffoli gates @xcite and therefore has linear complexity in @xmath0 . with no ancillas ,",
    "the complexity of the @xmath246-controlled cnot gate is @xmath254 @xcite .",
    "-qubit controlled-@xmath27 gate @xmath255 in terms of @xmath246-controlled cnot gate ( @xmath0-qubit toffoli gate ) for @xmath182 . ]",
    "the corresponding ancilla - based measurement for @xmath256 can be constructed with the help of two hadamard gates [ fig .",
    "[ fig : measurementm ] ] by adding an extra control to each @xmath257 gate .",
    "indeed , this correlates the state @xmath247 of the ancilla with @xmath256 acting on the @xmath0 qubits , and the state @xmath175 of the ancilla with @xmath124 .",
    "when constructing the measurement for the product of the operators @xmath256 , it is sufficient to use only one ancilla , since for each basis state @xmath258 only one of these operators acts non - trivially . the classical part of the overall measurement circuit without the graph state encoding @xmath236 is shown in fig .",
    "[ fig : gen ] .",
    "the complexity of measuring @xmath259 [ eq .  ( [ eq : mirroroperator ] ) ] then becomes @xmath9 times the complexity of @xmath260-qubit toffoli gate for measuring each @xmath256 , plus the complexity of the encoding circuit @xmath236 and its inverse @xmath261 , which is at most @xmath262 .",
    "overall , for large @xmath0 , the measurement complexity is no larger than @xmath263 , or @xmath264 for a circuit without additional ancillas .",
    "we would like to emphasize that so far we have only constructed the measurement for _ error detection_. actual _ error correction _ for a non - additive code in this scheme involves constructing measurements @xmath265 for all corrupted subspaces corresponding to different degeneracy classes given by different @xmath206 .",
    "this relies on the orthogonality of the corrupted subspaces , see appendix [ app : orthogonality ] . for a general @xmath1-error correcting code",
    ", the number of these measurements can reach the same exponential order @xmath11 as the number of correctable errors in eq .",
    "( [ eq : sphere ] ) . for non - degenerate codes",
    ", we can not do better using this method .    note that the measurement circuit derived in this section first decodes the quantum information , then performs the measurement for the classical code , and finally re - encodes the quantum state .                .",
    "notations as in fig .",
    "[ measurementand ] . the result ( cf .",
    "[ fig : measurementm ] ) @xmath266 is equivalent to @xmath267 . ]",
    "in this section we construct a quantum circuit for the measurement operator @xmath268 of a ust code @xmath160 . to this end , we define the logical combinations of non - pauli measurements in agreement with analogous combinations defined in ref .",
    "@xcite for the projection operators , and construct the circuits for logical combinations and [ figs .",
    "[ measurementand ] , [ measurementand_new ] ] and xor [ figs",
    ".  [ measurementxor ] , [ fig : measurementm1plusm0 ] ] .",
    "we use these circuits to construct the measurement for @xmath239 with complexity not exceeding @xmath269 .      _",
    "logical and _ : given two commuting measurement operators @xmath270 and @xmath271 , let @xmath272 denote the measurement operator that stabilizes all states in the subspace @xmath273 the output of the measurement @xmath272 is identical to the logical and operation performed on the output of measurements @xmath270 and @xmath271 .",
    "this measurement can be implemented by the circuit in fig .",
    "[ measurementand ] . here",
    "the first two ancillas are entangled with the two measurement outcomes ; the third ancilla is flipped only if both ancillas are in the @xmath44 state , which gives the combination @xmath274 .",
    "the projector onto the positive eigenspace of @xmath275 satisfies the identity @xmath276 this identity can be used to obtain a simplified circuit which only uses two ancillas , see fig .",
    "[ measurementand_new ] , with the price of two additional controlled - hadamard gates [ fig .",
    "[ chgate ] ] .",
    "gate based on the identity @xmath277 . ]    the circuits in figs .",
    "[ measurementand ] and [ measurementand_new ] can be generalized to perform the measurement corresponding to the logical and of @xmath278 commuting measurement operators with the help of associativity , e.g. , @xmath279 .",
    "the generalization of the simplified circuit in fig .",
    "[ measurementand_new ] requires only two ancillas for any @xmath280 .",
    "the corresponding complexity is @xmath281 times the complexity of a controlled-@xmath39 gate , plus @xmath281 times the complexity of a controlled single - qubit gate .",
    "when all @xmath282 are @xmath0-qubit pauli operators , the overall complexity with two ancillas is @xmath283 .    _",
    "logical xor _ :",
    "in analogy to the logical `` exclusive or '' , we define the symmetric difference @xmath284 of vector spaces @xmath285 , @xmath286 , @xmath287 ,   as the vector space formed by the basis vectors that belong to an odd number of the original vector spaces . for two vector spaces",
    "@xmath288 this operation is obviously associative , @xmath289 . for two commuting measurement operators",
    "@xmath290 , @xmath291 , let @xmath292 be the measurement operator that stabilizes the subspace @xmath293 .",
    "explicitly , @xmath294    \\oplus    \\left[\\mathcal{p}(m_{0})\\cap\\mathcal{p}^\\perp(m_{1})\\right ] .",
    "\\label{eq : oplus - space}\\end{aligned}\\ ] ] the output of measuring @xmath295 is identical to the logical xor operation performed on the outputs of measurements @xmath270 and @xmath271 .",
    "the corresponding measurement can be implemented by combining the two ancillas with a cnot gate [ fig .",
    "[ measurementxor ] ] .    to simplify this measurement ,",
    "we show that @xmath296 .",
    "indeed , eq .  ( [ eq : oplus - space ] ) implies that for the projection operators @xmath297 , @xmath298 , @xmath299 the corresponding measurement operator is factorized with the help of the projector identities  ( [ eq : projector - identities ] ) , @xmath300-\\openone\\\\ & = & -(2p_1-\\openone ) ( 2p_0-\\openone ) = -m_1m_0.\\end{aligned}\\ ] ] this implies that @xmath301 .",
    "in other words , the measurement of @xmath292 can be implemented simply as an ( inverted ) concatenation of two measurements , see fig .  [",
    "fig : measurementm1plusm0 ] . the same circuit can also be obtained from that in fig .",
    "[ measurementxor ] by a sequence of circuit simplifications ( not shown ) .    the circuit in fig .  [ fig : measurementm1plusm0 ] is immediately generalized to a combination of more than two measurements , @xmath302 .",
    "the corresponding complexity for computing the xor of @xmath303 measurements is simply the sum of the individual complexities , implying that this concatenation has no overhead .",
    "a ust code @xmath304 is a direct sum ( [ eq : ust - defined ] ) of @xmath9 mutually orthogonal subspaces obtained by translating the originating stabilizer code @xmath305 $ ] .",
    "for mutually orthogonal subspaces @xmath306 , we have @xmath307 and @xmath308 , and the direct sum is the same as the symmetric difference ( [ eq : symmetric - difference ] ) , @xmath309 .    in turn",
    ", the stabilizer code @xmath153 is an intersection of the subspaces stabilized by the generators @xmath102 of the stabilizer , see eq .",
    "( [ eq : stabilizer - code - intersection ] ) .",
    "the translated subspaces @xmath310 are stabilized by the pauli operators @xmath311 .",
    "we can therefore decompose the ust code @xmath58 as @xmath312   =    \\mathop{\\text{\\raisebox{-0.75ex}{\\large{$\\bigtriangleup$ } } } }    \\limits_{j=1}^{k}\\biggl [   \\bigcap_{i=1 }    ^{n - k}{\\mathcal{p}(m_{i , j})}\\biggr ]   .",
    "\\label{eq : ust - space - decomposition}\\ ] ] this gives the decomposition of the measurement operator @xmath259 whose positive eigenspace is the code @xmath58 as @xmath313 .",
    "\\label{eq : ust - decomposition}\\ ] ]    recall that the complexity of each of the @xmath9 logical and operations is @xmath314(n+1)$ ] .",
    "no additional overhead is required to form the logical xor of the results .",
    "thus , we obtain the following    [ theorem : complexity1 ] error detection for a ust code of length @xmath0 and dimension @xmath315 , formed by a translation set of size @xmath316 , has complexity at most @xmath317 .    note that in the special case of a cws code ( @xmath318 ) , the prefactor of @xmath9 is quadratic in @xmath0 whereas the corresponding prefactor obtained in sec .",
    "[ sec : generic ] is _ linear _ in @xmath0 .",
    "the reason is that in eq .",
    "( [ eq : mirroroperator ] ) the graph encoding circuit @xmath319 with complexity @xmath254 is used only twice , and the projections onto the classical states have linear complexity . in eq .",
    "( [ eq : ust - decomposition ] ) we are using @xmath9 projections onto basis states of the quantum code .",
    "the advantage of the more complex measurement constructed in this section is that it does not involve having unprotected decoded qubits for the entire duration of the measurement .",
    "recall from section  [ sec : stabilizer - codes ] that for stabilizer codes the representatives of the error degeneracy classes form an abelian group whose generators are in one - to - one correspondence with the generators of the stabilizer .",
    "measuring the @xmath96 generators of the stabilizer of a stabilizer code @xmath92 $ ] uniquely identifies the degeneracy class of the error .    in this section",
    "we establish a similar structure for cws codes .",
    "first , for any subset @xmath320 of correctable errors of a quantum code @xmath58 , we define the set @xmath321 of _ unrelated _ errors which do not fall in the same degeneracy class with any error from @xmath322 .",
    "the formal definition @xmath323 is based on the general error correction condition  ( [ sncondtion - correcting ] ) and the orthogonality of corrupted spaces , see appendix  [ app : orthogonality ] . when errors in @xmath71 are non - degenerate , the definition  ( [ eq : unrelated ] ) is equivalent to the set difference , @xmath324 . in the general case , since we do not distinguish between mutually degenerate errors , @xmath321 can be thought of as the difference between the sets of degeneracy classes in @xmath71 and in @xmath322",
    ".    definition ( [ eq : unrelated ] ) implies that the subspaces @xmath325 and @xmath326 , defined analogously , are mutually orthogonal .",
    "moreover , if the elements of the set @xmath322 form a group @xmath327 , the subspace @xmath328 is also orthogonal to @xmath329 $ ] [ see eq .",
    "( [ eq : err - detection - aux ] ) below ] . in other words",
    ", @xmath330 can be viewed as a quantum code which detects errors from @xmath331 .",
    "this observation , together with the error - detection measurement for ust codes constructed in the previous section , forms the basis of our error grouping technique .",
    "we prove the following    for a cws code @xmath193 in standard form and a group @xmath332 formed by graph images of some correctable errors in @xmath71 , the code @xmath330 is a ust code which detects all errors in @xmath333 .",
    "[ theorem : error - detect ]    * proof*. first , we show that the subspace @xmath328 is a ust code .",
    "the corresponding set of basis vectors is @xmath334 these vectors are mutually orthogonal , @xmath335 since every element @xmath336 of the group @xmath332 is a representative of a separate error degeneracy class .",
    "further , the group @xmath332 is abelian , and its elements commute with the codeword generators @xmath337 , @xmath338 .",
    "therefore , using eq .",
    "( [ eq : codeword - def ] ) , we can rearrange the set  ( [ eq : aux - basis ] ) as @xmath339 the set in the parentheses on the right hand side is a basis of the additive cws code @xmath340 formed by the group @xmath332 acting on the graph state @xmath186 .",
    "then , we can write the subspace @xmath328 explicitly as a ust code [ cf .  eq .  ( [ eq : ust - defined ] ) ] @xmath341 where the translations are given by the set of codeword operators @xmath342 of the original code @xmath58 . orthogonality condition  ( [ eq : ust - orthogonality ] ) is ensured by eq .",
    "( [ eq : orthogonality ] ) .",
    "second , we check the error - detection condition  ( [ sncondtion - detecting ] ) for the code  ( [ eq : aux - code ] ) .",
    "explicitly , for an error @xmath343 , and for the orthogonal basis states @xmath344 , @xmath345 for all @xmath346 , according to eqs .",
    "( [ sncondtion - correcting ] ) , ( [ eq : unrelated ] ) and the group property of @xmath332 .",
    "@xmath223    now , to correct errors in groups , we just have to find a suitable decomposition of the graph images of the original error set into a collection of groups , @xmath347 , and perform individual error - detection measurements for the auxiliary codes @xmath348 until the group containing the error is identified .    to find an error within a group @xmath349 with @xmath350 generators , we can try all @xmath350 subgroups of @xmath332 with one generator missing .",
    "more specifically , for a generator @xmath351 we consider the subgroup @xmath352 and perform error detection for the code @xmath353 . after completing @xmath350 measurements ,",
    "we obtain a representative of the actual error class .",
    "this is the product of all generators @xmath351 for which the corresponding code @xmath354 detected an error .      to actually carry out the discussed program , we need to construct the @xmath355 generators @xmath102 of the stabilizer of the code @xmath340 .",
    "the generators have to commute with the @xmath350 generators @xmath356 in the group @xmath332 .",
    "this can be done with the gram - schmidt ( gs ) orthogonalization @xcite of the graph - state generators @xmath167 [ eq .  ( [ eq : canonical - generators ] ) ] with respect to the generators @xmath356 .",
    "as a result , we obtain the orthogonalized set of independent generators @xmath357 such that @xmath358 .",
    "we can take the last @xmath355 of the obtained generators as the generators of the stabilizer , @xmath359 , @xmath360 .",
    "the orthogonalization procedure is guaranteed to produce exactly @xmath350 generators @xmath361 anti - commuting with the corresponding errors @xmath356 , @xmath362 .",
    "indeed , the gs orthogonalization procedure can be viewed as a sequence of row operations applied to the original @xmath363 binary matrix @xmath286 with the elements @xmath364 which define the original commutation relation , @xmath365 the generator @xmath366 anti - commutes with at least one operator in @xmath99 if and only if the @xmath367-th column of @xmath286 is not an all - zero column",
    ". then all @xmath350 generators are independent ( no generator can be expressed as a product of some others ) if and only if @xmath286 has full column rank .    by this explicit construction , the generators @xmath102 of the stabilizer of the auxiliary code @xmath368 [ eq .",
    "( [ eq : aux - code ] ) ] are pauli operators in the original graph - state basis . the complexity of each error - detection measurement @xmath369 is therefore given by theorem [ theorem : complexity1 ] .",
    "the procedure described above appears to be extremely tedious , much more complicated than the syndrome measurement for a stabilizer code .",
    "however , it turns out that for stabilizer codes this is no more difficult than the regular syndrome - based error correction .",
    "indeed , for a stabilizer code @xmath370 $ ] , the degeneracy classes for all correctable errors form a group of all translations of the code , @xmath371 , with @xmath96 generators . to locate the error",
    ", we just have to go over all @xmath96 ust codes @xmath372 generated by the subgroups of @xmath332 with the generator @xmath351 missing .",
    "since the originating code @xmath58 is a stabilizer code , the ust codes @xmath372 are actually stabilizer codes , encoding @xmath373 qubits each .",
    "hence there is only one non - trivial error , and up to error degeneracies , @xmath374 .",
    "the corresponding stabilizers @xmath375 have only one generator each .",
    "the necessary measurements are just independent measurements of @xmath96 pauli operators , the same as needed to measure the syndrome . moreover , if the error representatives @xmath351 , @xmath376 , are chosen to satisfy the orthogonality condition @xmath377 as in example 1 , the operators to be measured are the original generators @xmath102 of the stabilizer , and the corresponding measurement is just the syndrome measurement .    * example 5 .",
    "* consider the additive code @xmath224 equivalent to the stabilizer code @xmath136 $ ] , see examples 1 and 4 .",
    "the graph - induced maps of single - qubit errors form a group of translations of the code , @xmath378 .",
    "this group contains all error degeneracy classes , @xmath379 . with the addition of the logical operator @xmath380",
    ", these can generate the entire @xmath181-qubit hilbert space @xmath381 from the graph state @xmath186 ; we have @xmath382 .    indeed , if we form a measurement as for a generic cws code , we first obtain the stabilizer of the auxiliary code @xmath340 [ eq .",
    "( [ eq : aux - code ] ) ] which in this case has only one generator , @xmath383 , where @xmath384 , see example 4 . translating this code with the set ( in this case , group ) @xmath385 of codeword operators , we get the auxiliary ust code @xmath386 as the union of the positive eigenspaces of the operators [ see eq .",
    "( [ eq : ust - space - decomposition ] ) ] , @xmath387 which is the entire hilbert space , @xmath388 , as expected .    to locate the error within the group @xmath332 with @xmath389 generators , we form a set of smaller codes @xmath353 , @xmath390 , where the group @xmath391 is obtained from @xmath332 by removing the @xmath204-th generator .",
    "the corresponding stabilizers are @xmath392 , @xmath393 , etc .",
    "the matrices @xmath394 of conjugated generators have the form , e.g. , @xmath395{cc }      s_1 , & -s_1\\\\      s_5 , & -s_5    \\end{array } \\right ) , \\quad m_{i , j}^{(2)}=\\left (    \\begin{array}[c]{cc }      s_2 , & -s_2\\\\      s_5 , & -s_5    \\end{array } \\right ) , \\ldots\\ ] ] the code @xmath354 is formed as the union of the common positive eigenspaces of the operators in the columns of the matrix @xmath394 .",
    "clearly , these codes can be more compactly introduced as positive eigenspaces of the operators @xmath396 , @xmath390 .",
    "such a simplification only happens when the original code @xmath58 is additive . while the operators @xmath397 are different from the stabilizer generators in eq .",
    "( [ eq : stab513 ] ) , they generate the same stabilizer @xmath398 of the original code @xmath58 .",
    "it is also easy to check that the same procedure gives the original generators @xmath102 [ eq .  ( [ eq : stab513 ] ) ] if we start with the error representatives ( [ eq:513-errors ] ) .",
    "@xmath148      now consider the case of a generic cws code @xmath217 . without analyzing the graph structure ,",
    "it is impossible to tell whether there is any set of classical images of correctable errors that forms a large group .",
    "however , since we know its minimum distance , we know that the code can correct errors located on @xmath399 qubits .",
    "all errors located on a given set of qubits form a group . therefore , by taking an _ index set _",
    "@xmath400 of @xmath401 different qubit positions , we can ensure that the corresponding correctable errors @xmath402 form a group with @xmath403 independent generators .",
    "the corresponding graph images @xmath404 obey the same multiplication table , but they are not necessarily independent . as a result , the abelian group @xmath405 generally has @xmath406 generators .",
    "since all group elements correspond to correctable errors , the conditions of theorem  [ theorem : error - detect ] are satisfied .    overall , to locate an error of weight @xmath1 or less , we need to iterate over each ( but the last one ) of the @xmath407 index sets of size @xmath1 and perform the error - detecting measurements in the corresponding ust codes @xmath408 until the index set with the error is found .",
    "this requires up to @xmath16 measurements to locate the index set , and the error can be identified after additional @xmath409 measurements .",
    "this can be summarized as the following    a cws code of distance @xmath7 can correct errors of weight up to @xmath410 by performing at most @xmath411 measurements .    for any length @xmath412 , this scheme reduces the total number  ( [ eq : sphere ] ) of error patterns by a factor @xmath413{ll }        \\displaystyle        \\frac{3n+1}{n+1 } , & \\text{if}\\;\\,t=1,\\\\        \\displaystyle        \\;3^{t^{\\text{\\strut } } } , & \\text{if}\\;\\,t>1 .",
    "\\end{array }    \\right .",
    "\\label{factoreven}\\ ] ]    * example 6 . * consider the @xmath218 code previously discussed in example 3 . while the distance @xmath414 is too small to correct arbitrary errors , we can correct an error located at a given qubit .",
    "assume that an error may have happened on the second qubit .",
    "then we only need to check the index set @xmath415 .",
    "the errors @xmath416 located in @xmath285 form a group with generators @xmath417 ; the corresponding group of classical error patterns induced by the ring graph in fig .",
    "[ fig : tria](b ) is @xmath418 .",
    "the three generators @xmath102 of the stabilizer of the originating ust code @xmath419 can be chosen as , e.g. , @xmath420 , @xmath421 , @xmath422 . using the classical codewords  ( [ classicalcode ] ) for the translation operators @xmath423 , we obtain the conjugated generators @xmath311 @xmath424{rrrrrr }        g_1 , & -g_1 , & g_1 , & g_1 , & g_1 , & -g_1\\\\        g_2 , & g_2 , & -g_2 , & -g_2 , & g_2 , & -g_2\\\\        g_3 , & -g_3 , & g_3 , & -g_3 , & -g_3 , & g_3 \\end{array}\\right).\\ ] ] according to eq .",
    "( [ eq : ust - space - decomposition ] ) , the auxiliary code @xmath425 is a direct sum of the common positive eigenspaces of the operators in the six columns of the matrix  ( [ eq : translated-562 ] ) .    to locate the actual error in this @xmath426-dimensional space , we consider the two subgroups @xmath427 and @xmath428 of @xmath405 .",
    "the stabilizers of the corresponding auxiliary codes @xmath429 and @xmath430 can be obtained by adding @xmath431 and @xmath432 , respectively ; this adds one of the rows @xmath433 to the matrix  ( [ eq : translated-562 ] ) .",
    "the original code @xmath58 is the intersection of the codes @xmath429 and @xmath430 ; the corrupted space @xmath434 is located in @xmath429 , but not in @xmath430 , while , e.g. , the corrupted space @xmath435 is located in @xmath425 , but not in @xmath429 or @xmath430 .",
    "@xmath148      a similar procedure can be carried over for a general ust code @xmath436 , with the only difference that the definitions of the groups @xmath332 and the auxiliary codes @xmath340 [ eq .  ( [ eq : aux - code ] ) ] should also include the @xmath94 generators of the originating stabilizer code @xmath153 [ sec .  [ sec : ust ] ] .",
    "overall , the complexity of error recovery for a generic ust code can be summarized by the following    [ main]consider any @xmath1-error correcting ust code of length @xmath0 and dimension @xmath437 , with the translation set of size @xmath9 .",
    "then this code can correct errors using @xmath438 or fewer measurements , each of which has complexity @xmath439 or less .      for additive quantum codes",
    ", the syndrome measurement locates all error equivalence classes , not only those with `` coset leaders '' of weight @xmath440 .",
    "the same could be achieved with a series of clustered measurements , by first going over all clusters of weight @xmath441 , then @xmath442 , etc .",
    "this ensures that the first located error has the smallest weight .",
    "in contrast , such a procedure will likely fail for a non - additive code where the corrupted spaces @xmath443 and @xmath444 can partially overlap if either @xmath85 or @xmath89 is non - correctable . for instance , the measurement in example 6 may destroy the coherent superposition if the actual error ( e.g. , @xmath445 , @xmath446 ) was not on the second qubit",
    ".    therefore , if no error was detected after @xmath16 measurements , we can continue searching for the higher - weight errors only after testing the remaining size-@xmath1 index set . with a non - additive cws code , generally we have to do a separate measurement for each additional correctable error of weight @xmath447 .",
    "for generic cws and ust codes , we constructed a _ structured recovery algorithm _ which uses a single non - pauli measurement to check for groups of errors located on clusters of @xmath1 qubits .",
    "unfortunately , for a generic cws code with large @xmath9 and large distance , both the number of measurements and the corresponding complexity are exponentially large , in spite of the exponential acceleration already achieved by the combined measurement .    to be deployed , error - correction must be complemented with some fault - tolerant scheme for elementary gates .",
    "it is an important open question whether a fault - tolerant version of our measurement circuits can be constructed for non - additive cws codes .",
    "it is clear , however , that such a procedure would _ not _",
    "help for any cws code that needs an exponential number of gates for recovery .",
    "therefore , the most important question is whether this design can be simplified further .",
    "we first note that the group - based recovery [ see theorem  [ theorem : error - detect ] ] is likely as efficient as it can possibly be , illustrated by the example of additive codes in sec .",
    "[ sec : additive ] where this procedure is shown to be equivalent to syndrome - based recovery . also , while it is possible that for fixed @xmath9 the complexity estimate of theorem  [ theorem : complexity1 ] can be reduced in terms of @xmath0 ( e.g. , by reusing ancillas with measured stabilizer values ) , we think that for a generic code the complexity is linear in @xmath9",
    ".    however , specific families of cws codes might be represented as unions of just a few stabilizer codes which might be mutually equivalent as in eq .",
    "( [ eq : ust - defined ] ) , or non - equivalent @xcite . the corresponding measurement complexity for error detection",
    "would then be dramatically reduced .",
    "examples are given by the quantum codes derived from the classical non - linear goethals and preparata codes @xcite .",
    "another possibility is that for particular codes , larger sets of correctable errors may form groups .",
    "indeed , we saw that for an additive code @xmath448 , all error degeneracy classes form a large group of size @xmath449 which may include some errors of weight well beyond @xmath1 .",
    "such a group also exists for a cws code which is a subcode of an additive code .",
    "there could be interesting families of non - additive cws codes which admit groups of correctable errors of size beyond @xmath15 .",
    "for such a code , the number of measurements required for recovery could be additionally reduced .",
    "this research was supported in part by the nsf grant no .",
    "centre for quantum technologies is a research centre of excellence funded by ministry of education and national research foundation of singapore .",
    "the authors are grateful to bei zeng for the detailed explanation of the cws graph construction .",
    "as discussed in sec .  [ sec : general ] , for a general non - additive quantum code @xmath450 and two linearly independent correctable errors , the corrupted spaces @xmath83 and @xmath84 may be neither identical nor orthogonal @xcite .",
    "however , for cws and ust codes it is almost self - evident that when @xmath451 and @xmath452 do not coinside , they are mutually orthogonal . this orthogonality is inherited from the originating stabilizer code @xmath150 . in particular , in some previous publications ( e.g. , ref .",
    "@xcite ) orthogonality is implied in the discussion of degenerate errors for cws codes . however , to our knowledge , it was never explicitly discussed for cws or ust codes . since our recovery algorithms for cws and ust codes rely heavily on this orthogonality , we give here an explicit proof .",
    "first , consider a stabilizer code @xmath150 .",
    "for any pauli operator @xmath453 , there are three possibilities : ( * i * ) @xmath31 is proportional to a member of the stabilizer group , @xmath454 , where @xmath455 and @xmath456 , @xmath457 , ( * ii * ) @xmath31 is in the code normalizer @xmath152 but is linearly independent of any member of the stabilizer group , and ( * iii * ) @xmath31 is outside of the normalizer , @xmath458",
    ".    case ( * i * ) implies that the space @xmath459 is identical to the code @xmath150 ; the errors @xmath85 and @xmath89 are mutually degenerate .",
    "indeed , for any basis vector @xmath460 , the action of the error @xmath461 just introduces a common phase @xmath462 ; any vector @xmath463 is mapped to @xmath464 and hence no recovery is needed .    in case ( * ii * ) the operator @xmath31 also maps @xmath150 to itself , but no longer identically .",
    "therefore , at least one of the two errors @xmath85 , @xmath89 is not correctable .",
    "indeed , in this case we can decompose @xmath31 ( see sec .  [",
    "sec : stabilizer - codes ] ) as the product of an element @xmath455 in the stabilizer and logical operators , i.e. , @xmath465 , where @xmath457 determines the overall phase . while @xmath455 acts trivially on the code , the logical operator specified by the binary - vectors @xmath466 , @xmath467 is non - trivial , @xmath468 . using the explicit basis  ( [ eq : stabilizer - code - basis ] ) , it is easy to check that the error - correction condition ( [ sncondtion - correcting ] ) is _ not _",
    "satisfied for the operators @xmath85 , @xmath89 .",
    "finally , in case ( * iii * ) the spaces @xmath459 and @xmath469 are mutually orthogonal .",
    "indeed , since @xmath31 is outside of the code normalizer @xmath152 , there is an element of the stabilizer group @xmath455 that does not commute with @xmath31 .",
    "therefore , for any two states in the code , @xmath470 , we can write @xmath471 which gives @xmath472 , and the spaces @xmath469 and @xmath459 [ also , @xmath473 and @xmath474 are mutually orthogonal .    now , consider the same three cases for a ust code  ( [ eq : ust - defined ] ) derived from @xmath153 . in case",
    "( * i * ) the code is mapped to itself , @xmath475 .",
    "the operator @xmath31 acts trivially on the code ( and the errors @xmath85 , @xmath89 are mutually degenerate ) if @xmath31 either commutes  ( [ eq : translations - commute ] ) or anti - commutes  ( [ eq : translations - anti - commute ] ) with the entire set of translations generating the code : @xmath476 if neither of these conditions is satisfied , the error - correction condition ( [ sncondtion - correcting ] ) is violated .",
    "this is easily checked using the basis @xmath477 .",
    "finally , in case ( * iii * ) , the space @xmath479 is either orthogonal to @xmath450 , or the error correction condition is not satisfied .",
    "the latter is true if @xmath31 is proportional to an element in one of the cosets @xmath480 , where @xmath481 , @xmath482 .",
    "then the inner product @xmath483 , @xmath484 , which contradicts the error - correction condition  ( [ sncondtion - correcting ] ) . in the other case , namely , when @xmath31 is linearly independent of any operator of the form @xmath485 , @xmath486 , @xmath455 , @xmath31 must be a member of a different coset @xmath487 of the stabilizer @xmath488 of the code @xmath153 in @xmath489 .",
    "this implies orthogonality:@xmath490 where @xmath491 accounts for a possible phase factor .",
    "overall , as long as the error correction condition ( [ sncondtion - correcting ] ) is valid for a ust code @xmath58 and the pauli operators @xmath85 , @xmath89 , the spaces @xmath451 and @xmath452 either coincide , or are orthogonal . since cws codes can be regarded as ust codes originating from a one - dimensional stabilizer code @xmath153 , [ sec .",
    "[ sec : cws - defined ] ] , the same is also true for any cws code .",
    "m.  hein et  al . , entanglement in graph states and its applications , in _ quant .",
    ", algorithms . and chaos : proc .",
    "school physics `` enrico fermi '' _ , vol .",
    "115218 , ios press , amsterdam , 2005 ."
  ],
  "abstract_text": [
    "<S> codeword stabilized ( cws ) codes are , in general , non - additive quantum codes that can correct errors by an exhaustive search of different error patterns , similar to the way that we decode classical non - linear codes . for an @xmath0-qubit quantum code correcting errors on up to @xmath1 qubits , this brute - force approach consecutively tests different errors of weight @xmath1 or less , and employs a separate @xmath0-qubit measurement in each test . </S>",
    "<S> in this paper , we suggest an error grouping technique that allows to simultaneously test large groups of errors in a single measurement . </S>",
    "<S> this structured error recovery technique exponentially reduces the number of measurements by about @xmath2 times . </S>",
    "<S> while it still leaves exponentially many measurements for a generic cws code , the technique is equivalent to syndrome - based recovery for the special case of additive cws codes .    by -0.05 in </S>"
  ]
}