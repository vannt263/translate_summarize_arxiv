{
  "article_text": [
    "the unbounded identifier model were introduced in  @xcite . here",
    "we adopt this model with minor changes in formal definitions .",
    "we consider point - to - point synchronous networks and distributed protocols in them .",
    "nodes of a network communicate by sending messages through bi - directed links .",
    "all nodes perform the same communication protocol .",
    "communication speed is bounded by @xmath6 .",
    "the nodes are distinguishable but the amount of information to distinguish them may be arbitrary large .    in this section",
    "we provide formal definitions for this model .    a _ network _",
    "@xmath12 is a connected graph , where @xmath4 is the set of nodes and @xmath9 is the set of bi - directed links .",
    "the graph is equipped by a set of functions .",
    "an injective function @xmath13 assigns the unique identifier @xmath14 to a node  @xmath15 .",
    "links of each node are ordered by index functions @xmath16 .",
    "let @xmath17 be a degree of a node in @xmath12 .",
    "then the range of the index function @xmath18 is exactly the set of edges incident to @xmath15 in @xmath12 .",
    "we assume that initially a node has only local information about a network .",
    "it knows the number of its links ( the degree @xmath17 ) , can distinguish links by its index function , and knows its identifier .",
    "this model uses discrete time .",
    "time moments are numbered by nonnegative integers . at a moment",
    "@xmath19 a node @xmath15 receives messages from all its neighbors .",
    "the messages are bit strings , their lengths are bounded by a constant specified by a protocol .",
    "the empty string @xmath20 is allowed .",
    "it indicates absence of a  message .",
    "the list of messages received by the node @xmath15 at a moment  @xmath19 is denoted as @xmath21 the messages are ordered by the index function .",
    "usually states of nodes are used in protocol descriptions .",
    "but it is unnecessary and we avoid states in the definitions .",
    "one may take a  history of communication in a node as a state of a node . _ a  history of communication _",
    "@xmath22 in a node @xmath15 at a moment @xmath19 is the list @xmath23 .",
    "we assume that messages depend on the history of communication only .",
    "( so the protocols are deterministic . )    by definition , a _ protocol _ is the message function @xmath24 that determines the messages sent during the current round of communication .",
    "the first argument in the message function is an index of a link in the link enumeration .",
    "the second argument is the history of communication",
    ".    the message function may be arbitrary .",
    "it means that nodes are computationally unlimited .",
    "nevertheless , it is worth to mention that in the protocols presented in this paper the message functions are easy to compute .",
    "initially , at time @xmath25 , the history of communication in a node @xmath15 is @xmath26 .",
    "then the configuration of the network is changed according the following rules : @xmath27 where the link @xmath28 has the index @xmath29 in the node @xmath15 and the index @xmath30 in the node @xmath31 .",
    "( recall that no communication errors are allowed in this model . )",
    "note that the rules are the same for all nodes in the network .",
    "but behavior of a node may depend on a moment of time due to the synchronization assumption .",
    "we say that a node @xmath15 is in the _ final state _ at moment  @xmath19 , if @xmath32 for all @xmath29 , @xmath33 .",
    "it means that in the final state a node is not communicating with a network : it sends nothing and ignores all incoming messages .",
    "we say that a node @xmath15 is in a _ sleep _ state at moment  @xmath19 , if @xmath34 where @xmath35 is the list composed of the empty strings .",
    "thus a node in a sleep state does not generate messages and does not change its state if it has not received messages from its neighbors at the previous moment of time .",
    "it implies that communication finishes if all nodes are in sleep states . but a node in a sleep state can be ` awaken ' by a suitable message .",
    "a protocol is _ message terminating _",
    "if for any network @xmath12 , @xmath36 , @xmath37 all nodes are in a sleep state at some moment  @xmath19 .",
    "a protocol is _ processor terminating _ if for any @xmath12 , @xmath36 , @xmath37 all nodes are in the final state at some moment  @xmath19 .",
    "the running time @xmath38 of the protocol in the network @xmath12 , @xmath36 , @xmath37 is the first moment of time when all nodes are in the final ( a sleep ) state .",
    "now we are going to define a useful result of a protocol . loosely speaking ,",
    "it is an arbitrary function of a history of communication .",
    "we say that a protocol @xmath39 _ broadcasts the minimal identifier _ if it terminates in any network and there is a function @xmath40 such that @xmath41 for all @xmath42 . here",
    "@xmath38 is the running time of the protocol and @xmath43 is the minimal identifier in the network with respect to _ the shortlex order _",
    "@xmath44 : compare strings by the length and in the case of equal lengths compare them lexicographically .",
    "we say that a protocol @xmath39 _ elects a leader _ if it terminates in any network and there is a function @xmath45 such that ( i ) @xmath46 and ( ii ) after the protocol finishes , there is exactly one node ( the leader ) with the value  @xmath47 : @xmath48 for the leader @xmath49 and @xmath50 for all @xmath51 .",
    "it follows from the definitions that if a protocol broadcasts the minimal identifier then it also elects a leader : the value @xmath52 is determined by @xmath43 and @xmath36 in the straightforward way .",
    "we say that a protocol @xmath39 _ constructs a rooted spanning tree _ if it terminates in any network and there is a function @xmath53 such that ( i ) @xmath54 ; ( ii ) there is exactly one node @xmath55 such that @xmath56 ; ( iii ) for all @xmath42 if @xmath57 then @xmath58 and ( iv ) the links @xmath59 , where @xmath57 , form a spanning tree in the network .",
    "the definition of protocols constructing a spanning tree looks rather artificially .",
    "it is used to simplify formal arguments .",
    "note in advance that an orientation from a child to a parent appears in our protocols naturally as well as the list of childs .",
    "so we skip the list in the definition .",
    "speaking of rooted trees , we always assume edge orientation towards the root .",
    "in this section we discuss informally the protocols presented below .",
    "the basic idea is very simple : to broadcast information as fast as possible .",
    "once a  node obtains some useful information , it immediately resends it to all its neighbors .",
    "we illustrate the idea in a simpler situation .",
    "suppose that initially there is the unique _ active _ node in a network ( a leader ) .",
    "it starts communication and sends its identifier to neighbors bit by bit .",
    "an initially nonactive node awakes after receiving a non - empty message and chooses a sender of this message as a parent .",
    "then the node also transmits to its neighbors bits received from the parent . in this way",
    "we obtain a protocol that constructs a rooted tree in time @xmath60 , where @xmath1 is the size of the active node identifier .",
    "the root of the tree is the initially active node .",
    "such protocols are called _",
    "flooding protocols_.    in absence of a leader ( the initially active node ) the straightforward realization of this idea takes more time .",
    "we mean the following rules : nodes send identifiers to the neighbors , compare received identifiers and transmit the current minimal value . in this way we obtain a sort of flooding protocol to broadcast the minimal identifier .",
    "the protocol is easily transformed to a protocol constructing a spanning tree .",
    "the running time of this protocol in our settings is @xmath10 . essentially , it is the well - known perlman protocol  @xcite adjusted for our model .    to speed up this flooding protocol",
    "we will use two ideas .    at first",
    ", we encode identifiers in such a way that for encoded strings the result of comparison of string s prefixes does not change after receiving the suffixes of the strings .",
    "it gives a way to compare long strings by their short prefixes .",
    "thus , our protocols transmit _ keys _ ,",
    "i.e. encoded identifiers .",
    "the second idea is to transmit the current information about the minimal key although it might be incorrect .",
    "when incorrectness is revealed , a correction message is sent instead of re - sending the whole information about the minimal key .",
    "of course , corrections make the running time longer . in section  [ min - broadcasting ]",
    "we give the exact rules for the protocol and prove the time bound given in theorem  [ th : m - t - prot ] .    in this way",
    "we get a message terminating protocol . after receiving a set of keys ,",
    "a  node can not exclude a possibility that somewhere in a network there is a smaller key .",
    "to make a protocol processor terminating requires additional work .",
    "thus nodes should communicate and establish the fact of termination of the key distribution process . to make this communication faster",
    ", the nodes may use a spanning tree built by the message terminating protocol . for this purpose",
    "we implement a  protocol based on the idea of echo protocol ( see , e.g.  @xcite ) adjusted to our model .",
    "broadcasting messages through a tree requires a time proportional to the diameter of the tree .",
    "thus we come to the time bound given in theorem  [ th : p - t - prot ] : the tree depth does not exceed the running time of the message terminating protocol .",
    "details are presented in section  [ finalizing ] .",
    "we encode the identifiers by the map @xmath61 on the set @xmath62 of binary strings .",
    "hereinafter we use the standard notation : @xmath63 is the length of a binary string @xmath64 , @xmath65 is a string @xmath66 repeated @xmath67 times .",
    "all logarithms are binary . for the empty string",
    "@xmath20 we set @xmath68 .",
    "it corresponds to the general rule with @xmath69 .",
    "the image @xmath70 is the set of _",
    "it is easy to see several simple and useful properties of this encoding :    * if @xmath71 then @xmath72 ; * the length of @xmath64 is determined by a prefix @xmath73 of the key @xmath74 ; * the encoding is injective ( an identifier can be restored from its key ) ; * any key is not a proper prefix of another key ; * @xmath75 .",
    "we are interested in asymptotic bounds .",
    "so we will ignore the difference between lengths of keys and lengths of identifiers .",
    "keys are compared in _ the partial lexicographical order _ ( pl order ) .",
    "let @xmath76 be the longest common prefix of the strings @xmath77 , @xmath15 .",
    "then by definition @xmath77 is less than @xmath78 in the pl order if @xmath79 , @xmath80 .",
    "we denote this fact by @xmath81 .",
    "note that a prefix of a string is not pl comparable with the string . it justifies the term ` partial ' . in the other direction , if @xmath76 is a proper prefix of both strings @xmath77 and @xmath15 then the strings are comparable in the pl order .    we indicate properties of the pl order that will be useful in the analysis of the protocols .",
    "[ greedy - compare ] if @xmath81 then @xmath82 for all @xmath83 , @xmath84 .",
    "the proposition follows easily from the definition of the pl order .",
    "[ length - compare ] if @xmath77 , @xmath15 are keys and @xmath85 then @xmath81 .",
    "moreover , there are prefixes @xmath86 and @xmath87 of the keys @xmath77 , @xmath15 such that @xmath88 and @xmath89 .",
    "note that @xmath90 , where @xmath91 .",
    "so the prefixes @xmath92 , @xmath93 of the keys @xmath77 , @xmath15 are pl compared and @xmath88 .",
    "the second claim follows from the inequality @xmath94 .",
    "there is no linear order on the whole set of binary strings satisfying proposition  [ greedy - compare ] and proposition  [ length - compare ] .",
    "thus we need to introduce keys .",
    "also note that the pl order is a linear order on the set of the keys .",
    "[ lex - consistent ] the pl order on the keys is consistent with the shortlex order @xmath44 on the identifiers : @xmath95 iff @xmath96 .    if @xmath71 then @xmath97 , @xmath98 . in this case",
    "@xmath99 is equivalent to @xmath95 .    if @xmath100 then either @xmath101 or @xmath72 .",
    "the former implies @xmath96 by proposition  [ length - compare ] . if @xmath72 , then @xmath102 and @xmath103 .",
    "thus @xmath96 .    in the other direction",
    "the arguments are similar .",
    "[ min - pl ] let @xmath104 be the set of pl - minimal elements of a set @xmath105 of strings .",
    "then for any pair of strings in @xmath104 one is a prefix of another .",
    "the minimal elements form an antichain in the pl order .",
    "but the only pl uncomparable pairs are ( string @xmath77 , a prefix of @xmath77 ) .",
    "messages in the protocol consist of the _ information bit _ and _ control bits_. there will be finitely many control bits . thus the communication speed is @xmath6 .",
    "the value  1 of a  control bit indicates that a specific event occurs in the process of communication .",
    "absence of the information bit in a message is allowed ( the case is indicated by the empty string instead of 1-bit string ) .",
    "we assume that if the information bit is empty and all control bits are  @xmath106 , then no message is sent ( formally , the empty string is sent ) .",
    "each node sends the same messages to all its neighbors in this protocol .",
    "the message is determined by the following data .    executing the protocol ,",
    "a node maintains _ the candidate _",
    "( to the minimal key ) and the list of _",
    "participants_. candidates and participants are binary strings .",
    "participants are prefixes of the candidates that has been received by a node from its neighbors . in particular",
    ", the number of participants equals the number of neighbors in each node .",
    "initially the candidate of a node is its key and all participants are empty .    at any moment of time",
    "the candidate is the longest pl - minimal string among the participants and the node s key .",
    "proposition  [ min - pl ] guarantees the uniqueness of the candidate .    at _ regular periods of time _",
    "a node sends bits of its candidate one by one until all bits of the candidate are sent . at _ exceptional periods of time _",
    "the participant @xmath107 sent to the neighbors of a node is not a prefix of the current candidate @xmath108 of the node . during an exceptional period the node sends _ a correction message _ : the length of @xmath109 written in binary .",
    "( in other words , a node tells to neighbors how many bits in its data are valid . )",
    "the end of a correction message is indicated in control bits as well as the end of a correction message .",
    "it is possible that the candidate is changed during an exceptional period of time .",
    "it might cause that the current correction message becames incorrect ( more bits in the participant are wrong ) . in this case the current correction message is aborted ( this event is indicated in control bits ) and the node starts transmission of a new correction message .    if a node has finished transmission of the candidate it goes to a  sleep state .",
    "below we provide the exact rules of the protocol .",
    "we need the following notation .",
    "let @xmath110 $ ] be the substring of a string @xmath49 that starts at the position @xmath29 and ends in the position @xmath30 . a  single @xmath30th bit of the string",
    "is denoted by  @xmath111 $ ] .",
    "@xmath112 is the key of the node @xmath77 , i.e. , is a shortcut of @xmath113 .",
    "@xmath114 is the candidate of the node @xmath77 after @xmath19 steps of the protocol .",
    "@xmath115 is the participant sent by the node @xmath77 to all its neighbors after @xmath19 steps of the protocol .    to define the rules for exceptional periods we need a notation @xmath116 that means the prefix of the correction message that has been sent to neighbors after @xmath19 steps of the protocol . during regular periods",
    ", @xmath116 is the empty string .    in this protocol",
    "a node sends the same message to all its neighbors .",
    "so we indicate an information sent by the node .",
    "just the same information is received by all neighbors of the node ( recall that there are no communication errors in our model ) .",
    "thus , an operation of a node at step @xmath117 of protocol is defined by the data @xmath118 i.e. , by the candidate , by the prefixes of the candidate and a correction message sent up to the time , and by participants and prefixes of correction messages received from neighbors .",
    "the node also takes into account the values of control bits . for simplicity",
    "we do not introduce notation for control bits .",
    "instead , we describe a way to use them .",
    "to form a message at step @xmath117 , the node also uses a correction message string @xmath119 .",
    "it is determined by the basic data as follows : if @xmath115 is a prefix of @xmath114 ( a regular period ) , then @xmath119 is the empty string .",
    "otherwise ( an exceptional period ) @xmath120 where @xmath121 is a binary representation of an integer  @xmath122 .",
    "if @xmath119 is empty , then , if @xmath123 , the information bit @xmath124 of the next message is the next bit of the candidate , i.e. , @xmath125;\\ ] ] otherwise , @xmath126 .",
    "if @xmath119 is non - empty , then the node transmits the following message ( and indicates in control bits that it is a message of an exceptional period ) :    1 .",
    "if @xmath116 is non - empty and @xmath116 is a prefix of @xmath119 , then the information bit @xmath124 of the message is the next bit of the correction message , i.e. , @xmath127;\\ ] ] 2 .",
    "if either @xmath116 is empty or @xmath116 is not a prefix of @xmath119 , then the information bit @xmath124 of the message is @xmath128 $ ] , in control bits the fact of starting correction phase is indicated ; 3 .",
    "a  transmission of the last bit of a correction message is indicated in control bits also .",
    "figures  [ regular - message ] and  [ correction - message ] illustrate the rules determining the value of the information bit of a message .    depending on the messages received at moment  @xmath117 ,",
    "the nodes change the basic data according the following rules .    if @xmath129 ( a regular period ) , then @xmath130    if @xmath131 ( an exceptional period ) , then changes in the data are different :",
    "if @xmath132 ( the end of the exceptional period ) , then @xmath133 and @xmath134 ; 2 .",
    "if @xmath135 is a proper prefix of @xmath119 , then @xmath136 and @xmath137 ; 3 .   if @xmath135 is not a prefix @xmath119 , then @xmath138 and @xmath137 ( it follows from the rules determining the messages of exceptional period that this case is possible if a correction message is aborted for another correction message ) .",
    "note that , taking into account the received information and control bits , a node is able to update the data of neighbors , i.e. , to determine new values of the lists @xmath139 and @xmath140 . in particular , after receiving the last bit of a correction message from a neighbor  @xmath15 , a node @xmath77 sets the participant @xmath141 to be the prefix of @xmath142 of length @xmath143 , where the binary representation of an integer @xmath143 is just the correction message  @xmath144 received .",
    "the last piece of the updated data to be determined is the candidate of a  node .",
    "the new value @xmath145 is the longest pl - minimal string in the set @xmath146 .    initially , at moment @xmath25 , all participants @xmath147 and all prefixes of correction messages @xmath148 are empty and the candidates are the keys : @xmath149 for all  @xmath77 .",
    "note that the candidates , the participants and the correction messages are functions of the communication history in the node .",
    "thus the described protocol satisfies the definition  .",
    "let s check the important property of the protocol , which has been indicated in the above informal discussion .",
    "[ participant = pref(candidate ) ] a  participant @xmath150 is a prefix of some candidate @xmath151 , @xmath152 .",
    "induction by the moments of time .",
    "initially , at @xmath25 , the proposition holds due to the rules of the protocol ( the first step is regular ) .",
    "inductive step is a consideration of possible cases for determining a new value of a participant .    a  regular period , the information bit is non - empty . in this case",
    "@xmath153 is a prefix of the candidate @xmath114 by the rule of determining the information bit .    a  regular period , the information bit is empty . in this case @xmath154    the end of an exceptional period : by definition",
    ", @xmath150 is a prefix of @xmath114 .    on other steps of an exceptional period , the participant does not change .",
    "thus , by the induction hypothesis , it is a prefix of a previous candidate .",
    "informally , the candidates and the participants provide a sequence of approximations to the minimal key .",
    "therefore it is natural to expect that the sequence is monotone in each node .",
    "the strings are compared in a  partial order .",
    "so the only weak monotonicity is possible .",
    "the next proposition formalizes this intuition .",
    "[ monotone0 ] a sequence of the candidates @xmath155 in a node @xmath77 is non - increasing ; moreover , for @xmath156 either @xmath114 is a prefix of @xmath151 or @xmath157 .    by the rule of determining the next candidate as the longest possible pl - minimal string over the set that contains the previous candidate",
    ", it follows from @xmath158 that @xmath114 is a prefix @xmath145 due to proposition  [ min - pl ] .    for arbitrary @xmath156",
    "the statement follows by induction and transitivity of an order relation .",
    "it follows from the rules of the protocol that a node sends the empty message if @xmath159 .",
    "this condition remains true if the node has not received non - empty messages from its neighbor ( the data remain unchanged ) .",
    "therefore , if @xmath159 , then the node @xmath77 is in a sleep state .    below we prove the lemma .",
    "[ weak - correctness ] at some moment of time the candidates and the participants in all nodes are equal to the pl - minimal key in a network .",
    "proposition  [ lex - consistent ] ( the pl order on the keys is consistent with the short - lex order on the identifiers ) , injectivity of the mapping from the identifiers to the keys , and lemma  [ weak - correctness ] imply that the protocol described in the previous subsection is a message terminating protocol broadcasting the minimal identifier .    before the proof of lemma  [ weak - correctness ]",
    "we prove several facts that will also be useful in evaluating of the running time of the protocol .",
    "[ participant = pref(key ) ] at any moment of time @xmath19 the participant @xmath115 and the candidate @xmath114 of any node @xmath77 are prefixes of node keys .",
    "induction by the moments of time .",
    "it is sufficient to prove the statement for candidates only because participants are prefixes of candidates due to proposition  [ participant = pref(candidate ) ] .",
    "the base case holds since initially all candidates are keys .",
    "show that if the statement holds at moment  @xmath19 , then it also holds at moment  @xmath117 .",
    "participants of all nodes at moment @xmath117 are prefixes of candidates at earlier times due to proposition  [ participant = pref(candidate ) ] . by the induction hypothesis they are prefixes of keys .",
    "the candidate @xmath145 coincides either with @xmath114 or with a participant @xmath141 .",
    "let @xmath160 be the minimal key in a network .",
    "we will use the following fact about prefixes of the keys .",
    "[ key - dichotomy ] let @xmath107 be a prefix of a key @xmath161 .",
    "then either @xmath162 or @xmath107 is a prefix of @xmath160 .",
    "look at the position that determines the result of comparison @xmath160 and @xmath161 : @xmath163 let @xmath107 be a prefix of @xmath161 such that @xmath107 is not a prefix of @xmath160 . then @xmath107 is longer than @xmath164",
    ". therefore @xmath165 and @xmath166 .",
    "thus @xmath167 .",
    "[ kmin - stability ] if @xmath168 , then @xmath169 for all @xmath170 , @xmath171 .",
    "show that @xmath169 implies @xmath172 . by definition , @xmath145 is the longest string among all pl - minimal strings in a set containing the candidate @xmath169 and participants .",
    "the participants are prefixes of keys due to proposition  [ participant = pref(key ) ] .",
    "now apply proposition  [ key - dichotomy ] .",
    "we conclude from this corollary the following fact : if the candidate of a node  @xmath77 equals the minimal key at moment @xmath173 , then the node @xmath77 will finish communication at some later moment . indeed ,",
    "if the participant @xmath174 is not a prefix of the minimal key , then a correction message will be transmitted ( since the candidate remains unchanged , this correction message can not be aborted ) .",
    "after that the node resumes transmission of remaining bits of the candidate ( which coincides with the minimal key ) .",
    "the node finishes communication after sending the last bit of the candidate ( the minimal key ) .",
    "due to proposition  [ kmin - stability ] it is sufficient to prove that in any node the candidate equals the minimal key at some moment of time .",
    "the proof is by induction on the distance @xmath175 from the node with the minimal key .",
    "the base case @xmath176 is clear . in this case",
    "the candidate is the minimal key from the very beginning .    for induction step ,",
    "assume that at time @xmath19 in all nodes at distance @xmath177 from the minimal one the candidates are equal to the minimal key .",
    "take a node @xmath15 at distance @xmath175 from the minimal node .",
    "the node @xmath15 has a neighbor @xmath49 at distance @xmath178 from the minimal node .",
    "as shown above , the node @xmath49 finishes transmission of the minimal key at some moment @xmath179 . at this moment",
    ", the participant @xmath180 equals the minimal key .",
    "it means that @xmath181 is also the minimal key : from propositions  [ greedy - compare ] and  [ participant = pref(key ) ] we conclude that a prefix of a key is not lesser the minimal key in the pl order ; thus the minimal elements of the set @xmath182 are prefixes of the minimal key and the minimal key is the longest among them . applying the rule for determining the next candidate , we get @xmath183 .    by similar arguments one can easily get a simple upper bound on the running time of the protocol , namely , @xmath10 , where @xmath2 is the diameter of the network and @xmath1 is the length of the minimal key .    in the next subsection",
    "we improve this bound .",
    "assume that the candidate of a node equals the minimal key at some moment of time @xmath19 .",
    "after that moment the node is transmitting the bits of the minimal key preceding by at most one correction message of the length @xmath184 . for inductive bound similar to the proof of lemma  [ weak - correctness ] , we need a lower bound of the length of the prefix of the minimal key that has been sent by the node before time  @xmath19 .",
    "this bound is based on monotonicity of the minimal key propagation through a network .",
    "if a node has sent a prefix of the minimal key , then the prefix will not be corrected in future .",
    "we state this property formally and prove it .",
    "but it is convenient to divide it in two statements .",
    "[ monotone1 ] in each node the length of the longest common prefix of the candidate in the node and the minimal key does not decrease .",
    "let @xmath185 , @xmath186 be two subsequent candidates in a  node .",
    "we prove that @xmath187 is a prefix of @xmath188 .",
    "if @xmath189 is a prefix of @xmath188 , then the statement is trivial .",
    "so , we assume that the opposite holds",
    ". then @xmath190 due to proposition  [ monotone0 ] .",
    "let @xmath191 be @xmath192 . from the definition of the pl order we get @xmath193 by proposition  [ participant = pref(key ) ] ,",
    "the string @xmath188 is a prefix of a key @xmath161 .",
    "thus , @xmath194 therefore @xmath195 is not a prefix of @xmath160 .",
    "but it implies that @xmath196 is a prefix of @xmath107 , which is a prefix of @xmath188 .",
    "a similar statement holds for participants .",
    "but the proof is more tricky because participants can be arbitrary truncated .",
    "[ monotone2 ] in each node the length of the longest common prefix of a  participant in the node and the minimal key does not decrease .",
    "let @xmath197 , @xmath198 be two subsequent participants in a  node . by the rules of the protocol , in a regular period @xmath189",
    "is a prefix of @xmath188 ( possibly , @xmath199 ) . at all moments of an exceptional period , with except for the last ,",
    "@xmath199 too .",
    "this last moment is the only nontrivial case in the proof .    at the end of an exceptional period the rules of the protocol",
    "give us @xmath200    now we prove that @xmath201 is a prefix of @xmath188 . by proposition  [ participant = pref(candidate ) ] , @xmath115 is a prefix of some earlier candidate @xmath151 , @xmath152 .",
    "a  correction message is non - empty iff @xmath115 is not a prefix of @xmath114 .",
    "it selects in the dichotomy of proposition  [ monotone0 ] the case @xmath202 .",
    "thus , @xmath203 and @xmath195 is a prefix of @xmath115 ( since @xmath115 is not a prefix of @xmath114 ) . in other words , @xmath204 .",
    "since the candidate @xmath114 is a prefix of a key @xmath161 ( proposition  [ participant = pref(key ) ] ) and @xmath205 @xmath195 is not a prefix of @xmath160 .",
    "thus , @xmath201 is a prefix of  @xmath206 .",
    "now we introduce the main tool in the time analysis of the protocol : _ the delays _ of the minimal key transmission . by definition , the delay @xmath207 in the node @xmath15 at time @xmath19 is @xmath208 , if the node has not finished the minimal key transmission at moment  @xmath19 , i.e. , if @xmath209 .",
    "otherwise , the delay is undefined .    by lemma  [ weak - correctness ]",
    ", the participant of a node equals the minimal key at some moment of time",
    ". therefore the delays in the node are bounded .",
    "let @xmath210 be the maximal delay in a  node @xmath15 .",
    "note that a sequence of the delays @xmath207 in a node is non - decreasing since the only one information bit is transmitted during a step of protocol .",
    "also note that if the node @xmath15 has not finished transmission of the minimal key at time @xmath19 , then its participant @xmath142 has a common prefix of the length at least @xmath211 with the minimal key .",
    "[ delay - lemma ] if nodes @xmath15 and @xmath49 are neighbors in a network , then @xmath212 where @xmath1 is the length of the minimal key .",
    "let @xmath213 be the last moment when a node @xmath15 sends a wrong bit , i.e. @xmath214 after that , during an exceptional period @xmath215 , correction messages are transmitted ( therefore @xmath216 ) .",
    "at the last moment of correction transmission @xmath217 the length of the participant decreases to @xmath218 , since by proposition  [ monotone2 ] the length of the longest common prefix of a participant and the minimal key does not decrease but a new participant should be a prefix of the minimal key .",
    "from a moment @xmath219 the delays do not increase : the next bit of the minimal key is transmitted at the next step . as the delay function is monotone ,",
    "we get @xmath220    we upperbound @xmath221 via the delay @xmath222 of a neighbor @xmath49 of the node  @xmath15 .",
    "as it shown above , either the participant @xmath223 has a common prefix with the minimal key that is not shorter than @xmath224 , or this participant is the minimal key .",
    "the participant is in the set of strings , which is used in determining the next candidate of the node  @xmath15 . therefore the candidate @xmath225 has a common prefix with the minimal key that is not shorter than @xmath226 . on the other hand , this",
    "common prefix coincides with @xmath227 by construction : the moment @xmath213 is regular , thus @xmath228 is a prefix of @xmath225 . from this",
    "we get @xmath229 i.e. , @xmath230",
    ".    note that for @xmath231 the length of the candidate increases at step @xmath19 while the candidate differs from the minimal key .",
    "if @xmath232 holds , then the length of the participant also increases while the participant differs from the minimal key .",
    "thus @xmath233    the difference @xmath234 equals the length of the last correction message @xmath235 which is at most @xmath236 .    finally , we get @xmath237 it completes the proof .",
    "the running time of the protocol is @xmath238 .",
    "the delay in the node with the minimal key is @xmath106 .",
    "inequality   implies that for a node at distance @xmath239 from the minimal node the delay is @xmath240 .",
    "so the maximal delay over all nodes is @xmath241 .",
    "thus each node finishes transmission of the minimal key in time @xmath238 and the running time of the protocol has the same bound .      to complete the proof of theorem  [ th : m - t - prot ] , we need to show that the above protocol constructs a spanning tree .    after finishing the protocol ,",
    "all nodes are in sleep states and their participants and candidates are equal to the minimal key .",
    "one can define a spanning tree at this moment by the following rule : a node looks at the moment , when it has received the last bit of the minimal key , and chooses as a parent a node that has sent this bit ( a choice between several nodes satisfying this condition is arbitrary ) .",
    "the node having the minimal key is the root .",
    "we obtain in this way a directed graph ( a digraph ) .",
    "fan - outs of all nodes in the digraph @xmath242 and there are no directed cycles in it ( to send the last bit of the minimal key , the node should receive it ; thus the moments of transition to a sleep state form a strictly decreasing sequence ) .",
    "but for processor terminating protocol we need a more general construction .",
    "not only the minimal key is propagating through a network .",
    "it is possible that at some moment the protocol is stopped in a part of the network but the candidates in this part differ from the minimal key .",
    "recall that no key is a  prefix of another key . by proposition  [ participant = pref(key )",
    "] candidates are prefixes of keys .",
    "thus a  node can distinguish the moments of time when its candidate is a key as well as neighbors who sent the last bit of the key .",
    "for a node @xmath15 we define a sequence of keys @xmath243 passing through the node at some moment of time",
    ". the sequence   is decreasing due to proposition  [ monotone0 ] ( recall that the pl order is a linear order on the set of keys ) .",
    "the sequence is non - empty , since initially the candidate is the key of the node .    for a key @xmath244",
    "we denote by @xmath245 the first moment @xmath19 such that @xmath246 . if @xmath247 for all @xmath19 , then @xmath248 . by definition , @xmath249 and other values of @xmath250",
    "are either positive or infinite .    if @xmath251 and @xmath252 , then @xmath253 . by the rule of determining the candidate",
    ", we get @xmath254 for some neighbor  @xmath255 of the node  @xmath15 .",
    "actually , it might be several neighbors satisfying this condition .",
    "let choose one of them arbitrary .",
    "we say that the node @xmath15 receives ( the last bit of ) the key @xmath244 from the node  @xmath255 .",
    "[ birth - seq ] @xmath256 .",
    "the sequence of candidates is non - increasing in the pl order .",
    "a  participant of a node is a prefix of an earlier candidate of the node ( proposition  [ participant = pref(candidate ) ] ) .",
    "therefore the key @xmath244 is contained in the sequence of the keys passing through the node @xmath255 .",
    "moreover , it follows from @xmath254 that @xmath256 .",
    "note that @xmath255 is a function of the communication history @xmath257 in the node @xmath15 for @xmath258 .",
    "thus , to define a function @xmath53 from the definition of a protocol constructing a spanning tree , we set @xmath259 , where @xmath244 is the minimal key among the keys that has passed through the node @xmath15 up to the moment  @xmath19 .",
    "formally , @xmath260 and @xmath261 is in the key sequence for the node @xmath15 such that @xmath262 and if @xmath263 , then @xmath264 . if @xmath265 , then @xmath266 .    at the moment",
    "@xmath38 , when the protocol is finished , the candidate of any node is the minimal key @xmath160 . for the node @xmath55",
    "having the minimal key , the function @xmath267 defined above has the value @xmath268 . in other nodes",
    "@xmath269 points to @xmath270 .",
    "thus @xmath269 defines a digraph and fan - outs of all nodes are @xmath242 . along a directed path in the digraph ,",
    "the values @xmath271 are strictly decreasing ( proposition  [ birth - seq ] ) .",
    "so , there are no cycles in the digraph and it is a rooted tree .",
    "this argument completes the proof of theorem  [ th : m - t - prot ] .",
    "in this section we prove theorem  [ th : p - t - prot ] . to define processor terminating protocols that broadcast the minimal identifier and construct a spanning tree we use the function @xmath53 described in the subsection  [ span - tree ] and a structure relying on this function . for the proofs we also need auxiliary trees in a network .",
    "these trees are defined in the next subsection .",
    "after that we provide a protocol description and the proof of correctness .",
    "an analysis of a protocol proposed below is based on a relation @xmath272 `` a  node @xmath15 receives a key @xmath244 from a node  @xmath77 '' and changes of the relation in time . for this purpose",
    "we define a digraph @xmath273 including in it all edges in the form @xmath274 , @xmath275 .",
    "let @xmath276 be an edge of the digraph @xmath273 .",
    "it means by definition that @xmath277 for some key @xmath244 and the key @xmath244 is the minimal ( in the pl order ) key that has passed through the node  @xmath15 up to a moment  @xmath19 .",
    "we say that @xmath244 is the _ edge key _ and @xmath245 is the _ birth date _ of the edge .",
    "initially , @xmath278 consists of isolated roots . at the end , as it was shown above , it is a spanning tree . for the proof of correctness we will need a stronger property .",
    "[ forest - lemma ] the digraph @xmath273 is a spanning forest for any @xmath19 .",
    "the fan - outs of the nodes are @xmath242 in this digraph by construction",
    ". therefore the only cycles in the underlying undirected graph are the directed cycles in the digraph @xmath273 . to prove that there are no directed cycles we choose an appropriate monotonicity property .",
    "a  transition from an edge @xmath276 to an edge @xmath279 in the digraph @xmath273 decreases either the edge key ( the sequence of keys is monotone in each node ) or the birth date ( proposition  [ birth - seq ] ) .",
    "thus the lengths of directed paths in @xmath273 are bounded and the digraph does not contain directed cycles .",
    "connected components of the digraph @xmath273 are rooted trees ( the roots are nodes with fan - out  0 ) .",
    "we call them _ dynamic trees _ in the network . by @xmath280",
    "we denote the connected component that has a root @xmath55 with the key @xmath281 .    in the proof below",
    "we will use also _ static _ trees corresponding to keys . let @xmath281 .",
    "then the vertices of the rooted tree @xmath282 are the nodes such that @xmath252 .",
    "the node  @xmath55 is the root , a  parent of a node @xmath15 is the node @xmath255 .",
    "since @xmath245 is decreasing on a move from a child to a parent , the graph @xmath282 is a tree indeed .",
    "we call these tree static because they are defined by the whole communication history . for some keys the tree @xmath282 consists of the root with the key  @xmath244 only . for the minimal key @xmath160",
    "the static tree @xmath283 coincides with the spanning tree constructed by the message terminating protocol from the previous section .    on figure  [ gt ]",
    "two components of a dynamic tree @xmath273 are shown .",
    "figures  [ tk1][tk2 ] show the corresponding parts of static trees @xmath284 and @xmath285 .",
    "the roots of the trees are white circles .",
    "links of the network that are not included in trees are pictured by dashed lines .",
    "it follows from the definition that a node @xmath15 is included in a tree @xmath286 iff the candidate of the node equals the key  @xmath244 at some moment .",
    "[ conserve ] moreover , an edge @xmath276 of a static tree @xmath282 is in the digraph @xmath273 at all moments @xmath19 such that the key @xmath244 is the pl - minimal key among the keys passed through the node  @xmath15 .",
    "this remark will be used in the proof below .",
    "the required protocol is combined from three protocols @xmath287 , @xmath288 , @xmath289 .",
    "its operation is divided in stages . during each stage",
    "the combined protocol performs one step of each protocol @xmath287 , @xmath288 , @xmath289 in the indicated order .",
    "thus , each protocol is operating 3 times slower",
    ". it does not affect the asymptotic bound in theorem  [ th : p - t - prot ] .",
    "in the sequel , we refer to stages of the combined protocol . after performing @xmath19 stages of the combined protocol each protocol @xmath287 , @xmath288 ,",
    "@xmath289 has performed @xmath19 steps .",
    "the protocol @xmath287 is the message terminating protocol described in the previous section .",
    "it broadcasts the minimal identifier ( formally , it broadcasts the minimal key , but an identifier can be recovered by a key ) .",
    "the second protocol @xmath288 maintains the spanning forest @xmath273 defined in subsection  [ span - tree ] . in the protocol",
    "@xmath288 nodes send messages of two types : `` i m a child '' and `` i m not a child '' .",
    "the first message is sent by a node @xmath15 at that moment when its candidate @xmath290 becomes a key @xmath251 .",
    "the node @xmath15 sends this message to the neighbor @xmath255 , which sent the last bit of the key  @xmath244 .",
    "if the node @xmath15 has a parent @xmath291 at this moment ( i.e. , in the tree @xmath292 ) , then the node @xmath15 also sends the message of the second type to the node  @xmath49 .",
    "otherwise , the node sends no message ( formally , the empty message ) .    since a step of the protocol @xmath287 is followed by a step of the protocol @xmath288 , before a step of the protocol @xmath289 nodes have correct information about their childs in the forest @xmath273 .",
    "in the finalizing protocol @xmath289 each node @xmath15 checks the _ local termination condition _ : communication with the neighbors in the protocol @xmath287 is finished , the empty message is received in the protocol @xmath288 , and the candidate and all participants of the node @xmath15 are equal to some key  @xmath244 .    in the protocol",
    "@xmath289 nodes send messages through the edges of the spanning forest @xmath273 .",
    "there are two types of messages : the confirmation ( of local finish ) message and the termination message .",
    "a  node also can send no message .",
    "divide nodes in a dynamic tree @xmath280 into three groups : the root has fan - out  @xmath106 , the intermediate nodes have childs ( fan - in @xmath293 ) and the leaves have no childs ( fan - in @xmath106 ) .    communication in the protocol @xmath289 starts in leaves .",
    "a  leaf sends the confirmation message to its parent if the local termination condition becames true for the leaf .",
    "an intermediate node collects confirmation messages from its childs .",
    "it sends the confirmation message to its parent if it has received confirmations from all its childs and the node itself satisfies the local termination condition .",
    "it is possible that the local termination condition changes the value from true to false : a node exchanged a key with all neighbors but the key is not the minimal one . if the candidate of a node is decreased in the pl order after a step of the protocol @xmath287 or the node receives the message `` i m not a child '' after a step of the protocol @xmath288 , then the node removes all confirmations received .",
    "in further operation , it ignores all incoming confirmations until its candidate becomes a key .",
    "the root also collects confirmations from its childs and checks the local termination condition .",
    "the root sends the termination message to all its childs if all childs of the root have sent confirmations and the root satisfies the local termination condition .",
    "the termination messages broadcast from parents to childs through the tree . after sending the termination message a node goes to the final state .",
    "the combined protocol is processor terminating : if a node is in the final state at time @xmath19 , then the protocol @xmath287 has finished at time @xmath19 ; all nodes are in the final state at some moment of time .    to prove the first statement of the lemma",
    ", we show that if a root of a dynamic tree @xmath280 sends the termination message , then the tree is spanning .",
    "we say that a confirmation is passed through an edge @xmath276 with the edge key @xmath294 if at some moment @xmath295 the node @xmath15 sends the confirmation message to the node  @xmath77 .",
    "nodes remove confirmations if their candidates decrease or the message `` i m not a child '' is received .",
    "thus it is sufficient to take into account only those confirmations that were passed through the edges of the tree @xmath280 with the current edge keys ( but an edge can be in an another tree at the moment of passing confirmation ) .",
    "we conclude from this observation that the root does not send the termination message at moment @xmath19 if there exists an edge @xmath276 of the tree @xmath280 such that no confirmation has passed through the edge . indeed",
    ", the keys in the roots of trees containing the edge @xmath276 form a non - increasing sequence . therefore , while the edge @xmath276 is in the tree @xmath280 , this tree also contains all edges of the path from @xmath77 to the root and no confirmation was passed through edges of this path .",
    "it means that the root does not send the termination message .",
    "if the tree @xmath280 with the root @xmath55 is not a spanning tree , then the following cases are possible .    1 .   [ cand - less ] @xmath296 .",
    "2 .   [ key - geq ] otherwise , @xmath297 due to monotonicity of the candidates in a node . but",
    "it is possible that the tree @xmath280 includes edges whose keys differ from  @xmath244 .",
    "[ good - neighbors ] @xmath297 and the edge key is @xmath244 for each edge in the tree @xmath280 .",
    "we assume that the tree is not spanning .",
    "thus , there exist `` external links '' : between nodes in the tree and outside it ( the network itself assumed to be connected ) .",
    "we call _ tree neighbors _ the endpoints of the second type .",
    "+ suppose that the following condition holds : there is no neighbor of the tree @xmath280 such that its candidate is @xmath244 at some earlier moment .",
    "4 .   [ bad - neighbors ]",
    "the last case covers the remaining option .",
    "namely , there exists a neighbor of the tree @xmath280 such that its candidate is @xmath244 at some earlier moment .",
    "* case  [ cand - less ] . *",
    "the local termination condition violates in the root @xmath55 in this case : the candidate differs from a key .",
    "thus the root does not send the termination message .    for all other cases",
    "we indicate an edge in the tree @xmath280 such that no confirmation has been passed through the edge .    * case  [ key - geq ] . * by definition of a digraph @xmath273",
    ", the root @xmath55 has not been in any tree @xmath298 , @xmath152 , @xmath299 .",
    "it implies that the only possible value of the edge key for an edge @xmath300 is @xmath244 .",
    "thus , there are two edges in the tree @xmath301 , @xmath302 such that the first edge key is @xmath299 , the second edge key is  @xmath244 , and @xmath303 .",
    "indeed , both keys passed through the node @xmath15 up to the moment @xmath19 and inequality @xmath304 contradicts the definition of a digraph @xmath273 .",
    "show that no confirmation has passed through the edge @xmath302 .",
    "suppose the opposite : the node @xmath15 has sent the confirmation message to the node  @xmath49 at a moment @xmath305 .",
    "the local termination condition implies @xmath306 .",
    "but @xmath307 , otherwise the node @xmath15 has removed this confirmation up to the moment  @xmath19 .",
    "it implies that the key sequence   in the node @xmath77 contains the key @xmath308 and the edge key for the edge @xmath301 is less than  @xmath294 .",
    "it contradicts the assumption .",
    "this contradiction completes the argument for this case .",
    "* case  [ good - neighbors ] .",
    "* suppose that a confirmation passes through an edge @xmath301 .",
    "then the node @xmath77 satisfies the local termination condition .",
    "it implies that candidates of all neighbors are  @xmath244 .    from this observation",
    "we conclude that nodes in the tree  @xmath280 having `` external links '' have not sent the confirmations .",
    "( recall that in the case into consideration candidates of any neighbor of the tree @xmath280 differ from @xmath244 at any moment up to  @xmath19 . )    * case  [ bad - neighbors ] .",
    "* recall that in this case there are nodes outside the tree @xmath280 such that their candidates were @xmath244 at some earlier moments .",
    "all these nodes are in the static tree  @xmath282 .",
    "choose among them the neighbor @xmath49 of the tree @xmath280 that has leaved the dynamic tree with the key @xmath244 at the earliest moment .",
    "let @xmath309 be the path in the static tree @xmath282 from @xmath49 to the root @xmath55 .",
    "show that no node on the path has sent the confirmation through an edge of this path ( with the edge key @xmath244 ) .    while the node @xmath49 is in the dynamic tree with the key @xmath244",
    ", the conditions of the case  [ good - neighbors ] hold : there is no neighbor of the tree such that a  candidate of the neighbor was @xmath244 .",
    "it guarantees that the node @xmath310 has not sent confirmation .",
    "suppose that confirmations were sent by nodes on the path from @xmath49 to @xmath55 at earlier moments than @xmath19 . among the nodes , which sent these confirmations ,",
    "take @xmath311  the nearest to the node @xmath49 .",
    "as it was shown above , the node @xmath311 differs from @xmath49 .",
    "therefore there is the preceding node @xmath312 on the path .",
    "if a node @xmath312 is a child of a node @xmath311 in @xmath313 , then the node @xmath311 has not received the confirmation from @xmath312 .    otherwise , the candidate @xmath314 is lesser than @xmath244 in the pl order .",
    "it implies that either the node @xmath311 does not finish communication or it received the message `` i m not a child '' from @xmath312 .",
    "both variants contradict the sending of confirmation by the node  @xmath311 .",
    "so , no confirmation has been passed through the edges of the path  .",
    "take the minimal key @xmath315 that has been passed through the node @xmath316 .",
    "if @xmath317 , then the edge @xmath318 is in the tree @xmath280 ( see remark  [ conserve ] ) and no confirmation has been passed through the edge . otherwise , the local termination condition does not hold in the root @xmath55 because the candidate of @xmath316 is lesser than @xmath244 .",
    "this completes our case analysis .",
    "so , we have proved that if the tree @xmath280 is not spanning , then its root does not send the termination message .    to prove the second statement of the lemma , note that the protocol @xmath287 terminates at some time @xmath319 .",
    "the graph @xmath313 is a spanning tree .",
    "all candidates @xmath181 and all participants @xmath320 coincide with the minimal key .",
    "thus all nodes finish communication in the protocol  @xmath287 .",
    "it means that in the protocol @xmath289 the confirmations are transmitted upward .",
    "when the root collects the confirmations from all its childs , it sends the termination message .",
    "the termination message will broadcast downward .",
    "the running time of the protocol @xmath287 is @xmath321 due to theorem  [ th : m - t - prot ] .",
    "after that all nodes have finished the communication in the protocols @xmath287 , @xmath288 and confirmations will broadcast through the spanning tree without delays as well as termination messages .",
    "so , an additional time to finish the combined protocol is @xmath322 , where @xmath175 is the depth of the spanning tree constructed .    to bound the depth of the tree , note that all nodes receive the minimal key in time @xmath238 .",
    "the depth is not greater than this value .",
    "indeed , the moments of receiving the minimal key are different along a path from the root to a node . after receiving the minimal key",
    "the node does not change a parent .",
    "thus , the running time of the combined protocol is @xmath323",
    "the authors are thankful to anonymous referees for their numerous valuable comments and suggestions ."
  ],
  "abstract_text": [
    "<S> we present fast deterministic distributed protocols in synchronous networks for leader election and spanning tree construction . </S>",
    "<S> the protocols are designed under the assumption that nodes in a network have identifiers but the size of an identifier is unlimited . </S>",
    "<S> so time bounds of protocols depend on the sizes of identifiers . </S>",
    "<S> we present fast protocols running in time @xmath0 , where @xmath1 is the size of the minimal identifier and @xmath2 is the diameter of a network .    </S>",
    "<S> we study deterministic distributed protocols for leader election and spanning tree construction in a synchronous network . </S>",
    "<S> these problems play important role in distributed computation theory ( e.g. , see books  @xcite ) .    </S>",
    "<S> it is well - known that for anonymous networks ( processors are indistinguishable ) there are no deterministic protocols solving these problems . </S>",
    "<S> so we assume that processors in a network ( _ nodes _ ) have unique names ( _ identifiers _ ) . under this assumption , </S>",
    "<S> a natural way for leader election is _ the minimal identifier broadcast _ : if all nodes in a network know the value of the minimal identifier then the node having this identifier is elected .    </S>",
    "<S> the previous study of these problems was based on the assumption that the identifiers are rather short ( say , the nodes are numbered in the range @xmath3 $ ] , where @xmath4 is the size of a network ) and messages are rather long ( the message size is @xmath5 ) . in these settings </S>",
    "<S> near - optimal protocols are known for these problems and for a more general problem of minimum spanning tree construction  @xcite .    </S>",
    "<S> we address to an intermediate situation between the anonymous case and the well - numbered case . </S>",
    "<S> namely , we assume that the nodes have identifiers but there is no a priori bound on the size of the identifiers . </S>",
    "<S> also we restrict the communication speed by @xmath6 bit per message . </S>",
    "<S> we call this model _ the unbounded identifier model_. here we consider deterministic protocols only and do not analyze possible errors in the process of information transmission .    in this model bounds for the bit complexity of protocols ( the total number of bits sent ) are known . for asynchronous ring and chain networks rather close upper and lower bounds of the bit complexity </S>",
    "<S> were obtained in  @xcite . in  @xcite protocols with near - optimal bit complexity bounds </S>",
    "<S> were presented for arbitrary synchronous networks . </S>",
    "<S> more exactly , for each monotone unbounded function @xmath7 there is a protocol that constructs a spanning tree and sends @xmath8 bits , where @xmath9 is the number of links in a network , @xmath4 is the number of nodes . </S>",
    "<S> these protocols construct rooted trees and the root is the node with the minimal identifier . </S>",
    "<S> so the protocols also elect a leader in a network .    in this paper </S>",
    "<S> we are interested in time bounds of the protocols in the unbounded identifier model . in the unbounded identifier model the running time of a protocol </S>",
    "<S> depends on the sizes of identifiers . </S>",
    "<S> we denote by @xmath1 the length of the shortest identifier . </S>",
    "<S> ( we always assume that a shorter identifier is lesser . )    </S>",
    "<S> straightforward modifications of known protocols for the unbounded identifier model run in time @xmath10 . here </S>",
    "<S> @xmath2 is the diameter of a  network . </S>",
    "<S> we present better protocols .    </S>",
    "<S> we present the message terminating protocol and the processor terminating protocol for leader election and spanning tree construction . </S>",
    "<S> the definitions for these types of protocols are taken from the paper  @xcite . </S>",
    "<S> the message termination means that at some moment of time all nodes are in a _ </S>",
    "<S> sleep state_. in such a  state a  node does not send messages but can change the state after receiving a suitable message . </S>",
    "<S> the processor termination means that at some moment of time all nodes are in the _ </S>",
    "<S> final state_. this state can not be changed by any message . in other words , a node in the final state is off - line . </S>",
    "<S> processor terminating is a stronger property . </S>",
    "<S> it is important , e.g. , for compositions of protocols .    </S>",
    "<S> the following two results are our main contribution .    </S>",
    "<S> [ th : m - t - prot ] there exists a message terminating protocol that broadcasts the minimal identifier and constructs a rooted spanning tree in time @xmath11 , where @xmath1 is the length of the minimal identifier and @xmath2 is the diameter of the network .    </S>",
    "<S> [ th : p - t - prot ] there exists a processor terminating protocol that broadcasts the minimal identifier and constructs a rooted spanning tree in time @xmath11 , where @xmath1 is the length of the minimal identifier and @xmath2 is the diameter of the network .    </S>",
    "<S> these protocols are modifications of flooding and echo protocols designed for the well - numbered model . </S>",
    "<S> to speed up a flooding protocol in the unbounded identifier model , we introduce a suitable encoding of identifiers ( see section  [ id->key ] below ) and add a correction phase to the process of information transmission .    </S>",
    "<S> note also that the protocols presented in this paper remain correct in the asynchronous case . </S>",
    "<S> but time bounds are valid for the synchronous case only .    </S>",
    "<S> the rest of paper is organized as follows . in section  [ defs ] </S>",
    "<S> we give formal definitions of our model and the problems solved by protocols . </S>",
    "<S> section  [ informal ] contains an overview of our construction . </S>",
    "<S> section  [ min - broadcasting ] contains the proof of theorem  [ th : m - t - prot ] : a  detailed description of the message terminating protocol that broadcasts the minimal identifier in a network , the proof of correctness , the upper bound of the running time and spanning tree construction based on this protocol . in section  </S>",
    "<S> [ finalizing ] we present the proof of theorem  [ th : p - t - prot ] based on a suitable modification of an echo protocol combined with the previous protocol that broadcasts the minimal identifier . </S>"
  ]
}