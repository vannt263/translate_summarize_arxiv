{
  "article_text": [
    "matrix inversion is a computation task necessary in many scientic applications , such as signal processing , complex network analysis , statistics @xcite and some eigenvalue - related problems @xcite , to name just a few .",
    "there are some commonly available matrix inversion algorithms for any nonsingular matrix , like gaussian elimination , gauss - jordan , lu decomposition and cholesky decomposition .",
    "the majority of these algorithms are computationally intensive in use of memory and processor .",
    "for example , to compute the inverse of a @xmath3 matrix @xmath1 with gauss - jordan method has computational complexity of @xmath4 and memory storage complexity of @xmath5 .",
    "this can limit applicability of such methods for large - scale matrices , mainly , because of the amount of memory present in computational systems which is always bounded .    working with big data",
    "is a situation becoming increasingly common in today@xmath6s world in view of advances in sensor and communication technologies , coupled with increased processing power .",
    "this has become a challenging task because of the limited processing and memory capacity of conventional computers . in classification ( or regression ) problems , for example , inverting matrices of extremely high order @xcite can lead to exceeding the computer memory capacity just to store its inverse . in a scenario in which the data does not fit in the memory , it is worth to consider increasing iterations on the data , even if that increases processing time in order to allow such computations to be completed .    in linear algebra terms , the use of block partitioned matrices is commonly used to cut down processing time of matrices , column - row expansions , and many computer science applications , including vlsi chip design .",
    "block matrices may occurs , naturally , due to the ordering of the equations and the variables in wide variety of scientific and engineering applications , such as in the incompressible navier - stokes equations @xcite , mixed finite elements approximation of elliptic partial differential equations @xcite , optimal control @xcite , eletrical networks @xcite and the strassen s algorithm @xcite for fast matrix multiplication .",
    "algorithms that manipulate matrices at the block level are often more efficient because they are more abundant in level-3 operations @xcite , and thus , can be implemented recursively .",
    "there are many related papers on the inverse of block matrices . in @xcite ,",
    "the authors give inverse formulae for @xmath7 block matrices applied in block triangular matrices and various structured matrices such as hamiltonian , per - hermitian and centro - hermitian matrices .",
    "the inversion of block circulant matrices has been extensively investigated in @xcite and @xcite .",
    "also , there are research suggesting the use block preconditioner for the block partitioned matrices @xcite .",
    "likewise , recursive algorithms have been applied in @xcite , @xcite and @xcite for the inversion of particular cases of matrices , such as circulant - structured matrices . in @xcite",
    "a recursive method is proposed for the lu decomposition of a real symmetric circulant matrix . in @xcite ,",
    "a recursive algorithm is applied for the determination of the first block row of the inverse of a block circulant matrix with circulant blocks . and ,",
    "finally , @xcite proposed a recursive algorithm based on the inversion of @xmath0 block matrices for cases of matrices with circulant blocks based on previous diagonalization of each circulant block .    in @xcite , parts of inverse matrix , namely , the diagonal blocks of kernel matrix of the least squares support vector machine ( ls - svm )",
    "was used to compute the predicted labels of the cross validation algorithms .",
    "thus , it is not necessary to compute and , in fact , store in memory the entire inverse kernel matrix .    in this paper , motivated by the preceding considerations ,",
    "we introduce a recursive method for the inversion of a @xmath0 block matrix @xmath1 with square blocks of order @xmath8 .",
    "the basic idea of this algorithm lies on the determination of one block of the inverse of the matrix at a time .",
    "the method is based on successive splitting of the original matrix in @xmath9 square matrices of the inferior order , called frames . for this",
    ", it is considered two stages , namely the forward recursive procedure and backward recursive procedure .",
    "the forward recursive procedure terminates after @xmath10 steps , when the resulting frames have @xmath7 blocks . thereafter ,",
    "in the backward recursive procedure , for each 4 frames generated , operations are carried out reducing them to a single block .",
    "this paper is organized as follows . in section 2 , we introduce some notations and summarize the main definitions about inversion of @xmath7 block matrices using schur complement . in section 3 , we present the recursive algorithm . in section 4 ,",
    "we demonstrate a representative example of inverses of @xmath11 block matrices by recursion .",
    "finally , in section 5 , we present some numerical results , exhibiting the efficiency of the proposed method in terms of processing time and using of computational memory .",
    "in this section we begin with some basic notation which is frequently used in the sequel .",
    "let @xmath12 be a nonsingular matrix composed of square blocks @xmath13 of the same order @xmath14,\\ ] ]    where @xmath13 designates the @xmath15 block . with this notation , block",
    "@xmath13 has dimension @xmath16 , with @xmath17 , and @xmath18 is a @xmath19 block matrix .",
    "assume that @xmath20 is the inverse matrix of @xmath12 .",
    "so , @xmath21.\\ ] ]    assigning @xmath22 , then we have a @xmath7 block matrix as @xmath23,\\ ] ] where @xmath24 , @xmath25 , @xmath26 and @xmath27 ; and @xmath20 is its inverse matrix as @xmath28,\\ ] ] where @xmath29 , @xmath30 , @xmath31 and @xmath32 .",
    "if @xmath1 is nonsingular , the schur complement of @xmath12 with respect to @xmath1@xcite , denoted by @xmath33 , is defined by    @xmath34    let us remark that it is possible to define similarly the following schur complements    @xmath35    @xmath36    @xmath37    provided that the matrices @xmath38 , @xmath39 and @xmath40 are nonsingular only in ( [ eq : schurofb ] ) , ( [ eq : schurofc ] ) and ( [ eq : schurofd ] ) , respectively @xcite .",
    "considering the @xmath40 block , if both @xmath12 and @xmath40 in ( [ eq : blockmatrices2x2 ] ) are nonsingular , then @xmath41 is nonsingular , too , and @xmath12 can be decomposed as    @xmath42 \\left[\\begin{array}{cc } ( m / d ) & 0 \\\\ 0 & d \\end{array}\\right ] \\left[\\begin{array}{cc } i & 0 \\\\ d^{-1}c & i \\end{array}\\right],\\ ] ]    where @xmath43 is the identity matrix . in this case",
    ", the inverse of @xmath12 can be written as @xmath44 \\left[\\begin{array}{cc } \\scriptstyle ( m / d)^{-1 } & \\scriptstyle 0 \\\\ \\scriptstyle 0 & \\scriptstyle d^{-1 } \\end{array}\\right ] \\left[\\begin{array}{cc } \\scriptstyle i & \\scriptstyle -bd^{-1 } \\\\",
    "\\scriptstyle 0 & \\scriptstyle i \\end{array}\\right ] \\\\   & = & \\left[\\begin{array}{cc } \\scriptstyle ( m / d)^{-1 } & \\scriptstyle -(m / d)^{-1}bd^{-1 } \\\\   \\scriptstyle   -d^{-1}c(m / d)^{-1 } & \\scriptstyle   d^{-1}+d^{-1}c(m / d)^{-1}bd^{-1 } \\end{array}\\right ] .",
    "\\end{aligned}\\ ] ]    the formulae in ( [ eq : invschur ] ) is well known and has extensively been used in dealing with inverses of block matrices @xcite .",
    "it is worth noting that , according to ( [ eq : invschur ] ) , to get @xmath45 just calculate the inverse of schur complement of @xmath40 in @xmath12 .    following this premise ,",
    "it was observed that to obtain @xmath46 of inverse of the @xmath47 blocks matrix , with @xmath48 , just successively split the matrix involved in @xmath9 square matrices of the same order , called frames , following some basic rules .",
    "thereafter , for each 4 frames generated , should apply the schur complement in the opposite direction to the recursion , reducing them to a single frame .",
    "finally , @xmath46 is obtained by calculating the inverse of schur complement of the last @xmath9 frames involved in the reverse process to the recursion .    for a better understanding",
    ", the algorithm will be explained considering two stages , namely the _ forward recursive procedure _ and _ backward recursive procedure_. for this process , consider ( [ eq : blockmatricesnxn ] ) as the input block matrix",
    ".      * step 1 : * we split the input , a @xmath0 block matrix @xmath12 , into four @xmath49 block matrices @xmath50 , @xmath51 , @xmath52 and @xmath53 , called frames , excluding one of the block rows of @xmath12 and one of the block columns of @xmath12 as follows .",
    "the frame @xmath50 results from the removal of the lowermost block row and rightmost block column of @xmath12 ; @xmath51 results from the removal of the lowermost block row and leftmost block column of @xmath12 ; @xmath52 results from the removal of the uppermost block row and rightmost block column of @xmath12 and , finally , @xmath53 results from the removal of the uppermost block row and leftmost block column of @xmath12 , as shown in ( [ eq : f_k-1 ] ) .",
    "@xmath54 \\\\ \\nonumber m \\rangle_b = \\left[\\begin{array}{ccc } m_{12 } & \\cdots & m_{1k } \\\\",
    "\\vdots & \\ddots & \\vdots \\\\ m_{(k-1)2 } & \\cdots & m_{(k-1)k }   \\end{array}\\right ] \\\\ \\nonumber m \\rangle_{c } = \\left[\\begin{array}{ccc } m_{21 } & \\cdots & m_{2(k-1 ) } \\\\ \\vdots & \\ddots & \\vdots \\\\ m_{k1 } & \\cdots & m_{k(k-1 ) }   \\end{array}\\right ] \\\\   \\nonumber m \\rangle_{d } = \\left[\\begin{array}{ccc } m_{22 } & \\cdots & m_{2k } \\\\",
    "\\vdots & \\ddots & \\vdots \\\\ m_{k2 } & \\cdots & m_{kk }   \\end{array}\\right]\\end{aligned}\\ ] ]     + * step 2 : * exchange block rows and/or block columns until the that block @xmath55 reaches its original place , namely , second block row and second block column . in this case , in the frame @xmath50 , no exchange occurs . in @xmath51",
    ", it is necessary to exchange the two leftmost block columns . in @xmath52 , it is necessary to exchange the two uppermost block rows . and ,",
    "finally , in @xmath53 , simply exchange the two leftmost block columns and the two uppermost block rows .",
    "so , applying these exchanges , we have    @xmath56 \\\\",
    "m \\rangle_b & = & \\left[\\begin{array}{cccc } m_{13 } & m_{12 } & \\cdots & m_{1k } \\\\",
    "m_{23 } & m_{22 } & \\cdots & m_{2k } \\\\",
    "m_{33 } & m_{32 } & \\cdots & m_{3k } \\\\",
    "\\vdots & \\vdots & \\ddots & \\vdots \\\\ m_{(k-1)3 } & m_{(k-1)2 } & \\cdots & m_{(k-1)k }   \\end{array}\\right ] \\\\",
    "\\nonumber m \\rangle_c & = & \\left[\\begin{array}{cccc } m_{31 } & m_{32 } & \\cdots & m_{3(k-1 ) } \\\\ m_{21 } & m_{22 } & \\cdots & m_{2(k-1 ) } \\\\ m_{41 } & m_{42 } & \\cdots & m_{4(k-1 ) } \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ m_{k1 } & m_{k2 } & \\cdots & m_{k(k-1 ) }   \\end{array}\\right ]   \\\\ \\nonumber m \\rangle_d & = & \\left[\\begin{array}{cccc } m_{33 } & m_{32 } & \\cdots & m_{3k } \\\\ m_{23 } & m_{22 } & \\cdots & m_{2k } \\\\ m_{43 } & m_{42 } & \\cdots & m_{4k } \\\\",
    "\\vdots & \\vdots & \\ddots & \\vdots \\\\ m_{k3 } & m_{k2 } & \\cdots & m_{kk }   \\end{array}\\right]\\end{aligned}\\ ] ]    next , we split each one of the frames in ( [ eq : f_k-1_changem22 ] ) , @xmath50 , @xmath51 , @xmath52 e @xmath53 into four @xmath57 frames , excluding one of its block rows and one of its block columns , as showed in step 1 .",
    "for example , splitting the frame @xmath53 , we have :    @xmath58 \\\\",
    "m \\rangle_d \\rangle_b & = & \\left[\\begin{array}{cccc } m_{32 } & m_{34 } & \\cdots & m_{3k } \\\\",
    "m_{22 } & m_{24 } & \\cdots & m_{2k } \\\\",
    "m_{42 } & m_{44 } & \\cdots & m_{4k } \\\\",
    "\\vdots & \\vdots & \\ddots & \\vdots \\\\ m_{(k-1)4 } & m_{(k-1)2 } & \\cdots & m_{(k-1)k } \\end{array}\\right ] \\\\ \\nonumber m \\rangle_d \\rangle_c & = & \\left[\\begin{array}{cccc } m_{23 } & m_{22 } & \\cdots & m_{2(k-1 ) } \\\\ m_{43 } & m_{42 } & \\cdots & m_{4(k-1 ) } \\\\ m_{53 } & m_{52 } & \\cdots & m_{5(k-1 ) } \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ m_{k3 } & m_{k2 } & \\cdots & m_{k(k-1 ) }    \\end{array}\\right ] \\\\",
    "\\nonumber m \\rangle_d \\rangle_d & = & \\left[\\begin{array}{cccc } m_{22 } & m_{24 } & \\cdots & m_{2k } \\\\",
    "m_{42 } & m_{44 } & \\cdots & m_{4k } \\\\",
    "m_{52 } & m_{54 } & \\cdots & m_{5k } \\\\",
    "\\vdots & \\vdots & \\ddots & \\vdots \\\\ m_{k2 } & m_{k4 } & \\cdots & m_{kk }    \\end{array}\\right]\\end{aligned}\\ ] ]     + * step i : * for each of the @xmath59 frames resulting from the previous step ( step i-1 ) , @xmath60 @xmath61 , @xmath62 and @xmath63 , make the permutation of block rows and/or blocks columns and then generate more four @xmath64 frames , @xmath65 , @xmath66 , @xmath67 and @xmath68 , excluding one of its block rows and one of its block columns in a manner analogous to what was done in step 2 to the frames resulting from step 1 . repeat step i until @xmath69 .",
    "the superscript number to the `` @xmath70 '' symbol indicates the amount of these existing symbols , including those not represented .",
    "thus , it denotes @xmath71 with @xmath72 e @xmath73 .",
    "* step 1 : * for each of the resulting @xmath7 frames from the step k-2 in the forward recursive procedure , in subsection [ subsec : forward ] , @xmath74 @xmath75 , @xmath76 e @xmath77 , compute the schur complement of @xmath55 to generate the blocks : @xmath78 @xmath79 , @xmath80 and @xmath81 , using the equations ( [ eq : schurofd ] ) , ( [ eq : schurofc ] ) , ( [ eq : schurofb ] ) and ( [ eq : schurofa ] ) , in that order .",
    "the  @xmath82 ",
    "symbol indicates that the schur complement operation was done on the respective frame . + * step 2 : * assemble @xmath83 , @xmath84 , @xmath85 and @xmath86 , joining the four frames that were originated by each in the forward recursive procedure previously reported in [ subsec : forward ] , in the following way :    @xmath87,\\ ] ]    @xmath88,\\ ] ]    @xmath89,\\ ] ]    @xmath90.\\ ] ]    then , for each of these @xmath7 block matrices , calculate the schur complement applying ( [ eq : schurofd ] ) , ( [ eq : schurofc ] ) , ( [ eq : schurofb ] ) and ( [ eq : schurofa ] ) , in this order , generating the blocks : @xmath91 , @xmath92 , @xmath93 and @xmath94 . +",
    "* step i : * considering each four branches of the recursion , repeat the previous step generating frames @xmath95 , @xmath96 , @xmath97 and @xmath98 , until @xmath69 and thus get @xmath99 , @xmath100 , @xmath101 e @xmath102 . +",
    "* step k-1 : * assemble @xmath103 from @xmath104 , @xmath105 , @xmath106 e @xmath107 , in the following way :    @xmath108.\\ ] ]    and , finally , calculate the schur complement of @xmath103 with respect to @xmath107 using equation ( [ eq : schurofd ] ) .",
    "thus , the inverse of the matrix corresponding to @xmath46 corresponds to    @xmath109    it is worth noting that with suitable permutation of rows and columns , we can position any block in the upper left - hand corner of @xmath12 and get the corresponding inverse to this block with respect to @xmath12 .",
    "in order to clarify the operation of proposed algorithm of the inversion of @xmath16 block matrices , this section presents the process of inversion of a @xmath11 block matrix .",
    "the basic idea of the recursive algorithm , as shown in section [ sec : recursive_algorithm ] , for the inversion of @xmath11 block matrices lies in the fact that in each step the involved matrices are split into four square matrices of the same order until to get @xmath7 block matrices .",
    "consider that a nonsingular @xmath110 matrix @xmath12 can be partitioned into @xmath11 blocks of order @xmath8 as    @xmath111\\ ] ]    and @xmath20 is its inverse matrix :    @xmath112.\\ ] ]    now , consider four square matrices of order @xmath113 generated from @xmath12 by the process of excluding one of its block rows and one of its block columns , as shown in step 1 of subsection [ subsec : forward ] , for @xmath114 matrices .",
    "after positioning the block @xmath55 to its original position in @xmath12 ( step 2 ) , these frames are as follows :    @xmath115 \\quad m \\rangle_b   = \\left[\\begin{array}{ccc } m_{13 } & m_{12 } & m_{14}\\\\ m_{23 } & m_{22 } & m_{24}\\\\ m_{33 } & m_{32 } & m_{34 } \\end{array}\\right ] \\\\",
    "\\nonumber m \\rangle_c   = \\left[\\begin{array}{ccc } m_{31 } & m_{32 } & m_{33}\\\\ m_{21 } & m_{22 } & m_{23}\\\\ m_{41 } & m_{42 } & m_{43 } \\end{array}\\right ] \\quad m \\rangle_d   = \\left[\\begin{array}{ccc } m_{33 } & m_{32 } & m_{34}\\\\ m_{23 } & m_{22 } & m_{24}\\\\ m_{43 } & m_{42 } & m_{44 } \\end{array}\\right]\\end{aligned}\\ ] ]    thus , recursively , each of the frames @xmath50 , @xmath51 , @xmath52 and @xmath53 will be divided into four @xmath7 frames , applying the rules discussed in subsection [ subsec : forward ] ( steps 2 and i ) .",
    "this process is illustrated in figure [ fig : forwardprocedure ] .",
    "splitting , for example , the @xmath51 frame , the following frames are obtained :    @xmath116 , \\quad m \\rangle_b \\rangle_b = \\left[\\begin{array}{cc } m_{12 } & m_{14}\\\\ m_{22 } & m_{24 } \\end{array}\\right ] , \\\\",
    "\\nonumber m \\rangle_b \\rangle_c = \\left[\\begin{array}{cc } m_{23 } & m_{22}\\\\ m_{33 } & m_{32 } \\end{array}\\right ] , \\quad m \\rangle_b \\rangle_d = \\left[\\begin{array}{cc } m_{22 } & m_{24}\\\\ m_{32 } & m_{34 } \\end{array}\\right].\\end{aligned}\\ ] ]    as the step 1 of subsection [ subsec : backward ] , assuming @xmath55 as nonsingular and using the equations ( [ eq : schurofd ] ) , ( [ eq : schurofc ] ) , ( [ eq : schurofb ] ) and ( [ eq : schurofa ] ) , in that order , the schur complement of @xmath55 for each of the frames in ( [ eq : frames2x2_of_fb3 ] ) are :    @xmath117    @xmath118    @xmath119    @xmath120    running the step 2 of backward recursive procedure from the recursion algorithm presented in subsection [ subsec : backward ] , have that :    @xmath121\\ ] ]    @xmath122\\ ] ]    @xmath123\\ ] ]    @xmath124\\ ] ]    assuming @xmath55 and @xmath125 , @xmath126 , @xmath127 and @xmath128 as nonsingular and using the equations ( [ eq : schurofd ] ) , ( [ eq : schurofc ] ) , ( [ eq : schurofb ] ) and ( [ eq : schurofa ] ) , in that order , the schur complement to get for each of the frames are : @xmath129 @xmath130 @xmath131 @xmath132",
    "so , as the step k-1 of subsection [ subsec : backward ] , let @xmath133 be a block matrix generated by matrices resulting from ( [ eq : schur_phi_2_a ] ) , ( [ eq : schur_phi_2_b ] ) , ( [ eq : schur_phi_2_c ] ) and ( [ eq : schur_phi_2_d ] ) , as shown in figure [ fig : backwardprocedure ] .",
    "@xmath134\\ ] ]    thus , @xmath133 is a @xmath7 block matrix generated from the original @xmath11 block matrix .",
    "so , in order to get @xmath46 , simply to get the inverse of schur complement of @xmath135 in @xmath133 , following the same formula used to get @xmath45 , shown in the upper left - hand corner of ( [ eq : invschur ] ) , namely @xmath136 .",
    "applying this formula , we have @xmath137",
    "10 url # 1`#1`urlprefixhref # 1#2#2 # 1#1          h.  elman , v.  e. howle , j.  shadid , r.  shuttleworth , r.  tuminaro , a taxonomy and comparison of parallel block multi - level preconditioners for the incompressible navier ",
    "stokes equations , journal of computational physics 227  ( 3 ) ( 2008 ) 17901808 ."
  ],
  "abstract_text": [
    "<S> the inversion of extremely high order matrices has been a challenging task because of the limited processing and memory capacity of conventional computers . in a scenario </S>",
    "<S> in which the data does not fit in memory , it is worth to consider increasing iterations on the data , even if that increases processing time in order to allow such computations to be completed . </S>",
    "<S> we propose a algorithm to compute the inverse of block partitioned matrices as a new form of decreasing the memory footprint . </S>",
    "<S> the proposed algorithm works recursively to invert one block of a @xmath0 block matrix @xmath1 , with @xmath2 , based on the successive splitting of a. the algorithm compute one block of the inverse at a time , in order to limit memory usage during the entire processing .    </S>",
    "<S> block matrices , large matrices , schur complement , recursive inversion </S>"
  ]
}