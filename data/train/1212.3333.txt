{
  "article_text": [
    "multi - scale phenomena are common in many areas of research , in particular astrophysics and cosmology , fluid dynamics , and mechanical engineering .",
    "an example is the formation of the first stellar objects in the universe , involving spatial scales that range from several 10,000 light years , representing the overall dynamics of the proto - galaxies , down to the star forming regions in the order of a few light hours across  @xcite .",
    "tackling such processes numerically is a challenging task , and naive approaches using constant resolution fail due to their exorbitant computational requirements . hence adaptive techniques are crucial for this type of problems , as they allow to locally adjust the spatio - temporal resolution to the features of the particular system .",
    "a popular adaptive approach for numerically solving partial differential equations is _ structured adaptive mesh refinement ( samr ) _",
    "it combines the simplicity of structured grids with the benefits of local refinement by recursively overlaying regions of the computational domain with patches of structured grids of increasing resolution .",
    "applying standard visualization techniques to amr datasets has always been challenging , partly due to the arbitrary extension and placement of the subgrid patches , partly because of their sheer numbers .",
    "this holds in particular for gpu - based volume rendering approaches , which leverage the capabilities of texturing units of current graphics hardware architectures .",
    "these operate most efficiently on regular grids and therefore a partitioning of the computational domain covered by the samr grids into non - overlapping blocks of cells with the same resolution is crucial for good performance .",
    "adaptive kd - tree have been proven to be particularly suitable for this tasks  @xcite , but previous gpu - based methods required a single rendering pass for each of the resulting blocks , which inhibits the direct application of many advanced shading and lighting effects that need to simultaneously access data from more than one subgrid patch or require non - standard blending equations .",
    "in this paper we present a single - pass gpu - raycasting approach for amr data .",
    "it is based on an efficient kd - tree partition of the domain that minimizes the number of generated nodes and can directly be applied also to non - nested subgrids , which refine regions of more than one coarse `` parent '' grid patch .",
    "we propose an efficient encoding of the resulting tree using a set of 3d - textures , enabling the traversal of the tree and an adaptive sampling of the data on the gpu , on a per - pixel basis in the fragment shader , without any cpu interaction .",
    "we further discuss two different approaches to store the data associated with the amr grid patches : one using a packing scheme to organize the patches in a larger _ memory pool _ texture , the other employing _ nvidia s _ _ bindless texture _",
    "extension  @xcite for the _ opengl_-api .",
    "the remainder of this paper is organized as follows . in section  [ sec::relatedwork ]",
    "we discuss related work .",
    "we review the amr scheme in section  [ sec::amr ] and describe the new kd - tree generation strategy and its encoding on the gpu in section  [ sec::renderingalgorithm ] .",
    "the gpu - data access scheme as well as the rendering algorithm will be discussed in section  [ sec::gpudatastorage ] .",
    "we end with results and conclusions in section  [ sec::results ] and  [ sec::conclusions ] .",
    "to the best of our knowledge the first cpu - based volume rendering method for amr data was proposed by max  @xcite .",
    "it employed a back - to - front cell - sorting and cell - projection scheme .",
    "later the _ dual - mesh",
    "_ approach  @xcite , for higher order interpolation of `` cell - centered '' amr data without resampling , has been extended for more general subgrid configurations and was used for a direct volume rendering approach  @xcite .",
    "further several parallel cpu - based volume rendering methods for cluster architectures data have been presented  @xcite .    the first gpu - supported volume rendering approach for amr data",
    "was presented by weber  et  al .",
    "the authors applied their dual - mesh-``stitching '' scheme to implement a hardware - supported cell - projection algorithm rendering the faces of the resulting cells as semi - transparent triangles .",
    "kaehler  et  al . presented a 3d - texture - based volume rendering approach for large , sparse datasets , that clusters non - transparent voxels into axis - aligned blocks and encodes these as leaf nodes of amr data structures .",
    "@xcite they also described a multi - resolution texture - based volume rendering algorithm for amr data  @xcite .",
    "park  et  al .",
    "@xcite presented a hierarchical splatting approach for amr data .",
    "kelley  et  al .",
    "@xcite describe a framework for interactive , parallel volume rendering of remote amr data , that distributes subtrees of the amr hierarchy on individual processors and composes the images on a local rendering client .    with the advent of programmable graphics hardware that supports flexible shader programs , it became feasible to perform the ray integration on a per - pixel basis at interactive frame rates  @xcite .",
    "in the latter approach the data is converted to a 3d texture and a fragment shader is executed for each pixel that is covered by the projected bounding box of the data volume .",
    "the ray is parameterized in texture coordinates and the ray - integral is computed in the fragment shader .",
    "gpu - raycasting is particularly attractive for adaptive grids , as it does not suffer from the rendering artifacts inherent to slice - based methods , which can lead to visible artifacts at the interfaces between different resolution levels .",
    "gpu - raycasting has been extended to samr data , using a kd - tree that is traversed on the cpu and rendered node - by - node in separate rendering passes  @xcite .",
    "all previous approaches for single - pass multi - resolution gpu - raycasting were based on regular data structures , such as octrees or other partition strategies using regularly shaped nodes  @xcite . in principle also amr data structures can be partitioned in blocks of cells from the same resolution level using octrees . however , the resulting tree is usually inefficient , in particular if higher order interpolation is desired , because of the large number of resulting nodes  @xcite . in contrast",
    "kd - trees allow to minimize the number of nodes by adaptively choosing the position of the spatial subdivision planes and have been successfully applied to cpu- , and gpu - based volume rendering of amr data  @xcite .",
    "in this paper we present the first single - pass gpu - raycasting approach for amr data based on a kd - partition of the data domain .",
    "in the _ adaptive mesh refinement ( amr ) _",
    "@xcite approach the computational domain is covered by a set of coarse , structured subgrids.the configuration of this set of coarse grids is usually fixed over time . in a first step",
    "the solution of the ( partial differential ) equations is computed on these coarse grids and local error estimators are utilized to detect cells that require higher resolution .",
    "these cells are clustered into a set of rectangular grid patches , usually called _ subgrids _ , which do not replace , but rather overlap the corresponding regions of the coarse base grids .",
    "( a )    ( b )    ( c )    the equations are solved on these higher resolved subgrids , and the refinement procedure recursively continues until all cells have sufficient resolution , giving rise to a hierarchy of nested refinement levels , as shown in figure  [ img : spatialrefinementamr ] .",
    "a major advantage of amr is that each subgrid can be viewed as a separate , independent structured grid with its separate storage space .",
    "this allows to process subgrids almost independently , and thus it is well - suited for parallel processing .",
    "a popular variant of this general approach is _ structured adaptive mesh refinement ( samr ) _",
    "@xcite , where in contrast to the original scheme , the subgrids are aligned with the major axes of the coordinate system . in the following we will restrict the discussion to samr and just refer to it as amr . in the remainder of this section we will briefly introduce some notations that are used in this paper .    let @xmath0 denote the mesh spacing of the coarsest grids .",
    "the mesh spacings of the finer grids are recursively defined by @xmath1 for @xmath2 , where the positive integer @xmath3 denotes the so - called _ refinement factor _ and @xmath4 numbers the _ refinement level _ , starting with @xmath5 for the coarsest level . in principle",
    "the refinement factor can differ for each direction and each level , but in order to simplify the notation we assume that it is constant . in the amr approach , each refined cell is overlaid by a set of @xmath6 cells of the next level of refinement . in the original amr scheme  @xcite each refinement level was enclosed by at least one layer of cells from the next coarser level of resolution , such that adjacent cells differ by at most one level .",
    "this constraint was later relaxed  @xcite . in the following",
    "we will call the set of coarsest subgrids the _ root _ level and denote the @xmath7-th _ subgrid _ of the refinement level  @xmath4 by @xmath8 , see figure  [ fig::gridstructure ] .",
    "the outline of our gpu - raycasting algorithm can be summarized as follows :    * first the hierarchy of nested refinement levels is decomposed into non - overlapping , axis - aligned blocks , each covering only cells from the same level of resolution .",
    "these are organized in an adaptive kd - tree data structure , encoded using a set of integer - valued 3d textures . *",
    "the data associated with the separate grids are either packed into a single 3d texture or accessed dynamically as individual textures using _ nvidia s bindless texture _ extension for _ opengl_. * the textures are uploaded onto the gpu and the kd - tree is traversed in the fragment shader . for each pixel the intersections between the viewing ray and the nodes of the kd - tree are computed and the resulting ray - segments are processed in a front - to - back order .",
    "the color and opacity contribution of each segment is computed by adaptively sampling the corresponding textures , with a sampling distance based on the underlying level of refinement .",
    "the contributions are accumulated to yield the overall pixel color , which is written to the frame - buffer after all segments have been processed .    in the next subsections",
    "we will describe these steps in more detail .      in order to leverage the capabilities of texturing units on current graphics hardware , e.g.  for fast constant or tri - linear interpolation on regular grids ,",
    "it is beneficial to subdivide the data domain into separate blocks which do not overlap and cover only cells from the same resolution level . rendering a given hierarchy of separate subgrids",
    "directly would result in rendering artifacts , since in the amr approach the subgrid patches on finer levels do not replace but rather overlay regions of coarser levels , so refined regions of the data volume would be rendered multiple times .",
    "the root node of the kd - tree is defined by the enclosing bounding box @xmath9 of all subgrids @xmath10 on the root level of the amr hierarchy .",
    "@xmath9 is recursively subdivided by axis - aligned splitting planes , each defining the two child nodes of their parent node . in order to keep the number of generated blocks small ,",
    "the splitting planes are chosen such that they minimize the number of intersections with the bounding boxes of the subgrids in the domain represented by each node .",
    "therefore we sweep the plane parallel to all three major coordinate planes and determine the number of intersections . the split that introduces the smallest number of intersections and has at least one slab of cells on each side ,",
    "is chosen . in case",
    "several such splits exist , we chose the one that divides the subgrids in the most balanced way , in the sense that the ratio of the number of cells on each side is closest to @xmath11 . the recursion stops , once a node covers only cells from the same subgrid .    next all subgrids @xmath12 of the first refinement level are processed . for each leaf node in the current kd - tree",
    "we build a list with all the subgrids @xmath12 that overlap with it .",
    "this can be determined efficiently by traversing the current kd - tree top - down starting at the root node , visiting only the child nodes that intersect @xmath12 .",
    "next the kd - tree is refined at each of the resulting leafs , by determining the optimal splitting planes for the blocks defined by the intersections between the subgrids and the region represented by the leaf node as discussed above .",
    "this procedure is continued for the other refinement levels , successively extending the tree for each level , until all subgrids @xmath13 in the hierarchy are processed . a 2d example for the subgrid configuration from figure  [ fig::gridstructure ]",
    "is shown in figure  [ fig : kd - tree ] .",
    "the resulting kd - tree consists of three types of nodes :    a.   nodes representing regions of the computational domain with cells that are further refined , b.   nodes that cover only cells that are unrefined , i.  e. leaf nodes of the kd - tree , and c.   nodes that cover both , refined and unrefined cells , which are used to traverse the tree in a view - consistent order .",
    "the first type of nodes allows for a level - of - detail selection during the rendering phase , as the corresponding region is covered by at least two levels of resolution . if the resolution of the coarser level is sufficient , which can for example be decided based on the projected screen - space extension of the cells , the node is rendered at this resolution and the traversal is stopped , otherwise the sub - tree of the node is visited .",
    "( a )    ( b )    no data from the original amr hierarchy is copied in this process , but rather solely offsets and bounding box information as well as references to the original subgrids are stored with the kd - tree .      to traverse the kd - tree structure on the gpu ,",
    "we represent it by a set of 3d textures .",
    "the first texture , called _ tree texture _ in the following , encodes the structure of the kd - tree , using one texel for each node .",
    "each texel consists of @xmath14  bits , split into @xmath15  bits for the _ red _ and _ green _ channel .",
    "the root node of the tree is stored at texel coordinates @xmath16 .",
    "the first two bits of the _ red_-channel encode the orientation of the splitting plane that defines the two child nodes and the next @xmath17  bits store the level of refinement of the corresponding block of cells .",
    "the remaining @xmath18  bits of the first channel are used to endcode the texel coordinates of the first child node .",
    "the second child node is stored at the next sequential texel .",
    "as mentioned above the texel coordinate @xmath16 is reserved for the root note , and we use it to indicate leaf nodes of the tree .",
    "the first @xmath19 bits of the _ green_-channel store the location of the splitting plane defining the child nodes . by construction of the tree , the splitting planes are always located at the faces of the cells on the particular level of refinement , so we do not need to store its value in floating point coordinates .",
    "instead it is beneficial to use integer coordinates , defined as the number of cells on the current level of refinement , relative to the node s lower left corner .",
    "the remaining @xmath20  bits of the second channel are used as an index into a second 3d - texture that holds specific information required for nodes of type ( a ) and ( b ) , see section  [ sec::kdtree ] , and will be discussed in the next subsection . a diagram that depicts the specific usage of bits",
    "is shown in figure  [ fig::gpu - representation ] .",
    "a @xmath21 index texture , with a memory requirement of @xmath22 mbytes , is capable of encoding kd - trees with more than @xmath23 million nodes .",
    "the specific choice of bits allows us to distinguish @xmath14 levels of refinement and subdivision plane positions for nodes covering up to @xmath24 cells on their level of refinement , sufficient for the largest amr simulations up to date . for moderately sized amr hierarchies usually a resolution for @xmath25 index texture , with memory requirements of only @xmath23 mbytes , enabling the storage of more than @xmath26 million nodes , is sufficient .",
    "as discussed in section  [ sec::gpukdtree ] , texels for nodes of type ( a ) or ( b ) , i.e.  nodes that represent block of cells that are either completely refined or completely unrefined and thus can be rendered , store an index into a second texture , called _ data nodes _ texture in the following .",
    "the specific usage of its bits depends on the storage strategy for the data associated with the amr grids .",
    "one challenge for gpu - raycasting of multi - resolution data is that only a limited number of textures can be accessed simultaneously , depending on the number of texture units of the specific graphics hardware .",
    "the maximal number is currently about @xmath27 , far too few to assign a separate texture to each node in the tree structure .",
    "typical amr simulations generate between @xmath28 to @xmath29 separate subgrids for each time step .",
    "one option to tackle this problem is to use a large 3d texture as a memory pool and copy the data blocks associated with each amr grid into this texture , which will be discussed in section  [ subsec::memorypool ] . in subsection  [ subsec::bindlesstextures ]",
    "we will discuss an alternative approach , based on _",
    "nvidia s bindless textures _ extension for _ opengl _ ,  @xcite available since march 2012 , which enables _ opengl _ applications to dynamically access large number of separate textures in the graphics shaders .    in both cases",
    "it is advantageous to assign a separate texture brick per subgrid instead of one brick for each kd - tree nodes of type ( a ) and ( b ) , because in general there are more kd - tree nodes than subgrids and for higher order interpolation we use a common row of texels at interfaces between adjacent texture blocks . assigning a separate texture brick per kd - node would drastically increase the number of interfaces and thus texture memory consumption .",
    "furthermore the packing procedure would result in more fragmented areas for a larger number of smaller bricks , see section  [ subsec::memorypool ] and  [ sec::results ] .",
    "so we allocate one brick for each amr subgrid and rather store offsets into these bricks at the nodes of type ( a ) and ( b ) .",
    "we employ nearest - neighbor interpolation for cell - centered amr data and trilinear interpolation for vertex - centered data . in the first case",
    "the texels are aligned with the centers of the cells , while in the second one they are aligned with the vertices of the grid . to avoid artifacts originating from discontinuous tri - linear interpolation between subgrids with different resolutions , adjacent texture - blocks share a row of data samples at their common boundary faces and the data at dangling nodes has to be replaced to the interpolated texel values of the abutting , coarse texture .      for our purposes the following variant of",
    "the three - dimensional packing problem is appropriate : pack a given number of axis - aligned rectilinear boxes into one container with fixed width and depth , such that its height is minimized .",
    "@xcite this problem belongs to the class of np - hard problems , but a couple of useful heuristics have been suggested .",
    "similar to the approach discussed in kaehler  et  al .",
    "@xcite we use the so - called _ next - fit - decreasing - height ( nfdh ) _ algorithm .",
    "@xcite first the texture bricks are inserted into a list , in the order of decreasing extension in the z , y and then x - direction .",
    "the packing algorithm starts at the lower left - hand corner of the container and inserts the boxes along the x - axis until the maximal x - extension of the container is reached .",
    "a new row is opened , with a y - coordinate given by the largest y - extension of the already inserted boxes .",
    "this procedure is repeated until the lowest layer of the container is filled .",
    "then a new layer is in the z - direction is opened and this process continues until all boxes are inserted .",
    "we iterate this procedure with different values for the base layer extensions of the container and the result with the smallest volume is chosen .",
    "a 3d - texture of this size is defined with the subtextures inserted at their computed positions .",
    "each kd - node of type ( a ) or ( b ) in the _",
    "`` data nodes texture '' _ , see upper - right part of figure  [ fig::gpu - representation ] , stores its offset into the packed texture using 32-bits .",
    "this allows to index into a packed texture of up to @xmath30 texels .",
    "_ nvidia _ s _ bindless texture _ extension  @xcite allows _ opengl _ applications to dynamically access large numbers of texture objects in graphics shaders without the need to first bind the textures to specific texture units on the cpu .",
    "instead each texture is identified by a 64-bit handle that is used to sample the texture .",
    "this provides a means to manage the large amounts of separate texture bricks associated with typical amr data structures without the need to pack them into a memory pool .",
    "we use 32-bits per texel for the _ data nodes _ texture in this case . for each kd - tree node of type ( a ) and ( b ) we employ a 32-bit index into another 3d - texture with two 32-bit channels , referred to as the _ handles _ textures in the following .",
    "it endcodes the @xmath14-bit texture handles for each texture brick associated with a subgrid , see figure  [ fig::gpu - representation ] .",
    "it is advantageous to store the handles in a separate texture because the number of subgrids is much smaller than the number of kd - nodes , so storing them at each entry in the _ data nodes _ texture would introduce an overhead in gpu - memory usage .      as in the standard gpu - raycasting approach for uniform data  @xcite , we draw the faces of the bounding box enclosing the computational domain to execute an instance of a fragment shader for each covered pixel . in the fragment",
    "shader the ray s origin and direction for the corresponding pixel is computed .",
    "next the segments resulting from the intersection between the viewing ray and the kd - tree data nodes are determined similar to the _ kd - restart _ algorithm  @xcite .",
    "the _ kd - tree _ texture is sampled starting at the root node with texel coordinate @xmath16 and traversed _ top - down _ , using the child node pointers stored at each node , as discussed in section  [ sec::gpukdtree ] .",
    "the bounding box of each node is computed on - the - fly from the extensions of the kd - root node and the orientation and positions of the splitting planes for each node .",
    "the split position is mapped from integer - coordinates to the world coordinate system , using the cell size @xmath31 on the root level , the current level of refinement at the node as well as its bounding box .",
    "the traversal continues until either a leaf node is reached , indicated by an `` invalid '' child node entry of @xmath16 , or until a node of type ( a ) is visited , which is the case if the node has a valid child node entry and an index into the _ data nodes _ texture .",
    "the latter case allows for a level - of - detail selection , pruning the traversal of the tree if for example the projected screen size of the cells of this node is below a user - defined threshold .",
    "next the color and opacity contribution of the corresponding ray - segment is computed . in case of the `` packing '' approach discussed in section  [ subsec::memorypool ] ,",
    "the node s offset into the packed texture is sampled from its entry in the _ data nodes _ texture and the ray - segment is transformed to texel coordinates .    in the _ bindless texture _ approach the current texture handles are read from the _ handles _ texture using the index stored in the _ data nodes _ texture , and converted to a _",
    "glsl sampler3d _ object .",
    "the ray - position is converted to texture coordinates using the number of samples of the texture and the number of texels of the subregion corresponding to the kd - node , which can be computed on - the - fly from its bounding box and the current refinement level .",
    "the sampling rate is chosen proportional to the level s cell - size . when the segment is processed , the kd - tree traversal is `` restarted '' at the root node and the next ray - segment is visited .",
    "once the total ray is processed , the resulting colors and opacities are written to the frame - buffer .",
    "the comparison was performed using a _ nvidia geforce gtx 680 _ graphics card with @xmath26 gbyte of graphics memory , that was installed on a host with a _ intel xeon e5520 cpu _ and @xmath18 gbyte main memory .",
    "the rendering algorithms were implemented in _",
    "opengl _ and the _ opengl shading language ( glsl)_. we tested the performance and memory requirements of the proposed algorithms on three datasets with different sizes and characteristics .",
    "all performance measurements refer to a viewport size of @xmath32 pixels .",
    "table  [ tab::datasets ] lists information about the datasets and the corresponding kd - trees : the number of subgrids , refinement levels and cells in the original samr grid hierarchies as well as the total number of nodes in the resulting kd - trees and the portion of nodes of type ( b ) and ( c ) , see section  [ sec::kdtree ] .",
    ".the characteristics of the datasets : the number of subgrids , refinement levels , cells as well as the total number of nodes in the resulting kd - trees and the portion of internal and leaf nodes that are associated with blocks of cells . [ cols=\">,>,>,>,>,>,>\",options=\"header \" , ]     as indicated by the measurements shown in table  [ tab::timings ] the rendering performance of the packing approach is faster than the _ bindless texture _ approach for all examples , due to the overhead associated with the dynamic access of the separate textures in the _ bindless texture _ case .",
    "however , the packing approach uses more texture memory , as the packing of the differently sized subgrid textures into the texture memory pool necessarily introduces some fragmentation .",
    "an efficiency , defined as the number of used texels to the total number of texels in the packed texture , between 30% and 50% was achieved for the three datasets .",
    "the multi - pass approach has faster rendering performance for the smallest and the medium sized dataset 1 and 2 , but the packing approach is about 50% faster for the largest dataset , number 3 . here the cost of the per - pixel sampling of the kd - tree structure is lower than the overhead for binding of the separate textures and rendering the bounding boxes of each kd - node to initialize the fragment shader instances in the multi - pass approach .    (",
    "a )    ( b )    ( c )    unlike the multipass approach the single - pass methods allow the application of advanced lighting schemes , that require simultaneous access to more than one kd - tree node . two examples for dataset  3 are shown in figure  [ fig : advancedrendering2 ] and  [ fig : advancedrendering1 ] .",
    "figure  [ fig : advancedrendering1 ] is a non - polygonal semi - transparent iso - surface representation using a gradient - based shading approach , rendered at @xmath33 fps .",
    "the gradients were computed _ on - the - fly_. figure  [ fig : advancedrendering2 ] shows a global illumination example . here for each sampling location a secondary ray is traced to a central point - like light source .",
    "the achieved frame rate was @xmath34 fps .",
    "we presented a single - pass gpu - raycasting approach for _ structured adaptive mesh refinement ( samr ) _ data .",
    "it employs a kd - tree to subdivide the data domain into axis - aligned , non - overlapping blocks of cells from the same resolution level .",
    "the tree is encoded by a set of 3d - textures , which allows to efficiently traverse it entirely on the gpu .",
    "we discussed two different data access strategies , namely a `` packing '' approach using a texture memory pool , and a method based on _",
    "nvidia s bindless texture _ extension for _ opengl _ , and applied them to several samr datasets of different sizes and complexity .    for all examples the 3d textures used to encode the kd - tree structure required only small amounts of texture memory .",
    "the packing approach offers higher rendering performance as long as all data fits into texture memory , because of the extra costs of the dynamically accessing the separate textures in the _ bindless texture _ approach , whereas the latter consumes less texture memory .",
    "we further compared the new approaches to a previously published multi - pass method  @xcite .",
    "for complex and large samr datasets the packing approach outperformed the multi - pass algorithm and in contrast to the latter , both new methods enable a straight - forward implementation of many advanced shading and acceleration techniques , since all parts of the data domain are accessible in the fragment shader .",
    "they further do not suffer from _ read - after - write hazards _ as multi - pass approaches that use non - standard blending equations and need to read back from the frame - buffer for each pass , or apply synchronization methods , which substantially decrease the rendering performance .",
    "because the new single - pass methods are executed entirely on the gpu without any cpu interaction , their rendering performance should directly benefit from the increased number of shader cores expected for upcoming gpu generations .",
    "the _ bindless texture _ approach is especially well suited for datasets that exceed the available graphics memory , as it allows to dynamically upload subsets of textures as required by out - of - core rendering approaches .",
    "we would like to thank ziba mahdavi ( kipac ) and shalini venkataraman ( nvidia ) for providing us with @xmath35 @xmath36 gpus .",
    "we also thank ji - hoon kim ( ucsc ) and john wise ( georgia tech ) for the datasets used to test the presented algorithms . this work was supported in part by the _ national science foundation _ through award number ast-0808398 and the ldrd program at the slac national accelerator laboratory as well as the terman fellowship at stanford university .",
    "jankun - kelly , t.  j. , kreylos , o. , shalf , j.  m. , ma , k .-",
    "hamann , b. , joy , k.  i. , and bethel , e.  w. , `` deploying web - based visual exploration tools on the grid , '' _ ieee computer graphics and applications _  * 23*(2 ) , 4050 ( 2003 ) .",
    "weber , g.  h. , kreylos , o. , ligocki , t.  j. , shalf , j.  m. , hagen , h. , hamann , b. , and joy , k.  i. , `` high - quality volume rendering of adaptive mesh refinement data , '' in [ _ proceedings of vision , modeling , and visualization 2001 _ ] , 121128 ( stuttgart , germany , 2001 ) .",
    "weber , g.  h. , kreylos , o. , ligocki , t.  j. , shalf , j.  m. , hagen , h. , hamann , b. , and joy , k.  i. , `` extraction of crack - free isosurfaces from adaptive mesh refinement data , '' in [ _ data visualization 2001 ( proceedings of vissym 01 ) _ ] , 2534 ( 2001 ) .",
    "weber , g.  h. , oehler , m. , kreylos , o. , shalf , j.  m. , bethel , w. , hamann , b. , and scheuermann , g. , `` parallel cell projection rendering of adaptive mesh refinement data , '' in [ _ proceeding of the ieee symposium on parallel and large - data visualization and graphics _ ] , koning , a. , machiraju , r. , and silva , c.  t. , eds .",
    ", 5160 , ieee , ieee computer society press , los alamitos , california ( 2003 ) .",
    "turk , m.  j. , smith , b.  d. , oishi , j.  s. , skory , s. , skillman , s.  w. , abel , t. , and norman , m.  l. , `` yt : a multi - code analysis toolkit for astrophysical simulation data , '' _ the astrophysical journal supplement series _   * 192*(1 ) , 9 ( 2011 ) .",
    "park , s. , bajaj , c.  l. , and siddavanahalli , v. , `` case study : interactive rendering of adaptive mesh refinement data , '' in [ _ proceedings of ieee visualization _ ] , moorhead , r. , gross , m. , and joy , k.  i. , eds .",
    ", 521524 , ieee computer society press ( 2002 ) .",
    "roettger , s. , guthe , s. , weiskopf , d. , ertl , t. , and strasser , w. , `` smart hardware - accelerated volume rendering , '' in [ _ vissym 03 : proceedings of the symposium on data visualisation 2003 _ ] , 231238 , eurographics association , aire - la - ville , switzerland , switzerland ( 2003 ) .",
    "krueger , j. and westermann , r. , `` acceleration techniques for gpu - based volume rendering , '' in [ _ vis 03 : proceedings of the 14th ieee visualization 2003 ( vis03 ) _ ] , 38 , ieee computer society , washington , dc , usa ( 2003 ) .",
    "stegmaier , s. , strengert , m. , klein , t. , and ertl , t. , `` a simple and flexible volume rendering framework for graphics - hardware - based raycasting , '' in [ _ fourth international workshop on volume graphics _ ] , 187 241 ( 2005 ) .",
    "kaehler , r. , wise , j. , abel , t. , and hege , h .- c . ,",
    "`` gpu - assisted raycasting for cosmological adaptive mesh refinement simulations , '' in [ _ international workshop on volume graphics 2006 _ ] , 103110 , eurographics / ieee vgtc 2006 , boston ( 2006 ) .",
    "ljung , p. , `` adaptive sampling in single pass , gpu - based raycasting of multiresolution volumes , '' in [ _ proceedings of the international workshop on volume graphics 2006 _ ] , 3946 , eurographics / ieee vgtc 2006 , boston ( 30 - 31 july 2006 ) .",
    "vollrath , j.  e. , schafhitzel , t. , and ertl , t. , `` employing complex gpu data structures for the interactive visualization of adaptive mesh refinement data , '' in [ _ proceedings of the international workshop on volume graphics 2006 _ ] , 5558 , eurographics / ieee vgtc 2006 , boston ( 30 - 31 july 2006 ) .",
    "gobbetti , e. , marton , f. , and iglesias  guitin , j.  a. , `` a single - pass gpu ray casting framework for interactive out - of - core rendering of massive volumetric datasets , '' _ vis .",
    "comput . _  * 24 * , 797806 ( july 2008 ) .",
    "crassin , c. , neyret , f. , lefebvre , s. , and eisemann , e. , `` gigavoxels : ray - guided streaming for efficient and detailed voxel rendering , '' in [ _ acm siggraph symposium on interactive 3d graphics and games ( i3d ) _ ] , acm , acm press , boston , ma , etats - unis ( feb 2009 ) . to appear .",
    "horn , d.  r. , sugerman , j. , houston , m. , and hanrahan , p. , `` interactive k - d tree gpu raytracing , '' in [ _ proceedings of the 2007 symposium on interactive 3d graphics and games _ ] , _ i3d 07 _",
    ", 167174 , acm , new york , ny , usa ( 2007 ) ."
  ],
  "abstract_text": [
    "<S> structured adaptive mesh refinement ( samr ) is a popular numerical technique to study processes with high spatial and temporal dynamic range . </S>",
    "<S> it reduces computational requirements by adapting the lattice on which the underlying differential equations are solved to most efficiently represent the solution . particularly in astrophysics and cosmology such simulations now can capture spatial scales ten orders of magnitude apart and more . the irregular locations and extensions of the refined regions in the samr scheme and </S>",
    "<S> the fact that different resolution levels partially overlap , poses a challenge for gpu - based direct volume rendering methods . </S>",
    "<S> kd - trees have proven to be advantageous to subdivide the data domain into non - overlapping blocks of equally sized cells , optimal for the texture units of current graphics hardware , but previous gpu - supported raycasting approaches for samr data using this data structure required a separate rendering pass for each node , preventing the application of many advanced lighting schemes that require simultaneous access to more than one block of cells . in this paper </S>",
    "<S> we present the first single - pass gpu - raycasting algorithm for samr data that is based on a kd - tree . the tree is efficiently encoded by a set of 3d - textures , which allows to adaptively sample complete rays entirely on the gpu without any cpu interaction . </S>",
    "<S> we discuss two different data storage strategies to access the grid data on the gpu and apply them to several datasets to prove the benefits of the proposed method . </S>"
  ]
}