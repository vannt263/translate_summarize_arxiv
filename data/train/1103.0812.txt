{
  "article_text": [
    "prior to the first release of b - prolog in 1994 , several prototypes had been developed that incorporated results from various experiments .",
    "the very first prototype was based on the warren abstract machine ( wam ) @xcite as implemented in sb - prolog @xcite . in the original wam , the decision on which clauses to apply to a call is made solely on the basis of the type and sometimes the main functor of the first argument of the call .",
    "this may result in unnecessary creation of choice points and repeated execution of common unification operations among clauses in the predicate .",
    "the first experiment , inspired by the rete algorithm used in production rule systems @xcite , aimed at improving the indexing scheme of the wam .",
    "the results from that experiment included an intermediate language named _ matching clauses _ and a prolog machine named _ toam _ ( tree - oriented abstract machine ) which provided instructions for encoding tries called matching trees @xcite .",
    "several other proposals had been made with the same objective @xcite , but these proposed schemes had the drawback of possibly generating code of exponential size for certain programs .    the wam was originally designed for both software and hardware implementations . in the wam , arguments are passed through argument registers so that hardware registers can be exploited in native compilers and hardware implementations . in an emulator - based implementation , however",
    ", passing arguments through registers loses its advantage since registers are normally simulated . the second experiment , which took place during 1991 - 1994 , was to have arguments passed old - fashionedly through the stack as in dec-10 prolog @xcite .",
    "the result from that experiment was ntoam @xcite . in this machine",
    ", only one frame is used for each predicate call which stores a different set of information depending on the type of the predicate .",
    "this architecture was later refined and renamed to atoam @xcite .    during the past fifteen years since its first release ,",
    "b - prolog has undergone several major extensions and refinements .",
    "the first extension was to introduce a new type of frame , called a _ suspension frame _ for delayed calls @xcite .",
    "in wam - based systems , delayed calls are normally stored as terms on the heap @xcite .",
    "the advantage of storing delayed calls on the stack rather than on the heap is that contest switching is light .",
    "it is unnecessary to allocate a frame when a delayed call wakes up and deallocate it when the delayed call suspends again .",
    "this advantage is especially important for programs where calls wake up and suspend frequently , such as constraint propagators @xcite .",
    "a delay construct like freeze is too weak for implementing constraint solvers .",
    "new constructs , first delay clauses @xcite and then action rules @xcite , were introduced into b - prolog . while these new constructs give significantly more modeling power , they required only minor changes to the architecture : for action rules , one extra slot was added into a suspension frame for holding events .",
    "the action rule language serves well as a powerful and yet efficient intermediate language for compiling constraints over finite - domain variables .",
    "a constraint is compiled into propagators defined in action rules that maintain some sort of consistency for the constraint .",
    "the availability of fine - grained domain events facilitates programming ac-4 like propagation algorithms @xcite .",
    "as propagators are stored on the stack as suspension frames , allocation of frames is not needed to activate propagators and hence context switching among propagators becomes faster .",
    "another major extension was tabling . unlike oldt @xcite and slg @xcite which rely on suspension and resumption of subgoals to compute fixed points , the tabling mechanism , called _ linear tabling _",
    "@xcite , implemented in b - prolog relies on iterative computation of top - most looping subgoals to compute fixed points .",
    "linear tabling is simpler , easier to implement , and more space - efficient than slg , but a naive implementation may not be as fast due to the necessity of re - computation .",
    "optimization techniques have been developed to make linear tabling competitive with slg in time efficiency by significantly reducing the cost of re - computation @xcite . for tabled predicates ,",
    "a new type of frame was introduced into the architecture .",
    "recently , the tabling system has been modified to support table modes , which facilitate describing dynamic programming problems @xcite .",
    "the prism system @xcite has been the main driving force for the design and implementation of the tabling system in b - prolog .    in 2007 ,",
    "b - prolog s abstract machine was replaced by a new one named toam jr .",
    "this switch improved the speed of b - prolog by over 60% on the aquarius benchmarks @xcite .",
    "the old machine atoam , like the wam , has a very fine - grained instruction set in the sense that roughly each symbol in the source program is mapped to one instruction .",
    "this fine granularity is a big obstacle to fast interpretation due to the high dispatching cost commonly seen in abstract machine emulators . the new machine toam jr uses no temporary registers at all and provides variable - size specialized instructions for encoding predicate calls . in wam - based systems",
    ", similar efforts have also been made to specialize and merge instructions to reduce the cost of interpretation @xcite .",
    "the memory manager of b - prolog has also been improved recently .",
    "b - prolog employs an incremental copying garbage collector @xcite based on the one proposed for the wam by older and rummell @xcite . because of the existence of suspension frames on the stack , the garbage collector also reclaims space taken by unreachable stack frames .",
    "the memory manager automatically expands the stacks and data areas before they overflow , so applications can run with any initial setting for the spaces as long as the overall demand for memory can be met .    this paper overviews in section 2 the language features of b - prolog , gives in section 3 a detailed description of toam jr .",
    ", the architecture b - prolog has evolved into after nearly two decades , and summarizes in section 4 the changes made to the memory architecture for supporting action rules and tabling .",
    "the reader is referred to @xcite for a detailed description of architectural support for action rules and to @xcite for a detailed description of the extension of the architecture for tabling .",
    "in addition to the standard prolog language , b - prolog offers several useful new features . in this section",
    ", we give an overview of them .",
    "a matching clause is a form of a clause where the determinacy and input / output unifications are denoted explicitly .",
    "the compiler translates matching clauses into matching trees and generates indices for all input arguments .",
    "the compilation of matching clauses is much simpler than that of normal prolog clauses because no complex program analysis or specialization or dynamic indexing @xcite is necessary ; also the generated code tends to be more compact and faster .",
    "the b - prolog compiler and most of the library predicates are written in matching clauses .",
    "a _ determinate _ matching clause takes the following form :    aa = aaa = aaa = aaa = aaa = aaa = aaa @xmath0 = > @xmath1    where @xmath2 is an atomic formula , @xmath3 and @xmath1 are two sequences of atomic formulas .",
    "@xmath2 is called the head , @xmath3 the guard , and @xmath1 the body of the clause .",
    "no call in @xmath3 can bind variables in @xmath2 and all calls in @xmath3 must be in - line tests .",
    "in other words , the guard must be _",
    "flat_. for a call @xmath4 , matching rather than unification is used to select a matching clause in its predicate .",
    "when applying the matching clause to @xmath4 , the system rewrites @xmath4 _ determinately _ into @xmath1 .",
    "in other words , call @xmath4 fails once call @xmath1 fails .",
    "a _ nondeterminate _ matching clause takes the following form :    aa = aaa = aaa = aaa = aaa = aaa = aaa @xmath0 ?",
    "= > @xmath1    it differs from the determinate matching clause @xmath0 = > @xmath1 in that the rewriting from @xmath2 into @xmath1 is nondeterminate , i.e. , the alternative clauses will be tried when @xmath1 fails . in a predicate definition ,",
    "determinate and nondeterminate matching clauses can coexist .",
    "the following gives an example predicate in matching clauses that merges two sorted lists :    ....     merge([],ys , zs ) = > zs = ys .",
    "merge(xs,[],zs ) = > zs = xs .",
    "merge([x|xs],[y|ys],zs),x < y = > zs=[x|zst],merge(xs,[y|ys],zst ) .",
    "merge(xs,[y|ys],zs ) = > zs=[y|zst],merge(xs , ys , zst ) .",
    "....    the cons ` [ y|ys ] ` occurs in both the head and the body of the third clause . to avoid reconstructing the term",
    ", we can rewrite the clause into the following :    ....     merge([x|xs],ys , zs),ys=[y|_],x < y = > zs=[x|zst],merge(xs , ys , zst ) .",
    "....    the call ` ys=[y| _ ] ` in the guard matches ys against the pattern ` [ y| _ ] ` .",
    "the lack of a facility for programming `` active '' sub - goals that can be reactive to the environment has been considered one of the weaknesses of logic programming . to overcome this ,",
    "b - prolog provides action rules for programming agents @xcite .",
    "an agent is a subgoal that can be delayed and can later be activated by events .",
    "each time an agent is activated , some action may be executed .",
    "agents are a more general notion than delay constructs in early prolog systems and processes in concurrent logic programming languages in the sense that agents can be responsive to various kinds of events including instantiation , domain , time , and user - defined events .",
    "an action rule takes the following form :    aa = aaa = aaa = aaa = aaa = aaa = aaa @xmath0,\\{@xmath5 } = > @xmath1    where @xmath2 is a pattern for agents , @xmath3 is a sequence of conditions on the agents , @xmath5 is a set of patterns for events that can activate the agents , and @xmath1 is a sequence of arbitrary prolog goals ( called _ actions _ ) executed by the agents when they are activated .",
    "the sequence of actions @xmath1 can succeed only once and hence can never leave choice points behind .",
    "the compiler replaces @xmath1 with once(@xmath1 ) if it predicts that @xmath1 may create choice points .",
    "when the event pattern @xmath5 together with the enclosing braces is missing , an action rule degenerates into a determinate matching clause .",
    "a set of built - in events is provided for programming constraint propagators and interactive graphical user interfaces .",
    "for example , ins(@xmath6 ) is an event that is posted when the variable @xmath6 is instantiated .",
    "a user program can create and post its own events and define agents to handle them .",
    "a user - defined event takes the form of event(@xmath7 ) where @xmath6 is a variable , called a _ suspension variable _ , that connects the event with its handling agents , and @xmath8 is a prolog term that contains the information to be transmitted to the agents .",
    "the built - in post(@xmath5 ) posts the event @xmath5 . in the next subsection",
    ", we show the events provided for programming constraint propagators .",
    "consider the following examples :    ....      echo(x),{event(x , mes)}=>writeln(mes ) .",
    "ping(t),{time(t ) } = > writeln(ping ) . ....    the agent echo(x )",
    "echoes whatever message it receives .",
    "for example ,    ....      ?",
    "-echo(x),post(event(x , hello)),post(event(x , world ) ) .",
    "....    outputs the message hello followed by world .",
    "the agent ping(t ) responds to time events from the timer t. each time it receives a time event , it prints the message ping .",
    "for example ,    ....      ?",
    "-timer(t,1000),ping(t),repeat , fail . ....    creates a timer that posts a time event every second and creates an agent ping(t ) to respond to the events .",
    "the repeat - fail loop makes the agent perpetual .",
    "the action rule language has been found useful for programming coroutining such as freeze , implementing constraint propagators @xcite , and developing interactive graphical user interfaces @xcite .",
    "action rules have been used by @xcite as an intermediate language for compiling constraint handling rules and by @xcite to compile answer set programs .      like many prolog - based finite - domain constraint solvers , b - prolog s finite - domain solver was heavily influenced by the chip system @xcite .",
    "the first fully - fledged solver was released with b - prolog version 2.1 in march 1997 . that solver was implemented with delay clauses @xcite . during the past decade ,",
    "the action rule language has been extended to support a rich class of domain events ( ins(@xmath6 ) , bound(@xmath6),dom(@xmath9 ) , and dom_any(@xmath9 ) ) for programming constraint propagators @xcite and the system has been enriched with new domains ( boolean , trees , and finite sets ) , global constraints , and specialized fast constraint propagators .",
    "recently , the two built - ins in/2 and notin/2 have been extended to allow positive and negative table ( also called extensional ) constraints @xcite .",
    "the following program solves the send + more = money puzzle .",
    "the call vars in 0 .. 9 is a domain constraint , which narrows the domain of each of the variables in vars down to the set of integers from 0 through 9 .",
    "the call alldifferent(vars ) is a global constraint , which ensures that variables in the list vars are pairwise different .",
    "the operator ` # \\= ` is for inequality constraints and ` # = ` is for equality constraints .",
    "the call labeling(vars ) labels the variables in the given order with values that satisfy all the constraints .",
    "another well - used built - in , named labeling_ff , labels the variables using the so called _ first - fail principle _",
    "@xcite .    ....",
    "sendmory(vars):-        vars=[s , e , n , d , m , o , r , y ] ,         vars in 0 .. 9 ,        alldifferent(vars ) ,             s # \\= 0 ,        m # \\= 0 ,        1000*s+100*e+10*n+d+1000*m+100*o+10*r+e # =         10000*m+1000*o+100*n+10*e+y ,        labeling(vars ) .           ....    all constraints are compiled into propagators defined in action rules . for example , the following predicate defines a propagator for maintaining arc consistency for the constraint ` x+y # = c ` .    ....",
    "x_in_c_y_ac(x , y , c),var(x),var(y ) ,        { dom(y , ey ) }         = >                 ex is c - ey ,                domain_set_false(x , ex ) .",
    "x_in_c_y_ac(x , y , c ) = > true . ....    whenever an inner element ey is excluded from the domain of y , this propagator is triggered to exclude ex , the counterpart of ey , from the domain of x. for the constraint ` x+y # = c ` , we need to generate two propagators , namely , x_in_c_y_ac(x , y , c ) and x_in_c_y_ac(y , x , c ) , to maintain the arc consistency .",
    "note that in addition to these two propagators , we also need to generate propagators for maintaining interval consistency since dom(y , ey ) only captures exclusions of inner elements , not bounds .",
    "the dom_any(@xmath9 ) event , which captures the excluded value @xmath5 from the domain @xmath6 , facilitates implementing ac4-like algorithms @xcite .",
    "consider , for example , the channeling constraint assignment(@xmath10 ) , where @xmath11 is a list of variables [ @xmath12 ( called _ primal _ ) and @xmath13 is another list of variables [ @xmath14 ( called _ dual _ ) , and the domain of each @xmath15 and each @xmath16 ( @xmath17 ) is @xmath18 .",
    "the constraint is true iff @xmath19 or equivalently @xmath20 .",
    "clearly a straightforward encoding of the channeling constraint requires @xmath21 boolean constraints . with the dom_any event , however , we can use only @xmath22 propagators to implement the channeling constraint .",
    "let dualvarvector be a vector created from the list of dual variables .",
    "for each primal variable xi ( with the index i ) , a propagator defined below is created to handle exclusions of values from the domain of xi .    ....",
    "primal_dual(xi , i , dualvarvector),var(xi ) ,        { dom_any(xi , j ) }         = >        arg(j , dualvarvector , yj ) ,        domain_set_false(yj , i ) .",
    "primal_dual(xi , i , dualvarvector ) = > true .",
    "....    each time a value j is excluded from the domain of xi , assume yj is the jth variable in dualvarvector , then i must be excluded from the domain of yj .",
    "we need to exchange primal and dual variables and create a propagator for each dual variable as well .",
    "therefore , in total @xmath22 propagators are needed .",
    "thanks to the employment of action rules as the implementation language , the constraint solving part of b - prolog is relatively small ( 3800 lines of prolog code and 4500 lines of c code , including comments and empty lines ) but its performance is very competitive with other clp(fd ) systems @xcite .",
    "moreover , the action rule language is available to the programmer for implementing problem - specific propagators .",
    "a structure can be used as a one - dimensional array , and a multi - dimensional array can be represented as a structure of structures .",
    "to facilitate creating arrays , b - prolog provides a built - in , called new_array(@xmath23 ) , where @xmath6 must be an uninstantiated variable and @xmath24 a list of positive integers that specifies the dimensions of the array .",
    "for example , the call new_array(x,[10,20 ] ) binds x to a two dimensional array whose first dimension has 10 elements and second dimension has 20 elements .",
    "all the array elements are initialized to be free variables .",
    "the built - in predicate arg/3 can be used to access array elements , but it requires a temporary variable to store the result , and a chain of calls to access an element of a multi - dimensional array . to facilitate accessing array elements ,",
    "b - prolog supports the array subscript notation @xmath6[@xmath25, ... ,@xmath26 , where @xmath6 is a structure and each @xmath27 is an integer expression .",
    "this common notation for accessing arrays is , however , not part of the standard prolog syntax . to accommodate this notation , the parser is modified to insert a token @xmath28 between a variable token and [",
    "so , the notation @xmath6[@xmath25, ... ,@xmath26 is just a shorthand for @xmath6@xmath28[@xmath25, ... ,@xmath26 .",
    "this notation is interpreted as an array access when it occurs in an arithmetic expression , an arithmetic constraint , or as an argument of a call to @=/2 .",
    "@= @xmath29 is the same as @xmath6 = @xmath29 except that when an argument is an array access or a list comprehension ( described later ) , it is evaluated before the unification . ]    in any other context , it is treated as the term itself .",
    "the array subscript notation can also be used to access elements of lists .",
    "for example , the nth/3 predicate can be defined as follows :    ....      nth(i , l , e ) : - e @= l[i ] . ....    note that , for the array access notation a[i ] , while it takes constant time to access the ith element if a is a structure , it takes o(i ) time when a is a list .",
    "prolog relies on recursion to describe loops .",
    "the lack of powerful loop constructs has arguably made prolog less acceptable to beginners and less productive to experienced programmers because it is often tedious to define small auxiliary recursive predicates for loops .",
    "the emergence of constraint programming languages such as clp(fd ) has further revealed this weakness of prolog as a modeling language .",
    "inspired by ecl@xmath30ps@xmath31 @xcite and functional languages , b - prolog provides a construct , called foreach , for iterating over collections , and the list comprehension notation for constructing lists .",
    "the foreach call has a very simple syntax and semantics .",
    "for example ,    ....      foreach(a in [ a , b ] , i in 1 .. 2 , write((a , i ) ) ....    outputs four tuples ( a,1 ) , ( a,2 ) , ( b,1 ) , and ( b,2 ) .",
    "the base foreach call has the form :    aa = aaa = aaa = aaa = aaa = aaa = aaa    where @xmath32 in @xmath33 is called an _ iterator _",
    "( @xmath32 is called the _ pattern _ and @xmath34 the _ collection _ of the iterator ) , @xmath35 is a callable term , and @xmath36 ( optional ) specifies a list of variables in @xmath35 that are local to each iteration .",
    "the pattern of an iterator is normally a variable but it can be any term ; the collection of an iterator is a list of terms and the notation @xmath37 .. @xmath38 .. @xmath39 denotes the list of numbers @xmath37 , @xmath37+@xmath38 , @xmath37+@xmath40 , @xmath41 , @xmath37+@xmath42 where @xmath37+@xmath42 is the last element that does not cross over @xmath39 .",
    "the notation @xmath43 .. @xmath44 is a shorthand for @xmath43 .. 1 .. @xmath44 .",
    "the foreach call means that for each permutation of values @xmath45 , @xmath41 , @xmath46 , the instance @xmath35 is executed after local variables are renamed .    in general , a foreach call may also take as an argument a list of accumulators that can be used to accumulate values from each iteration . with accumulators ,",
    "we can use foreach to describe recurrences for computing aggregates .",
    "recurrences have to be read procedurally .",
    "for this reason , we adopt the list comprehension notation for constructing lists declaratively .",
    "a list comprehension takes the form :    aa = aaa = aaa = aaa = aaa = aaa = aaa    where @xmath36 ( optional ) specifies a list of local variables , @xmath35 ( optional ) is a callable term .",
    "this construct means that for each permutation of values @xmath45 , @xmath41 , @xmath46 , if the instance of @xmath35 with renamed local variables is true , then @xmath47 is added into the list .",
    "a list of this form is interpreted as a list comprehension if it occurs as an argument of a call to ` ' @='/2 ` or in arithmetic constraints .",
    "calls to foreach and list comprehensions are translated into tail - recursive predicates .",
    "for example , the call xs @= [ x : ( x , _ ) in ps ] is translated into    ....",
    "dummy(ps , l , [ ] ) , xs @= l ....    where dummy is defined with matching clauses as follows :    ....      dummy([],xs , xsr ) = > xs = xsr .",
    "dummy([(x,_)|ps],xs , xsr ) = > xs=[x|xs1 ] , dummy(ps , xs1,xsr ) .",
    "dummy([_|ps],xs , xsr ) = >",
    "dummy(ps , xs , xsr ) .",
    "dummy(ps , _ , _ ) = > throw(illegal_argument_in_foreach(ps ) ) .",
    "....    as can be seen in this example , there is little or no penalty to using these loop constructs compared with using recursion .",
    "the loop constructs considerably enhance the modeling power of clp(fd ) .",
    "the following gives two programs for the n - queens problem to illustrate different uses of the loop constructs .",
    "here is the first program :    ....      queens(n , qs):-          length(qs , n ) ,          qs in 1 .. n ,          foreach(i in 1 .. n-1 , j in i+1 .. n ,                  ( qs[i ] # \\= qs[j ] ,                   abs(qs[i]-qs[j ] ) # \\= j - i ) ) . ....",
    "the call queens(n , qs ) creates a list qs of n variables ( one variable for each column ) , declares the domain of each of the variables to be 1 .. n , and generates constraints to ensure that no two queens are placed in the same row or the same diagonal .",
    "the following program models the problem with boolean constraints .    ....",
    "bool_queens(n , qs):-      new_array(qs,[n , n ] ) ,      vars @= [ qs[i , j ] : i in 1 .. n , j in 1 .. n ] ,      vars in 0 .. 1 ,      foreach(i in 1 .. n ,      % one queen in each row              sum([qs[i , j ] : j in 1 .. n ] ) # = 1 ) ,      foreach(j in 1 .. n ,      % one queen in each column              sum([qs[i , j ] : i in 1 .. n ] ) # = 1 ) ,      foreach(k in 1-n .. n-1 , % at most one queen in each left - down diag              sum([qs[i , j ] : i in 1 .. n , j in 1 .. n , i - j=:=k ] ) # = <",
    "1 ) ,      foreach(k in 2 .. 2*n ,    % at most one queen in each left - up diag              sum([qs[i , j ] : i in 1 .. n , j in 1 .. n , i+j=:=k ] ) # = <",
    "1 ) . ....    the call vars @= [ qs[i , j ] : i in 1 .. n",
    ", j in 1 .. n ] extracts the variables from matrix qs into list vars .",
    "list comprehensions are used in aggregate constraints .",
    "for example , the constraint ` sum([qs[i , j ] : j in 1 .. n ] ) # = 1 ` means that the sum of the ith row of the matrix is equal to 1 .",
    "the foreach construct of b - prolog is different from the loop constructs provided by ecl@xmath30ps@xmath31 @xcite .",
    "syntactically , foreach in b - prolog is a variable - length call in which only one type of iterator , namely @xmath5 in @xmath48 , is used for iteration , and an extra argument is used for accumulators if needed .",
    "in contrast , ecl@xmath30ps@xmath31 provides a built - in , called do/2 , and a base iterator , named fromto/4 , from which six types of iterators are derived for describing various kinds of iteration and accumulation .",
    "in addition , in b - prolog variables in a loop are assumed to be global unless they are declared local or occur in the patterns of the iterators ( _ global - by - default _ ) .",
    "in contrast , in ecl@xmath30ps@xmath31 variables are assumed to be local unless they are declared global ( _ local - by - default _ ) . from the programmer s perspective , the necessity of declaring variables is a burden in both approaches and no approach is uniformly better than the other .",
    "nevertheless , small loops tend to have fewer local variables than global ones , and for them global - by - default tends to impose less a burden than local - by - default .",
    "for example , while the two n - queens programs shown above contain no declaration of local variables , in ecl@xmath30ps@xmath31 the variables n and qs would have to be declared global .",
    "large loop bodies , however , may require declaration of more local variables than global ones , but my personal opinion is that large loop bodies should be put in separate predicates for better readability . from the implementation perspective ,",
    "ecl@xmath30ps@xmath31 s local - by - default can be easily implemented by goal expansion while b - prolog s global - by - default requires analysis of variable scopes .",
    "b - prolog issues warnings for occurrences in loop goals of singleton variables including anonymous variables .    semantically , b - prolog s iterators are matching - based while ecl@xmath30ps@xmath31 s iterators are unification - based . in b - prolog , iterators never change collections unless the goal of the loop changes them explicitly .",
    "in contrast , in ecl@xmath30ps@xmath31 variables in collections can be changed during iterations even if the goal does not touch on the variables .",
    "this implicit change of variables in collections may make loops less readable .",
    "tabling has been found increasingly important not only for helping beginners write workable declarative programs but also for developing real - world applications such as natural language processing , model checking , and machine learning applications .",
    "b - prolog implements a tabling mechanism , called linear tabling @xcite , which is based on iterative computation of looping subgoals rather than suspension of them to compute the fixed points .",
    "the prism system @xcite , which heavily relies on tabling , has been the main driving force for the design and implementation of b - prolog s tabling system .",
    "the idea of tabling is to memorize the answers to tabled calls and use the answers to resolve subsequent variant calls . in b - prolog , as in xsb , tabled predicates are declared explicitly by declarations in the following form :    aa = aaa = aaa = aaa = aaa = aaa = aaa @xmath49/@xmath50,@xmath41,@xmath51/@xmath52 .",
    "for example , the following tabled predicate defines the transitive closure of a relation as given by edge/2 .    ....      : -table path/2 .",
    "path(x , y):-edge(x , y ) .",
    "path(x , y):-path(x , z),edge(z , y ) .",
    "....    with tabling , any query to the program is guaranteed to terminate as long as the term sizes are bounded .    by default ,",
    "all the arguments of a tabled call are used in variant checking and all answers are tabled for a tabled predicate .",
    "b - prolog supports table modes , which allow the system to use only input arguments in variant checking and table answers selectively .",
    "the table mode declaration    ....        : -table p(m1, ... ,mn):c .",
    "....    directs the system on how to do tabling on p / n , where c , called a _ cardinality limit _ , is an integer which limits the number of answers to be tabled , and each mi is a mode which can be min , max , + ( input ) , or - ( output ) .",
    "an argument with the mode min or max , called _",
    "optimized _ ,",
    "is assumed to be output .",
    "if the cardinality limit c is 1 , it can be omitted with the preceding :. in the current implementation , only one argument can be optimized .",
    "since an optimized argument is not required to be numeral and the built - in ` @<`/2 is used to select answers with minimum or maximum values , multiple values can be optimized .",
    "the system uses only input arguments in variant checking , disregarding all output arguments .",
    "after an answer is produced , the system tables it unconditionally if the cardinality limit is not yet reached .",
    "when the cardinality limit has been reached , however , the system tables the answer only if it is better than some existing answer in terms of the argument with the min or max mode . in this case",
    ", the new answer replaces the worst answer in the table .",
    "mode - directed tabling in b - prolog was motivated by the need to scale up the prism system@xcite for handling large data sets . for a given set of possibly incomplete observed data",
    ", prism collects all explanations for these data using tabling and estimates the probability distributions by conducting em learning  @xcite on these explanations . for many real - world applications ,",
    "the set of explanations may be too large to be completely collected even in compressed form .",
    "mode - directed tabling allows for collecting a subset of explanations .",
    "mode - directed tabling is in general very useful for declarative description of dynamic programming problems @xcite .",
    "for example , the following program encodes dijkstra s algorithm for finding a path with the minimum weight between a pair of nodes .    ....      : -table sp(+,+,-,min ) .",
    "sp(x , y,[(x , y)],w ) : -          edge(x , y , w ) .",
    "sp(x , y,[(x , z)|path],w ) : -          edge(x , z , w1 ) ,          sp(z , y , path , w2 ) ,          w is w1+w2 . ....    the table mode states that only one path with the minimum weight is tabled for each pair of nodes .      _ the jipl interface with java : _ this interface was designed and implemented by nobukuni kino , originally for his k - prolog system , and was ported to b - prolog .",
    "this bi - directional interface makes it possible for java applications to use prolog features such as search and constraint solving , and for prolog applications to use java resources such as networking , gui , database , and concurrent programming packages .    _",
    "prism @xcite : _ this is an extension of prolog that integrates logic programming , probabilistic reasoning , and em learning .",
    "it allows for the description of independent probabilistic choices and their logical consequences in general logic programs .",
    "prism supports parameter learning . for a given set of possibly incomplete observed data",
    ", prism can estimate the probability distributions to best explain the data .",
    "this power is suitable for applications such as learning parameters of stochastic grammars , training stochastic models for gene sequence analysis , game record analysis , user modeling , and obtaining probabilistic information for tuning systems performance .",
    "prism offers incomparable flexibility compared with specific statistical model such as hidden markov models ( hmms ) , probabilistic context free grammars ( pcfgs ) and discrete bayesian networks .",
    "prism is a product of the prism team at tokyo institute of technology led by taisuke sato .",
    "_ cglib @xcite : _ this is a constraint - based high - level graphics library developed for b - prolog .",
    "it supports over twenty types of basic graphical objects and provides a set of constraints including non - overlap , grid , table , and tree constraints that facilitates the specification of layouts of objects .",
    "the constraint solver of b - prolog serves as a general - purpose and efficient layout manager , which is significantly more flexible than the special - purpose layout managers used in java .",
    "the library uses action rules available in b - prolog for creating agents and programming interactions among agents or between agents and users .",
    "cglib is supported in the windows version only .    _",
    "logtalk @xcite : _ this is an extension of prolog developed by paulo moura that supports object - oriented programming . it runs with several prolog systems .",
    "thanks to paulo moura s effort , logtalk has been made to run with b - prolog seamlessly .",
    "logtalk can be used as a module system on top of b - prolog .    _ the lp / mip interface : _ b - prolog provides an interface to lp / mip ( linear programming and mixed integer programming ) packages such as glpk and cplex . with the declarative loop constructs ,",
    "b - prolog can serve as a powerful modeling language for lp / mip problems .",
    "we assume that all the clauses of a given prolog program have been translated into matching clauses where input and output unifications are separated and the determinacy is denoted explicitly .",
    "this form of matching clauses is called canonical form .",
    "consider , for example , the append predicate in prolog :    ....       append([],ys , ys ) .",
    "append([x|xs],ys,[x|zs]):-          append(xs , ys , zs ) .",
    "....    this program is translated equivalently into the following matching clauses with no assumption on modes of arguments :    ....     append(xs , ys , zs),var(xs ) = >         append_aux(xs , ys , zs ) .",
    "append([],ys , zs ) = >          ys = zs .",
    "append([x|xs],ys , zs ) = >        zs=[x|zs1 ] ,        append(xs , ys , zs1 ) . ....    .... append_aux(xs , ys , zs ) ?",
    "= >      xs= [ ] ,     ys = zs . append_aux(xs , ys , zs ) = >     xs=[x|xs1 ] ,     zs=[x|zs1 ] ,     append(xs1,ys , zs1 ) .",
    "....    the b - prolog compiler does not infer modes but makes use of modes supplied by the programmer to generate more compact canonical - form programs .",
    "for example , with the mode declaration    ....     : -mode append(+,+,- ) .",
    "....    the append predicate is translated into the following canonical form :    ....     append([],ys , zs ) = >          ys = zs .",
    "append([x|xs],ys , zs ) = >        zs=[x|zs1 ] ,        append(xs , ys , zs1 ) .",
    "....    the compiler does not check modes at compile time or generate code for verifying modes at runtime .      except for changes made to accommodate event handling and garbage collection as to be detailed below",
    ", the memory architecture is the same as the atoam @xcite employed in early versions of b - prolog .",
    "uses all the stacks and data areas used by the wam ( see figure [ fig : mem ] ) .",
    "there is a data area called _ code area _ that contains , besides instructions compiled from programs , a symbol table that stores information about the atom , function , and predicate symbols in the programs .",
    "there is one record for each symbol in the table which stores such information as the _ name _ , _ arity _ , _ type _ , and _ entry point _ if the symbol is defined .    the _ stack _ stores frames associated with predicate calls .",
    "predicate call arguments are passed through the stack and only one frame is used for each predicate call . each time",
    "a predicate is called , a frame is placed on top of the stack unless the frame currently at the top can be reused .",
    "frames for different types of predicates have different structures . for standard prolog ,",
    "a frame is either _ determinate _ or _ nondeterminate_. a nondeterminate frame is also called a _",
    "choice point_.    the _ heap _ stores terms created during execution .    the _ trail _ stack stores updates that must be undone upon backtracking .",
    "the use of a trail stack to support backtracking is the major difference between prolog machines and machines for other languages such as pascal , lisp , and java .",
    "terms are represented in the same way as in the wam @xcite .",
    "a term is represented by a word containing a value and a tag .",
    "the tag distinguishes the type of the term",
    ". it may be ref denoting a reference , int denoting an integer , atm denoting an atom , str denoting a structure , or lst denoting a cons .",
    "a float is treated as a special structure in our implementation .",
    "another tag is used for suspension variables including domain variables .",
    "the following registers are used to represent the machine status ( see figure [ fig : mem ] ) :    [ cols= \" < , < \" , ]     the subgoaltable points to the subgoal table entry , and the currentanswer points to the current answer that has been consumed . the next unconsumed answer can be reached from this reference .    when a tabled predicate is invoked by a subgoal , a tabled frame is pushed onto the stack .",
    "the subgoal table is looked up to see if a variant of the subgoal exists .",
    "if so , the subgoaltable slot is set to point to the entry and currentanswer is set to point to the first answer in the answer table ( recall that the first answer is a dummy ) . if the state of the entry is complete , the subgoal only consumes existing answers one by one through backtracking .",
    "if the state of the entry is not complete , the subgoal is resolved using clauses if it appears for the first time and using existing answers if it has occurred before in the current round of evaluation .",
    "if no variant of the subgoal exists in the subgoal table , then an entry is allocated and the subgoal is resolved using clauses .",
    "after all clauses are tried on a tabled subgoal , a test is performed to see if the subgoal is complete .",
    "a subgoal is complete if it has never occurred in a loop , or it is a top - most looping subgoal and none of the subgoals in its scc has obtained any new answer during the current round of evaluation .",
    "the execution of a top - most looping subgoal is iterated until it becomes complete .",
    "when a top - most looping subgoal becomes complete , all the subgoals in its scc become complete as well .    as can be seen",
    ", the change to the architecture is minimal for supporting linear tabling . unlike in the implementations of slg , no effort is needed to preserve states of tabled subgoals and the garbage collector is kept untouched in linear tabling .",
    "linear tabling is more space efficient than slg since no stack frames are frozen for tabled subgoals .",
    "nevertheless , linear tabling without optimization could be computationally more expensive than slg due to the necessity of re - computation @xcite .",
    "this paper has surveyed the language features of b - prolog and given a detailed description of toam jr . with architectural support for action rules and tabling .",
    "b - prolog has strengths and weaknesses .",
    "the competitive prolog engine , the cutting - edge clp(fd ) system , and the efficient tabling system are clear advantages of b - prolog . with them , b - prolog serves well the core application domains such as constraint solving and dynamic programming .",
    "we will further strengthen b - prolog as a tool for these applications .",
    "future work includes parallelizing action rules for better performance in constraint solving and improving the tabling system to enhance the scalability of b - prolog for large - scale machine - learning applications .",
    "the shortcomings of b - prolog are also obvious .",
    "the lack of certain functionalities such as a module system , native interfaces with database and networking libraries , and support of unicode increasingly hinders the adoption of b - prolog in many other application domains .",
    "additions of these new features are also part of the future work .",
    "very early experiments were conducted while the author was a phd student at kyushu university during 1988 - 1991 .",
    "the first working system and the versions up to 4.0 were built while the author was with kyushu institute of technology during 1991 - 1999 .",
    "most recent improvements and enhancements have been conducted at brooklyn college of the city university of new york .",
    "the b - prolog system is indebted to many people in the logic programming community .",
    "i wish to express my gratitude to taisuke sato and yoshitaka kameya for their support , encouragement , and propelling .",
    "their prism system has been a strong driving force for recent improvements in the tabling system and memory management .",
    "the countless feedbacks from the prism team greatly helped enhance the robustness of the system .",
    "special thanks are also due to bart demoen for his intensive scrutiny of both the design and the implementation of b - prolog , yi - dong shen for his cooperation on linear tabling , and paulo moura and ulrich neumerkel for helping make the core part of b - prolog more compatible with the iso standard .",
    "thanks also go to the anonymous referees and the editors , maria garca de la banda and bart demoen , for their detailed comments and guidances on the presentation .",
    "b - prolog - related projects have received numerous grants from various funding organizations , most recently from aist , cisdd , psc cuny , and nsf .                                  , carro , m. , puebla , g. , and hermenegildo , m.  v. 2005 .",
    "a generator of efficient abstract machine implementations and its application to emulator minimization . in _ proceedings of the international conference on logic programming ( iclp)_. 2136 .      ,",
    "carlsson , m. , and sagonas , k.  f. 2001 .",
    "instruction merging and specialization in the sicstus prolog virtual machine . in _ proceedings of the international conference on principles and practice of declarative programming ( ppdp)_. 4960 .",
    "\\1998 . a high - level intermediate language and the algorithms for compiling finite - domain constraints . in _ proceedings of the joint international conference and symposium on logic programming",
    "( jicslp)_. 7084 .              ,",
    "kameya , y. , and sato , t. 2010 .",
    "mode - directed tabling for dynamic programming , machine learning , and constraint solving . in _ proceedings of the international conference on tools with artificial intelligence ( ictai)_. 213218 .      ,",
    "shen , y .- d . , and you , j. 2011 . compiling answer set programs into event - driven action rules . in _ proceedings of the international conference on logic programming and nonmonotonic reasoning ( lpnmr)_. to appear ."
  ],
  "abstract_text": [
    "<S> b - prolog is a high - performance implementation of the standard prolog language with several extensions including matching clauses , action rules for event handling , finite - domain constraint solving , arrays and hash tables , declarative loop constructs , and tabling . </S>",
    "<S> the b - prolog system is based on the toam architecture which differs from the wam mainly in that ( 1 ) arguments are passed old - fashionedly through the stack , ( 2 ) only one frame is used for each predicate call , and ( 3 ) instructions are provided for encoding matching trees . </S>",
    "<S> the most recent architecture , called toam jr . , departs further from the wam in that it employs no registers for arguments or temporary variables , and provides variable - size instructions for encoding predicate calls . </S>",
    "<S> this paper gives an overview of the language features and a detailed description of the toam jr . </S>",
    "<S> architecture , including architectural support for action rules and tabling .    </S>",
    "<S> # 1    [ firstpage ]    prolog , logic programming system </S>"
  ]
}