{
  "article_text": [
    "updating knowledge bases is an important issue in the area of data and knowledge representation . while this issue has been studied extensively in the context of classical knowledge bases ( cf .",
    ", e.g. ,  @xcite ) , attention to it in the area of nonmonotonic knowledge bases , in particular in logic programming , is more recent . various approaches to evaluating logic programs in the light of new information have been presented .",
    "the proposals range from basic methods to incorporate an update @xmath0 , given by a set of rules , or a sequence of such updates @xmath1 , into a ( nonmonotonic ) logic program @xmath2 @xcite , to more general methods which use an _ update policy _ to specify , by means of update actions , how the updates @xmath1 should be incorporated into the current state of knowledge @xcite . using these approaches , queries to the knowledge base , like `` is a fact @xmath3 true in @xmath2 after updates @xmath1 ? '' , can then be evaluated .",
    "notably , the formulation of such queries is treated on an ad hoc basis , and more involved queries such as `` is a fact @xmath3 true in @xmath2 after updates @xmath1 and possibly further updates ? '' are not considered .",
    "more generally , reasoning about an evolving knowledge base @xmath4 , maintained using an update policy , is not formally addressed .",
    "however , it is desirable to know about properties of the contents of the evolving knowledge base , which also can be made part of a specification for an update policy .",
    "for example , it may be important to know that a fact @xmath5 is always true in @xmath4 , or that a fact @xmath6 is never true in @xmath4 .",
    "analogous issues , called _ maintenance _ and _ avoidance _ , have recently been studied in the agent community @xcite .",
    "other properties may involve more complex temporal relationships , which relate the truth of facts in the knowledge base over time .",
    "a simple example of this sort is the property that whenever the fact @xmath7 , which intuitively means that a message should be sent to tom , is true in @xmath4 at some point , then the fact @xmath8 , representing that a message has been sent to tom , will be true in the evolving knowledge base at some point in the future .",
    "* main problems addressed . * in this paper , we aim at a framework for expressing reasoning problems over evolving knowledge bases , which are modeled as extended logic programs @xcite and may be maintained by an update policy as mentioned above .",
    "in particular , we are interested in a logical language for expressing properties of the evolving knowledge base , whose sentences can be evaluated using a clear - cut formal semantics",
    ". the framework should , on the one hand , be general enough to capture different approaches to incorporating updates @xmath1 into a logic program @xmath2 and , on the other hand , pay attention to the specific nature of the problem .",
    "furthermore , it should be possible to evaluate a formula , which specifies a desired evolution behavior , across different realizations of update policies based on different definitions .",
    "* main results . * the main contributions and results of this paper are summarized as follows .",
    "we introduce a formal model in which various approaches for updating extended logic programs can be expressed .",
    "in particular , we introduce the concept of an _ evolution frame _ , which is a structure @xmath9 whose components serve to describe the evolution of knowledge states of an agent associated with the knowledge base .",
    "this structure comprises    * a logic programming semantics , @xmath10 , for extended logic programs @xmath2 , resp .",
    "sequences @xmath11 of extended logic programs @xmath12 , over an alphabet @xmath13 ; * a nonempty class of _ events _ , which are sets of rules communicated to the agent ; and * an update frame @xmath14 , consisting of a set of update actions @xmath15 , an update policy @xmath16 , and a realization assignment @xmath17 , which together specify how to incorporate _ events _ , which are sets of rules drawn from a class of possible events @xmath18 and communicated to the agent , into the knowledge base .    in our framework , a _ knowledge state _ @xmath19 of the agent consists of an initial knowledge base @xmath4 , given by an extended logic program over the alphabet @xmath13 , and a sequence of events @xmath20 .",
    "associated with the knowledge state @xmath21 is the _ belief set _ @xmath22 of the agent , which comprises all formulas which the agent beliefs to hold given its state of knowledge .",
    "the agent reacts on an event by adapting its belief state through the update policy @xmath23 , which singles out update actions @xmath24 from a set of possible update actions @xmath15 for application .",
    "these update actions are executed , at a physical level , by compilation , using the realization assignment @xmath17 , into a single logic program @xmath2 , resp .",
    "a sequence of logic programs @xmath25 , denoted @xmath26 .",
    "the belief set @xmath22 is then given by the belief set of the compiled knowledge state , and is obtained by applying the belief operator @xmath27 for ( sequences of ) logics programs to @xmath26 .",
    "suitable choices of @xmath28 allow one to model different settings of logic program updates , such as @xcite .",
    "we define the syntax and , based on evolution frames , the semantics of a logical language for reasoning about evolving knowledge bases , which employs linear and branching - time operators familiar from computational tree logic ( ctl )  @xcite . using this language ,",
    "properties of an evolving knowledge base can be formally stated and evaluated in a systematic fashion , rather than ad hoc .",
    "for example , the maintenance problem from above can be expressed by a formula @xmath29 , and the avoidance problem by a formula @xmath30 ; the property about tom s messages is expressed by @xmath31    we investigate semantical properties of knowledge states for reasoning . since in principle a knowledge base may evolve forever , we are in particular concerned with obtaining finitary characterizations of evolution . to this end , we introduce various notions of equivalence between knowledge states , and show several filtration results : under certain properties of the components of @xmath28 , evolution of a knowledge state @xmath21 in an evolution frame @xmath28 can be described by a finite transition graph @xmath32 , which is a subgraph bisimilar to the whole natural transition graph @xmath33 over knowledge states that includes an arc from @xmath34 to every immediate successor state @xmath35 . in some cases , @xmath32 is constructible by exploiting locality properties of the belief operator @xmath27 and increasing compilations @xmath36 , while in others it results by canonization of the knowledge states .    in a concrete case study , we establish this for evolution frames which model policies in the @xmath37 framework for logic program updates using the answer set semantics @xcite , as well as for the lups @xcite and lups@xmath38 policies  @xcite under the dynamic stable model semantics  @xcite .",
    "similar results apply to updates under other semantics in the literature .",
    "we derive complexity results for reasoning .",
    "namely , we analyze the problem of deciding , given an evolution frame @xmath28 , a knowledge state @xmath21 , and a formula @xmath39 , whether @xmath40 holds .",
    "while this problem is undecidable in general , we single out several cases in which the problem is decidable , adopting some general assumptions about the underlying evolution frame . in this way , we identify meaningful conditions under which the problem ranges from  up to complexity .",
    "we then apply this to the @xmath37 framework under the answer set semantics @xcite , and show that its propositional fragment has -complexity .",
    "similar results might be derived for the lups and lups@xmath38 frameworks .",
    "we also consider the complexity of sequences of extended logic programs ( elps ) and generalized logic programs ( glps ) , respectively . we show that deciding whether two sequences @xmath41 and @xmath42 of propositional elps are strongly equivalent under the update answer set semantics , i.e. , whether for every sequence @xmath43 , @xmath44 , the concatenated sequences @xmath45 and @xmath46 have the same belief sets , is @xmath47-complete .",
    "this result is not immediate , since potentially infinitely many pairs @xmath45 and @xmath46 need to be checked .",
    "thus , testing strong equivalence between sequences of elps is not more expensive than standard inference of a literal from all answer sets of an elp ( cf .",
    "analogous results hold for sequences of glps .    to the best of our knowledge ,",
    "no similar effort to formally express reasoning about evolving nonmonotonic knowledge bases at a level as considered here has been put forth so far . by expressing various approaches in our framework , we obtain a formal semantics for reasoning problems in them .",
    "furthermore , results about properties of these approaches ( e.g. , complexity results ) may be concluded from the formalism by this embedding , as we illustrate for the @xmath37 framework .",
    "note that j.  leite , in his recent ph.d .",
    "thesis @xcite , considers properties of evolving logic programs in a language inspired by our @xmath37 language @xcite , and derives some properties for dynamic logic programs similar to properties for update programs derived in section  [ sec : complexity ] .",
    "the rest of this paper is structured as follows . in the next section ,",
    "we give some basic definitions and fix notation . in section  [ sec : evolution ] , we introduce our notion of an evolution frame , which is the basic setting for describing update formalisms , and in section  [ sec : frameworks ] , we show how different approaches to updating logic programs can be captured by it . in section  [ sec : reasoning ] , we then define the syntax and semantics of our logical language for reasoning about evolving knowledge bases .",
    "section  [ sec : equivalence ] is devoted to the study of equivalence relations over knowledge states , which are useful for filtration of the infinite transition graph that arises from an evolving knowledge base . in particular , conditions are investigated under which a restriction to a finite subgraph is feasible .",
    "after that , we address in section  [ sec : complexity ] the complexity of reasoning .",
    "related work is discussed in section  [ sec : conclusion ] , where we also draw some conclusions and outline issues for further research .",
    "we consider knowledge bases represented as _ extended logic programs _ ( elps ) @xcite , which are finite sets of rules built over a first - order alphabet @xmath13 using default negation @xmath48 and strong negation @xmath49 .",
    "a rule has the form @xmath50 where each @xmath51 is a literal of form @xmath52 or @xmath53 , where @xmath52 is an atom over @xmath13 . for a literal @xmath54 , the _ complementary literal _ , @xmath55 , is @xmath53 if @xmath56 , and @xmath52 if @xmath57 , for some atom @xmath52 . for a set @xmath58 of literals",
    ", we define @xmath59 .",
    "we also denote by @xmath60 the set @xmath61 of all literals over @xmath13 .",
    "the set of all rules is denoted by @xmath62 .",
    "we call @xmath63 the _ head _ of @xmath64 ( denoted by @xmath65 ) , and the set @xmath66 the _ body _ of @xmath64 ( denoted by @xmath67 ) .",
    "we define @xmath68 and @xmath69 .",
    "we allow the case where @xmath63 is absent from @xmath64 , providing @xmath70 ; such a rule @xmath64 is called a _",
    "constraint_. if @xmath71 and @xmath72 , then @xmath64 is called _",
    "fact_. we often write @xmath63 for a fact @xmath73 . further extensions , e.g. ,  @xmath48 in the rule head  @xcite , might be added to fit other frameworks .",
    "an _ update program _",
    ", @xmath74 , is a sequence @xmath25 of elps ( @xmath75 ) , representing the evolution of program @xmath76 in the light of new rules @xmath77 .",
    "we sometimes use @xmath78 to denote the set of all rules occurring in @xmath74 , i.e. ,   @xmath79 .",
    "the semantics of update programs can abstractly be described in terms of a belief operator @xmath27 , which associates with every sequence @xmath74 a set @xmath80 of rules , intuitively viewed as the consequences of @xmath74 .",
    "@xmath27 may be instantiated in terms of various proposals for update semantics , like , e.g. ,  the approaches described in @xcite .      for concrete examples ,",
    "we consider the answer set semantics for propositional update programs as introduced in  @xcite , as well as the semantics for dynamic logic programs as defined in  @xcite .",
    "the former semantics defines answer sets of a sequence of elps , @xmath41 , in terms of answers sets of a single elp @xmath2 as follows .",
    "an _ interpretation _",
    ", @xmath58 , is a set of classical literals containing no opposite literals @xmath52 and @xmath53 .",
    "rejection set _",
    ", @xmath81 , of @xmath74 with respect to an interpretation @xmath58 is @xmath82 where @xmath83 , and , for @xmath84 , @xmath85 contains every rule @xmath86 such that @xmath87 and @xmath88 , for some @xmath89 with @xmath90 .",
    "that is , @xmath81 contains the rules in @xmath74 which are rejected by unrejected rules from later updates .",
    "then , an interpretation @xmath58 is an _ answer set _ of @xmath91 iff @xmath58 is a consistent answer set @xcite of the program @xmath92 , i.e. ,  @xmath58 is a minimal consistent set of literals closed under the rules of the _ reduct _ @xmath93 .",
    "the set of all answer sets of @xmath74 is denoted by @xmath94 .",
    "this definition properly generalizes consistent answer sets from single elps to sequences of elps .",
    "nevertheless , we use @xmath95 to denote the set of all answer sets of a single elp @xmath2 .",
    "moreover , an elp @xmath2 is called _ inconsistent _ if it has no consistent answer set , i.e. ,  @xmath96 .",
    "update answer sets for arbitrary ( non - ground ) update programs @xmath74 are defined in terms of its ground instance similar as answer sets for elps @xcite .",
    "let @xmath97 @xmath98 , @xmath99 @xmath100 , and @xmath101 .",
    "then , @xmath76 has the single answer set @xmath102 with @xmath103 ; @xmath104 has answer set @xmath105 with @xmath106 ; and @xmath107 @xmath108 @xmath109 has the unique answer set @xmath110 with @xmath111 .    the belief operator @xmath112 in the framework of @xcite is given by @xmath113 for all @xmath114 , where @xmath115 means that for each ground instance @xmath116 of @xmath64 , either @xmath117 , or @xmath118 for some @xmath119 , or @xmath120 for some @xmath121 .      by the term _ dynamic answer sets _",
    "we refer to the extension of dynamic stable models , defined for sequences of _ generalized logic programs _",
    "( _ glps _ ) by alferes _",
    "et al . _",
    "@xcite , to the three - valued case . in glps",
    ", default negation may appear in the head of rules , but strong negation is excluded .",
    "the definition of dynamic stable models uses a slightly non - standard concept of stable models , where weakly negated literals @xmath122 ( @xmath52 some atom ) are treated like ordinary propositional atoms , and rules @xmath123 @xmath124 are viewed as _",
    "horn clauses_. accordingly , an interpretation @xmath125 is in this context understood as a set of atoms and weakly negated atoms such that @xmath126 iff @xmath127 holds for each atom @xmath52 . to distinguish it from a usual interpretation , we call it a _ generalized interpretation_. as usual , a set @xmath128 , comprising atoms and weakly negated atoms , is true in a generalized interpretation @xmath125 , symbolically @xmath129 , iff @xmath130 . towards defining stable models ,",
    "the following notation is required :    let , for a set of atoms @xmath13 , @xmath131 stand for the set @xmath132 .",
    "furthermore , for @xmath133 , we set @xmath134 , and , for @xmath135 , we define @xmath136 if @xmath137 and @xmath138 if @xmath139 . for a program @xmath2 over @xmath13 , the deductive closure , @xmath140 ,",
    "is given by the set @xmath141 where @xmath2 is interpreted as a propositional horn theory and `` @xmath142 '' denotes classical derivability .",
    "a generalized interpretation @xmath58 is a stable model of a program @xmath2 iff @xmath143 .",
    "let @xmath91 be a sequence of glps over @xmath13 , and let @xmath125 be a generalized interpretation .",
    "et al . _",
    "@xcite introduce the following concepts :    xx= @xmath144 = = @xmath145 = @xmath146 + @xmath147 ; + @xmath148 = ' @xmath149 in @xmath74 such that @xmath150 and @xmath151 .",
    "a set @xmath152 is a _ dynamic stable model _ of @xmath74 iff",
    "@xmath153 we remark that alferes _",
    "defined dynamic stable models of @xmath74 as projections @xmath154 of the stable models of a single glp , @xmath155 , resulting from a transformation ( for a detailed definition cf .",
    "@xcite ) , and then proved the above characterization as a result .",
    "alferes _ et al . _",
    "@xcite defined also an extension of their semantics to the three - valued case : let @xmath41 be a sequence of elps over @xmath13 .",
    "then , a consistent set @xmath156 is a _",
    "dynamic answer set _ of @xmath74 iff @xmath157 is a dynamic stable model of the sequence @xmath158 of glps . here",
    ", the rules in @xmath159 serve for emulating classical negation through weak negation .",
    "let , as in the previous example , @xmath97 @xmath98 , @xmath99 @xmath100 , and @xmath101 over @xmath160 .",
    "then , @xmath76 has the single dynamic answer set @xmath161 , where @xmath162 and @xmath163 ; the sequence @xmath164 has the dynamic answer set @xmath105 , where @xmath165 and @xmath166 , @xmath167 ; and @xmath107 @xmath108 @xmath109 has the single dynamic answer set @xmath110 , where @xmath168 @xmath169 and @xmath170 .",
    "note that in these simple examples , update answer sets and dynamic answer sets coincide , which is not the case in general @xcite .",
    "similarly to the belief operator @xmath112 , we can define a belief operator @xmath171 for dynamic stable models as @xmath172 for all @xmath173 , where @xmath174 denotes the set of all dynamic stable models of @xmath74 .    finally",
    ", we remark that while we defined answer sets and belief sets for sequences of finite programs , they can be defined for sequences of possibly infinite programs in an analogous way .",
    "we assume that the agent has an initial knowledge base , @xmath4 , in form of an extended logic program , and a background _ update policy _ , @xmath23 , describing the update behavior of the agent , i.e. ,  how it has to react when it receives new information from the environment .",
    "information arrives to the agent in form of a sequence of _ events _ , each event being a finite set of rules from a given _",
    "event class_. the update policy specifies what rules or facts have to be incorporated into or retracted from the knowledge base , depending on the content of the event and on the belief set of the agent .",
    "the evolution of the agent s _ knowledge state _ is thus completely described when @xmath4 and a sequence of events @xmath20 are given , provided an update policy @xmath23 is specified .",
    "we start with the basic formal notions of an _ event _ and of the _ knowledge state _ of an agent maintaining a knowledge base .",
    "let @xmath13 be some alphabet . an _ event class over @xmath13 _",
    "@xmath175or simply _ event class _ , if no ambiguity arises@xmath176 is a collection @xmath177 of finite sets of rules .",
    "the members @xmath178 are called _",
    "events_.    informally , @xmath18 describes the possible events ( i.e. ,  sets of communicated rules ) an agent may experience . in the most general case ,",
    "an event is an arbitrary elp ; a plain case is that an event just consists of a set of facts , which are formed over a subset of the alphabet . in a deductive database setting",
    ", the latter case corresponds to an extensional database that is undergoing change while the intensional part of the database remains fixed .",
    "let @xmath18 an event class over some alphabet @xmath13 . a _ knowledge state over @xmath18 _",
    "@xmath175simply , a _ _ knowledge state__@xmath176 is a tuple @xmath179 , where @xmath180 is an elp @xmath175called _ initial knowledge base ) _ and each @xmath181 @xmath182 is an event from @xmath18 .",
    "the _ length of _",
    "@xmath21 , denoted @xmath183 , is @xmath184 .",
    "the set of all knowledge states over @xmath13 given @xmath18 is denoted by @xmath185 .",
    "intuitively , @xmath186 captures the agent s knowledge , starting from its initial knowledge base .",
    "when a new event @xmath187 occurs , the current knowledge state @xmath21 changes to @xmath188 , and the agent should adapt its belief set in accordance with the new event obeying its given update policy .",
    "the `` universe '' in which the evolution of an agent s knowledge base takes place is given by the concept of an _ evolution frame _ , which comprises different components that parameterize the update mechanism and the semantics used on the evolving knowledge base .",
    "this structure comprises , together with an alphabet @xmath13 ,    * a semantics , @xmath27 , for elps , resp .",
    "sequences of elps , over @xmath13 ; * a nonempty event class @xmath18 over @xmath13 ; and , * an _ update frame _ @xmath14 , consisting of a set of _ update commands _ @xmath15 , an _ update policy _ @xmath16 , and a _ realization assignment _ @xmath17 , which together specify how to incorporate events into the knowledge base .    in more detail ,",
    "the components of an update frame are as follows .",
    "[ [ update - commands . ] ] update commands .",
    "+ + + + + + + + + + + + + + + +    the update commands ( or _ actions _ ) in @xmath15 are names for commands which are supposed to be executed on the knowledge base .",
    "simple , elementary update commands are @xmath189 and @xmath190 , which add and remove a rule to a logic program , respectively , without a sophisticated semantics handling potential inconsistencies ( which may be delegated to the underlying update semantics ) .",
    "more involved update commands have been proposed in the literature ( cf .",
    ", e.g. ,  @xcite ) .",
    "however , several update frameworks can be modeled using these simple commands .",
    "the semantics ( i.e. , effects ) of update actions are given by the realization assignment , @xmath17 , which is described below .",
    "[ [ update - policy . ] ] update policy .",
    "+ + + + + + + + + + + + + +    the update policy @xmath23 , which is a function mapping every pair @xmath191 of a knowledge state @xmath21 over @xmath18 ( i.e. ,  @xmath192 ) and an event @xmath193 into a set @xmath194 of update commands , determines _ which _",
    "actions should be executed .",
    "update policies allow for specifying sensible and flexible ways to react upon incoming events .",
    "a very simple policy is @xmath195 ; it models an agent which incorporates the new information unconditionally .",
    "more sophisticated policies may define exceptions for the incorporation of rules from events , or the insertion of rules may be conditioned on the belief in other rules .",
    "[ [ realization - assignment . ] ] realization assignment .",
    "+ + + + + + + + + + + + + + + + + + + + + + +    the realization assignment @xmath17 assigns to each pair @xmath196 of a knowledge state @xmath21 over @xmath18 and a set @xmath197 of update commands a sequence @xmath198 of elps @xmath12 over @xmath13 @xmath199 .",
    "it associates in this way a meaning with the set of actions @xmath52 which must be executed on the knowledge state @xmath21 , in terms of an elp , resp .",
    "a sequence of elps , and `` realizes '' the update in this way .",
    "the agent s beliefs from the updated knowledge base may then be given by the operator @xmath27 applied to the result of @xmath200 as defined in section  [ sec : comp - belief ] below .",
    "different possibilities for concrete realization assignments @xmath17 may be used . a simple realization assignment , @xmath201 , which works for sets @xmath52 of actions of form @xmath202 and @xmath203 , and assumes that each knowledge state @xmath21 is assigned with an ordinary elp @xmath204 , is given by @xmath205 i.e. , the insertion and deletion commands in @xmath52 are `` physically '' implemented , with no further enforcement that consistency is preserved , or , as for deletion , that @xmath64 is actually logically deleted from the knowledge base .",
    "its restriction to insertion commands is the realization assignment @xmath206 , which may be used in contexts where data are not physically removed , for whatever reasons .",
    "more sophisticated realization assignments might block , at the logical level , the applicability of rules in the knowledge base , by using a sequence @xmath25 of elps as a representation , and aim at enforcing consistency of the knowledge base .",
    "for instance , in the dynamic logic programming semantics of sequences of elps in @xcite , more recent rules occur later in a sequence and override rules from programs which occur earlier in the sequence ; this mechanism is also used in the @xmath37 framework for incorporating changes to the knowledge base at the logical level @xcite .    in summary",
    ", we formally define an evolution frame as follows .",
    "let , for any alphabet @xmath13 , denote @xmath207 the set of all sequences @xmath208 , @xmath75 , of elps @xmath12 over  @xmath13 .",
    "an _ evolution frame _ is a tuple @xmath9 , where    * @xmath13 is a finite @xmath175first - order@xmath176 alphabet ; * @xmath18 is a nonempty event class over @xmath13 ; * @xmath15 is a set of update commands @xmath175or actions@xmath176 ; * @xmath209 is an update policy ; * @xmath210 is a realization assignment ; and * @xmath211 is a belief operator for sequences of elps .",
    "the set of all knowledge states in @xmath28 , denoted by @xmath212 , is given by @xmath185 .",
    "the concept of an evolution frame allows us to model various update approaches , as we discuss below in section  [ sec : frameworks ] .",
    "while @xmath23 determines _ what _ to do , the realization assignment @xmath17 states _ how _ this should be done .",
    "informally , @xmath200 `` executes '' actions @xmath52 on the knowledge state @xmath21 by producing a logic program @xmath2 or , in general , a sequence of logic programs @xmath74 .",
    "we can use @xmath17 to `` compile '' a knowledge state @xmath21 into a ( sequence of ) logic programs , by determining the set of actions @xmath52 from the last event in @xmath21 .",
    "we introduce the following notation .    for any knowledge state @xmath179 over @xmath18 , denote by @xmath213 its projection to the first @xmath214 events , for @xmath215 .",
    "in particular , @xmath216 is the initial knowledge base @xmath4 .",
    "we call @xmath217 a _ previous knowledge state _ ( or simply an _ ancestor _ ) of @xmath21 if @xmath218 .",
    "dually , a knowledge state @xmath219 over @xmath18 is _ a future knowledge state _ ( or simply a _ descendant _ ) of @xmath21 if @xmath21 is previous to @xmath219 .",
    "furthermore , @xmath220 is the _ predecessor _ of @xmath21 , and @xmath219 is a _ successor _ of @xmath21 , if @xmath21 is predecessor of @xmath219 . finally , for events @xmath221 ,",
    "we write @xmath222 to denote the concatenated knowledge state @xmath223 ; a similar notation is used for the concatenation of sequences of logic programs .    [ comp ] let @xmath9 be an evolution frame",
    ". for any knowledge state @xmath224 over @xmath18 , the _ compilation associated with @xmath21 _ is @xmath225    note that @xmath36 is a function which is fully determined by @xmath28 ; we often write @xmath226 instead of @xmath36 if @xmath28 is understood .",
    "this definition of compilation is fairly general .",
    "it first computes the actions for the latest event @xmath227 , and then requires that these actions are executed on the predecessor state .",
    "observe that , in view of @xmath26 , we could equally well model update policies as unary functions @xmath228 such that @xmath229 .",
    "however , we chose binary update policies to stress the importance of the last event in @xmath21 .",
    "furthermore , @xmath23 may be restricted in the compilation process , e.g. ,  such that only the belief set @xmath230 of the predecessor state is considered rather than the whole state itself ; this will be considered in section  [ sec : canonical ] .    [",
    "[ incremental - compilation . ] ] incremental compilation .",
    "+ + + + + + + + + + + + + + + + + + + + + + + +    an important class of compilations are those in which , for a future knowledge state @xmath219 , @xmath231 results by appending some further elements to the sequence @xmath232 of logic programs for the current knowledge state @xmath21 .",
    "this motivates the following notion :    given an evolution frame @xmath9 , @xmath36 is _ incremental _ iff , for each @xmath179 , @xmath233 such that @xmath234 and @xmath235 for @xmath236 .",
    "this definition amounts to the expected behavior :    the mapping @xmath36 is incremental iff , for each knowledge state @xmath21 , @xmath237 if @xmath238 , and @xmath239 otherwise , where @xmath240 are logic programs and `` + '' is the concatenation of sequences .",
    "the proof proceeds by straightforward induction on @xmath183 .",
    "@xmath241    a simple incremental compilation results for @xmath242 , @xmath243 as defined in subsection  [ sec : frame ] , and @xmath244 such that @xmath245 and @xmath246 , where @xmath247 , given that @xmath179 . note that @xmath26 is in this setting just the sequence @xmath248 .",
    "while incremental compilations are natural , we stress that other compilations are of course also highly relevant .",
    "in particular , the compilation might perform optimizations ( cf.section  [ sec : canonical ] ) , or output only an ordinary logic program .",
    "we also point out that our notion of incremental compilation should not be confused with an _ iterative compilation _ ; such a compilation would , similar in spirit , consider the events @xmath181 in a knowledge state @xmath249 in their chronological order one by one and instantaneously incorporate updates @xmath250 into the result @xmath251 for the previous knowledge state and return a single , ordinary logic program as the result .",
    "the compilation of a knowledge state into a ( sequence of ) elps is used , via the semantics @xmath27 for sequences of elps , to ascribe a set of beliefs to the agent in the respective knowledge state .",
    "more formally , the belief set emerging from a knowledge state is as follows .",
    "let @xmath9 be an evolution frame and @xmath21 a knowledge state .",
    "the belief set of @xmath21 , denoted @xmath22 , is given by @xmath252 .",
    "this completes the exposition of evolution frames and their semantics . before we consider some examples ,",
    "let us close this subsection with some remarks .",
    "[ [ remarks . ] ] remarks .",
    "+ + + + + + + +    \\(1 ) as mentioned earlier , our definition of an update policy , and similarly of a realization assignment , which effectively lead to the notion of a compilation , is very general .",
    "we may stipulate additional postulates upon them , like the incrementability property or an iterativity property ( which we omit here ) .",
    "likewise , the concept of a semantics @xmath253 for sequences @xmath74 of elps is very abstract , and further axioms and conditions could be imposed on it .",
    "an example of this is the requirement that @xmath253 is characterized by rules of bounded length , and in particular by rules without repeated literals ; this will be the case in section  [ sec : complexity ] .",
    "\\(2 ) our definition does not capture nondeterministic update policies , where @xmath254 may return one out of several possible sets of update actions . in order to model this ,",
    "the notion of a knowledge state can be extended by taking previous actions into account , i.e. ,  a knowledge state @xmath21 is then of the form @xmath255 , where each @xmath181 is an event , and @xmath256 is the set of update commands executed at step @xmath214 .",
    "in practice , we may assume a suitable _ selection function _",
    "@xmath257 , which chooses one of the possible outcomes of @xmath254 , and we are back to a deterministic update policy @xmath258 .",
    "if the selection function @xmath257 is unknown , we may consider all evolution frames @xmath259 arising for each @xmath257 .",
    "let us illustrate our framework on two examples , which serve as running examples throughout the remainder of the paper .",
    "[ exa : shop - agent ] consider a shopping agent selecting web shops in search for some specific merchandise .",
    "suppose its knowledge base , @xmath4 , contains the rules @xmath260 r_2 : & \\mathit{site\\_queried } & { \\leftarrow } & \\mathit{query}(s ) ; \\\\[0.5ex ] r_3 : & \\mathit{notify }     & { \\leftarrow } & { { \\it not}\\,}\\mathit{site\\_queried } ;   \\end{array}\\ ] ] and a fact @xmath261 as an initial time stamp . here",
    ", @xmath262 expresses that a shop @xmath58 , which has a sale and whose web site is up , is queried by default , and @xmath263 , @xmath264 serve to detect that no site is queried , which causes ` @xmath265 ' to be true .",
    "assume that an event , @xmath266 , might consist of one or more of the following items :    * at most one fact @xmath267 , for some date @xmath268 ; * facts @xmath269 or @xmath270 , stating that a shop @xmath21 is up or down , respectively ; * ground rules of form @xmath271 , stating that shop @xmath21 has a sale on date @xmath268 .    an update policy @xmath272 may be defined as follows :    xx= @xmath254 = = @xmath273 @xmath274 + @xmath275 + @xmath276 @xmath274 + @xmath277 + @xmath278 @xmath274 + @xmath279    informally , this update policy incorporates information about future sales , only .",
    "the information of the sale is removed , when the sale ends ( assuming the time stamps increase ) . to this end ,",
    "facts @xmath280 are used to keep track of inserted sale information .",
    "similarly , the current time stamp @xmath281 is maintained by deleting the old values .",
    "the realization assignment @xmath17 might be @xmath282 from subsection  [ sec : frame ] , which always returns a single elp , and for @xmath10 we may take any function which coincides on sequences @xmath283 of length one with the standard answer set semantics for elps . or",
    ", we might choose a realization assignment which maps @xmath21 and a set of @xmath202 and @xmath203 commands to a sequence @xmath25 of elps , using as @xmath10 the answer set semantics for sequences of elps as discussed in subsection  [ sec : frame ] .",
    "[ exa : mail - agent ] consider a more complex mail agent , which has the following initial knowledge base @xmath4 , whose rules are instantiated over suitable variable domains : @xmath284 the knowledge base allows to express several attributes of a message and determine the @xmath285 of a message based on these attributes ( rules @xmath262 and @xmath263 ) . by means of @xmath264",
    ", a default type is assigned to all messages which are neither @xmath286 nor @xmath287 .",
    "rule @xmath288 implicitly states that a @xmath289 operation is stronger than a @xmath290 one .",
    "note that in this way , once a message has been saved , it can never be removed . by means of @xmath291 ,",
    "all those messages are removed which have not been saved and are older than thirty days .",
    "rules @xmath292 , @xmath293 and @xmath294 are used to look for all messages of a given type , which have not been sent to the trash yet , and to signal if at least one such message has been found ( @xmath295 ) or not ( @xmath296 ) .",
    "suppose that an event @xmath266 may consist in this scenario of one or more of the following items :    * at most one fact @xmath297 , for some date @xmath298 ; * a fact @xmath299 , which causes messages in the trash to be eliminated ; * facts @xmath300 or @xmath301 , for mail identifiers @xmath302 ; * at most one fact @xmath303 , for some mail type @xmath304 ; * zero or more sets of facts @xmath305 , or @xmath306 for mail identifier @xmath302 , name @xmath184 , subject @xmath21 , and date @xmath298 .",
    "the update policy @xmath23 may be as follows :    xx= @xmath254 = = @xmath307 @xmath274 + @xmath308 @xmath274 + @xmath309 = @xmath310 , + @xmath311 @xmath274 + @xmath312 , + @xmath313 @xmath274 + @xmath314 , + @xmath315 .",
    "this update policy ( which does not respect possible conflicts of @xmath289 and @xmath290 ) intuitively adds all incoming information , plus a fact @xmath316 for each incoming mail to the knowledge base .",
    "the current date is maintained by deleting the old date .",
    "as well , all old information from a previous event , relative to a search or to the trash , is removed . if an event contains @xmath299 , then all messages in the trash are eliminated . like in the previous example , the realization assignment @xmath17 may be given by @xmath282 from subsection  [ sec : frame ] , or could map @xmath21 and @xmath52 incrementally to a sequence of elps using as @xmath10 simply the answer set semantics for sequences of elps .",
    "to emphasize the generality of our framework , we now discuss how existing frameworks for updating nonmonotonic knowledge bases can be captured in terms of evolution frames .",
    "this is possible at two different levels :    at an `` immediate update '' level , frameworks for updating logic programs can be considered , where each event is an _ update program _ , and the update policy is the ( implicit ) way in which update programs and the current knowledge are combined , depending on the semantics of updates of each approach . for example , the formalisms of update programs  @xcite , dynamic logic programs  @xcite , revision programs  @xcite , abductive theory updates @xcite , and updates through prioritized logic programs ( plps )  @xcite fall into this class .    at a higher level ,",
    "frameworks can be considered which allow for specifying an explicit _ update policy _ in some specification language , and which offer a greater flexibility in the handling of updates .",
    "examples of such frameworks are @xmath37  @xcite , lups and lups@xmath38 @xcite , kabul  @xcite , and , while not directly given in these terms , @xmath317  @xcite .",
    "in what follows , we show how some of the above mentioned frameworks can be expressed in evolution frames , which shows the generality of the approach .",
    "we start capturing the formalisms at the update level introduced in section  [ prel ] , i.e. ,  the answer set semantics for update programs , represented by @xmath112 , and the dynamic stable model semantics for generalized logic programs , represented by @xmath171 . for both semantics",
    ", we also show how they are combined with convenient specification languages to form higher level frameworks : @xmath171 is combined with the language lups  @xcite , which allows for more flexibility of the update process , permitting to dynamically specify the contents of a sequence of updates by means of update commands ; and the semantics @xmath112 is employed together with the language @xmath37  @xcite , which is more expressive than lups .",
    "it allows for update statements to depend on other update statements in the same @xmath37 policy , and more complex conditions on both the current belief set and the actual event can be specified .",
    "further frameworks and semantics are also discussed here , albeit more briefly and stressing only the main characterizations .",
    "we repeatedly use the particular set @xmath318 of insert commands , the insert policy @xmath319 , and the insert realizations @xmath244 and @xmath282 from subsection  [ sec : frame ] .",
    "update programs @xcite are captured by the following evolution frame : @xmath320 where @xmath321 is the collection of all elps over @xmath13 , and @xmath112 is the belief operator defined in section  [ prel ] .",
    "the @xmath37 framework @xcite corresponds to the evolution frame @xmath322 where    * @xmath323=@xmath324 + @xmath325 , + and the commands have the meaning as in  @xcite ; * @xmath326 is defined by any set of update statements in the language @xmath37 , which are evaluated through a logic program as defined in  @xcite ; * @xmath327 realizes the translation @xmath328 from @xcite , which compiles the initial knowledge base @xmath4 and the sets of update commands @xmath1 , in response to the events @xmath20 in @xmath249 , into a sequence @xmath25 of elps .",
    "the resulting compilation @xmath329 is incremental .",
    "observe that , while @xmath330 as in @xcite is involved and has to keep track of persistent update commands @xmath331}(r)$ ] from the past , as shown in @xcite , it is possible , by encoding persistent commands in polynomial time in the belief set , to restrict actions , without loss of expressiveness , to the commands @xmath332 and @xmath333 ( whose meaning is the intuitive one ) and making @xmath17 actually depend only the belief set @xmath230 of the predecessor and the event @xmath227 .",
    "dynamic logic programming @xcite can be captured by the following evolution frame : @xmath334 where @xmath335 is the collection of all finite sets of generalized logic program rules , i.e. ,  no strong negation is available and weak negation can occur in the head of rules , and @xmath171 is the semantics of dynamic logic programs as given in section  [ prel ] .",
    "the lups framework @xcite for update specifications corresponds to the following evolution frame : @xmath336 where    * @xmath337 is the collection of all finite sets of lups statements ( cf .",
    "@xcite ) ; * @xmath338=@xmath339 + @xmath325 , + where the commands have the meaning explained in  @xcite ; * @xmath340 is defined by @xmath341 @xmath342 @xmath266 contains @xmath343 and @xmath344 ; * @xmath345 is as described in  @xcite ; that is , @xmath346 adds for @xmath249 and @xmath52 a program @xmath347 to the sequence of programs @xmath25 associated with @xmath21 , returning @xmath348 , where @xmath347 is computed from the persistent commands @xmath349 valid at state @xmath21 , @xmath22 , and the lups commands in @xmath52 .    in  @xcite ,",
    "the semantics of lups has been slightly modified and extended by a permanent retraction command .",
    "the resulting framework , lups@xmath38 , can be captured by the following evolution frame : @xmath350 where    * @xmath351 is the collection of all finite sets of lups@xmath38 statements ( cf .",
    "@xcite ) ; * @xmath352=@xmath353 + @xmath354 + @xmath355 + @xmath356 , + where the commands have the meaning as described in  @xcite ; * @xmath357 is defined by @xmath358 @xmath342 @xmath266 contains @xmath343 and @xmath344 ; * @xmath359 is given as in  @xcite ; like before , @xmath360 adds a program @xmath347 to the sequence of programs @xmath25 associated with @xmath21 , where @xmath347 is computed from persistent commands @xmath361 valid at state @xmath21 , @xmath22 , and the lups@xmath38 commands in @xmath52 .    like in the case of @xmath37 , the compilation functions @xmath362 and @xmath363 are incremental , and also persistent commands ( @xmath364 and @xmath365 , as well as @xmath366 , @xmath367 , @xmath368 , and @xmath369 @xmath370 , respectively ) can be eliminated through coding into the knowledge base .      in @xcite , a language for revision specification of knowledge bases",
    "is presented , which is based on logic programming under the stable model semantics .",
    "a knowledge base is in this context a set of atomic facts , i.e. , a plain relational database .",
    "revision rules describe which elements are to be present ( so - called _ _",
    "in-__rules ) or absent ( _ _ out-__rules ) from the knowledge base , possibly under some conditions . a fixed - point operator , which satisfies some minimality conditions ,",
    "is introduced to compute the result of a revision program . as for stable models",
    ", there may be several knowledge bases or no knowledge base satisfying a given revision program .",
    "the framework of revision programs can be captured by the following evolution frame : @xmath371 where    * @xmath372 is the collection of finite sets of _ revision _ rules , i.e. ,  negation - free rules whose constituents are of the form @xmath373 or @xmath374 , where @xmath128 is an atom from @xmath13 ; * @xmath375 ; * @xmath376 is defined by @xmath377 , where @xmath378 is the _ necessary change _ ( cf .",
    "@xcite ) for @xmath232 with respect to @xmath266 ; * @xmath379 is defined by @xmath380",
    "if @xmath381 , and @xmath382 otherwise , i.e. ,  @xmath383 corresponds to @xmath384 where @xmath385 .",
    "notice that @xmath383 , and in particular @xmath232 , where @xmath386 , is thus a set of facts .",
    "* @xmath387 is such that , for each elp @xmath2 , it returns the collection of facts in @xmath2 .",
    "inoue and sakama @xcite developed an approach to theory update which focuses on nonmonotonic theories .",
    "they introduced an extended form of abduction and a framework for modeling and characterizing nonmonotonic theory change through abduction .",
    "intuitively , this is achieved by extending an ordinary abductive framework by introducing the notions of negative explanation and _ anti - explanation _ ( which makes an observation invalid by adding hypotheses ) , and then defining autoepistemic updates by means of this framework .",
    "the framework of extended abduction is then used in  @xcite to model updates of nonmonotonic theories which are represented by elps . for theory updates ,",
    "the whole knowledge base is subject to change .",
    "new information in form of an update program has to be added to the knowledge base and , if conflicts arise , higher priority is given to the new knowledge .",
    "the updated knowledge base is defined as the union @xmath388 of the new information @xmath0 and a maximal subset @xmath389 of the original program that is consistent with the new information ( which is always assumed to be consistent ) .",
    "the abductive framework is in this context used for specifying priorities between current and new knowledge , by choosing as abducibles the difference between the initial and the new logic program .",
    "the framework for updates by means of abduction can be captured by the following evolution frame : @xmath390 where    * @xmath391 , where @xmath392 ; * @xmath393 is defined by @xmath394 where @xmath395 is , as defined in  @xcite , a maximal set of rules to be removed from the current knowledge base @xmath232 , which is a single logic program .",
    "note that , in general , @xmath395 may not be unique .",
    "hence , for a deterministic update policy , we assume a suitable _ selection function _",
    "@xmath257 which chooses one of the possible outcomes for @xmath395 .",
    "* @xmath396 is defined by @xmath397 if @xmath381 , and @xmath398 otherwise , i.e. , @xmath396 amounts to @xmath384 for @xmath399 , provided that @xmath52 does not contain conflicting commands @xmath190 and @xmath189 for any rule @xmath64 . * @xmath400 is such that , for any elp @xmath2 , it is the ordinary answer set semantics of elps .      in  @xcite ,",
    "the update of a knowledge base of ground literals by means of a _",
    "prioritized logic program _ ( plp ) is addressed .",
    "the idea in updating the initial program , @xmath2 , with respect to the new one , @xmath401 , is to first eliminate contradictory rules from @xmath2 with respect to @xmath401 , and then to solve conflicts between the remaining rules by means of a suitable plp .",
    "the semantics of the update is thus given by the semantics of the corresponding plp , for which zhang and foo use the one they have proposed earlier in  @xcite , which extends the answer set semantics .",
    "the method is to reduce plps to elps by progressively deleting rules that , due to the defined priority relation , are to be ignored .",
    "the answer sets of the resulting elp are the intended answer sets of the initial plp .",
    "formulated initially for static priorities , the method was extended to dynamic priorities , which are handled by a transformation into a corresponding ( static ) plp .",
    "the framework for updates by means of plps is defined only for single step updates , and a generalization to multiple steps is not immediate .",
    "we can model a single - step update by the following evolution frame : @xmath402 where    * @xmath403 is defined by @xmath404 where @xmath405 is computed , along the procedure in @xcite , as a set of rules to be retracted from the current knowledge base ; * @xmath406 is defined by @xmath407 if @xmath381 , and @xmath408 otherwise , where @xmath409 and @xmath410 ; * @xmath411 is the semantics for prioritized logic programs @xcite , viewing @xmath412 as a program where the rules of @xmath413 have higher priority than the ones in @xmath414 .    thus , several well - known approaches to updating logic programs can be modeled by evolution frames .",
    "we remark that further approaches , though not concerned with logic programs , might be similarly captured .",
    "for example , to some extent , brewka s declarative revision strategies @xcite can be captured .",
    "brewka introduced a nonmonotonic framework for belief revision which allows reasoning about the reliability of information , based on meta - knowledge expressed in the object language itself . in this language ,",
    "revision strategies can be declaratively specified as well .",
    "the idea is to revise nonmonotonic theories by adding new information to the current theory , and to use an appropriate nonmonotonic inference relation to compute the accepted conclusions of the new theory .",
    "the desired result is achieved in two steps .",
    "the first step consists in an extension of default systems in order to express preference information in the object language , together with an appropriate new definition of theory extensions . in a second step ,",
    "a notion of prioritized inference is introduced , formalized as the least fixed - point of a monotone operator , thus identifying epistemic states with preferential default theories under this ad hoc semantics .",
    "the approach can be captured by a suitable evolution frame @xmath415 which naturally models the insertion of formulas into a preference default theory , i.e. ,     * @xmath416 is the set of all propositional formulas of the language ; * @xmath417 ; * @xmath418 is implicitly encoded in the current knowledge state ( i.e. ,  the current preference default theory , cf .",
    "@xcite ) , and is such that @xmath419 ; * @xmath420 produces the new preference default theory by simply executing the insertion of the new formula(s ) into it , i.e. , @xmath421 , where @xmath422 and @xmath423 if @xmath381 , as usual ; and * @xmath424 is the function assigning to each preference default theory its set of accepted conclusions , as defined in  @xcite .",
    "however , there also exist frameworks which take a different point of view and can not be captured by our definition of an evolution frame .",
    "this is the case if the state of an agent and the environment , and thus the action taken by an agent , are dependent on the whole history of events and actions taken ( which is also known as a _ run _ ) , not only on the current state .",
    "the approach of wooldridge  @xcite is an example of such a framework .",
    "we now introduce our logical language for expressing properties of evolving knowledge bases ,  ( evolving knowledge base logic ) , which we define as a branching - time temporal logic akin to ctl @xcite , which has become popular for expressing temporal behavior of concurrent processes and modules in finite state systems .",
    "[ [ syntax . ] ] syntax .",
    "+ + + + + + +    the primitive logical operators of the language   are :    * the boolean connectives @xmath425 ( `` and '' ) and @xmath426 ( `` not '' ) ; * the evolution quantifiers @xmath427 ( `` for all futures '' ) and @xmath428 ( `` for some future '' ) ; and * the linear temporal operators @xmath429 ( `` next time '' ) and @xmath430 ( `` until '' )",
    ".    atomic formulas of  are identified with the rules in the language @xmath62 , given an alphabet @xmath13 ; composite formulas are _ state formulas _ , as defined  by means of atomic formulas and _ evolution formulas_below .",
    "note that we use the symbol @xmath426 for negation in composite formulas , in order to distinguish it from the negation symbols used in atomic formulas occurring in rules .    1 .",
    "each atomic formula is a state formula .",
    "2 .   if @xmath39 and @xmath431 are state formulas , then @xmath432 and @xmath433 are state formulas .",
    "3 .   if @xmath39 is an evolution formula , then @xmath434 and @xmath435 are state formulas . 4 .   if @xmath436 are state formulas , then @xmath437 and @xmath438 are evolution formulas .    intuitively",
    ", evolution formulas describe properties of the evolving knowledge base , since they use the linear - time operators `` next time '' and `` until , '' which apply to a given infinite evolution path consisting of knowledge states which are reached by successive events .",
    "the operator @xmath429 refers to the next state of the path and states that the formula @xmath39 is true , while the operator @xmath430 refers to a ( possibly empty ) initial segment of the path , and asserts that @xmath39 holds true in each state of this segment and that immediately after it @xmath431 holds true .",
    "we may extend our language by defining further boolean connectives @xmath439 ( `` or '' ) , @xmath440 ( `` implies '' ) , and @xmath441 ( `` equivalence '' ) in terms of other connectives , as well as important linear - time operators such as @xmath442 ( `` finally @xmath39 '' ) and @xmath443 ( `` globally @xmath39 '' ) , which intuitively evaluate to true in path @xmath444 if @xmath39 is true at some resp .  every stage @xmath445 .",
    "the following examples illustrate the use of the logical language  for expressing certain properties a of given evolution frame .    even for our rather simple shopping agent of example  [ exa : shop - agent ] some interesting properties can be formulated . for convenience ,",
    "we allow in formulas non - ground rules as atoms , which is a shorthand for the conjunction of all ground instances which is assumed to be finite . recall that we identify facts with literals .",
    "* there can never be two current dates : @xmath446 * if there is a shop on sale which is up , then a query is always performed : @xmath447    in order to see whether the mail agent in example  [ exa : mail - agent ] works properly , the first property of the previous example ( formula ( [ exa - unique - date ] ) ) , stating that there can never be two different current dates , applies with slight syntactic modifications , i.e. ,     * @xmath448    in addition , we may consider the following properties .",
    "* the type of a message can not change : @xmath449 * if a message is removed or saved ( at least once ) , then the message is never trashed until it is either deleted or saved : @xmath450    [ [ semantics . ] ] semantics .",
    "+ + + + + + + + + +    we now define formally the semantics of formulas in our language with respect to a given evolution frame . to this end , we introduce the following notation .    [ def - path ]",
    "given an event class @xmath18 , a _ path _ is an ( infinite ) sequence @xmath451 of knowledge states @xmath452 such that @xmath453 is a successor of @xmath454 , for every @xmath455 . by @xmath445",
    "we denote the knowledge state at stage @xmath214 in @xmath444 , i.e. , @xmath456 , for every @xmath455 .",
    "[ def - model - relation ]",
    "let @xmath9 be an evolution frame , let @xmath21 be a knowledge state over @xmath18 , and let @xmath444 be a path .",
    "the satisfaction relation @xmath457 , resp .",
    "@xmath458 , where @xmath39 is an @xmath459 formula , is recursively defined as follows :    1 .",
    "@xmath460 iff @xmath461 , for any atomic  formula @xmath64 ; 2 .   @xmath462 iff @xmath463 and @xmath464",
    "@xmath465 iff @xmath466 ; 4 .",
    "@xmath467 iff @xmath468 , for some path @xmath469 starting at @xmath21 ; 5 .",
    "[ def - model - relation - label:1 ] @xmath470 iff @xmath468 , for each path @xmath469 starting at @xmath21 ; 6 .",
    "[ def - model - relation - label : n ] @xmath471 iff @xmath472 ; 7 .",
    "@xmath473 iff @xmath474 for some @xmath475 and @xmath476 for all @xmath477 .    if @xmath457 ( resp",
    ". , @xmath478 ) holds , then knowledge state @xmath21 ( resp .",
    ", path @xmath444 ) is said to _ satisfy _",
    "formula @xmath39 _ in _ the evolution frame @xmath28 , or @xmath39 is _ true _ at state @xmath21 ( resp . , path @xmath444 )",
    "_ in _ the evolution frame @xmath28 .",
    "notice that any evolution frame @xmath28 induces an infinite transition graph which amounts to a standard kripke structure @xmath479 , where @xmath480 is the set of knowledge states , @xmath481 is the successor relation between knowledge states , and @xmath54 labels each state @xmath21 with @xmath482 , such that @xmath21 satisfies @xmath39 in @xmath28 iff @xmath483 ( where @xmath484 is defined in the usual way ) .    as easily seen , the operators @xmath485 and @xmath486 are expressed by @xmath487 and @xmath488 , respectively , where @xmath489 is any tautology ; thus , @xmath490 and @xmath491 .",
    "other common linear - time operators can be similarly expressed , e.g. , @xmath492 @xmath493 .",
    "let us reconsider our running examples .",
    "it is easily verified that the initial knowledge base @xmath4 of the shopping agent satisfies both formulas ( [ exa - unique - date ] ) and ( [ exa - try - query ] ) in the respective @xmath37 evolution frame @xmath494 , i.e. ,  @xmath495 and @xmath496 .    as for @xmath4 as in example  [ exa : mail - agent ] for the mail agent , this set satisfies formulas ( [ exa - unique - date - mail ] ) and ( [ exa - trashed ] ) in the respective @xmath37 evolution frame @xmath494 , i.e. ,  @xmath497 and @xmath498 , while it is easily seen that it does not satisfy formula ( [ exa - type - change ] ) , i.e. ,  @xmath499 .    in",
    "what follows , we are mainly interested in relations of the form @xmath500 , i.e. ,  whether some formula @xmath39 is satisfied by some initial knowledge base @xmath4 with respect to some given evolution frame @xmath28 . in particular , we analyze in section  [ sec : complexity ] the computational complexity of this problem .",
    "while syntactically different , it may happen that knowledge states @xmath21 and @xmath219 are semantically equivalent in an evolution frame , i.e. ,  @xmath21 and @xmath219 may have the same set of consequences for the current and all future events .",
    "we now consider how such equivalences can be exploited to filtrate a given evolution frame @xmath28 such that , under suitable conditions , we can decide @xmath501 in a finite structure extracted from the associated kripke structure @xmath502 .",
    "we start with the following notions of equivalence .",
    "let @xmath9 be an evolution frame and @xmath44 some integer .",
    "furthermore , let @xmath503 be knowledge states over @xmath18 . then ,    1 .",
    "@xmath21 and @xmath219 are _ @xmath504-equivalent in @xmath28 _ , denoted @xmath505 , if @xmath506 , for all events @xmath507 from @xmath18 , where @xmath508 ; 2 .",
    "@xmath21 and @xmath219 are _ strongly equivalent in @xmath28 _ , denoted @xmath509 , iff @xmath505 for every @xmath510 .",
    "we call 0-equivalent states also _ weakly equivalent_. the following result is obtained easily .",
    "[ thm : strong - equivalence ] let @xmath9 be an evolution frame and @xmath503 knowledge states over @xmath18 .",
    "then ,    1 .   [ thm : seq-1 ] @xmath511 implies that @xmath457 is equivalent to @xmath512 , for any formula @xmath39 ; 2 .",
    "[ thm : seq-2 ] @xmath513 implies that @xmath514 is equivalent to @xmath512 , for any state formula @xmath39 in which @xmath430 does not occur and the nesting depth with respect to @xmath428 and @xmath427 is at most  @xmath504 .",
    "we prove part  [ thm : seq-1 ] of the theorem by induction on the formula structure of the state formula @xmath39 .",
    "induction base .",
    "let @xmath39 be an atomic formula and assume @xmath511 , for knowledge states @xmath515 .",
    "obviously , it holds that @xmath516 .",
    "thus , it follows that @xmath457 iff @xmath517 and , hence , @xmath457 iff @xmath518 .    induction step .",
    "assume that part  [ thm : seq-1 ] of theorem  [ thm : strong - equivalence ] holds for formulas @xmath431 of depth at most @xmath519 , i.e. ,  @xmath511 implies @xmath520 iff @xmath521 .",
    "let @xmath39 be a formula of depth @xmath184 , and consider the following cases .",
    "* @xmath522 or @xmath523 .",
    "then , @xmath524 and @xmath525 are of depth @xmath519 and , by the induction hypothesis , it holds that @xmath457 iff @xmath526 and @xmath527 , respectively @xmath457 iff @xmath528 .",
    "thus , again @xmath457 iff @xmath518 follows .",
    "* @xmath529 or @xmath530.then , @xmath431 is an evolution formula of depth @xmath519 of the form @xmath531 or @xmath532 , where @xmath524 and @xmath525 have depth @xmath533 . since @xmath511",
    ", we have that @xmath534 for a path @xmath535 such that @xmath536 iff @xmath537 , where @xmath538 results from @xmath444 by replacing @xmath453 with any @xmath539 such that @xmath540 , for all @xmath475 . since @xmath541",
    ", for each @xmath542 , such an @xmath539 exists .",
    "thus , the induction hypothesis implies that @xmath534 iff @xmath543 .",
    "+ hence , @xmath544 iff @xmath545 follows . by symmetry of @xmath546 , we similarly conclude that @xmath547 iff @xmath548 .",
    "thus , for every state formula of depth @xmath184 , the statement in part  [ thm : seq-1 ] of theorem  [ thm : strong - equivalence ] holds .",
    "this concludes the induction and proves part  [ thm : seq-1 ] of our result .",
    "concerning part  [ thm : seq-2 ] of the theorem , observe that in order to prove a formula @xmath39 in which @xmath430 does not occur and the evolution quantifier depth is at most @xmath44 , initial path segments of length at most @xmath549 need to be considered .",
    "this follows from the fact that evolution subformulas of @xmath39 can only be of form @xmath550 .",
    "moreover , since every evolution formula must be preceded by a quantifier @xmath428 or @xmath427 , at most @xmath504 nested evolution formulas can occur in @xmath39 and every evolution formula of the above form , i.e. ,  @xmath550 , can be verified by considering the truth value of @xmath431 in successor states of the current state .",
    "hence , initial path segments of length at most @xmath549 do suffice . since for two knowledge states",
    "@xmath21 and @xmath219 such that @xmath513 , all knowledge states reachable in @xmath504 steps are equivalent , @xmath457 iff @xmath551 holds by the same inductive argument as in the proof of part  [ thm : seq-1 ] above .",
    "thus , part  [ thm : seq-2 ] of theorem  [ thm : strong - equivalence ] follows .",
    "@xmath241    by part  1 of theorem  [ thm : strong - equivalence ] , strong equivalence can be used to filtrate an evolution frame @xmath28 in the following way .",
    "for an equivalence relation @xmath266 over some set @xmath552 , and any @xmath553 , let @xmath554_e=\\{y\\mid x\\,e\\,y \\}$ ] be the equivalence class of @xmath555 and let @xmath556_e\\mid x\\in x\\}$ ] be the set of all equivalence classes .",
    "furthermore , @xmath266 is said to have a _",
    "finite index ( with respect to @xmath552 _ ) , if @xmath557 is finite .    then , any equivalence relation @xmath266 over some set @xmath558 of knowledge states of @xmath28 compatible with @xmath559 ( i.e. , such that @xmath560 implies @xmath561 , for all @xmath562 ) induces a kripke structure @xmath563 , where @xmath564_e\\,r_e\\,[s']_e$ ] iff @xmath565 and @xmath566_e)=l(s)$ ] , which is bisimilar to the kripke structure @xmath502 restricted to the knowledge states in @xmath58 .",
    "thus , for every knowledge state @xmath21 and formula @xmath39 , it holds that @xmath501 iff @xmath567_e\\models \\varphi$ ] , for any @xmath558 such that @xmath58 contains all descendants of @xmath21 .    in the following ,",
    "we consider two cases in which @xmath568 has finite index . prior to this",
    ", we introduce some convenient terminology and notation .    for any state @xmath569 , we denote by @xmath570 the set of knowledge states containing @xmath21 and all its descendants ( with respect to @xmath18 in @xmath28 , which will be clear from the context ) , and by @xmath571 the ordered tree with root @xmath21 where the children of each node @xmath219 are its successor states according to @xmath28 , and @xmath219 is labeled with @xmath572 .",
    "furthermore , for any @xmath558 , we define @xmath573 , and call @xmath58 _ successor closed _",
    ", if @xmath574 , i.e. , each successor of a knowledge state in @xmath58 belongs to @xmath58 . note that for any @xmath569",
    ", @xmath571 has node set @xmath570 , which is successor closed .      in the first case ,",
    "we consider @xmath546 itself as a relation compatible with strong equivalence .",
    "we obtain a finite index if , intuitively , the belief set @xmath22 associated with @xmath21 evolves differently only in a bounded context .",
    "this is made precise in the following result .",
    "[ thm : finite - index ] let @xmath9 be an evolution frame such that @xmath18 is finite , and let @xmath558 be a successor - closed set of knowledge states over @xmath18 .",
    "then , the following two conditions are equivalent :    1 .   [ thm : f - ind-1 ] @xmath546 has a finite index with respect to @xmath58 .",
    "[ thm : f - ind-2 ] @xmath575 has a finite index with respect to @xmath58 and there is some @xmath44 such that @xmath576 implies @xmath577 , for all @xmath562 .",
    "( 2 @xmath578 1 ) .",
    "consider , for any @xmath579 , the tree @xmath571 . at depth",
    "@xmath475 , there are @xmath580 different nodes , and thus up to depth @xmath504 in total @xmath581 @xmath582 many different nodes if @xmath583 , and @xmath549 many if @xmath584 .",
    "thus , if @xmath585 is the number of different equivalence classes of the relation @xmath575 with respect to @xmath58 , then there are less than @xmath586 many trees @xmath571 , where @xmath587 , which are different up to depth @xmath504 .",
    "thus , there are at most @xmath588 knowledge states @xmath589 , @xmath590 , @xmath591 , which are pairwise not strongly equivalent .",
    "consequently , @xmath559 has at most @xmath588 different equivalence classes with respect to @xmath58 , and thus @xmath559 has a finite index with respect to  @xmath58 .",
    "( 1 @xmath578 2 ) .",
    "suppose the relation @xmath559 has at most @xmath184 different equivalence classes with respect to @xmath58",
    ". then , there are at most @xmath184 knowledge states @xmath592 which are pairwise not strongly equivalent , i.e. , @xmath593 for all @xmath594 .",
    "since strongly equivalent states are also weakly equivalent , @xmath184 is thus also a finite upper bound for the equivalence classes of the relation @xmath575 with respect to @xmath58 .",
    "now , for @xmath595 such that @xmath596 , let @xmath597 be the smallest integer @xmath598 for @xmath453 and @xmath599 , @xmath600 , such that @xmath601 , but @xmath602 @xmath603 , for all sequences of events @xmath604 , @xmath605 .",
    "furthermore , let @xmath606 be the largest such @xmath598 over all @xmath453 and @xmath599 .",
    "note that @xmath504 is well defined and finite because of the finite index of @xmath559 with respect to s. it follows that if any two knowledge states @xmath607 are @xmath504-equivalent , then they are also strongly equivalent . indeed , suppose the contrary , i.e. ,  suppose @xmath576 , but @xmath608",
    ". then there exists a sequence of @xmath598 events , @xmath609 , such that @xmath610 , but @xmath611 holds for all sequences of events @xmath604 , @xmath612 . from the assumption that @xmath613 , it follows that @xmath614 and @xmath615 , for some @xmath595 such that @xmath616 .",
    "this implies that @xmath617 , which contradicts the maximality of @xmath504 .",
    "thus , @xmath576 implies @xmath511 , for all @xmath562 . @xmath241    the condition that @xmath618 has a finite index , i.e. , that only finitely many knowledge states @xmath21 have different belief sets , is satisfied by common belief operators if , e.g. , every knowledge state @xmath21 is compiled to a sequence @xmath26 of elps or a single elp over a finite set of function - free atoms ( in particular , if @xmath13 is a finite propositional alphabet ) .",
    "we remark that , as can be seen from the proof of theorem  [ thm : finite - index ] , condition 1 implies condition 2 also for arbitrary @xmath58 , while the converse does not hold in general for an @xmath58 which is not successor closed .    by taking natural properties of @xmath27 and @xmath619 into account",
    ", we can derive an alternative version of theorem  [ thm : finite - index ] . to this end , we introduce the following concepts .",
    "given a belief operator @xmath27 , we call update programs @xmath74 and @xmath620 _ @xmath504-equivalent _ , if @xmath621 , for all programs @xmath622 @xmath623",
    ". likewise , @xmath74 and @xmath620 are _ strongly equivalent _ , if they are @xmath504-equivalent for all @xmath510 .",
    "we say that @xmath27 is _",
    "@xmath504-local _ , if @xmath504-equivalence of @xmath74 and @xmath620 implies strong equivalence of @xmath74 and @xmath620 , for any update programs @xmath74 and @xmath620 .",
    "furthermore , @xmath27 is _ local _ , if @xmath27 is @xmath504-local for some @xmath44 .",
    "we obtain the following result .",
    "[ thm : finite - index - sequences ] let @xmath9 be an evolution frame such that @xmath18 is finite and @xmath575 has a finite index with respect to some successor closed @xmath558 . if @xmath27 is local and @xmath619 is incremental , then @xmath559 has a finite index with respect to @xmath58 .",
    "similar to the proof of theorem  [ thm : finite - index ] , consider , for any knowledge state @xmath579 , the tree @xmath571 .",
    "each node in @xmath219 has label @xmath624 , where @xmath625 and @xmath626 , @xmath627 , are the increments of @xmath619 corresponding to the successive events @xmath181 in @xmath628 .",
    "note that incrementality of @xmath36 guarantees that the length of @xmath629 is at most @xmath184 plus the length of @xmath26 . since @xmath27 is @xmath504-local , up to depth @xmath504",
    ", there are at most @xmath630 many different trees , where @xmath585 .",
    "thus , there are at most @xmath588 update programs @xmath631 , and , hence , knowledge states @xmath589 , which are pairwise not strongly equivalent",
    ". consequently , @xmath559 has at most @xmath588 different equivalence classes , from which the result follows .",
    "@xmath241    as an application of this result , we show that certain @xmath37 evolution frames have a finite index . to this end , we use the following lemmata .",
    "we say that a semantics @xmath27 for sequences of propositional elps satisfies _ strong noninterference _ , if it satisfies , for every propositional update sequence @xmath74 , the following condition : if , for every elp @xmath632 , and @xmath401 such that @xmath633 and no pair of rules @xmath634 exists with @xmath635 , where @xmath636 and @xmath637 , then @xmath638 , i.e. , the rules from @xmath401 can be moved from the last component to the penultimate one .",
    "recall that @xmath112 is the belief operator of the answer set semantics of update programs @xcite , as described in section  [ prel ] .",
    "[ lemm : nonint ] @xmath112 satisfies _ strong noninterference_.    the proof appeals to the rejection mechanism of the semantics .",
    "let @xmath632 , and @xmath401 be elps , such that the following condition ( @xmath639 ) holds : @xmath633 and no pair of rules @xmath634 exists with @xmath635 , where @xmath636 and @xmath637 .",
    "if @xmath640 , the lemma holds trivially .",
    "so let @xmath641 , but no rule @xmath642 exists such that @xmath635 .",
    "then , there must not be such a rule @xmath116 in @xmath414 or @xmath413 , otherwise condition ( @xmath639 ) is not fulfilled .",
    "hence , no rule of @xmath414 is rejected by @xmath64 . moreover , adding @xmath64 to @xmath414 can neither cause an inconsistency of @xmath414 , nor can @xmath64 be rejected by a rule from @xmath643 .",
    "thus , @xmath644 holds in this case .",
    "now let @xmath401 also contain some rule @xmath116 such that @xmath635 ( @xmath414 can not contain such rules without violating the condition ( @xmath639 ) ) .",
    "then , @xmath401 must contain all rules with heads @xmath65 and @xmath645 of @xmath413 , and no such rule may exist in @xmath414 , in order to fulfill ( @xmath639 ) .",
    "again , no rule of @xmath414 can be rejected by any rule of @xmath401 , and no rule of @xmath401 can be rejected by any rule from @xmath646 . additionally , adding @xmath401 to @xmath414 makes",
    "@xmath414 inconsistent iff @xmath413 is inconsistent . as a consequence , also in this case , @xmath647 .",
    "since there are no other possibilities left , the lemma is shown .",
    "@xmath241    in our next result",
    ", we require part  [ lemm : bele-1 ] of the following lemma , which in turn will be relevant in section  [ sec : comp - equi ] .",
    "[ lemm : bele ] let @xmath74 and @xmath648 be sequences of elps . then ,    1 .",
    "[ lemm : bele-1 ] @xmath649 if @xmath650 , and 2 .",
    "[ lemm : bele-2 ] given that @xmath74 and @xmath648 are propositional sequences over possibly infinite alphabets , @xmath650 if @xmath649 .    as for part",
    "[ lemm : bele-1 ] , if @xmath651 then @xmath652 is immediate from the definition of @xmath112 .    to show part  [ lemm : bele-2 ] , it suffices to prove that , given elps @xmath414 and @xmath413 over a set @xmath13 of atoms , @xmath653 suppose @xmath654 , and assume first that @xmath13 is finite . without loss of generality ,",
    "suppose that @xmath655 but @xmath656 .",
    "this means that the constraint @xmath657 where @xmath658 are all the atoms from @xmath13 missing in @xmath58 , is in @xmath659 but not in @xmath660 .",
    "however , this contradicts the hypothesis that @xmath661 .",
    "this proves the result for finite @xmath13 . for infinite @xmath13 , it is possible to focus on the finite set of atoms occurring in @xmath662 , since , as well - known for the answer set semantics , @xmath663 for each @xmath664 and @xmath665 if @xmath2 is an elp on @xmath666 .",
    "@xmath241    now we can show the following result .",
    "[ theo : bele ] @xmath112 is local . in particular , @xmath667-equivalence of update programs @xmath74 and @xmath620 implies @xmath504-equivalence of @xmath74 and @xmath620 , for all @xmath668 .",
    "we show the result for propositional update sequences @xmath74 and @xmath620 by induction on @xmath668 .",
    "since the evaluation of @xmath112 for non - ground update sequences amounts to the evaluation of propositional sequences , the result for the non - ground case follows easily .",
    "induction base .",
    "the base case @xmath669 is trivial .",
    "induction step .",
    "assume that @xmath667-equivalence of @xmath74 and @xmath620 implies that they are @xmath670-equivalent , @xmath671 .",
    "suppose further , that @xmath74 and @xmath620 are @xmath667-equivalent , but not @xmath504-equivalent . then , there exist programs @xmath672 , where @xmath673 , such that @xmath674 , i.e. ,  according to part  [ lemm : bele-1 ] of lemma  [ lemm : bele ] , there exists a ( consistent ) answer set @xmath675 , such that @xmath676 .",
    "we can remove every rule @xmath64 from @xmath677 and @xmath678 such that either @xmath679 , or @xmath64 is a member of @xmath680 let the resulting programs be denoted by @xmath681 and @xmath682 , respectively .",
    "note that still @xmath683 and @xmath684 must hold , since these rules can neither be generating for @xmath58 , i.e. ,  fire with respect to @xmath58 , nor reject other rules .",
    "observe also that @xmath685 can not contain a pair of rules with conflicting heads .",
    "otherwise , contradicting our assumption , @xmath58 would be inconsistent since both rules were generating for @xmath58 .",
    "now we construct the program @xmath686 . from the strong noninterference property ( lemma  [ lemm : nonint ] )",
    ", it follows that @xmath687 @xmath688 . since , for every update sequence @xmath648 , @xmath689 , it follows @xmath687 @xmath690 @xmath691 @xmath692 .",
    "this means that @xmath74 and @xmath620 are not @xmath693-equivalent ; however , this contradicts the induction hypothesis that @xmath74 and @xmath620 are @xmath694-equivalent .",
    "hence , @xmath74 and @xmath620 are @xmath504-equivalent .",
    "@xmath241    furthermore , in any @xmath37 evolution frame @xmath695 , the update policy @xmath326 is , informally , given by a logic program such that @xmath326 returns a set of update actions from a finite set @xmath696 of update actions , which are compiled to rules from a finite set @xmath697 of rules , provided @xmath18 is finite .",
    "consequently , @xmath618 has finite index with respect to any set @xmath58 of knowledge states @xmath21 which coincide on @xmath216 , i.e.  the initial knowledge base @xmath4 .",
    "furthermore , @xmath329 is incremental .",
    "thus , from the proof of theorem  [ thm : finite - index - sequences ] , we obtain :    let @xmath695 be an @xmath37 evolution frame such that @xmath18 is finite , and let @xmath558 be a successor - closed set of knowledge states such that @xmath698 is finite .",
    "then , @xmath546 has a finite index with respect to @xmath58 .",
    "moreover , @xmath699 , where @xmath700 .    in  @xcite , an analogous result has been shown for @xmath171 , i.e. ,  @xmath667-equivalence of dynamic update programs @xmath74 and @xmath620 implies their strong equivalence , and , thus , @xmath171 is local .",
    "since for update policies over the lups or lups@xmath38 language and their respective compilations , the same as for their @xmath37 counterparts holds , we also get the following result :      next , we discuss a refinement of strong equivalence , called _ canonical equivalence _ , which also yields a finite index , provided that the evolution frame possesses , in some sense , only a `` bounded history '' . in contradistinction to the previous case , canonical equivalence uses semantical properties which allow for a syntactic simplification of update programs .",
    "we need the following notions .",
    "[ def : contraction ] [ property - remove ] let @xmath27 be a belief operator . then , @xmath27 is called _ contracting _ iff the following conditions hold : ( i ) @xmath706 , for all update programs",
    "@xmath74 and @xmath620 ; and ( ii ) @xmath707 , for any sequence @xmath41 and any rule @xmath708 such that @xmath709 .",
    "an evolution frame @xmath9 is contracting iff @xmath27 is contracting",
    ".    examples of contracting belief operators are @xmath112 and the operator @xmath171 ( see section  [ prel ] ) .    by repeatedly removing duplicate rules and empty programs from any sequence @xmath41 of elps , we eventually obtain a non - reducible sequence @xmath710 , which is called the _ canonical form _ of @xmath74 .",
    "observe that @xmath711 always holds , and that @xmath712 is uniquely determined , i.e. , the reduction process is church - rosser .",
    "we get the following property :    [ thm : regular - bel ] for any contracting belief operator @xmath27 and any update sequence @xmath74 , we have that @xmath74 and @xmath712 are strongly equivalent .    we must show that @xmath74 and @xmath712 are @xmath504-equivalent , for every @xmath44 . the proof is by induction on @xmath44",
    ".    induction base .",
    "we show that @xmath74 and @xmath713 are @xmath714-equivalent .",
    "the proof is by induction on the reduction process , i.e. ,  on the number of required removals of rules or empty programs from @xmath74 in order to obtain @xmath713 .",
    "for the induction base , suppose @xmath715 .",
    "then , @xmath74 and @xmath713 are trivially @xmath714-equivalent . for the induction step ,",
    "assume that @xmath716 , for all sequences of programs @xmath648 such that the canonical form @xmath717 can be constructed using @xmath519 removals of rules and empty programs .",
    "let @xmath74 be a sequence of programs such that the construction of @xmath713 requires @xmath184 removing steps , and let @xmath620 denote any sequence of programs obtained from @xmath74 after @xmath519 removals .",
    "then , @xmath718 , by induction hypothesis .",
    "furthermore , @xmath719 follows trivially from @xmath10 being contracting .",
    "thus , @xmath720 . we have shown that for any sequence @xmath74 of programs , if @xmath27 is contracting , then @xmath74 and @xmath713 are @xmath714-equivalent .    induction step .",
    "suppose @xmath721 , and let @xmath722 and @xmath723 .",
    "furthermore , let @xmath717 and @xmath724 denote the canonical forms of @xmath648 and @xmath725 , respectively . we show that @xmath726 .",
    "suppose @xmath713 is obtained from @xmath74 using @xmath184 reduction steps and @xmath724 is obtained reducing @xmath725 in @xmath302 steps .",
    "we construct @xmath717 as follows .",
    "we first perform @xmath184 reduction steps on the subsequence @xmath74 of @xmath648 , resulting in the sequence @xmath725",
    ". then we apply @xmath302 reduction steps on @xmath725 .",
    "since the reduction process is church - rosser , no further reductions can be applied , which proves @xmath726 . from the induction base",
    ", it follows that @xmath648 and @xmath717 are weakly equivalent , which proves @xmath504-equivalence of @xmath74 and @xmath713 .",
    "@xmath241      in this section , we study the relationship between an evolution frame and its _ canonized form _ :    given an evolution frame @xmath28 , we call knowledge states @xmath727 _ canonically equivalent _ , denoted @xmath728 , iff they are strongly equivalent in the canonized evolution frame @xmath729 , which results from @xmath28 by replacing @xmath26 with its canonical form @xmath730 ( i.e. ,  @xmath731 ) .    immediately , we note the following properties .",
    "[ thm : entailment - equiv ] let @xmath28 be a contracting evolution frame .",
    "then ,    1 .   [ thm : ent - eq-1 ] @xmath732 iff @xmath733 , for any knowledge state @xmath21 and any formula  @xmath39 .",
    "[ thm : ent - eq-2 ] @xmath734 is compatible with @xmath559 , for any @xmath558 , i.e. ,   @xmath735 implies @xmath509 , for every @xmath562 .    in order to show part  [ thm : ent - eq-1 ]",
    ", we consider the kripke structures @xmath502 and @xmath736 , corresponding to a contracting evolution frame @xmath28 and its canonized evolution frame , respectively . since , for every @xmath737 , it holds that @xmath738 = @xmath739 = @xmath740 , equal states have equal labels in @xmath502 and @xmath736 . hence , @xmath502 and @xmath736 coincide . as a consequence , @xmath741 iff @xmath742 , for every @xmath587 , and hence @xmath743 iff @xmath744 , for every @xmath745 .    as for the proof of part  [ thm : ent - eq-2 ] , assume @xmath735 , for @xmath607 and some @xmath558 .",
    "then , @xmath746 .",
    "moreover , @xmath747 holds , as well as @xmath748 , which implies @xmath749 , and the same is true for all corresponding successor states of @xmath21 and @xmath219 due to the fact that they are canonically equivalent .",
    "thus , @xmath735 implies @xmath509 , for every @xmath562 .",
    "@xmath241    as a result , we may use @xmath750 for filtration of @xmath28 , based on the following concept .",
    "let @xmath9 be an evolution frame and @xmath751 an integer .",
    "we say that @xmath28 is _ @xmath588-bounded _ if there are functions @xmath752 ,",
    "@xmath3 , and @xmath753 such that    1 .",
    "@xmath752 is a function mapping knowledge states into sets of events such that , for each @xmath754 , @xmath755 , where @xmath756 , and 2 .",
    "@xmath757 and @xmath758 , for each knowledge state @xmath759 , each event @xmath193 , and each @xmath197 .",
    "this means that in a @xmath588-bounded evolution frame , the compilation @xmath760 only depends on the belief set of the predecessor @xmath219 of @xmath21 and the last @xmath761 events in @xmath21 ( including the latest event ) . in particular",
    ", @xmath762 means that only the latest event needs to be considered .",
    "[ thm : c - bound ] let @xmath9 be an evolution frame where @xmath18 is finite , and let @xmath763 be successor closed and such that @xmath764 is finite . if ( i ) @xmath28 is contracting , ( ii ) there is some finite set @xmath765 such that @xmath760 contains only rules from @xmath697 , for every @xmath579 , and ( iii ) @xmath28 is @xmath588-bounded , for some @xmath751 , then @xmath734 has a finite index with respect to @xmath58 .",
    "we prove that @xmath734 has finite index with respect to @xmath58 by means of theorem  [ thm : finite - index ] .",
    "that is , we must show that @xmath766 has finite index with respect to @xmath58 and that there exists a @xmath44 , such that for any two knowledge states @xmath767 , @xmath768 implies @xmath769 .",
    "we first show that the relation @xmath766 , i.e. ,  weak canonical equivalence , has finite index with respect to @xmath58 .    for any knowledge state @xmath587 , @xmath770 yields an update sequence @xmath74 of at most @xmath771 programs , i.e. ,   @xmath91 and @xmath772 holds . to see this ,",
    "suppose otherwise that @xmath773 .",
    "since @xmath770 is canonical ( and thus _ contracting under empty updates _ ) , none of the programs @xmath12 , @xmath774 , is empty .",
    "furthermore , since @xmath26 only contains rules from @xmath697 , this also holds for @xmath770 .",
    "hence , there must be at least one rule @xmath775 , which occurs in at least two programs @xmath776 , @xmath777 , and @xmath778 .",
    "this , however , contradicts the fact that @xmath770 is canonical ( and thus _ contracting under rule repetition _ ) .",
    "hence , our assumption does not hold , which proves @xmath772 .",
    "moreover , @xmath779 holds for the canonical compilation @xmath74 by the same argument : if @xmath780 , then there must be at least one rule @xmath775 , such that @xmath781 for at least two programs @xmath776 , @xmath782 ; this contradicts that @xmath770 is contracting .    as a consequence",
    ", we can roughly estimate the number of different canonical compilations @xmath770 by @xmath783 ( note that @xmath784 for @xmath785 ) .",
    "this upper bound can be explained as follows .",
    "a canonical compilation need not contain all rules of @xmath697 , hence we add a special fact for signaling that , given an ordered sequence of rules from @xmath697 and the special fact , a canonical compilation consists of all rules in the sequence up to the special fact .",
    "there are @xmath786 permutations of such sequences , which is an over - estimate of the number of canonical compilations consisting of different ordered sequences of rules . for each such sequence , there are @xmath787 possibilities for the rules to be grouped into sequences of at most @xmath788 programs , respecting their order .",
    "to see this , observe that if we fixed a grouping into a sequence of programs for all but the last rule , then for the last rule there are two possibilities : it can either be added to the last program of the sequence , or we add a new program , consisting of the last rule only , to the sequence . applying this argument recursively and observing that for the first rule",
    "there is only one possibility ",
    "it has to go into the first program of the sequence  the given bound follows .",
    "hence , at most @xmath298 different canonical compilations @xmath770 can be built for all @xmath587 .",
    "thus , at most @xmath298 different belief sets @xmath22 exist among all @xmath587 , proving that @xmath766 has finite index with respect to @xmath58 .",
    "secondly , we show by induction on @xmath789 that for any two knowledge states @xmath790 canonical @xmath588-equivalence @xmath791 implies strong canonical equivalence @xmath769 , which proves our result in virtue of theorem  [ thm : finite - index ] .",
    "more precisely , we show for all @xmath789 , that in the canonized evolution frame @xmath729 , @xmath588-equivalence of knowledge states @xmath790 implies their @xmath504-equivalence in @xmath729 .",
    "induction base ( @xmath792 ) .",
    "canonical @xmath588-equivalence of knowledge states @xmath790 trivially implies @xmath791 .",
    "induction step ( @xmath793 ) .",
    "assume that , for any two knowledge states @xmath790 and some @xmath794 , @xmath791 implies @xmath795 .",
    "we show that under this assumption @xmath796 follows .",
    "let @xmath797 , @xmath798 , @xmath799 , and @xmath800 .",
    "since @xmath794 , the sets @xmath801 and @xmath802 are equal and @xmath803 holds by induction hypothesis .",
    "hence , the following equations hold : @xmath804 consequently , the equality @xmath805 holds , which implies that @xmath806 , and thus @xmath807 .",
    "this proves canonical @xmath504-equivalence .",
    "this proves that @xmath791 implies @xmath769 , for any two knowledge states @xmath790 . since we have also shown that @xmath766 has finite index with respect to @xmath58 , it follows from theorem  [ thm : finite - index ] that @xmath734 has finite index with respect to @xmath58 .",
    "@xmath241    we remark that the existence of @xmath697 is trivial if we have a function - free ( finite ) alphabet , and , as common in many logic programming semantics , repetition of literals in rule bodies has no effect , and thus the set of nonequivalent rules is finite .",
    "a similar remark applies to the initial knowledge bases @xmath216 .",
    "in this section , we investigate the computational complexity of our evolution framework . to this end , in what follows we assume that the alphabet @xmath13 of the evolution frames under consideration is finite and propositional .",
    "thus , we only deal with finite propositional ( sequences of ) programs which are the result of the state compilation @xmath232 .",
    "first , we study the computational complexity of the following reasoning task :    tempevo : : :    given an evolution frame    @xmath9 ,    a knowledge state @xmath21 over @xmath18 ,    and some formula @xmath39 , does    @xmath743 hold ?    in order to obtain decidability results",
    ", we assume that the constituents of the evolution frame @xmath28 in tempevo are all computable .",
    "more specifically , we assume that    * @xmath18 , @xmath15 , and @xmath10 are given as computable functions deciding @xmath193 , @xmath808 , and @xmath809 , and * @xmath23 and @xmath17 are given as computable functions .    nonetheless , even under these stipulations , it is easy to see that tempevo  is undecidable .",
    "indeed , the compilation function may efficiently simulate turing machine computations , such that the classical halting problem can be encoded easily in the above reasoning problem .",
    "the results of section  [ sec : equivalence ] provide a basis for characterizing some decidable cases .",
    "we consider here the following class of propositional evolution frames .",
    "[ def : regular ] let @xmath810 be a propositional evolution frame ( i.e. ,  @xmath13 is propositional ) .",
    "then , @xmath28 is called _ regular _ if the following three conditions hold :    1 .",
    "[ def : regular-1 ] the membership tests @xmath178 and @xmath811 are feasible in  ( e.g. ,  located in the polynomial hierarchy ) , and the functions @xmath23 and @xmath17 are computable in polynomial space ( the latter with polynomial size output ) .",
    "[ def : regular-2 ] rules in compilations @xmath26 and events @xmath266 have size polynomial in the representation size of @xmath28 , denoted by @xmath812 ( i.e. , repetition of the same literal in a rule is bounded ) , and events have size at most polynomial in @xmath812 .",
    "[ def : regular-3 ] @xmath27 is fully characterized by rules of length polynomial in @xmath812 , i.e. ,  there is some constant @xmath588 such that @xmath813 iff @xmath814 for all rules @xmath64 of length @xmath815 implies @xmath816 , for all update sequences @xmath74 and @xmath620 .",
    "conditions  [ def : regular-1 ] and  [ def : regular-3 ] apply to the approaches in  @xcite , and condition  [ def : regular-2 ] is reasonable to impose ; note that none of these semantics is sensible to repetitions of literals in rule bodies .",
    "however , we could imagine semantics where , similar as in linear logic , literals are `` consumed '' in the inference process , and that repetition of literals alludes to available resources .",
    "before we state our first complexity result , let us briefly recall some well - known complexity results for the above - mentioned approaches .",
    "deciding whether a literal @xmath817 , for a literal @xmath54 and a finite , propositional elp @xmath2 is -complete .",
    "the complexity does not increase for the update approaches in  @xcite , i.e. ,  deciding @xmath818 is -complete for @xmath819 , where @xmath74 is a finite , propositional sequence of ( at most two in case of plp ) elps .",
    "however , the complexity for abductive theory updates  @xcite , when considering all possible selection functions , increases one level in the polynomial hierarchy : deciding @xmath820 is @xmath821-complete .",
    "the following lemma will be used several times in the sequel .    [",
    "lemm : model - check ] given a regular evolution frame @xmath822 , a knowledge state @xmath823 , and a formula @xmath39 , suppose that @xmath546 has finite index , @xmath588 , with respect to @xmath824 .",
    "then , there exists a deterministic turing machine @xmath825 which checks @xmath743 in space polynomial in @xmath826 , where @xmath827 is the nesting depth of evolution quantifiers in @xmath39 , @xmath828 is the maximum space required to store @xmath829 representing a class of @xmath830 , and @xmath831 denotes the size of formula @xmath39 .",
    "we first show that for evaluating evolution quantifiers @xmath832 or @xmath833 , we may consider finite paths of length @xmath588 in @xmath28 .",
    "note that every path of length greater than @xmath588 in @xmath28 must contain at least one pair of strongly equivalent knowledge states .",
    "while this is trivial if @xmath431 is of form @xmath531 , consider the case where @xmath431 is of form @xmath834 .",
    "if a path @xmath444 starting at @xmath21 of arbitrary length exists such that @xmath835 , then there exists also a path @xmath469 starting at @xmath21 and of length at most @xmath588 , such that @xmath836 . to see this , note that @xmath835 implies that @xmath834 is satisfied in a finite path @xmath837 which is an initial segment of @xmath444",
    ". we can repeatedly shorten @xmath837 to obtain @xmath469 as follows .",
    "for any pair of strongly equivalent knowledge states @xmath838 and @xmath839 such that @xmath709 , consider the sequence @xmath840 of knowledge states between them .",
    "if @xmath525 is satisfied by none of them , we can cut @xmath841 and replace each state @xmath842 , @xmath843 ,   by an equivalent successor of @xmath844 , @xmath845 such that we obtain a ( finite ) path in @xmath28 .",
    "otherwise , i.e. ,  if @xmath846 for some @xmath847 , we can cut @xmath837 immediately after the first such @xmath848 .",
    "it is easily verified that the resulting path @xmath469 has length at most @xmath588 and still satisfies @xmath834 .",
    "now consider the case @xmath849 .",
    "obviously , if @xmath834 is satisfied by all finite paths of length @xmath588 starting at @xmath21 , it will also be satisfied by all paths of arbitrary length . to see the converse direction , assume there is an infinite path @xmath444 starting at @xmath21 such that @xmath850 .",
    "we show that then a finite path @xmath469 of length at most @xmath588 starting at @xmath21 exists such that @xmath851 .",
    "observe that either ( i ) @xmath525 is false in every @xmath445 , @xmath475 , or ( ii ) there exists some @xmath852 such that @xmath853 , and @xmath854 , for every @xmath855 . in case ( i )",
    ", we can , as above , transform the initial segment @xmath856 of @xmath444 by repeatedly removing sequences between pairs of strongly equivalent knowledge states and eventually obtain a path @xmath469 as claimed . in case ( ii ) , we start with @xmath857 and again repeatedly remove sequences between pairs of strongly equivalent knowledge states to obtain a path @xmath469 of length at most @xmath588 starting at @xmath21 such that @xmath858 . hence , if all infinite paths @xmath444 starting at @xmath21 satisfy @xmath834 , then so do all paths of length @xmath588 starting at @xmath21 .",
    "this proves that if there are at most @xmath588 strongly inequivalent descendants of @xmath21 , it suffices to consider paths of length @xmath588 to prove whether @xmath501 .",
    "now an algorithm for deciding @xmath859 is as follows .",
    "starting at @xmath21 , it recursively checks the satisfiability of @xmath39 by checking the satisfiability of its subformulas and evaluating boolean connectives . for any subformula @xmath860 of form @xmath832 ( resp . , @xmath833 ) , guess nondeterministically , step by step , a path @xmath444 in @xmath28 starting at @xmath21 in order to witness @xmath861 ( resp .",
    ", refute @xmath861 and exploit @xmath862 ) and check this by iterating through @xmath444 for ( at most ) @xmath588 steps , using a counter . the counter occupies space @xmath863 in a standard binary coding",
    "per nesting level , the algorithm requires space for one counter and for one descendant of @xmath21 , which is bounded by @xmath828 .",
    "furthermore , due to the fact that @xmath28 is regular , @xmath864 can be checked , for all @xmath865 and atomic @xmath39 , in space polynomial in @xmath21 , @xmath28 , and @xmath831 . hence at each level , the algorithm runs in space @xmath866 which is polynomial in @xmath867 .    by applying savitch s theorem in the formulation for turing machines with oracle access ( cf .",
    "theorem 2.27 in @xcite ) , we can show by induction on the evolution quantifier depth @xmath868 of a formula @xmath39 , that deciding @xmath501 is feasible on a deterministic turing machine @xmath825 using space at most @xmath869 .",
    "savitch s theorem states that if language @xmath52 can be decided by a nondeterministic turing machine with oracle set @xmath128 in space @xmath870 , then it can be decided by a deterministic turing machine with oracle set @xmath128 in space @xmath871 , providing @xmath872 .",
    "furthermore , @xmath870 must be space constructible ( which is the case in our application of the lemma ) .    induction base ( @xmath873 ) .",
    "since the above algorithm operates deterministically in space @xmath874 , the existence of @xmath825 is obvious .",
    "induction step ( @xmath875 ) .",
    "assume that formulas of evolution quantifier depth @xmath876 can be decided in deterministic space @xmath877 on some turing machine @xmath878 , and let @xmath39 have evolution quantifier depth @xmath827 . if @xmath39 is of form @xmath832 ( resp . , @xmath833 )",
    ", then the above algorithm amounts to a nondeterministic oracle turing machine @xmath878 using work space bounded by @xmath866 and calling an oracle for deciding subformulas of form @xmath879 ( resp . , @xmath880 ) . by savitch s theorem",
    ", there is a deterministic turing machine @xmath881 using work space at most @xmath882 which is equivalent to @xmath878 and uses the same oracle set . by the induction hypothesis ,",
    "the oracle queries can be deterministically decided in space @xmath877 .",
    "hence , from @xmath881 we can construct a deterministic turing machine @xmath825 deciding @xmath501 which operates in work space @xmath883 .",
    "this @xmath825 is easily extended to decide all @xmath39 of evolution quantifier depth @xmath827 within the same space bound .",
    "this concludes the induction and the proof of the lemma .",
    "we then obtain the following complexity results .",
    "[ thm : complexity ] deciding @xmath743 , given a regular propositional evolution frame @xmath884 , a knowledge state @xmath21 , and a formula @xmath39 is    1 .",
    "[ thm : complexity:1 ] -complete , if @xmath27 is @xmath504-local for some @xmath504 which is polynomial in @xmath812 , and @xmath619 is incremental ; 2 .",
    "[ thm : complexity:2 ] -complete , if @xmath28 is @xmath588-bounded , where @xmath588 is polynomial in @xmath812 , contracting , and functions @xmath23 and @xmath17 are computable in space polynomial in the size of @xmath36 .",
    "[ thm : complexity:3 ] -complete , if @xmath28 is as in [ thm : complexity:2 ] and , moreover , all rules in the compilations @xmath629 of descendants @xmath219 of @xmath21 are from a set @xmath697 of size polynomial in @xmath812 .",
    "we first prove the upper bounds of these results . recall that we assume a finite propositional alphabet @xmath13 .",
    "hence , by condition  [ def : regular-3 ] of a regular evolution frame @xmath28 , there are only finitely many different belief sets @xmath22 . indeed , the number of rules of length @xmath54 is bounded by @xmath885 , and hence there are @xmath886 ( single exponential in @xmath28 ) many rules , where @xmath887 is some constant , which are relevant for characterizing belief sets , and there are @xmath888 , i.e. ,  double exponentially many , different belief sets @xmath253 .",
    "this implies that @xmath889 where @xmath890 for any set @xmath891 .",
    "observe also that @xmath18 is finite and @xmath892 , for some constant @xmath893 .",
    "this follows from the finiteness of @xmath13 and the fact that rules in events , as well as events themselves , have size at most polynomial in @xmath812 .",
    "in particular , there exist @xmath894 many different rules in events , for some constant @xmath895 , and thus there are @xmath896 many different events in @xmath18 , for some constants @xmath897 and @xmath893 . in the following ,",
    "let @xmath898 .",
    "_ membership , part  [ thm : complexity:1]_. in order to prove an upper bound for part  [ thm : complexity:1 ] of the theorem , since @xmath27 is @xmath504-local , @xmath36 is incremental , and @xmath899 has finite index with respect to @xmath58 , which is successor closed , theorem  [ thm : finite - index - sequences ] can be applied , establishing that @xmath559 has finite index with respect to @xmath58 .",
    "recall from the proof of theorem  [ thm : finite - index - sequences ] that an upper bound for @xmath900 is given by @xmath901 , where @xmath504 is polynomial in @xmath812 , i.e. ,  @xmath902 for some constant @xmath903 .",
    "furthermore , @xmath904 , for constant @xmath893 .",
    "hence , we obtain that there are at most @xmath905 i.e. ,  double exponentially many knowledge states @xmath906 which are pairwise not strongly equivalent , for some constant @xmath598 ; in other words , @xmath907 .",
    "furthermore , we can store a representative , @xmath219 , of every class in @xmath830 by storing @xmath4 and at most double exponentially many events .",
    "since every event can be stored in polynomial space , overall double exponential space is sufficient to store @xmath219 . by application of lemma  [ lemm : model - check ]",
    ", @xmath743 can be verified in space polynomial in @xmath908 .",
    "we have shown above that @xmath828 satisfies @xmath909 , for some constant @xmath910 .",
    "furthermore , we have shown that the index of @xmath546 with respect to @xmath58 , @xmath588 , satisfies @xmath911 .",
    "hence , @xmath912 , for a constant @xmath913 .",
    "consequently , @xmath743 can be verified in .    _ membership , part  [ thm : complexity:2]_. an upper bound for part  [ thm : complexity:2 ] of the theorem can be obtained as follows . the fact that @xmath899 has finite index with respect to @xmath58 implies that @xmath766 has finite index with respect to @xmath58 , too . and , as we have shown in the proof of theorem  [ thm : c - bound ] , canonical @xmath588-equivalence implies strong canonical equivalence in a @xmath588-bounded , contracting evolution frame .",
    "thus , @xmath734 has finite index with respect to @xmath58 by theorem  [ thm : finite - index ] .",
    "furthermore , according to theorem  [ thm : entailment - equiv ] , @xmath734 is compatible with @xmath546 .",
    "hence , we may represent @xmath572 , @xmath829 , by the canonical compilation @xmath914 , together with the last @xmath588 events in @xmath219 , where @xmath588 is polynomial in @xmath812 .",
    "the polynomial size bound for rules in @xmath629 also holds for @xmath914 and thus , since @xmath28 is contracting , @xmath915 is bounded by the number of different rules , which is @xmath916 , for some constant @xmath598 . recalling the bound of @xmath917 for the number of different canonical compilations from the proof of theorem  [ thm : c - bound ] , we obtain that there are @xmath918 i.e. ,  double exponential many different canonical compilations , where @xmath913 and @xmath919 are suitable constants",
    ". multiplied with the number of possibilities for the last @xmath588 events , @xmath920 , which is single exponential , as @xmath921 for some constant @xmath922 , we obtain again that there are at most double exponentially many knowledge states @xmath829 which are pairwise not strongly equivalent .",
    "however , since @xmath923 , for some constant @xmath924 , we can represent every strongly inequivalent descendant @xmath925 of @xmath21 , using @xmath914 together with the last @xmath588 events in single exponential space .",
    "thus ,  membership follows from lemma  [ lemm : model - check ] .    _ membership , part  [ thm : complexity:3]_. next , we prove  membership for part  [ thm : complexity:3 ] of the theorem .",
    "the additional condition on @xmath926 that all rules are from a set @xmath697 of size polynomial in @xmath812 guarantees that @xmath915 is polynomial in the size of @xmath28 , for any @xmath829 . using the same estimate as above",
    ", we thus obtain at most single exponentially many different canonical compilations , for states @xmath219 .",
    "multiplied with the exponential number of possibilities for the last @xmath588 events , we now obtain at most single exponentially many strongly inequivalent descendants of @xmath21 . for storing them , we use again @xmath914 together with the last @xmath588 events , requiring the space of @xmath915 plus @xmath588 times the space of an event .",
    "since @xmath915 , @xmath588 , and the size of an event are all polynomial in the size of @xmath28 , overall polynomial space is needed for representation , establishing  membership in virtue of lemma  [ lemm : model - check ] .    _",
    "hardness_. we show the lower bounds by encoding suitable turing machine computations , using padding techniques , into particular evolution frames . in order to obtain a lower bound for part  [ thm : complexity:1 ] ,",
    "consider a regular evolution frame @xmath28 , where @xmath927 , hence , @xmath928 , and @xmath253 , defined below , is semantically given by a set of classical interpretations , where @xmath48 is classical negation and repetition of literals in rule bodies is immaterial .",
    "then , there exist @xmath929 classical interpretations yielding @xmath930 different belief sets @xmath931 .",
    "we assume an enumeration of interpretations @xmath932 , such that @xmath933 does not contain @xmath934 .",
    "moreover , we consider a single event @xmath935 .",
    "let @xmath936 .",
    "the number of events , @xmath214 , encountered for reaching a successor state @xmath219 of @xmath937 in @xmath938 steps serves as an index of its belief set , i.e. ,  @xmath939 . for @xmath940 , @xmath941",
    "is obtained using interpretations @xmath933 and @xmath942 as models , such that the @xmath943-th bit , @xmath944 , of index @xmath214 is @xmath667 .",
    "thus , the belief sets @xmath945 are pairwise distinct and under classical model - based semantics , @xmath946 holds for @xmath947 .    in state @xmath948",
    ", we simulate in polynomial time the behavior of an  turing machine @xmath825 on some fixed input @xmath125 . to this end",
    ", we use an action @xmath5 and an update policy @xmath23 , such that @xmath949 for @xmath950 , @xmath951 , if @xmath825 accepts @xmath125 , and @xmath952 otherwise . for all other knowledge states , i.e. ,  if @xmath953 , @xmath952 .",
    "the realization assignment @xmath954 is incremental and adds an empty program , @xmath955 , if @xmath956 , and the program @xmath957 in case of @xmath958 .",
    "the semantics @xmath959 is as follows . if @xmath960 , then @xmath961 , where @xmath962 . otherwise , if @xmath963 , then @xmath964 , where @xmath128 is a fixed belief set containing @xmath934 , and , if @xmath965 , then @xmath966 , where @xmath967 is defined as @xmath941 for @xmath940 , i.e. ,  @xmath968 . as easy to see , there are at most @xmath969 states @xmath970 which are not @xmath714-equivalent , and @xmath667-equivalence of two states @xmath21 and @xmath219 implies strong equivalence of @xmath21 and @xmath219 . to see",
    "the latter , observe that @xmath971 iff @xmath972 .",
    "thus , @xmath27 is local .",
    "furthermore , it is easily verified that the functions @xmath23 and @xmath973 can be computed in polynomial time .",
    "the same is true for deciding @xmath809 , @xmath974 , where we proceed as follows .",
    "we first compute @xmath975 .",
    "if @xmath976 , then we scan the bits @xmath977 of @xmath943 , and for every bit @xmath978 such that @xmath979 , we compute its index , @xmath980 , in binary ( which occupies at most @xmath184 bits ) , and extend its representation to length @xmath184 by adding leading zeros if necessary .",
    "the resulting binary string is regarded as representation of the interpretation @xmath981 , where the bits encode the truth values of the atoms @xmath982 and @xmath934 is false .",
    "hence , each model @xmath983 of @xmath74 can be computed in polynomial time ; checking whether @xmath984 is easy .",
    "thus , deciding @xmath985 is polynomial if @xmath986 . otherwise , i.e. ,  if @xmath987 , depending on @xmath988 , @xmath989 ( resp . ,",
    "@xmath990 ) can be similarly decided in polynomial time .",
    "summarizing , @xmath967 contains @xmath934 iff @xmath825 accepts @xmath125 iff @xmath991 .",
    "note that the dual formula @xmath992 can be used if every @xmath945 contains @xmath934 ( and @xmath967 contains @xmath934 iff @xmath825 accepts @xmath125 ) .",
    "furthermore , the membership tests @xmath993 and @xmath813 , as well as the functions @xmath23 and @xmath17 , are computable in @xmath994 ( in fact , even in polynomial time ) , thus deciding tempevo  in @xmath28 is -hard .",
    "let us now prove a lower bound for part  [ thm : complexity:2 ] of the theorem .",
    "again , we consider a regular evolution frame @xmath28 over a finite alphabet @xmath995 .",
    "moreover , we consider the single event @xmath996 .",
    "let @xmath36 be an incremental compilation function that compiles a knowledge state @xmath21 , @xmath997 , into a sequence of programs , @xmath998 , consisting of @xmath183 programs each consisting of a single positive , non - tautological rule , such that all rules are pairwise distinct and do not contain @xmath934 .",
    "furthermore , let the semantics @xmath27 be given by @xmath999 containing all rules which are true in the classical models of @xmath1000 .",
    "note that under these assumptions , all states of length less than @xmath1001 have mutually different belief sets , and @xmath1002 .    in state @xmath21 , @xmath1003",
    ", we simulate in polynomial time the behavior of an  turing machine @xmath825 on input @xmath125 . to this end , @xmath1004 returns @xmath958 , where @xmath5 is an action which causes @xmath934 to be included in the belief set @xmath1005 iff @xmath825 accepts @xmath125 , otherwise @xmath1006 . for",
    "all knowledge states @xmath219 , such that @xmath1007 , @xmath1008 .",
    "thus , @xmath825 accepts @xmath125 iff @xmath991 .",
    "since @xmath28 is contracting and @xmath714-bounded , and since the membership tests @xmath993 and @xmath1009 , as well as the functions @xmath23 and @xmath17 are computable in @xmath994 , it follows that deciding tempevo  in @xmath28 is -hard .",
    "finally , we give a proof for the lower bound of part  [ thm : complexity:3 ] of the theorem , by encoding the problem of evaluating a quantified boolean formula ( qbf ) , which is well known to be -hard , in the @xmath37 framework : let @xmath1010 be a qbf and let @xmath1011 , where @xmath1012 if @xmath1013 and @xmath1014 if @xmath1015 , @xmath1016 , be its corresponding state formula . consider the following evolution frame @xmath494 , where @xmath1017 , the initial knowledge base @xmath1018 , @xmath1019 , and the update policy @xmath326 is given by the following actions : @xmath1020 intuitively , a counter for events is implemented using atoms @xmath1021 , @xmath1016 , and each event , which may be @xmath714 or @xmath667 , assigns a truth value to the variable encoded by literals over atoms @xmath1022 , @xmath1016 .",
    "hence , @xmath326 creates a truth assignment in @xmath184 steps .",
    "thus , it is easily verified that @xmath1023 iff @xmath431 is true .",
    "note that after @xmath184 steps , i.e. ,  for all knowledge states @xmath1024 , @xmath1025 is always empty .",
    "this implies that @xmath494 is @xmath184-bounded .",
    "moreover , @xmath23 is factual , i.e. ,  it consists only of facts ( of update commands ) , yielding a contracting compilation function @xmath329 which uses only facts over @xmath13 . thus , and since the membership tests @xmath993 and @xmath1026 , as well as the functions @xmath23 and @xmath17 are computable in @xmath994 , it follows that tempevo  in part  [ thm : complexity:3 ] is -hard .",
    "@xmath241    while , for the propositional epi  framework , @xmath22 depends in general on all events in @xmath21 , it is possible to restrict @xmath1027 to the commands @xmath332 and @xmath333 , by efficient coding techniques which store relevant history information in @xmath22 , such that the compilation in @xmath1028 depends only on @xmath230 and the last event @xmath227 in @xmath21 , as shown in @xcite .",
    "furthermore , the policy @xmath326 is sensible only to polynomially many rules in events , and @xmath1028 contains only rules from a fixed set @xmath697 of rules , whose size is polynomial in the representation size of @xmath28 .",
    "thus , by part  [ thm : complexity:3 ] of theorem  [ thm : complexity ] , we get the following result .",
    "[ thm : epi : complexity ] let @xmath695 be a propositional @xmath37 evolution frame , let @xmath21 be a knowledge state , and let @xmath39 be a formula . then , deciding @xmath743 is -complete .",
    "the encoding of the qbf evaluation problem in the proof of part  [ thm : complexity:3 ] of theorem  [ thm : complexity ] has further interesting properties .",
    "the initial knowledge base used , @xmath4 , is stratified and the resulting update policy is also _ stratified _ and _ factual _ as defined in @xcite .",
    "this means that @xmath1029 can be decided in polynomial time for the given evolution frame . since , moreover",
    ", the membership test @xmath178 , as well as the functions @xmath23 and @xmath17 are computable in polynomial time , we get another corollary . to this end",
    ", we introduce the following notion .",
    "[ def : strong - reg ] let @xmath810 be a propositional evolution frame .",
    "@xmath28 is called _ strongly regular _ if the membership tests @xmath178 and @xmath1030 are feasible in polynomial time , as well as @xmath23 and @xmath17 are computable in polynomial time .",
    "now we can state the following result .",
    "[ thm : complexity2:3 ] deciding @xmath743 , given a strongly regular propositional evolution frame @xmath884 , a knowledge state @xmath21 , and a formula @xmath39 , is -complete , if @xmath28 is @xmath588-bounded , where @xmath588 is polynomial in @xmath812 , contracting , and all rules in the compilations @xmath629 of descendants @xmath219 of @xmath21 are from a set @xmath697 of size polynomial in @xmath812 .",
    "thus , concerning evolution frames according to part  [ thm : complexity:3 ] of theorem  [ thm : complexity ] , we stay within the same complexity class if we suppose strong regularity . for strongly regular evolution frames according to parts  [ thm : complexity:1 ] and  [ thm : complexity:2 ] of the theorem",
    ", we can establish the following result .",
    "[ thm : complexity2 ] given a strongly regular propositional evolution frame , @xmath1031 , a knowledge state @xmath21 , and a formula @xmath39 , deciding @xmath743 is    1 .",
    "[ thm : complexity2:1 ] -complete , if @xmath27 is @xmath504-local for some @xmath504 which is polynomial in @xmath812 , and @xmath619 is incremental ; 2 .   [ thm : complexity2:2 ] -complete , if @xmath28 is @xmath588-bounded , where @xmath588 is polynomial in @xmath812 , and contracting .",
    "we first prove  membership for part  [ thm : complexity2:1 ] of the theorem .",
    "we do so by constructing a kripke structure @xmath1032 in double exponential time in @xmath812 , such that @xmath1033 iff @xmath40 , and @xmath1034 are of size at most double exponential in the size of @xmath28 .",
    "this proves  membership by a well known result from model checking  @xcite , stating that there is an algorithm for determining whether @xmath39 is true in state @xmath21 of @xmath1032 , running in time @xmath1035 , where @xmath1036 denotes the evolution quantifier nesting depth of @xmath39 .",
    "the kripke structure @xmath1032 results from the kripke structure @xmath1037 , where @xmath1038 , by restricting the labeling @xmath54 to atomic subformulas of @xmath39 .",
    "let @xmath1039 denote the set of all atomic subformulas in @xmath39 .",
    "then , @xmath1040 , @xmath1041 , and @xmath1042 is the labeling function assigning to every @xmath1043 a label @xmath1044 .",
    "it is well known that @xmath1045 iff @xmath1046 , which in turn holds iff @xmath40 .",
    "recall from the proof of lemma  [ lemm : model - check ] that in order to prove @xmath743 , paths need to be considered only up to length @xmath588 , where @xmath1047 is the maximum number of strongly inequivalent descendants of @xmath21 .",
    "moreover , we can use one knowledge state as a representative for every equivalence class in @xmath266 , thus @xmath588 strongly inequivalent knowledge states are sufficient . recall also from the proof of part  [ thm : complexity:1 ] of theorem  [ thm : complexity ] that for the given evolution frame @xmath28 ,",
    "@xmath588 is double exponential in @xmath812 , and that there are at most single exponentially many different events , i.e. ,  @xmath1048 .",
    "we construct @xmath1049 using a branch and bound algorithm that proceeds as follows .",
    "the algorithm maintains a set @xmath1050 of open knowledge states , as well as the sets @xmath1051 , @xmath1052 , and @xmath1042 of @xmath1049 .",
    "initially , @xmath1053 , @xmath1054 , @xmath1055 , and @xmath1056 . for every knowledge state @xmath1057 , the algorithm removes @xmath21 from @xmath1050 and generates all possible ( immediate ) successor states @xmath219 of @xmath21 . for every such @xmath219",
    ", it is checked whether it is strongly inequivalent to every @xmath579 .",
    "if so , @xmath219 is added to @xmath1050 and @xmath58 , the tuple @xmath1058 is added to @xmath481 , and @xmath1059 is computed . otherwise ,",
    "if @xmath219 is strongly equivalent to a knowledge sate @xmath1060 , then the tuple @xmath1061 is added to @xmath1052 .",
    "the algorithm proceeds until @xmath1050 is empty .",
    "since there are at most @xmath588 strongly inequivalent descendants of @xmath21 , the algorithm puts into @xmath1050 at most @xmath588 , i.e. ,  double exponentially many knowledge states , each of which has size at most double exponential in @xmath812 .",
    "furthermore , since there exist at most single exponentially many different events , in every expansion of a node in @xmath1050 , at most exponentially many successors are generated , each in polynomial time .",
    "since @xmath27 is polynomial and @xmath504-local , we can detect @xmath1062 in single exponential time by comparing the trees @xmath571 and @xmath1063 up to depth @xmath504 , respectively . on levels 0 , 1 , ",
    ", @xmath504 , @xmath571 and @xmath1063 contain @xmath1064 many nodes each , where @xmath913 is some constant . for each pair",
    "@xmath1065 and @xmath1066 of corresponding nodes in @xmath571 and @xmath1063 , we must check whether @xmath1067 holds .",
    "condition  [ def : regular-3 ] of a regular evolution frame @xmath28 implies that single exponentially many tests @xmath1068 iff @xmath1069 ( for all rules @xmath64 of length polynomial in @xmath812 ) are sufficient .",
    "strong regularity implies that deciding @xmath1070 and @xmath1071 are polynomial .",
    "hence , deciding @xmath1067 is feasible in single exponential time in @xmath812 .    summing up , testing for ( at most ) double exponentially",
    "many knowledge states @xmath21 times single exponentially many successor states @xmath219 whether @xmath511 can be done in @xmath1072 time , for constants @xmath1073 and @xmath598 .",
    "thus , the overall algorithm proceeds in double exponential time , i.e. ,  @xmath1049 can be computed in in double exponential time .",
    "this proves  membership of @xmath1074 .",
    "hardness follows from a suitable encoding of  turing machines @xmath825 . to this end , a similar construction as in the hardness proof of part  [ thm : complexity:1 ] of theorem  [ thm : complexity ] can be used , where the update policy @xmath254 simulates a  turing machine rather than a  turing machine ; note that the components of @xmath28 there have polynomial time complexity .",
    "we prove part  [ thm : complexity2:2 ] of the theorem by showing that the lower bound does not decrease when demanding strong regularity . to this end",
    ", we encode the computations of an  turing machine , @xmath825 , into a strongly regular evolution frame @xmath28 , such that @xmath28 is @xmath588-bounded , where @xmath588 is polynomial in @xmath812 , and contracting .",
    "assume that @xmath825 has binary tape alphabet @xmath1075 and runs in space @xmath1076 , where @xmath598 is polynomial in @xmath812 .",
    "let us consider the following strongly regular evolution frame @xmath28 , where @xmath1077 , hence , @xmath1078 .",
    "then , there exist @xmath1079 classical models , which we use to represent the configuration of @xmath825 as follows .",
    "atoms @xmath626 , @xmath1080 , and @xmath1081 encode the state of @xmath825 .",
    "literals over atoms @xmath256 and",
    "@xmath12 , @xmath1082 , are used to represent an index of @xmath825 s tape in binary format .",
    "we use a `` disjunctive '' semantics as follows . observe that we could use conjunctions of literals over atoms @xmath626 and @xmath12 to encode the current state of @xmath825 and the position of @xmath825 s head , and conjunctions of literals over atoms @xmath256 to encode the fact that the tape cell at the encoded index contains @xmath667 . by building the disjunction of a set of such conjunctions",
    ", we get a formula in disjunctive normal form ( dnf ) describing by its models the current configuration of @xmath825 .",
    "we can make use of this observation by stipulating that we use rules to describe anti - models , i.e. ,  interpretations which are not models of the current knowledge base @xmath4 . by defining @xmath27 , taking the negation of the conjunction of all rules",
    ", we get a dnf , describing the models of @xmath4 , as intended , and @xmath1083 can be computed in polynomial time ( by checking whether @xmath64 is entailed by every disjunct ) , as required .",
    "furthermore , the semantics for sequences of programs @xmath1084 is defined by the semantics of their union @xmath1085 .",
    "we simulate in polynomial time the behavior of the  turing machine @xmath825 on input @xmath125 as follows . without loss of generality , we assume that the leftmost cell of @xmath825 s tape ( the cell at index @xmath714 ) is always @xmath667 , that @xmath825 initially is in state @xmath1086 and its head is in position  @xmath714 , and that @xmath825 uses the first steps to write @xmath125 to the tape ( without accepting ) . hence , the initial configuration can be represented by the single disjunct : @xmath1087 thus , the initial knowledge base @xmath4 consists of the single constraint : @xmath1088 we use a single event @xmath996 as the tick of the clock and let @xmath254 implement @xmath825 s transition function .",
    "that is , @xmath254 is a set @xmath52 of actions @xmath189 and @xmath1089 , where @xmath64 and @xmath116are constraints over @xmath13 .",
    "furthermore , we use @xmath1090 ( see section  [ sec : frame ] ) for adding ( resp . , removing ) the constraints to ( resp . , from ) the knowledge base @xmath4 , which amounts to the addition ( resp . ,",
    "removal ) of corresponding disjuncts to ( resp . , from ) the dnf representing the current configuration of @xmath825 .",
    "since for every transition of @xmath825 at most @xmath1091 rules need to be inserted and at most @xmath1092 rules need to be removed , @xmath23 and @xmath1090 are polynomial in the representation size of the belief set .",
    "moreover , @xmath825 accepts @xmath125 iff @xmath1093 .",
    "since @xmath28 is contracting and @xmath714-bounded , and since the membership tests @xmath993 and @xmath1009 , as well as the functions @xmath23 and @xmath17 are computable in time polynomial in the size of @xmath28 , deciding tempevo  in @xmath28 is -hard . @xmath241    .complexity results for regular and strongly regular evolution frames . [ cols=\"<,>,<,>,<\",options=\"header \" , ]     the complexity results obtained so far are summarized in table  [ table : complexity ] .",
    "further results can be derived by imposing additional meaningful constraints on the problem instances .",
    "we remark that if we restrict the semantics for @xmath27 to be defined in terms of a unique model ( e.g. ,  the extended well - founded semantics for elps @xcite ) , then in case of a @xmath588-bounded and contracting regular evolution frame @xmath28 , the complexity of deciding tempevodrops from  to .",
    "this can be argued by the observation that , in case of a unique model semantics , we have only single exponentially many different belief sets , and a knowledge state @xmath21 can be represented by storing the ( unique ) model of @xmath232 and the last @xmath588 events , which is possible in polynomial space . on the other hand , already for @xmath714-bounded , contracting , strongly regular evolution frames with polynomial - size rule set @xmath697 ,",
    "the problem tempevo  is -hard , as can be shown by adapting the construction in the proof of part  [ thm : complexity:3 ] in theorem  [ thm : complexity:3 ] to , e.g. , evolution frames based on stratified or well - founded semantics for elps @xcite .",
    "we conclude our complexity analysis with results concerning weak , strong , and @xmath504-equivalence of two finite propositional update programs under @xmath112 and @xmath171 , respectively .",
    "we can state our first result , concerning the complexity of deciding weak equivalence under @xmath112 , as a consequence of lemma  [ lemm : bele ] ( cf .",
    "section  [ sec : loc - bel ] ) .",
    "[ theo : weak ] deciding whether two given finite propositional update programs @xmath74 and @xmath648 are weakly equivalent under @xmath1094 , i.e. , satisfying @xmath649 , is -complete .",
    "membership follows from lemma  [ lemm : bele ] : the problem of checking @xmath649 for finite propositional update programs @xmath74 and @xmath648 is equivalent to the task of checking whether they yield the same answer sets , i.e. ,  whether @xmath650 , which is in .    for the lower",
    "bound , suppose that , without loss of generality , @xmath74 has no answer set . then checking whether @xmath649 , for an update sequence @xmath648 , amounts to the task of testing whether @xmath648 has no answer set , which is -complete ( cf .",
    "@xmath241    for deciding @xmath667-equivalence , the following lemma is useful :    [ lemma : one - equiv ] let @xmath74 and @xmath648 be finite propositional update programs over possibly infinite alphabets . then",
    ", @xmath74 and @xmath648 are not 1-equivalent under @xmath112 iff there is an elp @xmath2 and a set @xmath58 such that ( i ) @xmath1095 but @xmath1096 , or vice versa , ( ii )  @xmath1097 is at most the number of different literals in @xmath1098 plus @xmath667 , and ( iii )  @xmath1099 .",
    "( note that @xmath2 has polynomial size in the size of @xmath74 and  @xmath648 . )    intuitively , this holds since any answer set @xmath58 of @xmath1100 can be generated by at most @xmath1097 many rules .",
    "furthermore , if @xmath58 is not an answer set of @xmath1101 , by unfolding rules in @xmath2 we may disregard for an @xmath58 all but at most one literal which does not occur in @xmath74 or @xmath648 . to generate a violation of @xmath58 in @xmath1101 , an extra rule might be needed ; this means that a @xmath2 with latexmath:[$|p|\\leq     _ if part .",
    "_ let @xmath74 and @xmath648 be finite propositional update programs and @xmath58 a set such that conditions ( i ) , ( ii ) , and ( iii ) hold .",
    "then , @xmath74 and @xmath648 are not @xmath667-equivalent , since , by lemma  [ lemm : bele ] , @xmath1103 follows from ( i ) .",
    "_ only - if part .",
    "_ let @xmath74 and @xmath648 be finite propositional update programs which are not @xmath667-equivalent , i.e. ,  there exists an elp @xmath2 such that @xmath1103 .",
    "moreover , again by application of lemma  [ lemm : bele ] , there exists a set @xmath58 such that , without loss of generality , @xmath1095 but @xmath1096 , i.e. ,  condition ( i ) holds .    by means of @xmath2 and @xmath58",
    ", we construct a program @xmath1104 and a set @xmath1105 such that conditions  ( i ) , ( ii ) , and ( iii ) hold for @xmath1104 and @xmath1105 : consider the program @xmath1106 .",
    "then , according to the update answer set semantics , @xmath58 can be generated from the rules in @xmath1107 by means of constructing its least fixed - point .",
    "moreover , this still holds for the following simplification @xmath1108 of @xmath1109 .",
    "first , all rules which are not applied when constructing @xmath58 can be removed .",
    "second , among the remaining rules , we delete all rules with equal heads , except one of them , namely the rule which is applied first in the least fixed - point construction of @xmath58 .",
    "( if several rules with equal head are applied at this level of the fixed - point construction , then we keep an arbitrary of them . )",
    "thus , @xmath1108 consists of @xmath504 positive rules , @xmath1110 , with @xmath504 different heads , @xmath1111 , which are exactly those literals derived by @xmath1108 .",
    "hence , @xmath1112 .",
    "we will create the program @xmath1104 from @xmath1108 by employing unfolding .",
    "this means that some of the literals @xmath51 , @xmath1113 , will be eliminated by replacing every rule @xmath1114 such that @xmath1115 by a rule @xmath116 such that @xmath1116 and @xmath1117 , where @xmath1118 is the ( single ) rule having @xmath1119 .",
    "consider the program @xmath1120 . since @xmath58 is not in @xmath1121",
    ", it has a least fixed - point different from @xmath58 .",
    "there are two scenarios :    1 .",
    "some literal @xmath1122 can not be derived in @xmath1123 .",
    "let @xmath1124 occurs in @xmath1125 , and construct the program @xmath1104 from @xmath1108 by unfolding , eliminating all literals @xmath1126 .",
    "2 .   all literals @xmath1122 can be derived , as well as some literal @xmath1127 is derived by a rule @xmath1128 .",
    "let @xmath1129 , and build @xmath1104 from @xmath1108 by adding the rule @xmath1130 and eliminating all literals @xmath1131 from the resulting program by unfolding .",
    "then , in both cases , @xmath1105 is not a least fixed - point of @xmath1132 @xmath1133 , while it is a least fixed - point of @xmath1134 .",
    "this proves condition  ( i ) .",
    "furthermore , @xmath1135 is at most the number of different literals in @xmath1098 plus @xmath667 , and @xmath1112 implies @xmath1136 .",
    "hence , conditions ( ii ) and ( iii ) hold .",
    "@xmath241    deciding strong equivalence ( or @xmath504-equivalence , for a given @xmath44 ) of two given finite propositional update programs @xmath74 and @xmath648 over possibly infinite alphabets , is @xmath47-complete under @xmath112 .    for @xmath1137",
    ", the result is given by theorem  [ theo : weak ] .",
    "since , according to theorem  [ theo : bele ] , @xmath667-equivalence implies @xmath504-equivalence for all @xmath1138 under @xmath112 , it remains to show @xmath47-completeness for @xmath669 .",
    "membership follows from lemma  [ lemma : one - equiv ] : for deciding whether @xmath74 and @xmath648 are not @xmath667-equivalent , we guess a set @xmath58 and a program @xmath2 according to conditions ( ii ) and ( iii ) of lemma  [ lemma : one - equiv ]",
    ". then we check in time polynomial in the size of @xmath1098 whether @xmath74 and @xmath648 are not @xmath667-equivalent .",
    "hence , this problem is in @xmath1139 .",
    "consequently , checking whether @xmath74 and @xmath648 are @xmath667-equivalent is in @xmath47 .    for showing @xmath47-hardness , for @xmath669",
    ", we give a reduction from the problem of tautology checking .",
    "consider a formula @xmath1140 over atoms @xmath1141 , and two programs @xmath2 and @xmath401 over an alphabet @xmath1142 as follows : @xmath1143 q & = & \\{\\neg a_i { \\leftarrow}{{\\it not}\\,}a_i , \\ a_i",
    "{ \\leftarrow}{{\\it not}\\,}\\neg a_i \\mid i=1,\\ldots , n\\ } \\cup \\\\ & &   \\{t { \\leftarrow}\\ \\}.\\end{aligned}\\ ] ] clearly , @xmath2 and @xmath401 can be constructed in polynomial time .",
    "we show that @xmath395 is a tautology if and only if @xmath2 and @xmath401 are @xmath667-step equivalent .    _ if part .",
    "_ suppose @xmath395 is not a tautology .",
    "then , there is a truth assignment @xmath257 to @xmath1144 @xmath1145 such that @xmath395 is false , i.e. ,  @xmath1146 is false for @xmath1147 .",
    "let @xmath481 be the program consisting of facts @xmath1148 , for every atom @xmath256 , @xmath1149 , which is true in @xmath257 .",
    "it is easily verified that the set @xmath1150 is the only update answer set of @xmath1151 , while @xmath1152 is the only update answer set of @xmath1153 .",
    "thus , @xmath2 and @xmath401 are not @xmath667-equivalent .",
    "_ only - if part .",
    "_ suppose @xmath395 is a tautology . towards a contradiction ,",
    "assume that @xmath2 and @xmath401 are not @xmath667-equivalent .",
    "then , by virtue of lemma  [ lemm : bele ] , there is a ( consistent ) program @xmath481 and some set @xmath58 such that either @xmath1154 and @xmath1155 , or @xmath1156 and @xmath1157 holds .",
    "observe that , for any set @xmath58 and every program @xmath481 , the sets @xmath1158 and @xmath1159 do not differ with respect to rules in @xmath1160 .",
    "furthermore , @xmath1109 and @xmath1161 do not differ with respect to to rules in @xmath1162 .",
    "we first show that @xmath1163 holds , for @xmath1164 . indeed ,",
    "since @xmath58 is consistent , @xmath1165 can not hold for any @xmath1016 . on the other hand ,",
    "suppose that neither @xmath1166 , nor @xmath1167 holds for some @xmath1016 .",
    "then , @xmath58 entails the rules @xmath1168 and @xmath1169 of @xmath1160 , which also can not be rejected ( since neither @xmath1166 nor @xmath1167 ) .",
    "thus , both @xmath1170 and @xmath1171 are in @xmath1172 as well as in @xmath1173 .",
    "however , this contradicts the assumption that @xmath58 is a consistent answer set of either @xmath1151 or @xmath1153 .",
    "this proves @xmath1174 , for @xmath236 .",
    "assume first that @xmath1175 .",
    "then , every rule @xmath64 of @xmath2 such that @xmath1176 and @xmath1177 are in @xmath1158 , and @xmath1178 is in @xmath1159 . since @xmath58 is an answer set of either @xmath1151 or @xmath1153 , it is either the least set of literals closed under the rules of @xmath1179 or under the rules of @xmath1180 .",
    "since @xmath2 and @xmath401 coincide on all rules with head different from @xmath1181 , it follows that @xmath58 must be the least set of literals closed under the rules of @xmath414 as well as of @xmath1182 .",
    "thus , @xmath58 is an answer set of both @xmath1151 and @xmath1153 , which is a contradiction .",
    "hence , @xmath1183 holds .",
    "it is now easy to show that @xmath1184 must hold . indeed , if @xmath1185 , then , since @xmath395 is a tautology , @xmath1186 for some rule @xmath1187 such that @xmath1176 .",
    "moreover , @xmath1188 since @xmath1183 , which in turn means @xmath1184 .",
    "if , on the other hand , @xmath58 is an answer set of @xmath1153 , then @xmath1189 holds , and thus @xmath1190 must hold .",
    "now suppose that @xmath1154 . since @xmath395 is a tautology , @xmath1186 for some rule @xmath1187 such that @xmath1176 .",
    "since @xmath1183 , it follows that @xmath1191 .",
    "since @xmath1192 is in @xmath401 , and @xmath2 and @xmath401 coincide on all rules except those with head @xmath1181 , it follows that @xmath58 is the least set of literals closed under the rules of @xmath1193 .",
    "thus , @xmath1157 , which is a contradiction . on the other hand ,",
    "suppose @xmath1155 first .",
    "since @xmath1194 , we have @xmath1195 , and thus clearly @xmath58 must be the least set of literals closed under the rules of @xmath1196 .",
    "hence , @xmath1154 , which is again a contradiction .    hence , a program @xmath481 and a set @xmath58 as hypothesized can not exist .",
    "this shows that @xmath2 and @xmath401 are 1-equivalent .",
    "we have shown that for every @xmath1197 , deciding @xmath504-equivalence of finite propositional update sequences @xmath74 and @xmath648 is @xmath47-complete under the @xmath112 semantics , which proves our result .",
    "@xmath241    in  @xcite it is shown that two dynamic logic programs , @xmath74 and @xmath648 , are not @xmath504-equivalent , for @xmath1198 , iff there exists a glp @xmath2 such that @xmath1199 .",
    "this result , together with a corresponding version of lemma  [ lemm : bele ] and complexity results for dynamic logic programming from  @xcite , can be used to obtain the following analogous result .    deciding weak , strong , or @xmath504-equivalence , for a given @xmath44 , of two given finite propositional dynamic logic programs @xmath74 and @xmath648 , is @xmath47-complete under @xmath171 .",
    "our work on evolving nonmonotonic knowledge bases is related to several works in the literature on different issues .",
    "clearly , our formalization of reasoning from evolution frames is closely related to model checking of ctl formulas  @xcite , and so are our complexity results .",
    "the major difference is , however , that in kripke structures the models are given implicitly by its labels .",
    "nevertheless , since the semantics of evolution frames can be captured by kripke structures , it is suggestive to transform reasoning problems on them into model checking problems .",
    "however , in current model checking systems ( e.g. ,  the _ symbolic model verifier _ ( smv )  @xcite , or its new version nusmv  @xcite ) , state transitions must be specified in a polynomial - time language , but descriptions of these kripke structures would require exponential space even for evolution frames with  complexity ( e.g. , @xmath37 evolution frames ) .",
    "thus , extensions of model checking systems would be needed for fruitful usability .",
    "our filtration results for identifying finitary characterizations , which are based on various notions of equivalence between knowledge states , are somewhat related to results in  @xcite , obtained independently of our work and of each other . while we were concerned with the equivalence of sequences of elps ( including the case of single elps )",
    ", one can define two logic programs , @xmath414 and @xmath413 , to be equivalent ( i.e. ,  weakly equivalent in our terminology ) , if they yield the same answer sets .",
    "they are called strongly equivalent , similar in spirit to @xmath667-equivalence in our terminology , iff , for any logic program @xmath2 , programs @xmath1200 and @xmath1201 have the same answer sets .",
    "et al . _",
    "@xcite investigated efficient ( i.e. ,  linear - time computable ) encodings of _ nested logic programs _ , a proper generalization of disjunctive logic programs , into qbfs . in accordance with our results , they found that deciding whether two propositional nested logic programs are strongly equivalent is -complete . in  @xcite",
    ", the same result has been shown , but merely for disjunctive logic programs .",
    "lobo _ et al .",
    "_  introduced the @xmath317 @xcite language for policies , which contain _ event - condition - action rules _ , serving for modeling reactive behavior on observations from an environment . while similar in spirit , their model is different , and @xcite focuses on detecting action conflicts ( which , in our framework , is not an issue ) . in  @xcite ,",
    "reasoning tasks are considered which center around actions .",
    "further related research is on planning , where certain reachability problems are -complete ( cf .",
    "similar results were obtained in @xcite for related agent design problems . however , in all these works , the problems considered are ad hoc , and no reasoning language is considered .",
    "fagin _ et al . _",
    "@xcite important work on knowledge in multi - agent systems addresses evolving knowledge , but mainly at an axiomatic level .",
    "@xcite logic for reasoning about multi - agent systems embeds @xmath1202 and has belief , desire and intention modalities .",
    "the underlying model is very broad , and aims at agent communication and cooperation .",
    "it remains to see how our particular framework fits into these approaches .",
    "leite @xcite introduces in his ph.d .  thesis a language , kabul , which is inspired by our @xmath37 language , but goes beyond it , since this language foresees also possible updates to the update policy .",
    "that is , the function @xmath16 may change over time , depending on external events .",
    "this is not modeled by our evolution frames , in which @xmath16 is the same at every instance of time .",
    "however , a generalization towards a time - dependent update policy  and possibly other time - dependent components of an evolution frame  seems not difficult to accomplish .",
    "furthermore , leite s work does not include a formal language for expressing properties of evolving knowledge bases like ours , and also does not address complexity issues of the framework .      in this paper",
    ", we have presented a general framework for modeling knowledge bases built over ( extended ) logic programs , for which we have then defined a formal language , , for stating and evaluating properties of a nonmonotonic knowledge base which evolves over time .",
    "as we have shown , this framework , which results from an abstraction of previous work on update languages for nonmonotonic logic programs @xcite , can be used to abstractly model several approaches for updating logic programs in the literature .",
    "knowledge about properties of the framework may thus be helpful to infer properties of these and other update approaches , and in particular about their computational properties . in this line",
    ", we have studied semantic properties of the framework , and we have identified several classes of evolution frames for which reasoning about evolving knowledge bases in the language  is decidable . in the course of this , we have established that reasoning about propositional evolving knowledge bases maintained by @xmath37 update policies under the answer set semantics @xcite is -complete .",
    "while we have tackled several issues in this paper , other issues remain for further work .",
    "one issue is to identify further meaningful semantic constraints on evolution frames or their components , and investigate the semantic and computational properties of the resultant evolution frames .",
    "for example , iterativity of the compilation @xmath1203 , i.e. , where the events are incorporated one at a time , or properties of the belief operator @xmath10 , would be interesting to explore .",
    "another interesting topic , and actually related to this , is finding fragments of lower comlexity and , in particular , of polynomial - time complexity .",
    "furthermore , the investigation of special event classes , e.g. ,  _ _ event patterns _ _ , which exhibit regularities in sequences of events , is an interesting issue .",
    "j.  alferes , j.  leite , l.  pereira , h.  przymusinska , and t.  przymusinski . .",
    "in a.  cohn , l.  schubert , and s.  shapiro , editors , _ proc .",
    "sixth international conference on principles of knowledge representation and reasoning @xmath175kr98@xmath176 _ , pages 98109 .",
    "morgan kaufmann , 1998 .",
    "t.  eiter , m.  fink , g.  sabbatini , and h.  tompits . on properties of update sequences based on causal rejection .",
    ", 2(6):721777 , 2002 .",
    "longer version available as technical report , infsys 1843 - 00 - 05 , on updates of logic programs : semantics and properties , tu wien ."
  ],
  "abstract_text": [
    "<S> recently , several approaches to updating knowledge bases modeled as extended logic programs have been introduced , ranging from basic methods to incorporate ( sequences of ) sets of rules into a logic program , to more elaborate methods which use an update policy for specifying how updates must be incorporated . in this paper </S>",
    "<S> , we introduce a framework for reasoning about evolving knowledge bases , which are represented as extended logic programs and maintained by an update policy . </S>",
    "<S> we first describe a formal model which captures various update approaches , and we define a logical language for expressing properties of evolving knowledge bases . </S>",
    "<S> we then investigate semantical and computational properties of our framework , where we focus on properties of knowledge states with respect to the canonical reasoning task of whether a given formula holds on a given evolving knowledge base . </S>",
    "<S> in particular , we present finitary characterizations of the evolution for certain classes of framework instances , which can be exploited for obtaining decidability results . in more detail , we characterize the complexity of reasoning for some meaningful classes of evolving knowledge bases , ranging from polynomial to double exponential space complexity .    </S>",
    "<S> * keywords : * logic program updates , nonmonotonic knowledge bases , knowledge base evolution , temporal reasoning , answer sets , program equivalence , computational complexity </S>"
  ]
}