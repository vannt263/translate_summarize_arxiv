{
  "article_text": [
    "estimating the sortedness of a numerical sequence has found applications in , e.g. , sorting algorithms , database management and webpage ranking ( such as pagerank  @xcite ) .",
    "for example , sorting algorithms can take advantage of knowing the sortedness of a sequence so as to sort efficiently  @xcite . in relational database , many operations are best performed when the relations are sorted or nearly sorted over the relevant attributes  @xcite . maintaining",
    "an estimate on the sortedness of the relations can help determining whether a given relation is sufficiently nearly - sorted or a sorting operation on the relation ( which is expensive ) is needed .",
    "one common measurement of sortedness of a sequence is its _ edit distance to monotonicity _",
    "( or ed , in short )  @xcite : given a sequence @xmath6 of @xmath7 items , each associated with a value in @xmath8 = \\{1 , 2 , \\dots , m\\}$ ] , the ed of @xmath6 , denoted by @xmath9 , is the minimum number of edit operations required to transform @xmath6 to the sequence obtained by sorting @xmath6 in non - decreasing order . here , an edit operation involves removing an item and re - insert it into a new position of the sequence .",
    "equivalently , @xmath9 is the minimum number of items in @xmath6 to delete so that the remaining items have non - decreasing values .",
    "a closely related measurement is the _ length of the longest increasing subsequence _ ( or lis ) of @xmath6 , denoted by @xmath10 .",
    "it is not hard to see that @xmath11 .    with the rapid advance of data collection technologies",
    ", the sequences usually appear in the form of a data stream , where the stream of items is massive in size ( containing possibly billions of items ) and the items are rapidly arriving sequentially .",
    "this gives rise to the problem of estimating ed in the data stream model : an algorithm is only allowed to scan the sequence sequentially in one pass , and it also needs to be able to return , at any time , an estimate on ed of the items arrived so far .",
    "the main concern is the space usage and update time per item arrival , which , ideally , should both be significantly smaller than the total data size ( preferably polylogarithmic ) .",
    "estimating ed of a data stream is becoming well - understood over the past few years  @xcite .",
    "gopalan et al .",
    "@xcite showed that computing the ed of a stream exactly requires @xmath12 space even for randomized algorithms , where @xmath7 is the number of items arrived so far .",
    "they also gave a randomized @xmath2-approximate algorithm for estimating ed using space @xmath13 , where @xmath14 .",
    "later , ergun and jowhari  @xcite improved the result by giving a deterministic @xmath15-approximate algorithm using space @xmath16 . for the closely related lis problem , gopalan et al .",
    "@xcite also gave a deterministic @xmath17-approximate algorithm for estimating lis using @xmath18 space .",
    "this space bound is proven to be optimal in  @xcite .",
    "* ed in sliding windows . *",
    "the above results consider the sortedness of all items in the stream arrived so far , which corresponds to the _ whole stream model_. recently , it is suggested that ed can be an indicator of network quality  @xcite",
    ". the items of the stream correspond to the packets transmitted through a network , each associated with a sequence number . ideally , the packets would arrive in increasing order of the sequence number .",
    "yet network congestion would result in packet retransmission and distortion in the packet arrival order , which leads to a large ed value .",
    "one of the main causes to network congestion is that traffic is often bursty .",
    "thus , the network quality can be measured more accurately if the measurement is based on only recent traffic . to this end , we propose studying the _ sliding window model _ where we estimate the ed of a window covering the latest @xmath0 items in the stream . here",
    "@xmath0 is a positive integer representing the window size .",
    "the sliding window model is no easier than the whole data stream model because when @xmath0 is set to be infinity , we need to estimate ed for all items arrived .    * our results .",
    "* we give a deterministic @xmath4-approximate algorithm for estimating ed in a sliding window .",
    "the space usage is @xmath19 , where @xmath0 is the window size .",
    "our algorithm is a generalization of the algorithm by gopalan et al . @xcite .",
    "in particular , gopalan et al .",
    "show that ed of the whole stream can be approximated by the number of `` inverted '' items @xmath20 such that many items arrived before @xmath20 has a value bigger than @xmath20 .",
    "we extend this definition to the sliding window model . yet , maintaining the number of inverted items in a sliding window is non - trivial .",
    "an item @xmath20 may be inverted when it arrives , but it may become not inverted due to the expiry of items _ arrived earlier_. we give an interesting algorithm to estimate the number of inverted items using existing results on basic counting and quantile estimation over sliding windows .",
    "our algorithm also incorporates an idea in  @xcite to remove randomization .",
    "we also consider two extensions of the problem .    _",
    "@xmath21 partial ordered items .",
    "_ in some applications , each item arrived is associated with multiple attributes , e.g. , a network packet may contain both the ip address of the sender and a sequence number . to measure the network quality , it is sometimes useful to estimate the _ most congested _ traffic coming from a particular sender .",
    "this corresponds to estimating the ed of packets with respect to sequence number from the same sender ip address . in this case , only sequence numbers with the same ip address can be ordered .",
    "we model such a situation by considering items each associated with a value drawn from a partial ordered universe .",
    "we are interested in estimating the minimum number of items to delete so that the remaining items are sorted with respect to the partial order .",
    "we give a randomized @xmath4-approximate algorithm using @xmath22 space .",
    "_ @xmath21 out - of - order streams .",
    "_ when a sender transmits packets to a receiver through a network , the packets will go through some intermediate routers . to measure the quality of the route between the sender and an intermediate router , it is desirable to estimate the ed of the packets received by the router from the sender . yet in some cases",
    ", the router may not be powerful enough to deploy the algorithm for estimating the ed .",
    "we consider delegating the task of estimation to the receiver .",
    "to model the situation , whenever a packet arrives , the intermediate router marks in the packet a timestamp recording the number of packets  received  thus far ( which can be done by maintaining a single counter ) . hence , when the packets arrive at the receiver , each packet has both a sequence number assigned by the sender and a timestamp marked by the router .",
    "note that the packets arrived at the receiver may be out - of - order with respect to the timestamp .",
    "such stream corresponds to an _ out - of - order  stream_.    to measure the network quality between the sender and the router , the receiver can estimate the ed with respect to the sequence number when the items are arranged in increasing order of the timestamps . intuitively , the problem is difficult as items can be inserted in arbitrary positions of the sequence according to the timestamp .",
    "we show strong space lower bounds even in the whole stream model .",
    "in particular , any randomized constant - approximate algorithm for estimating ed of an out - of - order stream requires @xmath23 space , where @xmath7 is the number of items arrived so far .",
    "an identical lower bound holds for estimating the lis .",
    "like most streaming lower bounds , our lower bounds are proved based on reductions from two communication problems , namely , the index  problem and the disj  problem .",
    "optimal communication lower bounds for randomized protocols are known for both problems @xcite .    *",
    "* section  [ sec : definitions ] and  [ sec : main ] give the formal problem definitions and our main algorithm for estimating ed , respectively .",
    "section  [ sec : extensions ] considers out - of - order streams . due to the page limit ,",
    "extension to partial ordered items is left to the full paper .",
    "* sortedness of a stream . * consider a stream @xmath6 of @xmath7 items , @xmath24 where each @xmath25 is drawn from @xmath8 = \\{1 , 2 , \\dots , m\\}$ ] .",
    "the _ edit distance to monotonicity _ ( ed ) of @xmath6 , denoted by @xmath9 , is the minimum number of items required to remove so as to obtain an increasing subsequence of @xmath6 , i.e. , @xmath26 such that @xmath27 for some @xmath28 .",
    "we use @xmath10 to denote the _ length of the longest increasing subsequence _",
    "( lis ) of @xmath6 . note that @xmath11 .",
    "the sortedness can be computed based on the _ whole stream _",
    "( all items in @xmath6 received thus far ) or a _ sliding window _ covering the most recent @xmath0 items , denoted by @xmath29 , for @xmath1 .",
    "note that the whole stream model can be viewed as a special case of the sliding window model with window size @xmath30 .",
    "a streaming algorithm has only limited space and can only maintain an estimate on the sortedness of @xmath29 . for any @xmath31 , a @xmath32-approximate algorithm for estimating @xmath33 returns , at any time , an estimate @xmath34 such that @xmath35 .",
    "we can define a @xmath32-approximate algorithm for estimating @xmath36 similarly .",
    "* partial ordered universe .",
    "* we also consider a partial ordered universe with binary relation @xmath37 .",
    "a subsequence of @xmath6 with length @xmath38 , @xmath39 , is increasing if for any @xmath40 $ ] , @xmath41 .",
    "then for any window size @xmath1 , @xmath33 and @xmath36 can be defined analogously as before .    *",
    "out - of - order stream . *",
    "the data stream described above is an _ in - order _ stream , which assumes items arriving in the same order as their creation time . in an _ out - of - order stream _ , each item is associated with a distinct integral time - stamp recording its creation time , which may be different from its arrival time .",
    "precisely , an out - of - order stream @xmath6 is a sequence of tuples @xmath42 ( @xmath43 $ ] ) where @xmath44 and @xmath45 are the timestamp and value of the @xmath46-th item .",
    "the sortedness of @xmath6 is defined based on the permuted sequence @xmath47 such that @xmath48 , i.e. , @xmath49 and @xmath50 .",
    "in this section , we consider a stream @xmath6 of items with values drawn from a set @xmath8 = \\{1 , 2 , \\dots , m\\}$ ] , and we are interested in estimating the ed of a sliding window covering the most recent @xmath0 items in  @xmath6 . we give a deterministic @xmath4-approximate algorithm which uses @xmath51 space .",
    "our algorithm is based on an estimator @xmath52 , which is a generalization of the estimator in  @xcite to the sliding window model .",
    "let @xmath46 be the index of the latest arrived item .",
    "the sliding window we consider is @xmath53}}= \\langle \\sigma(i - w+1 ) , \\sigma(i - w+2 ) , \\dots , \\sigma(i ) \\rangle$ ] . for any item @xmath54 ,",
    "let @xmath55 be the set of items arrived before @xmath54 but have greater values than @xmath54 , i.e. , @xmath56 .",
    "we define an estimator @xmath52 for @xmath57}})$ ] as follows .",
    "consider the current sliding window @xmath53}}$ ] .",
    "we define @xmath52 to be the set of indices @xmath58 $ ] such that there exists @xmath59 $ ] with @xmath60 \\cap inv(j)| > \\frac{j - k}{2}$ ] .",
    "[ lem : estimator ] @xmath61 } ) /2",
    "\\le |r(i)| \\le 2 \\cdot { { \\rm ed } } ( \\sigma_{[i - w+1,i]})$ ] .    hence ,",
    "if we know @xmath62 , we can return @xmath63 as an estimation for @xmath64})$ ] and it gives a 4-approximation algorithm .",
    "however , maintaining @xmath52 exactly requires space linear to the window size . in the following ,",
    "we show how to approximate @xmath52 using significantly less space .",
    "we first present our algorithm and then show that it can approximate @xmath52 .",
    "our algorithm will make use of two data structures .",
    "let @xmath65 be a constant in @xmath66 ( which will be set to @xmath67 later ) .",
    "* @xmath68-approximate quantile data structure @xmath69 * : let @xmath70 be a set of items .",
    "the rank of an item in  @xmath70 is its position in the list formed by sorting @xmath70 from the smallest to the biggest . for any @xmath71 $ ]",
    ", the @xmath68-approximate @xmath72-quantile of @xmath70 is an item with rank in @xmath73 $ ] .",
    "we maintain an @xmath68-approximate @xmath72-quantile data structure given in  @xcite which can return , at any time , an @xmath68-approximate @xmath72-quantile of the most recent @xmath74 items for any @xmath75 .",
    "this data structure takes @xmath76 space .",
    "* @xmath68-approximate basic counting data structure @xmath77 * : when an item @xmath25 arrives , we may associate a token with some item @xmath78 where @xmath79 .",
    "the association is permanent and an item may be associated with more than one token . at any time , we are interested in the number of tokens associated with the most recent @xmath0 items . we view it as a stream @xmath80 of tokens , each of which has a timestamp @xmath81 if it is associated to @xmath78 , and we want to return the number of tokens with timestamp in @xmath82 $ ] .",
    "note that the tokens may be out - of - order with respect to the timestamp , leading to the basic counting problem for out - of - order stream considered in  @xcite .",
    "we maintain their @xmath68-approximate basic counting data structure on @xmath80 which can return , at any time , an estimate @xmath83 such that @xmath84 , where @xmath85 is the number of tokens associated with the latest @xmath0 items .",
    "it takes @xmath86 space , where @xmath87 is the maximum number of tokens associated within any window of @xmath0 items . as we may associate one token upon any item arrival",
    ", @xmath87 is at most  @xmath0 .",
    "we are now ready to define our algorithm , as follows .",
    "[ cols=\"<\",options=\"header \" , ]     let @xmath88 be the set of indices @xmath20 such that when @xmath54 arrives , we associate a token to an item @xmath78 where @xmath89 $ ] .",
    "observe that @xmath88 is an approximation of @xmath52 in the following sense .",
    "[ lem : r ] @xmath88 contains _ all _ indices @xmath58 $ ] satisfying that there exists @xmath59 $ ] such that @xmath60\\cap inv(j)| > ( \\frac{1}{2 } + 2\\epsilon')(j - k)$ ] .",
    "furthermore , _ all _ indices @xmath20 contained in @xmath88 must satisfy that there exists @xmath59 $ ] such that @xmath60\\cap inv(j)| > \\frac{j - k}{2}$ ] .",
    "an index @xmath20 is in @xmath88 if @xmath90 when @xmath54 arrives , where @xmath91 is the @xmath68-approximate @xmath92-quantile for some interval @xmath93}$ ] .",
    "note that the rank of @xmath91 in @xmath94}$ ] is at least @xmath95 .",
    "therefore , if @xmath60\\cap inv(j)| > ( \\frac{1}{2 } + 2\\epsilon')(j - k)$ ] , the rank of @xmath54 is less than @xmath96 , so @xmath90 and @xmath20 must be included in @xmath88 . on the other hand ,",
    "the rank of @xmath91 in @xmath94}$ ] is at most @xmath97 . since @xmath98",
    ", we conclude that all indices @xmath99 satisfy @xmath60\\cap inv(j)| > \\frac{j - k}{2}$ ] .",
    "we show that @xmath100 is a good approximation for @xmath57}})$ ] , as follows .",
    "[ lem : approx - estimator ] @xmath101 } } ) \\le |r'(i)| \\le 2 \\cdot { { \\rm ed}}({\\sigma_{[i - w+1,i]}})$ ] .",
    "we observe that by lemma  [ lem : r ] , any index @xmath20 in @xmath88 must be also in @xmath52 .",
    "hence , @xmath102 and @xmath103}})$ ] ( by lemma  [ lem : estimator ] ) .",
    "now , we show @xmath104 } } ) \\le |r'(i)|$ ] by giving an iterative pruning procedure to obtain an increasing subsequence ( may not be the longest ) .",
    "first let @xmath105 and @xmath106 .",
    "find the largest @xmath20 such that @xmath107 and @xmath108 and delete the interval @xmath109 $ ] .",
    "we then let @xmath110 and repeat the process until no such @xmath20 is found .",
    "as each  @xmath111 is not in @xmath88 , lemma  [ lem : r ] implies that in every interval that we delete , the fraction of items of @xmath88 is at least @xmath112 .",
    "note that eventually all items in @xmath88 will be deleted .",
    "thus , @xmath113}})$ ] .",
    "note that @xmath100 equals the number of tokens associated with the most recent @xmath0 items .",
    "since @xmath114 is only an @xmath65-approximate data structure , the value @xmath83 returned only satisfies that @xmath115 . since we report @xmath116 } } ) = \\hat t / ( \\frac{1}{2}-2\\epsilon ' ) ( 1-\\epsilon')$ ] as the estimation , we conclude with the following approximation ratio .",
    "@xmath57 } } ) \\le { \\widehat { { \\rm ed}}}({\\sigma_{[i - w+1,i ] } } ) \\le \\frac{2(1+\\epsilon')}{(1/2 - 2\\epsilon')(1-\\epsilon ' ) } \\cdot { { \\rm ed}}({\\sigma_{[i - w+1,i]}})$ ]    for any @xmath117 , we can set @xmath118 .",
    "then , @xmath119 } } ) \\le ( 4+\\epsilon)\\cdot { { \\rm ed}}({\\sigma_{[i - w+1,i]}})$ ] .",
    "the total space usage of the two data structures is @xmath120 . if @xmath121 , @xmath122 and thus the total space usage is @xmath123",
    "otherwise , we can store all items in the window , which only requires @xmath124 space .    * improving the running time . *",
    "the per - item update time of the algorithm is @xmath125 because the algorithm checks the interval @xmath126 $ ] for every length @xmath127 $ ] .",
    "an observation in  @xcite is that an @xmath128-approximate @xmath72-quantile of an interval with length @xmath129 is also an @xmath68-approximate @xmath72-quantile for all intervals with length @xmath130 .",
    "hence we only need to check @xmath131 intervals of length @xmath132 .",
    "then we obtain an @xmath68-approximate quantile for every interval .",
    "note that the query time for returning an approximate quantile is @xmath133 , and the per - item update time of the two data structures is @xmath134  @xcite .",
    "we conclude with the main result of this section .",
    "there is a deterministic @xmath4-approximate algorithm for estimating ed in a sliding window of the latest @xmath0 items .",
    "the space usage is @xmath135 and the per - item update time is @xmath134 .",
    "* for the whole stream model , the state - of - the - art result is a @xmath136-approximation in @xcite .",
    "they gave an improved estimator @xmath52 as the set of indices @xmath20 such that there exists @xmath137 with @xmath138\\cap inv(j)| >    @xmath52 or not depends on the number of members of @xmath52 before that index .",
    "note that a member of @xmath52 could become a nonmember due to window expiration .",
    "therefore , an index @xmath20 that is not a member of @xmath52 initially , may later become a member if some of the previous @xmath52 members become nonmembers .",
    "this makes estimating this improved @xmath52 difficult in the sliding window model .",
    "in this section , we consider an out - of - order stream @xmath6 consisting of a sequence of items @xmath139 for @xmath140 $ ] , where @xmath44 and @xmath45 are the timestamp and value of the @xmath46-th item , respectively .",
    "recall that the sortedness of the stream is measured on the derived value sequence by rearranging the items in non - decreasing order of the timestamps .",
    "we show that even for the whole data stream model , any randomized constant - approximate algorithm for estimating ed or lis requires @xmath141 space .",
    "in fact , a stronger lower bound holds for ed : any randomized algorithm that decides whether ed equals 0 uses @xmath141 space .",
    "our proofs follow from reductions from two different communication problems .",
    "[ thm : lb_ed ] consider an out - of - order stream @xmath6 of size @xmath142 .",
    "any randomized algorithm that distinguish between the cases that @xmath143 and that @xmath144 must use @xmath141 bits .",
    "therefore , for arbitrary constant @xmath31 , any randomized @xmath32-approximation to @xmath9 requires @xmath141 bits .",
    "we prove the above lower bound by showing a reduction from the classical communication problem index , which has strong communication lower bound .",
    "the problem index@xmath145  is a two - player one - way communication game .",
    "alice holds a binary string @xmath146 and bob holds an index @xmath43 $ ] . in this communication game , alice sends one message to bob and bob is required to output the @xmath46-th bit of @xmath111 , i.e. @xmath147 , based on the message received .",
    "a trivial protocol is for alice to send all her input string @xmath111 to bob , which has communication complexity of @xmath7 bits .",
    "it turns out that this protocol is optimal .",
    "particularly , alice must communicate @xmath12 bits in any randomized protocol for index  @xcite .",
    "given an out - of - order stream with length @xmath142 , suppose there is a randomized algorithm @xmath148 that can determine whether its ed equals to 0 or is at least 1 using @xmath149 memory bits .",
    "we define a randomized protocol @xmath150 for index@xmath145 for @xmath151 : alice constructs ( hypothetically ) an out - of - order stream @xmath6 with length @xmath7 by setting @xmath152 alice then simulates algorithm @xmath148 on stream @xmath6 and sends the content of the working memory to bob .",
    "bob constructs another stream item @xmath153 to continue running algorithm @xmath148 on it and obtains the output .",
    "if the output says @xmath154 , bob outputs 0 ; otherwise , bob outputs 1 .",
    "it is not hard to see that index@xmath155 implies @xmath143 and index@xmath156 implies @xmath157 .",
    "therefore , if algorithm @xmath148 reports the correct answer with high probability , the protocol @xmath150 outputs correctly with high probability , and thus is a valid randomized protocol for index . in the protocol ,",
    "the number of bits communicated by alice is at most @xmath149 . combining the @xmath158 lower bound",
    ", we obtain that @xmath159 , completing the proof .",
    "[ thm : lb_lis ] consider an out - of - order stream @xmath6 with size @xmath142 .",
    "any randomized algorithm that outputs an @xmath32-approximation on @xmath10 must use @xmath160 bits .",
    "we prove the lower bound by considering the @xmath85-party set disjointness problem disj .",
    "the input to this communication game is a binary @xmath161 matrix @xmath162 , and each player @xmath163 holds one row of @xmath164 , the 1-entries of which indicate a subset @xmath165 of @xmath166 $ ] .",
    "the input @xmath164 is called _ disjoint _ if the @xmath85 subsets are pairwise disjoint , i.e. , each column of @xmath164 contains at most one 1-entry ; and it is called _ uniquely intersecting _ if the subsets @xmath165 share a unique common element @xmath167 and the sets @xmath168 are pairwise disjoint , meaning that in @xmath164 , except one column with entries all equal to 1 , all the other columns have at most one 1-entry .",
    "the objective of the game is to distinguish between the two types of inputs . to obtain the space lower bound , we only need to consider a restricted version of disj  where , according to some probabilistic protocol , the first @xmath169 players in turn send a message privately to his next neighboring player and the last player @xmath170 outputs the answer .    an optimal lower bound of @xmath171 total communication is known for disj  even for general randomized protocols ( with constant success probability ) @xcite , and thus the lower bound also holds for our restrited one - way private communication model . by giving a reduction and setting the parameters appropriately ,",
    "we can obtain the space lower bound .",
    "given a randomized algorithm that outputs @xmath32-approximation to the lis of any out - of - order stream with length @xmath142 , using @xmath149 memory bits , we define a simple randomized protocol for disj  for @xmath172 and @xmath173 .",
    "let @xmath164 be the input @xmath174 matrix .",
    "the first player @xmath175 creates an out - of - order stream @xmath6 by going through his row of input @xmath176 and inserting a new item @xmath177 to the end of the stream whenever an entry @xmath178 equals to 1 .",
    "he then runs the streaming algorithm on @xmath6 and sends the content of the memory to the second player . in general , player",
    "@xmath163 appends a new item @xmath179 to the stream for each nonzero entry @xmath180 , simulates the streaming algorithm and communicates the updated memory state to the next player .",
    "finally , player @xmath170 obtains the approximated lis of stream @xmath6 .",
    "if it is at most @xmath32 he reports that the input @xmath164 is disjoint ; else , he reports it is uniquely intersecting .",
    "it s easy to verify that if the input @xmath164 is disjoint , the correct lis of stream @xmath6 is 1 , while if it is uniquely intersecting , the correct lis of @xmath6 is @xmath85 .",
    "consequently , if the streaming algorithm outputs an @xmath32-approximation to @xmath10 with probability at least @xmath181 , the protocol for disj  is correct with constant probability , using total communication at most @xmath182 . following the lower bound for disj , this implies @xmath183 , i.e. , @xmath184 .",
    "theorem  [ thm : lb_lis ] follows .",
    "* actually , for deterministic algorithms , we can obtain a slightly stronger lower bound of @xmath185 for @xmath32-approximation , by a reduction from the hidden - is  problem used in @xcite to prove the @xmath186 lower bound for approximating lis of an in - order stream .",
    "the reduction is similar to the above , and if we set the approximation ratio @xmath32 to a constant , the lower bounds become linear in both cases . therefore , we neglect the details here .",
    "we thank the anonymous reviewers for helpful comments and for pointing out the randomized lower bounds to us ."
  ],
  "abstract_text": [
    "<S> given a stream of items each associated with a numerical value , its edit distance to monotonicity is the minimum number of items to remove so that the remaining items are non - decreasing with respect to the numerical value . </S>",
    "<S> the space complexity of estimating the edit distance to monotonicity of a data stream is becoming well - understood over the past few years . motivated by applications on network quality monitoring , we extend the study to estimating the edit distance to monotonicity of a sliding window covering the @xmath0 most recent items in the stream for any @xmath1 . </S>",
    "<S> we give a deterministic algorithm which can return an estimate within a factor of @xmath2 using @xmath3 space .    </S>",
    "<S> we also extend the study in two directions . </S>",
    "<S> first , we consider a stream where each item is associated with a value from a partial ordered set . we give a randomized @xmath4-approximate algorithm using @xmath5 space . </S>",
    "<S> second , we consider an out - of - order stream where each item is associated with a creation time and a numerical value , and items may be out of order with respect to their creation times . </S>",
    "<S> the goal is to estimate the edit distance to monotonicity with respect to the numerical value of items arranged in the order of creation times . </S>",
    "<S> we show that any randomized constant - approximate algorithm requires linear space . </S>"
  ]
}