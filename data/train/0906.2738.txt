{
  "article_text": [
    "range reporting and range counting are two variants of the range searching problem . in the range counting problem , the data structure returns the number of points in an arbitrary query range . in the range reporting problem",
    "the data structure reports all points in the query range .",
    "both variants were studied extensively and in many cases we know the matching upper and lower bounds for those problems for dimension @xmath12 . answering",
    "an orthogonal range counting query takes more time than answering the orthogonal range reporting query in the same dimension .",
    "this gap can not be closed because of the lower bounds for the range counting queries : while range reporting queries can be answered in constant time in one dimension and in almost - constant time in two and three dimensions ( if the universe size is not too big ) time , we simply say that the query time is @xmath13 .",
    "] , range counting queries take super - constant time in one dimension and poly - logarithmic time in two and three dimensions .",
    "= 1000 _ approximate range counting queries _ help us bridge the gap between range reporting and counting : instead of exactly counting the number of points ( elements ) in the query range , the data structure provides a good estimation .",
    "there are data structures that approximate the number of points in a one - dimensional interval  @xcite or in a halfspace  @xcite ,  @xcite ,  @xcite ,  @xcite up to a constant factor : given a query @xmath14 , the data structure returns the number @xmath15 such that @xmath16 , where @xmath3 is the exact number of points in the answer and @xmath17 is an arbitrarily small positive constant . in this paper",
    "we consider the following new variant of approximate range counting : if @xmath3 is the number of points in the answer , the answer to a query @xmath14 is an integer @xmath15 such that @xmath18 for some constant @xmath19 .",
    "thus we obtain better estimation for the number of points in the answer for large ( superconstant ) values of @xmath3 . on the other hand ,",
    "if the range @xmath14 is empty , then @xmath20 .",
    "we present data structures that approximate the number of points in a @xmath21-dimensional orthogonal range for @xmath22 .",
    "we also describe a dynamic one - dimensional data structure . +",
    "* dynamic 1-d data structure . * a static data structure that answers 1-d reporting queries in @xmath0 time is described in  @xcite . in  @xcite",
    "the authors also describe a static data structure that approximates the number of points in a 1-d range up to an arbitrary constant factor in constant time .",
    "ptracu and demaine  @xcite show that any dynamic data structure with polylogarithmic update time needs @xmath23 time to answer an exact range counting query ; henceforth @xmath4 denotes the size of the universe .",
    "the dynamic randomized data structure of mortensen  @xcite supports approximate range counting queries in @xmath0 time and updates in @xmath24 time ; see  @xcite for other trade - offs between query and update times . in this paper",
    "we present a new result on approximate range counting in 1-d :    there is a deterministic data structure that can answer one - dimensional approximate range counting queries using the best known data structure for predecessor queries , i.e. dynamic data structure supports range reporting queries in @xmath25 time , where @xmath26 is the time to answer a predecessor query in the dynamic setting ; currently @xmath27  @xcite . we show that we can approximate the number of points in the query range up to an additive factor @xmath28 , where @xmath3 is the number of points in the answer and @xmath5 is an arbitrary constant , in @xmath25 time .",
    "we thus significantly improve the precision of the estimation ; the query time is still much less than the lower bound for the exact counting queries in the dynamic scenario .    using the standard techniques , we can extend the results for one - dimensional approximate range counting to an arbitrary constant dimension @xmath21 .",
    "there is a data structure that approximates the number of points in a @xmath21-dimensional range up to an additive term @xmath29 for any @xmath30 in @xmath31 time and supports updates in @xmath32 time . for comparison",
    ", the fastest known dynamic data structure  @xcite supports emptiness queries in @xmath33 time .",
    "dynamic data structures are described in section  [ sec:1d ] . +",
    "* approximate range counting in 2-d and 3-d .",
    "* we match or almost match the best upper bounds for 2-d and 3-d emptiness queries .",
    "best data structures for exact range counting in 2-d and 3-d support queries in @xmath34 and @xmath35 time respectively  @xcite .",
    "if all point coordinates do not exceed @xmath36 , we can approximate the number of points in a two - dimensional query rectangle up to an additive term @xmath6 for an arbitrary parameter @xmath37 , @xmath38 , in @xmath39 time .",
    "if all point coordinates do not exceed @xmath36 , we can approximate the number of points in three - dimensional query rectangle up to an additive term @xmath6 in @xmath40 time for an arbitrary parameter @xmath37 , @xmath41 , and @xmath11 .",
    "the parameter @xmath37 is not fixed in advance , i.e. the same data structures can be used for answering queries with arbitrary precision .",
    "if point coordinates are arbitrary integers , then the query time of the above data structures increases by an additive term @xmath42 . data structure for range counting in 2-d and 3-d are described in section  [ sec:23d ] . in section  [ sec : space ] we describe space - efficient variants of two- and three - dimensional data structures that estimate the number of points in a range up to an additive error @xmath29 for some fixed constant @xmath5 .",
    "our results for approximate range counting queries are valid in the word ram model . throughout this paper @xmath17",
    "denotes an arbitrarily small constant .",
    "= 1000 we show that in the dynamic scenario answering one - dimensional counting queries with an additive error @xmath1 can be performed as efficiently as answering predecessor queries .",
    "the best known deterministic data structure supports one - dimensional emptiness queries in @xmath43 time , where @xmath44 is the time needed to answer a predecessor query in dynamic scenario  @xcite ,  @xcite .",
    "[ theor : dyn1d2 ] for any fixed constant @xmath45 , there exists a linear space data structure that supports approximate range counting queries with additive error @xmath1 in @xmath25 time , deletions in @xmath46 amortized time , and insertions in @xmath25 amortized time .",
    "first we observe that if the query interval contains less than @xmath47 points for an arbitrary constant @xmath5 , @xmath48| \\leq ( \\log \\log n)^c$ ] , then we can use a simple modification of the standard binary tree solution : the set @xmath49 is divided into groups of @xmath47 consecutive elements , i.e. , @xmath50 and every element in @xmath51 is smaller than any element in @xmath52 . using a dynamic data structure for predecessor queries we can find in @xmath53 time the successor @xmath54 of @xmath55 in @xmath49 and the predecessor @xmath56 of @xmath57 in @xmath49 .",
    "if @xmath55 and @xmath57 belong to the same group @xmath51 , then we can count elements in @xmath58 $ ] in @xmath59 time using the standard binary range tree solution .",
    "if @xmath54 and @xmath56 belong to two consecutive groups @xmath51 and @xmath52 , then we count the number of elements @xmath60 , @xmath61 , and the number of elements @xmath62 , @xmath63 .",
    "if @xmath54 belongs to a group @xmath51 and @xmath56 belongs to a group @xmath64 so that @xmath65 , then @xmath58 $ ] contains more than @xmath47 elements .",
    "we also assume w.l.o.g . that @xmath66 .",
    "we maintain the exponential tree  @xcite ,  @xcite for the set @xmath49 .",
    "the root node has @xmath67 children , so that each child node contains between @xmath68 and @xmath69 points from @xmath49 . in a general case , if a node @xmath70 contains @xmath71 points of @xmath49 , then node @xmath70 has @xmath72 children , so that each child contains between @xmath73 and @xmath74 points from @xmath49 .",
    "the exponential tree can be maintained as described in  @xcite , so that insertions and deletions are supported in @xmath46 time .",
    "additionally in every node @xmath70 we store the approximate number of elements in any consecutive sequence of children of @xmath70 , denoted by @xmath75 : for any @xmath76 , @xmath77 . when @xmath78 elements are inserted into a node @xmath70 or deleted from @xmath70 , we set @xmath79 for all @xmath76 .",
    "recomputing @xmath80 for a node @xmath70 takes @xmath81 time . since insertion or deletion results in incrementing or decrementing the value of @xmath71 in @xmath46 nodes @xmath70",
    ", recomputing @xmath75 incurs an amortized cost @xmath46 . thus amortized cost of a delete operation is @xmath46 .",
    "when we insert a new point , we also have to find its position in the exponential tree ; therefore an insertion takes @xmath25 time .",
    "we store @xmath81 auxiliary values in each node @xmath70 ; hence , we can show that the space usage is @xmath82 in exactly the same way as in  @xcite .    given an interval @xmath58 $ ]",
    ", we find @xmath83 and @xmath84 and identify the leaves of the exponential tree in which they are stored .",
    "the lowest common ancestor @xmath85 of those leaves can be found in @xmath46 time because the height of the tree is @xmath46 .",
    "if @xmath54 and @xmath56 are stored in the @xmath86-th and the @xmath87-th children of @xmath85 and @xmath88 , then all elements stored in @xmath89 belong to @xmath58 $ ] and we initialize a variable @xmath90 to @xmath91 .",
    "otherwise @xmath90 is set to @xmath92 .",
    "then , we traverse the path from @xmath85 to @xmath54 and in every visited node @xmath70 we increment @xmath90 by @xmath93 , such that @xmath54 is in the @xmath94-th child of @xmath70 , and @xmath95 is the total number of @xmath70 s children . finally , we traverse the path from @xmath85 to @xmath56 and in every visited node @xmath70 we increment @xmath90 by @xmath96 , such that @xmath56 is in the @xmath94-th child of @xmath70 , suppose that the variable @xmath90 was incremented by @xmath97 when a node @xmath70 was visited .",
    "let @xmath98 be the exact number of elements in all children of @xmath70 whose ranges are entirely contained in @xmath70 .",
    "then , @xmath99 . since @xmath100 , @xmath101 .",
    "clearly , the total number of points equals to the sum of @xmath98 for all visited nodes @xmath70 .",
    "the search procedure visits less than @xmath102 nodes for a constant @xmath103 . hence , @xmath104 for @xmath48|$ ] . since @xmath105 , @xmath106 .",
    "we obtain the result of the theorem by replacing @xmath5 with @xmath107 in the above proof .",
    "our dynamic data structure can be extended to @xmath21 dimensions using the standard range tree  @xcite .",
    "[ theor : dynmd ] for any fixed constant @xmath45 , there exists a data structure that supports @xmath21-dimensional approximate range counting queries with additive error @xmath1 in @xmath108 time and updates in @xmath109 amortized time .",
    "+    this result can be obtained by combining the standard range tree technique ( node degree in a range tree is @xmath110 for an appropriate constant @xmath111 ) with the data structure for one - dimensional approximate range counting of theorem  [ theor : dyn1d2 ] .",
    "details will be given in the full version of this paper .",
    "a point @xmath112 dominates a point @xmath85 if each coordinate of @xmath112 is greater than or equal to the corresponding coordinate of @xmath85 .",
    "the goal of the ( approximate ) dominance counting query is to ( approximately ) count the number of points in @xmath49 that dominate @xmath85 .",
    "the dominance query is equivalent to the orthogonal range query with a restriction that query range @xmath14 is a product of half - open intervals .",
    "we start this section with a description of the data structure that estimates the number of points in the answer to a 2-d dominance query up to a constant factor .",
    "we can obtain a data structure for general orthogonal range counting queries using a standard technique .",
    "then , we show that queries can be answered with higher precision without increasing the query time .",
    "finally , we describe a data structure for approximate range counting in 3-d . for simplicity",
    ", we only consider the case when all point coordinates are bounded by @xmath36 .",
    "we can obtain the results for the case of arbitrarily large point coordinates by a standard reduction to rank space technique  @xcite : the space usage remains linear and the query time increases by @xmath113 - the time needed to answer a static predecessor query .",
    "[ theor : domin2d1 ] there exists a linear space data structure that answers approximate two - dimensional dominance range counting queries on @xmath114 grid in @xmath46 time .",
    "a @xmath115-approximate boundary , introduced by vengroff and vitter  @xcite is a polyline @xmath116 consisting of @xmath117 axis - parallel segments that partitions the space , so that every point @xmath116 is dominated by at most @xmath118 and at least @xmath115 points of @xmath49 .",
    "this notion can be straightforwardly extended to a @xmath119-boundary @xmath120 : @xmath120 partitions the space into two parts , and every point @xmath120 is dominated by at most @xmath121 and at least @xmath115 points of @xmath49 .",
    "we can construct a @xmath119-boundary with the same algorithm as in  @xcite .",
    "let @xmath112 be a point with coordinates @xmath122 .",
    "we move @xmath112 in the positive @xmath123 direction until @xmath112 is dominated by at most @xmath124 points .",
    "then , we repeat the following steps until the @xmath123-coordinate of @xmath112 equals to @xmath92 : a ) move @xmath112 in @xmath125 direction as long as @xmath112 is dominated by more than @xmath115 points of @xmath49 b ) move @xmath112 in the @xmath126 direction until @xmath112 is dominated by @xmath124 points of @xmath49 .",
    "the path traced by @xmath112 is a @xmath119-boundary ; see fig .",
    "[ fig : bound2d ] for an example . _",
    "inward corners _ are formed when we move @xmath112 in @xmath125 direction , i.e. inward corners mark the beginning of step a ) resp .",
    "the end of step b ) .",
    "inward corners of @xmath116 have a property that no point of @xmath116 is strictly dominated by an inward corner and for every point @xmath127 that is not an inward corner , there is an inward corner @xmath128 dominated by @xmath129 .",
    "there are @xmath117 inward corners in a @xmath119-approximate boundary because for every inward corner @xmath130 there are @xmath131 points that dominate @xmath5 and do not dominate inward corners whose @xmath123-coordinates are larger than @xmath132 .",
    "-approximate boundaries in 2-d . for simplicity , the points of the set @xmath49 are not shown.,width=264 ]    our data structure consists of @xmath133 @xmath119-approximate boundaries @xmath134 such that @xmath135 is an @xmath136-approximate boundary of @xmath49 , i.e. every point on @xmath135 is dominated by at least @xmath136 and at most @xmath137 points of @xmath49 .",
    "if a point @xmath138 is dominated by a query point @xmath85 , then @xmath85 is dominated by at most @xmath137 points of @xmath49 .",
    "if @xmath85 dominates a point on @xmath135 , then it also dominates an inward corner of @xmath135 .",
    "hence , we can estimate the number of points that dominate @xmath85 up to a constant @xmath139 by finding the minimal index @xmath87 such that @xmath85 dominates an inward corner of @xmath140 .",
    "since @xmath85 is dominated by a point of @xmath141 , @xmath85 is dominated by @xmath142 points of @xmath49 . on the other hand , @xmath143 because a point of @xmath140 is dominated by @xmath85 .",
    "we can store inward corners of all boundaries @xmath135 in a linear space data structure so that for any point @xmath85 the minimal index @xmath87 , such that some point on @xmath140 is dominated by @xmath85 , can be found in @xmath46 time .",
    "we denote by @xmath144 the point @xmath145 , such that @xmath146 where @xmath147 is the set of @xmath123-coordinates of all points in @xmath148 . for simplicity",
    ", we sometimes do not distinguish between a boundary @xmath135 and the set of its inward corners .",
    "let @xmath149 .",
    "let @xmath150 be the inward corner on a boundary @xmath135 whose @xmath123-coordinate @xmath132 precedes @xmath151 , @xmath152 . for any other inward corner @xmath153 on @xmath135 , @xmath154 if and only if @xmath155 because the @xmath156-coordinates of inward corners decrease monotonously as their @xmath123-coordinates increase .",
    "hence , @xmath85 dominates a point on @xmath135 if and only if @xmath157 . thus given a query point @xmath85",
    ", it suffices to identify the minimal index @xmath87 , such that the @xmath156-coordinate of the inward corner @xmath158 that precedes @xmath151 is smaller than or equal to @xmath159 .",
    "the @xmath123-axis is subdivided into intervals of size @xmath160 .",
    "for each interval @xmath161 the list @xmath162 contains indexes of boundaries @xmath135 such that the @xmath123-coordinate of at least one inward corner of @xmath135 belongs to @xmath161 . for a query point @xmath85 with @xmath163 and for every @xmath164",
    ", we can find the inward corner preceding @xmath151 with respect to its @xmath123-coordinate , @xmath165 , in @xmath0 time because @xmath123-coordinates of all relevant inward corners belong to an interval of size @xmath160 .",
    "hence , we can find the minimal index @xmath166 , such that @xmath85 dominates a point on @xmath167 in @xmath46 time by binary search among indexes in @xmath162 .",
    "for the left bound @xmath168 of an interval @xmath169 $ ] and for all indexes @xmath170 , the list @xmath171 contains the inward corner @xmath172 , such that @xmath173 . by binary search in @xmath171 we can find the minimal @xmath174 such that @xmath85 dominates the inward corner @xmath175 .",
    "clearly @xmath176 is the minimal index of a boundary dominated by @xmath85 .",
    "[ theor:2dgener ] there exists a @xmath177 space data structure that supports two - dimensional approximate range counting queries on @xmath114 grid in @xmath46 time .",
    "the next lemma will enable us to obtain a better estimation of the number of points .",
    "[ lemma : adn ] there exists a @xmath178 space data structure that supports two - dimensional approximate range counting queries on @xmath114 grid with an additive error @xmath179 in @xmath180 time for any @xmath37 , @xmath181 .",
    "we divide the grid into @xmath123-slabs @xmath182\\times [ 1,n]$ ] and @xmath156-slabs @xmath183\\times [ y_{j-1},y_j]$ ] , so that each slab contains @xmath184 points . for every point @xmath185 , @xmath186 we store the number of points in @xmath49 that dominate it .",
    "there is also a recursively defined data structure for each slab .",
    "the total space usage is @xmath187 and @xmath188 .",
    "we can easily obtain an approximation with additive error @xmath189 using the first level data structure : for a query @xmath149 we identify the indexes @xmath86 and @xmath87 , such that @xmath190 and @xmath191 , i.e. we identify the @xmath123-slab @xmath192 and the @xmath156-slab @xmath193 that contain @xmath85 .",
    "indexes @xmath86 and @xmath87 can be found in @xmath46 time .",
    "let @xmath194 be the number of points that dominate a point @xmath195 ; let @xmath196 ( @xmath197 ) be the number of points in the slab @xmath192 ( @xmath193 ) that dominate @xmath195 . then @xmath198 . since @xmath199 and @xmath200 , the value of @xmath201 is an approximation of @xmath202 with an additive error @xmath189 .",
    "using recursive data structures for slabs @xmath192 and @xmath193 we can estimate @xmath203 and @xmath204 with an additive error @xmath205 and estimate @xmath202 with an additive error @xmath206 . if the recursion depth is @xmath70 ( i.e. if we apply recursion @xmath70 times ) , then the total number of recursive calls is @xmath207 and we obtain in @xmath208 time an approximation with additive error @xmath209 for any positive integer @xmath70 .",
    "we set recursion depth @xmath210 .",
    "then , @xmath211 . hence , @xmath212 . therefore ,",
    "if recursion depth is set to @xmath70 , then our data structure provides an answer with additive error @xmath179 .",
    "[ theor : domin2d2 ] there exists a @xmath177 space data structure that supports two - dimensional dominance counting queries on @xmath114 grid with an additive error @xmath9 for an arbitrary parameter @xmath37 , @xmath181 , in @xmath213 time .",
    "+ there exists a @xmath214 space data structure that supports two - dimensional range counting queries on @xmath114 grid with an additive error @xmath9 for an arbitrary parameter @xmath37 , @xmath181 , in @xmath213 time .    as in theorem",
    "[ theor : domin2d1 ] we construct @xmath115-boundaries @xmath215 , such that @xmath216 is a @xmath217-approximate boundary , i.e. each point on @xmath135 is dominated by at least @xmath217 and at most @xmath218 points of @xmath49 .",
    "for each inward corner @xmath219 of every @xmath220 , we store a data structure @xmath221 that contains all points that dominate @xmath219 and supports approximate counting queries as described in lemma  [ lemma : adn ] . for a fixed @xmath87 , there are @xmath222 data structures @xmath221 , and each @xmath221 contains @xmath223 points .",
    "hence , all data structures @xmath221 use @xmath177 space .",
    "as described in theorem  [ theor:2dgener ] , we can find in @xmath46 time the minimal index @xmath87 , such that @xmath140 is dominated by the query point @xmath85 and an inward corner @xmath224 dominated by @xmath85 .",
    "then , we use the data structure @xmath221 to obtain a better approximation .",
    "since @xmath221 contains @xmath225 points , by lemma  [ lemma : adn ] @xmath221 estimates the number of points that dominate @xmath85 with an additive error @xmath9 in @xmath180 time . we can extend the result for dominance counting to the general three - dimensional counting using the standard technique from range reporting  @xcite ; see also the proof of theorem  [ theor:2dgener ] .",
    "[ lemma : adn2 ] there exists a @xmath226 space data structure that supports three - dimensional approximate range counting queries on @xmath227 grid with an additive error @xmath179 in @xmath228 time for any @xmath37 , @xmath181 , and for @xmath11 .",
    "we divide the grid into @xmath123- , @xmath156- , and @xmath229-slabs , @xmath182\\times [ 1,n]\\times [ 1,n]$ ] , @xmath183\\times [ y_{j-1},y_j]\\times [ 1,n]$ ] , @xmath230\\times [ 1,n]\\times [ z_{d-1},z_d]$ ] , so that each slab contains @xmath231 points . for each point",
    "@xmath232 we store the number of points in @xmath49 that dominate it .",
    "there is also a recursively defined data structure for each slab .",
    "the total space usage is @xmath233 and @xmath234 .    for a query @xmath235",
    "we identify the @xmath123- , @xmath156- , and @xmath229-slabs @xmath192 , @xmath193 , and @xmath236 that contain @xmath85 . by the same argument as in lemma  [ lemma : adn ] , the number of points that dominate @xmath232 differs from the number of points that dominate @xmath85 by at most @xmath237 .",
    "we can estimate the number of points that dominate @xmath85 and belong to one of the slabs @xmath192 , @xmath193 , and @xmath236 using recursively defined data structures .",
    "if the recursion depth is @xmath70 , then we obtain in @xmath238 time an approximation with additive error @xmath239 for any positive integer @xmath70 .",
    "the result of the lemma follows if we set @xmath11 .",
    "[ theor : approx3d ] there exists a @xmath214 space data structure that supports approximate dominance range counting queries on @xmath227 grid with an additive error @xmath9 in @xmath240 time for any @xmath37 , @xmath181 , and for @xmath11 .",
    "+ there exists a @xmath241 space data structure that supports approximate range counting queries on @xmath227 grid with an additive error @xmath9 in @xmath240 time for any @xmath37 , @xmath181 , and for @xmath11 .    instead of counting points that dominate @xmath85 we count points dominated by @xmath85 .",
    "both types of queries are equivalent .",
    "hence , the data structure of lemma  [ lemma : adn2 ] can be used to approximately count points dominated by @xmath85 .",
    "a downward corner of a point @xmath112 consists of all points dominated by @xmath112 .",
    "we define an approximate @xmath115-level as a set of downward corners @xmath242 , such that ( 1 ) any point @xmath112 that dominates at most @xmath115 points of @xmath49 is contained in some @xmath243 ( 2 ) any downward corner @xmath243 contains at most @xmath121 points of @xmath49 .",
    "afshani  @xcite showed that for an arbitrary constant @xmath139 there exists an approximate @xmath115-level of size @xmath244 .",
    "we can assume that no @xmath243 dominates @xmath245 in an approximate @xmath115-level @xmath242 : if @xmath246 dominates @xmath247 , then the downward corner @xmath247 can be removed from @xmath242 .",
    "identifying an inward corner @xmath243 that dominates a query point @xmath85 ( or answering that no @xmath243 dominates @xmath85 ) is equivalent to answering a point location query in a rectangular planar subdivision  @xcite and takes @xmath248 time .",
    "our data structure consists of approximate levels @xmath249 , such that @xmath135 is a @xmath217-approximate level and the constant @xmath139 is chosen to be @xmath250 .",
    "for every downward corner @xmath251 , we store all points dominated by @xmath252 in a data structure @xmath221 ; @xmath221 contains @xmath223 points and supports counting queries with additive error @xmath253 by lemma  [ lemma : adn2 ] .",
    "all data structures @xmath221 use @xmath214 space .",
    "we can find a minimal @xmath87 , such that @xmath140 dominates @xmath85 in @xmath254 time by binary search .",
    "let @xmath252 be the downward corner that dominates @xmath85 .",
    "we can use the data structure @xmath221 to estimate the number of points that are dominated by @xmath85 with an additive error @xmath9 ; by lemma  [ lemma : adn2 ] this takes @xmath255 time for @xmath11 .",
    "we can extend the result for dominance counting to the general three - dimensional counting using the standard technique  @xcite ; see also the proof of theorem  [ theor:2dgener ] .",
    "if we are interested in counting with an additive error @xmath256 for some predefined constant @xmath30 , then the space usage can be significantly reduced .",
    "the two - dimensional data structure uses @xmath177 space ( @xmath82 space for dominance counting ) , and the three - dimensional data structure uses @xmath226 space ( @xmath82 space for dominance counting ) .",
    "the main idea of our improvement is that in the construction of lemma  [ lemma : adn ] ( resp .",
    "lemma  [ lemma : adn2 ] ) each slab contains @xmath257 points ( @xmath258 points ) for some @xmath259 and there is a constant number of recursion levels .",
    "[ lemma : adn3 ] for any fixed constant @xmath260 , there exists a @xmath261 space data structure that supports two - dimensional approximate range counting queries on @xmath114 grid with an additive error @xmath262 in @xmath263 time .",
    "we divide the grid into @xmath123-slabs @xmath182\\times [ 1,n]$ ] and @xmath156-slabs @xmath183\\times [ y_{j-1},y_j]$ ] , so that each slab contains @xmath257 points . as in lemma",
    "[ lemma : adn ] , we store for each point @xmath185 , @xmath264 , the number of points in @xmath49 that dominate it .",
    "note that there are @xmath265 points @xmath185 for @xmath266 .",
    "if an @xmath123-slab or a @xmath156-slab contains more than @xmath267 points for a constant @xmath268 , we store a recursively defined data structure for that slab .",
    "the number of recursion levels is @xmath269 .",
    "since each point is stored in one recursively defined data structure for an @xmath123-slab and in one recursively defined data structure for a @xmath156-slab , the total number of points in all recursively defined data structures increases by factor @xmath250 with each recursion level .",
    "thus the total space usage is @xmath270 .    given a query @xmath149",
    ", we identify the @xmath123-slab @xmath192 and the @xmath156-slab @xmath193 that contain @xmath85 .",
    "let @xmath194 be the number of points that dominate a point @xmath195 ; let @xmath196 ( @xmath197 ) be the number of points in the slab @xmath192 ( @xmath193 ) that dominate @xmath195 . as in the proof of lemma  [ lemma : adn ] , @xmath198 , where @xmath192 and @xmath193 are the @xmath123-slab and the @xmath156-slab that contain @xmath85 . if slabs @xmath192 and @xmath193 , contain more than @xmath271 points , we estimate @xmath272 and @xmath203 using data structures for slabs @xmath193 and @xmath192 .",
    "otherwise we use @xmath201 as an estimation for @xmath202 . by the same argument as in the proof of lemma  [ lemma : adn ]",
    ", we obtain an approximation with additive error @xmath273 . since @xmath274 and @xmath275 , @xmath276 . hence , @xmath277 and",
    "we estimate the number of points in a range with an additive error that is less than @xmath278 .    using lemma  [ lemma : adn3 ]",
    ", we can prove the following theorem .",
    "[ theor:2dlin ] for any fixed constant @xmath260 , there exists a @xmath82 space data structure that supports two - dimensional dominance counting queries on @xmath114 grid with an additive error @xmath256 in @xmath46 time .",
    "+ for any fixed constant @xmath260 , there exists a @xmath177 space data structure that supports two - dimensional range counting queries on @xmath114 grid with an additive error @xmath256 in @xmath46 time .",
    "we construct a sequence of @xmath115-approximate boundaries @xmath135 in the same way as in theorem  [ theor : domin2d2 ] and store all points that dominate an inward corner @xmath219 in data structure @xmath221 .",
    "the only difference is that @xmath221 is implemented as described in lemma  [ lemma : adn3 ] . for a fixed @xmath87 ,",
    "there are @xmath222 data structures @xmath221 , and each @xmath221 needs @xmath279 space .",
    "hence , all data structures @xmath221 use @xmath280 space .    dominance queries are processed in exactly the same way as in theorem  [ theor : domin2d2 ] .",
    "we can extend the result for dominance counting to the general two - dimensional counting using the standard technique from range reporting  @xcite ; see also the proof of theorem  [ theor:2dgener ] .",
    "[ lemma : adn4 ] for any fixed constant @xmath260 , there exists a @xmath261 space data structure that supports three - dimensional approximate range counting queries on @xmath281 grid with an additive error @xmath262 in @xmath263 time .    like in lemma",
    "[ lemma : adn2 ] , we divide the grid into @xmath123- , @xmath156- , and @xmath229-slabs , @xmath182\\times [ 1,n]\\times [ 1,n]$ ] , @xmath183\\times [ y_{j-1},y_j]\\times [ 1,n]$ ] , @xmath230\\times [ 1,n]\\times [ z_{d-1},z_d]$ ] , but each slab contains @xmath258 points . for each point",
    "@xmath232 we store the number of points in @xmath49 that dominate it .",
    "if the number of points in a slab is greater than @xmath271 for @xmath282 , then we store a recursively defined data structure for each slab .",
    "we can estimate the space usage and analyze the query algorithm in the same way as in lemma  [ lemma : adn3 ] .",
    "[ theor : approx3d2 ] for any fixed constant @xmath260 , there exists a @xmath82 space data structure that supports approximate dominance range counting queries on @xmath227 grid with an additive error @xmath256 in @xmath254 time .",
    "+ for any fixed constant @xmath260 , there exists a @xmath214 space data structure that supports approximate range counting queries on @xmath227 grid with an additive error @xmath256 in @xmath254 time .    as in the proof of theorem  [ theor : approx3d ]",
    "our data structure consists of @xmath217-approximate levels @xmath135 for @xmath283 . for every inward corner @xmath251 , we store all points dominated by @xmath252 in the data structure @xmath221 described in lemma  [ lemma : adn4 ] .",
    "each @xmath221 uses @xmath284 space .",
    "since a @xmath285-approximate level @xmath286 has @xmath222 inward corners , all @xmath140 use @xmath280 space .",
    "dominance counting queries are answered in the same way as in theorem  [ theor : approx3d ] .",
    "we can extend the result for dominance counting to the general three - dimensional counting by applying the standard technique from range reporting  @xcite that was also used in proofs of theorems  [ theor:2dgener ] , [ theor : approx3d ] , [ theor:2dlin ] .",
    "we would like to thank an anonymous reviewer of the previous version of this paper for stimulating suggestions that helped us improve some of our results .",
    "99 p. afshani _ on dominance reporting in 3d _ , proc .",
    "esa 2008 , 41 - 51 .",
    "p. afshani , t. m. chan , _ on approximate range counting and depth _ , proc .",
    "socg 2007 , 337 - 343 .",
    "s. alstrup , g. s. brodal , t. rauhe _",
    "new data structures for orthogonal range searching _ , proc .",
    "focs , 198 - 207 , 2000 .",
    "s. alstrup , g. s. brodal , t. rauhe , _ optimal static range reporting in one dimension _ ,",
    "stoc 2001 , 476 - 482 .",
    "a. andersson , _",
    "faster deterministic sorting and searching in linear space _",
    "focs 1996 , 135 - 141 .",
    "a. andersson , m. thorup , _ dynamic ordered sets with exponential search trees _",
    "j. acm ( jacm ) 54(3):13 ( 2007 ) .",
    "b. aronov , s. har - peled , _ on approximating the depth and related problems _ , siam j. comput .",
    "38(3 ) : 899 - 921 ( 2008 ) .",
    "b. aronov , s. har - peled , m. sharir , _ on approximate halfspace range counting and relative epsilon - approximations _ , proc .",
    "socg 2007 , 327 - 336 .",
    "p. beame , f. e. fich , , j. comput .",
    "65(1 ) : 38 - 72 ( 2002 ) .",
    "j. l. bentley , , commun .",
    "acm 23 : 214 - 229 , 1980 . m. de berg , m.   j. van kreveld , j. snoeyink , _",
    "two- and three - dimensional point location in rectangular subdivisions _ , j. algorithms 18(2 ) : 256 - 277 ( 1995 ) .",
    "b. chazelle , l.  j. guibas , _ fractional cascading : i. a data structuring technique _ , algorithmica 1(2 ) : 133 - 162 ( 1986 ) .",
    "h. gabow , j.  l. bentley , r.  e. tarjan , _ scaling and related techniques for geometry problems _ proc .",
    "stoc 1984 , 135 - 143 .",
    "j. jaja , c. w. mortensen , q. shi , _ space - efficient and fast algorithms for multidimensional dominance reporting and counting _ , proc .",
    "isaac 2004 , 558 - 568 .",
    "h. kaplan , m. sharir , _ randomized incremental constructions of three - dimensional convex hulls and planar voronoi diagrams , and approximate range counting _ , proc .",
    "soda 2006:484 - 493 .",
    "y. matias , j.s .",
    "vitter , n. e. young , _ approximate data structures with applications _ ,",
    "soda 1994 , 187 - 194 .",
    "p. b. miltersen , n. nisan , s. safra , a. wigderson , j. comput .",
    "57(1 ) : 37 - 49 ( 1998 ) .",
    "c. w. mortensen , _ fully dynamic orthogonal range reporting on ram _ , siam j. comput .",
    "35(6 ) : 1494 - 1525 ( 2006 ) . c. w. mortensen , _ data structures for orthogonal intersection searching and other problems _ , ph.d .",
    "thesis ( 2006 ) . c. w. mortensen , r. pagh , m. patrascu , _ on dynamic range reporting in one dimension .",
    "stoc 2005 , 104 - 111 .",
    "y. nekrich , _ a data structure for multi - dimensional range reporting _ , proc .",
    "socg 2007 , 344 - 353 .",
    "y. nekrich , _ data structures for approximate orthogonal range counting _ , arxiv:0906.2738 ( 2009 ) .",
    "m. h. overmars , _ efficient data structures for range searching on a grid _ , j. algorithms 9(2 ) : 254 - 275 ( 1988 ) .",
    "m. patrascu , e. d. demaine , _ logarithmic lower bounds in the cell - probe model _",
    ", siam j. comput .",
    "35(4):932 - 963 ( 2006 ) .",
    "s. subramanian , s. ramaswamy , _ the p - range tree : a new data structure for range searching in secondary memory _ , proc .",
    "soda 1995 , 378 - 387 .",
    "d.   e. vengroff , j.  s. vitter , _ efficient 3-d range searching in external memory _",
    "stoc 1996 , 192 - 201 .",
    "we use the well known technique used for range reporting queries  @xcite .",
    "the set of points @xmath49 is subdivided into subsets @xmath287 , so that the total number of points in @xmath288 is @xmath177 , and an arbitrary query rectangle @xmath14 can be represented as a union of at most four rectangles @xmath289 , @xmath290 , so that @xmath291 and each @xmath292 is a product of two half - open intervals .",
    "we store the date structure for approximate dominance queries of theorem  [ theor : domin2d1 ] for each set @xmath293 , so that the total space usage is @xmath177 .",
    "given a query @xmath14 , we can decompose @xmath14 into @xmath294 and find the corresponding @xmath295 in @xmath46 time , see e.g.  @xcite . then",
    ", we can estimate the number of points in each @xmath296 , @xmath297 , and thus estimate the number of points in @xmath291"
  ],
  "abstract_text": [
    "<S> we present new data structures for approximately counting the number of points in an orthogonal range . </S>",
    "<S> there is a deterministic linear space data structure that supports updates in @xmath0 time and approximates the number of elements in a 1-d range up to an additive term @xmath1 in @xmath2 time , where @xmath3 is the number of elements in the answer , @xmath4 is the size of the universe and @xmath5 is an arbitrary fixed constant . </S>",
    "<S> we can estimate the number of points in a two - dimensional orthogonal range up to an additive term @xmath6 in @xmath7 time for any @xmath8 . we can estimate the number of points in a three - dimensional orthogonal range up to an additive term @xmath9 in @xmath10 time for @xmath11 . </S>"
  ]
}