{
  "article_text": [
    "coxeter - like complexes were introduced in [ br ] as a common generalization of coxeter complexes and chessboard complexes . the point was to associate a cell complex analogous to a coxeter complex to any minimal generating set for any finite group  for instance , to any set of @xmath8 transpositions in the symmetric group @xmath9 which generate @xmath9 . while traditional coxeter complexes are endowed with a wealth of beautiful and remarkable properties ( see e.g. [ hu ] , [ br ] ) , including shellability ( as proven in [ bj2 ] ) , the topological structure of more general coxeter - like complexes is often much more subtle .",
    "the chessboard complexes already demonstrate this .",
    "chessboard complexes have been studied extensively , motivated both by applications to computational geometry ( see e.g. [ zv ] ) and also because of a direct relation established in [ rr ] between their homology groups and the tor groups of segre modules .",
    "the homology groups for chessboard complexes are not easy to determine , for example involving 3-torsion ; results in [ blvz ] and [ sw ] together show that they are exactly @xmath10-connected , for @xmath11",
    ". our main focus will be on topological properties of more general coxeter - like complexes .",
    "let us now briefly recall some terminology and establish some notation , before describing our main results .",
    "babson and reiner associate to any finite group @xmath12 with chosen minimal generating set @xmath13 a cell complex which they call a _ coxeter - like complex _ , denoted @xmath14 , as follows .",
    "the cells of @xmath15 are the cosets of parabolic subgroups of @xmath12 , where a _",
    "parabolic subgroup _ is defined to be any subgroup generated by a subset of @xmath13 .",
    "a cell @xmath16 is said to be in the closure of a cell @xmath17 whenever @xmath18 .",
    "@xmath15 is the unique such regular cell complex with the property that each cell has the combinatorial type of a simplex . in other words ,",
    "all lower intervals in its face poset are boolean algebras , implying that its face poset is a simplicial poset ( as in [ st ] ) , and @xmath15 is what is known as a cell complex of boolean type ( cf .",
    "[ bj ] ) .    our focus will be on the case where the group @xmath12 is the symmetric group @xmath9 and the minimal generating set @xmath13 is a set of @xmath8 transpositions that generate @xmath9 . in this case",
    ", @xmath14 is a simplicial complex which is specified by the tree @xmath1 on @xmath2 vertices having the edge set @xmath19 , where @xmath20 denotes the transposition swapping @xmath21 and @xmath22 .",
    "here we are using the fact that a set @xmath13 of transpositions generates @xmath9 if and only if @xmath23 is a tree @xmath1 on @xmath2 vertices .",
    "denote @xmath14 by @xmath0 in this case , where @xmath1 is this associated tree .",
    "observe that the @xmath21-dimensional faces of @xmath0 may be interpreted as the labelled forests obtained by deleting @xmath24 edges from @xmath1 and then assigning @xmath25 labels to each of the resulting components @xmath26 in such a way that each of the labels @xmath27 is assigned to exactly one component .",
    "when defining the `` inversions '' of a face later , we will think of such a labelled forest as a tree whose vertices are the forest components and whose edges are the ( deleted ) edges which connect the components , with the `` capacity '' of a component being the number of labels to be assigned to it .    to allow for capacities larger than one , we study the more general type - selected coxeter - like complexes of [ br ] , denoted @xmath28 , where @xmath1 is a tree and @xmath29 is a vector consisting of @xmath30 nonnegative integers which specify the capacities of the various vertices of @xmath1 . denote the capacity of vertex @xmath31 by @xmath32 .",
    "one way to define @xmath33 is as a coxeter - like complex for the quotient group @xmath34 with generating set @xmath13 consisting again of transpositions corresponding to the edges of @xmath1 .",
    "notice that one can also then make a combinatorial definition , analogous to the one given above for @xmath35 , again obtaining a face @xmath36 by deleting a set of edges @xmath37 and then assigning the appropriate number of labels to each of the resulting graph components , i.e. assigning exactly @xmath38 labels to component @xmath26 , where the labels are taken from the set @xmath39 .",
    "just as above , this is a simplicial complex with face containments of the form @xmath40 if and only if @xmath41 is obtained from @xmath42 by merging neighboring components working in the generality of these type - selected complexes @xmath28 will be quite helpful to our analysis of the topological structure of skeleta of the complexes @xmath0 .",
    "recall that the _ chessboard complex _",
    "@xmath6 is the simplicial complex whose @xmath21-dimensional faces are the collections of @xmath43 mutually nonattacking rooks on an @xmath44 by @xmath2 chessboard .",
    "it was observed in [ br ] that @xmath6 is isomorphic to the coxeter - like complex resulting from a tree with @xmath44 leaves , each having capacity one and exactly one nonleaf vertex @xmath31 with @xmath45 .",
    "the edges from @xmath31 to the leaves specify the @xmath44 rows of the chessboard while the @xmath2 labels specify the columns .",
    "a collection of non - attacking rooks then corresponds to an assignment of labels to the subset of the leaves whose incident edges have been chosen .",
    "it was shown in [ blvz ] that @xmath6 is at least @xmath46-connected .",
    "shareshian and wachs later proved that @xmath47 in [ sw ] and exhibited 3-torsion in many cases .",
    "ziegler proved vertex decomposibility ( and thus shellability ) of the @xmath48-skeleta of chessboard complexes in [ zi ] ( see also [ at ] ) , while friedman and hanlon determined @xmath9-module structure in [ fh ] and also showed there was no rational homology in degree @xmath48 .",
    "see [ wa ] for a clear and quite comprehensive survey article regarding chessboard complexes and related complexes .",
    "our starting point was the following conjecture from [ br ] , which we will prove in theorem  [ proof - of - conjecture ] .",
    "[ connectivity - bound ] if a tree @xmath1 has @xmath2 nodes and @xmath4 leaves , then the coxeter - like complex @xmath0 is at least @xmath49-connected .",
    "in fact , we prove something stronger , namely that if @xmath1 has a collection @xmath50 of edges such that the tree @xmath51 associated to @xmath52 via definition  [ tree - assoc ] satisfies @xmath53 for each vertex @xmath54 , and a similar condition holds for all subtrees , then the @xmath55-skeleton of @xmath0 is shellable , hence homotopy equivalent to a wedge of @xmath56-spheres .",
    "the conjecture follows from the case in which @xmath57 is the set of edges from parents to first children in a depth - first - search of a planar embedding of @xmath1 with a leaf serving as the tree root . in the course of proving this result",
    ", we also do several other things :    1 .",
    "axiomatize the notions of inversions and weak order for permutations in a way that also makes sense for the labellings of any fixed tree ( regarding permutations as the labellings of a path ) 2 .",
    "provide such an inversion function and weak order for any tree @xmath58 in which each vertex @xmath54 satisfies @xmath59 , i.e. any so - called `` distributable capacity tree '' 3 .   prove that if @xmath58 admits an inversion function , then @xmath28 is shellable 4 .",
    "extend a shelling constructed using ( 2 ) and ( 3 ) to one for the entire @xmath5-skeleton of @xmath0 for any tree @xmath1 with @xmath2 nodes and @xmath4 leaves    our approach to shelling via an inversion function also turns out to be related to the question of how to route packets of data efficiently on a network of computers which has a tree structure , viewing vertices as processors and edges as connections between them .",
    "specifically , in theorem  [ equiv - sort ] we prove that the existence of an inversion function on the labellings of a tree is equivalent to that tree admitting greedy sorting based on this same inversion function ; the requirements of an inversion function ensure that any series of local moves which swap labels at neighboring nodes that are out of order will terminate , and that all such series of local moves terminate at the same fully - sorted tree .",
    "our setting is an idealized one which does not even begin to capture the complexity of the networks of widest current interest such as the internet graph , particularly since the graph of the internet is very far from being a tree .",
    "however , one still might hope that our topological viewpoint on sorting and routing could offer some useful new insight .",
    "for instance , the connection we establish between greedy sorting and shellability gives a topological obstruction to greedy sorting as follows : showing that @xmath28 has nonvanishing homology in low degrees directly implies that greedy sorting based on an inversion set is not possible on the tree @xmath1 with vertex capacities @xmath29 .",
    "chessboard complexes already provide a class of such trees , since they are known to have nonvanishing homology in low enough degrees to imply that their associated trees , namely stars , do not admit such greedy sorting algorithms unless the central node of the star has capacity at least its degree minus one .",
    "we refer readers to [ le ] for results in theoretical computer science regarding sorting and routing on various networks , though there are also many more recent results in this direction .",
    "the main focus of this paper is the coxeter - like complex @xmath0 in which @xmath12 is the symmetric group @xmath9 and @xmath13 is a set of @xmath8 transpositions which generate @xmath9 .",
    "the faces and incidences in this complex are as described in the introduction . given a face @xmath36 , denote by @xmath37 the set of edges in @xmath60 , i.e. the edges deleted from @xmath1 to obtain the labelled forest representing @xmath36 .",
    "thus , @xmath61 .",
    "[ tree - assoc ] associate to a tree @xmath58 and a choice of subset @xmath57 of the set of edges of @xmath1 a new tree @xmath62 as follows .",
    "the vertices of @xmath63 are the connected components @xmath26 in the forest obtained by deleting from @xmath1 the edges in @xmath57 , and the edges of @xmath63 are the edges in @xmath57 .",
    "the capacity of a component @xmath26 is the sum of its vertex capacities .",
    "figure  [ new - tree ] gives one example of this process , with edges in @xmath57 depicted by dashed lines .",
    "( 250,125)(40,10 )    for another example , suppose that @xmath1 is a tree of four nodes , three of which are leaves , and suppose each leaf has capacity one while the central node has capacity three .",
    "letting @xmath57 consist of any one edge of this tree , then the new tree @xmath62 will be a path on two nodes , one having capacity one and the other having capacity five .",
    "[ distrib - def ] a tree @xmath58 has _ distributable capacity _ if each of its vertices @xmath31 satisfies @xmath64 .    for example , a tree with four nodes , three of which are leaves , has distributable capacity iff the non - leaf has capacity at least two .",
    "[ face - assoc ] given a tree @xmath1 , a face @xmath36 in @xmath0 is said to have _ distributable capacity _ if the tree @xmath62 obtained by applying definition  [ tree - assoc ] to tree @xmath1 and edge set @xmath65 has distributable capacity .",
    "[ balanced - lemma ] the faces of @xmath35 with distributable capacity comprise a subcomplex . moreover , any component @xmath26 obtained by merging two neighboring components of a tree @xmath63 with distributable capacity satisfies @xmath66 .",
    "proper faces are obtained by successively merging neighboring nodes .",
    "if neighboring nodes @xmath67 are merged to form @xmath68 , and if @xmath69 , for @xmath70 , then @xmath71 satisfies @xmath72    denote by @xmath73 the simplicial complex comprised of a face @xmath36 and all the proper faces of @xmath36 . a _ shelling _ of a simplicial complex @xmath74 is a total order @xmath75 on the facets of @xmath74 , i.e. on its maximal faces , such that for each @xmath76 the simplicial complex @xmath77 is a pure , codimension one subcomplex of @xmath78 ; recall that a simplicial complex is _ pure _ if all maximal faces are equidimensional .",
    "it is well - known ( and easy to show ) that any shellable simplicial complex which is pure of dimension @xmath79 for some @xmath80 has homology concentrated in top degree and is simply connected , hence is @xmath81-connected .",
    "recall that the link of a face @xmath12 in a simplicial complex @xmath74 , denoted @xmath82 , is the subcomplex @xmath83 , and that a shelling for @xmath74 induces a shelling on the link of any face of @xmath74 .",
    "denote the @xmath84-skeleton of a simplicial complex @xmath74 by @xmath85 .",
    "we will prove that @xmath86 has a pure , full - dimensional subcomplex isomorphic to @xmath87 for some @xmath51 with distributable capacity , and use the upcoming inversion function for @xmath51 to construct a shelling for @xmath87 which extends to a shelling of @xmath86 . by convention",
    ", we will always work in terms of a choice of rooted , planar embedding for @xmath1 which has a leaf as its root .",
    "the _ destination _ of a label @xmath88 $ ] in a tree @xmath58 , denoted @xmath89 , is the @xmath90-th vertex visited in a depth - first - search of @xmath1 , where @xmath91 is the integer - valued sequence with @xmath92 for all @xmath21 which assigns @xmath32 consecutive labels to each @xmath31 as it is encountered in a depth - first - search .",
    "denote by @xmath93 the set of labellings of a tree @xmath58 with labels @xmath94 which assign @xmath32 labels to vertex @xmath31 for each @xmath95 .",
    "for further background in topological combinatorics and in coxeter group theory , see [ bj3 ] and [ hu ] , respectively .",
    "in this section , we prove the following implications , after first defining what we mean by inversion function :    1 .   if @xmath58 admits an inversion function , then @xmath28 is shellable .",
    "2 .   if @xmath28 is shellable via an inversion function for each @xmath58 having distributable capacity , then @xmath86 is shellable for @xmath1 any tree with @xmath2 nodes , @xmath4 of which are leaves .",
    "theorem  [ no - full - shell ] proves ( 1 ) .",
    "theorem  [ finish - shell ] implies ( 2 ) , but is more general . in section  [ inversion - section ] , we will construct an inversion function for all distributable capacity trees , enabling us to use ( 1 ) and ( 2 ) to give a shelling for @xmath86 and thereby deduce the connectivity lower bound conjectured in [ br ] .",
    "generalizing definition  [ tree - assoc ] , associate to any face @xmath36 in @xmath28 a tree @xmath96 by making a vertex for each connected component in @xmath97 and an edge for each element of @xmath37 , letting the capacity of any component be the sum of the capacities of the vertices comprising that component .",
    "label the vertices of this tree with the collections of labels in the components of @xmath98 .",
    "denote by @xmath99 the set of labellings of the tree @xmath58 .",
    "now let @xmath100 be a function which assigns to each face @xmath36 in @xmath28 a collection of pairs of neighboring components in @xmath96 , called the _ inversion pairs _ of @xmath36 .",
    "further require of @xmath100 that for each pair of neighboring components @xmath67 , there is a unique way to redistribute the labels collectively assigned to @xmath101 and @xmath102 so that @xmath103 is not an inversion pair of the resulting labelled tree @xmath42 , i.e. so that @xmath104 .",
    "this condition will in fact be subsumed by part 1 of definition  [ inv - fun - def ] .    for neighboring components",
    "@xmath105 with @xmath106 , define @xmath107 to be the labelling obtained from @xmath42 by redistributing the labels among @xmath21 and @xmath22 in the unique way so that @xmath108 . make a covering relation @xmath109 for each @xmath106 where @xmath20 are tree neighbors .",
    "[ inv - fun - def ] a function @xmath100 as above is an _ inversion function _ for @xmath58 if @xmath100 has the following properties :    1 .",
    "each face @xmath110 is contained in a unique facet which is inversion - free on its restriction to each component of @xmath36 .",
    "2 .   the transitive closure of @xmath111 is a partial order , which we then call the _ weak order _ with respect to @xmath100 , denoted @xmath112 .",
    "these properties also hold on the restriction to any subforest .",
    "for example , suppose @xmath1 is a path with one end of the path chosen as tree root .",
    "say that a labelling of @xmath1 has an inversion pair @xmath113 exactly when @xmath114 is closer than @xmath115 to the root but some label assigned to @xmath114 is larger than some label assigned to @xmath115 .",
    "it is easy to check that this meets the above requirements for an inversion function , and in fact is equivalent to the usual notion of inversions between adjacent letters in permutations .",
    "however , it is much more difficult , and in many cases is impossible , to define an inversion function for other trees besides paths .",
    "one of our main goals is to determine for which trees it is possible to construct an inversion function , and one of the main results in this paper will be a sufficient condition which will enable us to prove the conjecture of babson and reiner .",
    "[ no - full - shell ] if @xmath116 admits an inversion function , then @xmath117 is shellable .",
    "the facets in @xmath118 may be viewed as labellings of @xmath58 with @xmath119 labels assigned to the vertex @xmath114 for each @xmath21 .",
    "denote by @xmath120 the facet associated to tree labelling @xmath121 .",
    "we first prove for each facet @xmath120 with @xmath121 not the minimal element in @xmath122 that @xmath123 is a pure codimension one subcomplex of @xmath124 .",
    "implicitly here we use ( 2 ) to guarantee that @xmath112 is indeed a partial order . by ( 1 ) , merging neighboring components @xmath125 in @xmath120 for any @xmath126 yields a codimension one face of @xmath120 also contained in the earlier facet @xmath127 . given any face @xmath128 ,",
    "let @xmath129 be a facet containing @xmath12 such that @xmath130 .",
    "requirement ( 3 ) ensures that @xmath131 may be obtained from @xmath121 by a series of steps each eliminating an inversion between two neighboring nodes , with the further restriction that these pairs of neighboring nodes are each connected by edges not belonging to @xmath132 .",
    "thus , we obtain a codimension one face of @xmath120 , denoted @xmath133 , with @xmath134 as follows : merge two neighboring components of @xmath120 whose inversion may be eliminated as the first step in proceeding from @xmath120 to @xmath129 in weak order .",
    "now let @xmath135 be any linear extension of @xmath112 . consider @xmath12 any face in @xmath136 .",
    "the earliest facet containing @xmath12 is the unique one that is inversion - free on each component of @xmath12 .",
    "this will already come before @xmath137 in weak order , so @xmath138 regardless of our choice of linear extension @xmath139 .",
    "it is easy to check that the case of a path amounts to exactly the shellability of the type a coxeter complex by using any linear extension of weak order to order the facets .",
    "it seems to be much easier for our upcoming main example to confirm that a particular function @xmath100 is indeed an inversion function by considering the much more detailed data of inversions between non - neighboring nodes as well as neighbors . in particular",
    ", the extra information will make it easier to prove that the transitive closure of the set of covering relations is indeed a partial order .",
    "therefore , we make the following variation on the definition of inversion function , where now we let @xmath100 be a function assigning to each tree labelling a collection of ( not necessarily adjacent ) pairs of nodes .",
    "[ inv - fun - def2 ] a function @xmath100 assigning to each tree labelling a collection of pairs of nodes is a _ full inversion function _ for @xmath58 if @xmath100 has the following properties :    1 .   for each @xmath140 and each @xmath141 , there is an inversion pair ( denoted @xmath142 to keep notation simple ) between two neighboring components on the unique path from @xmath21 to @xmath84 in @xmath58 .",
    "2 .   each face @xmath36 is contained in a unique facet @xmath143 which is inversion - free on the restriction of @xmath143 to each component of @xmath36 .",
    "the transitive closure of @xmath111 is a partial order , which we then call the _ weak order _ with respect to @xmath100 , denoted @xmath112 .",
    "these properties also hold on the restriction to any subtree .",
    "note that any full inversion function induces an inversion function by assigning to each labelling its inversions which are between neighbors .      throughout this section",
    ", @xmath145 will always be a set of edges in a tree @xmath1 such that @xmath52 gives rise to a distributable capacity tree via definition  [ tree - assoc ] .",
    "moreover , if we delete from @xmath1 any set @xmath146 of edges such that @xmath147 , and we let @xmath148 be a connected component of the resulting forest with @xmath149 denoting the set of edges in @xmath148 , then we also assume that the tree @xmath51 obtained from @xmath150 via definition  [ tree - assoc ] will also have distributable capacity .",
    "theorem  [ finish - shell ] will show for such @xmath52 how to shell @xmath151 .",
    "proposition  [ c-0-case ] will show that the set of edges from parents to their first children in any depth first search of a tree whose root is a leaf will meet the above conditions on a set @xmath57 .",
    "see figure  [ first - children ] for what would be an example of such a set @xmath57 , except that in this example we have not chosen a leaf as the root .",
    "( 250,125)(-45,10 )    we will use this special case to prove that @xmath86 is shellable , for @xmath1 any tree with @xmath2 nodes and @xmath4 leaves .",
    "label each facet @xmath36 in @xmath152 with coordinates @xmath153 as described next , and then order the facets by letting earlier coordinates take precedence over later ones , using the orders specified below on individual coordinates .",
    "let @xmath154 , and order this first coordinate linearly .",
    "let @xmath155 , and order this second coordinate by lexicographic order on the words obtained from the sets @xmath13 by listing the elements of @xmath13 in increasing order with respect to depth - first - search order on the edges of the tree @xmath1",
    ".    it will be convenient to first determine @xmath156 for a given facet @xmath36 , and then describe the labels @xmath157 for the various facets having this fixed choice of @xmath158 and @xmath13 .",
    "in fact , we will need to fix somewhat more , namely the edge set @xmath37 , and then use the fact that the facets of @xmath86 with fixed edge set are the labellings of a fixed tree @xmath51 whose edges are exactly the edges in @xmath37 .",
    "two facets @xmath159 may have the same coordinates @xmath158 and @xmath13 despite having @xmath160 , but we deal with this by first ordering collections of facets using the labels @xmath158 and @xmath13 , and then choosing any ordering on the edge sets arising for a fixed @xmath158 and @xmath13 to extend to a total order on edge sets .",
    "next we describe how to assign sets @xmath157 to the facets with a given edge set @xmath37 and how to order these inversion sets .    when @xmath161 , the tree @xmath51 obtained from @xmath162 by definition  [ tree - assoc ] has distributable capacity , as shown in proposition  [ c-0-case ] .",
    "let @xmath157 then be the set of inversions given by the inversion function for this distributable capacity tree ( as provided in section  [ inversion - section ] ) .",
    "partially order the facets by the weak order on their inversion sets , i.e. , @xmath163 , and then choose any total order extension of @xmath163 to obtain a total order on the facets having a fixed edge set @xmath37 .",
    "all total order extensions of @xmath163 are equivalent for purpose of shelling , since @xmath164 for each @xmath22 regardless of our choice of linear extension @xmath165 , so there is no need to specify a choice .    for @xmath166 , consider each component @xmath148 in the forest obtained from @xmath1 by deleting the edges in @xmath167 . for each such @xmath148 , consider the tree @xmath51 obtained from @xmath168 via definition  [ tree - assoc ] .",
    "this tree also has distributable capacity , so let @xmath157 be the union over all these components @xmath148 of the inversion sets for the various @xmath148 .",
    "theorem  [ finish - shell ] will show that these sets @xmath157 come close enough to being inversion functions to allow us to extend the shelling of the subcomplex generated by the facets having @xmath161 to a shelling of the entire @xmath55-skeleton .",
    "[ finish - shell ] suppose there exists @xmath169 such that @xmath52 gives rise to a tree @xmath51 via definition  [ tree - assoc ] which has distributable capacity .",
    "moreover , for @xmath148 any subtree arising as a connected component in a forest obtained from @xmath1 by deleting any subset of the set of edges not in @xmath57 , suppose that the tree @xmath51 obtained from @xmath170 also has distributable capacity",
    ". then @xmath171 is shellable .",
    "let @xmath172 be the facets of @xmath171 , ordered as described in section  [ labelling - section ] .",
    "we will show this is a shelling in which the minimal face @xmath173 contributed by facet @xmath143 consists of the following three types of edges in @xmath174 .",
    "1 .   @xmath175 2 .",
    "@xmath176 3 .",
    "@xmath177    the first thing to show is that deleting an edge of any of these three types from the facet @xmath143 yields a codimension one face that is also contained in an earlier facet .",
    "secondly , we must prove that every face in @xmath178 is contained in some such codimension one face .",
    "together , these will imply that @xmath178 is a pure , codimension one subcomplex of @xmath179 , as is needed for the shelling .    to verify the first claim ,",
    "we show that omitting from @xmath143 any vertex of @xmath173 will yield a face @xmath36 that has codimension one in @xmath143 and is shared with a facet @xmath180 in which one of the coordinates in the facet labelling for @xmath143 has been decremented .",
    "if we delete from @xmath143 an edge in @xmath181 , then there must be some edge in @xmath182 that may be added to @xmath36 to obtain @xmath180 with smaller @xmath158 coordinate and with @xmath183 .",
    "if @xmath36 is obtained by deleting from @xmath143 an edge from @xmath184 such that @xmath174 lacks some earlier edge @xmath185 , then we may insert @xmath186 into @xmath36 to obtain a facet with the same @xmath158 coordinate as @xmath143 but a smaller @xmath13 coordinate . deleting an edge where there is an inversion between neighboring nodes means there will be an earlier facet in @xmath112 with this inversion eliminated , by theorem  [ inv - meets ] .",
    "now we turn to the second claim .",
    "suppose @xmath12 is a face in @xmath187 not contained in any codimension one face of @xmath143 .",
    "then @xmath12 must contain @xmath173 by ( a ) .",
    "in particular , @xmath12 must include @xmath188 , hence may only merge components of @xmath143 that are connected by edges @xmath189 .",
    "moreover , @xmath12 may only merge components such that the edge @xmath186 connecting the pair of components satisfies @xmath190 .",
    "thus , @xmath12 is not contained in any @xmath55-faces in which either of the first two coordinates of @xmath143 have been decremented from their value in @xmath143 .",
    "additionally , @xmath12 is not contained in any earlier facet @xmath180 satisfying @xmath191 since @xmath12 contains all edges in @xmath188 as well as all edges in @xmath192 that could possibly be replaced by earlier edges .",
    "finally , our first and third requirements for inversion sets completely determine the distribution of labels in @xmath143 and force @xmath143 to come earlier than all other facets containing @xmath12 , a contradiction to @xmath12 being shared with an earlier facet .",
    "[ c-0-case ] the tree @xmath1 together with the set @xmath57 of edges from parents to first children in a depth first search of @xmath1 with a leaf as root gives rise by definition  [ tree - assoc ] to a tree @xmath51 with distributable capacity .",
    "moreover , if we delete from @xmath1 any subset @xmath146 of the edges with @xmath147 and restrict to a component @xmath148 of the resulting forest , then the tree associated to @xmath193 by definition  [ tree - assoc ] also has distributable capacity .",
    "each component of the forest obtained by deleting these edges has at least as many vertices as it has edges from its vertices to their first children ; the only other possible edge to another component is from the root of the component to its parent , so @xmath36 has distributable capacity .",
    "the same clearly holds on the restriction to any @xmath148 , by virtue of our choice of edge set @xmath57 .",
    "[ skeleton - shell - corollary ] if @xmath1 has @xmath2 nodes and @xmath4 leaves , then @xmath86 is shellable .",
    "there are @xmath194 edges from parents to first children , since @xmath1 has a leaf as root .",
    "letting @xmath57 be this collection of edges , @xmath52 gives rise to a distributable - capacity tree , and this property also restricts to subtrees as needed ; this is verified in proposition  [ c-0-case ] , so we may apply theorem  [ finish - shell ] .    from this , the conjecture of [ br ] is immediate :    [ proof - of - conjecture ] if @xmath1 has @xmath2 nodes and @xmath4 leaves , then @xmath0 is at least @xmath3-connected .",
    "define a _ local sorting step _ to be the unique redistribution of labels between two neighboring nodes eliminating the inversion pair between the two nodes .",
    "a tree labelling is said to be _ completely sorted _ if it has no inversion pairs .",
    "[ equiv - sort ] definition  [ inv - fun - def ] may be rephrased in terms of greedy sorting algorithms as follows :    1 .",
    "any tree whose labels are not completely sorted admits a local sorting step .",
    "this is also true of the restriction to any subtree which is not completely sorted .",
    "2 .   all sequences of local sorting steps lead to the same completely sorted labelling .",
    "this also holds for restrictions to subtrees , using only local swaps within the subtree .",
    "any series of local sorting steps will eventually terminate at a completely sorted tree .",
    "the above properties also hold for the restriction to any subtree .",
    "it is easy to see that the conditions of definition  [ inv - fun - def ] imply the conditions above , so we focus on proving the other direction .",
    "the fact that any series of local sorting steps terminates implies that the transitive closure of @xmath195 is a partial order on the ( finite ) set of tree labellings , since otherwise there would be a cycle enabling the same series of sorting steps to be repeated indefinitely .",
    "the fact that every series of local swaps terminates with the same outcome implies that @xmath122 has a unique minimal element , giving the unique inversion - free labelling of the entire tree .",
    "the analogous requirement for restrictions to subtrees implies condition 2 also holds for all other faces .",
    "if one instead considers full inversion functions , i.e. , definition  [ inv - fun - def2 ] , note then that condition 1 in that definition is essentially equivalent to condition 1 of theorem  [ equiv - sort ] . combining theorems  [ equiv - sort ] and  [ no - full - shell ] yields :    [ sorting - obstruction ] if @xmath28 is not shellable",
    ", then @xmath58 does not admit a greedy sorting algorithm in the sense of proposition  [ equiv - sort ] .",
    "thus , we obtain a homological obstruction to many trees admitting greedy sorting algorithms based on inversion functions .",
    "for instance , chessboard complexes arise as the special case in which @xmath1 is a star , namely a tree with a single vertex @xmath31 that is not a leaf . by corollary  [ sorting - obstruction ] ,",
    "known results on the homology of chessboard complexes from [ sw ] tell us that stars with @xmath196 do not admit greedy sorting .",
    "we should note that in the context of sorting / routing algorithms , operations are typically performed simultaneously at the edges connecting many different pairs of processors .",
    "however , an inversion function still indicates which such operations would constitute progress in sorting data .",
    "the distributable - capacity hypothesis which will make possible an inversion function is very much in the spirit of results on routing in the sense that allowing queues of bounded size to accumulate at nodes greatly improves efficiency in algorithms .",
    "let us begin with an example demonstrating some challenges to be overcome .",
    "trees are depicted with the root at the top and siblings ordered from left to right .",
    "edges in @xmath37 are represented by dashed lines , while all other edges in @xmath197 are depicted by solid lines .",
    "we say @xmath198 when @xmath199 is one of the labels assigned to vertex @xmath114 .",
    "[ bottleneck - example ] a natural approach would be to make an inversion @xmath20 whenever there are labels at positions @xmath21 and @xmath22 traversing the same edge in opposite directions on the most direct routes to their destinations in depth - first - search order . however , this inversion set is too sparse to satisfy condition one of definition  [ inv - fun - def2 ] in general ( and will also fail definition  [ inv - fun - def ] ) .",
    "( 250,125)(-60,0 )    the example in figure  [ tree - queue ] also illustrates a second issue , namely that of contention .",
    "there are inversion pairs between the vertices with label pairs @xmath200 , but it is not clear where there should be an inversion between neighboring nodes on the path between the locations of labels @xmath201 and @xmath202 , as required by definition  [ inv - fun - def2 ] , condition one .",
    "notice also that this tree labelling would be inversion - free in the sense of definition  [ inv - fun - def ] , but would not be the unique such labelling because the labelling which puts labels in exactly depth - first - search order would also be inversion - free .",
    "the distributable capacity requirement will handle this sort of contention by ensuring that each vertex has enough capacity to allow distinct labels at the node to form inversions with its various neighbors , to exactly the extent that will be needed to define an inversion function ; remark  [ distrib - intuition ] makes this precise .",
    "this simple idea will be crucial to the inversion function which is constructed over the remainder of this section .",
    "for any face @xmath203 , define the _",
    "components _ of @xmath36 to be the components of the graph @xmath204 obtained by deleting the edges in @xmath37 from the tree @xmath1 .",
    "the inversions of @xmath36 will be the inversions of the labelled tree whose vertices are the components of @xmath204 and whose edges are the edges in @xmath37 , letting the labels of a vertex be the set of labels assigned to that component in @xmath204 .",
    "[ distrib - intuition ] let @xmath1 be a tree with distributable capacity and let @xmath63 be any tree obtained from @xmath1 by merging some neighboring nodes .",
    "then for any vertex @xmath205 comprised of more than one vertex of @xmath1 and for any vertex @xmath54 belonging to @xmath26 , notice that the number of edges from @xmath31 to vertices of @xmath1 not in @xmath26 is at least as large as the capacity of @xmath31 .",
    "call the edges @xmath206 from a fixed vertex @xmath31 the _ capacity channels _ of @xmath31 .",
    "define the _ path _ of a label @xmath199 in a tree labelling to be the minimal path from @xmath199 s position in the tree labelling to @xmath207 .",
    "when we speak of an edge @xmath208 in the path of a label , by convention the directed path proceeds from @xmath209 to @xmath31 . a label @xmath199 in a tree labelling _ fills a capacity channel @xmath210 _ if the path of @xmath199 includes the edge @xmath210 .    the following notion",
    "will help us generalize ideas from linear arrays to trees , by specifying a hierarchy of linear arrays within a tree :    [ coarsening - defn ] a _ coarsening _ with respect to a node @xmath211 ( which we will regard as a `` local root '' ) is the decomposition of a rooted tree @xmath1 with respect to a marked node @xmath211 into as many as three parts as follows : ( 1 ) if @xmath211 has multiple children , then there is a part @xmath101 consisting of @xmath211 s first child @xmath31 along with all descendants of @xmath31 , ( 2 ) if @xmath211 has more than two children , then there is a part @xmath212 consisting of @xmath211 s last child @xmath121 and all descendants of @xmath121 , and ( 3 ) in any case there is a part @xmath102 consisting of @xmath211 and all remaining nodes of @xmath1 ( some of which will not be descendants of @xmath211 if @xmath211 is not the global root )",
    ". now repeatedly subdivide @xmath102 in this fashion to obtain successive levels of coarsening on smaller and smaller subtrees , each of which includes @xmath211 , until reaching a subtree in which @xmath211 has at most one remaining child .",
    "[ path - dist - def ] the _ coarsening - path - distance _ of a label @xmath199 with respect to a particular coarsening at a chosen local root @xmath211 is @xmath213 , where @xmath214 and @xmath215 are the coarsening parts where the path of @xmath199 begins and ends .    while our upcoming inversion function may seem rather complicated , we are not aware of any simpler choice that provably works for more general trees than just paths",
    ". it would be interesting if a simpler inversion function exists in our level of generality , i.e. for all distributable capacity trees .",
    "part ( 1 ) of definition  [ distance - defn ] and part e1 of definition  [ label - inv - def ] below are both forced by our upcoming base - labelling algorithm ( which constructs the unique inversion - free labelling with proscribed labels ) .",
    "part ( 4 ) of definition  [ distance - defn ] and parts v1-v4 of definition  [ label - inv - def ] are chosen so as to make inversion - free labellings tend towards ordering labels consistently with depth - first - seach order .",
    "other parts constitute more arbitrary choices we have made where some choice was needed .",
    "first we prioritize the capacity channels out of a vertex :    [ edge - priority ] given a vertex @xmath209 , say that the edge @xmath216 is a _ higher priority edge _ at @xmath209 than @xmath208 if either ( 1 ) there is a coarsening with respect to local root @xmath209 such that @xmath217 but @xmath218 , or ( 2 ) there is a coarsening with respect to local root @xmath209 such that @xmath219 and @xmath220 , or ( 3 ) for all levels of coarsening we have @xmath221 but with @xmath31 a child of @xmath209 and @xmath121 the parent of @xmath31 .    [ distance - defn ]",
    "let @xmath222 be two labels in a labelled tree whose directed paths to their destinations intersect , letting @xmath210 be the final shared edge , when there is such an edge , and otherwise letting @xmath223 be the unique shared vertex",
    ". then @xmath224 has _ higher priority _ than @xmath225 at @xmath223 , or",
    "in other words @xmath224 _ travels farther _ than @xmath225 from @xmath223 ,",
    "if any of the following conditions hold :    1 .",
    "the path from @xmath223 to @xmath226 properly contains the path from @xmath223 to @xmath227 .",
    "2 .   there is a shared edge @xmath210 as above , and the coarsening - path - distance of @xmath224 is greater than that of @xmath225 with respect to some coarsening with @xmath228 as local root .",
    "3 .   there is a shared edge @xmath210 as above , and the edge @xmath229 in the path of @xmath224 is a higher priority edge out of @xmath228 ( cf . definition  [ edge - priority ] ) than the edge @xmath230 traversed by @xmath225 .",
    "there is a shared edge @xmath210 as above , @xmath231 , and either ( a ) @xmath232 with @xmath210 proceeding from later to earlier position in depth - first - search order , or ( b ) @xmath233 with @xmath210 proceeding from earlier to later position in depth - first - search order .",
    "@xmath224 traverses a higher priority edge out of @xmath223 than @xmath225 does .",
    "note that in definition  [ label - inv - def ] , given next , two labels will never form a label inversion unless their paths share at least a vertex .",
    "v1-v4 below will deal with the various ways two paths may meet in just a vertex , while e1-e3 handle the ways two paths may share an edge or have the starting point of one path be contained in the other path .",
    "[ label - inv - def ] a pair of labels @xmath234 with @xmath235 and @xmath236 forms a _ label inversion pair _ in a tree labelling @xmath41 , denoted @xmath237 , if any of the following conditions are met :    1 .",
    "@xmath238 and @xmath239 traverse the same edge in opposite directions on the paths from @xmath240 to @xmath241 and from @xmath242 to @xmath243 [ la ] 2 .",
    "@xmath239 is on the path of @xmath238 , and @xmath238 fills a lexicographically smaller list of unfilled capacity channels at @xmath115 ( i.e. ones not filled by higher priority labels according to the label prioritization scheme described below ) outward from @xmath115 than @xmath239 does , or there is a tie and @xmath238 travels farther from @xmath115 than @xmath239 does [ lb ] .",
    "the lexicographic order is on lists of indexing positions for sublists of the ordering on capacity channels given within our label prioritization scheme below .",
    "3 .   the paths of @xmath238 and @xmath239 share at least one directed edge @xmath208 for @xmath244 , and",
    "if we let @xmath210 denote the final shared edge , then @xmath239 is closer than @xmath238 to @xmath228 ( in the sense of definition  [ distance - defn ] ) , but @xmath238 travels farther than @xmath239 does from @xmath223 ( again as in definition  [ distance - defn ] ) [ lc ]    additionally , @xmath237 if the paths of @xmath238 and @xmath239 share a vertex @xmath121 but no common edge , and one of the following conditions is met :    1 .",
    "@xmath245 are in parts @xmath246 , respectively , of some coarsening with respect to a common ancestor @xmath121 , while @xmath238 and @xmath239 have destination parts @xmath247 and @xmath248 , respectively , with @xmath249 and @xmath250 [ le ] 2 .",
    "@xmath251 and @xmath252 with @xmath249 for @xmath246 parts in some coarsening with respect to a common ancestor @xmath121 , while @xmath253 are in the same part with respect to all possible coarsenings , and @xmath254 is an ancestor of @xmath121 which is an ancestor of @xmath255 .",
    "[ lf ] 3 .",
    "@xmath115 is a descendent of @xmath114 , @xmath121 is an ancestor of @xmath256 and @xmath257 , but @xmath258 precedes @xmath259 in depth - first - search order . [ lg ] 4 .",
    "@xmath260 , @xmath261 , and @xmath114 comes later than @xmath115 in depth - first - search order [ lh ]    [ inv - def ] a node pair @xmath113 forms an _ inversion pair _ in a tree labeling @xmath41 , denoted @xmath262 , if there are labels @xmath263 and @xmath264 forming a label inversion pair .    the tree labelling in figure  [ tree - label ] has inversions pairs @xmath265 and @xmath266 between neighboring nodes resulting from label inversions of type e1 , but has no inversions pairs in which both nodes belong to the set @xmath267 .",
    "( 250,125)(-15,10 )    * label prioritization scheme : * given a vertex @xmath121 and a collection of labels , first we prioritize edges , then will use the resulting ordering on the edges to prioritize labels . begin by ordering the edges incident to @xmath121 according to definition  [ edge - priority ] .",
    "then apply the list augmentation procedure below to add to the edge list all remaining tree edges .",
    "now use this edge list to order the labels as follows .",
    "repeatedly give highest priority among labels not yet chosen to the label whose path from @xmath121 to its destination includes the lexicographically smallest sublist of capacity channels in the edge list that are not filled by any earlier labels in the label list .",
    "keep repeating to obtain an ordering on all the labels .    *",
    "list augmentation procedure : * proceed through a given ordered list of edges sequentially . upon encountering an edge @xmath210 , append to the end of the list all @xmath268 for this fixed @xmath228 which are not yet in the list ,",
    "ordering those travelling farthest from @xmath228 ( as in definition  [ distance - defn ] , parts ( 2 ) and ( 3 ) applied to labels traversing these edges ) earliest .",
    "continue through the list until no further such augmentation is possible .",
    "[ unique - redistrib ] for each pair of vertices @xmath245 in a labelled tree , there is a unique redistribution of the set of labels collectively assigned to @xmath114 and @xmath115 such that @xmath113 is not an inversion pair in the relabelled tree .",
    "let @xmath269 be the path from @xmath114 to @xmath115 .",
    "for each capacity channel of @xmath114 or @xmath115 not involving any edges in @xmath269 , the inversion - free labeling will assign to @xmath114 ( resp .",
    "@xmath115 ) the highest priority label using that capacity channel , if any such label is available .",
    "the remaining labels must be assigned so as to avoid two labels traversing the same edge in opposite directions , which means that the vertex among @xmath245 having excess capacity will receive all the labels destined for it or outward from it across capacity channels not involving any edges in @xmath269 , as well as perhaps some additional labels .    for each label @xmath224 under consideration",
    ", there is a unique vertex @xmath270 such that the path from @xmath31 to @xmath271 only intersects @xmath269 in @xmath31 .",
    "this enables us to partition the labels to be assigned to @xmath245 according to their associated vertices in @xmath269 . by definition  [ label - inv - def ] , part e1",
    ", there is some vertex @xmath272 such that all labels associated to @xmath273 with @xmath274 closer than @xmath223 to @xmath114 must be assigned to @xmath114 in our inversion - free redistribution , and on the other hand all labels associated to @xmath275 having @xmath276 closer than @xmath223 to @xmath115 must be assigned to @xmath115 in the inversion - free labelling .",
    "this just leaves the labels associated to @xmath223 , but then conditions e3 and v1-v4 of definition  [ label - inv - def ] determine uniquely how to distribute to @xmath114 and @xmath115 these remaining labels .",
    "the unique inversion - free labelling of a component with a proscribed set of labels is its base - labelling , as defined next .",
    "figure  [ base - label ] gives an example of a base - labelling of a component .",
    "notice that this is a part of the tree labelling given in figure  [ tree - label ] .",
    "( 250,125)(-20,10 )    [ base - label - def ] the _ base - labelling _ of a component @xmath26 ( of a forest obtained by deleting edges from a distributable capacity tree @xmath1 ) with a specified set of labels is as follows .",
    "if @xmath26 consists of a single vertex of @xmath1 , then all labels are assigned to the unique vertex of @xmath26 , so henceforth assume @xmath277 .",
    "let @xmath13 be the maximal set of edges of @xmath26 which may be removed to yield a forest , each of whose components @xmath278 has exactly as much capacity as the number of labels destined either for @xmath278 or across edges from @xmath278 to components outside @xmath26 .",
    "call this set of labels @xmath279 . assign to each such",
    "@xmath278 exactly the labels in @xmath279 , associating them to specific nodes within @xmath278 as described next .",
    "obtain a directed graph on vertex set @xmath280 by orienting each edge of the induced subgraph on @xmath280 from the portion of @xmath278 with excess capacity towards the portion with insufficient capacity .",
    "now we specify for each sink @xmath31 in this digraph the set of labels to be assigned to @xmath31 ; this will be a subset of the labels either destined for @xmath31 or across edges @xmath206 for @xmath281 . for each capacity channel @xmath206 for @xmath281 , assign to @xmath31 the highest priority label traversing @xmath206 according to the label prioritization scheme below . by remark  [ distrib - intuition ] , we always have enough capacity to do this .",
    "then exhaust as much of the remaining capacity at @xmath31 as possible by greedily assigning additional labels to @xmath31 whose paths involve edges from @xmath31 to other components , using the label prioritization scheme below to prioritize which labels are chosen .",
    "break ties by choosing labels traveling farthest as in definition  [ distance - defn ] .",
    "fill any remaining vacancies at @xmath31 with labels destined for @xmath31 , doing so in the unique way that is inversion - free according to definition  [ inv - def ] .",
    "since @xmath31 is a sink , there will be enough such labels available to saturate @xmath31 .",
    "once we thereby saturate @xmath31 , remove @xmath31 from consideration , causing new nodes to become sinks and potentially splitting what remains of @xmath278 into multiple components ; keep repeating until each vertex in @xmath278 has been assigned as many labels as its capacity . if @xmath282 has multiple edges in @xmath278 leading to it just prior to its deletion , distribute as follows the unassigned labels of @xmath278 to the various components into which @xmath278 splits upon deleting @xmath31 .",
    "each component receives exactly as many of @xmath31 s excess labels as the capacity discrepancy across the edge from @xmath31 to that component ; specific excess labels are distributed to these components in the unique way that is inversion - free according to definition  [ inv - def ] .",
    "this is made possible by the fact that each label is an excess label for at most one sink at any given time  because at any stage at most one sink is on the label s path to its destination within the entire tree ( i.e. not just within @xmath278 ) .",
    "the _ base - labelling of a face _ is comprised of the base - labellings of its various components with their proscribed sets of labels .",
    "the _ inversions _ of a face are the inversions in its base - labelling .",
    "[ inv - meets ] definition  [ inv - def ] specifies a full inversion function , hence its restriction to neighboring pairs of nodes is an inversion function .",
    "it is straightforward to check the consistency and completeness of definitions  [ base - label - def ] ,  [ label - inv - def ] , and that base - labellings are inversion free ; this can be seen by drawing a few diagrams of different types of trees showing how definition  [ label - inv - def ] covers the various ways the paths of two labels may intersect . what remains is to verify that definition  [ inv - def ] satisfies the requirements from definition  [ inv - fun - def2 ] for a full inversion function .",
    "the fact that an inversion @xmath283 forces an inversion of two neighboring vertices on the path from @xmath114 to @xmath284 follows directly from the fact that traditional inversions in permutations have this property , together with our base - labelling algorithm ( i.e. definition  [ base - label - def ] ) which puts labels headed across the various capacity channels at nodes incident to these channels .",
    "this gives property ( 1 ) of definition  [ inv - fun - def2 ] .",
    "the first part of our base - labelling algorithm , i.e. the splitting into components @xmath278 by deleting all possible edges having 0 flow , ensures that for each @xmath285 , i.e. any face @xmath12 obtained by merging components of @xmath36 , that if @xmath36 is inversion free on the restriction of @xmath36 to any component of @xmath12 , then the base - labellings of @xmath36 and @xmath12 coincide on the restriction of @xmath36 to any component of @xmath12 . this confirms property ( 2 ) of definition  [ inv - fun - def2 ] .",
    "next , we show that the transitive closure of @xmath286 is a partial order , i.e. property ( 3 ) of definition  [ inv - fun - def2 ] .",
    "this is accomplished by verifying that the following integer - valued function @xmath287 on tree labellings satisfies @xmath288 for each @xmath289 . for @xmath41 a tree labelling , let @xmath290 be the number of labels at @xmath114 in @xmath41 that are assigned to @xmath115 in the unique redistribution @xmath291 of labels between @xmath114 and @xmath115 satisfying @xmath292 .",
    "lemma  [ unique - redistrib ] guarantees the existence of such a @xmath291 .",
    "now let @xmath293 with @xmath294 denoting distance in the usual graph - theoretic sense .",
    "let @xmath295 for @xmath235 and @xmath296 in the tree labelling @xmath41 .",
    "consider @xmath289 for @xmath297 .",
    "if @xmath298 , then @xmath299 , so we need only consider the contribution of pairs @xmath20 with @xmath300",
    ". for notational convenience , say @xmath301 throughout the following argument ; other cases are similar .",
    "suppose @xmath302 .",
    "consider @xmath303 for @xmath304 located at @xmath305 , respectively .",
    "then @xmath306 with @xmath307 unless @xmath308 swaps @xmath309 with some @xmath224 , and we have @xmath310 . there may be a choice of such @xmath224 , but any choice will work , provided our collection of such choices comprises a matching on pairs of values in @xmath311 being swapped between nodes @xmath312 and @xmath313 . if @xmath314 , then @xmath315 and @xmath316 . if @xmath317 , then @xmath318 is on the path from @xmath224 to @xmath115 in @xmath41 with @xmath319 and @xmath320 . in each case , the pairs @xmath321 and @xmath322 together contribute at least as much to @xmath323 as to @xmath324 .",
    "summing over all choices of @xmath325 such that @xmath326 yields @xmath327 . finally , @xmath328 while @xmath329 , yielding @xmath330 , as desired . property ( 4 ) of definition  [ inv - fun - def2 ] , namely restriction to subtrees of the other properties , is immediate again from our definition of base - labelling .",
    "a different choice of edge set @xmath57 which yields a capacity distributable tree will give a shelling of @xmath331 for @xmath332 namely , let @xmath57 consist of the edges from each vertex @xmath31 to its first @xmath333 children , together with the edge from the root to its only child .",
    "now apply theorem  [ finish - shell ] . in cases such as chessboard complexes with nodes of high degree",
    ", this gives an improved connectivity lower bound .",
    "next we recover a shellability result from [ zi ] .",
    "choose any edge set @xmath335 for @xmath1 a star with @xmath44 leaves .",
    "consider the subcomplex of @xmath336 generated by those faces @xmath36 with @xmath337 .",
    "these @xmath36 give rise to distributable capacity trees if and only if @xmath338 .",
    "thus , results of earlier sections yield shellability of @xmath339 for @xmath340 , hence shellability of @xmath6 for @xmath341 .",
    "our results do not yield the optimal connectivity bound for chessboard complexes in general , regardless of our choice of @xmath57 .",
    "it is interesting to note that an @xmath21-dimensional type - selected complex @xmath87 may not be shellable while the full @xmath21-skeleton of @xmath0 may still be shellable . it would be interesting to find the optimal connectivity bound for each @xmath0 , or more generally for each @xmath342 , the latter of which would include the chessboard complexes as a special case .    in [ he ] , we generalize ziegler s proof of vertex decomposability of skeleta to trees with one non - leaf vertex as well as long exact sequences of shareshian and wachs from [ sw ] .",
    "this enables a sharpness result , in the sense that we characterize exactly which trees @xmath58 have shellable coxeter - like complexes .",
    "however , the question of a sharp connectivity bound remains open for general coxeter - like complexes .",
    "let @xmath343 be the largest degree of any vertex in a tree @xmath1 .",
    "then the fact that ziegler s vertex decomposition for the @xmath344-skeleton of a chessboard complex generalizes to the link of each face @xmath345 together with the above theorem also suggests the following question .",
    "earlier sections prove a conjecture of babson and reiner by showing that the @xmath5-skeleton is shellable , where @xmath4 is the number of leaves in @xmath1 .",
    "notice that @xmath347 holds , since each edge outward from a fixed vertex @xmath31 of maximal degree leads to a subtree with at least one leaf in it .",
    "thus , an affirmative answer would give an improved connectivity bound for @xmath0 ."
  ],
  "abstract_text": [
    "<S> in their work on ` coxeter - like complexes ' , babson and reiner introduced a simplicial complex @xmath0 associated to each tree @xmath1 on @xmath2 nodes , generalizing chessboard complexes and type a coxeter complexes . </S>",
    "<S> they conjectured that @xmath0 is @xmath3-connected when the tree has @xmath4 leaves . </S>",
    "<S> we provide a shelling for the @xmath5-skeleton of @xmath0 , thereby proving this conjecture .    in the process , we introduce notions of weak order and inversion functions on the labellings of a tree @xmath1 which imply shellability of @xmath0 , and we construct such inversion functions for a large enough class of trees to deduce the aforementioned conjecture and also recover the shellability of chessboard complexes @xmath6 with @xmath7 . </S>",
    "<S> we also prove that the existence or nonexistence of an inversion function for a fixed tree governs which networks with a tree structure admit greedy sorting algorithms by inversion elimination and provide an inversion function for trees where each vertex has capacity at least its degree minus one . </S>"
  ]
}