{
  "article_text": [
    "software - defined networking ( sdn ) holds great promises to improve network performance and management . the key idea of sdn",
    "is to decouple the control plane from the data plane @xcite .",
    "data plane can focus on performing basic functionalities such as packet forwarding at high speed , while the logically centralized control plane manages the network .",
    "usually , switches at data plane send requests to control plane for processing some flow events , e.g. flow - install events .",
    "the control plane is a potential bottleneck of sdn in terms of scalability and reliability .",
    "as the data plane expands , control plane may not be able to process the increasing number of requests if implemented with a single controller , resulting unacceptable latency to flow setup .",
    "reliability is also an issue since a single controller is a single point of failure , resulting in disastrous break - down of the control plane and the network .",
    "existing proposals to address such problems fall broadly into two categories .",
    "one is to implement the control plane as a distributed system with multiple controllers @xcite @xcite .",
    "each switch then associate with certain controllers for fault - tolerance and load balancing @xcite @xcite@xcite@xcite .",
    "the other is to devolve partial loads of request processing from controllers to switches @xcite @xcite @xcite , reducing the work load of controllers .    for switch - controller association , the first category of solution , initial design choice is to make a static switch - controller association @xcite @xcite .",
    "however , such static association may result in overloading of controllers and increasing flow setup latency due to its inflexibility to handle traffic variations .",
    "an elastic distributed controller architecture is proposed in @xcite , with an efficient protocol to migrate switches across controllers .",
    "however , it remains open to determine the switch - controller association .",
    "then @xcite took a step further by formulating the switch - controller association problem as a deterministic optimization problem , i.e. , an integer linear problem with prohibitively high computational complexity .",
    "a local search algorithm was proposed to find suboptimal associations within a given time limit ( e.g. , 30 seconds ) . in @xcite ,",
    "the controller is assumed to be modeled as m / m/1 queue ( poisson arrival and exponential service ) . under such assumption ,",
    "the switch - controller association problem with steady - state objective function was formulated as a many - to - one stable matching problem with transfers . then a novel two - phase algorithm was proposed to connect stable matching with utility - based game theoretic solutions , i.e. , coalition formation game with nash stable solutions .    for control devolution ,",
    "the second category of solution , an obvious design choice is static devolution for certain functions and flows @xcite @xcite @xcite ; i.e. , switches locally process requests that do not require network - wide state , such as link - layer discovery service .",
    "static devolution mitigates the loads on control plane in some ways , but it could be inflexible in face of traffic variations . as an alternative",
    ", dynamic devolution allows switches to decide processing those requests locally or uploading them to control plane , depending on their amounts of loads at the moment .",
    "however , the design of dynamic devolution with respect to traffic variations remains open .",
    "then several interesting questions are raised and answers to such questions will definitely shape our design for sdn networks :    * instead of deterministic switch - controller association with infrequent re - association @xcite @xcite , can we directly perform dynamic switch - controller association with respect to the traffic variation ? what is the benefit that we can obtain from a fine - grained control at the request level ? * how to perform dynamic devolution ? * how to make a trade - off between dynamic switch - controller association and dynamic control devolution ?    in this paper , we consider a general sdn network with traffic variations , resulting variations of requests to handle with flow events .",
    "we assume each request can be either processed at switch ( incurs computation costs ) or be uploaded to certain controllers ( incurs communication costs ) .",
    "we aim at reducing the computational cost by control devolution at data plane , the communication cost by switch - controller association between data plane and control plane , and the response time experienced by switches , which is mainly caused by queueing delay on controllers . under such settings",
    ", we provide a new perspective and a novel scheme to answer those questions .",
    "our key results and contributions are summarized as follows :    * _ problem formulation _ : according to the best of our knowledge , this paper is the first to study the joint optimization problem of dynamic switch - controller association and dynamic control devolution . *",
    "_ finer granularity control _ :",
    "according to the best of our knowledge , this paper is the first to perform the control decisions at the granularity of request - level .",
    "note that request - level information such as time - varying queue backlog sizes and number of request arrivals presents the actual time - varying state of data plane .",
    "hence it d help for more accurate decision making of dynamic association and dynamic devolution when compared to coarse - grained control . * _ online algorithm design_ we formulate a stochastic network optimization problem , aiming at minimizing the long - term average sum of communication cost and computational cost , while keeping time - average queue backlogs of both switches and controllers small . by employing lyapunov drift technique @xcite and exploiting sub - problem s structure",
    ", we develop an efficient greedy algorithm to achieve optimality asymptotically .",
    "our algorithm is online , which means it does not need the statistics of traffic workloads and does not need the prior assumption of traffic distribution .",
    "* _ algorithm analysis _ : we show that our algorithm yields a tunable trade - off between @xmath1 deviation from minimum long - term average sum of communication cost and computational cost and @xmath2 bound for average queue backlogs . we also find that the positive parameter @xmath0 determines the switches willingness of uploading requests to controllers , i.e. , performing switch - controller association .",
    "* _ simulation _ : we conduct large - scale trace - driven simulations to evaluate the performance of our algorithm within two widely adopted data center networking topologies , i.e. , canonical 3-tiered topology and fat - tree topology .",
    "simulation results verify the effectiveness and the trade - off of our algorithm .",
    "in addition , in the extreme case that without control devolution , we compare our dynamic association scheme with other association schemes including static , random , and jsq ( join - the - shortest - queue ) .",
    "simulation results verify the advantages of our scheme .",
    "we organize the rest of paper as follows .",
    "we present the basic idea and formulation in section ii .",
    "then we show our algorithm design and corresponding performance analysis in section iii . in section iv",
    ", we present simulation results .",
    "we conclude this paper in section v.",
    "in this section , we first provide a motivating example for the dynamic switch - controller association and dynamic control devolution . then we introduce the system model and formulate the problem .",
    "the example of dynamic association and devolution is shown in fig .",
    "[ fig_sim ] .",
    "first , we focus on the behavior of @xmath3 . in fig .",
    "[ fig_sim ] ( b ) , @xmath3 chooses to process its requests locally , and that incurs a computational cost of 2 per request . in fig .",
    "[ fig_sim ] ( c ) , @xmath3 decides to upload requests to @xmath4 and that incurs a communication cost of 3 per request .",
    "although the computational cost is less than communication cost , the decision of locally processing leaves one request not processed yet at the end of the time slot .",
    "hence , it is non - trivial to decide when to trade computational cost off communication cost .",
    "second , we focus on the behavior of associations .",
    "[ fig_sim ] ( b ) and ( c ) show two different associations .",
    "[ fig_sim ] ( b ) shows the switch - controller association with @xmath5 and @xmath6 ( @xmath3 processes requests locally ) , denoted by @xmath7 .",
    "@xmath7 incurs the total cost of communication and computation by @xmath8 but results in uneven queue backlogs , leaving four requests unfinished after time slot @xmath9 .",
    "[ fig_sim ] ( c ) shows another association with @xmath5 and @xmath10 ( @xmath11 processes requests locally ) , denoted by @xmath12 .",
    "@xmath12 incurs the total cost by @xmath13 but does better in balancing queue backlogs .",
    "thus there is a non - trivial trade - off between minimizing the total cost of communication and computation and maintaining small queue backlogs in each controller .",
    "we consider a time slotted network system , indexed by @xmath14 .",
    "its control plane comprises a set @xmath15 of physically distributed controllers , while its data plane consists of a set of switches @xmath16 .",
    "each switch @xmath17 keeps a queue backlog of size @xmath18 for locally processing requests , while each controller @xmath19 maintains a queue backlog @xmath20 that buffers requests from data plane .",
    "we denote @xmath21 $ ] as @xmath22 and @xmath23 $ ] as @xmath24 .",
    "we use @xmath25 to denote @xmath26 $ ] .    at the beginning of time",
    "slot @xmath9 , each switch @xmath17 generates some amounts @xmath27 of requests .",
    "then each switch could choose to process its requests either locally or by sending to its associated controller .",
    "we assume that each switch @xmath17 has a service rate @xmath28 to process the devoluted requests , while each controller @xmath19 has an available service rate @xmath29 .",
    "we denote @xmath30 $ ] as @xmath31 , @xmath32 $ ] as @xmath33 , and @xmath34 $ ] as @xmath35 . for @xmath17 and @xmath19 ,",
    "we assume that all @xmath36 , @xmath37 , and @xmath38 are i.i.d . ;",
    "besides , their first and second raw moments are all finite .",
    "then the scheduler collects system dynamics information @xmath39 during current time slot and makes a scheduling decision , denoted by an association matrix @xmath40 . here",
    "if switch @xmath42 will be associated with controller @xmath43 during current time slot and @xmath44 otherwise .",
    "an association is feasible if it guarantees that each switch is associated with at most one controller during each time slot .",
    "we denote the set of feasible associations as @xmath45 , @xmath46    according to the scheduling decision , each switch @xmath42 sends its request to controller @xmath43 if @xmath47 .",
    "however , if @xmath48 , switch @xmath42 appends its requests to local queue backlog .",
    "then both switches and controllers serve as many requests in their queues as they could . as a result ,",
    "the update equation for @xmath18 at switch @xmath42 is @xmath49^{+ } \\end{array}\\ ] ] and the update equation for @xmath20 at controller @xmath43 is given by @xmath50^{+ } \\end{array}\\ ] ] where @xmath51^{+ } = \\max(x,0)$ ] .",
    "having covered the necessary notations and queueing dynamics , we switch to the objective and constraints of our problem .",
    "we define the communication cost between switch @xmath42 and controller @xmath43 as @xmath52 .",
    "accordingly , we have a communication cost matrix @xmath53 .",
    "fixing some association @xmath54 , the communication cost within one time slot is @xmath55 where we can view @xmath52 as the price of transmitting one request from switch @xmath42 to controller @xmath43 . then , given a series of associations @xmath56 , the time - average communication cost is shown as follows @xmath57      there is a computational cost @xmath58 for each devoluted request to @xmath42 when switch @xmath42 appends its requests to its local queue backlog for processing .",
    "given some association @xmath54 , we define the one - time - slot computational cost as @xmath59 given a series of associations @xmath56 , the time - average computational cost is @xmath60      a queueing process @xmath61 is stable , if the following condition holds : @xmath62 accordingly , @xmath22 is stable if @xmath63 and @xmath24 is stable if @xmath64    queueing stability implies that both switches and controllers would process buffered requests timely , so that queueing delay is controlled within a small range .",
    "consequently , our problem formulation is given as follows @xmath65",
    "to design a scheduling algorithm that solves problem ( [ ori - opt - pr ] ) , we adopt the lyapunov optimization technique in @xcite .",
    "define the quadratic lyapunov function as @xmath66    next , we define the conditional lyapunov drift for two consecutive time slots as @xmath67    this conditional difference measures the general change in queues congestion state .",
    "we want to push such difference as low as possible , so as to prevent queues @xmath24 and @xmath22 from being overloaded .",
    "however , to maintain low queue backlogs , the action we take might incur considerable communication cost @xmath68 or computational cost @xmath69 , or both .",
    "hence , we should jointly consider both queueing stability and @xmath70",
    ".    given any feasible association @xmath71 , we define one - time - slot conditional drift - plus - penalty function as @xmath72 where @xmath68 is defined by ( [ def - commcost ] ) , @xmath69 is defined by ( [ def - offload ] ) , and @xmath73 is a constant that weights the penalty brought by @xmath68 and @xmath69 .    by minimizing the upper bound of the drift - plus - penalty expression ( [ cond - v - drift ] ) , the time average of communication cost can be minimized while stabilizing the network of request queues .",
    "we employ the concept of _ opportunistically minimizing an expectation _ in @xcite , and we transform the long - term stochastic optimization problem ( [ ori - opt - pr ] ) into the following drift - plus - penalty minimization problem at every time slot @xmath9 . @xmath74 + \\\\      & \\displaystyle \\sum_{i \\in \\mathcal{s } } q^s_i(t ) \\cdot \\left [ ( 1 - \\sum_{j \\in \\mathcal{c } } \\mathbf{x}_{i , j } ) \\cdot a_i(t ) \\right ] \\\\      \\end{array}\\ ] ]    after rearranging the terms in ( [ obj - fn ] ) , our optimization problem turns out to be @xmath75 a_i(t ) + \\sum_{i \\in \\mathcal{s } } \\sum_{j \\in \\mathcal{c } }               \\left [ v w_{i , j } + \\right . \\\\          & \\displaystyle           \\left .",
    "q_j^c(t ) - v\\alpha_i - q^s_i(t ) \\right ] \\mathbf{x}_{i , j } a_i(t )",
    "\\\\      \\end{array}\\ ] ]    since the first term @xmath76 $ ] in ( [ opt - pr ] ) has nothing to do with @xmath71 , then we fix it as constant and put our focus on minimizing the second term of ( [ opt - pr ] ) only . for each @xmath17 , we split @xmath15 into two disjoint sets @xmath77 and @xmath78 , i.e. @xmath79 .",
    "@xmath80 @xmath81 note that @xmath82 and for switch @xmath42 , @xmath83 . therefore , for each switch @xmath17 , @xmath84 \\mathbf{x}_{i , j } a_i(t ) \\\\          = & \\displaystyle               \\left\\ {               \\sum_{j \\in \\mathcal{j}^{i}_1 } \\left [ v w_{i , j } +   q_j^c(t ) - v\\alpha_i - q^s_i(t ) \\right ] \\mathbf{x}_{i , j } + \\right . \\\\          & \\displaystyle \\left .",
    "\\sum_{j\\in\\mathcal{j}^{i}_2 } \\left [ v w_{i , j } +   q_j^c(t ) - v\\alpha_i - q^s_i(t ) \\right ] \\mathbf{x}_{i , j }              \\right\\ } a_i(t )      \\end{array}\\ ] ]    next we show how to minimize ( [ 1stterm ] ) . given @xmath85",
    ", we define @xmath86 then we consider two different cases .    * if @xmath87 , i.e. , @xmath88 for all @xmath19 , then the only way to minimize ( [ 1stterm ] ) is setting @xmath89 for all @xmath19 . *",
    "if @xmath90 , then we handle with @xmath91 for @xmath92 and @xmath93 separately . * * for @xmath92 , it is not hard to see @xmath89 for @xmath92 . * * for @xmath93 , @xmath94",
    ". then we should make @xmath95 for such @xmath96 that @xmath97 + and @xmath89 for @xmath98 .",
    "in such a way , given any @xmath99 , for switch @xmath42 the following always holds @xmath100 \\cdot 0 + \\underset{j \\in \\mathcal{j}^i_2}{\\min } \\omega(i , j ) \\\\",
    "= & \\displaystyle \\sum_{j\\in\\mathcal{j}^{i}_1 } \\omega(i , j ) \\cdot \\mathbf{x}^*_{i , j } +                   \\sum_{j\\in\\mathcal{j}^{i}_2 } \\omega(i , j ) \\cdot \\mathbf{x}^*_{i , j }              \\end{array}\\ ] ]    therefore , the above process shows us how to minimize ( [ opt - pr ] ) .",
    "then we have the algorithm shown as follows :    during time slot @xmath9 , the scheduler collects queue lengths information from individual controllers and switches , i.e. @xmath22 , @xmath24 , and @xmath31 a scheduling association @xmath101 + start with an empty set @xmath102 split all controllers @xmath15 into two sets @xmath77 and @xmath78 , where @xmath103 and + @xmath104 + if @xmath105 , then skip current iteration .",
    "if @xmath106 , then choose controller @xmath107 such that @xmath108 @xmath109 + @xmath110 + _ according to @xmath110 , switches upload requests to controllers or append requests to their local queues .",
    "then controllers and switches update their queue backlogs as in ( [ ueq for s ] ) and ( [ ueq for c ] ) after serving requests . _",
    "* remarks : *    * our algorithm is greedy since it greedily associates each switch with controllers that either with small queue backlog size or close to the switch , and otherwise it leaves all requests locally processed . * for switch @xmath42 ,",
    "given any controller @xmath43 far enough from @xmath42 , i.e. , @xmath111 , switch @xmath42 decides to upload requests to @xmath43 only if @xmath112 is non - positive and smaller than any other .",
    "this requires switch @xmath42 itself holds enough requests locally , i.e. , @xmath113 .",
    "then it will upload requests .",
    "thus smaller @xmath0 will invoke more effectively the willingness of switch @xmath42 to upload requests to control plane .",
    "* on the other hand , given any controller @xmath114 close to switch @xmath42 , i.e. , @xmath115 , switch @xmath42 will process requests locally if control plane holds large amounts of requests , i.e. , @xmath116 . thus given any large @xmath0 , controllers will have to hold great loads of requests before switches become willing to process requests locally . * therefore , the parameter @xmath0 actually controls switches willingness of uploading requests to controllers , i.e. , performing switch - controller association . in other words , it controls the trade - off between communication cost and the computational cost , which are incurred by uploading requests to control plane and locally processing , respectively .",
    "now we turn to time complexity analysis of our algorithm . within each time slot , the algorithm runs @xmath117 iterations in total . for each switch @xmath42",
    ", it takes @xmath118 steps to split @xmath15 into two disjoint sets .",
    "if the resulting @xmath90 , then the algorithm needs to calculate @xmath112 for each controller ( @xmath119 controllers in total ) and picks up @xmath96 for the minimum @xmath112 .",
    "for each switch - controller pair @xmath120 , calculating @xmath112 incurs only constant time according to ( [ weight - fn ] ) .",
    "therefore , during each time slot , our algorithm takes about @xmath121 time to decide the optimal switch - controller association .",
    "in fact , our algorithm can also run in a parallel manner : i.e. , for each switch @xmath42 , given @xmath122 , @xmath22 , @xmath18 , and @xmath36 , the scheduler can decide its associated controller independently from other switches .",
    "next we characterize the performance of our algorithm .",
    "we suppose @xmath123 and @xmath124 are the infimum of time - average computational cost and communication cost that we want to achieve , respectively .",
    "we also suppose @xmath125 .",
    "the we have the following theorem on the @xmath126 trade - off between costs and queue backlogs :    given the parameters @xmath127 , @xmath128 , and constant @xmath129 , then the queue vector process @xmath25 is stable ; besides , the time - average expectation of communication cost and computational cost , as well as queue backlogs on switches and controllers satisfy : @xmath130              & \\\\              \\displaystyle \\le \\frac{k + v \\cdot ( f^ * + g^ * ) } { \\epsilon } \\\\      \\end{array}\\ ] ]",
    "* topology : * in this section , we evaluate our * greedy * scheduling algorithm under two widely adopted topologies : canonical 3-tiered topology and fat - tree@xcite topology .",
    "we show two of their instances in fig . [ topo_3tiered ] and fig .",
    "[ topo_fattree ] , respectively .    .",
    "@xmath114 denotes the number of core switches . in this paper ,",
    "the number of aggregate switches is also set to @xmath114 , and each connects to @xmath131 edge switches .",
    "the total number of switches is @xmath132 .",
    "each edge switch is directly connected to @xmath133 hosts .",
    "therefore , there are @xmath134 hosts in total.,scaledwidth=45.0% ]    .",
    "@xmath114 denotes the number of pods . the number of core , aggregate , edge switches are @xmath135 , @xmath136 , @xmath136 , respectively .",
    "and the total number of switches is @xmath137 .",
    "each edge switch is directly connected to @xmath133 hosts .",
    "accordingly , there are @xmath138 hosts in total.,scaledwidth=45.0% ]    to make our performance analysis comparable in both topologies , we construct a fat - tree network and a canonical 3-tiered network with almost the same number of switches . regarding the canonical 3-tiered topology , we set the number of core switches as @xmath139 .",
    "accordingly , the total number of switches is @xmath140 .",
    "regarding the fat - tree topology , we set the port number as @xmath141 and thusly there are @xmath142 switches in total .",
    "note that the two resulting topologies are also comparable to the size of commercial data centers @xcite .    in both topologies , we deploy controllers on the hosts ( one controller for every two pods ) , which are denoted by the blue circles in fig . [ topo_3tiered ] and fig .",
    "[ topo_fattree ] .    * traffic workloads : * we conduct trace - driven simulations , where the flow arrival process on each switch follows the distribution of flow inter - arrival time in @xcite , which is drawn from measurements within real - world data centers . in @xcite ,",
    "the average flow inter - arrival time is about @xmath143 .",
    "we then set the length of each time slot as @xmath144 .",
    "accordingly , the average flow arrival rate on each switch is about @xmath145 flows per time slot .",
    "in fact , there do exist hot spots within pods in real - world data center networks , where the switches have significantly high flow arrival rates . in our simulation , we pick the first pod as a hot spot and all switches there have significantly high flow arrival rate , i.e. , @xmath146 flows per time slot . as for controllers ,",
    "we set their individual capacity as @xmath147 flows per time slot .",
    "that is consistent with the capacity of a typical nox controller @xcite .",
    "* costs : * given any network topology , we define the communication cost @xmath52 between switch @xmath42 and controller @xmath43 as the length ( number of hops ) of shortest path from @xmath42 to @xmath43 .",
    "then we set a common computation cost @xmath148 for all switches , which equals to the average hop number between switches and controllers of its underlying topology . in fat - tree topology , @xmath149 ; while in 3-tiered topology , @xmath150 .      fig .",
    "[ trace](a ) presents how the summation of long - term average communication cost and computational cost changes with different @xmath0 in fat - tree and 3-tiered topologies .",
    "as @xmath0 varies from @xmath44 to @xmath151 , we can observe that the total cost goes down gradually .",
    "this is consistent with our previous theoretic analysis .",
    "the intuition behind such decline is as follows .",
    "remind that @xmath0 controls the switches willingness of uploading requests . for switches that are close to controllers ( their communication cost is less than the average ) , large @xmath0 makes them unwilling to process requests locally unless the controllers get too heavy load .",
    "as @xmath0 increases , those switches will choose to upload requests to further reduce the costs since for those switches , communication costs are less than the computation cost .",
    "another observation we make is that the total cost of 3-tiered topology is more than fat - tree s .",
    "the reason is that 3-tiered has a higher computational cost ( @xmath150 compared to @xmath152 ) and it cost more when switches process requests locally . in fig .",
    "[ pp](a ) , we also show the total cost of * greedy * in fat - tree topology with other two request arrival processes .",
    "the curves of poisson and pareto exhibit qualitatively similar decline in total cost , although pareto incurs slightly ( @xmath153 ) larger queue backlog size than poisson .",
    "[ trace](b ) shows the curve of total queue backlog size with different values of @xmath0 . from the figure",
    ", we notice that total queue backlog size increases until @xmath0 reaches about @xmath154 and @xmath155 in fat - tree and 3-tiered topologies , respectively .",
    "this is also consistent with the @xmath2 queue backlog size bound in ( [ th1 ] ) .",
    "recall our analysis in _ total cost _ : larger @xmath0 invokes most switches to spend more time uploading requests to control plane . however , control plane s service capacity is fixed and requests will keep accumulating .",
    "thus when @xmath0 becomes sufficiently large , control plane will eventually hold most of requests in the system .",
    "this explains the increasing queue backlog size in fig .",
    "[ trace](b ) .",
    "[ pp](b ) present the total queue backlog size in fat - tree topology when we apply * greedy * with request arrivals that follow poisson and pareto processes .",
    "note that we do not show that of 3-tiered topology because curves there almost overlap with those in fig .",
    "[ pp](b ) .      in this subsection",
    ", we consider the extreme case by setting common computational cost @xmath156 for all switches .",
    "this means the cost of local processing requests are prohibitively high and each time slot switches choose to upload requests to controllers .",
    "thus our greedy algorithm degenerates into a dynamic switch - controller association algorithm .",
    "we compare its performance with three other schemes : * static * , * random * and * jsq(join - the - shorest - queue)*. in static scheme , each switch @xmath42 chooses the controller @xmath43 with minimum communication cost @xmath52 and then fixes this association for all time slots .",
    "in random scheme , the scheduler randomly picks up a controller for each switch at each time slot . in jsq scheme",
    ", it randomly picks up one switch @xmath42 without replacement round by round until all switches have chosen the target controllers . at each round ,",
    "the selected switch @xmath42 chooses the controller @xmath43 with the smallest queue backlog size at present , and appends all its requests to @xmath43 s queue .",
    "[ cost_trace ] presents a comparison among * static * , * random * , * jsq * , and * greedy * in terms of communication cost under canonical 3-tiered topology and fat - tree , respectively .",
    "first , the communication cost under * static * is the minimum among all schemes , which is consistent with its goal of minimizing the overall communication cost .",
    "* greedy * cuts down the communication cost with increasing @xmath0",
    ". eventually , when @xmath0 is sufficiently large , communication cost stops decreasing and remains unchanged .",
    "both * random * and * jsq * exhibit much higher communication costs , compared to * greedy * and * static*.    fig .",
    "[ var_trace ] presents a comparison among the four schemes in terms of the variance of queue backlog size under canonical 3-tiered topology and fat - tree topology , respectively .",
    "in fact , smaller queue backlog size variance indicates better capability of load balancing .",
    "the variance of * static * grows exponentially with time , showing that * static * is incompetent in load balancing .",
    "the reason is that * static * greedily associates switches with their nearest controllers , ignoring different controllers loads . when it comes to * random * and * jsq * , the variance is almost @xmath44 , which shows the two schemes advantage in load balancing .",
    "while the variance of * greedy * is in between the other three : it increases at the beginning and then remains stable after about thousands of time slots . furthermore , * greedy * exhibits higher variance of queue backlog size with larger @xmath0 , i.e. , the load of controllers is more imbalanced .    fig .",
    "[ qlen_trace ] presents a comparison among the four schemes in terms of the average queue backlog size under canonical 3-tiered topology and fat - tree topology , respectively . actually , the observations in fig .",
    "[ qlen_trace ] are very consistent with that of fig .",
    "[ var_trace ] .",
    "intuitively , the more balanced the load of controller is , the smaller of the average queue backlog size . in fig .",
    "[ var_trace ] , the variance of * static * is high while that of * random * and * jsq * are almost @xmath44 , so the average queue backlog size of * static * is large while that of * random * and * jsq * is small in fig .",
    "[ qlen_trace ] . as for * greedy",
    "* , the variance increases with @xmath0 in fig .",
    "[ var_trace ] , so the average queue backlog size of * greedy * rises as @xmath0 increases as shown in fig .",
    "[ qlen_trace ] .",
    "in addition to trace - driven simulation , we also conduct the comparison under other two assumptions of flow arrival processes , i.e. , _ poisson _ and _ pareto _ processes .",
    "they two are widely adopted in traffic analysis .",
    "we only show the simulation results under fat - tree topology , because the simulation results in 3-tiered topology is qualitatively similar to that in fat - tree topology .",
    "[ cost ] shows the communication cost comparison when the flow arrival process follows poisson and pareto , respectively .",
    "[ qlen ] shows the average queue backlog size comparison when the flow arrival process follows poisson and pareto processes , respectively .",
    "we can see from these figures that the scheduling policies perform qualitatively consistent under different arrival processes .    in summary , among four schemes , * static",
    "* is on the one end of performance spectrum : it minimizes communication cost while incurring extremely large queue backlogs ; both * random * and * jsq * are on the other end of performance spectrum : they minimize the average queue backlog while incurring much large communication costs . in contrast , our * greedy * scheme achieves a trade - off between minimization of communication costs and minimization of queue backlogs . through a tunable parameter @xmath0 , we can achieve different degrees of balance between cost minimization and latency ( queue backlog ) minimization .",
    "in this paper , we studied the joint optimization problem of dynamic switch - controller association and dynamic control devolution for sdn networks .",
    "we formulated the problem as a stochastic network optimization problem , aiming at minimizing the long - term average summation of total communication cost and computational cost while maintaining low time - average queue backlogs .",
    "we proposed an efficient online greedy algorithm , which yields a long - term average sum of communication cost and computational cost within @xmath157 of optimality , with a trade - off in an @xmath2 queue backlog size for any positive control parameter @xmath0 .",
    "extensive simulation results show the effectiveness and optimality of our online algorithm , and the ability to maintain a tunable trade - off compared to other dynamic association schemes .",
    "this work was supported in part by nsfc grant no.6130 2114 , and hong kong rgc crf - c7036 - 15 g .",
    "+    10 [ 1]#1 url@samestyle [ 2]#2 [ 2]l@#1=l@#1#2    n.  mckeown , t.  anderson , h.  balakrishnan , g.  parulkar , l.  peterson , j.  rexford , s.  shenker , and j.  turner , `` openflow : enabling innovation in campus networks , '' _ acm sigcomm computer communication review _",
    "38 , no .  2 ,",
    "pp . 6974 , 2008 .",
    "t.  koponen , m.  casado , n.  gude , j.  stribling , l.  poutievski , m.  zhu , r.  ramanathan , y.  iwata , h.  inoue , t.  hama _",
    "et  al . _ ,",
    "`` onix : a distributed control platform for large - scale production networks . '' in _ osdi _ , vol .  10 , 2010 , pp . 16",
    ".    a.  tootoonchian and y.  ganjali , `` hyperflow : a distributed control plane for openflow , '' in _ proceedings of the 2010 internet network management conference on research on enterprise networking _ , 2010 , pp .",
    "d.  levin , a.  wundsam , b.  heller , n.  handigol , and a.  feldmann , `` logically centralized ?",
    ": state distribution trade - offs in software defined networks , '' in _ proceedings of the first workshop on hot topics in software defined networks_.1em plus 0.5em minus 0.4emacm , 2012 , pp . 16 .",
    "a.  dixit , f.  hao , s.  mukherjee , t.  lakshman , and r.  kompella , `` towards an elastic distributed sdn controller , '' _ acm sigcomm computer communication review _ ,",
    "43 , no .  4 , pp . 712 , 2013 .",
    "a.  krishnamurthy , s.  p. chandrabose , and a.  gember - jacobson , `` pratyaastha : an efficient elastic distributed sdn control plane , '' in _ proceedings of the third workshop on hot topics in software defined networking_.1em plus 0.5em minus 0.4emacm , 2014 , pp .",
    "133138 .",
    "t.  wang , f.  liu , j.  guo , and h.  xu , `` dynamic sdn controller assignment in data center networks : stable matching with transfers , '' in _ proc . of infocom _ , 2016 .",
    "a.  r. curtis , j.  c. mogul , j.  tourrilhes , p.  yalagandula , p.  sharma , and s.  banerjee , `` devoflow : scaling flow management for high - performance networks , '' in _ acm sigcomm computer communication review _ , vol .",
    "41 , no .",
    "4.1em plus 0.5em minus 0.4emacm , 2011 , pp .",
    "254265 .",
    "s.  hassas  yeganeh and y.  ganjali , `` kandoo : a framework for efficient and scalable offloading of control applications , '' in _ proceedings of the first workshop on hot topics in software defined networks_.1em plus 0.5em minus 0.4emacm , 2012 , pp .",
    "k.  zheng , l.  wang , b.  yang , y.  sun , y.  zhang , and s.  uhlig , `` lazyctrl : scalable network control for cloud data centers , '' _ arxiv preprint arxiv:1504.02609 _ , 2015 .",
    "m.  j. neely , `` stochastic network optimization with application to communication and queueing systems , '' _ synthesis lectures on communication networks _ , vol .  3 , no .  1 ,",
    "pp . 1211 , 2010 .",
    "m.  al - fares , a.  loukissas , and a.  vahdat , `` a scalable , commodity data center network architecture , '' in _ acm sigcomm computer communication review _ , vol .",
    "38 , no .",
    "4.1em plus 0.5em minus 0.4emacm , 2008 , pp .",
    "t.  benson , a.  akella , and d.  a. maltz , `` network traffic characteristics of data centers in the wild , '' in _ proceedings of the 10th acm sigcomm conference on internet measurement_.1em plus 0.5em minus 0.4em acm , 2010 , pp . 267280 .",
    "a.  tootoonchian , s.  gorbunov , y.  ganjali , m.  casado , and r.  sherwood , `` on controller performance in software - defined networks , '' in _ presented as part of the 2nd usenix workshop on hot topics in management of internet , cloud , and enterprise networks and services _ , 2012 .",
    "by minimizing the upper bound of the drift - plus - penalty expression ( [ cond - v - drift ] ) , the time average of communication cost can be minimized while stabilizing the network of request queues .",
    "we denote the objective function of ( [ opt - pr ] ) by @xmath158 and its optimal solution @xmath159 .",
    "therefore , for any other scheduling decision @xmath54 made during time slot @xmath9 , we have @xmath160 taking the conditional expectation on both sides conditional on @xmath22 , we have @xmath161 \\ge e\\left[j_t(\\mathbf{x}^*)\\,|\\,\\mathbf{q}^c(t)\\right ]      \\end{array}\\ ] ] for any @xmath54 . in such way , instead of directly solving the long - term stochastic optimization problem ( [ ori - opt - pr ] ) , we can opportunistically choose a feasible association to solve problem ( [ opt - pr ] ) during each time slot .",
    "given @xmath162 defined in ( [ lyqueue ] ) ,",
    "we have @xmath163 + \\sum_{i \\in \\mathcal{s } } \\left [ \\left(q^s_i(t+1)\\right)^2 - \\right . \\right . \\\\          & \\displaystyle \\left .",
    "\\left(q^s_i(t)\\right)^2 \\right ] \\right ) \\\\",
    "\\le & \\displaystyle \\frac{1}{2 } \\sum_{j \\in \\mathcal{c } } \\left\\ { \\left ( q^c_j(t ) - b_j(t ) + \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j } \\cdot { a}_{i}(t ) \\right)^2 - \\left(q^c_j(t)\\right)^2 \\right\\ } + \\\\          & \\displaystyle \\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } \\left\\ { \\left ( q^s_i(t ) - u_i(t ) + \\mathbf{y}_i \\cdot { a}_{i}(t ) \\right)^2 - \\left(q^s_i(t)\\right)^2 \\right\\ } \\\\          = & \\displaystyle \\frac{1}{2 } \\sum_{j \\in \\mathcal{c } } \\left\\ { 2q^c_j(t ) \\cdot \\left ( \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j}\\cdot { a}_{i}(t ) - b_j(t ) \\right ) + \\right . \\\\          & \\displaystyle \\left .",
    "\\left ( \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j } \\cdot { a}_{i}(t ) - b_j(t ) \\right)^2 \\right\\ } +           \\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } \\displaystyle \\left\\ { \\left ( \\mathbf{y}_i \\cdot { a}_{i}(t ) - u_i(t ) \\right)^2 \\right .",
    "\\\\          & \\displaystyle \\left .",
    "+ 2q^s_i(t ) \\cdot \\left ( \\mathbf{y}_i \\cdot { a}_{i}(t ) - u_i(t ) \\right ) \\right\\ }          \\\\",
    "\\le & \\displaystyle \\sum_{j \\in \\mathcal{c } } \\left\\ { q^c_j(t ) \\cdot \\left ( \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j } \\cdot { a}_{i}(t ) - b_j(t ) \\right ) + \\right . \\\\          & \\displaystyle \\left . \\frac { ( \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j}\\cdot { a}_{i}(t))^2 + ( b_j(t))^2}{2 } \\right\\ } + \\\\          & \\displaystyle \\sum_{i \\in \\mathcal{s } } \\left\\ { q^s_i(t ) \\cdot \\left ( \\mathbf{y}_{i }",
    "\\cdot { a}_{i}(t ) - u_i(t ) \\right ) +          \\frac { ( y_i \\cdot { a}_{i}(t))^2 + ( u_i(t))^2}{2 } \\right\\ } \\\\      \\end{array}\\ ] ]    then with the definition of @xmath164 in ( [ cond - drift ] ) , we have @xmath165 \\,|\\,\\mathbf{q}(t ) \\right\\ } + \\\\          & \\displaystyle \\frac{1}{2 } e \\left\\ {   \\sum_{i \\in \\mathcal{s } } \\left [ \\left ( \\mathbf{y}_{i } a_i(t ) \\right)^2   + \\left ( u_i(t ) \\right)^2 \\right ] \\,|\\,\\mathbf{q}(t ) \\right\\ } \\\\          = & \\displaystyle \\sum_{j \\in \\mathcal{c } } q^c_j(t ) \\cdot e \\left\\ { \\left (           \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j}(t ) a_i(t ) - b_j(t )          \\right ) \\,|\\ , \\mathbf{q}(t ) \\right\\ } + \\\\            & \\displaystyle \\sum_{i \\in \\mathcal{s } } q^s_i(t ) \\cdot e \\left\\ { \\left (           \\mathbf{y}_{i}(t ) a_i(t ) - u_i(t )          \\right ) \\,|\\ , \\mathbf{q}(t ) \\right\\ } + \\\\          & \\displaystyle \\frac{1}{2 } \\sum_{j \\in \\mathcal{c } } \\left [ \\left ( \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j } a_i(t ) \\right)^2   + \\left ( b_j(t ) \\right)^2 \\right ] + \\\\          & \\displaystyle \\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } \\left [ \\left ( \\mathbf{y}_{i } a_i(t ) \\right)^2   + \\left ( u_i(t ) \\right)^2 \\right ] \\\\      \\end{array}\\ ] ] the last equality in ( [ lyap - delta1 ] ) holds because of conditional expectation on @xmath25 , then both @xmath166 and @xmath167 can be regarded as a constant . besides , the queueing process @xmath168 is independent of the arrival process @xmath169 and service process @xmath170 , @xmath171 .",
    "hence , the last two terms have nothing to do with @xmath25 . now consider the last two terms in ( [ lyap - delta1 ] ) .",
    "we have + @xmath172 + \\\\          & \\displaystyle \\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } \\left [ \\left ( \\mathbf{y}_{i } a_i(t ) \\right)^2   + \\left ( u_i(t ) \\right)^2 \\right ] \\\\          = & \\displaystyle \\frac{1}{2 } \\left [ \\sum_{j \\in \\mathcal{c } } \\left ( b_j(t ) \\right)^2 + \\sum_{i \\in \\mathcal{s } } \\left ( u_i(t ) \\right)^2 \\right ] + \\\\          & \\displaystyle \\frac{1}{2 } \\sum_{j \\in \\mathcal{c } } \\left [ \\left ( \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j } a_i(t ) \\right)^2 \\right ] +   \\\\          & \\displaystyle \\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } \\left [ \\left ( ( 1 - \\sum_{j \\in \\mathcal{c } } \\mathbf{x}_{i , j } ) \\cdot a_i(t ) \\right)^2 \\right ] \\\\      \\end{array}\\ ] ] then by taking expectation on ( [ lyap - delta2 ] ) , the following holds @xmath173 + \\right . \\\\          & \\displaystyle \\left",
    ". \\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } \\left [ \\left ( \\mathbf{y}_{i } a_i(t ) \\right)^2   + \\left ( u_i(t ) \\right)^2 \\right ] \\right\\ } \\\\",
    "= & \\displaystyle e \\left\\ { \\frac{1}{2 } \\left [ \\sum_{j \\in \\mathcal{c } } \\left ( b_j(t ) \\right)^2 + \\sum_{i \\in \\mathcal{s } } \\left ( u_i(t ) \\right)^2 \\right ] + \\right . \\\\          & \\displaystyle \\frac{1}{2 } \\sum_{j \\in \\mathcal{c } } \\left [ \\left ( \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j } a_i(t ) \\right)^2 \\right ] +   \\\\          & \\displaystyle \\left .",
    "\\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } \\left [ \\left ( ( 1 - \\sum_{j \\in \\mathcal{c } } \\mathbf{x}_{i , j } ) \\cdot a_i(t ) \\right)^2 \\right ] \\right\\ } \\\\          = & \\displaystyle \\frac{1}{2 } \\left [ \\sum_{j \\in \\mathcal{c } } e\\left\\ { \\left ( b_j(t ) \\right)^2 \\right\\ } + \\sum_{i \\in \\mathcal{s } } e\\left\\ { \\left ( u_i(t ) \\right)^2 \\right\\ } \\right ] + \\\\          & \\displaystyle \\frac{1}{2 } \\sum_{j \\in \\mathcal{c } } e \\left\\ { \\left ( \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j } a_i(t ) \\right)^2 \\right\\ } + \\\\          & \\displaystyle \\left .",
    "\\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } e \\left\\ { ( 1 - \\sum_{j \\in \\mathcal{c } } \\mathbf{x}_{i , j})^2 \\cdot \\left(a_i(t)\\right)^2 \\right\\ } \\right\\ } \\\\          = & \\displaystyle \\frac{1}{2 } \\left [ \\sum_{j \\in \\mathcal{c } } e\\left\\ { \\left ( b_j(t ) \\right)^2 \\right\\ } + \\sum_{i \\in \\mathcal{s } } e\\left\\ { \\left ( u_i(t ) \\right)^2 \\right\\ } \\right ] + \\\\          & \\displaystyle \\frac{1}{2 } \\sum_{j \\in \\mathcal{c } } e \\left\\ { \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j}^2 \\left(a_i(t)\\right)^2 + 2\\sum_{i < i ' } \\mathbf{x}_{i , j}\\mathbf{x}_{i',j } a_{i}(t ) a_{i'}(t ) \\right\\ } + \\\\          & \\displaystyle \\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } e \\left\\ { ( 1 - \\sum_{j \\in \\mathcal{c } } \\mathbf{x}_{i , j})^2 \\cdot \\left(a_i(t)\\right)^2 \\right\\ } \\\\      \\end{array}\\ ] ]",
    "remind that the request arrival processes @xmath169 are independent and they are also independent of @xmath91 for @xmath85",
    ". then we have @xmath174 + \\right . \\\\          & \\displaystyle \\left .",
    "\\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } \\left [ \\left ( \\mathbf{y}_{i } a_i(t ) \\right)^2   + \\left ( u_i(t ) \\right)^2 \\right ] \\right\\ } \\\\",
    "= & \\displaystyle \\frac{1}{2 } \\left [ \\sum_{j \\in \\mathcal{c } } e\\left\\ { \\left ( b_j(t ) \\right)^2 \\right\\ } + \\sum_{i \\in \\mathcal{s } } e\\left\\ { \\left ( u_i(t ) \\right)^2 \\right\\ } \\right ] + \\\\          & \\displaystyle \\frac{1}{2 } \\left [ \\sum_{j \\in \\mathcal{c } } \\sum_{i \\in \\mathcal{s } } e \\left\\ { \\mathbf{x}_{i , j}^2 \\right\\ } e\\left\\ { \\left(a_i(t)\\right)^2 \\right\\ } \\right . + \\\\          & \\displaystyle \\left .",
    "2\\sum_{i < i ' }",
    "e\\left\\ { \\mathbf{x}_{i , j } \\right\\ } e\\left\\ { \\mathbf{x}_{i',j } \\right\\ } e\\left\\ { a_{i}(t ) \\right\\ } e\\left\\ { a_{i'}(t ) \\right\\ } \\right ] + \\\\          & \\displaystyle \\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } e \\left\\ { ( 1 - \\sum_{j \\in \\mathcal{c } } \\mathbf{x}_{i , j})^2 \\right\\ } \\cdot e\\left\\ { \\left(a_i(t)\\right)^2 \\right\\ } \\\\",
    "\\le & \\displaystyle \\frac{1}{2 } \\left ( c \\cdot \\max_{j \\in \\mathcal{c } } \\ { e(b_j^2(t))\\ } + s \\cdot \\max_{i \\in \\mathcal{s } } \\ { e(u_i^2(t))\\ } + \\right . \\\\          & \\displaystyle \\max_{i \\in \\mathcal{s } } \\ { e(a_i^2(t))\\ } \\left [               \\sum_{j \\in \\mathcal{c } } e \\left\\ { \\left ( \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j } \\right)^2 \\right\\ } + \\right .",
    "\\\\          & \\displaystyle \\left .",
    "\\sum_{i \\in \\mathcal{s } } e\\left\\ { \\left(1 - \\sum_{j \\in \\mathcal{c } } \\mathbf{x}_{i , j}\\right)^2 \\right\\ }           \\right ] \\right ) \\\\",
    "\\le & \\displaystyle \\frac{1}{2 } \\max_{i , j } ( e(b_j^2(t ) ) , e(u_i^2(t ) ) , e(a_i^2(t ) ) ) \\cdot \\\\           & \\displaystyle \\left ( c + s + \\underset{\\mathbf{x } \\in \\mathcal{a}}{\\text{max } } \\left\\ {                   \\sum_{j \\in \\mathcal{c } } \\left ( \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j } \\right)^2                   + \\sum_{i \\in \\mathcal{s } } ( \\mathbf{y}_i(t))^2              \\right\\ } \\right ) \\\\      \\end{array}\\ ] ] where the first inequality holds because of the following reasoning .",
    "we suppose @xmath175 . then for any @xmath176 @xmath177 as we know that @xmath178 , then @xmath179 thus the first inequality in ( [ final - ineq ] ) holds .",
    "next , we focus on the upper bound of @xmath180 for @xmath54 . at each time slot , @xmath181 and for each switch @xmath17",
    ", it must decide either to upload requests to one of controllers or process them locally .",
    "then among all @xmath91 ( for all @xmath85 ) and @xmath182 ( for @xmath17 ) , there are exactly @xmath117 of them that s equal to one .",
    "let @xmath183 $ ] denote the number of switches that decide to upload requests to control plane , i.e. , there are @xmath184 terms among all @xmath91 ( for @xmath85 ) that s equal to one .",
    "likewise , let @xmath185 $ ] denote the number of switches that process requests locally .",
    "accordingly , we know that @xmath186 . besides , @xmath187 since there are exactly @xmath188 switches such that for any switch @xmath42 among them @xmath48 .",
    "now we prove that the upper bound of @xmath189 is @xmath190 and the bound is reached when all @xmath184 switches is associated with the same controller .",
    "we use @xmath191 to denote the set of those @xmath184 switches .",
    "we introduce indicator @xmath192 such that @xmath193 if switch @xmath114 and switch @xmath194 are associated with the same controller and @xmath44 otherwise .",
    "therefore , for any switch - controller association @xmath195 such that @xmath196 , we have @xmath197 where the last equality holds because for any pair of switches @xmath198 , @xmath199 only when @xmath42 and @xmath200 upload requests to the same controller . from ( [ to - cp - ineq ] ) , we know that the upper bound is reached when @xmath199 for all @xmath201 , i.e. , when all switches in @xmath191 connected to the same switches . in such case , since there are @xmath202 pairs of different switches , then the upper bound of @xmath189 is @xmath203 .",
    "hence , @xmath204 now that @xmath184 is a non - negative integer and @xmath205 , then the upper bound in ( [ tt - ineq ] ) reaches its maximum value @xmath206 when @xmath207 . in other words ,",
    "the upper bound reaches maximum when all switches in @xmath16 upload requests to the same controller . as a result , @xmath208 + \\right .",
    "\\\\          & \\displaystyle \\left .",
    "\\frac{1}{2 } \\sum_{i \\in \\mathcal{s } } \\left [ \\left ( \\mathbf{y}_{i } a_i(t ) \\right)^2   + \\left ( u_i(t ) \\right)^2 \\right ] \\right\\ } \\\\",
    "\\le & \\displaystyle \\frac{1}{2 } \\max_{i , j } ( e(b_j^2(t ) ) , e(u_i^2(t ) ) , e(a_i^2(t ) ) ) \\cdot \\left ( |\\mathcal{c}| + |\\mathcal{s}| + |\\mathcal{s}|^2 \\right ) \\\\          = & \\displaystyle \\frac{d_{max}}{2 } \\left ( |\\mathcal{c}| + |\\mathcal{s}| + |\\mathcal{s}|^2 \\right ) = k \\\\",
    "\\end{array}\\ ] ]    we assume the whole control plane is capable of handling all requests from data plane in the mean sense",
    ". therefore , for @xmath19 , there exists @xmath209 such that @xmath210 = \\epsilon^c_j$ ] .",
    "likewise , for @xmath17 , there exists @xmath211 such that @xmath212 = \\epsilon^s_i$ ] .",
    "following ( [ k - upper ] ) and the definition in ( [ cond - v - drift ] ) , after taking expectation on @xmath213 , we have @xmath214 a_i(t ) - u_i(t)\\,|\\,\\mathbf{q}(t)\\right\\ } \\right\\ } \\\\          & \\displaystyle + v \\cdot e\\left\\ { e\\ { f(t ) + g(t ) |\\mathbf{q}(t ) \\ } \\right\\ } \\\\          = & \\displaystyle k + \\sum_{j \\in \\mathcal{c } } e\\left\\ { q_j^c(t ) \\right\\ } \\cdot e\\left\\ { \\sum_{i \\in \\mathcal{s } } \\mathbf{x}_{i , j}(t ) a_i(t ) - b_j(t ) \\right\\ } \\\\          & \\displaystyle + \\sum_{i \\in \\mathcal{s } } e\\left\\ { q_i^s(t ) \\right\\ } \\cdot e\\left\\ { [ 1 - \\sum_{j \\in \\mathcal{c } } \\mathbf{x}_{i , j}(t ) ] a_i(t ) - u_i(t ) \\right\\ } \\\\          & \\displaystyle + v \\cdot e \\left\\ { f(t ) + g(t ) \\right\\ } \\\\          \\le & \\displaystyle k - \\epsilon^c \\sum_{j \\in \\mathcal{c } } q_j^c(t ) -",
    "\\epsilon^s \\sum_{i \\in \\mathcal{s } } q_i^s(t ) + v \\cdot ( f^ * + g^ * ) \\\\      \\end{array}\\ ] ] where @xmath215 , @xmath216 .",
    "expanding the term @xmath217 , then for any time slot @xmath218 , @xmath219 next , summing over @xmath220 for some @xmath221 , we have @xmath222 \\\\",
    "\\le & \\displaystyle t \\cdot k           - \\epsilon^c \\sum_{\\tau = 0}^{t-1 } \\sum_{j \\in \\mathcal{c } } e\\left\\{q_j^c(\\tau)\\right\\ }           - \\epsilon^s \\sum_{\\tau = 0}^{t-1 } \\sum_{i \\in \\mathcal{s } } e\\left\\{q_i^s(\\tau)\\right\\ } + \\\\          & t \\cdot v \\cdot ( f^ * + g^ * ) \\\\              \\end{array}\\ ] ] by re - arrangement of terms at both sides and ignoring some non - negative term such as @xmath223 and @xmath224 , with @xmath225 and @xmath73 , we have @xmath226 \\\\",
    "\\le & t \\cdot v \\cdot ( f^ * + g^ * ) + t \\cdot k + e\\left\\ { l(\\mathbf{q}(0 ) ) \\right\\ } \\\\      \\end{array}\\ ] ] @xmath227 @xmath228    then by dividing both sides of ( [ vfg ] ) by @xmath229 , ( [ ecq ] ) by @xmath230 , and ( [ esq ] ) by @xmath231 , we have @xmath232 \\\\",
    "\\le & \\displaystyle ( f^ * + g^ * ) + \\frac{k}{v } + \\frac{e\\left\\ { l(\\mathbf{q}(0 ) ) \\right\\}}{v \\cdot t } \\\\      \\end{array}\\ ] ] @xmath233 @xmath234 at last , taking the limit as @xmath235 for both equations , we have the desired results : @xmath236 \\le \\displaystyle f^ * + g^ * + \\frac{k}{v } \\\\      \\end{array}\\ ] ] @xmath237 @xmath238"
  ],
  "abstract_text": [
    "<S> in software - defined networking ( sdn ) , as data plane scale expands , scalability and reliability of the control plane have become major concerns . to mitigate such concerns , </S>",
    "<S> two kinds of solutions have been proposed separately . </S>",
    "<S> one is multi - controller architecture , i.e. , a logically centralized control plane with physically distributed controllers . </S>",
    "<S> the other is control devolution , i.e. , delegating control of some flows back to switches . </S>",
    "<S> most of existing solutions adopt either static switch - controller association or static devolution , which may not adapt well to the traffic variation , leading to high communication costs between switches and controller , and high computation costs of switches . in this paper </S>",
    "<S> , we propose a novel scheme to jointly consider both solutions , i.e. , we dynamically associate switches with controllers and dynamically devolve control of flows to switches . </S>",
    "<S> our scheme is an efficient online algorithm that does not need the statistics of traffic flows . </S>",
    "<S> by adjusting some parameter @xmath0 , we can make a trade - off between costs and queue backlogs . </S>",
    "<S> theoretical analysis and extensive simulations show that our scheme yields much lower costs and latency compared to static schemes , and balanced loads among controllers . </S>"
  ]
}