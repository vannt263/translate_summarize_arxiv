{
  "article_text": [
    "in queueing theory , customers and servers play different roles .",
    "customers arrive in the system , accumulate in a buffer , get served by a server , and eventually depart .",
    "servers on the other hand alternate between idle and busy periods but remain forever in the system .    within this framework ,",
    "many variations and refinements are possible .",
    "for instance , we may consider a model with multi - class customers and distinguishable servers .",
    "a customer of a given class @xmath5 must choose its server from a specified subset @xmath6 of the servers .",
    "and of course , the subsets @xmath6 may intersect , see figure [ fig : call ] .",
    "queueing model of a call center . ]    in this paper , we consider a model with the same multi - class flavor , but in which , by contrast , customers and servers play completely identical roles .",
    "we now argue that this simple symmetry requirement leads in a natural and ineluctable way to the _ bipartite matching model_.    by symmetry , both customers and servers should arrive into the system and depart from it . more specifically , upon completion of a service , both the customer and the server should depart simultaneously . to model arrivals , we have a priori more flexibility , but there is basically one non - trivial choice which is to assume that time is discrete and that customers and servers arrive in pairs .",
    "consider indeed the simplest possible model with continuous - time arrivals : ( i ) there is only one class of customers and one class of servers ; ( ii ) customers , resp .",
    "servers , arrive according to a poisson process of rate @xmath7 , resp .",
    "@xmath2 ; ( iii ) services have duration 0 .",
    "let us describe the state by @xmath8 , where @xmath9 is the number of unmatched customers and @xmath10 the number of unmatched servers .",
    "the process @xmath11 is a birth - and - death continuous - time markov process on @xmath12 with drift @xmath13 .",
    "it is either transient ( if @xmath14 ) or null recurrent ( if @xmath15 ) , but it is never positive recurrent .",
    "let us switch to discrete - time i.i.d .",
    "arrivals . at each time step , a batch of customers and a batch of servers arrive into the system . if the size of the batches are allowed to be different for customers and servers , then we are back to the continuous - time situation , and even the simplest model is never positive recurrent .",
    "therefore to get a non - trivial model , the natural assumption is that exactly one customer and one server arrive into the system at each time step .",
    "the resulting model is symmetric in another respect : both arrivals and departures occur in pairs .    for simplicity",
    ", we always assume that the service durations are null .",
    "so the model is specified by : ( i ) the finite set @xmath0 of customer classes and the finite set @xmath1 of server classes ; ( ii ) the probability law @xmath2 on @xmath3 for the arrivals in pairs ; ( iii ) the bipartite graph @xmath4 giving the possible matchings between customers and servers ( hence the possible departures in pairs ) ; ( iv ) the matching policy to decide how to match when several choices are possible .",
    "we consider so called _ admissible _ policies which depend only on the current state of the system . under these assumptions",
    ", the buffer content evolves as a discrete - time markov chain .",
    "we call this model the _ bipartite matching _ model .",
    "the bipartite matching model has been introduced by caldentey , kaplan , and weiss  @xcite , under an additional assumption of independence between arriving customers and servers ( @xmath16 ) , and for the fifo policy . in their paper , the authors mention several possible domains of applications ranging from call centers to crossbar data switches .",
    "they also provide references to papers on related models .",
    "we refer the interested reader to @xcite for details .    in the bipartite matching model , there is an equal number of customers and servers at any time .",
    "but the matching constraints may result in instability with unmatched customers and servers accumulating .",
    "it turns out that proving stability , i.e. positive recurrence of the markov chain , is highly non - trivial . given a bipartite graph @xmath17 , there",
    "exist natural necessary conditions on @xmath2 for stability to hold true .",
    "when these conditions are also sufficient , we say that the stability region is _",
    "caldentey @xmath18 al conjecture that any bipartite graph has a maximal stability region for the fifo policy  ( * ? ? ?",
    "* conjecture 4.2 ) .",
    "they prove the conjecture for some specific models ( under the additional assumption of independence of customers and servers ) : ( i ) the n model defined by @xmath19 , ( ii ) the w model , i.e. the matching model version of figure [ fig : call ] ; ( iii ) the nn model of figure [ fig : nn ] . in the first two cases , they are also able to compute explicitly the stationary distribution . for the last case , the proof of stability is already intricate .    in the present paper ,",
    "we consider the stability issue for various admissible matching policies : ml ( match the longest ) , ms ( match the shortest ) , fifo ( match the oldest ) , random ( match uniformly ) , priorities .",
    "the irreducibility of the markov chain describing the model is not granted , and we first study this question in detail ( section [ se - utc ] ) . then we obtain the following results :    sufficient conditions under which any admissible policy is stable ( section [ se - suff ] ) ;    for the nn model , the ms policy and some priority policies do not have a maximal stability region ( section [ se - ms ] ) ;    for any bipartite graph , the ml policy has a maximal stability region ( section [ se - ml ] ) .",
    "we do not know if the stability region is always maximal for the fifo and random policies .",
    "* notations . *",
    "denote by @xmath20 the set of non - negative integers .",
    "let @xmath21 be the free monoid generated by @xmath22 .",
    "for any word @xmath23 and any @xmath24 , set @xmath25 , the number of occurrences in @xmath26 of letters from @xmath27 . for @xmath28 , we shorten the notation to @xmath29 . furthermore , for any @xmath23 , set @xmath30:=(|w|_a)_{a\\in a}$ ] ( the commutative image of @xmath26 ) .",
    "we now proceed to a more formal definition of the model .",
    "[ de - structure ] a _ bipartite matching structure _ is a quadruple @xmath31 where    @xmath0 is the non - empty and finite set of customer types ;    @xmath1 is the non - empty and finite set of server types ;    @xmath32 is the set of possible matchings ;    @xmath33 is the set of possible arrivals .    the bipartite graph @xmath17 is called the _ matching graph_. it is assumed to be connected .",
    "the bipartite graph @xmath34 is called the _ arrival graph_. it is assumed to have no isolated vertices .",
    "the two assumptions in def .",
    "[ de - structure ] are made without loss of generality , see remarks [ re - wlog1 ] and [ re - wlog2 ] .    in figure",
    "[ fig : nn ] we give an example of a matching graph with @xmath35 customer and @xmath35 server types , called the `` nn graph '' in the following .",
    "nn graph . ]",
    "customers and servers play symmetrical roles in the model .",
    "also @xmath36 and @xmath37 play dual roles .",
    "the graph @xmath17 defines the pairs that may depart from the system , while the graph @xmath34 defines the pairs that may arrive into the system .",
    "[ de - model ] a _ bipartite matching model _ is a triple @xmath38 $ ] , where    @xmath31 is a bipartite matching structure ;    @xmath2 is a probability measure on @xmath3 satisfying @xmath39 where @xmath40 and @xmath41 are the @xmath0 and @xmath1 marginals of @xmath2 .",
    "pol is an admissible matching policy ( to be defined in  [ sse - match ] ) .",
    "observe that we can simplify the notation to @xmath42 $ ] .",
    "we say that the model @xmath43 $ ] is _ associated _ with the structure @xmath31 .",
    "[ re - wlog1 ] for to have solutions , @xmath34 must be without isolated vertices , the assumption made in definition [ de - structure ] .",
    "this is not a real restriction : if it is not satisfied , we can consider a new model without such customer or server classes .",
    "a realization of the model is as follows .",
    "consider an i.i.d .",
    "sequence of random variables of law @xmath2 , representing the arrival stream of pairs of customer / server .",
    "a state of the buffer consists of an equal number of customers and servers with no possible matchings between the classes . upon arrival of a new ordered pair @xmath44",
    ", two situations may occur : if neither @xmath5 nor @xmath45 match with the servers / customers already present in the buffer , then @xmath5 and @xmath45 are simply added to the buffer ; if @xmath5 , resp .",
    "@xmath45 , can be matched then it departs the buffer with its match . if several matchings are possible for @xmath5 , resp .",
    "s , then it is the role of the matching policy to select one .",
    "an admissible policy selects according to the current state of the buffer ( and not according to the whole history of the buffer contents , for instance ) .",
    "the resulting evolution of the buffer is described by a discrete - time markov chain .",
    "depending on the matching policy , we consider either a commutative ( e.g. for random ) or a non - commutative ( e.g. for fifo ) state space description . the different policies considered in the paper will be formally defined in ",
    "[ sse - match ] .",
    "let us choose a matching graph @xmath17 .",
    "we introduce the following convenient notations : @xmath46 is the set of customer classes that can be matched with an @xmath45-server ; @xmath6 is the set of server classes that can be matched with a @xmath5-customer : @xmath47 for any subsets @xmath48 , and @xmath49 , we define @xmath50    [ [ commutative - state - space . ] ] commutative state space .",
    "+ + + + + + + + + + + + + + + + + + + + + + + +    a state of the system is given by @xmath51 , @xmath52 and @xmath53 , where @xmath54 denotes the number of customers of type @xmath5 and @xmath55 the number of servers of type @xmath45 .",
    "the _ commutative state space _ is : @xmath56    [ [ non - commutative - state - space . ] ] non - commutative state space .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    a state of the system is given by two finite words of the same size @xmath57 , respectively on the alphabets @xmath0 and @xmath1 , describing unmatched customers and servers .",
    "the _ non - commutative state space _ is : @xmath58 ,      [ v ] ) \\mbox { belongs to } \\eref{eq - css }   \\bigr\\}.\\ ] ]    [ [ facet . ] ] facet .",
    "+ + + + + +    both the commutative and the non - commutative state space can be decomposed into facets , defined only by the non - zero classes .",
    "a _ facet _ is an ordered pair @xmath59 such that : @xmath60 and @xmath61 .",
    "the _ zero - facet _ is the facet @xmath62 , we denote it shortly by @xmath63 .    for a facet @xmath64 ,",
    "define : @xmath65    we alleviate the notations to @xmath66 when there is no possible confusion .",
    "the symbol @xmath67 stands for the non - zero classes , the symbol @xmath68 for the classes that are forced to be at zero ( since they are matched with non - zero classes ) , and the symbol @xmath69 for the classes that happen to be at zero",
    ".    the following notion will play an important role later on .",
    "[ de - saturated ] a facet @xmath70 is called saturated if @xmath71 or @xmath72 .    in figure",
    "[ fig : nnf33 ] , the facet on the left is non - saturated , while the one on the right is saturated .",
    "nn graph : facets @xmath73 and @xmath74 . ]",
    "[ [ graphical - convention . ] ] graphical convention .",
    "+ + + + + + + + + + + + + + + + + + + + +    a facet @xmath70 can be represented graphically by coloring the nodes of the bipartite graph according to the above convention ( see figure [ fig : nnf33 ] for an illustration ) :    nodes in @xmath75 and @xmath76 are represented as filled circles ;    nodes in @xmath77 and @xmath78 are represented as double circles ;    nodes in @xmath79 and @xmath80 are represented as simple circles .    in figure [ fig : nnfacets ] , we have represented the facets of the nn graph .",
    "the more complex case of the nnn graph will be given in section [ se - suff ] , figure [ fig : nnnfacets ] .",
    "facets for the nn graph . ]",
    "[ al : facets ] takes as input a matching graph and returns as output the set of facets . the termination and correctness of the algorithm",
    "are easily proved .",
    "informally , a matching policy is _ admissible _ if :    only the current state of the buffer is taken into account ;    priority is given to customers / servers that are already present in the buffer : if the state is @xmath81 and the new arrival is @xmath82 , then @xmath5 and @xmath45 are matched together iff there are no servers from @xmath6 in @xmath83 and no customers from @xmath46 in @xmath84 .",
    "it results from the first point that an admissible matching policy can be described as a mapping @xmath85 which returns the new state of the system after an arrival .",
    "the second point is called the _ buffer - first _ assumption .",
    "it is not a real restriction : a matching policy that always gives priority to new arrivals can be seen as a special case of the above with an arrival probability @xmath2 such that @xmath86 .",
    "we now define admissible policies formally , distinguishing between the non - commutative and commutative state spaces .    for a word @xmath87 and @xmath88",
    ", we denote by @xmath89}:= w_1\\ldots w_{i-1 } w_{i+1}\\ldots w_k$ ] the subword of @xmath26 obtained by deleting @xmath90 .",
    "[ def : bf ] a matching policy is _ admissible _ if there are functions @xmath91 and @xmath92 such that : @xmath93 } , v_{\\left [ \\psi(v , c)\\right ] } ) , & \\textrm{if } \\ ; |u|_{c(s ) } \\not= 0 , \\ ; |v|_{s(c ) } \\not= 0\\\\   ( u_{\\left [ \\phi(u , s)\\right]}c , v ) , & \\textrm{if } \\ ; |u|_{c(s ) } \\not= 0 , \\ ; |v|_{s(c ) } = 0\\\\   ( u , v_{\\left [ \\psi(v , c)\\right]}s ) , & \\textrm{if } \\ ; |u|_{c(s ) } = 0 , \\ ; |v|_{s(c ) } \\not= 0 \\end{array } \\right .\\ ] ]    the _ fifo _ and _ lifo _ policies are admissible matching policies with functions @xmath91 and @xmath92 as follows :    * fifo : @xmath94 , @xmath95 . *",
    "lifo : @xmath96 , @xmath97 .    for @xmath98 ,",
    "let @xmath99 be defined by @xmath100 and @xmath101 . for @xmath102 ,",
    "let @xmath103 be defined accordingly .",
    "[ def : bfc ] a matching policy is _ admissible _ if there are functions @xmath91 and @xmath92 such that : @xmath104    the following commutative matching policies are admissible ( for random , ml , and ms policies @xmath105 and @xmath106 are random variables ) :    * pr ( priorities ) . for each customer type @xmath98",
    ", we define a priority function @xmath107 .",
    "similarly , for each server type @xmath108 , we define @xmath109 . in the case of several matching options ,",
    "a customer / server is matched with the server / customer that has the highest priority ( greatest value of the priority function ) .",
    "it is convenient to specify the priorities by two @xmath110 matrices @xmath22 and @xmath27 defined by : @xmath111 then @xmath112 and @xmath113 . *",
    "random : @xmath114 , resp .",
    "@xmath115 , is a random variable valued in @xmath46 , resp .",
    "@xmath6 , and distributed as @xmath116 , resp .",
    "intuitively , the match is chosen uniformly among all possible ones .",
    "* ml : @xmath114 , resp .",
    "@xmath115 , is a random variable uniformly distributed on @xmath118 , resp . @xmath119 . *",
    "ms : @xmath114 , resp .",
    "@xmath115 , is a random variable uniformly distributed on @xmath120 , resp .",
    "to introduce the main ideas , consider first a simpler finite and deterministic problem .",
    "let @xmath17 be a matching graph .",
    "consider a batch of customers @xmath122 and a batch of servers @xmath123 of equal size : @xmath124 .",
    "a _ perfect matching _ of @xmath125 and @xmath126 is a tuple @xmath127 such that : @xmath128 by hall s theorem ( aka the `` marriage theorem '' ) , there exists a perfect matching if and only if : @xmath129 a perfect matching , if there is one , can be obtained by restating the model as a flow network and by solving the maximum flow problem for which efficient algorithms exist  @xcite .",
    "the bipartite matching model is much more complicated : first it is random , and second the matchings have to be performed on the fly , at each time step .",
    "however the two ingredients of the simpler model will play an instrumental role in the analysis : ( i ) the conditions ncond , to be defined in , are related to ; ( ii ) the restatement as a flow problem is used in most of the proofs .",
    "consider now a bipartite matching model @xmath42 $ ] .",
    "we identify the model with the markov chain on the state space @xmath130 describing the evolution of the buffer content .",
    "let @xmath131 be the transition matrix of the markov chain .",
    "a probability measure @xmath132 on @xmath130 is _ stationary _ if @xmath133 .",
    "it is _ attractive _ if for any probability measure @xmath134 on @xmath130 , the sequence of cesaro averages of @xmath135 converges weakly to @xmath132 .",
    "[ de - stab ] the model is said to be _ stable _ if the markov chain has a unique and attractive stationary probability measure .",
    "it implies in particular that the graph of the markov chain has a unique terminal strongly connected component with all states leading to it .",
    "let @xmath40 be a probability measure on @xmath0 and @xmath41 a probability measure on @xmath1 .",
    "define the following conditions on @xmath136 :    @xmath137    the above conditions appear in @xcite .",
    "they have a natural interpretation .",
    "let @xmath40 and @xmath41 be the marginals of the arrival probability @xmath2 .",
    "customers from @xmath138 need to be matched with servers from @xmath139 .",
    "the first line in ncond asks for strictly more servers in average from @xmath139 than customers from @xmath138 .",
    "the second line has a dual interpretation .    using the strong law of large numbers",
    ", we also see that the arrivals up to time @xmath140 satisfy for all values of @xmath140 large enough if and only if ncond is satisfied .",
    "[ le - le ] the conditions ncond are necessary stability conditions : if the markov chain is stable then the conditions ncond are satisfied by the marginals of @xmath2 .",
    "we suppose that the conditions ncond are not satisfied .",
    "assume first that there exists @xmath141 such that @xmath142 .",
    "let @xmath143 , resp .",
    "@xmath144 , be the total numbers of customers of type @xmath138 , resp .",
    "servers of type @xmath139 , to arrive in the system up to time @xmath140 .",
    "let @xmath145 be the number of customers of type @xmath138 present in the system at time @xmath140 . by definition , @xmath146 . by the strong law of large numbers",
    ", we have , a.s .",
    ", @xmath147 so the markov chain is transient .",
    "similarly , if there exists @xmath148 such that @xmath149 , the model is unstable .",
    "( this part of the argument appears in ( * ? ? ?",
    "3.4 ) . )",
    "assume now that there exists @xmath150 such that @xmath151 observe that @xmath152 , otherwise we would have @xmath153 which would contradict @xmath154 . set @xmath155 .",
    "eqn ( [ eq-1 ] ) is equivalent to : @xmath156 .",
    "the bipartite matching graph @xmath17 is represented in figure [ fi - help ] . by assumption , @xmath157 .    the bipartite graph @xmath17 .",
    "]    we have @xmath158 using eqn ( [ eq-1 ] ) , we get @xmath159    let @xmath160 be the number of departures of type @xmath161 up to time @xmath140 .",
    "let @xmath143 , @xmath144 , and @xmath145 be defined as above .",
    "set @xmath162 . for an arrival of type @xmath163",
    ", the @xmath11-process makes a + 1 jump , for an arrival of type @xmath161 , the @xmath11-process makes a -1 jump , otherwise the @xmath11-process remains constant .",
    "we have @xmath164 .",
    "we have two cases :    if @xmath165 , then , according to , the @xmath11-process is null recurrent .    if @xmath166 , then for any initial condition such that @xmath167 , a.s . @xmath168 .",
    "hence , in both cases , the model can not be stable .",
    "[ re - wlog2 ] consider a _",
    "non - connected _ matching graph @xmath17 .",
    "consider a probability @xmath2 and an admissible matching policy such that the bipartite matching model is stable .",
    "let @xmath169 be a connected subgraph of @xmath17 .",
    "following the exact same steps as in the proof of lemma [ le - le ] , we prove that @xmath170 ( otherwise the markov chain is either transient or null recurrent )",
    ". therefore , we can decompose the model into connected components and treat them separately .",
    "hence the assumption of connectedness of @xmath17 in def .",
    "[ de - structure ] was made without loss of generality .",
    "let us fix @xmath17 and the probability measures @xmath136 such that @xmath171 .",
    "we want an efficient algorithm to decide if the conditions ncond are satisfied .",
    "the number of inequalities in ncond is exponential in @xmath172 endow the arcs of @xmath36 with infinite capacity , an arc of type @xmath173 with capacity @xmath174 , and an arc of type @xmath175 with capacity @xmath176 .    the graph @xmath177 associated with the nn model of figure [ fig : nn ] . ]",
    "recall that a _ cut _ is a subset of the arcs whose removal disconnects @xmath178 and @xmath179 .",
    "the _ capacity _ of a cut is the sum of the capacities of the arcs .",
    "set @xmath180 .",
    "recall that @xmath181 is a _ flow _ if : ( i ) @xmath182 ; ( ii ) @xmath183 , @xmath184 is less or equal to the capacity of @xmath185 .",
    "the _ value _ of @xmath186 is @xmath187 .",
    "let @xmath188 be the set of inequalities obtained from ncond by replacing the strict inequalities by large inequalities .",
    "[ le - flow ] there exists a flow of value 1 in @xmath177 iff @xmath136 satisfies @xmath188 .",
    "there exists a flow @xmath186 of value 1 such that @xmath189 for all @xmath82 iff @xmath136 satisfies ncond .    the first part of lemma [ le - flow ] is proved in ( * ? ? ?",
    "we repeat the argument for completeness .    the celebrated max - flow min - cut theorem  @xcite states that the maximal value of a flow is equal to the minimal capacity of a cut .",
    "observe that the set of arcs @xmath190 forms a cut of capacity 1 .",
    "therefore the maximal flow is @xmath191 and it is 1 iff all cuts have a capacity @xmath192 .    to be of finite capacity , a cut must contain only customer arcs @xmath193 and server arcs @xmath194 . consider a subset @xmath195 .",
    "set @xmath196 and @xmath197 .",
    "the set @xmath198 is a cut iff @xmath199 , equivalently iff @xmath200 and @xmath201 .",
    "also the capacity of @xmath198 is @xmath202 .",
    "illustration of the proof of lemma [ le - flow ] . ]",
    "assume that the cut @xmath203 is of capacity strictly less than 1 .",
    "we have @xmath204 but @xmath201",
    "so , if @xmath188 is satisfied , we must have : @xmath205 so we have proved that @xmath188 is not satisfied .    the other way round , if @xmath188 is not satisfied , then there exist @xmath206 @xmath207 such that @xmath208 .",
    "set @xmath196 and @xmath209 . by definition , @xmath210 ,",
    "therefore @xmath203 is a cut .",
    "its capacity is @xmath211 .    by contrapposing the above",
    ", we get that : @xmath212 \\iff \\bigl [ \\mbox {    all cuts have a capacity } \\geq 1   \\bigr ] \\iff \\bigl [ \\mbox { maximal      flow is } 1 \\bigr]\\:.\\ ] ]    we now prove the second part of the lemma .",
    "assume that the conditions ncond are not satisfied .",
    "if the conditions @xmath188 are not satisfied either , then by the first part of the proof there exists no flow of value 1 .",
    "assume now that the conditions @xmath188 are satisfied .",
    "then there exists @xmath213 , such that @xmath214 .",
    "let @xmath186 be any flow of value 1 . using the flow relation for @xmath138",
    ", we get : @xmath215 using @xmath214 and the flow relation for @xmath139 , we deduce that : @xmath216 \\quad \\implies \\quad   \\bigl [   \\sum_{(c , s)\\in ( c - u ) \\times s(u ) } t(c , s ) = 0 \\ \\bigr ] \\:.\\ ] ] now it follows from the connectedness of @xmath17 that @xmath217 .",
    "we conclude that the flow @xmath186 is such that @xmath218 for some @xmath82 .",
    "assume now that the conditions ncond are satisfied .",
    "fix @xmath219 such that @xmath220 .",
    "consider the function @xmath221 defined by @xmath222 by construction @xmath223 is a flow .",
    "set @xmath224 for @xmath219 small enough , observe that @xmath225 , resp .",
    "@xmath226 , is a probability measure on @xmath0 , resp . on @xmath1 .",
    "choose @xmath219 small enough such that @xmath227 satisfies ncond .",
    "this is possible since the conditions ncond are open conditions .",
    "consider the directed graph @xmath177 , see , with new capacities on the customer and server arcs defined by @xmath225 and @xmath226 . by applying the first part of the proof",
    ", there exists a flow @xmath228 of value 1 .",
    "define @xmath229 by construction @xmath186 is a flow for the graph @xmath177 with the original capacity constraints ( @xmath40 for the customer arcs and @xmath41 for the server arcs ) .",
    "the value of @xmath186 is 1 and it satisfies @xmath230 for all @xmath231 .",
    "this completes the proof .",
    "there exist algorithms to find the maximal flow which are polynomial in the size of the underlying graph , independent of the arc capacities .",
    "for instance , the classical `` augmenting path algorithm '' of edmonds @xmath18 karp  @xcite operates in @xmath232 time , and there exist more sophisticated algorithms operating in @xmath233 time .",
    "take one of these polynomial algorithms , call it maxflow and consider it as a blackbox .",
    "we build on this to design a polynomial algorithm to check ncond .",
    "let us detail the construction .",
    "[ le - trick ] define @xmath234 as in .",
    "the pair @xmath136 satisfies ncond iff the pair @xmath234 satisfies ncond for @xmath219 strictly positive and small enough .",
    "assume that @xmath136 satisfies ncond .",
    "since we are dealing with open conditions , any small enough perturbation of @xmath136 still satisfies ncond .",
    "assume now that @xmath136 does not satisfy ncond .",
    "there exists @xmath150 such that @xmath235 . by using ,",
    "we get @xmath236 by definition , we have @xmath237 . we conclude that @xmath238 .",
    "so the pair @xmath234 does not satisfy ncond .    using lemmas [ le - flow ] and [ le - trick ] , ncond is satisfied iff maxflow@xmath239 returns 1 for @xmath219 small enough .",
    "so the trick is to run maxflow on the input @xmath239 by considering @xmath219 as a formal parameter made `` as small as needed '' .",
    "the precise meaning is the following . if @xmath240 , then : @xmath241 .",
    "furthermore , @xmath242 & \\iff &   \\bigl [    x_1=x_2 , \\ y_1 = y_2 \\bigr ]   \\nonumber \\\\ \\bigl [ x_1 + y_1\\eta < x_2 +",
    "y_2 \\eta \\bigr ] & \\iff &   \\bigl [    ( x_1 < x_2 ) \\",
    "\\mbox { or } \\   ( x_1 = x_2 , \\ y_1 <",
    "y_2 ) \\bigr]\\end{aligned}\\ ] ] so @xmath219 is small enough not to reverse any strict inequality .",
    "when running maxflow on @xmath239 , the algorithm deals with values of the type @xmath243 , and adds and compare them according to the above rules .",
    "now observe that the algorithm stops in finite time , so it will have performed only a finite number of operations .",
    "therefore , it would be possible , a posteriori , to assign to @xmath219 a value which would be small enough to enforce .",
    "the termination is obvious and the correctness follows from lemmas [ le - flow ] and [ le - trick ] .    given a bipartite model @xmath244 $ ] , there exists an algorithm of time complexity @xmath233 to decide if ncond is satisfied .",
    "define the following property for the transition graph of the markov chain :    utc : a unique ( terminal ) strictly connected component with all states leading to it .",
    "property utc is necessary for stability as defined in def .",
    "[ de - stab ] . but",
    "property utc is not granted in bipartite matching models and counterexamples are given below ( examples [ ex - nonirred1 ] and [ ex - nonirred2 ] ) .",
    "in fact , we will see that we are in an unusual situation : the necessary stability conditions ncond turn out to be sufficient conditions for the property utc ( theorem [ th - p ] ) !",
    "observe also that property utc is weaker than irreducibility , and we will give an example of a model satisfying ncond and utc without being irreducible ( example [ ex - pnonirred ] ) .      to establish property utc , we make a detour by introducing and studying a notion of independent interest : stable structures .",
    "a bipartite matching structure @xmath31 is _ stable _ if there exists a probability measure @xmath2 satisfying ( [ eq-3cond ] ) and whose marginals @xmath40 and @xmath41 satisfy ncond .    the justification for this terminology will appear in  [ se - ml ] :",
    "we prove there that under the ml policy , any model satisfying ncond is stable .",
    "so a structure is stable iff there exists an associated model which is stable .",
    "first of all , there exist stable structures .",
    "[ ex - irred ] consider @xmath245 , where @xmath17 is the nn bipartite graph of figure [ fig : nn ] .",
    "let @xmath246 the product measure @xmath247 has marginals @xmath40 and @xmath41 and we check that @xmath136 satisfy ncond .",
    "also it is easily proved that for any admissible matching policy , the graph of the markov chain is irreducible .    on the other hand ,",
    "there exist unstable structures .",
    "we illustrate this on two examples .",
    "[ ex - nonirred1 ] consider the structure @xmath31 where @xmath17 is the nn graph of figure [ fig : nn ] , and where @xmath248 consider any @xmath2 with @xmath249 .",
    "we have @xmath250 which violates ncond for @xmath251 .",
    "we can also prove that the property utc is not satisfied .",
    "consider a state of the type @xmath185 with @xmath252 , for some @xmath253 .",
    "any one of the three possible arrivals leave the state unchanged . in particular",
    ", there is an infinite number of terminal components .",
    "[ ex - nonirred2 ] consider the bipartite matching structure defined in figure [ fig : non - irred ] .",
    "the graph @xmath17 is represented on the left of the figure , while the graph @xmath34 is represented on the right .",
    "the matching graph @xmath17 on the left , and the arrival graph @xmath34 on the right . ]    consider any @xmath2 with @xmath249 .",
    "we have @xmath254 which contradicts ncond for @xmath255 .",
    "we can also prove that the property utc is not satisfied .",
    "consider a state @xmath185 with @xmath256 .",
    "reducing the number of customers of types 3/4 would require an arrival of type @xmath257 or @xmath258 or @xmath259 or @xmath260 .",
    "but none of these pairs belong to @xmath37 .",
    "therefore it is impossible to reach a state @xmath261 with @xmath262 . on the other hand an arrival of type @xmath263 or @xmath264 or @xmath265 or",
    "@xmath266 strictly increases the number of customers of types 3/4 . hence all the states are transient , and there is no terminal strongly connected component .",
    "stability of a structure is a decidable property",
    ". there exists a probability measure @xmath2 with the requested properties iff the following system of linear inequalities in the indeterminates @xmath267 have a solution : @xmath268 however , the number of inequalities is exponential in latexmath:[$|c| +    conceptually and algorithmically .    consider a bipartite matching structure @xmath31 .",
    "define @xmath270 .",
    "associate with the structure the * directed * graph @xmath271 , in other words the nodes are @xmath272 and the arcs are @xmath273    we have represented in figure [ fig : non - irred2 ] the directed graph associated with the structure of example  [ ex - nonirred2 ] .    the directed graph associated with the structure of figure [ fig : non - irred ] . ]",
    "the graph of figure [ fig : non - irred2 ] is not strongly connected : the four nodes on the right form a strongly connected component .",
    "similarly , the directed graph associated with the structure of example [ ex - nonirred1 ] is not strongly connected . on the other hand , the directed graph associated with the structure of example [ ex - irred ]",
    "is strongly connected .",
    "this is not a coincidence .",
    "[ th-2 ] let @xmath31 be a bipartite matching structure .",
    "the following two properties are equivalent :    1 .",
    "@xmath31 is a stable structure ; 2 .",
    "@xmath274 is strongly connected .",
    "in particular , one can decide if a structure is stable with an algorithm of time complexity @xmath275 by testing the strong connectivity of @xmath274 .",
    "assume that @xmath31 is a stable structure .",
    "let @xmath2 be a probability measure satisfying ( [ eq-3cond ] ) and ncond . suppose that there exist @xmath276 , with no directed path from @xmath5 to @xmath45 in @xmath274 .",
    "let @xmath277 be the set of nodes that can be reached starting from @xmath5 in @xmath274 .",
    "set @xmath278 by assumption , @xmath279 .",
    "the following two properties hold : @xmath280 using @xmath281 , we get @xmath282 but using @xmath283 $ ] and ncond for @xmath284 , we get @xmath285 from this contradiction , we deduce that for all @xmath286 , there exists a directed path from @xmath5 to @xmath45 in @xmath274 . similarly , we can prove that for all @xmath287 , there exists a directed path from @xmath45 to @xmath5 in @xmath274 .",
    "assume now that @xmath274 is strongly connected .",
    "consider the matrices @xmath288 and @xmath289 defined by @xmath290 consider the matrix @xmath291 . by construction , we have @xmath292 if and only if there is a path of length 2 from @xmath5 to @xmath293 in the graph @xmath274 .",
    "since @xmath294 is strongly connected , we deduce that @xmath295 is irreducible .",
    "clearly the spectral radius of @xmath295 is 1 . applying the perron - frobenius theorem  @xcite",
    ", we obtain the existence of a line vector @xmath296 such that : @xmath297 , @xmath298 , and @xmath299 .",
    "set @xmath300 .",
    "define the probability measure @xmath2 on @xmath3 by @xmath301 . by construction",
    ", we have @xmath302 . also , by construction , @xmath249 .",
    "define the function @xmath303 by @xmath304 by construction , @xmath186 is a flow of value 1 such that @xmath189 for all @xmath82 . using lemma [ le - flow ]",
    ", we get that @xmath305 satisfies ncond .",
    "we now have all the ingredients needed to prove the following result .",
    "[ th - p ] consider a bipartite matching model @xmath306 $ ] .",
    "assume that the structure @xmath31 is stable , equivalently that @xmath274 is strongly connected .",
    "then the transition graph of the markov chain of the bipartite matching model satisfies the property utc .",
    "we are going to prove that the empty state can be reached starting from any state .",
    "this is a sufficient condition for property utc to hold .",
    "the unique terminal strongly connected component is the set of states that can be reached from the empty state .",
    "we carry out the proof in the commutative case , but it works unchanged in the non - commutative case ( the only information needed is the number of customer / server of each class ) . consider a non - empty state @xmath307 , with @xmath308 and @xmath309 .",
    "it is sufficient to prove that we can always reach a state @xmath310 such that @xmath311 .    if there exists @xmath312 such that @xmath313 , then the proof is completed .",
    "assume now that @xmath314 .",
    "choose @xmath315 .",
    "by assumption , there exists a path from @xmath45 to @xmath5 in @xmath274 .",
    "let us denote it by @xmath316 .",
    "assume that @xmath317 and @xmath318 .",
    "( if not , consider a subpath with this property . )",
    "assume further that @xmath319 .",
    "( if @xmath320 , then @xmath321 implies @xmath322 , so we can consider the subpath @xmath323 . ) since @xmath324 and @xmath325 by construction and since @xmath319 , we get that @xmath326 and @xmath327 .    the path @xmath328 in @xmath274 .",
    "]    by definition of the graph @xmath274 , we have @xmath329 for all @xmath178 .",
    "choose the sequence of arrivals @xmath330 .",
    "consider the effect of the arrival of @xmath331 . since @xmath332",
    ", it will be matched with a customer of @xmath333 ( and not with @xmath334 , even if @xmath335 , since an admissible matching policy is always _ buffer - first _",
    ", see  [ sse - match ] ) .",
    "since @xmath336 , it will remain unmatched .",
    "let @xmath337 be the new state .",
    "we have @xmath338 .",
    "also , in the new state , we have @xmath339 , which implies that @xmath340 .",
    "so we can repeat the argument inductively . after the arrivals of @xmath341",
    ", we are in a state @xmath342 satisfying : @xmath343 therefore , after the arrival of @xmath344 , we end up in a state @xmath345 such that @xmath346 .",
    "this completes the proof .",
    "[ ex - pnonirred ] consider a bipartite matching model associated with the structure @xmath31 where @xmath17 is the nn graph of figure [ fig : nn ] , and where @xmath347 the graph @xmath274 is strongly connected . according to theorem [ th-2 ] ,",
    "the graph satisfies property utc .",
    "but it is not irreducible .",
    "indeed , it is impossible to reach the state @xmath348 starting from the empty state .",
    "more generally , none of the states of the facet @xmath349 belong to the terminal strongly connected component .",
    "below , we study the stability of bipartite matching models . therefore",
    ", we always assume that the necessary conditions ncond are satisfied .",
    "so we get the property utc for the markov chain as a consequence of theorem [ th - p ] .",
    "consider a bipartite graph @xmath17 and an admissible matching policy pol .",
    "the _ stability region _ is the set of values of @xmath2 for which the bipartite matching model @xmath306 $ ] is stable .",
    "the stability region is included in the polyhedron defined by ncond .",
    "the stability region is _ maximal _ if it is equal to this polyhedron .",
    "denote by @xmath350 the set of facets .",
    "define the following conditions on @xmath2 :    @xmath351    let @xmath70 be a saturated facet , see definition [ de - saturated ] .",
    "assume for instance that @xmath352 .",
    "then @xmath353 and @xmath354 .",
    "so implies : @xmath355 since @xmath356 , we recognize exactly for @xmath357 .",
    "conversely , consider @xmath358 and the associated condition in ncond : @xmath359 . choose a state with a strictly positive number of customers / servers for the classes @xmath138 and @xmath360 .",
    "let @xmath70 be the corresponding facet .",
    "the facet @xmath70 is saturated : @xmath361 .",
    "let us apply to the facet @xmath70 , we get : @xmath362    to summarize , the subset of the inequalities obtained by considering only the saturated facets gives precisely the inequalities ncond .",
    "we now show that the conditions scond are sufficient stability conditions .",
    "[ pr : cf ] a bipartite model with probability @xmath2 satisfying scond is stable under any admissible matching policy .    consider the linear lyapunov function : @xmath363 the number of unmatched customers ( servers ) .",
    "let @xmath364 be the markov chain of the buffer - content .",
    "let @xmath365 be an arbitrary and fixed facet .",
    "then for any @xmath366 we have ( see table  [ tab : lyaplin ] ) : @xmath367 $ } } } - l(u , v ) \\ =   \\   - \\mu(\\cz(\\cf ) , \\sz(\\cf ) ) +   \\mu(\\cr(\\cf ) , \\sb(\\cf ) ) \\\\ & &    + ~\\mu(\\cb(\\cf ) , \\sb(\\cf ) ) + \\mu(\\cb(\\cf ) , \\sr(\\cf ) ) +   \\mu(\\cr(\\cf ) \\times \\sr(\\cf ) \\cap e^c)\\\\ & = & 1 - \\mu_c(\\cz(\\cf ) ) - \\mu_s(\\sz(\\cf ) ) - \\mu ( \\cr(\\cf ) \\times \\sr(\\cf ) \\cap e ) \\:.\\end{aligned}\\ ] ] the inequality ( [ eq : snat ] ) implies directly that : @xmath368 $ } } } - l(u , v ) <",
    "\\epsilon < 0 \\:.\\ ] ]    by application of the lyapunov - foster theorem , see for instance @xcite , we conclude that the model is stable .",
    ".[tab : lyaplin]variation of the linear lyapunov function . [ cols=\"^,^,^,^\",options=\"header \" , ]     let us comment on a couple of cases . if the arrival is of type @xmath257 , then the selected matching is @xmath259 rather than @xmath369 due to the pr policy ( @xmath370 ) .",
    "if the arrival is of type @xmath258 , the selected matching is @xmath260 rather than @xmath258 according to the buffer - first property of admissible policies , see  [ sse - match ] .",
    "the other cases are argued similarly .",
    "let us introduce a new markov chain @xmath371 on @xmath12 defined by : @xmath372 ( the process @xmath371 is different from the process @xmath373 .",
    "the former is always defined according to the recursion while the latter is defined according to only for the @xmath140 s such that @xmath374 .",
    "the former is markovian while the latter is not . )",
    "condition @xmath375 becomes @xmath376 and @xmath377 becomes @xmath378 .",
    "both conditions follow from ncond .",
    "so the auxiliary chain @xmath371 is ergodic and its stationary distribution @xmath132 satisfies : @xmath379 where @xmath380 is the set of strictly positive integers and @xmath381 is the set of strictly negative integers .",
    "from now on , we fix an initial condition @xmath382 satisfying @xmath383    let us switch back to the markov chain @xmath307 . set @xmath384 if @xmath385 , then we check by direct inspection that : @xmath386 where @xmath92 is a deterministic function .",
    "we have in particular @xmath387 $ } } } \\ = \\ \\mu(3,2 ' ) + \\mu(3,3 ' ) - \\mu(1,1 ' ) - \\mu(2 , 1'),\\\\ \\beta &   \\stackrel{\\mbox{def}}{= } & { \\ensuremath{\\text{{e}$\\left[\\delta l(n ) \\ ; | \\ ; l(n ) >    0 , x_2(n ) = y_2(n ) = 0\\right]$ } } } \\ = \\",
    "\\mu(2 , 3 ' ) + \\mu(3,2 ' ) + \\mu(3,3 ' ) - \\mu(1,1 ' ) , \\\\",
    "\\gamma & \\stackrel{\\mbox{def}}{= } & { \\ensuremath{\\text{{e}$\\left[\\delta l(n ) \\ ; | \\ ; l(n ) > 0 , x_2(n ) > 0\\right]$ } } } \\",
    "\\mu(2 , 3 ' ) + \\mu(3,3 ' ) - \\mu(1,1 ' ) - \\mu(1,2').\\end{aligned}\\ ] ]    let us turn again to the auxiliary chain @xmath371 . by performing the computation",
    ", we get @xmath388$}}}= \\pi ( { \\mathbb z_-^ * } ) \\alpha + \\pi ( 0 ) \\beta + \\pi ( { \\mathbb z_+^ * } ) \\gamma \\:.\\ ] ] the ergodic theorem for markov chains , see for instance @xcite , gives : @xmath389 assume that @xmath390 .",
    "then we have : @xmath391 therefore , for each @xmath392 , there exists @xmath393 such that @xmath394    let us switch back to the markov chain @xmath395 .",
    "choose the initial condition @xmath396 such that @xmath397 where @xmath398 is defined in . by construction , on the event @xmath399 , we have @xmath400 so , on the event @xmath198 , we have @xmath401 we conclude that the markov chain @xmath307 of the nn - model is transient .",
    "we now show that the stability region is not maximal , by giving an example such that @xmath402 .",
    "consider @xmath403 , @xmath404 , and @xmath405 .",
    "thus conditions ncond are satisfied .",
    "however , we have : @xmath406 and @xmath407 this gives @xmath408 , and , @xmath409 this completes the proof .",
    "consider now the ms policy .",
    "set @xmath410 .",
    "the initial distribution can be taken such that @xmath411 modulo these modifications , the proof carries over unchanged .",
    "in this section , we show that the ml policy has a maximal stability region .",
    "the idea of the proof is as follows . consider the quadratic lyapunov function : @xmath412 observe that the ml policy minimizes the value of this lyapunov function at each step .",
    "we introduce an alternate policy that depends on the arrival distribution @xmath2 . for this policy ,",
    "we manage to prove that the quadratic lyapunov function has a negative drift outside a finite region .",
    "we introduce an alternate matching policy .",
    "this policy is admissible , corresponds to a commutative state space , but does not belong to the policies listed in  [ sse - match ] .",
    "it is a random policy and its specificity is to be facet dependent .",
    "let us describe the alternate policy on a non - empty facet @xmath70 .",
    "set @xmath413 etc . to describe the matching policy",
    ", the only thing we have to describe is the way to match an arriving customer of class @xmath414 , resp .",
    "server of class @xmath415 .",
    "let us concentrate first on a server of class @xmath415 .    from ncond",
    ": @xmath416 we build a directed graph as in but restricted to the nodes in @xmath417 and @xmath418 .",
    "formally , @xmath419 endow the arcs of @xmath420 with infinite capacity , an arc of type @xmath173 with capacity @xmath174 , and an arc of type @xmath175 with capacity @xmath176 .",
    "as in lemma [ le - flow ] , ncond implies that the minimal cut of @xmath421 has capacity @xmath422 .",
    "any maximal flow @xmath423 is such that : @xmath424 , @xmath425 .",
    "let us prove that there exists a maximal flow @xmath186 such that : @xmath426 define @xmath226 on @xmath418 by @xmath427 . here",
    "@xmath428 is chosen to be small enough so that : @xmath429 .",
    "this is possible since ncond are open conditions .",
    "consider the same network as above but with the capacities @xmath430 on the arcs @xmath175 .",
    "the minimal cut still has capacity @xmath422 .",
    "a maximal flow @xmath186 is such that : @xmath431 , @xmath432 .",
    "clearly , @xmath186 is also a flow for the original network .",
    "the server @xmath415 is matched to @xmath433 randomly , independently of the past , with probability : @xmath434 \\:.\\ ] ] let us check that this defines indeed a probability : @xmath435 \\\\ & = &   \\frac{1}{\\mu_s(s ) } \\bigl [ \\ \\mu_s(s)-t(s , f )   + t(s , f ) \\",
    "\\bigr ] \\ \\",
    "=    \\ \\   1 \\:.\\end{aligned}\\ ] ] for @xmath436 , @xmath437 , set @xmath438 . for @xmath436 ,",
    "set @xmath439 .",
    "we have @xmath440 .",
    "observe that : @xmath441    symmetrically , we define the directed graph of type but on the nodes @xmath442 and @xmath443 .",
    "we build a maximal flow on this new graph as above , and based on this flow , we define the probability @xmath444 that a customer @xmath445 is matched to a server @xmath446 . for @xmath447 , we define @xmath448 , and @xmath449 accordingly .",
    "we have @xmath450 .",
    "the arriving server is not matched with @xmath5 .",
    "this may occur in two possible ways : either the arriving server is of class @xmath457 , or the arriving server is of class @xmath437 but is not matched with @xmath5 ( probability @xmath458 ) .        using ( [ eq : vn ] )",
    ", we get : @xmath461 thus , @xmath462 . observe that @xmath463 .",
    "we get , for @xmath464 and @xmath465 : @xmath466 $ } } } & = \\beta_c ( 2 x_c + 1 ) - \\alpha_c(2 x_c -1 ) \\\\ & = 2\\beta_c - \\varepsilon_c ( 2 x_c -1)\\\\ & < 2\\mu_c(c)- \\varepsilon_c x_c.\\end{aligned}\\ ] ]    let @xmath467 be the quadratic lyapunov function .",
    "define @xmath468 .",
    "set @xmath469 .",
    "then ( the first term in the sum takes care of the vertices in @xmath470 and @xmath471 ) : @xmath472 $ } } } & <    2 + \\sum_{c \\in \\cb } \\left ( 2\\mu_c(c ) - \\varepsilon_c x_c   \\right ) + \\sum_{s \\in \\sb } \\left ( 2 \\mu_s(s ) - \\varepsilon_s y_s   \\right ) \\\\ & < 2 + 2 \\mu_c(\\cb ) + 2 \\mu_s(\\sb ) -",
    "\\varepsilon \\left(\\sum_{c \\in \\cb}x_c+\\sum_{s \\in \\sb}y_s \\right )   \\\\ & < 6 - 2\\:\\varepsilon \\sum_{c \\in c}x_c \\:.\\end{aligned}\\ ] ] fix @xmath473 . if @xmath474 , then @xmath475 $ } } } < -\\delta$ ] .",
    "there are finitely many facets , so there is a finite set @xmath476 such that @xmath477 $ } } } < -\\delta \\:.\\ ] ] by the lyapunov - foster s theorem , see for instance @xcite , the alternate matching policy is stable .",
    "many open questions remain .",
    "first , we do not know if the stability region is always maximal for the fifo and random policies .",
    "numerical experiments seem to indicate that it is indeed the case .",
    "second , for the ms and priority policies , we know that the stability region is not always maximal , but we do not know how to compute it .",
    "last , we would like to obtain sufficient conditions for stability , valid for all admissible policies , and which are better than the ones of  [ se - suff ] ."
  ],
  "abstract_text": [
    "<S> we consider the bipartite matching model of customers and servers introduced by caldentey , kaplan , and weiss ( adv . </S>",
    "<S> appl . </S>",
    "<S> probab . , 2009 ) . </S>",
    "<S> customers and servers play symmetrical roles . </S>",
    "<S> there is a finite set @xmath0 , resp . </S>",
    "<S> @xmath1 , of customer , resp . </S>",
    "<S> server , classes . </S>",
    "<S> time is discrete and at each time step , one customer and one server arrive in the system according to a joint probability measure @xmath2 on @xmath3 , independently of the past . also , at each time step </S>",
    "<S> , pairs of _ matched _ customer and server , if they exist , depart from the system . authorized _ </S>",
    "<S> matchings _ are given by a fixed bipartite graph @xmath4 . </S>",
    "<S> a _ matching policy _ is chosen , which decides how to match when there are several possibilities . </S>",
    "<S> customers / servers that can not be matched are stored in a buffer . </S>",
    "<S> the evolution of the model can be described by a discrete time markov chain . </S>",
    "<S> we study its stability under various admissible matching policies including : ml ( match the longest ) , ms ( match the shortest ) , fifo ( match the oldest ) , priorities . </S>",
    "<S> there exist natural necessary conditions for stability ( independent of the matching policy ) defining the maximal possible stability region . </S>",
    "<S> for some bipartite graphs , we prove that the stability region is indeed maximal for any admissible matching policy . for the ml policy , we prove that the stability region is maximal for any bipartite graph . for the ms and priority policies , we exhibit a bipartite graph with a non - maximal stability region .    </S>",
    "<S> * keywords : * markovian queueing theory , stability , bipartite matching .    </S>",
    "<S> * mathematics subject classification ( msc2010 ) : * 60j10 , 60k25 , 68m20 , 05c21 . </S>"
  ]
}