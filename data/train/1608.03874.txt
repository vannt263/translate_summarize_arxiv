{
  "article_text": [
    "the last few years , cooperative transmission has become widely prominent with the increases in the size of communication networks . in wireless networks , the transmitted message from a node is heard not only by its intended receiver , but also by other neighbour nodes and those neighbour nodes can use the received signals to help transmission .",
    "they bring a cooperative transmission by acting as relays .",
    "the relay channel first introduced by van der meulen in @xcite and it consists of a source aiming to communicate with a destination with the help of a relay . in this case",
    ", we call the relay channel _ one - way relay channel _ or _ single relay channel_. in @xcite , cover and el gamal proposed the fundamental _ decode - forward _ ( df ) and _ compress - forward _ ( cf )",
    "schemes for the one - way relay channels which achieve near capacity rates . in df scheme ,",
    "the relay decodes the messages from the source and forwards them to the destination . in cf scheme",
    ", the relay compresses received signals and forwards the compression indices .",
    "it is proved that the df scheme is optimal for these types of channels : for physically degraded relay channels @xcite in which the output observed at the receiver is a degraded version of the channel output at the relay , for semi - deterministic channels @xcite in which the channel output at the relay is a deterministic function of the channel input at the transmitter and the channel input at the relay . the exact capacity of general relay channels is not known to date , although , there exist tight capacity approximations for a large class of networks @xcite , and schemes like df and cf achieve near - capacity rates .",
    "the upper bound on capacity is given by the cut - set upper bound @xcite and the lower bound is given by chong et al . in @xcite .",
    "the scheme in @xcite is a block - markov transmission scheme that is a combination of the df scheme and the cf scheme .",
    "the one - way relay channel can be extended to the _ two - way relay channel _",
    ", where a relay helps two users exchange their messages .",
    "two types of two - way relay channels can be considered , that is , without a direct link between the two users , and with a direct link between the two users .",
    "the former is a suitable model for wired communication and the latter is suitable for wireless communication .",
    "applications of relay cooperation can be seen in increasing the capacity @xcite , combating the fading effect @xcite , mitigating the effects of interference @xcite and increasing the physical layer security @xcite .",
    "however , df scheme has been used in numerous applications , it achieves capacity only in special few cases . all of these approaches are using random gaussian coding which is impractical for implementation .",
    "thus , applying df scheme in a practical scenario is interesting .",
    "one of the research areas that has such potential is lattice theory .",
    "an @xmath0 dimensional lattice in @xmath1 is the set of integer linear combinations of a given basis with @xmath0 linearly independent vectors in @xmath1 . using lattices for communication over the real awgn channel ,",
    "has been investigated by poltyrev @xcite .",
    "in such a communication system , instead of the coding rate and capacity , normalized logarithmic density ( nld ) and generalized capacity @xmath2 have been introduced , respectively . using construction d of lattices @xcite , the existence of sphere - bound - achieving and capacity - achieving lattices has been proved by forney et al .",
    "a capacity - achieving lattice code can be obtained from a capacity - achieving lattice together with a proper shaping region @xcite .",
    "lattice codes are the euclidean - space analog of linear codes .",
    "researchers have also studied practical lattice codes .",
    "the search for practical implementable capacity - achieving lattices and lattice codes started by proposing low density parity check ( ldpc ) lattices  @xcite . in this class of lattices , a set of nested ldpc codes and construction d of lattices @xcite are used to generate lattices with sparse parity check matrices .",
    "another class of lattices , called low density lattice codes ( ldlc ) , introduced and investigated in @xcite .",
    "turbo lattices employed construction d along with turbo codes to achieve capacity gains @xcite .",
    "low density construction a ( lda ) lattices @xcite are another class of lattices with near - capacity error performance and low - complexity , low - storage decoder",
    ". an lda lattice can be obtained from construction a @xcite with a non - binary ldpc code as its underlying code .",
    "the use of lattice codes in relay networks has received significant attentions in recent years @xcite , @xcite , @xcite @xcite , @xcite , @xcite .",
    "it was shown in @xcite and @xcite that lattice codes can achieve the df rates for the relay channel .",
    "all of these achievable schemes rely on asymptotic code lengths , which is a drawback in practical implementation . recently ,",
    "aazhang et al .",
    "proposed a practical scheme based on ldlcs , for the real - valued , full - duplex one - way and two - way relay channels @xcite . in this work",
    ", we propose another class of practical , efficient lattice codes , based on ldpc lattices , for the real - valued , full - duplex one - way and two - way relay channels .",
    "the rest of this paper is organized as follows .",
    "section  [ system_model ] introduces the system models of the one - way and two - way relay channels .",
    "section  [ lattice ] presents the preliminaries on lattices and lattice codes . in section  [ ldpc lattices ] , we introduce ldpc lattices .",
    "the encoding and decoding of these lattices are also presented in this section . in section  [ shaping_sec ]",
    ", we consider the application of the ldpc lattices in the power constrained awgn channels by presenting two efficient shaping methods , based on hypercube shaping and nested lattice shaping . in section  [ one_way_channel ] , we adapt our shaping algorithms that enable us to do the decomposition of the ldpc lattices into lower - rate components without loss of shaping efficiency .",
    "then , we present a practical block markov scheme for the real - valued , full - duplex one - way relay channels , based on ldpc lattices . in section  [ two_way_channel_sec ] , we present another decomposition method based on doubly nested ldpc lattices , for the two - way relay channels . finally , in section  [ numerical results ] , we examine the practical performance of our proposed schemes .",
    "section  [ conclusions ] contains the concluding remarks .",
    "the relay channel that we have considered , is a three - terminal relay channel .",
    "first , we present the one - way relay channel , depicted in  ( a ) .",
    "the source transmits a message , which is mapped to a codeword , to both relay and destination and in the next time slot relay aids the destination by sending the part of the information of the previous time slot .",
    "we assume a full - duplex relay which can simultaneously transmit and receive the massages . for simplicity",
    "we suppose real - valued channels .",
    "( 5.,-57 . )",
    "rectangle ( 136.,-25 . ) ; ( 67.21748791714167,-32.21948106496881 )  ( 52.21748791714167,-32.21948106496881 )  ( 51.490059965882836,-32.48807198275779 )  ( 51.21748791714167,-33.21948106496881 )  ( 51.21748791714167,-36.219481064968804 )  ( 51.48476550176804,-36.95578284369824 )  ( 52.21748791714167,-37.219481064968804 )  ( 67.21748791714167,-37.219481064968804 )  ( 67.95243514205762,-36.95561431076526 )  ( 68.21748791714167,-36.219481064968804 )  ( 68.21748791714167,-33.21948106496881 )  ( 67.9514822812876,-32.484145066191346 )  cycle ; ( 22.217487917141618,-32.21948106496881 )  ( 7.21748791714162,-32.21948106496881 )  ( 6.490059965882777,-32.48807198275779 )  ( 6.21748791714162,-33.21948106496881 )  ( 6.21748791714162,-36.219481064968804 )  ( 6.484765501767987,-36.95578284369824 )  ( 7.21748791714162,-37.219481064968804 )  ( 22.217487917141618,-37.219481064968804 )  ( 22.952435142057574,-36.95561431076526 )  ( 23.217487917141618,-36.219481064968804 )  ( 23.217487917141618,-33.21948106496881 )  ( 22.951482281287547,-32.484145066191346 )  cycle ; ( 44.69811370147054,-47.22790740491434 )  ( 29.698113701470568,-47.22790740491434 )  ( 28.9706857502117,-47.49649832270332 )  ( 28.698113701470568,-48.22790740491434 )  ( 28.69811370147054,-51.22790740491434 )  ( 28.96539128609691,-51.96420918364377 )  ( 29.69811370147054,-52.22790740491434 )  ( 44.69811370147054,-52.227907404914355 )  ( 45.4330609263865,-51.9640406507108 ) ",
    "( 45.698113701470554,-51.227907404914355 ) ",
    "( 45.698113701470554,-48.22790740491434 ) ",
    "( 45.43210806561647,-47.492571406136875 )  cycle ; ( 88.82519949396965,-32.46041161184824 )  ( 73.82519949396965,-32.46041161184824 ) ",
    "( 73.09777154271082,-32.72900252963721 ) ",
    "( 72.82519949396965,-33.46041161184824 ) ",
    "( 72.82519949396965,-36.46041161184824 ) ",
    "( 73.09247707859603,-37.19671339057766 )  ( 73.82519949396965,-37.46041161184822 ) ",
    "( 88.82519949396965,-37.46041161184822 ) ",
    "( 89.56014671888562,-37.19654485764469 ) ",
    "( 89.82519949396965,-36.46041161184824 ) ",
    "( 89.82519949396965,-33.46041161184824 ) ",
    "( 89.55919385811558,-32.725075613070764 )  cycle ; ( 133.80047395779474,-32.47152777316628 )  ( 118.80047395779472,-32.47152777316628 ) ",
    "( 118.07304600653588,-32.74011869095526 ) ",
    "( 117.80047395779472,-33.47152777316628 ) ",
    "( 117.80047395779472,-36.47152777316628 ) ",
    "( 118.06775154242108,-37.207829551895706 ) ",
    "( 118.80047395779472,-37.47152777316628 )  ( 133.80047395779474,-37.47152777316628 ) ",
    "( 134.53542118271065,-37.207661018962746 ) ",
    "( 134.80047395779474,-36.47152777316628 ) ",
    "( 134.80047395779474,-33.47152777316628 ) ",
    "( 134.53446832194066,-32.73619177438882 )  cycle ; ( 111.28109974212362,-47.479954113111795 )  ( 96.28109974212362,-47.479954113111795 ) ",
    "( 95.55367179086474,-47.74854503090078 ) ",
    "( 95.28109974212362,-48.479954113111795 ) ",
    "( 95.28109974212362,-51.479954113111795 ) ",
    "( 95.54837732674994,-52.21625589184122 ) ",
    "( 96.28109974212362,-52.47995411311181 ) ",
    "( 111.28109974212362,-52.47995411311181 ) ",
    "( 112.01604696703953,-52.21608735890826 ) ",
    "( 112.28109974212362,-51.479954113111795 ) ",
    "( 112.28109974212362,-48.479954113111795 )  ( 112.01509410626954,-47.74461811433434 )  cycle ; ( 7.21748791714162,-32.21948106496881) ( 22.217487917141618,-32.21948106496881 ) ; ( 7.21748791714162,-37.219481064968804) ( 22.217487917141618,-37.219481064968804 ) ; ( 6.21748791714162,-33.21948106496881) ( 6.21748791714162,-36.219481064968804 ) ; plot[domain=1.5707963267948966:3.141592653589793,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 23.217487917141618,-33.21948106496881) ( 23.217487917141618,-36.219481064968804 ) ; plot[domain=3.141592653589793:4.71238898038469,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=0.:1.5707963267948966,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=-1.5707963267948966:0.,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 52.21748791714167,-32.21948106496881) ( 67.21748791714167,-32.21948106496881 ) ; ( 52.21748791714167,-37.219481064968804) ( 67.21748791714167,-37.219481064968804 ) ; ( 51.21748791714167,-33.21948106496881) ( 51.21748791714167,-36.219481064968804 ) ; plot[domain=1.5707963267948966:3.141592653589793,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 68.21748791714167,-33.21948106496881) ( 68.21748791714167,-36.219481064968804 ) ; plot[domain=3.141592653589793:4.71238898038469,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=0.:1.5707963267948966,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=-1.5707963267948966:0.,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 29.698113701470568,-47.22790740491434) ( 44.69811370147054,-47.22790740491434 ) ; ( 29.698113701470568,-52.207120204149255) ( 44.69811370147054,-52.227907404914355 ) ; ( 28.698113701470568,-48.22790740491434) ( 28.698113701470568,-51.207120204149255 ) ; plot[domain=1.5707963267948966:3.141592653589793,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 45.698113701470554,-48.22790740491434) ( 45.698113701470554,-51.227907404914355 ) ; plot[domain=3.141592653589793:4.71238898038469,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=0.:1.5707963267948966,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=-1.5707963267948966:0.,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 23.217487917141618,-34.719481064968804 ) ",
    "( 51.21748791714167,-34.72874555724628 ) ; ( 13.580557760431486,-31.894304393840127 ) node[anchor = north west ] @xmath3 ; ( 58.151882220748504,-31.74423259431044 ) node[anchor = north west ] @xmath4 ; ( 35.49104049176577,-47.05155614633853 ) node[anchor = north west ] @xmath5 ; ( 22.217487917141618,-37.219481064968804 ) ",
    "( 35.180406011112964,-47.22790740491434 ) ; ( 39.13768193920707,-47.22790740491434 ) ",
    "( 52.21748791714167,-37.219481064968804 ) ; ( 35.94125589035484,-28.592724804187007 ) node[anchor = north west ] @xmath6 ; ( 23.03508113080176,-40.14825336797292 ) node[anchor = north west ] @xmath7 ; ( 47.49678445414073,-39.848109768913545 ) node[anchor = north west ] @xmath8 ; ( 35.94125589035484,-53.054428127526016 ) node[anchor = north west ] ( a ) ; ( 73.80047395779467,-32.47152777316628) ( 88.80047395779465,-32.47152777316628 ) ; ( 73.80047395779467,-37.47152777316628) ( 88.80047395779465,-37.47152777316628 ) ; ( 72.80047395779467,-33.47152777316628) ( 72.80047395779467,-36.47152777316628 ) ; plot[domain=1.5707963267948966:3.141592653589793,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 89.80047395779465,-33.47152777316628) ( 89.80047395779465,-36.47152777316628 ) ; plot[domain=3.141592653589793:4.71238898038469,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=0.:1.5707963267948966,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=-1.5707963267948966:0.,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 118.80047395779472,-32.47152777316628) ( 133.80047395779474,-32.47152777316628 ) ; ( 118.80047395779472,-37.47152777316628) ( 133.80047395779474,-37.47152777316628 ) ; ( 117.80047395779472,-33.47152777316628) ( 117.80047395779472,-36.47152777316628 ) ; plot[domain=1.5707963267948966:3.141592653589793,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 134.80047395779474,-33.47152777316628) ( 134.80047395779474,-36.47152777316628 ) ; plot[domain=3.141592653589793:4.71238898038469,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=0.:1.5707963267948966,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=-1.5707963267948966:0.,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 96.28109974212362,-47.479954113111795) ( 111.28109974212362,-47.479954113111795 ) ; ( 96.28109974212362,-52.47995411311181) ( 111.28109974212362,-52.47995411311181 ) ; ( 95.28109974212362,-48.479954113111795) ( 95.28109974212362,-51.479954113111795 ) ; plot[domain=1.5707963267948966:3.141592653589793,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 112.28109974212362,-48.479954113111795) ( 112.28109974212362,-51.479954113111795 ) ; plot[domain=3.141592653589793:4.71238898038469,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=0.:1.5707963267948966,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; plot[domain=-1.5707963267948966:0.,variable=](1.*1.*cos(r)+0.*1.*sin(r),0.*1.*cos(r)+1.*1.*sin(r ) ) ; ( 81.80047395779465,-37.47152777316628 )  ( 95.28109974212362,-49.4315279994261 ) ; ( 95.28109974212362,-50.40898585229985 )  ( 80.80047395779465,-37.47152777316628 ) ; ( 112.28109974212362,-50.449155353102896 )  ( 126.80047395779474,-37.47152777316628 ) ; ( 125.80047395779471,-37.47152777316628 )  ( 112.28109974212362,-49.444917833027134 ) ; ( 89.80047395779465,-34.47152777316628 )  ( 117.80047395779472,-34.47152777316628 ) ; ( 117.80047395779472,-35.47152777316628 )  ( 89.80047395779465,-35.47152777316628 ) ; ( 79.46207775396404,-32.1944479928995 ) node[anchor = north west ] @xmath9 ; ( 124.03340221428105,-31.894304393840127 ) node[anchor = north west ] @xmath10 ; ( 102.42306308200614,-47.3516997453979 ) node[anchor = north west ] @xmath5 ; ( 102.57313488153582,-28.292581205127632 ) node[anchor = north west ] @xmath11 ; ( 102.57313488153582,-34.74566858490418 ) node[anchor = north west ] @xmath12 ; ( 91.3177499168093,-40.14825336797292 ) node[anchor = north west ] @xmath13 ; ( 83.21387274220622,-43.14968935856666 ) node[anchor = north west ] @xmath14 ; ( 111.72751465284674,-39.247822570794796 ) node[anchor = north west ] @xmath15 ; ( 119.9814636269795,-42.54940216044791 ) node[anchor = north west ] @xmath16 ; ( 102.57313488153582,-53.054428127526016 ) node[anchor = north west ] ( b ) ;    let @xmath17 and @xmath18 denote the signals transmitted by the source and the relay .",
    "let @xmath19 and @xmath20 denote the signals received at the relay and the destination .",
    "the received signals are @xmath21 where @xmath22 , @xmath23 .",
    "moreover , @xmath24 , @xmath25 , and @xmath26 are the channel gains between source , relay , and destination , which follow the usual path - loss model .",
    "in particular , we take the distance between source and destination to be unity , @xmath27 and @xmath28 to be the distance between source to relay and relay to destination , and @xmath29 and @xmath30 to be the corresponding path - loss exponents .",
    "we constrain the source and relay transmissions to have average power no greater than @xmath31 and @xmath32 .    in general",
    ", the capacity of this channel is unknown however , the df scheme which is proposed in @xcite , achieves the following inner bound : @xmath33 this rate can be achieved via _ block markov encoding_. after decoding the message , the relay re - encodes the message and transmits the corresponding codeword in the next block .",
    "the lattice - coding version of block markov encoding is proposed in @xcite .",
    "it is proved theoretically that it can achieve the decode - and - forward rates .",
    "the results of @xcite suggest that structured lattice codes may be used to outperform , random gaussian codes in general gaussian networks .",
    "the authors of @xcite have applied this scheme and designed a family of practically implementable ldlc lattice codes for relay channels . in this paper",
    "we present another family of lattice codes which are amenable to practical implementation in block markov schemes .",
    "@#1@@@(#1)@italiccorr next , we present the full - duplex gaussian two - way relay channel , as depicted in  ( b ) .",
    "the two sources @xmath9 and @xmath10 exchange their messages , which are mapped to codewords and transmitted over the wireless medium .",
    "the relay node @xmath5 overhears the noisy superposition of signals transmitted from sources and makes its own transmissions to facilitate communications .",
    "this channel can be modeled as follows @xmath34 where the noise components are @xmath22 , @xmath35 and @xmath36 .",
    "similar to the one - way relay channel model , @xmath37 , @xmath38 , @xmath15 , @xmath13 , @xmath14 and @xmath16 are the channel gains which follow the usual path - loss model .",
    "we constrain the sources @xmath9 , @xmath10 and relay @xmath5 transmissions to have average powers no greater than @xmath39 , @xmath40 and @xmath32 , respectively .",
    "the capacity of this channel is unknown , but a df scheme was presented in  @xcite that achieves rate pairs @xmath41 satisfying ( [ rate_bound2 ] ) , @xmath42^{+ } \\right\\},\\end{aligned}\\ ] ] in which @xmath43^{+}\\triangleq \\max \\left\\{x,0\\right\\}$ ] , @xmath44 , and @xmath45 .",
    "[ lattice ] a discrete , additive subgroup @xmath46 of the @xmath47-dimensional real space @xmath1 is a lattice .",
    "every lattice @xmath46 has a basis @xmath48 where every @xmath49 can be represented as an integer linear combination of vectors in @xmath50 .",
    "the rank of the lattice is @xmath0 and its dimension is @xmath47 . if @xmath51 , the lattice is called a full - rank lattice . in this paper , we consider full - rank lattices .",
    "the matrix @xmath52 with @xmath53 as rows , is a generator matrix for the lattice .",
    "the matrix @xmath54 is a gram matrix for the lattice .",
    "the determinant of the lattice @xmath55 is defined to be the determinant of the matrix @xmath56 and the volume of the lattice is defined as @xmath57 . a voronoi cell",
    "@xmath58 is the set of those points of @xmath59 that are at least as close to @xmath60 as to any other point in @xmath46 .",
    "we call the voronoi region associated with the origin , the fundamental voronoi region of @xmath46 , denoted by @xmath61 or @xmath62 .",
    "we say that a lattice @xmath63 is nested in @xmath64 if @xmath65 . using nested lattices in @xmath59 ,",
    "define the codebook @xmath66 which has the rate @xmath67 suppose that the points of a lattice @xmath46 are sent over an unconstrained awgn channel with noise variance @xmath68 .",
    "the volume - to - noise ratio ( vnr ) of lattice @xmath46 is defined as @xmath69 for a large @xmath0 , vnr is the ratio of the normalized volume of @xmath46 to the normalized volume of a noise sphere of squared radius @xmath70 which is defined as generalized signal - to - noise ratio ( snr ) in  @xcite and @xmath71 in @xcite .",
    "let @xmath72 be the transmitted vector on the unconstrained awgn channel , then the received vector @xmath73 can be written as @xmath74 , where @xmath75 and its components are independently and identically distributed ( i.i.d . )",
    "gaussian random variables with zero mean and variance @xmath68 .",
    "the probability of correct decoding , under maximum likelihood decoding , is given by @xmath76 where @xmath77 is the euclidean norm of @xmath60 .",
    "a lattice quantizer is a map @xmath78 for some lattice @xmath79 .",
    "if we use the nearest - neighbor quantizer @xmath80 , then the quantization error @xmath81 .",
    "let @xmath82 be uniformly distributed over the voronoi region @xmath62 .",
    "then , the _ second moment per dimension _ of @xmath46 is @xmath83=\\frac{1}{n}\\frac{1}{\\textrm{vol}(\\lambda)}\\int_{\\mathcal{v}(\\lambda)}\\|\\mathbf{x}_e\\|^2d\\mathbf{x}_e.\\ ] ]    a _ lattice constellation _ @xmath84 is the finite set of points in a lattice translate @xmath85 that lies within a compact bounding region @xmath86 of @xmath0-dimensional real space @xmath59 .",
    "the key geometric properties of the region @xmath86 are its _ volume _ @xmath87 and the _ average energy _ @xmath88 per dimension of a uniform probability density function over @xmath86 ( see , e.g. @xcite and @xcite ) : @xmath89 the _ normalized second moment _ of @xmath86 is defined as @xmath90 the normalized second moment of any @xmath0-cube centered at the origin is @xmath91 . the _ shaping gain _",
    "@xmath92 of @xmath86 , measures the decrease in average energy of @xmath86 relative to a baseline region , namely , an interval @xmath93 $ ] or an @xmath0-cube @xmath93^n$ ] , where @xmath94 is related to the @xmath87 @xcite .",
    "the definition of shaping gain is @xmath95 the optimum @xmath0-dimensional shaping region is an @xmath0-sphere  @xcite .",
    "the key geometrical parameters of an @xmath0-sphere @xmath96 of radius @xmath97 for an even @xmath0 are @xcite : @xmath98 the shaping gain of an @xmath0-sphere is a function of the dimension @xmath0 . when @xmath0 approaches infinity the shaping gain approaches the _ ultimate shaping gain _",
    "@xmath99 ( @xmath100db ) .",
    "the _ shaping loss _",
    "@xmath101 of a shaping region @xmath86 with respect to an @xmath0-dimensional sphere , where @xmath0 is even , based on ( [ spherev])-([sphereg ] ) , is  @xcite @xmath102 the shaping loss is greater than or equal to @xmath103 . if we form the intersection @xmath104 of a lattice with a shaping region @xmath105 , we would expect to obtain a code with about @xmath106 codewords  @xcite .",
    "in fact , by using minkowski - hlawka  theorem , it is proved that the value @xmath106 is correct in the average over a suitable set of lattices based on codes  @xcite .",
    "the rate of the code @xmath107 is approximately @xmath108",
    "[ ldpc lattices ] there exist many ways to construct lattices based on codes @xcite . here",
    "we mention two of them .",
    "the first one is construction a and the other one is construction d. assume that @xmath109 is a linear code over @xmath110 where @xmath111 is a prime number , i.e. @xmath112 . a lattice @xmath46 based on construction a  @xcite can be derived from @xmath109 as follows @xmath113 where @xmath114 is the embedding function .",
    "in this work , we are particularly interested in lattices with @xmath115 .",
    "construction d converts a set of parity checks defined by a family of nested codes @xmath116 , into congruences for a lattice  @xcite .",
    "the number @xmath117 is called the level of the construction .",
    "an ldpc lattice @xmath118 can be constructed from construction d and a number of nested binary ldpc codes .",
    "more detail about the structure and decoding of these lattices can be found in @xcite .",
    "if we consider one code as underlying code of construction d , which means @xmath119 , construction a is obtained  ( * ? ? ?",
    "* proposition 1 ) . in this case",
    ", construction a ldpc lattices or 1-level ldpc lattices @xcite will be obtained . in this paper",
    ", we refer to them as ldpc lattices without mentioning the level of the construction .",
    "an ldpc lattice @xmath46 is a lattice constructed based on construction a or d along with one binary ldpc code @xmath109 as its underlying code .",
    "equivalently , @xmath120 is in @xmath46 if and only if @xmath121 , where @xmath122 is the parity check matrix of @xmath109 .",
    "the generator matrix of construction a lattice @xmath46 using the underlying code @xmath123 is of the form @xmath124,\\end{aligned}\\ ] ] where @xmath125 $ ] is the generator matrix of @xmath109 in systematic form , @xmath126 is the rank of @xmath109 , @xmath127 and @xmath128 , are identity and all zero square matrices of size @xmath126 , respectively .      the practical",
    "encoding and decoding of ldpc lattices , both with linear complexity in the dimension of the lattice , has been addressed in @xcite . in this paper , we consider a translated and scaled version of the lattice @xmath46 , generated by ( [ eq12 ] ) , as suggested in @xcite and @xcite . in the sequel , we present the decoding of these scaled and translated versions of ldpc lattices , which is proposed in @xcite and it is obtained by combining the suggested decoding method in @xcite , and the decoding of binary ldpc codes .",
    "construction and decoding of these new lattices can be done using the following steps .",
    "first , convert the codewords of @xmath129 $ ]  binary code @xmath109 into @xmath130 notation ( convert @xmath131 to @xmath132 and @xmath103 to @xmath103 ) @xcite which produces a set @xmath133 consisting of the vectors of the form @xmath134 the set of points in ( [ newlattice ] ) strictly speaking , is not a lattice , but the translate of a lattice by the vector @xmath135 .",
    "the regular addition of vectors of the form ( [ newlattice ] ) will not be of the same form .",
    "however , we can show that @xmath133 is closed under following addition . for any @xmath136",
    ", we have @xcite @xmath137 the encoding of an integer row vector @xmath138 can be done as follows @xmath139 where @xmath140 is encoding function and @xmath141 is defined as ( [ eq12 ] ) .",
    "let @xmath142 be the transmitted lattice vector and @xmath143 be the received vector from awgn channel @xmath144 where @xmath145 and @xmath109 is a binary ldpc code in @xmath130 notation , @xmath146 and @xmath147 .",
    "first , we decode @xmath148 and next we find @xmath149 .",
    "the proposed algorithm in @xcite is similar to the sum - product algorithm ( spa ) for ldpc codes in message passing structure  @xcite .",
    "the inputs are the log likelihood ratios ( llr ) for the a priori message probabilities from each channel .",
    "the estimation of the llr vector @xmath150 for ldpc lattices is proposed in @xcite as follows @xmath151 where @xmath152 is the nearest integer to @xmath153 .",
    "input the llr vector @xmath154 to spa decoder of ldpc codes and consider @xmath155 as the output of this decoder .",
    "convert @xmath155 to @xmath130 notation and call the obtained vector @xmath156 .",
    "estimate @xmath157 as follows @xmath158 then , @xmath159 is the final decoded lattice vector .",
    "the complexity of this decoding algorithm is significantly lower than other lattices with practical decoding algorithm like lda lattices @xcite and ldlcs @xcite .",
    "the decoding algorithm of ldlcs first proposed in  @xcite which has complexity @xmath160 , where @xmath161 is the resolution and its typical value is @xmath162 , @xmath0 is the dimension of lattice , @xmath163 is the number of iterations and @xmath164 is the average code degree . then , in  @xcite , a new algorithm proposed with lower complexity @xmath165 , where @xmath166 is the number of replications , @xmath0 , @xmath163 and @xmath164 are similar to above .",
    "proposed typical value for @xmath166 is @xmath167 and for @xmath168 it is @xmath169 or @xmath170 .",
    "the computational complexity of the proposed decoding algorithm in @xcite is only @xmath171 , which is significantly lower than the complexity of ldlcs decoding .",
    "the main purpose of this section , is constructing practically implementable lattice constellations . as we mentioned in previous section , definition of lattice constellations",
    "entails finding the intersection of shaping region and a translated infinite lattice .",
    "thus , translating by @xmath172 in the proposed structure has no inconsistency with the definition of lattice codes . in the next section , we present efficient shaping methods to obtain a family of lattice codes based on ldpc lattices .",
    "in practical channels , there exists a power constraint which is needed to be fulfilled .",
    "this entails selecting a group of lattice points with a bounded norm . in theoretical approaches ,",
    "the coding lattice is intersected with a spherical shaping region to produce an efficient , power - constrained lattice code",
    ". however , spherical shaping has high computational complexity both for encoding and decoding . in @xcite , several efficient and practical shaping algorithms proposed for ldlc lattices . here",
    ", we present an efficient and practical shaping algorithm for ldpc lattices based on hypercube shaping method .    in order to perform shaping , restrict the integer vector @xmath173 to the following finite constellation @xmath174 shape the lattice codeword @xmath175 by translating each @xmath176 by an integer multiple of @xmath177 , @xmath178 .",
    "this is equivalent to transmitting a lattice point @xmath179 as follows @xmath180 where @xmath181 is a diagonal matrix and the new integer vector is @xmath182 .",
    "the choice of integer vector @xmath183 , depends on the employed shaping method . in hypercube",
    "shaping we choose @xmath183 such that the new lattice codeword components are constrained to lie in the hypercube , i.e. @xmath184 , for @xmath185 .",
    "the authors of @xcite used a triangular structure for @xmath122 , the inverse of their generator matrix @xmath56 , with unit diagonal elements . in this case ,",
    "hypercube shaping is straightforward , and @xmath186 and @xmath187 will be found recursively .",
    "instead , we use the generator matrix of the lattice for shaping . in our case",
    ", the generator matrix beside the triangular structure , has a simpler form which helps us to obtain the components of @xmath183 directly .",
    "since we have used a translated and scaled lattice , we shape the lattice vectors inside the hypercube around the origin of coordinate .",
    "then , we scale them by factor @xmath169 and translate them by the all @xmath132 vector . to this end , we need to solve the following system of linear equations @xmath188,\\ ] ] by choosing an integer vector @xmath189 such that @xmath184 for @xmath185 . from ( [ shaping_system ] )",
    ", we have the following equations @xmath190 by choosing @xmath191 , we have @xmath192 and @xmath193 , for @xmath194 . for @xmath195",
    ", we have the following inequalities @xmath196 or equivalently @xmath197 this interval contains only one integer number which is the unique solution @xmath198    note that , after finding the shaped lattice codeword as discussed above , we must scale it by factor @xmath169 and then translate it by @xmath199 .",
    "then , the shaped vectors of @xmath200 will be uniformly distributed over hypercube @xmath201 , where @xmath202 since , the lattice @xmath203 and shaping region @xmath204 are translated by the same vector and @xmath205 , based on  ( [ rate_loeliger ] ) , the rate of our scheme is @xmath206    algorithm  [ unshaped ] explains the method of obtaining original information @xmath173 from shaped lattice codeword @xmath179 .",
    "the complexity of this algorithm is @xmath207 , where @xmath164 is the average number of nonzero elements in a row of @xmath141 .",
    "@xmath208 @xmath209 .",
    "@xmath210 * return * @xmath211 .      despite of its low complexity nature ,",
    "hypercube shaping suffers a performance loss of @xmath100db in high dimensions compared to optimal hypersphere shaping @xcite .",
    "thus , we consider nested lattice shaping , which is suboptimal but it offers more shaping gains comparing to hypercube shaping  @xcite .",
    "first , limit the rate of the code by restricting the integer row vector @xmath173 to take values from a finite constellation in which @xmath212 for each @xmath213 .",
    "similar to the hypercube shaping , let @xmath214 . in this case",
    ", we choose the vector @xmath183 as follows @xmath215 choosing @xmath183 that minimizes @xmath216 is equivalent to finding the nearest lattice point of the scaled lattice @xmath217 to the non - shaped lattice point @xmath60 .",
    "therefore , the codewords will be uniformly distributed along the voronoi cell of the coarse lattice @xmath217 .",
    "thus , the rate of the code is @xmath218 the complexity of solving  ( [ nested_lattice ] ) is exponential in the dimension of lattice , even by restricting the components of @xmath173 . using the triangular structure of the parity check matrix @xmath122 , the authors of  @xcite suggested a tree search with affordable complexity for shaping their lattices .",
    "practically , their tree search can be done with simple sub - optimal sequential decoders such as the @xmath168-algorithm  @xcite . following their method",
    ", we present a nested lattice shaping by using the triangular structure of our generator matrix .",
    "our algorithm starts from the first row of @xmath141 , and sequentially goes down along the rows .",
    "the input at row @xmath219 is a list of up to @xmath168 candidate sequences @xmath220 for @xmath221 . for @xmath222 the list",
    "is initialized with a single empty sequence .",
    "each of these @xmath168 sequences will be extended to @xmath223 , for @xmath224 , where @xmath225 takes all possible values for @xmath186 .",
    "the algorithm assigns to each extended sequence a respective score @xmath226 .",
    "the scores are sorted , and the @xmath168 sequences with smallest score are retained as input to the next row . finally , we choose @xmath183 as the sequence with smallest score after processing of the last row @xmath227 .",
    "the storage and the computational complexity of this algorithm are determined by the value of @xmath168 , as @xmath228 . using an @xmath168-algorithm with @xmath229 , nested lattice shaping is equivalent to hypercube shaping , where for @xmath230 , the algorithm is a full exponential tree search that finds the exact solution for @xmath183 . the shaping gain and shaping loss of ldpc lattice codes",
    "are presented in  .",
    "the results are obtained by using monte carlo simulation and @xmath231 assumed to be @xmath232 .",
    "an @xmath168-algorithm with @xmath233 has been applied for nested lattice shaping .",
    "the results show that increasing the rate of the code , used as underlying code of the lattice , declines the shaping gain for hypercube shaping but it improves the shaping gain for nested lattice shaping . increasing the dimension of the lattice also improves the shaping gain for both of the applied shaping methods .",
    "thus , the reasonable shaping gains can be obtained by applying nested lattice shaping for high dimensional ldpc lattices , which have high rate ldpc codes as their underlying codes .",
    "[ table1 ]    cc|c|c||c|c| & & + & @xmath234 & shaping gain & shaping loss & shaping gain & shaping loss + & @xmath232 & @xmath235 & @xmath236 & @xmath237 & @xmath238 + & @xmath232 & @xmath239 & @xmath240 & @xmath241 & @xmath242 + & @xmath232 & @xmath243 & @xmath244 & @xmath245 & @xmath246 + & @xmath232 & @xmath247 & @xmath248 & @xmath249 & @xmath250 + & @xmath232 & @xmath251 & @xmath252 & @xmath253 & @xmath254 + & @xmath232 & @xmath255 & @xmath256 & @xmath257 & @xmath258 + & @xmath232 & @xmath259 & @xmath260 & @xmath261 & @xmath262 + & @xmath232 & @xmath263 & @xmath264 & @xmath265 & @xmath266 + & @xmath232 & @xmath267 & @xmath268 & @xmath269 & @xmath270 +",
    "in this section , we construct a lattice - coding scheme base on ldpc lattice codes that achieves the decode - and - forward bound of ( [ rate_bound ] ) .",
    "we present our scheme by following the scheme of @xcite for ldlcs .",
    "all steps of this scheme are rephrased due to the inherent differences between ldpc lattice codes and ldlcs .      based on block markov encoding and decomposition of the full lattice codebook into lower - rate codebooks",
    ", we can propose an encoding / decoding scheme for implementing ldpc lattice codes on one - way relay channels .",
    "let @xmath138 be the information vector , where each element @xmath176 is drawn from the finite constellation of ( [ constelation ] ) .",
    "then , we define the @xmath271 element of the _ resolution component _ @xmath272 as @xmath273 where @xmath274 is a @xmath126-element subset of @xmath275 , whose members are chosen randomly .",
    "let @xmath276 be the _ vestigial component _ vector .",
    "define the the @xmath271 element of @xmath277 as follows @xmath278 based on ( [ constelation_r ] ) and ( [ constelation_v ] ) , define the resolution lattice codeword @xmath279 and the vestigial lattice codeword @xmath280 , where @xmath140 is defined by ( [ encoding ] ) .",
    "it can be easily checked that the original lattice codeword @xmath281 is the sum of its resolution and vestigial components , that is @xmath282      in preceding subsection , we used unconstrained powers for codewords @xmath60 , @xmath283 and @xmath284 , due to the fact that we still have not enforced shaping for the lattice . linear decomposition is straightforward in the unconstrained power situation , but it is not trivial with power constrained scenario .",
    "we use the altered version of the proposed method in @xcite with the proposed hypercube shaping method of section  [ ldpc lattices ] .",
    "the steps of this method are as follows :    1 .",
    "map the information integer vector @xmath173 to @xmath285 such that the @xmath271 element of @xmath285 is @xmath286 and @xmath287 the power - constrained lattice codeword is then given as @xmath288 .",
    "2 .   decompose the original integer information vector @xmath173 as in ( [ constelation_r ] ) and ( [ constelation_v ] ) .",
    "3 .   map the resolution component @xmath272 to @xmath289 such that the new integer vector results in a power - constrained codeword : @xmath290 where @xmath291 and @xmath292 are the @xmath271 elements of @xmath272 and @xmath289 , respectively .",
    "for hypercube shaping , @xmath293 can be written as , @xmath294 where @xmath295 .",
    "then , the mapped lattice codeword is @xmath296 .",
    "4 .   for the sake of preserving the linearity of the lattice decomposition , we map the vestigial information vector @xmath277 to @xmath297 such that the @xmath298 element of @xmath297 is given as , @xmath299 where @xmath186 and @xmath293 are given in ( [ si2 ] ) and ( [ sri ] ) , respectively .",
    "then , the vestigial codeword @xmath300 can be obtained as @xmath301 .",
    "the primary information integers @xmath176 , @xmath291 and @xmath302 can be recovered from @xmath303 , @xmath291 and @xmath302 by modulo @xmath177 operation .",
    "it must be noted that the lattice codeword @xmath179 and the resolution lattice codeword @xmath304 respect the power constraint but , the vestigial lattice codeword @xmath300 may not fulfil the power constraint in general .",
    "however , this is not a problem for the considered relay network since we do not transmit the vestigial information alone . in order to obtain further shaping gain ,",
    "we employ nested lattice shaping in our decomposition . in this case , we find the vectors @xmath183 and @xmath305 such that @xmath306 after finding @xmath183 and @xmath305 , the vestigial codeword can be found as @xmath307 .      here",
    ", we explain the implementation of the encoding and the decoding of ldpc lattice codes , for one - way relay network .",
    "let @xmath308 $ ] be the full - rate power - constrained lattice codeword associated with @xmath309 block , and let @xmath310 $ ] be the resolution codeword decoded at the relay from the @xmath311^{th}$ ] block .",
    "the source and the relay transmit @xmath312 $ ] and @xmath313 $ ] during the @xmath309 block . at block",
    "@xmath314 , the source sends @xmath315 $ ] and the relay sends nothing . at blocks @xmath316 , destination receives the superposition of signals from the source and the relay at blocks @xmath163 and @xmath317 , respectively . at block @xmath318 ,",
    "destination only receives the resolution information from the relay since the source has no information to send .",
    "the source transmits @xmath319 symbols over @xmath320 channel use , so the encoding rate is close to @xmath5 for large @xmath321 .",
    "more detail about implementing block markov encoding using lattices can be found in @xcite and @xcite .    following the outline that proposed in (",
    "* theorem 1 ) , our decoding contains three stages . at the first stage , the relay decodes @xmath179 , in the next stage , the destination decodes @xmath304",
    ", finally , the destination uses @xmath304 to decode @xmath300 .",
    "first , we consider the decoding at the relay .",
    "the received signal by the relay at the @xmath309 block is @xmath322=h_{sr}\\sqrt{p_s}\\mathbf{x}'[t]+\\mathbf{z}_r[t].\\ ] ] we start by scaling @xmath323 $ ] by the factor @xmath324 .",
    "then , we use iterative decoder of ldpc lattices to obtain full - rate lattice codeword @xmath325 $ ] @xmath326=\\textrm{dec}_{\\textrm{ldpcl}}\\left ( \\frac{\\mathbf{y}_r[t]}{\\sqrt{p_s}h_{sr}},\\frac{n_r}{\\sqrt{p_s}h_{sr } } \\right),\\ ] ] where @xmath327 is the iterative decoding algorithm of ldpc lattices described in section  [ ldpc lattices ] .",
    "we use @xmath143 and @xmath68 to estimate llr vector in ( [ llr ] ) .",
    "the resulting information vector is denoted by @xmath328 $ ] and can be obtained as @xmath328=\\textrm{mod}(\\hat{\\mathbf{x}}'[t],\\mathbf{l},\\mathbf{g}_{\\lambda}^{-1})$ ] , where @xmath329 is @xmath330.\\end{aligned}\\ ] ] the relay estimates the resolution information @xmath331 $ ] from @xmath328 $ ] and ( [ constelation_r ] ) , from which it finds the estimation of shaped resolution codeword @xmath332 $ ] . in this case , the decoding error is @xmath333=\\mathbf{x}_r'[t]-\\hat{\\mathbf{x}}_r'[t]$ ] .",
    "the received signal at the destination during @xmath334 block is @xmath335=h_{rd}\\sqrt{p_r}\\hat{\\mathbf{x}}_r'[t]+h_{sd}\\sqrt{p_s}\\mathbf{x}'[t+1]+\\mathbf{z}_d[t+1].\\end{aligned}\\ ] ] replace @xmath332 $ ] by @xmath336-\\mathbf{e}_r[t]$ ] in @xmath337 $ ] . in the destination ,",
    "treat @xmath338+\\mathbf{z}_d[t+1]-h_{rd}\\sqrt{p_r}\\mathbf{e}_r[t]$ ] as noise and decode the resolution information vector @xmath339 $ ] @xmath340=\\left\\lfloor \\mathcal{d}\\left(\\textrm{dec}_{\\textrm{ldpcl}}\\left ( \\frac{\\mathbf{y}_d[t+1]}{\\sqrt{p_r}h_{rd}},\\frac{n_d}{\\sqrt{p_r}h_{rd } } \\right)\\right)\\mathbf{g}_{\\lambda}^{-1}\\right\\rceil,\\end{aligned}\\ ] ] where @xmath341 .",
    "then , the relay obtains @xmath342=\\textrm{mod}(\\tilde{\\mathbf{x}}_r'[t],\\mathbf{l},\\mathbf{g}_{\\lambda}^{-1})$ ] , from which it finds the unshaped resolution codeword @xmath343 $ ] .",
    "the decoding errors are @xmath344 & = & \\mathbf{x}_r'[t]- \\tilde{\\mathbf{x}}_r'[t ] , \\nonumber   \\\\",
    "\\mathbf{e}_{d_1}[t ] & = & \\mathbf{x}_r[t ] -\\tilde{\\mathbf{x}}_r[t].\\end{aligned}\\ ] ] now , the destination knows the unshaped resolution codeword @xmath343 $ ] and the shaped resolution codeword @xmath339 $ ] .",
    "next , the receiver turns to @xmath345 $ ] , which can be written as @xmath346&=&h_{rd}\\sqrt{p_r}(\\mathbf{x}_r'[t-1]-\\mathbf{e}_r[t-1])+ \\nonumber\\\\   & & \\quad\\quad\\quad\\quad\\quad\\quad\\quad h_{sd}\\sqrt{p_s}\\mathbf{x}'[t]+\\mathbf{z}_d[t].\\end{aligned}\\ ] ] from @xmath345 $ ] , we know @xmath347 $ ] . by using the linearity property  ( [ decomposition ] ) ,",
    "we can rewrite ( [ y_dt ] ) as follows @xmath348&=&h_{rd}\\sqrt{p_r}(\\mathbf{x}_r'[t-1]-\\mathbf{e}_r[t-1])+ \\mathbf{z}_d[t]+\\nonumber\\\\   & & h_{sd}\\sqrt{p_s}(\\mathbf{x}_r'[t]+\\mathbf{x}_v'[t]+(1,\\ldots , 1)).\\end{aligned}\\ ] ] now , we subtract the decoded resolution information @xmath349+(1,\\ldots , 1))+h_{rd}\\sqrt{p_r}\\tilde{\\mathbf{x}}_r'[t-1]$ ] from ( [ y_dt2 ] ) to obtain @xmath350=h_{sd}\\sqrt{p_s}\\mathbf{x}_v'[t]+\\mathbf{e}_{d_2}[t]+\\mathbf{z}_d[t],\\end{aligned}\\ ] ] where @xmath351=h_{rd}\\sqrt{p_r}(\\mathbf{e}_{d_1}'[t-1]-\\mathbf{e}_r[t-1])+ h_{sd}\\sqrt{p_s}\\mathbf{e}_{d_1}'[t].\\end{aligned}\\ ] ] then , we use @xmath352 $ ] in ( [ y_dt3 ] ) to decode the vestigial information as follows @xmath353=\\textrm{dec}_{\\textrm{ldpcl}}\\left ( \\frac{y_d'[t]}{\\sqrt{p_s}h_{sd}},\\frac{n_d}{\\sqrt{p_s}h_{sd } } \\right).\\end{aligned}\\ ] ] once we have decoded both the resolution and vestigial lattice codeword , the destination can find the desired lattice codeword by @xmath354=\\tilde{\\mathbf{x}}_v'[t]\\oplus\\tilde{\\mathbf{x}}_r'[t]=\\tilde{\\mathbf{x}}_v'[t]+\\tilde{\\mathbf{x}}_r'[t]+(1,\\ldots,1)$ ] . then , the desired integer vector can be obtained as @xmath355= \\textrm{mod}(\\tilde{\\mathbf{x}}'[t],\\mathbf{l},\\mathbf{g}_{\\lambda}^{-1})$ ] .",
    "in this section , we present a practical block markov encoding scheme for the two - way relay channel based on ldpc lattice codes .",
    "this scheme achieves the decode - and - forward bound in ( [ rate_bound2 ] ) and it is proposed in @xcite for ldlcs . due to the structural differences between ldpc lattices and ldlcs , as well as , differences between our shaping methods and theirs , all steps of this scheme are rephrased for ldpc lattice codes .",
    "our applied scheme relies on doubly - nested lattice codes in which the two sources use different codebooks with different transmit powers .",
    "let @xmath356 and @xmath357 be the shaping and coding lattices for @xmath9 and @xmath10 , respectively . consider the codebooks @xmath358 and @xmath359 .",
    "it is also assumed by the authors of  @xcite that @xmath360 , @xmath361 , and @xmath362 .",
    "there is another lattice , which is referred to as _ meso - lattice _ , that partitions the lattice codebook into lower - rate constituent codebooks @xcite .",
    "the meso - lattice @xmath363 , is nested according to @xmath364 , where @xmath365 and @xmath366 are also nested lattices .",
    "define the resolution codebooks @xmath367 and @xmath368 .",
    "then , the vestigial codebooks are @xmath369 and @xmath370 .",
    "let @xmath371 be the rates of @xmath372 , respectively . then , as before , @xmath373 and @xmath374 .",
    "thus , each full - rate codeword can be decomposed into a unique modulo sum of resolution and vestigial codewords .",
    "it is proved that the preceding code construction achieves near - capacity rates  @xcite .",
    "let @xmath138 be the information vector , where each element @xmath176 of @xmath173 is drawn from finite constellations @xmath375 and @xmath376 for hypercube shaping and nested lattice shaping , respectively .",
    "the @xmath271 element of the resolution component @xmath272 is @xmath377 where @xmath378 , for some @xmath379 .",
    "thus , the @xmath271 element of @xmath380 lies in the finite constellation @xmath381 and the rate of the obtained codebook @xmath382 can be acquired via  ( [ rate ] ) or ( [ rate_nested ] ) , depending on the applied shaping method , by replacing @xmath177 s with @xmath383 s .",
    "the vestigial component is defined as follows @xmath384 if the employed shaping method is hypercube shaping , it can be shown that the @xmath271 element of @xmath385 lies in the following finite constellation @xmath386 if the employed shaping method is nested lattice shaping , the @xmath271 element of @xmath385 lies in the finite constellation @xmath387 .",
    "the rate of the vestigial codebook is approximately @xmath388 . due to the aforementioned assumptions",
    ", each codeword @xmath389 decomposes into its resolution component @xmath390 and its vestigial component @xmath391 as @xmath392 .      the first step in shaping the lattice codeword @xmath60 is translating @xmath176 by an integer multiple of @xmath177 .",
    "then , following the same procedure as in section  [ shaping_sec ] , the shaped lattice point is obtained .",
    "the shaped lattice codeword is @xmath393 , where @xmath183 is given in ( [ si ] ) and ( [ nested_lattice ] ) , for hypercube shaping and nested lattice shaping , respectively .",
    "next , we adapt the shaping methods to the resolution codewords in such a way that the decomposition of the lattice codebook remains linear .",
    "we shape the resolution component @xmath380 to @xmath394 as follows @xmath395 where @xmath176 and @xmath396 are the @xmath271 elements of @xmath173 and @xmath394 , respectively , and @xmath397 we choose the elements of @xmath398 according to @xmath399 for hypercube shaping . for nested lattice shaping , we consider @xmath400 , where @xmath398 is given by ( [ sr_s_nested2 ] ) .",
    "indeed , the @xmath401 function is regular modulo operation , when the employed shaping method is nested lattice shaping .",
    "then , the shaped resolution component is given by @xmath402 . in order to preserve the modulo linearity of the lattice decomposition , we map the vestigial integer vector @xmath385 to @xmath403",
    "as follows @xmath404 where @xmath183 is given in ( [ si ] ) and ( [ nested_lattice ] ) , for hypercube shaping and nested lattice shaping , respectively . according to this decomposition , we have @xmath405 in general .",
    "however , the decomposition preserves componentwise modulo linearity , that is , @xmath406 .",
    "then , the vestigial codeword is @xmath407 .",
    "it can be easily shown that @xmath408 .",
    "it should be noted that the vestigial lattice codeword @xmath300 may not fulfil the power constraint , which is not a problem for the considered relay network , since we do not transmit the vestigial information alone .",
    "the original information vectors @xmath409 can be recovered from @xmath410 by using algorithm  [ unshaped ] with @xmath411 .",
    "similarly , the resolution information vector @xmath380 can be recovered from @xmath394 by using algorithm  [ unshaped ] with @xmath412 .      here , we present the implementation of encoding and decoding for two - way relay network using ldpc lattice codes .",
    "first , we describe the encoding scheme and then we discuss the decoding schemes at each node .",
    "the two sources employ ldpc lattice codes as described in previous subsection .",
    "the full - rate information vector , resolution information vector , vestigial information vector , full - rate codeword , resolution codeword , and vestigial codeword of source @xmath219 are denoted by @xmath413 and @xmath414 , respectively , for @xmath415 .",
    "let the constellation sizes of the @xmath271 element of @xmath416 and @xmath417 be @xmath418 and @xmath419 , respectively .",
    "further , let @xmath383 be the constellation size of the resolution codeword , which is selected such that @xmath383 divides both @xmath418 and @xmath419 @xcite .",
    "it is assumed by the authors of @xcite that the sources use transmit powers such that @xmath420 where @xmath421 and @xmath422 .",
    "furthermore , it is assumed that @xmath423 . in the rest of this paper , we assume @xmath424 .",
    "first , we describe the encoding steps .",
    "the two sources @xmath9 and @xmath10 transmit their signals to the relay and to each other",
    ". meanwhile , the relay transmits its own signal to both @xmath9 and @xmath10 .",
    "thus , @xmath9 receives the superposition of signals from @xmath10 and the relay .",
    "similarly , @xmath10 receives signals from @xmath9 and the relay . during the @xmath309 block , where @xmath425 , the sources @xmath9 and @xmath10 transmit their new codewords @xmath426 $ ] and @xmath427 $ ] , while the relay transmits the resolution component of the decoded sum codeword @xmath428 $ ] . during the block @xmath314 , the relay transmits nothing and at block @xmath318 , the sources receive the resolution information @xmath429 $ ] from the relay , since both sources have no information to send .",
    "next , we describe the decoding steps . since , the decoding at @xmath9 and @xmath10 is similar , we only consider decoding at @xmath10 .",
    "decoding occurs in three phases . in phase one",
    ", the relay decodes the sum codeword @xmath430 . in phase two",
    ", @xmath10 decodes the resolution codeword @xmath431 by treating other codewords as noise . in the last phase , @xmath10 decodes the vestigial codeword @xmath432 .",
    "the received signal at relay in @xmath309 block is @xmath433 & = & \\sqrt{p_{s_1}}h_{s_1r}\\mathbf{x}_{s_1}'[t]+\\sqrt{p_{s_2}}h_{s_2r}\\mathbf{x}_{s_2}'[t]+\\mathbf{z}_r[t]\\nonumber \\\\     & = & \\rho\\left(m_1\\mathbf{x}_{s_1}'[t]+m_2 \\mathbf{x}_{s_2}'[t]\\right)+\\mathbf{z}_r[t ] .",
    "\\label{y_r_two_way}\\end{aligned}\\ ] ] let @xmath434=\\mathbf{y}_r[t]-\\rho\\left(-m_1-m_2 + 1\\right)$ ] . using @xmath434 $ ] , the relay performs ldpc lattice decoding to obtain an estimate of the sum information @xmath435+m_2 \\mathbf{b}_{s_2}'[t]$ ] @xmath436\\oplus m_2 \\hat{\\mathbf{x}}_{s_2}'[t ] & = & \\textrm{dec}_{\\textrm{ldpcl}}\\left(\\frac{\\mathbf{y}_r'[t]}{\\rho},\\frac{n_r}{\\rho}\\right ) , \\quad\\,\\,\\,\\label{sum_information1}\\\\    m_1\\hat{\\mathbf{b}}_{s_1}'[t]+m_2 \\hat{\\mathbf{b}}_{s_2}'[t ] & = & \\left\\lfloor \\mathcal{d}\\left (    \\hat{\\mathbf{x}}_r'[t ]   \\right ) \\mathbf{g}_{\\lambda}^{-1}\\right\\rceil,\\label{sum_information2}\\end{aligned}\\ ] ] where function @xmath437 is defined in section  [ encoding_oneway ] and @xmath438=m_1\\hat{\\mathbf{x}}_{s_1}'[t]+m_2 \\hat{\\mathbf{x}}_{s_2}'[t]$ ] .",
    "the @xmath271 element of the sum is given by @xmath439 then , the relay takes the result modulo @xmath383 to find the modulo sum of the two resolution information vectors @xmath440,l_i^{(r)}\\right ) \\\\     & = & \\mathrm{smod}\\left ( \\left [ m_1\\hat{b}_{s_1,i}'+m_2 \\hat{b}_{s_2,i}'\\right],l_i^{(r ) } \\right).\\end{aligned}\\ ] ] since @xmath383 and @xmath441 , @xmath442 were selected to be co - primes , the individual codewords can be recovered from a single codeword and the modulo sum . due to the existent constraints on transmit power , the relay employs shaping methods and maps @xmath443 $ ] to another information vector @xmath444 $ ] @xmath445 & = & \\hat{\\mathbf{b}}_{r}^{(r)}[t]-\\mathbf{s}_r\\mathbf{l}^{(r)},\\end{aligned}\\ ] ] where @xmath446 is given in ( [ s_r_twoway ] ) and ( [ sr_s_nested2 ] ) for hypercube shaping and nested lattice shaping , respectively .",
    "then , the shaped lattice codeword is @xmath447=\\mathcal{e}\\left(\\hat{\\mathbf{b}}_{r}^{\\prime(r)}[t]\\right)$ ] . during block @xmath448",
    ", the relay transmits @xmath449 $ ] .",
    "now , we describe the decoding process at @xmath10 .",
    "the received signal at @xmath10 in block @xmath448 is @xmath450 & = & h_{rs_2}\\sqrt{p_r}\\hat{\\mathbf{x}}_{r}^{\\prime(r)}[t]\\nonumber\\\\    & + & h_{s_1s_2}\\sqrt{p_{s_1}}\\mathbf{x}_{s_1}'[t+1]+\\mathbf{z}_{s_2}[t+1].\\end{aligned}\\ ] ] source @xmath169 subtracts its own scaled and translated codeword @xmath451+(1,\\ldots,1)\\right]$ ] from the received signal to obtain @xmath452 & = & h_{rs_2}\\sqrt{p_r}\\left[\\hat{\\mathbf{x}}_{r}^{\\prime(r)}[t]-m_2\\mathbf{x}_{s_2}[t]-(1,\\ldots,1)\\right]\\nonumber\\\\    & + & h_{s_1s_2}\\sqrt{p_{s_1}}\\mathbf{x}_{s_1}'[t+1]+\\mathbf{z}_{s_2}[t+1].\\end{aligned}\\ ] ] then , treating @xmath453+\\mathbf{z}_{s_2}[t+1]$ ] as noise , @xmath10 uses ldpc lattice decoding to obtain @xmath454=\\left\\lfloor \\mathcal{d}\\left ( \\textrm{dec}_{\\textrm{ldpcl}}\\left(\\frac{\\mathbf{y}_{s_2}^{\\prime\\prime}[t+1 ] } { \\gamma},\\frac{n_{s_2 } } { \\gamma}\\right ) \\right ) \\mathbf{g}_{\\lambda}^{-1}\\right\\rceil,\\ ] ] where @xmath455 .",
    "it must be noted that the decoded integer vector in ( [ dec_s2_twoway ] ) is @xmath456=\\mathrm{smod}\\left ( \\tilde{\\mathbf{b}}_r^{(r)}[t],\\mathbf{l}^{(r ) } \\right)-m_2\\mathbf{b}_{s_2}[t]-\\mathbf{s}_r\\mathbf{l}^{(r)},\\ ] ] where @xmath457= m_1\\tilde{\\mathbf{b}}_{s_1}[t]+m_2 \\tilde{\\mathbf{b}}_{s_2}[t]$ ] .",
    "let @xmath458=\\mathrm{smod}\\left(\\left[\\tilde{\\mathbf{b}}_{s_1}^{\\prime ( r)}[t]+m_2\\mathbf{b}_{s_2}[t]\\right],\\mathbf{l}^{(r ) } \\right)$ ] and @xmath459=\\mathrm{smod2mod}\\left(\\mathbf{b}_1[t],\\mathbf{l}^{(r ) } \\right)$ ] , in which the function @xmath460 , that is defined next , is applied componentwise @xmath461 source @xmath169 obtains the resolution information of source @xmath103 as @xmath462 \\right . & - & \\left .",
    "m_2\\mathbf{b}_{s_2}[t]\\right ) \\pmod*{\\mathbf{l}^{(r)}}\\nonumber\\\\    & = & \\left[\\left(m_1\\tilde{\\mathbf{b}}_{s_1}[t]+m_2 \\tilde{\\mathbf{b}}_{s_2}[t]\\right)\\pmod*{\\mathbf{l}^{(r ) } } \\right .",
    "\\nonumber\\\\    & & - \\left",
    ". m_2\\mathbf{b}_{s_2}[t]-\\mathbf{s}_r\\mathbf{l}^{(r)}\\right]\\pmod*{\\mathbf{l}^{(r)}}\\nonumber\\\\    & = & m_1\\tilde{\\mathbf{b}}_{s_1}[t]\\pmod*{\\mathbf{l}^{(r)}}.\\end{aligned}\\ ] ] then , it recovers the @xmath271 element of unshaped resolution information @xmath463 $ ] by computing @xmath464 where @xmath465 is the unique integer such that @xmath466 .",
    "such a unique @xmath465 always exists since @xmath467 and @xmath441 are coprime @xcite .",
    "next , @xmath10 uses @xmath463 $ ] and @xmath468+m_2\\mathbf{b}_{s_2}[t]$ ] to obtain @xmath469=\\mathcal{e}(\\tilde{\\mathbf{b}}_{s_1}^{(r)}[t])$ ] and @xmath470=\\mathcal{e}(\\tilde{\\mathbf{b}}_{s_1}^{\\prime ( r)}[t]+m_2\\mathbf{b}_{s_2}[t])$ ] .",
    "hence , it has @xmath471 $ ] and @xmath469 $ ] from @xmath472 $ ] and @xmath473 $ ] .",
    "then , @xmath10 subtracts @xmath474+h_{s_1s_2}\\sqrt{p_{s_1}}\\left(\\tilde{\\mathbf{x}}_{s_1}^{(r)}[t]+(1,\\ldots,1)\\right)$ ] from the original received signal at @xmath309 block @xmath472 $ ] .",
    "the simplified form of this subtracted signal is @xmath475=h_{s_1s_2}\\sqrt{p_{s_1}}\\mathbf{x}_{s_1}^{\\prime ( v)}[t]+\\mathbf{e}_{s_2}+\\mathbf{z}_{s_2}[t],\\ ] ] where @xmath476 is the decoding error @xmath477-\\tilde{\\mathbf{x}}_{s_1}^{(r)}[t]\\right ] \\nonumber\\\\     & + & h_{rs_2}\\sqrt{p_r}\\left[\\hat{\\mathbf{x}}_r^{\\prime(r)}[t-1]-\\tilde{\\mathbf{x}}_{r}^{\\prime(r)}[t-1 ] \\right].\\end{aligned}\\ ] ] then , @xmath10 uses ldpc lattice decoding to find @xmath478=\\mathbf{l}^{(r)}\\circ\\left\\lfloor \\mathcal{d}\\left ( \\textrm{dec}_{\\textrm{ldpcl}}\\left(\\mathbf{y}_{s_2},\\boldsymbol{\\sigma}_{s_2}\\right ) \\right ) \\mathbf{g}_{\\lambda}^{-1}\\right\\rceil,\\ ] ] where @xmath479 denotes the hadamard product or entrywise product of matrices , @xmath480 and @xmath481 .    to obtain the vestigial information",
    ", @xmath10 computes @xmath482=\\mathrm{smod}(\\tilde{\\mathbf{b}}_{s_1}^{\\prime ( v)}[t],\\mathbf{l}_{s_1})$ ] . finally , @xmath10 obtains the shaped and unshaped full - rate information by taking the sum of the resolution and vestigial information as @xmath483=\\tilde{\\mathbf{b}}_{s_1}^{(r)}[t]+\\tilde{\\mathbf{b}}_{s_1}^{\\prime(v)}[t]$ ] and @xmath484=\\tilde{\\mathbf{b}}_{s_1}^{(r)}[t]+\\tilde{\\mathbf{b}}_{s_1}^{(v)}[t]$ ] , respectively .",
    "a symbol error occurs at @xmath10 if @xmath485 .",
    "note that the above decoding process is presented for the case that the employed shaping method is hypercube shaping .",
    "when the employed shaping is nested lattice shaping , this decoding steps are still valid by changing @xmath401 function into regular modulo operation .",
    "this is due to the fact that , the components of lattice vectors , given as the inputs for hypercube shaping and nested lattice shaping , are drawn from different sets . for hypercube and nested lattice shading methods we use the sets @xmath486 and @xmath487 , respectively .",
    "in the simulations , @xmath488 , i.e. , we assume @xmath489 of the information integers are zero for resolution and vestigial information vectors .",
    "we have used binary ldpc codes with @xmath490 , where @xmath0 and @xmath126 are the codeword length and the dimension of the code , respectively . symbol error rate ( ser ) performance of ldpc lattice codes are plotted against the sum power at source and the relay , i.e. , @xmath491 .",
    "we have considered @xmath492 , @xmath493 and @xmath494 .",
    "the path loss exponents are @xmath495 , @xmath496 .",
    "the variances of the noise at the relay and destination are @xmath497 .",
    "the maximum number of iterations in each step of the decoding is assumed to be @xmath498 . since , the encoder and the decoder both know the locations of the zeros in resolution and vestigial information , based on ( [ si2])([bvi ] ) , for following locations we have @xmath499    we estimate @xmath500 and @xmath501 for our scheme , for the case that hypercube shaping is applied .",
    "when , all of the elements of the lattice codewords are uniformly distributed over @xmath502 , the average power of @xmath187 is @xmath503 . due to the fact that , the resolution lattice vectors contain more zeros , the average power in this case is less than @xmath504 .",
    "we assume that the members of incoming integer vector are uniformly distributed over @xmath505 , for @xmath185 .",
    "since @xmath506 for @xmath507 and @xmath508 for @xmath509 , we have @xmath510 for @xmath509 , and @xmath511 for @xmath507 , and from above equations we have @xmath512 put @xmath513 , then we have @xmath514 for @xmath515 , @xmath516 , so @xmath517 . for @xmath518 , @xmath519 .",
    "thus , @xmath520    we have considered @xmath521 , for @xmath185 .",
    "thus , for the cases that we have employed hypercube shaping , based on ( [ rate ] ) , the corresponding rate is @xmath522 bits / integer . for employing nested lattice shaping , we consider @xmath523 and @xmath524 . then , based on ( [ rate_nested ] ) , the corresponding rate is @xmath525 bits / integer . in order to achieve these rates , according to ( [ rate_bound ] ) , the total required powers are @xmath526db , and @xmath527db , respectively .    in",
    ", we have presented ser variation versus sum of transmit powers for both nested - lattice shaping and hypercube shaping . in  @xcite , the implementation of block markov encoding proposed for ldlc lattice codes .",
    "we have considered @xmath6 , @xmath7 , @xmath8 and other parameters similar to their corresponding values in  @xcite .",
    "the ser performance of an ldlc lattice code with dimension @xmath528 and rate @xmath529 , which is obtained by employing nested lattice shaping , at @xmath530 is @xmath531 away from its corresponding df inner bound , which is @xmath532db .",
    "we observe that the ser performance of an ldpc lattice code of length @xmath528 at @xmath530 is @xmath533 away from its corresponding df inner bound .",
    "this is a natural result , due to the better ser performance of ldlcs comparing to ldpc lattice codes , over awgn channels .",
    "different decoders have been proposed for ldlcs . as far as we know ,",
    "the best one is proposed in @xcite .",
    "the decoding complexity of ldlcs , by using proposed decoder in @xcite , is at least @xmath534 times more than the decoding complexity of ldpc lattices .",
    "indeed , the decoding complexity of an ldpc lattice of dimension @xmath528 is equivalent to the decoding complexity of an ldlc with dimension @xmath535 .",
    "results of show that the increase in the dimension of the lattice can decrease the gap between df bound and the performance curve . using an ldpc lattice code of dimension @xmath536 instead of dimension @xmath528 makes about @xmath537db improvement in the performance .          in , we plot the ser versus the sum of transmit powers @xmath538 , for the two - way relay channel . we suppose that the relay is midway between the sources , that is , @xmath539 and @xmath540 .",
    "we assume @xmath541 , for @xmath542 and @xmath543 , for @xmath544 .",
    "for the resolution lattice we consider @xmath545 .",
    "we choose @xmath546db .",
    "path - loss exponents are @xmath547 and @xmath548 .",
    "the used underlying codes are the same ones that we used for one - way relay channels .",
    "depending on the dimension of the lattice and the applied shaping method , our scheme achieves to within @xmath169db of the achievable rate in ( [ rate_bound2 ] ) .",
    "in this paper , we present the implementation of block markov encoding using ldpc lattice codes over the one - way and two - way relay channels . in order to apply this scheme",
    ", we employ a low complexity decoding method for ldpc lattices .",
    "then , for using these lattices in the power constrained scenarios , we propose two efficient shaping methods based on hypercube shaping and nested lattice shaping .",
    "we apply different decomposition schemes for one - way and two - way relay channels .",
    "the applied decomposition schemes are the altered versions of the applied methods for decomposing ldlcs . due to the lower complexity of decoding ldpc lattices comparing to ldlcs ,",
    "the complexity of the proposed schemes in this paper are significantly lower than the ones proposed for ldlcs .",
    "simulation results show that ldlcs outperform ldpc lattices in general .",
    "however , having lower decoding complexity enables us to increase the dimension of the lattice to compensate the existing gap between the performance of the ldpc lattice codes and the ldlcs .",
    "j.  n. laneman , d.  n.  c. tse , and g.  w. wornell , `` cooperative diversity in wireless networks : efficient protocols and outage behavior , '' _ ieee trans . on inform .",
    "50 , no .  12 , pp .",
    "30623080 , dec . 2004 .",
    "n.  lee and c.  wang , `` aligned interference neutralization and the degrees of freedom of the two - user wireless networks with an instantaneous relay , '' _ ieee trans . on commun .",
    "_ , vol .",
    "61 , no .  9 , pp . 36113619 , sep ."
  ],
  "abstract_text": [
    "<S> low density parity check ( ldpc ) lattices are obtained from construction d and a family of nested binary ldpc codes . </S>",
    "<S> we consider an special case of these lattices with one binary ldpc code as underlying code . this special case of ldpc lattices </S>",
    "<S> can be obtained by lifting binary ldpc codes using construction a lattices . </S>",
    "<S> the ldpc lattices were the first family of lattices which have efficient decoding in high dimensions . </S>",
    "<S> we employ the encoding and decoding of the ldpc lattices in a cooperative transmission framework . </S>",
    "<S> we establish two efficient shaping methods based on hypercube shaping and voronoi shaping , to obtain ldpc lattice codes . </S>",
    "<S> then , we propose the implementation of block markov encoding for one - way and two - way relay networks using ldpc lattice codes . </S>",
    "<S> this entails owning an efficient method for decomposing full - rate codebook into lower rate codebooks . </S>",
    "<S> we apply different decomposition schemes for one - way and two - way relay channels which are the altered versions of the decomposition methods of low density lattice codes ( ldlcs ) . due to the lower complexity of the decoding for ldpc lattices comparing to ldlcs , </S>",
    "<S> the complexity of our schemes are significantly lower than the ones proposed for ldlcs . </S>",
    "<S> the efficiency of the proposed schemes are presented using simulation results .    </S>",
    "<S> relay networks , lattice codes , block markov encoding . </S>"
  ]
}