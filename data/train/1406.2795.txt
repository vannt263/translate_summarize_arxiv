{
  "article_text": [
    "suppose two friends travel to a distant land and arrive at a city where all road signs are written in a language unknown to either of them .",
    "if the friends get separated and can no longer communicate with each - other , how could the two friends get together again without any help from a third person .",
    "this problem of gathering two autonomous mobile agents , called the _ rendezvous _ problem has been studied in many different contexts , for example for two ships lost in the sea , two astronauts that land in separate parts of a planet and so on .",
    "initial studies on the problem were restricted to finding probabilistic strategies for movement of the two agents that minimize the expected time to rendezvous ( see @xcite for a survey of such results ) . in recent years",
    ", the deterministic version of the problem has received a lot of attention especially by the distributed computing community .",
    "the rendezvous problem for two agents moving along the edges of a graph is a typical problem of symmetry breaking and it is a primitive for distributed coordination among autonomous mobile robots .",
    "the solution to the problem depends on the structure of the graph , the capabilities of the agents and the initial knowledge available to the agents . in this paper",
    ", we consider the problem for deterministic agents with local vision moving in an initially unknown graph ; the problem is solved when the two agents are simultaneously located in the same vertex .",
    "we are interested in the worst case time complexity for rendezvous . in general ,",
    "rendezvous can not always be solved deterministically when the underlying graph is highly symmetric and the agents follow identical strategies .",
    "a typical example is that of a ring network with unlabelled nodes where the two agents are placed on opposite vertices on any diameter . in this case , the distance between the two agents may never decrease if the agents use identical strategies , moving left or right at the same time .",
    "known solutions to the rendezvous problem are based on one of the following two approaches .",
    "the first type of solutions relies on finding a point of asymmetry in the graph and meeting at a unique point of asymmetry ( e.g. such a point of asymmetry always exists in graphs where the nodes are labelled uniquely ) .",
    "the second type of solutions assumes that the agents are provided with distinct labels and thus , they can execute distinct strategies and ensure rendezvous . the former type of results require the agents to traverse every edge of the graph in the worst case and the time to rendezvous depends on the size of the graph . on the other hand ,",
    "the latter type of solutions allow the agents to rendezvous in graphs of arbitrary size or even infinite graphs when the agents are located a finite distance apart .",
    "it has been shown that rendezvous of agents with distinct labels can be achieved in arbitrary finite graphs in time polynomial in the size of the graph and the size of the smaller of the labels assigned to the agents both in the synchronous case  @xcite and the asynchronous case  @xcite . for infinite graphs ,",
    "the only known results are for very specific graphs such as lines  @xcite or grids  @xcite . for a @xmath0-dimensional infinite grid ,",
    "the optimal time to rendezvous is @xmath5 which is already exponential in the maximum degree of the graph .",
    "in fact , in unknown graphs of degree @xmath0 , where the agents start a distance of @xmath1 apart , an agent may have to visit all vertices at a distance of @xmath1 from its initial location . since there could be @xmath6 such vertices ,",
    "the time cost of rendezvous would be exponential in @xmath0 , even if the agents have complete knowledge of the graph as well as the initial distance between them .",
    "thus the question is what additional capabilities would enable the agents to rendezvous in polynomial time .",
    "in this paper we are interested in designing the simplest mechanism that can help the agents to rendezvous in a large ( possibly infinite ) graph in time polynomial in the other parameters of the problem , e.g. the initial distance , the maximum degree of the graph and the labels assigned to the agents .",
    "we achieve this by equipping the agents with a device that can measure the distance to the other agent in the graph after each step of the algorithm .",
    "in fact , our algorithm does not require knowledge of the exact distance between the agents , but instead it is sufficient if the agent can detect whether the distance to the other agent increased or decreased after each move .",
    "we assume time to be discretized into rounds ; in each round an agent can either traverse one edge of the graph or stay at its current location , and at the end of each round the agent can determine whether the distance to the other agent increased , decreased or remained unchanged during this round .",
    "note that the agents have no means of detecting the direction leading to the other agent .",
    "we call agents equipped with the above device _ distance - aware _ agents .",
    "we show that distance - aware agents can rendezvous in arbitrary graphs in time polynomial in the initial distance , in the degree of the graph , and in the size of the smaller of the two agent labels .",
    "we show that two distance - aware agents , starting from an initial distance @xmath1 apart from each other in a connected graph with maximum degree @xmath0 , can rendezvous in time @xmath7 rounds , where @xmath2 and @xmath8 and @xmath9 are the labels of the agents .",
    "the proof is constructive and provides a deterministic algorithm for the agent that takes as input the label of the agent .",
    "the algorithm does not require any prior knowledge of the graph and works for any connected graph .",
    "we also show that our algorithm is almost optimal by providing a lower bound of @xmath10 for rendezvous of distance - aware agents .",
    "thus , our algorithm is asymptotically optimal when the maximum degree @xmath0 is not extremely large .",
    "the lower bound presented in this paper holds even for agents that can compute the exact distance to each other at every step , while the algorithm requires only the knowledge of changes in distance .",
    "moreover , this lower bound extends existing lower bounds for the general problem of rendezvous of labelled agents in unknown graphs . in terms of the size of agent labels , the previous lower bound ( without distance awareness )",
    "was @xmath11 which already holds for the ring ; no generalizations of this lower bound to graphs of arbitrary degree have been presented before .",
    "our results show that the lower bound for rendezvous must be at least @xmath12 .",
    "this paper considers the deterministic version of rendezvous ( for randomized solutions see e.g. @xcite ) .",
    "the problem of rendezvous of autonomous mobile agents has been studied for agents moving in a discrete space i.e. a graph  @xcite or those moving on a continuous space ( e.g. two dimensional plane @xcite ) . in the graph",
    "setting , rendezvous of _ identical _ agents is possible only if the graph is asymmetric or the agents are placed in asymmetric positions on the graph .",
    "there exists a characterization of such instances ( graphs and initial positions of agents ) where rendezvous is solvable @xcite .",
    "if the agents are asynchronous , they can take advantage of the asymmetry in their initial positions by marking their initial position by a pebble  @xcite .",
    "on the other hand , if the agents have distinct labels then rendezvous is possible in any graph and any starting positions , without the need to mark nodes .",
    "the first deterministic synchronous rendezvous algorithm for agents with distinct labels was presented by dessmark et al . @xcite and the time complexity of the algorithm was @xmath13 for a graph of @xmath14 nodes , where @xmath15 is the delay in the starting time of the agents .",
    "subsequent studies  @xcite improved this result and removed the parameter @xmath15 from the time complexity allowing for rendezvous in time polynomial in both @xmath14 and @xmath16 . for the asynchronous case , de marco et al .",
    "@xcite provided an algorithm for rendezvous with a cost of @xmath17 rounds , when the graph is known . for unknown arbitrary graphs ,",
    "czyowicz et al . @xcite gave the first algorithm for asynchronous rendezvous but the cost of this algorithm is at least exponential in the distance @xmath1 and the degree @xmath0 of the graph .",
    "recently , dieudonn et al .",
    "@xcite provided an improvement over this result achieving asynchronous rendezvous in time polynomial in @xmath14 and @xmath16 .",
    "rendezvous of agents starting from a finite distance @xmath1 in an infinite graph has been studied for the special cases when the graph is a line  @xcite or a grid  @xcite , assuming that the agents have a sense of orientation and they know their own location in the labelled grid",
    ".    there have been several studies on the minimum capabilities needed by the agents to solve rendezvous . for example , the minimum memory required by an agent to solve rendezvous is known to be @xmath18 for arbitrary graphs .",
    "czyowicz et al .",
    "@xcite have provided a memory optimal algorithm for rendezvous , and there are studies on the tradeoff between time and space requirements for rendezvous  @xcite . in some papers ,",
    "additional capacities are assumed for the agents to overcome other limitations , e.g. global vision is assumed to overcome memory limitations  @xcite or the capability to mark nodes using tokens  @xcite or whiteboards  @xcite is often used to break symmetry .",
    "the model used in this paper can be seen as a special case of the oracle model for computation  @xcite where the agent is allowed to query an oracle that has global knowledge of the environment .",
    "however in our case , since the only queries are distance queries , the oracle can be implemented without complete knowledge of the graph topology .",
    "we model the environment as an undirected connected ( possibly infinite ) graph @xmath19 .",
    "the nodes of @xmath20 are unlabelled such that vertices of the same degree look identical to any agent ( i.e. the nodes are anonymous ) . at each node of the graph",
    ", the edges incident to it are locally labelled , so that an agent arriving at a node can distinguish among them .",
    "we assume that edges incident to a node @xmath21 are labelled by distinct integers ( called port numbers ) from the set @xmath22 , where @xmath23 is the degree of node @xmath21 .",
    "the degree of each node is finite and bounded by the parameter @xmath0 ( which is unknown to the agent ) . for any two distinct vertices @xmath24 , the distance between them , denoted by @xmath25 , is the number of edges in any shortest path from @xmath26 to @xmath21 in @xmath27 .",
    "there are exactly two agents @xmath28 and @xmath29 , and each agent @xmath30 has a distinct label @xmath31 @xmath32 @xmath33 for some integer @xmath34 .",
    "an agent knows its own label but not that of the other agent .",
    "the agents have no prior knowledge of the graph .",
    "each agent starts from a distinct node of the graph and moves along the edges of the graph in synchronous steps following a deterministic algorithm .",
    "in other words , time is discretized into regular intervals called rounds ; in each round , an agent at a node @xmath21 can either move to an adjacent node of @xmath27 or remain stationary at @xmath21 .",
    "if the agent moves to an adjacent node @xmath35 , the agent becomes aware of the port number of the edge through which it entered @xmath35 .",
    "the agent has no means of marking a node that it visits and the agents can not communicate with each other .",
    "an agent can see the other agent only when both agents are on the same node ( in particular the agents do not see each other if they cross on the same edge from opposite directions ) .",
    "the two agents start the algorithm in the same round ( called round @xmath36 ) and rendezvous is achieved in the earliest round @xmath37 when the two agents are at the same node .",
    "we denote by @xmath1 the distance between the starting locations of the agents .",
    "contrary to previous studies on rendezvous , we assume that the agent is equipped with a device that measures the distance to the other agent .",
    "an agent at a node @xmath21 in round @xmath38 can make a query to this device ( modelled as a function call `` ( ) ) which returns the value @xmath39 , where node @xmath26 is the location of the other agent in this round . in each round",
    "the agent can make one call to `` ( ) and depending on the value returned , the value of the agent s label , the current state of the agent , and the degree of the current node , the agent chooses a number between @xmath36 and @xmath23 and leaves the current node @xmath21 through this port .",
    "we assume that the port number @xmath36 corresponds to a self - loop at node @xmath21 and if the agent chooses @xmath36 it remains at the same node @xmath21 . in this paper",
    "we do not restrict the memory of an agent in any way .",
    "thus , the agent can memorize its complete history of moves up to the current round and store this as its internal state .",
    "in this section we provide lower bounds on the rendezvous time for distance - aware agents .",
    "observe that a trivial lower bound is @xmath40 since at least one of the two agents must traverse @xmath41 edges to achieve rendezvous .",
    "we could easily obtain a better lower bound for graphs of degree @xmath0 .",
    "the result below is folklore and we include it only for completeness .",
    "rendezvous of two agents that are initially at a distance of @xmath1 apart in an unknown graph of maximum degree @xmath0 requires @xmath42 rounds in the worst case .",
    "consider the caterpillar graph shown in figure  [ fig : lowerbound1 ] obtained by taking a line of @xmath43 nodes and replacing each node with a star of size @xmath44 .",
    "suppose that the two agents start at the endpoints of the path of length @xmath1 in this graph , as shown .",
    "if an agent traverses an edge leading to one of the leaves , it has no other option than to return and try another port . for any deterministic algorithm",
    ", an adversary can assign the port numbers in such a way that the agent needs to traverse all the @xmath0 incident edges before it gets any closer to the other agent .",
    "thus after @xmath45 rounds the agents can reduce the distance between them by @xmath46 . using a repetition of this argument , the result follows .",
    "the above lower bound is independent of the agent s labels .",
    "we now present a bound which includes the parameter @xmath47 which bounds the size of the set of possible agent labels .",
    "it is known that rendezvous of two agents with distinct labels requires @xmath48 rounds  @xcite .",
    "however this lower bound is for the simplest graph consisting of two nodes and a single edge connecting them .",
    "we provide below a better lower bound for arbitrary graphs of maximum degree @xmath0 .",
    "our method is constructive , i.e. , given a deterministic rendezvous algorithm @xmath49 , we describe a graph and a procedure for the adversary to label the ports in a graph and to choose starting positions that will keep the agents executing @xmath49 from meeting for the desired time period .",
    "a _ @xmath50-clique-@xmath51-butterfly _ is a @xmath52-regular graph on @xmath53 vertices ( denoted by @xmath54 , @xmath55 , @xmath56 ) , constructed as follows :    * for each @xmath57 , we connect all pairs of vertices from @xmath58 ( so they form a @xmath50-vertex clique , named @xmath59-th clique ) , * for any given @xmath60 , @xmath61 , we connect @xmath62 and @xmath63 if @xmath64 and @xmath65 .    for two vertices , @xmath21 from @xmath59-th clique and @xmath66 from @xmath67-th clique ,",
    "we say that their horizontal distance is @xmath68 . by the properties of the butterfly - type interconnections between the cliques , we observe that , if for two vertices the horizontal distance is at least @xmath69 , then their actual distance in the graph is equal to the horizontal distance .",
    "see figure  [ fig : lowerbound2 ] for an example of a _ @xmath50-clique-@xmath51-butterfly _ graph where the agents are at a distance @xmath70 .",
    "[ th : lowerbound ] for any odd @xmath71 and @xmath72 , given a @xmath50-clique-@xmath51-butterfly ( denoted further as @xmath27 ) , for any deterministic algorithm @xmath49 , and integers @xmath73 and @xmath74 , there exist labels @xmath75 and a port numbering of @xmath27 such that if two agents with these labels start at two vertices at distance @xmath1 in this graph , they will remain at distance @xmath1 for at least @xmath76 steps .",
    "the main idea of the proof is as follows .",
    "we will choose four special port numbers that will be assigned in every vertex to the  bridge \" edges connecting it to an adjacent clique ( two ports to advance to the next clique and two ports to go backward ) .",
    "note that moving inside the clique does nt change the distance to the other agent . by carefully picking the agent labels",
    ", we will ensure that both agents will choose the forward ports at the same rounds and the backward ports also at the same rounds , thus they will maintain a constant distance between themselves , for a sufficient amount of time and during this time period , any queries to the distance oracle would be useless .",
    "before we proceed to prove the theorem , we need to fix some notation and provide some basic lemmas",
    ". we will consider the @xmath50-clique-@xmath51-butterfly graphs with a special type of port numbering where the ports on the two ends of each edge always form one of the pairs of values : @xmath77 .",
    "in other words , whenever an agent chooses to leave a node by port @xmath59 , it arrives at the adjacent node by port @xmath78 . in a @xmath0-regular graph with such a port numbering",
    ", an agent can never distinguish between any two vertices and it can learn nothing new about the graph by traversing it .",
    "thus , the algorithm @xmath49 must choose a predefined sequence of ports to follow during the first @xmath79 rounds when the distance between the agents remains @xmath1 .",
    "for every @xmath80 we denote the sequence of ports chosen by algorithm @xmath49 ( with input label @xmath81 ) by @xmath82 .",
    "[ lem : low1 ] there exist @xmath83 , @xmath84 , and a set @xmath85 , @xmath86 , such that for each @xmath87 , at most @xmath88 elements of @xmath82 are equal to one of the four values @xmath89 ( in total ) .    in @xmath27 ,",
    "the port numbers on the edges are paired together as follows : @xmath90 . for each pair",
    "@xmath91 , let @xmath92 be the number of pairs @xmath93 , @xmath94 , such that @xmath95 . since @xmath96 , there must exist @xmath83 such that @xmath97=@xmath98 .",
    "thus , there must exist a subset @xmath99 containing at least half of the possible labels , such that for each @xmath87 , the number of @xmath100 s for which @xmath101 is not greater than @xmath102 .    given the ports @xmath103 and @xmath104 as in the lemma above , the adversary can assign the pairs of port numbers @xmath105 and @xmath106 to those edges of @xmath27 that connect two adjacent cliques , such that ports @xmath103 and @xmath104 will take an agent forward to the next clique , ports @xmath107 and @xmath108 would take an agent backward to the previous clique and any other port will keep an agent within the same clique .",
    "we partition the set of port numbers into the subsets : @xmath109 informally , the ports in @xmath110 take an agent one step ahead , the ports in @xmath111 take it one step back , and the @xmath112 ports keep it in the same clique .    [",
    "lem : low22 ] there exist @xmath113 such that @xmath114 , @xmath115 @xmath116    let @xmath117 be the first round such that for @xmath118 , either or does not hold for any possible pair of labels @xmath119 and @xmath120 from the set @xmath121",
    ". we will bound the value of @xmath38 .",
    "note that the sequence of ports @xmath82 can be written as a sequence of @xmath110,@xmath111 and @xmath112 s .",
    "we choose the set of labels @xmath99 from lemma  [ lem : low1 ] and for any @xmath87 , let us count the number of possible sequences @xmath82 which correspond to distinct words from the alphabet @xmath122 ; let us denote this number as @xmath123 .",
    "recall that any such sequence can have at most @xmath124 @xmath110-ports and @xmath111-ports in total ( cf .",
    "lemma  [ lem : low1 ] ) .",
    "assuming for the sake of notation that @xmath125 is an integer and using stirling s approximation , we get : @xmath126 @xmath127 since for any two labels in @xmath99 the algorithm chooses distinct sequences , we have @xmath128 , which gives us @xmath129 and thus @xmath130 .",
    "we now return to the proof of the theorem  [ th : lowerbound ] . from lemma  [ lem :",
    "low22 ] , we know that there exist two agents with labels @xmath131 such that these agents , when executing algorithm @xmath49 , will use the ports going forward or backward simultaneously during the first @xmath132 rounds . since the distance in the graph is independent of relative positions inside cliques ( for @xmath133 ) , the distance between agents is maintained to be @xmath1 for at least @xmath134 steps .",
    "the results of this section provide a lower bound of @xmath135 rounds for rendezvous of distance - aware agents .",
    "in this section we provide an algorithm that guarantees rendezvous of two distance - aware agents in @xmath136 rounds .",
    "the algorithm is divided into four procedures . for each procedure , first we provide some intuitions on its behavior , then we give its formal description in the form of pseudo - code .",
    "after the descriptions of all procedures , the proof of correctness and analysis of rendezvous time of the algorithm are given .",
    "we start with a procedure @xmath137 ( see algorithm  [ proc : singletest ] ) , which attempts to decrease the distance between the two agents .",
    "the input consists of a positive integer @xmath138 and a bit @xmath139 .",
    "recall that the command @xmath140 ( ) performs the oracle query and provides the current distance from the other agent .",
    "we also introduce a command @xmath141 , where @xmath142 is an integer , which behaves as follows . if @xmath143 , where @xmath21 is the node currently occupied by the executing agent , then @xmath141 forces the executing agent to move from @xmath21 by taking port @xmath142 , and the value returned by the @xmath141 command is the entry port at the arrival node .",
    "otherwise , that is when @xmath144 , the executing agent stays idle in the given round , and @xmath141 returns @xmath36 .",
    "( we pass @xmath36 as an argument to deliberately make an agent idle . )",
    "two integers @xmath145 and @xmath139 .",
    "@xmath146 if the distance between agents decreases in some round ; @xmath147 otherwise .",
    "@xmath148 ( ) @xmath149 @xmath150 ( ) @xmath146 @xmath151 @xmath147    the interpretation of the input variable @xmath152 is that whenever @xmath153 , then the agent does not perform any movements during the execution of @xmath137 .",
    "note that if @xmath154 , then @xmath155 forces an agent to move only if there exists an edge with port @xmath100 at @xmath21 .",
    "suppose that , in the same round , both agents perform calls to procedure @xmath137 with input parameters @xmath156 and @xmath157 , respectively .",
    "we will always ensure that @xmath158 .",
    "informally , @xmath159 implies that both agents iteratively take ports @xmath160 ( skipping the ones not present at the current node ) , ending the process if the distance between them decreases . clearly ,",
    "if @xmath161 , then both agents just stay idle during the @xmath162 rounds and the procedure returns @xmath147 .",
    "if @xmath163 , then one agent stays idle while the other ` tests ports ' . if we ensure that @xmath138 exceeds the degree of the node occupied by the agent that performs the movements , then the procedure will return @xmath146 whenever @xmath163",
    "we now describe a procedure @xmath164 with input variable @xmath139 ( see algorithm  [ proc : bounddegrees ] ) .",
    "informally speaking , for each @xmath165 such that @xmath166 , where @xmath21 is the node occupied at the beginning of the execution of the procedure , the executing agent stays idle for @xmath167 rounds ( this is achieved by the call to @xmath168 . this part is independent of @xmath152 .",
    "then , @xmath169 is called . if @xmath153 , then the agent stays idle for another @xmath170 rounds .",
    "if @xmath154 , then the agent sequentially explores all ports at @xmath21 ( note that the value of @xmath171 exceeds the degree of @xmath21 ) .",
    "the above process is interrupted whenever the agents observe that the distance between them decreased , and the procedure returns @xmath146 in that case .",
    "an integer @xmath139 .",
    "@xmath146 or @xmath147 .",
    "let @xmath21 be the currently occupied node .",
    "@xmath172 @xmath146    @xmath173 @xmath174    the observation given below follows directly from the formulation of procedure @xmath164 .",
    "[ obs : same - node ] suppose that agent @xmath175 occupies node @xmath176 , @xmath177 , and executes procedure @xmath164 at the beginning of round @xmath178 .",
    "if procedure @xmath137 does not return @xmath146 in the first @xmath59 iterations of @xmath164 , then :    1 .   [",
    "it : obs:1 ] @xmath175 occupies @xmath176 at the end of the @xmath59-th iteration of @xmath164 , 2 .",
    "[ it : obs:2 ] both agents end the execution of the @xmath59-th iteration in round @xmath179 .    denote @xmath180 $ ] and @xmath181 $ ] for @xmath182 .",
    "we say that two nodes @xmath26 and @xmath21 are _ similar _ if there exists @xmath183 such that @xmath184 and @xmath185 .",
    "[ lem : similar - nodes ] let @xmath178 be some integer .",
    "suppose that agent @xmath175 is present at @xmath176 , @xmath177 , and calls in round @xmath178 procedure @xmath164 with input value @xmath186 .",
    "then :    1 .   [",
    "it : sim:1 ] for @xmath159 , if both calls to @xmath164 return @xmath147 , then the nodes @xmath187 and @xmath188 are similar , and 2 .   [",
    "it : sim:2 ] if @xmath163 and @xmath187 and @xmath188 are similar , then both calls to @xmath164 return @xmath146 .",
    "we first prove [ it : sim:2 ] .",
    "suppose without loss of generality that @xmath189 and @xmath190 .",
    "since the nodes @xmath187 and @xmath188 are similar , @xmath191 and therefore the executions of procedure @xmath164 have the same number of iterations of the ` for ' loop .",
    "if , in one of those iterations , the execution of procedure @xmath164 ends , then [ it : sim:2 ] holds and hence suppose that this is not the case .",
    "thus , the calls to @xmath192 and @xmath193 are made by the agents . moreover , by observation  [ obs : same - node ] , both calls are made in the same round and when agent @xmath175 is at @xmath176 , @xmath177 . during these calls , @xmath194 stays idle during @xmath195 rounds ( because @xmath190 ) while @xmath196 explores all ports at @xmath187 during the same @xmath195 rounds ( because @xmath189 and @xmath197 ) .",
    "this guarantees that the latter calls to @xmath137 return @xmath146 , which completes the proof of [ it : sim:2 ] .",
    "we now prove [ it : sim:1 ] .",
    "let @xmath159 .",
    "we argue that if the nodes @xmath187 and @xmath188 are not similar , then the call to @xmath164 results in returning @xmath146 .",
    "suppose without loss of generality that @xmath198 , @xmath177 , where @xmath199 .",
    "the number of iterations of the ` for ' loop of procedure @xmath164 executed by @xmath175 is @xmath200 , @xmath177 .",
    "thus , by observation  [ obs : same - node][it : obs:1 ] , @xmath175 occupies @xmath176 at the end of @xmath201-th iteration of @xmath164 for each @xmath177 .",
    "moreover , by observation  [ obs : same - node][it : obs:2 ] , after finishing the execution of the ` for ' loop , @xmath196 calls @xmath202 while @xmath194 calls @xmath203 in the @xmath204-st iteration of the ` for ' loop of @xmath164 . also ,",
    "both of the above - mentioned calls to @xmath137 are made in the same round @xmath205 . by similar arguments as when proving [ it : sim:2 ]",
    ", we obtain that condition [ it : sim:1 ] holds .    note that if procedure @xmath164 returns @xmath146 , then the agents get closer , and we can repeat the same process for at their current locations .",
    "however , for some nodes procedure @xmath164 may return @xmath147 and then procedure @xmath206 described below ( see algorithm  [ proc : comparelabels ] ) helps to break the symmetry .    none .",
    "@xmath207 such that @xmath100 is distinguishing for the extended labels of the agents .",
    "let @xmath208 be the extended label of the executing agent .",
    "@xmath209 @xmath207    procedure @xmath206 uses the notion of extended labels .",
    "the _ extended label _",
    "@xmath208 of a label @xmath81 is an integer whose @xmath59-th bit is defined as follows : @xmath210 the index @xmath211 is called the _ terminating bit _ of @xmath208 ( this is the last bit set to @xmath212 ) .",
    "informally , the odd positions of the extended label are the the bits of @xmath81 while the even positions are all zeros , except for the terminating bit .",
    "we say that an index @xmath100 is _ distinguishing _ for two extended labels @xmath208 and @xmath213 if @xmath214 .    informally ,",
    "procedure @xmath206 iterates over the bits of the extended label of the executing agent in order to find an index @xmath100 that is distinguishing for the extended labels of the two agents .",
    "the construction of extended labels guarantees that there exists a distinguishing index @xmath100 not greater than the smaller length of the two extended labels and hence @xmath164 returns @xmath146 at the latest in the @xmath100-th iteration of the ` for ' loop of procedure @xmath206 ( the formal proof is given later ; we remark here that if we used the label instead of the extended label , then the number of iterations of the ` for loop ' would have to be equal to the length of the greater label to ensure rendezvous ) .",
    "we postpone the analysis of procedure @xmath206 ( given in lemma  [ lem : complabels ] ) as it depends on the context at which it is called by the main procedure .",
    "we finally describe the main procedure @xmath215 ( see algorithm  [ proc : rv ] ) .",
    "@xmath216 [ line : rv : b1 ] @xmath217 @xmath218 @xmath219    we start with its intuitive description . the first ` while ' loop iteratively calls procedure @xmath220 as long as its execution gets the agents closer to each other .",
    "if a call to @xmath220 does not achieve that , then ( as we formally prove later ) the agents observed the same distance between each other while both explored all ports at their respective locations .",
    "this is significant as both agents learn that they occupy nodes whose degrees are in the same interval @xmath221 for some @xmath183 . in other words ,",
    "the agents learn an asymptotically tight upper bound on both degrees .",
    "then , procedure @xmath206 is called and uses the above fact as well as the labels of the agents to break the symmetry that occurs at the current agents nodes .",
    "note that @xmath206 returns either @xmath36 or @xmath212 and in this case different values are returned for both agents ( see lemma  [ lem : complabels ] below ) .",
    "thus , the agent whose execution of @xmath206 returned @xmath36 stays idle from now on .",
    "the other agents continues making calls to @xmath220 and since each execution results in exploring all ports at the currently occupied node , each execution gets the agent one step closer to the one that is idle .",
    "we also remark that the respective calls to procedure @xmath164 in the second ` while ' loop of @xmath206 are not necessarily ` synced ' , that is , the @xmath59-th of those calls can be made in different rounds by the agents .",
    "this , however , is not important as one of the agents stays idle and the other one performs appropriate movements .",
    "lemma  [ lem : complabels ] analyzes the only call to procedure @xmath206 made by procedure @xmath215 .",
    "then , theorem  [ thm : upper - bound ] provides the upper bound on the rendezvous time for distance - aware agents in arbitrary networks .",
    "[ lem : complabels ] whenever procedure @xmath206 is called by both agents during the execution of procedure @xmath215 , both agents finish the execution of @xmath206 in the same round and the values returned by @xmath206 are different for the two agents .",
    "since both agents call @xmath206 , none of the preceding calls to procedure @xmath164 returns @xmath146 and the agents do not rendezvous prior to the call to @xmath206 . by observation  [ obs : same - node ] and a simple inductive argument ,",
    "the calls to procedure @xmath206 made by both agents end in the same round @xmath178 .",
    "it remains to prove that the calls to @xmath206 return different values . by lemma  [ lem : similar - nodes][it : sim:1 ] , at the beginning of round @xmath178 the agents @xmath196 and @xmath194 are , respectively , at two similar nodes @xmath187 and @xmath188 .",
    "let @xmath183 be the minimum distinguishing index for agents labels , i.e. , @xmath222 and @xmath223 for each @xmath224 .",
    "such an index @xmath59 exists because the labels of the agents are different and hence the extended labels have a distinguishing index .",
    "moreover , @xmath225 indeed , if the two labels are of the same length , then the extended labels are of the same length .",
    "if , on the other hand , the labels have different lengths , then the terminating bits are at different positions , which in particular implies that the terminating bit of the smaller label is at position that is distinguishing for the two extended labels .    by assumption ,",
    "observation  [ obs : same - node ] and an inductive argument , @xmath175 is at @xmath176 at the beginning of the @xmath67-th call to procedure @xmath164 during the execution of procedure @xmath206 , where @xmath226 . the last execution of procedure @xmath164 preceding the call to @xmath206 returns @xmath147 .",
    "hence , if @xmath227 , then the @xmath67-th call to @xmath164 returns @xmath147 . clearly ,",
    "if @xmath228 , then the agents stay idle during the @xmath67-th call to procedure @xmath164 which also implies that it returns @xmath147 .",
    "thus , the above proves that the @xmath59-th call to procedure @xmath164 takes place during the execution of procedure @xmath206 and , by lemma  [ lem : similar - nodes][it : sim:2 ] , it returns @xmath146 for both agents .",
    "thus , procedure @xmath206 returns the respective bits of the extended label at position that is distinguishing , which completes the proof .",
    "[ thm : upper - bound ] suppose that agent @xmath175 with label @xmath31 initially occupies node @xmath176 , @xmath177 .",
    "procedure @xmath215 guarantees that @xmath196 and @xmath194 rendezvous within @xmath229 rounds where @xmath230 .",
    "we first prove that the execution of procedure @xmath215 guarantees rendezvous .",
    "if the agents rendezvous during the execution of the first ` for ' loop , then the claim follows and hence suppose that this is not the case .",
    "denote by @xmath186 the value of the variable @xmath152 returned by the call to procedure @xmath206 by agent @xmath175 , @xmath177 .",
    "by lemma  [ lem : complabels ] , @xmath163 .",
    "let without loss of generality , @xmath231 and @xmath232 .",
    "this implies that the agent @xmath196 stays idle indefinitely .",
    "the agent @xmath194 , during execution of procedure @xmath233 called in the second ` for ' loop of procedure @xmath215 , explores all ports of the currently occupied node .",
    "thus , the distance between agents decreases in some round which implies that each such call to procedure @xmath233 returns @xmath146 .",
    "thus , the agents rendezvous eventually .",
    "now we analyze the rendezvous time . each call",
    "to @xmath164 takes @xmath234 rounds .",
    "moreover , each such call , except for at most one , made directly by procedure @xmath215 ensures that the distance between the agents decreases .",
    "this follows immediately for calls to @xmath164 preceding the call to procedure @xmath206 since those calls , possibly except for the last one , return @xmath146 . as for the remaining calls to @xmath164 ,",
    "the above claim is due to the fact that the input values are different for both agents due to lemma  [ lem : complabels ] .",
    "thus , the total number of rounds due to all calls to @xmath164 made directly by procedure @xmath215 is @xmath235 .",
    "the number of iterations of the ` for ' loop of procedure @xmath206 is @xmath236 , each resulting in @xmath234 rounds ( the call to @xmath164 ) .",
    "this paper presented a new model for mobile agent computation by providing the agents with the capability of measuring distances to each other ( or detecting changes in distances ) at each step .",
    "we show that this simple mechanism allows us to reduce the time to rendezvous from exponential to polynomial in the degree of the graph .",
    "assuming that such a distance measuring device is available to the agents , one could ask what other problems can be solved more easily using this additional capability . for example , the agents could use this mechanism for communication at distance by moving back and forth , when there are no other means of communication .",
    "this opens up a new area of research which is worth investigating .",
    "e. bampas , j. czyowicz , l. gsieniec , d. ilcinkas , a. labourel .",
    "almost optimal asynchronous rendezvous in infinite multidimensional grids , in proc .",
    "24th international symposium on distributed computing ( disc ) , lncs 6343 , 297 - 311 , 2010 .",
    "p. fraigniaud , d. ilcinkas , and a. pelc .",
    "oracle size : a new measure of difficulty for communication problems . in proc .",
    "25th ann acm symposium on principles of distributed computing ( podc ) , pp .",
    "179 - 187 , 2006 ."
  ],
  "abstract_text": [
    "<S> we study the problem of rendezvous of two mobile agents starting at distinct locations in an unknown graph . </S>",
    "<S> the agents have distinct labels and walk in synchronous steps . </S>",
    "<S> however the graph is unlabelled and the agents have no means of marking the nodes of the graph and can not communicate with or see each other until they meet at a node . </S>",
    "<S> when the graph is very large we want the time to rendezvous to be independent of the graph size and to depend only on the initial distance between the agents and some local parameters such as the degree of the vertices , and the size of the agent s label . </S>",
    "<S> it is well known that even for simple graphs of degree @xmath0 , the rendezvous time can be exponential in @xmath0 in the worst case . in this paper </S>",
    "<S> , we introduce a new version of the rendezvous problem where the agents are equipped with a device that measures its distance to the other agent after every step . </S>",
    "<S> we show that these _ distance - aware _ agents are able to rendezvous in any unknown graph , in time polynomial in all the local parameters such the degree of the nodes , the initial distance @xmath1 and the size of the smaller of the two agent labels @xmath2 . </S>",
    "<S> our algorithm has a time complexity of @xmath3 and we show an almost matching lower bound of @xmath4 on the time complexity of any rendezvous algorithm in our scenario . </S>",
    "<S> further , this lower bound extends existing lower bounds for the general rendezvous problem without distance awareness .   </S>",
    "<S> + * keywords : * mobile agent , rendezvous , synchronous , anonymous networks , distance oracle , lower bounds </S>"
  ]
}