{
  "article_text": [
    "1- 1    register allocation is one of the most studied problems in compilation .",
    "its goal is to map the temporary variables used in a program to either machine registers or main memory locations .",
    "the complexity of register allocation for a fixed schedule comes from two main optimizations , _ spilling _ and _ coalescing_. spilling decides which variables should be stored in memory to make possible register assignment ( the mapping of other variables to registers ) while minimizing the overhead of stores and loads .",
    "register coalescing aims at minimizing the overhead of moves between registers .    compilation for embedded processors is either aggressive or just in time ( jit ) .",
    "aggressive compilation is allowed to use a long compile time to find better solutions .",
    "indeed , the program is usually cross - compiled , then loaded in permanent memory ( rom , flash , etc . ) , and shipped with the product .",
    "hence the compilation time is not the main issue as compilation happens only once .",
    "furthermore , especially for embedded systems , code size and energy consumption usually have a critical impact on the cost and the quality of the final product .",
    "just - in - time compilation is the compilation of code on the fly on the target processor .",
    "currently the most prominent languages are cli and java .",
    "the code can be uploaded or sold separately on a flash memory , then compilation can be performed at load time or even dynamically during execution .",
    "the heuristics used , constrained by time and limited memory , are far from being aggressive . in this context",
    "there is trade - off between resource usage for compilation and quality of the resulting code .",
    "the static single assignment ( ssa ) form is an intermediate representation with very interesting properties .",
    "a code is in ssa form when every scalar variable has only one textual definition in the program code .",
    "most compilers use a particular ssa form , the strict ssa form , with the additional so - called dominance property : given a use of a variable , the definition occurs before any uses on any path going from the beginning of the program ( the root ) to a use .",
    "one of the useful properties of such a form is that the dominance graph is a tree and the live ranges of the variables ( delimited by the definition and the uses of a variable ) can be viewed as subtrees of this dominance tree . a well - known result of graph theory states that the intersection graph of subtrees of a tree is chordal ( see details in  @xcite ) .",
    "since coloring a chordal graph is easy using a greedy algorithm , it has the consequence for register allocation that the `` assignment problem ''  @xcite ( mapping of variables to registers with no additional spill ) is also easy .",
    "the fact that the interference graph of a strict ssa code is chordal , and therefore easy to color , leads to promising directions for the design of new register allocation heuristics .      spilling and coalescing are correlated problems that are , in classical approaches , done in the same framework .",
    "even if `` splitting '' , i.e. , adding register - to - register moves , is sometimes considered in such a framework , it is very hard to control the interplay between spilling and splitting / coalescing .",
    "the properties of ssa form has led to new approaches where spilling and coalescing are treated separately : the first phase of spilling decides which values are spilled and where , so as to get a code with @xmath0 where @xmath1 is the maximal number of variables simultaneously live and @xmath2 is the number of available registers . the second phase of coloring ( assignment ) , maps variables to registers with no additional spill",
    ". when possible , it also removes move instructions , also called shuffle code in  @xcite , due to coalescing .",
    "this is the approach advocated by appel and george  @xcite and , more recently , in  @xcite .",
    "the interest of this approach for embedded systems is twofold .    1 .",
    "because power consumption has to be minimized , it is very important to optimize memory transfers and thus design heuristics that spill less .",
    "this new approach allows to design much more aggressive spilling algorithms for aggressive compilers .",
    "2 .   for jit compilation",
    ", this approach allows to design very fast spilling heuristics . in a graph coloring approach  @xcite ,",
    "the spilling decision is subordinate to coloring . on the other hand ,",
    "when the spilling phase is decoupled from the coloring / coalescing phase , i.e. , when one considers better to avoid spilling at the price of register - to - register moves , then testing if spilling is required simply relies on checking that the number of simultaneous live variables ( register pressure ) is lower than @xmath2 .",
    "this simple test can be performed directly on the control flow graph and the construction of an interference graph can thus be avoided .",
    "this point is especially interesting for jit compilation since building an interference graph is not only time consuming  @xcite , but also memory consuming  @xcite .",
    "the second advantage of the dominance property under ssa form is that the coloring can be performed greedily on the control flow graph .",
    "the principle for coloring a program under ssa form can be seen as a generalization of linear scan .",
    "[ [ linear - scan ] ] linear scan :    in a linear scan algorithm , the program is mapped to a linear sequence . on this sequence ,",
    "the live range of a variable is an union of intervals with gaps in between .",
    "the sequence is scanned from top to bottom and , when an interval is reached , it is given an available color , i.e. , not already used at this point . in poletto and sarkar s",
    "approach  @xcite , each variable is pessimistically represented by a unique interval that contains all the effective intervals ( the gaps are `` filled '' ) .",
    "it has the negative effect of overestimating the register pressure between real intervals but it ensures that all intervals of the same variable are assigned the same register . in some way , poletto and sarkar s algorithm provides a `` color everywhere '' allocation , i.e. , it does not perform any live - range splitting .",
    "allowing the assignment of different colors for a given variable requires shuffle code  @xcite to be inserted afterwards to repair inconsistencies .",
    "such a repairing phase requires additional data - flow analysis that might be too costly in jit context .",
    "[ [ tree - scan ] ] tree scan :    coloring a program under ssa can be seen as a tree scan : the program is mapped on the dominance tree , live ranges are subtrees .",
    "the dominance tree is scanned from root to leaves and when an interval is reached it is given an available color . here",
    "the liveness is accurate and there is no need for gap filling or additional live range splitting .",
    "replacing @xmath3-functions by shuffle code does not require any global analysis .",
    "in other words , tree scan is a generalization of linear scan .",
    "as already mentioned , the dominance property of ssa form suggests promising directions for the design of new register allocation heuristics especially for jit compilation on embedded systems .",
    "the motivation of our study was driven by the hope of designing both fast and efficient register allocation based on ssa form .",
    "notice that answering whether spilling is necessary or not is easy  even if there can be some subtleties  @xcite  while minimizing the amount of load and store instructions is the real issue .",
    "in other words , if the search space is now cleanly delimited , the objective function that corresponds to minimizing the spill cost has still some open issues .",
    "so the question is : is it easier to solve the spilling problem under ssa ?",
    "in particular is the spill everywhere problem simple under ssa form ?",
    "the spilling problem can be considered at different granularity levels : the highest , so called spill everywhere , corresponds to considering the live range of each variable entirely .",
    "a spilled variable will then lead to a store after the definition and a load before each use .",
    "the finer granularity , so called load - store optimization , corresponds to optimize each load and store separately .",
    "the latter problem , also known as paging with write back , is np - complete  @xcite on a basic block even under ssa form .",
    "the former problem is much simpler , and a well - known polynomial instance  @xcite exists under ssa form on a basic block . to develop new spilling heuristics , studying",
    "the complexity of spilling everywhere is very important for the design of both aggressive and jit register allocators .    1 .",
    "first , the complexity of the load - store optimization problem comes from the asymmetry between loads and stores  @xcite .",
    "the main difference between the load - store optimization problem and the spill everywhere problem comes from this asymmetry .",
    "we have measured that , in practice , most ssa variables have only one or two uses .",
    "so , it is natural to wonder whether this singularity makes the load - store optimization problem simpler or not .",
    "the extreme case with only one use per variable is equivalent to the spill everywhere problem .",
    "more generally , even in the context of a traditional compiler , the spill everywhere problem can be seen as an oracle for the load - store optimization problem to answer whether a variable should be stored or not . in the context of aggressive compilation  @xcite , a way to decrease the complexity is to restore the symmetry between loads and stores as done in  @xcite .",
    "2 .   second , spill everywhere is a good candidate for designing simple and fast heuristics for jit compilation on embedded systems .",
    "again , in this context , the complexity and the footprint of the compiler is an issue .",
    "spilling only parts of the live ranges , as opposed to spilling everywhere , leads to irregular live range splitting and the insertion of shuffle code to repair inconsistencies , in addition to maintaining liveness information for coalescing purpose .",
    "all of this is probably too costly for some embedded compilers .",
    "studying the complexity of the spill everywhere problem in the context of ssa form is thus important to guide the design of both aggressive and jit register allocation algorithms .",
    "this the goal of this paper . to our knowledge",
    "this is the first exhaustive study of this problem in the literature .",
    "the rest of paper is organized as follows . for our study",
    ", we considered different variants of the spilling problem .",
    "section  [ sec_terminology ] provides the terminology and notation that describe the different cases we considered .",
    "section  [ sec_no_holes ] considers the simplified spill model where a spilled variable frees a register for its whole live range ; we provide an exhaustive study of its complexity under ssa form .",
    "section  [ sec_with_holes ] deals with the problem where a spilled variable might still need to reside in a register at its points of definition and uses . here ,",
    "the study is restricted to basic blocks as it is already np - complete for this simple case .",
    "section  [ sec_conclusion ] summaries our results and concludes .",
    "[ [ context ] ] context : + + + + + + + +    for the purpose of our study , we consider different configurations depending whether live ranges are _ restricted to a basic block or not_. indeed , on a basic block , the interference graph is an interval graph , while for a general control flow graph , under strict ssa form , it is chordal .",
    "we also consider whether the use of an evicted variable in an instruction requires a register or not .",
    "if not , spilling a variable corresponds to decreasing by one the register pressure on every points of the corresponding live range .",
    "otherwise , spilling a variable does not decrease the register pressure on program points that use it : in that case , instead of having the effect of removing the entire live range , spilling a variable corresponds to removing a version of the live range with `` holes '' at the use and definition points .",
    "we denote those two problems respectively as _ without holes _ or _ with holes_. finally , we distinguish the cases where the cost of spilling is the same for all variables or not . we denote those two problems respectively as _ unweighted _ ( denoted by @xmath4 for all @xmath5 ) or _ weighted _ ( denoted by @xmath6 ) .    [ [ decreasing ] ] decreasing : + + + + + + + + + + + +    as mentioned earlier the goal of the spilling problem is simply to lower the register pressure at every program point , while the corresponding optimization problem is to minimize the spilling cost . at a given program point ,",
    "the register pressure is the number of variables alive there .",
    "the maximum over all program points , usually named @xmath1 , will be denoted by @xmath7 here .",
    "let us denote by @xmath8 the number of available registers .",
    "hence formally , the goal is to decrease @xmath7 by spilling some variables .",
    "if we denote by  @xmath9 the register pressure after this spilling phase , we distinguished the following four problems : @xmath10 , @xmath11 where @xmath2 is a constant , @xmath12 where @xmath2 is a constant , and the general problem @xmath13 where there is no constraint on the number of registers @xmath8 .",
    "[ [ a - graph - problem ] ] a graph problem : + + + + + + + + + + + + + + + +    the spill everywhere problem without holes can be expressed as a node deletion problem  @xcite .",
    "the general node deletion problem can be stated as follows : `` given a graph or digraph @xmath14 find a set of nodes of minimum cardinal , whose deletion results in a subgraph or subdigraph satisfying the property  @xmath15 . ''",
    "hence , the results of the first section have a domain of application not only on register allocation but also on graph theory . for this reason ,",
    "we formalize them using graphs ( properties of the interference graphs ) instead of programs ( register pressure on the control flow graph ) while the algorithmic behind is actually based on the control flow graph representation .    [ [ perfect - graphs ] ] perfect graphs : + + + + + + + + + + + + + + +    perfect graphs  @xcite have some interesting properties for register allocation .",
    "in particular , they can be colored in polynomial time , which suggests that we can design heuristics for spilling or coalescing in order to change the interference graph into a perfect graph . for a graph",
    "@xmath14 , the maximal size of a complete subgraph , i.e. , a clique , is the _ clique number _ @xmath16 .",
    "the minimum number of colors needed to color @xmath14 is the _ chromatic number _  @xmath17 . of course",
    ", @xmath18 because vertices of a clique must have different colors .",
    "a graph @xmath14 is perfect if each induced subgraph  @xmath19 of  @xmath14 ( including @xmath14 itself ) is such that @xmath20 .",
    "a _ chordal _",
    "graph is a perfect graph ; it is the intersection graph of subtrees of a tree : to each subtree corresponds a vertex , and there is an edge between two vertices if the corresponding subtrees intersect .",
    "a well - known subclass of chordal graphs is the class of interval graphs , which are intersection graphs of subsequences of a sequence .",
    "it is well - known that , on a basic block , the unweighted spill everywhere problem without holes is polynomial : this is the greedy furthest use algorithm described by belady  @xcite .",
    "it is less known that the weighted version of this problem , which can not be solved using this last technique , is also polynomial  @xcite : the interference graph is an intersection graph for which the incidence matrix is totally unimodular and the integer linear programming ( ilp ) formulation can be solved in polynomial time .",
    "this property holds also for a path graph , which is a class of intersection graphs between interval graphs and chordal graphs .",
    "we recall these results here for completeness .",
    "we also recalled earlier that , under ssa form , once the register pressure has been lowered to @xmath8 at every program point , the coloring `` everywhere '' problem ( each variable is assigned to a _ unique _",
    "register ) is polynomial .",
    "the natural question raised by these remarks is whether the spill everywhere problem without holes is polynomial or not . in other words , does the ssa form make this problem simpler ?",
    "the answer is no . a graph theory result of gavril and yannakakis  @xcite shows it is np - complete , even in its unweighted version : for an arbitrarily large number of registers @xmath8 , a program with @xmath7 arbitrarily larger than  @xmath8 , spilling everywhere a minimum number of variables such that @xmath9 is at most @xmath8 is np - complete .",
    "the main result of this section shows more : this problem remains np - complete even if one requires only @xmath10 .",
    "the practical implication of this result is that for a heuristic that would lower @xmath7 one by one iteratively , even the optimization of each separate step is an np - complete problem . to @xmath21 ,",
    "then from @xmath21 to @xmath22 , and so on , until @xmath23 ) does not always give an optimal solution for the problem of going from @xmath7 to @xmath8 . ]",
    "table  [ tab.spillnoholes ] summarizes the complexity results of spilling everywhere ( without holes ) .",
    "we now recall classical results and prove new more accurate results .",
    "let us start with the decision problem related to the most general case of spill everywhere without holes .",
    "[ cols=\"^,^,^,^,^\",options=\"header \" , ]",
    "recent results on the ssa form have opened promising directions for the design of register allocation heuristics , especially for dynamic embedded compilation . studying the complexity of the spill everywhere",
    "problem was important in this context .",
    "unfortunately , our work shows that ssa does not simplify the spill problem like it does for the assignment ( coloring ) problem .",
    "still , our results can provide insights for the design of aggressive register allocators that trade compile time for provably `` optimal '' results .",
    "our study considers different singular variants of the spill everywhere problem .    1 .",
    "we distinguish the problem without or with holes depending on whether use operands of instructions can reside in memory slots or not .",
    "live ranges are then contiguous or with chads .",
    "2 .   for the variant with chads , we study the influence of the number of simultaneous chads ( maximum number of use operands of an instruction and maximum number of definition operands of an instruction ) .",
    "3 .   we distinguish the case of a basic block ( linear sequence ) and of a general ssa program ( tree ) .",
    "our model uses a cost function for spilling a variable .",
    "we distinguish whether this cost function is uniform ( unweighted ) or arbitrary ( weighted ) .",
    "finally , in addition to the general case , we consider the singular case of spilling with few registers and the case of an incremental spilling that would lower the register pressure one by one .",
    "the classical furthest - first greedy algorithm is optimal only for the unweighted version without holes on a basic block .",
    "an ilp formulation can solve , in polynomial - time , the weighted version , but unfortunately , only for a basic block , not a general ssa program .",
    "the positive result of our study for architectures with few registers is that the spill everywhere problem with a bounded number of registers is polynomial even with holes .",
    "of course , the complexity is exponential in the number of registers , but for architectures like x86 , it shows that algorithms based on dynamic programming can be considered in an aggressive compilation context . in particular , it is a possible alternative to commercial solvers required by ilp formulations of the same problem . for architectures with a large number of registers",
    ", we have studied the _ a priori _ symmetric problem where one needs to decrease the register pressure by a constant number .",
    "our hope was to design a heuristic that would incrementally lower one by one the register pressure to meet the number of registers .",
    "unfortunately , this problem is np - complete too .",
    "to conclude , our study shows that complexity also comes from the presence of chads .",
    "the problem of spill everywhere with chads is np - complete even on a basic block . on the other hand ,",
    "the incremental spilling problem is still polynomial on a basic block provided that the number of simultaneous chads is bounded .",
    "fortunately , this number is very low on most architectures .",
    "andrew  w. appel and lal george .",
    "optimal spilling for cisc machines with few registers . in _",
    "acm sigplan conference on programming language design and implementation ( pldi01 ) _ , pages 243253 , snowbird , utah , usa , june 2001 .",
    "acm press .",
    "florent bouchez , alain darte , christophe guillon , and fabrice rastello .",
    "register allocation : what does the np - completeness proof of chaitin et al .",
    "really prove ?",
    "in _ international workshop on languages and compilers for parallel computing ( lcpc06 ) _ , lncs , new orleans , louisiana , 2006 .",
    "springer verlag .",
    "zoran budimli , keith cooper , tim harvey , ken kennedy , tim oberg , and steve reeves .",
    "fast copy coalescing and live range identification . in _",
    "acm sigplan conference on programming language design and implementation ( pldi02 ) _ , pages 2532 , berlin , germany , 2002 .",
    "acm press .",
    "keith  d. cooper and anshuman dasgupta . tailoring graph - coloring register allocation for runtime compilation . in _",
    "international symposium on code generation and optimization ( cgo06 ) _ , pages 3949 .",
    "ieee computer society , 2006 .",
    "christian grothoff , rajkishore barik , rahul gupta , and vinayaka pandit .",
    "optimal bitwise register allocation using integer linear programming . in _ international workshop on languages and compilers for parallel computing ( lcpc06 ) _ , lncs , new orleans , louisiana , 2006 .",
    "springer verlag .",
    "sebastian hack , daniel grund , and gerhard goos .",
    "register allocation for programs in ssa - form . in _",
    "international conference on compiler construction ( cc06 ) _ , volume 3923 of _",
    "springer verlag , 2006 .",
    "omri traub , glenn  h. holloway , and michael  d. smith .",
    "quality and speed in linear - scan register allocation . in _",
    "acm sigplan conference on programming language design and implementation ( pldi98 ) _ , pages 142151 , 1998 .",
    "christian wimmer and hanspeter mssenbck . optimized interval splitting in a linear scan register allocator . in michael hind and jan vitek , editors , _",
    "1st international conference on virtual execution environments ( vee05 ) _ , chicago , il , usa , june 2005 . acm ."
  ],
  "abstract_text": [
    "<S> compilation for embedded processors can be either aggressive ( time consuming cross - compilation ) or just in time ( embedded and usually dynamic ) . the heuristics used in dynamic compilation </S>",
    "<S> are highly constrained by limited resources , time and memory in particular . </S>",
    "<S> recent results on the ssa form open promising directions for the design of new register allocation heuristics for embedded systems and especially for embedded compilation . in particular , heuristics based on tree scan with two separated phases </S>",
    "<S>  one for spilling , then one for coloring / coalescing  seem good candidates for designing memory - friendly , fast , and competitive register allocators . </S>",
    "<S> still , also because of the side effect on power consumption , the minimization of loads and stores overhead ( spilling problem ) is an important issue . </S>",
    "<S> this paper provides an exhaustive study of the complexity of the `` spill everywhere '' problem in the context of the ssa form . </S>",
    "<S> unfortunately , conversely to our initial hopes , many of the questions we raised lead to np - completeness results . </S>",
    "<S> we identify some polynomial cases but that are impractical in jit context . </S>",
    "<S> nevertheless , they can give hints to simplify formulations for the design of aggressive allocators .    </S>",
    "<S> universit de lyon , lip , ens lyon , ucbl , cnrs , inria , france firstname.lastname@ens-lyon.fr    [ code generation , optimization ]    algorithms , performance , theory .    </S>",
    "<S> register allocation , ssa form , spill , complexity . </S>"
  ]
}