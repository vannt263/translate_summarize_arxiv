{
  "article_text": [
    "nowadays , distributed storage systems ( dsss ) are being increasingly employed by network applications",
    ". data in dsss is deployed over multiple storage devices",
    ". however , these discrete devices are prone to failure because of malfunctions or maintenance . in order to ensure the reliability of the stored data even in the occurrence of node unavailability , dsss",
    "are supposed to introduce redundancy to resist storage node failures .",
    "replication is the simplest redundant fashion , and has been adopted to improve the reliability by many dsss , such as the google file system @xcite and the hadoop distributed file system ( hdfs ) @xcite . with the rapid growth of amount of storage data , erasure coding has become a better choice for dsss . compared with replication , it is able to provide orders of magnitude reliability increasing for same storage resource consumption @xcite . as a result , several large - scale systems , such as oceanstore @xcite , total recall @xcite , windows azure storage @xcite , and google colossus(gfs2 ) @xcite ,",
    "have employed erasure coding techniques to improve their storage efficiency .",
    "_ maximum distance separable _ ( mds )",
    "codes as one kind of erasure codes have been introduced into many dsss for their optimal storage efficiency .",
    "mds property can be used to recover missing data in a dss .",
    "consider an @xmath0-node dss deployed with an @xmath1 mds code .",
    "if one node of this storage system is failed , data stored in @xmath2 nodes is required to reconstruct the missing data in this failure node .",
    "@xmath2 times amount of stored data is needed to recover the missing data .",
    "thus , the usage of network and disk is significantly high , i.e. , the repair efficiency is very low . to address this repair issue ,",
    "many codes have been constructed to reduce the transmission data for repairing failure node .    as the statement in @xcite , there are three types of node repair : exact repair , functional repair and exact repair of the systematic part .",
    "however , exact repair is the most considered from in practical dsss . in @xcite , dimakis et al . defined the amount of transmission data during repairing one single failed node as _",
    "repair bandwidth_. the authors derived an optimal tradeoff between storage and repair bandwidth ( theoretic cut - set bound ) , and proposed _ regenerating codes _ which lie on the tradeoff curve . in @xcite , the existence and the construction of regenerating codes have been studied .",
    "however , the optimal tradeoff provided by regenerating codes was only derived for functional repair .",
    "almost all the interior points on the storage - bandwidth tradeoff are not achievable under exact repair @xcite .",
    "mds array codes are another important class of erasure codes used in ddss .",
    "they have the advantage of simple encoding and decoding procedures , so that they can be easily implemented in hardware devices .",
    "many designs of mds array codes , such as evenodd @xcite , b - code @xcite , x - code @xcite , rdp @xcite , star @xcite and zigzag codes @xcite , have been presented for storage and communication applications .",
    "however , the repair bandwidth of mds array codes can not achieve the theoretic cut - set bound .    in 2011 , rashmi et al .",
    "proposed a new kind of distributed storage codes called _ piggybacking codes _ to reduce the data amount read and downloaded for node repair @xcite .",
    "the key idea of piggybacking codes is taking several instances of an existing base code , and attaching linear combinations of symbols in some protected instances to other non - protected instances .",
    "hence , the missing symbols in protected instances are able to be recovered by solving these linear equations instead of mds decoding .",
    "piggybacking is a simple and useful construction to improve the repair efficiency of missing nodes .",
    "several designs of piggybacking codes were presented in @xcite and @xcite .",
    "these designs are able to save @xmath3 to @xmath4 repair bandwidth for one failed node on average .",
    "facebook warehouse cluster and the new hadoop distributed file system ( hdfs ) have employed piggybacking codes to improve their repair efficiency @xcite .",
    "although piggybacking codes are practical and easy to implementation , the reduction of repair bandwidth of the proposed piggybacking designs still has a gap to the theoretic cut - set bound of regenerating codes . in @xcite , rashmi , shah , and",
    "ramchandran gave three specific piggybacking constructions .",
    "the second one we represent with rsr - ii is the most efficient construction in terms of repair bandwidth .",
    "the description in @xcite shows that rsr - ii codes are able to save up to @xmath4 of repair bandwidth .",
    "this paper investigates the mechanism in reduction of repair bandwidth by using piggybacking codes . from the recovery methods of the systematic symbols , we distinguish instances of piggybacking codes with protected stripes and non - protected stripes .",
    "an analysis of a lower bound on the repair bandwidth of rsr - ii codes implies that the proportion of protected instances determines the repair efficiency of piggybacking constructions .",
    "this paper firstly presents a generalized piggybacking design with various protected and non - protected stripes in order to obtain various proportion of protected stripes .",
    "second , a lower bound and an upper bound on the repair bandwidth of generalized piggybacking codes are introduced .",
    "the analysis of the two bounds indicates that by optimizing the proportion of protected stripes , the _ repair ratio _ ( defined as average repair bandwidth as a fraction of the amount of original messages ) of a generalized piggybacking code approaches zero instead of @xmath4 as the number of parity check nodes tends to infinity .",
    "it is closer to that of minimum storage regenerating ( msr ) codes which has the theoretical lower bound .",
    "at last , the computational complexity for the repair of a single failed systematic node is analyzed .",
    "the results show that the generalized piggybacking codes are able to provide more efficient repair with little complexity overhead .",
    "the remainder of this paper is organized as follows .",
    "section ii briefly introduces the piggybacking framework and rsr - ii codes .",
    "section iii performs an analysis of the repair efficiency of rsr - ii codes .",
    "our generalized piggybacking codes are presented in section iv .",
    "finally , the conclusion is given in section v.",
    "consider an @xmath5 linear block code @xmath6 , where @xmath0 is its code length , @xmath2 is its dimension , and @xmath7 represents the minimum hamming distance .",
    "code @xmath6 is called an mds code , if its minimum hamming distance @xmath7 meets the singleton bound , i.e. , @xmath8    mds codes are an important class of linear block codes . for given parameters @xmath0 and @xmath2 , the minimum distance @xmath7 reaches the maximum possible value .",
    "thus , mds codes are able to correct as many as @xmath9 erasures for given @xmath0 and @xmath2 .",
    "mds codes have been extensively applied in many dsss . in an @xmath0-node storage system ,",
    "initially the original message is divided into @xmath2 information packets .",
    "subsequently , the @xmath2 packets are encoded into @xmath0 packets and stored in the @xmath0 nodes respectively . with the mds property , messages from any @xmath2 out of @xmath0 nodes",
    "could reconstruct the original message .",
    "thus , the system is able to tolerate the failures of any @xmath9 storage nodes .      in this subsection",
    ", we introduce the piggybacking framework which is the basis of constructing piggybacking codes . piggybacking framework guarantees that dsss are able to employ piggybacking codes without extra cost of storage .",
    "moreover , the decoding properties of the error - correction codes adopted by original dsss , such as the minimum distance or the mds property , are not ruined by piggybacking reconstruction .",
    "in general , the piggybacking framework operates on multiple instances of an existing base code and adds several designed functions of the data in some instances onto other instances .",
    "the base code of piggybacking framework can be arbitrary .",
    "in fact , it is a very attractive feature in practice . under the piggybacking framework ,",
    "the dsss enjoy a repair bandwidth reduction with only small modification based on their existing error - correction codes .",
    "consider a linear block code @xmath10 represented by @xmath0 encoding functions @xmath11 .",
    "suppose @xmath12 is the original message of @xmath10 .",
    "the @xmath0 encoded symbols are @xmath13 . for an @xmath0-node system , using @xmath10 as the base code , the piggybacking framework , which has @xmath14 instances of @xmath10 , is illustrated in fig.[fig.pbframe ] .",
    "c c c c c c & stripe @xmath15 & stripe @xmath16 & stripe @xmath17 & @xmath18 & stripe @xmath14 + & & & & & + & & & & & + & & & & & + & & & & & +    as shown in fig.[fig.pbframe ] , the @xmath0 rows correspond to the @xmath0 storage nodes , the @xmath14 columns are called @xmath14 _ stripes _ , @xmath19 are @xmath14 independent original messages and @xmath20 are _ piggyback functions_.    it is a very important consideration that the piggyback functions added on the @xmath21-th stripe @xmath22 can only be linear combinations of original messages of stripes @xmath23 .",
    "this principle guarantees that all the stripes of this piggybacking framework are decodable through a recursion process : in stripe 1 , no piggyback functions are added , so the original message @xmath24 can be directly recovered by using the decoding procedure of @xmath10 . for stripe 2 , with the decoded @xmath24 ,",
    "it is easy to compute the added piggyback functions @xmath25 and subtract them from the stored symbols .",
    "then , @xmath26 is decodable . in a similar way ,",
    "after the decoding procedures of stripes @xmath23 are finished , @xmath27 are available to the piggyback functions @xmath28 .",
    "the base code of this stripe is obtained after subtracting these piggybacking functions , so that @xmath29 can be recovered .    as the statement above",
    ", the @xmath14 symbols stored in one node are independent .",
    "sometimes , an invertible linear transformation is performed to simplify the computation .",
    "such a transformation still retains the decoding properties of the piggybacking framework .      under the piggybacking framework described in section.[sec.piggyfrm ] , rashmi et al .",
    "have presented three designs of piggybacking codes for different considerations .",
    "the second design rsr - ii is constructed for the purpose of pursuing high efficiency of repair . as the statement in @xcite",
    ", rsr - ii codes can save up to @xmath4 repair bandwidth of a systematic node .",
    "for the sake of simple description , an @xmath1 mds code in systematic form is chosen as the base code .",
    "denote @xmath30 as the number of parity check nodes .",
    "rsr - ii codes consist of @xmath31 instances of the base code .",
    "represent the @xmath31 associated original messages as @xmath32 , where @xmath33 @xmath34 is a vector of length @xmath2 , and @xmath35 $ ] .",
    "then , the @xmath31 stripes are shown in the following form :    l|c|c|c|c| node @xmath15 & @xmath36 & @xmath37 & @xmath18 & @xmath38 + @xmath39 & @xmath40 & @xmath40 & @xmath41 & @xmath40 + node @xmath2 & @xmath42 & @xmath43 & @xmath18 & @xmath44 + node @xmath2+@xmath15 & @xmath45 & @xmath46 & @xmath18 & @xmath47 + @xmath39 & @xmath40 & @xmath40 & @xmath41 & @xmath40 + node @xmath2+@xmath48 & @xmath49 & @xmath50 & @xmath18 & @xmath51 +    where @xmath52 are @xmath48 encoding vectors corresponding to the @xmath48 parity check symbols of the base code .",
    "the piggyback functions of rsr - ii codes are @xmath53 linear combinations of the systematic symbols of the first @xmath54 stripes , and they are added on the last @xmath54 parity check symbols of the last @xmath54 stripes .",
    "the construction of these piggyback functions is taken in three steps .",
    "first , the @xmath2 systematic nodes are split into @xmath54 node sets @xmath55 as evenly as possible . without loss of generality , we suppose @xmath2 is not a multiple of @xmath54 , and define three variables as follows , @xmath56 hence , the first @xmath57 node sets @xmath58 are of size @xmath59 , and the remaining @xmath60 are of size @xmath61 .",
    "second , define two sets of vectors of length @xmath2 @xmath62 and @xmath63 with @xmath64 then , introduce @xmath53 selection vectors @xmath65 to separate the @xmath2 tuples in each vector of @xmath66 into @xmath54 segments . and",
    "the selection vectors are defined as follows @xmath67 where @xmath68 s are diagonal matrices of size @xmath69 . on the diagonal of @xmath70 ,",
    "only the positions corresponding to the systematic nodes in @xmath71 are `` 1 ''",
    ". therefore , @xmath72    finally , add the piggyback functions of @xmath66 and @xmath73 into the parity check symbols in the last @xmath54 nodes .",
    "hence , node @xmath74+@xmath75 , @xmath76 , has the following form as shown in fig.[fig.nodesymbol_1 ] .",
    "an invertible linear transformation is introduced to reduce the complexity for node repair .",
    "finally , symbols in node @xmath74+@xmath75 are illustrated in fig.[fig.nodesymbol_2 ] .",
    "we use _ repair ratio _ @xmath77 to represent the measure of repair efficiency of a distributed storage code .",
    "repair ratio is defined as the average amount of transfer data needed for repairing one failure node as a fraction of original messages . in this subsection",
    ", we recall the repair procedure of one systematic node by rsr - ii codes .",
    "then , the repair ratio of rsr - ii @xmath78 is computed .",
    "consider an @xmath0-node dss deployed with an @xmath1 rsr - ii code .",
    "for the sake of simple description , we represent the first @xmath54 stripes as _ protected stripes _ , whose systematic symbols are involved in the piggyback functions and defined as _ protected symbols_. meanwhile , the last @xmath79 stripes are represented as _ non - protected stripes _ ,",
    "whose systematic symbols are named with _",
    "non - protected symbols_. if the @xmath80-th systematic node fails , repair procedure of this node is to recover the missing protected symbols @xmath81 and the missing non - protected symbols @xmath82 .",
    "assume node @xmath80 belongs to @xmath71 which is one of the @xmath54 node sets described in section.[sec.rsrcode ] .",
    "the repair procedure is described in algorithm [ alg.rsr-ii ] .    * recovering the missing non - protected symbols @xmath82 ; +",
    "the base code of this rsr - ii code is in systematic mds form . according to mds property",
    ", @xmath83 can be directly recovered with @xmath84 .",
    "* getting the piggyback functions involved with the missing protected systems @xmath81 ; + as statement in [ sec.rsrcode ] , there are @xmath54 piggyback functions containing @xmath85 s @xmath86)$ ] .",
    "these piggyback functions are linear combinations of the protected symbols in @xmath71 .",
    "download the @xmath54 parity check symbols containing the @xmath54 piggyback functions , and subtract the items about @xmath87 . then",
    ", the @xmath54 piggyback functions involved with @xmath81 are left . * recovering the missing protected symbols @xmath81 ; + including @xmath81 , the other surviving protected symbols in @xmath88 are also involved with the @xmath54 piggyback functions obtained in step 2 .",
    "download these surviving symbols , and subtract them out from the @xmath54 piggyback functions . then",
    ", @xmath81 can be reconstructed by solving the left @xmath54 linear combinations .    from algorithm [ alg.rsr-ii ] ,",
    "@xmath89 symbols are needed to be downloaded in step 1 , and @xmath54 symbols are needed in step 2 . in step 3 ,",
    "if the size of @xmath71 is @xmath59 , the number of downloaded symbols is @xmath90 .",
    "otherwise , if the size is @xmath61 , @xmath91 symbols are downloaded .",
    "we denote the average repair bandwidth of one systematic node as @xmath92 .",
    "the number of systematic nodes in the node sets of size @xmath59 is @xmath93 , and the number of those systematic nodes in the node set of size @xmath61 is @xmath94 .",
    "thus @xmath95.\\end{aligned}\\ ] ] thus , the repair ratio @xmath78 is @xmath96 \\nonumber\\\\ & = & \\frac{1}{k^2(2r-3)}[k^2(r-2)+ \\nonumber\\\\ & & ( tt_h^2+(r-1-t)t_l^2)(r-1)].\\end{aligned}\\ ] ]",
    "in this section , a further analysis on the repair efficiency of rsr - ii is performed .    here",
    ", we introduce a notation _ stripe - repair ratio _ @xmath97 to measure the repair efficiency of one stripe @xmath98 consider a piggybacking code with @xmath99 stripes .",
    "assume the stripe - repair ratios of these stripes are @xmath100 .",
    "denote the proportions of these stripes as @xmath101 .",
    "thus , the repair ratio for systematic nodes of this piggybacking code @xmath102 has the following form , @xmath103    recall the rsr - ii codes described in section [ sec.rb_rsr ] .",
    "the repair procedure deals with the missing protected and non - protected symbols in two different measures : mds decoding is adopted for the recovery of non - protected symbols , and the amount of downloading for repairing one missing non - protected symbol is @xmath2 symbols . as regard to the missing protected symbols , solving linear combinations is employed , and the average bandwidth is @xmath59 or @xmath61 , which depends on the size of node set containing the failure node .",
    "denote @xmath104 and @xmath105 as the stripe - repair ratios of protected and non - protected stripes , respectively .",
    "the amount of original message of one stripe equals to the @xmath2 symbols stored in the systematic nodes .",
    "hence , @xmath106 although only an approximate value of @xmath104 is given by equation ( [ equ.etap ] ) , it is obvious that @xmath107 , i.e. , repair procedure for protected stripes requires less downloaded symbols compared with non - protected stripes .",
    "this is the mechanism in reduction of repair bandwidth by using piggybacking codes .    in the remainder of this section",
    ", we explore the critical factors influencing the repair efficiency through an analysis of @xmath78 .",
    "represent the proportion of protected stripes with @xmath108 .",
    "thus , the proportion of non - protected stripes is @xmath109 .",
    "rewrite @xmath78 as the form of equation ( [ equ.sysratio ] ) .",
    "then , @xmath110 where @xmath111 , @xmath112 and @xmath113 .",
    "the inequality of quadratic and arithmetic means tells that for @xmath114 nonnegative integers @xmath115 , they satisfy the following inequality .",
    "@xmath116 thus , @xmath117 with equality if and only if @xmath118 , i.e. , @xmath2 is a multiple of @xmath54 . in this case , @xmath78 is able to reach a lower bound @xmath119 , and @xmath120    according to equation ( [ equ.lowerbandgamma1 ] ) , @xmath78 approaches @xmath121 as the number of parity check nodes tends to infinite , i.e. , rsr - ii codes are able to save at most @xmath4 repair bandwidth . for a dss",
    "whose parameters @xmath122 are given , in order to further improve the repair efficiency , the structure of piggybacking design is supposed to be modified .",
    "as the analysis above , the protected stripe - repair ratio @xmath104 is smaller than @xmath105 .",
    "it implies that the repair efficiency of piggybacking codes may be improved by increasing @xmath108 according to equation ( [ equ.aly_gamma1 ] ) .",
    "actually , larger @xmath108 means more protected symbols involved in one piggyback function that leads to the reduction of @xmath104 .",
    "therefore , it is possible to improve the repair efficiency of piggybacking codes by optimizing the proportion of protected stripes @xmath108 .",
    "in this section , we present a generalized construction which contains various protected and non - protected stripes .",
    "an analysis is performed to clarify the relationship between repair ratio @xmath77 and the proportion of protected stripes @xmath108 .",
    "the results show that our proposed generalized piggybacking codes are able to provide more efficient node repair by optimizing @xmath108 .",
    "the repair ratio @xmath123 of the generalized piggybacking codes approaches zero when the number of the parity check nodes tends to infinity .",
    "similarly , choose an @xmath1 systematic mds code @xmath124 as the base code of a generalized piggybacking code .",
    "@xmath30 is the parity check number .",
    "two parameters @xmath125 and @xmath126 are introduced to represent the numbers of protected and piggybacked stripes , respectively .",
    "figure [ fig.mul_stps ] depicts the @xmath127 instances of @xmath124 .",
    "l|p0.5 cm p0.25 cm p0.6 cm |p0.9 cm p0.25 cm p1.0cm| node @xmath15 & & & & & & + @xmath128 & & & & & & + node @xmath2 & & & & & & + node @xmath2+@xmath15 & & & & & & + node @xmath2+@xmath16 & & & & & & + @xmath128 & & & & & & + node @xmath2+@xmath48 & & & & & & +    according to the construction principle of piggybacking framework , piggyback functions added on the @xmath21-th stripe should only involve the original messages of the stripes @xmath129 $ ] .",
    "for the sake of simple analysis , we add the piggyback functions only on the parity check symbols in non - protected stripes .",
    "redefine the non - protected stripes as piggybacked stripes . as illustrated in fig.[fig.mul_stps ] , all symbols stored in the @xmath127 stripes are divided into 4 regions .",
    "* region a contains all the systematic symbols of the protected stripes . *",
    "region b contains all the systematic symbols and the first parity check symbol of the piggybacked stripes . *",
    "region c contains all the parity check symbols of the protected stripes . *",
    "region d contains the last @xmath54 parity check symbols of the piggybacked stripes .",
    "once a systematic node failure happens , the repair procedure is supposed to regenerate the @xmath127 missing symbols in region a and b. similar to rsr - ii codes , the systematic symbols in region b are self - sustaining : according to the mds property , missing symbols in one row of region b could be recovered by the surviving symbols in the other @xmath2 rows . as for the systematic symbols in region a , piggybacking functions are constructed to protected them .",
    "these piggyback functions are supposed to be embedded in region d. the size of region d is @xmath130 , i.e. , at most @xmath130 piggyback functions can be designed .",
    "it is a noteworthy fact that the @xmath125 failed protected symbols in one row of region a should be simultaneously recovered by solving a set of linear combinations . in order to guarantee that there are enough piggyback functions to simultaneously recover those @xmath125 missing symbols in region a , the following inequality must be satisfied when we choose the parameters @xmath125 and @xmath126 .",
    "@xmath131 in the remainder this subsection , an method of the construction of @xmath130 piggyback functions is illustrated as follows .",
    "* construct a @xmath132 empty piggybacking array .",
    "+ each column of this piggybacking array corresponds to one piggyback function . *",
    "fill the protected symbols in region a into the piggybacking array .",
    "+ the protected symbols in region a form a @xmath133 array as shown in fig.[fig.mul_stps ] .",
    "step 2 takes these symbols in rowwise from the @xmath133 array and fills them into the piggybacking array .",
    "obviously , if @xmath134 is not divisible by @xmath130 , the last row of this piggyback array would not be full .",
    "* obtain the @xmath130 piggybacking functions , and add them in region d. after all protected symbols are allocated into the piggyback array , sum the symbols in each column up .",
    "thus , @xmath130 piggybacking functions are obtained , and they can be added into region d in an arbitrary order .    it is remarkable that the piggyback functions are only summations of some protected symbols . as a result , the recovery of missing protected symbols could be very simple .",
    "an example is presented to illustrate the partition method and the repair procedure .",
    "consider an @xmath135 systematic mds code as the base code .",
    "set @xmath136 , and @xmath137 .",
    "denote @xmath138 of length 4 as the 5 input message vectors .",
    "thus , the original storage array is    [ cols= \" < , < , <",
    ", < , < \" , ]     according the analysis in section.[sec.analysis_rsrii ] , solving linear combinations is introduced by piggybacking codes to reduce the repair bandwidth of partial missing symbols . for rsr - ii codes ,",
    "@xmath54 missing protected symbols need to be simultaneously recovered by solving a group of @xmath54 linear functions . as a result",
    ", we have to perform gaussian elimination . however , for generalized piggybacking codes , piggyback functions are simple summations of some protected symbols . compared with the calculations for mds decoding , those for solving linear combinations cost only @xmath139 more additions .",
    "thus , the generalized piggybacking framework is able to provide high repair efficiency because it can significantly reduce the repair bandwidth for a single failed systematic node with low computational complexity .",
    "this paper presents a generalized piggybacking construction with various protected instances and piggybacked instances . compared with the previous design",
    ", our proposed generalized piggybacking codes can save more repair bandwidth by optimizing the proportion of protected instances .",
    "when the number of parity check nodes tends to infinity , the average repair bandwidth as a fraction of total messages approaches zero .",
    "moreover , complexity analysis demonstrates that generalized piggybacking codes are able to efficiently repair the failed node with reasonable complexity overhead .",
    "in fact , if we look at piggybacking functions from the view of error - correction codes , piggybacking codes are perfect encounter between codes with small minimum hamming distance and codes with large minimum hamming distance .",
    "the repair of systematic symbols in piggybacked stripes is relied on the base codes of these stripes .",
    "these base codes have strong erasure - correction capability due to their large minimum distance .",
    "however , it results in strong correlation among all the symbols .",
    "thus , decoding of these ` good codes ' requests large amount of data access . for the repair of protected stripes ,",
    "piggybacking functions are linear combinations of the protected systematic symbols . in other words ,",
    "these symbols together with piggyback functions can be considered as linear codes with small minimum distance . since these ` bad codes ' have weak correlation among symbols , their decoding requests small amount of data access .",
    "we sincerely thank prof . shu lin and dr . zhiying wang for their constructive suggests .",
    "this paper received funding from nsaf under grant u1530117 and national natural science foundation of china under grant 61471022 , and also sponsored by laboratory independent innovation project of qian xuesen laboratory of space technology .",
    "s. ghemawat , h. gobioff and s .- t .",
    "leung , `` the google file system '' , in _ proc .",
    "acm sigops operating systems review _ , vol .",
    "37 , no . 5 , 2003 , pp .",
    "d. borthakur , `` hdfs architecture guide , '' 2008 .",
    "[ online ] .",
    "available : http://hadoop.apache.org/common/docs/current/hdfs design.pdf h. weatherspoon and j. d. kubiatowicz , `` erasure coding vs. replication : a quantitative comparison , '' in _ proc .",
    "peer - to - peer systems(iptps ) _ , 2002 , pp .",
    "s. c. rhea , p. r. eaton , d. geels , h. weatherspoon , b. y. zhao , and j. kubiatowicz , `` pond : the oceanstore prototype , '' in _ proc .",
    "2nd usenix conf .",
    "file and storage technologies(fast ) _ , 2003 , pp . 114 .",
    "r. bhagwan , k. tati , y. cheng , s. savage , and g. m. voelker , `` total recall : system support for automated availability management , '' in _ proc .",
    "networked systems design and implementation(nsdi ) _ , 2004 , pp .",
    ". b. calder , j. wang , a. ogus , n. nilakantan , a. skjolsvold , s. mckelvie , y. xu , s. srivastav , j. wu , h. simitci et al .",
    ", `` windows azure storage : a highly available cloud storage service with strong consistency , '' in _ proc .",
    "23rd acm symposium on operating systems principles _ , 2011 , pp .",
    "`` google - gfs2 colossus , '' 2012 .",
    "[ online ] .",
    "available : http://www.quora.com/colossus-google-gfs2 .",
    "a. g. dimakis , k. ramchandran , y. wu , and c. suh , `` a survey on network codes for distributed storage , '' _ proceedings of the ieee _ , vol .",
    "3 , pp . 476489 , 2011 .",
    "a. g. dimakis , p. godfrey , y. wu , m. j. wainwright , and k. ramchandran , `` network coding for distributed storage systems , '' _ ieee trans .",
    "inf . theory _ ,",
    "9 , pp . 45394551 , 2010 .",
    "d. cullina , a. g. dimakis , and t. ho , `` searching for minimum storage regenerating codes , '' in _ proc .",
    "47th annu .",
    "allerton conf .",
    "commun . , control , comput .",
    ". k. v. rashmi , n. b. shah , p. v. kumar , and k. ramchandran , `` explicit construction of optimal exact regenerating codes for distributed storage , '' in proc .",
    "47th annu .",
    "allerton conf .",
    "commun . , control , comput . , 2009 ,",
    "c. suh and k. ramchandran , `` exact - repair mds codes for distributed storage using interference alignment , '' in _ proc .",
    "inf . theory _ , 2010 , pp .",
    ". k. v. rashmi , n. b. shah , and p. v. kumar , `` optimal exact - regenerating codes for distributed storage at the msr and mbr points via a product - matrix construction , '' _ ieee trans .",
    "inf . theory _ ,",
    "57 , no . 8 , pp . 52275239 , 2011 . j. li , x. tang , and u. parampalli , `` a framework of constructions of minimal storage regenerating codes with the optimal access / update property , '' _ ieee trans .",
    "inf . theory _ ,",
    "4 , pp . 19201932 , 2015 . n. b. shah , k. v. rashmi , p. v. kumar , and r. kannan , `` distributed storage codes with repair - by - transfer and nonachievability of interior points on the storage - bandwidth tradeoff , '' _ ieee trans .",
    "inf . theory _ , vol .",
    "18371852 , 2012 .",
    "m. blaum , j. brady , j. bruck , and j. menon , `` evenodd : an efficient scheme for tolerating double disk failures in raid architectures , '' _ ieee trans . computers _ , vol .",
    "2 , pp . 192202 , 1995 .",
    "l. xu , v. bohossian , j. bruck , and d. g. wagner , `` low - density mds codes and factors of complete graphs , '' _ ieee trans .",
    "45 , no . 6 , pp .",
    "18171826 , 1999 . l. xu and j. bruck , `` x - code : mds array codes with optimal encoding , '' _ ieee trans .",
    "inf . theory _ ,",
    "1 , pp . 272276 , 1999 .",
    "p. corbett , b. english , a. goel , t. grcanac , s. kleiman , j. leong , and s. sankar , `` row - diagonal parity for double disk failure correction , '' in _ proc .",
    "3rd usenix conference on file and storage technologies(fast ) _ , 2004 .",
    "c. huang and l. xu , `` star : an efficient coding scheme for correcting triple storage node failures , '' _ ieee trans",
    ". computers _ , vol .",
    "57 , no . 7 , pp .",
    "889901 , 2008 .",
    "i. tamo , z. wang , and j. bruck , `` zigzag codes : mds array codes with optimal rebuilding , '' _ ieee trans .",
    "inf . theory _ ,",
    "3 , pp . 15971616 , 2013 . k. rashmi , n. b. shah , and k. ramchandran , `` a piggybacking design framework for read - and download - efficient distributed storage codes , '' in _ proc .",
    "inf . theory _ , 2013 , pp .",
    "k. rashmi , n. b. shah , and k. ramchandran , `` a piggybacking design framework for read - and download - efficient distributed storage codes , '' 2013 .",
    "[ online ] .",
    "available : http://arxiv.org/pdf/1302.5872.pdf k. v. rashmi , n. b. shah , g. dikang , k. hairong , b. dhruba , and r. kannan , `` a solution to the network challenges of data recovery in erasure - coded distributed storage systems : a study on the facebookwarehouse cluster , '' in _ presented as part of the 5th usenix workshop on hot topics in storage and file system _ , 2013 .",
    "b. yang and x. tang , `` a systematic piggybacking design for minimum storage regenerating codes , '' _ ieee trans .",
    "inf . theory _ , vol .",
    "57795786 , 2015 ."
  ],
  "abstract_text": [
    "<S> this paper generalizes the piggybacking constructions for distributed storage systems by considering various protected instances and piggybacked instances . </S>",
    "<S> analysis demonstrates that the proportion of protected instances determines the average repair bandwidth for a systematic node . by optimizing the proportion of protected instances , </S>",
    "<S> the repair ratio of generalized piggybacking codes approaches zero instead of 50% as the number of parity check nodes tends to infinity . </S>",
    "<S> furthermore , the computational complexity for repairing a single systematic node cost by generalized piggybacking codes is less than that of the existing piggybacking designs .    submitted paper    piggybacking , distributed storage systems , mds , node repair </S>"
  ]
}