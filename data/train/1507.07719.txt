{
  "article_text": [
    "it is widely acknowledged that theoretical research and applications development evolve at different speeds , driven by different aims .",
    "research theory investigates new problems and new ideas , taking its time to study different solutions that tackle problems from different points of view .",
    "it often happens that while deeply studying one of these solutions , new ideas or entirely new problems emerge , opening the way to entirely new ( sub)theories . the development of applications , instead , is much more oriented towards effective solutions .",
    "moreover , the choice between different solutions is often dictated by technology constraints or market constraints such as cost - effectiveness and rapid productivity .",
    "the ( relative ) low speed and the wide scope of the theory often result in a ( relative ) lack of integration of results .",
    "the theoretical outcomes of research are so abundant that their integration and assimilation is quite hard .",
    "nevertheless , incorporating different results under a unifying or coherent view , both formally and epistemologically , would be of great help for the progress of the knowledge .",
    "on the other hand , the speedy development of application solutions tends to miss the opportunities offered by theoretical results that have been already established but not yet fully applied .",
    "while the percolation of theoretical results into applications intrinsically requires some time , it is helpful to remind taking a look from theory towards applications and from applications to theory every so often .    this paper",
    "is then written in this spirit .",
    "we examine the history of popular programming languages to expose how concurrency has been incorporated into the mainstream programming .",
    "this excursus is not meant to be a survey of concurrent languages ; it would be very incomplete in that sense .",
    "we aim instead at identifying a number of historical landmarks and crucial concepts that shaped the development of programming languages .",
    "moreover , rather than fully describing these major points , we focus on their connection under an evolutionary perspective , using the biological theory of evolution as an instructive metaphor .",
    "we then borrow the evolutionary talking from biology , using it as an explanatory tool to more deeply reflect on some concepts and to stimulate the development of meta - knowledge about the history of programming languages .",
    "[ [ structure - of - the - paper ] ] structure of the paper + + + + + + + + + + + + + + + + + + + + + +    in section 2 we start our excursus of the history of popular programming languages from an evolutionary perspective .",
    "we first examine the general development process , and we then deep into some language , trying to uncover evolutionary lineages related to specific programming traits . in section 3",
    "we consider concurrency abstractions : we put forward three different concurrency models used in mainstream programming , emphasizing the fact that they correspond to three different levels of explanation .",
    "the evolutionary excursus is then completed in section 4 with a discussion of the impact of the clouds and big data technologies in programming languages . in section 5",
    "we discuss the role of the theoretical research in the evolutionary scenario , putting forward its ability of promoting and testing language mutations .",
    "we conclude in section 6 with final comments .",
    "the research about programming languages can be described in many different ways .",
    "an interesting approach is looking at languages in a timeline perspective , trying to grasp the evolutionary process that guided ( or that unfolded behind ) the fortune of mainstream programming languages .",
    "it has been suggested ( e.g.,@xcite ) that information technology innovations occur mainly through the combination of previous technologies .",
    "even living structures are the result of a widespread reuse and combination of available elements , but in biology established solutions are seldom replaced , while the introduction of new simple technological elements can completely reset the path of future technologies .",
    "another key feature of technological evolution is that it is mainly guided by planned designs , that have no equivalent with natural evolution : technology designers seek optimality criteria in terms of correctness , efficiency , cost and speed , and they outline new goals and expectations .",
    "nevertheless , long - term trends and the diversification effects of contingencies , also due to social and economical factors , can only be captured a posteriori .",
    "we then give here a very incomplete and extremely partial outline of what could be called the modern history of mainstream programming languages .",
    "if we try the exercise of listing major languages in a total , time - based ordering , we observe that even a very rough ordering requires to choose a non - trivial criterion . should we list languages according to when they have been invented or according to when they became popular ?",
    "interestingly , such a question exposes the gap between why a language has been invented and why it became popular .",
    "for instance objective - c was designed long before the advent of mobile devices but its popularity greatly depends on the boost in the proliferation of apps for apple mobile tools ( see the objective - c s tiobe index in @xcite ) .",
    "a fair solution to the ordering problem is then not to linearize the languages , but the major evolutionary leaps that marked the area , as depicted in figure  [ fig : timelinep ] .    with the introduction of languages such as fortran , lisp , cobol and",
    "algol around 1950s-1960s we can start talking about modern languages , that rely on primitives such as ` if ` , ` goto ` , ` continue ` to add structure to the code . around 1970s-1980s the advent of languages like c , simula , smalltalk , ml and prolog marks the rise of modern programming _ paradigms _ , such as imperative programming , functional programming , logic programming and object - orientation .",
    "the case of object - oriented programming ( oop ) is particularly instructive . in its well known paper",
    "`` the free lunch is over ''",
    "@xcite , herb sutter recalls that even if oop dates back in 1960s , object - orientation did nt become the dominant paradigm until the 1990s .",
    "he also observes that the shift appeared    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` when the industry was driven by requirements to write larger and larger systems and oop s strengths in abstraction and dependency management _ made it a necessity _ for achieving large - scale software development that is economical , reliable , and repeatable '' .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    correspondingly , the killer application for oop and its modularity , encapsulation and code reuse principles , has been recognized to be the development of guis ( graphical user interfaces ) .",
    "the key observation here is that the object - oriented model , well studied in academia , became pervasive in applications and mainstream programming only when driven by critical industry requirements .",
    "similar evolutionary leaps in the history of programming languages can be traced also in recent years .",
    "more precisely , we can identify a number of _ catalysts _ that powered significant changes in mainstream programming .",
    "first of all , the advent of the internet ( and its appeal to the market ) shifted the programming language goals from efficiency to portability and security .",
    "this is the scenario where java came into the arena , and the jvm brought to the fore the concept of virtual machine bytecode , already used , e.g. , in ml and smalltalk .",
    "but the growth of the web had an impact also on the popularity of other languages : the so - called scripting languages , such as php , javascript , python , ruby , which are well suited to the development of short programs to be embedded into web pages and web servers .",
    "notice however that , besides web technologies , these languages are often the favorite choice of many general - purpose programmers because of their high - level , declarative programming model which enhances productivity and fast prototyping .",
    "it is worth remarking here that the success of these dynamic languages as general - purpose languages also comes as a reaction to the heavy and verbose type discipline imposed by strongly typed languages such as java or c#.    another landmark in the history of programming languages , which is directly related to the topic of this paper , is the popularity of concurrent programming , whose catalyst is the fact that new , efficient hardware can only be somehow parallel .",
    "moore s law , establishing that cpu performance doubles approximately every two years , is still valid only because performance gains can nowadays be achieved in fundamentally different ways : by means of cpu hyperthreading ( i.e. many threads in a single cpu ) and multicore ( many cpus on one chip ) .",
    "however , in order to benefit from such a new hardware , applications must be concurrent .",
    "for the sake of clarity , we observe that parallel and concurrent computing are different concepts , even if they are often used ( also in this article ) as synonyms .",
    "they both refer to computations where more than one thread of control can make progress at the same time .",
    "parallel computing stresses on the fact that many computations are actually carried out simultaneously by means of parallel hardware , such as multi - core computers or clusters .",
    "concurrent computation generally refers to tasks that may be executed in parallel either effectively , on a parallel hardware , or virtually , by interleaving the execution steps of each thread on a sequential hardware .",
    "moreover , in the context of programming languages , parallel tasks are generally sets of independent activities that are simultaneously active , while concurrent programs focus on the coordination of the interactions and communications between different tasks .",
    "as in the case of oop , concurrent programming has been known since 1960s ( e.g. , it is a core aspect of any operating system ) , but it became widespread and mainstream essentially only because of the inexorability of parallel hardware .",
    "the greatest cost of concurrency , that also limited its accessibility , is that ( correct ) concurrent programming is really hard and refactoring sequential code to add concurrency is even harder .",
    "concurrency is so hard partly because of intrinsic reasons , such as dealing with nondeterminism , but also because of accidental reasons , like improper programming models .",
    "as illustrated in figure  [ fig : concgap ] , concurrent programming involves two phases . first the design of a concurrent algorithm or a concurrent software architecture , then its translation into a concurrent code .",
    "the feasibility of such a translation clearly depends on the design choices of the target programming language .",
    "many concurrency models have been studied , offering a range of solutions at very different abstraction levels .",
    "single instruction multiple data ( simd ) architectures such as general purpose - gpus are tailored to specific parallel hardware devices , and efficient lock - free programming techniques require a precise account of the processor s memory model . at the other",
    "extreme stays the actor model , which fosters declarative programming and integrates well with oop .",
    "different concurrency models lead to different concurrent languages , e.g. , java , mpi , erlang , cuda , that entail very different programming styles , each one with merits and shortcomings .",
    "in particular , an effective high - level concurrent programming model is still lacking .",
    "such a deficiency can be rephrased in other terms : the quest for satisfactory , high - level concurrency abstractions is still open .",
    "we will further examine this point in section  [ sec : concabs ] , but before diving into concurrency , we now make our look at mainstream programming more concrete by applying the evolutionary explanation to specific language traits .",
    "after having discussed how large - scale industrial software , the internet and the popularity of parallel hardware had a pivotal role in the development of mainstream programming , we now shift the point of view and we move within some language , trying to uncover specific evolutionary processes .",
    "rather than looking at the history of a single language , we focus on how some key programming features evolved in time , in the same spirit of the biological study of the evolution of specific traits , like the wings , the eye or the thumb , across different species .    in the realm of programming languages ,",
    "a suitable definition of heritable traits to be used for studying a sort of programming language phylogeny is far from being clear .",
    "we then consider here the general notion of _ programming abstractions _ as the semantic traits that we can trace back in the history of programming languages .",
    "in particular , we discuss some object - oriented abstraction , the type discipline and the integration of functional programming with other paradigms .",
    "[ [ object - oriented - languages ] ] object oriented languages + + + + + + + + + + + + + + + + + + + + + + + + +    if we consider the object model used by ools , we can identify a tight `` evolutionary lineage '' starting from c++ , passing through java and ending in scala .",
    "for instance , the enforcing of encapsulation has progressively increased along this lineage : c++ s friend functions violating encapsulation disappeared in java , and scala adopted the uniform access principle ( which dates back to the eiffel language ) , that is , object s fields and methods are accessed through the same notation , preventing the disclosure of any implementation details .",
    "moreover , research and practice about multiple inheritance conducted from c++ s superclass diamonds with virtual inheritance , through java s single inheritance and multiple interfaces , up to scala s mixins .",
    "this lineage also illustrates another trend in mainstream , general - purpose , languages : the programming style becomes more declarative and high - level , while implementation and efficiency issues are progressively moved under the hood by increasing the complexity of the runtime .",
    "a simple example is memory management : java s automatic garbage collector takes fine - grained memory handling away from the programmer s control .",
    "additionally , java s distinction between the primitive type ` int ` and the class type ` integer ` disappeared in scala .",
    "primitive types exist in java because they allow for an efficient memory implementation that avoids the overhead of class representation ; scala s solution ( inherited from smalltalk ) keeps a uniform object - oriented model in the language , that only has the ` int ` class type , and delegates to the compiler ( and the jvm ) the implementation of the ` int ` class type as java s efficient ` int ` type .",
    "[ [ typed - languages ] ] typed languages + + + + + + + + + + + + + + +    the rise and fall of types in mainstream programming is well represented in another evolutionary lineage of languages : the path from c++ , to java , to python / javascript , up to scala . in this case",
    "the object - oriented type system of c++ ( among other aspects ) proved to be a valid support for early finding `` message - not - understood '' errors typical of oop .",
    "then java pushed ahead types to a strong typing discipline , at the cost of becoming verbose and possibly cumbersome . as a reaction , untyped languages like python or javascript attracted programmers more interested in concise , easier to read and faster to write programming .",
    "ancient philosophers teach that `` virtue stands in the middle '' , indeed recent solutions are a compromise between the two extremes : statically typed languages such as scala or apple s swift  @xcite dramatically reduced type verbosity by improving the compiler s ability to infer types . at the same time , statically typed versions of untyped languages have been proposed , e.g. , microsoft s typescript  @xcite for javascript and mypy  @xcite for python .",
    "[ [ functional - programming ] ] functional programming + + + + + + + + + + + + + + + + + + + + + +    another interesting example to be looked at in an evolutionary perspective is the case of functional programming . for",
    "a long time programming by means of immutable data and higher - order functions had been confined to languages that have never become mainstream .",
    "pure functional programming has its merits , but sometimes the imperative style is more natural and much easier to reason about .",
    "c # is possibly the first mainstream language that clearly marks the integration of oop and fp into a multiparadigm language as a design goal .",
    "however , the full integration of these two paradigms is better achieved in scala , whose default variables are immutable and a function is nothing else than an instance , i.e. an object , of the class ( implementing the trait ) ` function ` .",
    "it is important to remark here that scala borrowed many of its features from previous languages , from smalltalk s uniform object model , to ocaml , ohaskell and plt - scheme design choices .",
    "we just intend to highlight here which abstractions have been recently brought to the fore as a result of an instance of the recombination process mentioned at the beginning of this section . to conclude , it is mandatory to observe that the recent standards c++11 and java8 both extended the language with lambda - expressions , that is with higher - order functions . besides encouraging a more declarative programming style ,",
    "as illustrated in the example below , functional programming has been proved to leverage parallel programming over data structures , which brings us back to our main topic .",
    "consider a list of people from which we want to find the age of the oldest male .",
    "let s focus on the java language , even if this is not restrictive . in what we could call the original java style ,",
    "we would write something like the following code :    .... person [ ] people = ... int maxage=-1 ; for(int i=0 ; i < people.length ; i++ )    if(people[i].getgender()==male & & people[i].getage()>maxage )       maxage = people[i].getage ( ) ; ....    this iteration corresponds to a pure imperative programming style .",
    "a pure object - oriented style would rather use an ` iterator ` over a ` collection ` , rephrasing the pattern as follows :    .... collection < person > people = ... iterator < person > it = people.iterator ( ) ; int maxage=-1 ; while(it.hasnext ( ) ) {    person p = it.next ( ) ;    if(p.getgender()==male & & p.getage()>maxage )       maxage = p.getage ( ) ; } ....    since java5 we can rephrase the iteration in a more abstract style , using the foreach construct :    .... collection < person > people = ... int maxage=-1 ; for(person p : people )    if(p.getgender()==male & & p.getage()>maxage )       maxage = p.getage ( ) ; ....    this style is more abstract in the sense that the iteration variable is not just an index ( or an iterator , which is a sort of pointer ) , but the current element under examination .",
    "we have also abstracted away iteration details like the size of the collection and the iteration increment step . with java8 iteration",
    "can be even more abstract , focusing on _ what _ we want to do , without going into _ how _ to do it , thanks to higher - order methods :    .... collection < person > people = ... int maxage= people.stream().filter(p - > p.getgender()==male )                             .maptoint(p - > p.getage ( ) )                             .max ( ) ; ....    in this code the data structure ( ` collection ` ) is used to produce a stream of elements that proceed through a pipeline of aggregate operations .",
    "also notice that these operations correspond to the _ map - reduce _ functional programing pattern , where the ` maptoint ` method is the _ transformer _ and ` max ` is the _",
    "combiner_. this new iteration style is a real advantage when the code heavily handles large data structures , since it is easily parallelizable by relying on ` parallelstream`s rather than sequential ` stream`s . indeed , in presence of parallel streams the java runtime partitions the stream into multiple substreams and let the aggregate operations to process these substreams in parallel by minimizing the synchronizations required by the concurrent computation .",
    "anyway , it is interesting to observe such a drift toward a more declarative , high - level , programming style .",
    "after having looked at how programming abstractions evolved in other areas , in this section we go back to concurrency .",
    "as we said above , a number of different concurrency models have been proposed .",
    "we recall here three models mainstream programming has been attracted by : the shared memory model , the message passing model , and the gp - gpu concurrency model . however , before discussing the three models , we emphasize the fact that they correspond to three different _ levels of explanation _ ( with reference to  @xcite )",
    ". an epistemological account of this aspect is clearly out of scope , we just observe that tackling concurrent programming and finding suitable primitives is much harder than , say , functional programming , since concurrency affects many levels : the hardware , the operating system , the language runtime , the language syntax , and the logical level of algorithms . here a quote from robin milner s turing lecture  @xcite is particularly fitting :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` i reject the idea that there can be a unique conceptual model , or one preferred formalism , for all aspects of something as large as concurrent computation [ ... ] we need many levels of explanation : many different languages , calculi , and theories for the different specialisms '' , and also `` many levels of explanations are indispensable . indeed the entities at a higher level will certainly be of greater variety than those lower down '' .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _        [ [ shared - memory - model ] ] shared memory model + + + + + + + + + + + + + + + + + + +    in programming language terms , the shared memory model is represented by java - like threads : dynamically activated concurrent flows of computation that communicate by means of synchronization on a shared state .",
    "this model , relying on mutable shared state , is well - suited to imperative programming .",
    "moreover , it is a very natural model for _ data - centric _ , centralized algorithms and centralized systems where different software components operate on shared data .",
    "however , protecting the shared state with appropriate synchronization mechanisms has been shown to be very difficult .",
    "java - like locks and conditions ( that are also available in c # and c++11 ) are error - prone and unscalable .",
    "errors like data races , deadlocks , priority inversion can be very subtle , and extensive testing is difficult because of nondeterminism and the fact that locks are not compositional .    [ [ message - passing - model ] ] message passing model + + + + + + + + + + + + + + + + + + + + +    when the application has a distributed nature and is _ communication - centric _ , shared - state is extremely error - prone . in this case",
    "the message passing model is much more valuable : the state is no longer shared but it is dispatched as a message .",
    "therefore , data races are avoided by construction and deadlocks are infrequent .",
    "message passing typically allows for a more declarative programming style and more easily scales to a distributed system , possibly at the cost of high communication and coordination overheads . notice that this model endorses immutable data and programming techniques that use effects locally , selectively or minimally , that is , functional programming .",
    "but there are not just functional languages that provide support for message passing : for instance the mpi standard is implemented in languages such as fortran , c and java .",
    "the c - based google s language go offers message passing in a channel - based style . anyway , whenever the underlying paradigm is imperative , mutable variables are not immune to subtle race conditions .",
    "an interesting integration of the message passing model with the object - oriented paradigm is represented by the actor model  @xcite .",
    "an actor , like an object , has an identity and reacts to messages in a single - threaded way in the same spirit of method invocations",
    ". moreover , encapsulation , modularization , the clear distinction between interface and implementation are key notions also in the design of actor systems .",
    "interestingly enough , the following quote from a. key talking about ool in 1998 fully applies also to actors :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` the key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviours should be '' @xcite .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    notice that this is not an accident since the actor model has been proposed in the same years when languages with concurrent objects were studied ( e.g.@xcite ) .",
    "today , the actor model is distinctive of erlang , a purely functional language with concurrency primitives that has been developed in the 1990s but whose popularity has grown in the 2000s due to the demand for concurrent services . nowadays erlang is used in a number of significant industrial projects such as facebook chat , github , whatsapp .",
    "the actor model is also one of the successful features of scala , which is adopted for instance by coursera , linkedin , ebay , essentially because it provides a type safe language with scalable concurrency primitives on top of the jvm , which is a mature technology platform . in",
    "is interesting to observe that , differently from erlang , in the case of scala the original actor - based constructs are not primitive in the language , but they are defined as a regular api whose implementation emerges as an effective example , in the spirit of the quest depicted in section  [ sec : quest ] , of how scala s object - oriented and functional abstractions productively interoperate @xcite .",
    "another approach that is getting increasing attention in the realm of communication - centric computing is _ protocol - based computing_. in this view , programming a concurrent ( and distributed ) system entails the design of a precise communication protocol involving a , possibly dynamic , set of interacting parties . using the terminology of service - oriented programming ,",
    "if a service is represented as a sequence , or more generally as a graph , of messages to be sent / received , then an application can be viewed as service orchestration . however , web service technology and languages ( e.g. , jolie  @xcite ) are just an example of what can be called protocol - centric programming .",
    "another example is offered by the scribble language  @xcite and the other outcomes of the rich theory of behavioural types and session types that are percolating at the level of programming languages .",
    "[ [ general - purpose - gpu - programming ] ] general purpose - gpu programming + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    over the years the graphics processing unit ( gpu ) and its massively parallel architecture proved to be convenient also for general purpose usage , particularly for some class of algorithms and applications where large amount of data need to be parallely processed .",
    "physics simulations , ray tracing , bioinformatics , evolutionary computation , machine learning , oil exploration , scientific image processing , linear algebra , statistics , 3d reconstruction , bitcoins mining and even stock options pricing , and many more fields and disciplines can benefit from this architecture .",
    "gpus use the `` single instruction , multiple data''(simd ) architecture , in which multiple processors execute the same instructions on different pieces of data .",
    "this allows the control flow computation to be shared amongst processors , so that more of the hardware is devoted to instruction execution .",
    "however , given this architecture , gp - gpu programming requires a specific algorithmic thinking and a corresponding programming model . in 2006",
    "nvidia launched cuda , a parallel computing platform on gpus comprising a programming model and an extension to the c programming language .",
    "however , in the cuda programming model it is fundamental to precisely know the underlying architecture and its consequences on the performance of programs .",
    "it is essential to be aware of how ( sets of ) threads are mapped onto the hardware , how they are executed and scheduled , and to know the peculiarities of memory access patterns .",
    "therefore cuda brings about an extremely low - level programming , which allows c / c++ programmers to significantly fine - tune the applications performance , at the price of sacrificing high - level abstraction .    the recent explosion of interest in gp - gpu , both from the research community and the industry is changing the situation .",
    "in particular , efforts are made to unify host and device programming .",
    "on the hardware side , the memories of the cpu and gpu are physically distinct but cuda 6 very recently ( @xcite ) provided a unified managed memory that is accessible to both the cpu and gpu , and thus avoids the need of explicitly programming the migration of data from the cpu to the gpu and back",
    ". moreover , support for object handling , dynamic allocation and disposal of memory is rapidly growing . on the software side , many projects develop high - level programming models for gp - gpu , such as openacc for c / c++ , copperhead for python , the nova statically - typed functional language , and x10 heterogeneous compiler .",
    "this field is clearly not yet mature , but the integration of the gpu concurrency model with high - level programming is just a matter of time .",
    "we can trace an evolutionary lineage also locally to shared memory abstractions .",
    "the original java threading model provides a class ` thread ` whose instances are associated to ( possibly dynamically ) created jvm threads . to spawn a new thread",
    "the programmer must create a new object of type ` thread ` that encapsulates the code to be executed in parallel , and then call the method ` start ( ) ` on such an object .",
    "however , requesting and obtaining the exclusive control of a jvm thread is costly in terms of performance .",
    "novel solutions enforce a clear distinction between _ logical threads _ , that is , the activities to be concurrently executed , a.k.a .",
    "tasks , and the _ executors _ , which are pools of ( jvm ) thread workers . in particular , the link between the task to be executed and the thread actually executing it is taken away from the programmer s control and it is devolved to an efficient work - stealing scheduling algorithm implemented by the runtime .",
    "the difference between the lightweight threads spawned in the program and the pool of executors available in the runtime is particularly marked in the x10 language . in this language ,",
    "a block of code to be executed in parallel is simply defined by the statement ` async{ ... code ... } ` .",
    "the ` finish { ... } ` statement instructs the control to wait for the termination of all the concurrent code that might have been asynchronously spawned within the ` finish ` block . in other terms , x10 concurrency primitives provide a very simple ( but effective ) fork / join model that abstracts away the management of thread workers . similar ( but less straightforward ) solutions are available in recent java releases , together with a number of classes that allow the programmer to customize the pool of runtime executors .    to conclude",
    ", we observe the evolution of another distinctive feature of the java threading model : the use of locks and conditions . as we discussed above , correctly using primitives like ` synchronized , wait ( ) , notify ( ) ` is very difficult .",
    "hence java concurrency library encapsulates a correct usage of these primitives into ready - to - be - used higher level abstractions such as atomic values , barriers , synchronized data structures .",
    "however , x10 completely dismissed java s low level , error - prone building blocks , in favor of higher - level primitives such as ` atomic { ... } ` and ` when(condition ) { ... } ` , directly taken from software transactional memories .",
    "in this section we complete the overview of the programming languages timeline that we started in section  [ sec : quest ] .",
    "in particular , we discuss a couple of more recent driving forces that are powering other significant changes in mainstream programming , as illustrated in figure  [ fig : timelineii ] .",
    "besides multicores and gpus , which drive concurrent programming , another important achievement of modern technology is cloud computing , which is acting as a catalyst for _ distributed programming_. also in this case , distributed systems are well - established , together with a number of successful programming solutions like sockets , rpcs ( remote procedure call ) , rmi ( remote method invocation ) , the grid , soa ( service oriented architecture ) .",
    "however , the key change here is that the popularity of cloud resources shifted the business applications model from a centralized service provider accessed in client - server model , to the so - called software as a service ( saas ) model , where applications are deployed on heterogeneous platforms , from mobile devices up to cloud based clusters , running thousands of multicore processors .",
    "such a model requires ad hoc solutions to productively deal with scalability issues , hardware heterogeneity , fault tolerance , security and privacy .",
    "these requirements demand new architectural and system - level solutions , but also well - suited programming models can clearly offer a strong support .    in this context , _ reactive programming _ is attracting a growing appeal .",
    "the reactive manifesto  @xcite precisely distills the distinctive features of reactive applications : they must be ready to react to events , react to load , react to failures , and react to users .",
    "reactivity to events : :    entails an event - driven programming model that , instead of issuing a    command that",
    "_ asks for a change _",
    ", reacts to an event that indicates    that something _",
    "has changed_. such a model endorses all kinds of    asynchronous operations : non blocking operations and decoupling event    generation from event processing result in higher performance and    scalability . as an example , _ futures _ are an asynchronous concurrency    abstraction that has come to light in many recent mainstream    languages . reactivity to load : :    means the ability to scale up / down to deal with addition / removal of    cpus on a node , and to scale out / in to deal with addition / removal of    server nodes .",
    "scalability , or elasticity , requires loose coupling    between component behaviour and its location ( i.e. , location    transparency ) .",
    "it also requires to minimize shared mutable state and    explicitly focuses on components communication .",
    "reactivity to failures : :    asks for programming styles that enforce application resilience , in    order to quickly recover from software failures , hardware failures ,    and communication failures .",
    "for instance , minimization of    interdipendencies between components , encapsulation and hierarchic    supervision lead to software components that are better isolated and    monitored .",
    "reactivity to user interaction : :    addresses application responsiveness .",
    "this aspect champions    asynchronous and event - driven approaches and technologies that push    data towards consumers when available rather than polling , such as    push - servers  @xcite or websockets  @xcite which push events to    browser and mobile applications .",
    "this scenario will act as the environment operating a selection over the features of actual programming languages .",
    "many of the features described in the previous sections clearly have to do with some of the items above , but cloud computing and reactive programming bring about a new shuffle of old issues and new problems . hence new `` language mutations",
    "'' will appear to adapt to these new requirements .      by reaching the end of our timeline , we find the current challenge we are facing in computer science : dealing with the huge amount of data that are collected by smart devices and pervasive computing .",
    "big data applications require high - performance and data - parallel processing at a greater order of magnitude .",
    "interestingly , reactive programming can be convenient here with its view of data in terms of streams of data rather than a collection / warehouse of data .",
    "however , analytic computations on big data are proving to be the killer application for _ high performance computing _ ( hpc ) , that is , the programming model designed for scale - out computation on massively parallel hardwdare .",
    "this paradigm is targeted not only to cloud infrastructures , but also to high - performance computing on supercomputers with massive numbers of processors . to exemplify ,",
    "let s consider the x10 programming language , an open - source language developed at ibm research  @xcite , whose design recombines earlier programming abstraction into a new mix in order to fit the hpc requirements .",
    "x10 is designed around the _ place _ abstraction , which represents a virtual computational node that can be mapped onto a computer node in the cluster , or onto a processor or a core in a supercomputer .",
    "according to the hpc model , a single program runs on a collection of places , it can create global data structures spanning multiple places , and it can spawn tasks at remote places and detect their termination . at the same time , a significant design feature is that x10 is an object - oriented , high - level programming language : its syntax is reminiscent of java - like and scala - like abstractions , and a powerful and expressive type system enforces static checks and promotes the programming - by - contracts methodology in terms of constrained dependent types .",
    "notice that tackling high performance computing by means of high - level programming abstractions enhances productivity and integration with mainstream programming .",
    "however , it also implies that considerable efforts must be put in place at the runtime environment level : raising the abstraction level of the source program must indeed be balanced out by an efficient executable with significant performance on heterogeneous hardware .",
    "indeed , in the case of x10 , the source code compiles either to java code , or to c++ code or also to cuda code .",
    "moreover , the resilient runtime supports executions that are tolerant of place failures .",
    "x10 is then well - suited to write code running on 100 to 10.000 multicore nodes , that is up to 50 millions of cores .",
    "as far as concurrency is concerned , high performance computing requires specific abstractions that allow the program to capture the logic of big data applications without explicitly dealing with distribution and parallelism issues . once again , the quest for good abstractions that allow both a more declarative code and an efficient implementation is crucial also in hpc , where the gap between the logic of the application and the execution infrastructure is particularly large .",
    "a couple of so - called big data application frameworks are proving to be successful : the _ map - reduce _ model and the _ bulk synchronous parallel _ model .",
    "the map - reduce model , implemented for instance by google s mapreduce , apache hadoop and apache spark , is a model inspired by map and reduce combinators from the functional programming , through which many real world tasks can be expressed ( e.g. , sorting and searching tasks @xcite ) .",
    "the bulk synchronous parallel ( bsp ) model , implemented for instance by google s pregel [ 11 ] and apache giraph , has recently gained great interest because of its ability to process graphs of enormous size , such as social or location graphs , by deeply exploiting the work distribution on several machines ( e.g.  @xcite ) .",
    "it is worth observing that these two models could be classified as _",
    "concurrency patterns _ , in that , similarly to classical object - oriented design patterns , they compose basic ( concurrent ) abstractions into strategic solutions . this observation illustrates how hpc entails an abstraction level , hence also a level of explanation , that is higher than that of concurrent programming , that will lead to the forthcoming landmark in the timeline .",
    "the timeline we have described so far lists the catalysts that powered significant changes in mainstream programming .",
    "this list also bears out the co - evolution of programming languages and hardware technology , which incidentally is evocative of the co - evolution of the human language and the brain .",
    "however , in the history of programming languages there is another important co - evolving lineage , that corresponds to the advances of the theoretical research .",
    "it is not worth here to distinguish what theoretical results affected mainstream programming ad what application solutions powered theoretical work .",
    "such a distinction would require a precise historical reconstruction , and it is not essential to acknowledge that both areas have been mutually influenced , thus co - evolved .",
    "let us rather recall another quote from robin milner s turing lecture  @xcite talking about the semantic ingredients of concurrent computation :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` i believe that the right ideas to explain concurrent computing will only come from a dialectic between models from logic and mathematics and a proper distillation of a practical experience [ ... ] on the one hand , the purity and simplicity exemplified by the calculus of functions and , on the other hand , some very concrete ideas about concurrency and interaction suggested by programming and the realities of communication '' .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the role of the theory in the evolution of programming languages is then essential for the _ dialectic method _ devised by robin milner . in his lecture",
    "he aimed at distilling the basic semantic elements of concurrent interaction , but the same holds also in general for programming primitives : suitable programming abstractions come from a dialectic between the experimental tests conducted by practical programming , and the deep mathematical tests conducted by the theoretical approach .",
    "observe that these two kinds of tests are often conducted at different times , with practical programming occasionally picking out some theoretical result tested much earlier in a possibly slightly different context .",
    "the formal languages studied by the theoreticians are indeed well suited to test new abstractions and new mix of abstractions in a concise and expressive model . in other terms , they allow for experimentation in a controlled environment . for instance , notions like asynchrony , locality , scope extrusion , futures , mobility , security , timing , probability and many other have been studied by many process calculi both in isolation and in combination .",
    "this kind of research is a definite contribution to what we called the quest for good abstractions . in evolutionary terms",
    ", we could say that theoretical research tests and promotes language mutations , not necessarily driven by the actual environment or the short - term future .",
    "additionally , when working in a formal framework it is easier to distinguish the different abstraction levels involved in a given issue .",
    "hence it is easier to first pick out just a single level to develop specific solutions , and then to study the integration of separate approaches into a distinct model , explicitly targeted at the combination of the different abstraction levels .",
    "a nice example of combination of different abstraction levels are the works of abadi , fournet et gonthier about the translation of communication on secure channels into encrypted communication on public channels  @xcite . in these works the high level primitives for secure communication in a pi - calculus - like language",
    "are mapped into a lower - level , spi - calculus - like , language that includes cryptographic primitives .",
    "the correctness theorem for such a translation implies that one can reason about the security of programs in the high - level language without mentioning the subtle cryptographic protocols used in their lower - level implementation .    as a final example of productive mix of abstractions resulted from the dialectic method described above",
    ", we recall the recent process of integration of functional programming into object - oriented and concurrent programming languages . an interesting way of looking at such a process is observing that this integration is actually fostered by understanding the notion of _ function _ as an abstraction that represents a _ behavior _ , which can be passed around and composed .",
    "moreover , while imperative programming involves thinking in terms of _ time _ , functional programming rather focuses on _ space _ , where basic functions / behaviors are composed by need as building blocks , and the execution advances by transforming immutable values instead of stepwise modifications of mutable state ( @xcite ) .",
    "the spatial view of functional programming can smoothly fit oop s ability of structuring software systems . on the other hand , designing a concurrent system in terms of space rather than time is easier and it allows one to better deal with the intrinsic nondeterminism . as a result , after fifty years of functional programming , the distinctive traits of those languages shine in new languages essentially because they leverage concurrency .",
    "an evolutionary biologist would call such a functional shift an example of exaptation  @xcite .",
    "to conclude our excursus we point up some final comment .",
    "first we remark that in the realm of natural languages we know that writing in a language involves thinking in that language .",
    "the same holds also for programming languages : each language entails a specific programming style , and we know that _ what _ is being said ( or coded ) is shaped and influenced by _ how _ is being said ( or coded ) .",
    "and the same also holds for formal models and theoretical frameworks .",
    "it is then important to remind that there is no best model / language , but there might be a best suited model / language for a given situation .",
    "that is why occasionally changing the working model / language might be beneficial .",
    "moreover , modern software systems distinctive of innovative internet - driven companies such as google , facebook , linkedin , are actually written using a mix of languages , creating a sort of ecosystem of programming languages that interoperate at different abstraction levels . as a consequence ,",
    "a productive mix of models together with interoperable primitives is vital .",
    "a final comment is devoted to our evolutionary look at the modern history of programming languages . in this paper",
    "we essentially used the evolutionary talking as a metaphor .",
    "however , a thorough discussion about to what extent darwin s theory of evolution can be applied to programming languages would be very insightful .",
    "indeed , it would be quite interesting to answer questions like what are language mutations and is there a struggle for life in the language arena ?",
    "are different concurrency models / abstractions an example of mutations over which the market ( or the marketing strategies ) will do its selection action ? will only those languages that are equipped with higher plasticity either in their design choices or in their marketing strategies survive ?",
    "it is not an accident that oracle embarked on a deep change of the java platform , both in the language , the jvm and the programming style , to leverage java8 s lambda expressions  @xcite ; how else could we call such a change if not a form of adaptation ?"
  ],
  "abstract_text": [
    "<S> in this paper we examine how concurrency has been embodied in mainstream programming languages . in particular , we rely on the evolutionary talking borrowed from biology to discuss major historical landmarks and crucial concepts that shaped the development of programming languages . </S>",
    "<S> we examine the general development process , occasionally deepening into some language , trying to uncover evolutionary lineages related to specific programming traits . </S>",
    "<S> we mainly focus on concurrency , discussing the different abstraction levels involved in present - day concurrent programming and emphasizing the fact that they correspond to different levels of explanation . </S>",
    "<S> we then comment on the role of theoretical research on the quest for suitable programming abstractions , recalling the importance of changing the working framework and the way of looking every so often . </S>",
    "<S> this paper is not meant to be a survey of modern mainstream programming languages : it would be very incomplete in that sense . </S>",
    "<S> it aims instead at pointing out a number of remarks and connect them under an evolutionary perspective , in order to grasp a unifying , but not simplistic , view of the programming languages development process . </S>"
  ]
}