{
  "article_text": [
    "constraint logic programming ( clp )  @xcite is a natural and well understood extension of logic programming ( lp ) in which term unification is replaced by constraint solving over a specific domain .",
    "this brings a number of theoretical and practical advantages which include increased expressive power and declarativeness , as well as higher performance for certain application domains .",
    "the resulting clp languages allow applying efficient , incremental constraint solving techniques to a variety of problems in a very natural way : constraint solving blends in elegantly with the search facilities and the ability to represent partially determined data that are inherent to logic programming . as a result ,",
    "many modern prolog systems offer different constraint solving capabilities .",
    "one of the most successful instances of clp is the class of constraint logic languages using _ finite domains _",
    "( @xmath0 ) .",
    "finite domains refer to those constraint systems in which constraint variables can take values out of a finite set , typically of integers ( i.e. , a _ range _ ) .",
    "they are very useful in a wide variety of problems , and thus many prolog systems offering constraint solving capabilities include a finite domain solver . in such systems ,",
    "domain ( range ) definition constraints as well as integer arithmetic and comparison constraints are provided in order to specify problems .    since the seminal paper of van hentenryck et al .",
    "@xcite , many fd solvers adopt the so - called `` glass - box '' approach .",
    "our fd kernel also follows this approach , based on a unique primitive called an _",
    "indexical_. high - level constraints are then built / defined in terms of primitive constraints .",
    "an indexical has the form ` x in r ` , where @xmath1 is a range expression ( defined in [ fig : range : syntax ] ) . intuitively , `",
    "x in r ` constrains the @xmath0term ( @xmath0variable or integer ) ` x ` to belong to the range denoted by the term ` r ` . in the definition of the range special expressions",
    "are allowed .",
    "in particular , the expressions ` max(y ) ` and ` max(y ) ` evaluate to the minimum and the maximum of the range of the @xmath0variable ` y ` , and the expression ` dom(y ) ` evaluates to the current domain of ` y ` .",
    "constrains are solved partially in an incremental using consistency techniques  @xcite which maintain the constraint network in some coherent state ( depending on the arc - consistency algorithm used ) .",
    "this is done by monotone domain shrinking and propagation . when all constraints are placed and all values have been propagated a call is typically made to a _ labeling _ predicate which performs an enumeration - based search for sets of compatible instantiations for each of the variables that remain not bound to a single value .",
    "we refer to @xcite for more details regarding indexicals and finite domain constraint solving .    in this paper , we present a new free library for constraint logic programming over finite domains , included with the ciao prolog system  @xcite . the library is entirely written in prolog , leveraging on ciao s module system and code transformation capabilities in order to achieve a highly modular design without compromising performance .",
    "we describe the interface , implementation , and design rationale of each modular component .",
    "the library meets several design goals : a high level of modularity , allowing the individual components to be replaced by different versions ; high - efficiency , being competitive with other @xmath0 implementations ; a glass - box approach , so the user can specify new constraints at different levels ; and a prolog implementation , in order to ease the integration with ciao s code analysis components .",
    "the core is built upon two small libraries which implement integer ranges and closures .",
    "on top of that , a _ finite domain variable _ datatype is defined , taking care of constraint reexecution depending on range changes .",
    "these three libraries form what we call the _ @xmath0kernel _ of the library .",
    "this @xmath0kernel is used in turn to implement several higher - level finite domain constraints , specified using indexicals .",
    "together with a labeling module this layer forms what we name the _",
    "@xmath0 solver_. a final level integrates the clp(@xmath0)paradigm with our @xmath0solver . this",
    "is achieved using attributed variables and a compiler from the clp(@xmath0)language to the set of constraints provided by the solver .",
    "it should be noted that the user of the library is encouraged to work in any of those levels as seen convenient : from writing a new range module to enriching the set of @xmath0constraints by writing new indexicals .",
    "one of the first clp(@xmath0)implementations is the chip system  @xcite .",
    "this commercial system follows a typical black - box approach : it consists of a complete solver written in c and interfaces in an opaque manner to a prolog engine .",
    "this makes it difficult for the programmer to understand what is happening in the core of the system .",
    "also , no facilities are provided for tweaking the solver algorithms for a specific application .    more recent clp(@xmath0)systems such as those in sicstus  @xcite , gnu prolog  @xcite , and b - prolog @xcite are built instead following more the glass - box approach .",
    "the basic constraints are decomposed into smaller but highly optimized primitives ( typically indexicals ) . consequently",
    ", the programmer has more latitude to extend the constraints as needed .",
    "however , even if such systems can be easily modified / extended at the interface level ( e.g. , both sicstus and b - prolog provide way to define new global constraints ) they are much harder to modify at the implementation level ( e.g. , it is not possible to replace the implementation of range ) .",
    "the ciao clp(@xmath0)library that we present has more similarities with the one recently developed for swi prolog  @xcite .",
    "both are fully written in prolog and support unbound ranges .",
    "the swi library is clearly more complete than ciao s ( e.g. , it provides some global constraints and always terminating propagation ) , but it is designed in a monolithic way : it is implemented in a single file , mixing different language extensions ( using classical prolog ` term_expansion ` mechanisms ) while the ciao library is split in more around 20 modules with a clear separation of the different language extensions  @xcite .",
    "summarizing , our library differs in a number of ways from other existing approaches :    * first , along with more recent libraries it differs from early systems in that it is written entirely in prolog . this dispenses with the need for a foreign interface and opens up more opportunities for automatic program transformation and analysis .",
    "the use of the meta - predicates ` setarg/3 ` and ` call/1 ` means that the use of prolog has a minimal impact on performance . *",
    "second , the library is designed as a set of separate modules .",
    "this allows replacing a performance - critical part  like the range code  with a new implementation better suited for it . *",
    "third , the library supports the `` glass - box '' approach fully , encouraging the user to access directly the low - level layers for performance - critical code without losing the convenience of the high - level clp paradigm .",
    "again , the fact that the implementation is fully in prolog is the main enabler of this feature . *",
    "lastly , we have prioritized extensibility , ease of modification , and flexibility , rather than micro - optimizations and pure raw speed . however , we argue that our design will accommodate several key optimizations like the ones of  @xcite without needing to extend the underlying wam .    the rest of the paper proceeds as follows . in sec .  [",
    "sec : structure ] we present the architecture of the library and the interface of the modules . in sec .",
    "[ sec : glass - box - effect ] we discuss with an example how to use the glass box approach at different levels for better efficiency in a particular problem , with preliminary benchmarks illustrating the gains . finally , in sec .",
    "[ sec : conclusions ] we conclude and discuss related and future work .",
    "the ciao clp(@xmath0)library consists of seven modules grouped into three logical layers plus two specialized prolog to prolog translators . in the definition of these modules and interfaces we profit from ciao s module system  @xcite and ciao s support for assertions  @xcite , so that every predicate is correctly annotated with its types and other relevant interface - related characteristics , as well as documentation .",
    "the translators are built using the ciao _ packages _ mechanism  @xcite , which provides integrated and modular support for syntax modification and code transformations .",
    "a description of the user interface for the library along with up - to - date documentation may be found in the relevant part of the ciao manual .      the global architecture",
    "is illustrated in fig .",
    "[ fig : global - architecture ] .",
    "the kernel layer provides facilities for range handling and propagation chains , which are used for defining finite domain variables  which , as mentioned before , are different from the standard logical variables .",
    "the @xmath0layer defines a finite set of constraints such as ` a+b = c/3 ` , using indexicals .",
    "these constraints are translated form their indexical form to a set of instructions of the kernel layer .",
    "labeling and branch - and - bound optimization search modules complete the finite domain solver .",
    "the clp(@xmath0)constraints are translated to @xmath0constraints by a clp(@xmath0)compiler .",
    "we use attributed variables to attach a finite domain variable to every logical variable involved in clp(@xmath0)constraints .",
    "thus , the clp(@xmath0)layer is thin and of very low overhead .",
    "( fd_var ) at ( 0.5 , 1 ) @xmath0term ; ( fd_propags ) at ( -1.5 , -0.8 ) propagators ; ( fd_range ) at ( 1.5 , -0.8 ) range ; ( fd_var )  ( fd_range ) ; ( fd_var ) ",
    "( fd_propags ) ; ( kernel ) at ( -0.25,0.3 ) ; ( n ) at ( -1.75,1.5 ) * @xmath0kernel * ;    ( fd_const ) at ( 4 , -1.25 ) [ right ] @xmath0constraints ; ( labeling ) at ( 4,0.25 ) [ right ] labeling ; ( optim ) at ( 4,1.75 ) [ right ] b&b optimization ;    ( optim ) to [ out=180,in=25 ] ( kernel ) ; ( optim ) to [ out=-45,in=45 ] ( fd_const ) ; ( labeling ) to [ out=180,in=0 ] ( kernel ) ; ( labeling ) to [ out=-90,in=120 ] ( fd_const ) ; ( fd_const ) to [ out=180,in=-20 ] node[below=13,pos=0.6 ] idx compiler ( kernel ) ;    ( solver ) at ( 2.25,0 ) ; ( n ) at ( 6.5,-2.25 ) * @xmath0solver * ;    ( clp_rt ) at ( 2.25,3.65 ) clp(@xmath0)run time ; ( clp_rt )  ( solver ) node[midway , auto = left ] clp(@xmath0)compiler ; ( solver ) at ( 2.25,0.5 ) ; ( n ) at ( -2.5,3.5 ) * clp(@xmath0 ) * ;      the finite domain kernel is the most important part of the library .",
    "its implementation freely follows the design of the gnu  prolog @xmath0solver ( @xcite provides a general overview of this solver ) .",
    "a finite domain variable is composed of a range and several propagation chains . when the submission of a constraint modifies the range of a finite domain variable , other finite domain variables depending on that range are updated by firing up constraints stored in propagation chains .",
    "the propagation events are executed in a synchronous way , meaning that a range change will fail if any of its dependent constraints can not be satisfied",
    ".    the kernel implements arithmetic over ranges ( pointwise operations , union , intersection complementation , ... ) and management of propagation chains , amounting to the delay of prolog goals on arbitrary events .",
    "these two elements are used to implement the two basic operations of a finite domain variable : ` tell ` and ` prune ` .",
    "the first one attempts to constrain a variable into a particular range , while the second one ( prune/2 ) removes a value form the range of a variable .",
    "the variable code inspects the new and old ranges and wakes up the suspended goals on a given variable .",
    "all the data structures are coded in an object - oriented style .",
    "efficient access and in - place update are implemented by using the ` setarg/3 ` primitive .",
    "we took special care to use ` setarg/3 ` in a _",
    "safe _ way to avoid undesired side effects , such as those described by tarau  @xcite .",
    "range handling is one of the most important parts of the library , given the high frequency of range operations .",
    "indeed , the library supports three implementations for ranges : the standard one using lists of closed integer intervals ; an implementation using lists of open ( i.e. , unbounded ) intervals ; and a bit - based implementation which despite allowing unbound ranges is more suitable for problems dealing with small ranges .",
    "indeed , the user is encouraged to implement new range modules which are better suited to some particular problems .",
    "the interface that a range module must implement is split into two parts .",
    "the first one , shown in fig .",
    "[ fig : range : syntax ] , deals with range creation and manipulation .",
    "each of the operations defined in the figure has a corresponding predicate .",
    "for instance , bounds addition ` t+t ` is implemented by the predicate ` bound_add/3 ` , and similarly for the rest of the predicates .",
    "note that it is a convention of the interface that any operation that tries to create an empty range will fail .",
    "this is better for efficiency and we found no practical example yet where this would be inconvenient .",
    "[ fig : range : preds ] lists the rest of the predicates that a range implementation must provide .",
    "they are mainly used for obtaining information about a range and are instrumental for the labeling algorithms .",
    "lllllll ` r ` & & @xmath2 & @xmath3 & ` t .. t ` & @xmath4 & ( interval ) + & & & @xmath5 & ` { t } ` & & ( singleton ) + & & & @xmath5 & ` r \\/",
    "r ` & & ( union ) + & & & @xmath5 & ` r /\\ r ` & & ( intersection ) + & & & @xmath5 & ` - r ` & & ( complementation ) + & & & @xmath5 & ` r + n ` & & ( pointwise addition ) + & & & @xmath5 & ` r - n ` & & ( pointwise subtraction ) + & & & @xmath5 & ` r * n ` & & ( pointwise multiplication ) +   + ` t ` & & : : = & & ` min(y ) ` & & ( minimum ) + & & & @xmath5 & ` max(y ) ` & & ( maximum ) + & & & @xmath5 & ` dom(y ) ` & & ( domain ) + & & & @xmath5 & ` val(y ) ` & & ( value ) + & & & @xmath5 & @xmath6 & & ( arithmetic expression ) + & & & @xmath5 & ` n ` & & ( bound ) +    [ cols= \" < , < \" , ]     the differences go from negligible to more than 50% . in a different benchmark ( bridge ) , the closed interval version was 25% faster than the open one .",
    "we now focus on the different possibilities that the library allows for @xmath0constraint programming .    in the queens program ,",
    "the main constraint of the problem is expressed by the ` diff/3 ` constraint :    .... diff(x , y , i ) : -      x    # \\= y ,      x    # \\= y+i ,      x+i # \\= y. ....    where ` i ` will be always an integer .",
    "however , the compiler can not ( yet ) detect that ` i ` is an integer , and may perform some unnecessary linearization .",
    "we may skip the compiler and define ` diff ` using directly the @xmath0constraints :    .... diff(x , y , i):-",
    "fd_constraints:'a<>b'(~w(x),~w(y ) ) ,      fd_constraints:'a<>b+t'(x , y , i ) ,      fd_constraints:'a<>b+t'(y , x , i ) . ....",
    "the speedup is considerable , getting close to 50% speedup in some cases .",
    "indeed , the compiler should be improved to produce this kind of code by default .",
    "the user may notice that the above three constraints may be encoded by using just two indexicals .",
    "for instance one can use the following definition for ` diff/3 ` :    .... diff(x , y , i):-",
    "idx_diff(~w(x ) , ~w(y ) , i ) .",
    "idx_diff(x , y , i ) + :      x in -{val(y ) , val(y)+c(i ) , val(y)-c(i ) } ,      y in -{val(x ) , val(x)+c(i ) , val(x)-c(i)}. ....    again , the improvement is up to 40% from the previous version .",
    "however , the constraint ` diff ` can be improved significantly by using directly the kernel delay mechanism ( val chain ) and @xmath0variable operations . in particular , we use the optimized kernel ` prune/2 ` operation that removes a single element form the range of a variable :    .... diff(x , y , i):-      wrapper(x , x0 ) , wrapper(y , y0 )      fd_term : add_propag(y , val , ' queens : cstr'(x0 , y0 , i ) ) ,      fd_term : add_propag(x , val , ' queens : cstr'(y0 , x0 , i ) ) .",
    "% y is always a singleton .",
    "cstr(x , y , i):-      fd_term : integerize(y , y0 ) ,      fd_term : prune(x , y0 ) ,      y1 is y0 + i ,      fd_term : prune(x , y1 ) ,      y2 is y0 - i ,      fd_term : prune(x , y2 ) .",
    "....    we reach around 80% speedup from the first version , and this result is optimal regarding what the user can do .",
    "additional speedups can be achieved , but not without going beyond our glass - box approach .",
    "indeed , our clp(@xmath0)compiler is simpler given that we are working on a new translator that directly generates custom kernel constraints from clp(@xmath0)constraints .",
    "the ciao clp(@xmath0)library described is distributed with the latest ciao version , available at http://ciaohome.org . although included in the main distribution , it lives in the ` contrib ` directory , as it should be considered at a beta stage of development .    even if we did not include yet important optimizations that should improve significantly the performance of the library",
    ", the current results are encouraging .",
    "the library has been used successfully internally within the ciao development team in a number of projects .",
    "the modular design and low coupling of components allow their easy replacement and improvement .",
    "indeed , every individual piece may be used in a glass - box fashion .",
    "we expect that the use of prolog will allow the integration with ciao s powerful static analyzers . at the same time",
    ", the clear separation of run - time and compile - time phases allows the modification and the improvement of the translation schemes in an independent manner .",
    "indeed , the advantages of this design have already been showcased in  @xcite , where a prolog to javascript cross - compiler was used to provide a js version of the library and which only required replacing a few lines of code . using this",
    "cross - compiler clp(@xmath0)programs can be run on the server side or on the browser side unchanged .    regarding future work , we distinguish two main lines : the kernel and the clp(@xmath0)compiler .    for the kernel ,",
    "the first priority is to finish settling down its interface . while we consider it mature , some optimizations",
    " like avoiding reexecution  may require that we include more information in our @xmath0variable structure , range modification times , etc .",
    "indeed , we would like to support more strategies for propagators than the current linear one .",
    "support for some global constraints is on the roadmap , and will likely mean the addition of more propagation chains .",
    "the library features primitive but very useful statistics .",
    "however we think it is not enough and we are working on an @xmath0instrumentation package that will provide detailed statistics and profiling .",
    "this is key in order to extract the maximum performance from the library .",
    "once we get detailed profiling information from a wide variety of benchmarks , a better range implementation will be due .    regarding the clp(@xmath0)compiler , the current version should be considered a proof of concept .",
    "indeed , we are studying alternative strategies including the generation of custom kernels or specialized @xmath0constraints for each particular program in contrast to the current approach of mapping a clp(@xmath0)program to a fixed set of primitive constraints .",
    "ciaopp  ciao s powerful abstract interpretation engine  could be used in the translation , providing information about the clp(@xmath0)program to the clp(@xmath0)compiler so it can generate an optimal kernel of @xmath0code for that program . in this sense",
    ", we think that we will follow the ciaopp approach of combining inference with user - provided annotations in the new clp(@xmath0)compiler .",
    "the authors would like to thank the anonymous reviewers for their insightful comments .",
    "the research leading to these results has received funding from the madrid regional government under cm project p2009/tic/1465 ( prometidos ) , and the spanish ministry of economy and competitiveness under project tin-2008 - 05624 _ doves_. the research by rmy haemmerl has also been supported by picd , the programme for attracting talent / young phds of the montegancedo campus of international excellence .    10    jaffar , j. , maher , m. : onstraint lp : a survey .",
    "jlp * 19/20 * ( 1994 ) 503581    , saraswat , v. , deville , y. : design , implementation and evaluation of the constraint language cc(fd ) .",
    "journal of logic programming * 37*(13 ) ( 1998 ) 139164    dib , m. , abdallah , r. , caminada , a. : arc - consistency in constraint satisfaction problems : a survey . in : second international conference on computational intelligence ,",
    "modelling and simulation .",
    "( 2010 ) 291296    hermenegildo , m.v . ,",
    "bueno , f. , carro , m. , lpez , p. , mera , e. , morales , j. , puebla , g. : n overview of ciao and its design philosophy .",
    "theory and practice of logic programming * 12*(12 ) ( january 2012 ) 219252 http://arxiv.org/abs/1102.5497 .",
    "dincbas , m. , hentenryck , p.v . , simonis , h. , aggoun , a. : he constraint logic programming language chip . in : proceedings of the 2nd international conference on fifth generation computer systems .",
    "( 1988 ) 249264    carlsson , m. , ottosson , g. , carlson , b. : an open - ended finite domain constraint solver . in : proceedings of the9th international symposium on programming languages : implementations , logics , and programs : including a special trach on declarative programming languages in education .",
    "plilp 97 , london , uk , uk , springer - verlag ( 1997 ) 191206    d.  diaz , s.a . ,",
    "codognet , p. : on the implementation of gnu prolog . theory and practice of logic programming * 12*(12 ) ( january 2012 ) 253282    codognet , p. , diaz ,",
    "d. : compiling constraints in clp(fd ) . j. log . program .",
    "* 27*(3 ) ( 1996 ) 185226    zhou , n.f . :",
    "programming finite - domain constraint propagators in action rules .",
    ". log . program .",
    "* 6*(5 ) ( september 2006 ) 483507    triska , m. : the finite domain constraint solver of swi - prolog . in schrijvers ,",
    "t. , thiemann , p. , eds . : functional and logic programming .",
    "volume 7294 of lecture notes in computer science .",
    "springer berlin / heidelberg ( 2012 ) 307316    morales , j.f . , hermenegildo , m.v . ,",
    "haemmerl , r. : odular extensions for modular ( logic ) languages . in : 21th international symposium on logic - based program synthesis and transformation ( lopstr11 ) , odense , denmark ( july 2011 ) to appear .",
    "daz , d. , codognet , p. : inimal extension of the wam for clp(fd ) . in : proceedings of the tenth international conference on logic programming , budapest , mit press ( june 1993 ) 774790    cabeza , d. , hermenegildo , m. : ew module system for prolog . in : international conference on computational logic ,",
    "number 1861 in lnai , springer - verlag ( july 2000 ) 131148    hermenegildo , m. , puebla , g. , bueno , f. , lpez - garca , p. : ntegrated program debugging , verification , and optimization using abstract interpretation ( and the ciao system preprocessor ) .",
    "science of computer programming * 58*(12 ) ( 2005 ) 115140    tarau , p. : inprolog 2006 version 11.x professional edition user guide .",
    "binnet corporation .",
    "( 2006 ) available from ` http://www.binnetcorp.com/ ` .",
    "schrijvers , t. , triska , m. , demoen , b. : or : extensible search with hookable disjunction . draft .",
    "available from http://users.ugent.be/~tschrijv/tor/ ( 2012 )    morales , j.f .",
    ", haemmerl , r. , carro , m. , hermenegildo , m.v .",
    ": ightweight compilation of ( c)lp to javascript . theory and practice of logic programming , 28th intl .",
    "conference on logic programming ( iclp12 ) special issue ( 2012 ) to appear .",
    ".... queens(n , l , lab , const ) : -      length(l , n ) ,      domain(l , 1 , n ) ,      safe(l , const ) ,      labeling(lab , l ) ."
  ],
  "abstract_text": [
    "<S> we present a new free library for constraint logic programming over finite domains , included with the ciao prolog system . the library is entirely written in prolog , leveraging on ciao s module system and code transformation capabilities in order to achieve a highly modular design without compromising performance . </S>",
    "<S> we describe the interface , implementation , and design rationale of each modular component . </S>",
    "<S> the library meets several design goals : a high level of modularity , allowing the individual components to be replaced by different versions ; high - efficiency , being competitive with other @xmath0 implementations ; a glass - box approach , so the user can specify new constraints at different levels ; and a prolog implementation , in order to ease the integration with ciao s code analysis components . </S>",
    "<S> the core is built upon two small libraries which implement integer ranges and closures . </S>",
    "<S> on top of that , a _ finite domain variable _ datatype is defined , taking care of constraint reexecution depending on range changes . </S>",
    "<S> these three libraries form what we call the _ </S>",
    "<S> @xmath0kernel _ of the library . </S>",
    "<S> this @xmath0kernel is used in turn to implement several higher - level finite domain constraints , specified using indexicals . </S>",
    "<S> together with a labeling module this layer forms what we name _ the @xmath0 solver_. a final level integrates the clp(@xmath0)paradigm with our @xmath0solver . </S>",
    "<S> this is achieved using attributed variables and a compiler from the clp(@xmath0)language to the set of constraints provided by the solver . </S>",
    "<S> it should be noted that the user of the library is encouraged to work in any of those levels as seen convenient : from writing a new range module to enriching the set of @xmath0constraints by writing new indexicals . </S>"
  ]
}