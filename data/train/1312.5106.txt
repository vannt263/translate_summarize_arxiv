{
  "article_text": [
    "in a distributed storage system a file is dispersed across @xmath0 nodes in a network such that given any @xmath3 of these nodes one can reconstruct the original file .",
    "we also want to have such a redundancy in our network that if we lose a node then any @xmath4 of the remaining nodes can repair the lost node .",
    "we assume that each node stores the amount @xmath5 of information , _",
    "e.g. _ , @xmath5 symbols over a finite field , and in the repair process each repairing node transmits the amount @xmath6 to the new replacing node ( called a _ newcomer _ ) and hence the total repair bandwidth is @xmath7 .",
    "we also assume that @xmath8 .",
    "the repair process can be either functional or exact . by functional repair",
    "we mean that the nodes may change over time , _",
    "i.e. _ , if a node @xmath9 is lost and in the repair process we get a new node @xmath10 instead , then we may have @xmath11 .",
    "if only functional repair is assumed then the capacity of the system , denoted by @xmath12 , is known .",
    "namely , it was proved in the pioneering work by dimakis _",
    "_ @xcite that @xmath13    if the size of the stored file is fixed to be @xmath14 then the above expression for the capacity defines a trade - off between the node size @xmath5 and the total repair bandwidth @xmath15 .",
    "the two extreme points are called the minimum storage regenerating ( msr ) point and the minimum bandwidth regenerating ( mbr ) point .",
    "the msr point is achieved by first minimizing @xmath5 and then minimizing @xmath15 to obtain @xmath16 by first minimizing @xmath15 and then minimizing @xmath5 leads to the mbr point @xmath17    in this paper we will study codes that have exact repair property .",
    "the concepts of exact regeneration and exact repair were introduced independently in @xcite , @xcite , and @xcite .",
    "exact repair means that the network of nodes does not vary over time , _",
    "i.e. _ , if a node @xmath9 is lost and in the repair process we get a new node @xmath10 , then @xmath18 .",
    "we denote by @xmath19 the capacity of codes with exact repair with @xmath0 nodes each of size @xmath5 , with total repair bandwidth @xmath15 , and for which each set of @xmath1 nodes can recover the stored file and each set of @xmath2 nodes can repair a lost node .",
    "we have by definition that @xmath20      it was proved in @xcite , @xcite , @xcite , and @xcite that the codes with exact repair achieve the msr point and in @xcite that the codes with exact repair achieve the mbr point .",
    "the impossibility of constructing codes with exact repair at essentially all interior points on the storage - bandwidth tradeoff curve was shown in @xcite .",
    "other papers studying exact - regenerating codes in msr point include _ e.g. _ @xcite , @xcite , @xcite , and @xcite .",
    "locally repairable codes that achieve repair bandwidth that falls below the time - sharing trade - off of the msr and mbr points are studied in @xcite .    to the best of author s knowledge , no previous construction of exact - regenerating codes between mbr and msr points",
    "is done except in @xcite .",
    "our construction is very different to that .",
    "we do not use complex combinatorial structures but instead exploit some optimal codes in msr point .",
    "however , we require in our construction that storage symbols can be split into a sufficiently large number of subsymbols .",
    "tian has shown in @xcite that there exists a non - vanishing gap between the optimal bandwidth - storage tradeoff of the functional - repair regenerating codes and that of the exact - repair regenerating codes by characterizing the rate region of the exact - repair regenerating codes in the case @xmath21 .      in section [ construction ]",
    "we give a construction for codes between msr and mbr points with exact repair .",
    "in section [ inequalities ] we derive some inequalities from our construction .",
    "section [ example ] provides an example showing that , in the special case of @xmath22 , our construction is close to optimal when comparing to the known capacity when only functional repair is required . in section [ analysis ]",
    "we show that when the distances of the parameters @xmath0 , @xmath1 , and @xmath2 are fixed but the actual values approach to infinity , the fraction of performance of our codes with exact repair and the known capacity of functional - repair codes approaches to one .    in section [ easyconstructionsection ]",
    "we give another construction with quite similar performance .",
    "the main differences of this construction when compared to the construction of section [ construction ] is its easiness as advantage and relaxation of assumption of symmetric repair as its disadvantage .    in section [ similarconstructions ]",
    "we give yet two other constructions that have some similarities with the construction of section [ construction ] .",
    "however , the performance of these constructions is relatively bad and the main interest of this section is the comparison of these constructions with the construction of section [ construction ] .    to make it easier to compare our constructions we use notions @xmath23 , @xmath24 , @xmath25 , and @xmath26 to denote the performances of constructions of section [ construction ] , section [ easyconstructionsection ] , subsection [ konstruktionodekopioinnilla ] , and subsection [ konstruktiotiedostoilla ] , respectively",
    "it is clear that @xmath27 for @xmath28 .",
    "assume we have a storage system @xmath29 with exact repair for parameters @xmath30 with a node size @xmath5 and the total repair bandwidth @xmath31 .",
    "in this section we propose a construction that gives a new storage system for parameters @xmath32 let @xmath29 consist of nodes @xmath33 , and let the stored file @xmath34 be of maximal size @xmath35 .",
    "let then @xmath36 denote a new system consisting of the original storage system @xmath29 and one extra node @xmath37 storing nothing .",
    "it is clear that @xmath36 is a storage system for parameters @xmath38 and can store the original file @xmath34 .",
    "let @xmath39 be the set of permutations of the set @xmath40 .",
    "assume that @xmath41 is a storage system for @xmath42 corresponding to the permutation @xmath43 such that @xmath41 is exactly the same as @xmath36 except that the order of the nodes is changed corresponding to the permutation @xmath43 , _",
    "i.e. _ , the @xmath44th node in @xmath36 is the @xmath45th node in @xmath41 .",
    "using these @xmath46 new systems as building blocks we construct a new system @xmath47 such that its @xmath48th node for @xmath49 stores the @xmath48th node from each system @xmath50 for @xmath51 .",
    "it is clear that this new system @xmath47 works for parameters @xmath52 , has exact repair property , and stores a file of size @xmath53 . by noticing that there are @xmath54 such permutated copies @xmath41 , where the @xmath44th node is empty",
    ", we get that the node size of the new system @xmath47 is @xmath55 similarly , since an empty node does not need any repair we also find that the total repair bandwidth of the new system is @xmath56    by _ symmetric repair _ we mean that in the repair process of a lost node , each helper node transmits the same amount @xmath6 of information .",
    "let us fix some repairing scheme for subsystems .",
    "namely , define @xmath57 to be the amount of information when the @xmath44th node repairs the @xmath48th node and the other helper nodes have indices from the set @xmath58 .",
    "now @xmath59 and hence @xmath60\\setminus\\{j\\ } \\\\",
    "|s|=d+1 } } \\sum_{i \\in s } \\beta_{ijs } \\cdot ( n - d-1)!d ! \\\\ &   = \\sum_{j=1}^{n } \\sum_{\\substack { s \\subseteq [ n+1]\\setminus\\{j\\ } \\\\",
    "|s|=d+1 } } \\gamma \\cdot ( n - d-1)!d ! \\\\ &   = \\sum_{j=1}^{n } \\binom{n}{d+1 } \\gamma \\cdot ( n - d-1)!d ! \\\\ &   = n \\cdot n !",
    "\\cdot \\frac{d}{d+1 } \\beta .",
    "\\end{split}\\ ] ] this proves that our construction has symmetric repair property .",
    "the distributed storage system @xmath29 that we used as a starting point in our construction is not yet explicitly fixed .",
    "we have just fixed that the used storage system is some optimal system . to make it easier to follow our construction we use the notation @xmath61 to denote the performance of our incomplete construction .",
    "the above reasoning implies the equality @xmath62 dividing both sides by @xmath63 gives @xmath64    [ helppoesim ] if we relax on the requirement of a dss to have symmetric repair then the construction becomes a bit simpler .",
    "now , require instead only that the total repair bandwidth @xmath15 is constant _",
    "@xmath6 may take different values depending on the node .",
    "let @xmath65 and @xmath29 be a distributed storage system with exact repair .",
    "let @xmath41 be a storage system with @xmath66 nodes for @xmath67 where the @xmath48th node stores nothing , the @xmath44th node for @xmath68 stores as the @xmath44th node in the original system @xmath29 , and the @xmath44th node for @xmath69 stores as the @xmath70th node in the original system @xmath29 .",
    "that is , in the @xmath48th subsystem @xmath41 the @xmath48th node stores nothing while the other nodes are as those in the original system @xmath29 .    using these four new systems as building blocks we construct a new system @xmath47 for parameters @xmath71 such that its @xmath48th node for @xmath67 stores the @xmath48th node from each system @xmath50 for @xmath72",
    "hence each node in @xmath47 stores @xmath73 and the total repair bandwidth is @xmath74 .    for example , if the original system @xmath29 consists of nodes @xmath75 storing @xmath76 , @xmath77 storing @xmath78 , and @xmath79 storing @xmath80 then @xmath81 consists of nodes @xmath82 storing nothing , @xmath83 storing @xmath84 , @xmath85 storing @xmath86 , and @xmath87 storing @xmath88 .",
    "similarly @xmath89 consists of nodes @xmath90 storing @xmath91 , @xmath92 storing nothing , @xmath93 storing @xmath94 , and @xmath95 storing @xmath96 and so on .",
    "then in the resulting system the first node @xmath97 consists of nodes @xmath82 ( storing nothing ) , @xmath90 ( storing @xmath91 ) , @xmath98 ( storing @xmath99 ) , and @xmath100 ( storing @xmath101 ) .",
    "the stored file is @xmath102 .    .",
    "it consists of nodes @xmath97 , @xmath103 , @xmath104 , and @xmath105.,width=340 ]",
    "next we will derive some inequalities for the capacity in the case of exact repair . using equation [ firstbound ]",
    "inductively we get    [ bound ] for an integer @xmath106 $ ] we have @xmath107    it is proved in @xcite , @xcite , @xcite , and @xcite that the msr point can be achieved if exact repair is assumed . as a consequence of this and theorem [ firstbound ] we get the following bound .    [ boundmsr ] for integers",
    "@xmath108 we have @xmath109    write @xmath110 , @xmath111 , and @xmath112 .",
    "it is proved for the msr point in @xcite , @xcite , @xcite , and @xcite that @xmath113 _ i.e. _ , @xmath114    hence by theorem [ bound ] we have @xmath115    now a change of variables by setting @xmath116 gives us the result .",
    "our construction is now ready since we have decided to use msr optimal codes as a starting point for our construction .",
    "so let us use the notion @xmath117 for integers @xmath118 , to note the performance of our construction .",
    "tian characterized the rate region of the exact - repair regenerating codes in the case @xmath21 in @xcite . in this example",
    "we will compare our construction to this .",
    "in @xcite the stored file is assumed to be of size @xmath119 and then the rate - region of exact - regenerating codes is characterized by following pairs of @xmath120 : @xmath121 , @xmath122 , and @xmath123 .",
    "these correspond to following pairs of @xmath124 : @xmath125 , @xmath126 , and @xmath127 , _",
    "i.e. _ , @xmath128 , @xmath129 , and @xmath130",
    ".    theorem [ boundmsr ] gives in this same special case @xmath131 for integers @xmath132 .",
    "hence @xmath133 , @xmath134 , and @xmath135 . by substituting into these @xmath136 , respectively ,",
    "we get exactly the same performances as in @xcite .",
    "in this section we study the special case @xmath22 and compare the resulting capacity with exact repair to the known capacity with the assumption of functional repair , @xmath137    our construction gives codes with performance @xmath138 for integers @xmath118 .    notice that now in the extreme points our performance @xmath139 achieves the known capacity , _",
    "i.e. _ , @xmath140 for the mbr point and @xmath141 for the msr point .",
    "as an example we study the fraction @xmath142 for integers @xmath143 $ ] .",
    "writing it out we see that @xmath144 where @xmath145 .    for large values of @xmath0",
    "this is approximately @xmath146 for all @xmath118 .",
    "notice that if we had chosen @xmath147 instead of @xmath22 , then we would have ended up with @xmath148 similarly , if we had chosen @xmath149 then we would have ended up with @xmath150 these both are also close to 1 when @xmath44 is not too small . for this reason we will study the asymptotic behavior of the capacity curve more carefully in the next section .    [ ht ]    [ cols=\"^,^,^ \" , ]      + the figure shows the performance @xmath151 of codes from the construction of subsection [ konstruktionodekopioinnilla ] ( dotted curve ) between the capacity of functionally repairing codes ( uppermost curve ) and the trivial lower bound given by interpolation of the known msr and mbr points with different @xmath152 . [",
    "tab : nodecopyperformances ]      assume we have a storage system @xmath29 with exact repair for parameters @xmath152 with the node size @xmath5 and the total repair bandwidth @xmath31 . in this section",
    "we propose a construction that gives a new storage system for parameters @xmath153 let @xmath29 consist of the nodes @xmath33 , and let the stored file @xmath34 be of maximal size @xmath35 .",
    "let then @xmath36 denote a new system consisting of the original storage system @xmath29 and one extra node @xmath37 storing the whole file @xmath34 .",
    "it is clear that @xmath36 is a storage system for parameters @xmath154 and can store the original file @xmath34 .",
    "again we use permutations just similarly as in the construction of section [ construction ] : let @xmath39 be the set of permutations of the set @xmath40 .",
    "assume that @xmath41 is a storage system for @xmath42 corresponding to the permutation @xmath43 such that @xmath41 is exactly the same as @xmath36 except that the order of the nodes is changed corresponding to the permutation @xmath43 , _",
    "i.e. _ , the @xmath44th node in @xmath36 is the @xmath45th node in @xmath41 .    using these @xmath46 new systems as building blocks",
    "we construct a new system @xmath47 such that its @xmath48th node for @xmath49 stores the @xmath48th node from each system @xmath50 for @xmath51 .",
    "it is clear that this new system @xmath47 works for parameters @xmath155 , has exact repair property , and stores a file of size @xmath53 . by noticing that there are @xmath54 such permutated copies @xmath41 where the @xmath44th node is storing the whole file we get that the node size of the new system @xmath47 is @xmath156 since to repair a node storing the whole file can be done by bandwidth of size @xmath157 and repairing a node",
    "when the whole file is one of the helper nodes requires bandwidth @xmath5 , we find that the total repair bandwidth of the new system is @xmath158    hence the performance of this incomplete construction is @xmath159 that is @xmath160    substituting msr point into above gives a code with performance @xmath161 _ i.e. _ @xmath162 however , this construction is useless because it is easy to verify that this performance is strictly worse than the trivial lower bound by timesharing when @xmath163 and it lies on the timesharing line when @xmath164 .      despite the clear similarities of the construction techniques , there is a huge difference on the performances @xmath23 , @xmath25 , and @xmath26 of codes constructed using these different approaches .    in the cases where the performance @xmath23 of the construction of section [ construction ] is very poor",
    ", the construction of section [ konstruktiotiedostoilla ] performs better .",
    "however , the performance @xmath26 of the construction of section [ konstruktiotiedostoilla ] is still worse than the one achieved by timesharing of msr and mbr points .    comparing to the trivial lower",
    "bound given by timesharing mbr and msr points one can summarize that the construction of subsection [ konstruktiotiedostoilla ] is useless , the construction of subsection [ konstruktionodekopioinnilla ] is in certain cases quite good , and the construction of section [ construction ] is in certain cases very good .",
    "we have constructed exact - regenerating codes between mbr and msr points . to the best of author",
    "s knowledge , no previous construction of exact - regenerating codes between mbr and msr points is done except in @xcite .",
    "compared to that construction , our construction is very different .",
    "we have shown in this paper that when @xmath0 , @xmath1 , and @xmath2 are close to each other , the capacity of a distributed storage system when exact repair is assumed is essentially the same as when only functional repair is required .",
    "this was proved by using a specific code construction exploiting some already known codes achieving the msr point on the trade - off curve and by studying the asymptotic behavior of the capacity curve .",
    "a very easy alternative construction for the main construction of this paper was presented .",
    "its performance is almost as good as the performance of the main construction and it is simple to build up .",
    "the drawback of this construction was that it has no symmetric repair .",
    "also we have constructed two constructions in a similar manner as the main construction .",
    "these were to be compared to the main construction . despite the clear similarities of these three constructions their performances vary hugely .",
    "however , when @xmath0 , @xmath1 , and @xmath2 are not close to each other then the performance of our main construction is not good when compared to the capacity of functionally repairing codes .",
    "however , there is no evidence that the capacity of a distributed storage system when exact repair is assumed is generally close to the capacity of functionally repairing codes .",
    "so as a future work it is still left to find the precise expression of the capacity of a distributed storage system when exact repair is assumed , and especially to study the behavior of the capacity when @xmath0 , @xmath1 , and @xmath2 are not close to each other .",
    "this research was partly supported by the academy of finland ( grant # 131745 ) and by the emil aaltonen foundation , finland , through grants to camilla hollanti .",
    "salim el rouayheb at the illinois institute of technology is gratefully acknowledged for useful discussions .",
    "camilla hollanti at the aalto university is gratefully acknowledged for useful comments on the first draft of this paper .",
    "let @xmath165 .",
    "we study the behavior of the fraction for large @xmath166 , so we have @xmath167 . thus , to simplify the notation",
    ", we may assume that @xmath44 acts as an integer .",
    "we also use the notation @xmath168                a. g. dimakis , p. b. godfrey , y. wu , m. j. wainwright , and k. ramchandran , `` network coding for distributed storage systems , '' ieee transactions on information theory , vol .",
    "9 , pp . 4539 - 4551 , september 2010 .",
    "y. wu and a. g. dimakis , `` reducing repair traffic for erasure coding - based storage via interference alignment , '' in _ proc .",
    "ieee international symposium on information theory ( isit ) _ , seoul ,",
    "july 2009 , pp .",
    "2276 - 2280 .",
    "d. cullina , a. g. dimakis , and t. ho , `` searching for minimum storage regenerating codes , '' in _ proc .",
    "47th annual allerton conference on communication , control , and computing _ , urbana - champaign , september 2009 .",
    "k. v. rashmi , nihar b. shah , and p. vijay kumar , `` optimal exact - regenerating codes for distributed storage at the msr and mbr points via a product - matrix construction , '' _ ieee transactions on information theory _ , vol .",
    "57 , no . 8 , pp . 5227 - 5239 , august 2011 .",
    "nihar b. shah , k. v. rashmi , p. vijay kumar , and k. ramchandran , `` distributed storage codes with repair - by - transfer and nonachievability of interior points on the storage - bandwidth tradeoff , '' _ ieee transactions on information theory _ ,",
    "1837 - 1852 , march 2012 .",
    "v. r. cadambe , s. a. jafar , and h. maleki , `` distributed data storage with minimum storage regenerating codes - exact and functional repair are asymptotically equally efficient , '' available : arxiv:1004.4299v1 [ cs.it ]      v. r. cadambe , s. a. jafar , h. maleki , k. ramchandran and c. suh : `` asymptotic interference alignment for optimal repair of mds codes in distributed data storage , '' available : http://www.mit.edu/~viveck/resources/research/asymptotic_storage.pdf    v. r. cadambe , c. huang , j. li , `` permutation code : optimal exact - repair of a single failed node in mds code based distributed storage systems , '' in _ proc .",
    "ieee international symposium on information theory ( isit ) _ , saint petersburg , august 2011 , pp .",
    "1225 - 1229 .              c. tian , v. aggarwal , v. a. vaishampayan , `` exact - repair regenerating codes via layered erasure correction and block designs , '' in _ proc .",
    "ieee international symposium on information theory ( isit ) _ , istanbul ,",
    "july 2013 , pp .",
    "1431 - 1435 ."
  ],
  "abstract_text": [
    "<S> in this paper distributed storage systems with exact repair are studied . </S>",
    "<S> a construction for regenerating codes between the minimum storage regenerating ( msr ) and the minimum bandwidth regenerating ( mbr ) points is given . </S>",
    "<S> to the best of author s knowledge , no previous construction of exact - regenerating codes between mbr and msr points is done except in the work by tian et al . </S>",
    "<S> on contrast to their work , the methods used here are elementary .    </S>",
    "<S> in this paper it is shown that in the case that the parameters @xmath0 , @xmath1 , and @xmath2 are close to each other , the given construction is close to optimal when comparing to the known functional repair capacity . </S>",
    "<S> this is done by showing that when the distances of the parameters @xmath0 , @xmath1 , and @xmath2 are fixed but the actual values approach to infinity , the fraction of the performance of constructed codes with exact repair and the known capacity of codes with functional repair , approaches to one . </S>",
    "<S> also a simple variation of the constructed codes with almost the same performance is given .    </S>",
    "<S> [ section ] [ section ] [ thm]proposition [ thm]lemma [ thm]corollary [ section ] [ section ] </S>"
  ]
}