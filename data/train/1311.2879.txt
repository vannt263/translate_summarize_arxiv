{
  "article_text": [
    "the common due - date ( cdd ) scheduling problem involves sequencing and scheduling of jobs over machine(s ) against a common due - date .",
    "each job possesses a processing time and different penalties per unit time in case the job is completed before or later than the due - date .",
    "the objective of the problem is usually to schedule the jobs so as to get the least total penalty due to earliness or tardiness of all the jobs . in practice",
    ", a common due date occurs in almost any manufacturing industry and its goal is to reduce both , the earliness and tardiness of the goods produced .",
    "earliness of the produced goods is not desired because it requires the maintenance of some stocks leading to some expenses to the industry for storage cost , tied - up capital with no cash flow etc . on the other hand ,",
    "a tardy job leads to customer dissatisfaction .",
    "when scheduling on a single machine against a common due date , one job at most can be completed exactly at the due date .",
    "hence , some of the jobs might get completed earlier than the common due - date ( @xmath7 ) , while other jobs finish late .",
    "generally speaking , there are two classes of common due - date problems which have proven to be np - hard , namely the restrictive and non - restrictive cdd problem . in this work",
    "we consider the restrictive case of the problem where the common due date is less than the sum of the processing times of all the jobs and each job possess different earliness / tardiness penalties .",
    "this problem has proven to be the most difficult problem in this area of research  @xcite .",
    "common due - date problems have been studied extensively during the last @xmath8 years with several variants and special cases  @xcite . in @xmath9",
    ", kanet presented an o(@xmath10 ) algorithm for minimizing the total absolute deviation of the completion of jobs from the due date for the single machine  @xcite .",
    "panwalkar  _ et al .",
    "_ considered the problem of common due - date assignment to minimize the total penalty for one machine  @xcite .",
    "the objective of the problem was to determine the optimum value for the due - date and the optimal job sequence to minimize the penalty function , where the penalty function also depends on the due - date along with earliness and tardiness .",
    "an algorithm of o(@xmath11 ) complexity was presented but the problem considered by them consisted of symmetric costs for all the jobs  @xcite .",
    "cheng again considered the same problem with slight variations and presented a linear programming formulation  @xcite . in @xmath12 cheng",
    "_ et al . _ made a very good study on the common due date problem and presented some useful properties for the general case  @xcite .",
    "a pseudo - polynomial algorithm of o(@xmath13 ) complexity was presented by hoogeveen  _ et al .",
    "_ for the restrictive case with one machine when the earliness and tardiness penalty weights are symmetric for all the jobs  @xcite . in @xmath12 hall",
    "studied the un - weighted earliness and tardiness problem and presented a dynamic programming algorithm  @xcite . besides these earlier works , there have been some research on heuristic algorithms for the general common due date problem with asymmetric penalty costs .",
    "james presented a tabu search algorithm for the general case of the problem in @xmath14  @xcite .",
    "more recently feldmann  _ et al .",
    "_ approached the problem using metaheuristic algorithms namely simulated annealing ( sa ) and threshold accepting and presented the results for benchmark instances up to @xmath15 jobs on a single machine  @xcite .",
    "another variant of the problem was studied by toksari  _ et al . _ where they considered the common due date problem on parallel machines under the effects of time dependence and deterioration  @xcite .",
    "ronconi  _ et al .",
    "_ proposed a branch and bound algorithm for the general case of the cdd and gave optimal results for small benchmark instances  @xcite .",
    "rebai  _ et al .",
    "_ proposed metaheuristic and exact approaches for the common due date problem to schedule preventive maintenance tasks  @xcite .    in this paper",
    "we consider both single and parallel machine cases for the cdd problem with asymmetric penalties .",
    "we present polynomial exact algorithms to optimize a given job sequence on single and parallel machines .",
    "we present our results and compare the single machine results with the results provided in the or - library  @xcite .",
    "besides , we also present new results for the benchmark instances for parallel machines up to @xmath6 jobs with @xmath16 and the restrictive factor ( @xmath17 ) of @xmath18 and @xmath19 , provided by biskup  _ et al . _ in  @xcite .",
    "in this section we give the mathematical notation of the common due date problem based on  @xcite .",
    "we also define some new parameters which are later used in the presented algorithm in the next section .",
    "let , + @xmath2 = total number of jobs + @xmath3 = total number of machines + @xmath20 = number of jobs processed by machine @xmath21",
    "@xmath22 + @xmath23 = time at which machine @xmath21 finished its previous job + @xmath24 = @xmath25 job processed by machine @xmath21 + @xmath26 = processing time of job @xmath27 @xmath28 + @xmath29 = completion time of job @xmath27 @xmath28 + @xmath30 = the common due date + @xmath31 = the penalty cost per unit time for job @xmath27 for being early + @xmath32 = the penalty cost per unit time for job @xmath27 for being tardy + @xmath33 = earliness of job @xmath27 , @xmath34 ( @xmath35 ) + @xmath36 = tardiness of job @xmath27 , @xmath37 ( @xmath35 ) .",
    "the cost corresponding to job @xmath27 is then expressed as @xmath38 .",
    "if job @xmath27 is completed at the due date then both @xmath33 and @xmath36 are equal to zero and the cost assigned to it is zero .",
    "when job @xmath27 does not complete at the due date , either @xmath33 or @xmath36 is non - zero and there is a strictly positive cost incurred .",
    "the objective function of the problem can now be defined as @xmath39",
    "let @xmath40 be the input job sequence where @xmath41 is the @xmath27th job in the sequence @xmath40 .",
    "note that without loss of any generality we can assume @xmath42 , since we can rank the jobs for any sequence as per their order of processing .",
    "the algorithm takes the job sequence @xmath40 as the input and returns the optimal value for equation  .",
    "there are three requirements for the optimal solution : allotment of jobs to specific machines , the order of processing of jobs in every machine and the completion times for all the jobs",
    ".     jobs .",
    "each reduction is done by the minimum of the processing time of the job which is starting at the due date and the maximum possible left shift for the first job.,width=377,height=113 ]    cheng  _ et al . _",
    "@xcite proved some properties of the optimal solution for the restrictive common due date case , one among which is that the optimal solution for the restrictive common due date case with general penalties exists with no idle times between consecutive jobs .",
    "this property implies that all the jobs in any sequence are processed right after another . using this property",
    ", our algorithm assigns the completion times to all the jobs such that the first job is finished at @xmath43 and the rest of the jobs follow without any idle time in order to obtain an initial solution which is then improved incrementally .",
    "it is quite apparent that a better solution for this sequence can be found only by reducing the completion times of all the jobs , _",
    "i.e.  _ shifting all the jobs towards decreasing total tardiness penalty as shown in figure  [ fig1 ] with @xmath44 jobs . shifting all the jobs to the right will only increase the total tardiness .",
    "hence , we assign the jobs in @xmath40 to machines such that they incur least weighted tardiness initially and assign the initial completion times to the jobs in each machine as stated in equation  .",
    "we define @xmath45 as the machine which has the least value for @xmath23 , @xmath46 , i.e. @xmath47    @xmath48 @xmath49 @xmath50 @xmath49 @xmath51    algorithm  [ alotmac ] assigns the first @xmath3 jobs to each machine respectively such that they all finish processing at the due date or after their processing time , which ever is higher . for the remaining jobs ,",
    "we assign a machine @xmath45 to job @xmath27 since it offers the least possible tardiness .",
    "likewise each job is assigned at a specific machine such that the tardiness for all the jobs is the least for the given job sequence .",
    "the job sequence is maintained in the sense that for any two jobs @xmath27 and @xmath21 such that job @xmath21 follows @xmath27 ; the algorithm  [ alotmac ] will either maintain this sequence or assign the same starting times at different machines to both the jobs .",
    "finally , algorithm  [ alotmac ] will give us the number of jobs @xmath52 to be processed by any machine @xmath21 and the sequence of jobs in each machine , @xmath24 .",
    "this is the best assignment of jobs at machines for the given sequence .",
    "note that the sequence of jobs is still maintained here , since algorithm  [ alotmac ] ensures that any job @xmath27 is not processed after a job @xmath53 .",
    "once we have the jobs assigned to particular machines , the problem then converts to @xmath3 single machine problems , since all the machines are independent .",
    "we now present the ideas and the algorithm for solving the single machine case for a given job sequence . from here on we assume that there are @xmath2 jobs to be processed by a machine and all the parameters stated at the beginning of section  [ probform ] represent the same meaning .",
    "[ lemma ] if the initial assignment of the completion times of the jobs , for a given sequence @xmath40 is done according to @xmath29 where , @xmath54 then the optimal solution for this sequence can be obtained only by reducing the completion times of all the jobs or leaving them unchanged .",
    "we prove the above lemma by considering two cases of equation  .",
    "* case 1 : * @xmath55 + in this case equation   will ensure that the first job is completed at the due - date and the following jobs are processed consecutively without any idle time .",
    "moreover , with this assignment all the jobs will be tardy except for the first job which will be completed at the due date .",
    "the total penalty ( say , @xmath56 ) will be @xmath57 , where @xmath58 , @xmath59 .",
    "now if we increase the completion time of the first job by @xmath60 units then the new completion times @xmath61 for the jobs will be @xmath62 @xmath63 @xmath64 and the new total penalty @xmath65 will be @xmath66 , where @xmath67 @xmath68 . clearly , we have @xmath69 which proves that an increase in the completion times can not fetch optimality which in turn proves that optimality can be achieved only by reducing the completion times or leaving them unchanged from equation  .",
    "* case 2 : * @xmath70 + if the processing time of the first job in any given sequence is more than the due - date then all the jobs will be tardy including the first job as @xmath71 .",
    "since all the jobs are already tardy , a right shift ( _ i.e .",
    "_ increasing the completion times ) of the jobs will only increase the total penalty hence worsening the solution .",
    "moreover , a left shift ( _ i.e .  _ reducing the completion times ) of the jobs is not possible either , because @xmath72 , which means that the first job will start at time @xmath73 .",
    "hence , in such a case equation   is the optimal solution . in the rest of the paper",
    "we avoid this simple case and assume that for any given sequence the processing time of the first job is less than the due - date .    before stating the algorithm we first introduce some new parameters , definitions and theorems which are useful for the description of the algorithm .",
    "we first define @xmath74 , @xmath59 and @xmath75 .",
    "it is clear that @xmath76 is the algebraic deviation of the completion time of job @xmath27 from the due date and @xmath77 is the maximum possible shift ( reduction of completion time ) for the first job .",
    "[ lemma2 ] once @xmath78 for each job in a sequence is assigned according to lemma  [ lemma ] , a reduction of the completion times is possible only if @xmath79 .",
    "lemma  [ lemma ] proves that only a reduction of the completion times can improve the solution once the initialization is made as per equation  . besides there is no idle time between any jobs",
    ", hence an improvement can be achieved only if @xmath79 , in which case all the jobs will be shifted left by equal amount .",
    "[ pl ] @xmath80 is a vector of length @xmath2 and any element of @xmath80 ( @xmath81 ) is the penalty possessed by job @xmath27 .",
    "we define @xmath80 , as @xmath82    with the above definition we can now express the objective function stated by equation   as @xmath83 , where @xmath84 : @xmath85    * initialize * @xmath29 @xmath63 @xmath27 ( equation  [ initial ] ) * compute * @xmath86 @xmath87 @xmath88 @xmath84 [ return ]    for the parallel machine case we just need to first assign all the jobs to machines using algorithm  [ alotmac ] and then implement algorithm  [ main ] for each machine @xmath21 with @xmath89 jobs to optimize the jobs sequence in every machine , as stated in algorithm  [ parallel ] .",
    "* algorithm  [ alotmac ] *",
    "[ theorem ] algorithm  [ main ] finds the optimal solution for a single machine common due date problem , for a given job sequence .",
    "the initialization of the completion times for a sequence @xmath90 is done according to lemma  [ lemma ] .",
    "it is evident from equation   that the deviation from the due date ( @xmath76 ) is zero for the first job and greater than zero for all the following jobs . besides , @xmath91 for @xmath92 , since @xmath93 from equation   and @xmath76",
    "is defined as @xmath94 . by lemma  [ lemma ] the optimal solution for this sequence can be achieved only by reducing the completion times of all the jobs simultaneously or leaving the completion times unchanged .",
    "the total penalty after the initialization is @xmath95 since none of the jobs are completed before the due date . according to algorithm  [ main ] the completion times of all the jobs",
    "is reduced by @xmath96 at any iteration . since @xmath97 , there will be no loss or gain for @xmath98 .",
    "after any iteration of the @xmath99 loop in line @xmath44 , we decrease the total weighted tardiness but gain some weighted earliness penalty for some jobs .",
    "a reduction of the completion times by @xmath96 is the best non - greedy reduction .",
    "let @xmath100 and @xmath101 be a number between @xmath73 and @xmath96 . then reducing the completion times by @xmath101 will increase the number of early jobs by one and reduce the number of tardy jobs by one . with this operation ; if there is an improvement to the overall solution then a reduction by @xmath96 will fetch a much better solution ( @xmath102 ) because reducing the completion times by @xmath101 will lead to a situation where none of the jobs either start at time @xmath73 ( because @xmath79 ) nor any of the jobs finish at the due date since the jobs @xmath103 are early , jobs @xmath104 are tardy and the new completion time of job @xmath21 is @xmath105 .",
    "since after this reduction @xmath106 and @xmath107 for @xmath108 , none of the jobs will finish at the due date after a reduction by @xmath101 units .",
    "moreover , it was proved by cheng _",
    "_  @xcite that in an optimal schedule for the restrictive common due date , either one of the jobs should start at time @xmath73 or one of the jobs should end at the due date .",
    "this case can occur only if we reduce the completion times by @xmath96 . if @xmath109 the first job will start at time @xmath73 and if @xmath110 then one of the jobs will end at the due date . in the next iterations",
    "we continue the reductions as long as we get an improvement in the solution and once the new solution is not better than the previous best then we do not need to check any further and we have our optimal solution .",
    "this can be proved by considering the values of the objective function at two iterations indices ; @xmath21 and @xmath111 .",
    "let @xmath102 and @xmath112 be the value of the objective function at these two indexes then we can prove that the solution can not be improved any further if @xmath113 by lemma  [ lemma3 ] .",
    "[ lemma3 ] once the value of the solution at any iteration @xmath21 is less than the value at iteration @xmath111 , then the solution can not be improved any further .",
    "if @xmath113 then it means that further left shift of the jobs does not fetch a better solution .",
    "note that the objective function has two parts , penalty due to earliness and penalty due to tardiness .",
    "let us consider the earliness and tardiness of the jobs after the @xmath114 iterations are @xmath115 and @xmath116 for @xmath59 .",
    "then we have @xmath117 and @xmath118 . besides , after every iteration of the @xmath99 loop in algorithm  [ main ] , the completion times are reduced or in other words the jobs are shifted left .",
    "this leads to an increase in the earliness and a decrease in the tardiness of the jobs .",
    "let s say , the difference in the reduction between @xmath119 and @xmath120 is @xmath60 .",
    "then we have @xmath121 and @xmath122 .",
    "since @xmath123 , we have : @xmath124 . by substituting the values of @xmath125 and @xmath126",
    "we get , @xmath127 .",
    "hence , at the @xmath128 iteration the total penalty due to earliness exceeds the total penalty due to tardiness .",
    "this proves that for any further reduction there can not be an improvement in the solution because a decrease in the tardiness penalty will always be less than the increase in the earliness penalty .",
    ", for a job sequence . the value of the solution does not improve any further after a certain number of reductions.,width=415,height=321 ]",
    "in this section we study and prove the run - time complexity of the algorithms  [ alotmac ] ,  [ main ] and  [ parallel ] .",
    "we calculate the complexities of all the algorithms separately considering the worst cases for all .",
    "let @xmath129 be the run - time complexities of each algorithm respectively .",
    "the run - time complexity of algorithm  [ parallel ] is @xmath130 where @xmath2 and @xmath3 are the total number of jobs and machines , respectively .    to prove this we first consider the complexity of algorithm  [ alotmac ]",
    ". the most crucial step as per the run - time in algorithm  [ alotmac ] is the calculation of @xmath45 , which is of @xmath131 order .",
    "the rest of the steps are of order @xmath132 .",
    "hence , the overall complexity of algorithm  [ alotmac ] is @xmath133 , where @xmath131 corresponds to the first _ for _ loop and @xmath134 corresponds to the second _ for _ loop involving the calculation for @xmath45 .",
    "since the number of machines is usually much less than the number of jobs , we have @xmath135 .    as for algorithm  [ main ] ,",
    "the calculations involved in the initialization step and evaluation of @xmath136 are all of @xmath137 complexity and their evaluation is irrespective of the any conditions unlike inside the @xmath99 loop .",
    "the @xmath99 loop again evaluates and updates these parameters at every step of its iteration and returns the output once their is no improvement possible .",
    "the worst case will occur when the @xmath99 loop is iterated over all the values of @xmath21 , @xmath138 .",
    "hence the complexity of algorithm  [ main ] is @xmath139 with @xmath2 being the number of jobs processed by the machine .",
    "hence , @xmath140 .    to calculate the complexity of algorithm  [ parallel ] , we need to consider all the cases of the number of jobs processed by each machine .",
    "let @xmath141 be the number of jobs processed by the machines , respectively . then , @xmath142 .",
    "we make a reasonable assumption that the number of machines is less than the number of jobs , which is usually the case . in such a case",
    "the complexity of algorithm  [ parallel ] ( @xmath143 ) is equal to @xmath144 . since @xmath145",
    ", we have @xmath146 .",
    "thus the complexity of algorithm  [ parallel ] is @xmath130 .",
    "algorithm  [ main ] shifts the jobs to the left by reducing the completion times of all the jobs by @xmath96 on every iteration of the @xmath99 loop . the runtime complexity of the algorithm can be improved form @xmath139 to @xmath147 by implementing an exponential search instead of a step by step reduction , as in algorithm  [ main ] . to explain this we first need to understand the slope of the objective function values for each iteration . in the proof of optimality of algorithm  [ main ]",
    ", we proved that there is only one minimum present in @xmath120 @xmath148 .",
    "besides , the value of @xmath149 increases for every @xmath21 as it depends on the completion times . also note that the reduction in the completion times is made by @xmath96 . hence , if for any @xmath21 , @xmath150 then every iteration after @xmath21 will fetch the same objective function value , @xmath120 .",
    "hence , the solution values after each iteration will have trend as shown in figure  [ trend ] .    with such a slope of the solution we can use the exponential search as opposed to a step by step search , which will in turn improve the run - time complexity of algorithm  [ main ] .",
    "this can be achieved by increasing or decreasing the step size of the @xmath99 loop by orders of @xmath151 ( _ i.e .  _",
    "@xmath152 ) while keeping track of the slope of the solution .",
    "the index of the next iteration should be increased if the slope is negative and decreased if the slope is non - negative . at each step",
    "we need to keep track of the previous two indices and once the difference between the indices is less than the minimum of the two , then we need to perform binary search on the same lines .",
    "the optimum will be reached if both the adjacent solutions are greater than the current value . in this methodology",
    "we do not need to search for all values of @xmath21 but in steps of @xmath153 .",
    "hence the run - time complexity with exponential search will be @xmath147 for the single machine and @xmath1 for the parallel machine case .",
    "in this section we present our results for the single and parallel machine cases .",
    "we used our exact algorithms with simulated annealing for finding the best job sequence .",
    "all the algorithms were implemented on matlab and run on a machine with a @xmath154 ghz processor and @xmath151 gb ram .",
    "we first present our results for the benchmark instances provided by biskup  _ et al .",
    "_ in  @xcite and compare our results with the results provided in the or - library  @xcite , for the single machine case .",
    "we use a modified simulated annealing algorithm to generate job sequences and algorithm  [ main ] to optimize each sequence to its minimum penalty . the ensemble size for sa",
    "is taken to be @xmath155 for all the instances .",
    "the initial temperature is kept as twice the standard deviation of the energy at infinite temperature : @xmath156 .",
    "we estimate this quantity by randomly sampling the configuration space  @xcite . an exponential schedule for cooling",
    "is adopted with a cooling rate of @xmath157 .",
    "one of the modifications from the standard sa is in the acceptance criterion .",
    "we implement two acceptance criteria : the metropolis acceptance probability , @xmath158  @xcite and a constant acceptance probability of @xmath159 .",
    "a solution is accepted with this constant probability if it is rejected by the metropolis criterion .",
    "this concept of a constant probability is useful when the sa is run for many iterations and the metropolis acceptance probability is almost zero , since the temperature would become infinitesimally small . apart from this ,",
    "we also incorporate elitism in our modified sa .",
    "elitism has been successfully adopted in evolutionary algorithms for several complex optimization problems  @xcite .",
    "we observed that this concept works well for the cdd problem .",
    "as for the perturbation rule , we first randomly select a certain number of jobs in any job sequence and permute them randomly to create a new sequence .",
    "the number of jobs selected for this permutation is taken as @xmath160 , where @xmath2 is the number of jobs . for large instances the size of this permutation is quite small but we have observed that it works well with our modified simulated annealing algorithm .    in table",
    "[ result ] and  [ result1 ] we present our results ( apsa ) for the single machine case and compare them with the benchmark results ( br ) provided in the or - library  @xcite .",
    "the first @xmath161 instances with @xmath162 jobs each have been already solved optimally by biskup  _ et al . _ and we reach the optimality for all these instances within an average run - time of @xmath163 seconds . among the next @xmath164 instances we achieve equal results for @xmath165 instances , better results for @xmath166 instances and for the remaining @xmath167 instances with @xmath168 , @xmath169 and @xmath6 jobs , our results are within a gap of @xmath170 percent , @xmath171 percent and @xmath172 percent respectively .",
    "feldmann and biskup  @xcite solved these instances using three metaheuristic approaches , namely : simulated annealing , evolutionary strategies and threshold accepting ; and presented the average run - time for the instances on a pentium/@xmath173 pc . in table",
    "[ runtimes ] we show our average run - times for the instances and compare them with the heuristics approach considered in  @xcite .",
    "apparently our approach is faster and achieves better results .",
    "however , there is a difference in the machines used for the implementation of the algorithms . in table  [ result3 ] we present results for the same problem but with parallel machines for the biskup benchmark instances .",
    "the computation has been carried out for @xmath16 up to @xmath6 jobs and a different number of machines with restrictive factor @xmath17 .",
    "we make a change in the due date as the number of machines increases and assume that the due date @xmath30 is @xmath174 .",
    "this assumption makes sense as an increase in the number of machines means that the jobs can be completed much faster and reducing the due - date will test the whole setup for more competitive scenarios .",
    "we implemented algorithm  [ parallel ] with six different combinations of the number of machines and the restrictive factor .",
    "since these instances have not been solved for the parallel machines , we are presenting the upper bounds achieved for these instances using algorithm  [ parallel ] and the modified simulated annealing .",
    "in this paper we present two novel exact polynomial algorithms for the common due - date problem to optimize any given job sequence .",
    "we prove the optimality for the single machine and the run - time complexity of the algorithms .",
    "we implemented our algorithms over the benchmark instances provided by biskup  _ et al . _",
    "@xcite up to @xmath6 jobs .",
    "the results obtained by using our algorithms are superior to the benchmark results in quality .",
    "we also present results for the parallel machine case for the same instances .",
    "in future we intend to study our algorithms over all the instances up to @xmath15 jobs with some hybridized metaheuristic approach .",
    "we are planning to implement these metaheuristic approaches using graphics processing units ( gpus ) and provide speed - ups in runtime for all the instances .",
    "further we plan to implement it over all @xmath175 benchmark instances for several independent machines .",
    "the research project was promoted and funded by the european union and the free state of saxony , germany .",
    "the authors take the responsibility for the content of this publication .",
    "10 d.  biskup and m.  feldmann , `` benchmarks for scheduling on a single machine against restrictive and unrestrictive common due dates , '' _ computers & operations research _ , vol .",
    "28 , no .  8 , pp . 787  801 , 2001 .",
    "a.  seidmann , s.  panwalkar , and m.  smith , `` optimal assignment of due - dates for a single processor scheduling problem , '' _ the international journal of production research _ ,",
    "19 , no .  4 , pp . 393399 , 1981 .",
    "n.  hall , w.  kubiak , and s.  sethi , `` earliness  tardiness scheduling problems , ii : deviation of completion times about a restrictive common due date , '' _ operations research _ , vol .",
    "39 , no .  5 , pp . 847856 , 1991 .",
    "m.  feldmann and d.  biskup , `` single - machine scheduling for minimizing earliness and tardiness penalties by meta - heuristic approaches , '' _ computers & industrial engineering _ , vol .",
    "44 , no .  2 ,",
    "pp . 307323 , 2003 .",
    "m.  toksari and e.  guner , `` the common due - date early / tardy scheduling problem on a parallel machine under the effects of time - dependent learning and linear and nonlinear deterioration , '' _ expert systems with applications _ , vol .",
    "37 , no .  1 , pp . 92112 , 2010 .",
    "d.  ronconi and m.  kawamura , `` the single machine earliness and tardiness scheduling problem : lower bounds and a branch - and - bound algorithm , '' _ computational & applied mathematics _",
    "29 , pp . 107  124 , 2010 .",
    "m.  rebai , i.  kacem , and k.  adjallah , `` earliness-tardiness minimization on a single machine to schedule preventive maintenance tasks : metaheuristic and exact methods , '' _ journal of intelligent manufacturing _ , vol .",
    "23 , no .  4 , pp . 12071224 , 2012 .",
    "m.  gen , y.  tsujimura , and e.  kubota , `` solving job - shop scheduling problems by genetic algorithm , '' in _ ieee international conference on systems , man , and cybernetics , 1994 .",
    "humans , information and technology .",
    "_ , vol .  2 , 1994 , pp ."
  ],
  "abstract_text": [
    "<S> this paper considers the problem of scheduling jobs on single and parallel machines where all the jobs possess different processing times but a common due date . </S>",
    "<S> there is a penalty involved with each job if it is processed earlier or later than the due date . </S>",
    "<S> the objective of the problem is to find the assignment of jobs to machines , the processing sequence of jobs and the time at which they are processed , which minimizes the total penalty incurred due to tardiness or earliness of the jobs . </S>",
    "<S> this work presents exact polynomial algorithms for optimizing a given job sequence for single and parallel machines with the run - time complexities of @xmath0 and @xmath1 respectively , where @xmath2 is the number of jobs and @xmath3 the number of machines . </S>",
    "<S> the algorithms take a sequence consisting of all the jobs @xmath4 as input and distribute the jobs to machines ( for @xmath5 ) along with their best completion times so as to get the least possible total penalty for this sequence . </S>",
    "<S> we prove the optimality for the single machine case and the runtime complexities of both . </S>",
    "<S> henceforth , we present the results for the benchmark instances and compare with previous work for single and parallel machine cases , up to @xmath6 jobs . </S>"
  ]
}