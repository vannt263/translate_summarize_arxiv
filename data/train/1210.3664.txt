{
  "article_text": [
    "distributed storage systems ( dss ) are designed to store data over a distributed network of nodes .",
    "dss have become increasingly important given the growing volumes of data being generated , analyzed and archived today .",
    "oceanstore @xcite , google file system ( gfs ) @xcite , and totalrecall @xcite are a few examples of storage systems employed today .",
    "data to be stored is more than doubling every two years , and efficiency in storage and data recovery is particularly critical today .",
    "the coding schemes employed by dss are designed to provide efficient storage while ensuring resilience against node failures in order to prevent the permanent loss of the data stored on the system . in a majority of existing literature ,",
    "the analysis of dss focuses primarily on isolated node failures . in our work ,",
    "we study a more general scenario of dss that can suffer from multiple simultaneous node failures .",
    "in addition to multiple node failures , dss systems are also inherently susceptible to adversarial attacks , such as one from eavesdroppers aiming to gain access to the stored data .",
    "therefore , a `` good '' dss would meet desired security requirements while performing efficient repairs even in the case of multiple simultaneous node failures .    in @xcite ,",
    "dimakis et al .",
    "present a class of _ regenerating codes _ , which efficiently trade - off per node storage and repair bandwidth for single node repair .",
    "these codes are designed to possess a maximum distance separable ( mds ) property , which is an _ `` any @xmath0 out of @xmath1 '' _ property , wherein the entire data can be reconstructed by contacting to any @xmath0 storage nodes out of @xmath1 nodes . by utilizing a network coding approach , the notion of _ functional repair _",
    "is developed in @xcite , where the original failed node may not be replicated exactly , but can be repaired such that it is _ functionally _ equivalent . on the other hand , _ exact repair _ requires that the regeneration process results in an exact replica of the data stored on the failed node .",
    "this is essential due to the ease of maintenance and other practical purposes such as maintaining a code in its systematic form .",
    "exact repair may also prove to be advantageous compared to functional repair in the presence of eavesdroppers , as the latter scheme requires updating the coding coefficients , which in turn may leak additional information to eavesdroppers @xcite .",
    "the design of exact regenerating codes achieving one of the two ends of the trade off between storage and repair bandwidth has been recently investigated by researchers .",
    "in particular , rashmi et al .",
    "@xcite design codes that are optimal for all parameters at the minimum bandwidth regeneration ( mbr ) point . for the minimum storage regeneration ( msr )",
    "point , optimal codes are presented in multiple recent papers .",
    "( see @xcite and references therein . )    as discussed before , dss can also exhibit multiple simultaneous node failures , and it is desirable that these be repaired simultaneously .",
    "it is not uncommon that multiple failures occur in dss , especially for large - scale systems .",
    "in addition , some dss administrators may choose to wait to initiate a repair process after a critical number of failures has occurred ( say @xmath2 of them ) , in order to render the entire process more efficient and less frequent .",
    "for example , totalrecall @xcite currently executes a node repair process only after a certain threshold on the number of failures is reached . in such multiple failure scenarios ,",
    "each new node replacing a failed one can still contact @xmath3 remaining ( surviving ) nodes to download data for the repair process .",
    "in addition , replacement nodes , after downloading data from surviving nodes , can also exchange data within themselves to complete the repair process .",
    "this repair process is referred to as _ cooperative repair _ in @xcite , which present network coding techniques to implement such repairs .",
    "cooperative repair is shown to be essential as it can help in lowering the total repair bandwidth compared to the @xmath4 case .",
    "flexibility of the choice on download nodes at repair nodes is analyzed in  @xcite .",
    "@xcite , focusing on functional repair , shows that under the constraint @xmath5 , deliberately delaying repairs ( and thus increasing @xmath2 ) does not result in gains in terms of mbr / msr optimality . @xcite and",
    "@xcite utilize a cut - set bound argument and derive the cooperative counterpart of the end points of the trade off region .",
    "these two points are named as the minimum bandwidth cooperative regenerating ( mbcr ) point and the minimum storage cooperative regenerating ( mscr ) point ( see also  @xcite ) .",
    "the work in  @xcite shows the existence of cooperative regenerating codes with optimal repair bandwidth .",
    "explicit code constructions for exact repair on this setup are presented in  @xcite , for the mbcr point , and in  @xcite , for the mscr point .",
    "these constructions are designed for the setting of @xmath6 .",
    "( see also  @xcite . )",
    "interference alignment is used in  @xcite to construct scalar codes to operate at the mscr point .",
    "( this construction is limited to the case @xmath7 with @xmath8 , and does not generalize to @xmath9 with @xmath10 . ) an explicit construction for the mbcr point , with the restriction that @xmath5 for any @xmath11 , is presented in  @xcite .",
    "finally , the reference  @xcite presents designs of scalar codes for the mbcr point for all possible parameter values . noting the significance of cooperative repair in dss , regenerating codes that have resilience to eavesdropping attacks will have greater value if they also have efficient cooperative repair mechanisms .",
    "the security of systems can be understood in terms of their resilience to either ( or both ) active or passive attacks  @xcite .",
    "active attacks include settings where the attacker modifies existing packets or injecting new ones to the system , whereas passive attacks include eavesdroppers observing the information being stored / transmitted . for dss , cryptographic approaches like private - key cryptography",
    "are often logistically prohibitive , as the secret key distribution between each pair of nodes and its renewal are highly challenging , especially for large - scale systems .",
    "in addition , most cryptographic approaches are typically based on certain hardness results , which , if repudiated , could leave the system vulnerable to attacks . on the other hand , information theoretic security ,",
    "see , e.g. , @xcite , presents secrecy guarantees even with infinite computational power at eavesdroppers without requiring the sharing and/or distribution of keys .",
    "this approach is based on the design of secrecy - achieving coding schemes by taking into account the amount of information leaked to eavesdroppers , and can offer new solutions to security challenges in dss . in its simplest form ,",
    "the security can be achieved with the one - time pad scheme  @xcite , which claims the security of the ciphertext obtained by xor of data and uniform key .",
    "this approach is of significant value to dss .",
    "for example , consider a system storing the key at a node , and ciphertext at another node .",
    "then , the eavesdropper will not obtain any information by observing one of these two nodes , whereas the data collector can contact to both nodes and decipher the data .",
    "the problem of designing secure dss against eavesdropping attacks has been recently studied by pawar et al .",
    "@xcite , where the authors consider a passive eavesdropper model that observe the data stored on @xmath12 @xmath13 storage nodes for a dss employing an mbr code .",
    "the proposed schemes are designed for the `` bandwidth limited regime '' , and shown to achieve an upper bound on the secure file size , establishing its optimality .",
    "shah et al .",
    "@xcite consider the design of secure msr codes . here , they show that the eavesdropper model for an msr code should be extended compared to that of an mbr code .",
    "the underlying reason is that at the msr point of operation , the eavesdropper may obtain additional information by observing the downloaded information ( as compared to just observing the stored information ) .",
    "thus , at the msr point , the eavesdropper is modeled with a pair ( @xmath14 ) with @xmath15 , where the eavesdropper has knowledge of the content of the @xmath16 number of nodes , and , in addition , has knowledge of the downloaded information ( and hence also the storage content ) of the @xmath17 number of nodes .",
    "we note that , as the downloaded data is stored for minimum bandwidth regenerating codes , the two notions are different only at the minimum storage point .",
    "considering such an eavesdropper model , shah et al .",
    "present coding schemes utilizing product matrix codes @xcite , and show that the bound on secrecy capacity in @xcite at mbr is achievable .",
    "they further use product matrix based codes for msr point as well , and show the bound in @xcite is achievable only when @xmath18 .",
    "in addition to this classical mbr / msr setting , the security aspects of locally repairable codes ( see , e.g. , @xcite ) are studied in  @xcite ; and security against active eavesdroppers are investigated in  @xcite .    in this paper , we analyze and design secure and cooperative regenerating codes for dss . in terms of security requirements , we utilize a passive and colluding eavesdropper model as presented in @xcite . in this model , during the entire life span of the dss , the eavesdropper can gain access to data stored on an @xmath16 number of nodes , and , in addition , it observes both the stored content and the data downloaded ( for repair ) on an additional @xmath17 number of nodes . given this eavesdropper model ,",
    "we focus on the problem of designing secure regenerating codes in the context of dss that performs multiple node repairs in a cooperative manner .",
    "this scenario generalizes the single node repair setting considered in earlier works to multiple node failures .",
    "first , we present upper bound on the secrecy capacity for mbcr codes , and present a secure coding scheme that achieves this bound .",
    "this proves the tightness of the bound and characterizes the secrecy capacity for mbcr codes .",
    "next , we address the secrecy capacity of a dss employing the mscr codes , and show that the existing mscr codes can be made secure against eavesdropping . in this minimum storage setup ,",
    "our codes match the upper bound secure file size under special cases . in all scenarios ,",
    "the achievability results allows for exact repair , and secure file size upper bounds are obtained from mincut analyses over the secrecy graph representation of dss .",
    "the main secrecy achievability coding argument of the paper is obtained by utilizing a secret precoding scheme to obtain secure coding schemes for dss . in some cases ,",
    "this precoding is established simply with the one - time pad scheme , and in others _ maximum rank distance _ ( mrd )",
    "codes are utilized similar to the classical work of  @xcite .",
    "the rest of the paper is organized as follows . in section",
    "ii , we provide the general system model together with some preliminary results utilized throughout the text .",
    "section iii provides the analysis of secure mbcr codes , and section iv is devoted to the secure mscr codes .",
    "the paper is concluded in section v , and , to enhance the flow of the paper , some of the results and proofs are relegated to appendices .",
    "consider a dss with @xmath1 live nodes at a time and a file @xmath19 of size @xmath20 over @xmath21 that needs to be stored on the dss . in order to store the file @xmath19 ,",
    "it is divided into @xmath0 blocks of size @xmath22 each .",
    "let @xmath23 denotes these @xmath0 blocks . here",
    ", we have @xmath24 . these @xmath0 data blocks are encoded into @xmath1 data blocks , @xmath25 , each of length @xmath26 over @xmath21 ( @xmath27 ) .",
    "given the codewords , node @xmath28 in an @xmath1-node dss stores encoded block @xmath29 . in this paper , we use @xmath29 , to represent both block @xmath29 and a storage node storing this encoded block interchangeably .",
    "motivated by the mds property of the codes that are traditionally proposed to store data in centralized storage systems @xcite , the works on regenerating codes focus on storage schemes that have `` any @xmath0 out of @xmath1 '' property , i.e. , the content of any @xmath0 nodes will suffice to recover the file .",
    "we focus on codes achieving this property .",
    "we use the following notation throughout the text .",
    "we usually stick with the notation of having vectors denoted by lower - case bold letters ; and , sets and subspaces being denoted with calligraphic fonts . for @xmath30 , @xmath31 $ ] represents the set of numbers @xmath32 .",
    "( this is shortened as @xmath33 $ ] for @xmath34 $ ] , and brackets are omitted in subscripts to improve readability . ) the symbols stored at node @xmath28 is represented by the vector @xmath35 , the symbols transmitted from node @xmath28 to node @xmath36 is denoted as @xmath37 , and the set @xmath38 is used to denote all of the downloaded symbols to node @xmath36 .",
    "dss is initialized with the @xmath1 nodes containing encoded symbols , i.e. , @xmath39 for @xmath40 .      in most of the studies on dss ,",
    "exact repair for regenerating codes is analyzed in the context of single node failure .",
    "however , it is not uncommon to see simultaneous multiple node failures in storage networks , especially for large ones .",
    "the basic setup involves the simultaneous repair of @xmath2 ( possibly greater than one ) failed nodes .",
    "after the failure of @xmath2 storage nodes , the same number of newcomer nodes are introduced to the system .",
    "each such node contacts to @xmath3 live storage nodes and downloads @xmath41 symbols from each of these nodes .",
    "in addition , utilizing a cooperative approach , each newcomer node also contacts other nodes being under repair and downloads @xmath42 symbols from each other node .",
    "hence , the total repair cost is given by @xmath43 each newcomer node , to repair the @xmath28-th node of the original network , uses these @xmath44 number of downloaded symbols to regenerate @xmath26 symbols , @xmath45 , and stores these symbols .",
    "this exact repair process preserves the mds property , i.e. , data stored on any @xmath0 nodes ( potentially including the nodes that are repaired ) allows the original file @xmath19 to be reconstructed .",
    "see fig .",
    "[ fig : flowgraph1 ] .",
    "we remark that , as also argued in  @xcite , @xmath8 can be assumed without loss of generality .",
    "( earlier papers on the subject assumed @xmath8 case , and noted that this is assumed for simplicity .",
    "see , e.g. ,  @xcite . )",
    "remarkably , if @xmath46 , a data collector can reconstruct the whole file by contacting only @xmath3 nodes , as from these nodes the other nodes can be repaired in groups of size @xmath2 .",
    "thus , any @xmath47 code with @xmath46 can be reduced to @xmath48 code . therefore , without loss of generality , we will assume @xmath8 .    , @xmath49 , and @xmath50 . accordingly , after a failure of two nodes , namely node @xmath51 and node @xmath52 , the system cooperatively repairs these two nodes as node @xmath53 and node @xmath54 .",
    "downloads from live nodes ( blue ) and from cooperative repair pairs ( green ) are shown .",
    "due to exact repair , the network will repair the nodes to satisfy @xmath55 and @xmath56 . ]      in their seminal work @xcite , dimakis et al .",
    "models the operation dss using a multicasting problem over an information flow graph .",
    "( see figs .",
    "[ fig : flowgraph1 ] and [ fig : flowgraph2 ] for the flow graph in the cooperative setting . ) information flow graph consists of three types of nodes :    * source node ( @xmath57 ) : source node contains @xmath20 symbols long original file @xmath19 .",
    "the source node is connected to @xmath1 nodes .",
    "* storage nodes ( @xmath58 ) : in information flow graph associated with cooperative regenerating codes , we represent each node with a combination of three sub - nodes : @xmath59 , @xmath60 , and @xmath61 . here , @xmath59 is the sub - node having the connections from the live nodes , @xmath60 is the sub - node having the connections from the nodes under repair in the same repair group , and @xmath61 is the storage sub - node , which stores the data and is contacted by a data collector or other nodes under repair .",
    "@xmath59 is connected to @xmath60 with a link of infinite capacity , @xmath60 is connected to @xmath61 with a link of capacity @xmath26 .",
    "we represent cuts with a notation with bars as in @xmath62 , meaning the cut is passing through the link between @xmath60 and @xmath61 .",
    "( see fig .",
    "[ fig : flowgraph2 ] . )",
    "the nodes on the right hand side of the cuts belong to data collector side , represented by the set @xmath63 , whereas the nodes belonging to the left hand side of the cuts belong to @xmath64 , the source side . for a newcomer node",
    ", @xmath65 is connected to @xmath66 sub - nodes of @xmath3 live nodes with links of capacity @xmath41 symbols each , representing the data downloaded during node repair .",
    "this newcomer node also connects to @xmath67 sub - nodes of @xmath68 nodes being repaired in the same group , each having a link capacity of @xmath42 .",
    "* data collector node(s ) ( @xmath69 ) : each data collector contacts @xmath66 sub - node of @xmath0 live nodes with edges each having @xmath70-link capacity .    , @xmath49 , and @xmath50 .",
    "multiple repair stages and a cut , represented by dotted line , through the nodes connected to the @xmath69 are shown .",
    "the figure has different cut types : the first repaired node has a cut of type @xmath71 and the second has a cut of type @xmath62 .",
    "nodes that are being eavesdropped are indicated with dashed - dotted lines . here , both the content and the downloads of the first repaired node is observed by the eavesdropper ( @xmath72 ) , and only the content of the last repaired node is observed by the eavesdropper ( @xmath73 ) .",
    "accordingly , eavesdropper has observations of @xmath44 downloaded symbols from the first repaired node , and has @xmath26 number of symbols from the last repaired node . ]      with the aforementioned values of capacities of various edges in the information flow graph , the dss is said to employ an @xmath74 code . for a given graph @xmath75 and data collectors @xmath76 ,",
    "the file size that can be stored in such a dss can be bounded using the max flow - min cut theorem for multicasting utilized in network coding  @xcite .",
    "@xmath77 where @xmath78 represents the flow from the source node @xmath57 to data collector @xmath76 over the graph @xmath75 .",
    "therefore , e.g. , for the graph in fig .",
    "[ fig : flowgraph2 ] , @xmath20 symbol long file can be delivered to a data collector @xmath69 , only if the min cut is at least @xmath20 .",
    "dimakis et al . ,",
    "@xcite , consider @xmath0 successive node failures and evaluate the min - cut over possible graphs , and obtain the following bound ( for @xmath4 case ) .",
    "@xmath79 we emphasize that the min - cut for this ( @xmath4 ) case is given by the scenario where @xmath0 successively repaired nodes are connected to @xmath69 , and , for each successive repair , the repaired node @xmath80 also connects to @xmath28 number of previously repaired nodes .",
    "hence , for each @xmath69-connected node , the cut value is equal to @xmath81 if the cut is of type @xmath82 , and is equal to @xmath26 if the cut is of type @xmath83 .",
    "( note that , @xmath60 does not appear here as the model considered in  @xcite does not involve cooperative repair . )",
    "the codes that attain the bound in ( [ eq : dimakis_thm ] ) are named as regenerating codes @xcite .    for the cooperative scenario",
    ", we consider secure file size upper bound in the next section using similar min cut arguments in the presence of eavesdroppers . removing the leakage ( to eavesdropper ) terms one will obtain the min cut file size bound for the cooperative scenario .",
    "in particular , a file size bound in the cooperative setting is obtained as follows .",
    "@xmath84    where @xmath85 $ ] is the number of repaired nodes in repair group @xmath86 $ ] that is connected to @xmath69 .",
    "similar to the @xmath4 case described above , the cut of type @xmath62 has a value of @xmath26 .",
    "the cut of type @xmath71 , on the other hand , has a value of @xmath87 due to the links coming from the nodes under repair that are not connected to @xmath69 and additional value of @xmath88 due to the connections to the previously repaired live nodes that are not contacted by @xmath69 .",
    "( here , we again subtract the values of the flows from the nodes already belonging to the data collector side , @xmath63 . )",
    "the cut of type @xmath89 has value of @xmath70 and hence , does not appear in the min - cut .",
    "note that , given a file size @xmath20 , there is an inherent trade off between storage per node @xmath26 and _ repair bandwidth _ @xmath90 .",
    "this trade off , for the cooperative setting , can be established using a similar analyses leading to mbr / msr points from the equation .",
    "two classes of codes that achieve two extreme points of this trade off are named as _",
    "minimum bandwidth cooperative regenerating ( mbcr ) _ codes and _ minimum storage cooperative regenerating ( mscr ) _ codes .",
    "the former is obtained by first finding the minimum possible @xmath91 and then finding the minimum @xmath26 satisfying .",
    "this point is given by the following .",
    "@xmath92    .",
    "]    mscr point , on the other hand , is obtained by first choosing a minimum storage per node ( i.e. , @xmath93 ) , and then minimizing @xmath91 ( via choosing minimum possible @xmath41-@xmath42 pair ) satisfying the min cut .",
    "@xmath94    we depict these two trade off points , which are directly computable from , in fig .  [ fig : mbcr - mscr ] .",
    "( we refer reader to the works  @xcite for a detailed derivation of these two points .",
    "see also  @xcite for an analysis for the simplified case of when @xmath95 , i.e. , the number of groups satisfies @xmath96 . )",
    "note that , when @xmath4 , these two points correspond to mbr / msr points characterized in  @xcite .",
    "we consider an @xmath97 eavesdropper , which can access the stored data of nodes in the set @xmath98 , and additionally can access both the stored and downloaded data at the nodes in the set @xmath99 , where @xmath100 and @xmath101 .",
    "hence , the eavesdropper has access to @xmath102 for @xmath103 and @xmath104 for @xmath105 .",
    "( see fig .",
    "[ fig : flowgraph2 ] . )",
    "this is the eavesdropper model defined in @xcite ( adapted here to the cooperative repair setting ) , which generalizes the eavesdropper model considered in @xcite .",
    "the eavesdropper is assumed to know the coding scheme employed by the dss . at the mbcr point ,",
    "a newcomer downloads @xmath106 amount of data .",
    "thus , an eavesdropper does not gain any additional information if it is allowed to access the data downloaded during repair .",
    "however , at the mscr point , repair bandwidth is strictly greater than the per node storage , @xmath107 , and an eavesdropper potentially gains more information if it has access to the data downloaded during node repair as well .",
    "we summarize the eavesdropper model together with the definition of achievability of a secure file size in the following .",
    "a dss is said to achieve a secure file size of @xmath108 against an @xmath97 eavesdropper , if , for any sets @xmath98 and @xmath99 of size @xmath16 and @xmath17 , respectively , @xmath109 . here",
    "@xmath110 is the secure file of size @xmath108 , which is first encoded to file @xmath19 of size @xmath111 before storing into dss , and @xmath112 is the eavesdropper observation vector given by @xmath113 .",
    "we remark that , as it will be clear from the following sections , when a file @xmath19 of size @xmath111 is stored in dss and the secure file size achieved is @xmath108 , the remaining @xmath114 symbols can be utilized as public data , which does not have security constraints . yet , noting the possibility of storing the public data , we will refer to this uniformly distributed part as the random data , which is utilized to achieve security . finally , we note the following lemma , which will be used in the following parts of the sequel .",
    "[ thm : secrecylemma ] consider a system with information bits @xmath115 , random bits @xmath116 ( independent of @xmath115 ) , and an eavesdropper with observations given by @xmath112 . if @xmath117 and @xmath118 , then i(*u*;*e*)=0 .",
    "see appendix  [ app : secrecylemma ] .",
    "in this section , we study secure minimum bandwidth cooperative regenerating codes .",
    "we first present an upper bound on the secure file size that can be supported by an mbcr code .",
    "then , we present exact repair coding schemes achieving the derived bound .",
    "in addition , we analyze how the cooperation affects the penalty paid in securing storage systems .",
    "analysis of the cut - set bounds for cooperative regenerating codes are provided in  @xcite .",
    "( see also the arguments given in  @xcite . here , we follow the notations of  @xcite . )",
    "we consider groups of nodes being repaired , and denote the number of nodes in group @xmath28 that are repaired in group @xmath28 and contacted by the data collector as @xmath119 such that @xmath120 , \\forall i=0,1,\\cdots , g-1,\\\\ \\sum\\limits_{i=0}^{g-1 } u_i & = & k,\\end{aligned}\\ ] ] where @xmath121 is the total number of groups that have been repaired . while evaluating an upper bound on the file size that can be securely stored on the dss , the data collector under consideration is assumed to contact only these @xmath0 nodes that belong to one of these @xmath121 groups .",
    "we consider two types of cuts : @xmath122 number of nodes have the first cut type @xmath123 , and @xmath124 number of nodes have the second cut type @xmath125 , @xmath126 .",
    "note that the cuts of the form @xmath123 give a cut value of @xmath26 as opposed to @xmath127 , which has cut value larger than @xmath26 .",
    "since we are interested in the cuts of smaller size , we do not consider the cuts @xmath127 .",
    "we consider @xmath16 number of colluding eavesdroppers , each observing the contents of different nodes .",
    "note that , for mbcr point analysis , we can consider @xmath128 without loss of generality , as the amount of data a particular node stores is equal to amount of data it downloads during its repair .",
    "we denote the number of eavesdroppers on the nodes in the first cut type as @xmath129 , @xmath126 ; and denote the number of eavesdroppers on the nodes in the second cut type as @xmath130,@xmath126 , such that @xmath131 thus , for group @xmath28 , due to the eavesdroppers , the nodes that belong to the first type can only add the value of @xmath132 to the cut .",
    "the second type , on the other hand , consists of @xmath124 nodes , out of which @xmath130 of them are eavesdropper . as the data downloaded is equal to the data stored at mbcr point , the nodes that are eavesdropped do not add a value to the cut .",
    "the remaining @xmath133 number of nodes contact @xmath3 live nodes , @xmath134 number of these belong to the previous groups being repaired . in addition , these nodes contact @xmath135 nodes from the same repair group , out of which @xmath136 number of nodes belong to @xmath63 .",
    "accordingly , this cut - set bound is given by the following .",
    "let @xmath162 and @xmath163 , so that @xmath164 . from , we obtain @xmath165 considering possible allocations of eavesdroppers in this bound , i.e. , @xmath166 , we obtain the following bound ( where we collect eavesdropper dependent terms in the variable @xmath57 given below ) .",
    "@xmath167 where @xmath57 is given by @xmath168 @xmath169 note that we consider the worst case eavesdropper allocation to maximize @xmath57 in the above derivation .",
    "the normalized values at the mbcr point are given by @xmath170 using this and the bounds given in , , and , we get a bound on the secure file size at the mbcr point . we state this result in the following .",
    "[ thm : mbcrbound ] cooperative regenerating codes operating at the mbcr point with a secure file size of @xmath171 satisfy @xmath172 and the mbcr point is given by @xmath173 , @xmath174 , @xmath175 for a file size of @xmath176 .",
    "we consider secrecy precoding of the data at hand before storing it to dss nodes using an mbcr code .",
    "we establish this precoding with maximum rank distance ( mrd ) codes . in vector representation , assuming @xmath177 , the norm of a vector @xmath178 is the column rank of @xmath179 over the base field @xmath180 , denoted by @xmath181 .",
    "( this is the maximum number of linearly independent coordinates of @xmath179 over the base field @xmath180 , for a given basis of @xmath182 over @xmath180 .",
    "a basis also establishes an isomorphism between @xmath1-length vectors , in @xmath183 , to @xmath184 matrices , in @xmath185 . )",
    "rank distance between two vectors is defined by @xmath186 .",
    "( in matrix representation , this is equivalent to the rank of the difference of the two corresponding matrices of the vectors . )",
    "an @xmath187 $ ] mrd code over the extension field @xmath182 achieving the maximum rank distance @xmath188 ( for @xmath177 ) can be constructed with the following linearized polynomial .",
    "( this is referred to as the gabidulin construction of mrd codes , or gabidulin codes @xcite . )",
    "@xmath189},\\end{aligned}\\ ] ] where @xmath190=q^i$ ] , and @xmath191 . then , given @xmath1 linearly independent elements over @xmath180 , @xmath192 with @xmath193 , the codewords for a given set of @xmath0 elements , @xmath194 $ ] , are obtained by @xmath195}$ ] for @xmath196 $ ] .",
    "( with generator matrix representation , we have @xmath197 , where @xmath198 } , \\cdots , g_n^{[k-1]}]$ ] . )",
    "we also note that the linearized polynomial satisfies @xmath199 , for a given @xmath200 and @xmath201 , and this will be utilized in the following .",
    "consider now the mbcr point given by @xmath176 , @xmath173 , @xmath174 , @xmath175 , @xmath202 , and @xmath5 .",
    "we use mrd codes with @xmath203 ; hence , the rank distance bound @xmath204 is saturated at @xmath205 . accordingly",
    ", we utilize @xmath206 $ ] mrd codes over @xmath182 , which maps length @xmath111 vectors ( each element of it being in @xmath182 ) to length @xmath111 codewords in @xmath207 ( with @xmath208 ) .",
    "the coefficients of the underlying linearized polynomial ( @xmath209 ) are chosen by @xmath210 random symbols denoted by @xmath211 and @xmath171 secure data symbols denoted by @xmath212 .",
    "the corresponding polynomial @xmath209 is evaluated at @xmath20 points @xmath213 ,  , @xmath214 , which are linearly independent over @xmath21 .",
    "we denote these as @xmath215 for @xmath216 .",
    "this finalizes the secrecy precoding step .",
    "the second encoding step is based on the encoding scheme for cooperative repair proposed in  @xcite .",
    "( here , we will summarize file recovery and node repair processes for the case of mrd precoding , and provide the proof of security . ) split the @xmath20 symbols into two parts a ) @xmath217 to @xmath218 , and b ) @xmath219 to @xmath220 .",
    "( note that @xmath5 and @xmath221 . )",
    "the first part is divided into @xmath1 groups of @xmath0 symbols , and stored in @xmath1 nodes . here",
    ", node @xmath28 stores @xmath222 to @xmath223 .",
    "the second part is divided into @xmath224 groups of @xmath0 symbols .",
    "these symbols are encoded with an @xmath225 mds code , and stored on @xmath1 nodes . in particular , @xmath226 are generated from symbols @xmath227 , and @xmath228 is stored at node @xmath28 , for @xmath229 .",
    "node @xmath28 , having stored @xmath230 , which is referred to as the primary data of node @xmath28 , encodes these symbols using an @xmath231 mds code having a vandermonde matrix @xmath232 of size @xmath233 as its generator matrix .",
    "( this choice of @xmath232 ensure that @xmath234 $ ] is generator matrix for an @xmath235 mds code . )",
    "these @xmath236 symbols are stored in every other node one - by - one .",
    "we denote the encoded primary data of node @xmath28 that is stored in node @xmath237 as @xmath238 .",
    "we call these as the secondary data",
    ". this procedure is repeated for every node , so that each node @xmath28 stores @xmath239 @xmath240 , and hence total number of symbols stored at each node is @xmath241 .    _ file recovery at dc : _ dc connects to any @xmath0 nodes , without loss of generality we assume the first @xmath0 nodes . from @xmath242 ,",
    "dc can obtain @xmath243 , for each @xmath244 $ ] .",
    "it can re - encode this into @xmath245 using the mds code , and obtain the other @xmath246 symbols at the remaining nodes .",
    "then , for each @xmath247 $ ] , dc can use the mds property of @xmath248 $ ] , to obtain @xmath249 symbols of node @xmath28 from the @xmath0 secondary data symbols of the contacted nodes , i.e. , @xmath238 for @xmath250 $ ] , and additional @xmath224 symbols , @xmath228 for @xmath244 $ ] .",
    "having obtained @xmath251 , dc can perform interpolation to solve for both data and random coefficients .",
    "_ node repair : _ assume that the first @xmath2 nodes fail . from the secondary data stored in the remaining @xmath252 nodes , @xmath253 , one can recover @xmath249 and @xmath254 ; for node @xmath255 .",
    "( this corresponds to sending @xmath51 symbol from each of @xmath3 nodes to each of the @xmath2 nodes . )",
    "then , to recover the secondary data stored at each node under repair , say for the node @xmath256 , every other node , i.e. , nodes @xmath257 , including the nodes under repair , computes and sends its corresponding encoded primary data , i.e. , @xmath238 , to node @xmath36 .",
    "( this corresponds to sending @xmath51 symbol from each node to each of the @xmath2 nodes . )",
    "this achieves @xmath174 and @xmath173 symbols for the repair procedure .    _",
    "security : _ consider that the eavesdropper is observing the first @xmath16 nodes . due to the code construction , the symbols in the sets @xmath258 , @xmath259 , @xmath260 } correspond to linearly independent evaluation points .",
    "( note that , the symbols @xmath261 for @xmath262 ; @xmath263 ; @xmath237 , are linear combinations of the symbols in @xmath264 . ) due to the linearized property of the code , the eavesdropper observing @xmath265 symbols , has evaluation of polynomial @xmath266 at @xmath267 linearly independent points . using the data symbols , together with interpolation from these @xmath267 symbols ,",
    "the eavesdropper can solve for @xmath267 random symbols .",
    "therefore , denoting the eavesdroppers observation as @xmath112 , we have @xmath268 . as , @xmath269 , from lemma  [ thm : secrecylemma ] , we have @xmath270 .",
    "cooperative regenerating codes has a repair bandwidth given by @xmath272 . in this section ,",
    "we analyze @xmath273 , the ratio of repair bandwidth to the secure file size . in the following ,",
    "we refer to this parameter as the normalized repair bandwidth ( nrbw ) .    without the security constraints , for which @xmath274 in proposition  [ thm : mbcrbound ]",
    ", we observe that at mbcr point nrbw is given by @xmath275 which is equal to @xmath276 for a system with @xmath5 . here , the classical ( i.e. , non - cooperative ) scenario corresponds to @xmath4 case , which has an nrbw of @xmath277 comparing the last two equations , we see that @xmath278 with equality iff @xmath4 . therefore , without the security constraints , having simultaneous repairs of size greater than @xmath51 actually increases the repair bandwidth .",
    "this nature of cooperation also results in the conclusion that deliberately delaying the repairs does not bring additional savings  @xcite .",
    "( this observation is proposed for both mbcr and mscr points in  @xcite with an analysis of derivative of @xmath91 with respect to @xmath2 . here",
    ", we provide an analysis with nrbw . )",
    "we revisit the above conclusion under security constraints .",
    "the question is whether the cooperation ( i.e. , having a system with multiple failures , or deliberately delaying the repairs ) results in a loss / gain in secure dss .",
    "a calculation similar to above shows that nrbw for the case @xmath279 is strictly greater than that of @xmath4 when @xmath5 for @xmath280 .",
    "the mbcr points given in proposition  [ thm : mbcrbound ] for codes satisfying @xmath281 , @xmath8 , and @xmath252 are given in table  [ tab : coop ] in appendix  [ app : cooptable ] .",
    "as evident from the table , we see that cooperation does not bring additional savings for secure dss at mbcr point when @xmath282 .",
    "this in turn means that one may not delay the repairs to achieve a better performance than that of single failure - repair if @xmath3 is chosen such that @xmath5 for a given @xmath283 .",
    "however , if the downloads within the cooperative group are less costly compared to the downloads from the live nodes , then delaying repairs would be beneficial in reducing the total cost .",
    "we will revisit this analysis for codes having @xmath284 in the next subsection .",
    "the code construction above needs the requirement of @xmath252 .",
    "however , for practical systems , it may not be possible that a failed node connects to all the remaining nodes .",
    "this brings the necessity of code constructions for @xmath285 .",
    "remarkably , for a fixed @xmath286 , increasing @xmath2 can reduce the repair bandwidth in the secrecy scenario we consider here .",
    "this is reported in  @xcite for dss without secrecy constraints .",
    "hence , for a fixed @xmath3 , delaying the repairs can be advantageous , e.g. , when there is a limit on the number of live nodes that can be connected . in the following , we present a general construction which works for any parameters , in particular for @xmath284 .",
    "s.  rhea , p.  eaton , d.  geels , h.  weatherspoon , b.  zhao , and j.  kubiatowicz , `` pond : the oceanstore prototype , '' in _ proc . of the 2nd usenix conference on file and storage technologies ( fast 03 )",
    "_ , 2003 .",
    "s.  ghemawat , h.  gobioff , and s .- t .",
    "leung , `` the google file system , '' in _ proceedings of the nineteenth acm symposium on operating systems principles _ , ser .",
    "sosp 03.1em plus 0.5em minus 0.4emnew york , ny , usa : acm , 2003 , pp",
    "[ online ] .",
    "available : http://doi.acm.org/10.1145/945445.945450    r.  bhagwan , k.  tati , y .- c .",
    "cheng , s.  savage , and g.  m. voelker , `` total recall : system support for automated availability management , '' in _ proceedings of the 1st conference on symposium on networked systems design and implementation - volume 1 _ , ser .",
    "nsdi04.1em plus 0.5em minus 0.4emberkeley , ca , usa : usenix association , 2004 , pp . 2525 . [ online ] .",
    "available : http://dl.acm.org/citation.cfm?id=1251175.1251200      s.  pawar , s.  el  rouayheb , and k.  ramchandran , `` securing dynamic distributed storage systems against eavesdropping and adversarial attacks , '' _ ieee trans .",
    "inf . theory _ ,",
    "57 , no .",
    "6734 6753 , oct .",
    "k.  rashmi , n.  shah , and p.  kumar , `` optimal exact - regenerating codes for distributed storage at the msr and mbr points via a product - matrix construction , '' _ ieee trans .",
    "inf . theory _ , vol .",
    "57 , no .  8 , pp . 5227 5239 , aug . 2011 .",
    "d.  papailiopoulos , a.  dimakis , and v.  cadambe , `` repair optimal erasure codes through hadamard designs , '' in _ proc .",
    "49th annual allerton conference on communication , control , and computing ( allerton 2011 ) _ , sep .",
    "2011 , pp . 13821389 .",
    "v.  cadambe , c.  huang , and j.  li , `` permutation code : optimal exact - repair of a single failed node in mds code based distributed storage systems , '' in _ proc .",
    "2011 ieee international symposium on information theory ( isit 2011 ) _ , jul .",
    "31-aug . 5 2011 , pp .",
    "1225 1229 .",
    "z.  wang , i.  tamo , and j.  bruck , `` on codes for optimal rebuilding access , '' in _ proc .",
    "49th annual allerton conference on communication , control , and computing ( allerton 2011 ) _ , sep .",
    "2011 , pp .",
    "1374 1381 .    y.  hu , y.  xu , x.  wang , c.  zhan , and p.  li , `` cooperative recovery of distributed storage systems from multiple losses with network coding , '' _ ieee journal on selected areas in communications _ , vol .",
    "28 , no .  2 , pp .",
    "268 276 , feb . 2010 .",
    "kermarrec , n.  le  scouarnec , and g.  straub , `` repairing multiple failures with coordinated and adaptive regenerating codes , '' in _ proc .",
    "2011 international symposium on network coding ( netcod 2001 ) _ , jul .",
    "2011 .",
    "k.  w. shum and y.  hu , `` exact minimum - repair - bandwidth cooperative regenerating codes for distributed storage systems , '' in _ proc .",
    "2011 ieee international symposium on information theory proceedings ( isit 2011 ) _ , jul .",
    "31-aug . 5 2011 , pp .",
    "14421446 .",
    "n.  b. shah , k.  v. rashmi , and p.  v. kumar , `` information - theoretically secure regenerating codes for distributed storage , '' in _ proc .",
    "2011 ieee global telecommunications conference ( globecom 2011 ) _ , dec .",
    "2011 .          c.  huang , m.  chen , and j.  li , `` pyramid codes : flexible schemes to trade space for access efficiency in reliable data storage systems , '' in _ proc .",
    "sixth ieee international symposium on network computing and applications ( nca 2007 ) _ , jul . 2007 .",
    "n.  prakash , g.  kamath , v.  lalitha , and p.  kumar , `` optimal linear codes with a local - error - correction property , '' in _ 2012 ieee international symposium on information theory proceedings ( isit 2012 ) _ , jul .",
    "2012 .",
    "k.  rashmi , n.  shah , k.  ramchandran , and p.  kumar , `` regenerating codes for errors and erasures in distributed storage , '' in _ 2012 ieee international symposium on information theory proceedings ( isit 2012 ) _ , jul . 2012 .",
    "n.  silberstein , a.  s. rawat , and s.  vishwanath , `` error resilience in distributed storage via rank - metric codes , '' in _ proc .",
    "50th allerton conference on communication , control , and computing ( allerton 2012 ) _ , 2012 .",
    "d.  a. patterson , g.  gibson , and r.  h. katz , `` a case for redundant arrays of inexpensive disks ( raid ) , '' in _ proceedings of the 1988 acm sigmod international conference on management of data _ , ser .",
    "sigmod 88.1em plus 0.5em minus 0.4emnew york , ny , usa : acm , 1988 , pp",
    ". 109116 .",
    "[ online ] .",
    "available : http://doi.acm.org/10.1145/50202.50214    m.  blaum , j.  brady , j.  bruck , and j.  menon , `` evenodd : an efficient scheme for tolerating double disk failures in raid architectures , '' _ ieee transactions on computers _",
    "44 , no .  2 ,",
    "192202 , feb .",
    "1995 .",
    "t.  ho , m.  medard , r.  koetter , d.  karger , m.  effros , j.  shi , and b.  leong , `` a random linear network coding approach to multicast , '' _ ieee trans .",
    "inf . theory _ ,",
    "52 , no .",
    "10 , pp . 44134430 , oct .",
    "2006 .",
    "p.  delsarte , `` bilinear forms over a finite field , with applications to coding theory , '' _ journal of combinatorial theory , series a _ , vol .  25 , no .  3 , pp . 226",
    " 241 , 1978 .",
    "[ online ] .",
    "available : http://www.sciencedirect.com/science/article/pii/0097316578900158      f.  j. macwilliams and n.  j.  a. sloane , _ the theory of error - correcting codes _ , ser .",
    "north - holland mathematical library .",
    "1em plus 0.5em minus 0.4emelsevier , 1977 .",
    "[ online ] .",
    "available : http://www.sciencedirect.com/science/article/pii/s092465090870521x    n.  shah , k.  rashmi , p.  kumar , and k.  ramchandran , `` interference alignment in regenerating codes for distributed storage : necessity and code constructions , '' _ ieee trans .",
    "inf . theory _ ,",
    "58 , no .  4 , pp .",
    "21342158 , apr .",
    "2012 .    c.  suh and k.  ramchandran , `` exact - repair mds codes for distributed storage using interference alignment , '' in _ proc .",
    "2010 ieee international symposium on information theory proceedings ( isit 2010 ) _ , jun .",
    "2010 , pp . 161165 .",
    "e.  m. gabidulin , a.  v. paramonov , and o.  v. tretjakov , `` ideals over a non - commutative ring and their application in cryptology , '' in _ advances in cryptology - eurocrypt 91 _ , ser .",
    "lecture notes in computer science , vol .",
    "547.1em plus 0.5em minus 0.4emberlin , heidelberg : springer - verlag , 1991 , pp . 482489 .",
    "[ online ] .",
    "available : http://dl.acm.org/citation.cfm?id=1754868.1754922    k.  gibson , `` the security of the gabidulin public key cryptosystem , '' in _ advances in cryptology - eurocrypt 96 _ , ser .",
    "lecture notes in computer science , vol .",
    "1070.1em plus 0.5em minus 0.4emspringer , 1996 , pp ."
  ],
  "abstract_text": [
    "<S> regenerating codes enable trading off repair bandwidth for storage in distributed storage systems ( dss ) . due to their distributed nature , these systems are intrinsically susceptible to attacks , and they may be susceptible to multiple node failures . </S>",
    "<S> this paper analyzes storage systems that employ cooperative regenerating codes that are robust to ( passive ) eavesdroppers . </S>",
    "<S> the analysis is divided into two parts , studying both minimum bandwidth and minimum storage cooperative regenerating scenarios . </S>",
    "<S> first , the secrecy capacity of minimum bandwidth cooperative regenerating codes is characterized . </S>",
    "<S> second , for minimum storage cooperative regenerating codes , a secure file size upper bound and achievability results are provided . </S>",
    "<S> these results establish the secrecy capacity for the minimum storage scenario for certain special cases . in all scenarios , </S>",
    "<S> the achievability results correspond to exact repair , and secure file size upper bounds are obtained using mincut analyses over a suitable secrecy graph representation of dss . </S>",
    "<S> the main achievability argument is based on appropriate precoding of the data to eliminate the information at the eavesdropper .    </S>",
    "<S> coding for distributed storage systems , cooperative repair , minimum bandwidth cooperative regenerating ( mbcr ) codes , minimum storage cooperative regenerating ( mscr ) codes , security . </S>"
  ]
}