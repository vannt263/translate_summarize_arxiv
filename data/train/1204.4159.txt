{
  "article_text": [
    "algorithms for dynamic graphs have traditionally assumed that the graph evolves according to a completely arbitrary sequence of insertions and deletions of graph elements .",
    "this model makes minimal assumptions but often sacrifices efficiency for generality .",
    "for example , real world networks ( router networks , road networks , etc . ) _ do _ change slowly over time .",
    "however , the real dynamism of the networks comes from the frequent _ failure _ of edges / nodes and their subsequent recovery . in this paper",
    "we study connectivity problems in the _ dynamic subgraph model _ , which attempts to accurately model this type of dynamism .",
    "it is assumed that there is some fixed underlying graph whose nodes and edges can be _ off _ ( failed ) or _ on _ ; queries ( connectivity queries , in our case ) then answer questions about the subgraph turned on .",
    "the power of this model ( compared to the fully dynamic graph model ) stems from the ability to preprocess the underlying graph in advance .",
    "there are two natural variants of the dynamic subgraph model . in the @xmath0-failure version failures and recoveries",
    "occur in lockstep : a set @xmath8 of @xmath9 edges / nodes fail together .",
    "our goal is to process @xmath8 , ideally in @xmath10 time , in order to answer connectivity queries in @xmath11 . here",
    "@xmath0 may or may not be a parameter of the algorithm . in the fully dynamic model , node /",
    "edge failures and recoveries are presented one at a time and intermixed with connectivity queries , whereas in the decremental model the updates are restricted to failures .",
    "[ [ results . ] ] results .",
    "+ + + + + + + +    we give new algorithms for subgraph connectivity ( aka connectivity oracles ) on undirected planar graphs in the @xmath0-failure model and the decremental model , all of which require linear preprocessing time .",
    "when failures are restricted to edges , we give an especially simple connectivity oracle that processes @xmath0 edge failures ( for any @xmath0 ) in @xmath12 time and subsequently answers queries in @xmath13 time . here",
    "@xmath3 and @xmath4 refer to the time for sorting @xmath0 integers in the universe @xmath14 and @xmath4 for the time for predecessor search , given @xmath1 preprocessing time .",
    "( it is known that @xmath15 deterministically , @xmath16 randomized  @xcite , and @xmath17 randomized if @xmath18  @xcite . for predecessor search",
    "the bound is @xmath19 deterministically  @xcite and @xmath20 randomized  @xcite . )",
    "the problem becomes more complicated when vertices fail since we can not , in general , spend time proportional to their degrees .",
    "our second algorithm is a @xmath0-failure connectivity oracle for edge and vertex failures with the same parameters ( linear preprocessing , @xmath12 to process @xmath0 failures , @xmath13 time per query ) .",
    "it consists of two parts : a solution for triconnected graphs and a generic reduction from @xmath0-failure oracles in general graphs to @xmath0-failure oracles in triconnected graphs .",
    "triconnectivity plays an important role in the algorithm as it allows us to apply barnette s theorem  @xcite , which states that every triconnected planar graph contains a degree-3 spanning tree .",
    "it is known  @xcite that predecessor search is reducible to the @xmath0-edge / node failure connectivity problem on trees ( and hence planar graphs ) .",
    "our query time is therefore provably optimal .",
    "in particular , ptracu and thorup s lower bound  @xcite implies that @xmath20 query time can not be beaten in general , even given @xmath21 time to preprocess the edge / node failures .",
    "our third algorithm is in the decremental model . in triconnected planar graphs we can support vertex failures in @xmath6 amortized time and connectivity queries in @xmath6 time , whereas in general planar graphs both bounds become @xmath7 . of failures ,",
    "i.e. , in triconnected graphs processing @xmath22 failures takes @xmath23 time total . ]",
    "the logarithmic slowdown comes from a new reduction from ( planar ) dynamic subgraph connectivity to the same problem in triconnected graphs .",
    "[ [ prior - work - on - dynamic - connectivity . ] ] prior work on dynamic connectivity .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    before surveying dynamic subgraph connectivity it is instructive to see what type of `` off the shelf '' solutions are available using traditional dynamic graph algorithms .",
    "the best known dynamic connectivity algorithms for general undirected graphs require @xmath24 worst case time per edge update  @xcite or @xmath7 time amortized  @xcite .",
    "vertex updates are simulated with @xmath25 edge updates . in dynamic planar graphs",
    "the best connectivity algorithms take @xmath6 time per edge update  @xcite .    [",
    "[ prior - work - on - subgraph - connectivity . ] ] prior work on subgraph connectivity .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the dynamic subgraph model was proposed explicitly by frigioni and italiano  @xcite , who proved that in planar graphs , node failures and recoveries could be supported in @xmath26 amortized time per operation and connectivity queries in @xmath26 worst case time .",
    "an earlier algorithm of eppstein et al .",
    "@xcite implies that edge failures , edge recoveries , and connectivity queries in planar graphs require @xmath6 time .",
    "in general graphs , chan , ptracu , and roditty  @xcite ( improving  @xcite ) showed that node updates could be supported in amortized time @xmath27 , where @xmath28 is the number of edges , and connectivity queries in @xmath29 .",
    "chan et al .",
    "@xcite gave numerous applications of subgraph connectivity to geometric connectivity problems .",
    "the first algorithm with worst - case guarantees was given by duan  @xcite , who showed that node updates and queries require only @xmath30 and @xmath31 time , respectively .",
    "in the @xmath0-_edge _ failure model ptracu and thorup  @xcite gave a connectivity oracle for general graphs that processes @xmath0 failures in @xmath32 time and answers queries in @xmath33 time .",
    "however , their structure requires _ exponential _ preprocessing time ; a variant constructible in polynomial time has a slower update time : @xmath34 .",
    "duan and pettie  @xcite gave a connectivity oracle in the @xmath0-_node _ failure model occupying @xmath35 space that processes failures in @xmath36 time and answers queries in @xmath17 time , where @xmath37 depends on @xmath38 .",
    "they also showed that a @xmath0-edge failure oracle could be constructed in @xmath39 time with @xmath40 update time and @xmath33 query time .",
    "the _ distance sensitivity _ oracles avoiding 1 node failure  @xcite or 2 node failures @xcite also , as a special case , answer 1- and 2-failure connectivity queries on _ directed _ graphs in @xmath41 and @xmath6 time , respectively .",
    "these data structures occupy @xmath42 space .    [ [ overview ] ] overview + + + + + + + +    section  [ sec : defsnotres ] reviews notation and terminology . in section",
    "[ sec : multiedge ] we describe our planar @xmath0-edge failure connectivity oracle . in section  [ sec : multivertexedge ] we give a @xmath0-vertex failure oracle for triconnected planar graphs and in section  [ sec : singlevertexedge ] we extend it to a decremental subgraph connectivity oracle for triconnected graphs . finally , in section  [ sect : reduction - to - tri ] we give reductions from general graphs to triconnected graphs , which do not assume planarity .",
    "we assume that all graphs considered are undirected . a _ planar graph _ is a graph that can be drawn in the plane such that no two edges cross .",
    "we refer to such a drawing as a _ plane graph_. a plane graph @xmath43 partitions the plane into maximal open connected sets and we refer to the closure of these sets as the _ faces _ of @xmath44 . if @xmath44 is connected , we define a plane graph , called the _ dual graph _ @xmath45 of @xmath44 , as follows .",
    "associated with each face @xmath22 of @xmath44 is a vertex in @xmath45 which we identify with @xmath22 and which we draw inside @xmath22 . for each edge",
    "@xmath46 in @xmath44 , there is an edge @xmath47 in @xmath45 , where @xmath48 and @xmath49 are the faces in @xmath44 incident to @xmath46 .",
    "we draw @xmath47 such that it crosses @xmath46 exactly once and crosses no other edge in @xmath44 or in @xmath45 .",
    "we identify @xmath47 with @xmath46 .",
    "it can be shown that @xmath45 is also connected and that @xmath50 . in particular , each face in @xmath45 corresponds to a vertex in @xmath44 .",
    "we refer to @xmath44 as the _ primal _ graph .    for vertices @xmath51 and @xmath52 in a rooted tree",
    "@xmath53 , we let @xmath54 denote the lowest common ancestor of @xmath51 and @xmath52 in @xmath53 . consider a spanning tree @xmath53 in primal graph @xmath44 .",
    "it is well - known that the edges not present in @xmath53 form a spanning tree @xmath55 of @xmath45 .",
    "we call @xmath55 the _ dual tree _ of @xmath53 .",
    "the following lemma is a well - known result  @xcite .",
    "[ lem : primalduallink ] for an edge @xmath46 in primal tree @xmath53 , let @xmath22 and @xmath56 be the faces to either side of @xmath46 in @xmath44 .",
    "then the edges of @xmath57 that connect the two subtrees of @xmath58 are exactly those on the simple path in @xmath55 from @xmath22 to @xmath56 .",
    "a co - path is a sequence of faces that is a sequence of vertices in the dual that form a path .",
    "a co - path _ avoids _ a set of edges @xmath8 if every consecutive pair of faces in the sequence shares an edge not in @xmath8 .",
    "in this section , we develop a data structure that , given a planar undirected graph @xmath43 , an integer @xmath59 , and a dynamic subset of at most @xmath0 _ failed edges _ , supports the following operations :          if @xmath51 and @xmath52 are connected in @xmath62 , then there is a @xmath51-to-@xmath52 path @xmath63 in @xmath44 not using any edges in @xmath8 .",
    "this path , viewed as a sequence of vertices in @xmath44 is a sequence of faces , or co - path , in @xmath45 .",
    "since consecutive vertices in @xmath63 are adjacent by way of edges not in @xmath8 , consecutive faces in the identified co - path share an edge not in @xmath8 : this @xmath51-to-@xmath52 co - path avoids @xmath8 .",
    "conversely , let @xmath63 be a @xmath51-to-@xmath52 co - path avoiding @xmath8 .",
    "@xmath63 is a sequence of faces in @xmath45 , and so is a sequence of vertices in @xmath44 .",
    "consecutive faces on @xmath63 in @xmath45 share an edge avoiding @xmath8 and so are adjacent by way of edges not in @xmath8 : @xmath63 is a path in @xmath44 not using any edges in @xmath8 .",
    "consider the subgraph @xmath64 of @xmath45 consisting of the failed edges , @xmath8 .",
    "let @xmath64 inherit the embedding of @xmath45 .",
    "we refer to the faces of @xmath64 as _",
    "each superface corresponds to the union of faces of @xmath45 .",
    "[ lem : superfaces ] let @xmath22 and @xmath56 be faces of @xmath45 .",
    "there is an @xmath22-to-@xmath56 co - path in @xmath45 avoiding @xmath8 iff @xmath22 and @xmath56 are contained in the same superface of @xmath64 .",
    "suppose @xmath22 and @xmath56 are contained in different superfaces ; let @xmath65 be the set of edges that bound the superface containing @xmath22 .",
    "any @xmath22-to-@xmath56 co - path requires a face on either side of @xmath65 and so can not avoid @xmath65 , which is a subset of @xmath8 .",
    "suppose otherwise ; let @xmath66 be the set of faces of @xmath45 that form the superface @xmath67 containing @xmath22 and @xmath56 . since @xmath67 is a face of @xmath64 , there is a curve @xmath68 contained entirely in @xmath67 that starts inside @xmath22 and ends inside @xmath56 .",
    "consider the sequence of faces in @xmath66 that this path visits ; this is an @xmath8-avoiding @xmath22-to-@xmath56 co - path as consecutive faces must share an edge that @xmath68 crosses and this edge can not be in @xmath8 .",
    "fix a rooted spanning tree @xmath53 of the primal graph @xmath44 .",
    "we use @xmath53 to determine the superfaces of @xmath64 containing the faces corresponding to the query vertices @xmath51 and @xmath52 . to do so",
    ", we require constant - time lca query support for @xmath53  @xcite .",
    "the edges @xmath8 are listed in no particular order .",
    "we start by building the planar embedding of the subgraph @xmath64 induced by @xmath8 that is inherited from @xmath45 .",
    "let @xmath69 be the endpoints of @xmath8 ( in the dual sense ) .",
    "for each vertex @xmath70 identify the edges of @xmath8 incident to @xmath52 and their cyclic ordering in @xmath45 .",
    "we can compute these orderings in @xmath1 time .",
    "the boundaries of the superfaces given by @xmath64 can be traversed in @xmath17 time given this combinatorial embedding .",
    "the set @xmath69 is the set of faces of @xmath45 that are along the boundaries of superfaces of @xmath64 .",
    "label a dual face / primal vertex in @xmath69 with the superface that contains it ; mark the vertices of the static tree @xmath53 with these superface labels .      to answer a query",
    "` connected?`@xmath61 , suppose we have identified the first and last marked vertices ( if any ) on the @xmath51-to-@xmath52 path in @xmath53 ; call them @xmath71 and @xmath72 . by lemmas  [ lem : facepath ] and  [ lem : superfaces ] , @xmath51 and @xmath52 are connected in @xmath62 iff @xmath71 and @xmath72 do not exist , or @xmath71 and @xmath72 are labelled with the same superface .",
    "therefore , we need only identify @xmath71 and @xmath72 , if they exist .",
    "lemma  [ lem : marked - ancestor ] shows that finding @xmath71 and @xmath72 is reducible to one least common ancestor query and @xmath41 predecessor queries .",
    "[ lem : marked - ancestor ] let @xmath53 be a tree of size @xmath73 and @xmath74 be a set of _ marked _ vertices , with @xmath75 . then after @xmath25 preprocessing ( independent of @xmath76 ) , an @xmath17-size data structure can be constructed in @xmath12 time that answers the following query in @xmath13 time : given @xmath77 , what are the first and last @xmath76-vertices on the @xmath51-@xmath52 path ?",
    "recall that @xmath53 is rooted .",
    "let @xmath78 .",
    "the first marked vertex on the @xmath51-to-@xmath52 path is either the first marked vertex on the @xmath51-to-@xmath79 path or the last marked vertex on the @xmath52-to-@xmath79 path .",
    "thus , we can assume without loss of generality that @xmath52 is an ancestor of @xmath51 .",
    "fix an arbitrary dfs of @xmath53 and let @xmath80 ( resp .",
    "@xmath81 ) be the time when @xmath82 is pushed onto ( resp .  popped off ) the stack during dfs . given @xmath76 , we first sort the @xmath83 and @xmath84 indices of its elements , in @xmath12 time , which allows us to label each @xmath85 with the nearest strictly ancestral @xmath76-vertex @xmath86 .",
    "here it is convenient to assume that the root is marked ( honorarily , if not in @xmath76 ) so @xmath86 is defined everywhere except the root .",
    "we build a global predecessor structure on the set @xmath87 and local predecessor structures on the sets @xmath88 , where @xmath85 and @xmath89 is the set of `` immediate '' descendants in @xmath76 connected by a path of non-@xmath76 vertices . to answer a query @xmath90 ( where @xmath52 is ancestral to @xmath51 ) we first find the closest marked ancestors @xmath91 as follows .",
    "let @xmath92 be the predecessor of @xmath93 in @xmath94 . if @xmath95 for some @xmath96 then @xmath82 is an immediate descendant of @xmath97 and @xmath98 .",
    "if @xmath99 then let @xmath100 . see figure  [ fig : marked - ancestor](a ) .",
    "it follows that @xmath101 is an ancestor of @xmath51 and that there are no other @xmath76-vertices on the path from @xmath51 to @xmath101 .",
    "if @xmath101 is ancestral to @xmath52 then there are no marked nodes on the @xmath51-@xmath52 path , so assume this is not the case .",
    "in order to find the _ last _ marked vertex on the path from @xmath51 to @xmath52 we search for the predecessor of @xmath93 in @xmath102 , say @xmath103 .",
    "since there is _ some _ marked vertex on the path from @xmath51 to @xmath104 it follows that @xmath51 is a descendant of @xmath97 , which is a descendant of @xmath52 and that there are no other marked vertices on the path from @xmath97 to @xmath52 .",
    "see figure  [ fig : marked - ancestor](b ) .",
    "an @xmath105 tree @xmath106 represents how a biconnected graph @xmath44 is assembled form its triconnected components through _ merging _ operations .",
    "all separating pairs of @xmath44 are given implicitly by @xmath106 .",
    "let @xmath107 and @xmath108 be two edge - labeled multigraphs , where @xmath109 and where @xmath110 appears in both @xmath111 and @xmath112 with the same label .",
    "then _ merging _ @xmath107 and @xmath108 results in a new graph @xmath113 .",
    "that is , @xmath46 does not appear in the merged graph but @xmath82 and @xmath97 may still be adjacent in @xmath114 if there were multiple edges between @xmath82 and @xmath97 in either @xmath107 or @xmath108 .",
    "each node @xmath115 is associated with a triple @xmath116 , where @xmath117 is the _ model _ graph , one edge @xmath118 is distinguished as the _ polar edge _ whose endpoints are _",
    "poles_. let @xmath119 be the parent of @xmath51 in @xmath106 and @xmath120 the subtree rooted at @xmath51 .",
    "the graphs @xmath117 and @xmath121 have exactly two vertices in common , namely the endpoints of @xmath122 , and each contains identically labeled copies of @xmath122 .",
    "moreover , for any two @xmath106-nodes on opposite sides of the edge @xmath123 , their model trees do not intersect , except possibly at the poles of @xmath122 .",
    "the graph @xmath124 is formed by merging all model trees in @xmath120 .",
    "that is , @xmath51 has children @xmath125 where @xmath126 and @xmath127 contains the polar edge @xmath128 .",
    "obtain @xmath124 by merging @xmath129 with @xmath117 along the polar edges @xmath130 .",
    "( observe that the polar edge @xmath131 remains in @xmath132 . )",
    "let @xmath133 be @xmath124 without its polar edge @xmath122 .",
    "the tree @xmath106 is conceptually constructed in a top - down fashion as follows .",
    "( linear time triconnectivity algorithms  @xcite can be used to construct @xmath106 . ) the root @xmath134 is associated with @xmath135 and an arbitrary polar edge @xmath136 . in general , we are given a @xmath106-node @xmath51 and pair @xmath137 .",
    "we must select a model multigraph @xmath117 and then recursively construct the subtree @xmath120 .",
    "the reader may want to refer to an illustration of a graph and its @xmath105-tree in figure  [ fig : spqr ] .",
    "the endpoints of @xmath138 split @xmath132 into @xmath139 components @xmath140 where @xmath141 .",
    "let @xmath127 be @xmath142 augmented with a freshly labeled polar edge @xmath143 and let @xmath117 consist of @xmath139 parallel edges @xmath144 . clearly merging @xmath129 with @xmath117 yields",
    "@xmath124 . for each nontrivial @xmath142 ( nontrivial means having more than one edge ) , create a new child @xmath145 of @xmath51 and recursively compute its subtree in @xmath106 .",
    "trees  @xcite trivial graphs are actually assigned to children of @xmath51 . they are called @xmath146-nodes . ]",
    "let @xmath138 and let @xmath147 be the articulation points of @xmath133 .",
    "if there are any such points ( @xmath141 ) let @xmath148 be the partition of @xmath124 into edge - disjoint subgraphs such that @xmath142 and @xmath149 meet at @xmath150 .",
    "let @xmath117 be the cycle @xmath151 and let @xmath127 be @xmath142 augmented with a polar edge @xmath152 ( where @xmath153 ) , whose label matches the corresponding edge in @xmath154 .",
    "for each non - trivial @xmath142 form a new child @xmath145 of @xmath51 and recursively compute its subtree in @xmath106 .",
    "the previous two cases do not apply . a separating pair @xmath156 of @xmath124 splits it into some number of components @xmath157 with @xmath158 .",
    "let @xmath159 and @xmath160 be the union of @xmath161 . call @xmath162 _",
    "maximal _ if there is no separating pair @xmath163 for which @xmath164 is strictly contained in @xmath165 .",
    "let @xmath166 be the set of @xmath167 maximal separating pairs with respect to @xmath122 .",
    "we give @xmath51 children @xmath125 where @xmath145 is given the graph @xmath168 and polar edge @xmath128 .",
    "the model graph @xmath117 is induced by @xmath169 , that is , it is obtained from @xmath124 be replacing @xmath170 with the @xmath145 s polar edge @xmath128 , for all @xmath92 .",
    "the maximality of the separating pairs ensures that @xmath171 is triconnected , also called _",
    "rigid_.      the edges in a model graph @xmath117 that do not appear in @xmath44 are _ artificial _ and represent paths in @xmath44 .",
    "our goal is to reduce a connectivity query in @xmath44 to a constant number of connectivity queries in model graphs , so it is important that we identify the set of invalidated artificial edges .",
    "let @xmath172 , where @xmath173 , be the _ most _ ancestral @xmath106-node @xmath51 for which @xmath174 and let @xmath175 .",
    "( note that @xmath176 can appear in an unbounded number of model trees as a pole . )",
    "we begin by coloring _",
    "those @xmath106-nodes @xmath51 for which the endpoints of @xmath122 may be disconnected in @xmath177 . specifically , repeatedly color blue any @xmath51 satisfying one of the following criteria :    1 .",
    "@xmath178 for some @xmath179 .",
    "@xmath51 is an @xmath66-node with at least one blue child .",
    "( @xmath180 is a path , so the removal of one vertex or edge disconnects @xmath51 s poles . )",
    "@xmath51 is either an @xmath155- or @xmath63-node with at least two blue children .",
    "( there are at least two internally vertex - disjoint paths between the endpoints of @xmath122 in @xmath180 , so the removal of just one vertex or edge can not disconnect @xmath51 s poles . )      there are clearly at most @xmath0 blue nodes due to criterion ( 1 ) and at most @xmath182 due to criterion ( 3 ) . since , by observation  [ obs : psnodes ] , there are no adjacent @xmath66-nodes , the number due to criterion ( 2 ) is no more than the number due to criteria ( 1 ) and ( 3 )",
    ". they can be found in @xmath17 time as follows .",
    "for each @xmath179 color @xmath172 blue and continue to color any immediate ancestors blue if they satisfy criteria ( 2 ) or ( 3 ) .",
    "the first ancestor not colored blue is noted as having one blue child .",
    "the time per @xmath8-node is @xmath41 plus the number of formerly uncolored ancestors colored blue .",
    "next we color _ purple _ all blue nodes @xmath51 for which the poles of @xmath138 are disconnected in @xmath177 ( that is , ignoring parts of the graph outside @xmath51 s subtree ) , as follows . traverse the blue nodes in @xmath106 in postorder .",
    "if either of @xmath183 or @xmath184 is in @xmath8 then they are trivially disconnected , so color @xmath51 purple .",
    "if @xmath51 is a @xmath63-node then @xmath183 and @xmath184 are still connected if they are connected in _",
    "any _ child of @xmath51 , so color @xmath51 purple if all its children are purple .",
    "if @xmath51 is an @xmath66-node then @xmath183 and @xmath184 are disconnected if the poles of any child @xmath145 of @xmath51 are disconnected , so color @xmath51 purple if any child is purple . finally , if @xmath51 is an @xmath155-node , construct a connectivity oracle @xmath185 for @xmath117 avoiding vertex failures @xmath186 and edge failures @xmath187 .",
    "( the edge failures reflect the fact that the polar edges of purple children are definitely invalidated by the failures and it is not yet known if @xmath122 is invalidated . ) perform one query on @xmath185 to determine if @xmath188 are disconnected in @xmath177 and , if so , color @xmath51 purple .",
    "we also construct connectivity oracles for each colored @xmath66- and @xmath63-node @xmath51 in @xmath189 .",
    "this is trivial if @xmath51 is a @xmath63-node .",
    "( @xmath117 contains two vertices , which are either connected or not . )",
    "if @xmath51 is an @xmath66-node then @xmath117 is a cycle and a connectivity query can be answered with predecessor search , in @xmath2 time .",
    "the time to construct oracles for all colored nodes is @xmath190 .",
    "each colored node @xmath51 can contribute one edge failure to @xmath192 , namely the polar edge @xmath122 .",
    "note that @xmath186 can include at most two additional vertices than @xmath193 , namely the poles of @xmath122 .",
    "thus , the total number of failures is linear in @xmath0 and the number of colored nodes , which are fewer than @xmath181 .",
    "let @xmath194 be the farthest ancestral pole reachable from @xmath173 , or @xmath176 if there is no such pole .",
    "specifically , let @xmath115 be the farthest ancestor of @xmath172 such that @xmath176 is connected to either pole in @xmath122 in @xmath195 .",
    "if there is no such @xmath51 ( @xmath176 is disconnected from @xmath196 ) then @xmath197 and if @xmath176 is connected to both poles @xmath122 then @xmath194 can be either one .",
    "our goal is to preprocess @xmath8 so that we can quickly evaluate @xmath198 .",
    "let @xmath199 be either pole in @xmath196 connected to @xmath176 in @xmath200 , or undefined if there is no such pole .",
    "let @xmath201 be the farthest ancestral pole reachable from @xmath176 via uncolored @xmath106 nodes , defined precisely as follows .",
    "if @xmath202 and @xmath51 is colored then @xmath201 is undefined . if @xmath51 is uncolored and @xmath176 is disconnected from both of @xmath51 s poles ( this can only happen",
    "if they are in the failure set ) then @xmath201 is undefined .",
    "otherwise let @xmath203 be the farthest ancestor of @xmath51 such that the @xmath106-path from @xmath51 to @xmath203 is uncolored and at least one pole of @xmath203 is not in @xmath8 .",
    "then @xmath201 is any non-@xmath8 pole of @xmath203 . by lemma  [ lem : marked - ancestor ]",
    ", @xmath106 can be preprocessed in @xmath1 time to support @xmath204 queries in @xmath2 time .      1 .   if @xmath179 then @xmath194 is undefined .",
    "2 .   if @xmath51 is the root of @xmath106 or is a colored node without a colored ancestor then @xmath194 is a pole of the root of @xmath106 .",
    "3 .   if @xmath172 is colored then let @xmath197 if @xmath199 is undefined ( it is disconnected from both poles of @xmath172 ) and @xmath205 otherwise .",
    "4 .   if @xmath172 is uncolored then let @xmath197 if @xmath201 is undefined ( it is disconnected from both poles of @xmath172 ) or @xmath201 if @xmath206 is undefined ( @xmath201 is disconnected from both poles of @xmath207 ) or @xmath208 otherwise",
    ".        the query asks whether @xmath82 and @xmath210 are connected in @xmath11 , where @xmath211 .",
    "our goal is to reduce this to @xmath41 connectivity queries to the oracles associated with colored @xmath106-nodes .",
    "let @xmath212 if @xmath213 is uncolored and @xmath82 if @xmath213 is colored .",
    "it follows that @xmath214 is colored . using two connectivity queries on @xmath215 s oracle ( between @xmath216 and the poles of @xmath215 ) determine @xmath217 .",
    "if @xmath218 is defined let @xmath219 ; otherwise let @xmath220 .",
    "it follows directly from the definitions of @xmath221 and @xmath198 that @xmath222 is the most ancestral pole connected to @xmath82 , or is @xmath82 if there is no such pole . in any case",
    "let @xmath223 and define @xmath224 analogously , with respect to @xmath210 .",
    "[ lem : ] vertices @xmath82 and @xmath210 are connected in @xmath11 if and only if @xmath225 and @xmath226 and @xmath227 are connected in @xmath11 .",
    "it requires @xmath228 time to answer a connectivity query .",
    "note that by definition of @xmath221 and @xmath198 , @xmath82 is connected to @xmath216 , @xmath216 is connected to @xmath218 ( if it exists ) , and @xmath218 is connected to @xmath226 , hence @xmath82 is connected to @xmath226 .",
    "thus , @xmath82 and @xmath210 are connected if and only if @xmath226 and @xmath227 are connected , which is determined by @xmath229 s oracle if @xmath225 .",
    "( note that @xmath229 is either colored and we have such an oracle , or @xmath229 is the uncolored root and @xmath230 . )",
    "observe that if @xmath229 is not the root , @xmath226 is , by definition of @xmath198 , disconnected from the poles @xmath231 , and therefore also disconnected from _ every _ vertex in @xmath232 .",
    "the same is true of @xmath227 and @xmath233 . if @xmath234 then either @xmath235 or @xmath236 , that is , @xmath226 and @xmath227 must be disconnected .",
    "we prove theorem  [ thm : reduction - to - tri - fully - dynamic ] assuming , for notational simplicity , that the graph is biconnected and associated with an @xmath105-tree @xmath106 .",
    "it is easy to extend this algorithm to all graphs .",
    "an obvious strategy is to maintain the structure from section  [ sect : bi - to - tri ] , that is , to maintain the ability to evaluate @xmath204 on all vertices , @xmath238 on vertices in colored @xmath106-nodes , and @xmath198 on the poles of colored nodes .",
    "the first difficulty is that a vertex failure @xmath176 at some @xmath172 deep in @xmath106 can cause virtual edge failures in the model graphs of _ every _ ancestor of @xmath172 and potentially change the colored / uncolored status of such nodes .",
    "thus , we can not afford to explicitly maintain connectivity oracles at each colored node .-",
    "nodes this is equivalent to dynamic and - or tree evaluation . ]",
    "if we do not maintain explicit connectivity oracles then evaluating @xmath194 seems impossible since it is a function of @xmath41 @xmath238-queries at _ each _ colored ancestor of @xmath172 .",
    "our solution involves three main ideas .",
    "the first is to partition @xmath106 into heavy paths , a standard technique that ensures every node - to - root path intersects at most @xmath239 distinct paths .",
    "this introduces a @xmath240-factor overhead and reduces the problem to one on paths , yet it does not help us stop changes deep in @xmath106 from propagating upwards .",
    "two consecutive nodes @xmath51 and @xmath119 on a heavy path share two vertices , namely @xmath122 .",
    "our second idea is to make @xmath119 indifferent to _ all _ changes in @xmath241 by having it maintain two candidate connectivity oracles , one where @xmath122 is invalid ( its endpoints are disconnected in @xmath195 ) and one where @xmath122 is valid .",
    "this solves the propagation problem , but we must be able to determine which of @xmath119 s candidate oracles reflects the _ actual _ failure set @xmath8 .",
    "the third idea is to reduce a @xmath198-query to @xmath6 1d product queries over the domain of @xmath242 boolean matrices .",
    "updates and queries to such a structure will take @xmath243 time .",
    "let each nonleaf @xmath115 choose a child @xmath244 maximizing the number of descendants of @xmath244 .",
    "these choices partition the nodes of @xmath106 into a set @xmath245 of _ heavy paths _ such that all leaf - to - root paths intersect at most @xmath240 such paths .",
    "let @xmath246 be the heavy path containing @xmath51 and @xmath247 be the most ancestral node in @xmath246 .",
    "define @xmath248 to be the _ subpolar edge _ of @xmath51 let @xmath249 be the subgraph of @xmath133 induced by @xmath250 , that is , @xmath133 excluding vertices in @xmath251 .",
    "each non - leaf @xmath115 maintains two connectivity oracles for @xmath133 based on the current set @xmath8 of failed vertices .",
    "let @xmath252 be the failed vertices in @xmath253 , excluding the poles @xmath122 , if @xmath51 is not the root of @xmath106 .",
    "let @xmath254 and @xmath255 reflect versions of reality where all or none of the vertices in @xmath244 s subtree fail .",
    "the oracle @xmath256 answers connectivity queries between @xmath257 vertices in the graph @xmath258 whereas @xmath259 is defined with respect to @xmath260 .",
    "if we restrict our attention to connectivity in @xmath257 , at least one of @xmath259 and @xmath256 behaves correctly , with respect to the failure set @xmath261 . in order to determine which one is correct",
    "let us dispense with the old blue / purple / uncolored coloring system - nodes these colors since @xmath51 may be colored purple according to @xmath259 but not @xmath256 . ] from section  [ sect : bi - to - tri ] and designate _ all _ @xmath106-nodes _ white _ , _ grey _ , or _",
    "black_. a node @xmath51 is white if the poles @xmath122 are disconnected according to @xmath256 , black if they are connected according to @xmath259 , and gray if they are connected according to @xmath256 but not @xmath259 . in other words , in a gray @xmath51 , all paths between @xmath122 in @xmath262 go through the subpoles @xmath263 .",
    "if @xmath51 is a leaf it has no subpoles and therefore can not be gray , since @xmath264 . before continuing ,",
    "let us note that before any vertex failures occur , all non - leaf @xmath66-nodes are gray ( removing @xmath122 and @xmath263 disconnects the poles in @xmath117 , which is a cycle ) and all @xmath63- and @xmath155-nodes are black since there are at least three edge - disjoint paths between @xmath122 in @xmath117 .    in order to determine whether the poles @xmath122 are actually connected in @xmath262 it suffices to maintain a predecessor structure on all non - gray nodes in @xmath246 , which we view as oriented towards @xmath265 .",
    "let @xmath101 be the predecessor of @xmath51 on @xmath246 , that is , the first non - gray descendant of @xmath51 on @xmath246 , which may be @xmath51 itself .",
    "( there must be such a @xmath101 since leaves can not be gray . )",
    "if @xmath101 is black then the poles @xmath122 are connected in @xmath262 , and if white , they are not .",
    "it takes @xmath33 time per query or to delete / insert any node into the predecessor structure , which corresponds to a color transition to / from gray .",
    "consider the failure or recovery of a vertex @xmath176 with @xmath266 and @xmath267 .",
    "this change might cause the color of @xmath51 to change , but , by definition , can not invalidate the color of any other @xmath268 .",
    "now consider @xmath269 , if @xmath270 is not already the root of @xmath106 .",
    "the twin connectivity oracles for @xmath52 entertain the possibility that @xmath271 is invalid or valid , but both must represent the _ actual _ validity of the edge @xmath272 , which may have changed due to the failure / recovery of @xmath176 .",
    "thus , changing the status of @xmath176 may affect @xmath52 but no other nodes on @xmath273 and , in general , affects up to one node on each heavy path traversed from @xmath172 to the root of @xmath106 .",
    "suppose @xmath274 is a heavy path .",
    "if we are only concerned with connectivity between poles of nodes in @xmath63 , each node @xmath145 is effectively in one of 16 states depending on whether each pole in @xmath275 is connected , in the graph @xmath276 , to each pole in @xmath128 .",
    "let @xmath277 be a @xmath242 boolean matrix representing this connectivity .",
    "( in other words , a node s poles are ordered in some consistent fashion to map to rows and columns . )",
    "it follows that the boolean product @xmath278 represents the connectivity between @xmath275 and @xmath279 in the graph @xmath280 .",
    "our algorithm for computing @xmath194 ( and answering connectivity queries ) requires a dynamic data structure for answering various product queries .    1 .   `",
    "init`@xmath281 : set @xmath282 , for @xmath283 .",
    "update`@xmath284 : @xmath285 , where @xmath286 is a @xmath242 boolean matrix .",
    "product`@xmath287 : return @xmath288 .",
    "search`@xmath289 : return @xmath290 , given boolean row vector @xmath82 and @xmath242 mask @xmath210 .",
    "( sketch ) each @xmath277 requires 4 bits to represent , so @xmath293 matrices can be packed into one machine word .",
    "we maintain a @xmath293-way tree over the array , where @xmath294 are at the leaves and internal nodes store the product of their descendant leaves .",
    "all operations either need to update or retrieve @xmath41 words of information at each of @xmath295 levels , which can be done in @xmath295 time by tabulating various functions on @xmath293 bits in advance , in @xmath291 time .",
    "define @xmath296 for @xmath297 , to be the pole most ancestral to @xmath172 connected to @xmath176 in @xmath298 , or @xmath176 if there is no such pole . if @xmath296 is not a pole of @xmath270 then clearly @xmath299 .",
    "in general a @xmath194 query is easily reduced to @xmath240 @xmath300 queries , for the heavy paths @xmath63 intersecting the path from @xmath172 to the root of @xmath106 , so we shall focus our attention solely on evaluating @xmath296 , where @xmath301 .",
    "we compute @xmath296 as follows .    1 .",
    "our first task is to determine the boolean vector @xmath82 representing the connectivity between @xmath176 and the poles @xmath128 in @xmath302 . using one predecessor query on the non - gray nodes in @xmath63 we determine which @xmath303 reflects reality , where @xmath304 , then determine @xmath82 with two connectivity queries to @xmath303 .",
    "if @xmath305 then let @xmath306 and halt .",
    "otherwise let @xmath307 ` search`@xmath308 .",
    "let @xmath309 be the poles reachable from @xmath176 in @xmath310 .",
    "it follows that @xmath176 is disconnected from both poles of @xmath311 in @xmath312 , if @xmath313 .",
    "if there is some pole in @xmath314 let @xmath296 be any such pole and halt .",
    "( recall that @xmath315 is the set of failures in @xmath316 _ excluding _ its poles . )",
    "if the procedure has not halted then @xmath317 .",
    "for any index @xmath318 let @xmath319 .",
    "without loss of generality suppose @xmath320 , and that @xmath321 $ ] is the minimum index such that @xmath322 and , if @xmath323 , @xmath324 .",
    "( recall that a pole can appear in an unbounded number of nodes along @xmath63 . )",
    "at least one of the poles in @xmath325 is connected to @xmath176 .",
    "if @xmath326 is disconnected from @xmath176 then @xmath296 can be either pole of @xmath325 connected to @xmath176 .",
    "otherwise @xmath296 is the most ancestral pole among @xmath327 connected to @xmath176 , which can be found as follows .",
    "let @xmath328 `",
    "search`@xmath329 , where the first and second arguments encode that we are only interested in connectivity between @xmath327 . if @xmath330 then @xmath331 , otherwise @xmath332 where @xmath333 is the maximum index such that @xmath334 .",
    "the time bounds claimed in theorem  [ thm : reduction - to - tri - fully - dynamic ] follow easily .",
    "it takes linear time to build the @xmath105-tree , decompose it into heavy paths , build the white / black predecessor structure and boolean product structure on each heavy path , and augment it with various pointers , e.g. , pointers from each node to the root of its heavy path .",
    "a vertex update on @xmath176 induces vertex updates in the oracles @xmath335 and @xmath336 , updates to the color and @xmath242 matrix of @xmath172 , which take @xmath243 time , then @xmath6 edge updates in ancestors of @xmath172 together with @xmath6 color and matrix updates . a query on @xmath337 amounts to computing a connectivity query between @xmath338 and @xmath339 .",
    "a @xmath198 evaluation reduces to @xmath240 @xmath300 evaluations , which involve a constant number of queries and operations on the matrix product data structure , for a total time of @xmath340 ."
  ],
  "abstract_text": [
    "<S> we consider dynamic subgraph connectivity problems for planar undirected graphs . in this model </S>",
    "<S> there is a fixed underlying planar graph , where each edge and vertex is either `` off '' ( failed ) or `` on '' ( recovered ) . we wish to answer connectivity queries with respect to the `` on '' subgraph . </S>",
    "<S> the model has two natural variants , one in which there are @xmath0 edge / vertex failures that precede all connectivity queries , and one in which failures / recoveries and queries are intermixed .    </S>",
    "<S> we present a @xmath0-failure connectivity oracle for planar graphs that processes any @xmath0 edge / vertex failures in @xmath1 time so that connectivity queries can be answered in @xmath2 time . </S>",
    "<S> ( here @xmath3 and @xmath4 are the time for integer sorting and integer predecessor search over a subset of @xmath5 $ ] of size @xmath0 . ) </S>",
    "<S> our algorithm has two discrete parts . </S>",
    "<S> the first is an algorithm tailored to triconnected planar graphs . </S>",
    "<S> it makes use of barnette s theorem , which states that every triconnected planar graph contains a degree-3 spanning tree . </S>",
    "<S> the second part is a generic reduction from general ( planar ) graphs to triconnected ( planar ) graphs . </S>",
    "<S> our algorithm is , moreover , provably optimal . </S>",
    "<S> an implication of ptracu and thorup s lower bound on predecessor search is that no @xmath0-failure connectivity oracle ( even on trees ) can beat @xmath2 query time .    </S>",
    "<S> we extend our algorithms to the subgraph connectivity model where edge / vertex failures ( but no recoveries ) are intermixed with connectivity queries . in triconnected planar graphs </S>",
    "<S> each failure and query is handled in @xmath6 time ( amortized ) , whereas in general planar graphs both bounds become @xmath7 . </S>"
  ]
}