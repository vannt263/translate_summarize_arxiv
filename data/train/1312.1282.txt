{
  "article_text": [
    "quantum monte carlo ( qmc ) is an umbrella term for a family of first - principles methods for solving quantum many - body problems .",
    "these are the methods of choice for describing correlated quantum liquids and solids , with a wide range of applications @xcite .",
    "the methods scale well and can be used on systems with hundreds and even thousands of particles .",
    "qmc is nonetheless computationally expensive , creating a demand for efficient parallelization schemes . in this work we present a parallelization of qmc for graphical processing units ( gpu ) .",
    "a gpu processor is built with a number of transistors which is comparable to that of a modern cpu , but allocates more transistors to the arithmetic logical units , commonly called single processor cores .",
    "a gpu from the nvidia kepler family , for example , hosts over two thousand such `` cores '' . when properly programmed",
    ", gpus allow to execute numerical algorithms with significant acceleration .",
    "however , the large number of gpu cores are created in expense of the cache memory and control units .",
    "the challenge is to supply such a large number of cores with enough workload and to avoid serialization .",
    "several groups reported successful attempts of gpu parallelization for quantum monte carlo @xcite .",
    "most of these works relate to qmc methods that either operate in the second quantization formalism or use an expansion in finite basis sets and thus find their bottlenecks in operations on very large matrices , or even in the generation of pseudorandom number sequences @xcite .",
    "the method that is considered here uses the real - space representation , and the numerical challenges lie in the calculation of pair distances , estimation of wavefunctions and expectation values .",
    "numerically , qmc in space representation is rather different from the above methods .    while the real - space representation for qmc is a wide - spread approach , gpu parallelization of such methods has only been reported in refs .",
    "anderson , goddard , and schrder described their gpu efforts in 2007 @xcite .",
    "this early implementation masked the data structures as graphical objects and used a gpu to process them .",
    "such an approach necessarily had significant limitations . nevertheless , anderson et al.achieved acceleration , comparing to a single - core execution , of up to a factor of @xmath2 .",
    "it was concluded in @xcite that the amdahl law @xcite imposed limitations to the achieved acceleration .",
    "that is , the serial load represented a significant bottleneck .",
    "presently , gpu may be programmed with specially designed languages , most notably with cuda for nvidia gpus .",
    "recently , elser , kim , ceperley , and shulenburger reported a cuda implementation for the qmcpack package @xcite .",
    "compared to the execution on four cores of a xeon processor , the gpu - parallelized code ran up to @xmath3 times faster .",
    "the works @xcite established certain approaches , in particular , a successful use of the mixed precision for representing floating point numbers .",
    "it should be noted that while both of refs .",
    "@xcite considered both variational and diffusion monte carlo , this work is limited to variational monte carlo ( vmc ) .",
    "also , both of refs .",
    "@xcite treated fermionic wavefunctions for electrons . the present work deals with a bosonic quantum liquid , and uses liquid ^4^he  as an example .",
    "it should be noted that the nature of numerical challenges differs significantly for the fermionic problems , which require a determinant wavefunction .",
    "our bosonic wavefunction is a jastrow product of pair correlation factors .",
    "a good numerical throughput on the gpu became possible only after several enhancements .",
    "in particular , asynchronous walker writeouts from gpu to host memory allowed to limit reloading of walkers into the shared memory of the gpu .",
    "as the essential data remains loaded into high - level memory of the gpu , the gpu proceeds generating new configurations without delay .",
    "for the new kepler family of nvidia gpus , we made use of its very large register space , allowing for better occupancy of the gpu and for the simulation of significantly larger systems .",
    "asynchronous kernel execution allowed masking of the cpu load by the gpu run times , thus partially circumventing the amdahl limit .",
    "these and several other features are described in detail below , and a working minimal code is provided .",
    "for a review of quantum monte carlo , readers may refer to refs .",
    "the variational monte carlo relies on the variational principle which states that for any approximate wavefunction @xmath4 of a system with hamiltonian @xmath5 , its ground - state energy @xmath6 is bounded from above by @xmath7 minimization of the r.h.s .  of eq .",
    "( [ eq : ritz ] ) with respect to @xmath4 yields an upper bound for the ground state energy @xmath6 .",
    "optimized trial wavefunction @xmath4 may be taken as the best guess for the true ground state of the system .",
    "physical properties are extracted by evaluating the expectation values of their corresponding quantum operators , @xmath8 in particular , optimization of the trial wavefunction is the minimization of @xmath9 . the optimized variational wavefunction is also used for importance sampling in first - principles many - body calculations , in particular the diffusion monte carlo @xcite and sometimes for the path integral ground state monte carlo @xcite .",
    "the trial wavefunction @xmath4 is defined through a set of _ variational parameters _ @xmath10 and the minimization implied by eq .",
    "( [ eq : ritz ] ) is performed with respect to these parameters . using a real space representation of the many - body wavefunction @xmath4 , @xmath11 where @xmath12 through @xmath13 denote coordinates of all particles in the system . in variational monte carlo , the multidimensional integral ( [ eq : mainintegral ] )",
    "is evaluated via a monte carlo integration scheme , and this constitutes the numerical challenge of the method .",
    "the monte carlo integration of eq .",
    "( [ eq : mainintegral ] ) is carried out by sampling of the configuration space@xmath14 with probability proportional to the non - negative density @xmath15 @xcite .",
    "normalization implies that the distribution of samples in the configuration space follows the probability density given by @xmath16 averaging over this distribution the _ local value _ of an operator , defined as @xmath17 yields the integral of eq .",
    "( [ eq : mainintegral ] ) and thus the operator s expectation value ( [ eq : opexpectation ] ) .    in this work , the distribution of eq .",
    "( [ eq : probability ] ) is sampled with the metropolis scheme @xcite .",
    "the position in the configuration space @xmath18 is transformed to a position @xmath19 and the new position is accepted with probability equal to the ratio of the probability densities in the transformed and original configurations .",
    "thus the updated configuration is taken as @xmath20 where @xmath21 is a pseudorandom number uniformly distributed on @xmath22 $ ] .",
    "the markov chain produced with the acceptance criterion ( [ eq : decision ] ) provides configurations distributed according to the desired probability density ( [ eq : probability ] ) .",
    "we aim to describe the bulk properties of liquid helium-4 . with a very good accuracy ,",
    "helium atoms may be considered particle - like with a known pairwise interaction .",
    "the hamiltonian is given by @xmath23 where @xmath24 is the mass of the ^4^he  atom , @xmath25 is the number of atoms in the system , and @xmath26 is the distance between particles @xmath27 and @xmath28 . for the pairwise interaction @xmath29 , we will use hfd - b(he ) ( known as aziz - ii ) interatomic potential @xcite .",
    "the form of the wavefunction which we implemented is a widely used jastrow product of pair correlation factors @xcite , @xmath30 the choice of wavefunction fully defines the probability density for the metropolis sampling in variational monte carlo , according to eq .",
    "( [ eq : decision ] ) .",
    "we have implemented the parallelization for single - particle updates , where only one atom is displaced at a time to form the new configuration @xmath31 .",
    "the transformed ( trial ) configuration @xmath31 is given by @xmath32 where @xmath33 is a randomly selected particle index and @xmath34 is a randomly selected displacement .",
    "we use gaussian - distributed displacements .",
    "single - particle updates result in autocorrelation times in the generated markov chain that only scale as the first order in the number of particles .",
    "such updates are suitable for vmc sampling of quantum liquids with large number of atoms",
    ". for single - particle updates of a system given by  ( [ eq : jastrow ] ) , the acceptance probability in a metropolis step  ( [ eq : decision ] ) becomes @xmath35   \\right\\ } .",
    "\\label{eq : jastrowupdate}\\ ] ] we use a symmetrized form for @xmath36 , @xmath37 the symmetrization length @xmath38 is usually chosen as the smallest box dimension .",
    "symmetrization results in a continuous first derivative of @xmath39 , removes tail corrections to the kinetic energy and allows to use alternative estimators for the this energy .",
    "the pair - correlation factor @xmath40 is chosen in the schiff - verlet form @xcite",
    "@xmath41 this function prevents the overlap of atomic cores .",
    "the power in @xmath42 is dictated by the behavior of helium - helium interaction potential at short distances and is close to optimal for the aziz - ii potential .",
    "the parameter @xmath43 is the only variational parameter in this wavefunction .",
    "much more complicated forms of the trial wavefunctions exist for strongly correlated quantum liquids and solids @xcite . even for the jastrow form of eq .",
    "( [ eq : jastrow ] ) , the pair factor @xmath36 can be considerably more complex and computationally expensive .",
    "triple - correlation forms are also used @xcite . however",
    ", additional arithmetics increase the parallel fraction of the program and only improves the parallelization outcome .",
    "the simple choice of the wavefunction is made with the purpose to demonstrate the strength of the parallelization scheme .",
    "in this section , we introduce the relevant terminology , and review a number of gpu features that were taken advantage of in our program .",
    "single computing cores of the gpu are grouped into units called streaming multiprocessors ( sm or smx for kepler architecture ) .",
    "each sm contains additionally several special function units , a large amount of register space and a high - level user - managed cache called _ shared memory_. a gpu unit typically includes between one and twelve gb of an on - board high - speed operating memory accessible to all sms .",
    "this memory is called _",
    "global_.    a routine commanded by a cpu to be executed on a gpu is called a _ kernel_. a kernel is executed by a certain number of _ thread blocks_. each thread block is resident on a multiprocessor and the threads within a block are easily synchronized .",
    "communication and synchronization between different thread blocks is , however , slow and in principle not guaranteed by the language standard . to compute quantities to desired precision ,",
    "it is productive to generate several independent markov chains , each thread block working on its own walker . only for very large systems",
    ", it becomes advantageous to use all multiprocessors simultaneously to work on a single markov chain .",
    "advancing a single walker is also preferable for systems with very long equilibration times .",
    "such a cooperating approach , with synchronization written along the lines of ref .",
    "@xcite , has been successfully tried out but is not included here .",
    "using multiple walkers is also more compatible with other qmc methods .    by design ,",
    "each multiprocessor is capable of maintaining a very large number of threads with an intact register space for each thread , and can rapidly switch between the threads .",
    "quite unlike for cpu , the gpu masks memory latency and the latency of mathematical units by switching between threads in a thread block and executing the instructions for the threads that are ready to proceed .",
    "it is thus favorable to run a very large number of threads on each sm , much larger than the actual number of single cores .",
    "we take advantage of this by partitioning the calculation of interparticle distances to different threads , each thread only computing several distances .",
    "the number of threads in a threadblock does not have to equal the number of particles .",
    "successive chunks of 32 threads , called _ warps _ , simultaneously execute the same instruction sequence but with their own data .",
    "conditional branching within warps is possible but results in serialization",
    ". thus all threads in a given warp are automatically synchronized .",
    "the _ warp synchronicity _ is heavily exploited in the ql package , especially when performing parallel reduction such as for the sum of eq .",
    "( [ eq : jastrowupdate ] ) .",
    "this leads to a noticeable improvement in the execution times .",
    "the functionality can be switched by a preprocessor macro , as warp synchronicity is not strictly a part of the cuda standard .",
    "warp synchronicity is exercised on the thread level and it can be used even when the number of particles is not a multiple of the warp size .",
    "gpu kernels may write directly to the host memory via the front - side bus .",
    "this process does not require terminating the kernel , allowing for shared memory persistence .",
    "all the caches and sm shared memory content and even registers may be kept intact .",
    "the data transfer to the host memory is also asynchronous with respect to the kernel s execution .",
    "the kernel proceeds to the next operation after posting the memory command , even though the memory transaction completes thousands of cycles later .",
    "we take advantage of this feature by keeping the walkers in the shared memory , and regularly `` writing out '' a copy to the central ram .",
    "the sm proceeds to the next calculation immediately , and does not need to reload the coordinates .",
    "this feature was essential for achieving the reported performance .",
    "once a kernel is launched , control returns to the cpu , without waiting for the gpu task to finish .",
    "this capability is exploited to run the gpu and cpu parts of the code simultaneously .",
    "these are referred here as the gpu - side and cpu - side .",
    "the gpu performs the heavy number crunching ; the code on cpu at the same time processes generated configurations and prepares raw random numbers for the next chunk of calculations .",
    "so long as the execution times of the cpu - side are shorter than those of the gpu , the load of cpu computations is almost completely masked .",
    "this is further discussed in section  [ sec : loadmasking ] .",
    "variational monte carlo calculations can be seen as consisting of two interleaved tasks : generating the markov chains to produce new configurations ( according to the goal distribution ) and then computing various observables on these configurations .",
    "we refer to the former as the generation steps , and to the latter as the analysis steps . a number @xmath25 of single - particle updates ( sometimes called _ microupdates _ ) , where @xmath25 is the number of particles , constitute a _ macroupdate _ and separate configurations @xmath44 and @xmath45 in our notation .",
    "the cost of one microupdate includes computing @xmath25 interparticle distances for the sum of eq .",
    "( [ eq : jastrowupdate ] ) .",
    "thus the cost of performing one macroupdate is @xmath46 , the same as that of a typical analysis step , but possibly with quite a different coefficient .",
    "the consecutive configurations are correlated , and one needs to decide the optimal number of macroupdates to be performed between the analysis steps .",
    "optimal conditions result in the smallest statistical errors given the available computer time .",
    "for a stationary walk , the autocorrelation function @xmath47 of the sequence can be defined as @xmath48 where @xmath49 is the sequence of calculated observable values , and @xmath50 is its mean .",
    "we further define the autocorrelation time @xmath51 of a sequence as the sum of the autocorrelation function @xcite , @xmath52 for an uncorrelated sequence , @xmath53 , and the autocorrelation time @xmath51 defined in this way is equal to zero . while the above definitions can be used to perform the autocorrelation analysis directly @xcite , the autocorrelation time",
    "can also be extracted by reblocking techniques @xcite .",
    "given @xmath51 is the autocorrelation time between successive configurations , and that configurations are only analyzed every @xmath54 macroupdates ( that is , one only performs analysis on configurations @xmath44 , @xmath55 , @xmath56 ,  ) , the true uncertainty in the mean of a computed quantity is@xmath57 where @xmath58 is the variance of the distribution of this quantity and @xmath59 is the number of analysis instances @xcite .",
    "this expression is not modified in the important case when several independent markov chains are used .",
    "given that @xmath59 is the total number of the samples collected in all chains and the number of the chains is @xmath60 , the number of samples in each chain is @xmath61 and the resulting uncertainty is given by @xmath62 this reasoning applies so long as the number of samples in each chain is large , @xmath63 .",
    "thus , regardless of the value of @xmath51 , progressing several independent chains is as good as progressing a single but correspondingly longer chain .",
    "this equally applies to the case of very strong autocorrelation .",
    "a significant caveat , however , is that the chains have to be independent .",
    "this may become a difficulty for systems with very large initial equilibration times .",
    "such a situation is discussed further below .    for fixed computer time",
    ", @xmath59 is inversely proportional to the time between analyses @xmath64 .",
    "let @xmath65 be the time necessary for analysis , and @xmath66 the generation time necessary to produce one macroupdate . if both the generation and analysis are performed on the same unit , @xmath67 and the optimization of eq .",
    "( [ eq : correlatederror ] ) gives @xmath68 above we introduced @xmath69 , the ratio of time needed for analysis and macroupdate generation , @xmath70 consider now the asynchronous generation , in which the gpu generates new macroupdates , and the cpu performs analysis on previously prepared configurations at the same time .",
    "the asynchronous time per analysis instance is @xmath71 the optimization of eq .",
    "( [ eq : correlatederror ] ) yields , unsurprisingly , @xmath72 that is , both cpu and gpu are used at all times .",
    "the time that gpu takes to generate @xmath54 macroupdates is @xmath73 .",
    "meanwhile , the cpu side has just enough time to perform the analysis , since eq .",
    "( [ eq : optimalgpu ] ) requires @xmath74 .",
    "we can now estimate the penalty that one pays by using a non - optimal number of the analysis instances .",
    "the computer time necessary to reach a given error level @xmath75 is given by eq .",
    "( [ eq : correlatederror ] ) as @xmath76 it is a common practice to perform analysis after every macroupdate , corresponding to @xmath77 .",
    "we begin with the case when both the generation and analysis are performed sequentially on the same unit .",
    "using eqs .  , one can find the ratio @xmath78 of computer times @xmath79 necessary to reach a target uncertainty level when either @xmath77 or @xmath54 is selected optimally as given in eq .",
    "( [ eq : optimalcpu ] ) , @xmath80 the largest penalty occurs for strong autocorrelation , when the penalty ratio reaches the value @xmath81 .",
    "if the cost of computing the observable is similar to the cost of performing the macroupdate , then we can expect that @xmath69 is of the order of unity since the calculations are performed on the same unit .",
    "the penalty of performing analysis on every step is , therefore , not prohibitive . on the contrary",
    ", the value of @xmath69 for the gpu - accelerated markov walk with observables computed on the cpu is expected to be considerably large .",
    "it is closely related to the achieved overall acceleration . in this case , the ratio @xmath82 of computer time for @xmath77 and optimal @xmath54 given by eq .",
    "( [ eq : optimalgpu ] ) is equal to @xmath83 this ratio can not exceed @xmath84 , but in this case the penalty can be large .",
    "it is caused by the unnecessary idling of the accelerator .",
    "similar considerations apply when one chooses to perform the analysis some every @xmath54 steps . in this case",
    ", the penalty ratio for the sequential case is bounded by @xmath85 for masked execution with the gpu , the penalty is bounded by @xmath86 notice that the upper bounds do not contain the autocorrelation time @xmath51 .",
    "it is therefore possible to determine a `` good '' value for @xmath54 without performing the autocorrelation analysis .",
    "instead , one can determine @xmath69 from simple benchmarking , and select @xmath87 .",
    "for the sequential execution , the penalty is at most twofold : @xmath88 .",
    "the upper limit is only reached for very strong autocorrelation , when @xmath89 . for the cpu+gpu execution , it is in any case optimal to choose @xmath90 , see eq .",
    "( [ eq : optimalgpu ] ) . in practice , optimal @xmath54",
    "is often determined empirically through a series of benchmarks . in this case , using @xmath91 is a good starting point .",
    "when the autocorrelation time @xmath51 is large , the analysis needs to be performed infrequently and can be done on the cpu - side .",
    "the cost of analysis will be masked by the time that that the gpu needs to spend creating new configurations .",
    "however , if the autocorrelation time @xmath51 is small , the analysis should be performed frequently , and the the cpu - side becomes the bottleneck . if one needs to minimize the errorbars for such an observable , one should consider either moving the calculation of the observable to the gpu , or accelerating their computation on the cpu .",
    "( color online ) illustration of the modified amdahl law . here , we used @xmath92 for the computational fraction remaining on the host , and @xmath93 for the serial fraction of the gpu kernel .",
    "horizontal axis shows the parallelization factor @xmath94 , as explained in the text .",
    "the vertical axis shows achievable acceleration ratios .",
    "the dashed blue line corresponds to the `` traditional '' amdahl law , that is , the acceleration achievable via synchronous execution as given by eq .",
    "( [ eq : standardamdahl ] ) .",
    "the solid green line shows the amdahl law which results from concurrent ( asynchronous ) execution and load masking , as shown in eq .",
    "( [ eq : modifiedamdahlfull ] ) . while the maximal acceleration values are quite close ( @xmath95 and @xmath96 ) , the asynchronous execution reaches its limit significantly faster . ]    with increased parallelization , even a small serial fraction in a program inevitably becomes the main computational bottleneck .",
    "this observation is known as the amdahl law @xcite .",
    "the serial fraction arises not only from parts of the algorithm that were not parallelized , but also from the communication and synchronization between parallel workers .",
    "given that @xmath97 is the serial and @xmath98 the parallel fractions of the program ( @xmath99 ) , and @xmath94 is the number of parallel threads or processes , the achievable acceleration @xmath100 is given by @xmath101 for a program with the gpu acceleration , all work that remains on the cpu - side appears as the serial fraction , since it is not parallelized for the accelerator .",
    "the same consideration applies to the communication between the cpu and gpu .",
    "it is thus often the case that the cpu - side of the program becomes the bottleneck of the gpu parallelization , since @xmath102 and the amdahl limit regime is quickly reached .",
    "the load masking leads to a modified form of the amdahl law .",
    "suppose that @xmath103 is the code fraction that remains on the cpu , and the serial and parallelizable parts that are moved to the gpu are @xmath104 and @xmath105 .",
    "thus @xmath106 there is an additional overhead associated with launching the parallel process ; it is omitted here for clarity .",
    "if the parallel portion of the gpu code may be accelerated by a factor @xmath94 , the resulting speed - up is @xmath107 for a gpu , the parallelization factor @xmath94 is related to the number of available cores , but also strongly depends on a number of other factors . in the case of a complete cpu - side masking , acceleration reduces to @xmath108 with the cpu fraction @xmath103 completely removed from the equation .",
    "because the serial component of markov chain generation is much smaller than the serial fraction of the entire program , we have .",
    "having isolated the serial gpu fraction @xmath104 , we may focus on minimizing it by improving the program . in the absence of load masking ,",
    "the acceleration is limited by @xmath109 , and the cpu - side execution quickly becomes the bottleneck .",
    "the maximum acceleration @xmath110 that can be achieved under the modified version of the amdahl law of eq .",
    "( [ eq : modifiedamdahlfull ] ) is given by @xmath111 .",
    "if the execution of the gpu - side was synchronous with the cpu - side , the standard amdahl law would apply , with the acceleration given by @xmath112 the maximum acceleration in this case is given by @xmath113 , that is , not much different from the limit of @xmath110 .",
    "moreover , it holds that @xmath114 , by itself not a remarkable improvement .",
    "it simply reflects the fact that one has two devices to use for computation : the gpu and the cpu itself .",
    "what is special about the structure of eq .",
    "( [ eq : modifiedamdahlfull ] ) is the nature in which @xmath110 approaches the maximal value .",
    "the difference is illustrated in fig .",
    "[ fig : amdahl ] . for the purpose of illustration ,",
    "we have chosen @xmath115 and @xmath116 .",
    "the masked execution approaches its maximal without the slow tapering characteristic of the traditional amdahl law .",
    "thus , achieving the theoretical limit is possible for @xmath110 , and the smaller required parallelization factor @xmath94 means that the parallelization overhead needs not grow into a bottleneck of its own .",
    "even when the gpu performs both the generation and analysis , load masking improves the performance . for example , random numbers may be prepared by the cpu for the next block while the gpu is busy , as described below .",
    "memory transactions through the system bus are also at least partially masked .",
    "an important consequence is that other , less computationally intensive tasks and analysis may remain on the cpu without any performance penalty .",
    "the set of coordinates and other data representing each markov chain is commonly referred to as a `` walker '' .",
    "optimal execution of the gpu code requires a careful selection of the number of walkers ( and thus thread blocks )",
    ". the number of walkers should be maximal such that all thread blocks still remain simultaneously resident on the gpu . for smaller systems , number of threads equal to the number of particles is optimal .",
    "however , reducing the number of threads has the benefit of smaller relative loop overheads ( each thread serves several interparticle distances ) , reduced required register space and smaller temporary arrays ( allowing for a larger number of resident thread blocks ) , and a reduced cost of parallel reduction schemes .",
    "for this reason , large systems are best computed with the number of threads which is several times smaller than the number of particles .",
    "to make use of warp synchronicity , it is beneficial to use the number of threads such that it is a multiple of the warp size , equal to 32 .",
    "once the number of threads has been decided , the maximum number of resident blocks can be determined from the compute capability of the device , which determines maximum number of total resident threads on a multiprocessor .",
    "the optimal number of blocks may be below this value due to memory restrictions . finally , to save time on copying the random numbers to the gpu , it is best to use the largest number of steps which is allowed by the size of the gpu global memory .",
    "special care must be taken when simulating systems with large equilibration times .",
    "this effectively means that the simulation starts with large autocorrelation time ( this interval is called `` equilibration '' ; observables should not be collected during this initial stage ) .",
    "the equilibration finishes when the autocorrelation time decreases to its `` normal '' value , and afterwards the observables fluctuate about their average values . in this case",
    ", it is optimal to first progress a smaller number of walkers ( or just a single walker ) to pass the equilibration stage .",
    "the equilibrated walkers are then replicated and the simulation continues with the number of walkers that is optimal for the hardware . for the distributed package , however , there is little speed gain when using fewer walkers than the number of multiprocessors on the gpu .",
    "thus for the equilibration stage , it is optimal to use the number of walkers equal to the the number of multiprocessors .",
    "in this section we discuss in greater detail the workflow of the program .",
    "as described above , the part of the code that executes on the cpu is referred to as the cpu - side , and the gpu - side refers to execution on the graphical card .",
    "`` global memory '' is the term used for the ram memory of the gpu , and `` host memory '' refers to the main ram of the computer .    upon starting of the program ,",
    "input files provide starting walker coordinates , box dimension , random sequence seed and execution parameters .",
    "the cpu - side allocates page - locked arrays in host memory and the necessary arrays in global memory of the gpu .",
    "the former are used to pass walker coordinates to and from the gpu , and the latter are used to supply the gpu with random numbers .    for statistical analysis of monte carlo results ,",
    "the execution is broken into blocks .",
    "values averaged during a block are written to a file and values from successive blocks may be later averaged and analyzed for correlation and standard deviation values @xcite .",
    "walker coordinates and random seeds are also written to files at the end of each block .",
    "thus every block - end provides a natural restore point .",
    "an instance at which the gpu writes walker coordinates into page - locked host memory is here called a _",
    "writeout_. writeout also includes values such as the acceptance ratio , computed potential and kinetic energies .",
    "the writeouts are performed by the gpu code within the main computational kernel .",
    "this allows to achieve shared memory persistence .",
    "it is the persistence that , in our case , contributes most significantly to a good gpu utilization",
    ". additional benefit of the writeouts is masking of the cpu load as described in section  [ sec : loadmasking ] .",
    "each writeout occurs into a unique separate space in the host memory . in the beginning of a block",
    ", the program writes computationally impossible values into the writeout arrays .",
    "for example , negative values for particle coordinates .",
    "after starting the gpu kernel , the cpu - side loops over the memory space until the area to which a given generation of walkers is destined has been written to",
    ". freshly arrived data is then taken for processing .",
    "the behavior is assisted by forbidding host caching of the writeout arrays through the ` cudahostallocwritecombined ` flag to the ` cudahostalloc ` command .",
    "while it is not guaranteed that the writeout data will even begin to arrive before the kernel finishes , we have tested this behavior on a range of systems and always observed properly completed , uncorrupted asynchronous writeouts . because each writeout occurs to its reserved part of memory , _ in the worst - case scenario",
    "the data will be received after the kernel finishes , preserving program correctness_. there is a build - in check in the program which warns the users if the kernel in fact executes synchronously .",
    "the execution of a block is outlined in fig .",
    "[ fig : workflow ] .",
    "the cpu - side copies random numbers to the gpu , launches a gpu kernel for the box - muller transform , and after that , the main computation kernel .",
    "the box - muller transform is used to produce the gaussian - distributed particle displacements .",
    "once launched , the kernel loads walker coordinates from page - locked host memory , and begins to produce the metropolis updates .",
    "each thread block serves one walker , that is , one markov chain of configurations . for each microupdate , the thread block loads the random particle index @xmath28 , the `` dice '' variable @xmath21 , and three displacement coordinates @xmath117 from the gpu global memory .",
    "each thread computes distances from the updated particle to one or several other particles , and computes @xmath118 ( see eq .",
    "( [ eq : jastrowupdate ] ) ) .",
    "periodic boundary conditions are applied to all interparticle distances . after this , a parallel reduction scheme is invoked and the sum from all threads in a thread block is accumulated in the zeroth element of the array ` threadsum ` . zeroth thread makes the update decision according to eq .",
    "( [ eq : decision ] ) , @xmath119>\\xi\\right\\},\\ ] ] where the left - value is an integer variable and the logical right - value is evaluated as @xmath120 when true and @xmath121 otherwise .",
    "update happens non - conditionally as @xmath122 after predetermined number of updates , threads perform a writeout of walker coordinates and other necessary data .",
    "all threads participate in the memory command , with the data sequence ordered to ensue coalesced memory access .",
    "the generation of the ( pseudo)random numbers is separated from the markov chain generator .",
    "an entire sequence of `` raw '' pseudorandom numbers ( uniformly distributed on the unit interval ) that is necessary for the computational block is generated and placed in the gpu global memory .",
    "the sequence is indicated in fig .",
    "[ fig : workflow ] .",
    "this approach provided three advantages : ( i )  pseudorandom ( and truly random ) number generators may be readily interchanged , making it easy to test new generators , especially those that work from the gpu .",
    "( ii )  generating a large quantity of random numbers at once proved significantly faster than producing them one - by - one as the need arises .",
    "the gain in speed overcomes the necessary limitation from the bandwidth of ram because of the resulting favorable memory access patterns .",
    "( iii )  numbers may be generated for the next block by the cpu while the cpu - side is waiting on the gpu kernel to finish .",
    "this is , in effect , a masking of cpu load with respect to the pseudorandom number generation , as described in section  [ sec : loadmasking ] .    the number of operations necessary to perform a macroupdate scales as @xmath46 , while the number of necessary pseudorandom numbers is @xmath123 . thus producing sufficient amount of random numbers",
    "is a challenge only for small systems . in practice ,",
    "generating raw random numbers became a bottleneck only for systems with fewer than 256 particles .",
    "the program has a remarkable appetite for the random numbers when computing small systems .",
    "for example , in the case of a 64-particle system with 128 walkers on a tesla m2090 card , the gpu consumed over 100 million random numbers per second , rate limited by the generator . for such cases ,",
    "one may opt for gpu - parallel generators , such as those provided by the curand library @xcite .",
    "pre - generation of the entire set of pseudorandom numbers makes it convenient to use non - standard sources of uncorrelated sequences .",
    "for instance , we successfully tested our results against the amu sequence of true random numbers produced from vacuum fluctuation measurements @xcite .",
    "the kepler k20 is the latest generation gpu from nvidia .",
    "the kepler chipset sports a considerably increased number of computing cores , but a reduced number of streaming multiprocessors ( called smx on kepler ) .",
    "the amount of shared memory per multiprocessor is the same as in the previous , fermi generation of gpu .",
    "that is , 32 kb per multiprocessor .",
    "thus the total amount of shared memory on the card was reduced , while the number of cores increased dramatically .",
    "providing these cores with enough work proved to be a challenge .",
    "the issue was resolved by moving the walker data into the register space of the smx .",
    "the kepler chipset is equipped by 512 kb of register space per smx , which is considerably larger than the available shared memory .",
    "thus the walker data is partitioned , and each thread stores into its registers the coordinates for several particles of the walker .",
    "when a particle is displaced for a trial move , the holding thread releases necessary coordinates to the rest of the threads through shared memory .",
    "this approach allowed for considerably more resident walkers on an smx , giving better occupancy and increased performance .",
    "for the benchmarking , all k20 results were obtained with such _",
    "register heavy _ routines .",
    "the routines are provided as part of the released program and may be selected through a preprocessor macro .",
    "in addition to improved performance , the use of the register space on the k20 allows to compute much larger systems , in excess of ten thousand atoms .",
    "the cuda routines that are described here are provided along with the code code that is used to properly launch the calculations .",
    "the gpu code is written in the c implementation of cuda @xcite , while the supporting code is provided in fortran .",
    "the resulting program is distributed as a package through the computer physics communications program library .",
    "we refer to this program as the ql package .",
    "the ql package is a simplified version of a larger quantum fluids and solids package .",
    "the simplification allows us to focus on the gpu parallelization scheme .",
    "however , only basic functionality in terms of the observables is included .",
    "the supplied package files include a short manual .",
    "the manual lists the file structure of the program , input and output files , and control variables .",
    "interested readers should refer to the manual for setting up the calculations .",
    "the distributed package is programmed to simulate ^4^he with hfd - b(he ) ( known as aziz - ii ) interatomic potential @xcite and a jastrow wavefunction as described by eqs .",
    "( [ eq : jastrow]),([eq : ufunction]),([eq : fifthpower ] ) .",
    "it should be relatively straightforward to adapt the package to other bosonic systems , especially if the wavefunction remains in the jastrow form .",
    "the list of necessary changes is detailed in the manual .",
    "the ql package is distributed in the form of a compressed .tar archive .",
    "unpacking creates a directory called ` ql ` , which contains a makefile and the makefile configuration script , and a number of subdirectories .",
    "compilation requires the cuda compiler nvcc and the gnu fortran compiler .",
    "the make command should be invoked directly in the directory ` ql ` . for a standard linux distribution ,",
    "executing    .... make ql ....    in the command shell may be sufficient to compile the program .",
    "alternatively , users may first run the configuration script , and execute    .... make configure make clean make ql ....    the configuration script tries to locate the libraries and necessary compilers .    upon successful compilation ,",
    "the user should be able to change to the subdirectory ` bin ` and execute the program by entering    .... ./ql ....    in the command prompt .",
    "the package is distributed with the input files that are ready to simulate liquid ^4^he  at its experimental equilibrium density , with 1000 atoms and 16 walkers .",
    "the program should finish in less than three minutes .",
    "this sample run will execute 20 computational blocks , each block consisting of 100 analysis instances .",
    "each analysis is separated by 4 macroupdates .",
    "thus the sample run executes 128  million single - particle updates . during the execution ,",
    "several data files are produced in the same directory .",
    "these include ` e.dat ` with the energy values from each block , ` acceptance.dat ` with the average metropolis acceptance rates , and ` finalconfig.dat ` with the last walker coordinates .",
    "file ` kinetic.dat ` contains two independent estimates for the kinetic energy .",
    "the values in the second and third columns of this file should be statistically equal .",
    "file ` storeseed.dat ` contains the last used seed of the pseudorandom sequence .",
    "the details of the output file format are described in the provided manual , which can be found in the subdirectory ` ql / doc ` .",
    "the contents of ` e.dat ` become as follows ( not all digits are shown ) ,    ....        1        -5.8007     -20.9134      15.1127        2        -5.8122     -20.9253      15.1131        3        -5.7851     -20.9589      15.1738        ...",
    "19        -5.8102     -20.9566      15.1464       20        -5.7813     -20.9187      15.1373 ....    the acceptance rates in file ` acceptance.dat ` become    ....        1         0.3725        2         0.3727        3         0.3722        ...",
    "19         0.3720       20         0.3723 ....    it should be noted that the produced output depends on the pseudorandom sequence used , which is compiler - dependent .",
    "only the averages of the computed values need to be equal between different compilers .",
    "the distributed package uses fortran built - in generator .",
    "we have used the code with the gnu fortran compiler , which implements marsaglia s well - known kiss generator .",
    "the parameters file ` parameters.in ` specifies the execution configuration , including the number of the computational blocks ( field ` blockstogo ` ) , the number of analysis instances , or writeouts , in a block ( ` stepsinablock ` ) , number of macroupdates between writeouts ( variable @xmath54 in fig .",
    "[ fig : workflow ] ; field ` vmcmacrosteps ` ) , dimensions of the simulation volume ( field ` bulkdimarray ` ) , parameter @xmath43 for the wavefunction ( see eq.([eq : fifthpower ] ) ; field ` jastrowb ` ) , particle mass in a.m.u .",
    "( ` mass ` ) , and the amplitude multiplier for the random displacements ( ` mtpstep ` ) .",
    "changes in these parameters do not require recompilation .",
    "variables that require recompilation are included in the form of preprocessor macros in file ` setup.h ` , which is located in the source directory ` ql / src ` . the number of particles , walkers , threads , and the functionality which is performed on the gpu are set in ` setup.h ` .",
    "the file ` setup.pp ` is the preprocessor header file that is used for the fortran source files , and it is automatically produced by make by stripping the comment lines from ` setup.h ` .",
    "therefore , one should never have to edit ` setup.pp ` , which is automatically removed by make after the compilation .    in order to accumulate sufficient statistics ,",
    "it is often desirable to chain the execution of the monte carlo program . to do this",
    ", one has to copy the last walker coordinates and the last pseudorandom sequence seed into input files , by executing    .... cp final_config.dat configuration.in cp store_seed.dat seed.in ....    after the copy commands , the program may be launched again and it will continue from the point at which it had last finished .",
    "values for energy , acceptance rate , and pair distribution function histograms will be appended to the already existing data files .    while we have tested the program with the currently available fermi and kepler architectures , the code should be future - compatible with the upcoming generations of gpu .",
    "the kepler - specific optimization should be useful for the announced maxwell and volta cards , since it amounts to the extensive use of the expanded register space .",
    "users can toggle such optimization on and off with a preprocessor macro , as described in the manual .",
    "@lll>[6pt][6pt]llll>[6pt][6pt]llrrr@ & & & * 560ti * & & * m2090 * & & * k20 * + & & workstation & & cluster & & workstation + cpu & & & & & & & & + & & intel & & intel & & intel + & & i5 - 2500 & & xeon e5649 & & i5 - 3570 + & & 3.3 ghz & & 2.5 ghz & & 3.4 ghz + & & 16 gb & & 24 gb & & 12 gb + & & 6 mb & & 12 mb & & 6 mb + [ 5px ] gpu & & & & & & & & + & & geforce & & tesla & & tesla + & & fermi & & fermi & & kepler + & & gf114 & & t20a & & gk110 + & & gtx 560 ti & & m2090 & & k20 + & & 2.1 & & 2.0 & & 3.5 + & & 384 & & 512 & & 2496 + & & 8 & & 16 & & 13 + & & 48 & & 32 & & 192 + & & 1.8  ghz & & 1.3  ghz & & 0.71  ghz + & & 1.0  gb & & 6.0  gb & & 5.0  gb +    the reported acceleration values are ratios of times measured for the gpu - parallelized and serial code executed on the same machine .",
    "we have decided to compare the execution of our cpu+gpu code to the execution on a single - core of a cpu , notwithstanding the fact that a gpu is usually accompanied by a powerful cpu with several cores .",
    "notice that the cpu+gpu execution also uses only a single cpu thread .",
    "one may argue that the acceleration should be compared with a run which utilizes all available cpu cores .",
    "however , we find the single - core comparison appropriate for several important reasons .",
    "first of all , in practice , the calculations of the kind described here are so numerically demanding that they are performed on large clusters or supercomputers .",
    "the decision about using a gpu accelerator in such a case is guided by comparing available gpus to an available allocation of core - hours on a supercomputer .",
    "second , the code that uses several cores needs to be parallelized , and questions may arise regarding the efficiency of such parallelization .",
    "inefficient openmp implementations will artificially boost the apparent gpu acceleration numbers .",
    "a skeptical reader may always divide our results by the number of cores on the cpu , corresponding to an ideal openmp implementation , but the reverse is not possible without careful ( and distracting ) performance analysis of the cpu parallelization . finally , single - core benchmarking is a widely accepted practice and allows for a better comparison with other works .",
    "we note that the same optimized routines were also written for the cpu .",
    "thus the cpu - only program is optimized in good faith just like the gpu+cpu program . while the cpu was always used with a single core , automatic simd vectorization for the cpu",
    "was used on the compiler level .",
    "simd instructions allow for a small level of data parallelism already on the single - core level of a cpu .",
    "it is possible that a full manual optimization of the simd parallelization would additionally improve the cpu version of the program .",
    "however , we judged against such parallelization .",
    "the jastrow wavefunction that is used in this code is on purpose a rather simple one for its class .",
    "the mathematical load is small , while all the pair distances nonetheless need to be computed , and thus all the memory operations are still necessary , along with the pseudorandom number generation . in practice",
    ", one often uses trial functions that are much more elaborated .",
    "additional arithmetic complexity of the wavefunction in fact improves the parallel performance . in other words",
    ", we are testing the code with an unfavorable trial wavefunction .",
    "performance tests have been carried on several machines with different nvidia gpu models .",
    "the computer specifications are summarized in table  [ tab : architecture ] .",
    "the fermi - architecture 560ti is a card from the geforce family .",
    "it is a popular and very affordable card with excellent heat and noise control .",
    "our 560ti was overclocked by the manufacturer .",
    "the tesla m2090 is a fermi card designed specially for scientific computing .",
    "tesla m2090s were accessed in a gpu cluster provided by the barcelona supercomputing center .",
    "it should be noted that the xeon processor accompanying the m2090 has a slower clock than the i5 cpus in the other machines .",
    "this influences the acceleration ratios presented later , and one should be aware of this when trying to compare different cards .",
    "finally , the tesla k20 card was used in an intel i5 workstation .",
    "the tesla k20 is the latest kepler architecture card from nvidia .",
    "kepler devices provide a significantly increased number of cores ( in this case , 2496 ) , a much larger register space , and instructions for improving global memory caching .",
    "calculations were performed for a system representing liquid helium at its equilibrium density @xmath124  nm^3^. the wavefunction was of the jastrow type  ( [ eq : jastrow ] ) , ( [ eq : ufunction ] ) , ( [ eq : fifthpower ] ) , with the parameter @xmath43 at optimum value @xmath125  nm . the single - particle displacement was gaussian - distributed with a root mean square displacement of @xmath126 , which results in the acceptance of roughly @xmath127 of trial moves .",
    "we used the hfd - b(he ) ( known as aziz - ii ) interatomic interaction potential @xcite .",
    "the simulation box was always cubic with periodic boundary conditions .",
    "the cutoff distance for the potential and for the correlation factors ( length @xmath128 in eq .",
    "( [ eq : ufunction ] ) ) was set at half the box size .",
    "calculations were performed on three different cards , as detailed in section  [ sec : benchmarking ] and specified in table  [ tab : architecture ] .",
    "first we demonstrate masking of the cpu load by the gpu execution as described in section  [ sec : loadmasking ] .",
    "the calculations were made on the 560ti card for eight independent markov chains , one walker per sm .",
    "the gpu was used to execute the box - muller algorithm and then to generate new configurations , while the cpu - side generated the raw random numbers and performed energy calculations for configurations separated by a variable number of macroupdates @xmath54 .",
    "the total number of macroupdates was kept fixed while the number of analysis instances was varied .",
    "thus the work performed by the gpu was not varied , and the needed number of random numbers was also fixed .",
    "given the total number of macroupdates is @xmath33 ( in this case , 10 blocks of 9240 macroupdates ) , the number of writeouts and energy analyses is @xmath129 .",
    "thus the cpu time should be of the form @xmath130 , where the constant @xmath43 includes the cost of computing the energy .",
    "the results for the execution time are shown in the left panel of fig .",
    "[ fig : masking ] with open boxes . as can be seen , for small number of macroupdates between measurements @xmath54",
    ", the execution time is indeed very sensitive to @xmath54 . in this region ,",
    "the cpu time dominates , as it is larger than the gpu time .",
    "however , for @xmath131 , the cpu time becomes `` undetectable '' as it decreases below the gpu load . for a system with large autocorrelation times , such masking would allow to keep all the analysis calculations without parallelizing them for the gpu , with no performance consequences .",
    "moreover , any additional overhead on the cpu is also masked , in accordance with the modified amdahl law of eqs .",
    "( [ eq : modifiedamdahlfull])([eq : modifiedamdahlmasked ] ) .",
    "notice also that the gpu - dominated region in fig .",
    "[ fig : masking ] is perfectly flat , yet the number of configuration writeouts from the gpu to host ram is decreasing as @xmath132 .",
    "the gpu is able to continue its work before the memory transaction is complete , and the cost of configuration writeouts is masked to the level of being negligible .    the liquid helium system that we consider has short autocorrelation times regardless of the system size . for optimum performance ,",
    "the energy calculations had to be moved to the the gpu as well .",
    "the right panel of fig .",
    "[ fig : masking ] shows the resulting execution times ( with green crossed boxes ) .",
    "now the gpu time consists of a constant generation time and the time for computing the energy which scales as @xmath132 .",
    "the same figure shows masking of another operator ( with blue crosses ) . in that case ,",
    "configurations and the energies are computed on the gpu , while the cpu performs calculations of the pair distribution function , a quantity of interest for such systems .",
    "again there is a _ masking threshold _ in @xmath54 above which the additional calculation comes at no cost .      in this section",
    "we look at the speed in which the gpu can generate new configurations .",
    "this is especially important for properties with large correlation times .",
    "the gpu was only used to generate new configurations , for as many independent markov chains as was found optimal to achieve the maximal throughput . in practice",
    "this meant up to 208 walkers for the smallest @xmath133 systems on kepler k20 ( 16 walkers per smx ) .",
    "the optimal number of resident walkers per sm depends on the model of the gpu .",
    "for example , for the largest system shown in fig .",
    "[ fig : generatoracceleration ] ( @xmath134 ) , fermi m2090 was optimally ran with two walkers per sm ( 32 walkers in all ) , while kepler k20 could be efficiently loaded with up to five walkers per smx ( 65 walkers per card ) .",
    "for cpu - only execution , one chain is optimal to make the best use of the l1 cache .",
    "the results are shown in fig .",
    "[ fig : generatoracceleration ] in the form of times necessary to perform a macroupdate and the acceleration ratio for each gpu model .",
    "as can be seen , the acceleration is remarkable . both for gpu and cpu ,",
    "the macroupdate generation time scales with the system size as @xmath135 , and the resulting acceleration is roughly constant and equal to @xmath136 for the 560ti card , and over @xmath137 for m2090 and k20 .",
    "however , performance is reduced for small systems , where random number generation becomes a limiting factor .",
    "the random number generation scales as @xmath138 and is masked for systems with more than @xmath139 particles , as discussed in section  [ sec : loadmasking ] .",
    "notice that these results apply to the case when the system has reached equilibrium and one is interested in determining the observables with best accuracy , as described in section [ sec : loadmasking ] .",
    "for this , one needs to generate maximum overall number of new configurations for all markov chains combined . for the equilibration stage",
    ", one would use a smaller number of walkers , perhaps equal to the number of multiprocessors on the card ( between 8 and 16 , see table [ tab : architecture ] ) . the best acceleration for the progression of each individual walker that we observed did not exceed @xmath140 when the walkers are served by individual multiprocessors .",
    "when dealing with extremely slowly equilibrating systems , one may have to resort to updating a single walker with the cooperating kernels , when a single configuration is updated with the entire gpu , as mentioned in section  [ sec : cuda ] .",
    "speed gains should ultimately be judged from the time that is necessary to compute the observables .",
    "we focus on the energy , while other properties have a similar computational complexity .",
    "to determine the acceleration , we compared execution times that are necessary to reach a given error level in the computed energy per particle .",
    "both parallel and serial programs were ran with their respective optimal number of macroupdates between analyses , determined empirically .",
    "optimal execution is understood as such that leads to the smallest final uncertainty in the computed value of the observable , as described in section  [ sec : loadmasking ] . because the gpu - accelerated and cpu - bound codes have different ratios of analysis - to - generation costs @xmath69 , their optimal number of macroupdates between analysis @xmath54 are different ( see eqs.([eq : optimalcpu][eq : optimalgpu ] ) ) .",
    "benchmarking conditions are detailed in section  [ sec : benchmarking ] .",
    "only one core was used on the cpu - side . for the accelerated code ,",
    "the raw random numbers were generated on the cpu - side , while the gpu performed the box - muller transformation , generated new configurations and computed the energy values .",
    "the number of walkers was chosen such that it provided the best occupancy for each number of particles @xmath25 .",
    "the optimal number of walkers varies between the cards .",
    "best results for k20 were achieved with 8 to 12 walkers per multiprocessor ( between 104 and 156 walkers in total ) , even for the largest systems shown in fig .",
    "[ fig : totalacceleration ] .",
    "the benchmarking results are shown in fig .",
    "[ fig : totalacceleration ] .",
    "the left panel shows the time , in seconds , that is necessary to reach the errorbar of 1  mk . in agreement with the central limit theorem",
    ", the product of the execution time @xmath141 and the square of the resulting error @xmath142 is an invariant , @xmath143 both for the cpu - only and gpu - accelerated execution this constant scales with the first order of the number of particles @xmath25 , due to self - averaging .",
    "this relation can be used to estimate the necessary execution time for a desired accuracy level . at low particle numbers ,",
    "acceleration is limited by the random numbers generation . as should be expected , this limitation is more severe for the higher - performance kepler gpus .",
    "for all gpus , we observe linear scaling of the time - to - error for systems with more than 512 particles .",
    "for a 512-atom system , a 1  mk errorbar is reached in just over two minutes on kepler k20 ( @xmath144 ) , and in under four minutes on m2090 ( @xmath145 ) .",
    "it is worth pointing out that this corresponds to a @xmath146 relative accuracy , more than satisfactory for most applications .",
    "the right panel of fig .",
    "[ fig : totalacceleration ] shows the resulting acceleration for each card .",
    "the values degrade for small particle number , as commented above . for systems with more than 500 atoms ,",
    "acceleration ratios remain relatively constant . for the 560ti ,",
    "the value equals to @xmath14750 , and for the tesla m2090 and k20 , acceleration exceeds a factor of @xmath147120 .",
    "k20 was faster than m2090 for all system sizes .",
    "readers should be cautious when interpreting the acceleration ratios presented on the right panels of figs .",
    "[ fig : generatoracceleration ] and [ fig : totalacceleration ] .",
    "our benchmarks show acceleration by a factor of over @xmath147150 for generating new configurations and over @xmath147120 for the combined generation and energy calculations . as explained in section  [ sec : loadmasking ] , these were obtained by comparison with single - threaded execution on the cpu .",
    "modern multithreaded cpus , however , have up to eight cores and are capable of supporting as many as 16 threads .",
    "thus when comparing with the computational capability of an _ entire _ cpu , presuming nearly - ideal parallelization , one should remember to divide by the supported number of threads .",
    "misunderstandings of this sort often plague the interpretation of the gpu accelerator capabilities .",
    "the true `` benchmark '' for a program of this kind is its ability to compute observables . for quantum monte carlo calculations ,",
    "this amounts to the ability to reach a desired level of statistical accuracy .",
    "we have thus focused on the generation of the markov chain in general , and also used the energy as a reference observable .",
    "the performance for both of these functions can be clearly characterized in absolute terms . for the markov chain generation",
    ", one can find the rate at which new configurations can be produced , and for the energy calculation , one can record the time - to - error as explained above .",
    "this information is provided in the left panels of figs .",
    "[ fig : generatoracceleration ] and [ fig : totalacceleration ] .",
    "such `` observables performance '' can be readily compared between different programs and even methods .",
    "it is worth pointing out that the k20 was the best performing card .",
    "the execution times , shown in the left panels of figs .",
    "[ fig : generatoracceleration ] and  [ fig : totalacceleration ] , are smaller for the k20 than for the other two cards .",
    "the acceleration , shown in the right panels of the two figures , seems larger for the m2090 because the individual cpu cores of the machine with the m2090 where slower , thus slightly inflating the acceleration .",
    "in fact , the k20 was as much as one - third faster than the m2090 .",
    "this is remarkable given the already strong performance of the m2090 .",
    "the improvement was achieved by using the register - heavy routines as described in section  [ sec : implementation ] .",
    "the extraordinarily large amount of register space on kepler chips allowed to simultaneously process a larger number of walkers and thus keep the card occupancy high .",
    "the second advantage of the large register space of the k20 is that it is capable of handling much larger systems when using the register - heavy routines , as described in section  [ sec : implementation ] .",
    "the scaling behaviors shown in figs .  [ fig : generatoracceleration ]  and  [ fig : totalacceleration ] are preserved even for the largest systems .",
    "this is despite the fact that for large systems , one is limited to a single walker per multiprocessor .",
    "for example , generating one macroupdate for a 40960-particle calculation takes 418  ms ( this number takes into account the fact that there were 13 walkers in total ) .",
    "the energy - computing kernel uses extra memory to store wavefunction derivatives ; this kernel was used with up to 10240 particles .",
    "the ability to treat such large systems opens an access to a range of new applications .",
    "we have developed a remarkably efficient parallelization of bosonic variational monte carlo for graphical processing units . up to two thousand particles may be treated with an nvidia fermi gpu , and up to ten thousand with nvidia kepler cards .",
    "the gpu exhibits excellent speed results , which we measure as the time necessary to reach a level of statistical uncertainty in observables .",
    "the good acceleration is mainly due to two developments .",
    "first and foremost , the execution was organized to allow for shared memory persistence .",
    "the thread blocks of the gpu run uninterrupted for multiple steps , maintaining their walker information in shared memory or even in the register space .",
    "second , the produced configurations are written out by the gpu to host memory as the calculation progresses . the analysis and observable calculations can occur both on the gpu and on the cpu . the analysis on the cpu occurs simultaneously with the gpu generating the next configuration .",
    "this masks the cpu load and allows the developer to focus on improving the parallel fraction of the generating gpu kernel .",
    "the asynchronous execution results in a modified version of the amdahl law .",
    "existing cpu - based routines may be readily applied to the generated configurations , easing the transition to the gpu - parallel execution .",
    "the code is distributed in a form of a package that is ready to simulate liquid ^4^he . with minor modifications",
    ", it can be rendered to apply to a range of bosonic problems .",
    "author would like to thank the barcelona supercomputing center ( the spanish national supercomputing center ",
    "centro nacional de supercomputacin ) for the provided gpu facilities .",
    "d.  m. ceperley , an overview of quantum monte carlo methods , in : r.  wentzcovitch , l.  stixrude ( eds . ) , theoretical and computational methods in mineral physics , vol .",
    "71 of reviews in mineralogy & geochemistry , mineralogical soc .",
    ", 2010 , p. 129 .",
    "s.  zhang , s.  yamagia , s.  yunoki , a study of parallelizing @xmath148 green - function - based monte carlo method for many fermions coupled with classical degrees of freedom , j. phys .",
    "( 2013 ) 012049 ."
  ],
  "abstract_text": [
    "<S> we present a scheme for the parallelization of quantum monte carlo method on graphical processing units , focusing on variational monte carlo simulation of bosonic systems . </S>",
    "<S> we use asynchronous execution schemes with shared memory persistence , and obtain an excellent utilization of the accelerator . </S>",
    "<S> the cuda code is provided along with a package that simulates liquid helium-4 . </S>",
    "<S> the program was benchmarked on several models of nvidia gpu , including fermi gtx560 and m2090 , and the kepler architecture k20 gpu . </S>",
    "<S> special optimization was developed for the kepler cards , including placement of data structures in the register space of the kepler gpus . </S>",
    "<S> kepler - specific optimization is discussed .    </S>",
    "<S> quantum monte carlo , qmc , vmc , gpu , cuda , quantum liquid , liquid ^4^he    * program summary * +    _ manuscript title : _ fast quantum monte carlo on a gpu + _ authors : _ yaroslav lutsyshyn + _ program title : _ </S>",
    "<S> ql + _ journal reference : _ </S>",
    "<S> + _ catalogue identifier : _ </S>",
    "<S> + _ licensing provisions : _ none + _ programming language : _ cuda - c , c , fortran + _ computer : _ pc intel i5 , xeon cluster , gpus gtx 560ti , fermi m2090 , tesla k20 + _ operating system : _ linux + _ ram : _ typical execution uses as much ram as is available on the gpu ; usually between 1  gb and 12  gb . minimal requirement is 1  mb . </S>",
    "<S> + _ number of processors used : _ </S>",
    "<S> + _ supplementary material : _ </S>",
    "<S> + _ keywords : _ gpu , cuda , qmc , quantum monte carlo , variational monte carlo , quantum liquid , liquid ^4^he + _ classification : _ 4 quantum monte carlo , 6 cuda + _ external routines / libraries : _ + _ subprograms used : _ </S>",
    "<S> + _ nature of problem : _ + ql package executes variational monte carlo for liquid helium-4 with aziz ii interaction potential and a jastrow pair product trial wavefunction . </S>",
    "<S> sampling is performed with a metropolis scheme applied to single - particle updates . with minimal changes , </S>",
    "<S> the package can be applied to other bosonic fluids , given a pairwise interaction potential and a wavefunction in the form of a product of one- and two - body correlation factors . </S>",
    "<S> + _ solution method : _ + the program is parallelized for execution with nvidia gpu . by design , the generation of new configurations is performed with shared memory persistence and the asynchronous execution allows for the cpu load masking . </S>",
    "<S> + _ restrictions : _ + code is limited to variational monte carlo . due to the limitation of the shared memory of gpu , only systems under 2@xmath0000 particles </S>",
    "<S> can be treated on the fermi generation cards , and up to 10@xmath0000 on kepler cards . </S>",
    "<S> + _ unusual features : _ </S>",
    "<S> + _ additional comments : _ </S>",
    "<S> + _ running time : _ + because of the statistical nature of monte carlo calculations , computations may be chained indefinitely to improve statistical accuracy . as an example , using the ql package , the energy of a liquid helium system with 1952 atoms can can be computed to within 1mk per atom in less than 20 minutes . </S>",
    "<S> this corresponds the relative error of @xmath1 . </S>",
    "<S> it is unlikely that a higher accuracy may be needed . </S>"
  ]
}