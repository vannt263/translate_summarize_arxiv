{
  "article_text": [
    "context - oriented programming ( cop ) aims at software modularization , with focus on considering contextual behavior  @xcite .",
    "it enables us to implement context - aware behavior separately .",
    "central to cop are _ layers _ ,",
    "i.e.  the modules for such code .",
    "active layers encode the current context of an application",
    ".    _ contextual values _ ( cvs ) are variables whose values depend on context , i.e.  active layers .",
    "cvs fit nicely into cop ideas because of their seamless integration with layers .",
    "side - effects of cvs are limited to their respective context .",
    "their main advantage is their simplicity because cvs `` boil down to a trivial generalization of the idea of thread - local values ''  @xcite .",
    "currently many cop languages do not provide straight - forward , context - aware activation of layers .",
    "instead they mainly support code - snippets for activation  @xcite , e.g. :    .... activate ( austria ) if ( gps_pos==\"austria \" ) ....    in this example , we activate the layer |austria| according to the current gps position .",
    "developers can easily miss some context information at some places , considering that activations are spread across the whole source code .",
    "another problem cop languages currently face is that layer information can not easily be shared between applications .",
    "solutions with context - oriented middleware are often not light - weight and need special tools for introspection and debugging .",
    "we propose to persist layer information into configuration files . while it is well - known how to persist objects , we lack similar techniques for layers .",
    "because of this issue , it is difficult to separate context sensors and applications .",
    "often the same sensed context , however , is needed in several applications which leads to duplication of efforts .    in this paper we describe the novel idea to use persistent contextual values for layer activation .",
    "our goal is to combine layer activations with cvs that are shared across applications . in our approach",
    "we will use cvs as parameters for |activate| and |with| constructs .",
    "cop languages commonly use these constructs for layer activation  @xcite .",
    "our main contribution is a fully implemented framework fulfilling the above goals .",
    "it has already successfully been used in embedded systems .",
    "it does not make any assumptions of the application s architecture .",
    "our implementation provides ( 1 ) generated cvs to be used like variables , and ( 2 ) initialization , persistency , and notification for them .",
    "it supports many languages , including c++ and java .",
    "because cvs are context - aware they will automatically consider their context . by",
    "persisting cvs we synchronize layer activations between applications .",
    "our technique even works across different programming languages .    to be better suitable for mobile development",
    "one additional goal is that accessing cvs should not add overhead .",
    "instead it should deliver the same performance as reading native variables .",
    "thus our approach relies on explicit activation and a cache for every cv  @xcite .",
    "we avoid the |if| in the |austria| layer activation above .",
    "instead we would activate the contextual value |position| :    .... activate ( position ) ....    this way , due to cv semantics , contexts of |position| are automatically considered .",
    "the contextual value would be persistent and shared between applications .",
    "when a context sensor has new information available , other applications would be notified via our framework .",
    "for example , think about internationalized software .",
    "cvs help us to easily show correct translated messages .",
    "currently , however , we have to activate the correct layers in every cop application individually .",
    "there was no easy way for one application to tell all other applications that the language has changed .",
    "we want to be able to activate layers with cvs :    a code generator yields the classes |person| and |language| .",
    "they implement cvs semantics . in the line 2",
    "we activate the contextual value    startup .",
    "this initialization provides sensible defaults changeable by user settings or context .",
    "we answer the following research questions :    rq1 : :    : how can contextual values be used for layer activation ?",
    "which    limitations does it have ?",
    "rq2 : :    : what are the costs of inter - process layer activation ?",
    "the questions are significant because it is common that we face a number of applications and programming languages in our system . such a combination , however , currently is not well supported by cop .",
    "our idea is not only feasible but practical as demonstrated by a prototype .",
    "the paper is structured as follows : in section  [ background ] we explain the background .",
    "in section  [ approach ] we elaborate our approach and in section  [ evaluation ] we evaluate it . after considering related work in section  [ related ] , we conclude in section  [ conclusion ] .",
    "we implemented our approach as tool called elektra . in this section",
    "we will explain the essence and syntax previous versions of elektra .",
    "earlier versions lacked possibilities to use cvs for activations and needed extra layer specifications .",
    "cvs are very useful to interact with a program execution environment ( pee ) , i.e.  configuration files and environment variables .",
    "cvs ensure that the context always is taken into account when accessing the pee .",
    "pee is an elegant way to persist cvs : we write key - value pairs into configuration files .    for pee",
    "the performance focus lies on retrieving values .",
    "modification of the pee is usually only done manually by users when they change settings .",
    "thus , when changing pee , proper validation is more important than performance . in earlier work we demonstrated that pee can be tightly integrated with cvs  @xcite .",
    "we propose the adoption of pee as cv storage and maintain the goal to have fast access when reading cvs .    in our approach , a small library abstracts from syntax and location of the configuration files .",
    "elektra uses the pee , such as configuration files , to initialize contextual values .",
    "elektra supports over 190 configuration file formats , including ini , xml and json formats . in this paper",
    "we will use a simple key - value syntax to illustrate the content of the key - value database . to easily distinguish configuration and its specification in this paper , we use : ( 1 ) assignment with |=| for configurations containing the values of every cv , ( 2 ) keys written in     in the first line of the example above we _ configure _ the option identified with the key |path / key| . as hierarchy separator we use |/| .",
    "the key |key| is below |path| and has the value |value| . in lines 3 and 4",
    "we specify two properties for the same key |path / key| : they are called     in the key - value database , for example :    in this example , the cv has 3 different possible values with |*| as wildcard expression .",
    "furthermore , within the same configuration files , we can also _ specify _ contextual values .",
    "for example , we specify the cv     the respective key in line 1 , i.e.  the full string within |[]| , is a contextual value s name .",
    "lines 2 - 3 further specify the contextual value with |:=| assignment . here",
    "we specify that the cv |greeting| has the type |string| .",
    "in elektra a code - generator synthesizes context - aware classes using contextual value specifications .",
    "the tool generates the code for the underlying cv - classes |person| and |greeting| .",
    "often it is useful to give layers a name  @xcite .",
    "our approach consistently gives every layer a name , written within |[]| .",
    "all generated classes are nested in one hierarchy with |/| as root .",
    "a single cv has many values for each context . in the specification strings enclosed in |for contextual interpretations we substitute the placeholders with values given by layers .",
    "unique keys to lookup individual values are determined by substituting all placeholders with values from the layers .",
    "we use these keys to lookup values in the configuration files .",
    "when no layer was found , the |*| in the configuration file will match .",
    "the character means that the layer is inactive or empty . in the above example",
    ", if the only active layer is |language| with the value |german| , an instance of the class |greeting| has the value |guten tag!| .",
    "developers directly utilize the contextual values in their own code .",
    "cvs are used in the same way as variables .",
    "as example we extend our previous c++ snippet :    the |person|-object |p| is a contextual value passed via reference parameter on line 1 .",
    "dynamically scoped context is specified via the    are layers , but not persistent contextual values . within the dynamic scope of the block after |with| statements ,",
    "the content of cvs can differ .",
    "for example , when we modify the nested contextual value |visits| in line 4 , the changes are only visible within the |with| block . in line 8 ,",
    "the previous values are restored .",
    "our approach has introspection capabilities .",
    "we easily can inquiry layer information as done in line 6 .",
    "the introspection is useful for debugging and assertions  @xcite .",
    "the issue with the former approach is the implementation of the layers used in lines 2 and 3 .",
    "the previous approach forced us to implement a layer for every contextual variation .",
    "developers needed to manually implement features such as thread safety , contextual awareness and persistence for every layer . with many layers for highly - dynamic context - aware applications",
    "their implementation can be a burden . in this paper",
    "we describe how we can avoid this extra effort and exclusively use cvs specified in configuration files .",
    "we extend elektra with the possibility to directly activate cvs . we consider a layer to be active , when a cv is non - empty . as side - effect",
    ", this idea enables inter - process activation of layers because of the persistency of cvs . to synchronize layers with cvs we lack two essential features :    * we need an intra - process notification which allows us to update the context of cvs when other cvs , representing layers , change .",
    "* we need an inter - process notification to know when to reread configuration files .",
    "one of the main benefits of activation of cvs is that we automatically get contextual activation .",
    "we do not have to worry for every activation if every dependent context is considered .",
    "for example , we have the following cvs :    and we want to successively activate these cvs :    if |location| and |country| were layers as described in background exactly these layers would be activated in the given order .",
    "this means that the activation in line 3 will not consider the location activated in line 4 .    but because |location| and |country| are cvs , they take context into account and the activations influence each other . in this example after the activation of |location| , |country| will be updated according the new position . line 4",
    "will also update the |country| layer according to the established context .",
    "for example , if |location| is an empty string , no layer is activated . with symbolic links in the cvs specification",
    "@xcite one can implement even more complex scenarios . in line 5 the greeting",
    "will be according to local customs or some default if the cvs |country| and |location| are inactive .",
    "the value of cvs usually is determined by context sensors that run as separate active processes .",
    "their task is to track low - level sensor values such as gps and pool them to high - level context as needed by other processes .",
    "the main advantage of this approach is the reuse of context information and the decoupling between processes .",
    "for convenience we decided that by default the last part ( separated with    keys are specified within |[]| .",
    "this convention gives most cvs an appropriate layer name :    in above example , the cv - class |country| will automatically have the layer name |country| when activated . in some situations the last part of the name is not the right choice .",
    "for example , we use a country code to determine a country :    layer names , unlike cv - classes , do not provide a hierarchy .",
    "we likely do not want the layer to be named |code| , thus we rename it to |country| as specified by |layer / name| .",
    "then activation of such a cv activates the layer |country| .",
    "in previous versions of elektra it was assumed that every change of a cv is caused by the assignment to a cv . in this extension",
    "we avoid this assumption .",
    "we introduce a reload mechanism when the underlying persistent cvs change .",
    "we implement such a mechanism by an intra - process notification .",
    "for this functionality we use the observer pattern . the cvs act as observers , the context is the concrete subject . for in - memory synchronization",
    "the method |sync| can be used :    in line 2 we fetch all values for every context from the configuration files . in line 3",
    "we call the in - memory update of all cvs to reload their value .",
    "the |sync| invocation also makes sure that the correct layers are active .",
    "the persistency layer has two further methods for synchronization in both directions : with |kdb.get| modified configuration files are parsed , with |kdb.set| changes are written to the configuration files . this way the application developer decides about the behavior in the case of conflicts .",
    "because a three - way merge is the most - requested behavior , a convenience api exists for this case .    because we want cvs to act as layers we can not update the observers in an arbitrary order .",
    "instead we need to consider the dependencies between cvs .",
    "cvs with placeholders depend on cvs that have the placeholders name as their layer name .",
    "for example , |country| needs to be updated before    have dependencies .",
    "then we update cvs that are dependent on layers that were updated before .",
    "elektra solves this ordering problem with a topological sort based on kahn  @xcite .    because in our approach hooks can be registered to be executed on layer activation  @xcite",
    ", users might need a specific order .",
    "thus users can describe a specific order of activation .",
    "for example :    in the example , no dependency is given .",
    "thus any order would be correctly topological sorted .",
    "but because of the users preference in    user can be sure that |country| hooks would be executed before        with layers and cvs as completely separate concepts cycles were not possible : cvs depended on layers , but not the other way round .",
    "an issue of our approach is that we introduce potentially cyclic dependencies .",
    "for example :    if we activate |country| we would need the value of the current    before does not help with this issue .",
    "with specific values stored , every activation leads to toggling values :    such cycles usually stem from design errors and are unwanted . in our approach",
    "we prohibit such cycles .",
    "we introduce a limitation that causes some previously valid specification files to be rejected .",
    "these cases can already be detected when parsing the specification .",
    "if the specification nevertheless is faulty , the user will receive a run - time exception .      because cvs are frequently accessed ,",
    "we want to avoid any overhead when reading the value of cvs .",
    "we achieve this behavior by requiring the developer to define synchronization points . at synchronization",
    "points new values are pushed to cvs using the observer pattern . only during synchronization points",
    "performance overhead occurs . otherwise reading cvs has the same overhead as accessing native variables  @xcite .",
    "another advantage of explicit synchronization points is that the user has full control over costs occurring in the program .",
    "making synchronization points explicit might seem to be cumbersome to program .",
    "but in practice it is often obvious where synchronization should occur : when a user starts a new interaction . with a use - case - based software engineering approach",
    "one can systematically find all such places . forgetting about a synchronization point",
    "will only affect the specific interaction .",
    "in mostly single - threaded applications , which do not sense context itself , it is even simpler : one only synchronizes the main - thread when the application is notified .",
    "the synchronization points define when intra - process updates will take place .",
    "the context will push all changes to the respective cvs . for example :    in the example above , we introduce a synchronization point in line 2 . all mentioned reloading features only happen during this invocation .",
    "the contextual value |a| is not modified by context changes or changes of persistent cvs at other places .",
    "this means , that the programmer can be sure that |a| is not changed during the loop starting on line 3 .",
    "another property of our approach is that after an initial activation , every ( de)activation can occur via changing the values of cvs :    the precondition that layers are influenced via assignments is fulfilled in line 2 . in line 3",
    "we see an assignment to an empty string .",
    "layers with an empty value influence cvs in the same way as deactivated layers . but",
    "only after explicit deactivation in line 7 , changes of the cv |lang| do not influence other cvs anymore .",
    "synchronization via |sync| activate or deactivate layers in the same way as the assignment does .",
    "one can think of |sync| as correctly ordered assignment of every cv .      because of diverse requirements we took care that elektra follows very modular design principles  @xcite .",
    "the inter - process notification requirements differ from system to system .",
    "we decided to implement inter - process notification in plugins .",
    "whenever a process modifies the underlying configuration files plugins take care of notification .",
    "it is trivial to include notification mechanism that already implement a message bus . in the plugin you only have to publish the message without any further concerns . in every interested process",
    "one has to implement a listener that fetches the updated configuration .",
    "after every thread has passed a synchronization point , the application is fully updated to the new configuration .    implementing an inter - process notification without a message bus",
    "is more challenging .",
    "nevertheless such an endeavor is useful for legacy applications .",
    "notification via signals are very popular because they are part of c89 and posix .",
    "the idea is that every process using elektra registers its process identifications ( pids ) at startup . whenever configuration files change , a plugin sends a signal to all registered pids . within individual applications",
    "one has to install a signal handler .",
    "the signal handler is limited to atomic changes .",
    "thus it can only flag that such an event occurred and other threads can pickup the changes later .",
    "the update to current persistent cvs themselves is via |kdb.get| as shown before . on conflicts elektra",
    "usually uses a three - way merge to not lose data on concurrent updates of other processes .",
    "we benchmarked elektra on a hp^^ elitebook 8570w using the central processor unit ( cpu ) intel^^",
    "core^^ i7 - 3740qm with 4 cores @ 2.70ghz .",
    "the operating system was debian gnu / linux jessy 8.4 amd64 .",
    "we used the compiler gcc .",
    "we start with microbenchmarks that measure the cost of different synchronization methods .",
    "as we see hard coded in the code snippets below , we used 1000 iterations .",
    "we only show the mean value of the 11 measurements we did for every microbenchmark .",
    "we created four microbenchmarks for each line in figure  [ fig : switch ] .",
    "we designed the microbenchmarks in a way that they are valuable for the decision when which activation strategy should be used .",
    "first we start to explain the individual microbenchmarks , then discuss the results .",
    "for all four microbenchmarks we will use the same setup :    the first test , called |benchmarkactivate| , measures activation with layers . in line 2",
    "we start the measurement and stop it at line 10 . in lines 5 - 7 the relevant action takes place . in line 8",
    "another contextual value gets accessed to avoid too aggressive compiler optimizations . note that reading elektra cvs is without any overhead compared to access of native variables , so the line 8 does not influence the benchmark measurable :    in the second microbenchmark ( |benchmarkactivatecv| ) , we used the cv - activation feature introduced in this paper . in the relevant lines 5 to 7 , we now have activation of @xmath0 to @xmath1 cvs . in this benchmark ,",
    "activation of layers only happens implicitly .",
    "note that again the numbers of activations increase with the number of cvs :    as third benchmark , we used the |sync| feature introduced in this paper .",
    "the synchronization in line 6 will synchronize all @xmath1 different cvs . in this benchmark",
    "we do not reload from persistent storage .",
    "nevertheless , the implementation must recalculate every activation of every cv .    in the last microbenchmark , we fully reload configuration files from disk .",
    "the challenge of this benchmark is an optimization of elektra .",
    "the operation to fetch data from persistent storage would not reload without changes .",
    "thus we used for every iteration a different handle to fetch from persistent storage ( lines 2 and 3 ) .",
    "this ensures that the configuration file is actually reread :        we see in figure  [ fig : switch ] that the overhead increases linearly the more cvs or layers are involved .",
    "more flexible activation scenarios are more expensive .",
    "especially , reloading from configuration files introduces a relatively large , but constant , offset . note that we used a text configuration file parser .      in a case study we implemented a web server that outputs localized html pages .",
    "remote users can connect to the web server that is installed on an embedded device .",
    "for localization and session handling the web server heavily relies on cvs .",
    "because of the features cvs provide , these parts were trivial to implement .",
    "additionally the web server works together with context sensors that modify persistent cvs .",
    "for example , one sensor detected motion .    during implementation we found cvs very useful .",
    "the specification file was 87 lines and contained 17 cvs . from this specification file 3623 lines of code defining all cvs as classes in one large hierarchy",
    "were generated .",
    "the boilerplate code ( lines 1 to 10 ) left to write is minimal :    in line 12 we see how we can access cvs in the hierarchy .",
    "we call the function we defined earlier in the paper .    for the benchmark we created one additional thread . in the thread",
    "the web server periodically syncs with persistent changes in the same way as    requests / seconds the reply / seconds did not increase significantly anymore . to measure if context changes influence the functionality of the web server we used httperf on the same machine |l| :        as you see in figure  [ fig : lock ] the sync rate barely has influence on the request and replies the web server can deliver . only at sync rates below 3",
    "ms there is an effect .",
    "a possible explanation is that other cpu cores can compensate easily as long as the required lock during |sync| does not dominate .",
    "timeouts of requests were nearly always 0 except for sync rates of about 3 ms or when influencing the setup .",
    "we see that elektra can be practically used for embedded applications and that the number of context changes only has minimal effect , even across applications .",
    "lwis et al .",
    "@xcite also implemented cvs .",
    "they call them context variables",
    ". their layer activation ( they call it binding of cvs ) requires the programmer to explicitly declare layers .",
    "thus their approach is very similar to previous versions of elektra and would benefit from the approach described here .",
    "kamina et al .",
    "@xcite proposed a generalized activation mechanism based on contexts and subscribers .",
    "their implicit activation , however , has severe impact on the performance .",
    "very early work ( 1979 ) on contextual values is done by asirelli et al .",
    "their contextual values are depending on state .",
    "we could not find specific information , but their system may have achieved something similar to elektra .",
    "different from elektra , they use context - value pairs which do not encode variability information in their keys .",
    "montangero et al .",
    "@xcite described garbage collection techniques for cvs .",
    "wang et al .",
    "@xcite proposed a new metric useful for testing context - aware applications .",
    "information present in the specification of elektra helps to improve testing , too .",
    "elmongui et al .",
    "@xcite described context - aware dbms . because elektra focuses on persisting cvs",
    "the approaches seem to be complementary : such query languages could be an extension for some use cases of elektra .",
    "we also proposed to move the context awareness to a key - value database  @xcite . using interception techniques ,",
    "unmodified applications were made more context aware .",
    "mens et al .",
    "@xcite created a taxonomy of context - aware software variability approaches .",
    "they explicitly mention the execution environment to be an important source for context . based on the taxonomy , elektra has a closed form of variability , when only the values of cvs can change",
    ". then changes of behavior are limited to the code already present in the program .",
    "elektra has its focus on contextual ( not context ) features .",
    "elektra uses an one - branch context tree : without placeholders cvs are automatically non - context - aware configuration items .",
    "additionally , elektra supports programmer - declared dependencies .",
    "umuhoza et al .",
    "@xcite compared different ways for code generations on mobile development .",
    "their methods do not have specific support for context .",
    "williams et al .",
    "@xcite and biegel et al .",
    "@xcite presented frameworks for development of context - aware applications .",
    "contextphone  @xcite is a further prototyping platform for context - aware mobile applications .",
    "their approaches focus on developing context sensors , which complements our approach .",
    "in this paper we presented the idea to use persistent contextual values ( cvs ) as information source whether layers are active .",
    "we discussed several benefits and limitations of the approach : ( 1 ) the activations themselves take context into account .",
    "( 2 ) persistent cvs can be used to synchronize layers across different applications in different programming languages .",
    "the approach simplifies taking current context into account and sharing context with other applications .",
    "furthermore it provides support for individual customization .",
    "end - users can add or redefine configuration in specific context .    in the benchmarks , we showed that activation of cvs is not much more expensive than original layer - activation .",
    "synchronization of all cvs with configuration files , however , is more costly .",
    "luckily , the overhead is only constant . in a real - world benchmark",
    "we showed that the sync rate barely has an influence in a web - server setup .      1 .",
    "this combination of performance , context awareness and customization is unique to our approach .",
    "elektra enables programmers to use cvs with code generation in multi - threaded and multi - process applications .",
    "cvs can even be shared across applications .",
    "our implementation is free software and can be downloaded from http://www.libelektra.org .",
    "it supports mobile development in c++ , java and other languages .",
    "4 .   in a case study we described our experience with mobile development , and analyzed the performance in microbenchmarks and with a web server"
  ],
  "abstract_text": [
    "<S> mobile applications today often fail to be context aware when they also need to be customizable and efficient at run - time . </S>",
    "<S> context - oriented programming allows programmers to develop applications that are more context aware . </S>",
    "<S> its central construct , the so - called layer , however , is not customizable . </S>",
    "<S> we propose to use novel persistent contextual values for mobile development . </S>",
    "<S> persistent contextual values automatically adapt their value to the context . </S>",
    "<S> furthermore they provide access without overhead . </S>",
    "<S> key - value configuration files contain the specification of contextual values and the persisted contextual values themselves . by modifying the configuration files , the contextual values </S>",
    "<S> can easily be customized for every context . from the specification , we generate code to simplify development . </S>",
    "<S> our implementation , called elektra , permits development in several languages including c++ and java . in a benchmark </S>",
    "<S> we compare layer activations between threads and between applications . in a case study involving a web - server on a mobile embedded device </S>",
    "<S> the performance overhead is minimal , even with many context switches . </S>"
  ]
}