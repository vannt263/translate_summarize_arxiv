{
  "article_text": [
    "the following _ peeling process _ can be used to find the @xmath0-core of a hypergraph : vertices with degree less than @xmath0 are repeatedly removed , together with their associated edges . the @xmath0-core is easily shown to be the maximal subgraph where each vertex has degree at least @xmath0 ; it is therefore uniquely defined and does not depend on the order vertices are removed in the peeling process . peeling processes , and variations on it ,",
    "have found applications in low - density parity - check codes @xcite , hash - based sketches @xcite , satisfiability of random boolean formulae @xcite , and cuckoo hashing @xcite . usually in the design of these algorithms",
    "the primary question is whether or not the @xmath0-core is empty , and an empty @xmath0-core corresponds to a success .",
    "we say that a hypergraph is @xmath0-_peelable _ if it has an empty @xmath0-core .",
    "if the @xmath0-core is not empty , a natural question to ask is how many edges or vertices need to be removed to yield an empty @xmath0-core .",
    "this question may have algorithmic implications .",
    "for example , consider a multiple - choice hash table of the following form .",
    "there are @xmath3 keys and @xmath4 buckets ; each key has @xmath5 possible buckets where it can be placed ; and each bucket can hold at most @xmath6 keys . by associating buckets with vertices and keys with hyperedges ( each key being an edge of its @xmath5 possible buckets )",
    ", we see that peeling can naturally provide an assignment of keys to buckets satisfying the constraints .",
    "when a vertex is removed , the bucket obtains all the keys corresponding to adjacent edges ; if the peeling yields an empty hypergraph , all keys have been placed . in this",
    "setting , removing an edge from the hypergraph before peeling can correspond to placing a key into a separate structure , often referred to as a stash .",
    "if a suitably sized stash can be implemented , peeling can efficiently find an assignment , leading to the question of how many edges need to be removed so the remaining hypergraph is @xmath0-peelable . even without such algorithmic implications ,",
    "the minimum number of vertices or edges to remove to obtain a @xmath0-peelable graph appears a natural and interesting graph theoretic question .",
    "here we prove that determining the minimum number of vertices , or the minimum number of edges , that need to be stashed ( removed from the graph ) so that a @xmath5-regular hypergraph is @xmath0-peelable is np - complete for any @xmath7 .",
    "the only exception is that , in the case of edges , determining the minimal stash is solvable in polynomial time for @xmath8 ; that is , for 2-cores on standard graphs .",
    "although we believe the case of @xmath8 is well understood , we briefly review it section  [ polytime ] . given the connection to stashes for cuckoo hash tables , we call this class of problems _ stash problems_.    we note that a similar problem was recently considered in @xcite . in their variation , they look at the _ anchoring problem _ : given a budget @xmath9 , find the subset @xmath10 of @xmath9 vertices such that peeling the graph of vertices from @xmath11 of degree less than @xmath0 yields the maximum number of remaining edges . that is , the chosen subset @xmath10 can not be peeled , and serves as an anchor for the @xmath0-core .",
    "they show that when @xmath12 , the problem is solvable in linear time , and when @xmath13 the problem is np - hard and further is np - hard to approximate within an @xmath14 factor for any constant @xmath15 .",
    "one way of viewing the anchoring problem is that it",
    "_ adds _ to the graph ; for example , by replacing a vertex in @xmath10 by a clique of size at least @xmath0 ( and appropriately connecting edges ) , one can guarantee that vertex is anchored .",
    "in contrast , our goal in stash probelms is to _ remove _ vertices or edges from the graph .    in",
    "what follows , we define terms and briefly consider the case @xmath16 .",
    "we then show the problem of finding the optimal stash size when stashing vertices is np - complete for @xmath1 by a reduction from vertex cover .",
    "we then reduce the problem of finding the optimal stash size for vertices to the problem for edges .",
    "recall that we say that a hypergraph is @xmath0-peelable if it has an empty @xmath0-core .",
    "a _ k - vertex - stash _ of a hypergraph is a subset of vertices @xmath17 such that @xmath18 is @xmath0-peelable .",
    "( of course removing a vertex also removes all adjancent edges . ) similarly , a _",
    "k - edge - stash _ of a hypergraph is a subset of edges @xmath19 such that @xmath20 is @xmath0-peelable . for fixed values @xmath0 and @xmath5 , the decision problem",
    "@xmath0-vertex - stash@xmath21 ( respectively @xmath0-edge - stash@xmath21 ) asks whether the @xmath5-regular hypergraph @xmath22 has a minimal @xmath0-vertex - stash ( respectively @xmath0-edge - stash ) of size at most @xmath23 .",
    "we use @xmath0-vertex - stash and @xmath0-edge - stash where the meaning is clear .",
    "we note that we could also consider non - regular hypergraphs in this framework as well , but since stashing on these graphs can easily be reduced to stashing on regular hypergraphs , we consider only regular hypergraphs here .",
    "we refer to 2-regular hypergraphs as standard graphs for clarity and convenience .",
    "when we say problem1 @xmath24 problem2 , we mean that there is a polynomial time reduction from problem1 to problem2 . in most proofs",
    ", we do not explicitly say the reductions can be done in polynomial time since their implementations are easily seen to be linear .",
    "for standard graphs , the 2-core is empty precisely when the graph has no cycles .",
    "it follows readily that for 2-edge - stash the minimum number of edges that need to be removed equals the minimum number of edges that need to be removed so that the graph has no cycles ; this well - known quantity is the _ cyclomatic number _ of the graph , @xmath25 .",
    "we note @xmath26 is easily computed in polynomial time by starting with an empty graph , inserting the edges of @xmath27 one at a time in any order , and setting aside any edge that forms a cycle , incrementing @xmath26 accordingly .",
    "( standard union - find algorithms can be used to test for cycles . )    as we show later , the corresponding vertex stash problem for standard graphs is actually np - complete .",
    "to start , it is clear that @xmath0-vertex - stash is in np for any @xmath5-regular hypergraph as the certificate is just the @xmath0-vertex - stash . also , the standard np - complete vertex cover problem is the degenerate problem 1-vertex - stash .",
    "that is , since a graph has an empty 1-core if and only if it consists of a collection of isolated vertices , the smallest number of vertices to remove for 1-vertex - stash is the size of the minimum vertex cover .",
    "this connection suggests a reduction from vertex cover .",
    "a vertex cover of @xmath27 is a set of vertices @xmath28 such that all edges in @xmath27 are adjacent to at least one vertex in @xmath28 .",
    "the np - complete decision problem vertex - cover@xmath29 asks if @xmath27 has a vertex cover of size at most @xmath23 .",
    "vertex - cover @xmath24 @xmath0-vertex - stash for @xmath1 .    given a hypergraph @xmath27",
    "we construct a hypergraph @xmath30 by adding vertices and edges to @xmath27 such that @xmath31 is a minimal vertex cover of @xmath27 if and only if @xmath31 is a minimal @xmath0-vertex - stash of @xmath30 .",
    "to create @xmath30 , we replace every edge @xmath32 by a subgraph @xmath33 with the following properties",
    "2 .   each vertex @xmath35 has degree at least @xmath0 .",
    "if either @xmath36 or @xmath37 is removed , @xmath33 has an empty @xmath0-core .",
    "4 .   @xmath33 has @xmath0 edges adjacent to @xmath36 and @xmath0 edges adjacent to @xmath37 .",
    "@xmath33 has no edges connected to any vertex in @xmath27 apart from @xmath36 and @xmath37 .    to show that such hypergraphs exist , we first provide the construction for standard graphs ( @xmath38 ) .",
    "given @xmath39 , we construct @xmath33 by adding @xmath0 new vertices ( that we number from 1 to @xmath0 for convenience ) , with each of these vertices connected to both @xmath36 and @xmath37 . also , vertices @xmath40 and @xmath0 have @xmath41 additional edges to vertices @xmath42 but not to each other , while vertices @xmath43 have edges to all @xmath0 vertices .",
    "the third property is satisfied since if @xmath36 or @xmath37 is removed , vertices 1 and @xmath0 will then have degree @xmath41 and can be peeled , which reduces all other vertices to degree @xmath44 , allowing them to be peeled , which completely removes @xmath33 .",
    "the other properties are clearly satisfied .    for @xmath45",
    ", simply add @xmath46 extra `` dummy '' vertices that are adjacent to every hyperedge in @xmath33 . since @xmath33 has at least @xmath0 edges , these @xmath47 vertices have degree at least @xmath0 .",
    "all other properties are easily seen to be satisifed .",
    "for various @xmath5 and @xmath0 .",
    "@xmath36 and @xmath37 are highlighted in green .",
    "top left : @xmath48 .",
    "top right : @xmath49 .",
    "bottom : @xmath50 with the dummy vertex in red . ]     for various @xmath5 and @xmath0 . @xmath36 and @xmath37 are gray and marked with an x. top left : @xmath48 .",
    "top right : @xmath49 .",
    "bottom : @xmath50 with the dummy vertex in the center shaded darker .",
    "the hyper - edges are denoted by shaded triangles and join the three nodes they each touch . ]    now , we show that finding the minimal vertex cover of @xmath27 can be reduced to finding the minimal vertex stash of @xmath30 .",
    "to start , we show that if @xmath30 has a @xmath0-vertex - stash of size @xmath23 , it has a @xmath0-vertex - stash of size at most @xmath23 consisting entirely of vertices from @xmath27 ; that is , we can repeatedly replace any @xmath35 in the stash with either @xmath36 or @xmath37 until the stash consists only of vertices from @xmath27 . to see this ,",
    "let @xmath51 be a @xmath0-vertex - stash of @xmath30 and suppose there exists @xmath52 such that @xmath35 for some @xmath53 .",
    "define @xmath54 and similarly for @xmath55 .",
    "we claim that @xmath56 and @xmath55 are @xmath0-vertex - stashes of @xmath30 .",
    "suppose that @xmath56 were not a @xmath0-vertex - stash .",
    "then @xmath57 would have a non - empty @xmath0-core @xmath58 and since @xmath59 is a @xmath0-vertex - stash , @xmath60 .",
    "however , removing @xmath37 allows @xmath33 to be peeled , giving a contradiction .",
    "the same holds for @xmath55 .",
    "hence if @xmath30 has a @xmath0-vertex - stash of size @xmath23 , it has a @xmath0-vertex - stash of size at most @xmath23 consisting entirely of vertices from @xmath27 .",
    "we can now show that @xmath27 has a vertex cover of size at most @xmath23 if and only if @xmath30 has a @xmath0-vertex - stash of size at most @xmath23 . in the forward direction ,",
    "let @xmath61 be a vertex cover for @xmath27 with size at most @xmath23 .",
    "since every edge in @xmath27 is adjacent to some @xmath62 , @xmath63 consists solely of the @xmath33 , each with either or both of @xmath64 removed .",
    "each of the @xmath33 can then be peeled , so @xmath63 has an empty @xmath0-core , and hence @xmath31 is a @xmath0-vertex - stash of @xmath27 .    in the other direction ,",
    "let @xmath65 be a @xmath0-vertex - stash of size at most @xmath23 ; as we have shown , without loss of generality , we can assume @xmath66 .",
    "suppose that @xmath51 were not a vertex cover of @xmath27",
    ". then @xmath67 would contain edge @xmath32 , so @xmath68 would contain the subgraph @xmath69 , which is not peelable , yielding a contradiction .",
    "this completes the reduction .",
    "we previously showed that 2-edge - stash for standard graphs has a polynomial time solution .",
    "we now show that @xmath0-edge - stash is np - complete for both @xmath13 ( on all graphs ) and @xmath2 , @xmath70 by a reduction from @xmath0-vertex - stash .",
    "of course it is clear that @xmath0-edge - stash is in @xmath71 , since one can check that a given stash leads to an empty @xmath0-core .    in",
    "what follows , we use the following definitions : a _ neighbor _ of a subgraph @xmath72 is a vertex @xmath73 such that @xmath37 shares an edge with some @xmath52 . a _",
    "neighboring edge _ of @xmath51 is any edge shared by any neighbor of @xmath51 and some @xmath52 .",
    "we may often refer to neighboring edges without specifying a precise neighbor ; it is understood that the neighbors will be specified later in a construction that uses @xmath51 .",
    "we call an edge _ internal _ to @xmath51 if it is in @xmath51 .",
    "lastly , define a subgraph @xmath66 as @xmath0-_unpeelable _ if no vertex of @xmath51 has degree less than @xmath0 , counting neighboring edges .    throughout the reduction , vertices or edges may be _ peeled _ or _ stashed _ ( removed but not by the peeling process ) .",
    "these two actions are mutually exclusive ; however , we say an edge or vertex is _ removed _ , meaning either peeled or stashed , if the distinction is irrelevant .",
    "finally , we have chosen to present the reduction by starting with a `` high - level '' argument , showing the properties of the graph gadgets we require , and then subsequently showing how to construct actual gadgets with these properties ( any construction satisfying these properties constitutes a valid gadget ) we believe this approach is more enlightening than starting with the gadgets without motivation .",
    "@xmath0-vertex - stash @xmath24 @xmath0-edge - stash for @xmath13 and @xmath74 .",
    "our main idea is to modify @xmath27 as follows : given a hypergraph @xmath27 , we construct a hypergraph @xmath75 such that stashing a vertex @xmath76 can be simulated by stashing an appropriate edge in @xmath75 . as a result ,",
    "the size of the minimal vertex stash in @xmath27 will be equal to the size of the minimal edge stash in @xmath75 .",
    "we do this by replacing @xmath37 with a subgraph @xmath77 so that this subgraph acts under peeling and edge stashing exactly as @xmath37 would act under peeling and vertex stashing , respectively .    to ensure that @xmath77 correctly simulates @xmath37 in the peeling process",
    ", we need to be able to both ( i ) completely @xmath0-peel @xmath77 in @xmath75 exactly when @xmath37 can be @xmath0-peeled in @xmath27 and ( ii ) ensure that stashing and thus removing @xmath37 from @xmath27 can be simulated by stashing an edge in @xmath77 .",
    "this requires that @xmath77 has some edge that can be stashed that allows the subgraph to be fully @xmath0-peeled .",
    "we formalize these properties as follows :    1 .",
    "the degree of @xmath37 in @xmath27 is the number of neighboring edges of @xmath77 in @xmath75 . also , if @xmath36 is a neighbor of @xmath37 , then @xmath77 shares a neighboring edge with some vertex in @xmath78 .",
    "2 .   provided that no internal edges are stashed , @xmath77 can be @xmath0-peeled if and only if it has fewer than @xmath0 neighboring edges remaining ( potentially after other removals of edges ) .",
    "3 .   there exists a non - empty set of internal edges + @xmath79 such that @xmath77 can be fully @xmath0-peeled if any @xmath80 is stashed .    notice that @xmath81 , and more generally : @xmath82 . by ( p3 )",
    ", @xmath77 can be peeled by stashing a single edge , so this construction establishes an equivalence between stashing an edge in @xmath75 and a vertex in @xmath27 .",
    "notice furthermore that @xmath27 can be @xmath0-peeled if and only if @xmath75 can be @xmath0-peeled , which follows from observing that if there is no @xmath76 with degree less than @xmath0 , none of the @xmath77 subgraphs can be peeled .",
    "let us assume for now that we can find such a @xmath77 .",
    "then we claim @xmath27 has a @xmath0-vertex stash @xmath51 of size at most @xmath23 if and only if @xmath75 has a @xmath0-edge stash @xmath83 of size at most @xmath23 . to prove the first direction ,",
    "let @xmath84 , choose one @xmath85 for each @xmath37 , and let @xmath86 be the corresponding edge stash .",
    "by ( p3 ) of @xmath77 above , stashing @xmath83 in @xmath75 allows all @xmath87 to be @xmath0-peeled , resulting in @xmath88 . since @xmath89 is @xmath0-peelable , @xmath90 is @xmath0-peelable ( with an edge stash of size @xmath91 ) .",
    "to prove the other direction , let @xmath83 be an edge stash of @xmath75 .",
    "let @xmath92 and note that @xmath93 . since @xmath94 , @xmath95 is @xmath0-peelable , so @xmath96 is @xmath0-peelable with vertex stash @xmath97 .",
    "this completes the reduction assuming that @xmath77 exists . in the following subsections ,",
    "we show that a suitable @xmath77 exists for both the cases @xmath13 , @xmath45 and @xmath98 .",
    "[ main - edge - stash ]      we define the key building blocks used in constructing @xmath77 for both cases .    a @xmath99block is a @xmath100unpeelable subgraph with @xmath9 neighboring edges that is @xmath100peelable if any of its neighboring edges is removed .",
    "[ def - stable - block ] a _ stable _ block of degree @xmath4 is a @xmath100unpeelable subgraph @xmath10 with the following properties :    1 .",
    "@xmath10 has @xmath4 neighboring edges .",
    "if no internal edge of @xmath10 is stashed , @xmath10 is @xmath100peelable if and only if all @xmath4 neighboring edges are removed .",
    "2 .   there exists a nonempty set @xmath101 of internal edges such that @xmath10 is @xmath100peelable upon stashing any @xmath102 .      to begin we assume that we have stable blocks and 3-blocks available , and then provide their construction . for vertex @xmath37 , let @xmath103 .",
    "as shown in figure  [ pkv ] , we can construct a @xmath77 that consists of :    * a copy of vertex @xmath37 , called the primary node . * @xmath104 instances of 3-blocks ( @xmath9-blocks with 3 neighboring edges ) .",
    "* a stable block @xmath10 , with @xmath104 neighboring edges .",
    "@xmath77 is constructed as follows : let @xmath105 be the neighbors of @xmath37 , and index the 3-blocks in @xmath77 as @xmath106 . for each edge @xmath107 , add 3 edges connecting @xmath108 to the primary node , stable block , and @xmath109 .    )",
    "of a single @xmath76 to @xmath110 .",
    "the green squares are 3-blocks , and the dark blue structure is the stable block . note that @xmath0 does nt play an explicit role in this structure - it is hidden in the structure of the @xmath9-blocks and stable block . ]    ) of a single @xmath76 to @xmath110 .",
    "the black squares are 3-blocks , and the large gray structure is the stable block . note that @xmath0 does nt play an explicit role in this structure - it is hidden in the structure of the @xmath9-blocks and stable block . ]",
    "this construction of @xmath77 satisfies the 3 required properties listed above .",
    "( p1 ) is satisfied by construction . if @xmath111 , the edge between @xmath77 and @xmath78 is the edge between @xmath112 and @xmath113 as described above .",
    "( p2 ) is ensured by the 3-blocks .",
    "note that the primary node has the same number of neighboring edges as @xmath77 at all times , since each 3-block is connected to a neighboring edge of @xmath77 and is adjacent to the primary node .",
    "thus , if any neighboring edge is removed , the degree of the primary node will decrease by 1 after peeling , and vice versa .",
    "we can use this to prove ( p2 ) : if @xmath77 has fewer than @xmath0 neighboring edges , the primary node has degree less than @xmath0 and can be peeled , which peels all the @xmath108 , leaving the stable block with no neighboring edges . since",
    "stable blocks can be peeled completely if they have no neighboring edges , @xmath77 can be fully peeled .",
    "conversely , if @xmath77 has at least @xmath0 neighboring edges , the primary node has degree at least @xmath0 and can not be peeled . in this case , it is clear that @xmath77 is unpeelable .",
    "the stable block ensures ( p3 ) , that there is an internal edge of @xmath77 that can be stashed that allows @xmath77 to be @xmath0-peeled .",
    "specifically , there is an edge that when stashed allows the stable block to be @xmath0-peeled , and subsequently the @xmath114-blocks in turn are @xmath0-peeeled .",
    "note that this means that @xmath115 .",
    "we now detail the constructions of @xmath99blocks and stable blocks .",
    "while we note that @xmath9-blocks exist for every @xmath116 and @xmath13 , we only require 2- and 3-blocks , so only we explicitly construct those .",
    "an example is given in figure  [ bblocks ] .",
    "* a 2-block consists of two `` hub '' nodes , each adjacent to a neighboring edge , and a clique of size @xmath6 .",
    "both hub nodes have an edge to each node in the clique .",
    "since every vertex in this block has degree @xmath0 , it can not be peeled .",
    "however , it s easy to see that if either neighboring edge is removed , the whole block can be peeled . *",
    "see figure  [ bblocks ] for 3-blocks with @xmath117 .",
    "note the special case for @xmath118 , which is a single node . for @xmath119 ,",
    "a 3-block is created by first having 3 hub nodes , each adjacent to one of the neighboring edges , which we call `` layer 0 '' .",
    "there are then @xmath6 nodes in `` layer 1 '' and a clique of size @xmath120 as `` layer 2 '' .",
    "each hub node shares an edge with each layer 1 vertex , and each layer 1 vertex shares an edge with each layer 2 vertex .",
    "if no edge is removed , the block can not be peeled , since the vertices in layers 0 and 1 have degree @xmath0 , while the layer 2 nodes have degree @xmath121 since @xmath122 .",
    "notice that if any neighboring edge is removed , the corresponding hub node will have degree @xmath41 and can be peeled , leaving all layer 1 nodes with degree @xmath6 , which after peeling leaves all degree 2 vertices with degree @xmath123 , allowing the whole block to be peeled .",
    "blocks for @xmath124 and @xmath125 . ]      before constructing stable blocks , we first construct what we call a _ simple stable block _ , which is a stable block with degree @xmath126 .",
    "it consists of a central vertex with degree @xmath127 , two 2-blocks , and ( @xmath128 ) 3-blocks .",
    "the central vertex connects to @xmath4 neighboring edges , and each of the remaining @xmath6 edges adjacent to the central vertex are shared with one of the @xmath6 2- or 3-blocks .",
    "the @xmath9-blocks themselves are connected : the @xmath129th @xmath9-block shares edges with the @xmath130st and @xmath131st @xmath9-block , as shown in figure  [ k-1stable ] .",
    "as a result , the 1st and @xmath132st @xmath9-blocks are 2-blocks , while the other @xmath128 of them are 3-blocks .",
    "this satisfies the two properties of a stable block , since :    1 .",
    "if at least one neighboring edge of the stable block remains and no internal edges are stashed , the central node has degree at least @xmath0 and can not be peeled .",
    "2 .   @xmath133 contains any edge adjacent to the 2- or 3-blocks .",
    "removing any of these edges will remove adjacent @xmath9-blocks and then successively all the other @xmath9-blocks , since they are connected .",
    "this leaves the single central node , which would then have degree at most only @xmath6 by construction .",
    "given the construction of stable simple blocks with degree @xmath134 , we can construct a stable block of arbitrary degree @xmath135 by using a @xmath6-ary tree of simple stable blocks , each of degree @xmath6 , constructed above .",
    "each neighboring edge of the central vertex of a simple stable block at depth @xmath129 is connected to a 2-block of a simple stable block at depth @xmath136 ( which requires converting said 2-block into a 3-block ) , so that the whole tree has at least @xmath4 neighboring edges .",
    "any excess neighboring edges at the base of the tree can be removed to give the tree exactly @xmath4 neighboring edges .",
    "see figure  [ generalstable ] for an illustration .    .",
    "again , red squares are 2-blocks , while green squares are 3-blocks .",
    "the highlighted edges of the root node are all in @xmath133 .",
    "notice that the tree is made entirely out of simple stable blocks . ]    .",
    "again , gray squares are 2-blocks , while black squares are 3-blocks .",
    "the thickened edges of the root node are all in @xmath133 .",
    "notice that the tree is made entirely out of simple stable blocks . ]",
    "this satisfies both the requirements of a stable block :    1 .",
    "if a neighboring edge exists , there is at least one simple stable block at the base of the tree .",
    "it , and its parents , and so on up the tree , can not be peeled assuming that no internal edges are stashed .",
    "it is also easy to see that the tree is then peeled if no neighboring edge remains .",
    "2 .   if @xmath137 is the root simple stable block of this tree , then @xmath138stable block ) .",
    "once the root simple stable block is peeled , its children can be peeled , and so on for the whole stable block .",
    "this completes the construction of @xmath77 . if @xmath37 has degree @xmath104 , then @xmath77 has size @xmath139 .",
    "this construction can be easily adapted for @xmath140 by simply adding an additional @xmath46 dummy vertices and extending each internal edge in @xmath77 to include these extra vertices .",
    "these dummy vertices will not affect the peeling , since a dummy vertex can not be peeled until there are fewer than @xmath0 edges remaining in the original graph .",
    "for this case , we require a different construction ; we do not use @xmath9-blocks in our construction of the stable block , and we require a slightly different construction for a suitable @xmath141 building block as well . at the heart of a stable block @xmath58 of degree @xmath142 is a @xmath143-ary tree : a tree where each node has @xmath143 children all joined to it via the same edge .",
    "( note this requires @xmath140 , and hence is consistent with the fact that the case @xmath144 is polynomial time . )",
    "this tree must have at least @xmath142 leaves .",
    "suppose @xmath145 are leaves of the tree connected to the same parent by the same edge .",
    "then extra nodes @xmath146 are created , in addition to the edges @xmath147 for each @xmath148 .",
    "see figure  [ stable - block - hypergraph ] .",
    "notice that every node of the tree has degree at least 2 , except the root @xmath149 , which has degree 1 .",
    "notice also that if we were to remove the _ root edge _ @xmath150 ( the edge connecting the root to its immediate children in the tree ) , the entire tree would be subsequently 2-peeled .    to complete the construction of the stable block @xmath58 of degree @xmath142 ,",
    "choose any @xmath142 of the @xmath151 .",
    "for each @xmath152 , add a neighboring edge @xmath153 , where the @xmath154 are a collection of @xmath155 new vertices and neighbors of the stable block .",
    "we show below how the @xmath156 are used to finish the construction of @xmath77 .",
    "notice now that , with the neighboring edges , @xmath157 .",
    "the above construction @xmath58 is a stable block for @xmath2 and @xmath158uniform hypergraphs , where @xmath140 .",
    "it satisfies the 2 properties of stable blocks :    1 .",
    "suppose that no internal edge of @xmath58 is stashed .",
    "since every vertex in @xmath58 , except @xmath149 , has at least 2 internal edges , the only way for @xmath58 to be peeled is for @xmath149 to be peeled , which can happen only if all neighboring edges are removed .",
    "thus , @xmath58 is @xmath0-unpeelable if it has degree at least 1 . 2 .",
    "if @xmath150 is stashed , then the entire @xmath143-ary tree can be subsequently peeled . since each @xmath151",
    "would then have degree only 1 ( the neighboring edge ) , it can be peeled , peeling the neighboring edges as well . thus @xmath159 .    as with the stable block in the previous construction for @xmath13 ,",
    "the stable block is responsible for ( p3 ) of @xmath141 , which allows stashing a single edge in @xmath141 to correctly simulate stashing @xmath37 in @xmath27 .",
    "given this new stable block construction , construct @xmath141 as follows . for every vertex @xmath76 ,",
    "let @xmath103 and let @xmath160 be the edges in @xmath27 adjacent to @xmath37 and let @xmath161 be the neighbors of @xmath37 in @xmath27 that share edge @xmath162 with @xmath37 .",
    "then @xmath141 consists of :    * a copy of @xmath37 in @xmath141 , which is called the primary vertex and will serve the same role as the primary vertex in the previous @xmath77 construction . * a stable block @xmath58 of degree @xmath104 (",
    "recall that this means @xmath58 has @xmath163 neighbors ) . * a vertex @xmath164 for each neighboring edge @xmath162 . *",
    "add @xmath47 dummy vertices for each @xmath129 , and denote them by @xmath165 .    to combine these , add the edges @xmath166 for each @xmath129 .",
    "we further need to define the neighboring edges of @xmath77 .",
    "note that each @xmath167 will have its own copy of @xmath164 since all the @xmath168 share edge @xmath162 .",
    "call this copy @xmath169 . then , for each @xmath170 , add the hyperedge @xmath171 .",
    "these constitute the neighboring edges of @xmath141 .",
    "see figure  [ stable - block - hypergraph ] for an illustration .",
    "each @xmath164 and @xmath156 has degree 2 , while the primary node has degree @xmath104 .",
    "the @xmath164 in this construction are close analogs of the @xmath172 ( the 3-blocks ) used in the previous construction for @xmath13 , since both are responsible for ensuring ( p2 ) of @xmath77 .",
    "notice that the number of neighboring edges of @xmath141 is always equal to the number of @xmath164s present , since if an edge of @xmath141 is removed , the corresponding @xmath164 has degree 1 and can be peeled , which reduces the degree of the primary vertex @xmath37 by 1 . as such , it ensures that the degree of the primary node is equal to the number of neighboring edges of @xmath141 , which means that the primary vertex can be peeled if and only if @xmath141 has fewer than 2 neighboring edges .",
    "this is identical to the role of @xmath172 in the previous construction .",
    "the dummy vertices are there simply to interface with the stable block .",
    "since each edge must contain @xmath5 vertices , these dummy vertices just fill up the extra @xmath47 slots required for the stable block s neighboring edges to be complete .     with degree 3 in @xmath27",
    "is mapped to a set of vertices in @xmath30 for @xmath173 .",
    "the stable block is the dotted box , where the green node is @xmath149 , the light blue nodes are the other nodes in the tree , the purple nodes are the @xmath151 , the dummy nodes are yellow , the @xmath164 are deep blue , and @xmath37 ( the original vertex ) is black . ]     with degree 3 in @xmath27 is mapped to a set of vertices in @xmath30 for @xmath173 .",
    "the stable block is the dotted box , with the root of the tree @xmath149 marked in black .",
    "the hyper - edges are shown as triangles containing all the nodes they connect . ]",
    "we now show that @xmath141 satisfies the required properties .",
    "( p1 ) is clearly satisfied by construction . for ( p2 ) , if @xmath141 has degree less than 2 , then there are fewer than 2 @xmath164s , so @xmath37 can be peeled . then each @xmath164 and @xmath174 has degree at most 1 and can be peeled .",
    "the stable block then has degree 0 and is subsequently peeled , so @xmath141 be peeled entirely .",
    "similarly , if @xmath141 has degree at least @xmath175 , then at least 2 @xmath164s exist , so @xmath37 has degree at least 2 .",
    "the stable block therefore has at least @xmath175 neighbors and can not be peeled . for ( p3 ) ,",
    "the root edge @xmath149 of the @xmath143-ary tree is in @xmath176 . as shown above , stashing this edge peels the stable block , which peels the @xmath174 and in turn the @xmath164s and @xmath37 .",
    "it is clear that @xmath75 can be constructed in time polynomial in @xmath177 .",
    "we have shown that determining the minimum number of vertices ( or edges ) that need to be removed from a hypergraph so that peeling leads to an empty graph is np - complete ( except for @xmath178 for edges ) .",
    "this may potentially limit the use of stashes in algorithmic settings where peeling could be a useful tool , although we would expect in many situations non - optimal stashes based on reasonable heuristics would still prove effective in practice .",
    "a. broder , a. frieze , and e. upfal . on the satisfiability and maximum satisfiability of random 3-cnf formulas . in _ proceedings of the fourth annual acm - siam symposium on discrete algorithms _ , pp .",
    "322330 , 1993 .",
    "b. chazelle , j. kilian , r. rubinfeld , and a. tal .",
    "the bloomier filter : an efficient data structure for static support lookup tables . in _ proc . of the 15th annual acm - siam symposium on discrete algorithms _ , pp . 3039 , 2004 .",
    "d. eppstein and m goodrich , straggler identification in round - trip data streams via newton s identities and invertible bloom filters .",
    "_ ieee transactions on knowledge and data engineering _ , 23(2):297 - 306 , 2011 ."
  ],
  "abstract_text": [
    "<S> the analysis of several algorithms and data structures can be framed as a _ peeling process _ on a random graph : vertices with degree less than @xmath0 and their adjacent edges are removed until no vertices of degree less than @xmath0 are left . </S>",
    "<S> often the question is whether the remaining graph , the @xmath0-core , is empty or not . in some settings , it may be possible to remove either vertices or edges from the graph before peeling , at some cost . </S>",
    "<S> for example , in hashing applications where keys correspond to edges and buckets to vertices , one might use an additional side data structure , commonly referred to as a stash , to separately handle some keys in order to avoid collisions . the natural question in such cases </S>",
    "<S> is to find the minimum number of edges ( or vertices ) that need to be stashed in order to realize an empty @xmath0-core .    </S>",
    "<S> we show that both these problems are np - complete for all @xmath1 , with the sole exception being that the edge variant of stashing is solvable in polynomial time for @xmath2 on standard ( 2-uniform ) graphs .    </S>",
    "<S> # 1*/ </S>"
  ]
}