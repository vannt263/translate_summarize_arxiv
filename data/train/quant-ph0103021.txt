{
  "article_text": [
    "we thank p. wocjan for useful discussions and important corrections . this work has been supported by grants of the project q - acta of the european union ."
  ],
  "abstract_text": [
    "<S> if an experimentalist wants to decide which one of @xmath0 possible hamiltonians acting on an @xmath0 dimensional hilbert space is present , he can conjugate the time evolution by an appropriate sequence of known unitary transformations in such a way that the different hamiltonians result in mutual orthogonal final states . </S>",
    "<S> we present a general scheme providing such a sequence .    </S>",
    "<S> begintheorem#1#2    opargbegintheorem#1#2#3    beginlemma#1#2    opargbeginlemma#1#2#3    begindefinition#1#2    opargbegindefinition#1#2#3    begincorollary#1#2    opargbegincorollary#1#2#3    beginexample#1#2    opargbeginexample#1#2#3    2    controling simple quantum systems has become a large field of research during the last decade . </S>",
    "<S> experimental and theoretical investigations deal with the preparation of certain quantum states , the implementation of unitary transformations and the design of measurement procedures for different quantum observables . whereas the problem of optimal information gain about unknown quantum _ states _ is a large field of research ( see e.g. @xcite ) , discussions about optimal estimation of unknown quantum _ evolutions _ are comparably rare . a strategy for estimating an arbitrary unknown unitary transformation is developed in @xcite and in @xcite for general quantum operations . </S>",
    "<S> those approaches assume that the dynamical evolution to be estimated is taken from an infinite set of possibilities . </S>",
    "<S> the problem of estimating an unknown hamiltonian can arise in various contextes : assume we want to use a single quantum system in order to detect classical fields , e.g. , a spin particle as detector for a magnetic field . </S>",
    "<S> we expose the test particle to the field for a certain time period and estimate the field strength by measuring the particle s quantum state . assume the experimentalist is allowed to perform arbitrary unitary transformations on the test particle , expose the particle to the field again , repeat this several times and perform a single measurement at the end . what is the best procedure for estimating the field ? </S>",
    "<S> if the set of possible values for the field strength is larger than @xmath0 , a single measurement of the test particle can only allow _ estimations _ of the field . by basic quantum mechanics , it is well - known that a set of _ states _ is perfectly distinguishable by a single measurement if and only if their density matrices have disjoint support . led by this simple statement concerning the distinguishability of _ states _ , we focus on the question of distinguishing between @xmath0 possible hamiltonians @xmath1 of a quantum system on the hilbert space @xmath2 and show that they are always perfectly distinguishable provided they do not only differ by an _ additive _ constant . </S>",
    "<S> we assume that the experimentalist is allowed to prepare the initial state , to perform definite unitary transformations interrupting the unknown natural evolution and to perform an arbitrary measurement at the end . </S>",
    "<S> the assumption about the restricted set of possibilities is more natural than it might seem at first sight . </S>",
    "<S> take the following model of a measurement interaction ( compare @xcite ) : on the joint hilbert space of the measured system and the measurement apparatus we assume to have the hamiltonian @xmath3 where @xmath4 is the family of spectral projections of the measured observable and @xmath5 are different self - adjoint operators moving the pointer of the measurement apparatus conditioned on the state of the measured system . </S>",
    "<S> assume that we do not have any direct access to the measured system and that we are not able to change the interaction at all . </S>",
    "<S> the only way to use the interaction for a measurement procedure consists in initializing the measuring device , waiting ( i.e. implementing @xmath6 ) and interrupting this evolution several times by implementing local unitary transformations on the measurement apparatus in order to get mutual orthogonal pointer states for different hamiltonians @xmath5 .    </S>",
    "<S> our considerations show that this is always possible ( if @xmath7 for @xmath8 ) and give a general rule for such a quantum algorithm .    </S>",
    "<S> the algorithm consists of quite a large number of steps ; since we are working in the lie algebra instead of the lie group our scheme requires arbitrarily many unitary transformations ( close to the identity ) in order to obtain the correct result with arbitrary reliability . </S>",
    "<S> we are convinced that there exist much simpler algorithms for particular sets of @xmath0 hamiltonians . </S>",
    "<S> whether or not there are general rules requiring only a few steps is unclear . </S>",
    "<S> developing short procedures for the general case might result in computationally hard word problems in the lie group @xmath9 , whereas our classical precomputation consists only in solving linear equations for the price of obtaining only approximative solutions .    </S>",
    "<S> firstly we present an example of @xmath0 hamiltonians which can be distinguished easily : set @xmath10 with @xmath11 . by waiting the time @xmath12 </S>",
    "<S> we have implemented the unitary transformations @xmath13 . </S>",
    "<S> take the initial vector @xmath14 . </S>",
    "<S> then the states @xmath15 are orthogonal for different values of @xmath16 since they are the discrete fourier transforms of the canonical basis vectors of @xmath17 . in the rest of the paper </S>",
    "<S> we show that the general problem can be reduced to this example . for doing </S>",
    "<S> so we start by developing some technical tools :    by waiting the time @xmath18 , we have implemented the transformation @xmath19 for the unknown hamiltonian @xmath20 . </S>",
    "<S> we show that there is a procedure simulating @xmath21 for arbitrary @xmath22 : choose a finite subgroup @xmath23 of @xmath9 acting irreducibly on @xmath24 . </S>",
    "<S> then @xmath25 is an operator commuting with every @xmath26 and is therefore a multiple of the identity operator by schur s lemma ( this fact is used in decoupling techniques @xcite ) . without loss of generality </S>",
    "<S> we assume every @xmath5 to be traceless . </S>",
    "<S> then one has @xmath27 and hence @xmath28 . </S>",
    "<S> we obtain @xmath29 set @xmath30 . </S>",
    "<S> then for large @xmath31 we have approximately an implementation of @xmath32 as follows :    begin    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ for @xmath33 to @xmath31 do    for @xmath34 to @xmath35 do    implement @xmath36    wait the time @xmath37    implement @xmath38 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    end .    </S>",
    "<S> the possibility of implementing @xmath19 even for negative @xmath18 is decisive for using lie algebraic tools in the sequel : let @xmath39 be the lie algebra of traceless self - adjoint operators acting on @xmath24 .    by using the well - known formula @xmath40}\\ ] ] we can design an algorithm simulating the unitary @xmath41s}\\ ] ] for arbitrary @xmath42 with arbitrary small error . in the same way we conclude more generally :    * lemma 1 * let @xmath43 be arbitrary ( not necessarily linear ) functions . </S>",
    "<S> assume there exist for every @xmath44 procedures for simulating the unitary transformations @xmath45 and for simulating @xmath46 with arbitrary small error for the unknown hamiltonian @xmath47 . </S>",
    "<S> then there are procedures simulating @xmath48s}\\ ] ] and @xmath49s}\\ ] ] for every @xmath50 and every @xmath44 with arbitrary small error .    obviously , for every @xmath50 we can find an algorithm performing @xmath51=:ad(h ) ( a)$ ] . </S>",
    "<S> hence we can find for every @xmath52 an algorithm performing @xmath53 . </S>",
    "<S> we conclude :    * corollary * let @xmath54 be an arbitrary function . </S>",
    "<S> assume that for every required accuracy and every @xmath44 there exists a procedure such that @xmath45 is implemented . </S>",
    "<S> then lemma 1 provides a scheme for implementing @xmath55 where @xmath56 is an arbitrary real polynomial and @xmath50 .    </S>",
    "<S> furthermore we will need the following lie algebraic lemma :    * lemma 2 * let @xmath57 be the ring of @xmath58-linear maps on the real vector space @xmath39 . </S>",
    "<S> then there is no proper subring of @xmath57 containing all the maps of the form @xmath59 $ ] with arbitrary @xmath50 .    </S>",
    "<S> _ proof _ define @xmath60 , @xmath61 ,  </S>",
    "<S> , @xmath62 . </S>",
    "<S> furthermore let @xmath63 for every unordered pair @xmath64 with @xmath65 be the matrix with @xmath66 at the positions @xmath67 and @xmath68 and zero elsewhere . </S>",
    "<S> let @xmath69 be defined in an analogue way with entries @xmath70 and @xmath71 at positions @xmath67 and @xmath68 respectively . </S>",
    "<S> the set of these @xmath72 matrices forms a basis of the vector space @xmath39 . </S>",
    "<S> since all the basis vectors are unitarily equivalent ( note the analogy to the pauli - matrices ) , there always exists a map in the ring generated by maps of the form @xmath73 $ ] mapping one basis vector on the other . in order to show , that every map @xmath74 can be obtained by sums and concatenations of maps @xmath73 $ ] it is therefore sufficient to prove that a map @xmath75 can be generated with the following two properties : ( 1 ) the kernel of @xmath75 contains every basis vector except @xmath76 and ( 2 ) @xmath77 is proportional to @xmath78 . </S>",
    "<S> choose a finite subgroup @xmath79 of @xmath9 acting trivially on the vector space spanned by the first basis vector @xmath80 and irreducibly on its orthogonal complement @xmath81 . </S>",
    "<S> the sub ring we are looking for contains clearly the map @xmath82 since @xmath83 if @xmath84 is chosen such that @xmath85 . due to shur s lemma every operator in the image of @xmath86 is a multiple of the identity on @xmath81 . </S>",
    "<S> since the trace on the subspace @xmath81 is invariant , the restriction of @xmath86 to @xmath81 is given by @xmath87 . </S>",
    "<S> explicitly one obtains @xmath88 where @xmath89 is the projector onto @xmath81 . </S>",
    "<S> clearly @xmath86 annihilates all the basis vectors except @xmath90 . </S>",
    "<S> define @xmath75 by @xmath91 $ ] easy calculation shows that @xmath77 is proportional to @xmath78 . </S>",
    "<S> @xmath92    since @xmath93=\\lim_{s\\to 0 } ( e^{ias } b e^{-ias } - b)/s$ ] we can conclude that @xmath73 $ ] is an element of the vector space spanned by the maps @xmath94 . hence we obtain :    * corollary * let @xmath74 . </S>",
    "<S> then there is a set of unitaries @xmath95 and real numbers @xmath96 such that @xmath97 .    in order to obtain a constructive statement one </S>",
    "<S> can either take the approximative solution defined by the limit above or one can write @xmath98 as a finite linear combination of maps @xmath99 by solving the corresponding equation for the eigenvalues of @xmath98 . </S>",
    "<S> we conclude :    * lemma 3 * let @xmath100 be arbitrary . </S>",
    "<S> if there is a scheme implementing @xmath101 for the unknown hamiltonian @xmath47 then @xmath102 for arbitrary @xmath74 can be implemented with arbitrary small error by @xmath103 where @xmath104 are the unitaries and @xmath105 are the coefficients corresponding to @xmath86 in the sense of the corollary to lemma 2 and @xmath106 is large enough to keep the error small .    </S>",
    "<S> now we are able to construct our algorithm : choose an operator @xmath107 with exactly two different eigenvalues , called @xmath108 and @xmath109 . </S>",
    "<S> choose @xmath74 in such a way that @xmath110 with @xmath111 and @xmath112 . </S>",
    "<S> this is possible due to basic linear algebra . </S>",
    "<S> the map @xmath113 $ ] has the eigenvalues @xmath114 and @xmath115 . </S>",
    "<S> the spectrum of the map @xmath116 is hence given by the values @xmath117 . </S>",
    "<S> choose a real polynomial @xmath56 such that @xmath118 and @xmath119 . </S>",
    "<S> due to the functional calculus for the diagonalizable operator @xmath120 this implies @xmath121 by defining @xmath122 for arbitrary @xmath123 we obtain @xmath124    now choose a map @xmath125 such that @xmath126 we obtain @xmath127 .    </S>",
    "<S> the classical precomputation for our algorithm can be sketched as follows :    1 .   </S>",
    "<S> choose an element @xmath107 with two - valued spectrum and find a linear map @xmath86 such that @xmath110 with different values @xmath128 . </S>",
    "<S> 2 .   find a set of unitary transformations @xmath129 and a set of real numbers @xmath105 such that @xmath130 for every @xmath131 . </S>",
    "<S> this is possible due to the corollary to lemma 2 . </S>",
    "<S> 3 .   choose a polynomial @xmath56 such that @xmath132 and @xmath119 , if @xmath133 are the eigenvalues of @xmath134 . </S>",
    "<S> 4 .   choose an arbitrary operator @xmath123 and a map @xmath135 such that @xmath136 . </S>",
    "<S> find a set of unitary operators @xmath137 and real numbers @xmath138 such that @xmath139 .    </S>",
    "<S> now we sketch the required sequence of quantum operations as follows :    </S>",
    "<S> 1 .   prepare the initial state @xmath140 . </S>",
    "<S> 2 .   call a subroutine performing the evolution @xmath141 if the hamiltonian @xmath5 is present . </S>",
    "<S> 3 .   measure in the basis defined by the discrete fourier transforms of the canonical basis vectors of @xmath17 . </S>",
    "<S> if the result is the @xmath142 basis state then the hamiltonian @xmath5 is present .    </S>",
    "<S> the subroutine called in step ( 2 ) is recursively defined : the implementation of @xmath143 is based on lemma 2 by calling a subroutine simulating @xmath144 for small @xmath22 several times . </S>",
    "<S> the implementation of the latter is based on the corollary to lemma 2 by calling a subroutine for implementing @xmath145 several times ( lemma 3 ) . </S>"
  ]
}