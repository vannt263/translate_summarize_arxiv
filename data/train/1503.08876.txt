{
  "article_text": [
    "a covering array @xmath11 is an @xmath1 array @xmath2 whose cells take values from a set @xmath4 of size @xmath3 and the set of rows of every @xmath6 subarray of @xmath2 contains the whole set @xmath5 .",
    "the parameter @xmath12 is called the strength , the parameter @xmath3 is the alphabet size and @xmath7 is called the size of the array .",
    "a covering array with given parameters @xmath12 , @xmath13 and @xmath3 always exists .",
    "the two central questions regarding covering arrays are : what the smallest number of rows is , denoted by @xmath8 , for which a covering array with the given set of parameters @xmath14 exists , and how an array of such size can be constructed . in this paper",
    "we study the upper bounds on the asymptotic size of covering arrays .",
    "it is easy to see that if @xmath15 or @xmath16 , covering arrays are trivial .",
    "hence we assume that @xmath17 and @xmath18 .    covering arrays are best known for their applications in the software testing industry  @xcite as interaction testing plans .",
    "there are numerous software tools for construction of covering arrays  @xcite , and there is a vast literature on them as well  @xcite .",
    "however , the central question about the optimal size is far from fully answered .",
    "the only infinite family of covering arrays whose exact size is known is the first non - trivial family of arrays of strength @xmath19 and with alphabet size @xmath20  @xcite .",
    "the best known upper bound on the size of a covering array for any set of parameters @xmath14 is obtained by an application of the lovsz local lemma  @xcite .",
    "together these two results give us the asymptotic size of covering arrays when strength @xmath12 and alphabet size @xmath3 are fixed and the number of columns @xmath13 is varied .",
    "@xcite[thm : log growth ] let @xmath21 be integers . then , @xmath22    given the previous theorem , there is significant interest in determining the following two values ( we use the notation given in  @xcite ) : @xmath23    the exact value of @xmath24 is only known when @xmath19 .",
    "@xcite[thm : gargano d_2_v ] let @xmath25 be an integer",
    ". then @xmath26    however , covering arrays which meet this asymptotic size are hard to construct . the only family which we currently know how to construct which attains this size is the already mentioned family of @xmath27s with @xmath19 and @xmath20  @xcite .",
    "in 1996 , godbole  et .",
    "@xcite gave an upper bound on @xmath24 for any strength @xmath17 .",
    "@xcite[thm : old lll ] let @xmath17 and @xmath3 be positive integers .",
    "then , @xmath28    recently , the method of entropy compression was successfully used in the context of vertex - colourings of graphs  @xcite to improve on the previous results which used the local lemma . in this paper",
    "we explore an application of this method in the context of covering arrays .",
    "we give a new upper bound on @xmath24 for any @xmath29 in theorem  [ thm : d_t_v for any t ] , which improves theorem  [ thm : old lll ] .",
    "we also obtain a tighter upper bound on @xmath24 given in lemma  [ lemma : multivariable upper bound on d ] which depends on further computational approximations .",
    "table  [ table : constants ] displays our new upper bounds on @xmath24 for @xmath30 and @xmath31 .",
    "finally , we analyze these results and point out possible challenges and further avenues for improvement .",
    "we adapt the algorithms given in  @xcite to covering arrays .",
    "the algorithm is used as a tool for counting .",
    "the main idea is to keep a record of execution for the algorithm .",
    "this allows us to match an input sequence to the algorithm injectively with a pair consisting of the output array and the record of the execution . for a given input , we say that the execution was _ unsuccessful _ and that it produced a _ bad _ output if , the output array is only partially filled and has some empty columns .",
    "if the total number of possible input sequences is greater than the total number of bad output pairs , then there must exist an input sequence for which the algorithm successfully terminates .",
    "before we give the algorithm , we need to introduce some notation which is required for the analysis .    given array parameters @xmath32 and @xmath3 , the algorithm attempts to construct a covering array of size @xmath33 one column at a time .",
    "a column of a @xmath0 is an element of @xmath34 , where @xmath4 is the alphabet set of size @xmath3 . to remind us that these ordered @xmath7-tuples are columns",
    ", we denote elements of @xmath34 by @xmath35 .",
    "let @xmath36 denote a set of all admissible input columns for the algorithm .",
    "we will define @xmath37 in section  [ sec : balanced arrays ] .",
    "then the algorithm receives as an input value @xmath38 , a sequence of @xmath39 columns , where @xmath39 is the number of iterations to be performed .",
    "let @xmath40 denote the @xmath41 coordinate of @xmath42 .    at an intermediate step in the algorithm",
    ", some columns of the array may still be empty .",
    "let @xmath43 denote an empty column , and let @xmath44 .",
    "then , an array can be represented as a sequence of @xmath13 elements of @xmath45 , i.e. @xmath46 , where @xmath47 .",
    "let @xmath48 be the values in the @xmath49 column of the array .",
    "we also require a way to choose which column to fill at each step .",
    "define @xmath50 to be the priority function on the empty columns of @xmath2 : @xmath51",
    "the key property of a covering array is that the subarray on any @xmath12 columns contains each @xmath12-tuple in @xmath5 at least once .",
    "let @xmath52 be the set of all @xmath12-subsets of the set @xmath53 = \\{1,2,\\dots , k\\}$ ] .",
    "let @xmath54 , where @xmath55 . then denote by @xmath56 the subarray of @xmath2 on columns indexed by @xmath57 .",
    "an auxiliary function @xmath58 returns true if the set of rows of @xmath59 contains @xmath5 as a subset , and false otherwise .",
    "now we are ready to describe the algorithm which attempts to construct a @xmath0 for some positive integers @xmath7 , @xmath12 , @xmath13 and @xmath3 .",
    "it starts by initializing all columns of an @xmath1 array @xmath2 to be empty , and opens a new record file @xmath60 .",
    "then it runs for @xmath39 iterations where @xmath39 is the length of the input sequence . the partially constructed array @xmath2 satisfies the covering property at the beginning of each iteration .",
    "at a step @xmath61 , let @xmath62 be smallest index of an empty column of @xmath2 .",
    "the algorithm assigns to the @xmath63 column the @xmath41 element of the input sequence .",
    "now , if @xmath2 has an @xmath6 subarray on columns @xmath64 $ ] , which is not a covering , then @xmath65 since @xmath2 met the covering property before algorithm entered the @xmath41 iteration .",
    "the algorithm records @xmath66 and the content of the subarray of @xmath2 on columns in @xmath57 .",
    "note , in order to be able to recover input from the output , we need to know the relative position of @xmath62 with respect to other elements in @xmath67 since @xmath62 is not recorded . hence the elements of @xmath57 are first sorted in increasing order . finally ,",
    "since this subarray does not have the covering property , we assign empty values to the columns in @xmath57 .",
    "otherwise , the addition of a new column to @xmath2 preserves the covering property and the algorithm completes this iteration after recording a successful entry to the file .",
    "note that the number of lines in the record file @xmath60 is equal to the number of executed iterations .",
    "if the algorithm completes and the array @xmath2 has no empty columns , then it is easy to see that @xmath2 satisfies the covering property on every set of @xmath12-columns , i.e. it is a covering array .",
    "otherwise , @xmath2 is only partially constructed , it has some empty columns , and we say that the execution of the algorithm on the given input was unsuccessful .",
    "@xmath68 + @xmath69 new file ( ) +",
    "next , we establish bijection between the set of all possible inputs @xmath70 and the set of all possible outputs @xmath71 .",
    "it is easy to see that for an input sequence @xmath72 , we get only one output @xmath73 .",
    "we prove the converse in several steps .",
    "let @xmath74 denote the state of the array @xmath2 at the beginning of the @xmath41 iteration of algorithm  [ alg : ca2 ] .",
    "hence , @xmath75 is an empty array , and @xmath76 , the array returned by the algorithm .",
    "[ lemma : column at step j ] given @xmath77 , we can determine the set of indices of all columns which are empty in @xmath74 for all @xmath78 .",
    "we use induction on @xmath61 .",
    "denote by @xmath79 the set of all indices of columns which are empty in @xmath74 .",
    "when @xmath80 , @xmath81 $ ] , since the algorithm starts with an empty array @xmath75 .",
    "assume that we know @xmath79 for some @xmath82 .",
    "then , @xmath83 is the index of a column which receives a value in the @xmath41 iteration . if the @xmath41 line of @xmath60 starts with ` successful entry ' , then @xmath84",
    "otherwise , the @xmath41 line of @xmath60 contains @xmath85 , where @xmath57 is the set of columns whose content is removed at step @xmath61 .",
    "hence , @xmath86 .",
    "the following is an immediate corollary .",
    "[ cor : phii a_j ] we can determine @xmath87 for all @xmath88 $ ] from an output of the algorithm @xmath77 .",
    "next , we determine @xmath74 at each step of the algorithm from the output values .",
    "[ lemma : a_j ] given @xmath77 , we can deduce @xmath74 for all @xmath89 $ ] .",
    "the proof is by reverse induction . when @xmath90 , @xmath91 , the output of the algorithm .",
    "assume that we know @xmath92 for some @xmath93 .",
    "by corollary  [ cor : phii a_j ] , we know @xmath94 .",
    "we have two cases to consider .",
    "if the @xmath41 line of @xmath60 starts with ` successful entry ' , then @xmath74 is obtained by deleting the content of column @xmath62 in @xmath92 .",
    "otherwise , the @xmath41 line of @xmath60 contains @xmath67 , indices of all but one of the columns whose content is deleted at step @xmath61 of the algorithm .",
    "it also has the content of all @xmath12 of these columns , @xmath95 , where @xmath96 such that @xmath97 when @xmath98",
    ". then @xmath74 is obtained from @xmath92 after the following assignment : @xmath99 for all @xmath100 $ ] .    finally , we are ready to prove the reversibility : given an output , we can obtain the unique input sequence for the algorithm .",
    "[ lemma : unique input ] given @xmath77 , there is a unique input sequence @xmath101 , such that algorithm  [ alg : ca2 ] produces @xmath102 on input @xmath42 .",
    "the proof is by induction on @xmath39 . if @xmath103 , then @xmath104 .",
    "assume that the statement is true for some @xmath105 .",
    "let @xmath106 and denote by @xmath42 the desired input sequence .",
    "let @xmath107 be the record @xmath60 without the last line .",
    "by lemma  [ lemma : a_j ] , we know the value of @xmath108 and @xmath109 . by our assumption",
    ", there is a unique input sequence @xmath110 such that the algorithm gives @xmath111 on input @xmath112 .",
    "then @xmath113 for @xmath114 $ ] .",
    "it remains to determine @xmath115 .",
    "if the last line of @xmath60 is ` successful entry ' , then it must be that @xmath116 , where @xmath117 is given by corollary  [ cor : phii a_j ]",
    ". otherwise , the last line of @xmath60 contains @xmath67 and @xmath118 .",
    "as before , let @xmath119 , where @xmath97 when @xmath98 .",
    "let @xmath120 be such that @xmath121 .",
    "then we have that @xmath122 which is uniquely determined .",
    "in section  [ sec : bijection ] we established a bijection between the total number of inputs @xmath70 and outputs @xmath123 of algorithm  [ alg : ca2 ] .",
    "next , we want to show that when a given set of covering array parameters satisfies certain conditions and @xmath39 is big enough , the total number of inputs to the algorithm is greater than the set of outputs which have exactly @xmath39 lines in the record file ( which correspond to unsuccessful executions ) . hence , the algorithm will successfully terminate and output a covering array with desired parameters for some input sequence .",
    "we start by finding an upper bound on the size of @xmath124 , the set of all possible record files @xmath60 with @xmath39 lines which can be output from algorithm  [ alg : ca2 ] .",
    "let @xmath125 be the number of ` successful entry ' lines , and @xmath126 be the number of ` back - track ' lines .",
    "then @xmath127 and these lines can be positioned in the record file in @xmath128 ways .",
    "denote by @xmath129 the number of distinct pairs @xmath130 which can appear in a ` back - track ' line .",
    "then @xmath131    now , we can apply the following result from  @xcite .",
    "@xcite*corollary 19 .",
    "[ thm : b q ] let @xmath39 and @xmath132 be positive integers .",
    "let @xmath133 and @xmath134 , @xmath135 , for @xmath136 $ ] .",
    "define @xmath137 to be @xmath138 where @xmath139 is a non - negative integer , @xmath140 $ ] , @xmath141 and @xmath142 .",
    "then @xmath143where @xmath144    [ cor : size r_l ] let @xmath129 be the number of distinct pairs @xmath145 which can be recorded in a ` back - track ' line in an execution of algorithm  [ alg : ca2 ] . then , @xmath146    we apply theorem  [ thm : b q ] with @xmath147 and we only need to determine the value of @xmath148 .",
    "note that the algorithm can not back - track unless there are @xmath12 non - empty columns in @xmath2 .",
    "since the total number of added columns in @xmath2 is @xmath39 , one at each iteration , and the total number of deleted columns is @xmath149 , we have that @xmath150 .",
    "thus , let @xmath151 . now taking the first derivative of @xmath152 to get the minimum",
    ", the result follows .",
    "finally , we give a lemma which is going to be our main tool in further analysis .",
    "[ lemma : ca existence ] given positive integers @xmath7 , @xmath12 , @xmath13 and @xmath3 , and a set @xmath153 , where @xmath154 , there exists a @xmath0 whose columns are elements of the set @xmath37 if @xmath155 where @xmath129 the number of distinct pairs @xmath145 which can be recorded in a ` back - track ' line in an execution of algorithm  [ alg : ca2 ] .",
    "denote by @xmath156 , the subset of all possible outputs of the algorithm which have exactly @xmath39 lines in the record file @xmath60 .",
    "since an output array @xmath2 has @xmath13 columns each of which is either empty or in @xmath37 , we have that @xmath157 note that @xmath158 , and hence it is a constant with respect to @xmath159 therefore , by the assumption of the lemma , for sufficiently large @xmath39 , we have that @xmath160 , and @xmath161 equals the total number of possible inputs of length @xmath39 for the algorithm . since , @xmath162 by lemma  [ lemma : unique input ] , there exists an input on which the algorithm terminates in less than @xmath39 iterations and hence outputs a @xmath11 .    in the following section ,",
    "we apply lemma  [ lemma : ca existence ] to derive an upper bound on asymptotic size of covering arrays .",
    "to demonstrate how lemma  [ lemma : ca existence ] can be applied , we start with an easy example for a construction of a covering array of arbitrary strength",
    ". the main difficulty in the application of lemma  [ lemma : ca existence ] is to give a good upper bound on the value of @xmath129 . in section  [ sec : multivar counting ]",
    ", we will strengthen the general result in the cases when @xmath19 and @xmath163 .",
    "recall that @xmath129 equals the number of distinct pairs @xmath164 which may appear in a ` back - track ' line in the record file of algorithm  [ alg : ca2 ] for a parameter set @xmath165 .",
    "the ` back - track ' line is recorded only when the array @xmath166 is not a proper cover .",
    "hence , @xmath167 where @xmath168 is the set of all @xmath169 arrays on the alphabet set @xmath4 of size @xmath3 , such that for every array in @xmath168 there is at least one element of @xmath5 which is not contained in the set of rows of the array .    taking the input set @xmath170 to the equal to the set of all possible @xmath7-tuples on alphabet @xmath4 , we can easily obtain the upper bound on the size of a covering array using lemma  [ lemma : ca existence ] which is almost identical to the one derived using lovsz local lemma  @xcite .",
    "this bound is improved if instead we take @xmath37 to be the set of balanced columns : @xmath7-tuples in which every alphabet symbol appears equal number of times .",
    "hence , from now on , we will assume that @xmath171 for some @xmath172 , and @xmath37 is the set of balanced columns .",
    "therefore , @xmath173 .",
    "a _ balanced _ covering array , is a covering array whose columns are elements of @xmath37 .",
    "we also require some approximations of the binomial coefficient which we use in the subsequent sections .",
    "@xcite*theorems 2.6 .",
    "and 2.8.[lemma : binomial bounds ] let @xmath174 , @xmath25 and @xmath175 .",
    "then    @xmath176 where @xmath177    @xcite[lemma : binomial entropy ] for any positive integer @xmath178 @xmath179 where @xmath180 for @xmath181 .",
    "we will apply lemma  [ lemma : binomial bounds ] for parameters @xmath3 and @xmath172 , where @xmath3 denotes the alphabet size and @xmath172 denotes the number of occurrences of each symbol within a column .",
    "recall that covering arrays are trivial when either @xmath16 or @xmath15 .",
    "also , for any covering array , an obvious lower bound is @xmath182 , so @xmath183 for all @xmath17 .",
    "hence , the conditions of lemma  [ lemma : binomial bounds ] always hold for non - trivial parameter sets .",
    "our first application of lemma  [ lemma : ca existence ] is for the most general case when the strength of a covering array is any positive integer @xmath17 .",
    "[ thm : d_t_v for any t ] let @xmath12 and @xmath3 be positive integers , @xmath184 .",
    "then @xmath185    let @xmath4 be the alphabet set .",
    "let @xmath186 and @xmath172 be positive integers and @xmath187 be the set of balanced columns . since @xmath188 , there exists a balanced @xmath189 .",
    "now , @xmath190 indeed , if @xmath191 , then the following properties hold .",
    "there are @xmath192 choices for an element @xmath193 which is not covered by rows of @xmath2",
    ".    the first column of @xmath2 can be any element of the input set @xmath37 .",
    "the @xmath172 rows of @xmath2 having @xmath194 in the first column can not contain the ordered @xmath195-tuple @xmath196 in the remaining cells .",
    "all other rows of the array obtained from @xmath2 by removing the first column can contain any element of @xmath197 .    by lemma  [ lemma : binomial bounds ] , @xmath198 hence @xmath199 where @xmath200    for fixed covering array parameters @xmath14 , the right hand size of inequality  ( [ eq 2 ] ) is a function of @xmath172 and its dominant term is exponential with base smaller than @xmath201 .",
    "let @xmath172 be the smallest positive integer for which the right hand side of inequality  ( [ eq 2 ] ) is smaller than 1 .",
    "then inequality  ( [ eq : inequality for lemma 8 ] ) is satisfied , and so there exists a balanced @xmath202 .",
    "since @xmath172 is the smallest such integer , it follows that inequality  ( [ eq : inequality for lemma 8 ] ) does not hold for @xmath203 , that is @xmath204 taking the logarithm of both sides , we get @xmath205 note that @xmath206 by theorem  [ thm : log growth ] .",
    "finally , since @xmath8 is at most the size of a balanced @xmath207 , we get an upper bound on @xmath24 .",
    "the main difficulty in computing the value of @xmath129 is counting the @xmath208 arrays over an alphabet set @xmath4 which are not covering arrays .",
    "we can obtain a multivariable function in @xmath209 variables to approximate @xmath129 from above . when @xmath19 and @xmath210 , we get exact bounds , and for higher values of @xmath12 we obtain these bounds using mathematical software for non - linear optimization .        as before ,",
    "let @xmath4 be the alphabet set of size @xmath3 .",
    "let @xmath13 be an integer , @xmath186 .",
    "we need to bound the size of @xmath168 .",
    "a set of rows of @xmath218 does not contain a @xmath12-tuple in @xmath5 , which we denote by @xmath219 .",
    "next we count the number of occurrences of the 1-tuple @xmath220 in the first column of @xmath2 , the number of occurrences of the @xmath221-tuple @xmath222 in the first two columns of @xmath2 , and so on .",
    "let @xmath223 be such that the subarray of @xmath2 restricted to columns @xmath201 through @xmath62 contains exactly @xmath224 rows @xmath225 , where @xmath226 $ ] .",
    "we know that @xmath227 and @xmath228 since the columns of @xmath2 are balanced and does not cover @xmath229 . also , note that @xmath230 for all @xmath62 .",
    "the first column of @xmath2 can be chosen arbitrarily .",
    "any other column @xmath231 , contains @xmath232 cells with value @xmath233 within @xmath234 rows which contain @xmath235 in the previously chosen columns .",
    "hence , the @xmath49 column of @xmath2 can be completed in at most @xmath236 ways .",
    "if @xmath237 , using lemmas  [ lemma : binomial bounds ]  and  [ lemma : binomial entropy ] , we get @xmath238 where @xmath239 in the last inequality , the dominant term is an exponential function of @xmath172 .",
    "following the same reasoning as in the proof of theorem  [ thm : d_t_v for any t ] , we get an upper bound on @xmath24 .      if @xmath240 , since @xmath227 and @xmath241 , there is @xmath242 choice for the second column and hence @xmath243 .",
    "note that this is the only case for which we get the exact count of the number of @xmath6 arrays which are not coverings of strength @xmath12 .",
    "using lemma  [ lemma : binomial bounds ] , @xmath244 as before , taking the smallest @xmath172 for which the right hand - side of the last inequality is smaller than @xmath172,it follows that @xmath245 , which is the exact value of @xmath246  @xcite .",
    "observe that @xmath247 is a constant function since @xmath227 , and @xmath248 is a single variable function so we can easily obtain its maximum taking the first derivative of @xmath248 .",
    "the same result can be obtained using lovsz local lemma directly  @xcite .          for @xmath255",
    ", @xmath211 is a multivariable function .",
    "we used a successive quadratic programming solver in octave to compute @xmath256 .",
    "table  [ table : constants ] gives values of @xmath24 obtained in corollaries  [ cor : d_2_v ]  and  [ cor : d_3_v ] and by computational optimization for @xmath257 .",
    "determining the optimal size of a covering array for a given triple @xmath14 and constructing optimal covering arrays have been two central questions in this area of research .",
    "the interest in these two questions stems from the fact that covering arrays are natural models for interaction test suites and hence they are extensively used in the blooming software testing industry .",
    "however , these two questions have proven to be a great challenge for both combinatorial and computer science research communities .",
    "in this paper we tackled the problem of determining the upper bounds on the asymptotic size of covering arrays using an algorithmic version of the local lemma .",
    "we determined a new general bound on @xmath24 ( see theorem  [ thm : d_t_v for any t ] ) and we gave a tighter bound in lemma  [ lemma : multivariable upper bound on d ] which depends on further numerical computation .",
    "however , though we are improving the existing upper bounds on the asymptotic size of covering arrays for strength @xmath29 , in the simplest case when @xmath19 ( and the over - counting is the least ) , the bounds we are obtaining are far from the optimal predicted by theorem  [ thm : gargano d_2_v ] .",
    "the main challenge in improving these bounds is finding a better way to count the number of balanced arrays on @xmath12 columns which are not @xmath12-coverings .",
    "a new view to this problem may lead to better encrypting of information in the ` back - track ' lines in the algorithm .",
    "indeed , in the case when @xmath19 and @xmath20 , we are able to count these arrays exactly and as a result this general algorithm produces covering arrays whose size is asymptotically optimal ."
  ],
  "abstract_text": [
    "<S> a covering array @xmath0 is an @xmath1 array @xmath2 whose each cell takes a value for a @xmath3-set @xmath4 called an alphabet . </S>",
    "<S> moreover , the set @xmath5 is contained in the set of rows of every @xmath6 subarray of @xmath2 . the parameter @xmath7 is called the size of an array and @xmath8 denotes the smallest @xmath7 for which a @xmath0 exists . </S>",
    "<S> it is well known that @xmath9  @xcite . in this paper </S>",
    "<S> we derive two upper bounds on @xmath10 using the algorithmic approach to the lovsz local lemma also known as entropy compression . </S>"
  ]
}