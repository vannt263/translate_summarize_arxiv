{
  "article_text": [
    "sparse matrix - vector multiplication ( spmv ) is perhaps the most widely - used non - trivial sparse basic linear algebra subprogram ( blas ) in computational science and modeling .",
    "the operation multiplies a sparse matrix @xmath0 of size @xmath1 by a dense vector @xmath2 of size @xmath3 and gives a dense vector @xmath4 of size @xmath5 . despite its simplicity at the semantic level",
    ", an efficient spmv implementation is generally hard , because @xmath0 s sparsity structure can be very irregular and unpredictable .",
    "compared to cpus , co - processors ( e.g. , gpus and xeon phi ) promise much higher peak floating - point performance and memory bandwidth .",
    "thus a lot of research has focused on accelerating spmv on co - processors .",
    "one straightforward way on utilizing co - processors is to develop all - new sparse matrix formats ( e.g. , hyb  @xcite , cocktail  @xcite , jad  @xcite , esb  @xcite , bccoo  @xcite and brc  @xcite ) for specific hardware architectures .",
    "the experimental results showed that these formats can provide performance improvement for various spmv benchmarks .",
    "however , the completely new formats bring several new problems .",
    "the first one is backward - compatibility .",
    "when the input data are stored in basic formats such as compressed sparse row ( csr ) , a format conversion is required for using the new format based spmv . in practice , fusing a completely new format into well - established toolkits ( e.g. , petsc  @xcite ) for scientific software is not a trivial task  @xcite because of the format conversion . moreover , kumbhar  @xcite pointed out that once an application ( in particular a non - linear solver ) needs repeated format conversion after a fixed small number of iterations , the new formats may degrade overall performance .",
    "furthermore , langr and tvrdk  @xcite demonstrated that isolated spmv performance is insufficient to evaluate a new format .",
    "thus more evaluation criteria , such as format conversion cost and memory footprint , must be taken into consideration . secondly , when the spmv operation is used with other sparse building blocks ( e.g. , sparse matrix - matrix multiplication  @xcite ) that require basic storage formats , using the all - new formats is less feasible . to leverage the spmv performance and the practicality , liu and vinter proposed the csr5 format  @xcite to extend the basic csr format .",
    "the experimental results showed that the csr5 format delivers excellent spmv performance , but merely needs very short format conversion time ( a few spmv operations ) and very small extra memory footprint ( around 2% of the csr data ) .",
    "because the csr5 format shares data with the csr format , the csr - based sparse blas routines can efficiently work with the csr5 format .",
    "however , when a solver only needs a few iterations , the csr5 may not deliver speedups , compared to using the basic csr data .",
    "thereofore , improving performance of spmv using the most widely supported csr format has also gained plenty of attention  @xcite .",
    "most of the related work  @xcite has focused on improving row block method for the csr - based spmv",
    ". however , these newly proposed approaches are not highly efficient .",
    "the main reason is that co - processors are designed for load balanced high throughput computation , which is not naturally offered by the row pointer information of the csr format . on the other hand , using segmented sum method for the csr - based spmv has been proposed by  @xcite and been implemented in libraries cudpp  @xcite and modern gpu  @xcite for nvidia gpus . unlike the row block methods , the segmented sum algorithms evenly partition an input matrix @xmath0 for nearly perfect load balancing , and",
    "thus may be suitable for a co - processor implementation .",
    "but unfortunately , this method can not recognize empty rows and requires more costly global operations .",
    "these extra overheads may offset performance gain of load balanced segmented sum and degrade overall spmv efficiency .",
    "recently , heterogeneous processors ( which are also known as heterogeneous chip multiprocessors ) have been designed  @xcite and implemented  @xcite .",
    "compared to homogeneous processors such as cpus or gpus , heterogeneous processors can deliver improved overall performance and power efficiency  @xcite , while sufficient heterogeneous parallelisms exist .",
    "the main characteristics of heterogeneous processors include unified shared memory and fast communication among different types of cores ( e.g. , cpu cores and gpu cores ) .",
    "practically , heterogeneous system architecture ( hsa )  @xcite , opencl  @xcite and cuda  @xcite have supplied toolkits for programming heterogeneous processors .",
    "our work described in this paper particularly focuses on accelerating csr - based spmv on cpu - gpu heterogeneous processors .",
    "the main idea of our spmv algorithm is first speculatively executing spmv on a heterogeneous processor s gpu cores targeting high throughput computation , and then locally re - arranging resulting vectors by the cpu cores of the same chip for low - latency memory access . to achieve load balanced first step computation and to utilize both cpu and gpu cores",
    ", we improved the conventional segmented sum method by generating auxiliary information ( e.g. , segment descriptor ) at runtime and recognizing empty rows on - the - fly .",
    "compared to the row block methods for the csr - based spmv , our method delivers load balanced computation to achieve higher throughput .",
    "compared with the classic segmented sum method for the csr - based spmv , our approach decreases the overhead of global synchronization and removes pre- and post - processing regarding empty rows .",
    "this paper makes the following contributions :    * we propose a fast csr - based spmv algorithm that efficiently utilizes different types of cores in emerging cpu - gpu heterogeneous processors . *",
    "we develop an speculative segmented sum algorithm by generating auxiliary information on - the - fly and eliminating costly pre- and post - processing on empty rows . *",
    "we evaluate our csr - based spmv algorithm on a widely - adopted benchmark suite and achieve stable spmv performance independent of the sparsity structure of input matrix .    on a benchmark suite",
    "composed of 20 matrices with diverse sparsity structures , our approach greatly outperforms the row block methods for the csr - based spmv running on gpu cores of heterogeneous processors . on an intel heterogeneous processor ,",
    "the experimental results show that our method obtains up to 6.90x and on average 2.57x speedup over an opencl implementation of the csr - vector algorithm in cusp running on its gpu cores . on an amd heterogeneous processor ,",
    "our approach delivers up to 16.07x ( 14.43x ) and on average 5.61x ( 4.47x ) speedup over the fastest single ( double ) precision csr - based spmv algorithm from paralution and an opencl version of cusp running on its gpu cores . on an nvidia heterogeneous processor ,",
    "our approach delivers up to 5.91x ( 6.20x ) and on average 2.69x ( 2.53x ) speedup over the fastest single ( double ) precision csr - based spmv algorithm from cusparse and cusp running on its gpu cores .",
    "the paper is organized as follows .",
    "we first introduce background knowledge about the csr format , the csr - based spmv algorithms and heterogeneous processors in section 2 .",
    "then we describe our csr - based spmv algorithm in section 3 .",
    "moreover , we give and analyze our experimental results in section 4 .",
    "we review the related approaches in section 5 .",
    "the csr format of a sparse matrix consists of three separate arrays : ( 1 ) row pointer array of size @xmath6 , where @xmath5 is the number of rows of the matrix , ( 2 ) column index array of size @xmath7 , where @xmath7 is the number of nonzero entries of the matrix , and ( 3 ) value array of size @xmath7 .",
    "hence the overall space complexity of the csr format is @xmath8 .",
    "below we show a sparse matrix @xmath0 of size @xmath9 and its csr representation .",
    "@xmath10 @xmath11 \\\\ column\\ ; index & = \\begin{bmatrix}0 , 2 , 5,\\;\\ ; 0 , 1 , 2,\\;\\ ; 2 , 4,\\;\\ ; 4,\\;\\ ; 2 , 3 , 4\\end{bmatrix } \\\\% \\big [ [ \\ ; 0\\ ; 2\\ ; 5\\ ; ] [ \\ ; 0\\ ; 1\\ ; 2\\ ; 3\\ ; 4\\ ; 5\\ ; ] [ \\ ; 2\\;\\;\\ ; 4\\;\\;\\ , ] [ \\ ; 4\\;\\;\\ , ] [ \\;\\ , 2\\;\\;\\ , 3\\;\\;\\,\\ , 4\\;\\,\\ , ] \\big ] \\\\ value & = \\begin{bmatrix}a , b , c,\\;\\ ; d , e , f,\\;\\ ; g , h,\\;\\ ;   i,\\;\\;\\ ; j , k , l\\end{bmatrix}. \\nonumber% \\big [ [ \\ ; 1\\ ; 2\\ ; 3\\ ; ] [ \\ ; 4\\ ; 5\\ ; 6\\ ; 7\\ ; 8\\ ; 9\\ ; ] [ \\ ; 10\\;11\\ ; ] [ \\ ; 12\\ ; ] [ \\ ; 13\\ ; 14\\ ; 15\\ ; ] \\big ] \\\\   % segment\\ ; descriptor & = [ 1 , 0 , 0,\\;\\ ; 1 , 0 , 0,\\;\\ ; 1 , 0,\\;\\ ; 1,\\;\\ ; 1 , 0 , 0 ] .",
    "\\big [ [ \\ ; 1\\ ; 0\\ ; 0\\ ; ] [ \\ ; 1\\ ; 0\\ ; 0\\ ; 0\\ ; 0\\ ; 0\\ ; ] [ \\ ; 1\\;0\\ ; ] [ \\ ; 1\\ ; ] [ \\ ; 1\\ ; 0\\ ; 0\\ ; ] \\big ] \\nonumber % row\\ ; pointer & = \\big[\\;\\;\\;0\\;\\;\\;\\ ; 3\\;\\;\\;\\ ; 9\\;\\;\\;\\ ; 11\\;\\;\\;\\ ; 11\\;\\;\\;\\ ; 12\\;\\;\\;\\ ; 15\\;\\;\\;\\ ; \\big ] \\\\",
    "% column\\ ; index & = \\big [ [ \\ ; 0\\ ; 2\\ ; 5\\ ; ] [ \\ ; 0\\ ; 1\\ ; 2\\ ; 3\\ ; 4\\ ; 5\\ ; ] [ \\ ; 2\\;\\;\\ ; 4\\;\\;\\ , ] [ \\ ; 4\\;\\;\\ , ] [ \\;\\ , 2\\;\\;\\ , 3\\;\\;\\,\\ , 4\\;\\,\\ , ] \\big ] \\\\ % value & = \\big [ [ \\ ; 1\\ ; 2\\ ; 3\\ ; ] [ \\ ; 4\\ ; 5\\ ; 6\\ ; 7\\ ; 8\\ ; 9\\ ; ] [ \\ ; 10\\;11\\ ; ] [ \\ ; 12\\ ; ] [ \\ ; 13\\ ; 14\\ ; 15\\ ; ] \\big ] \\\\ % value & = \\big [ [ \\ ; 1\\ ; 0\\ ; 0\\ ; ] [ \\ ; 1\\ ; 0\\ ; 0\\ ; 0\\ ; 0\\ ; 0\\ ; ] [ \\ ; 1\\;0\\ ; ] [ \\ ; 1\\ ; ] [ \\ ; 1\\ ; 0\\ ; 0\\ ; ] \\big ] \\nonumber \\end{split}\\ ] ]    assume we have an input dense vector @xmath12 we can obtain a dense vector @xmath4 by multiplying the sparse matrix @xmath0 by the vector @xmath2 : @xmath13    the straightforward way to multiply @xmath0 with @xmath2 on a multicore processor is assigning a row block ( i.e. , multiple rows ) to each core .",
    "since the row pointer array records offset information of column index and value of nonzero entries , each core can easily position data in @xmath0 and @xmath2 .",
    "then generating corresponding entries of @xmath4 merely needs some simple multiply and add operations .",
    "for example , we assume that using a six - core processor for the above spmv operation and each core is responsible for one row . we can notice that the cores calculating the first , the second and the sixth rows are busier than the other cores .",
    "meanwhile , the core doing the fourth row is actually idle while the other cores are working .",
    "therefore , the row block method can not naturally handle load balance on multicore processors .",
    "on co - processors composed of a large amount of lightweight single instruction , multiple data ( simd ) units , the problem can heavily degrade performance of spmv operation .",
    "even though many strategies , such as vectorization  @xcite , data streaming  @xcite , memory coalescing  @xcite , static or dynamic binning  @xcite , dynamic parallelism  @xcite and dynamic row distribution  @xcite , have been proposed for the row block method , it is still impossible to achieve nearly perfect load balancing in general sense , simply since row sizes are irregular and unpredictable .",
    "the other method of computing the csr - based spmv is utilizing a segmented sum algorithm .",
    "this method first generates a segment descriptor of size @xmath7 .",
    "the descriptor marks the first nonzero entry of each non - empty row as 1 ( or equivalently ` true ` ) and the other nonzero entries as 0 ( or equivalently ` false ` ) . using the above 6-by-6 sparse matrix as an example",
    ", we have @xmath14 .",
    "\\nonumber \\end{split}\\ ] ] then an element - wise product array of size @xmath7 is allocated and filled by calculating @xmath15 = x[column\\ ; index[i]]\\times value[i ] , i\\in[0,nnz ) .",
    "\\nonumber \\end{split}\\ ] ] the third step conducts a segmented sum operation on the product array by using segment information stored in the segment descriptor .",
    "finally , the sum in each segment is stored to a contiguous location in @xmath4 .",
    "we can see that the segmented sum method can achieve nearly perfect load balance in the nonzero entry space .",
    "however , this method has two obvious drawbacks : ( 1 ) since the segment descriptor is binary , this method is unable to recognize empty rows , thus a pre - processing ( squeezing out possible empty rows ) is required for calculating a `` clean '' row pointer array , and a post - processing ( adding zeros to proper locations ) is needed for a correct resulting vector @xmath4 , and ( 2 ) this method requires more expensive global synchronizations and global memory access than the row block method ( which needs only one single kernel launch ) .",
    "therefore , in practice , the segmented sum method is not necessarily faster than the row block methods .      compared to homogeneous chip multiprocessors such as cpus and gpus , the heterogeneous processors are able to combine different types of cores into one chip .",
    "thus heterogeneous processors offer more flexibilities in architecture design space . because of mature cpu and gpu architectures and applications , cpu - gpu integrated heterogeneous processor with multiple instruction set architectures ( isas ) is the most widely adopted choice .",
    "representatives of this model include amd accelerated processing units ( apus )  @xcite , intel multi - cpu and gpu system - on - a - chip ( soc ) devices  @xcite , nvidia echelon heterogeneous gpu architecture  @xcite , and many mobile processors ( e.g. , nvidia tegra  @xcite and qualcomm snapdragon  @xcite ) .",
    "figure  [ spmv.parco.fig.hcmps ] shows two block diagrams of heterogeneous processors used as experimental testbed in this paper . in general , a heterogeneous processor consists of four major parts : ( 1 ) a group of cpu cores with hardware - controlled caches , ( 2 ) a group of gpu cores with shared command processors , software - controlled scratchpad memory and hardware - controlled caches , ( 3 ) shared memory management unit , and ( 4 ) shared global dynamic random - access memory ( dram )",
    ". the last level cache of the two types of cores can be separate as shown in figure  [ spmv.parco.fig.hcmps](a ) or shared as shown in figure  [ spmv.parco.fig.hcmps](b ) .",
    "the cpu cores have higher single - thread performance due to out - of - order execution , branch prediction and large amounts of caches .",
    "the gpu cores execute massively parallel lightweight threads on simd units for higher aggregate throughput .",
    "the two types of compute units have completely different isas and separate cache sub - systems .    in this paper ,",
    "our experiments run on three different platforms ( shown in table  [ spmv.parco.tab.testbed ] ) , the platforms from amd and nvidia are based on the design of figure  [ spmv.parco.fig.hcmps](a ) ; the intel platform uses the design of figure  [ spmv.parco.fig.hcmps](b ) .",
    "note that in the current amd apu architecture , although the two types of cores have separate last level caches , the gpu cores are able to snoop the last level cache on the cpu side . compared to loosely - coupled cpu - gpu heterogeneous systems , the two types of cores in a heterogeneous processor share one single unified address space instead of using separate address spaces ( i.e. , system memory space and gpu device memory space ) .",
    "one obvious benefit is avoiding data transfer through connection interfaces ( e.g. , pcie link ) , which is one of the most well known bottlenecks of co - processor computing  @xcite . additionally , gpu cores can access more memory by paging memory to and from disk .",
    "further , the consistent pageable shared virtual memory can be fully or partially coherent , meaning that much more efficient cpu - gpu interactions are possible due to eliminated heavyweight synchronization ( i.e. , flushing and gpu cache invalidation ) .",
    "currently , programming on the unified address space and low - overhead kernel launch are supported by hsa  @xcite , opencl  @xcite and cuda  @xcite .",
    "we first evenly decompose nonzero entries of the input matrix to multiple small tiles for load balanced data parallelism . here",
    "we define a tile as a 2d array of size @xmath16 .",
    "the width @xmath17 is the size of a thread - bunch , which is the minimum simd execution unit in a given vector processor .",
    "it is also known as wavefront in amd gpus or warp in nvidia gpus .",
    "the height @xmath18 is the workload ( i.e. , the number of nonzero entries to be processed ) of a thread .",
    "a tile is a basic work unit in matrix - based segmented sum method  @xcite , which is used as a building block in our spmv algorithm . actually , the term `` tile '' is equivalent to the term `` matrix '' used in original description of the segmented scan algorithms  @xcite .",
    "here we use `` tile '' to avoid confusion between a work unit of matrix shape and a sparse matrix in spmv .    since a thread - bunch can be relatively too small ( e.g. , as low as 8 in current intel gpus ) to amortize scheduling cost , we combine multiple thread - bunches into one thread - group ( i.e. , work - group in opencl terminology or thread block in cuda terminology ) for possibly higher throughput .",
    "we define @xmath19 to denote the number of thread - bunches in one thread - group .",
    "additionally , we let each thread - bunch compute @xmath20 contiguous tiles .",
    "thus higher on - chip resource reuse and faster global synchronization are expected .",
    "therefore , we can calculate that each thread - group deals with @xmath21 nonzero entries .",
    "thus the whole nonzero entry space of size @xmath7 can be evenly assigned to @xmath22 thread - groups .",
    "figure  [ spmv.parco.fig.datadecomposation ] shows an example of the data decomposition . in this example",
    ", we set @xmath23 , @xmath24 , @xmath25 , and @xmath26 .",
    "thus each thread - group is responsible for 32 nonzero entries .",
    "then @xmath27 thread - groups are dispatched .",
    "our csr - based spmv is based on fundamental segmented sum algorithm , which guarantees load balanced computation in the nonzero entry space .",
    "while utilizing segmented sum as a building block in our spmv algorithm , we have three main performance considerations : ( 1 ) the segment descriptor needs to be generated in on - chip memory at runtime to reduce overhead of global memory access , ( 2 ) empty rows must be recognized and processed without calling specific pre- and post - processing functions , and ( 3 ) taking advantages of both types of cores in a heterogeneous processor . hence we improve the basic segmented sum method to meet the above performance requirements .",
    "the algorithm framework includes two main stages : ( 1 ) speculative execution stage , and ( 2 ) checking prediction stage .",
    "the first stage speculatively executes spmv operation and generates a possibly incorrect resulting vector @xmath4 . here",
    "the term `` incorrect '' means that the layout of entries in @xmath4 can be incorrect , but the entries are guaranteed to be numerically identified .",
    "then in the second stage we check whether or not the speculative execution is successful . if the prediction is wrong , a data re - arrangement will be launched for getting a completely correct @xmath4 .",
    "we first give an example of our algorithm and use it in the following algorithm description .",
    "figure  [ spmv.parco.fig.example ] plots this example .",
    "the input sparse matrix includes 12 rows ( 2 of them are empty ) and 48 nonzero entries .",
    "we set @xmath19 to 1 , @xmath20 to 2 , @xmath17 to 4 and @xmath18 to 6 .",
    "this setting means that one thread - group is composed of one thread - bunch of size 4 ; each thread - bunch runs 2 iteration steps . before gpu kernel launch , three containers , _ synchronizer _ , _",
    "dirty_counter _ and _ speculator _ , are pre - allocated in dram for global synchronization and speculative execution .",
    "algorithm  [ spmv.parco.alg.spmv ] in appendix a lists pseudo code of the first stage .",
    "the * speculative execution stage * includes the following steps : ( 1 ) positioning a range of row indices for nonzero entries in a given tile , ( 2 ) calculating segment descriptor based on the range , ( 3 ) conducting segmented sum on the tile , ( 4 ) saving partial sums to the computed index range in vector @xmath4 .",
    "this stage also has some input - triggered operations such as labeling a tile with empty rows .",
    "first , each thread - bunch executes binary search of @xmath28 tile boundaries on the csr row pointer array . then we obtain corresponding row indices and store them in a scratchpad array _",
    "tile offset _ of size @xmath28 .",
    "the results of the binary search are starting and ending row indices of the nonzero entries in each tile .",
    "thus each tile knows the locations to store generated partial sums .",
    "lines 37 of algorithm  [ spmv.parco.alg.spmv ] give a code expression of this step .",
    "in our example shown in figure  [ spmv.parco.fig.example ] , the 2 tiles of size 24 have 3 boundaries \\{0 , 24 , 48}. the results of binary search of \\{0 , 24 , 48 } on the csr row pointer array are \\{0 , 4 , 12}. note that the binary search needs to return the rightmost match , if multiple slots have the same value .",
    "then each thread - bunch executes an iteration of @xmath20 steps .",
    "lines 859 of algorithm  [ spmv.parco.alg.spmv ] give code expression of this step .",
    "each iteration deals with one tile . by calculating offset between the left boundary of a tile and the covered row indices ,",
    "a local segment descriptor is generated ( lines 1421 in algorithm  [ spmv.parco.alg.spmv ] ) .",
    "for example , the left boundary of the second tile is 24 and its row index range is 412 . we need to compute offset between 24 and the row pointer \\{19 , 27 , 29 , 29 , 34 , 37 , 37 , 44 , 48}. then we obtain a group of offsets \\{-5 , 3 , 5 , 5 , 10 , 13 , 13 , 20 , 24}. after removing duplicate values and overflowed values on the left and the right sides , the effective part \\{3 , 5 , 10 , 13 , 20 } in fact implies local segment descriptor for the current tile .",
    "we can easily convert it to a binary expression \\{0 , 0 , 0 , 1 , 0 , 1 , 0 , ... , 0 , 0 , 1 , 0 , 0 , 0 } through a scatter operation in on - chip scratchpad memory .",
    "moreover , since each tile is an independent work unit , the first bit of its segment descriptor should be ` true ` .",
    "thus the final expression becomes \\{1 , 0 , 0 , 1 , 0 , 1 , 0 , ... , 0 , 0 , 1 , 0 , 0 , 0}. in figure  [ spmv.parco.fig.example ] , the filled and empty circles are heads ( i.e. , 1s or ` true`s ) and body ( i.e. , 0s or ` false`s ) of segments , respectively .    while generating the segment descriptor , each thread detects whether or not its right neighbor wants to write to the same slot .",
    "if yes ( like the duplicate offset information \\ { ... , 5 , 5 , ... } and \\ { ... , 13 , 13 , ... } in the above example ) , we can make sure that this tile contains at least one empty row , since an empty row is expressed as two contiguous indices of the same value in the csr row pointer array .",
    "then we mark this tile as `` dirty '' ( line 19 in algorithm  [ spmv.parco.alg.spmv ] ) .",
    "further , the _ dirty counter _",
    "array stored in dram is incremented by atomic operation , and this tile s offset is recorded in the _ speculator _ array ( lines 5358 in algorithm  [ spmv.parco.alg.spmv ] ) . in our example , _ dirty counter _ is 1 and _ speculator _ array has a pair of offsets \\{@xmath294 , 12@xmath30 } ( ( shown with angular brackets in figure  [ spmv.parco.fig.example ] ) .",
    "then we calculate and save element - wise products in scratchpad memory , based on its nonzero entries column indices , values and corresponding values in the vector @xmath2 .",
    "lines 2226 of algorithm  [ spmv.parco.alg.spmv ] show code expression of this step . when finished , we transmit the sum of the last segment to an intermediate space for the next iteration ( lines 2731 in algorithm  [ spmv.parco.alg.spmv ] ) . in our example , the first tile s last value @xmath31 is transmitted to the next tile",
    ". then we execute the matrix - based segmented sum ( lines 3233 ) on the tile . because the segmented sum algorithm used here is very similar to the method described in  @xcite",
    ", we refer the reader to  @xcite and several pervious gpu segmented sum algorithms  @xcite for details . but note that compared to  @xcite , our method makes one difference : we store partial sums in a compact pattern ( i.e. , values are arranged in order from the first location in the thread work space ) , but not save them to locations of corresponding segment heads .",
    "for this reason , we need to record the starting position and the number of partial sums",
    ". then we can use an ordinary exclusive scan operation ( lines 3435 ) for obtaining contiguous indices of the partials sums in @xmath4 . in figure",
    "[ spmv.parco.fig.example ] , we can see that the partial sums ( expressed as filled hexagons ) are aggregated in the compact fashion .",
    "note that empty hexagons are intermediate partial sums , which are already added to the correct position of segment heads .",
    "finally , we store the partial sums to known locations in the resulting vector .",
    "lines 3652 of algorithm  [ spmv.parco.alg.spmv ] show code expression . as an exception",
    ", the sum result of the first segment in a thread - bunch is stored to the _ synchronizer _ array ( lines 4043 ) , since the first row of each thread - bunch may cross multiple thread - bunch .",
    "this is a well known issue while conducting basic primitives , such as reduction and prefix - sum scan , using more than one thread - group that can not communicate with each other .",
    "in fact , atomic add operation can be utilized to avoid the global synchronization .",
    "but we choose not to use relatively slow global atomic operations and let a cpu core to later on finish the global synchronization .",
    "lines 6268 of algorithm  [ spmv.parco.alg.spmv ] show the corresponding code expression . since the problem size ( i.e. , @xmath32",
    ") can be too small to saturate a gpu core , a cpu core is in fact faster for accessing short arrays linearly stored in dram .",
    "taking the first tile in figure  [ spmv.parco.fig.example ] as an example , its first partial sum is @xmath33 , which is stored with its global index 0 to the _ synchronizer_. after that , the value @xmath33 is added to position 0 of @xmath4 .",
    "when the above steps are complete , the resulting vector is numerically identified , except that some values generated by dirty tiles are not in their correct locations . in figure  [ spmv.parco.fig.example ] , we can see that after synchronization , vector @xmath4 is already numerically identified to its final form , but entries @xmath34 , @xmath35 , @xmath36 and @xmath37 generated by the second tile are located in wrong slots .    the * checking prediction stage * first checks value of the _ dirty counter _ array .",
    "if it is zero , the previous prediction is correct and the result of the first stage is the final result ; if it is not zero , the predicted entries generated by dirty tiles are scattered to their correct positions in the resulting vector . in this procedure , the csr row pointer array is required to be read for getting correct row distribution information . again , we use a cpu core for the irregular linear memory access , which is more suitable for cache sub - systems in cpus . in our example , entries @xmath34 , @xmath35 , @xmath36 and @xmath37 are moved to their correct positions .",
    "then the spmv operation is done .",
    "@xmath38.start$ ] @xmath39.stop$ ]    @xmath40.index ] \\gets y[synchronizer[i].index ] + synchronizer[i].value$ ]      our csr - based spmv algorithm pre - allocates three auxiliary arrays , _ synchronizer _ , _ dirty counter _ and _ speculator _ , in dram .",
    "the space complexity of _ synchronizer _ is @xmath32 , equivalent to the number of thread - bunches .",
    "the size of _ dirty counter _ is constant 1 .",
    "the _ speculator _ array needs a size of @xmath41 , equivalent to the number of tiles . since @xmath18 and @xmath17 are typically set to relatively large values , the auxiliary arrays merely slightly increase overall space requirement .    for each thread -",
    "bunch , we executes @xmath28 binary searches in the row pointer array of size @xmath6 .",
    "thus @xmath42 is work complexity of this part . on the whole",
    ", generating segment descriptor needs @xmath43 time . collecting element - wise products needs @xmath44 time . for each tile , segmented sum needs @xmath45 time .",
    "thus all segmented sum operations need @xmath46 time . saving entries to @xmath4",
    "needs @xmath43 time .",
    "synchronization takes @xmath47 time .",
    "possible re - arrangement needs @xmath43 time in the worst case .",
    "thus overall work complexity of our csr - based spmv algorithm is @xmath48 .",
    "based on the above analysis , we can see that when the input matrix is fixed , the cost of our spmv algorithm only depends on two parameters : @xmath17 and @xmath18 . in our algorithm",
    "implementation , @xmath17 is set to simd length of the used processor .",
    "choosing @xmath18 needs to consider the capacity of on - chip scratchpad memory .",
    "the other two parameters @xmath19 and @xmath20 are empirically chosen .",
    "table  [ spmv.parco.tab.parameters ] shows the selected parameters .",
    "note that double precision is not currently supported in intel opencl implementation for its gpus .",
    "> m1.5 cm > m1.25 cm > m1.25 cm >",
    "m1.25 cm > m1.25 cm > m1.25",
    "cm    processor & intel & & precision & 32-bit single & 32-bit single & 64-bit double & 32-bit single & 64-bit double @xmath17 & 8 & 64 & 64 & 32 & 32 @xmath18 & 16 & 16 & 8 & 8 & 4 @xmath19 & 4 & 2 & 2 & 5 & 5 @xmath20 & 6 & 2 & 5 & 7 & 7    we implement the first stage of our algorithm in opencl for the intel and amd platforms ( and cuda for the nvidia platform ) for gpu execution and the second stage in standard c language running on the cpu part .",
    "since our algorithm needs cpu and gpu share some arrays , we allocate all arrays in shared virtual memory supported by opencl for the best performance . on the nvidia platform",
    ", we use unified memory in cuda sdk .",
    "we use three heterogeneous processors , intel core i3 - 5010u , amd a10 - 7850k apu and nvidia tegra k1 , for evaluating spmv algorithms .",
    "table  [ spmv.parco.tab.testbed ] shows specifications of the three processors .",
    "all of them are composed of multiple cpu cores and gpu cores .",
    "the two types of cores in the intel heterogeneous processor share a 3 mb last level cache .",
    "in contrast , gpu cores in the amd heterogeneous processor can snoop the l2 cache of size 4 mb on the cpu side . unlike those , the cache systems of the cpu part and the gpu part in the nvidia tegra processor are completely separate .",
    "note that currently the intel gpu can run opencl program only on microsoft windows operating system .",
    "also note that we use kb , mb and gb to denote @xmath49 , @xmath50 and @xmath51 bytes , respectively ; and use gflop to denote @xmath52 flops .",
    "m1.3 cm > m1.3 cm > m1.3 cm > m1.3 cm > m1.3 cm > m1.3 cm processor & & & core type & x86 cpu & gpu & x86 cpu & gpu & arm cpu & gpucodename & broadwell & hd 5500 & steamroller & gcn & cortex a15 & keplercores @ clock ( ghz ) & 2 @ 2.1 & 3 @ 0.9 & 4 @ 3.7 & 8 @ 0.72 & 4 @ 2.3 & 1 @ 0.85 sp flops / cycle & 2@xmath5332 & 3@xmath53128 & 4@xmath538 & 8@xmath53128 & 4@xmath538 & 1@xmath53384sp peak ( gflop / s ) & 134.4 & 345.6 & 118.4 & 737.3 & 73.6 & 327.2dp flops / cycle & 2@xmath5316 & 3@xmath5332 & 4@xmath534 & 8@xmath538 & 2@xmath532 & 1@xmath5316dp peak ( gflop / s ) & 67.2 & 86.4 & 59.2 & 46.1 & 18.4 & 13.6l1 data cache & 4@xmath5332 kb & 3@xmath534 kb & 4@xmath5316 kb & 8@xmath5316 kb & 4@xmath5332 kb & 1@xmath5316 kbl2 cache & 4@xmath53256 kb & 3@xmath5324 kb & 2@xmath532 mb & unreleased & 2 mb & 128 kbl3 cache & n / a & 384 kb & n / a & n / a & n / a & n / ascratchpad & n / a & 3@xmath5364 kb & n / a & 8@xmath5364 kb & n / a & 1@xmath5348 kb    shared last level cache & & & dram & & & dram capacity & & & dram bandwidth & & &    operating system & & & gpu driver version & & & compiler & & & toolkit version & & &      to evaluate our method , we choose 20 unstructured matrices from the university of florida sparse matrix collection  @xcite .",
    "table  [ spmv.parco.tab.benchmark ] lists main information of the evaluated sparse matrices .",
    "the first 14 matrices of the benchmark suite have been widely used in previous work  @xcite .",
    "the last 6 matrices are chosen as representatives of irregular matrices extracted from graph applications , such as circuit simulation and optimization problems .",
    "the first 10 matrices are relatively regular , due to short distance between the average value and the maximum value of @xmath7/row .",
    "the other matrices are relatively irregular . in this context ,",
    "` regular ' is used for a sparse matrix including rows of roughly the same size .",
    "in contrast , an ` irregular matrix ' can have some very long rows and many very short rows .",
    "for example , matrices generated from power - law graphs can have a few rows with @xmath54 nonzero entries and many rows with @xmath55 nonzero entries .",
    ".overview of evaluated sparse matrices [ cols=\"^,^,^,^,^,^ \" , ]      to analyze efficiency of the proposed spmv algorithm , we also benchmark parallel csr - based spmv using some other libraries or methods on cpus and gpus .    on cpus",
    ", we execute three csr - based spmv approaches : ( 1 ) openmp - accelerated basic row block method , ( 2 ) poski library  @xcite using oski  @xcite as a building block , and ( 3 ) intel mkl v11.2 update 2 in intel parallel studio xe 2015 update 2 .",
    "the three approaches are running on all cpu cores of the used heterogeneous processors .",
    "for the intel cpu , we report results from mkl , since it always delivers the best performance and the poski is not supported by the used microsoft windows operating system . for the amd cpu , we report the best results of the three libraries , since none of the three libraries outperforms all the others . for",
    "the arm cpu included in the nvidia tegra k1 platform , we only report results from openmp , since the current poski and intel mkl implementations do not support the arm architecture .",
    "moreover , single - threaded nave implementation on cpu is included in our benchmark as well .",
    "on gpus , we benchmark variants of the csr - scalar and the csr - vector algorithms proposed in  @xcite . the opencl version of the csr - scalar method is extracted from parallution v1.0.0  @xcite and evaluated on the amd platform .",
    "the opencl implementation of the csr - vector method is extracted from semantically equivalent cuda code in the cusp library v0.4.0 and executed on both the intel and the amd platforms . on the nvidia platform",
    ", we run the csr - based spmv from vendor - supplied cusparse v6.0 and cusp v0.4.0 libraries .",
    "for all tests , we run spmv 200 times and record averages . the implicit data transfer ( i.e. , matrices and vectors data copy from their sources to opencl shared virtual memory or cuda unified memory ) is not included in our evaluation , since spmv operation is normally one building block of more complex applications .",
    "all participating methods conduct general spmv , meaning that symmetry is not considered although some input matrices are symmetric .",
    "the throughput ( flops per second ) is calculated by @xmath56 the bandwidth ( bytes per second ) is calculated by @xmath57      -6pt",
    "-6pt -6pt -6pt    -6pt -6pt -6pt -6pt    figures  [ spmv.parco.fig.spthroughput ] and  [ spmv.parco.fig.dpthroughput ] show throughput of single precision and double precision spmv of the tested csr - based approaches , respectively .    in figure  [ spmv.parco.fig.spthroughput ] , we can see that on the intel heterogeneous processor , our approach obtains up to 6.90x and on average 2.57x speedup over the csr - vector method running on the used gpu .",
    "although the speedup mainly comes from irregular matrices , our method generally does not obviously lose performance on regular matrices .",
    "further , compared to cpu cores running mkl , both gpu spmv algorithms are slower . for our algorithm , the main reason is that the integrated gpu implements scratchpad memory in its l3 cache , which has one order of magnitude higher latency compared to fast scratchpad in nvidia or amd gpus .",
    "our algorithm in fact heavily uses scratchpad memory for storing and reusing segment descriptor , element - wise products and other shared data by threads .",
    "thus even though the gpu part of the intel heterogeneous processor has higher single precision theoretical peak performance than its cpu part , the delivered spmv throughput is lower than expected . for the csr - vector method",
    ", the low performance has another reason : small thread - bunch of size 8 dramatically increases loop overhead  @xcite , which is one of the well known bottlenecks  @xcite of gpu programming .    in figures  [ spmv.parco.fig.spthroughput ] and  [ spmv.parco.fig.dpthroughput ]",
    ", we can see that on the amd heterogeneous processor , our method delivers up to 71.90x ( 94.05x ) and on average 22.17x ( 22.88x ) speedup over the single ( double ) precision csr - scalar method running on the used gpu .",
    "compared to the gpu csr - vector method , our algorithm achieves up to 16.07x ( 14.43x ) and on average 5.61x ( 4.47x ) speedup .",
    "the csr - scalar and the csr - vector methods give very low throughput while running the last 6 irregular matrices , because of the problem of load imbalance .",
    "further , we find that the intel heterogeneous processor s gpu is actually faster than the amd gpu while running the last 6 matrices .",
    "the reason is that the shorter thread - bunch ( 8 in intel gpu vs. 64 in amd gpu ) brings a positive influence for saving simd idle cost by executing a much shorter vector width for dramatically imbalanced row distribution . on the other hand , for several very regular matrices with short rows , e.g. , _ epidemiology _ , the csr - scalar method offers the best performance because of almost perfect load balance and execution of short rows without loop cost . for most regular matrices ,",
    "our method delivers comparable performance over the best cpu algorithm .    in figures  [ spmv.parco.fig.spthroughput ] and  [ spmv.parco.fig.dpthroughput ]",
    ", we can see that on the nvidia platform , our method delivers up to 5.91x ( 6.20x ) and on average 2.69x ( 2.53x ) speedup over the single ( double ) precision spmv in the cusp library running on the used gpu .",
    "compared to cusparse , our method has higher speedups . since the both libraries use csr - vector algorithm , those speedups are within expectations .",
    "consider the tegra k1 platform only contains one single gpu core , the problem of load imbalance on this device is not as heavy as on the above amd platform . as a result ,",
    "the speedups are not as high as those from the amd processor . here",
    "our method delivers on average 1.41x ( 1.42x ) speedup over openmp - accelerated spmv on the quad - core arm cpu , while using single ( double ) precision benchmark .",
    "figure  [ spmv.parco.fig.bandwidth ] shows bandwidth utilization of our algorithm proposed in this paper .",
    "we can see that the regular matrices can use bandwidth more efficiently compared to the irregular ones .",
    "considering the throughput speedups listed above , our method can obtain higher bandwidth utilization than the other csr - based spmv algorithms running on gpus .",
    "we further conduct experiments to exploit how selected parameters influence overall performance .",
    "figure  [ spmv.parco.fig.parameterw ] shows dependency of the overall performance ( harmonic means of the 20 benchmarks ) on the parameters , while we fix all the parameters except for parameter @xmath18 ( i.e. , workload per thread ) .",
    "we can see that in general the overall performance goes up as parameter @xmath18 increases .",
    "this trend matches the algorithm complexity analysis described in section 3.3 .",
    "however , when @xmath18 is larger than a certain value , the overall performance degrades .",
    "the reason is that device occupancy may decrease while more on - chip scratchpad memory is allocated for @xmath58 work space of each thread - bunch .",
    "figure  [ spmv.parco.fig.parameters ] shows the trend of the overall performance while we change parameter @xmath20 ( i.e. , the number of iterations of each thread - bunch ) and fix all the other parameters .",
    "we can see that if we assign more work to each thread - bunch , a better performance can be expected .",
    "the performance improvement mainly comes from higher on - chip resource reuse .",
    "in recent years , some new formats have been designed for spmv operation on various processor architectures . because of less off - chip memory access and better on - chip memory localization , block - based formats or libraries , such as oski  @xcite , poski  @xcite , csb  @xcite , bellpack  @xcite , bccoo / bccoo+  @xcite , brc  @xcite and rsb  @xcite , attracted the most attention .",
    "however , block - based formats heavily rely on sparsity structure , meaning that the input matrix is required to have a block structure to meet potential block layout . therefore , block - based formats are mainly suitable for some matrices generated from scientific computation problems , but may not fit irregular matrices generated from graph applications .",
    "our method proposed in this paper is insensitive to the sparsity structure of input matrix , thus a generally better performance is achieved .",
    "a lot of research has focused on improving row block method csr - based spmv . williams et al .",
    "@xcite proposed multiple optimization techniques for spmv on multi - core cpus and cell b.e .",
    "nishtala et al .",
    "@xcite designed a high - level data partitioning method for spmv to achieve better cache locality on multicore cpus .",
    "pichel et al .",
    "@xcite evaluated how reordering techniques influence performance of spmv on gpus .",
    "baskaran and bordawekar  @xcite improved off - chip and on - chip memory access patterns of spmv on gpus .",
    "reguly and giles  @xcite improved thread cooperation for better gpu cache utilization .",
    "ashari et al .",
    "@xcite utilized static reordering and the dynamic parallelism scheme offered by nvidia gpus for fast spmv operation .",
    "greathouse et al .",
    "@xcite grouped contiguous rows for better runtime load balancing on gpus .",
    "lightspmv  [ liu : lightspmv ] proposed to dynamically distribute matrix rows over warps in order for more balanced csr - based spmv without the requirement of generating auxiliary data structures , and implemented this approach using atomic operations and warp shuffle functions as the fundamental building blocks .",
    "however , again , the row block methods can not achieve good performance for input matrix with dramatically imbalanced row distribution .",
    "in contrast , our method is independent with the sparsity structure of input matrix .",
    "using segmented sum as a building block is potentially a better generic method for the csr - based spmv .",
    "an early segmented sum method gpu spmv was introduced by sengupta et al .",
    "@xcite and garland  @xcite and implemented in the cudpp library  @xcite .",
    "but the cost of segmented sum and global memory access degrade overall spmv performance .",
    "zhang  @xcite improved backward segmented scan for a better cache efficiency and implemented the csr - based spmv on multicore cpus .",
    "recently , nvidia s modern gpu library  @xcite implemented an improved reduction method , which has been used as a back - end of cudpp .",
    "however , its performance still suffered by pre- and post - processing empty rows in global memory space .",
    "our method , in contrast , uses scratchpad memory more efficiently and utilizes the two types of cores in a heterogeneous processor for better workload distribution .    compared with our recent work csr5  @xcite ,",
    "a format designed for cross - platform spmv on cpus , gpus and xeon phi , the spmv approach presented in this paper does not need to process any format conversion or generate any auxiliary data for the input csr matrix . consider the format conversion from the csr to the csr5 merely needs the cost of a few spmv operations , the csr5-based spmv and the csr - based spmv can find their own application scenarios , such as solvers with different number of iterations .",
    "we proposed an efficient method for spmv on heterogeneous processors using the csr storage format . on three mainstream platforms from intel , amd and nvidia ,",
    "our method greatly outperforms row block method csr - based spmv algorithms running on gpus .",
    "the performance gain mainly comes from our newly developed speculative segmented sum strategy that efficiently utilizes different types of cores in a heterogeneous processor . in this work",
    ", we assign different task to the cpu part and the gpu part in one heterogeneous processor .",
    "however , the heaviest workload ( stage 1 in our method ) currently only runs on gpu cores , while the cpu cores may be idle .",
    "obviously , it is possible to schedule tasks in the first stage on both cpu cores and gpu cores simultaneously for potentially higher throughput .",
    "however , a heterogeneity - aware scheduling strategy is beyond the scope of the spmv algorithm focused in this paper .",
    "we refer the reader to  @xcite for recent progress on utilizing both cpu cores and gpu cores in a heterogeneous environment .",
    "the authors would like to thank james avery for his valuable feedback .",
    "the authors also thank the anonymous reviewers for their insightful suggestions and comments on this paper .",
    "10 url # 1`#1`urlprefixhref # 1#2#2 # 1#1    n.  bell , m.  garland , implementing sparse matrix - vector multiplication on troughput - oriented processors , in : proceedings of the conference on high performance computing networking , storage and analysis , sc 09 , 2009 , pp . 18:118:11 .",
    "su , k.  keutzer , clspmv : a cross - platform opencl spmv framework on gpus , in : proceedings of the 26th acm international conference on supercomputing , ics 12 , 2012 , pp .",
    "353364 .",
    "r.  li , y.  saad , gpu - accelerated preconditioned iterative linear solvers , the journal of supercomputing 63  ( 2 ) ( 2013 ) 443466 .",
    "x.  liu , m.  smelyanskiy , e.  chow , p.  dubey , efficient sparse matrix - vector multiplication on x86-based many - core processors , in : proceedings of the 27th international acm conference on international conference on supercomputing , ics 13 , 2013 , pp .",
    "273282 .",
    "s.  yan , c.  li , y.  zhang , h.  zhou , yaspmv : yet another spmv framework on gpus , in : proceedings of the 19th acm sigplan symposium on principles and practice of parallel programming , ppopp 14 , 2014 , pp .",
    "107118 .",
    "a.  ashari , n.  sedaghati , j.  eisenlohr , p.  sadayappan , an efficient two - dimensional blocking strategy for sparse matrix - vector multiplication on gpus , in : proceedings of the 28th acm international conference on supercomputing , ics 14 , 2014 , pp .",
    "273282 .",
    "s.  balay , s.  abhyankar , m.  f. adams , j.  brown , p.  brune , k.  buschelman , v.  eijkhout , w.  d. gropp , d.  kaushik , m.  g. knepley , l.  c. mcinnes , k.  rupp , b.  f. smith , h.  zhang , petsc users manual , tech .",
    "anl-95/11 - revision 3.5 , argonne national laboratory ( 2014 ) .",
    "v.  minden , b.  smith , m.  knepley , preliminary implementation of petsc using gpus , in : d.  a. yuen , l.  wang , x.  chi , l.  johnsson , w.  ge , y.  shi ( eds . ) , gpu solutions to multi - scale problems in science and engineering , lecture notes in earth system sciences , springer berlin heidelberg , 2013 , pp . 131140 .",
    "p.  kumbhar , performance of petsc gpu implementation with sparse matrix storage schemes , master s thesis , the university of edinburgh ( aug 2011 ) .",
    "d.  langr , p.  tvrdk , evaluation criteria for sparse matrix storage formats , ieee transactions on parallel and distributed systems [ in press ] .",
    "w.  liu , b.  vinter , an efficient gpu general sparse matrix - matrix multiplication for irregular data , in : proceedings of the 2014 ieee 28th international parallel and distributed processing symposium , ipdps 14 , 2014 , pp .",
    "370381 .",
    "w.  liu , b.  vinter , csr5 : an efficient storage format for cross - platform sparse matrix - vector multiplication , in : proceedings of the 29th acm international conference on supercomputing , ics 15 , 2015 , pp .",
    "339350 .",
    "s.  williams , l.  oliker , r.  vuduc , j.  shalf , k.  yelick , j.  demmel , optimization of sparse matrix - vector multiplication on emerging multicore platforms , parallel computing 35  ( 3 ) ( 2009 ) 178194 .",
    "j.  l. greathouse , m.  daga , efficient sparse matrix - vector multiplication on gpus using the csr storage format , in : proceedings of the international conference for high performance computing , networking , storage and analysis , sc 14 , 2014 , pp . 769780 .",
    "a.  ashari , n.  sedaghati , j.  eisenlohr , s.  parthasarathy , p.  sadayappan , fast sparse matrix - vector multiplication on gpus for graph applications , in : proceedings of the international conference for high performance computing , networking , storage and analysis , sc 14 , 2014 , pp .",
    "781792 .",
    "g.  e. blelloch , m.  a. heroux , m.  zagha , segmented operations for sparse matrix computation on vector multiprocessors , tech .",
    "cmu - cs-93 - 173 , carnegie mellon university ( aug 1993 ) .",
    "m.  harris , j.  d. owens , s.  sengupta , cudpp documentation , nvidia , 2nd edition ( aug 2014 ) .",
    "s.  baxter , modern gpu , nvidia ( 2013 ) .",
    "y.  liu , b.  schmidt , lightspmv : faster csr - based sparse matrix - vector multiplication on cuda - enabled gpus , in : application - specific systems , architectures and processors ( asap ) , 2015 ieee 26th international conference on , 2015 .",
    "s.  sengupta , m.  harris , y.  zhang , j.  d. owens , scan primitives for gpu computing , in : proceedings of the 22nd acm siggraph / eurographics symposium on graphics hardware , gh 07 , 2007 , pp . 97106 .",
    "m.  garland , sparse matrix computations on manycore gpu s , in : proceedings of the 45th annual design automation conference , dac 08 , 2008 , pp .",
    "r.  kumar , d.  tullsen , n.  jouppi , p.  ranganathan , heterogeneous chip multiprocessors , computer 38  ( 11 ) ( 2005 ) 3238 .",
    "s.  keckler , w.  dally , b.  khailany , m.  garland , d.  glasco , gpus and the future of parallel computing , micro , ieee 31  ( 5 ) ( 2011 ) 717 .",
    "a.  branover , d.  foley , m.  steinman , amd fusion apu : llano , ieee micro 32  ( 2 ) ( 2012 ) 2837 .",
    "amd , white paper : compute cores ( jan 2014 ) .",
    "s.  damaraju , v.  george , s.  jahagirdar , t.  khondker , r.  milstrey , s.  sarkar , s.  siers , i.  stolero , a.  subbiah , a 22 nm ia multi - cpu and gpu system - on - chip , in : solid - state circuits conference digest of technical papers ( isscc ) , 2012 ieee international , 2012 , pp .",
    "nvidia , nvidia tegra k1 a new era in mobile computing , 1st edition ( jan 2014 ) .",
    "qualcomm , qualcomm snapdragon 800 product brief ( aug 2013 ) .",
    "e.  chung , p.  milder , j.  hoe , k.  mai , single - chip heterogeneous computing : does the future include custom logic , fpgas , and gpgpus ? , in : microarchitecture ( micro ) , 2010 43rd annual ieee / acm international symposium on , 2010 , pp .",
    "225236 .",
    "hsa foundation , hsa programmer s reference manual : hsail virtual isa and programming model , compiler writer s guide , and object format ( brig ) , 0th edition ( may 2013 ) .",
    "a.  munshi , the opencl specification , khronos opencl working group , 2nd edition ( mar 2014 ) .",
    "d.  negrut , r.  serban , a.  li , a.  seidl , unified memory in cuda 6 : a brief overview and related data access / transfer issues , tech . rep .",
    "tr-2014 - 09 , university of wisconsin  madison ( jun 2014 ) .",
    "y.  s. deng , b.  d. wang , s.  mu , taming irregular eda applications on gpus , in : proceedings of the 2009 international conference on computer - aided design , iccad 09 , 2009 , pp .",
    "539546 .",
    "c.  gregg , k.  hazelwood , where is the data ?",
    "why you can not debate cpu vs. gpu performance without the answer , in : performance analysis of systems and software ( ispass ) , 2011 ieee international symposium on , 2011 , pp .",
    "134144 .",
    "y.  dotsenko , n.  k. govindaraju , p .-",
    "sloan , c.  boyd , j.  manferdelli , fast scan algorithms on graphics processors , in : proceedings of the 22nd annual international conference on supercomputing , ics 08 , 2008 , pp .",
    "205213 .",
    "t.  a. davis , y.  hu , the university of florida sparse matrix collection , acm trans .",
    "38  ( 1 ) ( 2011 ) 1:11:25 .",
    "byun , r.  lin , j.  w. demmel , k.  a. yelick , poski : parallel optimized sparse kernel interface library user s guide , university of california , berkeley , 1st edition ( apr 2012 ) .",
    "r.  vuduc , j.  w. demmel , k.  a. yelick , oski : a library of automatically tuned sparse matrix kernels , journal of physics : conference series 16  ( 1 ) ( 2005 ) 521530 .",
    "d.  lukarski , n.  trost , paralution - user manual , tech .",
    "1.0.0 , paralution labs ug ( haftungsbeschrnkt ) co. kg ( feb 2015 ) .",
    "m.  m. baskaran , u.  bondhugula , s.  krishnamoorthy , j.  ramanujam , a.  rountev , p.  sadayappan , a compiler framework for optimization of affine loop nests for gpgpus , in : proceedings of the 22nd annual international conference on supercomputing , ics 08 , 2008 , pp .",
    "225234 .",
    "j.  fang , a.  varbanescu , h.  sips , a comprehensive performance comparison of cuda and opencl , in : parallel processing ( icpp ) , 2011 international conference on , 2011 , pp . 216225 .",
    "r.  vuduc , h .- j . moon , fast sparse matrix - vector multiplication by exploiting variable block structure , in : high performance computing and communications , vol .",
    "3726 of lecture notes in computer science , springer berlin heidelberg , 2005 , pp . 807816 .",
    "r.  w. vuduc , automatic performance tuning of sparse matrix kernels , ph.d .",
    "thesis , university of california , berkeley ( dec 2003 ) .",
    "a.  bulu , j.  t. fineman , m.  frigo , j.  r. gilbert , c.  e. leiserson , parallel sparse matrix - vector and matrix - transpose - vector multiplication using compressed sparse blocks , in : proceedings of the twenty - first annual symposium on parallelism in algorithms and architectures , spaa 09 , 2009 , pp .",
    "233244 .",
    "a.  bulu , s.  williams , l.  oliker , j.  demmel , reduced - bandwidth multithreaded algorithms for sparse matrix - vector multiplication , in : parallel distributed processing symposium ( ipdps ) , 2011 ieee international , 2011 , pp .",
    "721733 .",
    "j.  w. choi , a.  singh , r.  w. vuduc , model - driven autotuning of sparse matrix - vector multiply on gpus , in : proceedings of the 15th acm sigplan symposium on principles and practice of parallel programming , ppopp 10 , 2010 , pp .",
    "115126 .",
    "m.  martone , efficient multithreaded untransposed , transposed or symmetric sparse matrix - vector multiplication with the recursive sparse blocks format , parallel computing 40  ( 7 ) ( 2014 ) 251  270 .",
    "r.  nishtala , r.  vuduc , j.  demmel , k.  yelick , when cache blocking of sparse matrix vector multiply works and why , applicable algebra in engineering , communication and computing 18  ( 3 ) ( 2007 ) 297311 .",
    "j.  c. pichel , f.  f. rivera , m.  fernndez , a.  rodrguez , optimization of sparse matrix - vector multiplication using reordering techniques on gpus , microprocessors and microsystems 36  ( 2 ) ( 2012 ) 65  77 .",
    "m.  m. baskaran , r.  bordawekar , optimizing sparse matrix - vector multiplication on gpus , tech .",
    "rc24704 , ibm ( 2008 ) .",
    "i.  reguly , m.  giles , efficient sparse matrix - vector multiplication on cache - based gpus , in : innovative parallel computing ( inpar ) , 2012 , 2012 , pp . 112 .",
    "n.  zhang , a novel parallel scan for multicore processors and its application in sparse matrix - vector multiplication , parallel and distributed systems , ieee transactions on 23  ( 3 ) ( 2012 ) 397404 .",
    "j.  lee , m.  samadi , y.  park , s.  mahlke , transparent cpu - gpu collaboration for data - parallel kernels on heterogeneous systems , in : proceedings of the 22nd international conference on parallel architectures and compilation techniques , pact 13 , 2013 , pp .",
    "245256 .",
    "r.  kaleem , r.  barik , t.  shpeisman , b.  t. lewis , c.  hu , k.  pingali , adaptive heterogeneous scheduling for integrated gpus , in : proceedings of the 23rd international conference on parallel architectures and compilation , pact 14 , 2014 , pp .",
    "151162 .",
    "j.  shen , j.  fang , a.  l. varbanescu , h.  sips , an application - centric evaluation of opencl on multi - core cpus , parallel computing 39  ( 12 ) ( 2013 ) 834850 .",
    "j.  shen , a.  l. varbanescu , p.  zou , y.  lu , h.  sips , improving performance by matching imbalanced workloads with heterogeneous platforms , in : proceedings of the 28th acm international conference on supercomputing , ics 14 , 2014 , pp . 241250 .",
    "@xmath59 ; _ //positioning row indices of tiles in the thread - bunch _ ` boundary[i ] ` @xmath60 ` tile_offset[i]`@xmath61}}$ ] _ //iterative steps in a thread - bunch _ @xmath62}$ ] @xmath63}$ ] @xmath64 _ //calculating segment descriptor _ @xmath65 - boundary[$i$ ] ] } \\gets \\texttt{true}$ ] @xmath66 _ //collecting element - wise products _ @xmath67+$j$]]}$ ] @xmath68 } \\gets x\\_value\\times \\texttt{value[boundary[$i$]+$j$]}$ ] _ //transmitting a value from the previous tile _ @xmath69 } \\gets \\texttt{product[0 ] } + transmitter$ ] @xmath70 } \\gets \\texttt{true}$ ]"
  ],
  "abstract_text": [
    "<S> sparse matrix - vector multiplication ( spmv ) is a central building block for scientific software and graph applications . recently , heterogeneous processors composed of different types of cores attracted much attention because of their flexible core configuration and high energy efficiency . in this paper </S>",
    "<S> , we propose a compressed sparse row ( csr ) format based spmv algorithm utilizing both types of cores in a cpu - gpu heterogeneous processor . </S>",
    "<S> we first speculatively execute segmented sum operations on the gpu part of a heterogeneous processor and generate a possibly incorrect results . </S>",
    "<S> then the cpu part of the same chip is triggered to re - arrange the predicted partial sums for a correct resulting vector . </S>",
    "<S> on three heterogeneous processors from intel , amd and nvidia , using 20 sparse matrices as a benchmark suite , the experimental results show that our method obtains significant performance improvement over the best existing csr - based spmv algorithms .    </S>",
    "<S> sparse matrices , sparse matrix - vector multiplication , compressed sparse row , speculative execution , segmented sum , heterogeneous processor </S>"
  ]
}