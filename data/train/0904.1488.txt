{
  "article_text": [
    "[ [ the - problem . ] ] * the problem . * + + + + + + + + + + + + + +    lamport s criticism @xcite of the next - time operator @xmath2 in @xmath1/@xmath6 arouse the interest in studying temporal logics like @xmath0/@xmath7 , obtained from @xmath1/@xmath6 by removing the next - time operator , and related notions of behavioral _ stuttering_-based equivalences  @xcite .",
    "we are interested here in _",
    "divergence blind stuttering _ simulation and bisimulation , that we call , respectively , stuttering simulation and bisimulation for short .",
    "we focus here on systems specified as kripke structures ( kss ) , but analogous considerations hold for labeled transition systems ( ltss ) .",
    "let @xmath8 be a ks where @xmath9 is a transition system and @xmath10 is a state labeling function .",
    "a relation @xmath11 is a stuttering simulation on @xmath12 when for any @xmath13 such that @xmath14 : ( 1 ) @xmath15 and @xmath16 have the same labeling by @xmath10 and ( 2 ) if @xmath17 then @xmath18 for some @xmath19 in such a way that the following diagram holds :    = [ ->,>=latex ] ( 6,2 ) node @xmath15 ; ( 7,2 ) node @xmath20 ; ( 8,2.06 ) node @xmath21 ; ( 0,0 ) node @xmath16 ; ( 5,1 ) node @xmath22 ; ( 1,0 ) node @xmath20 ; ( 2,-0.06 ) node @xmath23 ; ( 3,0 ) node @xmath20 ; ( 4,0 ) node @xmath22 ; ( 5,0 ) node @xmath20 ; ( 6,-0.06 ) node @xmath24 ; ( 7,0 ) node @xmath20 ; ( 8,0.03 ) node @xmath19 ; ( 6,1.9 ) node[name=62 ] ( 8,1.9 ) node[name=82 ] ( 0,0.05 ) node[name=00 ] ( 2,0.1 ) node[name=20 ] ( 6,0 ) node[name=60 ] ( 8,0 ) node[name=80 ] ;    \\(62 )  ( 00 ) ; ( 62 )  ( 20 ) ; ( 62 )  ( 60 ) ; ( 82 )  ( 80 ) ;    where a dotted line between two states means that they are related by @xmath25 .",
    "the intuition is that @xmath16 is allowed to simulate a transition @xmath26 possibly through some initial `` stuttering '' transitions ( @xmath27-transitions in case of ltss ) .",
    "@xmath25 is called a stuttering bisimulation when it is symmetric .",
    "it turns out that the largest stuttering simulation @xmath28 and bisimulation @xmath29 relations exist : @xmath28 is a preorder called the _ stuttering simulation preorder _ while @xmath29 is an equivalence relation called the stuttering bisimulation equivalence .",
    "moreover , the preorder @xmath28 induces by symmetric reduction the _ stuttering simulation equivalence _ @xmath30 .",
    "the partition of @xmath31 corresponding to the equivalence @xmath32 is denoted by @xmath33 .",
    "de nicola and vaandrager @xcite showed that for finite kss and for an interpretation of universal / existential path quantifiers over all the , possibly finite , prefixes , the stuttering bisimulation equivalence coincides with the state equivalence induced by the language @xmath0 ( this also holds for @xmath7 ) .",
    "this is not true with the standard interpretation of path quantifiers over infinite paths , since this requires a divergence sensitive notion of stuttering ( see the details in @xcite ) .",
    "groote and vaandrager  @xcite designed a well - known algorithm that computes the stuttering bisimulation equivalence @xmath29 in @xmath34-time and @xmath35-space .    clearly , stuttering simulation equivalence is coarser than stuttering bisimulation , i.e.@xmath36 . as far as language preservation is concerned , it turns out that stuttering simulation equivalence coincides with the state equivalence induced by the language @xmath3 , namely the existiential fragment of @xmath1 without next - time and globally operators @xmath2 and @xmath5 .",
    "thus , on the one hand , stuttering simulation equivalence still preserves a significantly expressive fragment of @xmath1 and , on the other hand , it may provide a significantly better state space reduction than simulation equivalence , and this has been shown to be useful in abstract model checking  @xcite .    [",
    "[ state - of - the - art . ] ] * state of the art . * + + + + + + + + + + + + + + + + + + +    to the best of our knowledge , there exists no algorithm for computing stuttering simulation equivalence or , more in general , the stuttering simulation preorder .",
    "there is instead an algorithm by bulychev et al .",
    "@xcite for _ checking _ stuttering simulation , namely , this procedure checks whether a given relation @xmath11 is a stuttering simulation .",
    "this algorithm formalizes the problem of checking stuttering simulation as a two players game in a straightforward way and then exploits etessami et al.s  @xcite algorithm for solving such a game .",
    "the authors claim that this provides an algorithm for checking stuttering simulation on finite kss that runs in @xmath37 time and space .",
    "[ [ main - contributions . ] ] * main contributions . *",
    "+ + + + + + + + + + + + + + + + + + + + +    in this paper we present an algorithm for computing simultaneously both the simulation preorder @xmath28 and stuttering simulation equivalence @xmath32 for finite kss .",
    "this procedure is incrementally designed in two steps .",
    "we first put forward a basic procedure for computing the stuttering simulation preorder that relies directly on the notion of stuttering simulation . for any state @xmath38",
    ", @xmath39 represents the set of states that are candidate to stuttering simulate @xmath40 so that a family of sets @xmath41 is maintained .",
    "a pair of states @xmath42 is called a refiner for @xmath43 when @xmath44 and there exists @xmath45 that can not stuttering simulate @xmath40 w.r.t .",
    "@xmath46 , i.e. , @xmath47 where @xmath48 is the set of all the states in @xmath49 that may reach a state in @xmath50 through a path of states in @xmath49 .",
    "hence , any such @xmath51 can be correctly removed from @xmath49 .",
    "actually , it turns out that one such refiner @xmath52 allows to refine @xmath43 to @xmath53 as follows : if @xmath54 then @xmath55 thus , our basic algorithm consists in initializing @xmath41 as @xmath56 and then iteratively refining @xmath43 until a refiner exists .",
    "this provides an _ explicit _ stuttering simulation algorithm , meaning that this procedure requires that for any explicit state @xmath38 , @xmath49 is explicitly represented as a set of states .    inspired by techniques used in algorithms that compute standard simulation preorders and equivalences ( cf .",
    "henzinger et al .",
    "@xcite and ranzato and tapparo  @xcite ) and in abstract interpretation - based algorithms for computing strongly preserving abstract models  @xcite , our stuttering simulation algorithm @xmath57 is obtained by the above basic procedure by exploiting the following two main ideas .    * the above explicit algorithm is made `` symbolic '' by representing the family of sets of states @xmath58 as a family of sets of blocks of a partition @xmath59 of the state space @xmath31 .",
    "more precisely , we maintain a partition @xmath59 of @xmath31 together with a binary relation @xmath60    a so - called partition - relation pair    so that : ( i )  two states @xmath40 and @xmath46 in the same block of @xmath59 are candidate to be stuttering simulation equivalent and ( ii )  if @xmath61 and @xmath62 are two blocks of @xmath59 and @xmath63 then any state in @xmath62 is candidate to stuttering simulate each state in @xmath61 .",
    "therefore , here , for any @xmath38 , if @xmath64 is the block of @xmath59 that contains @xmath40 then @xmath65 . * in this setting , a refiner of the current partition - relation @xmath66 is a pair of blocks @xmath67 such that @xmath68 and @xmath69 , where @xmath70 is the existential transition relation between blocks of @xmath59 , i.e. , @xmath68 iff there exist @xmath71 and @xmath72 such that @xmath44 .",
    "we devise an efficient way for finding a refiner of the current partition - relation pair that allows us to check whether a given preorder @xmath25 is a stuttering simulation in @xmath73 time and @xmath74 space , where @xmath59 is the partition corresponding to the equivalence @xmath75 .",
    "hence , this algorithm for checking stuttering simulation already significantly improves both in time and space bulychev et al.s  @xcite procedure .",
    "our algorithm @xmath57 iteratively refines the current partition - relation pair @xmath66 by first splitting the partition @xmath59 and then by pruning the relation @xmath76 until a fixpoint is reached . hence , @xmath57 outputs a partition - relation pair where @xmath77 and @xmath46 stuttering simulates @xmath40 iff @xmath78 , where @xmath79 and @xmath80 are the blocks of @xmath59 that contain , respectively , @xmath40 and @xmath46 .",
    "as far as complexity is concerned , it turns out that @xmath57 runs in @xmath81 space .",
    "it is worth remarking that stuttering simulation yields a rather coarse equivalence so that @xmath82 should be in general much less than the size @xmath83 of the concrete state space .",
    "[ [ notation . ] ] * notation . * + + + + + + + + + + +    if @xmath11 is any relation and @xmath38 then @xmath84 .",
    "let us recall that @xmath25 is called a preorder when it is reflexive and transitive .",
    "if @xmath85 is a function defined on @xmath86 and @xmath38 then we often write @xmath87 to mean @xmath88 .",
    "a partition @xmath59 of a set @xmath31 is a set of nonempty subsets of @xmath31 , called blocks , that are pairwise disjoint and whose union gives @xmath31 .",
    "@xmath89 denotes the set of partitions of @xmath31 . if @xmath90 and @xmath91 then @xmath92 denotes the block of @xmath59 that contains @xmath15 .",
    "@xmath89 is endowed with the following standard partial order @xmath93 : @xmath94 , i.e.  @xmath95 is coarser than @xmath96 , iff @xmath97 . for a given nonempty subset @xmath98 called splitter ,",
    "we denote by @xmath99 the partition obtained from @xmath59 by replacing each block @xmath100 with the nonempty sets @xmath101 and @xmath102 , where we also allow no splitting , namely @xmath103 ( this happens exactly when @xmath104 is a union of some blocks of @xmath59 ) .",
    "if @xmath105 then we denote by @xmath106 ( or simply by @xmath107 ) the unique block in @xmath59 that contains @xmath61 ( this may possibly be @xmath61 itself ) .",
    "+ a transition system @xmath108 consists of a set @xmath31 of states and a transition relation @xmath109 .",
    "the predecessor transformer @xmath110 is defined as usual : @xmath111 .",
    "if @xmath112 then @xmath113 iff there exist @xmath114 and @xmath115 such that @xmath116 .",
    "given a set @xmath117 of atomic propositions ( of some specification language ) , a kripke structure ( ks ) @xmath118 over @xmath117 consists of a transition system @xmath108 together with a state labeling function @xmath119 .",
    "@xmath120 denotes the state partition induced by @xmath10 , namely , @xmath121 .",
    "[ [ stuttering - simulation . ] ] * stuttering simulation . *",
    "+ + + + + + + + + + + + + + + + + + + + + + + +    let @xmath118 be a ks . a relation @xmath122 is a _ divergence blind stuttering simulation _ on @xmath12 if for any @xmath13 such that @xmath14 :    * @xmath123 ; * if @xmath17 then there exist @xmath124 , with @xmath125 , such that : ( i ) @xmath126 ; ( ii ) for all @xmath127 , @xmath128 and @xmath129 ; ( iii ) @xmath130 .    observe that condition  ( 2 ) allows the case @xmath131 and this boils down to requiring that @xmath132 . with a slight abuse of terminology , @xmath25 is called simply a _ stuttering simulation_. if @xmath14",
    "then we say that @xmath16 stuttering simulates @xmath15 and we denote this by @xmath133 . if @xmath25 is a symmetric relation then it is called a stuttering bisimulation .",
    "the empty relation is a stuttering simulation and stuttering simulations are closed under union so that the largest stuttering simulation relation exists .",
    "it turns out that the largest simulation is a preorder relation called _ stuttering simulation preorder _ ( on @xmath12 ) and denoted by @xmath28 .",
    "thus , for any @xmath134 , @xmath135 iff @xmath136 . _",
    "stuttering simulation equivalence _",
    "@xmath32 is the symmetric reduction of @xmath28 , namely @xmath137 , so that @xmath138 iff @xmath139 and @xmath140 .",
    "@xmath141 denotes the partition corresponding to the equivalence @xmath32 and is called stuttering simulation partition .",
    "+ following groote and vaandrager  @xcite , @xmath142 is defined as : @xmath143\\end{gathered}\\ ] ] so that a relation @xmath144 is a stuttering simulation iff for any @xmath145 , @xmath146 and if @xmath44 then @xmath147 .",
    "+ it turns out @xcite that @xmath33 is the coarsest partition preserved by the temporal language @xmath3 .",
    "more precisely , @xmath3 is inductively defined as follows : @xmath148 and its semantics is standard : @xmath149 and @xmath150 .",
    "the coarsest partition preserved by @xmath3 is the state partition corresponding to the following equivalence @xmath151 between states : for any @xmath134 , @xmath152",
    "for each state @xmath38 , the algorithm @xmath153 in figure  [ algouno ] computes the stuttering simulator set @xmath39 , i.e. , the set of states that stuttering simulate @xmath40 .",
    "the basic idea is that @xmath49 contains states that are candidate for stuttering simulating @xmath40 .",
    "thus , the input partition of @xmath153 is taken as the partition @xmath154 determined by the labeling @xmath10 so that @xmath49 is initialized with @xmath155 , i.e. , with all the states that have the same labeling of @xmath40 . following the definition of stuttering simulation ,",
    "a refiner is a pair of states @xmath52 such that @xmath156 and @xmath157 .",
    "in fact , if @xmath158 then @xmath51 can not stuttering simulate @xmath40 and therefore can be correctly removed from @xmath49 .",
    "conversely , if no such refiner exists then for any @xmath145 such that @xmath44 we have that @xmath159 so that any @xmath45 actually stuttering simulates @xmath40 . hence , @xmath153 consists in iteratively refining @xmath41 as long as a refiner exists , where , given a refiner @xmath52 , the refinement of @xmath43 by means of @xmath54 is as follows : @xmath160 it turns out that this procedure correctly computes the stuttering simulation preorder .",
    "[ basicssa ] @xmath153 is correct , i.e. , if @xmath43 is the output of @xmath153 on input @xmath154 then for any @xmath145 , @xmath161 .",
    "a _ partition - relation pair _ @xmath66 , pr for short , is given by a partition @xmath90 together with a binary relation @xmath162 between blocks of @xmath59 .",
    "we write @xmath163 when @xmath63 and @xmath164 and @xmath165 when @xmath166 and @xmath167 .",
    "our stuttering simulation algorithm relies on the idea of symbolizing the @xmath153 procedure in order to maintain a pr @xmath66 in place of the family of explicit sets of states @xmath168 . as a first step",
    ", @xmath169 induces a partition @xmath59 that corresponds to the following equivalence @xmath170 : @xmath171 hence , the intuition is that if @xmath172 then @xmath173 and @xmath174 are `` currently '' candidates to be stuttering simulation equivalent .",
    "accordingly , a relation @xmath76 on @xmath59 encodes stuttering simulation as follows : if @xmath91 then @xmath175 . here , the intuition is that if @xmath63 then any state @xmath176 is `` currently '' candidate to stuttering simulate any state @xmath177 .",
    "equivalently , the following invariant property is maintained : if @xmath133 then @xmath178 .",
    "thus , a pr @xmath66 will represent the current approximation of the stuttering simulation preorder and in particular @xmath59 will represent the current approximation of stuttering simulation equivalence .",
    "more precisely , a pr @xmath179 induces the following map @xmath180 : for any @xmath181 , @xmath182 note that , for any @xmath91 , @xmath183 , that is , @xmath184 represents the set of states that are currently candidates to stuttering simulate @xmath15 .",
    "a pr @xmath185 is therefore defined to be a stuttering simulation for a ks @xmath12 when the relation @xmath186 is a stuttering simulation on @xmath12 .",
    "recall that in @xmath153 a pair of states @xmath187 is a refiner for @xmath43 when @xmath188 and @xmath189 .",
    "accordingly , a pair of blocks @xmath67 is called a refiner for @xmath190 when @xmath68 and @xmath191 .",
    "thus , by defining @xmath192 the following characterization holds :    [ st - char2 ] @xmath193 is a stuttering simulation iff @xmath194 and for any @xmath91 , @xmath195 .",
    "the algorithm @xmath153 is therefore made symbolic as follows :    * @xmath196 is the input pr , where @xmath197 ; * find @xmath198 ; if @xmath194 exit ; * compute @xmath199 ; * @xmath200 , where @xmath201 and @xmath202 is modified in such a way that for any @xmath91 , @xmath203 ; * @xmath204 , where @xmath202 is modified to @xmath205 in such a way that for any @xmath206 : @xmath207 * @xmath208 and go to ( 2 ) .",
    "@xmath209    this leads to the symbolic algorithm @xmath57 described in figure  [ fig - ssa ] , where : the input pr @xmath210 at line  1 is @xmath196 of point  ( 1 ) ; point  ( 2 ) corresponds to the call @xmath211 at line  3 ; point  ( 3 ) corresponds to lines  4 - 5 ; point  ( 4 ) corresponds to the call @xmath212 at line  6 ; point  ( 5 ) corresponds to the call @xmath213 at line  7 .",
    "the following graphical example shows how points  ( 4 ) and  ( 5 ) refine a pr @xmath214,[2,3],[4,5],[6,7],[8,9]\\},{\\trianglelefteq}}$ ] w.r.t .",
    "the set @xmath215 , where if @xmath216 then @xmath61 is drawed below @xmath62 while if @xmath163 and @xmath217 then @xmath61 and @xmath62 are at same height and connected by a double line .",
    "= [ ->,>=latex ] ( 0,0 ) node[shape = rectangle , draw , name=01]0  1 ( 0,1.5 ) node[shape = rectangle , draw , name=23]2  3 ( 1.5,0 ) node[shape = rectangle , draw , name=45]4  5 ( 1.5,1.5 ) node[shape = rectangle , draw , name=67]6  7 ( 3,0 ) node[shape = rectangle , draw , name=89]8  9 ( 0.45,2.4 ) node[]@xmath104 ;    \\(01 )  ( 23 ) ; ( 01 )  ( 67 ) ; ( 45 )  ( 67 ) ; ( 89 )  ( 67 ) ;    ( 4.2,1.5 ) node[]@xmath218 ;    ( 6.1,0 ) node[shape = rectangle , draw , name=01m]0  1 ( 5.55,1.5 ) node[shape = rectangle , draw , name=2m]2 ( 6.65,1.5 ) node[shape = rectangle , draw , name=3m]3 ( 10.65,0 ) node[shape = rectangle , draw , name=9m]9 ( 9.55,0 ) node[shape = rectangle , draw , name=8m]8 ( 8.1,1.5 ) node[shape = rectangle , draw , name=67m]6  7 ( 8.1,0 ) node[shape = rectangle , draw , name=45m]4  5 ;    ( 01 m )  ( 2 m ) ; ( 01 m )  ( 3 m ) ; ( 2 m ) to ( 3 m ) ; ( 01 m )  ( 67 m ) ; ( 45 m )  ( 67 m ) ; ( 8 m ) ",
    "( 67 m ) ; ( 9 m ) ",
    "( 67 m ) ; ( 8 m ) ",
    "( 9 m ) ;    ( 11.5,1.5 ) node[]@xmath219 ;    ( 13,0 ) node[shape = rectangle , draw , name=01n]0  1 ( 13,1.5 ) node[shape = rectangle , draw , name=2n]2 ( 13,3 ) node[shape = rectangle , draw , name=3n]3 ( 15.75,0 ) node[shape = rectangle , draw , name=9n]9 ( 15.75,1.5 ) node[shape = rectangle , draw , name=8n]8 ( 14.5,3 ) node[shape = rectangle , draw , name=67n]6  7 ( 14.5,0 ) node[shape = rectangle , draw , name=45n]4  5 ;    ( 01n ) ",
    "( 2n ) ; ( 01n ) ",
    "( 67n ) ; ( 2n ) ",
    "( 3n ) ; ( 9n ) ",
    "( 8n ) ; ( 8n )  ( 67n ) ; ( 45n ) ",
    "( 67n ) ;    ( 0.1,0.5 ) ",
    "( 0.1,2 )  ( 0.7,2 ) ",
    "( 0.7,0.73 ) ",
    "( 3,0.73 ) ",
    "( 3,-0.6 )  ( 0.8,-0.6 )  ( 0.8,0.5 ) ",
    "( 0.1,0.5 ) ;    the correctness of this symbolic algorithm goes as follows .",
    "[ correctness ] @xmath57 is a correct implementation of @xmath153 , i.e. , if @xmath43 is the output function of @xmath153 on input @xmath154 and @xmath220 is the output pr of @xmath57 on input @xmath196 then for any @xmath38 , @xmath221 .",
    "the next step consists in devising an efficient implementation of @xmath57 .",
    "while it is not too hard to devise an efficient implementation of lines  2 and 4 - 7 of the @xmath57 algorithm , it is instead not straightforward to find a refiner in an efficient way . in groote and vaandrager s",
    "@xcite algorithm for computing stuttering bisimulations the key point for efficiently finding a refiner in their setting is the notion of _ bottom state_. given a set of states @xmath98 , a bottom state of @xmath104 is a state @xmath222 that can not go inside @xmath104 , i.e. , @xmath15 can only go outside @xmath104 ( note that @xmath15 may also have no outgoing transition ) . for any @xmath223 ,",
    "we therefore define : @xmath224    bottom states allow to efficiently find refiners in kss that do not contain cycles of states all having the same labeling .",
    "following groote and vaandrager  @xcite , a transition @xmath188 is called _ inert _ for a partition @xmath90 when @xmath225 . clearly , if a set of states @xmath104 in a ks @xmath12 is strongly connected via inert transitions for the labeling partition @xmath154 then all the states in @xmath104 are stuttering simulation equivalent , i.e. , if @xmath226 then @xmath227 .",
    "thus , each strongly connected component ( s.c.c . ) @xmath104 with respect to inert transitions for @xmath154 , called _ inert s.c.c .",
    "_ , can be collapsed to one single `` symbolic state '' .",
    "in particular , if @xmath228 is one such inert s.c.c .",
    ", i.e.  @xmath229 , then this collapse simply removes the transition @xmath229 .",
    "it is important to remark that a standard depth - first search algorithm by tarjan @xcite , running in @xmath230 time , allows us to find and then collapse all the inert s.c.c.s in the input ks .",
    "we can thus assume w.l.o.g .",
    "that the ks @xmath12 does not contain inert s.c.c.s .",
    "the following characterization of refiners therefore holds .",
    "[ l2 ] assume that @xmath12 does not contain inert s.c.c.s .",
    "let @xmath179 be a pr such that for any @xmath100 , @xmath231 .",
    "consider @xmath67 such that @xmath68 . then , @xmath198 iff @xmath232 .",
    "if @xmath100 is any block then we define as _ local bottom states _ of @xmath61 all the bottom states of @xmath233 that belong to @xmath61 , namely @xmath234 also , we define @xmath235 as a _ bottom block _ for @xmath61 when @xmath62 contains at least a bottom state of @xmath233 and @xmath216 , that is : @xmath236 local bottoms and bottom blocks characterize refiners for stuttering simulation as follows :    [ th - refiner ] assume that @xmath12 does not contain inert s.c.c.s .",
    "let @xmath179 be a pr such that @xmath76 is a preorder and for any @xmath100 , @xmath231 .",
    "consider @xmath67 such that @xmath68 and for any @xmath237 such that @xmath238 and @xmath239 , @xmath240 .",
    "then , @xmath198 iff at least one of the following two conditions holds :    1 .",
    "@xmath241 and @xmath242 ; 2 .",
    "there exists @xmath243 such that @xmath244 and @xmath245 .",
    "we will show that this characterization provides the basis for an algorithm that efficiently finds refiners .",
    "hence , this procedure also checks whether a given preorder @xmath25 is a stuttering simulation .",
    "this can be done in @xmath73 time and @xmath246 space , where @xmath59 is the partition corresponding to the equivalence @xmath75 .",
    "thus , this algorithm for checking stuttering simulation already significantly improves bulychev et al.s  @xcite procedure that runs in @xmath37 time and space .",
    "@xmath57 is implemented by exploiting the following data structures .    * a state @xmath15",
    "is represented by a record that contains the list @xmath15.pre of its predecessors @xmath247 and a pointer @xmath15.block to the block @xmath92 that contains @xmath15 .",
    "the state space @xmath31 is represented as a doubly linked list of states . *",
    "the states of any block @xmath61 of the current partition @xmath59 are consecutive in the list @xmath31 , so that @xmath61 is represented by two pointers begin and end : the first state of @xmath61 in @xmath31 and the successor of the last state of @xmath61 in @xmath31 , i.e. , @xmath248 .",
    "moreover , @xmath61 contains a pointer @xmath61.intersection to a block whose meaning is as follows : after a call to @xmath249 for splitting @xmath59 w.r.t .  a set of states @xmath104 , if @xmath250 then @xmath61.intersection points to a block that represents @xmath101 , otherwise @xmath61.intersection @xmath251 . finally , the fields localbottoms and bottomblocks for a block @xmath61 represent , resp . , the local bottom states of @xmath61 and the bottom blocks of @xmath61 .",
    "the current partition @xmath59 is stored as a doubly linked list of blocks .",
    "* the current relation @xmath76 on @xmath59 is stored as a resizable @xmath252 boolean matrix @xmath253 : @xmath254 iff @xmath63 .",
    "recall ( * ? ? ?",
    "* section  17.4 ) that insert operations in a resizable array ( whose capacity is doubled as needed ) take amortized constant time , and a resizable matrix ( or table ) can be implemented as a resizable array of resizable arrays .",
    "the boolean matrix @xmath253 is resized by adding a new entry to @xmath253 , namely a new row and a new column , for any block @xmath61 that is split into two new blocks @xmath255 and @xmath101 .",
    "* @xmath57 additionally stores and maintains a resizable integer table count and a resizable integer matrix bcount .",
    "count is indexed over @xmath31 and @xmath59 and has the following meaning : @xmath256 while bcount is indexed over @xmath257 and has the following meaning : @xmath258 .",
    "the table count allows to implement the test @xmath259 in constant time as @xmath260 , while bcount allows to implement in constant time the test @xmath261 as @xmath262 .",
    "the list @xmath59 is stored in reverse topological ordering wrt @xmath253    @xmath263    refiner  ( , )      the algorithm @xmath211 in figure  [ fig - refiner ] is an implementation of the characterization of refiners provided by theorem  [ th - refiner ] .",
    "in particular , lines  8 - 10 implement condition  ( i ) of theorem  [ th - refiner ] and lines  11 - 12 implement condition  ( ii ) .",
    "the correctness of this implementation depends on the following key point .",
    "given a pair of blocks @xmath67 such that @xmath68 , in order to ensure the equivalence : @xmath198 iff @xmath265 , theorem  [ th - refiner ] requires as hypothesis the following condition : @xmath266 in order to ensure this condition @xmath267 , we guarantee throughout the execution of @xmath57 that the list @xmath59 of blocks is stored in reverse topological ordering w.r.t .",
    "@xmath76 , so that if @xmath268 then @xmath269 precedes @xmath61 in the list @xmath59 .",
    "the reverse topological ordering of @xmath59 initially holds because the input pr is the dag @xmath196 which is trivially topologically ordered ( whatever the ordering of @xmath154 is ) .",
    "more in general , for a generic input pr @xmath210 to @xmath57 the function @xmath270 in figure  [ fig-2 ] in appendix  [ app ] achieves this reverse topological ordering by a standard algorithm ( * ? ? ?",
    "* section  22.4 ) that runs in @xmath271 time ( cf.the call @xmath272 in the @xmath270 function ) .",
    "then , the reverse topological ordering of @xmath59 is always maintained throughout the execution of @xmath57 .",
    "in fact , if the partition @xmath59 is split w.r.t .  a set @xmath104 and a block @xmath61 generates two new descendant blocks @xmath101 and",
    "@xmath102 then our @xmath273 in figure  [ fig - sp ] modifies the ordering of the list @xmath59 as follows : @xmath61 is replaced in @xmath59 by inserting @xmath101 immediately followed by @xmath274 .",
    "this guarantees that at the exit of @xmath213 at line  7 of @xmath57 the list @xmath59 is still in reverse topological ordering w.r.t.@xmath253 .",
    "this is a consequence of the fact that at the exit of @xmath213 , by point  ( 5 ) in section  [ asa ] , we have that @xmath275 , i.e. , @xmath276 so that @xmath277 .",
    "the reverse topological ordering of @xmath59 w.r.t .",
    "@xmath76 ensures that if @xmath278 then @xmath279 is scanned by @xmath264 after the pair @xmath280 . since @xmath211 exits as soon as a refiner is found , we have that @xmath280 can not be a refiner , so that condition @xmath267 holds for @xmath279 .",
    "+ when @xmath211 determines that a pair of blocks @xmath279 , with @xmath68 , is not a refiner , it stores this information in a local boolean matrix refiner that is indexed over @xmath257 and initialized to @xmath281 .",
    "thus , the meaning of the matrix refiner is as follows : if @xmath282 then @xmath283 . if @xmath284 then both ( i ) and ( ii ) do not hold , therefore @xmath211 executes the for - loop at lines  13 - 14 so that any @xmath285 with @xmath286 is marked as @xmath287 .",
    "this is correct because if @xmath283 and @xmath288 then @xmath289 : in fact , by lemma  [ l2 ] , @xmath290 , and since @xmath286 implies , because @xmath76 is transitive , @xmath291 , we have that @xmath292 , so that , by lemma  [ l2 ] , @xmath289 . the for - loop at lines",
    "13 - 14 is therefore an optimization of theorem  [ th - refiner ] since it determines that some pairs of blocks are not a refiner without resorting to the condition @xmath293 of theorem  [ th - refiner ] .",
    "this optimization and the related matrix refiner turn out to be crucial for obtaining the overall time complexity of @xmath57 .",
    "@xmath294    @xmath295 ( @xmath104 , @xmath296 ) \\ {",
    "@xmath297    @xmath25      given two lists of states @xmath104 and @xmath296 , we want to compute the set of states that belong to @xmath298 .",
    "this can be done by traversing once the edges of the transition relation @xmath20 provided that the list @xmath31 of states satisfies the following property :    for all @xmath145 , if @xmath40 precedes @xmath46 in the list @xmath31 and @xmath299 then @xmath300 .",
    "we denote this property by @xmath301 .",
    "hence , this is a topological ordering of @xmath31 w.r.t .",
    "the transition relation @xmath20 that is local to each block of the labeling partition @xmath154 .",
    "as described in section  [ sec : bs ] , as an initial pre - processing step of @xmath57 , we find and collapse inert s.s.c.s .",
    "after this pre - processing step , @xmath31 is then topologically ordered locally to each block of @xmath154 in @xmath302 time in order to establish initially @xmath301 .",
    "we will see in section  [ sec - sp ] that while the ordering of the list @xmath31 of states changes across the execution of @xmath57 , the property @xmath301 is always maintained invariant .",
    "the computation of @xmath298 is done by the algorithm in figure  [ fig - eu ] .",
    "the result @xmath25 consists of all the states in @xmath104 that are marked2 .",
    "we assume that all the states in @xmath104 have the same labeling by @xmath10 : this is clearly true when the function @xmath295 is called from the algorithm @xmath57 .",
    "the for - loop at lines  5 - 7 makes the states in @xmath303 marked2 .",
    "then , the for - loop at lines  8 - 10 scans backward the list of states @xmath104 and when a marked2 state @xmath46 is encountered then all the states in @xmath304 are marked2 .",
    "it is clear that the property @xmath301 guarantees that this procedure does not miss states that are in @xmath298 .",
    "split    split       split @xmath305      @xmath57 calls @xmath212 at line  6 with the precondition @xmath301 and needs to maintain this invariant property at the exit ( as discussed in section  [ euc ] this is crucial for computing @xmath295 ) .",
    "this function must modify the current pr @xmath220 to @xmath306 as follows :    * @xmath307 is the partition obtained by splitting @xmath59 w.r.t .",
    "the splitter @xmath104 ; * @xmath253 is modified to @xmath308 in such a way that for any @xmath38 , @xmath309 .",
    "recall that the states of a block @xmath61 of @xmath59 are consecutive in the list @xmath31 , so that @xmath61 is represented as @xmath248 .",
    "an implementation of the splitting operation @xmath310 that only scans the states in @xmath104 , i.e.  that takes @xmath311 time , is quite easy and standard ( see e.g.@xcite ) .",
    "however , this operation affects the ordering of the states in the list @xmath31 because states are moved from old blocks to newly generated blocks .",
    "it turns out that this splitting operation can be implemented in a careful way that preserves the invariant property @xmath312 .",
    "the idea is rather simple .",
    "observe that the list of states @xmath313 can be ( and actually is ) built as a sublist of @xmath31 so that the following property holds : if @xmath40 precedes @xmath46 in @xmath104 and @xmath314 then @xmath315 .",
    "the following picture shows the idea of our implementation of @xmath310 , where states within filled circles determine the splitter set @xmath104 .",
    "= [ ->,>=latex ] ( -0.75,2 ) node @xmath31 ; ( -0.75,0 ) node @xmath316 ; ( 0.5,2.7 ) node @xmath317 ; ( 4.5,2.7 ) node @xmath318 ; ( 8.5,2.7 ) node @xmath319 ; ( 4.5,1 ) node @xmath310 ; ( -0.1,-0.7 ) node @xmath320 ; ( 1,-0.7 ) node @xmath321 ; ( 3,-0.7 ) node @xmath322 ; ( 6,-0.7 ) node @xmath323 ; ( 8,-0.7 ) node @xmath324 ; ( 9.1,-0.7 ) node @xmath325 ;    ( 0,2 ) node[shape = circle , draw , name=0]0 ( 1,2 ) node[shape = circle , fill = blue!25,draw , name=1]1 ( 2,2 ) node[shape = circle , draw , name=2]2 ( 3,2 ) node[shape = circle , fill = blue!25,draw , name=3]3 ( 4,2 ) node[shape = circle , fill = blue!25,draw , name=4]4 ( 5,2 ) node[shape = circle , draw , name=5]5 ( 6,2 ) node[shape = circle , fill = blue!25,draw , name=6]6 ( 7,2 ) node[shape = circle , draw , name=7]7 ( 8,2 ) node[shape = circle , fill = blue!25,draw , name=8]8 ( 9,2 ) node[shape = circle , draw , name=9]9 ; ( 0,0 ) node[shape = circle , fill = blue!25,draw , name=00]1 ( 1,0 ) node[shape = circle , draw , name=11]0 ( 2,0 ) node[shape = circle , fill = blue!25,draw , name=22]3 ( 3,0 ) node[shape = circle , fill = blue!25,draw , name=33]4 ( 4,0 ) node[shape = circle , fill = blue!25,draw , name=44]6 ( 5,0 ) node[shape = circle , draw , name=55]2 ( 6,0 ) node[shape = circle , draw , name=66]5 ( 7,0 ) node[shape = circle , draw , name=77]7 ( 8,0 ) node[shape = circle , fill = blue!25,draw , name=88]8 ( 9,0 ) node[shape = circle , draw , name=99]9 ;    ( 0.north west ) + + ( -0.18,0.18 ) node[name = b1a ] ( 1.south east ) + + ( 0.18,-0.18 ) node[name = b1b ] ; ( 2.north west ) + + ( -0.18,0.18 ) node[name = b2a ] ( 7.south east ) + + ( 0.18,-0.18 ) node[name = b2b ] ; ( 8.north west ) + + ( -0.18,0.18 ) node[name = b3a ] ( 9.south east ) + + ( 0.15,-0.15 ) node[name = b3b ] ;    ( b1a ) rectangle ( b1b ) ; ( b2a ) rectangle ( b2b ) ; ( b3a ) rectangle ( b3b ) ;    ( 00.north west ) + + ( -0.18,0.18 ) node[name = c1a ] ( 00.south east ) + + ( 0.18,-0.18 ) node[name = c1b ] ; ( 11.north west ) + + ( -0.18,0.18 ) node[name = c2a ] ( 11.south east ) + + ( 0.18,-0.18 ) node[name = c2b ] ; ( 22.north west ) + + ( -0.18,0.18 ) node[name = c3a ] ( 44.south east ) + + ( 0.18,-0.18 ) node[name = c3b ] ; ( 55.north west ) + + ( -0.18,0.18 ) node[name = c4a ] ( 77.south east ) + + ( 0.18,-0.18 ) node[name = c4b ] ; ( 88.north west ) + + ( -0.18,0.18 ) node[name = c5a ] ( 88.south east ) + + ( 0.18,-0.18 ) node[name = c5b ] ; ( 99.north west ) + + ( -0.18,0.18 ) node[name = c6a ] ( 99.south east ) + + ( 0.18,-0.18 ) node[name = c6b ] ;    ( c1a ) rectangle ( c1b ) ; ( c2a ) rectangle ( c2b ) ; ( c3a ) rectangle ( c3b ) ; ( c4a ) rectangle ( c4b ) ; ( c5a ) rectangle ( c5b ) ; ( c6a ) rectangle ( c6b ) ;    the property @xmath326 still holds for the modified list of states @xmath316 .",
    "in fact , from the above picture observe that it is enough to check that : if @xmath61 has been split into @xmath101 and @xmath102 by preserving the relative orders of the states in @xmath31 then if @xmath327 and @xmath328 then @xmath315 .",
    "this is true because if @xmath329 and @xmath330 then , since @xmath40 and @xmath46 are in the same block of @xmath59 and @xmath331 is a union of some blocks of @xmath59 , by definition of @xmath295 we would also have that @xmath332 , which is a contradiction .",
    "the functions in figure  [ fig - sp ] sketch a pseudo - code that implements the above described splitting operation ( the @xmath333 function is in figure  [ fig - bis ] in appendix  [ app ] ) . the above point  ( b ) , i.e. , the modification of @xmath253 to @xmath308 so that for any @xmath38 , @xmath309 is straightforward and is implemented at lines  18 - 20 of @xmath334 .",
    "@xmath335 }      @xmath57 calls @xmath213 at line  7 with the precondition that @xmath104 is a union of blocks of the current partition @xmath59 .",
    "the function @xmath213 in figure  [ fig - ref ] implements the point  ( 5 ) of section  [ asa ] .",
    "this function must modify the current pr @xmath337 to @xmath338 by pruning the relation @xmath253 in such a way that for any @xmath100 : @xmath339 this is done by the @xmath340 function at lines  5 - 7 by reducing the relation @xmath253 to @xmath308 as follows : if @xmath341 and @xmath342 then @xmath343 iff @xmath344 and @xmath345 , while the rest of the code updates the data structures count , bcount and bottomblocks accordingly ( note that localbottoms do not need to be updated ) .",
    "it is straightforward to implement the remaining functions @xmath270 and @xmath346 ( these are given in figure  [ fig-2 ] in appendix  [ app ] ) .",
    "it is just worth remarking that in @xmath270 , @xmath347 establishes initially the property @xmath301 , while the call @xmath272 provides an initial reverse topological order of @xmath59 w.r.t .",
    "@xmath253 when the input partial ordering @xmath253 is not the identity relation @xmath348 .",
    "time and space bounds for @xmath57 are as follows . in the following statement we assume , as usual in model checking , that the transition relation @xmath20 is total , i.e. , for any @xmath91 there exists @xmath349 such that @xmath188 , so that the inequalities @xmath350 and @xmath351 hold and this allows us to simplify the expression of the time bound .    [ th - complexity ] @xmath57 runs in @xmath352-time and @xmath353-space .",
    "the algorithms @xmath57 computes the stuttering simulation preorder on kss , but it can be modified to work over ltss by following the adaptation to ltss of groote and vaandrager s algorithm  @xcite for kss . due to lack of space",
    "the details are here omitted .",
    "we just mention that for any action @xmath354 , we have a parametric @xmath355 operator for any action @xmath354 so that the notions of splitting and refinement of the current pr are parameterized w.r.t .  the action @xmath356 .",
    "we presented an algorithm , called @xmath57 , for computing the stuttering simulation preorder and equivalence on a kripke structure or labeled transition system . to the best of our knowledge ,",
    "this is the first algorithm for computing this behavioural preorder .",
    "the only available algorithm related to stuttering simulation is a procedure by bulychev et al .  @xcite that checks whether a given relation is a stuttering simulation .",
    "our procedure @xmath57 includes an algorithm for checking whether a given relation is a stuttering simulation that significantly improves bulychev et al.s one both in time and in space .",
    "[ [ acknowledgements . ] ] * acknowledgements .",
    "* + + + + + + + + + + + + + + + + + + +    this work was partially supported by the prin 2007 project `` _ _ aida2007 : abstract interpretation design and applications _ _ '' and by the university of padova under the projects `` _ _ formal methods for specifying and verifying behavioural properties of software systems _ _ '' and `` _ _ analysis , verification and abstract interpretation of models for concurrency _ _ '' .    99    m.c .",
    "browne , e.m .",
    "clarke and o.  grumberg . characterizing finite kripke structures in propositional temporal logic .",
    "_ theor .  comp .",
    "_ , 59:115 - 131 , 1988 .",
    "bulychev , i.v .",
    "konnov and v.a .",
    "computing ( bi)simulation relations preserving @xmath7 for ordinary and fair kripke structures . _ mathemathical methods and algorithms _ , institute for system programming , russian academy of sciences , vol .  12 , 2007 .",
    "available from http://lvk.cs.msu.su/@xmath151peterbul .",
    "cormen , c.e .",
    "leiserson , r.l .",
    "rivest and c.  stein .",
    "_ introduction to algorithms_. the mit press and mcgraw - hill , 2nd ed . , 2001 .",
    "r.  de nicola and f.  vaandrager .",
    "three logics for branching bisimulation .",
    "_ j.  acm _ , 42(2):458487 , 1995    k.  etessami , t.  wilke , r.a",
    ".  schuller .",
    "fair simulation relations , parity games , and state space reduction for buchi automata .",
    "_ siam j.   comput .",
    "_ , 34(5):1159 - 1175 , 2001 .",
    "groote and f.  vaandrager .",
    "an efficient algorithm for branching bisimulation and stuttering equivalence . in _ proc .",
    "17@xmath357 icalp _ , lncs  443 , pp .  626 - 638 , springer , 1990 .",
    "henzinger , t.a .",
    "henzinger and p.w .",
    "computing simulations on finite and infinite graphs . in _ proc .",
    "36@xmath357 focs _ , 453 - 462 , 1995 .",
    "l.  lamport .",
    "what good is temporal logic ?",
    "in _ information processing 83 _ , pp .  657 - 668 , ifip , 1983 .",
    "p.  manolios .",
    "_ mechanical verification of reactive systems_. phd thesis , university of texas at austin , 2001 .",
    "s.  nejati , a.  gurfinkel and m.  chechik .",
    "stuttering abstraction for model checking . in",
    "_ 3@xmath358 ieee int .  conf . on software engineering and formal methods ( sefm05 )",
    "_ , pp .  311 - 320 , 2005    f.  ranzato and f.  tapparo . a new efficient simulation equivalence algorithm . in _ proc",
    "22@xmath359 ieee symp .  on logic in computer science ( lics07 )",
    "_ , pp .  171180 , ieee press , 2007 .",
    "f.  ranzato and f.  tapparo .",
    "generalized strong preservation by abstract interpretation .",
    "_ j.  logic and computation _ , 17(1):157 - 197 , 2007 .",
    "[ sitrans ] at the beginning of any iteration of @xmath153 , @xmath43 is a preorder .",
    "initially , @xmath43 is reflexive and transitive because @xmath360 is a partition .",
    "let us denote by @xmath361 the value of @xmath43 at the beginning of the @xmath362-th iteration of @xmath153 .",
    "then , @xmath363 then , by inductive hypothesis , @xmath43 is clearly reflexive .",
    "let us turn on transitivity .",
    "consider @xmath364 and @xmath365 .",
    "then , by inductive hypothesis , @xmath366 . if @xmath367 then @xmath368 and therefore @xmath369 . if , instead , @xmath370 then @xmath371 and therefore @xmath332 . hence ,",
    "@xmath372 so that @xmath373 , i.e.  @xmath374 .    _ proof of lemma  [ basicssa ] .",
    "_ the output relation @xmath43 is a stuttering simulation so that @xmath375 .",
    "thus , we need to prove that @xmath376 .",
    "let us denote by @xmath361 the value of @xmath43 at the beginning of the @xmath362-th iteration of @xmath153 .",
    "we show by induction on @xmath362 that @xmath377 .        if @xmath387 then @xmath388 . if , instead , @xmath389 then @xmath390 . by inductive hypothesis ,",
    "@xmath391 , therefore it is enough to show that @xmath392 .",
    "consider @xmath393 .",
    "since @xmath394 , there exists a path @xmath395 such that for any @xmath396 , @xmath397 and @xmath398 .",
    "it turns out that any transition @xmath399 can be lifted to a path @xmath400 where @xmath401 when @xmath402 and @xmath403 , and in particular @xmath404 .",
    "in fact , consider the first transition @xmath405 .",
    "since @xmath406 , there exists @xmath407 such that @xmath408 where @xmath409 for any @xmath410 and @xmath411 .",
    "thus , by a simple induction , any transition @xmath399 can be lifted to one such path . moreover , by induction , for any @xmath396 , @xmath412 , while @xmath413 . by lemma  [ sitrans ]",
    ", @xmath361 is transitive so that from @xmath414 and @xmath415 we obtain that for any @xmath396 , @xmath416 and @xmath417 .",
    "the concatenation of the above paths therefore provides a path @xmath418 such that for any @xmath419 , @xmath420 and @xmath421 .",
    "consequently , @xmath422 and this concludes the proof .",
    "_ proof of theorem  [ st - char2 ] .",
    "_ @xmath423 if @xmath424 is a stuttering simulation and @xmath425 then @xmath426 , i.e. , @xmath427",
    ". moreover , if @xmath68 then there exists @xmath177 and @xmath428 such that @xmath26 , so that @xmath429 . since @xmath430 and @xmath431",
    ", we have that @xmath432 . hence , @xmath433 .",
    "@xmath434 assume that @xmath26 and @xmath425 .",
    "therefore , @xmath427 , i.e. , @xmath426 .",
    "furthermore , @xmath435 , so that from @xmath433 we obtain that @xmath436 . since @xmath437 and @xmath438",
    ", we have that @xmath439 , and therefore @xmath424 is a stuttering simulation .",
    "_ proof of theorem  [ correctness ] .",
    "_ this is a consequence of the following two facts .",
    "let @xmath43 be the current relation in @xmath153 at the end of some iteration and let @xmath185 be the corresponding pr .",
    "* we have that @xmath440 is a refiner in @xmath153 iff @xmath441 is a refiner in @xmath57 .",
    "this is true because for any @xmath145 , we have that @xmath442 iff @xmath443 .",
    "* let @xmath440 be a refiner in @xmath153 and @xmath444 .",
    "let @xmath445 .",
    "consider @xmath446 @xmath447 where @xmath38 and @xmath206 .",
    "then , for any @xmath38 , @xmath448 .    _ proof of lemma  [ l2 ] .",
    "_ let @xmath449 and @xmath450 such that @xmath68 .",
    "+ assume that @xmath451 and consider @xmath452 . then",
    ", @xmath453 , so that there exist @xmath454 , with @xmath125 , such that @xmath455 , for all @xmath127 , @xmath456 and @xmath457 , and @xmath458 .",
    "since @xmath459 , we have that @xmath460 and therefore necessarily either @xmath131 or @xmath461 . if @xmath131 then @xmath462 . if instead @xmath461 then @xmath463 .",
    "thus , @xmath464 .",
    "+ conversely , assume that @xmath465 and consider @xmath466 . if @xmath467 then clearly @xmath468 .",
    "if instead @xmath469 then @xmath470 , so that there exists @xmath471 such that @xmath44 .",
    "again , if @xmath472 then @xmath473 and therefore we have that @xmath474 .",
    "if @xmath475 then we can go on with this construction . since @xmath31 is finite , in this way we would obtain a cycle of inert transitions inside @xmath476 , namely a contradiction .",
    "thus , it must exist some @xmath477 such that @xmath478 , and therefore @xmath474 .",
    "hence , @xmath451 .",
    "_ proof of theorem  [ th - refiner ] .",
    "_ let us first observe that since @xmath479 is a preorder , and therefore transitive , if @xmath480 then @xmath481 .",
    "+ @xmath423 let us assume that @xmath482 .",
    "if @xmath483 then both conditions  ( i ) and ( ii ) trivially do not hold : for ( ii ) , @xmath484 implies @xmath485 , and therefore @xmath486 , which is in contradiction with @xmath487 .",
    "thus , assume that @xmath488 . since @xmath68 , by lemma  [ l2 ] , we have that @xmath489 .",
    "hence , @xmath490 , because @xmath488 implies @xmath491 . moreover , if @xmath492 , then , again by lemma  [ l2 ] , @xmath493 . if @xmath243 then @xmath494 and therefore @xmath495 , i.e. , @xmath496 .",
    "@xmath434 we prove that if ( i ) and ( ii ) do not hold then @xmath482 . by lemma  [ l2 ] ,",
    "let us show that @xmath489 . if @xmath497 then this is trivially true .",
    "thus , let us assume that @xmath488 .",
    "@xmath498\\hspace*{20ex } }      & \\\\           \\cup \\{d\\cap\\operatorname{bottom}(\\mu_{{\\mathcal{p}}}(b))~|~ b{\\trianglelefteq}d\\ }      & = \\\\",
    "\\text{\\small[by set theory]\\hspace*{20ex } }      & \\\\           ( b\\cap\\operatorname{bottom}(\\mu_{{\\mathcal{p}}}(b)))\\cup & \\\\      \\cup \\ { d\\cap \\operatorname{bottom}(\\mu_{{\\mathcal{p}}}(b))~|~ b { \\vartriangleleft}d ,       c\\not{\\trianglelefteq}d \\ } \\cup & \\\\      \\cup \\",
    "{ d\\cap \\operatorname{bottom}(\\mu_{{\\mathcal{p}}}(b))~|~ b { \\vartriangleleft}d ,       c{\\trianglelefteq}d \\ }       & = \\\\       \\text{\\small[by definition of $ \\operatorname{bottomblock}$]\\hspace*{20ex } } & \\\\               ( b\\cap\\operatorname{bottom}(\\mu_{{\\mathcal{p}}}(b)))\\cup & \\\\        \\cup \\ { d\\cap \\operatorname{bottom}(\\mu_{{\\mathcal{p}}}(b))~|~d \\in \\operatorname{bottomblock}(b ) , c       \\not{\\trianglelefteq}d\\ } \\cup&\\\\       \\cup \\ { d\\cap \\operatorname{bottom}(\\mu_{{\\mathcal{p}}}(b ) ) ~|~ b { \\vartriangleleft}d , c{\\trianglelefteq}d \\ }       & \\subseteq",
    "\\\\       \\text{\\small[by conditions~(i ) and ( ii)]\\hspace*{20ex } } & \\\\",
    "\\operatorname{pre}(\\mu_{{\\mathcal{p}}}(c ) ) \\cup & \\\\      \\cup \\",
    "{ d\\cap \\operatorname{bottom}(\\mu_{{\\mathcal{p}}}(b ) ) ~|~ d \\in          \\operatorname{bottomblock}(b),c\\not{\\trianglelefteq}d , d { { { \\shortrightarrow}}^{\\exists}}\\mu_{{\\mathcal{p}}}(c ) \\ } \\cup & \\\\      \\cup \\ { d\\cap \\operatorname{bottom}(\\mu_{{\\mathcal{p}}}(b ) ) ~|~ b { \\vartriangleleft}d ,       c{\\trianglelefteq}d \\ } &       \\subseteq \\\\      \\text{\\small[because $ c{\\trianglelefteq}d \\;{\\rightarrow}\\ ; d\\subseteq \\mu_{{\\mathcal{p}}}(c)$]\\hspace*{20ex } } & \\\\",
    "\\operatorname{pre}(\\mu_{{\\mathcal{p}}}(c ) ) \\cup & \\\\      \\cup \\",
    "{ d\\cap \\operatorname{bottom}(\\mu_{{\\mathcal{p}}}(b ) ) ~|~ d \\in \\operatorname{bottomblock}(b),c\\not{\\trianglelefteq}d , d { { { \\shortrightarrow}}^{\\exists}}\\mu_{{\\mathcal{p}}}(c ) \\ } \\cup&\\\\       \\mu_{{\\mathcal{p}}}(c ) . &",
    "\\\\      \\end{aligned}\\ ] ] consider now @xmath499 , @xmath487 and @xmath496 .",
    "then , @xmath500}\\\\ d \\cap \\neg \\operatorname{pre}(\\mu_{{\\mathcal{p}}}(b ) ) & \\subseteq   \\text{~~~\\small[as $ d\\subseteq \\mu_{{\\mathcal{p}}}(d ) \\subseteq \\mu_{{\\mathcal{p}}}(b)$]}\\\\ \\mu_{{\\mathcal{p}}}(d ) \\cap \\neg \\operatorname{pre}(\\mu_{{\\mathcal{p}}}(d ) ) & = \\\\",
    "\\operatorname{bottom}(\\mu_{{\\mathcal{p}}}(d ) ) & . \\\\\\end{aligned}\\ ] ] since @xmath496 , there exists @xmath501 such that @xmath238 . since @xmath502 and @xmath238 , by hypothesis , @xmath240 , so that , by lemma  [ l2 ] , we have that @xmath503 .",
    "thus , summing up , it turns out that @xmath504 , so that , by lemma  [ l2 ] , @xmath283 .",
    "* @xmath209 takes @xmath73 time . *",
    "@xmath505 takes @xmath506 time .",
    "this bound is computed as follows .",
    "line  4 takes @xmath271 time .",
    "lines  5 - 6 take @xmath507 time . note that lines  5 - 6 are actually implemented as follows : + lines  11 - 12 and 13 - 14 take @xmath508 time .",
    "the estimate of the overall cost of lines  7 - 10 deserves special care . at line  10 , it turns out that @xmath509 : if @xmath510 at line 10 then @xmath511 .",
    "however , as a consequence of the code at lines  13 - 14 , it turns out that when we are at line  10 , namely when refiner@xmath512 , it is true that @xmath513 so that @xmath514 .",
    "hence , the overall cost of lines  7 - 10 is @xmath515 takes @xmath516 time .",
    "* @xmath298 takes @xmath230 time . *",
    "@xmath212 takes @xmath517 time .",
    "in particular , @xmath310 takes @xmath311 time .",
    "* @xmath213 takes @xmath518 time .",
    "let us prove that the overall number of newly generated blocks by @xmath334 at line  6 of @xmath57 is @xmath519 .",
    "let @xmath520}$ ] be the sequence of partitions computed by @xmath57 where @xmath521 is the initial partition @xmath522 , @xmath523 is the final partition @xmath524 and for all @xmath525 $ ] , @xmath526 .",
    "the number of newly generated blocks by one splitting operation that refines @xmath527 to @xmath528 is given by @xmath529 .",
    "thus , the overall number of newly generated blocks is latexmath:[$\\sum_{i=0}^{n-1 } 2(|p_{i+1}| -     it turns out that the overall number of iterations of the main while - loop of @xmath57 is in @xmath531 .",
    "if at some iteration of @xmath57 it happens that line  7 of @xmath340 sets @xmath532 for some blocks @xmath61 and @xmath62 then for all the successive iterations of @xmath57 , for any block @xmath533 which is contained in @xmath61 ( namely , which is a descendant of @xmath61 ) and for any block @xmath534 which is contained in @xmath62 , and for all the successive iteratuons we will have that @xmath535 .",
    "moreover , at any iteration of @xmath57 , there exist at least two blocks @xmath341 such that the assignment @xmath536 at line  7 of @xmath340 is executed .",
    "since for any block @xmath61 , the assignment @xmath537 for some @xmath538 and for some @xmath62 may happen at most @xmath82 times , we obtain that the overall number of iterations is in @xmath531 .    hence , the overall time complexities of the functions called within the main while - loop of @xmath57 are as follows : + ",
    "@xmath211 : @xmath539 ; + ",
    "@xmath540 : @xmath541 ; + ",
    "@xmath298 : @xmath542 ; + ",
    "@xmath212 : @xmath543 .",
    "+ the analysis of the overall time complexity of @xmath213 needs the following observation . as observed above ,",
    "if at some iteration of @xmath57 it happens that line  7 of @xmath340 sets @xmath544 for some blocks @xmath61 and @xmath62 then for all the successive iterations of @xmath57 , for any block @xmath533 which is contained in @xmath61 and for any block @xmath534 which is contained in @xmath62 , we will have that @xmath545 .",
    "thus , for a given block @xmath61 , if the test @xmath546 at line  6 of @xmath340 is true then for any block @xmath547 which is descendant of @xmath62 , the test @xmath548 will be false .",
    "this means that for any given block @xmath61 , the body at lines  7 - 16 of the if - then statement at line  6 will be executed at most @xmath82 times .",
    "therefore , the overall time complexity in @xmath57 of lines  3 and  17 of @xmath213 is @xmath549 .",
    "since the overall cost of lines  2 - 7 and 18 is @xmath550 , it turns out that the overall cost of @xmath213 is @xmath551 .            * the pointers from any state @xmath556 to the block @xmath92 of the current partition",
    "are stored in @xmath557 space . *",
    "the lists localbottoms and bottomblocks globally take , respectively , @xmath558 and @xmath531 space .",
    "* the current partition @xmath59 is stored in @xmath559 space . *",
    "the current relation @xmath253 is stored in @xmath531 space . *",
    "the resizable tables count and bcount take , respectively , @xmath560 and @xmath561 space . * the local table refiner in function @xmath211 takes @xmath531 ."
  ],
  "abstract_text": [
    "<S> stuttering bisimulation is a well - known behavioral equivalence that preserves @xmath0 , namely @xmath1 without the next - time operator @xmath2 . </S>",
    "<S> correspondingly , the stuttering simulation preorder induces a coarser behavioral equivalence that preserves the existential fragment @xmath3 , namely @xmath4 without the next - time @xmath2 and globally @xmath5 operators . while stuttering bisimulation equivalence can be computed by the well - known groote and vaandrager s [ 1990 ] algorithm , to the best of our knowledge , no algorithm for computing the stuttering simulation preorder and equivalence is available . </S>",
    "<S> this paper presents such an algorithm for finite state systems . </S>"
  ]
}