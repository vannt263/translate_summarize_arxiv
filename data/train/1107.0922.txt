{
  "article_text": [
    "with the exponential growth in machine learning ( ml ) datasets sizes and increasing sophistication of ml techniques , there is a growing need for systems that can execute ml algorithms efficiently in parallel on large clusters .",
    "unfortunately , based on our comprehensive survey , we find that existing popular high level parallel abstractions , such as mapreduce @xcite and dryad @xcite , do not efficiently fit many ml applications .",
    "alternatively , designing , implementing , and debugging ml algorithms on low level frameworks such as openmp @xcite or mpi @xcite can be excessively challenging , requiring the user to address complex issues like race conditions , deadlocks , and message passing in addition to the already challenging mathematical code and complex data models common in ml research .    in this paper",
    "we describe the culmination of two years of research in collaboration with ml , parallel computing , and distributed systems experts . by focusing on machine learning we designed graphlab , a domain specific parallel abstraction @xcite that fits the needs of the ml community , without sacrificing computational efficiency or requiring ml researchers to redesign their algorithms . in @xcite",
    "we first introduced the graphlab multi - core api to the ml community .    in this paper",
    "we build upon our earlier work by refining the graphlab abstraction and extending the graphlab api to the distributed setting .",
    "we provide the first formal presentation of the streamlined graphlab abstraction and describe how the abstraction enabled us to construct a highly optimized c++ api for the distributed setting .",
    "we conduct a comprehensive performance analysis on the amazon elastic cloud ( ec2 ) cloud computing service .",
    "we show that applications created using graphlab outperform equivalent hadoop / mapreduce@xcite implementations by 20 - 60x and match the performance of carefully constructed and fine tuned mpi implementations .",
    "our main contributions are the following :     -3pt    asurvey of common properties of machine learning algorithms and the limitations of existing parallel abstractions .",
    "[ sec : needforgraphlab ] )    a formal presentation of the graphlab abstraction and how it naturally represents ml algorithms .",
    "[ sec : graphlababstraction ] )    two efficient distributed implementations of the graphlab abstraction ( sec .",
    "[ sec : impldetails ] ) :    @xmath0    * chromatic engine : * uses graph coloring to achieve efficient sequentially consistent execution for static schedules .    *",
    "locking engine : * uses distributed locking and latency hiding to achieve sequential consistency while supporting prioritized execution .",
    "implementations of three state - of - the - art machine learning algorithms using the graphlab abstraction .",
    "[ sec : applications ] )    an extensive evaluation of graphlab using a 512 processor ( 64 node ) ec2 cluster , including comparisons to hadoop and mpi implementations .",
    "[ sec : experiments ] )",
    "[ sec : needforgraphlab ]     * computation model * & * sparse depend . * & * async . comp . * & * iterative * & * prioritized ordering * & * sequentially consistent @xmath1 * & * distributed * + mpi@xcite & messaging & yes & yes & yes & n / a @xmath2 & n / a @xmath2 & yes + mapreduce@xcite & par . data - flow & no & no & extensions@xmath3 & n / a & n / a & yes + dryad@xcite & par .",
    "data - flow & yes & no & extensions@xmath4 & n / a & n / a & yes + pregel@xcite / bpgl@xcite & graphbsp@xcite & yes & no & yes & n / a & n / a & yes + piccolo@xcite & distr .",
    "map@xmath5 & n / a @xmath5 & yes & yes & no & accumulators & yes + pearce et.al.@xcite & graph visitor & yes & yes & yes & yes & no & no + * graphlab * & * graphlab * & yes & yes & yes & yes@xmath6 & yes & yes +    the graphlab abstraction is the product of several years of research in designing and implementing systems for statistical inference in probabilistic graphical models .",
    "early in our work @xcite , we discovered that the high - level parallel abstractions popular in the ml community such as mapreduce @xcite and parallel blas @xcite libraries are unable to express statistical inference algorithms efficiently .",
    "our work revealed that an efficient algorithm for graphical model inference should explicitly address the _ sparse dependencies _ between random variables and adapt to the input data and model parameters .",
    "guided by this intuition we spent over a year designing and implementing various machine learning algorithms on top of low - level threading primitives and distributed communication frameworks such as openmp @xcite , cilk++ @xcite and mpi @xcite . through this process , we discovered the following set of core algorithmic patterns that are common to a wide range of machine learning techniques .",
    "following , we detail our findings and motivate why a new framework is needed ( see table  [ table : abstrcomptable ] ) .",
    "* sparse computational dependencies : * many ml algorithms can be factorized into local * dependent * computations which examine and modify only a small sub - region of the entire program state . for example , the conditional distribution of each random variable in a large statistical model typically only depends on a small subset of the remaining variables in the model .",
    "this computational sparsity in machine learning arises naturally from the statistical need to reduce model complexity .",
    "parallel abstractions like mapreduce @xcite require algorithms to be transformed into an embarrassingly parallel form where computation is * independent*. unfortunately , transforming ml algorithms with computational _ dependencies _ into the embarrassingly parallel form needed for these abstractions is often complicated and can introduce substantial algorithmic inefficiency @xcite .",
    "alternatively , data flow abstractions like dryad @xcite , permit directed acyclic dependencies , but struggle to represent cyclic dependencies common to iterative ml algorithms .",
    "finally , graph - based messaging abstractions like pregel @xcite provide a more natural representation of computational dependencies but require users to explicitly manage communication between computation units .",
    "* asynchronous iterative computation : * from simulating complex statistical models , to optimizing parameters , many important machine learning algorithms iterate over local computation kernels .",
    "furthermore , many iterative machine learning algorithms benefit from @xcite and in some cases require @xcite asynchronous computation . unlike * synchronous * computation , in which all kernels are computed simultaneously ( in parallel ) using the previous values for dependent parameters , * asynchronous * computation requires that the local computation kernels use the most recently available values .",
    "abstractions based on bulk data processing , such as mapreduce @xcite and dryad @xcite were not designed for iterative computation .",
    "while recent projects like mapreduce online @xcite , spark @xcite , twister @xcite , and nexus @xcite extend mapreduce to the iterative setting , they do not support asynchronous computation .",
    "similarly , parallel graph based abstractions like pregel @xcite and bpgl @xcite adopt the bulk synchronous parallel ( bsp ) model @xcite and do not naturally express asynchronous computation .",
    "* sequential consistency : * by ensuring that all parallel executions have an equivalent sequential execution , sequential consistency eliminates many challenges associated with designing , implementing , and testing parallel ml algorithms .",
    "in addition , many algorithms converge faster if sequential consistency is ensured , and some even require it for correctness .    however , this view is not shared by all in the ml community . recently ,",
    "@xcite advocate soft - optimization techniques ( e.g. , allowing computation to intentionally race ) , but we argue that such techniques do not apply broadly in ml . even for the algorithms evaluated in @xcite , the conditions under which the soft - optimization techniques work are not well understood and may fail in unexpected ways on different datasets .",
    "indeed , for some machine learning algorithms sequential consistency is strictly required .",
    "for instance , gibbs sampling @xcite , a popular inference algorithm , requires sequential consistency for statistical correctness , while many other optimization procedures require sequential consistency to converge ( fig .",
    "[ fig : synchronouspmf ] demonstrates that the prediction error rate of one of our example problems is dramatically better when computation is properly asynchronous . ) . finally , as @xcite demonstrates , the lack of sequential consistency can dramatically increase the time to convergence for stochastic optimization procedures .    by designing an abstraction which enforces sequentially consistent computation , we eliminate much of the complexity introduced by parallelism , allowing the ml expert to focus on algorithm design and correctness of numerical computations .",
    "debugging mathematical code in a parallel program which has random errors caused by non - deterministic ordering of concurrent computation is particularly unproductive .",
    "the discussion of sequential consistency is relevant only to frameworks which support asynchronous computation .",
    "piccolo @xcite provides a limited amount of consistency by combining simultaneous writes using accumulation functions .",
    "however , this only protects against single write races , but does not ensure sequential consistency in general . the parallel asynchronous graph traversal abstraction by pearce et .",
    "@xcite does not support any form of consistency , and thus is not suitable for a large class of ml algorithms .    ) comparing prediction error when running sequentially consistent asynchronous iterations vs inconsistent asynchronous iterations over a five node distributed cluster .",
    "consistent iterations converge rapidly to a lower error while inconsistent iterations oscillate and converge slowly.,scaledwidth=25.0% ]    * prioritized ordering : * in many ml algorithms , iterative computation converges asymmetrically .",
    "for example , in parameter optimization , often a large number of parameters will quickly converge after only a few iterations , while the remaining parameters will converge slowly over many iterations @xcite .",
    "if we update all parameters equally often , we could waste substantial computation recomputing parameters that have effectively converged .",
    "conversely , by focusing early computation on more challenging parameters first , we can potentially reduce computation .",
    "adaptive prioritization can be used to focus iterative computation where it is needed . the only existing framework to support this is the parallel graph framework by pearce et .",
    "al . @xcite .",
    "the framework is based on the visitor - pattern and prioritizes the ordering of visits to vertices .",
    "graphlab however , allows the user to define _ arbitrary ordering _ of computation , and our implementation supports efficient fifo and priority - based scheduling .",
    "* rapid development : * machine learning is a rapidly evolving field with new algorithms and data - sets appearing weekly . in many cases these algorithms",
    "are not yet well characterized and both the computational and statistical properties are under active investigation .",
    "large - scale parallel machine learning systems must be able to adapt quickly to changes in the data and models in order to facilitate rapid prototyping , experimental analysis , and model tuning . to achieve these goals ,",
    "an effective high - level parallel abstraction must hide the challenges of parallel algorithm design , including race conditions , deadlock , state - partitioning , and communication .",
    "[ sec : graphlababstraction ] using the ideas from the previous section , we extracted a single coherent computational pattern : _ asynchronous parallel computation on graphs _ with a _ sequential _ model of computation .",
    "this pattern is both sufficiently expressive to encode a wide range of ml algorithms , and sufficiently restrictive to enable efficient parallel implementations .",
    "the graphlab abstraction consists of three main parts , the data graph , the update function , and the sync operation .",
    "the data graph ( sec .  [ sec : data_graph ] ) represents user modifiable program state , and both stores the mutable user - defined data and encodes the sparse computational dependencies .",
    "the update functions ( sec .  [ sec : update_functions ] ) represent the factorized user computation and operate on the data graph by transforming data in small overlapping contexts called scopes . finally , the sync operation ( sec .  [ sec : sync_operation ] ) is used to maintain global aggregate statistics of the data graph .",
    "we now present the graphlab abstraction in greater detail . to make these ideas more concrete",
    ", we will use the pagerank algorithm @xcite as a running example . while pagerank is not a common machine learning algorithm , it is easy to understand and shares many properties common to machine learning algorithms .",
    "[ ex : pagerank_intro ] the pagerank algorithm recursively defines the rank of a webpage @xmath7 : @xmath8 in terms of the ranks of those pages that link to @xmath7 and the weight @xmath9 of the link as well as some probability @xmath10 of randomly jumping to that page . the pagerank algorithm , simply iterates eq .  ( [ eqn : pagerank ] ) until the individual pagerank values converge ( i.e. , change by less than some small @xmath11 ) .",
    "[ sec : data_graph ]    the graphlab abstraction stores the program state as an undirected graph called the * data graph*. the data graph @xmath12 is a container which manages the user defined data @xmath13 .",
    "here we use the term  data \" broadly to refer to model parameters , algorithmic state , and even statistical data .",
    "the user can associate arbitrary data with each vertex @xmath14 and edge @xmath15 in the graph . since some machine learning applications require directed edge data ( e.g. , weights on directed links in a web - graph ) we provide the ability to store and retrieve data associated with directed edges . while the graph data is mutable ,",
    "the graph structure is _ _ static _ _ and can not be changed during execution .    the data graph for pagerank is directly obtained from the web graph , where each vertex corresponds to a web page and each edge represents a link .",
    "the vertex data @xmath16 stores @xmath17 , the current estimate of the pagerank , and the edge data @xmath18 stores @xmath19 , the directed weight of the link .",
    "the data graph is convenient for representing the state of a wide range of machine learning algorithms .",
    "for example , many statistical models are efficiently represented by undirected graphs @xcite called markov random fields ( mrf ) .",
    "the data graph is derived directly from the mrf , with each vertex representing a random variable . in this case",
    "the vertex data and edge data may store the local parameters that we are interested in learning .",
    "[ sec : update_functions ] computation is encoded in the graphlab abstraction via user defined update functions . an * update function * is a stateless procedure which modifies the data within the * scope * of a vertex and schedules the future execution of other update functions .",
    "the scope of vertex @xmath7 ( denoted by @xmath20 ) is the data stored in @xmath7 , as well as the data stored in all adjacent vertices and edges as shown in fig .",
    "[ fig : scope ] .     of vertex @xmath21 .",
    "each of the gray cylinders represent a block of user defined data and is associated with a vertex or edge .",
    "the * scope * of vertex @xmath21 is illustrated by the region containing vertices @xmath22 .",
    "an * update function * applied to vertex @xmath21 is able to read and modify all the data in @xmath23 ( vertex data @xmath24 , @xmath25 , @xmath26 , and @xmath27 and edge data @xmath28 , @xmath29 , and @xmath30 ) .",
    ", title=\"fig : \" ] [ fig : scope ]    a graphlab update function takes as an input a vertex @xmath7 and its scope @xmath20 and returns the new version of the scope as well as a set of tasks @xmath31 which encodes future task executions .",
    "@xmath32 after executing an update function the modified scope data in @xmath20 is written back to the data graph .",
    "each * task * in the set of tasks @xmath31 , is a tuple @xmath33 consisting of an update function @xmath34 and a vertex @xmath7 .",
    "all returned task @xmath31 are executed _ eventually _ by running @xmath35 following the execution semantics described in sec .",
    "[ sec : execution_model ] .    rather than adopting a message passing or data flow model as in @xcite , graphlab allows the user defined update functions complete freedom to read and modify any of the data on adjacent vertices and edges .",
    "this simplifies user code and eliminates the need for the users to reason about the movement of data . by controlling",
    "what tasks are added to the task set , graphlab update functions can efficiently express adaptive computation .",
    "for example , an update function may choose to reschedule its neighbors only when it has made a substantial change to its local data .",
    "the update function mechanism allows for _ asynchronous computation _ on the _ sparse dependencies _ defined by the data graph .",
    "since the data graph permits the expression of general cyclic dependencies , _ iterative computation _ can be represented easily .",
    "many algorithms in machine learning can be expressed as simple update functions .",
    "for example , probabilistic inference algorithms like gibbs sampling @xcite , belief propagation @xcite , expectation propagation @xcite and mean field variational inference @xcite can all be expressed using update functions which read the current assignments to the parameter estimates on neighboring vertices and edges and then apply sampling or optimization techniques to update parameters on the local vertex .    the update function for pagerank ( defined in alg .",
    "[ alg : pagerank_updatefunction ] ) computes a weighted sum of the current ranks of neighboring vertices and assigns it as the rank of the current vertex .",
    "the algorithm is adaptive : neighbors are listed for update only if the value of current vertex changes more than a predefined threshold .",
    "[ alg : pagerank_updatefunction ]    @xmath36 @xmath37    ( ) @xmath38}$ ] @xmath39      [ sec : sync_operation ]    in many ml algorithms it is necessary to maintain global statistics describing data stored in the data graph .",
    "for example , many statistical inference algorithms require tracking of global convergence estimators .",
    "alternatively , parameter estimation algorithms often compute global averages or even gradients to tune model parameters . to address these situations ,",
    "the graphlab abstraction expresses global computation through the * sync operation * , which aggregates data across all vertices in the graph in a manner analogous to mapreduce .",
    "the results of the sync operation are stored globally and may be accessed by all update functions . because graphlab is designed to express iterative computation , the sync operation runs repeated at fixed user determined intervals to ensure that the global estimators remain fresh .",
    "the sync operation is defined as a tuple @xmath40 consisting of a unique key , three user defined functions , an initial accumulator value , and an integer defining the interval between sync operations .",
    "the sync operation uses the @xmath41 and @xmath42 functions to perform a _",
    "global synchronous reduce _ where @xmath41 aggregates vertex data and @xmath42 combines intermediate @xmath41 results .",
    "the @xmath43 function performs a transformation on the final value and stores the result .",
    "the ` key ` can then be used by update functions to access the most recent result of the sync operation .",
    "the sync operation runs periodically , approximately every @xmath44 update function calls .",
    "we can compute the second most popular page on the web by defining the following sync operation : @xmath45    \\end{aligned}\\ ] ] where the accumulator taking on the initial value as the empty array @xmath46 . the function  @xmath47 \" returns the two pages with the highest pagerank in the set @xmath48 .",
    "after the global reduction , the @xmath49 array will contain the top two pages and @xmath50 $ ] in @xmath43 extracts the second entry .",
    "we may want to update the global estimate every @xmath51 vertex updates .",
    "[ sec : execution_model ] the graphlab execution model , presented in alg .",
    "[ alg : execution_model ] , follows a simple single loop semantics .",
    "the input to the graphlab abstraction consists of the data graph @xmath52 , an update function @xmath53 , an initial set of tasks @xmath31 to update , and any sync operations . while there are tasks remaining in @xmath31 , the algorithm removes ( line  [ ln : pop ] ) and executes ( line  [ ln : update ] ) tasks , adding any new tasks back into @xmath31 ( line  [ ln : push ] ) .",
    "the appropriate sync operations are executed whenever necessary . upon completion , the resulting data graph and synced values",
    "are returned to the user .",
    "[ alg : execution_model ]    the exact behavior of @xmath54 ( line  [ ln : pop ] ) is up to the implementation of the graphlab abstraction .",
    "the only guarantee the graphlab abstraction provides is that @xmath55 removes and returns an update task in @xmath31 . the flexibility in the order in which @xmath55 removes tasks from @xmath31 provides the opportunity to balance features with performance constraints .",
    "for example , by restricting task execution to a fixed order , it is possible to optimize memory layout .",
    "conversely , by supporting _",
    "prioritized ordering _",
    "it is possible to implement more advanced ml algorithms at the expense run - time overhead . in our implementation",
    "( see sec .",
    "[ sec : impldetails ] ) we support fixed execution ordering ( chromatic engine ) as well as fifo and prioritized ordering ( locking engine ) .    the graphlab abstraction presents a rich _ sequential model _ that is automatically translated into a _ parallel execution _ by allowing multiple processors to remove and execute update tasks simultaneously . to retain the same _ sequential _ execution semantics",
    "we must ensure that overlapping computation is not run simultaneously .",
    "however , the extent to which computation can _ safely _ overlap depends on the user defined update function . in the next section we introduce several * consistency models * that allow the runtime to optimize the parallel execution while maintaining consistent computation .",
    "[ sec : consistency ]    a parallel implementation of graphlab must guarantee sequential consistency @xcite over update tasks and sync operations .",
    "we define sequential consistency in the context of the graphlab abstraction as :    [ dfn : sequential_consistency ] for every parallel execution of the graphlab abstraction , there exists a sequential ordering on all executed update tasks and sync operations which produces the same data graph and synced global values .",
    "a simple method to achieve sequential consistency among update functions is to ensure that the scopes of concurrently executing update functions do not overlap .",
    "we refer to this as the * full consistency * model ( see fig .  [",
    "fig : scoperings ] ) .",
    "full consistency limits the potential parallelism since concurrently executing update functions must be at least two vertices apart ( see fig .",
    "[ fig : scopetradeoff ] ) .",
    "even in moderately dense data graphs , the amount of available parallelism could be low .",
    "depending on the actual computation performed within the update function , additional relaxations can be safely made to obtain more parallelism without sacrificing sequential consistency .",
    "we observed that for many machine learning algorithms , the update functions do not need full read / write access to all of the data within the scope .",
    "for instance , the pagerank update in eq .",
    "( [ eqn : pagerank ] ) only requires read access to edges and neighboring vertices . to provide greater parallelism",
    "while retaining sequential consistency , we introduced the * edge consistency * model . if the edge consistency model is used ( see fig .",
    "[ fig : scoperings ] ) , then each update function has exclusive read - write access to its vertex and adjacent edges but read only access to adjacent vertices .",
    "this increases parallelism by allowing update functions with slightly overlapping scopes to safely run in parallel ( see fig .",
    "[ fig : scopetradeoff ] ) .    finally , for many machine learning algorithms there is often some initial data pre - processing which only requires read access to adjacent edges and write access to the central vertex . for these algorithms",
    ", we introduced the weakest * vertex consistency * model ( see fig .",
    "[ fig : scoperings ] ) .",
    "this model has the highest parallelism but only permits fully independent ( ` map ` ) operations on vertex data .",
    "while sequential consistency is essential when designing , implementing , and debugging complex ml algorithms , an adventurous user @xcite may want to relax the theoretical consistency constraints .",
    "thus , we allow users to choose a weaker consistency model at their own risk .",
    "[ fig : consistency ]",
    "in our prior work @xcite we implemented an optimized shared memory graphlab runtime using pthreads . to fully utilize clouds composed of multi - core instances , we implemented distributed graphlab on top of our shared memory runtime . as we transitioned to the distributed setting , we had to address two main design challenges :    @xmath0    * distributed graph : * to manage the data graph across multiple machines we needed a method to efficiently load , distribute , and maintain the graph data - structure over a potentially varying number of machines .",
    "* distributed consistency : * to support the various consistency models in the distributed setting , we needed an efficient mechanism to ensure safe read - write access to the data - graph .",
    "we first implemented a data graph representation that allows for rapid repartitioning across different loads cluster sizes .",
    "next , we implemented two versions of the graphlab engine for the distributed setting , making use of asynchronous communication implemented on top of tcp sockets .",
    "the first engine is the simpler chromatic engine ( sec .",
    "[ sec : chromaticengine ] ) which uses basic graph coloring to manage consistency .",
    "the second is a locking engine ( sec .",
    "[ sec : lockingengine ] ) which uses distributed locks .      efficiently implementing the data graph in the distributed setting",
    "requires balancing computation , communication , and storage . to ensure balanced computation and storage",
    ", each machine must hold only a small fraction of the data graph . at the same time we would like to minimize the number of edges that cross partitions , to reduce the overall state that must be synchronized across machines .",
    "finally , the cloud setting introduces an additional challenge . because the number of machines available may vary with the research budget and the performance demands",
    ", we must be able to quickly load the data - graph on varying sized cloud deployments . to resolve these challenges",
    ", we developed a graph representation based on two - phased partitioning which can be efficiently load balanced on arbitrary cluster sizes .",
    "the graph is initially over - partitioned by an expert , or by using a graph partitioning heuristic ( for instance metis @xcite ) into @xmath56 parts where @xmath56 is much greater than the number of machines ( see fig .",
    "[ fig : graphcut ] ) .",
    "each part is stored as a different file possibly on a distributed store ( hdfs , amazon s3 ) . the connectivity structure of the @xmath56 parts is then represented as a * meta - graph * with @xmath56 vertices .",
    "each vertex of the * meta - graph * represents a partition , and is weighted by the amount of data it stores .",
    "each edge is weighted by the number of edges crossing the partitions .    distributed loading is accomplished by performing a fast balanced partition of the meta - graph into @xmath57 parts , and each machine constructs its local partition of the graph by merging its assigned files . to facilitate communication",
    ", each machine also stores the * ghost * of its local partition : the set of vertices and edges adjacent to the partition boundary ( see fig .",
    "[ fig : atoms ] ) .",
    "the ghosts conveniently act as local caches for their true counterparts across the network , and cache coherence is managed using versioning @xcite .",
    "the two - stage partitioning technique allows one graph partition to be reused for different numbers of machines without incurring a repartitioning step .",
    "a study on the quality of the two stage partitioning scheme is beyond the scope of this paper , though simple experiments using graphs obtained from @xcite suggest that the performance is comparable to direct partitioning .",
    "the graphlab * engine * emulates the _ execution model _ defined in sec .  [ sec : execution_model ] and is responsible for executing update task and sync operations , maintaining the update task set @xmath31 , and ensuring sequential consistency with respect to the appropriate consistency model ( see sec .",
    "[ sec : consistency ] ) . as discussed earlier in sec .",
    "[ sec : execution_model ] , variations in how @xmath31 is maintained and the order in which elements are removed is up to the implementation and can affect performance and expressiveness . to evaluate this trade - off",
    "we built the low - overhead * chromatic engine * , which executes @xmath31 in a fixed order , and the more expressive * locking engine * which executes @xmath31 in an asynchronous prioritized order .",
    "the * chromatic engine * imposes a static ordering on the update task set @xmath31 by executing update task in a canonical order ( e.g. , the order of their vertices ) .",
    "a classic technique @xcite to achieve a sequentially consistent parallel execution of a set of dependent tasks is to construct a vertex coloring .",
    "a vertex coloring assigns a color to each vertex such that no adjacent vertices share the same color .",
    "given a vertex color of the data graph , we can satisfy the _ edge consistency model _ by executing , _ in parallel _",
    ", all update tasks with vertices of the same color before proceeding to the next color .",
    "the sync operation can be run safely between colors .",
    "we can satisfy the other consistency models simply by changing how the vertices are colored .",
    "the stronger _ full consistency model _ is satisfied by constructing a second - order vertex coloring ( i.e. , no vertex shares the same color as any of its distance two neighbors ) .",
    "conversely , we can trivially satisfy the _",
    "vertex consistency model _ by assigning all vertices the same color .    in the distributed",
    "setting it is necessary to both prevent overlapping computation , and also synchronize any changes to ghost vertices or edge data between colors .",
    "a full communication barrier is enforced between color phases to ensure completion of all data synchronization before the next color begins . to maximize network throughput and to minimize time spent in the barrier , synchronization of modified data",
    "is constantly performed in the background while update functions are executing .",
    "approximate graph coloring can be quickly obtained through graph coloring heuristics .",
    "furthermore , many ml problems have obvious colorings . for example",
    ", many optimization problems in ml are naturally expressed as bipartite graphs ( sec .",
    "[ sec : applications ] ) , while problems based upon templated bayesian networks @xcite can be easily colored by the expert through inspection of the template model @xcite .",
    "the simple design of the chromatic engine is made possible by the explicit communication structure defined by the data graph , allowing data to be pushed directly to the machines requiring the information .",
    "in addition , the cache versioning mechanism further optimizes communication by only transmitting modified data .",
    "the advantage of the chromatic engine lies its predictable execution schedule .",
    "repeated invocations of the chromatic engine will always produce identical update sequences , regardless of the number of machines used .",
    "this property makes the chromatic engine highly suitable for testing and debugging purposes .",
    "we provide a distributed debugging tool which halts at the end of each color , allowing graph data and scheduler state to be queried .      even though the chromatic engine is a complete implementation of the graphlab abstraction as defined in sec .",
    "[ sec : graphlababstraction ] , it does not provide sufficient scheduling flexibility for many interesting applications .",
    "here we describe an implementation which directly extends from a typical shared memory implementation to the distributed case .    in the shared memory implementation of graphlab , the consistency models were implemented by associating a readers - writer lock with each vertex .",
    "the vertex consistency model is achieved by acquiring a write lock on the central vertex of each requested scope .",
    "the edge - consistency model is achieved by acquiring a write lock on the central vertex , and read locks on adjacent vertices .",
    "finally , full consistency is achieved by acquiring write locks on the central vertex and all adjacent vertices .    the main execution loop in the shared memory setting uses worker threads to pull tasks from the scheduler , acquire the required locks , evaluate the task , and then release the locks .",
    "this loop is repeated until the scheduler is empty .",
    "the sync operation is triggered by a global shared - memory task counter .",
    "periodically , as sync operations become ready , all threads are forced to synchronize in a barrier to execute the sync operation .    in",
    "the distributed setting , the same procedure is used . however , since the graph is partitioned , we restrict each machine to only run updates on vertices it owns .",
    "the ghost vertices / edges ensure that the update will always have direct memory access to all information in the scope , and distributed locks are used to ensure that the ghost is up to date .",
    "finaly , the scheduling flexibility permitted by the abstraction allow the use of efficient approximate fifo / priority task - queues .",
    "distributed termination is evaluated using a multi - threaded variant of the distributed consensus algorithm described in @xcite .    since the distributed locking and synchronization introduces substantial latency ,",
    "we rely on several techniques to reduce latency and hide its effects @xcite .",
    "first , the ghosting system provides caching capabilities eliminating the need to wait on data that has not changed remotely .",
    "second , all locking requests and synchronization calls are _ pipelined _ allowing each thread to request multiple scope locks simultaneously and then evaluate the update tasks only when the locks are satisfied . the _",
    "lock pipelining _ technique we implemented shares similarities to the continuation passing method in @xcite .",
    "[ sec : applications ] to evaluate the performance of the distributed graphlab runtime as well as the representational capabilities of the graphlab abstraction , we implemented several state - of - the - art ml algorithms .",
    "each algorithm is derived from active research in machine learning and is applied to real world data sets with different structures ( see table  [ table : appinp ] ) , update functions , and sync operations .",
    "in addition , each application tests different features of the distributed graphlab framework .",
    "the source and datasets for all the applications may be obtained from [ * http://graphlab.org * ] .",
    "data * & * edge data * & * update complexity * & * shape * & * partition * & * engine * + netflix & 0.5 m & 99 m & @xmath58 & @xmath59 & @xmath60 & bipartite & random & chromatic + coseg & 10.5 m & 31 m & @xmath61 & @xmath62 & @xmath63 & 3d grid & frames & locking + ner & 2 m & 200 m & @xmath64 & @xmath65 & @xmath63 & bipartite & random & chromatic +    [ table : appinp ]      [ sec : netflix ] the netflix movie recommendation task @xcite uses _ collaborative filtering _ to predict the movie ratings of users , based on the ratings of similar users . the * alternating least squares * ( * als * ) algorithm is commonly used in collaborative filtering .",
    "the input to als is a sparse users by movies matrix @xmath66 containing the movie ratings of each user .",
    "the algorithm proceeds by computing a low rank approximate matrix factorization : @xmath67{als_eqn}\\ ] ] where @xmath68 and @xmath69 are rank @xmath70 matrices .",
    "the als algorithm alternates between computing the least - squares approximation for @xmath68 or @xmath69 while holding the other fixed .",
    "the quality of the approximation depends on the magnitude of @xmath70 , as shown in fig .",
    "[ fig : alsaccuracy ] .",
    "while als may not seem like a graph algorithm , it can be represented elegantly using the graphlab abstraction .",
    "the _ sparse _ matrix @xmath71 defines a bipartite graph ( see table  [ table : appinp ] ) connecting each user with the movie he / she rated .",
    "the edge data contains the rating for a movie - user pair .",
    "the vertex data for users and movies contains the corresponding row in @xmath68 and column in @xmath69 respectively .",
    "the als algorithm can be encoded as an update function that recomputes the least - squares solution for the current movie or user given the neighboring users or movies .",
    "each local computation is accomplished using blas / lapack linear algebra library for efficient matrix operations .",
    "the bipartite graph is naturally two colored , thus the program is executed using the chromatic engine with two colors .",
    "a sync operation is used to compute the prediction error during the run . due to the density of the graph , a random",
    "partitioning was used .",
    "[ sec : coseg ] video cosegmentation automatically identifies and clusters spatio - temporal segments of video ( see fig .",
    "[ fig : videoframe ] ) that share similar texture and color characteristics .",
    "the resulting segmentation ( see fig .  [",
    "fig : cosegframe ] ) can be used in scene understanding and other computer vision and robotics applications .",
    "previous cosegmentation methods @xcite have focused on processing frames in isolation . as part of this work , we developed a joint cosegmentation algorithm that processes all frames simultaneously and therefore is able to model _ temporal _ stability .",
    "we preprocessed @xmath72 frames of high - resolution video by coarsening each frame to a regular grid of @xmath73 rectangular * super - pixels*. each super - pixel stores the color and texture statistics for all the raw pixels in its domain .",
    "the coseg algorithm predicts the best label ( e.g. , sky , building , grass , pavement , trees ) for each super pixel using * gaussian mixture model * ( * gmm * ) @xcite in conjunction with * loopy belief propagation * ( * lbp * ) @xcite .",
    "the gmm estimates the best label given the color and texture statistics in the super - pixel .",
    "the algorithm operates by connecting neighboring pixels in time and space into a large three - dimensional grid and uses lbp to smooth the local estimates .",
    "we combined the two algorithms so that coseg alternates between lbp to compute the label for each super - pixel given the current gmm and then updating the gmm given the labels from lbp .",
    "the graphlab data graph structure for video cosegmentation is the three dimensional grid graph ( see table  [ table : appinp ] ) .",
    "the vertex data stores the current label distribution as well as the color and texture statistics for each super - pixel .",
    "the edge data stores the parameters needed for the lbp algorithm .",
    "the parameters for the gmm are maintained using the sync operation .",
    "the graphlab update function executes the lbp local iterative update .",
    "we implement the state - of - the - art adaptive update schedule described by @xcite , where updates which are expected to change vertex values significantly are prioritized .",
    "we therefore make use of the locking engine with the approximate priority ordering task queue .",
    "furthermore , the graph has a natural partitioning by slicing across frames .",
    "this also allows feature processing of the video to be performed in an embarrassingly parallel fashion , permitting the use of hadoop for preprocessing .",
    "[ sec : coem ] named entity recognition ( ner ) is the task of determining the type ( e.g. , ` person ` , ` place ` , or ` thing ` ) of a * noun - phrase * ( e.g. , _ obama _ , _ chicago _ , or _ car _ ) from its * context * ( e.g. , _",
    "`` president _ _  '' _ , _ ``  lives near _ _ . '' _ , or _",
    "``  bought a _ _ . '' _ ) .",
    "ner is used in many natural language processing applications as well as information retrieval . in this application",
    "we obtained a large crawl of the web and we counted the number of occurrences of each noun - phrase in each context . starting with a small seed set of pre - labeled noun - phrases , the coem algorithm @xcite labels the remaining noun - phrases and contexts ( see table  [ tbl : coemwords ] ) by alternating between estimating the best assignment to each noun - phrase given the types of its contexts and estimating the type of each context given the types of its noun - phrases .",
    "the graphlab data graph for the ner problem is bipartite with vertices corresponding to each noun - phrase on one side and vertices corresponding to each context on the other .",
    "there is an edge between a noun - phrase and a context if the noun - phrase occurs in the context .",
    "the vertex for both noun - phrases and contexts stores the estimated distribution over types .",
    "the edge stores the number of times the noun - phrase appears in that context .",
    "the ner computation is represented in a simple graphlab update function which computes a weighted sum of probability tables stored on adjacent vertices and then normalizes .",
    "once again , the bipartite graph is naturally two colored , allowing us to use the chromatic scheduler . due to the density of the graph , a random partitioning",
    "since the ner computation is relatively light weight and uses only simple floating point arithmetic ; combined with the use of a random partitioning , this application stresses the overhead of the graphlab runtime as well as the network .",
    "[ sec : otherapplications ] in the course of our research , we have also implemented several other algorithms , which we describe briefly :    * gibbs sampling on a markov random field .",
    "* the task is to compute a probability distribution for a graph of random variables by sampling .",
    "algorithm proceeds by sampling a new value for each variable in turn conditioned on the assignments of the neighboring variables .",
    "strict sequential consistency is necessary to preserve statistical properties @xcite .",
    "* bayesian probabilistic tensor factorization ( bptf ) .",
    "* this is a probabilistic markov - chain monte carlo version of alternative least squares that also incorporates time - factor into the prediction . in this case , the tensor @xmath71 is decomposed into three matrices @xmath74 which can be represented in graphlab as a tripartite graph .",
    "in addition , graphlab has been used successfully in several other research projects like clustering communities in the twitter network , collaborative filtering for bbc tv data as well as non - parametric bayesian inference .",
    "[ sec : experiments ] we evaluated graphlab on the three applications ( netflix , coseg and ner ) described above using important large - scale real - world problems ( see table  [ table : appinp ] ) .",
    "we used the chromatic engine for the netflix and ner problems and the locking engine for the coseg application .",
    "equivalent hadoop and mpi implementations were also tested for both the netflix and the ner application .",
    "an mpi implementation of the asynchronous prioritized lbp algorithm needed for coseg requires building an entirely new asynchronous sequentially consistent system and is beyond the scope of this work .",
    "experiments were performed on amazon s elastic computing cloud ( ec2 ) using up to 64 high - performance cluster ( hpc ) instances ( ` cc1.4xlarge ` ) .",
    "the hpc instances ( as of february 2011 ) have 2 x intel xeon x5570 quad - core nehalem architecture with 22 gb of memory , connected by a low latency 10 gigabit ethernet network .",
    "all our timings include data loading time and are averaged over three or more runs .",
    "our principal findings are :    @xmath0    _ graphlab is fast ! _ on equivalent tasks , graphlab outperforms hadoop by 20x-60x and is as fast as custom - tailored mpi implementations .",
    "graphlab s performance scaling improves with higher computation to communication ratios .",
    "when communication requirements are high , graphlab can saturate the network , limiting scalability .",
    "the graphlab abstraction more compactly expresses the netflix , ner and coseg algorithms than mapreduce or mpi .",
    "[ sec : scaling ] in fig .",
    "[ fig : speedupmain ] we present the parallel speedup of graphlab when run on 4 to 64 hpc nodes .",
    "speedup is measured relative to the 4 hpc node running time . on each node",
    ", graphlab spawned eight shared memory engine threads ( matching the number of cores ) .",
    "of the three applications , coseg demonstrated the best parallel speedup , achieving nearly ideal scaling up to 32 nodes and moderate scaling up to 64 nodes .",
    "the excellent scaling of the coseg application can be attributed to its sparse data graph ( maximum degree 6 ) and a computationally intensive update function .",
    "while netflix demonstrated reasonable scaling up to 16 nodes , ner achieved only modest 3x improvement beyond 16x or more nodes .",
    "we attribute the poor scaling performance of ner to the large vertex data size ( 816 bytes ) , dense connectivity , and poor partitioning ( random cut ) which resulted in substantial communication overhead per iteration .",
    "[ fig : networkpernode ] shows for each application , the average number of bytes transmitted by each node per second as the cluster size is increased . beyond 16 nodes ,",
    "it is evident that ner saturates the network , with each machine sending at a rate of over 100 mb per second .",
    "note that fig .",
    "[ fig : networkpernode ] plots the _ average _ transmission rate and the peak rate could be significantly higher .",
    "to better understand the effect of the ratio between computation and communication on the scaling of the graphlab abstraction , we varied the computational complexity of the netflix experiment .",
    "the amount of computation performed in netflix can be controlled by varying @xmath70 : the dimensionality of the approximating matrices in eq .",
    "( [ eqn : als ] ) . in fig .",
    "[ fig : compcomplex ] we plot the speedup achieved for varying values of @xmath70 and the corresponding number of _ instructions per byte _ ( ipb ) of data accessed .",
    "the speedup at 64 nodes increases quickly with increasing ipb indicating that speedup is strongly coupled .",
    "[ sec : netflixandner ]    in this section , we compare our graphlab implementation of the netflix application and the ner application to an algorithmically equivalent hadoop and mpi implementations .",
    "* mapreduce / hadoop . *",
    "we chose to compare against hadoop , due to its wide acceptance in the machine learning community for large scale computation ( for example the mahout project @xcite ) .",
    "fair comparison is difficult since hadoop is implemented in java while ours is highly optimized c++",
    ". additionally , to enable fault tolerance , hadoop stores interim results to disk . in our experiments , to maximize hadoop s performance , we reduced the hadoop distributed filesystem s ( hdfs ) replication factor to one , eliminating fault tolerance .",
    "a significant amount of our effort was spent tuning the hadoop job parameters to improve performance .",
    "[ fig : alshadoop ] shows the running time for one iteration of netflix application on graphlab , hadoop and mpi ( @xmath75 for all cases ) , using between 4 and 64 nodes .",
    "the hadoop evaluation makes use of the of sebastian schelter contribution to the mahout project , while the mpi implementation was written from scratch .",
    "we find that graphlab performs the same computation between * 40x-60x * times faster than hadoop .",
    "[ fig : coemhadoop ] plots the running for one iteration of the ner application on graphlab , hadoop and mpi .",
    "the hadoop implementation was aggressively optimized : we implemented specialized binary marshaling methods which improve performance by 5x over a baseline implementation .",
    "[ fig : coemhadoop ] shows that the graphlab implementation of ner obtains a 20 - 30x speedup over hadoop .",
    "part of the performance of graphlab over hadoop can be explained by implementation differences , but it is also easy to see that the graphlab representation of both ner and als is inherently more efficient .",
    "for instance the case of ner , when implemented in hadoop , the map - function , normally the cornerstone of embarrassing - parallelism in mapreduce essentially does no work .",
    "the map only serves to emit the vertex probability table for every edge in the graph , which corresponds to over 100 gigabytes of hdfs writes occurring between the map and reduce stage . the cost of this operation can easily be multiplied by factor of three if hdfs replication is turned on .",
    "comparatively , the graphlab update function is simpler as users do not need to explicitly define the flow of information from the map to the reduce , but simply modifies data in - place . in the case of such iterative computation , graphlab s knowledge of the dependency structure",
    "allow modified data to be communicated directly to the destination .",
    "overall , we can attribute graphlab s superior performance over hadoop to the fact that the abstraction is a much better fit .",
    "it presents a simpler api to the programmer and through the data graph , and informs graphlab about the communication needs of the program .",
    "* in order to analyze the cost of using a higher level abstraction we implemented efficient versions of the netflix and ner applications using mpi . the implementations made use of synchronous mpi collective operations for communication .",
    "the final performance results can be seen in fig .",
    "[ fig : alshadoop ] and fig .",
    "[ fig : coemhadoop ] .",
    "we observe that the performance of mpi and graphlab implementations are similar and conclude that graphlab does not impose significant performance penalty .",
    "graphlab also has the advantage of being a higher level abstraction and is easier to work with .",
    "the coseg application makes use of dynamic prioritized scheduling which requires the locking engine ( sec .",
    "[ sec : lockingengine ] ) .",
    "to the best of our knowledge , there are no other abstractions which provide the dynamic asynchronous scheduling as well as the sequentially consistent sync ( reduction ) capabilities required by this application .    in fig .",
    "[ fig : speedupmain ] we demonstrate that the locking engine can provide significant scalability and performance on the large 10.5 million vertex graph used by this application , achieving a 10x speedup with 16x more machines .",
    "we also observe from fig .",
    "[ fig : weakscalability ] that the locking engine provides nearly optimal weak scalability .",
    "the runtime does not increase significantly as the size of the graph increases proportionately with the number of processors .",
    "we can attributed this to the properties of the graph partition where the number of edges crossing machines increases linearly with the number of processors , resulting in low communication volume .    in fig .",
    "[ fig : lockevaluation ] we further investigate the properties of the distributed lock implementation described in sec .",
    "[ sec : lockingengine ] .",
    "the evaluation is performed on a tiny 32-frame ( 192k vertices ) problem on a 4 node cluster .",
    "two methods of cutting the graph is explored .",
    "the first method is an  optimal partition \" where the frames are distributed evenly in 8 frame blocks to each machine .",
    "the second method is a `` worst case partition '' where the frames are striped across the machines ; this is designed to stress the distributed lock implementation since every scope acquisition is forced to acquire a remote lock .",
    "the maximum number of lock requests allowed in the pipeline is varied ( ` maxpending ` ) .",
    "the baseline evaluation is optimal partitioning with the ` maxpending ` set to zero .",
    "[ fig : lockevaluation ] demonstrates that on well - partitioned models , increasing the maximum number of pending locks from @xmath76 to @xmath77 increases performance significantly .",
    "however , we observe diminishing returns as ` maxpending ` is further increased to @xmath78 . on the other hand",
    "when the partitioning is poor , increasing the number of pending locks to @xmath78 improves performance significantly .      to help put costs in perspective , we plot a price - performance curve for the netflix application in fig .  [",
    "fig : ec2cost ] .",
    "the curve shows the cost one should expect to pay to obtain a certain desired performance level . to ensure interpretability of the curve , the cost assumes fine - grained billing even though amazon ec2 billing rounds up utilization time to the nearest hour .",
    "the curve has an `` * *",
    "l * * '' shape implying diminishing returns : as lower runtimes are desired , the cost of attaining those runtimes increases faster than linearly . as a comparison",
    ", we also provide the price - performance curve for hadoop on the same application .",
    "it is evident that for the netflix application , graphlab is about two orders of magnitude more cost - effective than hadoop .    fig .  [ fig : ec2accuracy ] is an interesting plot which the cost required to attain a certain degree of accuracy ( lower rmse is better ) on the netflix task using 32 hpc nodes .",
    "similarly the curve demonstrates diminishing returns : the cost of achieving lower test errors increase quickly .",
    "the lower bound of all four curves inform the reader with the  cheapest \" value of @xmath70 which attains the desired accuracy .",
    "[ sec : relatedwork ] perhaps the closest approach to our abstraction is * pregel * @xcite , which also computes on a user - defined data graph .",
    "the most important difference is that pregel is based on the bsp model @xcite , while we propose an asynchronous model of computation .",
    "parallel bgl @xcite is similar .",
    "* piccolo * @xcite shares many similarities to graphlab on an implementation level , but does not explicitly model data dependencies . sequential consistency of execution is also not guaranteed .",
    "* mapreduce * @xcite and * dryad * @xcite are popular distributed data - flow frameworks which are used extensively in data mining .",
    "the use of mapreduce for ml in multi - core setting was first made popular by chu et .",
    "@xcite in 2006 .",
    "such data - flow models can not express efficiently sparse dependencies or iterative local computation .",
    "there are several extensions to these frameworks , such as * mapreduce online * @xcite , * twister * @xcite , * nexus * @xcite and * spark * @xcite , but none present a model which supports sparse dependencies with asynchronous local computation .",
    "most notably , * surfer * @xcite extends mapreduce with a special primitive _ propagation _ for edge - oriented tasks in graph processing , but this primitive is still insufficient for asynchronous local computation .    recently ,",
    "work by * pearce * et .",
    "al @xcite proposed a system for asynchronous multithreaded graph traversals , including support for prioritized ordering .",
    "however , their work does does not address sequential consistency or the distributed setting .",
    "finally , * optiml * @xcite , a parallel programming language , for machine learning .",
    "we share their approach of developing domain specific parallel solutions .",
    "optiml parallelizes operations on linear algebra data structures , while graphlab defines a higher level model of parallel computation .",
    "[ sec : conclusion ] many important ml techniques utilize sparse computational dependencies , are iterative , and benefit from asynchronous computation .",
    "furthermore , sequential consistency is an important requirement which ensures statistical correctness and guarantees convergence for many ml algorithms .",
    "finally , prioritized ordering of computation can greatly accelerate performance .",
    "the graphlab abstraction we proposed allows the user to explicitly represent structured dependent computation and extracts the available parallelism without sacrificing sequential consistency .",
    "furthermore , graphlab s sync operation allows global information to be efficiently aggregated even as an asynchronous iterative algorithm proceeds .",
    "since the graph representation of computation is a natural fit for many ml problems , graphlab simplifies the design , implementation , and debugging of ml algorithms .",
    "we developed a highly optimized c++ distributed implementation of graphlab and evaluated it on three state - of - the - art ml algorithms using real data : collaborative filtering on the netflix dataset , named entity recognition , and video cosegmentation .",
    "the evaluation was performed on amazon ec2 using up to 512 processors in 64 hpc nodes .",
    "we demonstrated that graphlab outperforms hadoop ( a popular framework in the ml community ) by 20 - 60x , and is competitive with tailored mpi implementations .",
    "future work includes supporting dynamic and implicitly represented graphs , as well as support for graphs in external storage .",
    "the current implementation provides limited support for external storage through the use of * mmap*ed memory for vertex and edge data .",
    "there are interesting possibilities for the intelligent placement and caching of graph data to maximize performance @xcite .",
    "while the current graphlab implementation does not provide fault tolerance , relatively simple modifications could be made to support snapshotting capabilities .",
    "in particular , a globally consistent snapshot mechanism can be easily performed using the sync operation .",
    "additionally , we plan to extend graphlab to other architectures including gpus and supercomputers ."
  ],
  "abstract_text": [
    "<S> machine learning ( ml ) techniques are indispensable in a wide range of fields . </S>",
    "<S> unfortunately , the exponential increase of dataset sizes are rapidly extending the runtime of sequential algorithms and threatening to slow future progress in ml . with the promise of affordable large - scale parallel computing , </S>",
    "<S> cloud systems offer a viable platform to resolve the computational challenges in ml . </S>",
    "<S> however , designing and implementing _ efficient _ , _ provably correct _ distributed ml algorithms is often prohibitively challenging . </S>",
    "<S> to enable ml researchers to easily and efficiently use parallel systems , we introduced the graphlab abstraction which is designed to represent the computational patterns in ml algorithms while permitting efficient parallel and distributed implementations .    in this paper </S>",
    "<S> we provide a formal description of the graphlab parallel abstraction and present an efficient distributed implementation . </S>",
    "<S> we conduct a comprehensive evaluation of graphlab on three state - of - the - art ml algorithms using real large - scale data and a 64 node ec2 cluster of 512 processors . we find that graphlab achieves orders of magnitude performance gains over hadoop while performing comparably or superior to hand - tuned mpi implementations . </S>"
  ]
}