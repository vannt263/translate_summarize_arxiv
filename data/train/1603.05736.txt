{
  "article_text": [
    "arikan s polar codes @xcite form the first explicit family of binary codes that achieve the capacity of binary - input channels .",
    "polar codes rely on a remarkable phenomenon called channel polarization .",
    "after their introduction , both polar codes and the channel polarization concept have been used in a vast range of problems in information theory @xcite@xcite .",
    "a drawback of the original proposal of @xcite is that the construction of codes is not efficient because the alphabet of bit subchannels grows exponentially as a function of the number of iterations of the polarization procedure , resulting in an exponential complexity of construction .",
    "the difficulty of selecting subchannels for information transmission with polar codes was recognized early on in a number of papers . according to an observation made in @xcite , the construction procedure of polar codes for binary - input channels relies on essentially the same density evolution procedure that plays a key role in the analysis of low - density parity - check codes .",
    "it was soon realized that the proposal of @xcite requires increasing precision of the computations , but this paper paved way for later research on the construction problem .",
    "an important step was taken in @xcite which suggested to approximate each bit - channel after each evolution step by its degraded or upgraded version whose output alphabet size is constrained by a specified threshold @xmath1 that serves as a parameter of the procedure . as a result , @xcite put forward an approximation procedure that results in a code not too far removed from the ideal choice of the bit - channels of @xcite .",
    "this code construction scheme has a complexity of @xmath6 , where @xmath7 is the code length . for the channel degradation method described in @xcite ,",
    "an error analysis and approximation guarantees are provided in @xcite .",
    "another approximation scheme for the construction of binary codes was considered in @xcite .",
    "it is based on degrading each bit - channel after each evolution step , performed by merging several output symbols into one symbol based on quantizing the curve @xmath8 vs @xmath9 where @xmath10 is the conditional distribution of the `` reverse channel '' that corresponds to the bit - channel in question .",
    "symbols of the output alphabet that share the same range of quantization are merged into a single symbol of the approximating channel .",
    "yet another algorithm based on bit - channel upgrading was described in @xcite , in which the authors argue that it is possible to obtain a channel which is arbitrarily close to the bit - channel of interest in terms of the capacity .",
    "however , no error or complexity analysis is provided in this work .    moving to general input alphabets ,",
    "let us mention a code construction algorithm based on degrading the subchannels in each evolution step designed in @xcite .",
    "this algorithm involves a merging procedure of output symbols similarly to @xcite .",
    "however , as noted by the authors , their construction scheme is practical only for small values of input alphabet size @xmath4 , its efficiency constrained by the complexity of order @xmath11 paper @xcite proposed to perform the upgrading instead of degrading of the subchannels , but did not manage to reduce the implementation complexity . in @xcite ,",
    "the authors consider another channel upgrading method for nonbinary - input channels , but stop short of providing an explicit construction scheme or error analysis .",
    "papers @xcite addressed the construction problem of polar codes for awgn channels .",
    "these works are based on gaussian approximation of the intermediate likelihood ratios and do not analyze the error guarantees or rate loss of the obtained codes",
    ". a comparative study of various polar code constructions for awgn channel is presented in @xcite .",
    "some other heuristic constructions for binary - input channels similar to the cited results for the gaussian channel appear in @xcite .",
    "note also constructions of polar codes for some particular channels @xcite , for various transformation kernels @xcite , and concatenated codes @xcite .",
    "in this paper we present a construction method of polar codes for input alphabets of arbitrary size , together with explicit analysis of approximation error and construction complexity .",
    "in particular , the complexity estimate of our procedure grows as @xmath12 as opposed to @xmath13 in earlier works .",
    "our algorithm can be viewed as a generalization of the channel degradation method in @xcite to nonbinary input channels .",
    "although the approach and the proof methods here are rather different from earlier works , the estimate of the approximation error that we derive generalizes the error bound given by @xcite for the binary case .",
    "another interesting connection with the literature concerns a very recent result of @xcite which derives a lower bound on the alphabet size @xmath1 that is necessary to restrict the capacity loss by at most a given value @xmath14 this bound is valid for any approximation procedure that is based only on the degrading of the subchannels in each evolution step .",
    "the construction scheme presented here relies on the value @xmath1 that is not too far from this theoretical limit ( see proposition [ third_lemma ] for more details ) .",
    "we stress that we aim at approximating symmetric capacity of the channels , and do not attempt to construct or implement polar codes that attain shannon capacity , which is greater than the symmetric one for non - symmetric channels .",
    "our paper is organized as follows . in section [ prelim ]",
    "we give a brief overview of polar codes including various polarizing transformations for nonbinary alphabets .",
    "the rate loss estimate in the code construction based on merging pairs of output symbols in a greedy way is derived in section [ main ] . in section [ cyclic ]",
    "we argue that output symbols whose posterior probability vectors are cyclic shifts of each other can be merged with no rate loss .",
    "this observation enables us to formulate an improved version of the construction algorithm that further reduces the construction complexity .",
    "we have also implemented our algorithms and constructed polar codes for various nonbinary alphabets .",
    "these results are presented in section [ sim ] .",
    "for relatively small @xmath4 we can construct rather long polar codes ( for instance , going to length @xmath15 for @xmath16 takes several hours ) . for larger @xmath4 such as 16 we can reach lengths of tens of thousands within reasonable time and with low rate loss .",
    "even in this case , by increasing the gap to capacity of the resulting codes , we can reach lengths in the range of hundreds of thousands to a million without putting an effort in optimizing our software .",
    "we begin with a brief overview of binary polar codes .",
    "let @xmath17 be a channel with the output alphabet @xmath18 input alphabet @xmath19 and the conditional probability distribution @xmath20 throughout the paper we denote the capacity and the symmetric capacity of @xmath17 by @xmath21 and @xmath22 , respectively .",
    "we say @xmath17 is symmetric if @xmath23 can be obtained from @xmath24 through a permutation @xmath25 such that @xmath26 note that if @xmath17 is symmetric then @xmath27    for @xmath7 and @xmath28 , define the polarizing matrix ( or the arikan transform matrix ) as @xmath29 , where @xmath301&1\\end{array}\\hspace*{-.05in}\\big)$}}$ ] , @xmath31 is the kronecker product of matrices , and @xmath32 is a `` bit reversal '' permutation matrix @xcite . in @xcite , arikan showed that given a symmetric and binary input channel @xmath17 , an appropriate subset of the rows of @xmath33 can be used as a generator matrix of a linear code that achieves the capacity of @xmath17 as @xmath34 .    given a binary - input channel @xmath17 , define the channel @xmath35 with input alphabet @xmath36 and output alphabet @xmath37 by the conditional distribution @xmath38 where @xmath39 is the conditional distribution that defines @xmath17 .",
    "define a combined channel @xmath40 by the conditional distribution @xmath41 in terms of @xmath40 , the channel seen by the @xmath42-th bit @xmath43 ( also known as the bit - channel of the @xmath42-th bit ) can be written as @xmath44 we see that @xmath45 is the conditional distribution of @xmath46 given @xmath47 provided that the channel inputs @xmath48 are uniformly distributed for all @xmath49 .",
    "moreover , it is the case that @xcite the bit - channels @xmath45 can be constructed recursively using the channel transformations @xmath50 and @xmath51 , which are defined by the equations @xmath52    the bhattacharyya parameter @xmath53 of a binary - input channel @xmath17 is defined as @xmath54 the bit - channels defined in - are partitioned into good channels @xmath55 and bad channels @xmath56 based on the values of @xmath57 .",
    "more precisely , we have @xmath58 : z(w_i ) \\leq \\delta_n \\}\\\\ { \\mathscr b}_n ( w,\\beta)&= \\ { i\\in [ n ] : z(w_i )   >",
    "1-\\delta_n \\ } , \\end{aligned}\\ ] ] where @xmath59=\\{1,2,\\dots , n\\}$ ] and @xmath60 is a small number . as shown in @xcite , for any binary - input channel @xmath17 and any constant @xmath61 @xmath62 based on this equality , information can be transmitted over the good - bit channels while the remaining bits are fixed to some values known in advance to the receiver ( in polar coding literature they are called _ frozen bits _ ) . the transmission scheme can be described as follows : a message of @xmath63 bits is written in the bits @xmath64 the remaining @xmath65 bits are set to 0 .",
    "this determines the sequence @xmath66 which is transformed into @xmath67 and the vector @xmath68 is sent over the channel .",
    "denote by @xmath69 the sequence received on the output .",
    "the decoder finds an estimate of @xmath66 by computing the values @xmath70 as follows : @xmath71 the results of @xcite imply the following upper bound on the error probability @xmath72 @xmath73 where @xmath74 and @xmath75 is arbitrarily small .",
    "this describes the basic construction of polar codes @xcite which attains symmetric capacity @xmath22 of the channel @xmath17 with a low error rate . at the same time , , highlight the main obstacle in the way of efficiently constructing polar codes : the size of the output alphabet of the channels @xmath45 is of the order @xmath76 so it scales exponentially with the code length . for this reason ,",
    "finding a practical code construction scheme of polar codes represents a nontrivial problem .",
    "concluding the introduction , let us mention that the code construction technique presented below can be applied to any polarizing transform based on combining pairs of subchannels .",
    "there has been a great deal of research on properties of polarizing operations in general . in particular , it was shown in @xcite that holds true whenever the input alphabet size @xmath4 of the channel @xmath17 is a prime number , and @xmath50 and @xmath51 are defined as @xmath77 meaning that arikan s transform @xmath781&1\\end{array}\\hspace*{-.05in}\\big)$}}$ ] is polarizing for prime alphabets . for the case",
    "when @xmath4 is a power of a prime , it was proved in @xcite that there exist binary linear transforms different from @xmath79 that support the estimate in for some exponent @xmath80 that depends on @xmath79 .",
    "for example , @xcite shows that the transform @xmath81 is polarizing whenever @xmath82 is a primitive element of the field @xmath83 .",
    "paper @xcite considered the use of arikan s transform for the channels with input alphabet of size @xmath84 , showing that the symmetric capacities of the subchannels converge to one of @xmath85 integer values in the set @xmath86    even more generally , necessary and sufficient conditions for a binary operation @xmath87 given by @xmath88 to be a polarizing mapping were identified in @xcite .",
    "a simple set of _ sufficient _ conditions for the same was given in @xcite , which also gave a concrete example of a polarizing mapping for an alphabet of arbitrary size @xmath89 according to @xcite , in one can take @xmath90 in the form @xmath91 , where @xmath92 is the following permutation : @xmath93 we include experimental results for code construction using the transforms and in sect .",
    "[ sim ] .    finally recall that it is possible to attain polarization based on transforms that combine @xmath94 subchannels .",
    "in particular , polarization results for transformation kernels of size @xmath95 with @xmath96 for binary - input channels were studied in @xcite . apart from that ,",
    "@xcite derived estimates of the error probability of polar codes for nonbinary channels based on transforms defined by generator matrices of reed - solomon codes . however , below we will restrict our attention to binary combining operations of the form discussed above .",
    "in the algorithm that we define , the subchannels are constructed recursively , and after each evolution step the resultant channel is replaced by its degraded version which has an output alphabet size less than a given threshold @xmath1 . in general terms , this procedure is described in more detail is described as follows .    * input : * dmc @xmath17 , bound on the output size @xmath1 , code length @xmath7 , channel index @xmath42 with binary representation    @xmath97    * output : * a dmc obtained from the subchannel @xmath45 .",
    "@xmath98 @xmath99 * else * @xmath100 @xmath101 * return * @xmath102    before proceeding further we note that @xmath103 and @xmath104 appearing in algorithm [ euclid ] can be any transformations that produce combined channels for the polarization procedure .",
    "the possibilities range from arikan s transform to the schemes discussed in the end of section [ prelim ] .",
    "the next step is to define the function @xmath105 in such a way that it can be applied for general discrete channels .",
    "ideally , the degrading - merge operation should optimize the degraded channel by attaining the smallest rate loss over all @xmath106 @xmath107 equation defines a convex maximization problem , which is difficult to solve with reasonable complexity . to reduce the computational load",
    ", @xcite proposed the following approximation to : replace @xmath108 by a single symbol if the pair @xmath109 gives the minimum loss of capacity among all pairs of output symbols , and repeat this as many times as needed until the number of the remaining output symbols is equal to or less than @xmath1 ( see algorithm c in @xcite ) . in @xcite",
    "this procedure was called _ greedy mass merging_. in the binary case this procedure can be implemented with complexity @xmath6 because one can check only those pairs of symbols @xmath110 which are closest to each other in terms of the likelihood ratios ( see theorem 8 in @xcite ) .",
    "this simplification does not generalize to the channels with nonbinary inputs , meaning that we need to inspect all pairs of symbols .",
    "since the total number of pairs is @xmath111 after each evolution step , the overall complexity of the greedy mass merging algorithm for nonbinary input alphabets becomes @xmath112 .",
    "for a channel @xmath113 define @xmath114 for all @xmath115 and @xmath116 for a subset @xmath117 define @xmath118    in the following lemma we establish an upper bound on the rate loss of the greedy mass merging algorithm for nonbinary input alphabets .",
    "let @xmath119 be a discrete memoryless channel and let @xmath120 be two output symbols .",
    "let @xmath121 be the channel obtained from by @xmath17 by merging @xmath122 and @xmath123 which has the transition probabilities @xmath124 then @xmath125    [ first_lemma ]    since @xmath126 is degraded with respect to @xmath17 , we clearly have that @xmath127 where @xmath128 is the symmetric capacity . to prove the upper bound for @xmath129 in let @xmath130 be the random variable uniformly distributed on @xmath131 , and let @xmath132 be the random output of @xmath17 .",
    "then we have @xmath133 - \\big ( h(x ) -&h(x|y\\in\\{y_1,y_2\\ } ) ( p_y(y_1)+p_y(y_2))-   \\!\\!\\!\\!\\!\\!\\!\\ ! \\sum_{y\\in{\\mathscr y}\\backslash \\{y_1,y_2\\ } } \\!\\!\\!\\!\\!\\!\\!\\ !",
    "h(x|y = y ) p_y(y ) \\big )      \\nonumber\\\\[.1 in ] & = h(x|y\\in\\{y_1,y_2\\ } ) ( p_y(y_1)+p_y(y_2))\\nonumber\\\\&\\hspace*{1in}- h(x| y = y_1 ) p_y(y_1)- h(x|y = y_2 ) p_y(y_2 ) .",
    "\\label{ineq1 }      \\end{aligned}\\ ] ] next we have @xmath134 where @xmath135 .",
    "hence , it follows from that @xmath136 \\\\      & \\times\\log_2 \\frac{1}{\\alpha_{12 } p_w ( x|y_1)+ ( 1-\\alpha_{12 } ) p_w ( x|y_2 ) } \\\\      & - p_y(y_1 ) \\sum_{x\\in{\\mathscr x } } p_w ( x|y_1 ) \\log_2 \\frac{1}{p_w ( x|y_1 ) } - p_y(y_2 ) \\sum_{x\\in{\\mathscr x } } p_w ( x|y_2 ) \\log_2 \\frac{1}{p_w ( x|y_2)}.       \\end{aligned}\\ ] ] rearranging the terms , we obtain @xmath137 next use the inequality @xmath138 to write @xmath139 which simplifies to @xmath140 bound the first term in using the inequality @xmath141 and do the same for the second term .",
    "we obtain the estimate    @xmath142    this completes the proof of .    the bound brings in metric properties of the probability vectors .",
    "leveraging them , we can use simple volume arguments to bound the rate loss due to approximation .    let the input and output alphabet sizes of @xmath17 be @xmath4 and @xmath143 , respectively .",
    "then , there exists a pair of output symbols @xmath110 such that    @xmath144    which implies the estimate @xmath145 [ second_lemma ]    consider the subset of output symbols @xmath146 noticing that @xmath147 , we conclude that @xmath148 keeping in mind the bound , let us estimate the maximum value of the quantity @xmath149 for each @xmath150 , the vector @xmath151 is an element of the probability simplex @xmath152 let @xmath153 be a number less than the quantity in . clearly , for any @xmath154",
    "the @xmath4-dimensional @xmath155-balls of radius @xmath156 centered at @xmath157 are disjoint , and therefore , so are their intersections with @xmath158 let @xmath159 be the @xmath160-dimensional volume of @xmath161 .",
    "it is easily seen that @xmath162 but in this proof we will stay with crude bounds ( a more precise calculation is performed in the remark below ) .",
    "clearly for any @xmath163 @xmath164 on account of we obtain that @xmath165 whence @xmath166 for all @xmath167 less than the quantity in .",
    "hence , we see that there exist two output symbols @xmath168 such that the conditions , hold simultaneously .",
    "so if these symbols are merged in the algorithm discussed , the rate loss is bounded above as in .",
    "this lemma leads to an important conclusion for the code construction : to degrade the subchannels we should merge the symbols @xmath169 with small @xmath170 and such that the reverse channel conditional pmfs @xmath157 are @xmath155-close .",
    "performing this step several times in succession , we obtain the operation called ` degrade ` in the description of algorithm  [ euclid ] .",
    "the properties of this operation are stated in the following proposition .",
    "let @xmath17 be a dmc with input of size @xmath4 .",
    "+ ( a ) there exists a function ` degrade`@xmath171 such that its output channel @xmath102 satisfies @xmath172 ( b ) for a given block length , let @xmath173 be the @xmath42-th subchannel after @xmath174 evolution steps of the polarization recursion .",
    "let @xmath175 denote the its approximation returned by algorithm [ euclid ] .",
    "then @xmath176 [ third_lemma ]    let @xmath143 be the cardinality of the output alphabet of @xmath17 .",
    "performing @xmath177 merging steps of the output symbols in succession , we obtain a channel with an output alphabet of size @xmath1 .",
    "if the pairs of symbols to be merged are chosen based on lemma [ second_lemma ] , then implies that @xmath178 where @xmath179 is a constant which depends on the input alphabet size @xmath4 but not on the number @xmath174 of recursion steps .",
    "this proves , and follows immediately .",
    "this result provides a generalization to the nonbinary case of a result in @xcite which analyzed the a merging ( degrading ) algorithm of @xcite . for the case of binary - input channels ,",
    "lemma 1 of @xcite gave an estimate @xmath180 of the approximation error .",
    "substituting @xmath181 in , we note that this result is a generalization of @xcite to channels with arbitrary finite - size input .",
    "upper bounds similar to are derived in ( * ? ? ?",
    "* lemma 6 ) and ( * ? ? ?",
    "* lemma 8) .",
    "the output symbol merging policy in @xcite makes it possible to have @xmath182 . on the other hand ,",
    "the channel upgrading technique introduced in @xcite gives the same bound as .",
    "recall that the code construction schemes considered in those two works have complexity @xmath183 .",
    "it is interesting to observe that merging a pair of output symbols at each step as we do here is as good as the algorithms based on binning of output symbols which requires a higher complexity .",
    "a very recent result of @xcite states that any construction procedure of polar codes construction based on degrading after each polarization step , that guarantees the rate loss bounded as @xmath184 necessarily has the output alphabet of size @xmath185 proposition [ third_lemma ] implies that the alphabet size of the algorithm that we propose scales as the square of this bound , meaning that the proposed procedure is not too far from being optimal , namely for any channel , our degradation scheme satisfies @xmath186 , and there exists a channel for which @xmath187 holds true even for the optimal degradation scheme .",
    "a heuristic calculation related to : some of the implicit constants in the calculation that leads to in the proof of lemma [ second_lemma ] can be removed using the following ( heuristic ) geometric argument .",
    "let @xmath188 be the regular @xmath4-dimensional simplex whose `` outer '' face is @xmath158 consider the intersection of the @xmath4-dimensional balls with @xmath189 rather than @xmath161 .",
    "the volume of this intersection is the smallest when the center of the ball is located at a vertex of @xmath189 .",
    "let @xmath190 be the volume of the @xmath191-ball of radius @xmath167 in @xmath4 dimensions . computing a crude estimate for the number of simplices that share a common vertex , note that they all fit in the @xmath192 sphere of radius @xmath193 ,",
    "so their number is at most @xmath194 assuming that the volume of the @xmath155-ball around the vertex is shared equally between these simplices , we estimate the volume of the intersection to be @xmath195 using a packing argument similar to , we obtain @xmath196 which gives @xmath197 where @xmath198 .",
    "this calculation results in a bound slightly weaker than the one in , but contains no implicit constants .",
    "throughout this section we will use the transformation - , in which the  @xmath199 \" is addition modulo @xmath89 we discuss a way to further reduce the complexity of the code construction algorithm using the additive structure on @xmath200 as shown in , the symmetric capacity loss is small if the posterior distributions induced by the merged symbols are @xmath155-close . here",
    "we argue that if these vectors are related through cyclic shifts , the output symbols can be merged at no cost to code performance .",
    "consider the construction of @xmath4-ary polar codes for channels with input alphabet @xmath201 since @xmath202 to construct polar codes it suffices to track the values of @xmath203 for the transformed channels .",
    "keeping in mind that @xmath204 let us write the polarizing transformation in terms of the reverse channel @xmath205 @xmath206 if @xmath207 is uniform , both @xmath208 and @xmath209 are also uniform .",
    "consequently , the transformation is the same as - under the uniform prior distributions . throughout this section",
    "we will calculate the transformation of probability distributions using instead of - since we rely on the posterior distributions to merge symbols .    given a distribution @xmath210 on @xmath211",
    "define an _ equivalence relation _ on @xmath212 as follows : @xmath213 if for every @xmath115 there exists @xmath214 such that @xmath215 this defines a partition of @xmath212 into a set of equivalence classes @xmath216    we show that if @xmath217 then we can merge @xmath122 and @xmath123 into one alphabet symbol without changing @xmath203 for all @xmath218 , @xmath219 and all @xmath220 . as a consequence ,",
    "it is possible to assign one symbol to each equivalence class , i.e. , the effective output alphabet of @xmath17 for the purposes of code construction is formed by the set @xmath221 .    to formalize this intuition",
    ", we need the following definitions .",
    "[ quid ] consider a pair of distributions @xmath222 we say that two subsets of output alphabets @xmath223 are in correspondence , denoted @xmath224 , if    \\(1 ) @xmath225 ;    \\(2 ) for every @xmath226 and @xmath227 and every @xmath115 there exists @xmath214 such that @xmath228 ( the value of @xmath229 may depend on @xmath122 and @xmath123 ) .    note that condition ( 2 ) in this definition implies that all the elements in @xmath230 are in the same equivalence class , and all the elements in @xmath231 are also in the same equivalence class .",
    "[ def : eq ] we call the distributions @xmath232 _ equivalent _ , denoted @xmath233 , if there is a bijection @xmath234 such that @xmath235 for every equivalence class @xmath236    note that two equivalent distributions have the same @xmath237    the following proposition underlies the proposed speedup of the polar code construction .",
    "its proof is computational in nature and is given in the appendix .",
    "[ thm : simeq ] let @xmath232 be two distributions . if @xmath233 then for all @xmath238 we have @xmath239 ( and therefore @xmath240 ) .",
    "the next proposition provides a systematic way to merge output symbols of the synthesized channels obtained by the ` @xmath199 ' transformation .",
    "[ novak ] let distribution @xmath210 on @xmath241 and let @xmath242 and @xmath243 be defined as in .",
    "for every @xmath244 we have @xmath245 where if @xmath246 then @xmath247    for every @xmath248 and any @xmath249 we have @xmath250 this proves .    using the above considerations",
    ", we can reduce the time needed to construct a polar code .",
    "the informal description of the algorithm is as follows . given a dmc @xmath251 we calculate a joint distribution @xmath210 on @xmath252 by assuming a uniform prior on @xmath200 we then use to recursively calculate @xmath253 and after each step of the recursion we reduce the output alphabet size by assigning one symbol to the whole equivalence class .",
    "namely , for each equivalence class @xmath230 in the output alphabet @xmath254 we set @xmath255 and @xmath256 for an arbitrarily chosen @xmath257 note that @xmath258 can be chosen arbitrarily because the vectors @xmath259 are cyclic shifts of each other . by prop .",
    "[ thm : simeq ] , we have @xmath260 i.e. , the alphabet reduction entails no approximation of the capacity values .",
    "let us give an example , which shows that this simple proposal can result in a significant reduction of the size of the output alphabet .",
    "let @xmath17 be a _",
    "@xmath4-ary symmetric channel _ ( @xmath4sc ) @xmath251 @xmath261 @xmath262 and",
    "let us take @xmath263 consider the channels @xmath264 obtained by several applications of the recursion - .",
    "the actual output alphabet size of the channels @xmath265 and @xmath266 is @xmath267 and @xmath268 respectively . at the same time , the effective output alphabet size of @xmath265 and @xmath266 obtained upon merging the equivalence classes in @xmath212 is no more than @xmath269 and @xmath270 in particular , the effective output alphabet size of @xmath266 is less than a @xmath271-th fraction of its actual output alphabet size .",
    "let @xmath272 and @xmath273 if @xmath274 starts with @xmath275 then the effective output alphabet size of @xmath276 is less than a @xmath277-th fraction of its actual alphabet size .",
    "now we are ready to describe the improved code construction scheme .",
    "[ thm : simeq ] implies that if the vectors @xmath278 are cyclic shifts of each other , merging them into one symbol @xmath279 incurs no rate loss .",
    "extending this intuition , we assume that performing greedy mass merging using all the cyclic shifts of these vectors improves the accuracy of the approximation .    given a dmc @xmath251 we calculate a joint distribution @xmath210 on @xmath252 by assuming the uniform prior on @xmath280 and taking @xmath17 as the conditional probability .",
    "we then use to recursively calculate @xmath281 and after each step of transformation :    \\(1 ) if the last step in @xmath274 is @xmath199 : first use the ` mergepair ` function below to merge the symbols @xmath282 and @xmath283 for all @xmath284 then use the ` degrade ` function below on @xmath285    \\(2 ) if the last step in @xmath274 is @xmath286 , use the ` degrade ` function below on @xmath285    the function ` mergepair`@xmath287 is defined as follows : form the alphabet @xmath288 putting @xmath289 for all @xmath115 and @xmath290 and @xmath291    due to the concavity of the entropy function ( * ? ? ?",
    "2.7.3 ) , @xmath203 can only increase after calling the ` mergepair ` function .",
    "* input : * distribution @xmath292 over @xmath293 the target output alphabet size @xmath294    * output : * distribution @xmath295 over @xmath241 where @xmath296    @xmath297 @xmath298 @xmath299 @xmath300 @xmath301 * return * @xmath302    the function ` choose`@xmath303 is defined as follows .",
    "find the triple @xmath169 and @xmath304 such that the change of conditional entropy @xmath305 incurred by the merge @xmath306 using ` mergepair`@xmath287 @xmath307 is the smallest among all the triples @xmath308 .",
    "the main difference between algorithm  [ alg2 ] and the ordinary greedy mass merging algorithm discussed in sect .",
    "[ main ] ( e.g. , algorithm c in @xcite ) can be described as follows . in order to select a pair of symbols that induces the smallest increase of @xmath309 algorithm  [ alg2 ] considers all the cyclic shifts of the posterior distributions of pairs of symbols , while the `` ordinary '' greedy mass merging algorithm examines only the distributions themselves . as argued above , this is the reason that algorithm [ alg2 ] leads to a smaller rate loss than algorithm [ euclid ] .",
    "note that to perform the ` + ' transformation , we first use to merge pairs of symbols with cyclically shifted posterior vectors and then switch to greedy mass merging . in doing so , we incur a smaller rate loss because the number of steps of approximation performed for algorithm  [ alg2 ] is only half the number of steps performed in algorithm [ euclid ] .",
    "moreover , since provides a systematic way of merging symbols with cyclically shifted distributions , ( in other words , we do not need to search all the pairs in order to find them , ) the running time of algorithm [ alg2 ] is also reduced from that of algorithm [ euclid ] .",
    "this intuition is confirmed in our experiments which show that the overall gap to capacity of the constructed codes is smaller than the one attained by using the basic greedy mass merging , while the time taken by the algorithm is reduced from greedy mass merging alone .",
    "more details about the experiments are given in sect .",
    "[ sim ] .",
    "we also note that prop .",
    "[ thm : simeq ] remains to be valid when the alphabet is a finite field @xmath310 and arikan s transform @xmath3111&1\\end{array}\\hspace*{-.05in}\\big)$}}$ ] is replaced by the transform given by .",
    "this fact is stated in the proposition below .",
    "its proof is similar to prop .",
    "[ thm : simeq ] and will be omitted .",
    "let @xmath312 and let @xmath232 be two distributions . if @xmath233 then for all @xmath238 we have @xmath239 ( and therefore @xmath240 ) .",
    "there are several options of implementing the alphabet reduction procedures discussed above .",
    "the overall idea is to perform cyclic merging ( with no rate loss ) and then greedy mass merging for every subchannel in every step @xmath220 of the recursion .",
    "greedy mass merging ( the function ` degrade ` of algorithm 1 ) calls for finding a pair of symbols @xmath169 whose merging minimizes the rate loss @xmath313 which can be done in time @xmath314 in practice this may be too slow , so instead of optimizing we can merge the first pair of symbols for which the rate loss is below some chosen threshold @xmath315 it is also possible to merge pairs of symbols based on the proximity of probabilities on the rhs of .    note also that greedy mass merging can be applied to any binary polarizing operation including those described in sect .",
    "[ prelim ] .",
    "we performed a number of experiments using addition modulo @xmath4 , the finite field polarization @xmath316 and a polarizing operation from @xcite .",
    "a selection of results appears in fig .",
    "[ fig1 ] . in examples 1 - 3",
    "we construct polar codes for the @xmath4-ary symmetric channel and the 16 qam channel , showing the distribution of capacities of the subchannels . in examples 4 - 6",
    "we apply different polarizing transforms to a channel @xmath17 with inputs @xmath317 and outputs @xmath318 where @xmath319 can be 0 or 1 .",
    "the transitions are given by @xmath320 for all @xmath321 .",
    "following @xcite , we call @xmath17 an _ ordered erasure channel_. one can observe that under the addition modulo - q transform - the channel polarizes to several extremal configurations , while under the transforms given in , it converges to only two levels .",
    "this behavior , predicted by the general results cited in section [ prelim ] , supports the claim that the basic algorithm of sect .",
    "[ main ] does not depend on ( is unaware of ) the underlying polarizing transform .",
    "more details about the experiments are provided in the captions to fig .",
    "[ fig1 ] .",
    "it is interesting to observe that the @xmath4-ary symmetric channel for @xmath5 polarizes to two levels under arikan s transform . in principle",
    "there could be 5 different extremal configurations , and it is a priori unclear that no intermediate levels arise in the limit . an attempt to prove this fact",
    "was previously made in @xcite , but no complete proof is known to this date .",
    "2.1 in   and @xmath322 ( in these examples qsc is a @xmath4-ary symmetric channel defined in ) . in examples 4 - 6",
    "we apply different polarizing transforms , showing convergence to different number of extremal configurations for the same channel ( here oec is the ordered erasure channel , see ) , title=\"fig:\",width=192 ]    2.1 in    2.1 in     +    2.1 in   and @xmath322 ( in these examples qsc is a @xmath4-ary symmetric channel defined in ) . in examples 4 - 6",
    "we apply different polarizing transforms , showing convergence to different number of extremal configurations for the same channel ( here oec is the ordered erasure channel , see ) , title=\"fig:\",width=182 ]    2.1 in   and @xmath322 ( in these examples qsc is a @xmath4-ary symmetric channel defined in ) . in examples 4 - 6 we apply different polarizing transforms , showing convergence to different number of extremal configurations for the same channel ( here oec is the ordered erasure channel , see ) , title=\"fig:\",width=182 ]    2.1 in   and @xmath322 ( in these examples qsc is a @xmath4-ary symmetric channel defined in ) . in examples 4 - 6",
    "we apply different polarizing transforms , showing convergence to different number of extremal configurations for the same channel ( here oec is the ordered erasure channel , see ) , title=\"fig:\",width=182 ]    next we give some simulation results to support the conclusions drawn for algorithm 2 .",
    "we construct polar codes of several block lengths for @xmath4sc @xmath17 with @xmath323 and @xmath324 setting the threshold @xmath325 the capacity of the channel equals @xmath326    [ cols=\"^,^,^,^,^,^,^ \" , ]     in the second table @xmath3 is the code length , @xmath327 is the running time of algorithm a in @xcite , and @xmath328 is the running time of our algorithm in seconds .",
    "our algorithm indeed is about 7 times faster , and the codes constructed in both cases are exactly the same .",
    "we considered the problem of constructing polar codes for nonbinary alphabets .",
    "constructing polar codes has been a difficult open question since the introduction of the binary polar codes in @xcite .",
    "ideally , one would like to obtain an explicit description of the polar codes for a given block length , but this seems to be beyond reach at this point . as an alternative , one could attempt to construct the code by approximating each step of the recursion process . for binary codes , this has been done in @xcite,@xcite , but extending this line of work to the nonbinary case was an open problem despite several attempts in the literature .",
    "we take this question one step closer to the solution by designing an algorithm that approximates the construction for moderately - sized input alphabets such as @xmath329 the algorithm we implement works for both binary and non - binary channels with complexity @xmath12 , where @xmath3 is the blocklength and @xmath1 is the parameter that limits the output alphabet size .",
    "furthermore , the error estimate the we derive generalizes the estimate of @xcite to the case of nonbinary input alphabets ( but relies on a different proof method ) .",
    "it is also interesting to note that the error is rather close to a _ lower bound _ for this type of construction algorithms , derived recently in @xcite .",
    "apart from presenting a theoretical advance , this algorithm provides a useful tool in the analysis of properties of various polarizing transforms applied to nonbinary codes over alphabets of different structure .",
    "the proposed construction algorithm also brings nonbinary codes closer to practical applications , which is another promising direction to be explored in the future .",
    "we will show that if @xmath330 then @xmath331 and @xmath332 which will imply the full claim by induction on @xmath333 + ( a ) ( the ` @xmath286 ' case ) the distributions @xmath334 and @xmath335 are defined on the sets @xmath336 and @xmath337 respectively . in order to prove that @xmath338 we need to show that for every @xmath339 we have @xmath340 indeed , @xmath341 similarly , @xmath342 since @xmath343 and @xmath344 we have @xmath345 and @xmath346 therefore , @xmath347 thus @xmath348 and @xmath349 satisfy condition ( 1 ) in def .",
    "[ quid ] .    to prove condition",
    "( 2 ) , choose @xmath350 and let @xmath351 and @xmath352 by def .",
    "[ quid ] , there exist @xmath229 and @xmath353 such that @xmath354 and @xmath355 for all @xmath356 thus @xmath357 where @xmath358 .",
    "therefore , @xmath359 and @xmath360 + ( b ) .",
    "( _ the ` @xmath199 ' case _ ) the distribution @xmath361 and @xmath362 are over @xmath363 and @xmath364 respectively . similarly to case ( a ) above , we will show that for every @xmath365 there exist permutations @xmath366 and @xmath367 on @xmath280 such that for every @xmath368 @xmath369 to show this , fix @xmath365 and choose some @xmath370 @xmath351 and @xmath352 by def .",
    "[ quid ] , for every @xmath371 there exist @xmath372 and @xmath373 such that @xmath374 for @xmath371 define permutations @xmath375 as @xmath376 and @xmath377 we compute @xmath378 similarly , @xmath379 the last two equations imply that @xmath380 which verifies condition ( 2 ) in def .",
    "let us check that condition ( 1 ) is satisfied as well .",
    "we have @xmath381 and @xmath382 by assumption @xmath383 and @xmath384 so this proves that @xmath385 thus for every @xmath368 @xmath369 the proof is complete ."
  ],
  "abstract_text": [
    "<S> it is known that polar codes can be efficiently constructed for binary - input channels . at the same time , existing algorithms for general input alphabets are less practical because of high complexity . </S>",
    "<S> we address the construction problem for the general case , and analyze an algorithm that is based on successive reduction of the output alphabet size of the subchannels in each recursion step . for this procedure </S>",
    "<S> we estimate the approximation error as @xmath0 where @xmath1 is the `` quantization parameter , '' i.e. , the maximum size of the subchannel output alphabet allowed by the algorithm . the complexity of the code construction scales as @xmath2 where @xmath3 is the length of the code .    we also show that if the polarizing operation relies on modulo-@xmath4 addition , it is possible to merge subsets of output symbols without any loss in subchannel capacity . performing this procedure before each approximation step results in a further speed - up of the code construction , and the resulting codes have smaller gap to capacity . we show that a similar acceleration can be attained for polar codes over finite field alphabets .    </S>",
    "<S> experimentation shows that the suggested construction algorithms can be used to construct long polar codes for alphabets of size @xmath5 and more with acceptable loss of the code rate for a variety of polarizing transforms .    * </S>",
    "<S> _ _ * index terms : channel degrading , greedy symbol merging , polarizing transforms . </S>"
  ]
}