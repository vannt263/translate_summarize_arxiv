{
  "article_text": [
    "the grafalgo library uses _ index - based data structures_. these are data structures in which the items of interest are represented by integers in a restricted range . for example , in a graph , we identify vertices by vertex numbers and edges by edge numbers .",
    "index - based data structures have some advantages over data structures that use pointers ( or object references ) to identify the objects of interest .",
    "one key advantage is that the same integer index values can be used in several related data structures .",
    "for example , in some applications it s useful to define several graphs on the same vertex set .",
    "if all graphs use the same vertex numbers , it easy to relate the vertices in the different graph objects . using pointer - based data structures , we would need some other explicit mechanism to relate the vertex objects in one graph to the corresponding vertex objects in another .",
    "this can certainly be done , but it s cumbersome when compared to the use of shared index values .",
    "the use of indexes also makes it easy to associate properties of interest with the vertices or edges of a graph .",
    "these can simply be stored in separate tables , indexed by the same vertex and edge numbers used in the graph .",
    "index - based data structures also allow some operations to be implemented more efficiently than they can be using the equivalent pointer - based data structures .",
    "let s illustrate this with a simple index - based list , defined on the index set @xmath0 .",
    "such a list can represent any subset of the index set , with the indexes arranged in any order .",
    "it is implemented by a simple array called _",
    "next_. for any index @xmath1 in the list , @xmath2 $ ] is the next index in the list following @xmath1 , or 0 if @xmath1 is the last index in the list . for any index @xmath1",
    "that is not currently in the list , we define @xmath2=-1 $ ] .",
    "figure  [ indexlist ] shows how the list [ 7 , 5 , 3 , 8 , 2 ] is represented .",
    "note that this representation allows us to implement a constant - time membership test for index - values in the list , while a conventional list representation requires linear time . to iterate through a list",
    ", we use the _ first _ and _ next _ methods .    ....    for ( index x = alist.first ( ) ; x ! = 0 ;",
    "x = alist.next(x ) ) { .. } ....    we frequently use this data structure to represent a list of vertices in a graph . in this case , the index values in the list object correspond directly to the vertex numbers in the graph .",
    "grafalgo implements this data structure as the _ list _ class .",
    "there is also a doubly - linked version , called _",
    "list_d_.    now , one might well object that these lists are limited , in that they do not allow values to appear more than once in a given list .",
    "morever , the size of the object must be as large as its largest index , which may be considerably larger than the number of items in the list .",
    "these are certainly valid points , and for those situations where these drawbacks are significant , grafalgo provides a more generic list data structure called _",
    "list_g_. this is a template - based data structure , allowing one to construct lists of arbitrary items .",
    "grafalgo also includes a data structure that represents a set of disjoint lists on the underlying index set .",
    "each non - empty list has a distinguished index called its _",
    "identifier_. the data structure is implemented using two arrays _ next _ and _",
    "prev_. for each index @xmath1 , @xmath2 $ ] is the next index in the list containing @xmath1 ( or 0 if @xmath1 is the last index in the list ) , while @xmath3 $ ] is the previous index in the list containing @xmath1 ( or , the last index if @xmath1 is the first ) .",
    "an example , representing the collection @xmath4,[2,7],[4],[5,10,12],[8],[9,11]\\}$ ] is shown in figure  [ dlists ] .",
    "note that every index in the index set belongs to some list , although some of these lists are singletons .",
    "this data structure is implemented by the _ dlists _ class .",
    "now , let s look at the representation of the _ graph _ class used to represent undirected graphs .",
    "an example is shown in figure  [ graph ] .",
    "the diagram at the top left shows the five vertices in the graph ( identified by letters rather than integer indexes ) along with the edges ( identified by edge numbers ) .",
    "we also associate two edge _ endpoint numbers _ with each edge .",
    "specifically , edge @xmath5 has endpoints numbered @xmath6 and @xmath7 .",
    "the diagram includes these endpoint numbers and shows how they are distributed among a set of adjacency lists ( for example , the list for vertex @xmath8 is [ 2 , 7 , 4 ] , corresponding to the three edges 1 , 3 and 2 that are incident to @xmath8 ) .",
    "the adjacency lists are implemented by a _",
    "dlists _ object that partitions the endpoint numbers among the adjacency lists .",
    "a _ first endpoint _",
    "array identifies the first endpoint for each vertex .",
    "finally , we have an array that identifies the left and right endpoints of each edge .",
    "we can iterate through the vertices and edges of a graph as follows .    ....    for ( vertex u = 1 ; u < = g.n ( ) ; u++ ) {        for ( edge e = g.firstat(u ) ; e ! = 0 ; e = g.nextat(u,e ) {            ...        }    } ....    the _ graph _ class also includes methods for iterating through all the edges of the graph , and methods for creating and removing edges .",
    "all data structures in grafalgo include a _ tostring _ method that produces a printable representation of the data structure ( for example , the string `` [ 13 30 22 ] '' is the string represention of a _ list _ object for indexes 13 , 30 and 22 ) .",
    "all the data structures in the library also define a stream output operator .",
    "so for example ,    ....      cout",
    "< < mygraph ; ....    converts the object mygraph to a string and sends it to the standard output stream .    for small instances of a data structure , the _ tostring _",
    "method converts index values to lower - case letters .",
    "so for example , the list [ 1 , 3 , 4 ] is shown as the string `` [ _ a c d _ ] '' , and the graph in the earlier example is shown as    ....      {      [ a : b c d ]      [ b : a e ]      [ c : a d ]      [ d : a c e ]      [ e : b d ]      } ....    here , each line represents the adjacency list of the vertex listed before the ` : ' and the remaining vertices are its neighbors ( neighbors are listed repeatedly when there are multiple edges joining the same vertices ) .",
    "letters are used in place of numeric indexes for any data structure defined on an index set @xmath0 , where @xmath9 .",
    "this makes small examples easier for human readers to understand , especially for data structures that include other numeric data , such as edge weights or key values . for data structures using larger index sets ,",
    "the numeric index values are used in the string representation .",
    "the objective of the minimum spanning tree problem is to find a spanning tree of an edge - weighted graph that has the smallest total weight .",
    "so for example , the bold edges in figure  [ mst ] represent a minimum spanning tree of the graph shown .",
    "grafalgo contains several algorithms that solve the minimum spanning tree problem ( mst ) .",
    "all have two arguments , a weighted graph ( _ graph_w _ ) and a list in which the result is returned .",
    "specifically , on return , the list contains the edge numbers of the edges in the minimum spanning tree .",
    "_ prim s algorithm _",
    "( _ mst_p _ ) sovles the minimum spanning tree problem in @xmath10 time . for dense graphs ,",
    "this is @xmath11 , which is optimal .",
    "for very sparse graphs ( @xmath12 ) , the running time is @xmath13 , which falls a little short of optimal .",
    "prim s algorithm uses a @xmath14-heap to guide the selection of edges to be included in the tree .",
    "the _ heap_d _ class represents a set of items , each with a numeric _",
    "key_. the _ heap_d _",
    "object is used to guide the selection of edges to be included in the tree , where the keys correspond to edge weights in the graph .",
    "the _ heap_d _ class is implemented as a template , allowing different key types to be used in different applications .    a second version of prim s algorithm ( _ mst_pf _ ) that uses a _ fibonacci _ heap in place of the @xmath14-heap",
    "is also provided .",
    "this leads to a worst - case running time of @xmath15 which is better for sparse graphs .",
    "however , in practice , the relative simplicity of the @xmath14-heap data structure makes the first version faster under most conditions .",
    "fibonacci heaps do have some nice features relative to @xmath14-heaps . in particular , the _ fheap _ class represents a collection of disjint heaps that can be efficiently combined ( called _ melding _ ) , something that can not be done using @xmath14-heaps .",
    "it shares this property with other _",
    "meldable heaps_.",
    "_ kruskal s algorithm _",
    "( _ mst_k _ ) finds a minimum spanning tree in @xmath13 time .",
    "its running time is determined by an initial step which sorts the edges by weight .",
    "if the edges happen to be pre - sorted or can be sorted using radix sort , then kruskal s algorithm runs in @xmath16 where @xmath17 is a very slowly growing function ( it is inversely related to _",
    "ackerman s function _ ) .",
    "it builds the minimum spanning tree by scanning edges in order of their weight and including any edge that does not create a cycle among the tree edges selected so far .",
    "it uses a _",
    "disjoint sets _ data structure ( _ dsets _ ) to maintain a partition over the vertices in the graph .",
    "this is used to efficiently determine if an edge joins two vertices that are already connected by a path consisting of tree edges .",
    "( the disjoint sets data structure is often referred to as the _ union - find _ data structure . )    the _ cheriton - tarjan _",
    "( _ mst_ct _ ) algorithm runs in @xmath18 time . for very sparse graphs ,",
    "this yields the best overall performance among the algorithms included in grafalgo , although the extra overhead of its data structures prevents it from out - performing prim s algorithm in typical applications . like kruskal s algorithm",
    ", it uses a _",
    "dsets _ data structure to determine if two vertices are in a common subtree of the forest defined by the tree edges selected so far .",
    "it also uses a _ leftist heap _ data structure ( _ mheaps_l _ ) to represent the edges incident to each subtree in the current forest .",
    "this section of the library also includes a program called _ testmst _ that can be used to compute a minimum spanning tree on a given graph , using a specified algorithm .",
    "a separate program called _ randgraph _ can be used to generate random weighted graphs that serve as input to _",
    "testmst_. so for example , the command randgraph wgraph 6 8 1 9 1 0 produces the output    ....      {      [ a : e(9 ) f(9 ) ]      [ b : c(7 ) d(2 ) e(8 ) f(9 ) ]      [ c : b(7 ) f(9 ) ]      [ d : b(2 ) ]      [ e : a(9 ) b(8 ) f(7 ) ]      [ f : a(9 ) b(9 ) c(9 ) e(7 ) ]      } ....    the first argument to _",
    "randgraph _ is the type of graph ( possiblities include ugraph , bigraph , tree , wgraph , digraph , dag and flograph among others ) .",
    "the second and third arguments specify the number of vertices and edges in the graph .",
    "the next two specify the range of edge weights to be used .",
    "the next argument is the _ seed _ for the random number generator and a non - zero value for the last argument specifies that the vertex and edge numbers should be randomly scrambled ( this can be useful in situations where the default numbering might be exploited by an algorithm to improve its performance ) .",
    "the command    ....      randgraph wgraph 6 8 1 9 1 0 | testmst kruskal show verify   ....    produces the output    .... mst weight : 33      {      [ a : e(9 ) f(9 ) ]      [ b : c(7 ) d(2 ) e(8 ) f(9 ) ]      [ c : b(7 ) f(9 ) ]      [ d : b(2 ) ]      [ e : a(9 ) b(8 ) f(7 ) ]      [ f : a(9 ) b(9 ) c(9 ) e(7 ) ]      }        ( b , d,2 ) ( e , f,7 ) ( b , c,7 ) ( b , e,8 ) ( a , f,9 ) ....    the list of edges at the bottom defines the minimum spanning tree .",
    "the first argument to _",
    "testmst _ specifies the algorithm to use , the optional second argument requests that the graph and spanning tree be output ( if omitted , only the mst weight is output ) , the optional third argument requests that the spanning tree be checked for validity .    using these two programs",
    ", one can write simple scripts that test a given algorithm on a wide variety of sample graphs , and automatically check the results for correctness .",
    "another program called _ timemst _ can be used to obtain basic timing measurements of a specified algorithm , when run repeatedly on different random graphs .",
    "the shortest path problem involves determining minimum length paths in a directed graph with numeric edge lengths .",
    "there are several variants of the problem .",
    "grafalgo includes algorithms for the _ single - source _ version of the problem and the _ all pairs _ version .",
    "two algorithms are implemented for the single - source problem , dijkstra s algorithm ( _ spt_d _ ) and the bellman - moore algorithm ( _ spt_bm _ ) .",
    "dijkstra s algorithm is implemented using a @xmath14-heap and has a running time of @xmath19 , but is restricted to graphs with non - negative edge lengths .",
    "the bellman - moore algorithm can handle graphs with negative edge lengths , it requires only a simple queue and and runs in @xmath20 time .",
    "both take four arguments , a weighted directed graph object ( _ graph_wd _ ) , a source vertex and two arrays used to return the results of the computation .",
    "the _ parent - edge _ array specifies the edge connecting each vertex to its parent in the shortest path tree , while the _ distance _ array specifies the shortest path distance from the source .",
    "grafalgo also includes two algorithms for the all - pairs version of the problem , floyd s algorithm ( _ apsp_f _ ) and the edmonds - karp algorithm ( _ apsp_ek _ ) , both of which can handle negative edge lengths .",
    "floyd s algorithm runs in @xmath21 time , while the edmonds - karp algorithm runs in @xmath22 time .",
    "both return a 2-d array of distances , plus a second array that defines the actual shortest paths .",
    "there are also several utilities : _ testspt _ , _ testapsp _ , _ timespt _ and _ timeapsp _ that can be used to demonstrate correct operation and generate timing information .",
    "for example , the command    .... randgraph wdigraph 6 15 1 9 5 0 | testspt dijkstra show verify ....    produces the output    ....      distance sum is 25      {      [ a : b(5 ) c(2 ) d(4 ) ]      [ b : f(8 ) ]      [ c : b(7 ) d(5 ) e(1 ) ]      [ d : b(1 ) c(2 ) ]      [ e : a(1 ) c(7 ) d(6 ) f(8 ) ]      [ f : b(3 ) d(1 ) ]      }        0 5 2 4 3 11       ( a , b,5 ) ( a , c,2 ) ( a , d,4 ) ( c , e,1 ) ( e , f,8 ) ....    where the last line lists the edges in a shortest path tree with source vertex @xmath8 , while the preceding line gives the distance of the vertices from @xmath8 .",
    "an instance of the _ maximum flow problem _ is a directed graph with a _ source _ vertex , a _ sink _ vertex and positive _ edge capacities_. a flow function for such a graph is an assignment of non - negative flow values to the edges that respects the edge capacities and that balances the incoming and outgoing flows at all vertices , except the source and sink .",
    "the objective of the problem is to find a flow function that maximizes the total flow leaving the source .",
    "grafalgo includes a flow graph class ( _ graph_f _ ) which implements edge capacities , flows and methods for manipulating flows .",
    "there are many different algorithms for the maximum flow problem .",
    "grafalgo includes implementations of three major `` families '' of algorithms .",
    "the _ ford - fulkerson _ algorithms find maximum flows using the concept of _ augmenting paths_. three variants of the ford - fulkerson algorithm are implemented in grafalgo .",
    "the _ shortest path _ variant ( _ mflo_ffsp _ ) finds augmenting paths of minimum length in @xmath23 time , the _ maximum capacity _ ( _ mflo_ffmc _ ) variant finds paths of maximum residual capacity and runs in @xmath24 time , where @xmath25 is the maximum edge capacity , and the _ capacity scaling _ ( _ mflo_ffs _ ) variant finds high capacity augmenting paths ( not necessarily maximum capacity paths ) and runs in @xmath26 time .",
    "these algorithms are implemented as classes , allowing the internal data used by the algorithms to be shared among their internal methods , but hidden from other parts of the program .",
    "the algorithms are invoked using the constructor ( creating a temporary object that is retained only while the algorithm executes ) .",
    "these classes share a common base clase _",
    "mflo_ff_.    dinic s algorithm ( _ mflo_d _ ) is a more sophisticated version of the shortest path variant of the ford - fulkerson algorithm . instead of starting over with each augmenting path search",
    ", it operates in phases , where each phase finds all paths of a given length .",
    "this enables a more efficient search procedure and an overall running time of @xmath27 . a second version of dinic s algorithm ( _ mflo_dst _ ) , using sleator and tarjan s _ dynamic trees _  @xcite data structure , improves this to @xmath28 . the dynamic trees data structure is implemented by the class _",
    "dtrees_.    the _ preflow - push _ algorithms are based on the concept of a _ preflow _ ( a flow function that is allowed to violate the balance conditions of ordinary flow functions ) .",
    "grafalgo implements two variants , the _ fifo _ variant ( _ mflo_ppf _ ) , which runs in @xmath21 time , and the _ highest - label - first _ variant ( _ mflo_pphl _ ) , which runs in @xmath29 time . these are implemented by classes and share a common base class _ mflo_pp_.    grafalgo also includes utilities for testing different max flow algorithms and measuring their running times .",
    "the command    ....    randgraph flograph 10 20 2 30 10 1 0 | testmaxflo dinic show ....    produces the output    ....      total flow of 17      {      [ b : c(7,0 ) d(8,4 ) f(6,6 ) h(9,6 ) ]      [ c : d(1,1 ) e(5,0 ) ]      [ d : a(1,0 ) g(4,4 ) h(1,1 ) ]      [ e : a(2,0 ) c(7,0 ) ]      [ f : h(2,0 ) j(15,13 ) ]      [ g : c(4,0 ) d(3,0 ) j(28,4 ) ]      [ h : f(7,7 ) g(5,0 ) ]      [ i- > : b(16,16 ) c(16,1 ) ]      [ ->j : ]      } ....    the capacity and flow is shown for each edge in the _ graph_f _ object .",
    "the source vertex is @xmath30 and the sink is @xmath31 .",
    "grafalgo also includes an algorithm for a variant of the max flow problem in which some edges have minimum flow requirements or _ flow floors_. this problem can be solved by first finding a _ feasible flow _",
    "( which may not always be possible ) , then converting the feasible flow to a maximum flow .",
    "a separate _ graph_ff _ class is used to implement this algorithm . it allows the specification of flow floors and re - defines the residual capacity of an edge to account for the floors .",
    "in the min - cost flow problem , each edge has an associated _ cost _ the cost of the flow on an edge is the product of the flow and the edge cost , and the total cost of the flow is the sum of the costs of the flows on the edges .",
    "grafalgo includes a _ graph_wf _ class for use by min - cost flow algorithms .",
    "the _ cycle reduction _ algorithm ( _ mcf_cr _ ) converts an arbitrary maximum flow to one of minimum cost by pushing flow around cycles of negative cost .",
    "its worst - case running time is @xmath32 where @xmath25 is the maximum edge capacity and @xmath33 is the maximum edge cost",
    ". the _ least - cost augmenting path _ algorithm ( _ mcf_lc _ ) uses augmenting paths of minimum cost .",
    "this can be implemented to run in @xmath34 time , where @xmath35 is the maximum flow value .",
    "_ algorithm ( _ mcf_s _ ) adds flows to high capacity paths , leading to a running time of @xmath24 .",
    "utilities are provided to demonstrate the correct operation of the min cost flow algorithms and measure their running times .",
    "a _ matching _ in an undirected graph is a subset of the edges , no two of which are incident to the same vertex ( or equivalently , it is a degree 1 subgraph ) .",
    "the objective of the _ matching problem _ in unweighted graphs is to find a matching with the maximum possible number of edges .",
    "if the edges have weights , the objective is to find a matching of maximum weight .",
    "the special case of bipartite graphs is easier to solve and has a variety of applications .",
    "grafalgo includes several algorithms for finding matchings in bipartite graphs , based on the concept of _ augmenting paths_. the hopcroft - karp algorithm ( _ matchb_hk _ ) finds a maximum size matching in @xmath36 time .",
    "a closely related algorithm reduces the matching problem to a maximum flow problem and has the same running time . the hungarian algorithm ( _ matchwb_h _ ) finds a maximum weight matching in @xmath22 time .",
    "the same running time can be obtained by reducing the matching problem to a minimum cost flow problem .",
    "the algorithms for unrestricted graphs are all variants of _",
    "algorithm_. gabow s implementation of edmonds algorithm ( _ match_eg _ ) for unweighted graphs runs in @xmath28 time .",
    "the galil - micali - gabow implementation of edmonds algorithm for weighted graphs  @xcite also runs in @xmath28 time .",
    "grafalgo does not yet include a full implementation of the galil - micali - gabow variant , but it does include a version that is specialized to bipartite graphs ( _ matchb_egmg _ ) .",
    "grafalgo also includes an algorithm for finding _ maximum priority matchings _ in graphs where every vertex has an integer priority . a maximum priority matching is one that maximizes a _ priority score _ defined with respect to these priorities  @xcite .",
    "the objective of the _ edge coloring problem _ is to assign colors to all edges of a graph , in such a way that no two edges incident to the same vertex are assigned the same color ( or equivalently , it seeks to partition the graph into a minimum number of matchings ) . for a bipartite graph with maximum degree @xmath37 , the edges can be colored with @xmath37 colors .",
    "grafalgo includes several algorithms for coloring bipartite graphs . the alternating path algorithm ( _ ecolor_ap _ ) colors edges by finding alternating paths and",
    "can be implemented to run in @xmath20 time .",
    "the matching algorithm ( _ ecolor_m _ ) finds a sequence of matchings that cover vertices of maximum degree , removing the matching edges from the graph after each step .",
    "it can be implemented to run in @xmath38 .",
    "algorithm  @xcite ( _ ecolor_g _ ) uses a divide - and - conquer strategy that uses _ euler partitions _ to split the graph into parts with smaller maximum vertex degree .",
    "it can be implemented to run in @xmath39 time . for graphs where @xmath37 is a power of 2",
    ", it runs in @xmath40 time .",
    "grafalgo also includes algorithms for two variations on the classical edge coloring problem . in the _ bounded edge coloring problem _",
    "@xcite , each edge has a lower bound on its allowed color . in the _ edge group coloring problem _",
    "@xcite , edges are divided into groups and edges belonging to the same group are allowed to have the same color .",
    "these problems are abstract versions of scheduling problems in crossbar switches .",
    "they are both np - complete , and consequently the provided algorithms can not guarantee optimal solutions .",
    "the grafalgo library includes a number of other components , including classes that implement hash tables , search trees and multi - threaded queues , as well as assorted utility functions .",
    "this report is meant only as a brief introduction to grafalgo . to learn more about the algorithms that have been mentioned here , see the references . to learn more about the implementations , see the on - line documentation and the source code .",
    "grafalgo remains a work - in - progress and additional algorithms and data structures will be added over time .",
    "this is an open - source project and anyone interested in contributing is invited to contact the author .",
    "turner , jonathan s. `` the edge group coloring problem with applications to multicast switching , '' washington university department of computer science and engineering technical report , _",
    "wucse_-2015 - 02 . also , available from the _ computing research repository _",
    "( _ corr _ ) arxiv:1512.08995 [ cs.ds ] .",
    "turner , jonathan s. `` maximum priority matchings , '' washington university department of computer science and engineering technical report , _",
    "wucse_-2015 - 06 . also , available from the _ computing research repository _ ( _ corr _ ) arxiv:1512.08555 [ cs.ds ] .",
    "turner , jonathan s. `` the bounded edge coloring problem and offline crossbar scheduling , '' washington university department of computer science and engineering technical report , _",
    "wucse_-2015 - 02 . also , available from the _ computing research repository _",
    "( _ corr _ ) arxiv:1512.09002 [ cs.ds ] .",
    "turner , jonathan s. `` faster maximium priority matchings in bipartite graphs , '' washington university department of computer science and engineering technical report , _",
    "wucse_-2015 - 08 .",
    "also , available from the _ computing research repository _ ( _ corr _ ) arxiv:1512.09349 [ cs.ds ] ."
  ],
  "abstract_text": [
    "<S> this report provides an ( updated ) overview of _ grafalgo _ , an open - source library of graph algorithms and the data structures used to implement them . the programs in this library </S>",
    "<S> were originally written to support a graduate class in advanced data structures and algorithms at washington university . </S>",
    "<S> because the code s primary purpose was pedagogical , it was written to be as straightforward as possible , while still being highly efficient . </S>",
    "<S> grafalgo is implemented in c++ and incorporates some features of c++11 .    </S>",
    "<S> the library is available on an open - source basis and may be downloaded from https://code.google.com / p / grafalgo/. source code documentation is at www.arl.wustl.edu/~jst/doc/grafalgo . while not designed as production code , the library is suitable for use in larger systems , so long as its limitations are understood . </S>",
    "<S> the readability of the code also makes it relatively straightforward to extend it for other purposes .    </S>",
    "<S> _ grafalglo _ includes implementations of algorithms for a variety of classical graph optimization problems . </S>",
    "<S> these include the minimum spanning tree problem , the shortest path problem , the max flow problem , the min - cost flow problem , the graph matching problem and the edge coloring problem for bipartite graphs . </S>",
    "<S> multiple algorithms are provided for each problem , illustrating a variety of different approaches . </S>",
    "<S> while all the algorithms included here are efficient enough to be reasonable candidates in practical applications , some are clearly better than others . </S>",
    "<S> often the most sophisticated methods , with the best performance from a theoretical perspective , are not the best choice for real applications . still , it s instructive to study the techniques on which these algorithms are based , and the implementations provided here can aid in such study . </S>",
    "<S> this report does not attempt to describe the algorithms and data structures in detail . </S>",
    "<S> readers may find more information in standard texts , including  @xcite and  @xcite , as well as in the online documentation and source code .    </S>",
    "<S> this report is organized mainly by problems . </S>",
    "<S> we start with a brief description of a few of the basic data structures , then proceed to a discussion of the minimum spanning tree problem and the algorithms provided to solve it . </S>",
    "<S> subsequent sections address different problems and the algorithms used to solve them . </S>"
  ]
}