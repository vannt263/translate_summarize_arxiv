{
  "article_text": [
    "as semantic technologies are becoming increasingly mature , there is a need for mechanisms to ensure that confidential data is only accessible by authorised users .    controlled query evaluation ( cqe ) is a prominent confidentiality enforcement framework , in which sensitive information is declaratively specified by means of a _ policy _ and confidentiality is enforced by a _",
    "censor_. when given a query , a censor checks whether returning the answer may lead to a policy violation , in which case it returns a distorted answer .",
    "the cqe framework was introduced in @xcite , and studied in @xcite for propositional databases .",
    "it has been recently extended to ontologies , where different formalisations have been proposed @xcite .",
    "we study cqe for ontologies that are expressed in the rule language datalog as well as in the lightweight description logics ( dls ) underpinning the standadised profiles of owl  2  @xcite .",
    "we assume that data is hidden , and users access the system by a query interface .",
    "an ontology , which is known to users , provides the vocabulary and background knowledge needed for users to formulate queries , as well as to enrich query answers with implicit information .",
    "policies , formalised as conjunctive queries , are available only to system administrators , but not to ordinary users .",
    "the role of the censor is to preserve confidentiality by filtering out those answers to user queries that could lead to a policy violation . in this setting",
    ", there is a danger that confidentiality enforcement may over - restrict the access of the user .",
    "thus , we focus on _ optimal _ censors , which maximise answers to queries while ensuring confidentiality of the policy .",
    "we are especially interested in censors that can be realised by off - the - shelf reasoning infrastructure .",
    "to fullfil this requirement , we introduce in section  [ sec : censor - types ] _ view _ and _ obstruction _ censors .",
    "view censors return only answers that follow from the ontology and an anonymised dataset ( a view ) where some occurrences of constants may have been replaced with labelled nulls .",
    "the censor answers faithfully all queries against the view ; thus , any information not captured by the view is inaccessible by default . view censors may require materialisation of implicit data , and hence are well - suited for applications where materialisation is feasible .",
    "obstruction censors are defined by a set of `` forbidden query patterns '' ( an obstruction ) , where all answers instantiating such patterns are not returned to users .",
    "these censors do not require data modification and are well - suited for applications such as ontology based data access ( obda ) , where data is managed by an rdbms .",
    "obstruction censors are dual to view censors in the sense that they specify the information that users are denied access to .",
    "we formally characterise this duality , and show that their capabilities are incomparable .    in section  [ sec : view - censors ]",
    "we investigate the limitations of view censors and show that checking existence of an optimal view is undecidable for datalog ontologies .",
    "we then study fragments of datalog for which optimal views always exist and extend our results to owl 2 profile ontologies . in section  [ sec : obstruction - optimal ] we focus on obstruction censors , and provide sufficient and necessary conditions for an optimal censor to exist .",
    "then , we propose a tractable algorithm for computing optimal obstruction censors for linear datalog ontologies and apply our results to owl 2 ql ontologies .",
    "@xmath0 + @xmath1 , \\\\ & \\mbox{}\\hspace{-.8ex }   \\mathrm{(4 ) } \\ ;           a(x ) \\rightarrow x { \\approx}a , & & \\hspace{-1ex } \\mathrm{(5 ) }   \\ ;      r(x , y ) { \\wedge } s(y , z ) \\rightarrow t(x , z ) , \\\\ & \\mbox{}\\hspace{-.8ex }   \\mathrm{(6 ) } \\ ;           a(x ) { \\wedge } b(x ) \\rightarrow c(x ) ,   & & \\hspace{-1ex } \\mathrm{(7 ) } \\ ;           a(x ) \\wedge r(x , y ) \\rightarrow b(y ) , \\\\ & \\mbox{}\\hspace{-.8ex }   \\mathrm{(8 ) } \\ ;      r(x , y ) \\rightarrow s(y , x ) , & & \\hspace{-1ex } \\mathrm{(9 ) } \\ ;          r(x , a ) \\rightarrow b(x ) , \\\\   &",
    "\\mbox{}\\hspace{-.8ex }   \\mathrm{(10 ) } \\ ;          r(x , y ) \\rightarrow a(y ) , & & \\hspace{-1ex } \\mathrm{(11 ) } \\ ;          a(x ) \\rightarrow r(x , a),\\\\ & \\mbox{}\\hspace{-.8ex }    \\mathrm{(12 ) } \\ ; a(x ) \\rightarrow b(x ) , & & \\hspace{-1ex } \\mathrm{(13 ) } \\ ;           r(x , y ) \\wedge b(y ) \\rightarrow a(x).\\end{aligned}\\ ] ]    we adopt standard notions in first order logic over function - free finite signatures .",
    "our focus is on ontologies , so we assume signatures with predicates of arity at most two . we treat equality @xmath2 as an ordinary predicate , but assume that any set of formulae containing @xmath2 also contains all the axioms of @xmath2 for its signature .    * datasets and ontologies * a _ dataset _ is a finite set of facts ( i.e. , ground atoms )",
    ". an _ ontology _ is a finite set of _ rules _ , that is , formulae of the form @xmath3 where the _ body _ @xmath4 and the _ head _ @xmath5 are conjunctions of atoms , and variables @xmath6 are implicitly universally quantified .",
    "we restrict ourselves to ontologies @xmath7 and datasets @xmath8 such that @xmath9 is satisfiable , which ensures that answers to queries are meaningful .",
    "a rule is    * _ datalog _ if the head has a single atom and @xmath10 is empty ; * _ guarded _ if the body has an atom ( _ guard _ ) with all @xmath6 ; * _ linear _ if the body has a single atom ; * _ multi - linear _ if the body contains only guards ; * _ tree - shaped _ if the undirected multigraph with an edge @xmath11 for each binary body atom @xmath12 is a tree .",
    "an ontology is of a type above if so are all the rules in it .",
    "* owl 2 profiles * table  [ tab : dl - axioms ] provides the types of rules sufficient to capture the axioms in the owl 2 rl , el , and ql profiles .",
    "we treat the @xmath13 concept in dls as a unary predicate and assume that each ontology contains the rule @xmath14 for each predicate @xmath15 and variable @xmath16 from @xmath17 .",
    "an ontology consisting of rules in table  [ tab : dl - axioms ] is    * _ rl _ if it has no rules of type ( 3 ) ; * _ ql _ if it only has rules of types  ( 2 ) , ( 3 ) , ( 8) , ( 10 ) , ( 12 ) ; * _ el _ if it has no rules of types  ( 1 ) ,  ( 7 ) ,  ( 8) .",
    "* queries * a _ conjunctive query _ ( _ cq _ ) with _ free _ variables",
    "@xmath17 is a formula @xmath18 of the form @xmath19 , with the _ body _ @xmath20 a conjunction of atoms .",
    "a _ union _ of cqs ( _ ucq _ ) is disjunction of cqs with same free variables .",
    "queries with no free variables are _",
    "boolean_. a tuple of constants",
    "@xmath21 is a ( _ certain _ ) _ answer _ to @xmath18 over ontology @xmath7 and dataset @xmath8 if @xmath22 .",
    "the set of answers to @xmath18 over @xmath7 and @xmath8 is denoted by @xmath23 .",
    "we assume that data @xmath8 is hidden while the ontology @xmath7 is known to all users .",
    "it is assumed that system administrators are in charge of specifying policies as cqs , and that policies are assigned to users by standard mechanisms such as role - based access control @xcite .",
    "a _ cqe _ _ instance _ @xmath24 is a triple @xmath25 , with @xmath7 an ontology , @xmath8 a dataset , and @xmath26 a cq , which is called _",
    "policy_. the instance @xmath24 is datalog , guarded , etc .  if so is the ontology @xmath27 , where @xmath20 is the body of @xmath26 and @xmath28 a fresh predicate .",
    "[ ex : running - example ] consider the following ontology and dataset that describe an excerpt of a social network : @xmath29 here , the ontology @xmath30states , for example , that people who like thrillers are thriller fans , or that friendship is a symmetric relation .",
    "then , a policy @xmath31 forbids access to john s friend list .",
    "a key component of a cqe system is the _ censor _ , whose goal is to decide according to the policy which query answers can be safely returned to users .    a _ censor _ for a cqe instance @xmath32 is a function @xmath33 mapping each cq @xmath34 to a subset of @xmath23 .",
    "the _ theory _",
    "@xmath35 of @xmath33 is the set @xmath36 censor @xmath33 is _ confidentiality preserving _ if for each tuple @xmath21 of constants @xmath37 .",
    "it is _ optimal _ if    * it is confidentiality preserving , and * no confidentiality preserving censor @xmath38 exists such that @xmath39 for every cq @xmath34 .    intuitively , @xmath35 represents all the information that a user can gather by asking cqs to the system . if the censor is confidentiality preserving , then no information can be obtained about the policy , regardless of the number of cqs asked . in this way ,",
    "optimal censors maximise information accessibility without compromising the policy .",
    "the idea behind _ view censors _ is to modify the dataset by anonymising occurrences of constants as well as by adding or removing facts , whenever needed .",
    "we refer to such modified dataset as an _ ( anonymisation ) view_. the censor returns only the answers that follow from the ontology and view ; in this way , the main workload of the censor amounts to the computation of certain answers , which can be delegated to the query answering engine .",
    "[ def : view - censor ] a _ view _ @xmath40 for @xmath41 is a dataset over the signature of @xmath24 extended with a set of fresh constants .",
    "the _ view censor _ @xmath42 is the function mapping each cq @xmath43 to the set @xmath44 .",
    "the view is _ optimal _ if so is its corresponding censor .",
    "clearly , for the censor to be confidentiality preserving @xmath45 must not entail any answer to the policy .",
    "on the other hand , to ensure optimality a view must encode as much information from the hidden dataset as possible .",
    "[ ex : view - basic ] consider the view @xmath46 obtained from @xmath47 by replacing @xmath48with a fresh @xmath49 .",
    "intuitively , @xmath46 is the result of `` anonymising '' the constant @xmath48 , while keeping the structure of the data intact .",
    "since @xmath46 contains no information about @xmath50 , we have @xmath51 and the censor based on @xmath46 is confidentiality preserving .",
    "view @xmath46 , however , is not optimal : for instance , @xmath52 does not entail the fact @xmath53 , which can be added to the view without violating confidentiality .",
    "the idea behind _ obstruction censors _ is to associate to a cqe instance a boolean ucq @xmath54 s.t .",
    "the censor returns an answer @xmath21 to a cq @xmath43 only if no cq in @xmath54 follows from @xmath55 .",
    "thus , the obstruction can be seen as a set of forbidden query patterns , which should not be disclosed .",
    "an _ obstruction _ @xmath54 for @xmath41 is a boolean ucq .",
    "the _ obstruction censor _",
    "@xmath56 based on @xmath54 is the function that maps each cq @xmath43 to the set @xmath57 the obstruction is _ optimal _ if so is its censor @xmath56 .    similarly to view censors ,",
    "obstruction censors do not require dedicated algorithms : checking @xmath58 can be delegated to an rdbms .",
    "obstructions can be virtually maintained and do not require data materialisation .    [",
    "ex : obstruction - basic ] the censor based on @xmath46 from example [ ex : view - basic ] can also be realised with the following obstruction @xmath59 : + @xmath60 intuitively , @xmath59 `` blocks '' query answers involving @xmath50 ; and all other answers are the same as over @xmath61 .",
    "examples [ ex : view - basic ] and [ ex : obstruction - basic ] show that the same censor may be based on both a view and an obstruction .",
    "these censors , however , behave _ dually _ : a view explicitly encodes the information accessible to users , whereas obstructions specify information which users are denied access to . it is not obvious whether ( and how ) a view can be realised by an obstruction , or vice - versa .",
    "we next focus on datalog ontologies and characterise when a view @xmath40 and obstruction @xmath54 yield the same censor .",
    "we start with few definitions .",
    "each datalog ontology @xmath7 and dataset @xmath8 have a unique _ least herbrand model _",
    "@xmath62 : a finite structure satisfying @xmath63 iff @xmath64 for every cq @xmath34 .",
    "thus , this model captures all the information relevant to cq answering .",
    "a natural specification of the duality between views and obstructions is then as follows : @xmath54 and @xmath40 implement the same censor if and only if @xmath54 captures the structures _ not _ homomorphically embeddable into @xmath65 . to formalise this statement , we recall the central problem in the ( non - uniform ) constraint satisfaction theory .",
    "let @xmath66 be a class of finite structures and let @xmath67 be a subset of @xmath66 .",
    "first - order sentence @xmath68 _ defines _",
    "@xmath67 if @xmath69 is equivalent to @xmath70 for every structure @xmath71 .    let @xmath72 denote the fact that there is a homomorphism from a structure @xmath73 to a structure @xmath74 .",
    "the correspondence is given in the following theorem .",
    "theoremcensorsimulation[th : simulation ] let @xmath41 be datalog and @xmath75 .",
    "then , @xmath76 iff @xmath54 defines the set @xmath77 .    using this theorem together with definability results in finite model theory",
    ", we can show that views and obstructions can not simulate one another in general .",
    "theoremcensornotsimulationgeneral[th : no simulation in general ] there is a datalog cqe instance admitting a confidentiality preserving view censor that is not based on any obstruction .",
    "conversely , there is a datalog cqe instance admitting a confidentiality preserving obstruction censor that is not based on any view .",
    "our discussion in section  [ sec : censor - types ] suggests that view and obstruction censors must be studied independently . in this section",
    "we focus on view censors and start by establishing their theoretical limitations .",
    "the following example shows that optimal view censors may not exist , even if we restrict ourselves to empty ontologies .",
    "[ ex : no optimal view ] consider a cqe instance with empty ontology , dataset consisting of a fact @xmath78 , and policy @xmath79 .",
    "consider also the family of boolean cqs @xmath80 , which intuitively represent strict total orders on @xmath81 elements .",
    "answering these queries positively is harmless : @xmath82 for any confidentiality preserving view @xmath40 .",
    "assume now that @xmath40 is optimal , and let @xmath83 be the number of constants in @xmath40 .",
    "then , @xmath84 since otherwise @xmath40 would encode a self - loop and violate the policy .",
    "this contradicts the optimality of @xmath40 , and hence no optimal view exists .",
    "furthermore , determining the existence of an optimal view is undecidable even for datalog cqe instances .",
    "theoremundectheorem the problem of checking whether a datalog cqe instance admits an optimal view is undecidable .",
    "the proof is by reduction to the undecidable problem of checking whether a deterministic turing machine without a final state has a repeated configuration in a run on the empty tape . for each such machine",
    "we construct a cqe instance such that the run corresponds to an infinite grid - like `` view '' with axes for the tape and time .",
    "the ontology guarantees that representations of adjacent configurations agree with the transition function , and the policy forbids invalid configurations ( e.g. , with many symbols in a cell ) .",
    "coinciding configurations appear in the run iff the grid can be `` folded '' to a finite view on all sides ( e.g. , if configurations can be merged ) .    in",
    "what follows , we identify classes of cqe instances that guarantee existence of optimal view censors .",
    "we start by studying restrictions on datalog ontologies and then adapt the obtained results to the owl 2 profiles .",
    "the idea behind view censors is to anonymise information in the original data in such a way that the policy can not be violated .",
    "for instance , in example  [ ex : view - basic ] we substituted the atom @xmath85 with @xmath86 , where @xmath49 is a fresh constant that is an anonymised copy of @xmath50 . in general , however , many such anonymous copies may be required for each data constant to encode all the information required for ensuring optimality .",
    "the limit case is illustrated by example  [ ex : no optimal view ] , where no finite number of fresh constants suffices for optimality .",
    "observe that the cqe instance used in example [ ex : no optimal view ] is neither guarded nor tree - shaped due to the form of the policy . in",
    "what follows , we show that an optimal view can always be constructed using at most exponentially many anonymous constants if we restrict ourselves to datalog cqe instances that are guarded and tree - shaped .",
    "we next provide an intuitive idea of the construction .",
    "consider the view for a cqe instance @xmath25 consisting of the following three components @xmath87@xmath88 .",
    "* component @xmath87 is any maximal set of unary atoms in @xmath62 that does not compromise the policy . * to construct @xmath89 , we consider an anonymised copy @xmath90 of each constant @xmath91 and each set @xmath92 of unary predicates",
    "@xmath93 s.t .",
    "the corresponding set of all unary atoms @xmath95 for @xmath96 is a part of @xmath89 if and only if it is `` safe '' , that is , neither discloses the policy nor entail new facts together with @xmath97 . *",
    "finally , @xmath88 consists of a maximal set of binary atoms on all the constants ( including the copies ) that are justified by @xmath62 and do not disclose the policy .",
    "optimality of this view follows immediately from the construction . the view",
    ", however , may require exponentially many anonymised copies of data constants .",
    "the need for them is illustrated by the following example .    ' '' ''    [ rdfnode/.style = inner sep=1 mm , rectangle , rounded corners=5pt , draw , rdfnodea/.style = inner sep=1.5 mm , rectangle , rounded corners=5pt , draw , rdflabel/.style = inner sep=.5 mm , > = stealth , scale=1 ]    at ( 0.5,1 ) ( john ) [ rdfnodea ] @xmath98 ; at ( 0.5,0 ) ( bob ) [ rdfnodea ] @xmath48 ;    at ( 3,1 ) ( ajohn1 ) [ rdfnode ] @xmath99 ; at ( 6,1 ) ( ajohn2 ) [ rdfnode ] @xmath100 ; at ( 4.5,0 ) ( abob ) [ rdfnode ] @xmath101 ; at ( 2,0 ) ( dots ) @xmath102 ;    ( john ) to node [ rdflabel , auto ] ( bob ) ; ( john ) to node [ rdflabel , auto ] ( abob ) ; ( ajohn1 ) to node [ rdflabel , auto ] ( bob ) ; ( ajohn1 ) to node [ rdflabel , auto ] ( abob ) ; ( ajohn2 ) to node [ rdflabel , auto ] ( abob ) ;    ' '' ''    [ ex : algorithm - intuition ] consider the cqe instance with ontology consisting of rules @xmath103 and @xmath104 @xmath105 , dataset consisting of facts @xmath106 , @xmath107 and @xmath108 , and policy @xmath105 .",
    "the essential part of the optimal view obtained using the aforementioned construction is given in figure  [ fig : running example ] .",
    "here @xmath109 , @xmath89 contains unary atoms over the anonymised copies @xmath99 and @xmath100 of @xmath110 , and @xmath101 of @xmath50 , while @xmath88 contains the @xmath111 atoms represented by arrows .",
    "note that at least two anonymised copies of @xmath110 are necessary in any optimal view to answer correctly `` harmless '' queries such as @xmath112    this example shows that , in order to avoid the exponential blow up in the number of anonymised copies , we need further restrictions on the ontology . in particular , in the case of multi - linear cqe instances we can guarantee that just one copy suffices for every constant .",
    "the following theorem formalises the intuition above .",
    "theoremguardedtreeshapeddatalogview[th : guarded ] let @xmath24 be a datalog tree - shaped cqe instance . if @xmath24 is guarded , it admits an optimal view that can be computed in time exponential in @xmath113 and polynomial in data size .",
    "if @xmath24 is multi - linear , it admits an optimal view that can be computed in time polynomial in @xmath113 .",
    "additionally , @xmath24 has a unique optimal censor if it is linear .",
    "the result in theorem [ th : guarded ] is immediately applicable to rl ontologies , with the only restriction that they do not contain rules of types ( 1 ) , ( 4 ) , or ( 5 ) in table [ tab : dl - axioms ] . in contrast to rl , the ql and el profiles provide means for capturing existentially quantified knowledge . to bridge this gap ,",
    "we show that every ( guarded ) ql or el cqe instance @xmath41 can be polynomially trasformed into a datalog cqe instance @xmath114 by rewriting @xmath7 into a ( guarded and tree - shaped ) datalog ontology @xmath115 in such a way that optimal views for @xmath24 can be directly obtained from those for @xmath116 .",
    "we start by specifying what constitutes an acceptable rewriting @xmath115 of @xmath7 .",
    "let @xmath117 be a set of constants.a datalog ontology @xmath115 is a @xmath117-_rewriting _ of an ontology @xmath7 if @xmath118 for each tree - shaped cq @xmath34 and dataset @xmath8 over constants from @xmath117 .",
    "the following proposition provides the mechanism to reduce optimal view computation for arbitrary ontologies to the case of datalog .",
    "propositionhorndatalog [ prop : horn2datalogprop ] let @xmath41 be a cqe instance over constants @xmath117 with @xmath26 tree - shaped , and @xmath115 a @xmath117-rewriting of @xmath7 s.t .",
    "if @xmath120 is an optimal view for @xmath121 , then @xmath122 is an optimal view for @xmath24 .",
    "= -1    with this proposition at hand , we just need to devise a technique for rewriting any ql ( or guarded el ) ontology into a stronger datalog ontology , which , however , preserves the answers to all tree - shaped queries . to this end",
    ", we exploit techniques developed for the so - called _ combined approach _ to query answering @xcite .",
    "the idea is to transform rules of type ( 3 ) into datalog by skolemising existentially quantified variables into globally fresh constants .",
    "such transformation strengthens the ontology ; however , if applied to a ql or guarded el ontology , it preserves answers to tree - shaped cqs for any dataset over  @xmath117 @xcite .",
    "let @xmath7 be an ontology and @xmath117 be a set of constants .",
    "the ontology @xmath123 is obtained from @xmath7 by replacing each rule @xmath124 $ ] with @xmath125 where @xmath126 is a fresh binary predicate , uniquely associated to the original rule , and @xmath91 is a globally fresh constant not from @xmath117 , uniquely associated to @xmath127 and @xmath128 .",
    "[ thm : combined - approach ] for any ontology @xmath7 we have @xmath129 . furthermore ,",
    "if @xmath7 is either a ql or guarded el ontology , then @xmath123 is a @xmath117-rewriting of @xmath7 .",
    "proposition  [ prop : horn2datalogprop ] and theorem [ thm : combined - approach ] ensure that @xmath130 is an optimal view for @xmath24 whenever @xmath40 is such a view for @xmath131 .",
    "the transformation of @xmath7 to @xmath123 preserves linearity , guardedness , and tree - shapedness , so the results of section  [ sec : data - view - rl ] are applicable to @xmath116 .",
    "[ def : view - el - ql - optimal ] every guarded el cqe instance admits an optimal view that can be computed in exponential time .",
    "every ql instance admits a unique optimal censor , which is implementable by a view of polynomial size .",
    "similarly to section  [ sec : view - censors ] , we start the study of optimal obstruction censors with its limitations .",
    "the following example shows that such a censor may not exist even if we restrict ourselves to ontologies with only one rule .",
    "[ example : no obstruction censor ] consider a cqe instance with ontology @xmath132 , dataset @xmath133 , and policy @xmath134 .",
    "let @xmath135 , @xmath136 , be a family of boolean cqs @xmath137 with the help of the ontology each of @xmath135 discloses the policy .",
    "thus , each @xmath135 should entail a boolean cq in any optimal obstruction .",
    "consider the set of all cqs that are entailed by queries @xmath135 but not equivalent to any of them .",
    "on the one hand , this set is `` harmless '' , than is , any obstruction censor should answer all these queries positively . on the other hand ,",
    "the cqs @xmath135 do not entail each other .",
    "hence , any optimal obstruction should contain a cq equivalent to each @xmath135 , which is however not possible , because @xmath81 is unbounded .",
    "we leave the question of decidability of checking the existence of an optimal obstruction for a cqe instance open .",
    "answering this question positively would imply a solution to a long - standing open problem . in appendix  [ app : reduction ]",
    "we provide a reduction from the problem of uniform boundedness for binary datalog , for which the decidability is unknown  @xcite , to the existence problem of optimal obstructions for datalog cqe instances . in the rest of the section",
    "we give a characterisation of optimal obstructions for datalog instances in terms of resolution proofs and identify restrictions for which the characterisation guarantees existence of such obstructions .",
    "we first recall the standard notion of sld resolution .",
    "a _ goal _ is a conjunction of atoms .",
    "sld resolution step _ takes a goal @xmath138 with a selected atom @xmath139 and a sentence @xmath140 that is either a datalog rule @xmath141 or a fact @xmath142 , and produces a new goal @xmath143 , where @xmath144 is a most general unifier of @xmath139 and @xmath142 ( assuming that @xmath68 is empty in the case when @xmath140 is a fact )",
    ". an _ ( sld ) proof _ of a goal @xmath145 in a datalog ontology",
    "@xmath7 and dataset @xmath8 is a sequence of goals @xmath146 , where @xmath147 is empty , and each @xmath148 is obtained from @xmath149 and a sentence ( rule or fact ) in @xmath9 by an sld resolution step .",
    "resolution is sound and complete : for any datalog ontology @xmath7 , dataset @xmath8 , and goal @xmath150 ( such that @xmath9 is satisfiable ) there is a proof of @xmath150 in @xmath7 and @xmath8 if and only if @xmath151 for the existential closure @xmath152  of  @xmath150 .",
    "we next characterise optimal obstructions using sld proofs .",
    "intuitively , if an obstruction censor answers positively sufficient number of boolean cqs @xmath152 for goals @xmath150 in a proof of a policy , then a user could reconstruct ( a part of ) this proof and compromise the policy .",
    "also , there can be many proofs , and a user may compromise the policy by reconstructing any of them .",
    "thus , to ensure that a censor is confidentiality preserving , we must guarantee that the obstruction contains enough cqs to prevent reconstruction of any proof .",
    "if we also want the censor to be optimal , the obstruction should not block too many cqs . as we will see later on ,",
    "these requirements may be in conflict and lead to an infinite `` obstruction '' .",
    "next definitions formalise this intuition .",
    "[ def : pseudo obstruction ] let @xmath41 be a datalog cqe instance , @xmath153 be the set of all boolean cqs @xmath152 for goals @xmath150 in proofs of @xmath154 in @xmath7 and @xmath8 for some tuple of constants @xmath21 , and @xmath155 be a maximal subset of @xmath153 such that @xmath156 for any @xmath21 .",
    "then , a _ _ for @xmath24 is a subset of @xmath157 that contains a cq @xmath158 for any @xmath34 in @xmath157 with @xmath159 .",
    "the next theorem establishes the connection between pseudo - obstructions and optimality .",
    "theoremoptimalucqcensor [ th : characterisation ] let @xmath24 be a datalog cqe instance .    1 .",
    "if @xmath160 is a finite for @xmath24 , then @xmath161 is an optimal obstruction for @xmath24 .",
    "if each for @xmath24 is infinite , then no optimal obstruction censor for @xmath24 exists .",
    "this theorem has implications on the expressive power of obstructions .",
    "in particular , we can now extend the result in theorem [ th : no simulation in general ] , which applies to censors that are not necessarily optimal , to capture also optimality .",
    "theoremnonexistenceobs[th : non - existence - comparison ] there is a cqe instance , which is both rl and el , admitting an optimal view , but no optimal obstruction .",
    "conversely , there exists an rl cqe instance that admits an optimal obstruction , but no optimal view .",
    "we now show how to apply resolution - based techniques to compute optimal obstructions for linear datalog cqe instances and then adapt the results to ql .",
    "in fact , we can guarantee not only existence of optimal obstructions for such instances , but also uniqueness and polynomiality of corresponding censors .",
    "our solution for linear datalog instances is based on the computation of the set @xmath153 of existential closures of goals in the proofs of policies .",
    "however , since all the rules in the ontology are linear and the body of the policy is an atom ( recall that the rule corresponding to the policy should be linear as well ) , each of these goals consists of a single atom , except the last goal in each proof , which is empty .",
    "there are only polynomial number of such atoms ( up to renaming of variables ) .",
    "so , all the proofs can be represented by a single finite _ proof graph _ with atoms and the empty conjunction ( denoted by @xmath13 ) as nodes , and sld resolution steps as edges .",
    "this is illustrated by the following example .",
    "[ ex : graph - proof ] consider a cqe instance with ontology @xmath162 dataset @xmath163 , and policy @xmath164 .",
    "a fragment of the proof graph is given in figure  [ fig : proof_graph ] .",
    "using proof graphs we can compute optimal censors .",
    "theoremalgorithmforqliscorrect [ thm : optimal censors for linear rl ]",
    "let @xmath165 be a linear datalog cqe instance , and let @xmath15 be the set of all nodes in the proof graph of @xmath9 on the paths from facts @xmath154 with any tuple of constants @xmath21 to @xmath13 . then , the boolean ucq @xmath166 is an optimal obstruction computable in polynomial time , and @xmath56 is the unique optimal censor for @xmath167 .    for the instance in example  [ ex : graph - proof ] there is only one path in the proof graph from the policy to @xmath13 , and @xmath168 .",
    "thus , @xmath169 is optimal .",
    "finally , note that the transformation of a ql ontology @xmath7 to an rl ontology @xmath123 given in definition  [ xidef ] , preserves linearity of rules .",
    "hence , proposition  [ thm : combined - approach ] with theorem  [ thm : optimal censors for linear rl ] yield the following result .",
    "theoremobstructionforql [ thm : obstruction censor for ql ] every ql cqe instance admits a unique optimal censor based on an obstruction that can be computed in polynomial time .    ]",
    "the formal study of privacy in databases has received significant attention .",
    "cqe for propositional databases with complete information has been studied in @xcite .",
    "cqe was extended to ( propositional ) incomplete databases in @xcite .",
    "@xcite ( @xcite ) studied _ perfect privacy_. perfect privacy , however , is very strict and may preclude publishing of any meaningful information when extended to ontologies  @xcite .",
    "view - based authorisation was investigated in @xcite , and @xcite ( @xcite ) analysed the implications to privacy derived from publishing database views .",
    "privacy in the context of ontologies is a growing area of research .",
    "information hiding at the schema level was studied in  @xcite .",
    "data privacy for @xmath170 and @xmath171 dls was investigated in  @xcite , and the notion of a privacy - preserving reasoner was introduced in  @xcite .",
    "@xcite ( @xcite ) extended the view - based authorisation framework by @xcite ( @xcite ) to dl ontologies .    an early work on non - propositional cqe is  @xcite .",
    "cqe for ontologies has been studied in  @xcite .",
    "we extend @xcite ( @xcite ) with a wide range of new results :    we consider arbitrary cqs as policies rather than just ground facts ;    we introduce obstruction censors , compare their expressive power with that of view censors , characterise their optimality , and show how to compute obstructions for linear datalog and ql ontologies ;    we show undecidability of checking existence of an optimal view censor and provide algorithms for guarded datalog and all the owl 2 profiles .",
    "we see our work as complementary to @xcite ( @xcite ) and @xcite ( @xcite ) .",
    "the former focuses on situations where attackers have access to external sources of background knowledge ; they identify additional vulnerabilities and propose solutions within the cqe framework . the latter focuses on meta - properties of general censors that , in contrast to ours , can also provide unsound answers or refuse queries .",
    "we studied cqe in the context of ontologies .",
    "our results provide insights on the fundamental tradeoff between accessibility and confidentiality of information . moreover , they yield a flexible way for system designers to ensure selective access to data . in particular , we proposed tractable view based solutions for cqe instances with tree - shaped and linear datalog and ql ontologies , and tractable obstruction based solutions for linear datalog and ql ontologies .",
    "our solutions can be implemented using off - the - shelf query answering infrastructure and provide a starting point for cqe system development .",
    "jie bao , giora slutzki , and vasant honavar . .",
    "wi _ , pages 791797 , 2007 .",
    "joachim biskup and piero bonatti . .",
    ", 38(2):199222 , 2001 .",
    "joachim biskup and piero bonatti . .",
    ", 3(1):1427 , 2004 .",
    "joachim biskup and piero bonatti . . ,",
    "50(1 - 2):3977 , 2007 .",
    "joachim biskup and torben weibert . . ,",
    "7(3):199217 , 2008 .",
    "piero bonatti and luigi sauro . .",
    "in _ iswc _ , pages 1732 , 2013 .",
    "piero bonatti , sarit kraus , and v.  s. subrahmanian . .",
    ", 7(3):406422 , 1995 .",
    "diego calvanese , giuseppe de giacomo , maurizio lenzerini , and riccardo rosati . .",
    ", 78(1):2646 , 2012 .",
    "bernardo cuenca grau and ian horrocks . .",
    "in _ ecai _ , pages 4044 , 2008 .",
    "bernardo cuenca grau and boris motik . .",
    ", 45:197255 , 2012 .",
    "bernardo cuenca grau , evgeny kharlamov , egor  v. kostylev , and dmitriy zheleznyakov . .",
    "in _ iswc _ , pages 4965 , 2013 .    alin deutsch and yannis papakonstantinou . .",
    "in _ icdt _ , pages 230245 , 2005 .    phokion  g. kolaitis and moshe  y. vardi . .",
    "in _ complexity of constraints _ , pages 125155 , 2008 .",
    "boris konev , dirk walther , and frank wolter . .",
    "in _ ijcai _ , pages 830835 , 2009 .",
    "roman kontchakov , carsten lutz , david toman , frank wolter , and michael zakharyaschev . .",
    "in _ ijcai _ , pages 26562661 , 2011 .",
    "carsten lutz , david toman , and frank wolter . .",
    "in _ ijcai _ , pages 20702075 , 2009 .",
    "carsten lutz , inan seylan , david toman , and frank wolter . .",
    "in _ iswc _ , pages 314330 , 2013 .",
    "jerzy marcinkowski . .",
    ", 29(1):231257 , 1999 .",
    "gerome miklau and dan suciu . , 73(3):507534 , 2007 .",
    "boris motik , bernardo cuenca grau , ian horrocks , zhe wu , achille fokoue , and carsten lutz .",
    ", 2012 . recommendation .",
    "shariq rizvi , alberto  o. mendelzon , s.  sudarshan , and prasan roy . .",
    "in _ sigmod _ , pages 551562 .",
    "acm , 2004 .",
    "ravi  s. sandhu , edward  j. coyne , hal  l. feinstein , and charles  e. youman . .",
    ", 29(2):3847 , 1996 .",
    "george  l. sicherman , wiebren de  jonge , and reind  p. van  de riet . . ,",
    "8(1):4159 , 1983 .",
    "giorgio stefanoni , boris motik , and ian horrocks . .",
    "in _ aaai _ , pages 11771183 , 2013 .",
    "phiniki stouppa and thomas studer . .",
    "psi _ , pages 400408 , 2007 .",
    "thomas studer and johannes werner . .",
    ", 7(3):223252 , 2014 .",
    "jia tao , giora slutzki , and vasant honavar . .",
    "in _ rr _ , pages 195203 , 2010 .    zheng zhang and alberto  o. mendelzon . .",
    "in _ icdt _ , pages 259273 , 2005 .",
    "before proving theorem  [ th : simulation ] we present the following notation and a lemma .",
    "let @xmath172 be a finite structure and @xmath173 a function associating a fresh variable to each domain element of @xmath172 .",
    "the query @xmath174 for @xmath172 is the boolean cq defined as follows , with @xmath175 the predicates interpreted by @xmath172 : @xmath176    given a bcq @xmath34 , denote @xmath177}$ ] the structure interpreting each @xmath128 , occurring in @xmath34 , with @xmath178 for every atom @xmath179 in @xmath34 , where @xmath173 maps each constant in @xmath34 to itself and each variable @xmath180 to a fresh constant @xmath181 .",
    "[ lem : known - csp ] let @xmath73 be a finite structure and let @xmath66 be a class of finite structures .",
    "then , the following holds : @xmath182    let @xmath71 be such that @xmath183 ; clearly , @xmath184 and hence @xmath185 , as required .",
    "conversely , assume that @xmath71 is such that @xmath185 ; then , there exists @xmath186 such that @xmath187 , @xmath188 and @xmath189 .",
    "the latter implies that @xmath190 and hence we can deduce @xmath183 , as required ( otherwise , we would have by composition of homomorphisms that @xmath191 , which is a contradiction ) .",
    "+ @xmath192 assume that @xmath54 defines @xmath193 , which is equal to @xmath194 .",
    "then , for each @xmath71 we have that @xmath195 iff @xmath196 . by lemma  [ lem : known - csp ] ,",
    "the following holds for each @xmath71 : @xmath197 let @xmath43 be a cq , and let @xmath198 , which implies that @xmath199 } { \\ensuremath{\\hookrightarrow}\\xspace}{\\mathcal{h}_{{\\ensuremath{\\mathcal{o}}\\xspace},{\\ensuremath{\\mathcal{d}}\\xspace}}}$ ] and hence @xmath199 } \\in \\mathbb{c}$ ] .",
    "we show that @xmath200 iff @xmath201 .",
    "for the forward direction , assume that @xmath202 ; then , @xmath203 and hence @xmath199 } { \\ensuremath{\\hookrightarrow}\\xspace}{\\mathcal{h}_{{\\ensuremath{\\mathcal{o}}\\xspace},{\\ensuremath{\\mathcal{v}}\\xspace}}}$ ] .",
    "we can then conclude @xmath199 } \\not\\models \\bigvee_{{\\mathcal{k } } \\in \\mathbb{c } ,       { \\mathcal{k } } \\not{\\ensuremath{\\hookrightarrow}\\xspace}{\\mathcal{h}_{{\\ensuremath{\\mathcal{o}}\\xspace},{\\ensuremath{\\mathcal{v}}\\xspace } } } } { q^{{\\mathcal{k}}}}$ ] ( otherwise , @xmath204}$ ] for some @xmath205 in @xmath54 and since we have established that @xmath199 } { \\ensuremath{\\hookrightarrow}\\xspace}{\\mathcal{h}_{{\\ensuremath{\\mathcal{o}}\\xspace},{\\ensuremath{\\mathcal{v}}\\xspace}}}$ ] and homomorphism compose we would have @xmath206 which is a contradiction ) .",
    "but then , equation   implies that @xmath199 } \\not\\models u$ ] and by the definition of obstruction - censor that @xmath201 , as required .    for the backward direction , assume now that @xmath201",
    "then , by the definition of obstruction censor we have @xmath199 } \\not\\models u$ ] . by equation",
    "we then have @xmath199 } \\not\\models \\bigvee_{{\\mathcal{k } } \\in \\mathbb{c } ,       { \\mathcal{k } } \\not{\\ensuremath{\\hookrightarrow}\\xspace}{\\mathcal{h}_{{\\ensuremath{\\mathcal{o}}\\xspace},{\\ensuremath{\\mathcal{v}}\\xspace } } } } { q^{{\\mathcal{k}}}}$ ] .",
    "lemma  [ lem : known - csp ] immediately implies that @xmath199 } \\not\\in { \\{{\\ensuremath{\\mathcal{i}}\\xspace}\\in \\mathbb{c } \\mid { \\ensuremath{\\mathcal{i}}\\xspace}\\not{\\ensuremath{\\hookrightarrow}\\xspace}{\\mathcal{h}_{{\\ensuremath{\\mathcal{o}}\\xspace},{\\ensuremath{\\mathcal{v}}\\xspace}}}\\}}$ ] . from this",
    ", we must conclude that @xmath199 } \\in { \\{{\\ensuremath{\\mathcal{i}}\\xspace}\\in \\mathbb{c } \\mid { \\ensuremath{\\mathcal{i}}\\xspace}{\\ensuremath{\\hookrightarrow}\\xspace}{\\mathcal{h}_{{\\ensuremath{\\mathcal{o}}\\xspace},{\\ensuremath{\\mathcal{v}}\\xspace}}}\\}}$ ] and hence @xmath199 } { \\ensuremath{\\hookrightarrow}\\xspace}{\\mathcal{h}_{{\\ensuremath{\\mathcal{o}}\\xspace},{\\ensuremath{\\mathcal{v}}\\xspace}}}$ ] , which implies @xmath203 and @xmath202 , as required .",
    "@xmath207 assume that @xmath208 . to show that @xmath54 defines @xmath194 , we prove that @xmath196 iff @xmath195 for every structure @xmath172 in @xmath66 .",
    "if @xmath209 and @xmath196 , then @xmath210 .",
    "since @xmath208 , we also have that @xmath211 and hence @xmath212 .",
    "consequently , @xmath195 , as required .",
    "if @xmath195 , then @xmath212 ; consequently , @xmath211 .",
    "since @xmath208 , we have @xmath210 and hence , since @xmath209 , we necessarily have @xmath196 .    first we illustrate that obstruction censors can not always simulate view censors .",
    "consider cqe instance @xmath213 , where @xmath8 represents an undirected graph with nodes `` green '' @xmath214 and `` blue '' @xmath215 , which are connected by @xmath216 in all possible ways : @xmath217 clearly , @xmath8 entails every boolean cq over the @xmath218 relation and thus every graph can be homomorphically embedded into @xmath8 .",
    "consider @xmath219 . since the ontology is empty ,",
    "@xmath220 and @xmath221 is the class of all graphs that are not 2-colourable .",
    "it is well - known that this class of graphs is not first - order definable and hence can not be captured by a ucq .",
    "next we construct an obstruction censor which can not be simulated by a view censor .",
    "consider the instance @xmath222 , where @xmath223 and @xmath7 consists of the single transitivity rule @xmath224 clearly , @xmath9 entails each boolean cq over the @xmath218 relation . consider obstruction @xmath225 , which defines the class of directed graphs with self loops .",
    "suppose that some view @xmath40 realises @xmath56 . by theorem [ th :",
    "simulation ] , the obstruction @xmath54 must define @xmath194 where @xmath226 is the class of all directed graphs . thus , any graph @xmath150 must satisfy the property @xmath227 due to the rule in @xmath7 , we conclude that @xmath40 is a dag , that is , it has no @xmath218-loops .",
    "take a dag @xmath150 extending ( a graph isomorphic to ) @xmath65 with a new node @xmath228 and edges connecting all its sink nodes to @xmath228 .",
    "clearly @xmath150 has no self loops , but @xmath229 , which is a contradiction.=-1      the proof is by reduction from the following problem : does a deterministic turing machine without a final state have a repeated configuration ?",
    "this problem is undecidable by rice s theorem .",
    "formally , for every such turing machine @xmath230 with @xmath231 a tape alphabet , which include the blank symbol @xmath232 , @xmath233 a set of states , @xmath234 an initial state , and @xmath235 a transition function , we construct an datalog cqe instance @xmath236 such that it admits an optimal view if and only if @xmath237 starting on the empty tape has a repeated configuration .",
    "the notion of configuration is as usual ",
    "it is the content of the tape and the head pointer to a cell on the tape .",
    "note that the transition function @xmath142 is defined is such a way that the initial state does not appear in a computation anywhere except the initial configuration .",
    "this clearly does not affect the undecidability of the problem .",
    "we also assume , that the tape of the machine is infinite in both directions , and all of it can freely be used for computations .",
    "we start the construction of @xmath238 from the dataset @xmath8 .",
    "it uses only one constant @xmath91 and consists of three binary atoms @xmath239 the predicate @xmath240 is intended to point to the next cell on the tape , the predicate @xmath15 points to the same cell in the following configuration , and the predicate @xmath128 is responsible for initialisation .",
    "we start the definition of the ontology @xmath7 with the description of the role of @xmath128 .",
    "let @xmath7 contain rules @xmath241 as we will see formally later , these rules guarantee that if @xmath238 admits an optimal view , then this view contains the fact @xmath242 .",
    "this fact initialises the tape by means of the following rules ( conjunction in heads is just a syntactic sugar ) : @xmath243 in these rules @xmath244 is a unary predicate indicating that the head is pointing to the first cell and the state is @xmath245 . for each other state @xmath246 in @xmath247",
    "the vocabulary contains the corresponding predicate @xmath248 .",
    "the rest of the tape should always be marked by predicates @xmath249 indicating that the head does not point to this cell .",
    "similarly , if in some configuration a cell contains an alphabet symbol @xmath250 , then this is indicated by the predicate @xmath251 ; for example , the rules above ensure that the tape is initialised by the symbol @xmath232 . to ensure the consistency of the computation grid , constructed by means of tape and time predicates @xmath240 and @xmath15 , the ontology contains the rules @xmath252 finally",
    ", we need to make the adjacent configurations consistent .",
    "in particular , the content of each cell , as well as the fact that the head is pointing to this cell in some particular state , that is , the cell s @xmath248 and @xmath251 labels , is completely defined by the labels of the three cells in the previous configuration .",
    "so , abbreviating @xmath253 by @xmath254 , the ontology @xmath7 contains the rules @xmath255    having the ontology defined , we complete the construction with specifying the policy .",
    "it consists of several bcqs , but the translation to a single cq by means of several rules in the ontology is straightforward .",
    "the policy @xmath26 guarantees that a cell can not contain several alphabet symbols , the machine can not be in several states , and the head can not simultaneously point and not point to a cell .",
    "this is formalised as the following set of bcqs : @xmath256    completed the construction , next we formally prove that @xmath237 has a repeated configuration if and only if @xmath238 has a ( finite ) optimal view .",
    "we start with forward direction .",
    "( @xmath257 )    let the first pair of repeated configurations of @xmath237 have numbers @xmath83 and @xmath81 , while the smallest ( non - positive ) number of a cell whose content was changed during the computation is @xmath258 , and the biggest ( non - negative ) such number is @xmath259 ( we assume that initially the head is pointing to the cell number 0 ) .",
    "note that @xmath260 and @xmath261 are finite , because a computation can not use infinite number of cells in finite number of steps .",
    "in fact , @xmath262 and @xmath263 .",
    "the view @xmath40 makes use of constants @xmath264 with @xmath265 and @xmath266 , such that @xmath267 and all others are anonymous copies of @xmath91 . by means of binary predicates @xmath15 and @xmath240 these constants form a grid , that is the view contains atoms @xmath268 the grid is `` folded '' on all the sides , in the configuration number @xmath269 and cells number @xmath260 and @xmath261 by means of self loops , and on repeated configurations @xmath83 and @xmath81 : @xmath270 each configuration with number @xmath271 with the word @xmath272 written on the part of the tape with cell numbers from @xmath260 to @xmath261 , the state @xmath246 , and the head pointing to the cell number @xmath273 is represented by means of the following facts : @xmath274 the auxiliary `` configuration '' number @xmath275 is the same as a usual configuration with the empty tape , except that the head does not point anywhere : @xmath276 the constant @xmath91 is in the initialisation predicates : @xmath277 finally , each configuration with number @xmath265 ( i.e. , including the auxiliary one ) has cells with numbers @xmath278 and @xmath279 such that all the cells between @xmath260 and @xmath278 , as well as all the cells between @xmath279 and @xmath261 contain @xmath232 and do not have the head pointing on them .",
    "the first group is marked by @xmath280 and the second by @xmath281 : @xmath282    it is straightforward to see that @xmath283 and @xmath284 , that is , @xmath40 is a confidentiality preserving view for @xmath238 . also , it is a matter of technicality to check that the view is indeed optimal .",
    "( @xmath285 )    next we show that if the machine @xmath237 does not have a repeated configuration , then there is no optimal view for the instance @xmath238 .",
    "assume for the sake of contradiction that such a view @xmath40 exists .",
    "without loss of generality we may assume that @xmath283 .",
    "the first fact we need is the following claim .",
    "the view @xmath40 contains the atom @xmath242 .",
    "whatever is the shape of @xmath40 , it entails the bcqs @xmath286 since @xmath287 is unbounded , but @xmath40 is finite , there exists @xmath288 such that there is a homomorphism from the body of @xmath289 to @xmath40 which sends different @xmath290 and @xmath291 to the same constant .",
    "this means that there is an @xmath128-loop of some length in @xmath40 , which is connected by an @xmath128-chain from @xmath91 . by the rules ( [ in1])([in3 ] )",
    "this implies that @xmath242 is a fact in @xmath40 .",
    "similarly to the proof of the claim above , whatever is the shape of @xmath40 , it entails the bcqs whatever is the shape of @xmath40 , it entails the bcqs @xmath292 since @xmath40 is finite , this implies that there is the ( finite ) biggest number @xmath293 such that the body of @xmath294 has a homomorphism to @xmath40 which sends different @xmath290 to different constants .",
    "consider now a `` grid '' bcq @xmath295 that consists of the following atoms : @xmath296 this query is also `` harmless '' , that is , should be entailed by @xmath40 whatever is its shape . since this bcq has a chain of @xmath15 starting from @xmath91 of length greater than @xmath297 , for any homomorphism from the body of @xmath295 to @xmath40 there are numbers @xmath260 and @xmath261 such that this homomorphism sends @xmath298 and @xmath299 to the same constant .",
    "let @xmath273 be such a homomorphism , and @xmath260 , @xmath261 be the numbers corresponding to @xmath273 . by rules ( [ grid1 ] ) and ( [ grid2 ] ) we have that @xmath40 contains atoms",
    "@xmath300    on the other hand , by the fact that @xmath242 is in @xmath40 and the rules ( [ in4])([in6 ] ) we have that the constants @xmath301 for @xmath302 represent the part of the initial configuration on cells with numbers from @xmath303 to @xmath81 .",
    "furthermore , by means of the rules corresponding to the transition function of the machine , the constants @xmath304 form the part of the configuration with number @xmath287 for all @xmath305 . by the same rules and atoms ( [ loop ] )",
    "we conclude that the constants @xmath306 represent not only the part of the configuration number @xmath260 , but also the part of the configuration number @xmath261 .",
    "if these parts are different , then this discloses the policy , so they are the same .",
    "but the rest of the configuration , that is the content of the tape beyond the cells with numbers from @xmath303 to @xmath81 , is also the same for the configurations , because they are just full of symbols @xmath232 ( the head can not reach this part of the tape because it is too far ) .",
    "so , we come to the fact that @xmath237 has a repeated computation , which contradicts the precondition .",
    "propositionbasicview[prop : basic - view - properties ] the censor @xmath42 based on a view @xmath40 is confidentiality preserving for a cqe instance @xmath165 if and only if @xmath307 for each @xmath308 .",
    "additionally , it is optimal if and only if for each cq @xmath43 and each @xmath309 , the fact that @xmath310 for any @xmath308 implies that @xmath311 .",
    "assume that @xmath307 for each @xmath308 .",
    "trivially , @xmath312 and hence we have @xmath313 for each @xmath308 , as required .",
    "assume now that @xmath33 is confidentiality preserving , in which case @xmath313 for each @xmath308 .",
    "next , assume for the sake of contradiction that @xmath314 for some @xmath308 . since @xmath315 , by the definition of policy we have that @xmath316 and thus @xmath317 ; therefore , @xmath318 , which is a contradiction .",
    "we next focus on the optimality statement .",
    "assume that @xmath310 for any @xmath308 implies that @xmath311 , while @xmath42 is not optimal .",
    "then , there is a confidentiality preserving censor @xmath33 that extends @xmath42 ; this means that for some cq @xmath43 and , @xmath309 we have @xmath319 , but @xmath320 .",
    "the fact that @xmath320 and @xmath309 implies that @xmath321 .",
    "furthermore , the fact that @xmath33 is confidentiality - preserving implies that @xmath322 for any @xmath308 .",
    "but then , since @xmath33 extends @xmath42 , we have that @xmath323 and hence @xmath324 , and therefore @xmath325 , which is a contradiction .",
    "finally , assume that there exists some cq @xmath43 and @xmath309 such that @xmath326 for each @xmath308 , but @xmath327 .",
    "then , we can define a censor @xmath33 that behaves exactly like @xmath42 , with the exception of answering @xmath328 positively .",
    "thus , @xmath329 .",
    "but then , since @xmath326 for each @xmath308 and @xmath312 we have that @xmath330 , which implies that @xmath33 is confidentiality preserving and @xmath331 is not optimal , as required .",
    "we say that a rule is _ normalised _ if it has at most two atoms in its body ; an ontology is _ normalised _ if it is a set of normalised rules .",
    "clearly , any guarded ontology can be normalised .",
    "[ def : predicates closed under o ] let @xmath332 be a signature , an ontology over @xmath332 , and a subset @xmath15 of @xmath332 is a set of unary predicates .",
    "@xmath15 is _ closed under  _ if    @xmath333 implies that @xmath334 and    if @xmath127 does not occur in  , then @xmath335 .     +",
    "* guarded , tree - shaped cqe instance .",
    "* algorithm  [ alg : view guarded datalog full ] presents a procedure that builds a view for a given cqe instance @xmath165 .",
    "we are going to show that if @xmath24 is tree - shaped and guarded , then the algorithm returns an optimal view for @xmath167 . by its construction , the constructed dataset @xmath336is safe",
    ", so it remains to prove its optimality .",
    "due to proposition  [ prop : basic - view - properties ] , it suffices to show that for each cq @xmath34 and a tuple @xmath337 such that @xmath309 : @xmath338 } \\not\\models { [ { p(\\vec s ) } ] }      \\text { for each } \\vec s \\in { \\mathsf{cert}(p,{\\ensuremath{\\mathcal{o}}\\xspace},{\\ensuremath{\\mathcal{d}}\\xspace } ) } ,      \\text { then } \\vec t \\in { \\mathsf{cert}(q,{\\ensuremath{\\mathcal{o}}\\xspace},{\\ensuremath{\\mathcal{v}}\\xspace})}.\\end{aligned}\\ ] ] observe the following .",
    "1 .   w.l.g .",
    "we can assume that @xmath339}$ ] .",
    "[ it : opt view th guarded datalog , maximised query ] 2 .",
    "if @xmath340 is as defined in algorithm  [ alg : view guarded datalog full ] , @xmath341 and @xmath342 consists of unary atoms only over fresh predicates introduced into @xmath343 at line  1 .",
    "no rule of @xmath343 can be applied to @xmath336 .",
    "assume that @xmath328 satisfies the `` if''-clause of equation  .",
    "since by the assumption @xmath309 , then there is a homomorphism @xmath273 from @xmath344}}}$ ] into @xmath62 .",
    "it is easy to see that @xmath345 } } } \\rightarrow { \\mathcal{h}_{{\\ensuremath{\\mathcal{o}}\\xspace},{\\ensuremath{\\mathcal{d}}\\xspace } } }      \\text { iff }      h : { \\mathcal{h}_{{\\ensuremath{\\mathcal{o}}\\xspace}_e,{[{q(\\vec t ) } ] } } } \\rightarrow { \\mathcal{h}_{{\\ensuremath{\\mathcal{o}}\\xspace}_e,{\\ensuremath{\\mathcal{d}}\\xspace}}}.\\end{aligned}\\ ] ] we are going to use the following notations .    *",
    "denote @xmath346}}}$ ] as @xmath347 .",
    "* let @xmath348 be a dataset and @xmath349 an element occurring in @xmath348 .",
    "then we define the set @xmath350 as @xmath351 .",
    "we are going to show the existence of a homomorphism @xmath352 , which would prove that @xmath34 satisfies the `` then''-clause of equation  .",
    "let @xmath353 be all the fresh constants from @xmath199}$ ] , let @xmath349 be an element from @xmath199}$ ] , and let @xmath273 be a homomorphism from @xmath347 into @xmath340 .",
    "we claim that there exists @xmath214 that satisfies the following properties :    if @xmath349 is from @xmath9 , then @xmath354 .",
    "let @xmath355 and @xmath356",
    ". then @xmath357 such that @xmath358 , @xmath359 and @xmath360 , where @xmath361 is a set of all `` copies '' of @xmath91 introduced by the algorithm ( for example , see sub - routines in algorithm  [ alg : view guarded datalog sub - routines 1 ] ) .",
    "it remains to show that @xmath214 does indeed exist and map @xmath347 into @xmath40 . to this end , we need to show that    for each element @xmath349 from @xmath199}$ ] , there is an element @xmath362 in @xmath40 satisfying the second property of @xmath214 , and    for each binary atom @xmath363}$ ] , there exists a corresponding binary atom @xmath364 .",
    "the former requirement follows from the construction of @xmath336 .",
    "the latter one requires that @xmath365 note that equation  [ eq : view optimality criterion for guarded datalog ] implies that @xmath366 . also observe that _ no rule from @xmath343 is applicable to @xmath367_. indeed , no rule is applicable to @xmath40 nor to @xmath347 by construction .",
    "assume that a rule @xmath140 is applicable to @xmath367 .",
    "if the body of @xmath140 contains one atom , then we immediately obtain a contradiction .",
    "if the body of @xmath140 contains two atoms then there exist an atom @xmath368 and an atom @xmath369 such that @xmath370 is an instantiation of the body of @xmath140 .",
    "assume that the atom in the body of @xmath140 corresponding to @xmath371 is a guard of the rule ; then all constants occurring in @xmath372 occur in @xmath371 too .",
    "since @xmath373and @xmath336share only `` active '' constants ( i.e. , the ones from @xmath167 ) , we have that @xmath374 ( due to observation  [ it : opt view th guarded datalog , maximised query ] ) , and thus @xmath140 is applicable to @xmath336 , which gives a contradiction .",
    "assume that equation  [ eq : homomorphism is safe ] does not hold .",
    "hence , there is a rule @xmath375 applicable to @xmath376 .",
    "recall that @xmath140 is not applicable to @xmath40 .",
    "we have the following cases depending on the shape of @xmath140 .    1 .",
    "@xmath140 is of the form @xmath377 , @xmath378 , or @xmath379 .",
    "clearly , in this case @xmath140 is applicable to @xmath380 .",
    "it is easy to see that @xmath140 is then applicable to @xmath373 since @xmath381 for every @xmath349 in @xmath347 , which contradicts the observation above . 2 .",
    "@xmath140 is of the form @xmath382 or @xmath383 , where @xmath384 is of one of the following forms for some unary @xmath385 of binary @xmath34 predicate : @xmath386 , @xmath387 , @xmath388 , or @xmath389 . here",
    "we obtain a contradiction similarly to the previous case .",
    "@xmath140 is of the form @xmath390 .",
    "there are three cases .",
    "a.   there are @xmath91 , @xmath215 , and @xmath391 such that @xmath392 and @xmath393 , where @xmath394 .",
    "since @xmath140 is not applicable to @xmath373 , then for any element @xmath395 occurring in @xmath373 ,",
    "it is the case that @xmath396 . thus , @xmath397 and consequently @xmath398 .",
    "the latter statement contradicts the assumption that @xmath392 . b.   there are @xmath91 , @xmath399 , and @xmath391 such that @xmath400 and @xmath401 , where @xmath394 . since @xmath140 is not applicable to @xmath373 , then @xmath402 and thus @xmath403 .",
    "this contradicts that @xmath401 . c.   there are @xmath91 , @xmath215 , @xmath399 , @xmath391 , and @xmath404 such that @xmath400 , @xmath405 , @xmath406 , and @xmath407 .",
    "then we conclude that @xmath408 and consequently @xmath393 . if @xmath409 is equal to @xmath410 or @xmath411 for some unary predicate @xmath385 , then @xmath412 or @xmath413 , respectively , and thus @xmath414 or @xmath415 , respectively .",
    "if @xmath409 is equal to @xmath416 for some binary predicate @xmath34 , then @xmath417 and @xmath418 , and thus @xmath419 and @xmath420 are in @xmath336 ; therefore , @xmath421sub - routine of the algorithm would return @xmath422 on input @xmath423 , and thus @xmath424 .",
    "anyway , the obtained contradictions conclude the case .",
    "@xmath140 is of the form @xmath425 .",
    "this case is analogous to the previous one .",
    "finally , @xmath426 should be in @xmath336for each binary atom @xmath427 , since    equation   holds and    binary atoms that do not discover the policy were exhaustively added to @xmath336 .    regarding the size of the @xmath336 , if @xmath91 is a constant occurring in @xmath24 and @xmath385 a set of unary predicates @xmath127 such that @xmath428 , then the number of `` copies '' of @xmath91 added by the algorithm is equal to a number of subsets of @xmath385 closed under @xmath343 ( see algorithm  [ alg : view guarded datalog sub - routines 1 ] ) .",
    "clearly , this number is exponential in @xmath429 and polynomial in @xmath430 ( see definition  [ def : predicates closed under o ] ) .    * multi - linear , tree - shaped cqe instance .",
    "* let a dpi @xmath165 be such that is multi - linear datalog .",
    "let @xmath40 be a dataset returned by algorithm  [ alg : view guarded datalog full ] .",
    "for every constant @xmath91 , the set @xmath361 contains the constant @xmath431 such that @xmath432 is a maximal subset of @xmath433 closed under @xmath343 .",
    "it is easy to check that the number of such subsets is polynomial in the size of @xmath7 .",
    "the set @xmath432 is a maximal set of labels ( i.e. , unary predicates ) among all constants in @xmath361 ,",
    "i.e. , if @xmath358 , then @xmath434 for some @xmath432 . we will also denote as @xmath435 an element of @xmath361 such that @xmath436 .",
    "let @xmath215 be a constant from @xmath167and let @xmath362 be from @xmath361 such that @xmath437 is in @xmath438",
    ". since @xmath167is multi - linear , does not include rules with bodies of the form @xmath439 and thus whatever unary atoms @xmath362 participates in , they can not affect the atoms @xmath215 participates in . hence we conclude that    if @xmath440 is in @xmath336for some @xmath358 and @xmath215 from @xmath167 , then so is @xmath441 for a corresponding element @xmath435 from @xmath361 ;    if @xmath442 is in @xmath336for some @xmath358 and @xmath443 , then so is @xmath444 for corresponding elements @xmath435 and @xmath445 from @xmath361 and @xmath446 , respectively .",
    "let @xmath447 be a subset of @xmath40 which is based on constants @xmath91 from @xmath167and their copies @xmath435 . clearly if , for some cq @xmath43 , @xmath63 and @xmath448 , then @xmath449 , which proves optimality of @xmath447 .",
    "the polynomial size of @xmath447 follows from the observation that the sub - routine @xmath450introduces only linearly many copies of a constant @xmath91 for each set of labels , including @xmath432 .    * linear , tree - shaped cqe instance . * finally , assume that is linear . then , there is the unique maximal subset @xmath451 of @xmath438 such that @xmath452 , which gives the uniqueness of @xmath336 .",
    "first we show the confidentiality preservation of the censor .",
    "since @xmath453 is confidentiality - preserving , we have that @xmath454 for each @xmath308 .",
    "since @xmath115 is datalog , it is clear that @xmath455 ; thus , @xmath456 for each @xmath308 .",
    "but then , since @xmath26 is tree - shaped and @xmath115 is a rewriting of @xmath7 we have @xmath307 for each @xmath308 ( see  @xcite ) , as required .",
    "now we concentrate on the optimality of the view .",
    "assume by contradiction that @xmath42 is not optimal , then , by proposition  [ prop : basic - view - properties ] , there exists a bcq @xmath34 such that _ ( i ) _ @xmath457 ; _ ( ii ) _ @xmath458 ; and _ ( iii ) _",
    "@xmath459 for each @xmath308 . since @xmath457 and @xmath119 we have _",
    "( iv ) _ @xmath460 . furthermore ,",
    "condition _ ( iii ) _ implies that @xmath461 } \\not\\models p(\\vec s)$ ] and since @xmath26 is tree - shaped and @xmath115 is a rewriting of @xmath7 we have @xmath462 } \\not\\models p(\\vec s)$ ] , which by the fact that @xmath463 then also implies that _",
    "@xmath464 for each @xmath308 .",
    "but then , _",
    "( iv ) _ and _ ( v ) _ and the fact that @xmath120 is optimal for @xmath116 we must have @xmath465 .",
    "since @xmath466 we have @xmath467 , which contradicts _ ( ii)_.      for the sake of ease in the proofs for theorems and propositions of this section we will consider only the class of bcqs with constants .",
    "clearly , any results obtained for this class will also hold for the class of all cqs . before proceeding to the main proofs , we introduce few definitions and lemmas .",
    "let be a datalog ontology and @xmath468a dataset ; let @xmath469 be a possibly infinite set of queries such that @xmath457 for each @xmath470 . then a censor @xmath471 is defined as follows : @xmath472 } \\not\\models q ' \\text { for each } q ' \\in \\mathbb{q}'.\\end{aligned}\\ ] ]    lemmaucqcensorminimalset [ prop : ucq censor over minimal set ] let @xmath165 be a cqe instance ; let @xmath160 be a pseudo - obstruction based on a subset @xmath473 of @xmath153 .",
    "then , @xmath474 .",
    "let @xmath34 be a cq such that @xmath475 .",
    "assume that @xmath476 ; this yields that @xmath177 } \\models q'$ ] for some @xmath477",
    ". then there exists @xmath478 such that @xmath479 and thus @xmath177 } \\models q''$ ] , i.e. , @xmath480 .",
    "assume that @xmath480 ; this yields that @xmath177 } \\models q''$ ] for some @xmath478 .",
    "note that @xmath481 since @xmath482 and thus @xmath476 .",
    "the lemma above allows us to speak of obstruction censors in terms of either @xmath160 or @xmath483 , whatever way is more convenient to show the required results . we are going to show now that a censor @xmath484is optimal for a given cqe instance @xmath24 iff there exists a maximal subset @xmath473 of @xmath153 such that @xmath485 .",
    "but first we need the following notion of a normalised proof .",
    "let be a datalog ontology , @xmath468a dataset , and @xmath145 a goal .",
    "a proof @xmath486 of length @xmath81 of @xmath145 in @xmath9 is _ normalised _ if there is @xmath487 such that @xmath488 for each @xmath489 and @xmath490 for each @xmath491 .",
    "moreover , the number @xmath260 is called the _ frontier _ of @xmath486 , denoted @xmath492 .    intuitively , a normalised proof @xmath486 works as follows : first we rewrite the initial query @xmath145 over the ontology  until we obtain the query @xmath493 that can be mapped into @xmath468 , and then we perform such a mapping applying @xmath494 with @xmath495 . observe that for every @xmath496 with @xmath497 it holds that @xmath498 .",
    "we exploit the following known result about sld resolution over datalog ontologies .",
    "lemmaproofnormalisation [ lem : normalisation of a proof ] let be a datalog ontology , let @xmath468be a dataset , and let @xmath145 be a goal such that @xmath499 .",
    "then there exists a normalised sld proof @xmath486 of @xmath145 in @xmath9 .",
    "[ lem : on characterisation of optimal censors for datalog ] let @xmath165 be a cqe instance with a datalog ontology and @xmath484a censor for @xmath7 and @xmath8 . then @xmath484is optimal for @xmath167iff there exists a maximal subset @xmath473 of @xmath153 such that    @xmath500 for each @xmath308 and    @xmath485 .",
    "we start with the `` only if''-direction .",
    "let us assume that such maximal subset @xmath473 exists .",
    "we show that @xmath501 is optimal .",
    "first , we show that @xmath501 is confidentiality preserving",
    ". assume the contrary ; then , there is a ( finite ) subset @xmath502 of @xmath503 such that @xmath504 for some @xmath308 .",
    "this yields the existence of proof @xmath486 of @xmath505 in @xmath506}$ ] , where @xmath507 } = \\bigcup_{q \\in \\mathbb{f } } { [ { q}]}$ ] . due to lemma  [ lem : normalisation of a proof ] , we can assume that @xmath486 is normalised with frontier @xmath258 .",
    "let @xmath508 be the goal right before frontier in @xmath486 .",
    "since @xmath486 is normalised , then @xmath508 is proved by using only facts from @xmath507}$ ] .",
    "so , we can write @xmath508 as @xmath509 , where each @xmath510 is the conjunction of all atoms that are proved using facts only from a particular @xmath511}$ ] .",
    "obviously , the order in which these @xmath510 are proved is irrelevant , so let us assume that all @xmath510 have been proved except for @xmath512 ; since , the different @xmath510 can share variables , the remaining goal to prove may not be just @xmath512 , but rather @xmath513 , with @xmath514 some substitution .",
    "we make the following observations :    1 .",
    "@xmath513 does not mention any constants not in @xmath9 .",
    "indeed , for any distinct queries @xmath515 , @xmath516 in @xmath502 we have that @xmath517}$ ] and @xmath511}$ ] only share constants from @xmath9 @xmath517}$ ] ; thus , if @xmath513 contains some constant coming from @xmath511}$ ] with @xmath518 , it would not be possible to prove @xmath519 using only facts from @xmath520}$ ] .",
    "2 .   there exists a proof of @xmath505 in @xmath9 such that @xmath513 occurs as a subgoal .",
    "we construct such proof as follows .",
    "first , we can `` reach '' goal @xmath508 because it only requires rules from @xmath7 .",
    "note also that each @xmath510 follows from @xmath9 , so we can continue the proof by showing all @xmath510 except for @xmath512 .",
    "then , we can do it in such a way we reach precisely @xmath513 as a subgoal .",
    "3 .   @xmath521 since @xmath513 is provable from @xmath520}$ ] .",
    "observation 2 means that @xmath522 for all @xmath523 .",
    "furthermore , since the censor answers @xmath524 for each @xmath525 we have that @xmath526 .",
    "but then , @xmath527 , which is a contradiction .",
    "now we show the optimality of @xmath501 .",
    "clearly , a censor @xmath33 for @xmath41 is optimal if and only if for each cq @xmath43 and each @xmath528 the fact that @xmath322 holds for each @xmath308 implies that @xmath529 . due to this",
    ", @xmath501 is optimal if and only if for each @xmath34 such that @xmath475 and @xmath530 , it holds that @xmath531 .",
    "assume to the contrary that there exists a cq @xmath34 such that @xmath475 and @xmath530 , but @xmath532 .",
    "the latter means that @xmath476 , that is , @xmath177 } \\models q'$ ] , for some @xmath477 .",
    "recall that for any @xmath533 it holds that @xmath534 due to maximality of @xmath473 .",
    "observe that @xmath535 ; this yields @xmath536 , which contradicts the initial assumption and concludes the `` only if''-direction .",
    "now we consider the `` if''-direction .",
    "let us now assume that @xmath33 is optimal , and let @xmath537 .",
    "consider the following subset @xmath473 of @xmath153 : @xmath538 . to prove the `` if''-direction",
    ", it suffices to prove the following two conditions :    @xmath473 is a maximal subset of @xmath153 such that @xmath500 for each @xmath308 and    @xmath539 .    to show _ (",
    "i ) _ , assume that @xmath534 for some @xmath308 and some @xmath540 .",
    "clearly , since by construction @xmath541 , it holds that @xmath542 , and therefore @xmath543 , i.e. @xmath470 , which implies _ ( i)_.    to show _",
    "( ii ) _ , let us pick an arbitrary @xmath34 such that @xmath457 but @xmath543 and hence @xmath470 .",
    "since @xmath33 is optimal , we have that @xmath544 for some @xmath308 , so let @xmath502 be any minimal subset of @xmath35 such that @xmath545 . following the same arguments as we used in the `` only if '' direction we have that there exists @xmath546 such that @xmath547 ; since @xmath152 is part of the obstruction , then @xmath476 .",
    "finally , assume that @xmath476 ; then , @xmath547 for some @xmath546 . since @xmath548 , we have that @xmath543 , as required .",
    "let us prove statement 1 .",
    "assume that @xmath160 is a finite pseudo - obstruction .",
    "by lemma  [ prop : ucq censor over minimal set ] , we have that @xmath474 . by the `` only if '' statement in lemma [ lem : on characterisation of optimal censors for datalog ] , we have that @xmath501 is optimal .",
    "but then , since @xmath160 is finite , then @xmath54 is an obstruction .",
    "next , we show statement 2 .",
    "assume by contradiction that each pseudo - obstruction is infinite , but there is an optimal censor based on an obstruction @xmath54 .",
    "since @xmath56 is an optimal censor , then the `` if '' direction of lemma [ lem : on characterisation of optimal censors for datalog ] tells us that there exists a pseudo - obstruction @xmath160 such that @xmath549 .",
    "we can show that then there exists a finite pseudo - obstruction which contradicts the assumption above .",
    "pick any cq @xmath34 from @xmath54 ; then , clearly , @xmath550 and hence @xmath480 .",
    "the latter implies that there exists @xmath551 such that @xmath159 .",
    "let us now construct @xmath552 , which is finite and also a `` subset '' of @xmath160 . to obtain a contradiction , it thus suffices to show now that @xmath553 .",
    "indeed , for each cq @xmath34 such that @xmath554 ( recall that @xmath549 ) :    * assume that @xmath550 ; then there is @xmath158 in @xmath54 such that @xmath177 } \\models q'$ ] , which yields @xmath177 } \\models q''$ ] with @xmath555 from @xmath556 , and therefore @xmath557 . *",
    "assume that @xmath557 ; then @xmath177 } \\models q''$ ] for some @xmath555 in @xmath556 , and consequently , since @xmath481 , we conclude that @xmath558 .",
    "the obtained contradiction concludes the proof .    to show the first statement ,",
    "consider @xmath559 , where @xmath560 , @xmath561 , and the guarded rl ( and el ) ontology @xmath562 @xmath563 .",
    "since this cqe instance is guarded and tree - shaped , by theorem  [ th : guarded ] we can devise an optimal view . no optimal obstruction , however , exists , which is shown in example  [ example : no obstruction censor ] .    to show the second statement , consider cqe instance @xmath564 , with @xmath565 , @xmath566 , and @xmath567 .",
    "from  @xcite we know that no optimal view exists for this instance , and the proof can be easily extended to our framework ( note that our notion of a censor @xmath42 based on a view @xmath40 differs from the one in  @xcite ) extends also to the case where views are not required to be sound . however , @xmath568 is an optimal obstruction , since there is only one proof of @xmath134 with subgoal @xmath569 .",
    "optimality and uniqueness follows from theorem  [ th : characterisation ] and the facts that    the set @xmath15 is exactly @xmath153    the only maximal subset @xmath473 of @xmath153 such that @xmath570 does not entail any @xmath505 is the empty set .    to prove the former fact ,",
    "first observe that any goal that can appear in any sld proof in @xmath9 is isomorphic to one of the nodes of the proof - graph of @xmath9 ; then fact  ( i ) follows directly from the construction of the proof - graph .",
    "fact  ( ii ) follows from the observation that each sld proof in case of linear @xmath7 is normalised , and therefore for each @xmath571 it holds that @xmath572 for some @xmath573 .",
    "finally , polynomiality follows from the fact that in linear datalog the size of the proof - graph is at most cubic in @xmath574 .",
    "let @xmath165 be a cqe instance with @xmath7 in ql .",
    "let @xmath575 be the optimal censor for @xmath576 , where @xmath117 is a set of constants of @xmath167 and @xmath123 is a linear datalog ontology . by theorem  [ thm : optimal censors for linear rl ] , @xmath577 for the ucq @xmath54 as defined in the theorem .",
    "let @xmath578 .",
    "we are going to show that @xmath484is an optimal censor for @xmath24",
    ".    * confidentiality preservation . *",
    "assume that @xmath484is not confidentiality preserving for @xmath24 , that is , @xmath579 for some @xmath308 .",
    "this means that there exist @xmath580 such that @xmath581 ; clearly , @xmath582 for each @xmath583 . by proposition  [ thm : combined - approach ] ,",
    "@xmath129 and consequently @xmath584 for each @xmath583 . since @xmath575 is confidentiality preserving for @xmath116 , we conclude that @xmath585 , so there is @xmath586 such that @xmath587 ; i.e. , @xmath520 } \\models u$ ] . the last entailment implies that @xmath588 , i.e. , @xmath589 , which yields a contradiction and thus @xmath33 is confidentiality preserving for @xmath167 .",
    "* optimality . * assume , for the sake of getting a contradiction , that @xmath484is not optimal for @xmath167 , that is , there exists @xmath34 such that    @xmath457 ,    @xmath590 , and    @xmath591 for each @xmath308 .",
    "this yields @xmath177 } \\models u$ ] for some disjunct @xmath592 in @xmath54 and consequently @xmath593 .",
    "note that for each disjunct @xmath592 in @xmath54 , it holds that @xmath594 for some @xmath308 ; thus @xmath595 .",
    "there are the following cases depending on the form of @xmath592 .    *",
    "if @xmath592 is of the form @xmath134 or @xmath437 with @xmath596 , then @xmath597 since , due to proposition  [ thm : combined - approach ] , @xmath123 is a @xmath117-rewriting of  ; thus , @xmath598 which yields a contradiction with _ ( iii)_. * if @xmath592 is of the form @xmath599 with @xmath600 , then let @xmath601 be a minimal subset of @xmath123 such that @xmath602 . due to the assumption , it holds @xmath603 ; thus , @xmath604 and therefore @xmath601 includes one of the rules introduced by @xmath605 .",
    "that is , @xmath601 contains ( some of ) the following rules that come from the skolemisation @xmath606 of some rule @xmath607 $ ] of type  ( 3 ) in  : @xmath608 consider a proof @xmath609 of @xmath505 in @xmath610}$ ] , where @xmath611 .",
    "clearly , @xmath496 can be obtained from @xmath149 by applying a rule from @xmath601 for each @xmath612 , and @xmath613 for some @xmath614 since the last step of the proof is applying the only rule from @xmath615}$ ] .",
    "let @xmath508 be the first goal in @xmath486 obtained from @xmath616 by applying a rule from equation  ; clearly , @xmath617 .",
    "we have the following cases . *",
    "* assume that we apply the third rule from equality   to @xmath618 for some constant @xmath215 ( note that a goal @xmath619 with @xmath16 a skolem constant can not appear by applying ql rules except for type @xmath620 ) .",
    "then @xmath621 , and the only rule that has @xmath622 in its head is the first one from equality  ; however , this rule can not be applied to @xmath508 since we can not unify @xmath215 and @xmath623 .",
    "thus , this case is invalid . * * assume that we apply the second rule from equality   to @xmath624 for some constants @xmath215 and @xmath349 .",
    "this case is always invalid due to the same reason as the previous one . * * assume that we apply the third rule from equality   to @xmath625 for some constant @xmath215 and skolem constant @xmath16 .",
    "then , @xmath626 and @xmath627 is obtained from @xmath508 by applying the first rule from equation  ; that is , @xmath628 .",
    "but then we have that @xmath629 \\in { \\ensuremath{\\mathcal{o}}\\xspace}$ ] and consequently @xmath630 .",
    "we can assume that starting from @xmath627 rules only from @xmath7 are used , which means that @xmath631 } \\models a(b)$ ] .",
    "* * no other case is possible .",
    "+ thus @xmath632 which contradicts _ ( iii)_.    thus , @xmath484is optimal for @xmath167 , which concludes the proof .",
    "@xmath633 ;    @xmath634 the minimal herbrand model for @xmath343 and @xmath468 ;    @xmath635 a maximal subset of unary atoms from @xmath636 s.t .",
    "@xmath637 ;    @xmath336 ;    * sub - routine @xmath450 *    ' '' ''    @xmath638 ;    @xmath639 ;    @xmath640 ;    @xmath120 ;    ' '' ''    * sub - routine @xmath641 *    ' '' ''    @xmath638 ;    @xmath120 ;    ' '' ''    * sub - routine @xmath421 *    ' '' ''",
    "in this section , we show the reduction of the problem of uniform boundedness for binary datalog to the problem of existence of optimal obstructions for datalog cqe instances ( see section  [ sec : obstruction - optimal ] ) .",
    "let @xmath7 be a binary datalog ontology over a signature @xmath332 ( observe that w.l.o.g .",
    "we can assume that @xmath7 is connected ) .",
    "then , is _ uniformly bounded _ if there is a constant @xmath642 such that for every dataset @xmath8 over @xmath332 and for every ground atom @xmath643 , if the atom has a proof from @xmath7 and @xmath8 , then it has a proof not longer than @xmath642 .",
    "it is well known that each relation @xmath644 defined by @xmath7 is equivalent to an infinite union of cqs @xmath645 .",
    "note that each @xmath646 is a result of applying some sequence of rules from @xmath7 to @xmath644 .",
    "moreover ,      now we are ready to provide the required reduction .",
    "let @xmath7 be a binary datalog ontology .",
    "we are going to construct a cqe instance @xmath648 which admits an optimal obstruction if and only if @xmath7 is uniformly bounded .",
    "the ontology @xmath115 of @xmath167is defined as @xmath649 where all @xmath650 and @xmath651 and @xmath26 are fresh predicates .",
    "the dataset @xmath8 is equal to @xmath652 where @xmath653 is @xmath332 extended with fresh predicates @xmath654 .",
    "observe that this dataset admits any possible proof of @xmath26 .",
    "let @xmath655 are built as in definition  [ def : pseudo obstruction ] .",
    "it is easy to see that @xmath655 contains the queries @xmath656 and @xmath657 of the form @xmath658 and @xmath659 , respectively , for each @xmath660 as each of them with the help of @xmath115 compromises the policy .",
    "assume that @xmath7 is not uniformly bounded ; then , due to property  ( p1 ) , there is some @xmath661 such that for any number @xmath642 we have that @xmath662 .",
    "that is , it is not the case that for each @xmath663 there exists @xmath664 with @xmath665 such that there is a homomorphism from @xmath666 to @xmath667 ( note that here distinguished variables are mapped into themselves ) .",
    "this immediately yields that it is not the case that for each number @xmath642 and for each @xmath668 there exists @xmath669 with @xmath665 such that there is a homomorphism from @xmath669 to @xmath668 ( note that , although here we do not have distinguished variables , we still have that the variables of @xmath669 that correspond to distinguished variables of @xmath666 are mapped to the variables of @xmath668 that correspond to distinguished variables of @xmath667 since they are `` marked '' by predicates @xmath654 ) . moreover , for every predicate @xmath240 different from @xmath34 , it holds that for any @xmath287 and any @xmath670 there is no homomorphism from @xmath668 to @xmath671 since the former one mentions the predicate @xmath672 and the latter one @xmath673 .",
    "hence , there is no finite pseudo - obstruction for @xmath167 and therefore , due to theorem  [ th : characterisation ] , no optimal obstruction censor for @xmath167exists .",
    "assume that @xmath7 is uniformly bounded and @xmath642 is a number such that for any dataset , if a fact can proved from @xmath7 and the dataset , then there is a proof of this fact not longer than @xmath642 .",
    "let @xmath674 be a subset of @xmath655 consisting of those boolean cqs @xmath152 , where @xmath150 is a sub - goal in some proof of @xmath26 in @xmath675 of length not longer than @xmath676 .",
    "we claim that the ucq @xmath677 is an optimal obstruction for @xmath167 .",
    "assume that there exists a boolean cq @xmath678 from @xmath655 with @xmath145 a sub - goal coming from some proof of length greater than @xmath679 .",
    "this means that @xmath680 .",
    "than there exists a proof @xmath486 of @xmath26 from @xmath681 , where @xmath682 } \\cup \\bigcup_{{\\varphi}\\in \\mathbb{s } } { [ { { \\varphi}}]}$ ] , of length no longer than @xmath679 ( @xmath683 step to apply one of the rules @xmath684 from @xmath115 , @xmath642 steps to proof @xmath685 using rules from @xmath686 , and @xmath687 additional steps to proof @xmath688 using facts from @xmath689 for some elements @xmath690 and @xmath691 ) . w.l.o.g . , we can assume that this proof is normalised .",
    "recall that all the rules that are applied after the frontier are from @xmath689 .",
    "we can assume w.l.o.g .  that rules from @xmath692}$ ] are applied only at the very end of the proof .",
    "clearly , the goal @xmath150 right before we start to apply the rules from @xmath692}$ ] is such that"
  ],
  "abstract_text": [
    "<S> we study confidentiality enforcement in ontologies under the controlled query evaluation framework , where a policy specifies the sensitive information and a censor ensures that query answers that may compromise the policy are not returned . </S>",
    "<S> we focus on censors that ensure confidentiality while maximising information access , and consider both datalog and the owl 2 profiles as ontology languages . </S>"
  ]
}