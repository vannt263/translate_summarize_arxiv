{
  "article_text": [
    "given any two sets , @xmath1 and @xmath2 , a _",
    "binary relation between @xmath1 and @xmath2 _ is any subset of the power set of @xmath3 , @xmath4 .",
    "partial functions are just a particular kind of binary relations , in which ordered pairs are restricted to verify the classical notion of function ",
    "i.e . that each element in the domain is mapped to at most one element in the range , although they may be undefined for some elements in the domain ",
    "they are partial .",
    "binary relations are in turn just sets of ordered pairs .",
    "then , all relational operators ( such as @xmath5 , @xmath6 , @xmath7 , etc . ) can be applied to partial functions and all set operators can be applied to both of them .",
    "conversely , and this feature distinguishes partial functions from binary relations , if @xmath8 is an element in the domain of a partial function @xmath9 then @xmath10 is defined as the element , @xmath11 , in the range of @xmath9 such that @xmath12 .",
    "the motivation for adding partial functions to specification / programming languages is primarily to enhance the language s expressive power .",
    "in fact , partial functions constitute a powerful and convenient data abstraction . as an example",
    ", the relation between the key of a table and the rest of its columns is naturally modeled as a partial function .",
    "partial functions are common in formal specification notations , such as z @xcite , b @xcite and alloy @xcite , which are mainly used to specify state - based systems ( notice that , many concepts or features of these systems are best represented as partial functions , not as total functions ) .",
    "usefulness of partial functions in executable programming languages is attested by the common presence of library facilities , e.g. the ` map ` class of java and c++ , that support at some extent the partial function abstraction .",
    "availability of maps , dictionaries or similar associative data structures as _ primitive _ components of some programming languages , such as setl @xcite or phyton , also attests usefulness of the partial function abstraction .",
    "partial functions ( or maps or , more generally , binary relations ) can be added naturally also to clp languages with sets , as observed for instance in @xcite . in particular , in @xcite",
    "we have shown how partial functions can be encoded in the clp language with sets @xmath0(pronounced ` setlog ' ) @xcite . specifically , partial functions can be represented in @xmath0as sets of pairs , where each pair @xmath13 is represented as a list of two elements @xmath14 $ ] .",
    "operations on partial functions can be implemented by user - defined predicates in such a way to enforce the characteristic properties of partial functions over the corresponding set representations .    when partial functions are completely specified this approach is satisfactory , at least from an ` operational ' point of view . on the other hand , when some elements of a partial function or ( part of ) the partial function itself are left unspecified ",
    ", they are represented by unbound variables  then this approach presents major flaws . for example , the predicate ran(f,\\{1 } ) , which holds if \\{1 } is the range of the partial function f , admits infinite distinct solutions f = \\{[x1,1 ] } , f = \\{[x1,1],[x2,1 ] } , ...",
    ", whenever f is unbound . if subsequently a failure is detected , such as with the goal ran(f,\\{1 } ) & dom(f,\\ { } ) , then the computation loops forever and @xmath0is not able to detect the unsatisfiability .    making the implementation of predicates over partial functions more sophisticated as shown for instance in may help in solving more efficiently a larger number of cases , but does not provide a completely satisfactory solution in the general case .",
    "in fact , there are still cases , such as that considered above , in which there is no simple finite representation of the possibly infinite solutions and this may cause the interpreter to go into infinite computations .    most of the above mentioned problems could be solved by viewing partial functions as first - class entities of the language and the operations dealing with them as _ primitive constraints _ , for which the constraint language provides a suitable solver .",
    "hence , the motivation for managing partial functions through constraint solving is primarily to enhance the language effectiveness , that is the ability to compute the satisfiability / unsatisfiability of as many as possible ( complex ) set - based formulas involving partial functions .",
    "selecting @xmath0as the host constraint language for this embedding gives one the possibility to exploit its flexible and general management of sets to represent partial functions and to provide many basic set - theoretical operations on partial functions as primitive set constraints for free .",
    "other more specific operations on partial functions can be added to the language as primitive constraints and the solver can be extended accordingly .",
    "the main original results of this work are : @xmath15 the identification of a small set of operations on partial functions , to be dealt with as primitive constraints , which are sufficient to represent all other common operations on partial functions as simple conjunctions of these constraints ; @xmath16 the definition of a collection of rewrite rules to simplify conjunctions of primitive constraints ; @xmath17 the definition of a labeling mechanism based on the notion of finite representable domains for partial functions ; @xmath18 the definition of a collection of inference rules to detect possible inconsistencies without the need to perform time - consuming labeling operations .    at our knowledge ,",
    "only very few works have addressed the problem of adding partial functions as primitive entities in a c(l)p setting .",
    "for instance , the conjunto language @xcite provides relation variables at the language level .",
    "however , the domain and the range of the relations are limited to ground finite sets .",
    "map variables where the domain and range of the mapping can be also finite set variables are introduced in cp(map ) @xcite .",
    "all these proposals , however , do not consider the more general case of partially specified partial functions  where some elements of the domain or the range can be left unknown  which on the contrary are essential in our proposal .",
    "moreover , the collection of primitive constraints on map variables they provide is usually restricted to very few constraints , in particular to model the function application operation .    the rest of this paper is organized as follows . in section [ sec : clpset ] , we briefly recall the main features of the language @xmath0 .",
    "the new extended language with partial functions is presented in section [ sec : clppf ] , focusing on what is new with respect to @xmath0 . in section [ sec : procedures ] we describe the constraint rewriting procedures for the new constraints and the global organization of the constraint solver .",
    "the labeling mechanism with the introduction of pf - domains is addressed in section [ sec : pfdomains ] .",
    "section [ sec : improving ] introduces a number of inference rules that allow the solver to decide satisfiability of irreducible constraints without having to resort to pf - domains , thus improving its overall efficiency .",
    "a practical assessment of the performance of the new solver is provided in section [ empirical ] .",
    "@xmath0is a _ constraint logic programming ( clp ) _ language , whose constraint domain is that of _ hereditarily finite sets_i.e . , finitely nested sets that are finite at each level of nesting .",
    "@xmath0allows sets to be _ nested _ and _ partially specified_e.g .",
    ", set elements can contain unbound variables , and it is possible to operate with sets that have been only partially specified . @xmath0provides a collection of primitive constraint predicates , sufficient to represent all the most commonly used set - theoretic operations ",
    "e.g . , union , intersection , difference .",
    "the @xmath0language was first presented by .",
    "a complete constraint solver for the pure clp fragment included in @xmath0called is described by , while its extension to incorporate intervals and finite domain constraints is briefly presented by . hereafter , with the name  we will refer to this last version of our constraint language , while @xmath0will refer to the whole language including , along with a number of other syntactic extensions and extra - logical prolog - like facilities .",
    "a working implementation of @xmath0(actually , an interpreter written in prolog ) is available on the web @xcite .",
    "sets are denoted by _ set terms_. for example , @xmath19 , @xmath20 , and @xmath21 are set terms , all denoting the same set of two elements , @xmath22 and @xmath23 ; @xmath24 is a set term denoting a partially specified set containing one or two elements , depending on whether @xmath1 is equal to @xmath2 or not , and a , possibly empty , unknown part @xmath25 .",
    "a _ primitive @xmath26-constraint _ is defined as any literal based on the set of predicate symbols @xmath27 = @xmath28 .",
    "symbols in @xmath27 have their natural set - theoretic interpretation . in particular , the predicate @xmath29 represents the union relation ( @xmath30 holds if and only if @xmath31 ) , while the predicate @xmath32 represents the disjoint relation between two sets ( @xmath33 holds if and only if @xmath34 ) .",
    "most other useful set - theoretical predicates , e.g. , @xmath35 and @xmath36 , can be defined as @xmath26-constraints , using @xmath32 and @xmath29e.g .",
    ", @xmath37 @xcite . as an example , the following formula , @xmath38 , is an admissible @xmath39-constraint whose ( informal ) interpretation is : the cardinality of @xmath40 must be not greater than @xmath23 .",
    "is endowed with a complete _ constraint solver _ , called @xmath41 , for verifying the satisfiability of @xmath26-constraints . given a constraint @xmath42 , @xmath43 transforms @xmath42 either to false(if @xmath42 is unsatisfiable ) or to a finite collection @xmath44 @xmath45 @xmath46 of constraints in _ solved form_. a constraint in solved form",
    "is guaranteed to be satisfiable w.r.t .",
    "the underlying interpretation structure .",
    "moreover , the disjunction of all the constraints in solved form generated by @xmath43 is equisatisfiable to @xmath42 in the structure",
    ". a detailed description of the constraint solver @xmath41 can be found in .",
    "[ ex : solving solved form ] let @xmath42 be @xmath47",
    ". then @xmath43 returns , one by one , the following three answers , each of which is a constraint in solved form : @xmath48 ; @xmath49 ; and @xmath50 ( where @xmath51 is a new variable ) .",
    "the constraint domain @xmath26 is extended so as to incorporate partial functions . the new constraint domain and the related language",
    "are called @xmath52 and , respectively . since @xmath52 includes @xmath26 as a special case we will simply highlight what is new in @xmath52 with respect to @xmath26 .    as concerns syntax",
    ", our choice is to not introduce any special symbol to represent partial functions , since they can be easily represented as sets .",
    "partial functions are just a particular kind of sets . forcing a set to represent a partial function",
    "will be obtained at run - time by using suitable constraints on its elements .",
    "we say that a set term @xmath53 represents a _ partial function _",
    "if @xmath53 has one of the forms : @xmath54 or @xmath55,[x_2,t_2],\\dots,[x_n , t_n]\\}$ ] or @xmath55,[x_2,t_2],\\dots,[x_n , t_n ] \\mid s\\}$ ] , and @xmath56 , @xmath57 , @xmath58 , are terms , @xmath59 is a set term representing a partial function , and the constraints @xmath60 , @xmath61 , hold for all @xmath62 , @xmath63 .",
    "a critical issue in the definition of @xmath52 is the choice of which operations over partial functions should be _ primitive_i.e .",
    ", part of @xmath27and which , on the contrary , should be _ programmed _ using the language itself . minimizing the number of predicate symbols in @xmath27 has the advantage of reducing the number of different kinds of constraints to be dealt with and , hopefully , simplifying the language and its implementation . on the other hand ,",
    "having to implement such operations on top of the language may lead to efficiency and effectiveness problems , similar to those encountered with the implementation of partial functions using @xmath0discussed in section  [ sec : introduction ] .",
    "our choice is to extend the set @xmath27 of constraint predicate symbols with the following four predicate symbols : @xmath64 the intuitive interpretation of these predicate symbols is : @xmath65 ( resp .",
    "@xmath66 ) holds iff @xmath67 is the domain ( resp . ,",
    "range ) of the partial function @xmath53 ; @xmath68 holds iff the partial function @xmath69 is the composition of the partial functions @xmath53 and @xmath59 , i.e. @xmath70 : \\exists y([x , y ] \\in r \\land [ y , z ] \\in s)\\}$ ] ; @xmath71 holds iff @xmath53 is a partial function .",
    "atomic predicates based on these symbols are the only primitive constraints that offers to deal with partial functions ( let us simply call these constraints _ @xmath52-constraints _ ) .",
    "a ( general ) _",
    "@xmath72-constraint _ is just a conjunction of primitive constraints built using the enlarged @xmath27 , i.e. @xmath73 .    the following theorem ensures that the primitive constraints are sufficient to define most of the common operations on partial functions as @xmath74-constraints .",
    "complete proofs of this and the remaining theorems are available on - line at http://people.math.unipr.it/gianfranco.rossi/setlog/setlogpf_proofs.pdf . many of these theorems were formally proved using the z / eves proof assistant @xcite .",
    "[ equivalent conjs ] literals based on predicate symbols : @xmath75 ( domain restriction ) , @xmath76 ( range restriction ) , @xmath77 ( domain anti - restriction ) , @xmath78 ( range anti - restriction ) , @xmath79 ( relational image ) , @xmath80 ( overriding ) and @xmath81 ( identity ) can be replaced by equivalent conjunctions of literals based on @xmath82 , @xmath29 , @xmath32 , @xmath83 , @xmath84 and @xmath85 .    the following equivalences hold : @xmath86    other common operations on partial functions can be defined in the same way .",
    "for example , the application of a partial function @xmath53 to an element @xmath8 can be easily defined in terms of primitive constraints as follows : @xmath87 is true if and only if @xmath14 { \\mathbin{\\mathsf{\\,in\\,}}}r$ ] holds .",
    "the ability to express operations on partial functions as @xmath74-constraints as stated in theorem [ equivalent conjs ] allows us to not consider these operations in the definition of the constraint solver for @xmath88 and to focus our attention only on the four primitive constraints based on @xmath89 , @xmath83 , @xmath84 and @xmath85 .",
    "it is worth noting that the proposed subset of primitive predicate symbols is not the only possible choice . roughly speaking ,",
    "it is motivated by observing that : since a function is a tuple of the form @xmath90 , then choosing @xmath83 and @xmath84 seems a rather natural choice ; the @xmath91 can be given as membership predicates ( i.e. @xmath92 ) which is already part of the primitive constraints ; @xmath89 is easy to justify since it is necessary to state which sets are partial functions ; finally , @xmath85 is justified by observing that it is hardly definable in terms of the other primitive constraints .",
    "however , proving that this subset of primitive constraints is the minimal one , as well as comparing our choice with other possible choices , in terms of , e.g. , expressive power , completeness , effectiveness , and efficiency , is out of the scope of the present work .",
    "for each primitive constraint symbol @xmath93 , we develop a _ constraint rewriting procedure _ specifically devoted to process that type of constraint .",
    "basically , each procedure repeatedly applies to the input constraint @xmath42 a collection of _ rewrite rules _ for @xmath94 until either @xmath42 becomes falseor no rule for @xmath94 applies to @xmath42 . at any moment",
    ", @xmath42 represents the _ constraint store _ managed by the solver .",
    "the rewrite rules have the following general form @xmath95 where @xmath96 and @xmath97 are primitive @xmath72-constraints and _ pre - conditions _ are ( possibly empty ) boolean conditions on the terms occurring in @xmath98 . in order to apply the rule , all _ pre - conditions _ need to be satisfied .",
    "@xmath99 ( @xmath100 , @xmath101 @xmath102 ) represents the changes in the constraint store caused by the rule application .",
    "some rewrite rules for dealing with single @xmath52-constraints are shown in figures [ f : domrules ] and [ f : comprules ] ; all of them can be found in the online appendix ( appendix a ) .",
    "rewrite rules for all other primitive constraints can be found elsewhere @xcite .",
    "@xmath103 \\label{rule : dom_emptyset2 } \\frac{{\\mathsf{empty}}(a ) }   { \\{{\\mathsf{dom}}(r , a)\\ } \\rightarrow \\{r = { \\emptyset}\\ } } \\\\[1 mm ] \\label{rule : dom_emptyset1 } \\frac{{\\mathsf{empty}}(r ) }   { \\{{\\mathsf{dom}}(r , a)\\ } \\rightarrow \\{a = { \\emptyset}\\ } } \\\\[1 mm ] \\label{rule : dom_knownset } \\frac{r = \\{[x , y]|rr\\ } \\phantom{aaa } \\lnot { \\mathsf{empty}}(a ) }   { \\{{\\mathsf{dom}}(r , a)\\ } \\rightarrow { } \\{a = \\{x | rs\\ } , [ x , y ] { \\mathbin{\\mathsf{\\,nin\\,}}}rr , { \\mathsf{dom}}(rr , rs)\\ } }   \\\\[1 mm ] \\label{rule : dom_var } \\frac{r \\in \\mathcal{v } \\phantom{aaa } a = \\{x | rs\\ } }   { \\{{\\mathsf{dom}}(r , a)\\ } \\rightarrow \\{r = \\{[x , y]|rr\\ } , x { \\mathbin{\\mathsf{\\,nin\\,}}}rs , { \\mathsf{dom}}(rr , rs)\\ } } \\end{gathered}\\ ] ]    @xmath104 \\frac{q = \\{[x , z]|rq\\ } \\phantom{aaa } \\lnot{\\mathsf{empty}}(r ) \\phantom{aaa } \\lnot{\\mathsf{empty}}(s ) }    { \\begin{array}{c }      \\{{\\mathsf{comp}}(r , s , q)\\ } \\rightarrow \\{r = \\{[x , y ] | rr\\ } ,   \\\\      s = \\{[y , z ] | rs\\ } , [ x , z ] { \\mathbin{\\mathsf{\\,nin\\,}}}rq , [ y , z ] { \\mathbin{\\mathsf{\\,nin\\,}}}rs , { \\mathsf{comp}}(rr , s , rq)\\ }    \\end{array }    } \\label{rule : comp_qset } \\\\[1 mm ] \\frac{q \\in \\mathcal{v } \\phantom{aaa } r = \\{[x , y ] | rr\\ } \\phantom{aaa } \\lnot{\\mathsf{empty}}(s ) \\phantom{aaa } s \\notin \\mathcal{v } }    { \\begin{array}{c }      \\{{\\mathsf{comp}}(r , s , q)\\ } \\rightarrow \\{s = \\{[y , z ] | rs\\ } , \\\\       q = \\{[x , z ] | rq\\ } , [ x , y ] { \\mathbin{\\mathsf{\\,nin\\,}}}rr , [ y , z ] { \\mathbin{\\mathsf{\\,nin\\,}}}rs , { \\mathsf{comp}}(rr , s , rq)\\ } \\\\      \\mathsf{or } \\\\      \\{{\\mathsf{comp}}(r , s , q)\\ } \\rightarrow \\{{\\mathsf{dom}}(s , ds ) ,   y { \\mathbin{\\mathsf{\\,nin\\,}}}ds ,   [ x , y ] { \\mathbin{\\mathsf{\\,nin\\,}}}rr , \\\\       { \\mathsf{comp}}(rr ,",
    "s , q)\\ }     \\end{array }   } \\label{rule : comp_qvar}\\end{gathered}\\ ] ]    the global organization of the solver for the new language  called @xmath105is shown in algorithm [ glob ] .",
    "it makes use of two procedures : infer and step .",
    "is used to automatically add the constraints @xmath106 , @xmath107 , and @xmath89 to the constraint @xmath42 to force arguments of primitive constraints to be of the proper type .",
    "for example , if @xmath42 contains the constraint @xmath65 then @xmath108 will add to @xmath42 the constraint @xmath109 .",
    "the procedure is the core part of @xmath105 : it applies specialized constraint rewriting procedures to the current constraint @xmath42 and returns the modified constraint .",
    "the execution of @xmath110 is iterated until a fixpoint is reached  i.e .",
    ", the constraint can not be simplified any further .",
    "notice that step returns @xmath111 whenever ( at least ) one of the procedures in it rewrites @xmath42 to @xmath111 .",
    "moreover , step(@xmath111 ) returns @xmath111 .",
    "@xmath112 @xmath113 ; @xmath114 ;    when no rewrite rule applies to the considered @xmath52-constraint then the corresponding rewriting procedure terminates immediately and the constraint store remains unchanged .",
    "since no other rewriting procedure deals with the same kind of constraints , the irreducible constraints will be returned as part of the constraint computed by @xmath105 .",
    "precisely , if @xmath1 and @xmath115 are variables and @xmath69 is a term ( either a variable or not ) , the following @xmath52-constraints are dealt with as _",
    "irreducible _ :",
    "@xmath116 , where @xmath117 and @xmath118 are distinct variables ; 2 .",
    "@xmath119 , where @xmath69 is distinct from @xmath1 and @xmath69 is not the empty set ; 3 .",
    "@xmath120 or @xmath121 , where @xmath69 is not the empty set ; 4 .",
    "@xmath122 and there are no constraints of the form @xmath123 in @xmath42 .    roughly speaking ,",
    "the irreducible constraints are these because we are not able to rewrite them to _ finite _ conjunctions of primitive @xmath74-constraints .",
    "in particular , solving the constraint @xmath119 , where @xmath69 is a set term not denoting the empty set , would amount to solve the formula @xmath124 \\wedge z \\in t))$ ] which is not expressible as a finite conjunction of primitive @xmath72-constraints .",
    "notice that , conversely , the case @xmath125 , where @xmath69 is a set term ( e.g. @xmath126 ) , can be easily rewritten to a finite conjunction of primitive constraints since the cardinality of @xmath1 is necessarily that of @xmath69 ; hence this constraint is not dealt with as irreducible .    for all other primitive @xmath72-constraints ,",
    "@xmath105 uses the rewriting rules of  and the irreducible form constraints it returns are all @xmath39-constraints in solved form ( cf .",
    "[ sec : clpset ] and ) . observe that , a constraint composed of only solved form literals is proved to be always satisfiable .",
    "constraint rewriting .",
    "* @xmath127,[b,2],[c,1]\\},d)$ ] is rewritten to @xmath128 * @xmath127\\},\\{b\\})$ ] is rewritten to false * @xmath129\\},b,\\{[1,a]\\})$ ] is rewritten to @xmath130 | br\\ } \\land [ b , a ] { \\mathbin{\\mathsf{\\,nin\\,}}}br \\land { \\mathsf{pfun}}(br ) \\land { \\mathsf{dom}}(br , d ) \\land b { \\mathbin{\\mathsf{\\,nin\\,}}}d \\land { \\mathsf{set}}(d)$ ] * @xmath131 is rewritten to @xmath132 * @xmath133 is rewritten to false .    note that with the implementation of @xmath83 and @xmath84 as user - defined @xmath0 predicates ( see ) the last goal would loop forever .",
    "the @xmath105 procedure is proved to be always terminating .",
    "[ termination - glob ] the @xmath105 procedure terminates for every input constraint @xmath42 .    the termination of @xmath105 and the finiteness of the number of non - deterministic choices generated during its computation guarantee the finiteness of the number of constraints non - deterministically returned by @xmath105 .",
    "therefore , @xmath105  applied to a constraint @xmath42 always terminates , returning either @xmath111 or a ( finite ) disjunction of @xmath72-constraints in a simplified form .",
    "the following theorem proves that the collection of constraints in irreducible form generated by @xmath105 preserves the set of solutions of the input constraint , hence , it is correct .",
    "[ sound ] let @xmath42 be a constraint , @xmath134 @xmath135 @xmath136 be the constraints obtained from @xmath137 , @xmath138 be a valuation of @xmath42 and @xmath139 , expanded to the new variables possibly introduced into @xmath140 by the rewrite procedures , and @xmath141 be the interpretation structure associated with the constraint domain @xmath52 . then , @xmath142 if and only if @xmath143 .",
    "if at least one of the constraints @xmath144 returned by @xmath137 contains _ only _ primitive @xmath145-constraints then , according to , @xmath144 is in solved form and it is surely satisfiable .",
    "therefore , in this case , thanks to theorems [ termination - glob ] and [ sound ] , we can conclude that the original constraint @xmath42 is surely satisfiable .",
    "unfortunately , this is not always the case , as discussed in the next section .",
    "differently from , the simplified constraint returned by @xmath105 is not guaranteed to be satisfiable .",
    "[ ex : unsatisfiable ] the following @xmath72-constraint @xmath146 is an irreducible constraint but it is clearly unsatisfiable ( the only possible solution for @xmath147 is @xmath148 , but @xmath148 if and only if @xmath149 ) .    thus , differently from , the ability to produce a collection of constraints in an irreducible form from the input constraint @xmath42 can not be used to decide the satisfiability of @xmath42 . as many concrete solvers , e.g. the solvers",
    ", @xmath105 is an _",
    "incomplete _ solver .",
    "thus , if it returns false  the input constraint is surely unsatisfiable , whereas if it returns a constraint in irreducible form then we can not conclude that the input constraint is surely satisfiable .    in order to obtain a complete solver , we provide a way to associate a _ finitely representable domain _ to each partial function variable and to force these variables to get values from their associated domains , i.e. to perform _ labeling _ on them .",
    "this is obtained by defining a new primitive constraint @xmath89 , of arity @xmath23 , with the following interpretation : @xmath150 .",
    "the solutions of @xmath151 are all the partial functions @xmath53 with cardinality less than or equal to @xmath100 .",
    "the ability to represent domains and ranges of partial functions as partially specified sets , i.e. sets containing unbound variables as their elements , allows us to provide a _",
    "representation for the ( possibly infinite ) set of all solutions of @xmath151 .",
    "for example , the set of solutions for @xmath152 , where @xmath53 is a variable , can be represented by the following equisatisfiable disjunction of three primitive constraints : @xmath153\\ } { \\,\\vee}r = \\{[x_1,y_1],[x_2,y_2]\\ } \\wedge x_1 { \\mathbin{\\mathsf{\\,neq\\,}}}x_2 $ ] .",
    "we will call the set of partial functions represented by these constraints the _ pf - domain _ of the pf - variable @xmath53 .",
    "pf - domains represent in general infinite sets but they are finitely representable in our language .",
    "> from an operational point of view , solving @xmath151 , with @xmath100 a constant natural number , non - deterministically computes , one after the other , all the @xmath154 possible assignments for @xmath53 .",
    "therefore , solving @xmath151 allows us to perform a sort of _ labeling _ over the pf - variable @xmath53 .",
    "note that , differently from @xmath71 , @xmath151 has no irreducible form .",
    "if @xmath53 is an unbound variable ( @xmath100 is required to be a constant number ) , then solving @xmath151 always generates an equality for @xmath53 , along with possible inequality constraints over the elements in the domain of @xmath53 .",
    "the labeling process involved in @xmath155 constraints do not compromise termination of the procedure @xmath105 since the set of possible values to be assigned to partial function variables through labeling is anyway finite .",
    "moreover , assuming our domain of discourse is limited to finite partial functions , it is straightforward to see that the rewriting rules for @xmath155 preserve the set of solutions of the input constraint .",
    "thus we can immediately extend to @xmath155 constraints the results of theorems [ termination - glob ] and [ sound ] .",
    "solving @xmath155 constraints allows pf - variables to always get a value , although it can be a non - ground value .",
    "this is enough , however , to guarantee that all @xmath156-constraints are completely eliminated at the end of the computation .",
    "[ elimination ] let @xmath42 be an input constraint and @xmath157 all the pf - variables occurring in @xmath42 . if @xmath42 contains @xmath158 , @xmath159 , then @xmath137 returns either falseor a disjunction of @xmath26-constraints in _ solved form_.    remembering that @xmath145-constraints in solved form are always satisfiable , lemma [ elimination ] guarantees that , if the input constraint @xmath42 contains @xmath155 constraints for all the pf - variables occurring in it and @xmath137 does not terminate with false , then the disjunction of constraints returned by @xmath137 is surely satisfiable . since @xmath105 is proved to preserve the set of solutions of @xmath42 ( cf .",
    "theorem [ sound ] ) , then we can conclude that in this case @xmath42 is satisfiable .    hence , by properly exploiting @xmath155 constraints , we get a complete solver .",
    "this means that , once @xmath160 are fixed , our solver can detect all cases in which the input constraint is unsatisfiable , as well as all cases in which the input constraint is satisfiable and , in these cases , it can generate all viable solutions .",
    "the following constraints are rewritten to either falseor to a solved form constraint , whereas they are left unchanged if no pf - domain is specified .",
    "* @xmath161 is rewritten to false * @xmath162 is rewritten to the solved form constraint ( first solution ) : @xmath163\\ } \\wedge z = \\{[a,1 ] | y\\ } \\wedge { \\mathsf{set}}(y)$ ] .",
    "> from a more practical point of view , having to perform labeling for pf - variables may cause unacceptable execution time in some cases . for example , the constraint @xmath164 is proved to be unsatisfiable , but only for relatively small values of @xmath165 .    to alleviate this problem , we introduce a number of new rewrite rules  hereafter simply called _ inference rules_that allow new constraints to be inferred from the irreducible constraints .",
    "the presence of these additional constraints allows the solver to deduce possible unsatisfiability of the given constraint without having to resort to any labeling process , thus improving the overall efficiency of constraint solving in many cases .",
    "the inference rules are applied by calling function just after the iteration of @xmath110 ends finding a fixpoint ( see algorithm [ glob ] ) .",
    "( @xmath42 ) applies all possible inference rules to all possible primitive constraints in @xmath42 .",
    "after the rules have been applied , possibly modifying @xmath42 , the @xmath110 loop is repeated from the beginning .",
    "only when both @xmath110 and do not modify @xmath42 , then the new global constraint solving procedure  called @xmath166ends .",
    "some of the inference rules used by @xmath166 are shown in figure [ f : infrules ] ; all of them can be found in the online appendix ( appendix a ) .",
    "each inference rule captures some property of the primitive operators for partial functions , possibly relating these operators with other general operators , such as inequality ( constraint @xmath167 ) and set cardinality ( constraint @xmath168 ) .",
    "all rules take into account one or two primitive constraints at a time and add new primitive constraints to the constraint store .",
    "@xmath169 \\frac{a \\in \\mathcal{v } }   { \\{{\\mathsf{ran}}(r , a ) , r { \\mathbin{\\mathsf{\\,neq\\,}}}{\\emptyset}\\ } \\rightarrow \\{{\\mathsf{ran}}(r , a ) , r { \\mathbin{\\mathsf{\\,neq\\,}}}{\\emptyset } , a { \\mathbin{\\mathsf{\\,neq\\,}}}{\\emptyset}\\ } }   \\label{irule : ran_neq2 } \\\\[1 mm ] \\frac { }   { \\{{\\mathsf{dom}}(r , a)\\ } \\rightarrow \\{{\\mathsf{dom}}(r , a ) , { \\mathsf{size}}(r , n ) , { \\mathsf{size}}(a , n)\\ } }   \\label{irule : dom_size1 } \\\\[1 mm ] \\frac { }   { \\begin{array}{cl }   \\{{\\mathsf{comp}}(r , s , q)\\ } \\rightarrow & \\{{\\mathsf{comp}}(r , s , q ) , \\\\                                & \\phantom{a } { \\mathsf{dom}}(q , a ) , { \\mathsf{dom}}(r , b ) , { \\mathsf{subset}}(a , b)\\ }   \\end{array }   }   \\label{irule : comp_dom_ran1 } \\\\[1 mm ] \\frac { }   { \\begin{array}{cl }    \\{{\\mathsf{un}}(r , s , q ) , { \\mathsf{pfun}}(q)\\ } \\rightarrow & \\{{\\mathsf{un}}(r , s , q ) , { \\mathsf{pfun}}(q ) ,   \\\\         & \\phantom{a } { \\mathsf{dom}}(r , dr ) , { \\mathsf{dom}}(s , ds ) , { \\mathsf{dom}}(q , dq ) , \\\\         & \\phantom{a } { \\mathsf{un}}(dr , ds , dq ) \\ }   \\end{array } }   \\label{irule : un_dom}\\end{gathered}\\ ] ]    [ ex : unsatisfiable2 ] the following constraints are all proved to be unsatisfiable using @xmath166 ( see the applied rules in figure [ f : infrules ] ) : @xmath170\\},y , z ) \\wedge { \\mathsf{dom}}(z , dz ) \\wedge a { \\mathbin{\\mathsf{\\,nin\\,}}}dz \\wedge z { \\mathbin{\\mathsf{\\,neq\\,}}}{\\emptyset } & \\text{(rule \\eqref{irule : comp_dom_ran1 } ) } \\\\    { \\mathsf{un}}(x , y , z ) \\wedge { \\mathsf{dom}}(x , d ) \\wedge { \\mathsf{dom}}(y , d ) \\wedge { \\mathsf{dom}}(z , dz ) \\wedge d { \\mathbin{\\mathsf{\\,neq\\,}}}dz   & \\text{(rule \\eqref{irule : un_dom } ) } \\\\    \\end{array}\\ ] ]    the same constraints of example [ ex : unsatisfiable2 ] but using @xmath105 , that is without applying any inference rule , are simply treated as irreducible . on the other hand ,",
    "adding constraints @xmath89/2 to perform labeling on pf - variables would allow @xmath105 to detect the unsatisfiability for all these constraints , but only when the specified partial function cardinalities are relatively small the response times would be practically acceptable .",
    "termination of the improved constraint solver is stated by the following theorem .",
    "[ termination - glob2 ] the @xmath166 procedure can be implemented in such a way that it terminates for every input constraint @xmath42 .",
    "soundness of the extended solver @xmath166 comes from soundness of @xmath105 and from the following theorem , which ensures that the added constraints do not modify the set of solutions of the original constraint .",
    "[ equisatisfiable ] let @xmath25 be a constraint and @xmath171 be the constraint obtained from the inference rules .",
    "then @xmath171 is equisatisfiable to @xmath25 with respect to the interpretation structure @xmath141 .",
    "@xmath166 is still not a complete solver unless @xmath155 is used for all pf - variables . as a counterexample ,",
    "consider the following constraint @xmath172 this constraint is unsatisfiable with respect to @xmath141 , but @xmath166 is not able to prove this fact ( it simply leaves the constraint unchanged ) .",
    "new inference rules could be added to the solver to detect further properties of the partial function domain , thus avoiding as much as possible the need for @xmath89/2 constraints .    however , finding a collection of inference rules that guarantees to obtain a complete solver , regardless of the presence of @xmath89/2 constraints , seems to be a difficult task .",
    "moreover , checking the constraint store to detect applicable inference rules may be quite costly in general .",
    "thus , the solution we adopted is based on finding a tradeoff between efficiency and completeness , as usual in many concrete constraint solvers .",
    "only those properties that require relatively small effort to be checked are taken into account by the solver .",
    "for all cases not covered by the inference rules , however , solver s completeness is obtained by exploiting pf - domains and @xmath89/2 constraints .",
    "further empirical assessment of the solver may lead to review the current choices and provide additional inference rules in future releases .",
    "in this section we present how the new version of @xmath0(i.e . 4.8.2 - 2 ) improves its efficiency and effectiveness when solving formulas including partial functions and their operators .",
    "to do so we have generated more than 2,000 goals , some of which include partial functions and the related operators .",
    "these goals have been used to evaluate @xmath04.8.0 as a test case generator for fastest , a model - based testing tool @xcite . besides , these goals have been generated by fastestfrom 10 different z specifications , some of which are formalizations of real requirements and , in general , they cover a wide range of applications  totalizing around 3,000 lines of z code .",
    "these goals not only include partial functions , but also sets ( in particular intentional sets ) , integer and relational constraints .",
    "thus , we consider that they are a representative sample .    in this assessment , we want to know : @xmath15 how many satisfiable and unsatisfiable goals are found by @xmath0 ; @xmath16 how long it takes to process all the goals ; @xmath17 how @xmath0performs in each task compared with version 4.8.0 ( which do not include partial functions as primitive constraints ) .",
    "experiments were run on a 4 core intel core i5 - 2410 m cpu at 2.30ghz with 4 gb of main memory , running linux ubuntu 12.04 ( precise pangolin ) 32-bit with kernel 3.2.0 - 80-generic - pae . @xmath04.8.0 and",
    "4.8.2 - 2 over swi - prolog 6.6.6 for i386 were used during the experiments .",
    "a 10 seconds timeout was set as the maximum time that @xmath0can spend to give an answer for a goal .",
    "table [ t : results ] displays the results of the experiments .",
    "the meaning of the columns is as follows : * z spec * , z specification ; * goals * , number of goals processed during the experiment ; * s * , number of satisfiable goals detected as satisfiable ; * u * , number of goals detected as unsatisfiable ; * a * , percentage of goals for which @xmath0 gives a meaningful answer ( i.e. @xmath173 ) ; * t * , time spent by @xmath0 during the entire execution .    .[t",
    ": results]summary of empirical assessment [ cols= \" < , > , > , > , > , > , > , > , > , > \" , ]     as can be seen , @xmath0 4.8.2 - 2 outperforms 4.8.0 in almost all sets of goals . in effect , in all sets but two ( swpdc and sec .",
    "class ) 4.8.2 - 2 gives more right answers and in less time than 4.8.0 .",
    "note that 4.8.2 - 2 hits 100% of right answers in 5 sets of goals while 4.8.0 does it only in 2 . also note the impressive time reduction in , for example , launcher .",
    "given that giving more right answers in less time is the best behavior , we can define @xmath174 , for quality index , as @xmath175 .",
    "then , the higher the @xmath174 the better .",
    "@xmath04.8.2 - 2 has higher or equal @xmath174 than 4.8.0 in all but one set of goals .    in summary ,",
    "the experimental results show that adding constraints for partial functions as @xmath0 s primitive constraints greatly improves its efficiency and effectiveness as a constraint solver for a very general theory of sets .",
    "in this paper we have shown how to integrate partial functions as first - class citizens into the clp language with sets @xmath0 .",
    "since partial functions can be viewed as sets , they are embedded quite smoothly into @xmath0 , and all facilities for set manipulation offered by @xmath0 are immediately available to manipulate partial functions as well .",
    "we have added to the language a very limited number of new primitive constraints , specifically devoted to deal with partial functions and we have provided sound and terminating rewriting procedures for them . the resulting constraint solver either terminates with falseor with a disjunction of simplified constraints which the solver can not further simplify ( i.e. , irreducible constraints ) .",
    "we have identified conditions under which the ability to generate such a disjunction guarantees the satisfiability of the input constraint .",
    "moreover , we have defined a number of inference rules that allow the solver to detect , in many cases , unsatisfiability even in the more general situations ( e.g. without requiring to specify an upper bound for the cardinality of partial functions ) .    for the future , there are two main correlated lines of work : @xmath15 identifying more precisely the class of irreducible constraints which are guaranteed to be satisfiable ; so far this class is restricted to irreducible constraints not containing pf - constraints , but it is likely to be enlarged to include pf - constraints as well , at least of some specific form ( e.g. , those which contain only unbound variables , thus excluding for instance the irreducible constraints of the form @xmath176 ) @xmath16 defining new inference rules that allow further `` hidden '' properties of irreducible constraints to be made explicit , in order to make constraint solving more and more `` precise '' ; that is , on the one hand , to allow the solver to detect more and more unsatisfiable constraints and , on the other hand , to allow the class of irreducible constraints whose satisfiability can be decided without the need to perform any labeling operation to be enlarged as much as possible ."
  ],
  "abstract_text": [
    "<S> partial functions are common abstractions in formal specification notations such as z , b and alloy . </S>",
    "<S> conversely , executable programming languages usually provide little or no support for them . in this paper </S>",
    "<S> we propose to add partial functions as a primitive feature to a constraint logic programming ( clp ) language , namely @xmath0 . </S>",
    "<S> although partial functions could be programmed on top of @xmath0 , providing them as first - class citizens adds valuable flexibility and generality to the form of set - theoretic formulas that the language can safely deal with . </S>",
    "<S> in particular , the paper shows how the @xmath0constraint solver is naturally extended in order to accommodate for the new primitive constraints dealing with partial functions . </S>",
    "<S> efficiency of the new version is empirically assessed by running a number of non - trivial set - theoretical goals involving partial functions , obtained from specifications written in z.    clp , @xmath0 , set theory , partial functions </S>"
  ]
}