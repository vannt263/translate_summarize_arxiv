{
  "article_text": [
    "many real - world problems , arising in formal verification of hardware and software , planning and other areas , can be formulated as constraint satisfaction problems , which can be translated into boolean formulas in conjunctive normal form ( cnf ) .",
    "modern boolean satisfiability ( sat ) solvers , such as chaff  @xcite and minisat  @xcite , which implement enhanced versions of the davis - putnam - longeman - loveland ( dpll ) backtrack - search algorithm , are often able to determine whether a large formula is satisfiable or unsatisfiable .",
    "when a formula is unsatisfiable , it is often required to find an _",
    "unsatisfiable core_that is , a small unsatisfiable subset of the formula s clauses .",
    "example applications include functional verification of hardware  @xcite , fpga routing  @xcite , and abstraction refinement  @xcite .",
    "for example , in fpga routing , an unsatisfiable instance implies that the channel is unroutable .",
    "localizing a small unsatisfiable core is necessary to determine the underlying reasons for the failure .",
    "an unsatisfiable core is a _ minimal unsatisfiable core ( muc ) _",
    ", if it becomes satisfiable whenever any one of its clauses is removed .",
    "it is always desirable to find a minimal unsatisfiable core , but this problem is very hard ( it is @xmath0-complete ; see  @xcite ) .    in this paper , we propose an algorithm that is able to find a minimal unsatisfiable core for large `` real - world '' formulas .",
    "benchmark families , arising in formal verification of hardware ( such as  @xcite ) , are of particular interest for us . the only approach for unsatisfiable core extraction that scales well for formal verification benchmarks was independently proposed in  @xcite and in  @xcite .",
    "we refer to this method as the _ ec ( empty - clause cone ) _ algorithm .",
    "ec exploits the ability of modern sat solvers to produce a resolution refutation , given an unsatisfiable formula .",
    "most state - of - the - art sat solvers , beginning with grasp  @xcite and including chaff  @xcite and minisat  @xcite , implement a dpll backtrack search enhanced by a failure - driven assertion loop  @xcite .",
    "these solvers explore the assignment tree and create new _ conflict clauses _ at the leaves of the tree , using resolution on the initial clauses and previously created conflict clauses .",
    "this process stops when either a satisfying assignment is found or when the empty clause ( @xmath1 ) is derived . in the latter case , sat solvers are able to produce a _ resolution refutation_a directed acyclic graph ( dag ) , whose vertices are associated with clauses , and whose edges describe resolution relations between clauses .",
    "the sources of the refutation are the initial clauses and the empty clause @xmath1 is a sink .",
    "ec traverses a reversed refutation , starting with @xmath1 and taking initial clauses , connected to @xmath1 , as the unsatisfiable core . invoking ec until a fixed point",
    "is reached  @xcite allows one to reduce the unsatisfiable core even more .",
    "we refer to this algorithm as _ ec - fp_. however , the resulting cores can be reduced further .    the basic flow of the algorithm for minimal unsatisfiable core extraction proposed in this paper is composed of the following steps :    1 .",
    "produce a resolution refutation @xmath2 of a given formula using a sat solver .",
    "2 .   drop from @xmath2 all clauses not connected to @xmath1 . at this point",
    ", all the initial clauses remaining in @xmath2 comprise an unsatisfiable core .",
    "3 .   for every initial clause @xmath3 remaining in @xmath2 , check whether it belongs to a minimal unsatisfiable core ( muc ) in the following manner : + _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ remove @xmath3 from @xmath2 , along with all conflict clauses for which @xmath3 was required to derive them .",
    "pass all the remaining clauses ( including conflict clauses ) to a sat solver .",
    "* if they are satisfiable , then @xmath3 belongs to a minimal unsatisfiable core , so continue with another initial clause . *",
    "if the clauses are unsatisfiable , then @xmath3 does not belong to a muc , so replace @xmath2 by a new valid resolution refutation not containing @xmath3 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 4 .",
    "terminate when all the initial clauses remaining in @xmath2 comprise a muc .",
    "related work is discussed in the next section . section  [ sec : rr ] is dedicated to refutation - related definitions . our basic _ complete resolution refutation ( crr ) _ algorithm is described in sect .",
    "[ sec : crr ] , and a pruning technique , enhancing crr and called _ resolution refutation - based pruning ( rrp ) _ , is described in sect .",
    "[ sec : ecrr ] .",
    "experimental results are analyzed in sect .  [",
    "sec : er ] .",
    "this is followed up by a brief conclusion .",
    "algorithms for unsatisfiable core based on the ability of modern sat solvers to produce resolution refutations  @xcite are the most relevant for our purposes for two reasons .",
    "first , this approach allows one to deal with real - world examples arising in formal verification .",
    "second , it serves as the basis of our algorithm .",
    "we have already described the ec and ec - fp algorithms in the introduction . here",
    "we briefly consider other approaches .",
    "theoretical work ( e.g. , @xcite ) has concentrated on developing efficient algorithms for formulas with small _ deficiency _ ( the number of clauses minus the number of variables ) . however , real - world formulas have arbitrary ( and usually large ) deficiency . a number of works considered the harder problem of finding the smallest minimal unsatisfiable core  @xcite , or even finding all minimally unsatisfiable formulas  @xcite .",
    "as one can imagine , these algorithms are not scalable for even moderately large real - world formulas .    in @xcite ,",
    "an `` adaptive core search '' is applied for finding a small unsatisfiable core .",
    "the algorithm starts with a very small satisfiable subformula , consisting of _ hard _ clauses .",
    "the unsatisfiable core is built by an iterative process that expands or contracts the current core by a fixed percentage of clauses .",
    "the procedure succeeds in finding small , though not necessarily minimal , unsatisfiable cores for the problem instances it was tested on , but these are very small and artificially generated .",
    "another approach that allows for finding small , but not necessarily minimal , unsatisfiable cores is called amuse  @xcite . in this approach",
    ", selector variables are added to each clause and the unsatisfiable core is found by a branch - and - bound algorithm on the updated formula .",
    "selector variables allow the program to implicitly search for unsatisfiable cores using an enhanced version of dpll on the updated formula .",
    "the authors note their methods ability to locate different unsatisfiable cores , as well as its inability to cope with large formulas .",
    "the above described algorithms do not guarantee minimality of the cores extracted .",
    "one folk algorithm for minimal unsatisfiable core extraction , which we dub _ nave _ , works as follows : for every clause @xmath3 in an unsatisfiable formula @xmath4 , nave checks if it belongs to the minimal unsatisfiable core , by invoking a sat solver on @xmath5 .",
    "clause @xmath3 does not belong to muc if and only if the solver finds that @xmath6 is unsatisfiable , in which case @xmath3 is removed from @xmath4 . in the end , @xmath4 contains a minimal unsatisfiable core .",
    "the only non - trivial algorithm existing in the current literature that guarantees minimality is mup  @xcite .",
    "mup is mainly a prover of minimal unsatisfiability , as opposed to an unsatisfiable core extractor .",
    "it decides the minimal unsatisfiability of a cnf formula through bdd manipulation .",
    "when mup is used as a core extractor , it removes one clause at a time until the remaining core is minimal .",
    "mup is able to prove minimal unsatisfiability of some particularly hard classical problems quickly , whereas even just proving unsatisfiability is a challenge for modern sat solvers .",
    "however , the formulas described in  @xcite are small and arise in areas other than formal verification .",
    "we will see in section  [ sec : er ] that mup is significantly outperformed by nave on formal verification benchmarks .",
    "we begin with a resolution refutation of a given unsatisfiable formula , defined as follows :    [ fig : def_rrg ] let @xmath4 be an unsatisfiable cnf formula ( set of clauses ) and let @xmath7 be a dag whose vertices are clauses .",
    "suppose @xmath8 , where @xmath9 are all the sources of @xmath2 , referred to as _ initial clauses _ , and @xmath10 is an ordered set of non - source vertices , referred to as _",
    "conflict clauses_. then , the dag @xmath7 is a _ resolution refutation of @xmath4 _ if :    1 .   @xmath11 ; 2 .   for every conflict clause @xmath12",
    ", there exists a resolution derivation @xmath13 , such that : 1 .   for every @xmath14 ,",
    "@xmath15 is either an initial clause or a prior conflict clause @xmath16 , @xmath17 , and 2 .",
    "[ fig : def_edges ] there are edges @xmath18 ( these are the only edges in @xmath19 ) ; 3 .",
    "the sink vertex @xmath20 is the only empty clause in @xmath21 .",
    "for the subsequent discussion , it will be helpful to capture the notion of vertices that are `` reachable '' , or `` backward reachable '' , from a given clause in a given dag .",
    "[ fig : def_rve ] let @xmath2 be a dag .",
    "a vertex @xmath22 is _ reachable _ from @xmath3 if there is a path ( of 0 or more edges ) from @xmath3 to @xmath22 .",
    "the set of all vertices reachable from @xmath3 in @xmath2 is denoted @xmath23 .",
    "the set of all vertices unreachable from @xmath3 in @xmath2 is denoted by @xmath24    [ fig : def_brve ] let @xmath2 be a dag .",
    "a vertex @xmath22 is _ backward reachable _ from @xmath3 if there is a path ( of 0 or more edges ) from @xmath22 to @xmath3 .",
    "the set of all vertices backward reachable from @xmath3 in @xmath2 is denoted by @xmath25 .",
    "the set of all vertices not backward reachable from @xmath3 in @xmath2 is denoted @xmath26 .    for example , consider the resolution refutation of fig .",
    "[ fig : muc_fig1 ] .",
    "we have @xmath27 and @xmath28 .",
    "resolution refutations trace all resolution derivations of conflict clauses , including the empty clause .",
    "generally , not all clauses of a refutation are required to derive @xmath1 , but only such that are backward reachable from @xmath1 .",
    "it is not hard to see that even if all other clauses and related edges are omitted , the remaining graph is still a refutation .",
    "we refer to such refutations as _ non - redundant _ ( see definition  [ fig : def_nrs_rrg ] ) .",
    "the refutation in fig .",
    "[ fig : muc_fig1 ] is non - redundant .    to retrieve a non - redundant subgraph of a refutation , it is sufficient to take @xmath29 as the vertex set and to restrict the edge set @xmath19 to edges having both ends in @xmath29 .",
    "we denote a non - redundant subgraph of a refutation @xmath2 by @xmath30 .",
    "observe that @xmath30 is a valid non - redundant refutation .",
    "[ fig : def_nrs_rrg ] a resolution refutation @xmath2 is _ non - redundant _ if there is a path in @xmath2 from every clause to @xmath1 .",
    "lastly , we define a relative hardness of a resolution refutation .    [",
    "fig : def_relsize ] the _ relative hardness _ of a resolution refutation is the ratio between the total number of clauses and the number of initial clauses .",
    "our goal is to find a minimal unsatisfiable core of a given unsatisfiable formula @xmath4 .",
    "the proposed _",
    "method is displayed as algorithm  [ fig : muc1 ] .",
    "build a non - redundant refutation @xmath31 [ lbl : pick ] @xmath32 _ pickunmarkedclause(@xmath9 ) _ invoke a sat solver on @xmath24 [ lbl : sat ] mark @xmath3 as a muc member [ lbl : unsat1 ] let @xmath33 build resolution refutation @xmath34 @xmath35 @xmath36 @xmath37 [ lbl : unsat2 ] @xmath38 @xmath9    first , crr builds a non - redundant resolution refutation .",
    "invoking a sat solver for constructing a ( possibly redundant ) resolution refutation @xmath7 and restricting it to @xmath30 is sufficient for this purpose .",
    "suppose @xmath31 is a non - redundant refutation .",
    "crr checks , for every unmarked clause @xmath3 left in @xmath9 , whether @xmath3 belongs to the minimal unsatisfiable core .",
    "initially , all clauses are unmarked . at each stage of the algorithm",
    ", crr maintains a valid refutation of @xmath4 .",
    "recall from definition  [ fig : def_rve ] that @xmath24 is the set of all vertices in @xmath2 unreachable from @xmath3 . by construction of @xmath2 ,",
    "the @xmath24 clauses were derived independently of @xmath3 . to check whether @xmath3 belongs to the minimal unsatisfiable core",
    ", we provide the sat solver with @xmath24 , including the conflict clauses .",
    "we are trying to _ complete the resolution refutation _ , not using @xmath3 as one of the sources .",
    "observe that @xmath1 is always reachable from @xmath3 , since @xmath2 is a non - redundant refutation ; thus @xmath1 is never passed as an input to the sat solver .",
    "we let the sat solver try to derive @xmath1 , using @xmath24 as the input formula , or else prove that @xmath24 is satisfiable .    in the latter case , we conclude that @xmath3 must belong to the minimal unsatisfiable core , since we found a model for an unsatisfiable subset of initial clauses minus @xmath3 . hence , if the sat solver returns _",
    "satisfiable _ , the algorithm marks @xmath3 ( line  [ lbl : sat ] ) and moves to the next initial clause .",
    "however , if the sat solver returns _",
    ", we can not simply remove @xmath3 from @xmath4 and move to the next clause , since we need to keep a valid resolution refutation for our algorithm to work properly .",
    "we describe the construction of a valid refutation ( lines  [ lbl : unsat1][lbl : unsat2 ] ) next .",
    "let @xmath33 .",
    "the sat solver produces a new resolution refutation @xmath34 for @xmath39 , whose sources are the clauses @xmath24 .",
    "we can not use @xmath40 as the refutation for the subsequent iterations , since the sources of the refutation may only be initial clauses of @xmath4 .",
    "however , the `` superfluous '' sources of @xmath40 are conflict clauses of @xmath2 , unreachable from @xmath3 , and thus are derivable from @xmath41 using resolution relations , corresponding to edges of @xmath2 .",
    "hence , it is sufficient to augment @xmath40 with such edges of @xmath2 that connect @xmath42 and @xmath24 to obtain a valid refutation whose initial clauses belong to @xmath4 .",
    "algorithm crr constructs a new refutation , whose sources are @xmath42 ; the conflict clauses are @xmath43 and the edges are @xmath44 .",
    "this new refutation might be redundant , since @xmath34 is not guaranteed to be non - redundant .",
    "therefore , prior to checking the next clause , we reduce the new refutation to a non - redundant one . observe that in the process of reduction to a non - redundant subgraph , some of the initial clauses of @xmath4 , may be omitted ; hence , each time a clause @xmath3",
    "is found not to belong to the minimal unsatisfiable core , we potentially drop not only @xmath3 , but also other clauses .",
    "we demonstrate the process of completing a refutation on the example from fig .",
    "[ fig : muc_fig1 ] .",
    "suppose we are checking whether @xmath45 belongs to the minimal unsatisfiable core . in this case ,",
    "the sat solver receives @xmath39 as the input formula .",
    "it is not hard to check that @xmath39 is unsatisfiable .",
    "one refutation of @xmath39 is @xmath34 , where @xmath47 , @xmath48 ) , and @xmath49 @xmath50 .",
    "therefore , @xmath45 , @xmath51 , @xmath52 , @xmath53 and related edges are excluded from the refutation of @xmath4 , whereas @xmath54 , @xmath55 and related edges are added to the refutation of @xmath4 . in this case , the resulting refutation is non - redundant .",
    "we did not define how the function _ pickunmarkedclause _ should pick clauses ( line  [ lbl : pick ] ) .",
    "our current implementation picks clauses in the order in which clauses appear in the given formula .",
    "development of sophisticated heuristics is left for future research .",
    "another direction that may lead to a speed - up of crr is adjusting the sat solver for the purposes of crr algorithm , considering that the sat solver is invoked thousands of times on rather easy instances . integrating the data structures of crr and the sat solver , tuning sat solver s heuristics for crr , and holding the refutation in - memory , rather than on disk ( as suggested in  @xcite for ec )",
    ", can be helpful .    &",
    "[ name = norm ] * norm * + * sat * & & [ name = false]*false * +    & & [ name = eop]*eop * + ^@xmath22 has no parent ^@xmath22 has no children",
    "in this section , we propose an enhancement of algorithm crr by developing resolution refutation - based pruning techniques for when a sat solver invoked on @xmath24 to check whether it is possible to complete a refutation without @xmath3 .",
    "we refer to the pruning technique , proposed in this section , _ resolution refutation - based pruning ( rrp)_. we presume that the reader is familiar with the functionality of a modern sat solver .",
    "( an overview is given in  @xcite . )",
    "an assignment @xmath56 _ falsifies _ a clause @xmath3 , if every literal of @xmath3 is _ false _ under @xmath56 .",
    "an assignment @xmath56 _ falsifies _ a set of clauses @xmath57 if every clause @xmath58 is falsified by @xmath56 .",
    "we claim that a model for @xmath24 can only be found under such a partial assignment that falsifies every clause in some path from @xmath3 to the empty clause in @xmath23 .",
    "the intuitive reason is that every other partial assignment satisfies @xmath3 and must falsify @xmath24 , since @xmath4 is unsatisfiable .",
    "a formal statement and proof is provided in theorem  [ theo : uu ] below .",
    "consider the example of fig .",
    "[ fig : muc_fig1 ] .",
    "suppose the currently visited clause is @xmath59 .",
    "there exist two paths from @xmath59 to the empty clause @xmath53 , namely @xmath60 and @xmath61 . a model for @xmath62",
    "can only be found in a subspace under the partial assignment @xmath63 , falsifying all the clauses of the first path .",
    "the clauses of the second path can not be falsified , since @xmath64 must be _ true _ to falsify clause @xmath59 and _ false _ to falsify clause @xmath52 .",
    "denote a subtree connecting @xmath3 and @xmath1 by @xmath65 .",
    "the proposed pruning technique , rrp , is integrated into the decision engine of the sat solver .",
    "the solver receives @xmath65 , together with the input formula @xmath24 .",
    "the decision engine of the sat solver explores @xmath65 in a depth - first manner , picking unassigned variables in the currently explored path as decision variables and assigning them _",
    "false_. as usual , boolean constraint propagation ( bcp ) follows each assignment . backtracking in @xmath65 is tightly related to backtracking in the assignment space .",
    "both happen when a satisfied clause in @xmath65 is found or when a new conflict clause is discovered during bcp .",
    "after a particular path in @xmath65 has been falsified , a general - purpose decision heuristic is used until the sat solver either finds a satisfying assignment or proves that no such assignment can be found under the currently explored path .",
    "this process continues until either a model is found or the decision engine has completed exploring @xmath65 . in the latter case , one can be sure that no model for @xmath24 exists",
    ". however , the sat solver should continue its work to produce a refutation .",
    "we need to describe in greater detail the changes in the decision and conflict analysis engines of the sat solver required to implement rrp .",
    "the decision engine first invokes function _ rrp_decide _ , depicted in fig .",
    "[ fig : ecrr_dec ] , as a state transition relation .",
    "each transition edge has a label consisting of a condition under which the state transition occurs and an operation , executed upon transition .",
    "the state can be one of the following :    [ cols= \" < , < \" , ]",
    "we have implemented crr and rrp in the framework of the ve solver .",
    "ve , a variant of the industrial solver eureka , is a modern sat solver , which implements the following state - of - the - art algorithms and techniques for sat : it uses 1uip conflict clause recording  @xcite , enhanced by conflict clause minimization  @xcite , frequent search restarts  @xcite , an aggressive clause deletion strategy  @xcite , and decision stack shrinking  @xcite .",
    "ve uses berkmin s decision heuristic  @xcite until 4000 conflicts are detected , and then switches to the cbh heuristic , described in  @xcite .",
    "we used benchmarks from four well - known unsatisfiable families , taken from bounded model checking ( _ barrel _ , _ longmult _ )  @xcite and microprocessor verification ( _ fvp - unsat.2.0 , pipe_unsat_1.0 _ )  @xcite .",
    "all the instances we used appear in the first column of table  [ tab : results ] .",
    "the experiments on families _ barrel _ and _ fvp - unsat.2.0 _ were carried out on a machine with 4 gb of memory and two intel xeon cpu 3.06 processors .",
    "a machine with the same amount of memory and two intel xeon cpu 3.20 processors was used for experiments with the families _ longmult _ and _",
    "pipe_unsat_1.0_.    table  [ tab : results ] summarizes the results of a comparison of the performance of two algorithms for suboptimal unsatisfiable core extraction and five algorithms for minimal unsatisfiable core extraction in terms of execution time and core sizes .",
    "first , we compare algorithms for minimal unsatisfiable core extraction , namely , nave , mup , plain crr , and crr enhanced by rrp . in preliminary experiments",
    ", we found that nave demonstrates its best performance on formulas that are first trimmed down by a suboptimal algorithm for unsatisfiable core extraction .",
    "we tried nave in combination with ec , ec - fp and amuse and found that ec - fp is the best front - end for nave . in our main experiments",
    ", we used nave , combined with ec - fp , and nave combined with amuse .",
    "we have also found that mup demonstrates its best performance when combined with ec - fp , while crr performs the best when the first refutation is constructed by ec , rather than ec - fp .",
    "consequently , we provide results for mup combined with ec - fp and crr combined with ec .",
    "mup requires a so - called `` decomposition tree '' , in addition to the cnf formula .",
    "we used the c2d package  @xcite for decomposition tree construction .",
    "the sizes of the cores do not vary much between muc algorithms , so we concentrate on a performance comparison .",
    "one can see that the combination of ec - fp and nave outperforms the combination of amuse and nave , as well as mup .",
    "plain crr outperforms nave on every benchmark , whereas crr+rrp outperforms nave on 15 out of 16 benchmarks ( the exception being the hardest instance of _ longmult _ ) .",
    "this demonstrates that our algorithms are justified practically .",
    "usually , the speed - up of these algorithms over nave varies between 4 and 10x , but it can be as large as 34x ( for the hardest instance of _ barrel _ family ) and as small as 2x ( for the hardest instance of _ longmult _ ) .",
    "rrp improves performance on most instances .",
    "the most significant speed - up of rrp is about 2.5x , achieved on hard instances of family _ fvp - unsat.2.0_. the only family for which rrp is usually unhelpful is _",
    "longmult_.    a natural question is why the complex instances of family _ longmult _ are hard for crr , and even harder for rrp .",
    "the key difference between _ longmult _ and other families is the hardness of the resolution proof .",
    "the relative hardness of a resolution refutation produced by crr+rrp varies between 1.4 to 2 for every instance of every family , except _ longmult _ , where it reaches 14.2 for the _ longmult7 _ instance .",
    "when the refutation is too complex , the exploration of @xmath66 executed by rrp is too complicated ; thus , plain crr is advantageous over crr+rrp .",
    "also , when the refutation is too complex , it is costly to perform traversal operations , as required by crr .",
    "this explains why the advantage of crr over nave is as small as 2x .",
    "comparing crr+rrp on one side and ec and ec - fp on the other , we find that crr+rrp always produce smaller cores than both ec and ec - fp .",
    "the average gain on all instances of cores produced by crr+rrp over cores produced by ec and ec - fp is 53% and 11% , respectively .",
    "the biggest average gain of crr+rrp over ec - fp is achieved on families _ fvp - unsat.2.0 _ and _ longmult _ ( 18% and 17% , respectively ) . unsurprisingly , both ec and ec - fp are usually much faster than crr+rrp . however , on the three hardest instances of the barrel family , crr+rrp outperforms ec - fp in terms of execution time .",
    "we have proposed an algorithm for minimal unsatisfiable core extraction .",
    "it builds a resolution refutation using a sat solver and finds a first approximation of a minimal unsatisfiable core .",
    "then it checks , for every remaining initial clause @xmath3 , if it belongs to the minimal unsatisfiable core .",
    "the algorithm reuses conflict clauses and resolution relations throughout its execution .",
    "we have demonstrated that our algorithm is faster than currently existing algorithms by a factor of 6 or more on large problems with non - overly hard resolution proofs , and that it can find minimal unsatisfiable cores for real - world formal verification benchmarks .",
    "we thank jinbo huang for his help in obtaining and using mup and zaher andraus for his help in receiving amuse .",
    "nam , g.j . ,",
    "aloul , f. , sakallah , k. , rutenbar , r. : a comparative study of two boolean formulations of fpga detailed routing constraints . in : proceedings of the 2001 international symposium on physical design ( ispd01 ) .",
    "( 2001 )    mcmillan , k.l .",
    ", amla , n. : automatic abstraction without counterexamples . in : proceedings of the ninth international conference on tools and algorithms for the construction and analysis of systems ( tacas03 ) .",
    "( 2003 )              liffton , m.h . ,",
    "sakallah , k.a . : on finding all minimally unsatisfiable subformulas . in : proceedings of the eights",
    "international conference on theory and applications of satisfiability testing ( sat05 ) .",
    "( 2005 )    mneimneh , m.n . ,",
    "lynce , i. , andraus , z.s . , marques - silva , j.p . ,",
    "sakallah , k.a . : a branch and bound algorithm for extracting smallest minimal unsatisfiable formulas . in : proceedings of the eights",
    "international conference on theory and applications of satisfiability testing ( sat05 ) .",
    "( 2005 )        zhang , l. , malik , s. : extracting small unsatisfiable cores from unsatisfiable boolean formula . in : proceedings of sixth international conference on theory and applications of satisfiability testing ( sat03 ) .",
    "( 2003 )            en , n. , srensson , n. : t v1.13 - a sat solver with conflict - clause minimization .",
    "( http://www.cs.chalmers.se / cs / research / formalmethods / minisat / cgi / minisa% t_v1.13_short.ps.gz.cgi[http://www.cs.chalmers.se",
    "/ cs / research / formalmethods / minisat / cgi / minisa% t_v1.13_short.ps.gz.cgi ] )    dershowitz , n. , hanna , z. , nadel , a. : a clause - based heuristic for sat solvers . in : proceedings of the eighth international conference on theory and applications of satisfiability testing ( sat05 ) .",
    "( 2005 )    velev , m. , bryant , r. : effective use of boolean satisfiability procedures in the formal verification of superscalar and vliw microprocessors . in : proceedings of the 38th design automation conference ( dac01 ) .",
    "( 2001 )      berre , d.l . ,",
    "simon , l. : fifty - five solvers in vancouver : the sat 2004 competition . in : proceedings of the seventh international symposium on theory and applications of satisfiability testing ( sat04 ) ."
  ],
  "abstract_text": [
    "<S> the task of extracting an unsatisfiable core for a given boolean formula has been finding more and more applications in recent years . </S>",
    "<S> the only existing approach that scales well for large real - world formulas exploits the ability of modern sat solvers to produce resolution refutations . </S>",
    "<S> however , the resulting unsatisfiable cores are suboptimal . </S>",
    "<S> we propose a new algorithm for minimal unsatisfiable core extraction , based on a deeper exploration of resolution - refutation properties . </S>",
    "<S> we provide experimental results on formal verification benchmarks confirming that our algorithm finds smaller cores than suboptimal algorithms ; and that it runs faster than those algorithms that guarantee minimality of the core . </S>"
  ]
}