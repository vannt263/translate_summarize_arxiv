{
  "article_text": [
    "the most popular programming languages in high performance computing ( hpc ) are those which produce fast executables ( fortran and c for instance ) .",
    "large programs written in these languages are difficult to maintain and these languages are in constant evolution to facilitate the development of large codes .",
    "for example , the c++ language@xcite was proposed as an improvement of the c language by introducing classes and other features of object - oriented programming . in this paper",
    ", we propose a fortran pre - processor with a very limited number of keywords , which facilitates the development of large programs and the re - usability of the code without affecting the efficiency .    in the imperative programming paradigm , a computation is a ordered list of commands that change the state of the program . at the lowest level ,",
    "the machine code is imperative : the commands are the machine code instructions and the state of the program is represented by to the content of the memory . at a higher level , the fortran language is an imperative language .",
    "each statement of a fortran program modifies the state of the memory .    in the functional programming paradigm ,",
    "a computation is the evaluation of a function .",
    "this function , to be evaluated , may need to evaluate other functions .",
    "the state of the program is not known by the programmer , and the memory management is handled by the compiler .",
    "imperative languages are easy to understand by machines , while functional languages are easy to understand by human beings .",
    "hence , code written in an imperative language can be made extremely efficient , and this is the main reason why fortran and c are so popular in the field of high performance computing ( hpc ) .",
    "however , codes written in imperative languages usually become excessively complicated to maintain and to debug . in a large code , it is often very difficult for the programmer to have a clear image of the state of the program at a given position of the code , especially when side - effects in a procedure modifiy memory locations which are used in other procedures .    in this paper , we present a tool called `` implicit reference to parameters with fortran 90 '' ( irpf90 ) . it is a fortran pre - processor which facilitates the development of large simulation codes , by allowing the programmer to focus on _ what _ is being computed , instead of _ how _ it is computed .",
    "this last sentence often describes the difference between the functional and the imperative paradigms@xcite . from a practical point of view , irpf90 is a program written in the python@xcite language .",
    "it produces fortran source files from irpf90 source files .",
    "irpf90 source files are fortran source files with a limited number of additional statements .",
    "to explain how to use the irpf90 tool , we will write a simple molecular dynamics program as a tutorial .",
    "we first choose to implement the lennard - jones potential@xcite to compute the interaction of pairs of atoms : @xmath0\\ ] ] where @xmath1 is the atom - atom distance , @xmath2 is the depth of the potential well and @xmath3 is the value of @xmath1 for which the potential energy is zero .",
    "@xmath2 and @xmath3 are the parameters of the force field .",
    "using an imperative style , one would obtain the program given in figure  [ fig : irp1 ] .",
    "one can clearly see the sequence of statements in this program : first read the data , then compute the value of the potential",
    ".        this program can be re - written using a functional style , as shown in figure  [ fig : irp2 ] . in the functional form of the program",
    ", the sequence of operations does not appear as clearly as in the imperative example .",
    "moreover , the order of execution of the commands now depends on the choice of the compiler : the function sigma_over_r and the function epsilon_lj are both called on line 12 - 13 , and the order of execution may differ from one compiler to the other .",
    "the program was written in such a way that the functions have no arguments .",
    "the reason for this choice is that the references to the entities which are needed to calculate a function appear inside the function , and not outside of the function .",
    "therefore , the code is simpler to understand for a programmer who never read this particular code , and it can be easily represented as a production tree ( figure  [ prod_tree ] , above ) . this tree exhibits the relation \\{needs / needed by } between the entities of interest : the entity v_lj needs the entities sigma_over_r and epsilon_lj to be produced , and sigma_over_r needs sigma_lj and interatomic_distance .    .",
    "below , the tree obtained if only one call to sigma_over_r is made . ]    in the imperative version of the code ( figure  [ fig : irp1 ] ) , the production tree has to be known by the programmer so he can place the instructions in the proper order . for simple programs it is not a problem , but for large codes the production tree can be so large that the programmer is likely to make wrong assumptions in the dependencies between the entities .",
    "this complexifies the structure of the code by the introduction of many different methods to compute the same quantity , and the performance of the code can be reduced due to the computation of entities which are not needed .    in the functional version ( figure  [ fig : irp2 ] ) , the production tree does not need to be known by the programmer .",
    "it exists implicitely through the function calls , and the evaluation of the main function is realized by exploring the tree with a depth - first algorithm .",
    "a large advantage of the functional style is that there can only be one way to calculate the value of an entity : calling the corresponding function .",
    "therefore , the readability of the code is improved for a programmer who is not familiar with the program . moreover , as soon as an entity is needed , it is calculated and valid . writing programs in this way reduces considerably the risk to use un - initialized variables , or variables that are supposed to have a given value but which have been modified by a side - effect .    with the functional example , every time a quantity is needed it is computed , even if it has already been built before .",
    "if the functions are pure ( with no side - effects ) , one can implement memoization@xcite to reduce the computational cost : the last value of the function is saved , and if the function is called again with the same arguments the last result is returned instead of computing it again . in the present example we chose to write functions with no arguments , so memoization is trivial to implement ( figure  [ fig : memo ] ) .        if we consider that the leaves of the production tree are constant , memoization can be applied to all the functions .",
    "the production tree of v_lj can now be simplified , as shown in figure  [ prod_tree ] , below .",
    "irpf90 is a fortran pre - processor : it generates fortran code from source files which contain keywords specific to the irpf90 program .",
    "the keywords understood by irpf90 pre - processor are briefly presented .",
    "they will be examplified in the next subsections for the molecular dynamics example .",
    "end_provider + delimitates the definition of a provider ( sections  [ sub : irp1 ] and  [ sub : irp2 ] ) .",
    "begin_doc ... end_doc + delimitates the documentation of the current provider ( section  [ sub : irp1 ] ) .",
    "begin_shell ... end_shell + delimitates an embedded script ( section  [ sub : irp3 ] ) .",
    "assert + expresses an assertion ( section  [ sub : irp1 ] ) .",
    "touch + expresses the modification of the value of an entity by a side - effect ( section  [ sub : irp4 ] ) .",
    "free + invalidates an entity and free the associated memory .",
    "( section  [ sub : irp6 ] ) .",
    "irp_read / irp_write + reads / writes the content of the production tree to / from disk ( section  [ sub : irp5 ] ) .",
    "irp_if ... irp_else ... irp_endif + delimitates blocks for conditional compilation ( section  [ sub : irp5 ] ) .    provide + explicit call to the provider of an entity ( section  [ sub : irp5 ] ) .      in the irpf90 environment ,",
    "the entities of interest are the result of memoized functions with no arguments .",
    "this representation of the data allows its organization in a production tree , which is built and handled by the irpf90 pre - processor .",
    "the previous program may be written again using the irpf90 environment , as shown in figure  [ fig : irp3 ] .",
    "the program shown in figure  [ fig : irp3 ] is very similar to the functional program of figure  [ fig : irp2 ] .",
    "the difference is that the entities of interest are not functions anymore , but variables .",
    "the variable corresponding to an entity is provided by calling a providing procedure ( or provider ) , defined between the keywords begin_provider ... end_provider . in the irpf90 environment",
    ", a provider can provide several entities ( as shown with the parameters of the potential ) , although it is preferable to have providers that provide only one entity .",
    "when an entity has been built , it is tagged as built .",
    "hence , the next call to the provider will return the last computed value , and will not build the value again .",
    "this explains why in the irpf90 environment the parameters of the force field are asked only once to the user .",
    "the assert keyword was introduced to allow the user to place assertions@xcite in the code .",
    "an assertion specifies certain general properties of a value .",
    "it is expressed as a logical expression which is supposed to be always true .",
    "if it is not , the program is wrong .",
    "assertions in the code provide run - time checks which can dramatically reduce the time spent finding bugs : if an assertion is not verified , the program stops with a message telling the user which assertion caused the program to fail .",
    "the begin_doc ... end_doc blocks contain the documentation of the provided entities .",
    "the descriptions are encapsulated inside these blocks in order to facilitate the generation of technical documentation .",
    "for each entity a `` man page '' is created , which contains the \\{needs / needed by } dependencies of the entity and the description given in the begin_doc ... end_doc block .",
    "this documentation can be accessed by using the irpman command followed by the name of the entity .",
    "the irpf90 environment was created to simplify the work of the scientific programmer .",
    "a lot of time is spent creating makefiles , which describe the dependencies between the source files for the compilation .",
    "as the irpf90 tool `` knows '' the production tree , it can build automatically the makefiles of programs , without any interaction with the user .",
    "when the user starts a project , he runs the command irpf90 init in an empty directory .",
    "a standard makefile is created , with the gfortran compiler@xcite as a default .",
    "then , the user starts to write irpf90 files which contain providers , subroutines , functions and main programs in files characterized by the .irp.f suffix .",
    "running make calls irpf90 , and a correct makefile is automatically produced and used to compile the code .",
    "now the basics of irpf90 are known to the reader , we can show how simple it is to write a molecular dynamics program .",
    "as we will compute the interaction of several atoms , we will change the previous program such that we produce an array of potential energies per atom .",
    "we first need to introduce the quantity natoms which contains the number of atoms .",
    "figure  [ fig : irp4 ] shows the code which defines the geometrical parameters of the system .",
    "figure  [ fig : irp5 ] shows the providers corresponding to the potential energy @xmath4 per atom @xmath5 , where it is chosen equal to the lennard - jones potential energy : @xmath6\\ ] ]        figure  [ fig : irp6 ] shows the providers corresponding to the kinetic energy @xmath7 per atom @xmath5 : @xmath8 where @xmath9 is the mass and @xmath10 is the velocity vector of atom @xmath5 .",
    "the velocity vector is chosen to be initialized zero .",
    "the dimensions of arrays are given in the definition of the provider .",
    "if an entity , defines the dimension of an array , the provider of the dimensioning entity will be called before allocating the array .",
    "this guarantees that the array will always be allocated with the proper size . in irpf90 , the memory allocation of an array entity",
    "is not written by the user , but by the pre - processor .",
    "memory can be explicitely freed using the keyword free .",
    "for example , de - allocating the array velocity would be done using free velocity .",
    "if the memory of an entity is freed , the entity is tagged as `` not built '' , and it will be allocated and built again the next time it is needed .      the irpf90 environment allows the programmer to write scripts inside his code . the scripting language that will interpret the script",
    "is given in brackets .",
    "the result of the shell script will be inserted in the file , and then will be interpreted by the fortran pre - processor .",
    "such scripts can be used to write templates , or to write in the code some information that has to be retrieved at compilation .",
    "for example , the date when the code was compiled can be inserted in the source code using the example given in figure  [ fig : irp7 ] .        in our molecular dynamics program ,",
    "the total kinetic energy e_kin is the sum over all the elements of the kinetic energy vector t : @xmath11 similarly , the potential energy e_pot is the sum of all the potential energies per atom . @xmath12 the code to build e_kin and e_pot is very close : only the names of the variables change , and it is convenient to write the code using a unique template for both quantities , as shown in figure  [ fig : irp8 ] .        in this way , adding a new property which is the sum over all the atomic properties can done be done in only one line of code : adding the triplet ( property , documentation , atomic property ) to the list of entities at line 15 .",
    "many computer simulation programs contain iterative processes . in an iterative process",
    ", the same function has to be calculated at each step , but with different arguments . in our irpf90 environment , at every iteration the production tree is the same , but the values of some entities change . to keep the program correct ,",
    "if the value of one entity is changed it has to be tagged as `` built '' with its new value , and all the entities which depend on this entity ( directly or indirectly ) need to be tagged as `` not built '' .",
    "these last entities will need to be re - computed during the new iteration .",
    "this mechanism is achieved automatically by the irpf90 pre - processor using the keyword touch . the side - effect modifying the value of the entity",
    "is controlled , and the program will stay consistent with the change everywhere in the rest of the code .    in our program , we are now able to compute the kinetic and potential energy of the system .",
    "the next step is now to implement the dynamics .",
    "we choose to use the velocity verlet algorithm@xcite : @xmath13 where @xmath14 and @xmath15 are respectively the position and velocity vectors at step @xmath16 , @xmath17 is the time step and the acceleration vector @xmath18 is defined as @xmath19 the velocity verlet algorithm is written in a subroutine verlet , and the gradient of the potential energy @xmath20 can be computed by finite difference ( figure  [ fig : irp9 ] ) .        computing a component @xmath5 of the numerical gradient of @xmath21",
    "can be decomposed in six steps :    1 .",
    "change the component @xmath5 of the coordinate @xmath22 2 .",
    "compute the value of @xmath21 3 .   change the coordinate @xmath23 4 .   compute the value of @xmath21 5",
    "compute the component of the gradient using the two last values of @xmath21 6 .",
    "re - set @xmath24    the provider of v_grad_numeric follows these steps : in the internal loop , the array coord is changed ( line 16 ) . touching it ( line 17 ) invalidates automatically e_pot , since it depends indirectly on coord .",
    "as the value of e_pot is needed in line 18 and not valid , it is re - computed between line 17 and line 18 .",
    "the value of e_pot which is affected to v_grad_numeric(k , i ) is the value of the potential energy , consistent with the current set of atomic coordinates .",
    "then , the coordinates are changed again ( line 19 ) , and the program is informed of this change at line 20 . when the value of e_pot is used again at line 22 , it is consistent with the last change of coordinates . at line 23",
    "the coordinates are changed again , but no touch statement follows .",
    "the reason for this choice is efficiency , since two cases are possible for the next instruction : if we are at the last iteration of the loop , we exit the main loop and line 26 is executed .",
    "otherwise , the next instruction will be line 16 .",
    "touching coord is not necessary between line 23 and line 16 since no other entity is used .",
    "the important point is that the programmer does nt have to know _ how _",
    "e_pot depends on coord .",
    "he only has to apply a simple rule which states that when the value of an entity @xmath25 is modified , it has to be touched before any other entity @xmath26 is used .",
    "if @xmath26 depends on @xmath25 , it will be re - computed , otherwise it will not , and the code will always be correct . using this method to compute a numerical gradient",
    "allows a programmer who is not familiar with the code to compute the gradient of any entity @xmath25 with respect to any other quantity @xmath26 , without even knowing if @xmath25 depends on @xmath26 .",
    "if @xmath25 does not depend on @xmath26 , the gradient will automatically be zero . in the programs dealing with optimization problems ,",
    "it is a real advantage : a short script can be written to build automatically all the possible numerical derivatives , involving all the entities of the program , as given in figure  [ fig : irp11 ] .",
    "the velocity verlet algorithm can be implemented ( figure  [ fig : irp10 ] ) as follows :    1 .",
    "compute the new value of the coordinates 2 .",
    "compute the component of the velocities which depends on the old set of coordinates 3 .   touch the coordinates and the velocities 4 .",
    "increment the velocities by their component which depends on the new set of coordinates 5 .",
    "touch the velocities              as irpf90 is designed for hpc , conditional compilation is an essential requirement .",
    "indeed , it is often used for activating and deactivating blocks of code defining the behavior of the program under a parallel environment .",
    "this is achieved by the irp_if ...",
    "irp_else ... irp_endif constructs . in figure",
    "[ fig : irp101 ] , the checkpointing block is activated by running irpf90 -dcheckpoint . if the -d option is not present , the other block is activated .",
    "the current state of the production tree can written to disk using the command irp_write as in figure  [ fig : irp101 ] .",
    "for each entity in the subtrees of e_pot and e_kin , a file is created with the name of the entity which contains the value of the entity .",
    "the subtree can be loaded again later using the irp_read statement .",
    "this functionality is particularly useful for adding quickly a checkpointing feature to an existing program .",
    "the provide keyword was added to assign imperatively a needs / needed by relation between two entities .",
    "this keyword can be used to associate the value of an entity to an iteration number in an iterative process , or to help the preprocessor to produce more efficient code .",
    "a last convenient feature was added : the declarations of the local variables do not need anymore to be located before the first executable statement .",
    "the local variables can now be declared anywhere inside the providers , subroutines and functions .",
    "the irpf90 pre - processor will put them at the beginning of the subroutines or functions for the programmer .",
    "it allows the user to declare the variables where the reader needs to know to what they correspond .",
    "in the laboratory , we are currently re - writing a quantum monte carlo ( qmc ) program , named qmc = chem , with the irpf90 tool .",
    "the same computation was realized with the old code ( usual fortran code ) , and the new code ( irpf90 code ) .",
    "both codes were compiled with the intel fortran compiler version 11.1 using the same options .",
    "a benchmark was realized on an intel xeon 5140 processor .    the irpf90 code is faster than the old code by a factor of 1.60 :",
    "the cpu time of the irpf90 executable is 62% of the cpu time of the old code .",
    "this time reduction is mainly due to the avoidance of computing quantities that are already computed .",
    "the total number of processor instructions is therefore reduced .",
    "the average number of instructions per processor cycle is 1.47 for the old code , and 1.81 for the irpf90 code .",
    "this application shows that even if the un - necessary computations were removed from the old code , the code produced by irpf90 would still be more efficient .",
    "the reason is that in irpf90 , the programmer is guided to write efficient code : the providers are small subroutines that manipulate a very limited number of memory locations .",
    "this coding style improves the temporal locality of the code@xcite and thus minimizes the number of cache misses .",
    "the conclusion of this real - size application is that the overhead due to the management of the production tree is negligible compared to the efficiency gained by avoiding to compute many times the same quantity , and by helping the fortran compiler to produce optimized code .",
    "the irpf90 environment is proposed for writing programs with reduced complexity .",
    "this technique for writing programs , called `` implicit reference to parameters '' ( irp),@xcite is conform to the recommendations of the `` open structure interfaceable programming environment '' ( osipe)@xcite :    * open : unambiguous identification and access to any entity anywhere in the program * interfaceable : easy addition of any new feature to an existing code * structured : the additions will have no effect on the program logic    the programming paradigm uses some ideas of functional programming and thus clarifies the correspondance between the mathematical formulas and the code .",
    "therefore , scientists do not need to be experts in programming to write clear , reusable and efficient code , as shown with the simple molecular dynamics code presented in this paper .",
    "the consequences of the locality of the code are multiple :    * the code is efficient since the temporal locality is increased , * the overlap of pieces of code written simultaneously by multiple developers is reduced . *",
    "regression testing@xcite can be achieved by writing , for each entity , a program which tests that the entity is built correctly .",
    "finally , let us mention that the irpf90 pre - processor generates fortran 90 which is fully compatible with standard subroutines and functions . therefore the produced fortran code can be compiled on any architecture , and the usual hpc libraries ( blas@xcite , lapack@xcite , mpi@xcite ,  ) can be used .",
    "the irpf90 program can be downloaded on http://irpf90.sourceforge.net",
    "the author would like to acknowledge f. colonna ( cnrs , paris ) for teaching him the irp method , and long discussions around this subject .",
    "the author also would like to thank p. reinhardt ( universit pierre et marie curie , paris ) for testing and enjoying the irpf90 tool , and f. spiegelman ( universit paul sabatier , toulouse ) for discussions about the molecular dynamics code .",
    "hughes r.j.m .",
    "`` lazy memo functions '' in : g. goos and j. hartmanis , eds .",
    "conf : on functional programming and computer architecture , nancy , france , september 1985 , springer lecture note series , vol . 201 ( springer , berlin , 1985 ) .                  l. s. blackford , j. demmel , j. dongarra , i. duff , s. hammarling , g. henry , m. heroux , l. kaufman , a. lumsdaine , a. petitet , r. pozo , k. remington , r. c. whaley , _ acm trans . math .",
    "_ * 28(2 ) * , 135 ( 2002 ) .",
    "anderson e. , bai z. , bischof c. , blackford s. , demmel j. , dongarra j. , du croz j. , greenbaum a. , hammarling s. , mckenney a. and sorensen d. _ lapack users guide _ , ed : society for industrial and applied mathematics , philadelphia , pa , ( 1999 ) ."
  ],
  "abstract_text": [
    "<S> irpf90 is a fortran programming environment which helps the development of large fortran codes . in fortran programs , </S>",
    "<S> the programmer has to focus on the order of the instructions : before using a variable , the programmer has to be sure that it has already been computed in all possible situations . for large codes , it is common source of error . in irpf90 </S>",
    "<S> most of the order of instructions is handled by the pre - processor , and an automatic mechanism guarantees that every entity is built before being used . </S>",
    "<S> this mechanism relies on the \\{needs / needed by } relations between the entities , which are built automatically . </S>",
    "<S> codes written with irpf90 execute often faster than fortran programs , are faster to write and easier to maintain . </S>"
  ]
}