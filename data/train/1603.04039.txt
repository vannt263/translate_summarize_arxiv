{
  "article_text": [
    "the particle - in - cell ( pic ) method @xcite is a popular method for solving the vlasov - poisson equations for a class of problems in plasma physics , astrophysics , and particle accelerators , for which electrostatic approximation applies , as well as for solving the gravitational problem in cosmology and astrophysics .",
    "in such a hybrid particle - mesh method , the distribution function is approximated using particles and the poisson problem is solved on a rectangular mesh . charges ( or masses ) of particles are interpolated onto the mesh , and the poisson problem is discretized using finite differences or spectral approximations .",
    "on simple rectangular domains , fft methods are most commonly used for solving the poisson problem . in the presence of irregular boundaries , finite difference approximations are often used , complemented by a cut - cell ( a.k.a . embedded boundary )",
    "method @xcite for computational cells near boundaries , and fast linear solvers ( including multigrid iterations ) for the corresponding linear system . the computed force ( gradient of the potential ) on the mesh is then interpolated back to the location of particles . for problems with irregular geometry , unstructured grid with finite element method",
    "is often used .",
    "the traditional pic method has several limitations .",
    "it is less straightforward to use for geometrically complex domains . the aforementioned embedded boundary method , while maintaining globally second order accuracy for the second order finite difference approximation , usually results in much larger errors near irregular boundaries @xcite .",
    "it is also difficult to generalize to higher order accuracy .",
    "another major drawback of the pic method is associated with highly non - uniform distribution of particles .",
    "as shown in section 2 , the discretization of the differential operator and the right hand side in the pic method is not balanced in terms of errors .",
    "the accuracy is especially degraded in the presence of non - uniform particle distributions .",
    "the amr - pic @xcite improves this problem by performing block - structured adaptive mesh refinement of a rectangular mesh , so that the number of particles per computational cell is approximately the same .",
    "however , the original amr - pic algorithms suffered from very strong artificial self - forces due to spurious images of particles across boundaries between coarse and refined mesh patches .",
    "analysis of self - force sources and a method for their mitigation was proposed in @xcite .    in this paper",
    ", we propose a new adaptive particle - in - cloud ( ap - cloud ) method for obtaining optimal numerical solutions to the vlasov - poisson equation . instead of a cartesian grid",
    "as used in the traditional pic , the ac - cloud uses adaptive computational nodes or particles with an octree data structure .",
    "the quantity characterizing particles ( charge in electrostatic problems or mass in gravitational problems ) is assigned to computational nodes by a weighted least squares approximation .",
    "the partial differential equation is then discretized using a generalized finite difference ( gfd ) method and solved with fast linear solvers .",
    "the density of nodes is chosen adaptively , so that the error from gfd and that from monte carlo integration are balanced , and the total error is approximately minimized .",
    "the method is independent of geometric shape of computational domains and free of artificial self - forces .",
    "the remainder of the paper is organized as follows . in section 2 ,",
    "we analyze numerical errors of the traditional pic method and formulate optimal refinement strategy .",
    "the ap - cloud method , generalized finite differences , and the relevant error analysis are presented in section 3 .",
    "section 4 describes some implementation details of the method .",
    "section 5 presents numerical verification tests using 2d and 3d problems of particle beams with halo and additional tests demonstrating the absence of artificial self - forces .",
    "we conclude this paper with a summary of our results and perspectives for the future work .",
    "in a particle - in - cell ( pic ) method , the computational objects include a large number of particles and an associated cartesian grid .",
    "these particles are typically randomly sampled and represent an even greater number of physical particles ( e.g. , protons ) , so they are also known as `` macro - particles '' , but conventionally simply referred to as particles . for simplicity of presentation",
    ", we will focus on electrostatic problems , for which the states are particle charges .",
    "suppose there are @xmath0 charged particles at positions @xmath1 in @xmath2 dimensions , and let @xmath3 denote the charge at @xmath4 . for simplicity , we assume that all the particles carry the same amount of charge , the total charge is 1 , i.e. , @xmath5 , and the charges of the particles can be represented accurately by a continuous charge distribution function @xmath6 .",
    "we assume that @xmath6 is smooth and positive , and its value and all derivatives have comparable magnitude .",
    "let @xmath7 denote the cartesian grid , and without loss of generality , suppose its edge length is @xmath8 along all directions , and let @xmath9 denote the @xmath10th grid point in @xmath7 .",
    "a pic method estimates the charge density @xmath6 on @xmath7 , then solves the poisson equation @xmath11 on @xmath7 to obtain the potential @xmath12 , whose gradient is the electric field @xmath13 . in this setting , a pic method consists of the following three steps :    1 .",
    "approximate the right - hand side of ( [ eq : poisson ] ) by interpolating the states from particles to the grid points @xmath9 , i.e. , @xmath14 where @xmath15 is the interpolation kernel , a.k.a .",
    "the charge assignment scheme .",
    "2 .   discretize the left - hand side of ( [ eq : poisson ] ) on @xmath7 , typically using the finite difference method , and then solve the resulting linear system .",
    "3 .   obtain the electric field @xmath13 by computing @xmath16 using finite difference , and then interpolating @xmath13 from the grid points to the particles using the same interpolation kernel @xmath15 as in step 1 , i.e. , @xmath17    one of the most commonly used charge assignment schemes @xmath15 is the cloud - in - cell ( cic ) scheme @xmath18 for which the interpolation in step 3 corresponds to bilinear and trilinear interpolation in 2-d and 3-d , respectively .    in pic , the error in potential @xmath12 comes from two sources .",
    "one is from the first approximation in ( [ eq : density ] ) , for which the analysis is similar to monte carlo integration within a control volume associated with @xmath9 , under the assumption that ( [ eq : density ] ) is a continuous function .",
    "the other source is the discretization error of both the second approximation in ( [ eq : density ] ) in step 1 and the left - hand side of ( [ eq : poisson ] ) on @xmath7 in step 2 .",
    "we denote the above two errors from these two sources as @xmath19 and @xmath20 , respectively . as shown in [ appen ] , under the assumption that the interpolation kernel @xmath15 satisfies the positivity condition , the expected value of the former is @xmath21=\\mathcal{o}\\left(\\sqrt{\\frac{\\rho(\\mathbf{y})}{nh^d}}\\right),\\ ] ] and the discretization error is @xmath22 let @xmath23 denote the coefficient matrix of the linear system in step 2 , and suppose @xmath24 is bounded by a constant .",
    "the expected total error in the computed potential @xmath12 is then @xmath25)+\\mathcal{o}(\\mathcal{e}_{d})= \\mathcal{o}\\left(\\sqrt{\\frac{\\rho(\\mathbf{y})}{nh^d}}+\\rho(\\mathbf{y})h^2\\right).\\ ] ]    in general , @xmath20 dominates the total error for coarse grids and @xmath19 dominates for finer grids .",
    "the total expected error is approximately minimized if @xmath19 and @xmath20 are balanced .",
    "if the particles are uniformly distributed , then the errors are balanced when @xmath26 in this setting , the discretization error in @xmath12 is second order in @xmath8 . the discretization error in numerical differentiation",
    "@xmath27 is also second order , a fact called supraconvergence  @xcite .",
    "thus , although the optimal mesh size is deduced to minimize the error in @xmath12 , the error in @xmath13 is also minimized .    in many applications ,",
    "the particle distribution is highly non - uniform , for which the pic is neither efficient nor accurate . in @xcite , an adaptive method , called amr - pic ,",
    "was proposed , which fixed the number of particles per cell , and hence @xmath28 the amr - pic over - refines the grid compared to the optimal grid resolution in ( [ eq : optimal ] ) .",
    "in addition , the original amr - pic technique also introduces artificial self forces .",
    "new adaptive strategies are needed to resolve both of these issues .",
    "in this section , we describe a new adaptive method , called adaptive particle - in - cloud or ap - cloud , which approximately minimizes the error by balancing monte carlo noise and discretization error , and at the same time is free of the artificial self forces present in amr - pic .",
    "the ap - cloud method can be viewed as an adaptive version of pic that replaces the traditional cartesian mesh of pic by an octree data structure .",
    "we use a set of computational nodes , which are octree cell centres , instead of the cartesian grid , of which the distribution is derived using an error balance criterion .",
    "computational nodes will be referred to as nodes in the remainder of the paper . instead of the finite difference discretization of the laplace operator ,",
    "we use the method of generalized finite - difference ( gfd ) @xcite , based on a weighted least squares formulation .",
    "the framework includes interpolation , least squares approximation , and numerical differentiation on a stencil in the form of cloud of nodes in a neighborhood of the point of interest .",
    "it is used for the charge assignment scheme , numerical differentiation , and interpolation of solutions .",
    "the advantage of gfd is that it can treat coarse regions , refined regions , and refinement boundaries in the same manner , and it is more flexible for problems in complex domain or with irregular refinement area . as a method of integration , gfd will be used in the quadrature rule in charge assignment scheme .",
    "the new charge assignment scheme , together with gfd differentiation and interpolation operators from computational nodes to particles is easily generalizable to higher order schemes .",
    "we described the key components of the ap - cloud in this section , and discuss its implementation details in section  [ sec : implementation ] .",
    "for simplicity of presentation , we consider a second order generalized finite - difference method .",
    "let @xmath9 , @xmath29 be the nodes in a neighborhood of reference node @xmath30 .",
    "given a @xmath31 function @xmath32 , by taylor expansion we have @xmath33 where @xmath8 is the characteristic interparticle distance in the neighborhood , for example , @xmath34 , and @xmath35 is the hessian matrix .",
    "putting equations for all neighbors together and omitting higher order term , we obtain @xmath36 where @xmath37 is a generalized vandermonde matrix , @xmath38 is the first order and second order derivative of @xmath32 at @xmath30 , and @xmath39 is the increment of @xmath32 .    for example , in 2-d , let @xmath40 and @xmath41 , then @xmath42,\\ ] ] @xmath43^t,\\ ] ] where @xmath44 denotes the derivative of @xmath32 with respect to @xmath45 , and @xmath46^t.\\ ] ]    to analyze the error in gfd , let @xmath47 . rewrite ( [ gfd ] ) as @xmath48 where @xmath49,\\ ] ] @xmath50^t.\\ ] ] now @xmath51 depends on the shape but not the diameter of the gfd stencil . the error in solving",
    "linear system is @xmath52 the error in right hand size comes from the omitted term in the taylor expansion @xmath53 for @xmath54 , and @xmath55 is a constant independent of @xmath8 , so the error in @xmath56 is also @xmath57 . because the coefficient before the @xmath58th order derivative in @xmath56 is @xmath59 , the error for @xmath58th order derivative is @xmath60    in this example , the number of neighbors is equal to the number of unknowns , and it is quite likely for @xmath51 to be nearly singular . in practice , we use more neighbors in the stencil than the number of coefficients in the taylor series to improve the stability . in ap - cloud method , 8 neighbors instead of 5 are used for the second order gfd in two dimensions , and 17 neighbors instead of 9 are used in three dimensions . in this case , the linear system is a least square problem .",
    "it is often helpful to assign more weights to closer neighbors to improve the accuracy , which is called the weighted lest square method  @xcite .",
    "ap - cloud method uses a normalized gaussian weight function  @xcite : @xmath61 where @xmath62 is the weight , @xmath63 is the distance of the neighbor from the reference particle , @xmath64 is the maximum distance of all neighbors in the stencil from the reference particle , @xmath65 .    by solving the linear system or least square problem ( [ gfd ] )",
    ", we can express the gradient @xmath66 as linear combinations of @xmath67 .",
    "for example , once the potential @xmath12 is computed at nodes , we can find its gradient by generalized finite - difference , and then interpolate it to particles by taylor expansion .",
    "generally , the error of the @xmath68th order gfd interpolation is @xmath69 , and its approximation of the @xmath58th order derivative is @xmath70 .    given a set of nodes , the selection for gfd neighbors , or",
    "the shape of the gfd stencil , is important for both accuracy and stability .",
    "simply choosing the nearest nodes to be neighbors may lead to an imbalanced stencil .",
    "we follow the quadrant criterion in  @xcite and select two nearest nodes from each quadrant to be neighbors .",
    "ap - cloud also has three steps to calculate the electric field given by a particle distribution : a density estimator , a poisson solver , and an interpolation step , but each step is different from its counterpart in pic .",
    "let @xmath71 be the set of all computational nodes , and @xmath72 , where @xmath73 is the total number of nodes .",
    "below is a detailed description of the three steps .    1 .   approximate density by interpolating states from particles @xmath74 to computational nodes @xmath71 by @xmath75 + the right hand side of ( [ eq : density_apcloud ] ) is identical to the monte carlo integration in pic , but the left hand side is a linear combination of derivatives , instead of the simple @xmath76 in the pic method . because the coefficients in the linear combination , @xmath77 , depend only on @xmath8 and the interpolation kernel ,",
    "they can be easily pre - calculated and tabulated in a lookup table .",
    "the derivatives @xmath78 are in turn linear combinations of density values @xmath79 given by least square solution of ( [ gfd ] ) : @xmath80 where @xmath81 is the pseudo - inverse of the vandermonde matrix .",
    "+ let @xmath82 be a matrix such that @xmath83 . substituting ( [ eq : pseudoinverse ] ) into ( [ eq : density_apcloud ]",
    ") , we get a linear equation for density values at the reference node @xmath9 and its neighors @xmath84 + putting equations for all nodes together , we obtain a global linear system for density values @xmath85 where @xmath86 $ ] . solution of ( [ eq : density_linear_system ] ) is the estimated density in ap - cloud method .",
    "2 .   discretize the left - hand side of ( [ eq : poisson ] ) on @xmath71 using gfd method .",
    "solve the resulting linear system for @xmath87 .",
    "3 .   obtain the electric field @xmath13 by computing @xmath16 using gfd method , and then interpolating @xmath12 and @xmath13 from the @xmath71 to @xmath74 using a taylor expansion .",
    "similar to pic , the error in ap - cloud also contains the monte carlo noise @xmath88 and the discretization error @xmath89 .",
    "the monte carlo noise in replacing @xmath90 by @xmath91 is identical to the monte carlo noise in pic , that is , @xmath92 .",
    "the discretization error in the first step has two sources : the taylor expansion in ( [ eq : density_apcloud ] ) and the gfd approximation of the gradient in ( [ eq : pseudoinverse ] ) .",
    "the difference between the average of the @xmath68th order taylor expansion of @xmath6 and @xmath6 itself is @xmath93 , where we obtain an additional order for even @xmath68 due to the symmetry of the kernel @xmath15 . because the error of @xmath58th order derivative is @xmath94 , and the coefficient for @xmath58th order derivative @xmath95 , the discretization error given by the gfd derivative approximation is @xmath96 .",
    "thus the total discretization error in step 1 is @xmath97 .",
    "generalized finite - difference poisson solver has the same accuracy with its estimation of @xmath98 , i.e. , @xmath99 .",
    "however , for the second order gfd we observe a supraconvergence when the gfd stencil is well - balanced due to the error cancellation similar to that in the standard five point finite difference stencil . in this case , the error for the solution and its gradient of the gfd poisson solver are both @xmath100 , as observed in our numerical experiments .",
    "the interpolation from @xmath71 to @xmath74 , based on the @xmath68th order taylor expansion of @xmath12 where the derivatives are given by gfd , is @xmath101th order accurate for @xmath12 and @xmath68th order accurate for @xmath13 .      generally , when @xmath68th order gfd is used in the charge assignment scheme , the poisson solver , and the differentiation and interpolation routines , the total error for both @xmath12 and @xmath13 are @xmath102)+\\mathcal{o}(\\mathcal{e}_d ) = \\mathcal{o}\\left(\\sqrt{\\frac{\\rho(\\mathbf{y})}{nh^d}}+\\rho(\\mathbf{y})h^{k-1}\\right),\\ ] ] where the @xmath99 leading term in discretization error is from gfd poisson solver .",
    "to minimize the error , the optimal mesh size is @xmath103 and the minimized error is @xmath104    for the second order gfd in particular , we have better error bound due to the symmetry of interpolation kernel and stencil and supraconvergence @xmath105+\\mathcal{e}_d = \\mathcal{o}\\left(\\sqrt{\\frac{\\rho(\\mathbf{y})}{nh^d}}+\\rho(\\mathbf{y})h^2\\right),\\ ] ] and the optimal mesh size is the same as in ( [ eq : optimal ] ) @xmath106",
    "we use a @xmath107-tree data structure to store particles , and select some of its cell centres as computational nodes .",
    "the @xmath107-tree data structure is a tree data structure in a @xmath2-dimensional space in which each cell has at most @xmath107 children .",
    "quadtree and octree are standard terms in 2d and 3d spaces , respectively .    the algorithm in  @xcite is used in the @xmath107-tree construction .",
    "the first step is to sort the particles by their morton key , so particles in the same cell are contiguous in the sorted array",
    ". then leaf cells are constructed by an array traversal , during which we record the number of particles and the index of the first particle in each cell . at last",
    "the interior cells are constructed in a depth decreasing order by a traversal of cells of the deeper level .",
    "the overall time complexity , dominated by the morton key sorting , is @xmath108 , where @xmath0 is the total number of particles .",
    "this parallel @xmath107-tree construction algorithm , together with parallel linear solver , enables efficient parallel implementation of ap - cloud .",
    "because all computational nodes are cell centres of a @xmath107-tree , their distribution will be similar to an amr - pic mesh .",
    "this is a result of our implementation method and not an internal property of ap - cloud .",
    "the optimal interparticle distance @xmath8 given in ( [ gfdoptimal ] ) depends on the charge density @xmath6 .",
    "in most applications , we do not know @xmath6 in advance ; otherwise , we do not need the charge assignment scheme to estimate it .",
    "we use a monte carlo method to obtain a rough estimation of @xmath6 : @xmath109 where @xmath110 is the volume of a neighborhood of @xmath111 , and @xmath112 is the number of particles in the neighborhood .    if the neighborhood is the box with the edge length @xmath8 centred at @xmath111 , @xmath113 , we substitute ( [ rough ] ) into ( [ gfdoptimal ] ) and obtain @xmath114      if the charge density undergoes rapid changes , as is typical for certain applications ( such as particle accelerators and cosmology ) , the optimal @xmath8 ( [ criterion ] ) also changes rapidly .",
    "this causes two potential problems .",
    "first , when the difference between levels of refinement on two sides of a cell is too large , that cell can not find a balanced gfd stencil .",
    "if no particle in the coarse side is chosen to be its neighbor , the information on that side is missing .",
    "if we force the algorithm to choose a particle on the coarse side as a neighbor , the truncation error from this particle is much larger than that from the others .",
    "second , in some cases , there are almost no particles in the region near the boundary . in order to enforce the boundary condition ,",
    "interior nodes need to use far away nodes located on the boundary as their neighbors .    to avoid these two problems , we enforce a 2:1 mesh balance .",
    "the 2:1 mesh balance requires that the difference between the levels of refinement of two neighbors is at most one . because the mesh size changes smoothly , both imbalanced gfd stencils and empty regions are avoided .      for clarity",
    ", we will focus on the selection of nodes in 3d in this subsection .",
    "the selection of nodes in 2d is similar and easier .",
    "an octree cell and the centre of a cell will be used interchangeably in this subsection .",
    "we say an octree cell @xmath115 is a neighbor of another octree cell @xmath111 in a set of octree cells @xmath116 , if    * @xmath117 ; * @xmath118 is a face . * @xmath119 ; * no ancestor of @xmath115 satisfies the previous three conditions .",
    "the neighbors defined here are different from the neighbors in  @xcite or the neighbors in gfd stencil .",
    "generally , for any cell @xmath111 in any set of octree cells @xmath116 , it has at most 6 neighbors , each corresponding to one of its 6 faces .",
    "it is possible for a cell to have less than 6 neighbors .",
    "for example , root cell has no neighbor in any @xmath116 in a non - periodic region .    during the selection of nodes",
    ", we will keep a queue of octree cells , @xmath120 , and a list @xmath121 for each cell @xmath111 in @xmath120 containing its neighbors in @xmath120 , which we call neighbor list .",
    "the basic operation is to open a cell @xmath122 :    1 .   mark @xmath111 as non - node candidate .",
    "2 .   add all children cells of @xmath111 at the end of @xmath120 , mark them as node candidates .",
    "3 .   initialize the neighbor lists of the new added cells .",
    "some of the neighbors are their siblings , while others are the neighbors of @xmath111 or children of the neighbors of @xmath111 .",
    "4 .   update the neighbor lists of the descendent of the neighbors of @xmath111 .",
    "the algorithm for the selection of nodes is as follows .    1 .",
    "initialize a queue @xmath120 , which contains only the root cell .",
    "2 .   traverse @xmath120 .",
    "for each cell @xmath111 in @xmath120 , test if it satisfies @xmath123 where @xmath124 is a tuning parameter , @xmath8 is the diameter of the subtree , @xmath73 is the number of particles in the subtree .",
    "if the condition is not satisfied , open @xmath111 . let @xmath58 be the deepest level in @xmath120 at the end of this traverse .",
    "3 .   traverse @xmath120 .",
    "for each leaf cell @xmath111 at level @xmath58 , check if the neighbors of @xmath111 satisfy the 2:1 mesh balance .",
    "open each neighbor @xmath115 that does not satisfy 2:1 mesh balance .",
    "4 .   if @xmath125 , let @xmath126 , then repeat step 3 .",
    "if @xmath127 , output all node candidates as computational nodes . if non - periodic boundary condition is used , add additional nodes on the boundary .",
    "given the number of particles and the order of gfd is fixed , the tuning parameter @xmath124 in ( [ errorbalance_implementation ] ) determines the number of nodes .",
    "ideally , @xmath124 can be computed from the constant in the proportional relationship in ( [ gfdoptimal ] ) , which in turn depends on the order of gfd , the kernel function , and the relative magnitude of @xmath6 and its gradients .",
    "however , in most applications , the relative magnitude of @xmath6 and its gradients is unknown , so we try different values of @xmath124 and compare their results to estimate its optimal value in numerical tests .",
    "checking error balance criterion and 2:1 mesh balance takes only constant number of operations per cell . except the part to update the neighbor lists , each open operation takes constant number of elementary operations as well , which can be charged on the 8 new added cells , so the time complexity is @xmath128 , where @xmath129 is the number of cells in @xmath120 in the end of the selection . to analyze the complexity to update the neighbor lists",
    ", we note that each time we update the neighbor of a cell @xmath115 in @xmath120 , the level of its neighbor increases .",
    "since the level of its neighbor is bounded by the height of the octree @xmath130 , the total running time to update neighbors of all particles is @xmath131 . because each interior cell of @xmath120 has 8 children",
    ", @xmath120 is a complete octree , we have @xmath132 , where @xmath73 is the number of not opened cells , i.e. , the number of computational nodes . in conclusion , the complexity to select nodes is @xmath131 .    after selecting the nodes ,",
    "the neighbor list can be used to search gfd neighbors .",
    "if @xmath115 is a neighbor of node @xmath111 , and @xmath115 is not a node itself , then the 4 children of @xmath115 that share a face with @xmath111 must be nodes because of 2:1 mesh balance .",
    "the nodes among the neighbors of @xmath111 and the children of these neighbors that share a face with @xmath111 are called 1-ring .",
    "the union of the @xmath68-ring and the nodes among the neighbors of @xmath68-ring nodes and the children of these neighbors that share a face with @xmath68-ring nodes are called @xmath101-ring .",
    "gfd neighbors are chosen from 2-ring by the quadrant criterion if there are enough number of nodes in 2-ring .",
    "if there are not enough number of nodes in @xmath68-ring , we will try to select gfd neighbors from @xmath101-ring . in our simulations",
    ", 5-ring always contains enough neighbors .",
    "because this neighbor searching algorithm only depends on the local nodes information and local data structures , we claim the complexity to search neighbors of a node is independent from the total number of nodes , and this algorithm takes @xmath133 time to find neighbors of all computational nodes .",
    "one problem is related to the fact that we do not know in advance how deep the nodes are in the octree while we build the octree .",
    "in other words , it is possible that during the algorithm to select nodes , a leaf cell in the octree needs to be opened .",
    "however , this is very unlikely to happen in practice , if we always use the maximum depth supported in the implementation .",
    "for example , in the 2d gaussian beam with halo test in section 5 , the order of gfd is 2 , the region is @xmath134\\times[-1,1]$ ] , and the minimum tuning parameter @xmath124 used in simulations is 0.01 . if we use a 64 bits morton key , the maximum depth of the octree is 21 , the cell size of the leaf cell is @xmath135 . according to ( [ errorbalance_implementation ] )",
    ", @xmath136 particles must be in the same leaf cell in order to open it , which is more than the total number of particles in the whole domain .",
    "the ap - cloud method approximately minimizes the error .",
    "however , it does incur additional cost for the construction and search of the octree data structure .",
    "in addition , the fast fourier transform can no longer be used for solving the resulting linear system , so we must replace it with a sparse linear solver .",
    "therefore , the practical advantage of ap - cloud is by no means obvious . in this section ,",
    "we present some numerical results for problems with non - uniform distribution , and demonstrate the advantages of ap - cloud in terms of both accuracy and efficiency compared to pic .",
    "we also discuss potential advantages over amr - pic .",
    "we have performed verification of the adaptive particle - in - cloud method using examples of highly non - uniform distributions of particles typical for accelerator beams with halos . in such problems , a high - intensity , small - sigma particle beam is surrounded by a larger radius halo containing from 3 to 6 orders of magnitude smaller number of particles compared to the main beam . as accurate modeling of realistic accelerator beam and halo distributions is unnecessary for the numerical verification",
    ", we represent the system by axially symmetric gaussian distributions .",
    "this also allows us to obtain a benchmark solution .",
    "consider the following 2d electrostatic problem @xmath137 where charge density @xmath6 is given by two overlapping gaussian distribution : @xmath138 , \\label{gaussiandist}\\ ] ] in the domain @xmath139\\times [ -1,1]$ ] .",
    "we use the following values for the coefficients : the radius of the main beam @xmath140 , the halo intensity @xmath141 , and the width of the halo @xmath142 .",
    "coefficient @xmath143 is a normalization parameter to ensure @xmath144 .",
    "the model is consistent ( in terms of the order of magnitude for the beam versus halo ratio ) with real particles beams in accelerators .",
    "while the ap - cloud method is independent of the geometric shape of the computational domain , we solve the problem in a square domain to enable the comparison with the traditional pic method .",
    "the benchmark solution is obtained in the following way .",
    "the problem is embedded in a larger domain , a radius 2 disk , using the same charge density function @xmath6 and the homogeneous dirichlet boundary condition .",
    "a solution , obtained by a highly refined 1d solver in cylindrically symmetric coordinates , is considered as the benchmark solution . the dirichlet boundary condition for the two - dimensional problem",
    "is computed by interpolating the 1d solution at the location of the 2d boundary .",
    "this boundary condition function is then used for both the second - order ap - cloud and pic methods .    in our numerical simulations , cic scheme  ( [ cloud_in_cell ] )",
    "is used in charge assignment and interpolation in pic method .",
    "theoretically , there are more accurate schemes available , such as triangular shaped cloud with reshaping step . however , these higher order schemes are very computationally intensive , and are not able to give better result than cic with the same cpu time in our numerical tests .",
    "the order of accuracy of ap - cloud method does not depend on the particular kernel function @xmath15 , so we choose the nearest grid point scheme for its simplicity , that is , @xmath15 in  ( [ eq : density_apcloud ] ) is set to be the characteristic function of the corresponding octree cell .",
    "particles and the electric potential.,width=302 ]         computed by ap - cloud .",
    "( @xmath145),width=302 ]     computed by ap - cloud .",
    "( @xmath146),width=302 ]    .cpu time and accuracy of traditional pic with @xmath147 particles . [ cols=\"^,^,^,^\",options=\"header \" , ]             results presented in tables [ 3d_pic ] and [ 3d_ap_cloud ] and figures [ log_plot_3d_n ] and [ log_plot_3d_t ] show that the advantage of ap - cloud is more evident in 3d problem . with only 1546 nodes and less than 1 second running time , ap - cloud has more accurate result than pic with 4096000 cells and more than 361 seconds running time .      as mentioned in the introduction , vlasov - poisson problems with highly non - uniform distributions of matter",
    "can be solved using the adaptive mesh refinement technique for pic @xcite .",
    "however , it is well known that amr - pic introduces significant artifacts in the form of artificial image particles across boundaries between coarse and fine meshes .",
    "these images introduce spurious forces that may potentially alter the particle motion to an unacceptable level @xcite .",
    "methods for the mitigation of the spurious forces have been designed in @xcite .",
    "the traditional pic on a uniform mesh is free of such artifacts .",
    "the convergence of adaptive particle - in - cloud solutions to benchmark solutions , discussed in the previous section , already indicates the absence of artifacts . to further verify that ap - cloud is free of artificial forces present in the original amr - pic",
    ", we have performed an additional test similar to the one in @xcite , which involved the motion of a single particle across the coarse and fine mesh interface . for ap - cloud",
    ", we studied the motion of a single test particle represented by a moving cloud of nodes with refined distances towards the test particle .",
    "the test particle contained a smooth , sharp , gaussian - type charge distribution to satisfy the requirements of the gfd method .",
    "the forces and motion of a single test particle obtained with pic and ap - cloud methods are shown in figure  [ fig : single_p_trajectory ] .",
    "we observe that the electric forces computed by the ap - cloud method are more accurate and smoother compared to even the traditional pic .",
    "but the oscillatory deviation of forces in pic from the correct direction does not cause accumulation of the total error due to conservative properties of pic .",
    "the trajectories of the particle obtained by both methods are close .",
    "the test provides an additional assurance that artificial images are not present in the ap - cloud method .",
    "we have developed an adaptive particle - in - cloud ( ap - cloud ) method that replaces the cartesian grid in the traditional pic with adaptive computational nodes .",
    "adaptive particle placement balances the errors of the differential operator discretization and the source computation ( analogous to the error of the monte carlo integration ) to minimize the total error .",
    "ap - cloud uses gfd based on weighted least squares ( wls ) approximations on a stencil of irregularly placed nodes .",
    "the framework includes interpolation , least squares approximation , and numerical differentiation capable of high order convergence .",
    "the adaptive nature of ap - cloud gives it significant advantages over the traditional pic for non - uniform distributions of particles and complex boundaries .",
    "it achieves significantly better accuracy in the gradient of the potential compared to the traditional pic for the problem of particle beam with halo .",
    "the method is independent of the geometric shape of the computational domain , and can achieve highly accurate solutions in geometrically complex domains .",
    "the optimal mesh size based on error - balance criterion gives ap - cloud a potential advantage over amr - pic in terms of accuracy , and specially designed tests showed that the ap - cloud method is free of artificial images and spurious forces typical for the original amr - pic without special mitigation techniques .",
    "another advantage of ap - cloud over amr - pic is the ease of implementation , as ap - cloud does not require special remapping routines between different meshes .",
    "our future work will focus on higher convergence rates of the method , performance optimization , parallel implementation using hybrid technologies , as well as applications to practical problems with non - uniform distribution of matter .",
    "a direct comparison of ap - cloud with amr - pic in terms of accuracy and efficiency will also be addressed in the future work .",
    "this work was supported in part by the u.s .",
    "department of energy , contract no .",
    "de - ac02 - 98ch10886 .    100    r.w .",
    "hockney , j.w .",
    "eastwood , computer simulation using particles , ( crc press , 1988 ) , 21 .",
    "h. johansen , p. colella , a cartesian grid embedding boundary method for poisson s equation on irregular domains , j comput phys , 1998 ( 147 ) , 60?85 .",
    "s. wang , r. samulyak , t. guo , an embedded boundary method for parabolic problems with interfaces and application to multi - material systems with phase transitions , acta mathematica scientia , 30b ( 2010 ) , no . 2 , 499 - 521 .",
    "vay , j - l . ,",
    "et al .  mesh refinement for particle - in - cell plasma simulations : applications to and benefits for heavy ion fusion . \"",
    "laser and particle beams 20.04 ( 2002 ) : 569 - 575 .",
    "vay , j - l . , et al .",
    " application of adaptive mesh refinement to particle - in - cell simulations of plasmas and beams . \"",
    "physics of plasmas ( 1994-present ) 11.5 ( 2004 ) : 2928 - 2934 .",
    "colella , phillip , and peter c. norgaard .",
    " controlling self - force errors at refinement boundaries for amr - pic .",
    "\" journal of computational physics 229.4 ( 2010 ) : 947 - 957 .",
    "onate , e. , et al .",
    " a finite point method in computational mechanics .",
    "applications to convective transport and fluid flow .",
    "\" international journal for numerical methods in engineering 39.22 ( 1996 ) : 3839 - 3866 .",
    "benito , j. j. , f. urena , and l. gavete .",
    " influence of several factors in the generalized finite difference method . \" applied mathematical modelling 25.12 ( 2001 ) : 1039 - 1053 .",
    "benito , j. j. , et al .  an h - adaptive method in the generalized finite differences .",
    "\" computer methods in applied mechanics and engineering 192.5 ( 2003 ) : 735 - 759 .",
    "liszka , tadeusz , and janusz orkisz .  the finite difference method at arbitrary irregular grids and its application in applied mechanics . \"",
    "computers & structures 11.1 ( 1980 ) : 83 - 95 .",
    "golub , gene h. , and charles f. van loan , matrix computations , 4th edition , johns hopkins university press , 2012 .",
    "barbeiro , s. , j. a. ferreira , and r. d. grigorieff .",
    " supraconvergence of a finite difference scheme for solutions in hs ( 0 , l ) . \"",
    "i m a journal of numerical analysis 25.4 ( 2005 ) : 797 - 811 .",
    "zhou , kun , et al .",
    " data - parallel octrees for surface reconstruction .",
    "\" visualization and computer graphics , ieee transactions on 17.5 ( 2011 ) : 669 - 681 .    cottet , g - h . , and p - a . raviart .",
    "`` particle methods for the one - dimensional vlasov - poisson equations . ''",
    "siam journal on numerical analysis 21.1 ( 1984 ) : 52 - 76 .",
    "wang , bei , gregory h. miller , and phillip colella .",
    "`` a particle - in - cell method with adaptive phase - space remapping for kinetic plasmas . ''",
    "siam journal on scientific computing 33.6 ( 2011 ) : 3509 - 3537 .",
    "assume the interpolation kernel @xmath15 is symmetric , non - negative , bounded by 1 , integrable and normalized over a compact support .",
    "that is , @xmath148 for all @xmath149 , @xmath150 for @xmath151 for some @xmath63 , and @xmath152 .",
    "these properties hold for all commonly used charge assignment schemes , including the nearest grid point , cloud - in - cell , and triangular shaped cloud schemes without reshaping step . in the following subsections , we will analyze the errors in the three steps of pic , respectively .      to analyze the error in ( [ eq : density ] ) ,",
    "let us first define an average quantity at a grid point @xmath153 as @xmath154 then , @xmath155 where @xmath19 is analogous to the error in monte carlo integration of a continuous function , and @xmath156 is known as moment error or discretization error in step 1 , which depends on the interpolation kernel @xmath15 .        by the definition of variance , @xmath160 where @xmath161 is the estimation of @xmath6 from a single particle @xmath4 , and @xmath162=\\bar\\rho(\\mathbf{y}^j , h).\\ ] ]",
    "let @xmath163 then , @xmath164\\\\&=&\\int_{\\omega}\\tau^{2}(\\mathbf{y}^j,\\mathbf{x},h)\\rho(\\mathbf{x})\\mathbf{dx}.\\end{aligned}\\ ] ] consider the small neighborhood about @xmath9 of radius @xmath165 , i.e. , @xmath166 , so that @xmath167 in @xmath168 .",
    "then , @xmath169 note that @xmath170 and @xmath171 where @xmath172 is the volume of the unit ball in @xmath2 dimensions .",
    "assume @xmath8 is small enough , so that @xmath173 and @xmath174",
    ". then , @xmath175 and @xmath176 therefore , @xmath177 and @xmath178=\\sqrt{\\mbox{e}[|\\mathcal{e}_m|^2]-\\mbox{var}(|\\mathcal{e}_m|)}\\leq \\sqrt{\\mbox{e}[|\\mathcal{e}_m|^2]}=\\mathcal{o}\\left(\\sqrt{\\frac{\\rho(\\mathbf{y}^j)}{nh^d}}\\right).\\ ] ]    note that above bound for @xmath179}$ ] is asymptotically tight . to see this ,",
    "assume @xmath180 , and let @xmath181 .",
    "then , @xmath182 the volume of @xmath183 is @xmath184 , so @xmath185 is no smaller than @xmath186 , and @xmath179}$ ] is no smaller than @xmath187 .      the moment error in charge assignment scheme , @xmath156 , can be viewed as the error in a numerical quadrature rule . here",
    "we follow the approach taken in @xcite and @xcite .",
    "let @xmath188 , @xmath189 be the hessian matrix for @xmath6 at @xmath9 .",
    "the moment error is @xmath190 where the fifth equal sign is due to the symmetry of interpolation kernel .",
    "step 3 contains a numerical differentiation and a linear interpolation , both of which has second order accuracy .",
    "one problem is that numerical differentiation is unstable .",
    "generally , if @xmath12 is already polluted with a @xmath68th order error , then its gradient given by numerical differentiation has at most @xmath193th order accuracy , because of the @xmath8 factor in denominator . for finite difference scheme for elliptic equation",
    ", it has been proved that , nevertheless , if the solution is smooth enough , then both the solution and its gradient are second order convergent , even if the mesh is non - uniform , which is called supraconvergence  @xcite .",
    "more precisely , let @xmath194 be the interpolation operator from grid function to piecewise linear function , @xmath195 be the restriction operator from continuous function to grid function , @xmath196 be the exact solution of poisson equation , @xmath197 be the numerical solution , then we have @xmath198 where @xmath199 is the maximal mesh size .",
    "thus we claim the discretization error for @xmath13 is also second order ."
  ],
  "abstract_text": [
    "<S> we propose a new adaptive particle - in - cloud ( ap - cloud ) method for obtaining optimal numerical solutions to the vlasov - poisson equation . unlike the traditional particle - in - cell ( pic ) method , which is commonly used for solving this problem , </S>",
    "<S> the ap - cloud adaptively selects computational nodes or particles to deliver higher accuracy and efficiency when the particle distribution is highly non - uniform . </S>",
    "<S> unlike other adaptive techniques for pic , our method balances the errors in pde discretization and monte carlo integration , and discretizes the differential operators using a generalized finite difference ( gfd ) method based on a weighted least square formulation . as a result , </S>",
    "<S> ap - cloud is independent of the geometric shapes of computational domains and is free of artificial parameters . efficient and robust </S>",
    "<S> implementation is achieved through an octree data structure with 2:1 balance . </S>",
    "<S> we analyze the accuracy and convergence order of ap - cloud theoretically , and verify the method using an electrostatic problem of a particle beam with halo . </S>",
    "<S> simulation results show that the ap - cloud method is substantially more accurate and faster than the traditional pic , and it is free of artificial forces that are typical for some adaptive pic techniques .    </S>",
    "<S> particle method , generalized finite difference , pic , amr - pic    65m06 , 70f99 , 76t10 </S>"
  ]
}