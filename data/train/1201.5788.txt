{
  "article_text": [
    "in order to understand complex , multi - variate simulations of phenomena , it has proven to be useful to be able to observe the shape , symmetries and asymmetries of higher dimensional mathematical models which emerge from these studies .",
    "this capability allows the observer insights into the nature of complex phenomena such as : viewing relativistic spacetime interactions ; preventing collision in the design of a robotic arm or fine tuning a robotic assembly line ; exploring intersecting brane models in physics ; discovering unexpected elegant symmetries in physical laws .",
    "describing and viewing extra - dimensional objects on the computer has been a thorny problem due to a lack of an elegant extensible data structure to represent higher dimensional models as well as the processing requirements of an interactive solution .",
    "techniques for viewing four- and higher - dimensional objects have been proposed and in some cases implemented by noll@xcite as early as 1965 , and later beginning in the 1990 s by hollasch@xcite , hanson@xcite , banks@xcite , and in the domain of visualizing four - dimensional spacetime by weiskopf@xcite .",
    "presented here are a fundamental data structure and attendant library of tools to represent and display a 4d model as a four - manifold with boundary by describing a mesh of its 3d bounding simplices .",
    "the toolkit as described and demonstrated here can both generate the bounding three - simplices - simplex : * a convex hull of ( m+1 ) independent points in an @xmath0-dimensional ( @xmath0d ) euclidean space @xmath1 ( where @xmath2 ) .",
    "a triangle is a two - simplex , while a tetrahedron is a three - simplex .",
    "a simplex need not be regular .",
    "] bordering the mathematical 4d model at a specified level - of - detail , and allow the user to interactively explore this model in real - time by selecting 3d projections and intersections while viewing the resultant 3d object just as does an architect , engineer , or video gamer .",
    "while the vector library was implemented in seven euclidean dimensions , only four dimensions are described and demonstrated here . each 4d object",
    "is represented by its bounding three - manifold which is a closed surface approximated by a pure simplicial 3-complex - complex * - a set of aligned non - intersecting simplices of dimension @xmath3 in @xmath0-space , where @xmath4 . ] in 4-space .",
    "two - torus in 4d and projected obliquely onto a three - flat ]    this paper describes a technology to reveal the embedded 3d structures composed of 2-manifolds within a 3-manifold in 4-space generated by intersecting a 3-flat with the model s pure simplicial 3-complex , and displaying the resultant closed 2-manifold as a conventional bounded 3d object in 3-space via the opengl library .",
    "the vertex database and vector math module were implemented in 7d to support a future application that will require 7-space .",
    "the impact on performance of raising the matrices from 4x4 to 7x7 was deemed to be acceptable for a proof - of - concept .",
    "this decision facilitated the inclusion of a sample projection from 5d of a 4-flat intersecting a manifold with extent in 5 dimensions as described in section  [ sec : resu ] and depicted in figure  [ fig:5dobject ] .",
    "a 4-manifold with boundary model is created and described by its bounding closed 3-manifold in the same manner as a bounded 3-manifold is described by its bounding 2-manifold .",
    "a sphere enclosed by its surface of bounding triangles is an example of the latter .",
    "the bounding closed 3-manifold is a pure simplicial 3-complex of adjacent tetrahedra sharing faces , edges , and vertices .",
    "the data structure for each tetrahedron is a list of four vertices .",
    "since all vertices are shared among the 4 adjacent tetrahedra in the 3-complex , the vertices are merged into one indexed vertex array .",
    "the tetrahedron data structure element contains a list of the four indices into this vertex array .",
    "a 3-flat - space @xmath5 , where @xmath6 hyperplane equation is manipulated interactively via a 3d icon in a 4d gui .",
    "the resulting 3-flat of infinite extent , as depicted by the shaded rectilinear grid in the right column of figure  [ fig:2torusproj ] , is then intersected with the edges of each tetrahedron , thus extracting a triangle ( or a pair of coplanar triangles ) which can be displayed as a surface element of the closed 2-manifold that defines the extracted 3d object .",
    "an animated video of the gridded icon moving through the depicted 4d object and the resulting 3d projection can be found online.@xcite    this extracted 3d object can then be passed on to the opengl library and the usual flat or smooth shading effects implemented .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ * _ pseudo - code of sample data structures _ *    @xmath7=@xmath7=@xmath7=@xmath7=@xmath7=@xmath7=@xmath7=@xmath8=@xmath9 + @xmath10@xmath11 + @xmath12@xmath13@xmath14 + @xmath15 +   + @xmath16@xmath17 + @xmath18@xmath19@xmath20 + @xmath21@xmath22@xmath23 + @xmath24@xmath25@xmath26-@xmath27 + @xmath15 +   + @xmath28@xmath29 + @xmath30 + @xmath31@xmath32 + @xmath15 +   + @xmath33@xmath34 + @xmath35 + @xmath36;$]@xmath37 + @xmath15 +   + @xmath38 + @xmath39@xmath40@xmath41 + @xmath39@xmath42@xmath43 + @xmath39@xmath44@xmath45 + @xmath46@xmath47@xmath48 + @xmath49@xmath50@xmath51 + @xmath15 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _      as shown in the pseudo - code description of the data structure in figure  [ fig : codeobject ] , the 3-manifold is a list of tetrahedra and their vertices .",
    "since the 4 vertices of adjacent 3-simplices are shared , only approximately one vertex per simplex need be stored in the 3-manifold s data set .",
    "the number of simplices required to describe an @xmath3-manifold increases exponentially with the dimension @xmath3 . thus the data structure and computational complexity also increase exponentially with the manifold s",
    "dimensionality @xmath3 .",
    "the object - generator projects the user - specified 4d model s bounding closed pure simplicial 3-complex onto the 3-sphere enclosing the origin of the world s 4-space at a user specified radius .",
    "for example , a 4d hyper - torus can be displayed at an arbitrary scale . a balanced binary search tree ( bbst ) algorithm merges proximate vertices to reduce storage and subsequent computational complexity .",
    "a snippet of code for the generation of a three - torus is provided in appendix  [ sec : objectgenerator ] and is described as follows .",
    "the make3torus ( ) method iteratively computes the hyper - spherical coordinates of the projected position of the cube onto the three - sphere .",
    "the threetorusxyzw ( ) method converts to rectilinear components , and puttetras ( ) tessellates the cube s eight vertices into six tetrahedra .",
    "the decomposition of a cube into six tetrahedra is described by black.@xcite the verticesarray.putvert ( ) method in puttetra ( ) builds the bbst lexically from the components of the vertices .",
    "the resulting vertices and tetrahedra list are output to an ascii text file .    a 4d sphere sliced eight times along the w axis by a 3d hyperplane . ]      the user can manipulate the grid - like 3d icon as shown in figure  [ fig:2torusproj ] via a conventional `` click - and - drag '' gui to position and orient the 3-flat in 4-space resulting in a user - defined 3-flat equation .",
    "the gui description is beyond the scope of this paper .",
    "[ [ intersection ] ] intersection + + + + + + + + + + + +    as noted above , the 3-flat via its equation is intersected with each tetrahedron .",
    "the structure of the 3-manifold in 4d will be visualized as a sequence of 2d surfaces .",
    "so ideally we would intersect the 3-flat with this 3-manifold and get a 2d surface . by moving the 3-flat",
    "we can get different slices of this 3 manifold .",
    "but since this 3-manifold we are considering , is a simplicial 3-complex , it consists of linear simplices of known face , edge , and vertex connections between these 3-simplices . using this information ,",
    "the intersection operation can be simplified to just performing the intersection of the edges of the 3-simplices with the 3-flat , and connecting these intersection points according to the connectivity of their parent simplices to get a 2d mesh .",
    "the 2d mesh is then rendered via opengl .",
    "a discussion of the development of the plane equation in 4d can be found in hanson@xcite or chu & hanson@xcite .",
    "the intersection is simplified to a solution of the 3-flat hyperplane equation with the line equation of each edge of the tetrahedron .",
    "the resulting 3 or 4 vertices define one or two triangles that are one face of the bounding 2-manifold of the new 3d object .",
    "this new object is then rendered using opengl .",
    "a snippet of code for viewing the 3d bounds of a 4d object is provided in appendix  [ sec : objectviewer ] and is described as follows .",
    "the list of vertices and enclosing tetrahedra with indices into the vertex list are input from the ascii text file described above .",
    "a codimension 3 of 4 hyperplane equation is generated from the user s manipulation of the mouse and keyboard to position and orient the 3-flat icon as a 2d or 3d rectilinear grid depending on its 4d to 3d projection .",
    "] within the multi - view projection of the 4d object s bounding manifold , as shown in figure  [ fig:2torusproj ] .    following the code in appendix  [ sec : objectviewer ] from bottom to top ,",
    "clipscene ( ) selects each object type data element in the scene linked - list and passes it to clipobject ( ) where the object type is determined . the clipndxtet ( ) method is used to clip the six edges of the tetrahedron via islinein3flat ( ) and xsctlineto3flat ( )",
    ". since the 3-flat is a 3d hyperplane of infinite extent , ignoring degenerate cases , three or four coplanar vertices will be intersected by the 3-flat .",
    "three vertices form a triangle , while four vertices can be tesselated into two coplanar adjacent triangles as shown by _ case 3 : _ and _ case 4 : _ , respectively , in the code snippet .",
    "these vertices , now internal to the clipping 3d hyperplane s 3-space , are thus 3d vertices describing a 3d object s boundary .",
    "the resultant triangles as described by their 3d vertices are inserted into a new scene linked - list and handed off to the opengl library for interactive display .",
    "[ [ projection ] ] projection + + + + + + + + + +    a user - specified 4-space component is discarded and a 3d object is composed of the remaining 3 components .",
    "the 3d object is derotated to the 3-flat view screen , and the object s resultant 3d vertices are handed to opengl for 3d display.@xcite     a 4d torus sliced eight times along the w - axis by a 3d hyperplane ]",
    "these examples have been selected to illustrate the capabilities of the described method .",
    "figure  [ fig:4sphereslicew ] shows eight frames from an animation of the 3-flat progressing along the @xmath52-axis of a 4d three - sphere . the radius of the resultant two - sphere increases up to the maximum radius of the three - sphere and then decreases .",
    "an animated video of this sequence can be found online@xcite .",
    "figure  [ fig:4torusslicew03 ] shows eight frames from a more interesting animation of the 3-flat progressing along the @xmath52-axis of a three - torus which was defined to be @xmath53 as mapped in appendix  [ sec : objectgenerator ] . in this case ,",
    "dimensional reduction reveals hidden 3d structure and symmetry within the 3-torus .",
    "as the 3-flat progresses along the @xmath52-axis , the revealed object transforms from genus zero , to genus one , to genus two and back .",
    "some interesting symmetries can be observed in the animation sequences that can be found online@xcite .     a 3-manifold spanning 5-space depicted in twelve 3d viewports ]    as shown in figure  [ fig:5dobject ] , the algorithm can be extended to include higher dimensional objects . shown here",
    "is a 4d three - manifold homeomorphic to a three - sphere that has been extruded along the @xmath54-axis to yield an object spanning five dimensions . as suggested by figure  [ fig:5dobject ] ,",
    "the algorithm lends itself to the creation and exploration of an interactive minkowski spacetime diagram in four dimensions or more spatial or temporal dimensions .",
    "a complex three - manifold in euclidean four - space can be interactively explored in real - time on a desktop computer .",
    "while only two four - dimensional objects were demonstrated here , the algorithm and implementation support higher dimensional objects as is shown in figure  [ fig:5dobject ] . the data structure and algorithm",
    "are designed such that they can be extended to allow visualization of objects of yet greater spatial dimensionality .",
    "the 5d example suggests that twice the number of 2d viewports are required for each additional dimension displayed , depending on the art of the developer . while exploring the 4d objects",
    "is interactive on the author s desktop , the interactivity of the 5d implementation can be described at best as near - realtime .",
    "since the nature of the algorithm will allow for a parallel implementation on contemporary multi - gpu devices , such implementation will likely address the 5d performance issue .",
    "* * acknowledgments.**the author would like to thank the following individuals for their contributions used in this paper : dr .",
    "richard palais for his three - torus definition ; dr james arvo for his toytracer raytrace code ; digital choreographics and the edutech foundation for their computer hardware and infrastructure .",
    "the data structures used in the following pseudo - code are defined in figure  [ fig : codeobject ] .",
    "void puttetra ( vec7 vtx0 , vec7 vtx1 , vec7 vtx2 , vec7 vtx3 , vec7 vvec , vec7 ovec ) {      int ndxv = verticesarray.putvert ( vvec ) ,     ndxo = verticesarray.putvert ( ovec ) ;      int ndx0 = verticesarray.putvert ( vtx0 ) ,     ndx1 = verticesarray.putvert ( vtx1 ) ,          ndx2 = verticesarray.putvert ( vtx2 ) ,     ndx3 = verticesarray.putvert ( vtx3 ) ;      printf(\"itetrahedra % d,%d,%d,%d,%d,%d\\n \" ,    ndx0 , ndx1 , ndx2 , ndx3 , ndxv , ndxo ) ;      putcolor ( l_color , l_color ) ; } //",
    "puttetra    //",
    "output three adjacent 3d tetrahedra to form a prism ( extruded triangle ) . //",
    "prism knows that v0->v3 , v1->v4 , v2->v5 are velocity vectors for the vertices void putprism ( vec7 velocity , vec7 v0 , vec7 v1 , vec7 v2 , vec7 v3 , vec7 v4 , vec7 v5 ) {      puttetra ( v0 , v1 , v2 , v3 , velocity , vec7 ( ) ) ;    // prism 1 , tet 1      puttetra ( v1 , v2 , v3 , v4 , velocity , vec7 ( ) ) ;    //",
    "prism 1 , tet 2      puttetra ( v2 , v3 , v4 , v5 , velocity , vec7 ( ) ) ;    //",
    "prism 1 , tet 3 } //",
    "putprism    //",
    "output two adjacent 3d prisms to form a cube void puttetras ( vec7 velocity , vec7 v0 , vec7 v1 , vec7 v2 , vec7 v3 ,                                 vec7 v4 , vec7 v5 , vec7 v6 , vec7 v7 ) {      putprism ( velocity , v0 , v1 , v2 , v4 , v5 , v6 ) ;     // prism 1      putprism ( velocity , v1 , v3 , v2 , v5 , v7 , v6 ) ;     // prism 2 } //",
    "puttetras ....      //   compute the 5d components of the 7d vector vec7 threetorusxyzw ( double phi , double psi , double theta ,                       double radius = 5.0 , double tube = 2.0 , double depth=1.0 ) {          return vec7 ( 0.0 ,                      ( radius + ( tube + depth * cos(phi ) ) * cos(psi ) ) * cos(theta ) ,                      ( radius + ( tube + depth * cos(phi ) ) * cos(psi ) ) * sin(theta ) ,                                ( tube + depth * cos(phi ) ) * sin(psi ) ,                                        depth * sin(phi )                      ) ; } //",
    "threetorusxyzw    //",
    "generate a 3-torus in 7-space .",
    "rotate about a hypersphere center make3torus(double deltaang , double radius = 5.0 , double tube = 2.0 , double depth=1.0 ) {      double phi0 = 0.0 ;      for ( phi = deltaang ; phi<=2*pi ; phi + = deltaang )      {          double psi0 = 0.0 ;          for ( psi = deltaang ; psi < = 2*pi ; psi+=deltaang )          {              double theta0 = 0.0 ;              for ( theta = deltaang ; theta<=2*pi ; theta",
    "+ = deltaang )              {                    oldrow0 = threetorusxyzw ( phi0 , psi0 , theta0 , radius , tube , depth ) ;                  oldrow1 = threetorusxyzw ( phi0 , psi ,   theta0 , radius , tube , depth ) ;                  oldrow2 = threetorusxyzw ( phi0 , psi0 , theta ,   radius , tube , depth ) ;                  oldrow3 = threetorusxyzw ( phi0 , psi ,   theta ,   radius , tube , depth ) ;                  newrow0 = threetorusxyzw ( phi ,   psi0 , theta0 , radius , tube , depth ) ;                  newrow1 = threetorusxyzw ( phi ,   psi ,   theta0 , radius , tube , depth ) ;                  newrow2 = threetorusxyzw ( phi ,   psi0 , theta ,   radius , tube , depth ) ;                  newrow3 = threetorusxyzw ( phi ,   psi ,   theta ,   radius , tube , depth ) ;                    puttetras(velocity , oldrow0 , oldrow1 , oldrow2 , oldrow3 ,                                          newrow0 , newrow1 , newrow2 , newrow3 ) ;                  theta0 = theta ;              }              psi0 = psi ;          }          phi0 = phi ;      } // for",
    "//   list sorted vertices vertices :      verticesarray.output ( ) ; } //",
    "make3torus ....",
    "int islinein3flat(slice3d & hyperbrane , vec7",
    "la , vec7 lb , vec7 * rslt ) {      vec7 col5n       = vec7(1.0 , la.t , la.x , la.y , la.z ) ;      double n         = hyperbrane.cofactors * col5n ;      vec7 vec         = lb - la ;      vec7 col5d       = vec7(0.0 , vec.t , vec.x , vec.y , vec.z ) ;      double d         = hyperbrane.cofactors * col5d ;        if ( real_near0(d ) )    {          if ( bf02 & & ! !",
    "real_near0(n ) )         return st_in3flat_all ;          else                                 return st_in3flat_none ;      }      double s",
    "= - n / d ;      * rslt = la + s*vec ;      return small_range ( s)?st_in3flat_xsct                            : st_in3flat_none ; } //",
    "islinein3flat            int      in3flat = islinein3flata (   hyperbrane , vtx0 , vtx1 , & q0 )      switch(in3flat ) {          case st_in3flat_xsct :    // add vertex to segment list                                  iq0 = slicedarray.putvec ( q0 ) ;                                  return iq0 ;          case st_in3flat_all :     // mark this segment as trivially in                                  return 0 ;          default :                 // no intersection          case st_in3flat_none :                                  break ;      }      return -1 ; } // xsctlineto3flat    object * clipndxtet ( slice3d & brane , itetrahedra * itet ) {      object * obj = null ,             * next = null ;      int j , rc[6 ] , ivert[6][2 ] , iv[6 ] ;      / * a * / ivert[0][0 ] = itet->ivert[0 ] ;    ivert[0][1 ] = itet->ivert[1 ] ;      / * b * / ivert[1][0 ] = itet->ivert[0 ] ;    ivert[1][1 ] = itet->ivert[2 ] ;      / * c * / ivert[2][0 ] = itet->ivert[0 ] ;    ivert[2][1 ] = itet->ivert[3 ] ;      / * d * / ivert[3][0 ] = itet->ivert[1 ] ;    ivert[3][1 ] = itet->ivert[2 ] ;      / * e * / ivert[4][0 ] = itet->ivert[1 ] ;    ivert[4][1 ] = itet->ivert[3 ] ;      / * g * / ivert[5][0 ] = itet->ivert[2 ] ;    ivert[5][1 ] = itet->ivert[3 ] ;                        //   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   //              //",
    "is it a triangle ?              //",
    "this is only a test to draw triangles              //   since the vertices are unordered ! ! ! !              //",
    "this must be coordinated with the itetrahedra              //",
    "vertex generation code ( mkhyper.cpp ) .              //",
    "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   //",
    "switch(icnt ) {                   // number of edges : should be 3 or 4 !",
    "case 3 :      obj = new itriangle ( & slicedarray , iv[0 ] , iv[1 ] , iv[2 ] ) ;                  if(bf03 ) obj->material.diffuse = seg_purp ;                  break ;      case 4 :      obj = new itriangle ( & slicedarray , iv[0 ] , iv[1 ] , iv[2 ] ) ;                  if(bf03 ) obj->material.diffuse = seg_blu ;                  obj->next = new itriangle ( & slicedarray , iv[1 ] , iv[2 ] , iv[3 ] ) ;                  if(bf03 ) obj->next->material.diffuse = seg_grn ;                  break ;        case 0 :      obj = null ;                  break ;      case 1 :      obj = new iedge ( & slicedarray , iv[0 ] , iv[0 ] ) ;                  if(bf03 ) obj->material.diffuse = seg_mint ;                  break ;      case 2 :      obj = new iedge ( & slicedarray , iv[0 ] , iv[1 ] ) ;                  if(bf03 ) obj->material.diffuse = seg_mint ;                  break ;      case 5 :      obj = new ipolygon ( & slicedarray , iv[0 ] , iv[1 ] , iv[2 ] , iv[3 ] , iv[4 ] ) ;                  if(bf03 ) obj->material.diffuse = seg_red ;                  //",
    "i do n't think this can happen :                  break ;      }      return obj ; } //",
    "clipndxtet     object * clipobject ( object * object ) {      extern object * clipndxtet ( slice3d & brane , itetrahedra * itet ) ;      vec7         hyperpoint   = vec7(slicerange.t.min ,                                     slicerange.x.min , slicerange.y.min , slicerange.z.min ,                                     slicerange.w.min , slicerange.v.min , slicerange.u.min ) ;      extern vecarray vectorarray , slicedarray ;      vecarray * ptrarray = & slicedarray ;              switch ( object->objtype )            {            default :                printf(\"clipobject : invalid objtype ( % d ) : ' % s'\\n \" ,                              object->objtype , sname[object->objtype ] ) ;                break ;          scene * clipscene ( scene & pscene ) {        extern vecarray vectorarray ;        extern vecarray slicedarray ;        extern vecarray normalarray ;        object         * obj = null ;        scene          * newscene    = new scene ( & pscene , & slicedarray , &",
    "normalarray ) ;        object         * newobject   = null ,                      * prvobject   = null ,                      * nextobj ;",
    "//     got at least one valid object , carry on        oindex++ ;        for ( obj = nextobj->next ; obj ! = null ; obj = obj->next )        {            oindex++ ;      //",
    "printf(\"%3d % s\\n \" , oindex++ , sname[obj->type ] ) ;            prvobject = newobject ;            newobject = clipobject ( obj ) ;            //     skip this object",
    "if a null comes back            if ( newobject ) {                prvobject->next = newobject ;                //     itet could return many faces                while(newobject->next )     newobject = newobject->next ;            } else {                newobject        = prvobject ;            }        } // for      return newscene ; }",
    "// clipscene ....                david banks .",
    "interactive manipulation and display of surfaces in four dimensions . in _",
    "92 : proceedings of the 1992 symposium on interactive 3d graphics _ , pages 197207 , new york , ny , usa , 1992 .",
    "daniel weiskopf , marc borchers , thomas ertl , martin falk , oliver fechtig , regine frank , frank grave , andreas king , ute kraus , thomas muller , hans - peter nollert , isabel  rica mendez , hanns ruder , corvin zahn , michael zatloukal , tobias schafhitzel , and sonja schar .",
    "visualization in the einstein year 2005 : a case study on explanatory and illustrative visualization of relativity and astrophysics .",
    ", 0:74 , 2005 ."
  ],
  "abstract_text": [
    "<S> a data structure and toolkit are presented here that allow for the description and manipulation of mathematical models of three - manifolds and their interactive display from multiple viewpoints via the opengl 3d graphics package . </S>",
    "<S> the data structure and vector math package can be extended to support an arbitrary number of euclidean spatial dimensions .    a model in 4-space </S>",
    "<S> is described by its bounding pure simplicial 3-complex . by intersecting a 3-flat with this 3-manifold </S>",
    "<S> , the algorithm will extract the requested closed pure simplicial 2-complex surface enclosing the desired 3d slice . </S>",
    "<S> the user can interactively rotate , pan , zoom , and shade arbitrary 3d solid or wire - frame views of the revealed 3d object created by intersection , thus exploring both expected and unexpected symmetries or asymmetries in the world of 3-manifolds in 4-space . </S>"
  ]
}