{
  "article_text": [
    "diffusion layers are a central part of most block cipher constructions .",
    "there are many options when designing a diffusion layer , but linear diffusion is usually a good choice as it can be efficient and is easy to analyze .",
    "the quality of a linear diffusion layer is connected to its _ branch number _",
    "@xcite : the minimum over all possible nonzero inputs of the sum of the hamming weights of the input and the corresponding output of this diffusion layer .",
    "a high branch number implies that changing a single bit of the input will change the output a lot , which is exactly what one expects from a good diffusion layer . before going into more details on how to build linear diffusion with a high branch number ,",
    "let us recall some elements of coding theory .",
    "a linear code @xmath0 of dimension @xmath1 and length @xmath2 over @xmath3 ( denoted as an @xmath4_q$ ] code ) is a vectorial subspace of dimension @xmath1 of @xmath5 .",
    "elements of @xmath0 are called code words .",
    "the minimal distance @xmath6 of a code is the minimum over all nonzero code words @xmath7 of the hamming weight of @xmath8 .",
    "a @xmath4_q$ ] code of minimal distance @xmath6 will be denoted as an @xmath9_q$ ] code .",
    "a generator matrix @xmath10 of a code is any @xmath11 matrix over @xmath3 formed by a basis of the vectorial subspace @xmath0 .",
    "we say a generator matrix is in systematic form when it contains ( usually on the left - most positions ) the @xmath12 identity matrix @xmath13 .",
    "the non - systematic part ( or redundancy part ) of @xmath10 is the @xmath14 matrix next to this identity matrix .    now , suppose a linear diffusion layer of a block cipher is defined by an invertible matrix @xmath15 of size @xmath12 over @xmath3 , so that an input @xmath16 yields an output @xmath17 with @xmath18 .",
    "then , the @xmath19 generator matrix @xmath20 having @xmath15 as its non - systematic part ( the matrix defined as the concatenation of the @xmath12 identity matrix @xmath13 and of @xmath15 , as @xmath21 $ ] ) generates a @xmath22_q$ ] code @xmath23 whose minimal distance is exactly the branch number of @xmath15 . indeed , a code word @xmath24 in @xmath23 is the concatenation of an input @xmath25 to the diffusion layer and the corresponding output @xmath26 .",
    "so the hamming weight of every code word is the sum of the hamming weights of an input and its output",
    ".    optimal linear diffusion can thus be obtained by using codes with the largest possible minimal distance , namely maximum distance separable ( mds ) codes .",
    "a @xmath4_q$ ] code is called mds if its minimal distance is @xmath27 . by extension",
    ", we will say that a matrix @xmath15 is mds when its concatenation with the identity matrix yields a generating matrix @xmath20 of an mds code @xmath23 . in the context of diffusion where @xmath28 being",
    "mds means that @xmath29 : changing a single element in the input of the diffusion layer will change all the elements in its output .",
    "we also recall the mds conjecture : if there exists an @xmath4_q$ ] mds code , meaning an mds code of length @xmath2 and dimension @xmath1 over @xmath3 , then @xmath30 , except for particular cases which are not relevant to our context . all along",
    "this article we will assume that this conjecture holds  @xcite .",
    "[ [ note - on - vector - representation . ] ] note on vector representation .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in coding theory , vectors are usually represented as rows ( with @xmath26 ) , as we have done for the moment . in cryptography , however , they are more often represented as columns ( with @xmath31 ) .",
    "luckily , the transposed of an mds matrix is also mds , so if @xmath20 defines an mds code , both @xmath15 and @xmath32 can be used as mds diffusion matrices . in the rest of the article we will use the column representation , which people used to the aes and the mixcolumns operation are more familiar with : the diffusion layer defined by a matrix @xmath15 computes @xmath33 .",
    "this way , the branch number of @xmath15 is the minimal distance of the code generated by @xmath34 $ ] .",
    "however , in order to avoid matrix transpositions , we will rather check wether @xmath35 $ ] generates an mds code or not .",
    "mds matrices offer optimal linear diffusion , but in general , they do not allow for a very compact description .",
    "indeed , the non - systematic part @xmath15 of an mds generator matrix can not contain any 0 element of an mds generator matrix contained a 0 , then the line of @xmath20 containing this zero would have hamming weight @xmath36 , which is in contradiction with the minimal distance of the code . more generally , for an mds code @xmath23 , for any @xmath37 all the @xmath38 minors of @xmath15 must be non - zero . ] .",
    "these matrices can never be sparse and applying such a matrix to its input requires a full matrix multiplication for the diffusion .",
    "several different techniques have been studied to obtain _ simpler _ mds matrices , a well known example being circulant matrices ( or modifications of circulant matrices ) as used in the aes  @xcite or fox  @xcite .",
    "recently a new construction has been proposed : the so - called _ recursive _ mds matrices , that were for example used in photon  @xcite or led  @xcite .",
    "these matrices have the property that they can be expressed as a power of a companion matrix @xmath39 .",
    "for example , in photon , using the same decimal representation of elements of @xmath40 as in  @xcite :    @xmath41    the advantage of such matrices is that they are particularly well suited for lightweight implementations : the diffusion layer can be implemented as a linear feedback shift register that is clocked 4 times ( or more generally @xmath1 times ) , using a very small number of gates in hardware implementations , or a very small amount of memory for software .",
    "the inverse of the diffusion layer also benefits from a similar structure , see eq .   for a particular case .      in the next section",
    ", we will present previous methods that have been used to find recursive mds matrices .",
    "then , in section  [ sec.bch ] , we will introduce bch codes and shortened bch codes , show that they too can yield recursive mds matrices , and give a direct construction of such matrices . in section  [ sec.algo ] we will then describe an algorithm to explore all bch codes and the mds diffusion layers they yield for given parameters",
    ". we will conclude with a few experimental results .",
    "exhaustive search for recursive mds matrices can be quite straightforward :    * pick some parameters : the matrix size @xmath1 and the field size @xmath42 , * loop through all companion matrices @xmath39 of size @xmath1 over @xmath3 , * for each @xmath39 , computes its @xmath1-th power and check if it is mds .",
    "however , this technique is very expensive as there are many companion matrices ( @xmath43 , which could be @xmath44 for an 128-bit cipher ) and checking if a matrix is mds is also expensive ( the number of minors to compute is exponential in @xmath1 ) .",
    "also , it does not specially explore the most efficient matrices first . in the photon example",
    ", the matrix uses very sparse coefficients ( the field elements represented by 1 , 2 and 4 ) to make the implementation of their operations on inputs even more efficient .",
    "exhaustive search should focus on such matrices .",
    "following this idea , sajadieh _ et al . _",
    "@xcite proposed to split the search in two .",
    "their companion matrices are symbolic matrices @xmath45 which have coefficients in the polynomial ring @xmath46 $ ] where @xmath47 is an indeterminate , which will be substituted later by some @xmath48-linear operator @xmath49 of @xmath3 . then their search space is reduced to symbolic companion matrices @xmath45",
    "whose coefficients are small degree polynomials in @xmath47 ( small degree polynomials will always yield a rather efficient matrix ) .",
    "once @xmath45 is raised to the power @xmath1 , to get @xmath50 , the matrix @xmath51 will give an mds matrix @xmath52 when evaluated at a particular @xmath49 , if for all @xmath37 , all its @xmath38 minors evaluated at @xmath49 are invertible matrices ( non - zero is enough in a field , but now the coefficients are @xmath48-linear operators ) . indeed , for a symbolic matrix @xmath51 , the minors are polynomials in @xmath47 , and their evaluation at a particular linear operator @xmath49 needs to be invertible matrices .    this way , for each matrix @xmath45 explored during the search , the minors of all sizes of @xmath50 are computed : some matrices have minors equal to the null polynomial and",
    "can never be made mds when @xmath47 is substituted by a linear operator @xmath49 , for the others this gives ( many ) algebraic polynomials in @xmath47 which must not vanish when evaluated at @xmath49 , for the @xmath1-th power @xmath52 to be mds .",
    "then , the second phase of the search of sajadieh _",
    "et al._is to look for efficient operators @xmath49 such that all the above minors are non zero when evaluated at @xmath49 .",
    "the advantage of this technique is that it finds specially efficient recursive mds matrices , but the computations of the minors of symbolic matrices can be pretty heavy , because of the growth of the degree of the intermediate polynomials involved . in the case of photon",
    ", the matrix could be found as @xmath53 where @xmath49 is the multiplication by the field element represented by 2 .",
    "continuing this idea and focusing on hardware implementation , wu , wang , and wu  @xcite were able to find recursive mds matrices using an impressively small number of xor gates .",
    "they used a technique similar to sajadieh  _ et al .",
    "_ , first searching for symbolic matrices with a list of polynomials having to be invertible when evaluated in @xmath49 , then finding an @xmath48-linear operator @xmath49 using a single xor operation and with a minimal polynomial not among the list of polynomials that have to be invertible .",
    "then , looking for larger recursive mds matrices , augot and finiasz  @xcite proposed to get rid of the expensive symbolic computations involved in this technique by choosing the minimal polynomial of @xmath49 _ before _ the search of companion matrices @xmath45 .",
    "then , all computation can be done in a finite field ( modulo the chosen minimal polynomial of @xmath49 ) , making them much faster .",
    "of course , assuming the mds conjecture holds , the length of the code can not be larger than the size of the field plus one , so for an @xmath49 with irreducible minimal polynomial of degree @xmath54 , the field is of size @xmath55 , and @xmath1 must verify @xmath56 .",
    "larger mds matrices will require an operator @xmath49 with a higher degree minimal polynomial .",
    "also , in the case where the bound given by the mds conjecture is almost met ( when @xmath57 ) , augot and finiasz noted that all companion matrices found had some kind of symmetry : if the @xmath1-th power of @xmath58 is mds , then @xmath59 for all @xmath60",
    ".      one of the _ symmetric _ mds matrices found by augot and finiasz  @xcite for @xmath61 and @xmath62 is @xmath63 with @xmath64 . as we will see later",
    ", there is a strong link between companion matrices and the associated polynomial , here @xmath65 in this example , this polynomial factors into terms of degree two : @xmath66 meaning that @xmath67 is split in a degree-2 extension of @xmath68 , the field @xmath40 .",
    "if we now consider @xmath67 in @xmath69 $ ] , which we can , since @xmath68 is a subfield of @xmath40 , and look for its roots in @xmath40 , we find that there are 8 roots in @xmath40 , which , for a certain primitive @xmath70-th root of unity @xmath71 , are @xmath72.\\ ] ] this indicates a strong connection with bch codes that we will now study .",
    "before jumping to bch codes , we must first note a few things that are true for any cyclic code and not only bch codes . for more details on the definition and properties of cyclic codes",
    ", the reader can refer to  @xcite .",
    "an @xmath4_q$ ] code is said to be cyclic if a cyclic shift of any element of the code remains in the code .",
    "for example , the code defined by the following generator matrix @xmath10 over @xmath48 is cyclic : @xmath73    a cyclic shift to the right of the last line of @xmath10 gives @xmath74 which is the sum of the first , third and last lines of @xmath10 , thus remains in the code : @xmath10 indeed generates a cyclic code .",
    "cyclic codes can also be defined in terms of polynomials : @xmath75 corresponds to @xmath76 and a cyclic shift to the right is a multiplication by @xmath47 modulo @xmath77 .",
    "this way , cyclic codes can be seen as ideals of @xmath46/(x^n-1)$ ] , meaning that each cyclic code @xmath0 can be defined by a generator polynomial @xmath78 such that @xmath79 and @xmath78 divides @xmath77 .",
    "then , the code defined by @xmath78 has dimension @xmath80 . in our example",
    ", @xmath81 , which divides @xmath82 , and the code is indeed of dimension 4 .",
    "any multiple of @xmath78 is in the code , so for any polynomial @xmath83 of degree less than @xmath2 , the polynomial @xmath84 is in the code .",
    "using this property with @xmath85 for @xmath86 $ ] , we obtain an interesting systematic form for any cyclic code generator matrix :    @xmath87    this form is exactly what we are looking for when searching for powers of companion matrices . indeed ,",
    "if we associate the companion matrix @xmath88 to the polynomial @xmath89 , then the successive powers of @xmath39 are ( continuing with our example where @xmath90 ) : @xmath91    to build recursive mds matrices we thus simply need to build mds cyclic codes with suitable parameters and their corresponding @xmath78 .    note that a multiplication by a companion matrix can also be expressed in terms of lfsr . initializing the lfsr of  [ fig.lfsr ] with a vector and clocking it once corresponds to the multiplication of this vector by @xmath39 . clocking it @xmath1 times corresponds to the multiplication by @xmath92 .",
    "we will continue using the matrix representation in the rest of the paper , but most results could also be expressed in terms of lfsr .    an lfsr corresponding to the companion matrix @xmath39 of polynomial @xmath93 .",
    "clocking it @xmath1 times is equivalent to applying @xmath94 to its internal state.,width=188 ]      in general , given a generator polynomial @xmath78 , computing the minimal distance of the associated cyclic code is a hard problem .",
    "for instance , the code generated by @xmath81 in the example of the previous section has minimal distance 3 , but even for such small examples it is not necessarily immediate to find the minimum distance .",
    "nonetheless , lower bounds exist for some specific constructions .",
    "this is the case for bch codes , as described for example in  @xcite .",
    "a bch code over @xmath3 is defined using an element @xmath95 in some extension @xmath96 of @xmath3 .",
    "first , pick integers @xmath97 and @xmath6 and take the @xmath98 consecutive powers @xmath99 of @xmath95 , then compute @xmath100 , where @xmath101 is the minimal polynomial of @xmath102 over @xmath3 .",
    "the cyclic code over @xmath3 of length @xmath103 defined by @xmath78 is called a _ bch code _ , it has dimension @xmath104 and has minimal distance at least @xmath6 .",
    "we write this as being an @xmath105_q$ ] code .",
    "for such a bch code to be mds , @xmath78 must have degree exactly @xmath106 ( for a cyclic code @xmath107 and for an mds code @xmath108 , so an mds bch code necessarily verifies @xmath109 ) .",
    "seeing that @xmath78 already has @xmath106 roots over @xmath96 , it can not have any other roots .",
    "this means that the powers @xmath110 , @xmath111 , must all be conjugates of each other .      when building diffusion layers , the input and output of the diffusion generally have the same size ( otherwise inversion might be a problem ) , so we need codes of length @xmath112 and dimension @xmath1 . in terms of bch codes , this translates into using @xmath1 consecutive powers of an element @xmath95 of order @xmath112 , and having @xmath78 of degree @xmath1 .",
    "of course , elements of even order do not exist in extensions of @xmath48 , so this is not possible . instead of using full length bch codes , we thus use _ shortened _ bch codes .    given a @xmath9_q$ ] code @xmath0 , and a set @xmath113 of @xmath114 indices @xmath115 , the shortened code @xmath116 of @xmath39 at indices from @xmath113 is the set of words from @xmath0 which are zero at positions @xmath117 , and whose zero coordinates are deleted , thus effectively shortening these words by @xmath114 positions .",
    "the shortened code @xmath116 has length @xmath118 , dimension @xmath119 and minimal distance @xmath120 .",
    "if @xmath0 is mds , then @xmath108 and @xmath116 will necessarily be an @xmath121_q$ ] mds code , as neither the dimension nor the minimal distance can increase without breaking the singleton bound  @xcite .",
    "we can thus look for @xmath122_q$ ] bch codes and shorten them on @xmath123 positions to obtain our mds codes .",
    "however , shortened bch codes are no longer cyclic , so the shortening has to be done in a way that conserves the recursive structure .",
    "this is easy to achieve by using the previous systematic representation and shortening on the last positions .",
    "starting from @xmath78 of degree @xmath1 , which divides @xmath124 , we get a generating matrix : @xmath125 shortening the code on the @xmath123 last positions will maintain the systematic form and simply remove the @xmath123 last lines to obtain : @xmath126 as said above , when @xmath10 generates an mds code , then @xmath127 also generates an mds code , and this is ( up to a permutation of the two @xmath12 blocks , that will not affect the mds property ) exactly what we are looking for : a recursive mds matrix defined by the companion matrix associated to the polynomial @xmath78 .      from this result , in the case where @xmath55 , we can deduce a direct construction of recursive mds matrices based on mds bch codes that were already described in  @xcite , chapter  11 ,  5 .",
    "we first pick a @xmath95 of order @xmath128 . as @xmath128 divides @xmath129",
    ", @xmath95 is always in @xmath130 , the degree-2 extension of @xmath3 .",
    "then , apart from @xmath131 , all powers of @xmath95 have minimal polynomials of degree 2 : since @xmath95 is of order @xmath128 , each @xmath132 has a conjugate @xmath133 which is the second root of @xmath134 . from there , it is easy to build a @xmath135_q$ ] mds bch code for any value of @xmath136 .    *",
    "if @xmath1 is even , we need to select @xmath1 consecutive powers of @xmath95 that are conjugates by pairs : if @xmath132 is selected , @xmath137 is selected too .",
    "we thus select all the powers @xmath132 with @xmath138 $ ] , grouped around @xmath139 . *",
    "if @xmath1 is odd , we need to select @xmath140 as well .",
    "we thus select all the powers @xmath132 with @xmath141 $ ] , grouped around 0 .    in both cases ,",
    "we get a polynomial @xmath78 of degree @xmath1 defining an mds bch code of length @xmath128",
    ". we can then shorten this code on @xmath142 positions and obtain the @xmath143_q$ ] mds code we were looking for .",
    "the non - systematic part of the generator matrix of this code is the @xmath1-th power of the companion matrix defined by @xmath78 .",
    "also , as the conjugate of @xmath132 is its inverse , @xmath78 enjoys the same symmetry as the example of section  [ sec.example ] : @xmath144 .",
    "this explains the symmetry observed in  @xcite .",
    "furthermore , the companion matrix associated to @xmath78 thus has at most @xmath145 different coefficients and can be implemented with at most @xmath145 multiplications .    finally , by cycling over all @xmath95 of order @xmath128 , in the case where @xmath146 we were able to recover with this direct construction all the solutions found in  @xcite through exhaustive search .",
    "we conjecture that when @xmath146 , the only recursive mds matrices that exist come from these shortened bch codes .",
    "we have seen that shortened bch codes allow to directly build recursive mds matrices . however , when building a block cipher , the designer usually has some parameters in mind ( say , a diffusion layer on @xmath1 symbols of @xmath54 bits each ) and wants the _ best _ diffusion layer matching these parameters .",
    "our direct construction gives good solutions , but can not guarantee they are the best .",
    "so the designer needs an algorithm that will enumerate all possible matrices and let him pick the most suitable one . for this",
    ", we will consider bch codes where @xmath95 is a @xmath147-th root of unity and not only a @xmath148-th root of unity as in the direct construction .",
    "first , there are a few constraints to consider .",
    "[ [ field - multiplication - or - mathbbf_2-linearity ] ] field multiplication or @xmath48-linearity ? + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the designer has to choose the type of linearity he wants for his diffusion layer .",
    "if he wants ( standard ) linearity over @xmath149 , then the bch code has to be built over @xmath149 ( or a subfield of @xmath149 , but the construction is the same ) .",
    "however , as in the sajadieh  _ et al . _",
    "@xcite or the wu  _ et al . _",
    "@xcite constructions , he could choose to use an @xmath48-linear operator @xmath49 .",
    "assuming @xmath49 has an irreducible minimal polynomial of degree @xmath150 ( see  @xcite for how to deal with non - irreducible minimal polynomials ) , then he needs to build a bch code over @xmath151 .",
    "this choice is up to the designer but does not change anything to the rest of the algorithm , so we will assume @xmath152 .",
    "[ [ the - mds - conjecture . ] ] the mds conjecture",
    ". + + + + + + + + + + + + + + + + + + +    our shortened bch construction starts by building an mds code of length @xmath153 over @xmath149 .",
    "the mds conjecture tells us that @xmath154 must hold .",
    "when @xmath155 , @xmath156 is the only choice . in general , we can choose any @xmath157 $ ] , so the algorithm will need to try all these possibilities .    [ [ minimal - polynomials - of - roots - of - unity . ] ] minimal polynomials of roots of unity .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the @xmath95 involved in the bch construction is a @xmath147-th root of unity , and @xmath78 is formed as the product of minimal polynomials of powers of @xmath95 .",
    "first , @xmath147-th roots of unity must exist , meaning @xmath153 must be odd ( or more generally coprime with @xmath158 when @xmath158 is not @xmath159 ) .",
    "then , when factorizing @xmath160 , the minimal polynomials of the @xmath132 are factors of this decomposition , and @xmath78 is the product of some of these factors . it must thus be possible to obtain a polynomial of degree @xmath1 this way .",
    "this is not always possible : for example , @xmath161 decomposes over @xmath162 in a factor of degree 1 and two factors of degree 11 and very few values of @xmath1 can be obtained . however , this last condition is rather complex to integrate in an algorithm and it will be easier to simply not take it into account .      for given parameters @xmath1 and @xmath55",
    "we propose to use algorithm  [ alg.bch ] to enumerate all possible recursive mds matrices coming from shortened bch codes .",
    "this algorithm explores all code lengths from @xmath163 to @xmath128 , meaning that the number of shortened columns can be much larger than the final code we are aiming for . instead of computing minimal polynomials and their least common multiple as in the definition of bch codes we directly compute @xmath164 and check if it is in @xmath46 $ ]",
    "this allows the algorithm to be more efficient and also makes upper bounding its complexity much easier .",
    "the following lemma shows that the two formulations are equivalent .",
    "a bch code over @xmath3 defined by the @xmath106 roots @xmath165 $ ] is mds , if and only if @xmath166 is in @xmath46 $ ] . in this case",
    ", @xmath167 is equal to @xmath83 .",
    "we have seen that a bch code is mds if and only if @xmath78 is of degree @xmath106 exactly . also , @xmath78 is always a multiple of @xmath83 .    first , assume we have an mds bch code",
    ". then @xmath78 is of degree @xmath106 and is a multiple of @xmath83 which is also of degree @xmath106 .",
    "so , up to a scalar factor , @xmath168 and @xmath169 $ ] .",
    "conversly , assume we have a bch code such that @xmath170 $ ] .",
    "then , for any @xmath171 $ ] , @xmath83 is a polynomial in @xmath46 $ ] having @xmath110 as a root , so @xmath83 is a multiple of @xmath172 .",
    "therefore , @xmath78 divides @xmath83 and , as @xmath83 also divides @xmath78 , we have @xmath173 .",
    "@xmath78 thus has degree @xmath106 and the code is mds .",
    "@xmath174 @xmath175      the previous algorithm simply tests all possible candidates without trying to be smart about which could be eliminated faster .",
    "it also finds each solution several times ( typically for @xmath95 and @xmath176 ) , and finds some _ equivalent _ solutions ( applying @xmath177 on all coefficients of the polynomial preserves the mds property , so each equivalence class is found @xmath54 times ) .",
    "the product at line  [ line.gprod ] does not have to be fully recomputed for each value of @xmath97 .",
    "it can be computed once for @xmath178 , then one division by @xmath179 and one multiplication by @xmath180 are enough to update it at each iteration .",
    "this update costs @xmath181 operations in the extension of @xmath3 containing @xmath182 .",
    "the whole loop on @xmath97 can thus be executed in @xmath183 operations in the extension field .",
    "the number of @xmath95 for which the loop has to be done is euler s phi function @xmath184 which is smaller than @xmath147 , itself smaller than @xmath158 , and there are @xmath185 values of @xmath123 to test .",
    "this gives an overall complexity of @xmath186 operations in an extension of @xmath3 .",
    "this extension is of degree at most @xmath153 , so operations are at most on @xmath187 bits in this extension and cost at most @xmath188 .",
    "this gives an upper bound on the total complexity of @xmath189 binary operations , a degree-6 polynomial in @xmath1 and @xmath158 .",
    "this is a quite expensive , but as we will see in the next section , this algorithms runs fast enough for most practical parameters .",
    "it should also be possible to accelerate this algorithm using more elaborate computer algebra techniques .",
    "we implemented algorithm  [ alg.bch ] in magma  @xcite ( see the code in appendix  [ sec.magma ] ) and ran it for various parameters .",
    "first , we ran the algorithm for parameters on the bound given by the mds conjecture , that is , when @xmath191 .",
    "these are the parameters that were studied by augot and finiasz in  @xcite .",
    "it took their algorithm 80 days of cpu time to perform the exhaustive search with parameters @xmath192 and @xmath193 and find the same 10 solutions that our new algorithm finds in a few milliseconds .",
    "the timings and number of solutions we obtained are summarized in table  [ tab.bornemds ] .",
    "we were also able to find much larger mds diffusion layers .",
    "for example , we could deal with @xmath194 elements of @xmath195 bits , which maybe is probably too large to be practical , even with a recursive structure and the nice symmetry .",
    "below are the logs in base @xmath182 ( with @xmath196 ) of the last line of the companion matrix of an example of such 1024-bit diffusion : @xmath197}\\dots   , { 83 } ] \\end{gathered}\\ ] ]    .experimental results for parameters on the bound given by mds conjecture . the value `` diff .",
    "bits '' is the size in bits of the corresponding diffusion layer .",
    "the number of solutions is given as both the raw number and the number of distinct equivalence classes.[tab.bornemds ] [ cols=\"^,^,^,^,^,^ \" , ]      we also ran some computations for other interesting parameters , typically for values of @xmath1 and @xmath54 that are both powers of 2 as it is often the case in block ciphers .",
    "the results we obtained are summarized in table  [ tab.gener ] .",
    "note that for these solutions the number of shortened positions is sometime huge : for @xmath198 and @xmath195 one can start from a @xmath199_{256}$ ] bch code and shorten it on 249 positions to obtain a @xmath200_{256}$ ] code .",
    "we counted both the total number of solutions we found and the number of regular solutions where the constant term of the polynomial is  1 .",
    "regular solutions are particularly interesting as the diffusion and its inverse share the same coefficients : @xmath201 in the case of symmetric solutions ( like those from section  [ sec.direct ] ) , encryption and decryption can even use the exact same circuit by simply reversing the order of the input and output symbols . here",
    "are some examples of what we found :    * for parameters @xmath198 and @xmath202 , with @xmath182 such that @xmath64 , the matrices @xmath203 and @xmath204 are mds . * for parameters @xmath198 and @xmath195 , with @xmath182 such that @xmath205 , the matrices @xmath206 , @xmath207 , and @xmath208 are mds .",
    "the reader might note the absence of larger fields in table  [ tab.gener ] .",
    "one could for example want to obtain a 128-bit diffusion layer using @xmath61 symbols of @xmath209 bits .",
    "however , going through all the possible values of @xmath123 and @xmath97 takes too long with @xmath210 .",
    "our algorithm is too naive , and an algorithm enumerating the divisors of @xmath160 of degree @xmath1 and checking if they correspond to bch codes could be faster in this case .",
    "otherwise , it is always possible to use the direct construction given in section  [ sec.direct ] .",
    "as we have seen , for most parameters , this algorithm runs fast enough to find all recursive mds matrices coming from bch codes .",
    "however , not all recursive mds matrices come from a bch code .",
    "* first , there are other classes of cyclic codes that are mds and could be shortened in a similar way .",
    "any such class of codes can directly be plugged into our algorithm , searching for polynomials @xmath78 having another structure than roots that are consecutive powers of @xmath95 . * then , there also are cyclic codes which are not mds , but become mds once they are shortened .",
    "these will be much harder to track as they do not have to obey the mds conjecture and can have a much larger length before shortening .",
    "for this reason , we are not always able ( yet ) to find the most efficient matrices with our algorithm .",
    "for example , the matrix used in photon corresponds to a cyclic code of length @xmath211 over @xmath162 which is not mds .",
    "we know that this code has minimum distance 3 , and its distance grows to 5 when shortened from the length @xmath211 to the length 8 .    however , for some parameters , our algorithm is able to find very nice solutions . for @xmath198 and @xmath182",
    "verifying @xmath212 ( a primitive element of @xmath213 , or an @xmath48-linear operator with this minimal polynomial ) , the matrix @xmath214 found by algorithm  [ alg.bch ] yields an mds diffusion layer .",
    "this is especially nice because it is possible to build simple @xmath48-linear operators that also have a simple inverse , and this solution is symmetric meaning the inverse diffusion can use the same circuit as the diffusion itself .",
    "the main result of this article is the understanding that recursive mds matrices can be obtained directly from shortened mds cyclic codes . from this , we derive both a direct construction and a very simple algorithm , based on the enumeration of bch codes , that allows to efficiently find recursive mds matrices for any diffusion and symbol sizes . these constructions do not always find all existing recursive mds matrices and can thus miss some interesting solutions .",
    "as part of our future works , we will continue to investigate this problem , trying to understand what properties the other solutions have and how we can extend our algorithm to find them all .",
    "a first step is to elucidate the photon matrix in terms of cyclic codes which are not bch codes , hopefully finding a direct construction of this matrix .",
    "however , in the same way as computing the minimal distance of a cyclic code is difficult , it might turn out that finding all recursive mds matrices of a given size is a hard problem .",
    "10    daniel augot and matthieu finiasz .",
    "exhaustive search for small dimension recursive mds diffusion layers for block ciphers and hash functions . in _ information theory proceedings ( isit ) , 2013 ieee international symposium on",
    "_ , pages 15511555 .",
    "ieee , 2013 .",
    "wieb bosma , john cannon , and catherine playoust .",
    "the magma algebra system .",
    "i. the user language .",
    ", 24(3 - 4):235265 , 1997 .",
    "joan daemen . .",
    "k.u.leuven , 1995 .",
    "joan daemen and vincent rijmen . .",
    "information security and cryptography .",
    "springer , 2002 .",
    "jian guo , thomas peyrin , and axel poschmann .",
    "the photon family of lightweight hash functions . in phillip rogaway , editor , _ crypto 2011 _ , volume 6841 of _ lecture notes in computer science _ , pages 222239 .",
    "springer , 2011 .",
    "jian guo , thomas peyrin , axel poschmann , and matthew j.  b. robshaw . the led block cipher . in bart",
    "preneel and tsuyoshi takagi , editors , _ ches 2011 _ , volume 6917 of _ lecture notes in computer science _ , pages 326341 .",
    "springer , 2011 .",
    "pascal junod and serge vaudenay . : a new family of block ciphers . in helena",
    "handschuh and m.  anwar hasan , editors , _ selected areas in cryptography _",
    ", volume 3357 of _ lecture notes in computer science _ , pages 114129 .",
    "springer , 2004 .",
    "macwilliams and n.j.a .",
    ". north - holland mathematical library .",
    "north - holland , 1978 .",
    "mahdi sajadieh , mohammad dakhilalian , hamid mala , and pouyan sepehrdad .",
    "recursive diffusion layers for block ciphers and hash functions . in anne canteaut , editor , _ fast software encryption 2012 _ , volume 7549 of _ lecture notes in computer science _ , pages 385401 .",
    "springer berlin heidelberg , 2012 .",
    "richard singleton .",
    "maximum distance @xmath158-nary codes .",
    ", 10(2):116118 , april 1964 .",
    "shengbao wu , mingsheng wang , and wenling wu .",
    "recursive diffusion layers for ( lightweight ) block ciphers and hash functions . in lars",
    "r. knudsen and huapeng wu , editors , _ selected areas in cryptography _ ,",
    "volume 7707 of _ lecture notes in computer science _ , pages 355371 .",
    "springer , 2013 .",
    "here is the magma code for algorithm  [ alg.bch ] .",
    "simply run ` bch(k , s ) ` to get the set of all polynomials of degree @xmath1 over @xmath149 that yield mds diffusion layers on @xmath215 bits .",
    "of course , these polynomials have to be written as companion matrices which then have to be raised to the power @xmath1 to obtain the final mds matrices .",
    ".... bch : = function(k , s )    q : = 2^s ;    f : = gf(q ) ;    p : = polynomialring(f ) ;    s : = { } ;    for z:=1 to q+1 - 2*k by 2 do      a : = rootofunity(2*k+z , f ) ;      pext < x > : = polynomialring(parent(a ) ) ;      for i:=0 to 2*k+z-1 do        b : = a^i ;        if order(b ) eq ( 2*k+z ) then          g : = & * [ ( x - b^l ) : l in [ -1 .. k-2 ] ] ;          for l in [ 0 .. 2*k+z-2 ] do            g : = ( g*(x - b^(l+k-1 ) ) ) div ( x - b^(l-1 ) ) ;            if iscoercible(p , g ) then              include(~s , p!g ) ;            end if ;          end for ;        end if ;      end for ;    end for ;    return s ; end function ; ...."
  ],
  "abstract_text": [
    "<S> mds matrices allow to build optimal linear diffusion layers in block ciphers . however , mds matrices can not be sparse and usually have a large description , inducing costly software / hardware implementations . </S>",
    "<S> recursive mds matrices allow to solve this problem by focusing on mds matrices that can be computed as a power of a simple companion matrix , thus having a compact description suitable even for constrained environments . however , up to now , finding recursive mds matrices required to perform an exhaustive search on families of companion matrices , thus limiting the size of mds matrices one could look for . in this article </S>",
    "<S> we propose a new _ direct _ construction based on shortened bch codes , allowing to efficiently construct such matrices for whatever parameters . </S>",
    "<S> unfortunately , not all recursive mds matrices can be obtained from bch codes , and our algorithm is not always guaranteed to find the best matrices for a given set of parameters . </S>"
  ]
}