{
  "article_text": [
    "static analysis of logic programs can provide useful information for programmers and compilers .",
    "typing systems , such as in @xmath3prolog @xcite , have proved valuable during the development of code : type errors often represent program errors that are caught at compile time when they are easier to find and fix than at runtime when they are much harder to repair .",
    "static type information also provides valuable documentation of code since it provides a concise approximation to what the code does .    in this paper",
    "we describe a method by which it is possible to infer that certain relationships concerning collections underlying structured data hold .",
    "we shall focus on relations that are also decidable and can be done during compile time analysis of logic programs .",
    "we shall use _ multisets _ and _ sets _ to _ approximate _ more complicated structures as lists and binary trees .",
    "consider , for example , a list sorting program that maintains duplicates of elements .",
    "part of the correctness of a sort program includes the fact that if the atomic formula @xmath0 is provable , then @xmath2 is a permutation of @xmath1 that is in - order .",
    "the proof of such a property is likely to involve inductive arguments requiring the invention of invariants : in other words , this is not likely to be a property that can be inferred statically during compile time . on the other hand ,",
    "if the lists @xmath1 and @xmath2 are approximated by multisets ( that is , if we forget the order of items in lists ) , then it might be possible to establish that if the atomic formula @xmath0 is provable , then the multiset associated to @xmath2 is equal to the multiset associated to @xmath1 .",
    "if that is so , then it is immediate that the lists @xmath1 and @xmath2 are , in fact , permutations of one another ( in other words , no elements were dropped , duplicated , or created during sorting ) .",
    "as we shall see , such properties based on using multisets to approximate lists can often be done statically .",
    "this paper considers exclusively the static analysis of first - order horn clauses but it does so by making substitution instances of such horn clauses that carry them into linear logic .",
    "proofs for the resulting linear logic formulas are then attempted as part of static analysis .",
    "there are various themes that underlie our approach to inferring properties of horn clause programs .",
    "we list them explicitly below .",
    "the rest of the paper can be seen as a particular example of how these themes can be developed .",
    "types and other static properties of programming languages have proved important on a number of levels .",
    "typing can be useful for programmers : they can offer important invariants and document for code .",
    "static analysis can also be used by compilers to uncover useful structures that allow compilers to make choices that can improve execution .",
    "while compilers might make use of multiple static analysis regimes , programmers do not usually have convenient access to multiple static analyzes for the code that they are composing .",
    "sometimes , a programming language provides no static analysis , as is the case with lisp and prolog .",
    "other programming languages offer exactly one typing discipline , such as the polymorphic typing disciplines of standard ml and @xmath3prolog ( sml also statically determines if a given function defined over concrete data structures cover all possible input values ) .",
    "it seems clear , however , that such analysis of code , if it can be done quickly and incrementally , might have significant benefits for programmers during the process of writing code .",
    "for example , a programmer might find it valuable to know that a recursive program that she has just written has linear or quadratic runtime complexity , or that a relation she just specified actually defines a function .",
    "the ciao system preprocessor @xcite provides for such functionality by allowing a programmer to write various properties about code that the preprocessor attempts to verify .",
    "having an open set of properties and analysis tools is an interesting direction for the design of a programming language .",
    "the collection analysis we discuss here could be just one such analysis tool .      if we do not commit to just one typing discipline",
    ", then it seems sensible to use a completely untyped setting for encoding programs and declarations .",
    "given that untyped @xmath3-terms provide for arbitrary applications and arbitrary abstractions , such terms can provide an appealing setting for the encoding of program expressions , type expressions , assertions , invariants , etc . via the well developed theory of @xmath3-conversion",
    ", such abstractions can be instantiated with a variety of other objects .",
    "abstractions can be used to encode quantifiers within formulas as well as binding declarations surrounding entire programs .    in logic programming",
    ", proofs can be viewed as computation traces and such proof objects can also be encoded as untyped @xmath3-terms .",
    "instantiations into proofs is also well understood since it is closely related to the elimination of cut in sequent calculus or to normalization in natural deduction proofs .",
    "the fact that proofs and programs can be related simply in a setting where substitution into both has well understood properties is certainly one of the strengths of the proof theoretic foundations of logic programming ( see , for example , @xcite ) .      in proof theory",
    ", there is interesting problem of duality involving atomic formulas .",
    "the _ initial rule _ and the _ cut rule _ given as @xmath4 can be seen as being dual to each other @xcite .",
    "in particular , the initial rule states that an occurrence of a formula on the left is stronger than the same occurrence on the right , whereas the cut rule states the dual : an occurrence of a formula on the right is strong enough to remove the same occurrence from the left . in most well designed proof systems , all occurrence of the cut - rule can be eliminated ( whether or not @xmath5 is an atomic formula ) whereas only non - atomic initial rules ( where @xmath5 is non - atomic ) can be eliminated .",
    "atoms seem to spoil the elegant duality of the meta - theory of these inference rules .",
    "while the logic programming world is most comfortable with the existence of atomic formulas , there have been a couple of recent proof theoretic approaches that try to eliminate them entirely .",
    "for example , in the work on _ definitions _ and _ fixed points _ by schroeder - heister @xcite , girard @xcite , and mcdowell & miller @xcite , atoms are defined to be other formulas . in this approach ,",
    "the only primitive judgment involving terms is that of equality . in that setting , if definitions are _ stratified _ ( no recursion through negations ) and _ noetherian _ ( no infinite descent in recursion ) , then all instances of cut and initial can be removed .",
    "the setting of _ ludics _ of girard @xcite is a more radical presentation of logic in which atomic formulas do not exist : formulas can be probed to arbitrary depth to uncover `` subformulas '' .",
    "another approach to atoms is to consider _ all _ constants as being variables . on one hand",
    "this is a trivial position : if there are no constants ( thus , no predicate constants ) there are no atomic formulas ( which are defined as formulas with non - logical constants at their head ) .",
    "on the other hand , adopting a point - of - view that constants can vary has some appeal .",
    "we describe this next .",
    "the inference rule of @xmath6-generalization states that if @xmath7 is provable then @xmath8 is provable ( with appropriate provisos if the proof of @xmath7 depends on hypotheses ) .",
    "if we are in a first - order logic , then the free first - order variable @xmath9 of @xmath7 becomes bound in @xmath8 by this inference rule .",
    "observe the following two things about this rule .",
    "first , if we are in an untyped setting , then we can , in principle , quantify over any variable in any expression , even those that play the role of predicates or functions .",
    "mixing such rich abstractions with logic is well known to be inconsistent so when we propose such rich abstractions in logic , we must accompany it with some discipline ( such as typing ) that will yield consistency .",
    "second , we need to observe that differences between constants and variables can be seen as one of `` scope '' , at least from a syntactic , proof theoretic , and computational point of view . for example , variables are intended as syntactic objects that can `` vary '' . during the computation of , say , the relation of appending lists , universal quantified variables surrounding horn clauses",
    "change via substitution ( via backchaining and unification ) but the constructors for the empty and non - empty lists as well as the symbol denoting the append relation do not change and , hence , can be seen as constants .",
    "but from a compiling and linking point - of - view , the append predicate might be considered something that varies : if append is in a module of prolog that is separately compiled , the append symbol might denote a particular object in the compiled code that is later changed when the code is loaded and linked . in a similar fashion",
    ", we shall allow ourselves to instantiate constants with expression during static analysis .",
    "substituting for constants allows us to `` split the atom '' : that is , by substituting for the predicate @xmath10 in the atom @xmath11 , we replace that atom with a formula , which , in this paper , will be a linear logic formula .",
    "linear logic @xcite is able to explain the proof theory of usual horn clause logic programming ( and even richer logic programming languages @xcite ) .",
    "it is also able to provide means to reason about resources , such as items in multisets and sets .",
    "thus , linear logic will allow us to sit within one declarative framework to describe both usual logic programming as well as `` sub - atomic '' reasoning about the resources implicit in the arguments of predicates .",
    "linear logic connectives can be divided into the following groups : the multiplicatives @xmath12 , @xmath13 , @xmath14 , @xmath15 ; the additives @xmath16 , @xmath17 , @xmath18 , @xmath19 ; the exponentials @xmath20 , @xmath21 ; the implications @xmath22 ( where @xmath23 is defined as @xmath24 ) and @xmath25 ( where @xmath26 is defined as @xmath27 ) ; and the quantifiers @xmath6 and @xmath28 ( higher - order quantification is allowed ) .",
    "the equivalence of formulas in linear logic , @xmath29 , is defined as the formula @xmath30 .",
    "first - order horn clauses can be described as formulas of the form @xmath31",
    "\\qquad ( n , m\\ge 0)\\ ] ] where @xmath32 and @xmath33 are intuitionistic or classical logic conjunction and implication .",
    "there are at least two natural mappings of horn clauses into linear logic .",
    "the `` multiplicative '' mapping uses the @xmath14 and @xmath22 for the conjunction and implication : this encoding is used in , say , the linear logic programming settings , such as lolli @xcite , where horn clause programming can interact with the surrounding linear aspects of the full programming language . here , we are not interested in linear logic programming per se but with using linear logic to help establish invariants about horn clauses when these are interpreted in the usual , classical setting . as a result , we shall encode horn clauses into linear logic using the conjunction @xmath18 and implication @xmath25 : that is , we take horn clauses to be formulas of the form @xmath34 .",
    "\\qquad ( n , m\\ge 0)\\ ] ] the usual proof search behavior of first - order horn clauses in classical ( and intuitionistic ) logic is captured precisely when this style of linear logic encoding is used .",
    "@xmath35    @xmath36",
    "[ proof theory ]    a sequent is a triple of the form @xmath37 were @xmath38 , the signature , is a list of non - logical constants and eigenvariables paired with a simple type , and where both @xmath39 and @xmath40 are multisets of @xmath38-formulas ( i.e. , formulas all of whose non - logical symbols are in @xmath38 ) .",
    "the rules for linear logic are the standard ones @xcite , except here signatures have been added to sequents .",
    "the rules for quantifier introduction are the only rules that require the signature and they are reproduced here : @xmath41,\\gamma \\seqsym \\delta } }         { \\sigma ; { \\exists         x^\\tau.b,\\gamma \\seqsym \\delta } } \\exists l \\quad    \\frac{\\sigma\\vdash t\\colon \\tau \\quad \\sigma ; { \\gamma \\seqsym b[t / x],\\delta } }         { \\sigma;{\\gamma \\seqsym \\exists x^\\tau.b,\\delta } } \\exists r\\ ] ] @xmath42,\\gamma \\seqsym \\delta } }         { \\sigma ; { \\forall x^\\tau.b,\\gamma \\seqsym \\delta } } \\forall l \\quad    \\frac{\\sigma , y:\\tau;{\\gamma \\seqsym b[y / x],\\delta } }         { \\sigma;{\\gamma \\seqsym \\forall x^\\tau.b,\\delta } } \\forall r\\ ] ] the premise @xmath43 is the judgment that the term @xmath1 has the ( simple ) type @xmath44 given the typing declaration contained in @xmath38 .",
    "we now outline three ways to instantiate things within the sequent calculus .",
    "although we think of formulas and proofs as untyped expressions , we shall use simple typing within sequents to control the kind of formulas that are present .",
    "a signature is used to bind and declare typing for ( eigen)variables and non - logical constants within a sequent .",
    "simple types are , formally speaking , also a simple class of untyped @xmath3-terms : the type @xmath45 is used to denote formulas ( following church @xcite ) . in a sequent calculus proof ,",
    "simple type expressions are global and admit no bindings . as a result",
    ", it is an easy matter to show that if one takes a proof with a type constant @xmath46 and replaces everywhere @xmath46 with some type , say , @xmath44 , one gets another valid proof .",
    "we shall do this later when we replace a list by a multiset that approximates it : since we are using linear logic , we shall use formulas to encode multisets and so we shall replace the type constant list with o.      consider the sequent @xmath47 where the type @xmath44 is a predicate type ( that is , it is of the form @xmath48 ) and where @xmath10 appears in , say , @xmath49 and @xmath50 and in no formula of @xmath39 .",
    "the linear logic exponential @xmath20 is used here to encode the fact that the formulas @xmath49 and @xmath50 are available for arbitrary reuse within a proof ( the usual case for program clauses ) . using the right introduction rules for implication and the universal quantifier",
    ", it follows that the sequent @xmath51}\\ ] ] is also provable .",
    "since this is a universal quantifier , there must be proofs for all instances of this quantifier .",
    "let @xmath52 be the substitution @xmath53 $ ] , where @xmath54 is a term over the signature @xmath55 of type @xmath45 .",
    "a consequence of the proof theory of linear logic is that there is a proof also of @xmath56}\\ ] ] and of the sequent @xmath57}.\\ ] ] as this example illustrates , it is possible to instantiate a predicate ( here @xmath10 ) with an abstraction of a formula ( here , @xmath58 ) .",
    "such instantiation carries a provable sequent to a provable sequent .",
    "an instance of the cut - rule ( mentioned earlier ) is the following : @xmath59 this inference rule ( especially when associated with the cut - elimination procedure ) provides a way to merge ( substitution ) the proof of a formula ( here , @xmath7 ) with a use of that formula as an assumption .",
    "for example , consider the following situation .",
    "given the example in the section  [ subcon ] , assume that we can prove @xmath60 using two instances of the cut rule and the proofs of these sequent , it is possible to obtain a proof of the sequent @xmath61}\\ ] ] ( contraction on the left for @xmath20ed formulas must be applied ) .",
    "thus , by a series of instantiations of proofs , it is possible to move from a proof of , say , @xmath62 to a proof of @xmath61}.\\ ] ] we shall see this style of reasoning about proofs several times below .",
    "this allows us to `` split an atom '' @xmath63 into a formula @xmath64 $ ] and to transform proofs of the atom into proofs of that formula . in",
    "what follows , the formula @xmath54 will be a linear logic formula that provides an encoding of some judgment about the data structures encoded in the terms @xmath65 .",
    "a few simple examples of using higher - order instantiations of logic programs in order to help reasoning about them appear in @xcite .",
    "we wish to encode multisets and sets and simple judgments about them ( such as inclusion and equality ) as linear logic formulas .",
    "we consider multisets first .",
    "let token _ item _ be a linear logic predicate of one argument : the linear logic atomic formula @xmath66 will denote the multiset containing just the one element @xmath9 occurring once .",
    "there are two natural encoding of multisets into formulas using this predicate .",
    "the _ conjunctive _ encoding uses @xmath15 for the empty multiset and @xmath14 to combine two multisets .",
    "for example , the multiset @xmath67 is encoded by the linear logic formula @xmath68 .",
    "proofs search using this style encoding places multiset on the left of the sequent arrow .",
    "this approach is favored when an intuitionistic subset of linear logic is used , such as in lolli @xcite , linearlf @xcite , and msr @xcite .",
    "the dual encoding , the _ disjunctive _ encoding , uses @xmath13 for the empty multiset and @xmath12 to combine two multisets .",
    "proofs search using this style encoding places multisets on the right of the sequent arrow .",
    "multiple conclusion sequents are now required .",
    "systems such as lo @xcite and forum @xcite use this style of encoding . if negation is available , then the choice of which encoding one chooses is mostly a matter of style .",
    "we pick the disjunctive encoding for the rather shallow reason that the inclusion judgment for multisets and sets is encoded as an implication instead of a reverse implication , as we shall now see .",
    "let @xmath54 and @xmath69 be the two formulas @xmath70 and @xmath71 , respectively ( @xmath72 ) .",
    "notice that @xmath73 if and only if @xmath74 if and only if the two multisets @xmath75 and @xmath76 are equal .",
    "consider now , however , the following two ways for encoding the multiset inclusion @xmath77 .",
    "* @xmath78 .",
    "this formula mixes multiplicative connectives with the additive connective @xmath79 : the latter allows items that are not matched between @xmath54 and @xmath69 to be deleted . *",
    "this formula mixes multiplicative connectives with a higher - order quantifier .",
    "while we can consider the instantiation for @xmath81 to be the multiset difference of @xmath54 from @xmath69 , there is no easy way in the logic to enforce that interpretation of the quantifier .",
    "as it turns out , these two approaches are equivalent in linear logic : in particular , @xmath82 ( linear logic absurdity ) and @xmath83.\\ ] ] thus , below we can choose either one of these encodings for multiset inclusion .",
    "a _ multiset expression _ is a formula in linear logic built from the predicate symbol _ item _ ( denoting the singleton multiset ) , the linear logic multiplicative disjunction @xmath12 ( for multiset union ) , and the unit @xmath13 for @xmath12 ( used to denote the empty multiset ) .",
    "we shall also allow a predicate variable ( a variable of type @xmath45 ) to be used to denote a ( necessarily open ) multiset expression .",
    "an example of an open multiset expression is @xmath84 , where @xmath85 is a variable of type @xmath45 , @xmath86 is a first - order variable , and @xmath87 is some first - order term constructor .",
    "let @xmath54 and @xmath69 be two multiset expressions .",
    "the two _ multiset judgments _ that we wish to capture are multiset inclusion , written as @xmath77 , and equality , written as @xmath88 .",
    "we shall use the syntactic variable @xmath89 to range over these two judgments , which are formally binary relations of type @xmath90 .",
    "a _ multiset statement _ is a formula of the form @xmath91\\ ] ] where the quantified variables @xmath92 are either first - order or of type @xmath45 and formulas @xmath93 are possibly open multiset expressions .    if @xmath54 and @xmath69 are closed multiset expressions , then we write @xmath94 whenever the multiset ( of closed first - order terms ) denoted by @xmath54 is contained in the multiset denoted by @xmath69 , and we write @xmath95 whenever the multisets denoted by @xmath54 and @xmath69 are equal .",
    "similarly , we write @xmath96\\ ] ] if for all closed substitutions @xmath52 such that @xmath97 for all @xmath98 , it is the case that @xmath99 .",
    "the following proposition is central to our use of linear logic to establish multiset statements for horn clause programs .",
    "[ ms ok ] let @xmath100 ( @xmath101 ) be multiset expressions all of whose free variables are in the list of variables @xmath92 .",
    "for each judgment @xmath102 we write @xmath103 to denote @xmath104 if @xmath105 is @xmath106 and @xmath107 if @xmath105 is @xmath108 . if @xmath109\\ ] ] is provable in linear logic , then @xmath110\\ ] ]",
    "this proposition shows that linear logic can be used in a sound way to infer valid multiset statement .",
    "on the other hand , the converse ( completeness ) does not hold : the statement @xmath111 is valid but its translation into linear logic is not provable .",
    "@xmath112    @xmath113    to illustrate how deduction in linear logic can be used to establish the validity of a multiset statement , consider the first - order horn clause program in figure  [ one ] .",
    "the signature for this collection of clauses can be given as follows :    .... nil     : list cons    : int - > list - > list append : list - > list - > list - > o split   : int - > list - > list - > list - > o sort    : list - > list - > o leq     : int - > int - > o gr      : int - > int - > o ....    the first two declarations provide constructors for empty and non - empty lists , the next three are predicates whose horn clause definition is presented in figure  [ one ] , and the last two are order relations that are apparently defined elsewhere .",
    "if we think of lists as collections of items , then we might want to check that the sort program as written does not drop , duplicate , or create any elements .",
    "that is , if the atom @xmath114 is provable then the multiset of items in the list denoted by @xmath2 is equal to the multiset of items in the list denoted by @xmath1 .",
    "if this property holds then @xmath1 and @xmath2 are lists that are permutations of each other : of course , this does not say that it is the correct permutation but this more simple fact is one that , as we show , can be inferred automatically .",
    "computing this property of our example logic programming follows the following three steps .",
    "first , we provide an approximation of lists as being , in fact , multiset : more precisely , as _ formulas _ denoting multisets .",
    "the first step , therefore , must be to substitute for in the signature above .",
    "now we can now interpret the constructors for lists using the substitution @xmath115 under such a mapping , the list (  1  (  3  (  2  ) ) ) is mapped to the multiset expression @xmath116 .",
    "second , we associate with each predicate in figure  [ one ] a multiset judgment that encodes an invariant concerning the multisets denoted by the predicate s arguments . for example , if @xmath117 or @xmath118 is provable then the multiset union of the items in @xmath119 with those in @xmath2 is equal to the multiset of items in @xmath1 , and if @xmath114 is provable then the multisets of items in lists @xmath2 and @xmath1 are equal .",
    "this association of multiset judgments to atomic formulas can be achieved formally using the following substitutions for constants : @xmath120 the predicates and ( for the least - than - or - equal - to and greater - than relations ) make no statement about collections of items , so that they can be mapped to a trivial tautology via the substitution @xmath121 figure  [ two ] presents the result of applying these mappings to figure  [ one ] .",
    "third , we must now attempt to prove each of the resulting formulas . in the case of figure",
    "[ two ] , all the displayed formulas are trivial theorems of linear logic .    having taken these three steps , we now claim that we have proved the intended collection judgments associate to each of the logic programming predicates above : in particular , we have now shown that our particular sort program computes a permutation .",
    "the formal correctness of this three stage approach is easily justified given the substitution properties we presented in section  [ proof theory ] for the sequent calculus presentation of linear logic .",
    "let @xmath39 denote a set of formulas that contains those in figure  [ one ] .",
    "let @xmath52 denote the substitution described above for the type list , for the constructors nil and cons , and for the predicates in figure  [ one ] .",
    "if @xmath38 is the signature for @xmath39 then split @xmath38 into the two signatures @xmath122 and @xmath123 so that @xmath122 is the domain of the substitution @xmath52 and let @xmath124 be the signature of the range of @xmath52 ( in this case , it just contains the constant _ item _ ) .",
    "thus , @xmath125 is the set of formula in figure  [ two ] .",
    "assume now that @xmath126 is provable .",
    "given the discussion in sections  [ subtyp ] and  [ subcon ] , we know that @xmath127 is provable",
    ". since the formulas in @xmath125 are provable , we can use substitution into proofs ( section  [ subass ] ) to conclude that @xmath128 .",
    "given proposition  [ ms ok ] , we can conclude that @xmath129 : that is , that @xmath130 and @xmath131 encode the same multiset .",
    "consider the following model theoretic argument for establishing similar properties of horn clauses .",
    "let @xmath132 be the herbrand model that captures the invariants that we have in mind .",
    "in particular , @xmath132 contains the atoms @xmath133 and @xmath134 if the items in the list @xmath119 added to the items in list @xmath2 are the same as the items in @xmath1 .",
    "furthermore , @xmath132 contains all closed atoms of the form @xmath135 and @xmath136 , and closed atoms @xmath137 where @xmath2 and @xmath1 are lists that are permutations of one another .",
    "one can now show that @xmath132 satisfies all the horn clauses in figure  [ one ] . as a consequence of the soundness of first - order classical logic",
    ", any atom provable from the clauses in figure  [ one ] , must be true in @xmath132 . by construction of @xmath132 ,",
    "this means that the desired invariant holds for all atoms proved from the program .",
    "the approach suggested here using linear logic and deduction remains syntactic and proof theoretic : in particular , showing that a model satisfies a horn clause is replaced by a deduction within linear logic .",
    "it is rather easy to encode sets and the equality and subset judgments on sets into linear logic .",
    "in fact , the transition to set from multiset is provided by the use of the linear logic exponential : since we are using disjunctive encoding of collections ( see the discussion in section  [ msets ] ) , we use the @xmath21 exponential ( if we were using the conjunctive encoding , we would use the @xmath20 exponential ) .",
    "the expression @xmath138 can be seen as describing the presence of an item for which the exact multiplicity does not matter : this formula represents the capacity to be used any number of times .",
    "thus , the set @xmath139 can be encoded as @xmath140 . using logical equivalences of linear logic",
    ", this formula is also equivalent to the formula @xmath141 .",
    "this latter encoding is the one that we shall use for building our encoding of sets .",
    "a _ set expression _ is a formula in linear logic built from the predicate symbol _ item _ ( denoting the the singleton set ) , the linear logic additive disjunction @xmath16 ( for set union ) , and the unit @xmath17 for @xmath16 ( used to denote the empty set ) .",
    "we shall also allow a predicate variable ( a variable of type @xmath45 ) to be used to denote a ( necessarily open ) set expression .",
    "an example of an open multiset expression is @xmath142 , where @xmath85 is a variable of type @xmath45 , @xmath86 is a first - order variable , and @xmath87 is some first - order term constructor .",
    "let @xmath54 and @xmath69 be two set expressions .",
    "the two _ set judgments _ that we wish to capture are set inclusion , written as @xmath143 , and equality , written as @xmath144 .",
    "we shall use the syntactic variable @xmath89 to range over these two judgments , which are formally binary relations of type @xmath90 .",
    "a _ set statement _ is a formula of the form @xmath91\\ ] ] where the quantified variables @xmath92 are either first - order or of type @xmath45 and formulas @xmath145 are possibly open set expressions .",
    "if @xmath54 and @xmath69 are closed set expressions , then we write @xmath146 whenever the set ( of closed first - order terms ) denoted by @xmath54 is contained in the set denoted by @xmath69 , and we write @xmath147 whenever the sets denoted by @xmath54 and @xmath69 are equal .",
    "similarly , we write @xmath148\\ ] ] if for all closed substitutions @xmath52 such that @xmath149 for all @xmath98 , it is the case that @xmath150 .",
    "the following proposition is central to our use of linear logic to establish set statements for horn clause programs .",
    "[ set ok ] let @xmath100 ( @xmath101 ) be set expressions all of whose free variables are in the list of variables @xmath92 . for each judgment",
    "@xmath102 we write @xmath103 to denote @xmath151 if @xmath105 is @xmath152 and @xmath153 if @xmath105 is @xmath154 . if @xmath109\\ ] ] is provable in linear logic , then @xmath155\\ ] ]    lists can be approximated by sets by using the following substitution : @xmath156 under such a mapping , the list (  1  (  2  (  2  ) ) ) is mapped to the set expression @xmath157 .",
    "this expression is equivalent ( @xmath158 ) to the set expression @xmath159 .    for a simple example of using set",
    "approximates , consider modifying the sorting program provided before so that duplicates are not kept in the sorted list .",
    "do this modification by replacing the previous definition for splitting a list with the clauses in figure  [ three ] .",
    "that figure contains a new definition of splitting that contains three clauses for deciding whether or not the `` pivot '' for the splitting x is equal to , less than ( using the lt predicate ) , or greater than the first member of the list being split . using the following substitutions for predicates @xmath160 ( as well as the trivial substitution for and ) , we can show that sort relates two lists only if those lists are approximated by the same set .",
    "@xmath161 @xmath162 @xmath163 here , @xmath72 and in the bc ( backchaining ) inference rule , the formula @xmath164 must be a member of @xmath39 and @xmath165 .    in the case of determining the validity of a set statement",
    ", the use of linear logic here appears to be rather weak when compared to the large body of results for solving set - based constraint systems @xcite .",
    "we describe how automation of proof for the linear logic translations of set and multiset statements given in propositions  [ ms ok ] and  [ set ok ] can be performed .    in order to understand how to automatically prove the required formulas",
    ", we first provide a normal form theorem for the fragment of linear logic for which we are interested .",
    "the key result of linear logic surrounding the search for cut - free proofs is given by the completeness of _ focused proofs _",
    "focused proofs are a normal form that significantly generalizes standard completeness results in logic programming , including the completeness of sld - resolution and uniform proofs as well as various forms of bottom - up and top - down reasoning .",
    "we first analyze the nature of proof search for the linear logic translation of set statements .",
    "note that when considering provability of set statements , there is no loss of generality if the only set judgment it contains is the subset judgment since set equality can be expressed as two inclusions .",
    "we now prove that the proof system in figure  [ additive ] is sound and complete for proving set statements .",
    "[ additive ps ] let @xmath100 ( @xmath101 ) be set expressions all of whose free variables are in the list of variables @xmath92 .",
    "the formula @xmath166\\ ] ] is provable in linear logic if and only if the sequent @xmath167 is provable using the proof system in figure  [ additive ] .    the soundness part of this proposition ( `` if '' ) is easy to show . for completeness (",
    "`` only if '' ) , we use the completeness of focused proofs in @xcite . in order to use this result of focused proofs ,",
    "we need to give a polarity to all atomic formulas .",
    "we do this by assigning all atomic formulas ( those of the form @xmath168 and those symbols in @xmath92 of type @xmath45 ) negative polarity .",
    "second , we need to translation the two sided sequent @xmath169 to @xmath170 when @xmath54 is not atomic ( that is , its top - level logical connective is @xmath16 ) and to @xmath171 when @xmath54 is a atom .",
    "completeness then follows directly from the structure of focused proofs .",
    "notice that the resulting proofs are essentially bottom - up : one reasons from formulas on the left of the sequent arrow to formulas on the right .",
    "we can now conclude that it is decidable to determine whether or not the linear logic translation of a set statement is provable .",
    "notice that in a proof built using the inference rules in figure  [ additive ] , if the endsequent is @xmath169 then all sequents in the proof have the form @xmath172 , for some @xmath173 .",
    "thus , the search for a proof either succeeds ( proof search ends by placing @xmath16 r on top ) , or fails to find a proof , or it cycles , a case we can always detect since there is only a finite number of atomic formulas that can be @xmath173 .",
    "@xmath174 @xmath175 @xmath176 here , @xmath72 and in the bc ( backchaining ) inference rule , it must be the case that the formula @xmath177 is a member of @xmath39 .",
    "the proof system in figure  [ multiplicative ] can be used to characterize the structure of proofs of the linear logic encoding of multiset statements .",
    "let @xmath109\\ ] ] be the translation of a multiset statement into linear logic .",
    "provability of this formula can be reduced to attempting to prove @xmath178 from assumptions of the form @xmath179 where @xmath180 are atomic formulas .",
    "such formulas can be called _ multiset rewriting clauses _ since backchaining on such clauses amounts to rewriting the right - hand - side multiset of a sequent ( see rule bc in figure  [ multiplicative ] ) .",
    "such rewriting clauses are particularly simple since they do not involve quantification .",
    "[ multiplicative ps ] let @xmath181 and @xmath182 be multiset expressions all of whose free variables are in the list of variables @xmath92 and let @xmath39 be a set of multiset rewriting rules .",
    "the formula @xmath183 is a linear logic consequence of @xmath39 if and only if the sequent @xmath184 is provable using the inference rules in figure  [ multiplicative ] .    the soundness part of this proposition ( `` if '' ) is easy to show .",
    "completeness ( `` only if '' ) is proved elsewhere , for example , in ( * ? ? ?",
    "* proposition 2 ) .",
    "it is also an easy consequence of the the completeness of focused proofs in @xcite : fix the polarity to all atomic formulas to be positive .",
    "notice that the proofs using the rules in figure  [ multiplicative ] are straight line proofs ( no branching ) and that they are top - down ( or goal - directed ) . given these observation",
    ", it follows that determining if @xmath183 is provable from a set of multiset rewriting clauses is decidable , since this problem is contained within the reachability problem of petri nets @xcite . proving a multiset inclusion judgment",
    "@xmath185 involves first instantiating this higher - order quantifier . in principle , this instantiation can be delayed until attempting to apply the sole instance of the @xmath12 l rule ( figure  [ multiplicative ] ) .",
    "we now consider using lists as approximations .",
    "since lists have more structure than sets and multisets , it is more involved to encode and reason with them .",
    "we only illustrate their use and do not follow a full formal treatment for them .",
    "since the order of elements in a list is important , the encoding of lists into linear logic must involve a connective that is not commutative .",
    "( notice that both @xmath12 and @xmath16 are commutative . )",
    "linear implication provides a good candidate for encoding the order used in lists . for example , consider proof search with the formula @xmath186 on the right .",
    "( this formula is equivalent to @xmath187 . )",
    "such a formula can be seen as describing a process that is willing to output the item @xmath188 then go into input mode waiting for the atomic formula @xmath10 to appear .",
    "if that formula appears , then item @xmath189 is output and again it goes into input waiting mode looking for @xmath10 . if another occurrence of @xmath10 appears , this process becomes the inactive process .",
    "clearly , @xmath188 is output prior to when @xmath189 is output : this ordering is faithfully captured by proof search in linear logic .",
    "such an encoding of asynchronous process calculi into linear logic has been explored in a number of papers : see , for example , @xcite .",
    "the example above suggests that lists and list equality can be captured directly in linear logic using the following encoding : @xmath190 the encoding of the list , say @xmath191 , is given by the @xmath3-abstraction @xmath192    the following proposition can be proved by induction on the length of the list @xmath1 .",
    "[ list eq ] let @xmath2 and @xmath1 be two lists ( built using and ) and let @xmath54 and @xmath69 be the translation of those lists into expressions of type @xmath193 via the substitution above .",
    "then @xmath194 is provable in linear logic if and only if @xmath2 and @xmath1 are the same list .",
    "this presentation of lists can be `` degraded '' to multisets simply by applying the translation of a list to the formula @xmath13 .",
    "for example , applying the translation of @xmath191 to @xmath13 yields the formulas @xmath195 which is linear logically equivalent to @xmath196",
    ".    given this presentation of lists , there appears to be no simple combinator for , say , list concatenation and , as a result , there is no direct way to express the judgments of prefix , suffix , sublist , etc .",
    "thus , beyond equality of lists ( by virtual of proposition  [ list eq ] ) there are few natural judgments that can be stated for list .",
    "more can be done , however , by considering difference lists .",
    "since our framework includes @xmath3-abstractions , it is natural to represent difference lists as a particular kind of list abstraction over a list . for example , in @xmath3prolog a difference list is naturally represented as a @xmath3-term of the form @xmath197 such abstracted lists are appealing since the simple operation of composition encodes the concatenation of two lists . given concatenation , it is then easy to encode the judgments of prefix and suffix . to see other example of computing on difference lists described in fashion , see @xcite .",
    "@xmath198    @xmath199    lists can be encoded using the difference list notion with the following mapping into linear logic formulas . @xmath200",
    "the encoding of the list , say @xmath191 , is given by the @xmath3-abstraction @xmath201    in figure  [ traverse ] , a predicate for traversing a binary tree is given .",
    "binary trees are encoded using the type and are constructed using the constructors , for the empty tree , and of type @xmath202 , for building non - empty trees .",
    "a useful invariant of this program is that the list of items approximating the binary tree structure in the first argument of is equal to the list of items in the second argument .",
    "linear logic formulas for computing that approximation can be generated using the following approximating substitution .",
    "@xmath203 the result of applying that substitution ( as well as the one above for and ) is displayed in figure  [ traverse ll ] . while these formulas appear rather complex , they are all , rather simple theorems of higher - order linear logic : these theorems are essentially trivial since the @xmath3-conversions used to build the formulas from the data structures has done all the essential work in organizing the items into a list . establishing these formulas proves that the order and multiplicity of elements in the binary tree and in the list in a provable traverse computation are the same .",
    "various extensions of the basic scheme described here are natural to consider . in particular",
    ", it should be easy to consider approximating data structures that contain items of differing types : each of these types could be mapped into different @xmath204 predicates , one for each type @xmath205 .",
    "it should also be simple to construct approximating mappings given the _",
    "polymorphic _ typing of a given constructor s type .",
    "for example , if we are given the following declaration for binary tree ( written here in @xmath3prolog syntax ) ,        abstract interpretation @xcite can associate to a program an approximation to its semantics .",
    "such approximations can help to determine various kinds of properties of programs .",
    "it will be interesting to see how well the particular notions of collection analysis can be related to abstract interpretation .",
    "more challenging would be to see to what extent the general methodology described here  the substitution into proofs ( computation traces ) and use of linear logic  can be related to the very general methodology of abstract interpretation .",
    "i am grateful to the anonymous reviewers for their helpful comments on an earlier draft of this paper .",
    "this work was funded in part by the information society technologies programme of the european commission , future and emerging technologies under the ist-2005 - 015905 mobius project .",
    "this paper reflects only the author s views and the community is not liable for any use that may be made of the information contained therein .",
    "i.  cervesato , n.  a. durgin , p.  d. lincoln , j.  c. mitchell , and a.  scedrov .",
    "a meta - notation for protocol analysis . in r.",
    "gorrieri , editor , _ proceedings of the 12th ieee computer security foundations workshop  csfw99 _ , pages 5569 , mordano , italy , 2830 june 1999 .",
    "ieee computer society press .",
    "i.  cervesato and f.  pfenning . a linear logic framework . in _",
    "proceedings , eleventh annual ieee symposium on logic in computer science _ , pages 264275 , new brunswick , new jersey ,",
    "july 1996 .",
    "ieee computer society press .",
    "m.  v. hermenegildo , g.  puebla , f.  bueno , and p.  lpez - garca .",
    "integrated program debugging , verification , and optimization using abstract interpretation ( and the ciao system preprocessor ) .",
    ", 58(1 - 2):115140 , 2005 .",
    "d.  miller .",
    "the @xmath207-calculus as a theory in linear logic : preliminary results . in e.",
    "lamma and p.  mello , editors , _",
    "3rd workshop on extensions to logic programming _ , number 660 in lncs , pages 242265 , bologna , italy , 1993 .",
    "springer - verlag ."
  ],
  "abstract_text": [
    "<S> we consider approximating data structures with collections of the items that they contain . for examples , lists , binary trees , tuples , etc , </S>",
    "<S> can be approximated by sets or multisets of the items within them . </S>",
    "<S> such approximations can be used to provide partial correctness properties of logic programs . </S>",
    "<S> for example , one might wish to specify than whenever the atom @xmath0 is proved then the two lists @xmath1 and @xmath2 contain the same multiset of items ( that is , @xmath2 is a permutation of @xmath1 ) . </S>",
    "<S> if sorting removes duplicates , then one would like to infer that the sets of items underlying @xmath1 and @xmath2 are the same . </S>",
    "<S> such results could be useful to have if they can be determined statically and automatically . </S>",
    "<S> we present a scheme by which such collection analysis can be structured and automated . </S>",
    "<S> central to this scheme is the use of linear logic as a computational logic underlying the logic of horn clauses . </S>"
  ]
}