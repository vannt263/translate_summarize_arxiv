{
  "article_text": [
    "the main motivation for this paper comes from recent developments in knowledge representation , especially the appearance of a new generation of systems @xcite based on the so - called answer set programming ( asp ) paradigm @xcite .",
    "the emergence of these asp systems suggest that we need to revisit one of the basic issues in the foundations of asp , namely , how can we characterize what such asp systems can theoretically compute .    throughout this paper",
    ", we shall focus mostly on one particular asp formalism , specifically , the stable semantics for logic programs ( slp ) @xcite .",
    "we note that the underlying methods of asp are similar to those used in logic programming @xcite and constraint programming @xcite .",
    "that is , like logic programming , asp is a declarative formalism and the semantics of all asp systems are based on logic . like constraint programming , certain clauses of an asp program act as _ constraints_. there is a fundamental difference between asp programs and constraint logic programs , however .",
    "that is , in constraint programming , the constraints act on individual elements of herbrand base of the program while the constraint clauses in asp programs act more globally in that they place restrictions on what subsets of the herbrand base can be acceptable answers for the program .",
    "for example , suppose that we have a problem @xmath12 whose solutions are _ subsets _ of some herbrand base @xmath13 . in order to solve the problem",
    ", an asp programmer essentially writes a logic program @xmath14 that describes the constraints on the subsets of @xmath13 which can be answers to @xmath12 .",
    "the basic idea is that the program @xmath14 should have the property that there is an easy decoding of solutions of @xmath12 from stable models of @xmath14 and that all solutions of @xmath12 can be obtained from stable models of @xmath14 through this decoding . the program @xmath14 is then submitted to the asp engine such as _ smodels _",
    "@xcite , dlv @xcite or deres @xcite which computes the stable models of the program @xmath14 .",
    "thus the asp engine finds the stable models of the program ( if any exists ) and one reads off the solutions to @xmath12 from these stable models .",
    "notice that the idea here is that all solutions are equally good in the sense that any solution found in the process described above is acceptable .",
    "currently , the systems based on asp paradigm are being tested on the problems related to planning @xcite , product configuration @xcite , combinatorial optimization problems @xcite and other domains .",
    "it is a well - known fact that the semantics of existing logic programming systems such as prolog , mercury and ldl have serious problems , principally due to necessary compromises in the implementations .",
    "for instance , the unification algorithms used by most dialects of prolog do not enforce the occurs check and hence these systems can produce incorrect results @xcite .",
    "moreover , the processing strategies of prolog and similar languages have the effect that correct logic programs can be non - terminating @xcite .",
    "while good programming techniques can overcome these problems , it is clear that such deficiencies have restricted the appeal of the logic programming systems for ordinary programmers and system analysts .",
    "the promise of asp and , in particular , of slp and its extensions , such as disjunctive logic programming @xcite , is that a new generation of logic programming systems can be built which have a clear semantics and are easier to program than the previous generation of logic programming systems .",
    "in particular , both of the problems referred to above , namely , the occurs check problem and the termination problem , do not exist in slp .",
    "of course , there is a price to pay , namely , slp systems only accept programs without function symbols .",
    "consequently , one of the basic data structures used in prolog , the _ term _ , is not available in slp .",
    "thus slp systems require the programmer to explicitly construct many data structures .",
    "in slp programming , predicates are used to construct the required data structures and clauses that serve as constraints are used to ensure that the predicates behave properly with respect to semantics of the program .",
    "slp programs are always terminating because the herbrand base is finite and hence there are only a finite number of stable models .",
    "in addition , unlike the case of usual logic programming , the order of the clauses of the program does not affect the set of stable models of the program .",
    "finally the stable semantics of logic programs is well understood so that slp programs have clear semantics .",
    "the restriction that asp programs do not contain function symbols is crucial .",
    "first , it is well known that once one allows function symbols in a logic program @xmath14 , the herbrand base becomes infinite .",
    "moreover , the stable models of logic programs _ with _ function symbols can be immensely complex .",
    "for example , for stratified logic programs @xcite , the perfect model is the unique stable model of that program @xcite .",
    "apt and blair @xcite showed that perfect models of stratified logic programs capture precisely the arithmetic sets .",
    "that is , they show that for a given arithmetic set @xmath15 of natural numbers , there is a finite stratified logic program @xmath16 such that in the perfect model of @xmath16 , some predicate @xmath17 is satisfied by precisely the numbers in @xmath15 .",
    "this was the first result that showed that it is not possible to have meaningful practical programming with general stratified programs _ if we allow _ unlimited use of function symbols .",
    "the result of @xcite was extended in @xcite where blair , marek , and schlipf showed that the set of stable models of a locally stratified program can capture any set in the hyperarithmetic hierarchy .",
    "marek , nerode , and remmel @xcite showed that the problem of finding a stable model of a finite ( predicate ) logic program @xmath14 is essentially equivalent to finding a path through an infinite branching recursive tree .",
    "that is , given an infinite branching recursive tree @xmath18 , there is a finite program @xmath19 such that there is a one - to - one degree - preserving correspondence between the infinite paths through @xmath20 and the stable models of @xmath19 and , vice versa , given a finite program @xmath14 , there is a recursive tree @xmath21 such that there is one - to - one degree preserving correspondence between the stable models of @xmath14 and the infinite paths through @xmath21 .",
    "one consequence of this result is that the problem of determining whether a finite predicate logic program has a stable model is @xmath22-complete .",
    "more results on the structure of the family of stable models of programs can be found in @xcite .",
    "all the results mentioned in the previous paragraph show that the stable model semantics for logic programs admitting function symbols can be used practically , only in a very limited setting .",
    "xsb system attempts to do deal with this problem by computing only the well - founded semantics .",
    "when the well - founded semantics is total , the resulting model is the unique stable model of the program .",
    "unfortunately , the class of programs for which it succeeds is not intuitive @xcite .",
    "yet another attempt to return the power of function symbols to the language has been made in @xcite .",
    "the class of programs considered in @xcite allows one to express recursively enumerable sets , but not more complex sets so that , at best , one could get a more compact representation of problems solved with ordinary prolog .",
    "as stated above , asp systems propose a more radical solution to the problem of complexity of stable models of logic programs with function symbols , namely , abandoning function symbols entirely .",
    "once this is accepted , the semantics of a logic program @xmath14 can be defined in two stages .",
    "first , we assume , as in standard logic programming , that we interpret @xmath14 over the herbrand universe of @xmath14 determined by the predicates and constants that occur in @xmath14 .",
    "since the set of constants occurring in the program is finite , we can ground the program in these constants to obtain a finite propositional logic program @xmath23 .",
    "the stable models of @xmath14 are by definition the stable models of @xmath23 .",
    "the process of grounding is performed by a separate grounding engine such as _ lparse _ @xcite .",
    "the grounded program @xmath23 is then passed to an engine that computes stable models of propositional logic programs .",
    "it is then easy to check that the features of slp mentioned above , i.e. , the absence of occurs check and termination problems and the independence of the semantics from the ordering of the clauses of the program , automatically hold .",
    "that is , since grounding uses only very limited part of unification , the occurs check problem is eliminated .",
    "the space of candidates for stable models is finite and so there is no termination problem .",
    "finally , the stable semantics of propositional programs does not depend on the order of clauses .",
    "the language of logic programming without function symbols was studied by the database community with the hope that it could lead to new , more powerful , database language @xcite .",
    "this language is called @xmath1 and some database systems such as db2 implement the positive part of @xmath1 .",
    "the fact that admitting negation in the bodies of clauses leads to multiple stable models was unacceptable from the database perspective .",
    "hence the database community preferred other semantics for @xmath1 programs such as the well - founded semantics @xcite or the inflationary semantics @xcite .",
    "the main purpose of this paper is to revisit the question of what can be computed by logic programs without functions symbols under the stable model semantics .",
    "first , consider the case of finite propositional programs .",
    "here the situation is simple . given a set @xmath24 of propositional atoms , let @xmath25 be a finite antichain of subsets of @xmath24 , i.e. whenever @xmath26 , @xmath27 , then @xmath28 . then one can show that there is a logic program @xmath29 such that @xmath25 is precisely the class of all stable models of @xmath29 @xcite .",
    "moreover , the family of stable models of any program @xmath14 forms such an antichain .",
    "thus in the case of finite propositional logic programs , we have a complete characterization of the possible sets of stable models .",
    "however , this result by itself does not tell us anything about the uniformity and the effectiveness of the construction .",
    "the basic complexity result for slp propositional programs is due to marek and truszczyski @xcite who showed that the problem of deciding whether a finite propositional logic program has a stable model is @xmath0-complete . for @xmath1 ,",
    "an analogous result has been obtained in @xcite .    to precisely formulate our question about what can be computed by logic programs without functions symbols under the stable model semantics , we first need to recall the notion of _ search problem _ @xcite and of a _ uniform _ logic program @xcite .",
    "a search problem is a set @xmath30 of finite instances such that , given any instance @xmath31 , there is a set @xmath32 of solutions to @xmath30 for the instance @xmath33 .",
    "it is possible that for some instances @xmath33 , @xmath32 is the empty set .",
    "for example , the search problem may be to find hamiltonian paths in a graph .",
    "thus , the set of instances of the problem is the set of all finite graphs .",
    "then , given any instance , i.e. a graph @xmath34 , @xmath35 is the set of all hamiltonian paths of @xmath34 .",
    "we say that an algorithm solves a search problem @xmath30 if it returns a solution @xmath36 whenever @xmath32 is non - empty and it returns the string `` empty '' otherwise .",
    "we say that a search problem @xmath30 _ is in @xmath0 _ if there is such an algorithm which can be computed by a non - deterministic polynomial time turing machine .",
    "we say that search problem @xmath30 _ is solved by a uniform logic program _ if there exists a single logic program @xmath37 , a polynomial time extensional data base transformation function @xmath38 and a polynomial time solution decoding function @xmath39 such that for every instance @xmath33 in @xmath30 ,    1 .",
    "@xmath40 is a finite set of facts , i.e. clauses with empty bodies and no variables , 2 .",
    "whenever @xmath41 is non - empty , @xmath42 maps the set of stable models of the @xmath43 onto the set of solutions @xmath32 of @xmath33 and 3 .",
    "if @xmath41 is empty , then @xmath43 has no stable models .",
    "we note that decision problems can be viewed as special cases of search problems .",
    "schlipf @xcite has shown that the class of _ decision _ problems in @xmath0 is captured precisely by uniform logic programs .",
    "specifically he proved that a decision problem is solved by a uniform logic program if and only if it is in @xmath0 .",
    "an excellent review of the complexity and expressibility results for logic programming can be found in @xcite .",
    "the goal of this paper is to prove a strengthening of schlipf s result as well as prove a number of related facts .",
    "we will prove that schlipf s result can be extended to all @xmath0 _ search _ problems .",
    "that is , we shall show that there is a single logic program @xmath2 that is capable of simulating polynomial time nondeterministic turing machines in the sense that given any polynomial time nondeterministic turing machine @xmath3 , any input @xmath5 , and any run - time polynomial @xmath44 , there is a set of facts @xmath45 such that a stable model of @xmath46 codes an accepting computation of @xmath3 started with input @xmath5 that terminates in @xmath47 or fewer steps and any such accepting computation of @xmath3 is coded by some stable model of @xmath46 .",
    "this result will show that logic programs without function symbols under the stable model semantics capture all @xmath0-search problems of an @xmath0 search problem @xmath12 , there is a program @xmath48 and a polynomial time projection from the collection of stable models of @xmath48 to the set of solutions of @xmath33 .",
    "our result shows that this property holds in a stronger form .",
    "namely , there is a single program with a varying extensional database . ] .",
    "the converse implication , that is , a search problem computed by a uniform logic program @xmath14 is an @xmath0-search problem is obvious since one can compute a stable model @xmath3 of a program by first guessing @xmath3 and then doing a polynomial time check to verify that @xmath3 is a stable model of the program .",
    "in this section we shall formally introduce several notions that will be needed for the proof of our main result .",
    "the proof of our main result uses the basic idea used by cook @xcite in his proof of the @xmath0-completeness of the satisfiability problem .",
    "first , we introduce the set of logic programs that we will study .",
    "we will consider here only so called @xmath1 programs . specifically , a clause is an expression of the form @xmath49 where @xmath50 are atoms , possibly with variables and/or constants .",
    "here we abuse notation by writing @xmath51 to mean that the variables that occur in the predicate @xmath4 are contained in @xmath52 .",
    "a program is a finite set @xmath14 of clauses of the form ( [ eq.1 ] ) .",
    "we assume that the underlying language @xmath53 of any given program @xmath14 is determined by the constants and predicate symbols which occur in the program .",
    "thus the herbrand universe @xmath54 of @xmath14 is just the set of all constant terms occurring in @xmath14 and the herbrand base @xmath55 of @xmath14 is the set of all ground atoms of the language @xmath53 .",
    "since there are no function symbols in our programs , both the herbrand universe and the herbrand base of the program are finite .    a ground instance of a clause @xmath56 of the form ( [ eq.1 ] ) is the result of a simultaneous substitution of constants @xmath57 for variables @xmath52 occurring in @xmath56 . given a program @xmath14",
    ", @xmath58 is the propositional program consisting of all ground substitutions of the clauses of @xmath14 . given a propositional program @xmath14 and a set @xmath3 included in its herbrand base , @xmath55 , the gelfond - lifschitz transformation of @xmath14 relative to @xmath3 is the program @xmath59 arising from @xmath14 as follows .",
    "first , eliminate all clauses @xmath56 in @xmath14 such that for some @xmath60 , @xmath61 , @xmath62 .",
    "next , in any remaining clause , eliminate all negated atoms .",
    "the resulting set of clauses forms a program , @xmath59 , which is a horn program and hence it possesses a least model @xmath63 .",
    "we say that @xmath3 is a _ stable model of the propositional program _",
    "@xmath14 if @xmath64",
    ". finally , given any program @xmath14 with variables , we say that @xmath3 is a stable model of a program @xmath14 if @xmath3 is a stable model of the propositional program @xmath58 .",
    "a nondeterministic turing machine is a septuple of the form @xmath65 here @xmath66 is a finite set of states and @xmath7 is a finite alphabet of input symbols .",
    "we assume @xmath66 always contains two special states , @xmath67 , the start state , and @xmath68 , the final state .",
    "we also assume that there is a special symbol @xmath69 for `` blank '' such that @xmath70 .",
    "the set @xmath71 is the set of tape symbols .",
    "the set @xmath72 is the set of move directions consisting of the elements @xmath73 and @xmath74 where @xmath75 is the `` move left '' symbol , @xmath76 is the `` move right '' symbol and @xmath74 is the `` stay put '' symbol .",
    "the function @xmath77 is the transition function of the machine @xmath3 . here",
    "@xmath78 denotes the power set of the set @xmath79 .",
    "we can also think of @xmath80 as a 5-ary relation .",
    "thus we can represent the transition function of the machine @xmath3 as a collection of atoms describing 5-tuples .",
    "we assume @xmath3 operates on a one - way infinite tape where the cells of the tape are labeled from left to right by @xmath81 . to visualize the behavior of the machine @xmath3 , we shall talk about the read - write head of the machine . at any given time in a computation ,",
    "the read - write head of @xmath3 is always in some state @xmath82 and is reading some symbol @xmath83 which is in a cell @xmath84 of the tape .",
    "it then picks an instruction @xmath85 and then replaces the symbol @xmath4 by @xmath86 , changes its state to state @xmath87 , and moves according to @xmath88 .",
    "we assume that at the start of the computation of @xmath3 on input @xmath89 , cells @xmath90 contain the symbols @xmath91 respectively and all cells to the right of cell @xmath92 are blank .",
    "we do not impose ( as it is often done ) any special restrictions on the state of the tape and the position of the head at the end of computation .",
    "however , we assume that at the start of any computation , the read - write head is in state @xmath67 and is reading the symbol in cell 0 .",
    "suppose we are given a turing machine @xmath3 whose runtimes are bounded by a polynomial @xmath93 where each @xmath94 and @xmath95 .",
    "that is , on any input of size @xmath6 , an accepting computation terminates in at most @xmath10 steps .",
    "then any accepting computation on input @xmath5 can affect at most the first @xmath10 cells of the tape .",
    "thus in such a situation , there is no loss in only considering tapes of length @xmath10 .",
    "hence in what follows , one shall implicitly assume that the tape is finite .",
    "moreover , it will be convenient to modify the standard operation of @xmath3 in the following ways .",
    ". we shall assume @xmath96 for all @xmath97 .",
    "+ 2 . given an input @xmath98 of length @xmath6 , instead of immediately halting when we first get to the final state @xmath68 reading a symbol @xmath99",
    ", we just keep executing the instruction @xmath100 until we have completed @xmath10 steps .",
    "that is , we remain in state @xmath68 , we never move , and we never change any symbols on the tape after we get to state @xmath68 .",
    "+ the main effect of these modifications is that all accepting computations will run for exactly @xmath10 steps on an input of size @xmath6 .",
    "in this section , we shall describe the logic program @xmath2 and our extensional data base function @xmath45 described above .",
    "the key to our construction is the fact that at any given moment of time , the behavior of a turing machine @xmath3 depends only on the current state of tape , the position of the read - write head and the set of available instructions .",
    "our coding of turing machine computation reflects this simple observation .",
    "first , we define the language ( i.e. a signature ) of the program @xmath2 .",
    "the set of predicates that will occur in our extensional database are the following : + @xmath101 for `` @xmath15 is a time step '' , + @xmath102 for `` @xmath15 is a cell number '' , + @xmath103 for `` @xmath15 is a symbol '' , + @xmath104 for `` @xmath105 is a state '' , + @xmath106 for `` @xmath14 is the initial position of the read - write head '' , + @xmath107 for `` initially , the tape stores the symbol @xmath66 at the cell @xmath14 '' , + @xmath108 for `` the triple @xmath109 is an executable instruction when the read - write head is in state @xmath15 and is reading the symbol @xmath110 '' ( thus @xmath111 represents the five - place relation @xmath80 ) , + @xmath112 for `` @xmath15 is different from @xmath110 '' + @xmath113 for `` @xmath15 is equal to @xmath110 '' , + @xmath114 for `` @xmath110 is equal to @xmath115 '' , inequality symbol , @xmath116 and relation described by the successor function @xmath117 , instead of @xmath118 , and @xmath119 . ]    fix a nondeterministic turing machine @xmath120 , a run - time polynomial @xmath44 and an input @xmath121 of length @xmath6 .",
    "this given , we now define the extensional database @xmath122 .",
    "first , @xmath122 will contain the following the following set of constant symbols : + ( 1 ) @xmath123 , + ( 2 ) @xmath124 , for each @xmath125 ( note two constants @xmath67 ( for initial state ) , and @xmath68 ( for final state ) will be present in every extensional database ) , + ( 3 ) @xmath69 ( blank symbol ) and @xmath98 for each @xmath126 , and + ( 4 ) @xmath127 .",
    "+ we let @xmath128 consist of the following set of facts that describe the machine @xmath3 , the segment of integers @xmath129 and the initial configuration @xmath5 of the tape .    1 .   for each @xmath130 , the clause  @xmath131 belongs to @xmath132 2 .   for each @xmath133",
    ", the clause  @xmath134 belongs to @xmath132 3 .   for every pair @xmath135 and every triple @xmath136",
    ", the clause   @xmath137   belongs to @xmath132 4 .   for @xmath138 , the clause   @xmath139 belongs to @xmath132 5 .   for @xmath140 , the clause   @xmath141  belongs to @xmath132 6 .   for @xmath142 , the clause  @xmath143   belongs to @xmath132 7 .   for @xmath144 , the clause   @xmath145 belongs to @xmath132 8 .   for @xmath146 , the clause   @xmath147   belongs to @xmath132 9 .",
    "the clauses  @xmath148 , @xmath149 and @xmath150   belong to @xmath132 10 .",
    "the clause  @xmath151   belongs to @xmath132 11 . for all @xmath152 with @xmath153",
    ", the clause   @xmath154   belongs to @xmath132 12 . for all @xmath155",
    ", the clause   @xmath156   belongs to @xmath132    the remaining predicates of @xmath2 are the following : + @xmath157 for `` the tape stores symbol @xmath66 at cell @xmath14 at time @xmath20 '' , + @xmath158 for `` the read - write head reads the content cell @xmath14 at time @xmath20 '' , + @xmath159 for `` the read - write head is in state @xmath105 at time @xmath20 '' ( notice that we have both a unary predicate @xmath160 with the content consisting of states , and @xmath161 to describe the evolution of the machine ) , + @xmath162 for `` instruction @xmath163 belonging to @xmath164 has been selected for execution at time @xmath20 '' , + @xmath165 for `` instruction other than @xmath163 belonging to @xmath164 has been selected for execution at time @xmath20 '' , + @xmath166 for `` there is an instruction to be executed at time @xmath20 '' , + @xmath167 for `` computation successfully completed '' , and + @xmath168 , a propositional letter will be used whenever we write clauses acting as constraints .",
    "that is , the symbol @xmath168 will occur in the following syntactical configuration .",
    "@xmath168 will be the head of some clause , and the negation of @xmath168 will also occur in the body of that same clause .",
    "in such situation a stable model _ can not _ satisfy the remaining atoms in the body of that clause . ] .",
    "+ in the program @xmath2 , there should be no constants .",
    "for notational convenience , we will not be absolutely strict in this respect . that is , to simplify our presentation",
    ", we will use the constants 0 , @xmath68 , and @xmath67 in @xmath2 .",
    "these can easily be eliminated by introducing appropriate unary predicates . finally to simplify the clauses",
    ", we will follow here the notation used in the _ smodels _ syntax .",
    "that is , we will use @xmath169 as an abbreviation for @xmath170 . this given , we are now ready to write the program @xmath2 .    1 .",
    "our first four clauses are used to describe the position of the read - write head at any given time @xmath171 .",
    "( initial position of the read - write head ) + @xmath172 @xmath173 , @xmath174 2 .",
    "@xmath175 @xmath176 , @xmath177 , @xmath178 , + @xmath179 , @xmath180 @xmath181 @xmath159 , + @xmath182 @xmath183 , @xmath184 3 .   @xmath185 @xmath186 , @xmath176 , @xmath187 , @xmath178 , + @xmath179 , @xmath188 @xmath189 , @xmath181 @xmath159 , @xmath182 @xmath190 , @xmath191 , @xmath192 4 .",
    "@xmath185 @xmath186 , @xmath176 , @xmath187 , + @xmath179 , @xmath178 , @xmath193 , + @xmath159 , @xmath182 @xmath190 , @xmath194 2 .",
    "our next three clauses describe how the contents of the tape change as instructions get executed",
    "@xmath195 @xmath173 , @xmath196 , @xmath197 2 .",
    "@xmath198 @xmath186 , @xmath199 , @xmath187 , @xmath179 , @xmath178 , @xmath200 @xmath159 , @xmath182 + @xmath190 3 .",
    "@xmath201 @xmath186 , @xmath176 , @xmath196 , @xmath202 + @xmath203 @xmath204 3 .",
    "our next two clauses describe how the state of the read - write head evolves in time",
    "@xmath205 @xmath206 , @xmath207 , @xmath208 2 .",
    "@xmath209 @xmath186 , @xmath199 , @xmath179 , @xmath187 , + @xmath178 , @xmath210 @xmath159 , @xmath182 + @xmath190 4 .",
    "our next two clauses describe how we select a unique instruction to be executed at time @xmath20 .",
    "1 .   selecting instruction at step 0 .",
    "+ @xmath211 + @xmath212 , @xmath213 , + @xmath214 2 .",
    "selecting instruction at other steps .",
    "+ @xmath215 + @xmath216 + @xmath217 5 .",
    "our next set of clauses defines the @xmath218 predicate . here",
    "clauses ( 5.6 ) and ( 5.7 ) are designed to ensure that exactly one instruction is selected for execution at any given time @xmath20 .",
    "1 .   @xmath219 + @xmath220 @xmath221 @xmath222 + @xmath223 @xmath224 2 .",
    "@xmath219 + @xmath220 @xmath221 @xmath222 + @xmath223 @xmath225 3 .",
    "@xmath219 + @xmath220 @xmath221 @xmath222 + @xmath223 @xmath226 4 .",
    "@xmath219 + @xmath220 @xmath221 @xmath222 + @xmath223 @xmath227 5 .",
    "@xmath219 + @xmath220 @xmath221 @xmath222 + @xmath228 6 .",
    "the definition of the @xmath229 predicate . + @xmath230 + @xmath162 7 .",
    "the clause to ensure that there is an instruction to be executed at any given time .",
    "+ @xmath231 6 .",
    "constraints for the coherence of the computation process .",
    "1 .   when the task is completed .",
    "+ @xmath232 .",
    "2 .   the atom _ completion _ belongs to every stable model .",
    "+ @xmath233    notice that the program @xmath2 is _ domain - restricted _",
    "@xcite , that is , every variable in the body of a clause is bound by a positive occurrence of an extensional database predicate .",
    "this restriction does not limit the expressive power of such programs , but greatly reduces the work of the grounding engine @xcite .",
    "our first proposition immediately follows from our construction .    there is a polynomial @xmath234 so that for every machine @xmath3 , polynomial @xmath4 , and an input @xmath5 , the size of the extensional database @xmath45 is less than or equal to @xmath235 .",
    "we shall now prove that for any nondeterministic turing machine @xmath3 , runtime polynomial @xmath44 , and input @xmath5 of length @xmath6 , the stable models of @xmath236 encode the sequences of tapes of length @xmath10 which occur in the steps of an accepting computation of @xmath3 starting on @xmath5 and that any such sequence of steps can be used to produce a stable model of @xmath236 .",
    "[ propo - main ] the mapping of turing machines to datalog@xmath237 programs defined by @xmath238 has the property that there is a 1 - 1 polynomial time correspondence between the set of stable models of @xmath236 and the set of computations of @xmath3 of the length @xmath10 , starting on the tape corresponding to the input @xmath5 , and ending in the state @xmath68 .    proof : we first need to see what is a valid run of a machine @xmath3 that ends in the state @xmath68 . to this end",
    "let us define an _ instruction _ of the machine @xmath3 as a quintuple @xmath239 such that @xmath240 .",
    "a _ state of tape _ is a sequence @xmath105 of symbols of the length @xmath10 from alphabet @xmath241 .",
    "configuration _ is a triple @xmath242 where @xmath243 is an instruction @xmath239 , @xmath105 is a state of tape , and @xmath244 is an integer @xmath245 and such that @xmath246 .",
    "informally , @xmath244 is the index of the cell on which the read - write head is pointing at the time the configuration is observed and @xmath247 is the content of that cell . the _ coherence _",
    "condition @xmath248 says that the instruction @xmath243 is applicable at this moment .",
    "a _ one step - transition _ is a pair of configurations @xmath249 where @xmath250 and @xmath251 satisfy the following :    1 .",
    "@xmath252 ( i.e. in the transition we moved to the next state as required by @xmath243 ) , 2 .",
    "@xmath253 + ( i.e. the read - write head moved as required by the instruction @xmath243 ) , 3 .",
    "@xmath254 + ( i.e. the state of tape has been altered in just one place , namely @xmath244 and @xmath255 has been put there ) , and 4 .   @xmath256 .",
    "( i.e. the instruction @xmath60 is coherent with the cell observed by the read - write head ) .",
    "we write @xmath257 when @xmath56 and @xmath72 are configurations and @xmath258 is a one - step transition . a _",
    "run _ of a machine @xmath3 is a sequence of configurations @xmath259 such that    1 .",
    "@xmath260 ( that is the machine @xmath3 is in the start state @xmath67 , @xmath261 is the content of the cell @xmath262 , and the read - write head points to cell @xmath262 ) and 2 .   for all @xmath263 , @xmath264",
    ".    a _ valid run _ of the machine @xmath3 is a run where @xmath265 , @xmath266 .",
    "thus a valid run of @xmath3 is a run where the last state of the machine is @xmath68 .    for the rest of this proof",
    ", we shall only consider valid runs @xmath259 of @xmath3 such that @xmath267 where @xmath268 for @xmath269 and @xmath270 for @xmath271 .",
    "that is , we shall only consider valid runs of @xmath3 which start on an input @xmath121 of length @xmath6 .",
    "we will show that each such valid run determines a unique stable model of @xmath236 and conversely every stable model of the program @xmath236 determines such a valid run of @xmath3 .",
    "first , given a valid run @xmath272 of the machine @xmath3 , where for @xmath273 , @xmath274 , @xmath275 we define the set of atoms @xmath276 which consists of the union of sets of atoms @xmath277 where :    @xmath278    @xmath279    @xmath280    @xmath281    @xmath282 + @xmath283    @xmath284    @xmath285    we show that @xmath276 is a stable model of @xmath286 .",
    "indeed , after we ground @xmath236 and reduce it with respect to @xmath276 , it is straightforward to prove by simultaneous induction on @xmath273 that the least model of the reduct contains    1 .   for each @xmath273 , @xmath287",
    "exactly one atom of the form + @xmath288 and that this atom belongs to @xmath276 , 2 .   for each @xmath273 , @xmath289 all atoms @xmath290 with @xmath291 , where @xmath292 , and @xmath293 and that these atoms belong to @xmath276 , 3 .   for each @xmath273 and @xmath76 , @xmath274 , @xmath294 exactly one atom of the form",
    "@xmath295 that these atoms belong to @xmath276 4 .   for each @xmath273 ,",
    "@xmath287 exactly one atom of the form @xmath296 and that @xmath297 , 5 .   for each @xmath273 , @xmath287 exactly one atom of the form @xmath298 , and 6 .",
    "the atom _ completion_.    thus @xmath276 is a stable model of @xmath236 .",
    "moreover , it is clear that the mapping @xmath299 is an injection since two different valid runs @xmath300 and @xmath301 differ in some least place @xmath273 and , hence , the atoms of group @xmath302 involving the relational symbol _ instr _ at time @xmath273 must differ in @xmath276 and @xmath303 .",
    "conversely , suppose that @xmath304 is a stable model of @xmath236 .",
    "first observe that @xmath305 .",
    "that is , all the clauses that have @xmath168 in the head also have @xmath306 in the body . thus if @xmath307 , then there are no clauses with head @xmath168 in @xmath308 so that @xmath304 could not be a stable model . since , @xmath168 is not in @xmath304 , then it is easy to to see that clause ( 6.2 ) forces @xmath304 to contain the atom _",
    "completion_. since the only way to derive the atom _ completion _ is via clause ( 6.1 ) , it follows that @xmath304 must contain the atom @xmath309 for some symbol @xmath310 .",
    "similarly , by clause ( 5.7 ) , for every @xmath311 , it must be the case that @xmath312 must be in @xmath304 . since the only way to derive @xmath313 is via clause ( 5.6 )",
    ", it follows that for each @xmath311 , there must exist @xmath314 and @xmath88 such that @xmath315 .",
    "there can not be a time @xmath171 with @xmath311 such that there two different 6-tuples @xmath316 and @xmath317 such that both atoms @xmath318 and @xmath319 are in @xmath304 because then it follows from clauses ( 5.1)-(5.5 ) , that @xmath320 holds for all 5-tuples in @xmath321 such that @xmath322 .",
    "but then the only clauses that have @xmath318 in the head are the clauses in either ( 4.1 ) or ( 4.2 ) and all such clauses would all be eliminated in the construction of @xmath323 so that there could be no @xmath318 in @xmath304 .",
    "thus it follows that for each @xmath311 , there is a unique @xmath324 such that @xmath325 is in @xmath304 .",
    "it is then easy to check that our clauses in groups ( 1 ) through ( 4 ) ensure that the instructions @xmath326 determine a valid run of the turing machine @xmath3 started on input @xmath5 . in particular , for each @xmath311 , there is a unique position @xmath327 such that the atom @xmath328 is in @xmath304 and @xmath329 is the only state such that @xmath330 is in @xmath304 and @xmath331 is the only symbol such that @xmath332 is in @xmath304 .",
    "moreover it is easy to check that for each time @xmath311 and each cell @xmath333 , there is a unique symbol @xmath334 such that @xmath335 is in @xmath304 .",
    "it follows if we define the sequence @xmath336 so that for each @xmath311 , @xmath337 where    1 .",
    "@xmath338 and @xmath339 , 2 .",
    "@xmath340 and 3 .",
    "@xmath341 is the only @xmath244 such that @xmath342 ,    then @xmath343 is a valid run of @xmath3 . finally , it is easy to show by induction that @xmath344 .",
    "this , together with the fact that @xmath299 is one - to - one completes our argument .",
    "@xmath345    [ ff1 ]",
    "a search problem @xmath30 can be solved by means of a uniform logic program in slp if and only if @xmath30 is an @xmath0-search problem .    a _ supported model _ @xmath3 of a propositional logic program @xmath14 is a subset of the herbrand base of @xmath14 that is a fixed point of the one step provablility operator , @xmath21 associated with @xmath14 .",
    "that is , @xmath3 is a supported model of @xmath14 if and only if @xmath346 .",
    "thus a supported model @xmath3 consists precisely of heads of clauses with bodies satisfied by @xmath3 .    given a logic program @xmath14",
    "we say that @xmath3 is supported model of @xmath14 if and only if @xmath3 is a supported model of @xmath58 .",
    "[ ff2 ] for all @xmath3 , @xmath4 , and @xmath5 , @xmath3 is a supported model of @xmath236 if and only if @xmath3 is stable model of @xmath236 .",
    "proof : it is well known that for every program @xmath14 , every stable model of @xmath14 is a supported model of @xmath14 .",
    "for the other direction , suppose that @xmath347 and suppose that @xmath3 is a supported model of @xmath348 so that @xmath349",
    ". first we observe that @xmath168 can not be in @xmath3 .",
    "that is , all the clauses that have @xmath168 in the head also have @xmath306 in the body . thus if @xmath350 , then there are no clauses with head @xmath168 whose body is satisfied by @xmath3 and hence @xmath168 would not be in @xmath351 which would violate that our assumption that @xmath352 . since @xmath168 is not in @xmath3 , then it is easy to see that clause ( 6.2 ) forces @xmath3 to contain the atom _ completion _ since otherwise @xmath168 would be in @xmath351 . similarly , by clause",
    "( 5.7 ) , for every @xmath311 , it must be the case that @xmath312 must be in @xmath3 . since the only way to derive @xmath313 is via clause ( 5.6 )",
    ", it follows that for each @xmath311 , @xmath3 must satisfy the body of clause ( 5.6 ) where @xmath353 .",
    "thus there must exist @xmath314 and @xmath88 such that @xmath354 .",
    "we claim that there can not be a time @xmath171 with @xmath311 such that there two different 6-tuples @xmath316 and @xmath317 such that both atoms @xmath318 and @xmath319 are in @xmath3 .",
    "otherwise the clauses ( 5.1)-(5.5 ) would show that that @xmath355 for all 5-tuples in @xmath321 such that @xmath322 .",
    "but then the only clauses that have @xmath318 in the head are the clauses in either ( 4.1 ) or ( 4.2 ) and the body of all such clauses would not be satisfied by @xmath3 .",
    "hence there could be no @xmath318 in @xmath356 which would violate our assumption that @xmath349 .",
    "thus it follows that for each @xmath311 , there is a unique @xmath324 such that @xmath325 is in @xmath3 .",
    "we can then proceed exactly as in our proof of theorem [ propo - main ] to prove by induction that the fact @xmath349 implies that @xmath3 must be of the form @xmath276 where @xmath272 is a valid run of the machine @xmath3 started on input @xmath5 .",
    "thus @xmath3 must be a stable model of @xmath3 .",
    "@xmath357    lemma [ ff2 ] implies that analogue of corollary [ ff1 ] holds for supported logic programming , sulp .",
    "a search @xmath105 problem can be solved by means of a uniform logic program in sulp if and only if @xmath105 is an @xmath0-search problem .",
    "we can also prove similar results for default logic programs without function symbols with respect to nondeterministic turing machines with an oracle for 3-@xmath358 .",
    "[ thm - defo ] for each @xmath359 there is a default theory @xmath360 such that for every 3-sat oracle turing machine @xmath3 , every polynomial @xmath361 $ ] , and every finite input @xmath5 where @xmath362 , there is a polynomial - time one - to - one correspondence between the accepting computations of length @xmath10 of @xmath3 on input @xmath5 and the reiter extensions of the default theory @xmath363 .",
    "the proof of this result is more involved and requires additional technical means .",
    "it will be a subject of a separate publication .",
    "it follows from theorem [ thm - defo ] that a search problem @xmath105 can be solved by means of a uniform default logic program if and only if @xmath105 is in @xmath364 .",
    "a version of this result for decision problems has been proved in @xcite .",
    "the first author s research has been partially supported by the nsf grant iis-0097278 .",
    "the second author s research has been partially supported by the aro contract daad19 - 01 - 1 - 0724 .",
    "cmmt98 s.  abiteboul , r.  hull , and v.  vianu . .",
    "addison - wesley publishing company , 1995 .",
    "apt . logic programming . in _",
    "handbook of theoretical computer science _ , pages 475574 .",
    "elsevier , 1990 .",
    "apt and h.a .",
    "arithmetical classification of perfect models of stratified programs . , 12:117 , 1990 .",
    "apt , h.a .",
    "blair , and a.  walker . towards a theory of declarative knowledge . in _ foundations of deductive databases and logic programming _ , pages 89142 , morgan kaufmann , 1988 .",
    "apt and d. pedreschi .",
    "reasoning about termination of pure prolog programs . _ information and computation _",
    ", 106:109157 , 1994 .",
    "apt and a. pellegrini . on the occur - check free pure prolog programs .",
    "_ acm transactions on programming languages and systems _ , 16:687726 , 1994 .",
    "blair , w.  marek , and j.  schlipf .",
    "the expressiveness of locally stratified programs .",
    ", 15:209229 , 1995 .",
    "reasoning with infinite stable models .",
    "_ proceedings of international joint conference on artificial intelligence _ , pages 603608 , morgan kaufmann , 2001 .",
    "bowen and r.a .",
    "amalgamating language and metalanguage in logic programming . in : _",
    "logic programming , _",
    "pages 153172 , academic press , 1982 .",
    "m. cadoli , t. eiter , and g. gottlob .",
    "default logic as a query language .",
    ", 9:448463 , 1997 . m.  cadoli and l.  palipoli .",
    "circumscribing datalog : expressive power and complexity .",
    ", 193:215244 , 1998 .",
    "d. cenzer and j.b .",
    "@xmath365 classes in mathematics .",
    "_ handbook of recursive mathematics _ , pages 623821 , elsevier 1999 .",
    "p.  cholewiski , w.  marek , a.  mikitiuk , and m.  truszczyski .",
    "programming with default logic . 112:105146 , 1999 .",
    "p.  cholewiski , w.  marek , and m.  truszczyski .",
    "default reasoning system deres . in _ proceedings of fifth international conference on principles of knowledge representation and reasoning ( kr-96 ) _ , pages 518528 , morgan kaufmann , 1996 . s. cook . the complexity of theorem - proving procedures . in _ proceedings of third annual acm symposium on theory of computing",
    "_ , pages 151158",
    "e. dantsin , t. eiter , g. gottlob , and a. voronkov .",
    "complexity and expressive power of logic programming .",
    "_ acm computing surveys _ , 33:374425 , 2001 .",
    "p.m. dung and k. kanchanasut . on the generalized predicate completion of non - horn programs . in _ logic programming , proceedings of the north american conference_. pages 587603 , mit press , 1989 .",
    "t.  eiter , n.  leone , c.  mateis , g.  pfeifer , and f.  scarcello . a deductive system for non - monotonic reasoning . in _ proceedings of the 4th international conference on logic programming and nonmonotonic reasoning _ ,",
    "springer lecture notes in computer science 1265 , pages 363374 , 1997 .",
    "t.  eiter , n.  leone , c.  mateis , g.  pfeifer , and f.  scarcello . .",
    "in _ proceedings of sixth international conference on principles of knowledge representation and reasoning ( kr-98 ) _ , pages 406417 , morgan kaufmann , 1998 .",
    "garey and d.s . johnson . .",
    "freeman , 1979 .",
    "m.  gelfond and v.  lifschitz .",
    "the stable semantics for logic programs . in _ proceedings of the 5th international symposium on logic programming _ , pages 10701080 , mit press , 1988 .",
    "m.  gelfond and v.  lifschitz .",
    "classical negation in logic programs and disjunctive databases .",
    "_ new generation computing _ 9:365385 , 1991 .",
    "j.  jaffar and m.j .",
    "constraint logic programming : a survey .",
    ", 19(20):503581 , 1994 . v.  lifschitz .",
    "action languages , answer sets and planning . in _ the logic programming paradigm _ , pages 357373 , springer - verlag , 1999 .",
    "v.  lifschitz .",
    "answer set planning . in _ proceedings of the 5th international conference on logic programming and nonmonotonic reasoning _ ,",
    "springer lecture notes in computer science 1730 , pages 373374 , 1999 .",
    "w.  marek , a.  nerode , and j.  b. remmel .",
    "the stable models of predicate logic programs .",
    ", 21(3):129154 , 1994 .",
    "marek and j.  b. remmel . on the foundations of answer set programming . in _",
    "answer set programming : towards efficient and scalable knowledge representation and reasoning _ , pages 124131 , aaai press , 2001 .",
    "w.  marek and m.  truszczyski .",
    "autoepistemic logic .",
    ", 38:588619 , 1991 .",
    "marek and m.  truszczyski . , springer - verlag , 1993 .",
    "marek and m.  truszczyski .",
    "stable models and an alternative logic programming paradigm . in _ the logic programming paradigm _ , pages 375398 , springer - verlag , 1999 .",
    "k.  marriott and p.j .",
    "stuckey . .",
    "mit press , 1998 .",
    "i.  niemel .",
    "logic programs with stable model semantics as a constraint programming paradigm . in _ proceedings of the workshop on computational aspects of nonmonotonic reasoning _ , pages 7279 , 1998 .",
    "i.  niemel and p.  simons .",
    "efficient implementation of the well - founded and stable model semantics . in _ proceedings of joint international conference and symposium on logic programming _ , pages 289303 , mit press , 1996 .",
    "i.  niemel and p.  simons .",
    "smodels  an implementation of the stable model and well - founded semantics for normal logic programs \" , in _ proceedings of the 4th international conference on logic programming and nonmonotonic reasoning _ , springer lecture notes in computer science 1265 , pages 420429 , 1997 .",
    "t.  przymusiski . on the declarative semantics of deductive databases and logic programs . in _",
    "foundations of deductive databases and logic programming _ , pages 193216 , morgan kaufmann , 1988 .",
    "p.  rao , i.v .",
    "ramskrishnan , k.  sagonas , t.  swift , d.  s. warren , and j.  freire . : a system for efficiently computing well - founded semantics . in _ proceedings of the 4th international conference on logic programming and nonmonotonic reasoning _ ,",
    "springer lecture notes in computer science 1265 , pages 430440 , 1997 .",
    "j.  schlipf .",
    "the expressive powers of the logic programming semantics . , 51:6486 , 1995 .",
    "t. syrjnen , manual of lparse version 1.0 , http://saturn.tcs.hut.fi/software/smodels t.  soininen and i.  niemel . developing a declarative rule language for applications in product configuration . in _ proceedings of the first international workshop in practical aspects of declarative languages _ , pages 305319 .",
    "springer - verlag , 1999 .",
    "computer science press , 1988 .",
    "a.  van gelder , k.a .",
    "ross , and j.s .",
    "unfounded sets and well - founded semantics for general logic programs . , 38:620650 , 1991 ."
  ],
  "abstract_text": [
    "<S> schlipf @xcite proved that stable logic programming ( slp ) solves all @xmath0 decision problems . </S>",
    "<S> we extend schlipf s result to prove that slp solves all search problems in the class @xmath0 . </S>",
    "<S> moreover , we do this in a uniform way as defined in @xcite . </S>",
    "<S> specifically , we show that there is a single @xmath1 program @xmath2 such that given any turing machine @xmath3 , any polynomial @xmath4 with non - negative integer coefficients and any input @xmath5 of size @xmath6 over a fixed alphabet @xmath7 , there is an extensional database @xmath8 such that there is a one - to - one correspondence between the stable models of @xmath9 and the accepting computations of the machine @xmath3 that reach the final state in at most @xmath10 steps . </S>",
    "<S> moreover , @xmath8 can be computed in polynomial time from @xmath4 , @xmath5 and the description of @xmath3 and the decoding of such accepting computations from its corresponding stable model of @xmath9 can be computed in linear time . </S>",
    "<S> a similar statement holds for default logic with respect to @xmath11-search problems .    </S>",
    "<S> [ firstpage ]    answer set programming , turing machines , expressibility </S>"
  ]
}