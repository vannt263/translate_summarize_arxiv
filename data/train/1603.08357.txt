{
  "article_text": [
    "the connected component labeling ( ccl ) algorithm has been used to study image processing @xcite , applications in physics @xcite , percolation theory , and a problem involving porous rocks @xcite .",
    "the majority of ccl algorithms were designed for lattice environments , with only a few studies of ccl algorithms for non - lattice environments . in non - lattice environments ,",
    "the positions of the sites are arbitrary rather than being restricted to discrete points of a regular lattice .",
    "non - lattice environments exist not only in the percolation theory of disordered discs and spheres , but also in networks .",
    "the performance of a single cpu core remains almost unchanged from a decade ago .",
    "however , the number of cores has increased each year , and recent advances in application performance have been realized by exploiting such concepts as multiple cores and many threads .",
    "graphics accelerators are a common example of many - thread devices , having evolved into highly parallel threads with very high memory bandwidth , and research has clearly shown that they can dramatically improve computing performance .",
    "the most widely used programming model for accelerators is cuda @xcite , a parallel - computing platform and programming model developed by nvidia that is essentially c / c++ with several extensions that allow functions to be executed directly on the nvidia gpu .",
    "connected component labeling algorithms with a single gpu have been proposed by many researchers .",
    "the majority of those ccl algorithms have been designed for lattice environments , and use a two - stage approach that divides the lattice into sub - blocks that are independently treated and then merged . however , the sub - block decomposition is difficult in non - lattice environments .",
    "thus we need gpu - based ccl algorithms without a sub - block decomposition for computation in non - lattice environments .    here",
    "we describe several experiments on ccl algorithms with a single gpu and without the sub - block decomposition .",
    "@xcite proposed a ccl algorithm called  label equivalence  , and kalentev _ et al . _",
    "@xcite improved the label equivalence algorithm .",
    "both of these algorithms are realized by an iterative method of comparison with nearest - neighbor sites .",
    "more recently , the present author @xcite has also proposed a single gpu ccl algorithm that does not use conventional iteration .",
    "the computation times using this approach have proved to be about half those of the previous method @xcite for the application of the swendsen - wang multi - cluster spin - flip algorithm @xcite .",
    "the above described ccl algorithms focus on the case of square and simple cubic lattices , and the algorithm in @xcite is specialized to the case of square and simple cubic lattices . in this paper , we propose a generalized gpu - based ccl algorithm that can be applied to both various lattices and to non - lattice environments in a uniform fashion .",
    "this generalized method extends our recent gpu - based ccl algorithm @xcite , which does not use conventional iteration . to confirm the correctness and performance of this algorithm ,",
    "we deal with bond percolation problems .",
    "this paper is organized as follows : in section  2 , we briefly review the gpu - based ccl algorithm that serves as a starting point @xcite . in section  3 , we describe the new generalized algorithm . in section  4 ,",
    "we first show the result of the bond percolations for the honeycomb and triangle lattices to confirm the correctness .",
    "moreover , we adapt the generalized algorithm to bond percolation for the bethe lattice as a substitute for a network structure , and the resulting performance is described . finally , a summary and discussion are presented in section  5 .",
    "connected component labelling algorithms assign proper cluster labels to each site on the basis of local connection information .",
    "many ccl algorithms have been proposed by many researchers .",
    "the hoshen  kopelman algorithm @xcite and the ccl algorithm proposed by suzuki _",
    "_ @xcite are the best - known ccl algorithms that use a single cpu .",
    "the majority of ccl algorithms using a single cpu are specialized to the case of square and simple cubic lattices .",
    "moreover , those algorithms are realized by sequential computation .",
    "however , sequential algorithms can not be applied to gpu computation , and thus many ccl algorithms that use a single cpu can not be directly applied to gpu computation , so a suitable new algorithm is required .",
    "we briefly review the ccl algorithm without conventional iteration  @xcite .",
    "the cornerstone of this algorithm is the method of label reduction proposed by wende et al .",
    "@xcite ; the procedure is illustrated in fig .  1 of @xcite .",
    "the labeling consists of four steps : ( i ) initialization , ( ii ) analysis , ( iii ) label reduction , and ( iv ) analysis .",
    "this method does not require an iterative method of comparison with nearest - neighbor sites .",
    "the number of such comparisons in this method is 1 for a square lattice and 2 for a simple cubic lattice if periodic boundary conditions are not used . in the initialization function",
    ", a label is assigned to each site based on its connections : each site has @xmath0=\\textit{min}$ ] , where _ min _ is the lowest - numbered of the connected sites .",
    "the analysis function tracks the label from a given site to a new site determined by the value of the label at the given site .",
    "all sites have @xmath0=\\textit{label}\\mskip 2mu [ \\textit{label}\\mskip 2mu [ i]]$ ] calculated until _ label _",
    "remains unchanged . in the label reduction step ,",
    "we use algorithm  1 of @xcite on all sites .",
    "the reduction method is used in only one direction for square lattices and in only two directions for simple cubic lattices . to resolve conflicts in the label update process",
    ", the atomic function is used in algorithm  1 of @xcite , and each chain of labels , i.e. , @xmath1 $ ] , is constructed automatically .",
    "finally , the analysis function is executed again .",
    "the cluster labeling algorithm in @xcite uses a ` while ` loop within the label reduction step .",
    "however , the number of sites for which the ` while ` loop is executed in this step is kept to a minimum .",
    "example of the nearest - neighbor ( nn ) list for a complex network .",
    "the number at each site is the index , and each has a nn list . , width=453 ]     initialization step of the generalized algorithm .",
    "the left panel shows the state of the nn list in fig .",
    "[ fig : method1 ] .",
    "each site generates the residual list from the nn list by keeping only those neighbors that are numbered lower than the site .",
    "moreover , each site has had its label set to the lowest value in the residual list , @xmath0=\\textit{min}$ ] , and this number has been removed from the residual list .",
    "if there is no value in the residual list , each site is labeled with its site number , i.e. , @xmath0=i$ ] .",
    "the right panel is the state after the initialization step [ step ( i ) ] , , width=453 ]     label reduction step of the generalized algorithm .",
    "the left panel shows the state after the end of the first analysis step [ step ( ii ) ] .",
    "the right panel shows the state after label reduction [ step ( iii ) ] , in which each site is calculated using algorithm  1",
    ". , width=453 ]     final analysis step of the generalized algorithm .",
    "the left panel shows the state after the end of the label reduction step [ step ( iii ) ] .",
    "the right panel shows the state after the second analysis step [ step ( iv ) ] .",
    ", width=453 ]",
    "we now turn to the proposed algorithm .",
    "the algorithm in @xcite is specialized to the case of square and simple cubic lattices .",
    "we extend this algorithm of @xcite to the generalized algorithm .",
    "the proposed algorithm can be applied to both lattices and to non - lattice environments in a uniform fashion as long as a nearest - neighbor ( nn ) list is supplied .",
    "figure  [ fig : method1 ] presents an example of such a list .",
    "each site has a list of immediate neighbors . in this paper",
    ", we prepare the array of nn list in advance . the total size of nn list is equal to the product of the number of sites and the largest size of nn list in all sites , and each site gets access to a nn list as @xmath2,nn\\_list[i+n],nn\\_list[i+2n], ... $ ] , where n is the number of sites .",
    "the generalized ccl algorithm also consists of the same four steps : ( i ) initialization , ( ii ) analysis , ( iii ) label reduction , and ( iv ) analysis . in the initialization step ,",
    "we generate the residual lists from the nn list by keeping only those neighbors that are numbered lower than any given site .",
    "moreover , each site has its label set to the lowest site number in the residual list , @xmath0={min}$ ] , and this is removed from the residual list .",
    "if there is no number in the residual list , the site is labeled with its site number , i.e. , @xmath0=i$ ] .",
    "figure  [ fig : method2 ] shows an example of this procedure .",
    "the analysis function tracks the label from a given site to a new site determined by the value of the label at the given site .",
    "all sites have @xmath0=\\textit{label}\\mskip 2mu [ \\textit{label}\\mskip 2mu [ i]]$ ] calculated until _ label _",
    "remains unchanged . in the label reduction step",
    ", each site executes algorithm [ alg1 ] . in the label reduction step",
    ", the calculation at each site uses the pairs at each site and the remaining sites in the residual list .",
    "the label reduction method allows each chain of labels , i.e. , @xmath1 $ ] , to be constructed automatically .",
    "figure  [ fig : method3 ] illustrates this procedure . in fig .",
    "[ fig : method3 ] , we show the actual output of our algorithm for the complex network in fig .",
    "[ fig : method1 ] . finally , each site is assigned the proper cluster label by executing the analysis function again .",
    "the procedure is illustrated in fig .",
    "[ fig : method4 ] .    unlike the ccl algorithms using a single cpu , the label of the cluster is not given serially in this method .",
    "the label of each cluster depends on the minimum site number in each cluster",
    ". however , we can renumber the cluster labels to sequence labels by using the method shown in fig . 4 in @xcite , for example .",
    "as an application of the generalized ccl algorithm , we study bond percolation problems .",
    "bond percolation creates bonds between neighboring sites with probability @xmath3 . in bond percolation ,",
    "one considers whether there is a cluster that spans the entire lattice .",
    "if there is such a spanning cluster , the system is regarded as percolating .",
    "there is a threshold value @xmath4 that distinguishes percolating and non - percolating behavior .",
    "the probability that a spanning cluster is produced is zero for @xmath5 and is unity for @xmath6 as the system size approaches infinity .",
    "we test the correctness and performance of the proposed code on an nvidia titan x machine with the cuda version 7.5 compiler . for the random - number generator",
    ", we used the xorwow pseudorandom generator @xcite with double precision on the device api in the curand library @xcite .",
    "spanning probability for bond percolation on the honeycomb lattice.,width=302 ]     spanning probability for bond percolation on the triangle lattice.,width=302 ]     average computational time for a single realization on the honeycomb and triangle lattices for probabilities @xmath7 .",
    "we use the threshold value of @xmath8 for the honeycomb lattice and @xmath9 for the triangle lattice . , width=302",
    "]    we first deal with bond percolation on the honeycomb and triangle lattices to check the correctness of our algorithm . for the measured quantity , we use the spanning probability @xmath10 .",
    "figure  [ fig : probability_honeycomb ] shows the spanning probability @xmath10 for the honeycomb lattice , and fig .  [ fig : probability_triangle ] shows the spanning probability for the triangle lattice .",
    "the total lattice sizes @xmath11 are @xmath12 , @xmath13 , @xmath14 , and @xmath15 . from these figures",
    ", we can see that all curves intersect at one point . from the crossing point",
    ", we estimate the threshold value @xmath16 on the honeycomb lattice to be @xmath17 and the threshold value @xmath18 on the triangle lattice to be @xmath19 .",
    "these estimated values are compatible with the exact values from @xcite , namely @xmath8 and @xmath9 .",
    "those results show that our algorithm works well .",
    "secondly , we demonstrate the performance for bond percolation on the honeycomb and triangle lattices . we give a double logarithmic plot of the average computational times for a single realization for the honeycomb and triangle lattices in fig .",
    "[ fig : time_tri_honey ] . because the computational time is dependent on the probability @xmath3",
    ", we show the average computational times at the probabilities @xmath7 on these lattices .",
    "we use @xmath8 as the threshold value for the honeycomb lattice and @xmath9 as the threshold value for triangle lattice , and the total lattice sizes @xmath11 are @xmath12 , @xmath13 , @xmath14 , and @xmath15 . from fig .",
    "[ fig : time_tri_honey ] , we can see that the average computational time is proportional to the total lattice size for all probabilities .",
    "the computational times on each lattice when the probability is @xmath20 is the shortest of those probabilities .",
    "the computational time for the honeycomb lattice with @xmath21 when the probability is @xmath22 is 5.8 ms , and that for the triangle lattice with @xmath21 when the probability is @xmath23 is 7.2 ms .",
    "moreover , the computational time for the honeycomb lattice with @xmath21 when the probability is @xmath24 is about 1.4 times greater than when the probability is @xmath22 , and the computational time for the triangle lattice with @xmath21 when the probability is @xmath25 is about 1.7 times greater than when the probability is @xmath23 .",
    "the differences between the computational times for different probabilities are due to the increment in the size of the residual list , and the difference between the computational times on the two lattices is due to the coordination number .",
    "an example of one realization of the standard position on the bethe lattice with coordination number @xmath26 when the probability is @xmath27 .",
    "the number at each site is its index , and the connection between sites in the same cluster is represented by the same color .",
    ", width=302 ]     an example of one realization of the random position on the bethe lattice with coordination number @xmath26 when the probability is @xmath27 .",
    "the number at each site is its index , and the connection between sites in the same cluster is represented by the same color .",
    ", width=302 ]     average computational times for a single realization on the bethe lattice with coordination number @xmath26 for standard site positions and random site positions when the probability is @xmath7 .",
    ", width=302 ]    next , we deal with bond percolation on the bethe lattice as a substitute for a network structure .",
    "the bethe lattice is a connected cycle - free graph , where each site is connected to @xmath28 neighbors .",
    "the threshold value for bond percolation on the bethe lattice is related to the coordination number @xmath28 , and the threshold value of the bethe lattice with coordination number @xmath28 is @xmath29 .",
    "we usually give the site number starting from a center site , called the standard position in this paper .",
    "the generalized ccl algorithm is excellent with this numbering method because the remaining sites in the residual list for all sites become zero at all probabilities .",
    "thus , we deal with the two bethe lattices with coordination number @xmath26 .",
    "one is standard position , where the site numbers are given from a center site , and the other is random position , where the site numbers are given at random .",
    "figure  [ fig : bethe ] shows an example of one realization of standard position on the bethe lattice with coordination number @xmath26 when the probability is @xmath27 , and fig .  [ fig : bethe_random ] shows an example of one realization of random position on the bethe lattice with coordination number @xmath26 when the probability is @xmath27 .",
    "the threshold value of the bethe lattice with coordination number @xmath26 is @xmath30 .",
    "those examples are the results of the actual output .",
    "we examine the computational times of the generalized ccl algorithm for bond percolation on the two bethe lattices .",
    "figure  [ fig : time_bethe ] shows a double logarithmic plot of the average time required for one realization on the two bethe lattices when the probabilities are @xmath31 .",
    "we measure the average computational times for the total lattice sizes @xmath32 , and @xmath33 . in the case of standard position ,",
    "the computational times are almost independent of the probability , and the computational time is proportional to the total lattice size . in contrast , in the case of random position , the computational time is dependent on the probability .",
    "the computational times of the random position for the total lattice sizes @xmath34 are proportional to the total lattice sizes for all probabilities , and those for the total lattice sizes @xmath35 deviate from being proportional to the total lattice size at all probabilities .",
    "this change is related to the amount of l2 cache , which is 3 mb in the titan x. the computational time is shortest when the probability is @xmath20 .",
    "the computational time for random position with @xmath36 when the probability is @xmath20 is 7.1 ms , and that when the probability is @xmath37 is 21 ms .",
    "moreover , the computational time for random position with @xmath36 when the probability is @xmath38 is about 8.0 times greater than that for standard position with @xmath36 . because we give the site number at random , the remaining sites in the residual list for each site are also random .",
    "this randomness causes a load imbalance .",
    "thus , the computational times for random position are greater than those for standard position . however ,",
    "those results show that the generalized ccl algorithm can be applied directly to any structure without reordering .",
    "we have proposed a generalized gpu - based ccl algorithm that can be applied to both various lattices and to non - lattice environments . because the algorithm in @xcite is specialized to the case of square and simple cubic lattices ,",
    "we have extended our previous labeling algorithm @xcite , which does not use conventional iteration , to the generalized method .",
    "the proposed algorithm can be applied directly to any structure without reordering .",
    "we chose the bond percolation problem as a test application .",
    "we first dealt with bond percolation on the honeycomb and triangle lattices to confirm the correctness of our algorithm .",
    "we used the spanning probability as a measured quantity , and reproduced some well - known results .",
    "secondly , we showed the performance for bond percolation on the honeycomb and triangle lattices . because the computational time is dependent on the probability @xmath3 , we reported the average computational times for the probabilities @xmath7 the computational time for the honeycomb lattice with @xmath21 when the probability is @xmath20 is 5.8 ms , and that for the triangle lattice with @xmath21 when the probability is @xmath20 is 7.2 ms .",
    "finally , we dealt with bond percolation on the bethe lattice as a substitute for a network structure . because the remaining sites in the residual list for all sites become zero at all probabilities when we give the site numbers starting from a center site , we dealt with the two bethe lattices with coordination number @xmath26 .",
    "the computational times for random position , where the site numbers are given at random , are greater than those for standard position , where the site numbers are given from a center site , at all probabilities .",
    "however , the generalized ccl algorithm can be applied directly to any structure without reordering .",
    "we finally emphasize the efficiency of the proposed algorithm .",
    "this algorithm is very powerful ; it can be adapted both to a variety of lattices and to non - lattice environments in a uniform fashion as long as an nn list is supplied .",
    "that is , this algorithm can be adapted to any structure by simply replacing the nn list .",
    "moreover , this algorithm is suitable for the gpu architecture which the memory access latency can be hidden with calculations instead of big data caches .",
    "this algorithm is realized by indirect memory access and random memory access , and frequently cause the simultaneous update with atomic function .",
    "thus , this algorithm is unsuitable for the architecture of traditional multiprocessors because this algorithm can not be vectorized and frequently cause the cache coherence .",
    "we hope that many researchers show more interest in developing parallel algorithms from a standpoint of architecture .",
    "this work was supported by kakenhi grant 15k21623 from the japan society for the promotion of science .",
    "k. suzuki , i. horiba , n. sugie , fast connected - component labeling based on sequential local operations in the course of forward raster scan followed by backward raster scan , pattern recognition , 2000 . proceedings .",
    "15th international conference on , ( 2000 ) 434 - 437 .",
    "f. wende , t. steinke , swendsen - wang multi - cluster algorithm for the 2d/3d ising model on xeon phi and gpu , proceeding sc 13 proceedings of the international conference on high performance computing , networking , storage and analysis article no .",
    "83 ( 2013 ) ."
  ],
  "abstract_text": [
    "<S> we propose a generalized gpu - based connected component labeling ( ccl ) algorithm that can be applied to both various lattices and to non - lattice environments in a uniform fashion . </S>",
    "<S> we extend our recent gpu - based ccl algorithm without the use of conventional iteration to the generalized method . as an application of this algorithm </S>",
    "<S> , we deal with the bond percolation problem . </S>",
    "<S> we investigate bond percolation on the honeycomb and triangle lattices to confirm the correctness of this algorithm . </S>",
    "<S> moreover , we deal with bond percolation on the bethe lattice as a substitute for a network structure , and demonstrate the performance of this algorithm on those lattices .    </S>",
    "<S> connected component labeling , percolation theory , bethe lattice , parallel computing , gpu </S>"
  ]
}