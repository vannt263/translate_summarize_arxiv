{
  "article_text": [
    "[ sec : intro ] incremental solving has contributed to the success of sat technology and potentially yields considerable improvements in applications where sequences of related formulas are solved .",
    "the logic of quantified boolean formulas ( qbf ) extends propositional logic ( sat ) by explicit existential and universal quantification of variables and lends itself for problems within pspace . also for qbfs ,",
    "incremental solving has been successfully applied in different domains  @xcite .",
    "the development of sat and qbf solvers has been driven by competitive events like the sat competitions , qbf evaluations ( qbfeval ) , or the qbf galleries .",
    "these events regularly result in publicly available benchmarks submitted by the participants which help to push the state of the art in sat and qbf solving . in the past , the focus was on _ non - incremental _ sat solving , and the evaluation of _ incremental _ solvers does not readily benefit from competitions and available benchmark collections .    benchmarking incremental solvers",
    "requires to solve a sequence of related formulas . to this end , the formulas must be incrementally imported to the solver and solved by means of api calls .",
    "the api calls are typically generated by an application program , like a model checker or a formal verification or planning tool , for example , which tackles a problem by encoding it incrementally to a sequence of formulas . in order to compare different incremental solvers on that sequence of formulas ,",
    "the solvers must be tightly coupled with the application program by linking them as a library .",
    "hence benchmarking of incremental solvers relies on the application program used to generate the sequence of formulas which , however , often is not available . even if the application program is available , it has to be adapted to support different solvers , where each solver might come with its own api .",
    "further , the same sequence of formulas must be generated multiple times by the application program to compare different solvers .",
    "to remedy this situation , we present an approach to automated benchmarking of incremental sat and qbf solvers which decouples incremental sat / qbf solving from incremental generation of formulas using an application program .",
    "this is achieved by translating a sequence of related cnfs and qbfs in prenex cnf ( pcnf ) into api calls of incremental solvers .",
    "such a sequence might be the output of an application program or it was taken from existing benchmark collections .",
    "the formulas are then syntactically analyzed and instructions to incrementally import and solve them are generated . for cnfs ,",
    "the instructions are function calls in the ipasir api , which has been proposed for the incremental library track of the sat race 2015 . for pcnfs , the instructions correspond to calls of the api of the qbf solver @xmath0 , which generalizes ipasir and allows to update quantifier prefixes .",
    "the result of translating a sequence of formulas to solver api calls is a _",
    "standalone benchmarking program _ which replays the incremental solver calls .",
    "any incremental sat / qbf solver supporting the ipasir api or its qbf extension as implemented in @xmath0can be integrated by simply linking it to the program .",
    "this allows to compare different solvers independently from an application .    in some applications",
    ", the sequence of formulas depends on the used solver , e.g. , if truth assignments are used to guide the process .",
    "even then , our approach allows to compare different incremental solvers on the fixed sequences generated with one particular solver .",
    "however , then it is important to note that this comparison is limited to this particular fixed sequence , it would be unfair to conclude something about the performance of the solvers would they have been genuinely used within the application .",
    "this problem occurs also in sequences of formulas which are already present in benchmark collections . for experiments in this paper , we only considered applications where the sequences of generated formulas do not depend on intermediate truth assignments .",
    "as our approach is also applicable to already generated formulas that are part of existing benchmark collections , such collections become available to developers of incremental solvers .",
    "furthermore , comparisons between solvers in incremental and non - incremental mode are made possible .",
    "in addition , since the input for the benchmarking program describes only the differences between consecutive formulas , we obtain a quite succinct representation of incremental benchmarks .",
    "our approach to automated benchmarking of incremental sat and qbf solvers underpins the goal of the incremental library track of the sat race 2015 .",
    "we have generated benchmarks and submitted them to this competition .",
    "[ sec : bg ] we consider propositional formulas in cnf and identify a cnf with the set of its clauses .",
    "a sequence @xmath1 of formulas represents the formulas that are incrementally generated and solved by an application program .",
    "a qbf @xmath2 in prenex cnf ( pcnf ) extends a cnf @xmath3 by a quantifier prefix @xmath4 .",
    "the prefix @xmath5 of a qbf is a sequence of pairwise disjoint _",
    "quantified sets _ @xmath6 .",
    "a quantified set @xmath7 is a set of variables with an associated quantifier @xmath8 .",
    "we consider only closed pcnfs . for adjacent quantified sets @xmath6 and @xmath9 , @xmath10 .",
    "given a prefix @xmath11 , index @xmath12 is the _ nesting level _ of @xmath13 in @xmath4 .",
    "our automated benchmarking approach is based on _ solving under assumptions _  @xcite as implemented in modern sat  @xcite and qbf solvers  @xcite . when solving a cnf under assumptions ,",
    "the clauses are augmented with _",
    "selector variables_. selector variables allow for temporary variable assignments made by the user via the solver api .",
    "if the value assigned to a selector variable satisfies the clauses where it occurs , then these clauses are effectively removed from the cnf . this way , the user controls which clauses appear in the cnf in the forthcoming incremental solver run .",
    "the ipasir api proposed for the incremental library track of the sat race 2015 consists of a set of functions for adding clauses to a cnf and handling assumptions .",
    "a disadvantage of this approach is that the user has to keep track of the used selector variables and assumptions manually .    for incremental qbf solving ,",
    "additional api functions are needed to remove quantified sets and variables from and add them to a prefix . for qbf solvers ,",
    "we generate calls in the api of @xmath0which generalizes ipasir by functions to manipulate quantifier prefixes .",
    "additionally , it allows to remove and add clauses in a stack - based way by push / pop operations where selector variables and assumptions are handled internal to the solver and hence are invisible to the user  @xcite . for details on the ipasir and @xmath0interfaces",
    ", we refer to the respective webpages mentioned in the introduction .",
    "[ sec : workflow ] we present the workflow to translate a given sequence @xmath14 of related ( p)cnfs into a standalone benchmarking program which calls an integrated solver via its api to incrementally solve the formulas from @xmath15 up to @xmath16 :     first , the formulas in @xmath17 are analyzed and the syntactic differences between each @xmath18 and @xmath19 are identified .",
    "this includes clauses and quantified sets that have to be added or removed to obtain @xmath19 from @xmath18 .",
    "also , variables may be added to or removed from quantified sets . for cnfs , the prefix analysis is omitted .",
    "the differences between the formulas identified in the first step are expressed by generic update instructions and are written to a file .",
    "a clause set is represented as a stack which can be updated via push and pop operations .",
    "the update instructions for quantifier prefixes are adding a quantified set at a nesting level and adding new variables to quantified sets already present in the prefix .",
    "unused variables are deleted from the prefix be the solver .",
    "files that contain generic update instructions are then interpreted by a _",
    "benchmarking program _ which translates them into calls of the ipasir api ( for cnfs ) or qbf solver calls ( for pcnfs ) . for the latter",
    ", calls of @xmath0 s api are generated .",
    "the benchmarking program is standalone and independent from the application program used to generate @xmath17 .",
    "it takes the files containing the generic update instructions as the only input .",
    "multiple solvers may be integrated in the benchmarking program by linking them as libraries .",
    "files containing the update instructions can serve as standardised benchmarks for incremental sat and qbf solvers .    [ [ sec : analyze : cnfs ] ] analyzing cnfs .",
    "+ + + + + + + + + + + + + + +    the algorithm to analyze sequences @xmath20 of clause sets relies on a stack - based representation of @xmath21 which allows for simple deletion of clauses that have been added most recently .",
    "a clause @xmath22 which appears in some @xmath21 and is removed later at some point to obtain @xmath23 with @xmath24 is called _ volatile in _ @xmath25 .",
    "a clause which appears in some @xmath21 for the first time and also appears in every @xmath23 with @xmath24 and hence is never deleted is called _ cumulative in _ @xmath25 .",
    "the algorithm to analyze sequence @xmath17 identifies volatile and cumulative clauses in all clause sets in @xmath17 .",
    "cumulative clauses are pushed first on the stack representing the current clause set because they are not removed anymore after they have been added .",
    "volatile clauses are pushed last because they are removed at some point by a pop operation when constructing a later formula in @xmath17 . for illustration , consider the following sequence @xmath26 of clause sets @xmath27 along with their respective sets @xmath28 of cumulative clauses and sets @xmath29 of volatile clauses :    [ cols= \" < , < , < \" , ]     to illustrate our approach in the context of qbf solving , we consider the problem of _ verifying partial designs _ , i.e. , sequential circuits where parts of the specification are black - boxed . in recent work  @xcite",
    ", the question whether a given safety property can be violated regardless of the implementation of a black - box has been translated to qbfs which are solved incrementally by a version of the qbf solver @xmath30  @xcite .",
    "benchmarks are available from qbflib , however neither the solver used in  @xcite nor the application program used to generate sequences of qbfs are publicly available .",
    "marin et al .",
    "@xcite introduced two encoding strategies : forward incremental and backward incremental reasoning . in a nutshell ,",
    "the quantifier prefix is always extended to the right in the former approach , while it is extended to the left in the latter approach .",
    "both strategies yield the same sequences of formulas up to renaming  @xcite .",
    "we used the publicly available instances from the forward - incremental encoding without preprocessing to evaluate @xmath0 .",
    "instances from the backward - incremental approach are not publicly available .    table  [ tab : results - qbf ] shows the comparison between @xmath30and @xmath0 .",
    "runtimes are in seconds , @xmath31 is the index of the first satisfiable formula , to and mo refer to a timeout and memout , respectively .",
    "the maximal runtime of algorithm  [ alg : cumvol ] and  [ alg : prefix ] was 95 seconds .",
    "runtimes for @xmath30 in table  [ tab : results - qbf ] are the ones reported in  @xcite . there , experiments were carried out on an amd opteron 252 processor running at 2.6 ghz with 4 gb of main memory and a timeout of 7200 seconds .",
    "experiments for @xmath0 were performed on a 2.53 ghz intel core 2 duo processor with 4 gb of main memory with os x 10.9.5 installed .",
    "thus runtimes are not directly comparable because experiments were carried out on different machines , they give , however , a rough picture of how the solvers relate . like @xmath30 , @xmath0benefits from the incremental strategy on most instances .",
    "the backward - incremental strategy is clearly the dominating strategy for @xmath30 .",
    "a quite eye - catching observation is that forward - incremental solving , while hardly improving the performance of @xmath30compared to the non - incremental approach , works quite well for @xmath0 .",
    "[ sec : concl ] we presented an approach to automated benchmarking of incremental sat and qbf solvers by translating sequences of formulas into api calls of incremental sat and qbf solvers executed by a benchmarking program .",
    "several incremental solvers may be tightly integrated into the benchmarking program by linking them as libraries .",
    "thus , we decouple the generation of formulas by an application from the solving process which is particularly relevant when application programs are not available . additionally , we make sequences of formulas which already exist in public benchmark collections available for benchmarking and testing . we illustrated our approach to automated benchmarking of incremental sat and qbf solvers on instances from hardware verification problems . to improve the performance of incremental qbf solving on these problems , we want to integrate incremental preprocessing into @xmath0 . as shown in  @xcite , preprocessing potentially improves the performance of incremental workflows considerably .",
    "10 [ 1]`#1 `    audemard , g. , lagniez , j.m . ,",
    "simon , l. : improving glucose for incremental sat solving with assumptions : application to mus extraction . in : sat 2013 .",
    "lncs , springer ( 2013 )    biere , a. : picosat essentials .",
    "jsat 4(2 - 4 ) , 7597 ( 2008 )    biere , a. : lingeling essentials , a tutorial on design and implementation aspects of the the sat solver lingeling . in : pragmatics of sat ( pos ) workshop .",
    "epic series , vol .",
    "27 , p.  88 .",
    "easychair ( 2014 )    bloem , r. , egly , u. , klampfl , p. , knighofer , r. , lonsing , f. : sat - based methods for circuit synthesis . in : fmcad .",
    ". 3134 . ieee ( 2014 )    en , n. , srensson , n. : an extensible sat - solver . in : sat 2003 .",
    "lncs , vol .  6 , pp . 502518 .",
    "springer ( 2003 )    en , n. , srensson , n. : temporal induction by incremental sat solving .",
    "notes theor .",
    "89(4 ) , 543560 ( 2003 )    egly , u. , kronegger , m. , lonsing , f. , pfandler , a. : conformant planning as a case study of incremental qbf solving . in : aisc 2014 .",
    "lncs , vol . 8884 , pp .",
    "springer ( 2014 )    giunchiglia , e. , marin , p. , narizzano , m. : qube7.0 .",
    "jsat 7(2 - 3 ) , 8388 ( 2010 )    lagniez , j.m . , biere , a. : factoring out assumptions to speed up mus extraction . in : sat 2013 .",
    "lncs , vol . 7962 , pp .",
    "springer ( 2013 )    lonsing , f. , egly , u. : incremental qbf solving . in : cp 2014 .",
    "lncs , vol . 8656 , pp .",
    "514530 . springer ( 2014 )    marin , p. , miller , c. , lewis , m.d.t . , becker , b. : verification of partial designs using incremental qbf solving . in : date .",
    ". 623628 .",
    "ieee ( 2012 )    miller , c. , marin , p. , becker , b. : verification of partial designs using incremental qbf . ai commun .",
    "28(2 ) , 283307 ( 2015 )    nadel , a. , ryvchin , v. , strichman , o. : ultimately incremental sat . in : sat 2014 .",
    "lncs , vol . 8561 , pp .",
    "springer ( 2014 )",
    "algorithm  [ alg : cumvol ] is totally correct with respect to the precondition that @xmath32 is a sequence of sets of clauses with @xmath33 and the postcondition that any @xmath28 , @xmath34 , contains the cumulative clauses of @xmath25 in @xmath17 , and any @xmath29 , @xmath35 , contains the volatile clauses of @xmath25 in @xmath17 .",
    "we show that the condition that any @xmath36 , @xmath37 , contains the cumulative clauses of @xmath38 in the subsequence @xmath39 of @xmath17 , and any @xmath40 , @xmath37 , contains the volatile clauses of @xmath38 in @xmath41 is an invariant of the main loop ( at line 2 ) .",
    "the invariant together with @xmath42 implies the postcondition as @xmath43 always contains those clauses that are in @xmath44 but not in @xmath45 , and @xmath46 always equals the empty set ( line 12 ) .",
    "likewise , the precondition implies the invariant since after line 1 , @xmath47 contains all clauses of @xmath48 that are not in @xmath49 and which are thus volatile in @xmath48 in the sequence @xmath50 , and @xmath51 contains all clauses which are in @xmath48 and @xmath49 and which are hence cumulative in @xmath48 in the sequence @xmath50 .",
    "it remains to show that if the invariant holds for some @xmath12 , @xmath52 at line 3 , then it holds for @xmath53 after executing lines 311 .",
    "after line 3 , @xmath29 contains all the clauses that are volatile in @xmath25 in @xmath54 .",
    "likewise , after line 4 , @xmath28 contains all the clauses that are in @xmath25 but not in @xmath55 and which are not volatile in @xmath25 , that is , which are cumulative in @xmath25 in @xmath54 .",
    "note that if a clause @xmath22 is volatile in some @xmath38 , @xmath56 , in @xmath41 , then @xmath22 is also volatile in @xmath38 in @xmath54 . on the other hand ,",
    "if a clause is cumulative in @xmath38 , it can be the case that @xmath22 becomes volatile in @xmath54 if @xmath57 .",
    "hence , it is possible that clauses that were previously classified as cumulative need to be reclassified .",
    "we make use of the following claim : after line 4 , a clause @xmath22 is in @xmath58 iff , for some @xmath56 , @xmath36 contains a clause @xmath22 that is volatile in @xmath54 .",
    "this claim is proven as follows : assume that for some @xmath56 , @xmath36 contains a clause @xmath22 that is volatile in @xmath54 . as the invariant holds for @xmath12 , @xmath59 , for all @xmath60 but @xmath57 and thus @xmath61 . clearly , @xmath62 . on the other hand ,",
    "assume some clause @xmath22 is in @xmath58 .",
    "clearly , @xmath61 implies @xmath63 .",
    "hence , as the invariant holds for @xmath12 , @xmath64 , for some @xmath56 , and , since @xmath61 , c is volatile in @xmath38 in @xmath54 .    by virtue of the above claim",
    ", @xmath58 contains precisely those clauses which need to be reclassified as volatile .",
    "after lines 6  11 , for each @xmath62 , the first ( and only ) @xmath36 with @xmath64 is found , and @xmath22 is removed from @xmath36 and added to all @xmath65 , @xmath66 . hence , after lines 3  11 , the invariant holds for @xmath53 .",
    "algorithm  [ alg : prefix ] works as follows . for",
    "each quantified set @xmath67 of @xmath68 , either it has one matching set @xmath69 in @xmath70 ( lines 4 and 5 ) or it does not have a matching quantified set in @xmath70 ( lines 7,8 , and 9 ) . in the former case , we need to add the atoms in @xmath67 to @xmath69 if they are not already there ( line 5 ) . in the latter case ,",
    "we need to add the entire set @xmath67 to the prefix ( line 9 ) .",
    "adding atoms and quantified sets is always done at the right nesting level @xmath71 .",
    "we store in @xmath72 the number of new quantified sets that have been added . at line 5 ,",
    "when adding atoms to a matching quantified set , @xmath71 is the nesting level of the matching quantified set in @xmath70 plus the number @xmath72 of previously added unmatched quantified sets . at line 9 , when adding an entire quantified set , @xmath71 is the nesting level of the quantified set that was modified last plus one .",
    "@xmath73 & @xmath74 & @xmath0 + 6s393r & 15 & 15 & 14 & 10 + 6s394r & 27 & 23 & 22 & 16 + 6s514r & 17 & 16 & 16 & 14 + arbi0s08 & 12 & 12 & 13 & 11 + arbi0s16 & 17 & 17 & 17 & 17 + arbixs08 & 9 & 10 & 10 & 10 + cuabq2f & 28 & 22 & 40 & 19 + cuabq2mf & 77 & 46 & 65 & 20 + cuabq4f & 21 & 22 & 26 & 15 + cuabq4mf & 25 & 23 & 40 & 16 + cuabq8f & 22 & 21 & 26 & 19 + cubak & 83 & 43 & 55 & 28 + cufq2 & 101 & 88 & 83 & 21 + cugbak & 38 & 32 & 42 & 21 + cuhanoi10 & 35 & 34 & 35 & 17 + cujc12 & 47 & 46 & 38 & 15 + cunim1 & 22 & 21 & 23 & 19 + cunim2 & 22 & 21 & 22 & 18 + cuom1 & 14 & 13 & 14 & 10 + cuom2 & 14 & 13 & 15 & 10 +   +       @xmath73 & @xmath74 & @xmath0 + cuom3 & 15 & 14 & 16 & 10 + cupts14 & 34 & 32 & 37 & 25 + cupts15 & 35 & 32 & 37 & 27 + cupts16 & 35 & 34 & 37 & 24 + cutarb16 & 52 & 37 & 48 & 30 + cutf1 & 44 & 32 & 35 & 21 + pdtfifo1to0 & 16 & 16 & 16 & 13 + pdtpmsdc16 & 28 & 19 & 30 & 15 +   + 6s188 & 39 & 34 & 36 & 33 + 6s24 & 25 & 23 & 27 & 20 + 6s270b1 & 51 & 13 & 51 & 11 + arbi0s32p03 & 32 & 32 & 33 & 32 + arbixs16p03 & 16 & 16 & 16 & 16 + bmhan1f1 & 29 & 21 & 29 & 19 + bobpcihm & 17 & 15 & 16 & 11 + bobsmvhd3 & 14 & 11 & 14 & 10 + cufq1 & 45 & 33 & 37 & 23 + cujc128 & 7 & 8 & 7 & 7 + cujc32 & 9 & 10 & 10 & 8 +   +"
  ],
  "abstract_text": [
    "<S> incremental sat and qbf solving potentially yields improvements when sequences of related formulas are solved . </S>",
    "<S> an incremental application is usually tailored towards some specific solver and decomposes a problem into incremental solver calls . </S>",
    "<S> this hinders the independent comparison of different solvers , particularly when the application program is not available . as a remedy , we present an approach to automated benchmarking of incremental sat and qbf solvers . given a collection of formulas in ( q)dimacs format generated incrementally by an application program </S>",
    "<S> , our approach automatically translates the formulas into instructions to import and solve a formula by an incremental sat / qbf solver . </S>",
    "<S> the result of the translation is a program which replays the incremental solver calls and thus allows to evaluate incremental solvers independently from the application program . </S>",
    "<S> we illustrate our approach by different hardware verification problems for sat and qbf solvers . </S>"
  ]
}