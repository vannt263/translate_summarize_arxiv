{
  "article_text": [
    "one way to interpret real - time communication is the assignment of particular importance to information flows in the time domain . in this case , the efficacy of data transfer is not measured in terms of raw communication throughput but it becomes dependent on the time instant the information is delivered .",
    "the increased interest in real - time communication comes at a time when the internet becomes a carrier of more time - sensitive information and a new generation of systems such as wireless sensor networks are deployed for the monitoring of time - critical physical environments .",
    "high data rate applications like video - on - demand and high quality interactive video communications also require timeliness guarantees .    in this paper , we investigate the communication of real - time messages through a queueing theory -based analysis .",
    "we aim at modeling the achievable timeliness benefits when packet skipping and network coding are employed at a router node .",
    "we initially model a network node , where data packets have to be serviced ( transmitted ) within a certain deadline , as a single - server queue . the queueing system is assumed to have an overwrite - buffer with space for one packet ; when a new packet bearing more recent data arrives to the queueing system , the buffered packet , if any , is discarded and the new packet is stored in the buffer . including the buffer space at the server , the system represents an m / m/1/2 queue with deadlines .    the model we consider provides significant insights into the impact of local decisions on the timeliness performance of simple networks .",
    "in particular , we show that the real - time goodput of the queueing system is improved when the system employs a policy where buffered packets are only served if the remaining time until their deadline ( i.e. their lead - time ) is larger than a certain threshold @xmath0 .",
    "the intuition behind this policy is that server capacity is not wasted on packets that have a low probability of being served before their deadline expires . by skipping service of the currently stored packet , and waiting for a new packet arrival instead ,",
    "goodput benefits are obtained because a newly arriving packet has a higher probability of meeting its deadline .    under the assumption that the service times of the single - server system are exponentially distributed",
    ", we derive an exact analytic expression for the goodput of the system with this thresholding policy .",
    "the exact goodput expression allows us to compute the optimal threshold , which gives insight into the maximum performance gain , as well as the parameter ranges for which the threshold policy provides effective performance benefits . in the second part of the paper ,",
    "the m / m/1/2 queueing system is extended with the ability to algebraically code packets ; with network coding , two data packets are transformed into one by a simple algebraic xor - operation .",
    "the coded packet is transmitted and the original native packets can be retrieved at their respective destination nodes through a similar xor - operation  @xcite . the idea of network coding has gained a lot of interest because of its potential to radically affect the way networks operate . when packets with timeliness restrictions undergo network coding , key qos parameters might be improved but also compromised .",
    "therefore , additional insight into the performance of systems with coding capability in the presence of timeliness requirements is needed .",
    "more specifically , it is critical to understand what is the impact of coding on packet delays and the interplay with the system goodput . in this part of the paper ,",
    "we model a router node to which packets from two flows arrive and must be forwarded .",
    "we provide a detailed derivation and exact expressions for the stationary real - time goodput of the router node in the presence of network coding .",
    "the analytical results obtained in this paper can be related qualitatively to our recent simulation - based study of the network coding and thresholding policy  @xcite .",
    "later , we will discuss aspects of these simulation results that can be related to this paper .",
    "the rest of this paper is organized as follows .",
    "section  [ section : deadlines ] provides background information on service models and the different types of deadlines that can be associated with real - time information .",
    "related work is presented in section  [ section : related - works ] . the system model adopted in this paper",
    "is presented in section  [ section : system - model ] . the analysis for packet",
    "skipping based on lead - time thresholding is described in section  [ section : analysis - thresholding ] .",
    "subsequently , the goodput analysis for a system with network - coded communication is developed in section  [ section : performanceanalysisnetworkcoding ] .",
    "section  [ section : joint ] looks at the joint modeling of skipping and network coding .",
    "finally , section  [ section : conclusions ] presents our conclusions and possible directions for future work .",
    "in queueing systems where packets are associated with deadlines , a service must usually either _ begin _ or _ end _ before a specific point in time . in the first case , services are usually non - preemptive ( i.e. , a service that has begun must be completed ) , while in the latter case , services are usually preemptive ( i.e. , a service that has begun can be aborted ) . in our case , the deadlines are to the end of service , but services are non - preemptive ; indeed , the information contained in a packet needs to be completely transmitted before the receiver node can decode the packet and use the information , thus the end - of - service nature of the deadlines . additionally , serving a packet in the context of wireless network communication consists of possibly contending for wireless channel access , and subsequent transmission of the packet bits . due to the layered communication architecture adopted in wireless networks",
    ", little control can be exerted on the channel contention mechanism once it is activated . the same holds for the physical transmission once it is started .",
    "kruk et al .",
    "@xcite furthermore consider three types of deadlines : hard , firm , and soft . with hard deadlines , a single packet that is not served before its deadline makes all other packets useless as well . with this type of deadlines",
    "all packets must thus be served before their deadlines , which requires a worst - case analysis . with firm deadlines , every packet that is not served before its deadline is useless , whereas with soft deadlines lateness is permitted and packets can still be used afterwards .",
    "we consider the case of firm deadlines , a natural choice that arises when looking at back - end applications requirements in systems such as sensor networks , where conclusions should be based on non - expired data but deadline misses can be tolerated .",
    "barrer  @xcite was one of the first to analyze a queue with deadlines .",
    "he studied an @xmath1 queue with deterministic deadlines .",
    "this analysis was extended to systems with state - dependent arrival and service rates , and more general deadlines by brandt and brandt  @xcite and by movaghar  @xcite .",
    "these studies all deal with non - preemptive systems with deadlines to service beginnings , but in  @xcite , movaghar considers deadlines to service endings with preemption .",
    "movaghar and kargahi  @xcite have devised an approximation for an @xmath1 queue with the earliest - deadline - first ( edf ) discipline , which is known to stochastically maximise the fraction of packets served before their deadline ( see , e.g. , @xcite ) .",
    "lehoczky  @xcite analyzed an @xmath1 queue with deadlines to service endings and the edf - policy in heavy traffic .",
    "he argued that , since the deadlines of all stored packets have to be taken into account , this queue gives rise to a markov process on a statespace of infinite dimension .",
    "lehoczky shows that the markov process collapses to a tractable one - dimensional process in heavy traffic .",
    "lehozcky later used these results to analyze control policies in  @xcite , and extended his analysis to jackson networks in  @xcite .",
    "doytchinov et al .",
    "@xcite extended this analysis to a @xmath2 queue with deadlines , and kruk et al .",
    "@xcite to networks of such queues .",
    "delay sensitive traffic in the presence of network coding was studied by parag et al . in  @xcite .",
    "the authors adopted a statistical qos measure that expresses the decay rate of the buffer at the middle node in a butterfly network .",
    "this router node is the bottleneck in the butterfly case , which explains the reasons why the authors focus on its buffer behavior .",
    "although this metric is enough for approximating the delivered qos per flow , it does not express it directly in terms of the achieved packet error rate and goodput .",
    "shah et al .",
    "@xcite start with the goal of minimizing the backlog of coded packets at receiving nodes .",
    "they design an online algorithm so that the linear packet combinations that are generated , are chosen in such a way that their actual span excludes any linear combination that is already known to the receivers .",
    "eryilmaz et al .",
    "@xcite studied the delay benefits of network coding in wireless multicast and multiple unicast scenarios .",
    "they presented a model that considers only a single - hop transmission and the random coding across packets from the same flow ( intra - session network coding ) .",
    "online network coding and delay minimization was more recently presented in  @xcite . a precise model is not presented in that work , although a simple delay analysis for the wireless channel with bernoulli erasures is performed .",
    "another interesting modeling work can be found in  @xcite where the authors used stochastic network calculus for calculating the throughput in a coded butterfly network .",
    "nevertheless , the model does not cover delay and timeliness aspects . a recent work from goseling et al .",
    "@xcite aims at modeling the performance of coded queueing systems . instead of focusing on providing exact expressions ,",
    "the authors provide bounds on the performance of a coded tandem queuing network with two independent flows .",
    "nevertheless , the extension of this work to packets with deadline requirements is not straightforward .",
    "for the analysis of packet skipping , we consider the single server queueing system depicted in fig .  [",
    "fig : model_sr ] .",
    "packets arrive according to a poisson process with parameter @xmath3 and have exponentially distributed service times with parameter @xmath4 .",
    "the system has an ` overwrite ' buffer with one buffer position ( not counting the packet in service , if there is one ) .",
    "if a packet arrives when there is already a packet in the buffer , the latter is overwritten ( i.e. , replaced ) by the newly arriving packet . the result is thus a modified version of an @xmath5 queueing system ( note that , in an @xmath6 system , the @xmath7 refers to the number of buffer positions , including the one in service ) .",
    "the same @xmath6 system is adopted for the analysis of network coding ; two input processes with parameters @xmath8 and @xmath9 are considered , as depicted in fig .",
    "[ fig : model_nc ] .",
    "the overall arrival process here is also a poisson process with parameter @xmath10 . in the network coding case ,",
    "when a packet is waiting in the buffer , a second packet arriving to the system is algebraically coded with the waiting packet instead of overwriting it , in case they belong to different flows .",
    "overwriting takes place when waiting packet and arriving packet belong to same flow , or when the buffer is already occupied by a coded packet .",
    "with network coding the coded packet is transmitted and the original native packets can be retrieved at their respective destination nodes through a similar algebraic xor operation  @xcite .",
    "we provide two scenarios where the above is possible . in the case of multicast transmission",
    "if each node has one of the two desired packets , they can both recover the other packet after the reception of the single xor - coded packet  @xcite .",
    "also a similar situation arises in the wireless bidirectional relay network where both nodes want to transmit to each other a packet they already have through an intermediate relay node  @xcite . in this case similarly , if the two nodes have packets @xmath11 and @xmath12 , with the transmission of a single coded packet @xmath13 from the relay they could both decode the opposite packet .",
    "the broadcast nature of the wireless medium allows this operation .",
    "a packet service is considered successful if it is _ completed _ within @xmath14 time units after the arrival of the packet to the queue , i.e. , if a packet arrives at time  @xmath15 , its service must end before its global deadline @xmath16 , with @xmath14 being a fixed relative deadline .",
    "services are non - preemptive , which means that if a packet starts service , its service has to be completed , before service on another packet can be started .",
    "we define the goodput of the system as the number of packets that are served successfully , i.e. within the deadline requirement , per unit of time .    in the packet skipping case",
    ", we introduce a threshold @xmath0 such that the packet in the buffer may only start service if its lead - time , i.e. the remaining time until its absolute deadline , is larger than @xmath0 .",
    "if the time until the deadline of the packet becomes smaller than @xmath0 , the packet is removed from the buffer .",
    "the idea behind this threshold is that if the deadline of a packet will be exceeded shortly , there is a large probability that the packet is not served in time .",
    "thus , the goodput of the system might be improved by waiting for another packet that has a higher probability of being served successfully .",
    "a packet whose deadline has expired is not served , both in the system that employs packet skipping and in the system that employs network coding .",
    "a coded packet is considered to be expired if the deadlines of both its underlying native packets are expired .",
    "this is implemented by setting the expiration deadline of a coded packet to that of the largest among the absolute deadlines of the underlying native packets that were coded together .",
    "note that the individual deadlines of the native packets are still the ones considered when calculating the goodput .",
    "therefore , a coded packet that completes service before its expiration deadline does not necessarily mean that the underlying native packet with the smallest deadline has been served on - time .",
    "also a packet that arrives to an empty system is always served . indeed , with fixed deadlines , for packet skipping",
    ", there is no gain in _ not _ serving packets arriving to an empty system and waiting for the next packet .",
    "after all , the next packet will have the same deadline , and hence the same probability of being served successfully .",
    "delaying the service of a packet arriving to an empty system might be proved to provide additional benefits in the network coding case , but was not considered in this work due to the additional analysis complexity it would engender .    ( 0,0 )  ( 1.5,0 )  ( 1.5,1 )  ( 0,1 ) ; ( 2.1,0.5 ) circle(0.5 cm ) ; ( -1,0.5 )  node[above]@xmath3 ( 0,0.5 ) ; ( 2.6,0.5 ) ",
    "node[above]@xmath4(3.6,0.5 ) ; ( 0.75,0.25 ) rectangle + ( 0.5,0.5 ) ; ( 1.85,0.25 ) rectangle + ( 0.5,0.5 ) ;    ( 0,0 )  ( 1.5,0 )  ( 1.5,1 )  ( 0,1 ) ; ( 2.1,0.5 ) circle(0.5 cm ) ; ( -1,0.7 )  node[above]@xmath8 ( 0,0.7 ) ; ( -1,0.2 )  node[below]@xmath9 ( 0,0.2 ) ; ( 2.6,0.5 ) ",
    "node[above]@xmath4(3.6,0.5 ) ; ( 0.75,0.25 ) rectangle + ( 0.5,0.5 ) ; ( 1.85,0.25 ) rectangle + ( 0.5,0.5 ) ;",
    "in this section , we compute the goodput of the system in the presence of packet skipping",
    ". it will be convenient to view the goodput as a function of the threshold @xmath0 , and we denote it by @xmath17 .",
    "furthermore , we denote by @xmath18 the number of packets present in the system ( including the server ) immediately before a packet arrival .",
    "a packet arriving to the system will find the latter in one of the following three states :    * _ empty ( l = 0 ) _ : the server is available , and there is no packet occupying the waiting buffer . * _ busy server ( l = 1 ) _ : the server is servicing a packet , but the waiting buffer is free .",
    "* _ full , ( l = 2 ) _ : the server is busy and the waiting buffer is occupied .",
    "in that case , the arriving packet overwrites the buffered one .",
    "[ theoremforreneging ] the goodput @xmath17 is given by @xmath19 ,                \\end{split}\\ ] ] where @xmath20 is the probability that an arbitrary packet arrives at an empty system .",
    "the goodput @xmath17 is by definition equal to the arrival rate times the probability that the service of an arbitrary packet is successful .",
    "to compute this probability , we condition on whether a packet arrives at an empty system or not . denoting by @xmath21 the service time that the arriving packet would experience ,",
    "we have : @xmath22    evaluating the probabilities and the integral indeed yields  .    the rationale behind eq .",
    "is as follows : if an arbitrary packet  @xmath23 arrives at an _ empty _ system , its service is successful if its service time @xmath21 is less than @xmath14 .",
    "this explains the term @xmath24 .",
    "if @xmath23 arrives at a _ non - empty _ system ( @xmath25 or @xmath26 ) , we condition on the length of the remaining ( residual ) service time  @xmath15 of the packet in service .",
    "the residual service time is exponentially distributed , so its density is @xmath27 .",
    "moreover , given that the residual service time is @xmath15 , the service of  @xmath23 is successful if the following three conditions are all met : first , the time until the deadline is larger than @xmath0 when the residual service ends , i.e. , @xmath28 .",
    "this is taken into account in the integration region of eq .",
    "( [ eq : gamma in p(l=0 ) ] ) .",
    "second , the service time is less than @xmath29 , which explains the factor @xmath30 .",
    "third , there were no other arrivals during @xmath15 time units , which explains the term @xmath31 .",
    "+ in order to determine @xmath32 , we introduce the concept of cycle time , which we define as the time between two consecutive moments at which the system becomes empty .",
    "the cycle time  @xmath33 consists of two parts : a part during which the system is empty , the ` idle time ' , and a part during which the system serves packets until it becomes empty again , the ` busy period ' .",
    "an illustration of a cycle is presented in fig .",
    "[ fig : cycle ] .    the busy period spreads throughout the time that the system is not in a state @xmath34 .",
    "it consists of a collection of consecutive states characterized by @xmath25 or @xmath26 .",
    "we shall refer to the case where @xmath26 during a busy period as _ clearance period _",
    "( @xmath35 ) , which is the amount of time the buffer is continuously occupied .",
    "a clearance period ends when the buffer is cleared , i.e. when either a dispatch to the server occurs , or when the stored packet is denied service and removed from the system following the thresholding procedure .",
    "the idle time lasts until a packet arrives , so the mean idle time is @xmath36 .",
    "denoting the busy period by @xmath37 , we have : @xmath38 = \\frac{1}{\\lambda } + \\operatorname{\\mathbb{e}}[bp].\\ ] ]    the pasta - property ( poisson arrivals see time averages , see  @xcite ) implies that the probability that a packet arrives at an empty system , @xmath39 , is given by the probability that the system is empty at an arbitrary time . a standard argument from renewal theory",
    "implies that the latter probability is given by the mean idle time divided by the mean cycle time : @xmath40 }      { \\ensuremath{\\mathbb{p}}}(l=0 ) = \\frac{1/\\lambda}{\\operatorname{\\mathbb{e}}[c ] } = \\frac{1/\\lambda}{1/\\lambda + \\operatorname{\\mathbb{e}}[bp]}.\\ ] ] the mean busy period is given by the following equation : @xmath41 in e[bp ] }      \\operatorname{\\mathbb{e}}[bp ] = \\frac{1}{\\lambda+\\mu}+\\frac{\\mu}{\\lambda+\\mu}\\cdot 0 + \\frac{\\lambda}{\\lambda+\\mu}\\left(\\operatorname{\\mathbb{e}}[t ] + \\operatorname{\\mathbb{e}}[bp]\\right),\\ ] ] where @xmath42 $ ] is the mean buffer clearance period",
    ". we will derive @xmath42 $ ] next .",
    ".   follows from a probabilistic argument : the busy period starts when a packet arrives to an empty system .",
    "after this , the expected time until the first event ( an arrival or service completion ) is @xmath43 .",
    "furthermore , with probability @xmath44 , the first event is a service completion , and the busy period ends after 0 additional time units . with probability @xmath45",
    ", the first event is an arrival . in this case , the arriving packet is stored in the buffer and the buffer has to be cleared , which takes in expectation an additional @xmath42 $ ] time units .",
    "once the buffer has been cleared , the expected time before the system becomes empty is again equal to @xmath46 $ ] due to the memorylessness of service times . evaluating   yields @xmath41 in e[t ] }      \\operatorname{\\mathbb{e}}[bp ] = \\frac{1}{\\mu } + \\frac{\\lambda}{\\mu } \\operatorname{\\mathbb{e}}[t].\\ ] ]    it thus remains to determine @xmath42 $ ] , the expected length of the buffer clearance period . without loss of generality , we assume that the buffer clearance period starts at time  0 . we condition on @xmath15 , the time at which the next event ( arrival or service completion ) occurs .",
    "because the time until the next event is exponentially distributed with parameter @xmath47 , we obtain : @xmath48 & = & \\int\\limits_{d-\\theta}^{\\infty } ( \\lambda+\\mu){e}^{-(\\lambda+\\mu)t}(d-\\theta ) dt \\\\",
    "& + & \\int\\limits_0^{d-\\theta } \\frac{\\mu}{\\lambda+\\mu}(\\lambda+\\mu){e}^{-(\\lambda+\\mu)t } t dt \\\\      & + & \\int\\limits_0^{d-\\theta } \\frac{\\lambda}{\\lambda+\\mu}(\\lambda+\\mu){e}^{-(\\lambda+\\mu)t}(t+\\operatorname{\\mathbb{e}}[t])dt .",
    "\\end{aligned}\\ ] ] the three integrals ( from left to right ) cover the following three possibilities : first , if there are no events before time @xmath49 , the buffer is cleared at time @xmath49 because the deadline of the buffered packet becomes smaller than @xmath0 .",
    "second , if the first event occurs at time @xmath50 , and the first event is a service completion , the buffer is cleared at time  @xmath15 because the buffered packet enters service .",
    "third , if the first event occurs at time @xmath51 and is a packet arrival , the arriving packet overwrites the buffered packet , and a new buffer clearance period begins .    after rewriting and evaluating the integrals ( the rightmost two using partial integration ) ,",
    "we obtain : @xmath52 }      \\operatorname{\\mathbb{e}}[t ] = \\frac{1-{e}^{-(\\lambda+\\mu)(d-\\theta)}}{\\mu + \\lambda { e}^{-(\\lambda+\\mu)(d-\\theta)}}.\\ ] ] combining eqs .  , , and   yields eq .  .",
    "if @xmath53 , deadlines become irrelevant and two special cases occur for specific values of @xmath0 . if @xmath54 , packets in the buffer are always served , regardless of the time until their deadline .",
    "the goodput of the system is thus equal to that in an @xmath5 queue , namely @xmath55 , with @xmath56 ( see e.g. , ( * ? ? ?",
    "* section  5.7 ) or   ( * ? ? ?",
    "* section  3.6 ) ) . if @xmath57 , packets in the buffer are never served .",
    "only packets arriving to an empty system are . in this case , the goodput is equal to that in an @xmath58 queue , namely @xmath59 . by substituting @xmath14 and @xmath0 , these values follow from eq .   as well .      in this section",
    ", we study the goodput numerically . in fig .",
    "[ fig : throughput mu = lambda = d=1 ] , we present @xmath17 for various values of @xmath0 , with @xmath60 .",
    "we clearly see that the goodput of the system is indeed increased by the threshold  @xmath0 , as long as @xmath0 is chosen appropriately .    having established that an appropriately chosen threshold increases goodput , we study _ how much _ the goodput can be increased by this threshold .",
    "note that @xmath61 is the goodput of the system without threshold .",
    "we define @xmath62 as the threshold that maximizes the relative increase in goodput , i.e. , we define @xmath63 we define the maximal goodput gain as the maximal relative increase in goodput , i.e. , as ( @xmath64 .    in the sequel , we fix @xmath65 .",
    "we can make this assumption without loss of generality ; all parameters are relative to each other , so for any set of parameters , we can scale time in such a way that @xmath65 without changing the goodput of the system .    in fig .",
    "[ fig : maximal gain up to 5 ] we display the maximal goodput gain for @xmath14 between 0 and  2 , and @xmath3 between 0 and  5 .",
    "fig  [ fig : maximal gain up to 5 ] implies that , in this parameter region , we can obtain an increase of up to @xmath66 in goodput by setting the threshold to its optimal value .",
    "furthermore , we see that the relative increase in goodput is maximal if @xmath67 , but even for larger values of @xmath14 there can be a goodput enhancement .",
    "in addition to this , the maximal goodput gain grows as @xmath3 grows , so the goodput policy is especially beneficial if the system is overloaded .    .",
    "]    likewise , in fig .",
    "[ fig : maximal gain up to 10 ] we show the maximal goodput gain for @xmath3 up to 10 . in this region ,",
    "the increase in goodput can be as much as @xmath68 .",
    "furthermore , the value of @xmath14 with the largest relative increase in goodput , as well as the range of @xmath14 for which gain is achieved become smaller .",
    "this is conveyed by fig .",
    "[ fig : goodput different rates ] , which plots the gain for three increasing values of @xmath3 , equal to 3 , 4 and 6 . the narrower range of @xmath14 where gain is achieved is explained by a shorter sojourn time of buffered packets that later enter service , due to more frequent buffer overwriting for an increasing arrival rate .",
    "the shorter sojourn time reflects itself in a larger lead - time when the buffered packet is assessed , by the packet skipping component , for dispatch to the server .",
    "this in turns presents itself in a decrease of the upper value of @xmath14 for which packet skipping still results in service denials for some packets , and as such , still results in goodput gain .    . ]",
    "values equal to 3 , 4 and 6 . ]    finally , we show values of the gain for specific values of @xmath3 and @xmath14 in table  [ tab : maximal gain values ] .",
    "we clearly see that , for this parameter region , the maximal goodput increase grows as @xmath3 becomes larger .",
    "furthermore , for a fixed @xmath3 , the maximal gain increases up to a certain value of @xmath14 , and decreases beyond that value .",
    ".the maximal goodput gain for specific values of @xmath3 and @xmath14 . [ cols=\"^,^,^,^,^,^,^ \" , ]",
    "in this part of the paper we focus our analysis on a router element r , to which two flows of packets arrive and need to be routed .",
    "the system model is depicted in fig .",
    "[ fig : model_nc ] .",
    "the router node is capable of opportunistically coding two native ( un - coded ) packets belonging to different flows , and transmitting the resulting coded packet instead of two native transmissions . for convenience ,",
    "we refer to packets of the first flow as type-1 packets , while those of the second flow are type-2 packets .",
    "a coded packet is referred to as type-3 .",
    "the sum of the two arrival rates @xmath69 and @xmath70 is denoted by @xmath3 .",
    "we shall restrict the analysis to one relative deadline @xmath14 value for both flows .",
    "this restriction neither impacts the quality nor the representativeness of the analysis .",
    "it is merely used to simplify the underlying presentation .",
    "the extension of our analysis to different deadline distribution is straightforward .",
    "we define the _ goodput of a flow _ as the number of packets of that flow that are served by the router within their deadline requirement , per unit of time . given the symmetry of the problem , we will concentrate our analysis on the goodput of type-1 packets .",
    "the analysis for packets of type-2 is identical .",
    "the state of the queueing system at the router is fully conveyed through the characterization of the status of its waiting buffer and the status of its server .",
    "two variables will be used to keep track of the system state : @xmath18 , already introduced in section  [ section : reneginggoodputanalysis ] , that defines the current number of packets in the system ( including a packet being served ) , and @xmath71 , that defines the type of the packet residing in the buffer , if any .",
    "knowledge of the type of a packet when it is in service is not required for the analysis .",
    "variable @xmath18 can take one of three values : 0 , 1 , or 2 .",
    "note that a coded packet is counted as a single packet in the system .",
    "variable @xmath71 can take one of three values : 1 ( packet in buffer is of type-1 ) , 2 ( packet in buffer is of type-2 ) , or 3 ( packet in buffer is a coded packet , type-3 )",
    ".    a packet of type-1 arriving to the system can find it in one of five states :    * _ empty ( l = 0 ) _ : the server is available , and there is no packet occupying the waiting buffer . * _ busy server ( l = 1 ) _ : the server is servicing a packet , but the waiting buffer is free . * _ full , type-1 packet in buffer ( l = 2 , n = 1 ) _ : the server is busy .",
    "the waiting buffer is occupied by a type-1 packet .",
    "* _ full , type-2 packet in buffer ( l = 2 , n = 2 ) _ : the server is busy .",
    "the waiting buffer is occupied by a type-2 packet . * _ full , type-3 packet in buffer ( l = 2 , n = 3 ) _ : the server is busy .",
    "the waiting buffer is occupied by a coded packet .",
    "[ theoremforcoding ] the goodput of type-1 packets is given by the following expression : @xmath72 where @xmath73 is the probability that the system is in state @xmath74 and @xmath75 is the probability that an arbitrary type-1 packet arriving to the system in state ( l = a , n = b ) meets its deadline",
    ".    follows a similar reasoning as the proof of theorem  [ theoremforreneging ] ; the goodput @xmath76 of type-1 packets is by definition equal to the probability that the service of an arbitrary packet of flow 1 is successful , i.e. meets its deadline . by the pasta property  @xcite , the probability that an arbitrary type-1 packet arrives to the system in state @xmath77 is equal to the steady - state probability that the system is in state @xmath77 .",
    "the overall service success probability is therefore given by summing , over the entire state space , the probability that the system is in state @xmath74 times the success probability conditioned on the occurrence of this state .",
    "finding @xmath76 amounts to finding the success probabilities per system state , @xmath75 , and the different state probabilities @xmath73 .",
    "we derive these probabilities in the following two subsections .",
    "we start by finding the probabilities @xmath75 that a packet of type-1 arriving to the system when it is in state @xmath74 is served by the router server and completes its service before the expiration of its deadline .",
    "the arrival of the packet is considered as time origin .",
    "therefore , the absolute deadline of the packet is equal to its relative deadline .",
    "a packet arriving to an empty system directly enters service .",
    "its success probability is equal to : @xmath78 which is equal to the probability that the service time it experiences is smaller than its deadline @xmath14 .      due to the overwrite property of the waiting buffer ,",
    "an arrival of a type-1 packet to a busy server state is identical to an arrival when the system is full and the buffered packet is of type-1 or type-3 . indeed , in all three cases , the newly arriving packet will occupy ( or overwrite ) the buffer and wait to be serviced .",
    "therefore @xmath79 and @xmath80 are both equal to @xmath81 , given by :    @xmath82    to derive eq .",
    ", we first condition on the length of the residual service time _",
    "t _ of the current packet in the server .",
    "being exponentially distributed , this residual service time has a density equal to @xmath27 .",
    "given that the residual service time is @xmath15 , a buffered packet is successfully serviced if all following conditions are met :    1 .",
    "the server becomes free before the deadline expiration of the buffered packet , i.e. , @xmath83 .",
    "the packet is not overwritten while waiting in the buffer .",
    "the service time of the packet is smaller than the remaining time the packet has until deadline expiration .",
    "condition 1 is accounted for in the integration region ( 0 to @xmath14 ) .",
    "condition 2 is met if and only if , starting from the arrival moment 0 of the buffered packet until the residual service time _",
    "t _ is completed , no new type-1 packet arrives and at most one arrival of type-2 occurs .",
    "indeed , the first arrival of a type-2 packet will not result in overwriting the buffered packet , since it will be coded with it ( resulting in a type-3 packet ) .",
    "any arrival of type-1 is not tolerated since it overwrites both a type-1 and a type-3 buffered packet .",
    "the term @xmath84 gives the probability that no type-1 arrivals occur during t. the term @xmath85 gives the probability that at most one type-2 arrival occurs .",
    "finally , condition 3 is met if the service time experienced by the packet is _ at most _ equal to the remaining time @xmath86 until deadline expiration .",
    "the term @xmath87 is equal to the probability that the service time is smaller than @xmath88 .",
    "if the type-1 packet arrives to a system where the waiting buffer is occupied by a type-2 packet , both packets will be coded together , resulting in a type-3 buffered packet .",
    "the success probability of the arriving packet is therefore equal to the probability that the resulting type-3 packet is served before the deadline @xmath14 of the arriving packet is expired .",
    "it is given by :    @xmath89    eq .",
    "differs from eq .   in that no arrival of type-2",
    "is allowed at all , throughout the whole sojourn time of the coded packet in the buffer .",
    "indeed , any type-2 arrival will overwrite the coded packet .",
    "this arrival restriction on type-2 packets is reflected in eq .   through the term @xmath90 .",
    "in order to determine the probabilities @xmath73 of finding the system in a particular state @xmath74 , we again make use of the notion of cycle time . for additional clarity of the following analysis ,",
    "the reader is referred to fig .",
    "[ fig : cycle ] .    the arrival that causes a state change from @xmath25 to @xmath26 ( i.e. that starts a clearance period )",
    "is referred to as _",
    "first arrival_. as a busy period might comprise multiple clearance periods , there can be multiple first arrivals during a busy period .",
    "note that the notion of a type-3 packet as first arrival is abstract in the sense that it does not occur in practice , but is introduced for analysis purposes .",
    "the idle time lasts from the moment the system becomes empty until the arrival of a packet of either type-1 or type-2 .",
    "therefore , the mean idle time is equal to @xmath91 .",
    "the mean busy period is the same as that given in eq .  , with @xmath3 equal to the sum of @xmath69 and @xmath70 .",
    "similarly , the expected length of the buffer clearance period , @xmath42 $ ] , is obtained from eq .   by setting @xmath0 to 0 . the mean cycle time",
    "@xmath92 $ ] is obtained as the sum of the mean idle time and the mean busy period .    as standard argument from renewal theory , the probability that the system is in a certain state is given by the mean time the system spends in this state during a cycle , divided by the mean cycle time .",
    "@xmath93 _ be the total time the system has a packet of type _",
    "i _ in the buffer during a cycle time . in other words",
    ", @xmath93 is the total amount of time the system is in state @xmath94 during a cycle .",
    "the system state probabilities are then obtained using :    @xmath95}{\\operatorname{\\mathbb{e}}[c]},\\ ] ]    @xmath96}{\\operatorname{\\mathbb{e}}[c ] } , \\text{and}\\ ] ]    @xmath97    to find @xmath98 $ ] , we define _ @xmath99 _ as the cumulative amount of time that the buffer is occupied by type - i packets during a clearance period , given that the _ first arrival _ of that clearance period was a type - j packet . the expected value of _",
    "@xmath93 _ is given by simply summing up the two different cases of packet types for the first arrival : @xmath100 & = & \\sum_{j=1}^2 \\frac{\\lambda_{j}}{\\lambda + \\mu}(\\operatorname{\\mathbb{e}}[t_{i , j } ] + \\operatorname{\\mathbb{e}}[c_{i}])\\nonumber\\\\      & = & \\sum_{j=1}^2 \\frac{\\lambda_{j}}{\\mu}(\\operatorname{\\mathbb{e}}[t_{i , j } ] ) .",
    "\\end{aligned}\\ ] ]    it now finally remains to find the expected values of the different @xmath99 .",
    "the expected value of @xmath101 is given by : @xmath102 & = \\int\\limits_{0}^{d }   ( \\lambda+\\mu){e}^{-(\\lambda+\\mu)t}\\left[\\frac{\\mu}{\\lambda+\\mu } t + \\frac {   \\lambda_{1}}{\\lambda+\\mu}\\left(e[t_{1,1}]+t\\right)\\right.\\\\    & \\left .",
    "+ \\frac{\\lambda_{2}}{\\lambda+\\mu}(e[t_{1,3}]+t ) \\right ] dt + d{e}^{-(\\lambda+\\mu)d}. \\end{split}\\ ] ] eq .   conveys the following : after the _ first arrival _ an event is bound to occur : either a service completion , or a new arrival .",
    "we condition on @xmath15 , the time at which the next event occurs .",
    "because of the memorylessness of the system , @xmath15 has density @xmath103 . with probability @xmath104 ,",
    "this event is a service completion , and the clearance period is equal to @xmath15 .",
    "with probability @xmath105 , the first event is a type-2 arrival . due to memorylessness",
    ", this can be seen as the beginning of a new clearance period with a type-3 arrival as _ first arrival _ ,",
    "i.e. , with expectation @xmath106 $ ] . however , up to time @xmath15 , there was a type-1 packet in the buffer , so the expected _ cumulative _ amount of time type-1 packets spend in the buffer is given by @xmath107 $ ] .",
    "with probability @xmath108 , the first event is a type-1 arrival .",
    "likewise , this can be seen as a new clearance period with a type-1 arrival as a _ first arrival _ ,",
    "i.e. , with expectation @xmath109 $ ] and cumulative amount of time equal to @xmath110 $ ] .",
    "finally , with probability @xmath111 , no event happens prior to the deadline expiration and subsequent removal of the type-1 first arrival . in that case",
    ", the buffer would have been occupied by this type-1 packet for an amount of time equal to @xmath14 .    likewise , the expected values of @xmath112 and that of @xmath113 are respectively given by :    @xmath114 =   \\int\\limits_{0}^{d }   & ( \\lambda+\\mu){e}^{-(\\lambda+\\mu)t } \\\\       & \\left[\\frac{\\lambda_{1}}{\\lambda+\\mu}e[t_{1,3 } ]   +   \\frac{\\lambda_{2}}{\\lambda+\\mu}e[t_{1,2}]\\right ] dt ,      \\end{split}\\ ] ]    @xmath115 = \\int\\limits_{0}^{d } & ( \\lambda+\\mu){e}^{-(\\lambda+\\mu)t } \\\\      & \\left[\\frac{\\lambda_{1}}{\\lambda+\\mu}e[t_{1,1 } ] + \\frac{\\lambda_{2}}{\\lambda+\\mu}e[t_{1,2}]\\right ] dt .",
    "\\end{split}\\ ] ]    let @xmath116 .",
    "the upper set of integrals results in the following set of three equations with three unknowns , which can be solved to find @xmath109 $ ] , @xmath117 $ ] and @xmath106 $ ] :    @xmath118 = \\alpha\\left[\\frac{1}{\\lambda + \\mu } + \\frac{\\lambda_{1}}{\\lambda + \\mu } e[t_{1,1 } ] +   \\frac{\\lambda_{2}}{\\lambda + \\mu } e[t_{1,3}]\\right]\\ ] ]    @xmath119 = \\alpha\\left[\\frac{\\lambda_{1}}{\\lambda + \\mu } e[t_{1,3 } ] +   \\frac{\\lambda_{2}}{\\lambda + \\mu } e[t_{1,2 } ] \\right]\\ ] ]    @xmath120 = \\alpha\\left[\\frac{\\lambda_{1}}{\\lambda + \\mu}e[t_{1,1 } ] +   \\frac{\\lambda_{2}}{\\lambda + \\mu } e[t_{1,2 } ] \\right]\\ ] ]    following a similar reasoning ,    @xmath121 = \\alpha\\left[\\frac{\\lambda_{1}}{\\lambda + \\mu } e[t_{2,1 } ] +   \\frac{\\lambda_{2}}{\\lambda + \\mu } e[t_{2,3}]\\right]\\ ] ]    @xmath122 = \\alpha\\left[\\frac{1}{\\lambda + \\mu } + \\frac{\\lambda_{1}}{\\lambda + \\mu } e[t_{2,3 } ] +   \\frac{\\lambda_{2}}{\\lambda + \\mu } e[t_{2,2 } ] \\right]\\ ] ]    @xmath123 = \\alpha\\left[\\frac{\\lambda_{1}}{\\lambda + \\mu}e[t_{2,1 } ] +   \\frac{\\lambda_{2}}{\\lambda + \\mu } e[t_{2,2 } ] \\right]\\ ] ]    and    @xmath124 = \\alpha\\left[\\frac{\\lambda_{1}}{\\lambda + \\mu } e[t_{3,1 } ] +   \\frac{\\lambda_{2}}{\\lambda + \\mu } e[t_{3,3}]\\right]\\ ] ]    @xmath125 = \\alpha\\left[\\frac{\\lambda_{1}}{\\lambda + \\mu } e[t_{3,3 } ] +   \\frac{\\lambda_{2}}{\\lambda + \\mu } e[t_{3,2 } ] \\right]\\ ] ]    @xmath126 = \\alpha\\left[\\frac{1}{\\lambda + \\mu } + \\frac{\\lambda_{1}}{\\lambda + \\mu}e[t_{3,1 } ] +   \\frac{\\lambda_{2}}{\\lambda + \\mu } e[t_{3,2 } ] \\right]\\ ] ]    once the different @xmath127 $ ] are found , they are used in eq .   to find the state probabilities @xmath128 . replacing the result of eqs .  ,  , and   along with the different conditional success probabilities ( eqs .  - ) into eq .",
    "yields the type-1 goodput of the system , which is a function of @xmath69 , @xmath70 , @xmath4 and d.     and @xmath70 when d = 1 . ]     between 0 and 5 and values of @xmath14 between 0 and 5 . ]     between 5 and 15 . ]      in this section , we study numerically the goodput gain of network coding relative to the no - coding base case .",
    "we are particularly interested in finding how much the goodput of real - time packets flows can be increased by applying network coding .",
    "we define @xmath129 as the total goodput of the router without coding , and @xmath130 as the total goodput of the router with coding .",
    "an important remark to be made here is that @xmath129 can be found using eq .  , by considering the existence of a single arriving flow instead of two , with parameter @xmath3 = @xmath69 + @xmath70 . in other words , @xmath131 we define the goodput gain as the relative increase in goodput , i.e. , as @xmath132 .    in the sequel ,",
    "we fix @xmath4 = 1 . fig .",
    "[ fig : gainfunctionlambda1lambda2 ] provides the goodput gain as a function of the arrival rates @xmath69 and @xmath70 , for @xmath14 equal to 1 .",
    "a major conclusion to be drawn here is that the gain provided by network coding is always maximized when @xmath69 is equal to @xmath70 .",
    "this result is logical , since equal arrival rates provide the most opportunities for coding .",
    "[ fig : gainlambda0to5deadline0to5 ] provides the maximal goodput gain for d between 0 and 5 , and @xmath3 between 0 and 5 . similarly , fig .",
    "[ fig : gainlambda5to15deadline0to5 ] provides the maximal goodput gain for the same range of deadlines and larger values of @xmath3 , between 5 and 15 .    for a fixed arrival rate @xmath3 , the gain increases for an increasing deadline value .",
    "a larger deadline provides a higher probability of success for coded packets , hence a positive return on applying network coding .",
    "similarly , for a fixed deadline @xmath14 , the gain increases for an increasing arrival rate ; this can be explained by the more efficient buffer usage that network coding provides ; in the base case , every arrival overwrites the buffer",
    ". the higher the arrival rate , the more frequent such overwritings occur . on the other hand , with network coding , an arrival of type-1 when the buffer is occupied by a type-2 packet , or vice - versa , does not result in an overwriting , but in a coding operation which maintains both packets . as shown in fig .",
    "[ fig : gainlambda0to5deadline0to5 ] , the gain provided by network coding remains limited in the operating region ( @xmath3 @xmath133 2 , @xmath14 @xmath133 1 ) , where low arrival rates limit the opportunities of coding , and the short deadlines causes most of the coded packets to miss their timeliness requirement anyway . finally , as conveyed in fig .",
    "[ fig : gainlambda5to15deadline0to5 ] , the gain of network coding for high arrival rates and large deadlines can reach up to 30% , a substantial improvement compared to the base case scenario .",
    "this result is important for highlighting the applicability of the proposed approach in more general networks .",
    "when the same network coding algorithm was employed for the transmission of real - time packets in a wireless multihop sensor network , the simulation results also showed a maximum performance of 30% for higher values of the traffic load and higher deadlines  @xcite .",
    "a reasoning along the lines of buffer usage efficiency also explains the difference in performance between packet skipping and network coding when the deadline value is increased . as already shown in fig .",
    "[ fig : maximal gain up to 5 ] and fig .",
    "[ fig : maximal gain up to 10 ] , the gain of packet skipping is limited to the smallest range of deadlines ( @xmath134 ) .",
    "in contrast , network coding provides increasing gain for an increasing deadline value , up to reaching a saturation value of 30% . for higher deadlines , lead - time thresholding basically allows any buffered packet to be serviced , thus providing no improvement in buffer usage . on the other hand ,",
    "the efficient usage of the buffer is maintained in the case of network coding , since coding operations are deadline - oblivious .",
    "the following section studies the performance benefits obtained when network coding and packet skipping are concurrently applied . with packet skipping enabled in a network coding setting , instead of removing a waiting packet only once its absolute deadline expires , lead - time thresholding with threshold @xmath0 is applied ; if the waiting packet is a native one ( a type-1 or type-2 packet ) , its lead - time is used in the thresholding procedure .",
    "if the waiting packet is a coded packet , the largest among the lead - times of the two underlying native packets is used .",
    "the goodput analysis for the joint coding - skipping approach is essentially identical to the analysis of the network coding goodput in section  [ section : performanceanalysisnetworkcoding ] .",
    "a number of equations are affected by the introduction of @xmath0 ; @xmath135 $ ] takes exactly the expression provided in eq .",
    ", in comparison to the simple network coding case where @xmath0 was set to 0 .",
    "the threshold @xmath0 is also introduced in the equations of @xmath136 and @xmath137 , resulting in :    @xmath138    @xmath139    note that the equations giving @xmath140 and @xmath141 remain identical to eq .  .",
    "finally , the threshold @xmath0 should be taken into account in all @xmath142 $ ] expressions ( eqs .  - ) , by setting @xmath143 to @xmath144 instead of @xmath145 .     between 0 and 5 ,",
    "achieved when adding skipping to network coding .",
    "]     up to 10 , achieved when adding skipping to network coding . ]    , between gain of skipping and the additional gain it provides when enabled concurrently with network coding . ]",
    "[ fig : comparisonrngandrngimpactincombinedlambdaequal5 ] and fig .",
    "[ fig : comparisonrngandrngimpactincombinedlambdaequal10 ] plot the _ additional _ gain of combining service skipping with network coding , relative to the gains enjoyed from network coding alone .",
    "the impact of packet skipping in a joint coding - skipping approach remains limited to the smallest range of deadlines , in accordance with the results for which only packet skipping was employed .",
    "however , we observe that the range where the performance of the joint system is noticeable , is smaller than the one of the packet skipping case . a snapshot of this difference can also be seen in fig .",
    "[ fig : rngvsrnginjointforlambda4 ] .",
    "this behavior is consistent with our simulation results in  @xcite where we observed that the additional gain from packet skipping was reaching at most 10 - 12% and for the lower regime of deadline values .",
    "this behavior puzzled us both in our analysis here and also in our simulations .",
    "but careful analysis reveals that when network coding is employed , our system naturally removes opportunities for skipping since many native packets , once coded , are transmitted even if they would have been normally dropped with thresholding .",
    "this situation is even more true for higher arrival rates since more packets are coded and they are replaced from the buffer faster . therefore , the opportunities that occur for efficient use of packet skipping become less as the arrival rate is increased .",
    "in this paper , we developed an analytical model that captures the impact of packet skipping and network coding on the delivery of real - time packets .",
    "first , we developed a model that considers only packet skipping for packets that have associated deadlines .",
    "we showed through the analytical model , that an optimal thresholding policy , when applied to the incoming packets at the router , can lead to goodput gains of up to 30% .",
    "subsequently we developed a model for the case where the router employs algebraic coding on the incoming packets .",
    "we showed that depending on the operating region , the gain of network coding can reach up to 30% .",
    "the ultimate objective of the paper was a router queueing system model that considers jointly network coding and packet skipping in the presence of per - packet deadlines .",
    "we provided exact expressions for the stationary goodput of the system and numerical results of the achievable goodput gain .",
    "employing packet skipping in addition to network coding adds up to 15% gain over the collected gains obtained from employing network coding exclusively .",
    "in addition to the novel approach that looks at network coding and packet skipping from a real - time perspective , our work intends to be a stepping stone for future research . among the topics we foresee as interesting are the qualitative and quantitative studies of network coding and packet skipping in more complex network topologies .",
    "furthermore , we will seek ways to translate some of the results and conclusions of this work to heuristic optimization algorithms for real - life wireless networks .",
    "m.  aoun , a.  argyriou , p.  van  der stok , performance evaluation of network coding service reneging in ieee 802.15.4-based wireless sensor networks , in : european conference on wireless sensor netoworks ( ewsn ) , 2011 .",
    "m.  kargahi , a.  movaghar , non - preemptive earliest - deadline - first scheduling policy : a performance study , in : ieee international symposium on modeling , analysis , and simulation of computer and telecommunication systems , georgia , atl , usa , 2005 , p. 201 - 210 .",
    "d.  shah , m.  mdard , j.  k. sundararajan , on queueing in coded networks ",
    "queue size follows degrees of freedom , in : ieee information theory workshop on wireless networks , solstrand , norway , 2007 , pp .",
    "j.  barros , r.  a. costa , j.  widmer , effective delay control for online network coding , in : ieee international conference on computer communications , joint conference of the ieee computer and communications societies ( infocom ) , rio de janeiro , brazil , 2009 , pp .",
    "208216 .",
    "k.  wu , w.  jia , y.  yuan , y.  jiang , performance modeling of stochastic networks with network coding , in : workshop on network coding , theory , and applications ( netcod ) , lausanne , switzerland , 2009 , pp .",
    "j.  goseling , r.  j. boucherie , j .- k .",
    "ommeren , energy consumption in coded queues for wireless information exchange , in : workshop on network coding , theory , and applications ( netcod ) , lausanne , switzerland , 2009 , pp ."
  ],
  "abstract_text": [
    "<S> we provide an analytical study of the impact of packet skipping and opportunistic network coding on the timely communication of messages through a single network element . in a first step , we consider a single - server queueing system with poisson arrivals , exponential service times , and a single buffer position . </S>",
    "<S> packets arriving at a network node have a fixed deadline before which they should reach the destination . to preserve server capacity , </S>",
    "<S> we introduce a thresholding policy , based on remaining time until deadline expiration , to decide whether to serve a packet or skip its service . </S>",
    "<S> the obtained goodput improvement of the system is derived , as well as the operating conditions under which thresholding can enhance performance . </S>",
    "<S> subsequently , we focus our analysis on a system that supports network coding instead of thresholding . </S>",
    "<S> we characterize the impact of network coding at a router node on the delivery of packets associated with deadlines . </S>",
    "<S> we model the router node as a queueing system where packets arrive from two independent poisson flows and undergo opportunistic coding operations . </S>",
    "<S> we obtain an exact expression for the goodput of the system and study the achievable gain . </S>",
    "<S> finally , we provide an analytical model that considers both network coding and packet skipping , capturing their joint performance . </S>",
    "<S> a comparative analysis between the aforementioned approaches is provided .    </S>",
    "<S> queueing model , network coding , packet skipping , real - time traffic , packet deadlines </S>"
  ]
}