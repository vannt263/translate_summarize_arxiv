{
  "article_text": [
    "delaunay triangulations and quadtrees are among the oldest and best - studied notions in computational geometry  @xcite , captivating the attention of researchers for almost four decades .",
    "both are proximity structures on planar point sets ; figure  [ fig : intro - qt+intro - dt ] shows a simple example of these structures . here , we will demonstrate that they are , in fact , equivalent in a very strong sense .",
    "specifically , we describe two algorithms .",
    "the first computes a suitable quadtree for @xmath0 , given the delaunay triangulation @xmath1 .",
    "this algorithm closely follows a previous result by krznaric and levcopolous  @xcite , who solve this problem in a stronger model of computation .",
    "our contribution lies in adapting their algorithm to the real ram / pointer machine model . for a description of different computational models . ]",
    "the second algorithm , which is the main focus of this paper , goes in the other direction and computes @xmath1 , assuming that a suitable quadtree for @xmath0 is at hand .",
    "the connection between quadtrees and delaunay triangulations was first discovered and fruitfully applied by buchin and mulzer  @xcite ( see also  @xcite ) . while their approach is to use a hierarchy of quadtrees for faster conflict location in a randomized incremental construction of @xmath1 , we pursue a strategy similar to the one by lffler and snoeyink  @xcite : we use the additional information to find a connected subgraph of @xmath1 , from which @xmath1 can be computed in linear deterministic time  @xcite . as in lffler and snoeyink  @xcite",
    ", our subgraph of choice is the _",
    "euclidean minimum spanning tree _ ( emst ) for @xmath0 , @xmath2  @xcite .",
    "the connection between quadtrees and emsts is well known : initially , quadtrees were used to obtain fast approximations to @xmath2 in high dimensions  @xcite . developing these ideas",
    "further , several algorithms were found that use the _ well - separated pair decomposition _ ( wspd )  @xcite , or a variant thereof , to reduce emst computation to solving the _",
    "bichromatic closest pair _ problem . in that problem , we are given two point sets @xmath3 and @xmath4 , and we look for a pair @xmath5 that minimizes the distance @xmath6  @xcite . given a quadtree for @xmath0 , a wspd for @xmath0 can be found in linear time  @xcite .",
    "emst algorithms based on bichromatic closest pairs constitute the fastest known solutions in higher dimensions .",
    "our approach is quite similar , but we focus exclusively on the plane .",
    "we use the quadtree and wspds to obtain a sequence of bichromatic closest pair problems , which then yield a sparse supergraph of the emst .",
    "there are several issues : we need to ensure that the bichromatic closest pair problems have total linear size and can be solved in linear time , and we also need to extract the emst from the supergraph in linear time . in this paper",
    "we show how to do this using the structure of the quadtree , combined with a partition of the point set according to angular segments similar to yao s technique  @xcite .",
    "our two algorithms have several implications for derandomizing recent algorithms related to dts .",
    "first , we mention _ hereditary _ computation of dts .",
    "et al . _",
    "@xcite show how to _ split _ a delaunay triangulation in linear expected time ( see also  @xcite ) .",
    "that is , given @xmath7 , they describe a randomized algorithm to find @xmath1 and @xmath8 in expected time @xmath9 . knowing that dts and quadtrees are equivalent , this result becomes almost obvious , as quadtrees are easily split in linear time .",
    "more importantly , our new algorithm achieves linear _ worst - case _ running time .",
    "et al . _",
    "@xcite use hereditary dts for _ self - improving algorithms _",
    ". together with the @xmath10-net construction by pyrga and ray  @xcite ( see  ( * ? ? ?",
    "* appendix  a ) ) , our result yields a deterministic version of their algorithm for point sets generated by a random source ( the inputs are probabilistic , but not the algorithm ) .",
    "eppstein _ et al . _",
    "@xcite introduce the skip - quadtree and show how to turn a ( compressed ) quadtree into a skip - quadtree in linear time .",
    "buchin and mulzer  @xcite use a ( randomized ) skip - quadtree to find the dt in linear expected time .",
    "this yields several improved results about computing dts .",
    "most notably , they show that in the _ transdichotomous _ setting  @xcite , computing dts is no harder than sorting the points ( according to some special order ) . here",
    ", we show how to go directly from a quadtree to a dt , without skip - quadtrees or randomness .",
    "this gives the first _",
    "deterministic _ transdichotomous reduction from dts to sorting .",
    "buchin _ et al . _",
    "@xcite use both hereditary dts and the connection between skip - quadtrees and dts to simplify and generalize an algorithm by lffler and snoeyink  @xcite to preprocess imprecise points for delaunay triangulation in linear expected time ( see also devillers  @xcite for another simplified , but not worst - case optimal , solution ) .",
    "lffler and snoeyink s original algorithm is deterministic , and the derandomized version of the buchin  _ et al . _  algorithm proceeds in a very similar spirit .",
    "however , we now have an optimal deterministic solution for the generalized problem as well .    in figure  [",
    "fig : diagram ] , we show a graphical representation of different proximity structures on planar point sets .",
    "the arrows show which structures can be computed from which in linear deterministic time on a pointer machine , before and after this paper .",
    "please realize that there are several subtleties of different algorithms and their interactions that are hard to show in a diagram , it is included purely as illustration of the impact of our results .",
    "the main result of our paper is an algorithm to compute a minimum spanning tree of a set of points from a given compressed quadtree .",
    "before we can describe this result in section  [ sec : qt->dt ] , we need to establish the necessary tools ; to this end we review several known concepts in section  [ sec : prelim ] and prove some related technical lemmas in section  [ sec : qt ] . in section  [ sec : dt->qt ] , we describe the algorithm to compute a quadtree when given the delaunay triangulation ; this is an adaptation of the algorithm by krznaric and levcopoulos  @xcite to the real ram model .",
    "finally , we detail some important implications of our two new algorithms in section  [ sec : applications ] .",
    "we review some known definitions , structures , algorithms , and their relationships .      given a set @xmath0 of @xmath11 points in the plane , an important and extensively studied structure is the _ delaunay triangulation _ of @xmath0  , denoted @xmath1 .",
    "it can be defined as the dual graph of the voronoi diagram , the triangulation that optimizes the smallest angle in any triangle , or in many other equivalent ways , and it has been proven to optimize many other different criteria  @xcite .",
    "the _ euclidean minimum spanning tree _ of @xmath0 , denoted @xmath2 , is the tree of smallest total edge length that has the points of @xmath0 as its vertices , and it is well known that the emst is a subgraph of the dt  ( * ? ? ? * theorem  7 ) . in the following",
    ", we will assume that all the pairwise distances in @xmath0 are distinct ( a general position assumption ) , which implies that @xmath2 is uniquely determined .",
    "finally , we remind the reader that @xmath2 , like every minimum spanning tree , has the following _ cut property _ : let @xmath12 a partition of @xmath0 , and let @xmath13 and @xmath14 be the two points with @xmath15 and @xmath16 that minimize the distance @xmath6 . then @xmath17 is an edge of @xmath2 . note that this is very similar to the bichromatic closest pair reduction mentioned in the introduction , but the cut property holds for any partition of @xmath0 , whereas the bichromatic closest pair reduction requires a very specific decomposition of @xmath0 into pairs of subsets ( which is usually not a partition ) .",
    "let @xmath0 be a planar point set .",
    "the _ spread _ of @xmath0 is defined as the ratio between the largest and the smallst distance between any two distinct points in @xmath0 .",
    "a _ quadtree _ for @xmath0 is a hierarchical decomposition of an axis - aligned bounding square for @xmath0 into smaller axis - aligned _ squares _",
    "regular _ quadtree is constructed by successively subdividing every square with at least two points into four congruent child squares .",
    "a node @xmath19 of a quadtree is associated with ( i ) @xmath20 , the square corresponding to @xmath19 ; ( ii ) @xmath21 , the points contained in @xmath20 ; and ( iii ) @xmath22 , the axis - aligned bounding square for @xmath21 .",
    "@xmath20 and @xmath22 are stored explicitly at the node .",
    "we write @xmath23 and @xmath24 for the diameter of @xmath20 and @xmath22 , and @xmath25 for the center of @xmath20 .",
    "we will also use the shorthand @xmath26 to denote the shortest distance between any point in @xmath27 and any point in @xmath20 .",
    "furthermore , we denote the parent of @xmath19 by @xmath28 .",
    "regular quadtrees can have unbounded depth ( if @xmath0 has unbounded spread so in order to give any theoretical guarantees the concept is usually refined .",
    "in the sequel , we use two such variants of quadtrees , namely _ compressed _ and _ @xmath18-cluster _ quadtrees , which we show are in fact equivalent .",
    "a _ compressed _ quadtree is a quadtree in which we replace long paths of nodes with only one child by a single edge  @xcite .",
    "it has size @xmath29 .",
    "formally , given a large constant @xmath30 , an @xmath30-compressed quadtree is a regular quadtree with additional _ compressed _ nodes .",
    "a compressed node @xmath19 has only one child @xmath31 with @xmath32 and such that @xmath33 has no points from @xmath0 .",
    "figure  [ fig : ex - compquad - notaligned ] shows an example .",
    "note that in our definition @xmath34 need not be aligned with @xmath20 , which would happen if we literally `` compressed '' a regular quadtree .",
    "this relaxed definition is necessary because existing algorithms for computing aligned compressed quadtrees use a more powerful model of computation than our real ram / pointer machine ( see appendix  [ app : models ] ) . in the usual applications of quadtrees , this is acceptable .",
    "har - peled  ( * ? ?",
    "* chapter  2 ) pointed out that some non - standard operation is _ inevitable _ if we require that the squares of the compressed quadtree are perfectly aligned .",
    "however , here we intend to derandomize algorithms that work on a traditional real ram / pointer machine , so we prefer to stay in this model .",
    "this keeps our results comparable with the previous work .",
    "now let @xmath18 be a large enough constant .",
    "a subset @xmath35 is a _ @xmath18-cluster _",
    "if @xmath36 or @xmath37 , where @xmath38 denotes the smallest axis - aligned bounding square for @xmath39 , and @xmath40 is the minimum distance between a point in @xmath41 and a point in @xmath4  @xcite . in other words , @xmath39 is a @xmath18-cluster precisely if @xmath42 is a @xmath43-_semi_-separated pair  @xcite .",
    "it is easily seen that the @xmath18-clusters for @xmath0 form a laminar family , i.e. , a set system in which any two sets @xmath41 and @xmath4 satisfy either @xmath44 ; @xmath45 ; or @xmath46 .",
    "thus , the @xmath18-clusters define a _",
    "@xmath18-cluster tree _",
    "figure  [ fig : ex - ccluster ] shows an example .",
    "these trees are a very natural way to tackle point sets of unbounded spread , and they have linear size .",
    "however , they also may have high degree . to avoid this",
    ", a @xmath18-cluster tree @xmath47 can be augmented by additional nodes , adding more structure to the parts of the point set that are not strongly clustered .",
    "this is done as follows .",
    "first , recall that a quadtree is called _ balanced _ if for every node @xmath48 that is either a leaf or a compressed node , the square @xmath27 is adjacent only to squares that are within a factor @xmath49 of the size of @xmath27 . for each internal node @xmath48 of @xmath47 with set of children @xmath50",
    ", we build a balanced regular quadtree on a set of points containing one representative point from each node in @xmath50 ( the intuition being that such a cluster is so small and far from its neighbors , that we might as well treat it as a point ) .",
    "this quadtree has size @xmath51 ( lemma  [ lem : c - cluster - qt ] ) , so we obtain a tree of constant degree and linear size , the _ @xmath18-cluster quadtree_. figure  [ fig : ex - cclusquad ] shows an example .",
    "the sets @xmath21 , @xmath20 and @xmath22 for the @xmath18-cluster quadtree are just as for regular and compressed quadtrees , where in @xmath21 we expand the representative points appropriately . note that it is possible that @xmath52 , but the points of @xmath21 can never be too far from @xmath20 . in section  [ sec : ccqt ]",
    "we elaborate more on @xmath18-cluster quadtrees and their properties , and in section  [ sec : compressed - c - cluster ] , we prove that @xmath18-cluster quadtrees and compressed quadtrees are equivalent ( theorem  [ thm : cluster - compressed - equiv ] ) .      for any two finite sets @xmath39 and @xmath50 , let @xmath53 .",
    "a _ pair decomposition _",
    "@xmath54 for a planar @xmath11-point set @xmath0 is a set of @xmath55 _ pairs _",
    "@xmath56 @xmath57 @xmath58 , such that ( i ) for all @xmath59 , we have @xmath60 and @xmath61 ; and ( ii ) for any @xmath62 , there is exactly one @xmath63 with @xmath64 .",
    "we call @xmath55 the _ size _ of @xmath54",
    ". fix a constant @xmath65 , and let @xmath66 .",
    "denote by @xmath38 , @xmath67 the smallest axis - aligned squares containing @xmath39 and @xmath50 .",
    "we say that @xmath68 is _ @xmath10-well - separated _ if @xmath69 , where @xmath70 is the distance between @xmath38 and @xmath67 ( i.e. , the smallest distance between a point in @xmath38 and a point in @xmath67 ) . if @xmath68 is not @xmath10-well - separated , we say it is _ @xmath10-ill - separated_. we call @xmath54 an _ @xmath10-well - separated pair decomposition _ ( @xmath10-wspd ) if all its pairs are @xmath10-well - separated  @xcite",
    ".    now let @xmath71 be a ( compressed or @xmath18-cluster ) quadtree for @xmath0 .",
    "given @xmath72 , it is well known that @xmath71 can be used to obtain an @xmath10-wspd for @xmath0 in linear time  @xcite . since we will need some specific properties of such an @xmath10-wspd , we give pseudo - code for such an algorithm in algorithm  [ alg : wspd ] .",
    "we call this algorithm @xmath73 , and denote its output on input @xmath71 by @xmath74",
    ". the correctness of the algorithm @xmath73 is immediate , since it only outputs well - separated pairs , and the bounds on the running time and the size of @xmath74 follow from a well - known volume argument which we omit  @xcite .    1 .   call @xmath75 on the root @xmath13 of @xmath71 .",
    "@xmath76    1 .",
    "if @xmath19 is a leaf , return @xmath77 .",
    "2 .   return the union of @xmath78 and @xmath79 for all children @xmath80 and pairs of distinct children @xmath81 of @xmath19 .",
    "0.2 cm @xmath82    1 .   if @xmath83 and @xmath84 are @xmath10-well - separated , return @xmath85 .",
    "2 .   otherwise ,",
    "if @xmath86 , return the union of @xmath87 for all children @xmath80 of @xmath19 .",
    "3 .   otherwise , return the union of @xmath88 for all children @xmath80 of @xmath48 .",
    "[ thm : wspd ] there is an algorithm _",
    "@xmath73 _ , that given a ( compressed or @xmath18-cluster ) quadtree @xmath71 for a planar @xmath11-point set @xmath0 , finds in time @xmath89 a linear - size @xmath10-wspd for @xmath0 , denoted _ @xmath74_.    note that the wspd is not stored explicitly : we can not afford to store all the pairs @xmath68 , since their total size might be quadratic .",
    "instead , @xmath74 contains pairs @xmath90 , where @xmath48 and @xmath19 are nodes in @xmath71 , and @xmath90 is used to represent the pair @xmath91 .",
    "note that the algorithm computes the wspd with respect to the squares @xmath20 , instead of the bounding squares @xmath22 .",
    "this makes no big difference , since for compressed quadtrees @xmath92 , and for @xmath18-cluster quadtrees @xmath22 can be outside @xmath20 only for @xmath18-cluster nodes , resulting in a loss of at most a factor @xmath93 in separation .",
    "referring to the pseudo - code in algorithm  [ alg : wspd ] , we now prove three observations .",
    "the first observation says that the size of the squares under consideration strictly decreases throughout the algorithm .",
    "[ obs : parents - bigger ] let @xmath90 be a pair of distinct nodes of @xmath71 .",
    "if _ @xmath82 _ is executed by _",
    "@xmath73 _ run on @xmath71 ( in particular , if _ @xmath94 _ ) , then @xmath95 .",
    "we use induction on the depth of the call stack for @xmath96 .",
    "initially , @xmath48 and @xmath19 are children of the same node , and the statement holds . furthermore , assuming that @xmath96 is called by @xmath97 ( and hence @xmath98 ) , we get @xmath99 , where the last equation follows by induction .",
    "the next observation states that the wspd - pairs reported by the algorithm are , in a sense , as high in the tree as possible .",
    "[ obs : parents - not - ws ] if _",
    ", then @xmath101 and @xmath28 are ill - separated .",
    "if @xmath102 , the claim is obvious . otherwise , let us assume that @xmath96 was called by @xmath97 .",
    "this means that @xmath103 is ill - separated and @xmath104 .",
    "therefore , @xmath105 , and @xmath106 is ill - separated .",
    "the last claim shows that for each wspd - pair , we can find well - behaved boxes whose size is comparable to the distance between the point sets . in the following",
    ", this will be a useful tool for making volume arguments that bound the number of wspd - pairs to consider .",
    "[ clm : quad - squares ] let _",
    "@xmath94_. then there exist squares @xmath107 and @xmath108 such that ( i ) @xmath109 and @xmath110 ; ( ii ) @xmath111 ; and ( iii ) @xmath112 .",
    "suppose @xmath96 is called by @xmath113 , the other case is symmetric .",
    "let us define @xmath114 .",
    "by observation  [ obs : parents - bigger ] , we have @xmath115 . since @xmath90 is well - separated",
    ", we have @xmath116 .",
    "hence , @xmath117 , and we can pick squares @xmath107 and @xmath108 of diameter @xmath13 that fulfill ( i ) . now",
    "( ii ) holds by construction , and it remains to check ( iii ) .",
    "first , note that @xmath118 , for @xmath119 .",
    "this proves the lower bound . for the upper bound ,",
    "observe that @xmath120 , because @xmath121 is ill - separated .",
    "thus , we have @xmath122 , and @xmath123 , as desired .",
    "in this section , we describe a few more properties of the @xmath18-cluster trees and @xmath18-cluster quadtrees defined in section  [ sec : cqt&cqt ] , and we prove that they are equivalent to the more standard compressed quadtrees ( theorem  [ thm : cluster - compressed - equiv ] ) . since most of the material is very technical ,",
    "we encourage the impatient reader to skip ahead to section  [ sec : qt->dt ] .",
    "krznaric and levcopolous  ( * ? ? ?",
    "* theorem  7 ) showed that a @xmath18-cluster tree can be computed in linear time from a delaunay triangulation .",
    "[ thm : c - cluster - tree ] let @xmath0 be a planar @xmath11-point set .",
    "given a constant @xmath124 and @xmath1 , we can find a @xmath18-cluster tree @xmath47 for @xmath0 in @xmath89 time and space on a pointer machine .    here , we will actually use a more relaxed notion of @xmath18-cluster trees : let @xmath125 , @xmath126 be two constants with @xmath127 , and let @xmath0 be a planar @xmath11-point set .",
    "a _ @xmath128-cluster tree _",
    "@xmath129 is a rooted tree in which each inner node has at least two children and which has @xmath11 leaves , one for each point in @xmath0 .",
    "each node @xmath130 corresponds to a subset @xmath131 in the natural way .",
    "every node @xmath19 must fulfill two properties : ( i ) if @xmath19 is not the root , then @xmath132 ; and ( ii ) if @xmath21 has a proper subset @xmath133 with @xmath134 , then there is a child @xmath80 of @xmath19 with @xmath135 . in other words",
    ", each node of @xmath129 corresponds to a @xmath125-cluster of @xmath0 , and @xmath129 must have a node for every @xmath126-cluster of @xmath0 .",
    "thus , the original @xmath18-cluster tree is also a @xmath136-cluster tree .",
    "our relaxed definition allows for some flexibility in the construction of @xmath129 while providing the same benefits as the original @xmath18-cluster tree .",
    "thus , outside this section we will be slightly sloppy and not distinguish between @xmath18-cluster trees and @xmath137-cluster trees .",
    "as mentioned above , the tree @xmath129 is quite similar to a well - separated pair decomposition : any two unrelated nodes in @xmath138 correspond to a @xmath139-well - separated pair .",
    "however , @xmath129 has the huge drawback that it may contain nodes of unbounded degree .",
    "for example , if the points in @xmath0 are arranged in a square grid , then @xmath138 consists of a single root with @xmath11 children . nonetheless , @xmath138 is still useful , since it represents a decomposition of @xmath0 into well - behaved pieces .",
    "as explained above , the @xmath128-cluster quadtree @xmath71 is obtained by augmenting @xmath129 with quadtree - like pieces to replace the nodes with many children .",
    "we will now prove some relevant properties of @xmath140-cluster quadtrees .",
    "for a node @xmath48 of @xmath138 , let @xmath141 be the balanced regular quadtree on the representative points of @xmath48 s children .",
    "the _ direct neighbors _ of a square @xmath142 in @xmath143 are the @xmath144 squares of size @xmath145 that surround @xmath142 .",
    "first , we recall how the balanced tree @xmath141 is obtained : we start with a regular ( uncompressed ) quadtree @xmath146 for the representative points . while @xmath146 is not balanced , we take a leaf square @xmath142 of @xmath146 that is adjacent to a leaf square of size less than @xmath147 and we split @xmath142 into four congruent child squares . the following theorem is well known .",
    "[ theorem  14.4 of @xcite ] [ thm : balance ] let @xmath146 be a quadtree with @xmath55 nodes .",
    "the above procedure yields a balanced quadtree with @xmath148 nodes , and it can be implemented to run in @xmath148 time .",
    "let @xmath19 be a child of @xmath48 in @xmath138 .",
    "the properties of the balanced quadtree @xmath143 and the fact that the children of @xmath48 are mutually well - separated yield the following observation .",
    "[ obs : close ] if @xmath125 is large enough , at most four leaf squares of @xmath141 contain points from @xmath21 .",
    "let @xmath149 be the diameter of the bounding square for @xmath21 . by definition",
    ", @xmath21 is a @xmath125-cluster , so the distance from any point in @xmath21 to any point in @xmath150 is at least @xmath151 .",
    "suppose that @xmath142 is a leaf square of @xmath141 with @xmath152 , and let @xmath153 be the parent of @xmath142 .",
    "there are two possible reasons for the creation of @xmath142 : either @xmath142 is part of the original regular quadtree for the representative points , or @xmath142 is generated during the balancing procedure . in the former case",
    ", @xmath153 contains at least two representative points .",
    "thus , since in @xmath153 there is a point from @xmath21 and a point from @xmath150 , we have @xmath154 . in the latter case",
    ", @xmath153 must be a direct neighbor of a square with at least two representative points ( see  ( * ? ? ?",
    "* proof of theorem  14.4 ) ) .",
    "therefore , since @xmath153 contains a point from @xmath21 and has a direct neighbor with a point from @xmath150 , the diameter of @xmath142 is at least @xmath155 .",
    "either way , we certainly have @xmath156 .    now if @xmath157 , then @xmath158 , so the side length of every leaf square @xmath142 that intersects @xmath21 is strictly larger than @xmath159 .",
    "thus , @xmath21 can be covered by at most @xmath160 such squares , and the claim follows .    to see that @xmath128-cluster quadtrees have linear size",
    ", we need a property that is ( somewhat implicitly ) shown in  ( * ? ? ?",
    "* section  4.3 ) .",
    "[ lem : c - cluster - qt ] if @xmath48 has @xmath55 children @xmath161 , @xmath162 , @xmath163 , @xmath164 in @xmath47 , then @xmath141 has @xmath148 nodes .",
    "note that the total number of nodes in @xmath143 is proportional to the number of squares that contain at least two representative points . indeed , the number of squares in a balanced regular quadtree is proportional to the number of squares in the corresponding unbalanced regular quadtree ( theorem  [ thm : balance ] ) , and in that tree the squares with at least two points correspond to the internal nodes , each of which has exactly four children .",
    "thus , it suffices to show that the number of squares in @xmath143 with at least two representative points is @xmath148 .    call a square @xmath142 of @xmath143 _ full _ if @xmath142 contains a representative point .",
    "a full square @xmath165 is called _ merged _ if it has at least two full children . there are @xmath148 merged squares , so we only need to bound the number of non - merged full squares with at least two points .",
    "these squares can be charged to the merged squares , using the following claim .",
    "[ clm : merged_ancestor ] there exists a constant @xmath166 ( depending on @xmath126 ) such that the following holds : for any full square @xmath142 with at least two representative points , one of the @xmath166 closest ancestors of @xmath142 in @xmath143 ( possibly @xmath142 itself ) is either merged or has a merged direct neighbor .",
    "let @xmath142 be a non - merged full square with at least two representative points .",
    "since @xmath142 intersects more than one @xmath167 , the definition of @xmath138 implies that the set @xmath168 is not a @xmath126-cluster .",
    "thus , @xmath169 contains a point at distance at most @xmath170 from @xmath142 .",
    "hence , @xmath142 has an ancestor @xmath171 in @xmath143 that is at most @xmath172 levels above @xmath142 and that has a full direct neighbor @xmath173 ( note that @xmath143 is balanced , so @xmath174 actually belongs to @xmath143 ) .",
    "we repeat the argument : since @xmath175 is not a @xmath126-cluster , there is a point in @xmath176 at distance at most @xmath177 from @xmath178 .",
    "thus , if we go up @xmath172 levels in @xmath143 , we either encounter a common ancestor of @xmath171 and @xmath174 , in which case we are done , or we have found a set @xmath179 of three full squares of @xmath143 such that ( i ) one square in @xmath179 is an ancestor of @xmath142 ; ( ii ) the squares in @xmath179 have equal size ; and ( iii ) the squares in @xmath179 form a ( topologically ) connected set .",
    "we keep repeating the argument while going up the tree . in each step , if we do not encounter a common ancestor of at least two squares in @xmath179 , we can add one more full square to @xmath179 .",
    "however , as soon as we have five squares of equal size that form a connected set , at least two of them have a common parent .",
    "thus , the process stops after at most two more iterations .",
    "furthermore , since @xmath179 is connected , once at least two squares in @xmath179 have a common parent , the parents of the other squares must be direct neighbors of that parent .",
    "hence , we found an ancestor of @xmath142 that is only a constant number of levels above @xmath142 and that is merged or has a merged direct neighbor , as desired .",
    "now we use claim  [ clm : merged_ancestor ] to charge each non - merged full node with at least two representative points to a merged node .",
    "each merged node is charged at most @xmath180 times , and lemma  [ lem : c - cluster - qt ] follows .",
    "the proof of lemma  [ lem : c - cluster - qt ] implies the following , slightly stronger claim : recall that @xmath141 was constructed by building a regular quadtree for the representative points for @xmath48 s children , followed by a balancing step . now , suppose that before the balancing step we subdivide each leaf that contains a representative point for a @xmath18-cluster @xmath181 until it has size at most @xmath182 , for some constant @xmath183 ( if the leaf is smaller than @xmath182 , we do nothing ) .",
    "call the tree that results after the balancing step @xmath184 .",
    "[ cor : c - cluster - qt - extended ] the tree @xmath184 has @xmath148 nodes .",
    "we only need to worry about the additional squares created during the subdivision of the leaves .",
    "if we take such a square and go up at most @xmath185 levels in the tree , we get a square with a direct neighbor that contains a point from another cluster . now the argument from the proof of lemma  [ lem : c - cluster - qt ] applies and we can charge the additional squares to merged squares , as before .      in this section , we show that it is possible to `` shift '' a quadtree ; that is , given a compressed quadtree on a set of points @xmath0 with base square @xmath3 , to compute another compressed quadtree on @xmath0 with a base square that is similar to @xmath3 , in linear time .",
    "the main difficulty lies in the fact that the clusters in the two quadtrees can be very different , as illustrated in figure  [ fig : shift - plain+shift - comp ] .",
    "[ thm : shiftbalance ] suppose @xmath30 is a sufficiently large constant and @xmath0 a planar @xmath11-point set .",
    "furthermore , let @xmath71 be an @xmath30-compressed quadtree for @xmath0 with base square @xmath3 , and let @xmath142 be a square with @xmath186 and @xmath187 .",
    "then we can construct in @xmath148 time a balanced @xmath30-compressed quadtree @xmath146 for @xmath0 with base square @xmath142 and with @xmath148 nodes .",
    "the idea is to construct @xmath146 in the traditional way through repeated subdivision of the base square @xmath142 , while using the information provided by @xmath71 in order to speed up the point location .",
    "we will use the terms _ @xmath71-square _ and _ @xmath146-square _ to distinguish the squares in the two trees . during the subdivision process",
    ", we maintain the partial tree @xmath146 , and for each square @xmath171 of @xmath146 we keep track of the @xmath71-squares that have similar size as @xmath171 and that intersect @xmath171 ( in an associated set ) .",
    "we call the leaves of the current partial tree the _ frontier _ of @xmath146 . in each step",
    ", we pick a frontier @xmath146-square and split it , until we have reached a valid quadtree for @xmath0 .",
    "we need to be careful in order to keep @xmath146 balanced and in order to deal with compressed nodes .",
    "the former problem is handled by starting a cascading split operation as soon as a single split makes @xmath146 unbalanced .",
    "for the latter problem , we would like to treat the compressed children in the same way as the points in @xmath0 , and handle them later recursively .",
    "however , there is a problem : during the balancing procedure , it may happen that a compressed child becomes too large for its parent square and should be part of the regular tree . in order to deal with this , we must keep track of the compressed children in the associated sets of the @xmath146-squares . when we detect that a compressed child has become too large for its parent ,",
    "we treat it like a regular square .",
    "once we are done , we recurse on the remaining compressed children . through a charging scheme",
    ", we can show that the overall work is linear in the size of @xmath71 .",
    "the following paragraphs describe the individual steps of the algorithm in more detail .",
    "[ [ initialization - and - data - structures . ] ] initialization and data structures .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we obtain from @xmath142 a grid with squares of size in @xmath188 $ ] , either by repeatedly subdividing @xmath142 , if @xmath189 ; or by repeatedly doubling @xmath142 , if @xmath190 .",
    "since @xmath187 , this requires a constant number of steps",
    ". then we determine the @xmath146-squares @xmath191 of that grid that intersect @xmath3 ( note that @xmath192 ) .",
    "our algorithm maintains the following data structures : ( i ) a list @xmath193 of _ active _ @xmath146-squares ; and ( ii ) for each @xmath146-square @xmath171 a list @xmath194 of _ associated _ @xmath71-squares .",
    "we will maintain the invariant that @xmath194 contains the smallest @xmath71-squares that have size at least @xmath195 and that intersect @xmath171 , as well as any compressed children that are contained in such a @xmath71-square and that intersect @xmath171 .",
    "this invariant implies that each @xmath171 has @xmath196 associated squares .",
    "we call a @xmath146-square @xmath171 _ active _ if @xmath194 contains a @xmath71-square of size in @xmath197 or a compressed child of size in @xmath198 .",
    "initially , we set @xmath199 and @xmath200 , fulfilling the invariant .",
    "[ [ the - split - operation . ] ] the split operation .",
    "+ + + + + + + + + + + + + + + + + + + +    the basic operation of our algorithm is the _",
    "split_. a split takes a @xmath146-square @xmath171 and subdivides it into four children @xmath201 .",
    "then it computes the associated sets @xmath202 as follows . for each @xmath203",
    ", we intersect @xmath204 with all @xmath71-squares in @xmath194 , and we put those @xmath71-squares into @xmath205 that have non - empty intersection with @xmath204 . then we replace each @xmath71-square in @xmath194 that is neither a leaf , nor a compressed node , nor a compressed child by those of its children that have non - empty intersection with @xmath206 .",
    "finally , we remove from @xmath205 those compressed nodes whose compressed children have size at least @xmath207 and intersect @xmath206 .",
    "having determined @xmath208 , we use it to check whether @xmath206 is active .",
    "if so , we add it to @xmath193 .",
    "the split operation maintains the invariant about the associated sets , and it takes constant time .",
    "[ [ main - body - and - point - location . ] ] main body and point - location .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we now describe the main body of our algorithm .",
    "it consists of _ phases_. in each phase , we remove a @xmath146-square @xmath171 from @xmath193 .",
    "we perform a split operation on @xmath171 as described above .",
    "then , we start the _",
    "balancing procedure_. for this , we check the four @xmath146-squares in the current frontier that are directly above , below , to the left and to the right of @xmath171 to see whether any of them have size @xmath209 .",
    "we put each such @xmath146-square into a queue @xmath210 .",
    "then , while @xmath210 is not empty , we remove a square @xmath211 from @xmath210 and perform a split operation on it ( note that this may create new active squares ) .",
    "furthermore , if @xmath211 is in @xmath193 , we remove it from @xmath193 .",
    "finally , we consider the @xmath146-squares of the current frontier directly above , below , to the left and to the right of @xmath211 .",
    "if any of them have size @xmath212 and are not in @xmath210 yet , we append them to @xmath210 and continue . the balancing procedure , and hence the phase , ends once @xmath210 is empty .",
    "we continue this process until @xmath193 is empty .",
    "next , we do _ point - location_. let @xmath171 be a @xmath146-square of the current frontier . since @xmath193 is empty , @xmath171 is associated with @xmath196 @xmath71-squares , all of which are either leaves or compressed nodes or compressed children in @xmath71 . for each @xmath71-leaf that intersects @xmath171",
    ", we determine whether it contains a point that lies in @xmath171 . in the end",
    ", we have a set of at most four points from @xmath0 or compressed children of @xmath71 that intersect @xmath171 , and we call this set the _ secondary _ associated set for @xmath171 , denoted by @xmath213",
    ". we do this for every @xmath146-square in the current frontier .",
    "[ [ the - secondary - stage . ] ] the secondary stage .",
    "+ + + + + + + + + + + + + + + + + + + +    next , the goal is to build a small compressed quadtree for the secondary associated set of each square in the current frontier .",
    "of course , the tree needs to remain balanced . for this",
    ", we start an operation that is similar to the main body of the algorithm .",
    "we call a @xmath146-square @xmath171 _ post - active _ if @xmath214 and the smallest bounding square for the elements in @xmath213 has size larger than @xmath215 .",
    "we put all the post - active squares into a list @xmath216 and we proceed as before : we repeatedly take a post - active square from @xmath216 , split it , and then perform a balancing procedure . here , the splitting operation is as follows : given a square @xmath171 , we split it into four children @xmath217 . by comparing each child @xmath206 to each element in the secondary associated set @xmath213",
    ", we determine the new secondary associated sets @xmath218 .",
    "we use these associated sets to check which children @xmath204 ( if any ) are post - active and add them to @xmath216 , if necessary .",
    "this splitting operation takes constant time .",
    "again , it may happen that the balancing procedure creates new post - active squares .",
    "we repeat this procedure until @xmath216 is empty .",
    "[ [ setting - up - the - recursive - calls . ] ] setting up the recursive calls . + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    after the secondary stage , there are no more post - active squares , so for each square @xmath171 in the current frontier we have ( i ) @xmath219 ; or ( ii ) the smallest bounding square of @xmath213 has size at most @xmath215 .",
    "below in lemma  [ lem : secondary - bound ] we will argue that if @xmath213 contains a single compressed child @xmath181 , then @xmath181 has size at most @xmath215 .",
    "thus , ( ii ) holds in any case .",
    "the goal now is to set up a recursive call of the algorithm to handle the remaining compressed children .",
    "unfortunately , a compressed child may intersect several leaf @xmath146-squares , so we need to be careful about choosing the base squares for the recursion .",
    "let @xmath171 be a square of the current frontier , and set @xmath220 . while there is a compressed child @xmath181 in @xmath221 that intersects the boundary of @xmath222 , we add all the @xmath146-squares of the current frontier that are intersected by @xmath181 to @xmath223 .",
    "since @xmath146 is balanced , the @xmath63-th square @xmath224 that we add to @xmath223 has size at most @xmath225 and hence the bounding square of @xmath226 has size at most @xmath227 . by construction",
    ", @xmath226 contains at least one element that intersects a square in the old @xmath223 , so by induction we know that after @xmath63 steps the set @xmath228 has a bounding square of size at most @xmath229 .",
    "it follows that the process stops after at most three steps ( i.e. , when @xmath223 has four elements ) , because after four steps we would have a bounding square of size at most @xmath230 that is intersected by five disjoint squares of size at least @xmath231 ( since @xmath146 is balanced ) , which is impossible ( for @xmath30 large enough ) .",
    "figure  [ fig : shift - rec ] shows an example .",
    "now we put two base squares around @xmath228 : a square @xmath232 that is aligned with @xmath71 , and a square @xmath233 that is aligned with @xmath146 . for @xmath232 ,",
    "if @xmath228 contains only one element , we just use the bounding square of @xmath228 . if @xmath234 , then the elements of @xmath228 are separated by an edge or a corner between leaf @xmath71-squares .",
    "thus , we can pick a base square @xmath232 for @xmath228 such that ( i ) @xmath235 ; ( ii ) @xmath232 is aligned with @xmath71 ; and ( iii ) the first split of @xmath232 separates the elements in @xmath228 . for @xmath233 , if @xmath236 , we just use the bounding square for @xmath228 . if @xmath237 , the squares in @xmath223 must share a common edge or corner , and we can find a base square @xmath233 such that ( i ) @xmath233 contains @xmath228 ; ( ii ) the first split of @xmath233 produces squares that are aligned with this edge or corner of @xmath223 ; and ( iii ) @xmath238 .",
    "figure  [ fig : shift - rec2 ] shows an example .",
    "we now construct an @xmath30-compressed quadtree @xmath239 with base square @xmath232 for the elements of @xmath228 in the obvious way .",
    "( if @xmath228 contains any compressed children , we reuse them as compressed children for @xmath239 .",
    "this may lead to a violation of the condition for compressed nodes at the first level of @xmath239 .",
    "however , our algorithm automatically treats large compressed children as active squares , so there is no problem . )",
    "this takes constant time .",
    "we call the algorithm recursively to shift @xmath239 to the new base square @xmath233 .",
    "note that this leads to a valid @xmath30-compressed quadtree since either @xmath233 is wholly contained in @xmath171 ; or the first split of @xmath233 produces squares that are wholly contained in the @xmath146-leaf squares and have size at most @xmath240 , while each square that intersects @xmath233 has size at least @xmath241 , as @xmath146 is balanced .",
    "we repeat the procedure for every leaf @xmath146-square whose secondary associated set we have not processed yet .",
    "[ [ analysis . ] ] analysis .",
    "+ + + + + + + + +    the resulting tree @xmath146 is a balanced @xmath30-compressed quadtree for @xmath0 .",
    "it remains to prove that the algorithm runs in linear time .",
    "the initialization stage needs @xmath196 steps .",
    "next , we consider the main body of the algorithm . since each split takes constant time , the total running time for the main body is proportional to the number of splits . recall that a @xmath146-square @xmath171 is called _ active _ if it is put into @xmath193 , i.e. , if @xmath194 contains a @xmath71-square of size in @xmath197 or a compressed child of size in @xmath242 $ ] .",
    "since each @xmath71-square can cause only a constant number of @xmath146-squares to be active , the total number of active @xmath146-squares is @xmath148 .",
    "thus , we can use the following lemma to conclude that the total number of splits in the main body of the algorithm is linear .",
    "[ lem : main - body ] every split in the main body of the algorithm can be charged to an active @xmath146-square such that each such square is charged a constant number of times .",
    "if we split an active square @xmath171 , we can trivially charge the split to @xmath171 .",
    "hence , the critical splits are the ones during the balancing procedure . by induction on the number of steps of the balancing procedure , we see that if a square @xmath171 is split , there must be a square @xmath211 in the current partial tree @xmath146 that is a direct neighbor of @xmath171 and that has an active descendant whose removal from @xmath193 triggered the balancing procedure .",
    "is one of the eight squares of size @xmath195 that surround @xmath171 . ]    if @xmath211 has an active ancestor @xmath243 that is at most five levels above @xmath211 in @xmath146 ( possibly @xmath244 ) , we charge the split of @xmath171 to @xmath243 , and we are done .",
    "otherwise , we know that @xmath245 contains at least one compressed child of size less than @xmath246 ( otherwise , @xmath211 would not have an active descendant or would itself be active ) and @xmath71-squares of size at least @xmath247 ( otherwise , one of the five nodes above @xmath211 in @xmath146 would have been active ) .",
    "now , before @xmath171 is split , there must have been a split on @xmath211 : otherwise the active descendant of @xmath211 that triggers the split on @xmath171 would not exist .",
    "thus , we repeat the argument to show that @xmath211 has a direct neighbor @xmath248 with an active descendant that triggers the split of @xmath171 .",
    "note that @xmath249 , because the split on @xmath211 happens before the split on @xmath171 .",
    "if @xmath248 has an active ancestor that is at most five levels higher up in @xmath146 ( possibly @xmath248 itself ) , we are done again . otherwise , we repeat the argument again .",
    "we claim that this process finishes after at most @xmath250 steps . indeed , suppose we find @xmath251 squares @xmath252 without stopping . we know that each @xmath253 is a direct neighbor of @xmath254 and that each @xmath253 is associated with a compressed child of size at most @xmath255 and with @xmath71-squares of size at least @xmath256 . since the set @xmath257 has diameter at most @xmath258 , the set @xmath259 contains at most four @xmath71-squares of size at least @xmath256 .",
    "now each compressed child in an associated set @xmath260 is the only child of one of these four large @xmath71-squares , so there are at most four of them .",
    "furthermore , each such compressed child is intersected by at most four disjoint @xmath71-squares of size @xmath195 , so there can be at most @xmath250 squares @xmath253 , a contradiction .",
    "hence , we can charge each split to an active square in the desired fashion , and the lemma follows .",
    "next , we analyze the running time of the secondary stage . again , the running time is proportional to the number of splits , which is bounded by the following lemma .",
    "[ lem : secondary - bound ] let @xmath171 be a frontier @xmath146-square at the beginning of the secondary stage . then after the secondary stage , the subtree rooted at @xmath171 has height at most @xmath261 .",
    "below , we will argue that for every descendant @xmath174 of @xmath171 , if @xmath262 contains a compressed child @xmath181 , then @xmath263 .",
    "for now , suppose that this holds .",
    "first , we claim that there are @xmath261 splits to post - active descendants of @xmath171 .",
    "the secondary associated set @xmath213 contains at most four elements , so @xmath213 has at most @xmath264 subsets with two or more elements .",
    "fix such a subset @xmath265 .",
    "then @xmath171 has at most @xmath261 post - active descendants with secondary associated set @xmath265 .",
    "this is because each level of @xmath146 has at most two squares with secondary associated set @xmath265 , and the post - active squares with secondary associated set @xmath265 must have size between @xmath266 and @xmath267 , where @xmath268 denotes the smallest bounding square for the elements in @xmath265 .",
    "( here we use our claim that the compressed children in the secondary associated set of each frontier @xmath146-square @xmath174 are much smaller than @xmath174 . )",
    "there are only @xmath261 such levels , so adding over all @xmath265 , we see that @xmath171 has at most @xmath261 post - active descendants , implying the claim .",
    "each split creates at most one new level below @xmath171 , so there are only @xmath261 new levels due to splits to post - active descendants of @xmath171 .",
    "next , we bound the number of new levels that are created by splits during the balancing phases .",
    "each balancing phase creates at most one new level below @xmath171 .",
    "furthermore , by induction on the number of steps in the balancing phase , we see that the balancing phase was triggered by the split of a post - active square that is a descendant either of @xmath171 or of a direct neighbor of @xmath171 . at the beginning of the secondary stage ,",
    "there are @xmath196 @xmath146-squares that are descendants of direct neighbors of @xmath171 ( as @xmath146 is balanced ) .",
    "as we argued above , each of them has at most @xmath261 post - active descendants .",
    "thus , the balancing phases add at most @xmath261 new levels below @xmath171 .    finally , we need to justify the assumption that for any descendant @xmath174 with a compressed child @xmath269 , we have @xmath263 . by construction , we have @xmath270 .",
    "suppose that @xmath171 has a descendant @xmath174 that violates this assumption .",
    "the square @xmath174 was created through a split in the secondary stage , and suppose that @xmath174 is the first such square during the whole secondary stage .",
    "this means that during all previous splits , the assumption holds , so by the argument above , there are at most @xmath261 levels below @xmath171 .",
    "this means that @xmath271 , so we would get @xmath272 , a contradiction ( for @xmath30 large enough ) .",
    "thus , no @xmath174 can violate the assumption , as desired .",
    "the time to set up the recursion is constant for each square of the current frontier . from lemmas  [ lem : main - body ] and",
    "[ lem : secondary - bound ] , we can conclude that the total time of the algorithm is @xmath148 , which also implies that @xmath146 has @xmath148 squares .",
    "this concludes the proof of theorem  [ thm : shiftbalance ] .",
    "[ [ special - cases . ] ] special cases .",
    "+ + + + + + + + + + + + + +    we note two useful special cases of theorem  [ thm : shiftbalance ] .",
    "the first one gives an analog of theorem  [ thm : balance ] for compressed quadtrees .",
    "[ cor : balance-n - thread ] let @xmath71 be a @xmath30-compressed quadtree with @xmath55 nodes .",
    "there exists a balanced @xmath30-compressed quadtree that contains @xmath71 , has @xmath273 nodes and can be constructed in @xmath273 time .",
    "let @xmath3 be the base square of @xmath71 .",
    "we apply theorem  [ thm : shiftbalance ] with @xmath274 .",
    "the second special case says that we can realign an uncompressed quadtree locally in any way we want , as long as we are willing to relax the definition of quadtree slightly .",
    "let @xmath0 be a planar point set .",
    "we call a quadtree for @xmath0 _ @xmath275-relaxed _ if it has at most @xmath275 points of @xmath0 in each leaf , and is otherwise a regular quadtree .    [ cor : qt - shift ] let @xmath0 be a planar point set and @xmath71 a regular quadtree for @xmath0 , with base square @xmath3 .",
    "let @xmath142 be another square with @xmath186 and @xmath187 .",
    "then we can build a @xmath160-relaxed quadtree @xmath146 for @xmath0 with base square @xmath142 in @xmath276 time such that @xmath146 has @xmath276 nodes .",
    "we apply theorem  [ thm : shiftbalance ] to @xmath71 , but we stop the algorithm before the beginning of the secondary stage .",
    "since each secondary associated set for a leaf square has at most four elements , and since @xmath71 contains no compressed nodes , the resulting tree @xmath146 has the desired properties .      the goal of this section is to prove the following theorem .",
    "[ thm : cluster - compressed - equiv ] let @xmath0 be a planar @xmath11-point set . given a @xmath128-cluster quadtree on @xmath0 , we can compute in @xmath89 time an @xmath277-compressed quadtree on @xmath0 ; and given an @xmath30-compressed quadtree on @xmath0 , we can compute in @xmath89 time an @xmath278-cluster quadtree on @xmath0 .",
    "we present the proof of theorem  [ thm : cluster - compressed - equiv ] in two lemmas .",
    "[ lem : c - cluster->compressed ] let @xmath0 be a planar @xmath11-point set . given a @xmath128-cluster quadtree @xmath71 for @xmath0 , we can compute in linear time an @xmath277-compressed quadtree @xmath146 on @xmath0 .",
    "we construct the compressed quadtree in a top - down fashion , beginning from the root .",
    "suppose that we have constructed a partial compressed quadtree @xmath146 , and let @xmath279 be the representative point for a node @xmath48 in the @xmath140-cluster tree @xmath138 that corresponds to @xmath71 .",
    "we show how to expand @xmath279 in @xmath146 to the corresponding quadtree @xmath143 .",
    "first , we add to @xmath143 a new root that is aligned with the old base square and larger by a constant factor , such that the old base square does not touch any boundary of the new one .",
    "next , we determine by a search from @xmath279 which leaf squares of @xmath146 intersect @xmath143 . by observation  [ obs : close ] , there are at most four such leaves , so this step takes constant time .",
    "( note that since we grow the base square of each quadtree that we expand , it can not happen that @xmath143 intersects the boundary of its parent quadtree . )",
    "next , we repeatedly split each leaf that intersects @xmath143 and that contains some other point or compressed child until there are no more such leaves .",
    "the proof of observation  [ obs : close ] shows that every leaf square of @xmath146 that intersects @xmath143 has size at least @xmath155 , where @xmath159 is the size of @xmath143 s base square .",
    "if @xmath143 lies completely inside a leaf of @xmath146 , we add @xmath143 as a compressed child to @xmath146 .",
    "if @xmath143 intersects more than one leaf square , we identify a square at most twice the size of @xmath143 s base square that is aligned appropriately with the relevant edges of @xmath71 , and apply corollary  [ cor : qt - shift ] to shift @xmath280 to this new base square .",
    "this results in a valid @xmath277 compressed quadtree in which @xmath279 has been expanded .",
    "we repeat this process until all the quadtree pieces of @xmath71 have been integrated into a large compressed quadtree .",
    "the total time for the top - down traversal and for the realignment procedures is linear .",
    "furthermore , corollary  [ cor : c - cluster - qt - extended ] shows that the total work for splitting the leaves of @xmath146 is also linear , since the points in the different clusters are @xmath139-semi - separated .",
    "hence , the total running time is linear .",
    "[ lem : compressed->c - cluster ] let @xmath0 be a planar @xmath11-point set , and @xmath71 be an @xmath30-compressed quadtree for @xmath0",
    ". then we can compute in linear time a @xmath278-cluster quadtree for @xmath0 .",
    "we use corollary  [ cor : balance-n - thread ] to balance @xmath71 , but without the recursive calls for the remaining cluster nodes .",
    "this gives a balanced top - level quadtree @xmath281 ( possibly with some compressed children of @xmath71 now integrated in the tree ) , in which each leaf square is associated with at most four points from @xmath0 or compressed children of @xmath71 .",
    "furthermore , for each leaf square @xmath142 of @xmath281 , we have a bounding square for the associated elements that is aligned with @xmath71 and has size at most @xmath282 .    we use @xmath283 to identify a partial cluster quadtree , and we then recurse on the compressed children .",
    "we say a square @xmath284 is _ full _ if there is a leaf below @xmath142 with a non - empty associated set .",
    "otherwise , @xmath142 is _",
    "empty_. first , we consider the squares of @xmath281 in top - down fashion and check for each full square @xmath142 which direct neighbors of @xmath142 are empty ( this can be done in constant time since @xmath71 is balanced ) . if @xmath142 has at most three full direct neighbors , and if all these full squares share a common corner , we let @xmath39 be a square that is aligned with @xmath142 and contains the full squares ( i.e. , either @xmath285 or @xmath39 is a square of size @xmath286 that contains @xmath142 and its full neighbors ) .",
    "next , we consider the squares of size @xmath287 in the @xmath288 grid centered at @xmath39 and check whether they are all empty ( again , since @xmath71 is balanced , this takes constant time ) .",
    "if so , the points associated with @xmath39 define a @xmath289-cluster .",
    "we put a representative point for the cluster into @xmath39 , make a new quadtree with root @xmath39 , and remove @xmath39 s children from @xmath281 .",
    "we continue until all the squares of @xmath281 have been traversed , and then we process all the new trees in a similar way , iterating if necessary .",
    "after we are done , a part of the cluster quadtree has been created , and we need to consider the compressed children to set up a recursion .    for this , we consider each non - empty leaf square @xmath142 of the partial tree .",
    "let @xmath4 be the bounding square of the associated elements of @xmath142 .",
    "we know that @xmath290 , so the disc @xmath291 of radius @xmath292 centered at @xmath4 intersects at most three other leaf squares .",
    "we check for each of these leaf squares whether @xmath291 intersects the bounding square of its associated elements .",
    "if so , we make a new bounding square for the union of these elements and repeat .",
    "this can happen at most twice more , because in each step the size of the bounding square increases by a factor of at most @xmath289 .",
    "hence , after three steps we have a disk @xmath291 of radius @xmath293 that intersects four disjoint squares of size @xmath294 that share a corner .",
    "thus , @xmath291 must be completely contained in those squares .",
    "this also implies that this procedure yields a @xmath289-cluster . for each such cluster",
    ", we create a representative point and an appropriate base square for the child quadtree .",
    "then , we process the cluster recursively . in the end",
    ", we can prune the resulting compressed trees to remove unnecessary nodes .    by the proof of corollary  [ cor : balance-n - thread ] , and",
    "since be spend only constant additional time for each square , this procedure takes linear time .",
    "furthermore , as we argued above , we create only @xmath289-clusters .",
    "if @xmath295 is a @xmath296-cluster , then @xmath210 is either contained in at most four leaf squares of @xmath281 that share a corner or the bounding square @xmath297 intersects at most four squares of @xmath281 of size @xmath298 such that the surrounding @xmath288 grid contains only empty squares . in either case",
    ", @xmath210 ( or a superset ) is discovered .",
    "it follows that the result is a valid @xmath299-cluster quadtree .",
    "we now come to the heart of the matter and show how to construct a dt from a wspd .",
    "let @xmath0 be a set of points , and @xmath71 a compressed quadtree for @xmath0 . throughout this section",
    ", @xmath10 is a small enough constant ( say , @xmath300 ) , and @xmath301 is a large enough constant ( e.g. , @xmath302 ) .",
    "let @xmath48 and @xmath19 be two _ unrelated _ nodes of @xmath71 , i.e. , neither node is an ancestor of the other .",
    "let @xmath303 be the set of directed lines that stab @xmath27 before @xmath20 .",
    "the set @xmath304 of directions for @xmath303 is an interval modulo @xmath305 whose extreme points correspond to the two diagonal bitangents of @xmath27 and @xmath20 , i.e. , the two lines that meet @xmath27 and @xmath20 in exactly one point each and have @xmath27 and @xmath20 to different sides . figure  [ fig : angle - int ] illustrates this .",
    "[ obs : directions - contained ] let @xmath48 and @xmath19 be two unrelated nodes of @xmath71 , and let @xmath306 be a descendant of @xmath48 and @xmath31 be a descendant of @xmath19",
    ". then @xmath307 .",
    "this is immediate , because @xmath308 and @xmath309 .",
    "[ obs : small - phi ] if @xmath48 and @xmath19 are two nodes of @xmath71 such that @xmath90 is @xmath10-well - separated , then @xmath310 .",
    "let @xmath311 , @xmath312 be the disk around @xmath313 with radius @xmath314 , and @xmath315 the disk around @xmath25 with the same radius . by well - separation , @xmath316 and @xmath317 .",
    "let @xmath166 be the angle between the diagonal bitangents of @xmath312 and @xmath315 .",
    "then @xmath318 , and @xmath319 as claimed .",
    "figure  [ fig : angle - sep ] illustrates this .    for a number @xmath320",
    "we define @xmath321 \\}$ ] , i.e. , the set of all directions that differ from @xmath322 by at most @xmath323 .",
    "we say that an ordered pair @xmath324 of nodes has direction @xmath322 if @xmath325 .",
    "we also say that a pair of points @xmath326 has direction @xmath322 if the corresponding pair in the wspd has direction @xmath322 .",
    "the same definition also applies to an edge . for a given point @xmath327 in the plane",
    ", we define the @xmath10-cone @xmath328 as the cone with apex @xmath327 and opening angle @xmath10 centered around the direction @xmath322 .      in the following , we abbreviate @xmath329 .",
    "the goal of this section is to construct a graph @xmath330 with vertex set @xmath0 and @xmath89 edges , such that @xmath331 .",
    "it is well known that if we take the graph @xmath332 on @xmath0 with edge set @xmath333 , where each @xmath334 connects the bichromatic closest pair for @xmath335 and @xmath21 , then @xmath332 contains @xmath2 and has @xmath89 edges  @xcite . however , as defined , it is not clear how to find @xmath332 in linear time .",
    "there are several major obstacles .",
    "firstly , even though the tree @xmath71 has @xmath89 nodes , it could be that @xmath336 .",
    "secondly , even if the total size of all @xmath335 s was @xmath89 , we still need to find bichromatic closest pairs for all _ pairs _ in @xmath54 .",
    "thus , a large set @xmath335 might appear in many pairs of @xmath54 , making the total problem size superlinear .",
    "thirdly , we need to actually solve the bichromatic closest pair problems .",
    "a straightforward solution to find the bichromatic closest pair for sets @xmath3 and @xmath4 with sizes @xmath13 and @xmath14 would take time @xmath337 , by computing the voronoi diagram for the smaller set and locating all points from the other set in it .",
    "we need to find a way to do it in linear time .    to address these problems , we actually construct a slightly larger graph @xmath330 , by partitioning the pairs in @xmath54 according to their direction .",
    "more precisely , let @xmath338 be a set of @xmath339 numbers , where we assume that @xmath340 is an integer .",
    "for every @xmath341 , we construct a graph @xmath342 with @xmath89 edges and then let @xmath343 . given @xmath341 , the graph @xmath342",
    "is constructed in three steps :    1 .   for every node @xmath344 ,",
    "select a subset @xmath345 , such that @xmath346 , and such that @xmath347 still contains all edges of @xmath2 with orientation @xmath322 .",
    "this addresses the first problem by making the total set size linear .",
    "2 .   find a subset @xmath348 , such that each @xmath344 appears in @xmath196 pairs of @xmath349 , and the set @xmath350 contains all edges of @xmath2 with orientation @xmath322 .",
    "in particular , we choose for every node @xmath344 a subset @xmath351 such that @xmath352 , each pair in @xmath353 contains @xmath48 , and @xmath354 .",
    "this addresses the second problem by ensuring that every set appears in @xmath196 pairs .",
    "3 .   for every pair @xmath355",
    ", we include in @xmath342 the edge @xmath356 such that @xmath357 is the closest pair in @xmath358 ( i.e. , @xmath359 ) .",
    "here we actually solve all the bichromatic closest pair problems .    clearly , @xmath342 has @xmath89 edges , and we will show that @xmath330 is indeed a supergraph of @xmath2 .",
    "our strategy of subdividing the edges according to their orientation goes back to yao , who used a similar scheme to find emsts in higher dimensions  @xcite .",
    "[ [ step-1-finding - the - z_us . ] ] step 1 : finding the @xmath360 s .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    recall that we fixed a direction @xmath341 .",
    "take the set @xmath361 of pairs with direction @xmath322 . for a pair @xmath362",
    ", we write @xmath363 for the tuple such that @xmath364 and @xmath313 comes before @xmath25 in direction @xmath322 , it is a _ directed _ pair in @xmath365 . call a node @xmath48 of @xmath71 _ full _ if either ( i ) @xmath48 is the root ; ( ii ) @xmath48 is a non - empty leaf ; or ( iii ) @xmath366 has a directed pair @xmath324 .",
    "let @xmath146 be the tree obtained from @xmath71 by connecting every full node to its closest full ancestor , and by removing the other nodes .",
    "we can compute @xmath146 in linear time through a post - order traversal .",
    "now , for every leaf @xmath19 of @xmath146 , put the point @xmath367 into the sets @xmath360 , where @xmath48 is one the @xmath301 is a sufficiently large constant .",
    "] closest ancestors of @xmath19 in @xmath146 . repeat this procedure , while changing property ( iii ) above so that @xmath365 has a directed pair @xmath368 .",
    "this takes linear time , and @xmath346 .",
    "intuitively , @xmath360 contains those points of @xmath335 that are sufficiently on the outside of the point set in direction @xmath322 .",
    "figure  [ fig : qt - example+qt - wspd+qt - zu ] shows an example",
    ". variants of the following claim have appeared several times before  @xcite .",
    "[ clm : lune_nn ] let @xmath369 , and let @xmath370 denote the cone with apex @xmath327 and opening angle @xmath371 centered around @xmath322 .",
    "suppose that @xmath356 is an edge of @xmath2 and @xmath372 .",
    "then @xmath279 is the nearest neighbor of @xmath327 in @xmath373 .",
    "if @xmath356 is an edge of @xmath2 , then the _ lune _ @xmath193 defined by @xmath327 and @xmath279 contains no point of @xmath0  @xcite .",
    "is the intersection of two disks with radius @xmath374 , one centered at @xmath327 , the other centered at @xmath279 .",
    "] since the opening angle of @xmath370 is at most @xmath375 , for @xmath10 small enough , the intersection of @xmath370 with @xmath193 equals the intersection of @xmath370 with the disk around @xmath327 of radius @xmath374 .",
    "hence , @xmath279 must be the nearest neighbor of @xmath327 in @xmath373 .",
    "[ lem : constant - levels ] let @xmath356 be an edge of @xmath2 with direction @xmath322 , and let @xmath90 be the corresponding wspd - pair .",
    "then @xmath376 .",
    "let @xmath80 be the leaf for @xmath327 , and suppose for contradiction that @xmath377 , i.e. , @xmath48 is not among the @xmath301 closest ancestors of @xmath80 in @xmath146 .",
    "this means there exists a sequence @xmath378 of @xmath379 distinct ancestors of @xmath80 , such that each node is an ancestor of all previous nodes and such there are well - separated pairs @xmath380 .",
    "let @xmath370 be the cone with apex @xmath327 and opening angle @xmath371 centered around @xmath322 . by observation  [ obs : small - phi ]",
    ", we have @xmath381 .",
    "furthermore , since @xmath85 is well - separated , @xmath382 .",
    "now claim  [ clm : quad - squares ] implies that there are squares @xmath383 , @xmath384 such that ( i ) @xmath385 and @xmath386 ; ( ii ) @xmath387 ; and ( iii ) @xmath388 .",
    "this means that @xmath389 where in the first inequality we bounded the distance between any point in @xmath383 and any point in @xmath384 by the distance between the squares plus their diameter ( since we do not know where the points lie inside the squares ) .",
    "the second inequality comes from @xmath390 and the third inequality is due to the fact that @xmath391 lies at least @xmath392 levels below @xmath27 in @xmath146 .",
    "since @xmath393 for @xmath394 and since @xmath395 , this contradicts the fact that @xmath279 is the nearest neighbor of @xmath327 inside @xmath370 ( claim  [ clm : lune_nn ] ) .",
    "thus , @xmath327 must lie in @xmath360 .",
    "a symmetric argument shows @xmath396 .    [",
    "[ step-2-finding - the - mathcalp_us . ] ] step 2 : finding the @xmath353 s .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for every node @xmath344 , we include in @xmath353 the @xmath301 shortest pairs in direction @xmath322 , i.e. , the pairs @xmath100 such that ( i ) @xmath25 is contained in the @xmath10-cone @xmath397 with apex @xmath313 centered around direction @xmath322 ; and ( ii ) there are less than @xmath301 pairs @xmath398 that fulfill ( i ) and have @xmath399 .",
    "since @xmath301 is constant , the @xmath353 s can be constructed in total linear time .",
    "even though each @xmath353 contains a constant number of elements , a node might still appear in many such sets , so we further prune the pairs : by examining the @xmath353 s , determine for each @xmath400 the set @xmath401 .",
    "for each @xmath402 , find the @xmath301 closest neighbors ( measured by the distance between their center points ) of @xmath19 in @xmath402 , and for all other @xmath353 s remove the corresponding pairs @xmath90 .",
    "now each node appears in only a constant number of pairs of @xmath352 .",
    "[ lem : constant - neighbors ] let @xmath356 be an edge of @xmath2 with orientation @xmath322 , and let @xmath90 be the corresponding wspd - pair",
    ". then @xmath403 .",
    "we show that @xmath19 is among the @xmath301 closest neighbors of @xmath48 in direction @xmath322 , a symmetric argument shows that @xmath48 is among the @xmath301 closest neighbors of @xmath19 in direction @xmath404 .",
    "we may assume that @xmath405 .",
    "suppose that @xmath90 is not among the @xmath301 shortest pairs in direction @xmath322 .",
    "then there is a set @xmath406 of @xmath301 nodes of @xmath71 such that for all @xmath407 we have ( i ) @xmath408 ; ( ii ) @xmath409 ; and ( iii ) @xmath410 . by claim  [ clm : quad - squares ]",
    ", there exists for every @xmath407 a pair of squares @xmath411 such that @xmath412 , @xmath413 and @xmath414 .",
    "let @xmath370 be the cone with apex @xmath327 and opening angle @xmath371 centered around @xmath322 . by observation  [ obs : small - phi ] , @xmath415 for all @xmath407 .",
    "furthermore , every @xmath416 contains a point at distance at most @xmath417 from @xmath327 , because @xmath418 .",
    "also , by claim  [ clm : lune_nn ] , every @xmath416 contains a point at distance at least @xmath419 from @xmath327 .",
    "thus , since @xmath420 by claim  [ clm : quad - squares ] and @xmath421 , we get @xmath422 , for @xmath10 small enough",
    ". however , this implies that @xmath406 has only a constant number of squares : all @xmath416 ( and hence all @xmath423 ) intersect the annular segment @xmath41 inside @xmath370 with inner radius @xmath424 and outer radius @xmath417 ( see figure  [ fig : lune ] ) .",
    "all @xmath407 are unrelated , since they are paired with @xmath48 in @xmath74 .",
    "furthermore , the set @xmath41 has diameter @xmath425 . if @xmath407 is a compressed child , then @xmath423 is contained in the parent of @xmath80 and intersects no other @xmath426 , for @xmath427 .",
    "otherwise , @xmath428 .",
    "thus , if we assign to each compressed child @xmath407 the square @xmath423 and to each other node @xmath407 the square @xmath416 , we get a collection of @xmath301 disjoint squares that meet @xmath41 and each have diameter @xmath429 .",
    "since @xmath41 has diameter @xmath425 , there can be only a constant number of such squares , so choosing @xmath301 large enough leads to a contradiction .    [",
    "[ step-3-finding - the - nearest - neighbors . ] ] step 3 : finding the nearest neighbors .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    unlike in the previous steps , the algorithm for step 3 is a bit involved , so we switch the order and begin by showing correctness .",
    "[ lem : emst_nn ] let @xmath356 be an edge of @xmath2 with direction @xmath322 and let @xmath90 be the corresponding wspd - pair . then @xmath357 is the closest pair in @xmath358 .    by lemma  [ lem : constant - levels ] , we have @xmath376 .",
    "furthermore , the cut property of minimum spanning trees implies that @xmath430 . since @xmath85 is well - separated , we have @xmath431 now consider an execution of kruskal s mst algorithm on @xmath432  ( * ? ? ?",
    "* chapter  23.2 ) .",
    "let @xmath433 be the closest pair in @xmath358 .",
    "by @xmath434 , the algorithm considers @xmath435 only after processing all edges in @xmath436 .",
    "hence , at that point the sets @xmath360 and @xmath437 are each contained in a connected component of the partial spanning tree , and @xmath438 can have at most one edge from @xmath358 .",
    "hence , it follows that @xmath439 , as claimed .",
    "we now describe the algorithm . for ease of exposition ,",
    "we take @xmath440 ( i.e. , we assume that @xmath0 is rotated so that @xmath322 points in the positive @xmath441-direction ) . note that now the squares are not generally axis - aligned anymore , but this will be no problem .",
    "given a point @xmath442 , we define the four _ directional cones _",
    "@xmath443,@xmath444 , @xmath445 , and @xmath446 as the leftward , upward , rightward and downward cones with apex @xmath327 and opening angle @xmath447 .",
    "the directional cones subdivide the plane into four disjoint sectors .",
    "we will also need the _ extended _ rightward cone @xmath448 with apex @xmath327 and opening angle @xmath449 .",
    "[ clm : emptycone ] let @xmath363 be a directed pair in @xmath365 , and suppose that @xmath357 with @xmath450 and @xmath451 is the closest pair for @xmath363 . then @xmath452 and @xmath453",
    ", so @xmath454 and @xmath455 mean `` in direction @xmath322 '' and `` in direction @xmath404 '' . ]",
    "we prove the claim for @xmath456 , the argument for @xmath444 is symmetric .",
    "we may assume that @xmath457 .",
    "by assumption , the unit disk @xmath291 centered at @xmath327 contains no points of @xmath21 , so it suffices to show that @xmath458 . since @xmath459 and by observation  [ obs : small - phi ] , the direction of the line @xmath460 differs from @xmath322 by at most @xmath371 .",
    "therefore , the intersections of the boundaries of @xmath456 and @xmath291 have distance at least @xmath461 from @xmath279 .",
    "however , the pair @xmath90 is well - separated , so all points in @xmath21 have distance at most @xmath10 from @xmath279 , which implies the claim ; see figure  [ fig : closest - cone ] .",
    "given a set @xmath360 for a node @xmath48 of @xmath71 , we define the _ upper chain _ of @xmath360 , @xmath462 as follows : remove from @xmath360 all points @xmath327 such that @xmath444 contains a point from @xmath360 in its interior .",
    "then sort @xmath360 by @xmath463-coordinate and connect consecutive points by line segments .",
    "all segments of @xmath462 have slopes in @xmath464 $ ] .",
    "similarly , we define the _ lower chain _ of @xmath360 , @xmath465 , by requiring the cones @xmath446 for the points in @xmath465 to be empty .",
    "the goal now is to compute @xmath462 and @xmath465 for all nodes @xmath48 .",
    "define a directed graph @xmath466 as follows : we create two copies of each vertex @xmath48 in @xmath71 , called @xmath467 and @xmath468 , and we add a directed edge from @xmath467 to @xmath468 for each such vertex .",
    "furthermore , we replace every edge @xmath469 of @xmath71 ( @xmath48 being the parent of @xmath19 ) by two edges : one from @xmath467 to @xmath470 , and one from @xmath471 to @xmath468 .",
    "we call these edges the _ tree_-edges .",
    "finally , for every pair @xmath94 , where @xmath20 is wholly contained in the extended rightward cone @xmath472 , we create a directed edge from @xmath468 to @xmath470 .",
    "these edges are called _ wspd_-edges . figure  [ fig : chain - care+chain - graph ] shows a small example .    [ clm : acyclic ] the graph @xmath466 is acyclic .",
    "suppose @xmath181 is a cycle in @xmath466 .",
    "the tree - edges form an acyclic subgraph , so @xmath181 has at least one wspd - edge .",
    "let @xmath473 be the sequence of wspd - edges along @xmath181 , and let @xmath474 be such that the endpoint of @xmath475 is of the form @xmath476 . finally , write @xmath477 , where @xmath478 is the sequence of tree - edges between two consecutive wspd - edges .",
    "each @xmath478 consists of a ( possibly empty ) sequence of @xmath479 edges , followed by one @xmath480 edge and a ( possibly empty ) sequence of @xmath481 edges .",
    "thus , the origin of the next wspd - edge @xmath482 is an @xmath483-node for an ancestor or a descendant of @xmath484 in @xmath71 . in either case , by the definition of wspd - edges , it follows that the leftmost point of @xmath485 lies strictly to the right of the leftmost point of @xmath486 .",
    "indeed , write @xmath487",
    ". then @xmath485 lies strictly to the right of @xmath488 , because @xmath489 and because @xmath490 is well - separated .",
    "if @xmath491 is a descendant of @xmath484 , then @xmath492 and the leftmost point of @xmath488 can not lie to the left of the leftmost point of @xmath486 , which implies the claim . if @xmath491 is an ancestor of @xmath484 ,",
    "then all of @xmath485 is strictly to the right of @xmath486 , and the claim follows again .",
    "thus , the leftmost point of @xmath485 lies strictly to the right of the leftmost point of @xmath493 and the leftmost point of @xmath494 lies strictly to the right of the leftmost point in @xmath495 , which is absurd .",
    "let @xmath496 be a topological ordering of the nodes of @xmath466 .",
    "[ clm : order ] any pair @xmath497 of points in @xmath360 with @xmath498 satisfies @xmath499 .",
    "[ clm : respecting_order ] suppose for the sake of contradiction that @xmath500 .",
    "let @xmath19 , @xmath80 be the descendants of @xmath48 such that @xmath451 , @xmath501 , and @xmath502 . by observation  [ obs : small - phi ]",
    ", @xmath416 lies completely in the extended rightward cone @xmath503 , so @xmath466 has an edge from @xmath471 to @xmath504 .",
    "now the tree edges in @xmath466 require that the leaf with @xmath279 comes before @xmath471 and the leaf with @xmath327 comes after @xmath504 , and the claim follows .",
    "since all edges on @xmath462 have slopes in @xmath505 $ ] , we immediately have the following corollary .",
    "the ordering @xmath506 respects the orders of @xmath462 and @xmath465 .    for every node @xmath344 ,",
    "let @xmath507 be the order that @xmath496 induces on the leaf nodes corresponding to @xmath360 .",
    "[ clm : topo_sort ] all the orderings @xmath507 can be found in total time @xmath89 .    to find the orderings @xmath507 ,",
    "perform a topological sort on @xmath466 , in linear time has @xmath89 edges , as @xmath508 . ]",
    "* chapter  22.4 ) . with each node @xmath48 of @xmath71",
    "store a list @xmath509 , initially empty .",
    "we scan the nodes of @xmath466 in order . whenever we see a leaf for a point @xmath369 , we append @xmath327 to the at most @xmath510 lists @xmath509 for the nodes @xmath48 with @xmath511 .",
    "the total running time is @xmath512 , and @xmath509 is sorted according to @xmath507 for each @xmath344 .",
    "[ clm : finduclc ] for any node @xmath344 , if @xmath360 is sorted according to @xmath513 , we can find @xmath462 and @xmath465 in time @xmath514 .",
    "we can find @xmath462 by a graham - type pass through @xmath509 .",
    "an example of such a list is shown in figure  [ fig : topo - chain ] .",
    "that is , we scan @xmath509 from left to right , maintaining a tentative upper chain @xmath39 , stored as a stack .",
    "let @xmath13 be the rightmost point of @xmath39 . on scanning a new point @xmath327 , we distinguish cases depending in which of the four quadrants @xmath515 , @xmath516 , @xmath517 , or @xmath518 it lies in . by claim  [ clm : respecting_order ] , we know that @xmath519 . if @xmath520 , we discard @xmath327 and continue to the next point in @xmath509 . if @xmath521 , we pop @xmath13 from @xmath39 and reassess @xmath327 from the point of view of the new rightmost point of @xmath39 .",
    "if @xmath522 , we push @xmath327 onto @xmath39 .",
    "the algorithm takes @xmath514 time , because every point is pushed or popped from the stack at most once and because it takes constant time to decide which point to push or pop .",
    "now we argue correctness . for this",
    ", we use induction in order to prove that after @xmath63 steps , we have correctly computed the upper chain for the first @xmath63 points in @xmath509 , @xmath523 .",
    "this clearly holds for the first point .",
    "now consider the cases for the @xmath524-th point @xmath327 .    * if @xmath520 , then @xmath327 is certainly not on the upper chain .",
    "furthermore , @xmath525 , so @xmath327 can not conflict with any other point on @xmath523 , so in this case @xmath526 . *",
    "if @xmath521 , then @xmath527 and @xmath327 must be on @xmath528 .",
    "furthermore , every point that we remove from @xmath523 has @xmath327 in its upper cone and can not be on @xmath528 .",
    "now let @xmath529 be the first point of @xmath523 that is not popped .",
    "since @xmath530 and since the remainder of @xmath523 lies inside of @xmath531 , there are no conflicts between @xmath327 and the points we have not popped . thus @xmath528 is computed correctly . *",
    "if @xmath522 , then @xmath532 , and @xmath327 is on @xmath528 , because @xmath517 contains no points from @xmath533 .",
    "futhermore , @xmath523 is contained in @xmath443 , so @xmath327 conflicts with no point on @xmath523 and the result is correct .",
    "this finished the inductive step and the correctness proof .",
    "the lower chain is computed in an analogous manner .",
    "[ clm : find_closest ] for any node @xmath344 and any pair @xmath90 in @xmath353 , given @xmath462 and @xmath534 , we can find the closest pair in @xmath358 in time @xmath535 .",
    "connect the endpoints of @xmath462 and @xmath534 to obtain a simple polygon ( note that the two new edges can not intersect the chains , because @xmath90 has direction @xmath536 , so by observation  [ obs : small - phi ] @xmath537 $ ] and all edges of the chains have slopes in @xmath464 $ ] ) . then use the algorithm of chin and wang  @xcite to find the constrained dt of the polygon in time @xmath535 .",
    "the closest pair will appear as an edge in this dt , and hence can be found in the claimed time .-",
    "monotone , so the most difficult part of the algorithm by chin and wang  @xcite , finding the visibility map of the polygon  @xcite , becomes much easier  @xcite .",
    "the problem may allow a much more direct solution , but since we will later require chin and wang s algorithm in full generality , we do not pursue this direction . ]",
    "[ lem : findnn ] in total linear time , we can find for every @xmath344 and for every pair @xmath403 the closest pair in @xmath358 .    by claims  [ clm :",
    "topo_sort ] , [ clm : finduclc ] , [ clm : find_closest ] , the time to find all the closest pairs is proportional to @xmath538 because every @xmath19 appears in only a constant number of @xmath353 s .",
    "[ [ putting - it - together . ] ] putting it together .",
    "+ + + + + + + + + + + + + + + + + + + +    we thus obtain the main result of this section .",
    "[ thm : qtree->h ] given a compressed quadtree @xmath71 for @xmath0 and _ @xmath74 _ , we can find a graph @xmath330 with @xmath89 edges such that @xmath330 contains all edges of @xmath2 .",
    "it takes @xmath89 time to construct @xmath330 .    the fact that @xmath330 contains the emst follows from lemmas  [ lem : constant - levels ] , [ lem : constant - neighbors ] and [ lem : emst_nn ] .",
    "the running time follows from the discussion at the beginning of steps 1 and 2 and from lemma  [ lem : findnn ] .",
    "we want to extract @xmath2 , but no general - purpose deterministic linear time pointer machine algorithm for this problem is known : the fastest such algorithm whose running time can be analyzed needs @xmath539 steps  @xcite .",
    "however , the special structure of the graph @xmath330 and the @xmath18-cluster quadtree @xmath71 make it possible to achieve linear time .",
    "we know that @xmath330 contains all emst edges .",
    "furthermore , by construction each edge of @xmath330 corresponds to a wspd - pair .",
    "thus , we can associate each edge @xmath540 of @xmath330 with two nodes @xmath48 and @xmath19 such that @xmath90 is the wspd - pair for the endpoints of @xmath540 . the pruning operation in step  2 of section  [",
    "sec : emstsup ] ensures that each node is associated with @xmath196 edges of @xmath330 , and we store a list of these edges at each node of @xmath71 .",
    "now we use theorem  [ thm : cluster - compressed - equiv ] to convert our quadtree into a @xmath18-cluster quadtree @xmath71 . during this conversion",
    ", we can preserve the information about which edges of @xmath330 are associated with which nodes of @xmath71 , because each old square overlaps with only a constant number of new squares of similar size .",
    "a special case are those edges that have an endpoint associated with a compressed child . during the conversion of theorem  [ thm : cluster - compressed - equiv ] ,",
    "compressed children either become regular squares ( during the balancing operation ) , or they correspond to @xmath18-clusters and are replaced by representative points in the parent tree . in the former case , we handle the compressed child just like any regular square , in the latter case , we associate @xmath540 with the square that contains the representative point for the @xmath18-cluster .",
    "next , we would like ensure for each edge @xmath540 of @xmath330 that the associated squares in @xmath71 have size between @xmath541 and @xmath542 , where @xmath543 denotes the length of @xmath540 .",
    "for the endpoints that were associated with regular squares in the original quadtree , such a square can be found by considering a constant number of ancestors and descendants in @xmath71 , by claim  [ clm : quad - squares ] .",
    "if the associated square was a compressed child that has become a regular square , we may need to consider more than a constant number of ancestors , but each such ancestor is considered only a constant number of times , since the compressed child has a constant number of associated edges . if @xmath540 has an endpoint that is now associated with a representative point , we may need to subdivide the square containing the representative point , but by corollary  [ cor : c - cluster - qt - extended ] the total work is linear .",
    "thus , in total linear time we can obtain a @xmath18-cluster tree @xmath71 such that each square of @xmath71 is associated with @xmath196 edges of @xmath330 and such that the two associated square of each edge @xmath540 of @xmath330 contain the endpoints of @xmath540 and have size @xmath544 .    by the cut property of minimum spanning trees , @xmath2 is connected within each @xmath18-cluster .",
    "thus , we can process the clusters bottom - up , and we only need to find the emst within a @xmath18-cluster given that the points in each child are already connected . within this cluster , @xmath71 is a regular uncompressed quadtree , and we can use the structure of @xmath71 to perform an appropriate variant of borvka s mst algorithm  @xcite in linear time .    [",
    "lem : extract - emst ] let @xmath146 be a subtree of @xmath71 corresponding to a @xmath18-cluster , and let @xmath545 be the edges in @xmath330 associated with @xmath146 . then @xmath546 can be computed in time @xmath547 .",
    "let @xmath548 be the size of the root square of @xmath146 . through a level order traversal of @xmath146",
    "we group the squares in @xmath549 by height into layers @xmath550 , @xmath551 , @xmath163 , @xmath552 ( where @xmath550 is the bottommost layer , and @xmath552 contains only the root ) .",
    "the squares in @xmath553 have size @xmath554 .",
    "as stated above , each square @xmath142 has a constant number of associated edges in @xmath545 that have one endpoint in @xmath142 and length length between @xmath555 and @xmath556 . to find the emst",
    ", we subdivide the edges into sets @xmath557 , where @xmath557 contains all edges with length in @xmath558 .",
    "given the @xmath553 , we can determine the sets @xmath557 in total time @xmath547 , as the edges for @xmath557 are associated only with squares in @xmath559 , @xmath560 , @xmath163 , @xmath561 , for some constant @xmath562 .",
    "note that every edge in @xmath557 is crossed by @xmath196 other edges in @xmath557 , because all @xmath563 have roughly the same length and because every pair of squares in @xmath553 has only a constant number of associated edges in @xmath557 .",
    "now we compute the emst by processing the sets @xmath564 , @xmath163 , @xmath565 in order . here",
    "is how to process @xmath557 .",
    "we consider the squares in @xmath553 .",
    "assume that we know for each square of @xmath553 the connected component in the current partial emst it meets ( initially each @xmath18-cluster is its own component ) . by the cut property , every square @xmath142 meets only one connected component , as @xmath142 is much smaller than the edges in @xmath557 .",
    "eliminate all edges in @xmath557 between squares in the same component , and remove duplicate edges between each two components , keeping only the shortest of these edges ( this takes @xmath566 time with appropriate pointer manipulation ) . then find the shortest edge out of each component and add these edges to the partial emst .",
    "determine the new components and merge their associated edge sets .",
    "this sequence of steps is called a _",
    "borvka - phase_. perform borvka - phases until @xmath557 has no edges left .    by the crossing - number inequality  ( * ? ? ?",
    "* theorem  4.3.1 ) , the number of edges considered in each phase is proportional to the number @xmath13 of components with an outgoing edge in that phase . indeed , viewing each component as a supervertex , we have an embedding of a graph with @xmath13 vertices and @xmath567 edges such that there are @xmath568 crossings ( since every edge @xmath563 is crossed by @xmath196 other edges in @xmath557 ) .",
    "thus , the crossing number inequality yields @xmath569 , for some constant @xmath570 , so @xmath571 . since the number of components at least halves in each phase , and since initially there are at most @xmath572 components , the total time for @xmath557 is @xmath573 .",
    "finally , label each square in @xmath574 with the component it meets and proceed with round @xmath575 . in total ,",
    "processing @xmath71 takes time @xmath576 , as desired .",
    "we conclude :    [ thm : wspd->dt ] let @xmath0 be a planar point set and @xmath71 be a compressed quadtree or a @xmath18-cluster quadtree for @xmath0 .",
    "then @xmath1 can be computed in time @xmath577 .",
    "if @xmath71 is a @xmath18-cluster quadtree , invoke theorem  [ thm : cluster - compressed - equiv ] to convert it to a compressed quadtree .",
    "then use theorem  [ thm : wspd ] to obtain @xmath74 .",
    "next , apply theorem  [ thm : qtree->h ] to compute the supergraph @xmath330 of @xmath2 .",
    "after that , if necessary , convert @xmath71 to a @xmath18-cluster quadtree for @xmath0 via theorem  [ thm : cluster - compressed - equiv ] , and apply lemma  [ lem : extract - emst ] to each @xmath18-cluster , in a bottom - up manner , to extract @xmath2 .",
    "finally , apply the algorithm by chin and wang  @xcite to find @xmath1 .",
    "all this takes time @xmath577 , as claimed .",
    "for the second direction of our equivalence we need to show how to compute a @xmath18-cluster quadtree for @xmath0 when given @xmath1 .",
    "this was already done by krznaric and levcopolous  @xcite , but their algorithm works in a stronger model of computation which includes the floor function and allows access to data at the bit level . as argued in the introduction , we prefer the real ram / pointer machine , so we need to do some work to adapt their algorithm to our computational model . in this section",
    "we describe how krznaric and levcopolous s algorithm can be modified to avoid bucketing and bit - twiddling techniques .",
    "the only difference is that in the resulting @xmath18-cluster quadtree the squares for the @xmath18-clusters are not perfectly aligned with the squares of the parent quadtree . in our setting , this does not matter .",
    "the goal of this section is to prove the following theorem .",
    "[ thm : dt->c - cluster - qt ] given @xmath1 , we can compute a @xmath18-cluster quadtree for @xmath0 in linear deterministic time on a pointer machine .    in the following",
    ", we will refer to the paper by krznaric and levcopolous  @xcite as kl .",
    "our description is meant to be self - contained ; however , we refer the reader to kl for more intuition and a more elaborate description of the main ideas .",
    "we begin by recalling some terminology from kl .",
    "* * neighborhood . *",
    "the _ neighborhood _ of a square @xmath142 of a quadtree consists of the 25 squares of size @xmath145 concentric around @xmath142 ( including @xmath142 ) ; see figure  [ fig : neighbors ] . * * direct neighborhood . *",
    "the _ direct neighborhood _ of a square @xmath142 consists of the 9 squares of size @xmath145 directly adjacent to @xmath142 ( including @xmath142 ) ; see figure  [ fig : neighbors ] . * * star of a square .",
    "* let @xmath0 be a planar point set , and let @xmath142 be a square .",
    "the _ star _ of @xmath142 , denoted by @xmath578 , is the set of all edges @xmath540 in @xmath1 such that ( i ) @xmath540 has one endpoint inside @xmath142 and one endpoint outside the neighborhood of @xmath142 ; and ( ii ) @xmath579 , where @xmath543 is the length of @xmath540 . * * dilation .",
    "* let @xmath0 be a planar point set , and @xmath580 a connected plane graph with vertex set @xmath0 .",
    "the _ dilation _ of @xmath0 is the distortion between the shortest path metric in @xmath580 and the euclidean distance , i.e. , the maximum ratio , over all pairs of distinct points @xmath581 , between the length of the shortest path in @xmath580 from @xmath327 to @xmath279 , and @xmath374 .",
    "there are many families of planar graphs whose dilation is bounded by a constant  @xcite . in particular , for any planar point set @xmath0 , the dilation of @xmath1 is bounded by @xmath582  @xcite . * * orientation . *",
    "the _ orientation _ of a line segment @xmath540 is the angle the line through @xmath540 makes with the @xmath463-axis .      by theorem  [ thm : c - cluster - tree ]",
    ", we can obtain a @xmath18-cluster tree @xmath47 for @xmath0 in linear time , given @xmath1 .",
    "thus , we only need to construct the regular quadtrees @xmath143 for each node @xmath48 in @xmath47 .",
    "this is done by processing each node of @xmath47 individually .",
    "first , however , we need to perform a preprocessing step in order to find for each edge @xmath540 of @xmath1 the node of @xmath47 that is the least common ancestor of @xmath540 s endpoints . for every node @xmath583",
    ", we define @xmath584 as the set of edges in @xmath1 that have exactly one endpoint in @xmath335 and both endpoints in @xmath585 .",
    "clearly , every edge is contained in exactly two sets @xmath584 and @xmath586 , where @xmath48 and @xmath19 are siblings in @xmath47 .",
    "the following is a simple variant of a lemma from kl  ( * ? ? ?",
    "* lemma  3 ) .",
    "[ lem : out ] let @xmath0 be a planar @xmath11-point set . given @xmath587 and a @xmath18-cluster tree @xmath47 for @xmath0 , the sets _",
    "@xmath584 _ for every node @xmath583 can be found in overall @xmath89 time and space on a pointer machine .",
    "kl show how to reduce the problem of determining the sets @xmath584 to @xmath89 off - line least - common ancestor ( lca ) queries in two appropriate trees .",
    "for the lca - queries , they invoke an algorithm by harel and tarjan  @xcite that requires the word ram .",
    "however , since all lca - queries are known in advance ( i.e. , the queries are _ off - line _ ) , we may instead use an algorithm by buchsbaum _",
    "et al . _",
    "* theorem  6.1 ) which requires @xmath89 time and space on a pointer machine .",
    "we now describe the preprocessing that is necessary on a single node @xmath48 of @xmath47 before the quadtree @xmath143 can be constructed .",
    "let @xmath588 be the children of @xmath48 .",
    "for each child @xmath484 , let @xmath589 .",
    "[ clm : delta_i ] for @xmath59 , _",
    "@xmath590 _ contains an edge of length @xmath591 .",
    "if @xmath1 contains an edge @xmath540 with an endpoint in @xmath167 and with length @xmath591 , then @xmath540 must be in @xmath590 , by the definition of a @xmath18-cluster .",
    "since @xmath2 is a subgraph of @xmath1 , it thus suffices to show that @xmath2 contains such an edge .",
    "consider running kruskal s mst algorithm on @xmath0 . according to the definition of a @xmath18-cluster , by the time the algorithm considers the edge @xmath540 that achieves @xmath591",
    ", the partially constructed emst contains exactly one connected component that has precisely the points in @xmath167 .",
    "therefore , @xmath592 , and the claim follows .    [ [ initialization . ] ] initialization .",
    "+ + + + + + + + + + + + + + +    by scanning the sets @xmath590 , we determine a child @xmath593 with minimum @xmath594 ( by claim  [ clm : delta_i ] a shortest edge in @xmath590 has length @xmath591 ) .",
    "we may assume that @xmath595 .",
    "let @xmath596 be a square that contains @xmath597 and that has side - length @xmath598 .",
    "let @xmath562 be the smallest integer such that four squares of size @xmath599 cover all of @xmath335 .",
    "lemma  [ lem : c - cluster - qt ] implies that @xmath600 .",
    "the goal is to compute @xmath143 , the balanced regular quadtree aligned at @xmath596 such that each @xmath167 is contained in squares of size @xmath601 .",
    "to begin , we use @xmath596 to initialize @xmath143 as the partial balanced quadtree @xmath143 shown in figure  [ fig : initialqt ] .",
    "every square @xmath142 of @xmath143 stores the following fields :    * @xmath602 : a pointer to the parent square , @xmath603 for the root ; * @xmath604 : pointers for the four children of @xmath142 , @xmath603 for a leaf ; * @xmath605 : links to the four orthogonal neighbors of @xmath142 in the quadtree @xmath143 with size @xmath145 ( or size @xmath286 , if no smaller neighbor exists ) ;    the fields @xmath602 , @xmath604 , and @xmath605 are initialized for all the nodes in @xmath606 .",
    "[ lem : node - init ] the total time for the initialization phase is _",
    "@xmath607_.    by lemma  [ lem : c - cluster - qt ] , the initial size of @xmath143 is @xmath148 .",
    "all other operations consist of scanning the ` out`-lists or are linear in the size of @xmath143 .",
    "@xmath608    1 .",
    "[ step : actives ] set @xmath609 .",
    "2 .   set @xmath610 .",
    "[ step : loop ] until the squares in @xmath611 have size greater than @xmath612 : 1 .",
    "[ step : activeloop ] for every square @xmath142 in @xmath611 call the function @xmath613 to determine @xmath578 .",
    "append @xmath614 to @xmath615 , if it is not present yet .",
    "[ step : starloop ] for every edge @xmath616 , if @xmath540 has an endpoint in an undiscovered cluster , call the function @xmath617 , and append all the squares returned by this call to @xmath615 .",
    "[ step : newactive ] set @xmath618 .",
    "@xmath617    1 .",
    "walk along @xmath540 through the current @xmath143 to find the square @xmath171 of @xmath143 that contains the other endpoint of @xmath540 .",
    "this tracing is done by following the appropriate @xmath619 pointers from @xmath142 .",
    "[ step : refine ] refine @xmath143 for the new cluster , and let @xmath620 be the set of leaf squares containing the newly discovered cluster .",
    "3 .   call @xmath621 . afterwards , return the @xmath611 squares from the recursive call .",
    "now we build the tree @xmath143 by a traversing @xmath1 in a way reminiscent of dijkstra s algorithm  @xcite . in their algorithm , kl make extensive use of the floor function in order to locate points inside their quadtree squares .",
    "the purpose of this section is to argue that this point location work can be done through local traversal of the quadtree , without the floor function .",
    "refer to algorithm  [ alg : explore ] .",
    "the heart of the algorithm is the procedure @xmath622 , which is initially called as @xmath623 .",
    "the procedure @xmath622 builds the tree @xmath143 level by level , beginning with the level of @xmath596 . at each point",
    ", it maintains a set @xmath611 of all squares at the current level that contain a cluster that has already been processed . for each such square @xmath142 , it calls a function @xmath624 . this function returns all edges of the delaunay triangulation that have one endpoint in @xmath142 and have length @xmath625 , for a constant @xmath562 . using @xmath624 we can new clusters whose distance from the active clusters is comparable to the size of the squares in the current level .",
    "we will say more about the implementation @xmath624 below . for each new cluster",
    ", we call the procedure @xmath626 which adds more squares to @xmath143 to accommodate the new cluster and recursively explores the short edges out of this new cluster .",
    "after the recursive call has finished , we can continue the exploration of the tree at the current level .",
    "we now give the details for the refinement in step  [ step : refine ] of @xmath626 : let @xmath593 be the cluster that contains the other endpoint @xmath279 of @xmath540 ( we can find @xmath593 in constant time , since @xmath627 , and since for each edge we store the two clusters whose @xmath628-lists contain it ) . subdivide the current leaf square containing @xmath279 ( and possibly also its neighbors if they contain points from @xmath629 ) in quadtree - fashion until @xmath629 is contained in squares of size @xmath630 .",
    "then balance the quadtree and update the @xmath619 pointers accordingly .",
    "the algorithm is recursive , and at each point there exists a sequence @xmath631 , @xmath632 , @xmath163 , @xmath633 of instantiations ( i.e. , stack frames ) of @xmath622 , where @xmath634 was invoked by @xmath635 .",
    "each @xmath636 has a set @xmath637 of active squares , such that all squares in each @xmath637 have the same size , and such that the squares in @xmath638 are not larger than the squares in @xmath637 .",
    "we say that a square is active if it is contained in @xmath639 .",
    "the neighborhood of @xmath640 is the union of the neighborhoods of all boxes in @xmath611 .",
    "we maintain the following invariant :    [ inv : neighborhood ] at all times during the execution of _",
    "@xmath622 _ ,",
    "all undiscovered @xmath18-clusters lie outside the neighborhood of _ @xmath640_.    [ clm : invariant ] invariant  [ inv : neighborhood ] is maintained by _",
    "the set @xmath640 only changes in steps  [ step : actives ] and [ step : newactive ] .",
    "the invariant is maintained in step  [ step : actives ] , since the size of the squares in @xmath179 ( i.e. , @xmath641 is chosen such that their neighborhoods can contain no point from any other cluster .",
    "let us now consider step  [ step : newactive ] . the set @xmath615 contains two kinds of squares : ( i ) the parents of squares processed in the current iteration of the main loop ; and ( ii ) squares that were added to @xmath615 after a recursive call .",
    "we only need to focus on squares of type ( i ) , since squares of type ( ii ) are already added to @xmath640 during the recursive call .",
    "suppose that @xmath640 contains a square @xmath142 whose neighborhood has a point @xmath369 in an undiscovered cluster .",
    "since @xmath642 , there is a point @xmath643 , and by the definition of neighborhood , we have @xmath644 .",
    "however , since the dilation of @xmath1 is at most @xmath645  @xcite , @xmath1 contains a path @xmath646 of length at most @xmath647 from @xmath327 to @xmath279 .",
    "let @xmath648 be the last discovered point along @xmath646 .",
    "the point @xmath648 lies in an active square @xmath171 with @xmath649 , and the edge @xmath540 leaving @xmath648 on @xmath646 has length at most @xmath650 .",
    "therefore , @xmath651 for a descendant @xmath174 of @xmath171 , which contradicts the fact that @xmath648 is the last discovered point along @xmath646 .",
    "[ lem : node - explore ] the total running time of _",
    "@xmath622 _ , excluding the calls to _ @xmath624 _ , is _",
    "@xmath607_.    all squares appearing in @xmath640 are ancestors of non - empty leaf squares in the final tree @xmath143 .",
    "therefore , by lemma  [ lem : c - cluster - qt ] , the total number of iterations for the loop in step  [ step : activeloop ] is @xmath148 .",
    "furthermore , @xmath578 contains only edges of length @xmath652 , so every edge appears in only a constant number of stars .",
    "it follows that the total size of the @xmath653-lists , and hence the total number of iterations of the loop in step  [ step : starloop ] is @xmath654 .",
    "it remains to bound the time for tracing the edges and balancing the tree . since @xmath143 is balanced and since @xmath578 contains only edges of length @xmath652 , the tracing along the @xmath619 pointers of an edge takes constant time ( since we traverse a constant number of boxes of size @xmath652 ) . by invariant  [ inv : neighborhood ] , the other endpoint of the edge is contained in a leaf square of the current @xmath143 of size @xmath652 .",
    "( this is because the quadtree is balanced and because the other endpoint of the edge lies outside the neighborhood of the active squares . ) therefore , the time to build the balanced quadtree for the new leaf squares containing the newly discovered cluster can be charged to the corresponding nodes in the final @xmath143 , of which there are @xmath148 .",
    "furthermore , note that by invariant  [ inv : neighborhood ] , balancing the quadtree for the newly discovered leaf squares does not affect any descendants of the active squares .",
    "kl show how to exploit the geometric properties of the delaunay triangulation in order to implement the function @xmath624 , quickly .",
    "for this , they store two additional fields with each active square , called @xmath655 and @xmath656  ( * ? ? ?",
    "* section  6 ) , and they explain how to maintain these lists throughout the procedure . this part of the algorithm works on a real ram / pointer machine without any further modification , so we just state their result .",
    "[ lem : findstar ] the total time for all calls to _ @xmath624 _ and the maintenance of the required data structures is _",
    "@xmath607_.      we can now finally prove theorem  [ thm : dt->c - cluster - qt ] .    first , we use theorem  [ thm : c - cluster - tree ] to find a @xmath18-cluster tree @xmath47 for @xmath0 in @xmath89 time .",
    "next , we use the algorithm from section  [ sec : dt->c - cluster - preprocess ] to preprocess the tree . by lemma  [ lem : out ] , this also takes @xmath89 time .",
    "finally , we process each node of @xmath47 using the algorithm from section  [ sec : one - node ] . by lemmas  [ lem : node - init ] , [ lem : node - explore ] , and [ lem : findstar ] , this takes total time @xmath657 , where the sum ranges over all the nodes of @xmath47 .",
    "this sum is @xmath89 because there are @xmath89 nodes in @xmath47 , and because every edge of @xmath1 appears in exactly two @xmath628-lists .",
    "hence , the total running time is linear , as claimed .",
    "as mentioned in the introduction , our result yields deterministic versions of several recent randomized algorithms related to dts .",
    "firstly , we can immediately derandomize an algorithm for hereditary dts by chazelle  _ et al . _",
    "@xcite :    [ cor : split ] let @xmath0 a planar @xmath11-point set , and let @xmath658 .",
    "given @xmath1 , we can find @xmath659 in deterministic time @xmath89 on a pointer machine .",
    "use theorem  [ thm : dt->c - cluster - qt ] to find a @xmath18-cluster quadtree @xmath71 for @xmath0 , remove the leaves for @xmath660 from @xmath71 and trim it appropriately . might create new @xmath18-clusters .",
    "however , since we are aiming for running time @xmath89 , we can apply theorem  [ thm : wspd->dt ] to a partly compressed quadtree that may contain long paths where every node has only one child .",
    "] finally , apply theorem  [ thm : wspd->dt ] to extract @xmath659 from @xmath71 , in time @xmath89 .",
    "secondly , we obtain deterministic analogues of the algorithms by buchin  _ et al . _",
    "@xcite to preprocess imprecise point sets for faster dts .",
    "for example , we can prove the following :    [ cor : idt ] let @xmath661 be a sequence of @xmath11 @xmath166-fat planar regions so that no point in @xmath662 meets more than @xmath301 of them .",
    "we can preprocess @xmath663 in @xmath664 deterministic time into an @xmath89-size data structure so that given a sequence of @xmath11 points @xmath665 with @xmath666 for all @xmath63 , we can find @xmath1 in deterministic time @xmath667 on a pointer machine .",
    "the method of buchin  _ et al .",
    "_  ( * ? ?",
    "* theorem  4.3 and corollary  5.6 ) proceeds by computing a representative quadtree @xmath71 for @xmath663 . given @xmath0 ,",
    "the algorithm finds for every point in @xmath0 the leaf square of @xmath71 that contains it , and then uses this information to obtain a compressed quadtree @xmath146 for @xmath0 in time @xmath667 .",
    "however , @xmath146 is _ skewed _ in the sense that not all its squares need to be perfectly aligned and that some squares can be cut off .",
    "however , the authors argue that even in this case @xmath74 takes @xmath89 time and yields a linear - size wspd  ( * ? ? ?",
    "* appendix  b ) . the main observation  ( * ? ? ?",
    "* observation  b.1 ) is that any ( truncated ) square @xmath142 in @xmath146 is adjacent to at least one square whose area is at least a constant fraction of the area @xmath142 would have without clipping . since in skewed quadtrees",
    "the size of a node is at most half the size of its parent , the argument of lemma  [ lem : constant - levels ] still applies . to see that lemma  [ lem : constant - neighbors ] holds",
    ", we need to check that the volume argument goes through . for this , note that by the main observation of buchin  _ et al .",
    "_ , we can assign every square @xmath423 ( the notation is as in the proof of lemma  [ lem : constant - neighbors ] ) to an adjacent square of comparable size at distance @xmath425 from @xmath41 .",
    "since every such square is charged by disjoint descendants from a constant number of neighbors , the volume argument still applies , and lemma  [ lem : constant - neighbors ] holds .",
    "lemma  [ lem : findnn ] only relies on well - separation and the combinatorial structure of @xmath71 , and hence remains valid . finally , in order to apply lemma  [ lem : extract - emst ] , we need to turn @xmath146 into a @xmath18-cluster quadtree , which takes linear time by theorem  [ thm : cluster - compressed - equiv ] .",
    "thus , the total running time is @xmath668 , as claimed .",
    "finally , buchin and mulzer  @xcite showed that for word rams , dts are no harder than sorting .",
    "we can now do it deterministically .",
    "let @xmath669 be the time to sort @xmath11 integers on a @xmath80-bit word ram .",
    "the best deterministic bound for @xmath669 is @xmath670  @xcite .",
    ", we can do better . for example , if @xmath671 , radix sort shows that @xmath672  @xcite . ]",
    "[ cor : wramdt ] let @xmath0 be a planar @xmath11-point set given by @xmath80-bit integers , for some word - size @xmath673 .",
    "we can find @xmath1 in deterministic time @xmath674 on a word ram supporting the @xmath675-operation .- bit words , @xmath676 and @xmath677 , we define @xmath678 as the @xmath679-bit word @xmath680 . ]    buchin and mulzer  @xcite show how to find a compressed quadtree @xmath71 for @xmath0 in time @xmath681 , using the @xmath682-operation .",
    "they actually do not find the squares of the quadtree , only the combinatorial structure of @xmath71 and the bounding boxes @xmath22 .",
    "it is easily seen that the algorithm @xmath73 also works in this case .    to apply lemma  [ lem : constant - levels ] , we need to check that the sizes of the bounding boxes decrease geometrically down the tree . for this , consider a node @xmath400 with associated point set @xmath21 and the quadtree square @xmath20 ( i.e. , the smallest aligned square of size @xmath683 such that the coordinates of all points in @xmath21 share the first @xmath684 bits ) .",
    "let @xmath22 be the bounding box of @xmath21 , and let @xmath685 be such that @xmath686 .",
    "clearly , @xmath22 meets at most nine aligned squares of size @xmath687 , arranged in a @xmath688 grid .",
    "hence , any descendant @xmath31 of @xmath19 that is at least five levels below @xmath19 must have @xmath689 , since after at most four ( compressed ) quadtree divisions the squares for @xmath22 have been separated .",
    "thus , the proof of lemma  [ lem : constant - levels ] goes through as before , if we choose @xmath301 larger and consider every fifth node along the chain @xmath378 .",
    "lemma  [ lem : constant - neighbors ] still holds , because every bounding box @xmath22 is contained in a ( possibly much larger ) square @xmath20 , so the volume argument applies .",
    "also , lemma  [ lem : findnn ] only relies on well - separatedness and the combinatorial structure of @xmath71 , so we can find the graph @xmath330 in linear time .",
    "after that , it takes @xmath89 time to compute @xmath2 , using the transdichotomous minimum spanning tree algorithm by fredman and willard  @xcite .",
    "we strengthen the connections between proximity structures in the plane and sharpen several known results between them . even though our results are optimal , the underlying algorithms are still quite subtle , and it may be of interest to see whether some of them can be simplified .",
    "it is also interesting to see whether systematic derandomization techniques , like @xmath10-nets , can be useful to yield alternative deterministic algorithms for some of the problems considered here .",
    "finally , some of the previous results also apply to higher dimensions , whereas we focus exclusively on the plane .",
    "can we obtain analogous derandomizations for @xmath690 ?",
    "this work was initiated while the authors were visiting the computational geometry lab at carleton university .",
    "we would like to thank the group at carleton and especially our hosts jit bose and pat morin for their wonderful hospitality and for creating a great research environment .",
    "we also would like to thank kevin buchin and martin nllenburg for sharing their thoughts on this problem with us .",
    "work on this paper by m. lffler has been supported by the office of naval research under muri grant n00014 - 08 - 1 - 1015 .",
    "work by w. mulzer has been supported in part by nsf grant ccf-0634958 , nsf ccf 083279 , and a wallace memorial fellowship in engineering .",
    "10    p.  k. agarwal , h.  edelsbrunner , o.  schwarzkopf , and e.  welzl .",
    "euclidean minimum spanning trees and bichromatic closest pairs .",
    ", 6(5):407422 , 1991 .",
    "n.  ailon , b.  chazelle , k.  l. clarkson , d.  liu , w.  mulzer , and c.  seshadhri .",
    "self - improving algorithms . , 40(2):350375 , 2011 .",
    "m.  de  berg , o.  cheong , m.  van kreveld , and m.  overmars . .",
    "springer - verlag , berlin , third edition , 2008 .",
    "m.  bern , d.  eppstein , and j.  gilbert .",
    "provably good mesh generation . , 48(3):384409 , 1994 .",
    "m.  bern , d.  eppstein , and s .- h . teng .",
    "parallel construction of quadtrees and quality triangulations .",
    ", 9(6):517532 , 1999 .",
    "boissonnat and m.  yvinec . .",
    "cambridge university press , cambridge , 1998 .",
    "o.  borvka .",
    "o jistm problmu minimlnm . , 3:3758 , 1926 .",
    "k.  buchin , m.  lffler , p.  morin , and w.  mulzer .",
    "delaunay triangulation of imprecise points simplified and extended . , 2010 .",
    "published online , doi:10.1007/s00453 - 010 - 9430 - 0 .",
    "k.  buchin and w.  mulzer .",
    "elaunay triangulations in @xmath691 time and more .",
    ", 58(2):art .  6 , 2011 .    a.  l. buchsbaum , l.  georgiadis , h.  kaplan , a.  rogers , r.  e. tarjan , and j.  r. westbrook .",
    "linear - time algorithms for dominators and other path - evaluation problems .",
    "38(4):15331573 , 2008 .    p.  b. callahan and s.  r. kosaraju .",
    "faster algorithms for some geometric graph problems in higher dimensions . in _ proc .",
    "acm - siam sympos .",
    "discrete algorithms ( soda ) _ , pages 291300 , 1993 .",
    "p.  b. callahan and s.  r. kosaraju . a decomposition of multidimensional point sets with applications to @xmath301-nearest - neighbors and @xmath11-body potential fields .",
    ", 42(1):6790 , 1995 .",
    "t.  m. chan .",
    "well - separated pair decomposition in linear time ?",
    ", 107(5):138141 , 2008 .",
    "t.  m. chan and m.  ptracu .",
    "transdichotomous results in computational geometry , ii : offline search . `",
    "arxiv:1010.1948 ` ( see also stoc 2007 )",
    ".    t.  m. chan and m.  ptracu .",
    "transdichotomous results in computational geometry .",
    "i. point location in sublogarithmic time .",
    ", 39(2):703729 , 2009 .",
    "b.  chazelle .",
    "triangulating a simple polygon in linear time .",
    ", 6(5):485524 , 1991 .",
    "b.  chazelle . a minimum spanning tree algorithm with inverse - ackermann type complexity .",
    ", 47(6):10281047 , 2000 .",
    "b.  chazelle , o.  devillers , f.  hurtado , m.  mora , v.  sacristn , and m.  teillaud .",
    "splitting a delaunay triangulation in linear time .",
    ", 34(1):3946 , 2002 .",
    "b.  chazelle and w.  mulzer .",
    "computing hereditary convex structures .",
    ", 45(2):796823 , 2011 .",
    "f.  chin and c.  a. wang . finding the constrained delaunay triangulation and constrained voronoi diagram of a simple polygon in linear time . , 28(2):471486 , 1999 .",
    "k.  l. clarkson .",
    "fast algorithms for the all nearest neighbors problem . in _ proc .",
    "24th annu .",
    "ieee sympos . found .",
    "( focs ) _ , pages 226232 , 1983 .",
    "t.  h. cormen , c.  e. leiserson , r.  l. rivest , and c.  stein . .",
    "mit press , third edition , 2009 .",
    "g.  das and d.  joseph . which triangulations approximate the complete graph ? in _ proceedings of the international symposium on optimal algorithms _ ,",
    "pages 168192 , 1989 .",
    "b.  delaunay .",
    "sur la sphre vide .",
    "a la memoire de georges voronoi .",
    ", 7:793800 , 1934 .",
    "o.  devillers .",
    "delaunay triangulation of imprecise points : preprocess and actually get a fast query time .",
    ", 2(1):3045 , 2011 .",
    "d.  eppstein .",
    "spanning trees and spanners . in _",
    "handbook of computational geometry _ , pages 425461 .",
    "north - holland , amsterdam , 2000 .",
    "d.  eppstein , m.  goodrich , and j.  sun .",
    "the skip quadtree : a simple dynamic data structure for multidimensional data . , 18(12):131160 , 2008 .",
    "r.  a. finkel and j.  l. bentley .",
    "quad trees : a data structure for retrieval on composite keys . , 4:19 , 1974 .",
    "m.  l. fredman and d.  e. willard .",
    "trans - dichotomous algorithms for minimum spanning trees and shortest paths .",
    ", 48(3):533551 , 1994 .",
    "m.  furst , j.  b. saxe , and m.  sipser .",
    "parity , circuits , and the polynomial - time hierarchy .",
    ", 17(1):1327 , 1984 .",
    "m.  r. garey , d.  s. johnson , f.  p. preparata , and r.  e. tarjan .",
    "triangulating a simple polygon . , 7(4):175179 , 1978 .",
    "deterministic sorting in @xmath692 time and linear space .",
    ", 50(1):96105 , 2004 .    s.",
    "har - peled . , volume 173 of _ mathematical surveys and monographs_. ams press , 2011 .",
    "d.  harel and r.  e. tarjan .",
    "fast algorithms for finding nearest common ancestors .",
    ", 13(2):338355 , 1984 .    j.  m. keil and c.  a. gutwin .",
    "classes of graphs which approximate the complete euclidean graph . , 7(1):1328 , 1992 .",
    "d.  e. knuth .",
    ", volume  1 .",
    "addison - wesley , 3rd edition , 1997 .",
    "d.  krznaric and c.  levcopoulos .",
    "computing hierarchies of clusters from the euclidean minimum spanning tree in linear time . in _ proc .",
    "15th found .",
    "software technology and theoret .",
    "( fsttcs ) _ , pages 443455 , 1995 .",
    "d.  krznaric and c.  levcopoulos .",
    "computing a threaded quadtree from the delaunay triangulation in linear time .",
    ", 5(1):118 , 1998 .",
    "d.  krznaric , c.  levcopoulos , and b.  j. nilsson .",
    "minimum spanning trees in @xmath159 dimensions .",
    ", 6(4):446461 , 1999 .",
    "m.  lffler and j.  snoeyink .",
    "elaunay triangulation of imprecise points in linear time after preprocessing .",
    ", 43(3):234242 , 2010 .",
    "j.  matouek . .",
    "springer - verlag , new york , 2002 .",
    "o.  musin .",
    "properties of the delaunay triangulation . in _ proc .",
    "13th annu .",
    "acm sympos .",
    ", pages 424426 , 1997 .",
    "f.  p. preparata and m.  i. shamos . .",
    "springer - verlag , new york , 1985 .",
    "e.  pyrga and s.  ray .",
    "new existence proofs for @xmath693-nets . in _ proc .",
    "24th annu .",
    "acm sympos .",
    "( socg ) _ , pages 199207 , 2008 .",
    "h.  samet . .",
    "addison - wesley , boston , ma , usa , 1990 .",
    "a.  schnhage . on the power of random access machines . in _ proc .",
    "6th internat .",
    ". program .",
    "( icalp ) _ , pages 520529 , 1979 .",
    "m.  i. shamos and d.  hoey .",
    "closest - point problems . in _ proc .",
    "16th annu .",
    "ieee sympos . found .",
    "( focs ) _ , pages 151162 , 1975",
    ".    r.  e. tarjan . .",
    "siam , philadelphia , 1983 .",
    "p.  m. vaidya .",
    "minimum spanning trees in @xmath301-dimensional space .",
    ", 17(3):572582 , 1988 .",
    "k.  r. varadarajan .",
    "a divide - and - conquer algorithm for min - cost perfect matching in the plane . in _ proc .",
    "39th annu .",
    "ieee sympos . found .",
    "( focs ) _ , pages 320331 , 1998 .",
    "a.  c.  c. yao . on constructing minimum spanning trees in @xmath301-dimensional spaces and related problems .",
    ", 11(4):721736 , 1982 .",
    "since our results concern different computational models , we use this appendix to describe them in more detail .",
    "our two models are the real ram / pointer machine and the word ram .",
    "the standard model in computational geometry is the _",
    "real ram_. here , data is represented as an infinite sequence of storage cells .",
    "these cells can be of two different types : they can store real numbers or integers .",
    "the model supports standard operations on these numbers in constant time , including addition , multiplication , and elementary functions like square - root .",
    "the _ floor _ function can be used to truncate a real number to an integer , but if we were allowed to use it arbitrarily , the real ram could solve pspace - complete problems in polynomial time  @xcite .",
    "therefore , we usually have only a restricted floor function at our disposal , and in this paper it will be banned altogether .",
    "the _ pointer machine _  @xcite models the list processing capabilities of a computer and disallows the use of constant time table lookup .",
    "the data structure is modeled as a directed graph @xmath580 with bounded out - degree .",
    "each node in @xmath580 represents a _ record _ , with a bounded number of pointers to other records and a bounded number of ( real or integer ) data items .",
    "the algorithm can access data only by following pointers from the inputs ( and a bounded number of global entry records ) ; random access is not possible .",
    "the data can be manipulated through the usual real ram operations ( again , we disallow the floor function ) .",
    "the _ word ram _ is essentially a real ram without support for real numbers .",
    "however , on a real ram , the integers are usually treated as atomic , whereas the word ram allows for powerful bit - manipulation tricks .",
    "more precisely , the word ram represents the data as a sequence of @xmath80-bit words , where @xmath673 ( @xmath11 being the problem size ) .",
    "data can be accessed arbitrarily , and standard operations , such as boolean operations ( ` and ` , ` xor ` , ` shl ` , @xmath163 ) , addition , or multiplication take constant time .",
    "there are many variants of the word ram , depending on precisely which instructions are supported in constant time .",
    "the general consensus seems to be that any function in @xmath694 is acceptable .",
    "is the class of all functions @xmath695 that can be computed by a family of circuits @xmath696 with the following properties : ( i ) each @xmath697 has @xmath11 inputs ; ( ii ) there exist constants @xmath698 , such that @xmath697 has at most @xmath699 gates , for @xmath700 ; ( iii ) there is a constant @xmath159 such that for all @xmath11 the length of the longest path from an input to an output in @xmath697 is at most @xmath159 ( i.e. , the circuit family has bounded depth ) ; ( iv ) each gate has an arbitrary number of incoming edges ( i.e. , the _ fan - in _ is unbounded ) .",
    "] however , it is always preferable to rely on a set of operations as small , and as non - exotic , as possible .",
    "note that multiplication is not in @xmath694  @xcite .",
    "nevertheless , it is usually included in the word ram instruction set  @xcite ."
  ],
  "abstract_text": [
    "<S> we show that delaunay triangulations and compressed quadtrees are equivalent structures . </S>",
    "<S> more precisely , we give two algorithms : the first computes a compressed quadtree for a planar point set , given the delaunay triangulation ; the second finds the delaunay triangulation , given a compressed quadtree . both algorithms run in deterministic linear time on a pointer machine . </S>",
    "<S> our work builds on and extends previous results by krznaric and levcopolous  @xcite and buchin and mulzer  @xcite . </S>",
    "<S> our main tool for the second algorithm is the well - separated pair decomposition ( wspd )  @xcite , a structure that has been used previously to find euclidean minimum spanning trees in higher dimensions  @xcite . </S>",
    "<S> we show that knowing the wspd ( and a quadtree ) suffices to compute a planar euclidean minimum spanning tree ( emst ) in _ linear _ time . with the emst at hand </S>",
    "<S> , we can find the delaunay triangulation in linear time  @xcite .    as a corollary </S>",
    "<S> , we obtain deterministic versions of many previous algorithms related to delaunay triangulations , such as splitting planar delaunay triangulations  @xcite , preprocessing imprecise points for faster delaunay computation  @xcite , and transdichotomous delaunay triangulations  @xcite . </S>"
  ]
}