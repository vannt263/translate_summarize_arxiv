{
  "article_text": [
    "many gis applications involve data in the form of a network , such as road , railway , or river networks .",
    "it is common to represent network data in the form of so - called _ polylines_. a polyline consists of a sequence of consecutive straight - line segments of variable length .",
    "polylines allow for the modeling of both straight lines and curved lines . a point on a polyline",
    "in which exactly two straight - line segments meet , is called a _ regular _ point .",
    "regular points are important for the modeling of curved lines .",
    "indeed , to represent accurately a curved line by a polyline , one needs to use many regular points .",
    "curved lines often occur in river networks , or in road networks over hilly terrain .",
    "we illustrate this in figure  [ fig : regular ] in which we show a part of the road network in the ardennes ( belgium ) . in this hilly region , many bended roads occur .",
    "as can be seen in the figure , there is an abundance of regular points  which is often the case in real network maps  @xcite .        although regular points are necessary to model the reality accurately , for many applications they can be disregarded .",
    "more specifically , for topological queries such as path queries , one can `` topologically simplify '' the network by eliminating all regular points ; and answer the query ( more efficiently ) on the much simplified network .",
    "even when the network contains distance information , one still can topologically simplify the network , but maintain the distance information , as we will show in the present paper .",
    "more generally , we work with arbitrary weight information .",
    "thus , the simplification of a network contains in a compact manner the same topological and distance information as the original network .",
    "such `` lossless topological representations '' have been studied by a number of researchers @xcite .",
    "for example , initial experiments reported by segoufin and vianu have shown drastic compression of the size of the data by topological simplification .",
    "( the inclusion of distance information is new to the present paper . )",
    "of course , if we want to answer queries using the simplified network instead of the original one , we are faced with the problem of on - line maintenance of the simplified network under updates to the original one .",
    "this problem is important due to the dynamic character of certain network data .",
    "for example , suppose that there is a huge snowstorm which makes all roads unusable . as a result",
    ", many snow clearing crews are sent to all parts of the city .",
    "they continuously report back to a central station the road segments that they have cleared .",
    "the central station also continuously updates its map of the usable network of roads .",
    "moreover , big arteries are cleared first , and therefore , the usable network will have a high percentage of regular vertices in the initial stages .",
    "while the snow is being cleared , thousands of people may query the database of the central station to find out what is the shortest path they can take using the already cleared roads .",
    "analogous applications requiring on - line monitoring involve traffic jams in road networks , or downlinks in computer networks .",
    "two of us have reported on an initial investigation of this problem @xcite .",
    "the result was a maintenance algorithm that was _ fully - dynamic _",
    ", i.e. , insertions and deletions of edges and vertices are allowed .",
    "this algorithm , however , is ( in certain `` worst cases '' ) not any better than redoing the simplification from scratch after every update , resulting in an @xmath2 time algorithm , where @xmath1 is the number of updates .",
    "this is clearly not very practical .",
    "the present paper proposes two very different algorithms for on - line topological simplification :    1 .   *",
    "renumbering algorithm * , which relies on the numbering and renumbering of the regular vertices , takes on the average , only _ logarithmic _ time per edge insertion to keep the simplified network up - to - date ; and 2 .",
    "* topology tree algorithm * , is based on the topology tree data structure of frederickson  @xcite and has the same time complexity @xmath3 .",
    "neither algorithm makes any assumptions on the graph , such as planarity and the like .",
    "real - life network data is often _ not _ planar ( e.g. , in a road or railway network , bridges occur ) .",
    "the presented algorithms are only _ semi - dynamic _ , in that they can react efficiently to insertions ( of vertices and edges ) , but not to deletions .",
    "insertions are sufficient for many applications ( such as the snow clearing mentioned above , were simply more and more road segments become available again ) , but for applications requiring also deletion , the topology tree algorithm easily can be extended to also react correctly to edge deletions .",
    "we have performed an empirical comparison of the renumbering algorithm and the topology tree algorithm using random , non - random and two real data sets .",
    "this paper is further organized as follows .",
    "basic definitions are given in section  2 .",
    "the general description of the on - line simplification algorithm is described in section  3 . in section  4 , we describe the renumbering algorithm , and in section  5 , the topology tree algorithm is described . the empirical comparison of both algorithms is presented in section  6 .",
    "consider an undirected graph without self - loops @xmath4 with weighted edges ; the weights of the edges are given by a mapping @xmath5 .",
    "we will use the following definitions :    1 .",
    "a vertex @xmath6 is _ regular _ if and only if it is adjacent to precisely two edges . 2 .",
    "a vertex that is not regular is called _",
    "singular_. 3 .   a path between two singular vertices that passes only through regular vertices",
    "is called a _ regular path_.",
    "we assume that the graph @xmath7 does not contain regular cycles : cycles consisting of regular vertices only .",
    "the _ simplification _ @xmath8 of @xmath7 is a multigraph with self - loops and weighted edges , which is obtained as follows : ( see figure  [ fig : regular ] )    1 .",
    "@xmath9 , the set of nodes of @xmath10 , consists of all singular vertices of @xmath7 .",
    "@xmath11 , the set of edges of @xmath10 , formally consists of all regular paths of @xmath7 .",
    "every regular path between two singular vertices @xmath6 and @xmath12 represents a _",
    "topological edge _ in @xmath10 between @xmath6 and @xmath12",
    ". there might be multiple regular paths between two singular vertices , so in general @xmath10 is a multigraph .",
    "the weight @xmath13 of a topological edge @xmath14 is equal to the sum of all weights of edges on the regular path corresponding to @xmath14 .    in the following ,",
    "when a particular regular path @xmath14 between two singular vertices @xmath6 and @xmath12 is clear from the context , we will abuse notation and conveniently denote the topological edge @xmath14 by @xmath15 .",
    "we consider only insertions of a new isolated vertex and insertions of edges between existing vertices in the graph @xmath7 ( other more complex insertion operations can be translated into a sequence of these basic insertion operations ) .",
    "the insertion of an isolated vertex is handled trivially , i.e. , we insert it into @xmath9 .    for the insertion of an edge we distinguish between six cases that are explained below .",
    "the left side of each figure shows the situation before the insertion of the edge @xmath16 , drawn as the dotted line , and the right side shows the situation after the insertion .",
    "the topological edges are drawn in thick lines .",
    "case 1 : :    vertices @xmath17 and @xmath18 are both singular and    @xmath19 and @xmath20 .",
    "+       +    then the edge @xmath16 is also _ inserted _ in    @xmath10 .",
    "case 2 : :    vertices @xmath17 and @xmath18 are both singular and one    of them , say @xmath17 , has degree one .",
    "+    let @xmath21 be the edge in @xmath10 adjacent to    @xmath17 .",
    "_ extend _ this edge the new edge @xmath22    in @xmath10 , putting    @xmath23 .",
    "note that @xmath17 becomes a regular vertex after the    insertion .",
    "case 3 : :    vertices @xmath17 and @xmath18 are both singular and    @xmath24 .",
    "+    let @xmath25 ( @xmath26 ) be the edge in    @xmath10 adjacent with @xmath17 ( @xmath18 ) .",
    "( since we disallow regular cycles in @xmath7 , we have    @xmath27 and @xmath28 . )",
    "then _ merge _ the    edges @xmath25 and @xmath29 in    @xmath10 into a single , new edge @xmath30 in    @xmath10 , putting    @xmath31 .",
    "case 4 : :    one of the vertices @xmath17 and @xmath18 is regular ,    say @xmath17 , and the other vertex , @xmath18 , is    singular and has degree one .",
    "+    first , the edge @xmath30 of @xmath10 which    corresponds to the regular path between @xmath32 and    @xmath33 on which @xmath17 lies , must be _ split _ into    two new edges @xmath25 and @xmath34 of    @xmath10 . here , we put    @xmath35 , where the    summation is over all edges in @xmath7 on the regular path    from @xmath32 to @xmath17 .",
    "we similarly define    @xmath36 .",
    "secondly , let    @xmath37 be the edge in @xmath10 adjacent to    @xmath18",
    ". then we _ extend _ this edge to a new edge    @xmath38 in @xmath10 , putting ,    @xmath39 .",
    "+    a special subcase occurs when @xmath40 . in that case",
    ", the    two paths from @xmath17 to @xmath32 give rise to two    different edges from @xmath17 to @xmath32 in    @xmath10 ( recall that @xmath10 was defined as a    multigraph ) .",
    "case 5 : :    one of the vertices , say @xmath17 , is regular and the other    one , @xmath18 , is singular with degree not equal to one .",
    "+    then we split exactly as in case  4 , and now we also insert    @xmath16 as a new edge in @xmath10 .",
    "case 6 : :    both @xmath17 and @xmath18 are regular .",
    "+    now , two _ splits _ must be performed .    as can be seen in the above description",
    ", if no regular vertices are involved , then the update on the graph @xmath7 translates in a straightforward way to an update on the simplification @xmath10 .",
    "it is only in cases 4 , 5 , and 6 , that the update on the graph @xmath7 involves vertices which _ have no counterpart _ in the simplification @xmath10 . in these cases ,",
    "we need to find the edge to split and the weights of the topological edges created by the split .",
    "consequently , the problem of maintaining the simplification @xmath10 of a graph @xmath7 amounts to two tasks :    * maintain a function _ find topological edge _",
    ", which takes a regular vertex as input , and outputs the topological edge whose corresponding regular path in @xmath7 contains the input vertex .",
    "* maintain a function _ find weights _ which outputs the weights of the edges created when a topological edge is split at the input vertex .    in an earlier , naive approach  @xcite ,",
    "we only discussed the function _ find topological edge .",
    "_ it worked by storing for each regular vertex a direct pointer to its topological edge . this made the topological edge accessible in constant time , but the maintenance of the pointers under updates can be very inefficient in the worst case .",
    "we next describe two algorithms which are more efficient .",
    "both algorithms keep the simplification of a graph up - to - date when the graph is subject to edge insertions only .",
    "in this section we introduce an algorithm for keeping the simplification of a graph up - to - date when this graph is subject to edge insertions .",
    "we first show how the topological edges can be found efficiently .",
    "we number the regular vertices , that lie on a regular path , consecutively .",
    "the numbers of the regular vertices on any regular path will always form an interval of the natural numbers .",
    "the renumbering algorithm will maintain two properties :    interval property : : :    the assignment of _ consecutive _ numbers to _ consecutive _ regular    points ; disjointness property : : :    _ different _ regular paths have _ disjoint _ intervals .",
    "we then have a unique interval associated with each regular path , and hence with each topological edge of size @xmath41 .",
    "moreover , we choose the minimum of such an interval as a unique number associated with a topological edge .",
    "specifically , the minimal number serves as a _ key _ in a _",
    "dictionary_. recall that in general , a dictionary consists of pairs @xmath42 , where the item is unique for each key .",
    "given a number @xmath43 , the function which returns the item with the maximal key smaller than @xmath43 can be implemented in @xmath44 time , where @xmath45 is the number of items in the dictionary @xcite .",
    "the items we use contain the following information .    1 .   an identifier of the topological edge associated with the key .",
    "2 .   the number of regular vertices on the regular path corresponding to this topological edge .",
    "3 .   an identifier of the regular vertex that has the key as number on this path .    in figure  [ dict ]",
    "we give an example of a dictionary containing three keys , corresponding to the three topological edges in the simplification @xmath10 of the graph @xmath7 .",
    "we must now show how to maintain this numbering under updates , such that the interval and disjointness properties mentioned above remain satisfied .    actually , only in case  3 in section  [ sec :",
    "update ] we need to do some maintenance work on the numbering .",
    "indeed , by merging two topological edges , the numbering of the regular vertices is no longer necessarily consecutive .",
    "we resolve this by _ renumbering _ the vertices on the shorter of the two regular paths .",
    "note that the size of a regular path is stored in the dictionary item for that path .    in order to keep the intervals disjoint",
    ", we must assume that the maximal number of edge insertions to which we need to respond is known in advance .",
    "concretely , let us assume that we have to react to at most @xmath46 update operations .",
    "this assumption is rather harmless .",
    "indeed , one can set this maximum limit to a large number .",
    "if it is eventually reached , we restart from scratch . a regular path is `` born '' with at most two regular vertices on it . every time a new regular path is created ,",
    "say the @xmath43th time , we assign the number @xmath47 to one of the two regular vertices on it . hence , newly created topological edges correspond to numbers which are @xmath48 apart from each other .",
    "since a newly created topological edge can become at most @xmath49 vertices longer , no interference is possible .",
    "consider that we are in one of the cases 46 described in section  [ sec : update ] , where we have to split the topological edge at vertex @xmath17 .",
    "we look at the number of @xmath17 , say @xmath43 , and find in the dictionary the item associated with the maximal key smaller than @xmath43 .",
    "this key corresponds to the interval to which @xmath43 belongs , or equivalently , to the regular path to which @xmath17 belongs . in this way we find the topological edge",
    "which has to be split , since this edge is identified in the returned item .",
    "the numbering thus enables us to find an edge in @xmath50 time , where @xmath51 is the number of edges in @xmath10 which correspond to a regular path passing through at least one regular vertex . because @xmath51 is at most @xmath52 , the number of edges in @xmath7",
    ", we obtain :    given a regular vertex and its number , the dictionary returns in @xmath53 time the topological edge corresponding to the regular path on which this regular vertex lies .",
    "we next show how , when a topological edge is split , we can quickly find the weights of the two new edges created by the split .",
    "the _ weight _ of a regular vertex @xmath6 will be denoted by @xmath54 .",
    "weights will be assigned to the regular vertices such that if @xmath6 and @xmath12 are two consecutive regular vertices with weights @xmath54 and @xmath55 respectively , then @xmath56 .",
    "the maintenance of the weights of regular vertices under edge insertions is easy .",
    "it requires only constant time when a topological edge is extended .",
    "indeed , let @xmath16 be a topological edge , and suppose that we extend this edge by inserting @xmath57 .",
    "let @xmath58 be the regular vertex adjacent to @xmath18 .",
    "then ,    * if @xmath59 , then @xmath60 . *",
    "if @xmath61 , and no regular vertex with a positive weight is adjacent to @xmath58 , then @xmath62 .",
    "otherwise , let @xmath6 be the regular vertex adjacent to @xmath58 .",
    "if @xmath63 , then let @xmath64 , else let @xmath65 .    when a topological edge is split , no adjustments to the weight of the remaining regular vertices is needed at all .",
    "however , when two topological edges are merged we need to adjust the weights of the regular vertices on the shortest of the two regular paths , as shown in figure  [ weights ] .",
    "this adjustment of the weights can clearly be done simultaneously with the renumbering of the vertices .",
    "the weights of regular vertices now enable us to find the weights of the two edges created by a split of a topological edge in logarithmic time .",
    "indeed , given the number of the regular vertex where the split occurs , we search in the dictionary which topological edge needs to be split ; call it @xmath30 . in the returned item",
    "we find the vertex which has the minimal number of the vertices on the regular path corresponding to @xmath30 .",
    "denote this vertex with @xmath58 which is adjacent to either @xmath32 or @xmath33 .",
    "we assume that @xmath58 is adjacent to @xmath32 , the other case being analogous .",
    "the weight of the two new topological edges @xmath25 and @xmath34 can be computed easily :    * @xmath66 ; and * @xmath67 .",
    "if only one regular vertex remains on a regular path after a split , or a regular vertex becomes singular , then the weight of this vertex is set to @xmath68 .",
    "this can all can be done in constant time , after the topological edge which needs to be split has been looked up in the dictionary .      by the _ amortized complexity _ of an on - line algorithm @xcite , we mean the total computational complexity of supporting @xmath46 updates ( starting from the empty graph ) , as a function of @xmath46 , divided by @xmath46 to get the average time spent on supporting one single update .",
    "we will prove here that the renumbering algorithm has @xmath69 amortized time complexity .",
    "we only count edge insertions because the insertion of an isolated vertex has zero cost .",
    "[ thm : renum ] the total time spent on @xmath46 updates by the renumbering algorithm is @xmath70 .",
    "if we look at the general description of the renumbering algorithm , we see that in each case only a constant number of steps are performed .",
    "these are either elementary operations on the graph , or dictionary lookups .",
    "there is however one important exception to this . in cases where we need to merge two topological edges , the renumbering of regular vertices ( and simultaneous adjustment of their weights )",
    "is needed .",
    "since every elementary operation on the graph takes constant time , and every dictionary lookup takes @xmath69 time , all we have to prove is that the total number of vertex renumberings is @xmath71 .    a key concept in our proof is the notion of a _ super edge _ ( see figure  [ fig : super ] ) .",
    "super edges are sets of topological edges which can be defined inductively : initially each topological edge ( with one or two regular vertices on it ) is a member of a separate super edge . if a member @xmath72 of a super edge @xmath73 is merged with a member @xmath74 of another super edge @xmath75 , then the two super edges are unioned together in a new super edge @xmath76 and @xmath72 and @xmath74 are merged into a new member @xmath77 of the new super edge @xmath78 .",
    "if a member @xmath79 of a super edge is split into @xmath80 and @xmath81 , then both @xmath80 and @xmath81 will belong to the same super edge as @xmath79 did .",
    "the important property of super edges is that the total number of vertices can only grow .",
    "we call this number the _ size _ of a super edge",
    ". a split operation does not affect the size of super edges , while merge operations can only increase it .",
    "it now suffices to show that the total number of vertex renumberings in a super edge of size @xmath46 is @xmath82 .",
    "we will do this by induction .",
    "the statement is trivial for @xmath83 , so we take @xmath84 .",
    "we may assume that the @xmath46th update involves a merge of two topological edges , since this is the only update for which we have to do renumbering .",
    "suppose that the sizes of the two super edges being unioned are @xmath85 and @xmath86 .",
    "without loss of generality assume that @xmath87 .",
    "hence , according to the renumbering algorithm which renumbers the shortest of the two , we have to do @xmath88 renumbering steps : @xmath85 to assign new numbers , and @xmath85 to assign new weights .",
    "the size of the new super edge will be @xmath89 . by the induction hypothesis ,",
    "the total number of renumberings already done while building the two given super edges are @xmath90 and @xmath91 .",
    "it is known ( @xcite ) that @xmath92 for @xmath93 $ ] .",
    "define @xmath94 . by  ( [ eq : logeq ] )",
    ", we then obtain the inequality @xmath95 as had to be shown .",
    "to conclude this section , we recall from section  [ secnumbers ] that the maximal number assigned to a regular vertex is @xmath96 .",
    "so , all numbers involved in the renumbering algorithm take only @xmath69 bits in memory .",
    "theorem  [ thm : renum ] assumes the standard ram computation model with unit costs .",
    "if logarithmic costs are desired , the total time is @xmath97 .",
    "in this section we introduce another algorithm for keeping the simplification of a graph up - to - date when this graph is subject to edge insertions .",
    "we only describe the case of edge insertion , but it is straightforward to extend the topology tree algorithm to a fully dynamic algorithm , which can also react to deletions .",
    "the algorithm uses a direct adaptation of the topology - tree data structure introduced by frederickson  @xcite .",
    "this data structure has been used extensively in other partially and fully dynamic algorithms  @xcite .",
    "we first show how the topological edge can be found efficiently .",
    "we define a _ cluster _ as a set of vertices .",
    "the _ size _ of a cluster is the number of vertices it contains .",
    "regular cluster _ is a cluster of size at most two , containing adjacent regular vertices .",
    "a _ regular partition _ of a graph @xmath7 is a partition of the set @xmath98 of regular vertices , such that for any two adjacent regular vertices @xmath6 and @xmath12 , the following holds :    * either @xmath6 and @xmath12 are in the same regular cluster @xmath99 ; or * @xmath6 and @xmath12 are in different regular clusters @xmath100 and @xmath101 , and at least one of these regular clusters has size two .    a _ regular multilevel partition _ of a graph @xmath7 is a set of partitions of @xmath98 that satisfy the following ( see figure  [ fig : regularpart ] ) :    1 .   for each level @xmath102 , the clusters at level @xmath103 form a partition of @xmath98 .",
    "2 .   the clusters at level @xmath68 form a regular partition of @xmath98 .",
    "3 .   the clusters at level @xmath103 form a regular partition when viewing each cluster at level @xmath104 as a regular vertex .    a _ regular forest _ of a graph @xmath7 is a forest based on a regular multilevel partition of @xmath7 .",
    "we focus on the construction of a single tree in the forest corresponding to a single regular path .",
    "a single tree is constructed as follows ( see figure  [ fig : regulartree ] ) .    1 .",
    "a vertex at level @xmath103 in the tree represents a cluster at level @xmath103 in the regular multilevel partition .",
    "a vertex at level @xmath105 has children that represent the clusters at level @xmath104 whose union is the cluster it represents .",
    "the height of a topology tree is logarithmic in the number of regular vertices in the leafs  @xcite",
    ".    we also store adjacency information for the clusters .",
    "two regular clusters @xmath99 and @xmath106 at level @xmath68 are _ adjacent _ , if there exists a vertex @xmath107 and a vertex @xmath108 such that @xmath6 and @xmath12 are adjacent in @xmath7 .",
    "we call two clusters @xmath99 and @xmath106 at level @xmath103 adjacent , if they have adjacent children",
    ". a regular cluster @xmath99 at level @xmath68 is adjacent to a singular vertex @xmath109 if there exists a regular vertex @xmath107 adjacent to @xmath109 .",
    "a cluster at level @xmath105 is adjacent to a singular vertex @xmath109 if it has a child adjacent to @xmath109 .",
    "the following procedure , for maintaining a regular multilevel partition under edge insertions , closely follows the procedure described by frederickson @xcite , as our data structure is a direct adaptation of frederickson s .",
    "[ [ level-0 ] ] level @xmath68 + + + + + + + + + + + + + + + + + + + + +    it is very easy to adjust the regular partition , i.e. , the regular clusters at level @xmath68 of the regular multilevel partition .",
    "when an edge @xmath110 is inserted , we distinguish between the following cases : 1 .",
    "the edge @xmath14 destroys a regular vertex @xmath58 ; 2 .",
    "the edge @xmath14 destroys two regular vertices @xmath58 and @xmath6 ; 3 . the edge @xmath14 creates a regular vertex @xmath58 ; 4 .",
    "the edges @xmath14 creates two regular vertices @xmath58 and @xmath6 ; 5 .",
    "the edge @xmath14 does not change the number of regular vertices .",
    "we denote with @xmath111 ( @xmath112 ) the regular cluster containing the vertex @xmath58 ( @xmath6 ) .",
    "we treat these cases as follows .    1 .",
    "if the size of @xmath111 is @xmath113 , then this cluster is deleted .",
    "otherwise if @xmath111 is adjacent to a cluster @xmath114 of size one , remove @xmath58 from @xmath111 and union @xmath111 with @xmath114 .",
    "2 .   apply case 1 to both @xmath111 and @xmath112 .",
    "3 .   create a new cluster @xmath111 only containing @xmath58 . if @xmath111 is adjacent to a cluster @xmath114 of size one , union @xmath111 with @xmath114 .",
    "4 .   apply case 3 , but if both @xmath111 and @xmath112 are not adjacent to a cluster of size one , then they are unioned together . 5 .",
    "nothing has to be done .",
    "as an example consider the graph depicted in figure  [ fig : regcluster ] .",
    "the insertion of edge @xmath16 destroys the regular vertex @xmath17 , so we are in case 1 . because @xmath106 is adjacent to @xmath115 and the size of @xmath115 is one , we must union @xmath106 and @xmath115 together into a new regular cluster @xmath99 .",
    "the maintenance of the regular partition is completed after adjusting the adjacency information of both @xmath99 and @xmath116 , as shown in figure  [ fig : regcluster ] .",
    "[ [ level-0 - 1 ] ] level @xmath41 + + + + + + + + + + + + + + + + + + + + + + +    we assume that the regular partition at level @xmath68 reflects the insertion of an edge , as discussed above .",
    "the number of clusters which have changed , inserted or deleted is at most some constant .",
    "we put these clusters in a list @xmath117 , @xmath118 , and @xmath119 according to whether they are changed , inserted or deleted .",
    "more specifically , these lists are initialized as follows .",
    "each regular cluster that has been split or combined to form a new regular cluster is inserted in @xmath119 , while each new regular cluster is inserted in list @xmath118 .",
    "the adjacency information is stored with the clusters in @xmath118 . for clusters in @xmath119",
    "every adjacency information is set to null , except the parent information . for each regular cluster",
    "whose set of vertices has not changed but its adjacency information has changed , update the adjacency information and insert it into @xmath117 .",
    "we create lists @xmath120 , @xmath121 , and @xmath122 to hold the clusters at the next higher level of the regular multilevel partition .",
    "these lists are initially empty .",
    "we first adjust the clusters in the list @xmath119 .",
    "every cluster @xmath99 in @xmath119 is removed from @xmath119 , and @xmath99 is removed as child from its parent @xmath123 ( if existing ) .    *",
    "if @xmath123 has no more children , then insert @xmath123 in @xmath120 . *",
    "if @xmath123 still has a child @xmath106 , then if @xmath106 is not already in @xmath117 or @xmath119 , then insert @xmath106 into @xmath117 .",
    "next , we search the list @xmath117 for clusters that have siblings .",
    "suppose that @xmath124 has a sibling @xmath106 and parent @xmath123 .    * if @xmath99 and @xmath106 are adjacent , then remove @xmath99 from the list @xmath117 , and remove @xmath106 from @xmath117 if it is in this list .",
    "insert @xmath123 into @xmath122 . *",
    "if @xmath99 and @xmath106 are not adjacent , then remove @xmath99 and @xmath106 as children from @xmath123 .",
    "remove @xmath99 from the list @xmath117 , and also remove @xmath106 from @xmath117 if it is in this list .",
    "insert both @xmath99 and @xmath106 into @xmath118 , and insert @xmath123 in @xmath120 .    finally , we treat the remaining clusters in @xmath117 and in @xmath118 .",
    "let @xmath99 be such a cluster .",
    "remove @xmath99 from the appropriate list . in what follows",
    ", the degree of @xmath99 is the number of adjacent clusters .    * if @xmath99 has degree zero , then it is the root of a tree in the regular forest .",
    "insert its parent @xmath123 , if existing , in @xmath120 . * if @xmath99 has degree one or two , then we have the following possibilities : * * if every adjacent cluster to @xmath99 has a sibling , then insert the parent @xmath123 of @xmath99 into @xmath122 in case @xmath123 exists . in case @xmath99",
    "does not have a parent , create a new parent cluster @xmath123 and insert it into @xmath121 . *",
    "* let @xmath106 be a cluster adjacent to @xmath99 which has no sibling .",
    "remove @xmath106 from the appropriate list , if it is in a list .",
    "if both @xmath99 and @xmath106 have a parent , denoted by @xmath123 and @xmath125 respectively , then remove @xmath99 as child of @xmath123 and make it a child of @xmath125 .",
    "insert @xmath123 into @xmath120 , and insert @xmath126 into @xmath122 .",
    "if both @xmath99 and @xmath106 have no parent , then create a new parent @xmath123 of @xmath99 and @xmath106 , and insert @xmath123 into @xmath121 .",
    "if @xmath99 has a parent @xmath123 , and @xmath106 has no parent , then make @xmath106 a child of @xmath123 and insert @xmath123 into @xmath122 .",
    "the case that @xmath106 has a parent @xmath125 , and @xmath99 has no parent , is analogous .",
    "when all clusters are removed from @xmath119 , @xmath117 , and @xmath118 , determine and adjust the adjacency information for all clusters in @xmath120 , @xmath122 , and @xmath121 and reset @xmath117 to be @xmath122 , @xmath117 to be @xmath122 , and @xmath118 to be @xmath121 .",
    "if no clusters are present in @xmath120 , @xmath122 or @xmath121 , nothing needs to be done and the iteration stops .",
    "this completes the description of how to handle the lists @xmath119 , @xmath117 , and @xmath118 .",
    "consider that we are in one of the cases 46 described in section  [ sec : update ] , where we have to split a topological edge .",
    "let @xmath17 be the regular vertex at which we have to split the topological edge .",
    "we store a pointer from @xmath17 to the regular cluster @xmath127 in which it is contained .",
    "we also store a pointer from each root of a tree @xmath128 in the regular forest to the topological edge , corresponding to the regular path formed by all vertices in the leaves of @xmath128 .",
    "we find the topological edge which needs to be split by going from @xmath127 to the root of the tree containing @xmath127 .",
    "since the height of the tree is at most @xmath129 , where @xmath46 is the current number of edge insertions , we obtain the following .    given a regular vertex @xmath17 , the regular forest returns the topological edge corresponding to the regular path on which this regular vertex lies in @xmath69 time .",
    "we store weight information in two different places .",
    "we define the weight of a regular cluster at level @xmath68 of size one as zero .",
    "let @xmath99 be a cluster at level @xmath68 of size two , and let @xmath6 and @xmath12 be the two regular vertices in @xmath99 .",
    "then we define the weight of @xmath99 as the weight of the edge @xmath15 .",
    "if a cluster at level @xmath68 is adjacent to a singular vertex @xmath109 , then we store the weight of @xmath130 together with the adjacency information ( here , @xmath6 is the vertex in @xmath99 adjacent to @xmath109 ) .",
    "if two clusters @xmath99 and @xmath106 at level @xmath68 are adjacent , then we store the weight of @xmath15 together with their adjacency information ( here @xmath107 and @xmath108 and @xmath6 is adjacent to @xmath12 ) .",
    "the weight of a cluster of size one at level @xmath105 , is defined as the weight of its child at the next lower level .",
    "the weight of a cluster of size two at level @xmath105 equals the sum of the weights of its two children and the weight stored with their adjacency information .",
    "if two clusters at level @xmath105 are adjacent , we store the weight of the adjacency information of their adjacent children . if a cluster at level @xmath105 is adjacent to a singular node , we store the weight of the adjacency information of its child and the singular node .",
    "the weight of clusters and the weights stored together with the adjacency information , is updated after each run of the update procedure for the regular multilevel partition , with an extra constant cost . indeed ,",
    "both the weights of clusters at level @xmath68 and the weights stored with the adjacency information , are trivially updated .",
    "when we assume that all levels lower than @xmath103 represent the weight information correctly , the weight information of clusters in @xmath117 and @xmath118 is trivially updated using the weight information at level @xmath104 .",
    "as mentioned above , each root of a regular tree in the regular forest , has a pointer to a unique topological edge .",
    "this root has its own weight , as defined above , and is adjacent to two singular vertices .",
    "the weight of the topological edge is obtained by summing the weight of the root together with the weights of the adjacency information of the two singular vertices .",
    "this is illustrated in figure  [ fig : examplewithweights ] .",
    "the complexity of the topology tree algorithm is governed by two things : the maximal height of a single tree in the regular forest , and the amount of work that needs to be done at each level in the maintenance of the regular multilevel partition .",
    "we already saw that the height of a single tree is logarithmic in the number of regular vertices on the regular path on which the tree is built .",
    "moreover , frederickson has proven that in the lists @xmath117 , @xmath119 , and @xmath118 only a constant number of clusters are stored @xcite .",
    "these lists are updated at most @xmath69 times , where @xmath46 is the number of edge insertions , so that the total update time is @xmath69 per edge insertion .",
    "hence , we may conclude the following :    the total time spent on @xmath46 updates by the topology tree algorithm is @xmath70 .",
    "the renumbering algorithm and the topology tree algorithm are very different , but have the same theoretical complexity .",
    "hence , the question arises how they compare experimentally . in this section",
    "we try to obtain some insight into this question .",
    "both algorithms were implemented in c++ using leda @xcite .",
    "we used the gnu g++ compiler version 2.95.2 without any optimization option .",
    "our experiments were performed on a sun ultra 10 running at 440  mhz with 512  mb internal memory . implementing the renumbering algorithm",
    "was considerably easier than implementing the topology tree algorithm .",
    "we conducted our experiments on three types of inputs .",
    "first of all , we extensively studied random inputs , which are random sequences of updates on random graphs .",
    "next , we used two kinds of non - random graph inputs which focus specifically on the merging and the splitting of topological edges .",
    "thereto , we constructed an input sequence which repeatedly merges topological edges , and an input sequence which first creates a very large number of small topological edges , and then splits these edges randomly . finally , we ran both algorithms on two inputs originating from real data sets .",
    "[ [ methodology ] ] methodology + + + + + + + + + + +    since the experiments have an element of randomness , we show the results in the form of 95% confidence intervals . for each test",
    ", we perform a large number of runs . for each run , we compute the ratio between the total time taken by topology tree and that taken by renumbering .",
    "we took the average of these ratios and computed the @xmath131 confidence interval .",
    "so , for example , the interval @xmath132 $ ] means that topology tree was 10 to 15% slower than renumbering in 95% of the runs in the test .",
    "[ [ random - inputs ] ] random inputs + + + + + + + + + + + + +    the random inputs consist of random graphs that are generated , given the number of vertices and edges .",
    "each run builds a random graph incrementally with the insertions uniformly distributed over the set of edges .",
    "we conducted a series of tests for different number of nodes @xmath1 and number of edges @xmath52 .",
    "for every pair of values for @xmath1 and @xmath52 we did @xmath133 runs .",
    "the results of these experiments are shown in table  [ tabel : een ] .",
    ".95% confidence intervals on ratio between topology tree and renumbering , from 1000 runs on random inputs .",
    "[ cols=\"^,^,^,^\",options=\"header \" , ]     again , we see that when there are only few , but long , topological edges , the renumbering algorithm is faster than the topology tree algorithm . when there are many , short , topological edges , like in the railroad graph , the topology tree algorithm is slightly faster than the renumbering algorithm .    in summary",
    ", our experimental study shows that when the percentage of regular vertices is high in a graph , then the renumbering algorithm is clearly better than the topological tree algorithm , and when the same percentage is low , then the reverse often holds .",
    "however , our experimental study did not compare any specific problem solving with and without using topological simplification .",
    "intuitively , the value of topological simplification should increase with the percentage of regular vertices in the graph .",
    "therefore , when the percentage of the regular vertices is high , the renumbering algorithm should be not only better than the topological tree algorithm but also yield a significant time saving over problem solving without topological simplification .",
    "we expect this to be the most important practical implication of our study for the case when there are only insertions of edges and vertices into the graph",
    ". however , when a fully dynamic structure is needed , then the topological tree algorithm should be also advantageous in practice .",
    "we would like to thank bill waltman for providing us with the hydrography data set .",
    "f.  geerts , b.  kuijpers , and j.  van den bussche .",
    "`` topological canonization of planar spatial data and its incremental maintenance '' , in t.  polle , t.  ripke , and k .- d .",
    "schewe , editors , fundamentals of information systems , kluwer academic publishers , 1998 , pp 5568 ."
  ],
  "abstract_text": [
    "<S> we describe two efficient on - line algorithms to simplify weighted graphs by eliminating degree - two vertices . </S>",
    "<S> our algorithms are on - line in that they react to updates on the data , keeping the simplification up - to - date . </S>",
    "<S> the supported updates are insertions of vertices and edges ; hence , our algorithms are partially dynamic . we provide both analytical and empirical evaluations of the efficiency of our approaches . </S>",
    "<S> specifically , we prove an @xmath0 upper bound on the amortized time complexity of our maintenance algorithms , with @xmath1 the number of insertions . </S>"
  ]
}