{
  "article_text": [
    "optimization problems with combined inventory and routing decisions arise in a wide variety of contexts . in inventory routing problems",
    "@xcite , for example , inventory and routing costs are minimized on a planning horizon .",
    "each route occurs on a specific time period , originates from a central depot and visits some customers to replenish their inventories .",
    "the adequate selection of a subset of customers for each period , as in the team orienteering and prize - collecting problems @xcite , is thus an essential problem feature .",
    "other related problems have been defined on a single planning period , such as the tsp with pickups and deliveries @xcite , the balancing problems for static bike sharing systems @xcite and also the lateral transhipment problem for a single route ( srltp ) , @xcite .",
    "this latter problem aims to distribute inventory on a network @xmath0 via pickups and deliveries using one vehicle , to minimize a non - linear objective . in bike sharing systems @xcite ,",
    "a target level is defined and the objective is to minimize the corresponding total deviation ( a piecewise - linear convex function ) .",
    "some mip formulations of this problem are introduced in @xcite .",
    "the objective includes expected shortage costs and travel costs , similar to the tsp with profits  @xcite .",
    "dynamic route interactions like hand - overs ( intermediate storage ) and multiple visits are also considered .    in the context of the srltp , both travel costs and profits",
    "must be considered .",
    "each location @xmath1 is characterized by a piecewise - linear _ profit function _ @xmath2 .",
    "the problem is to find inventory changes @xmath3 , such that the revenue minus the costs for the pickup - and - delivery routes is maximized .",
    "suppose that @xmath4 is the initial inventory and @xmath5 , @xmath6 are bounds on the inventory level , then the total revenue can be expressed as : @xmath7 .",
    "\\label{formula : f}\\ ] ] each vehicle , subject to a load limit @xmath8 and a tour length limit @xmath9 , visits a subset @xmath10 of customers to redistribute their inventories . the travel cost and duration on an arc @xmath11 is notated as @xmath12 and @xmath13 .",
    "this work aims to contribute towards better addressing the srltp , through a dedicated study of one essential subproblem : the a - priori route evaluation problem for lateral transhipment ( areltp ) .",
    "indeed , most modern heuristic techniques for the srltp consider a large set of vehicle routes during the search and aim to evaluate their profit .",
    "the goal of this paper is to find an efficient algorithm , which , for a given route ( i.e. , a sequence of visits ) , returns the optimal pickup or delivery quantities at each location in the presence of piecewise - linear profit functions , capacity and distance constraints .",
    "we also consider the ability to _ shortcut _ a customer if this is profitable .",
    "the problem is also very relevant on its own , as a case of routing optimization with a - priori routes @xcite . in practical routing applications , retaining some fixed route fragments can lead to a better operational and computational tractability for companies , as well as efficiency gains through driver learning .",
    "the corresponding subproblem is called the evaluation problem for a - priori routes , and efficient solution methods are needed to quickly react to changing environments .",
    "we also show that the same model encompasses several lot sizing applications with re - qualification costs",
    ".    the contributions of this paper are the following .",
    "we first provide a formal definition of the lateral transhipment problem with a - priori routes .",
    "in contrast with previous articles on the topic , general piecewise linear cost functions are considered .",
    "this enables to model economies of scale and expected stochastic demands . to address this problem",
    ", we introduce a pure dynamic programming approach and a branch - and - bound framework that combines dynamic programming with lagrangian relaxation .",
    "the methods are also adapted for problem settings where the triangle inequality is not satisfied , hence allowing to deal with lot sizing models where the triangle inequality ( for setup costs and times ) is often violated .",
    "finally , extensive computational experiments are conducted to determine the most suitable solution approach for different instances , depending on their size and the magnitude of some of their key parameters , e.g. , vehicle capacities .",
    "the resulting algorithms finds optimal solutions for small- and medium - scale instances in a fraction of seconds .",
    "the paper is organized as follows , in section  [ sec : probdesc ] , the areltp is formally defined and its computational complexity is analyzed .",
    "the lot sizing application with re - qualification costs ( lswrc ) is also presented in section  [ sec : lswrc ] and alternative mixed integer linear programming models for the problems are discussed in section  [ sec : mipsolverformualtion ] .",
    "the proposed dynamic programming and branch - and - bound approaches are described in sections  [ sec : dp ] and [ sec : bblr ] .",
    "to impact of the absence of triangle inequalities is discussed in section  [ sec::triangle ] .",
    "finally , section  [ sec : comp ] describes our computational experiments and section  [ sec : conclu ] concludes .",
    "this section introduces a mathematical formulation of the areltp and discusses its computational complexity .",
    "let @xmath14 be an a - priori route , i.e. , a sequence of @xmath15 locations . now",
    ", suppose that some of the locations in @xmath16 are skipped in the optimal subtour @xmath17 and the optimal inventory changes are @xmath18 , then the total profit minus routing costs is equal to : @xmath19 if the total optimal revenue is larger than @xmath20 , then the lateral transhipment on route @xmath16 route is profitable , otherwise not .    to simplify the notation",
    ", we define the cost change @xmath21 at a location @xmath22 as @xmath23 , as a function of the inventory change @xmath3 , which should be in the interval @xmath24 $ ] , where @xmath25 and @xmath26 .",
    "note that @xmath27 .",
    "the areltp can then be formulated as : @xmath28    the objective ( [ areltp : obj ] ) is equivalent to maximizing the total profit minus the distance cost .",
    "the arc selection variables @xmath29 are defined for @xmath30 , therefore it is sufficient to formulate the flow balance ( [ areltp : fb ] ) and the constraints for the source ( [ areltp : source ] ) and the sink ( [ areltp : sink ] ) to define a subsequence of @xmath16 . according to ( [ areltp : visit ] ) , changing the inventory level at a location @xmath22 ( @xmath31 ) implies that the location must also be visited .",
    "the load of the truck when leaving @xmath22 is @xmath32 , therefore ( [ areltp : qmax ] ) enforces that @xmath8 is the corresponding upper limit .",
    "the mip ( [ areltp : obj]-[areltp : y ] ) is called the areltp without duration limit constraint .",
    "we will also consider a variant of the problem ( [ areltp : obj][areltp : y ] ) , called the areltp with duration limit , with the following additional constraint : @xmath33    in previous literature , a simplified version of the areltp was presented in , but subject to three simplifications :    * @xmath12 is not considered , * @xmath21 is linear , * @xmath9 is not considered .    by transforming the problem to a minimum cost flow , it is possible to solve this special case in polynomial time .",
    "however , revoking any one these simplifications leads to a np - hard problem .",
    "as demonstrated in section [ sec : complexity ] of the appendix , the areltp is np - hard if either @xmath12 is considered , or @xmath21 is piecewise linear , or if @xmath9 is considered .    in the following ,",
    "two exact solution approaches for the areltp ( [ areltp : obj]-[areltp : tmax ] ) will be proposed . the special case without duration constraint ( [ areltp : obj]-[areltp : y ] )",
    "will also be discussed separately .",
    "the areltp is an interesting an difficult problem on its own .",
    "in particular , a lot sizing problem with re - qualification costs ( lswrc ) is described in the next section , and a transformation that establishes the equivalence of the problems is provided .",
    "various algorithms are known to deal with lot sizing models considering product - dependent setup times @xcite .",
    "in contrast , lot sizing problems with idle time - dependent setups have been much less studied .",
    "such models arise in food and pharmaceutical industry , where the qualification of processes and tools have a given duration or expiration ( see ( * ? ? ?",
    "* j ) and @xcite ) . in these applications ,",
    "a frequent use of a tool may stretch the duration of its qualification .",
    "this characteristic also appears in semiconductor industry , where tools need to be qualified for each process and product .",
    "first - time qualifications are usually time consuming and expensive .",
    "for some tools ( e.g. steppers in lithography ) , this qualification for a product expires if it is not running on this tool for a longer period and expensive requalifications become necessary .",
    "we will formulate a lot sizing problem with re - qualification costs ( lswrc ) which considers these aspects , and the equivalence with the areltp will be established . consider the decision variable @xmath3 for the production quantity in period @xmath22 . if production takes place in period @xmath22 ( @xmath34 ) the lower bound @xmath35 and the upper bound @xmath36 need to be respected .",
    "the production cost for each period @xmath22 is represented by a piecewise linear functions @xmath37 , therefore the total production cost is @xmath38 .",
    "the inventory level @xmath39 at the end of period  @xmath22 and the unit holding cost @xmath40 for holding one item in period @xmath22 for one period defines the inventory holding cost @xmath41 . the inventory level is zero in the beginning ( @xmath42 ) and the balance equation @xmath43 states that the inventory level @xmath39 at the end of period @xmath22 is non - negative . in other words , the demand is satisfied at all times , i.e. @xmath44 .",
    "we also introduce setup variables to model time - dependent setup costs : @xmath45 being valued to one if and only if @xmath46 and @xmath47 .",
    "the corresponding setup cost @xmath12 covers the qualification costs and may be larger for long idle times , when considering expensive re - qualifications and setups .    finally , associating a resource consumption @xmath13 if @xmath48 , and setting a restriction on the total setup - related expenses @xmath9 leads to the same constraint as equation ( [ areltp : tmax ] ) .",
    "this restriction can be used to limit the number of production periods , by setting @xmath49 for all @xmath11 , or to limit the total setup cost by using @xmath50 .",
    "the complete model can be stated  as : @xmath51    to evaluate inventory costs as a function of @xmath3 , the following conversion  is  used : @xmath52    the following substitutions enable then to reduce the lswrc to the areltp :    * @xmath53 , and * @xmath54 .",
    "too facilitate the exposition , we will present the different solution approaches based on the areltp terminology .",
    "our computational experiments will also cover some instances of the lswrc . in the following",
    ", we will discuss different exact solution approaches .",
    "section  [ sec : mipsolverformualtion ] first provides a quick discussion about the direct resolution of this model with standard mip solvers .",
    "alternative linearizations are discussed , since they have a significant impact on performance .",
    "in order to solve the problem with a state of the art mip solver , a suitable formulation for the problem ( [ areltp : obj]-[areltp : tmax ] ) is provided in this section .",
    "the formulation is based on special ordered sets ( sos2 ) which an established approach for linear problems ( @xcite,@xcite ) and mixed integer problems @xcite .",
    "if @xmath21 is piecewise linear in the general sense , it may happen that for points @xmath55 on the border of neighboring interval domains , and strict inequalities ( @xmath56-constraints ) are necessary to apply linear programming techniques .",
    "therefore , we assume that the profit change functions @xmath21 are piecewise linear and lower semicontinuous , which allows to extend the domains of all segments to the closed intervals without causing ambiguities .",
    "according to that , each segment is represented by the convex combination of the points related to the interval borders , and @xmath21 can be represented as a sequence of points @xmath57 .    in the following formulation the decision variables @xmath58 and @xmath59 will used to model @xmath21 , i.e. @xmath60 . according to the choice of @xmath58 one of the segments will be activated ( type @xmath61 ) , by choosing neighboring points and a corresponding convex combinations @xmath62 , i.e. : @xmath63 accordingly , the objective has the following form : @xmath64    if sos2 is not included in the modeling language , two alternatives are presented , the first one uses a set of variables @xmath65 to identify the selected neighboring pairs of points and the second one solves this problem by adding constraints on non - subsequent pairs of points .",
    "the first alternative is formulated as follows : @xmath66 & \\quad \\quad   1 \\leq i \\leq n , \\ 0 \\leq k \\leq m_i   \\label{sos:7 } \\end{aligned}\\ ] ] in the second alternative , the binary variables @xmath67 are introduced to replace ( [ sos:6 ] ) by : @xmath68 according to our computational experiments , the second alternative leads to a smaller cpu time than the first .",
    "the differences between the second alternative and using sos2 directly are not significant .",
    "we thus considered the second alternative in our computational experiments of section [ sec : comp ] .",
    "the next sections introduce two new solution approaches : a pure dynamic programming algorithm and a branch - and - bound approach based on a lagrangian relaxation of the route duration constraint .",
    "this section introduces two dynamic programming approaches for the areltp . we assume for now that the triangle inequalities for @xmath12 and @xmath13 are satisfied and that no duration constraints are imposed .",
    "we define the value function @xmath69 for @xmath70 , which returns the optimal cost of a route ending at @xmath71 with inventory level @xmath72 .",
    "the functions @xmath73 can be expressed as : @xmath74 these functions can be computed by using the following recurrence relation : @xmath75    in the case where skipping one or more visits is forbidden , then @xmath76 would be the only predecessor of @xmath77 .",
    "we now define the _ superposition _ operation @xmath78 as @xmath79 and the recurrence relation ( [ fx : rec ] ) gets the following form : @xmath80    the value functions are piecewise linear as a consequence of the mip representation .",
    "we thus represent each piecewise linear function @xmath81 as a sequence of segments @xmath82 for @xmath83 .",
    "our algorithm computes iteratively the results of the dynamic programming recurrence ( [ f : rec ] ) , and stores the values functions as lists of functions segments .",
    "each iteration is performed in two steps .",
    "first , @xmath84 is computed ( called the _ envelope _ of the functions @xmath85 ) via a simple procedure which compares segments with a common domain .",
    "second , the _ superposition _ @xmath86 is evaluated .",
    "figure  [ fig : dprec2 ] provides an example of the evaluation of the superposition , using functions with two segments each .",
    "this is done by evaluating the superposition of all pairs of segments @xmath87 from @xmath88 and @xmath81 , respectively , and extracting the minimum ( lower envelope ) of the resulting piecewise - linear functions . in the case of figure",
    "[ fig : dprec2 ] , four superpositions of segments are performed .",
    "the result of the superposition of two segments @xmath89 can be derived analytically in @xmath90 .",
    "a geometrical interpretation of this step is that the set of feasible @xmath91 values forms a parallelogram , and the result of a superposition corresponds to the lower edges of these parallelograms .",
    "overall , the complexity of one iteration of the dynamic programming  computing @xmath92 from the value functions of predecessors  is linked to the complexity of the _ envelope _ operation and the complexity of the _ superposition _ operation .",
    "let @xmath93 be the number of segments of the value function @xmath77 and @xmath94 the total number of segments of the value functions of predecessors @xmath95 .",
    "let @xmath96 be the number of segments in @xmath81 .",
    "as shown in section [ appendix : superpos ] of the appendix , the superposition can be implemented in @xmath97 and according to section [ appendix : envelope ] , the envelope operation can be computed in @xmath98 , where @xmath99 denotes the inverse ackermann function . the superposition operation is a special case of the calculation of the envelope of the minkowski sum of two polygons ( cf .",
    "@xcite,@xcite ) .",
    "finally , note that in many applications , the capacity @xmath8 and the domains of the segments of @xmath21 are integer .",
    "this allows to restrict the segments of the value function to integer domains reduce the number of segments of the values functions , as explained in section [ sec : integerdata ] of the appendix .",
    "this section now describes the dynamic programming recursion when considering the duration constraint @xmath9 .",
    "the value functions now include one additional dimension related to the duration @xmath100 .",
    "let @xmath101 be the value function for step @xmath22 and for travel times equal to @xmath100 , which returns the best profit for a final inventory @xmath102 .",
    "the recurrence relation for @xmath103 has the following form : @xmath104    with these conventions , @xmath103 is defined for every possible duration considering all feasible paths of different lengths .",
    "this number of possible durations values grows exponentially and can include dominated elements .",
    "hence , to avoid representing dominated parts , we compute an alternative value function @xmath105 , where only the non - dominated options @xmath101 for a given _ duration budget _",
    "@xmath106 are considered .",
    "this function is defined as follows : @xmath107 note that @xmath108 is piecewise constant in @xmath100 if @xmath102 is fixed . furthermore , if the profit functions are monotonically decreasing , then the functions @xmath109 are monotonically increasing in  @xmath102 , and monotonically decreasing in @xmath100 .",
    "the functions @xmath105 can be evaluated via the following recurrence formula : @xmath110    the values functions @xmath109 are computed explicitly in our dynamic programming algorithm . as in the previous section , each step of the recursion requires to apply the _ envelope _ and _ superposition _ operations .",
    "these operations are repeated for distinct values of @xmath100 .",
    "the explicit representation of the value functions is also generalized : instead of linked lists of function segments , the algorithm relies on several connected lists , one for each non - dominated duration value @xmath100 .",
    "this structure is illustrated in figure [ fig : mlla ] .",
    "the corresponding value function @xmath109 consists of planes that are constant with respect to @xmath100 .",
    "each plane is represented by a single segment for the corresponding domain of feasible time budgets .",
    "the segments and the corresponding domains have the same color ; darker colors correspond to larger time budgets .",
    "figure [ fig : mllb ] is a representation of @xmath109 by linked segments .",
    "each class of time budgets ( e.g. @xmath111 ) is associated with a unique color and the corresponding linked list of valid segments can be traced by following the segments and links of this color .",
    "there are two types of links , down - links that lead to segments that are feasible for a lower time budgets , and up - links that lead to segments that are feasible for higher time budgets .",
    "this structure can be used to traverse @xmath109 with respect to @xmath102 for a fixed value @xmath100 .",
    "adding the duration constraint in the dynamic programming algorithm results in a larger number of non - dominated function segments .",
    "a key difference between the duration and capacity constraints is that the route duration limit @xmath9 acts as a global constraint , and there are little opportunities to prune by feasibility in intermediate steps . to circumvent this issue",
    ", we introduce an alternative algorithm based on a lagrangian relaxation @xcite of the duration constraint .",
    "the notation will be extended to simplify the description of the methods .",
    "let @xmath112 be the objective value ( [ areltp : obj ] ) for a feasible solution @xmath113 , and @xmath114 ( indicating that finding the optimal @xmath115 is declared as the subordinate problem ) .",
    "note that finding the corresponding optimal solution for @xmath115 can still be a hard problem ( section [ sec : complexity ] ) .",
    "furthermore , each sub - route @xmath116 of @xmath16 can be characterized by its subset of visited customers , since the order of indices also defines the order of customers .",
    "the subset notation will thus also be used for subsequences . the objective value for a subroute @xmath116",
    "is identified as @xmath117 .      applying a lagrangian relaxation to the duration constraints leads to the following formulation , @xmath118 which is equivalent to minimizing @xmath119 , for @xmath120 , such that @xmath121    we note that @xmath122 is again a distance matrix and the triangle inequality holds .",
    "the dynamic programming algorithm of section [ sec : dpnotmax ] can thus be used to evaluate @xmath119 for any given value of @xmath123 , and the corresponding primal solution is called @xmath124 .",
    "the function @xmath119 is concave ( see , e.g. , * ? ? ?",
    "* ) , and any @xmath119 is a lower bound of ( [ areltp : obj]-[areltp : y ] )",
    ".    the best dual bound @xmath125 can be found by means of standard iterative techniques for convex optimization , such as bisection search , intersection of tangents , or quasi - newton , among others .",
    "these methods depend on an initial search interval @xmath126 $ ] , which should satisfy @xmath127 .",
    "we can choose @xmath128 .",
    "for the upper bound , two cases should be considered .",
    "if @xmath129 , then the problem is infeasible since even the direct trip from @xmath130 to @xmath15 is infeasible .",
    "else , if @xmath131 , the direct trip from @xmath130 to @xmath15 is a feasible solution , and with the inventory decisions @xmath132 , @xmath133 , the following inequality holds : @xmath134    since ( [ f : lbineq1 ] ) is valid for @xmath135 and if @xmath129 we can find the following bound : @xmath136    therefore @xmath135 is contained in the following interval : @xmath137 \\label{f : lbinterval } \\end{aligned}\\ ] ]    we performed extensive computational experiments to find a most adequate search algorithm for  @xmath135 . using the intersection of sub - gradients , at each iteration , as next search point turned out to be an efficient and robust choice , as it led to the average least number of evaluations of @xmath119 .",
    "thus , for a current search interval @xmath138 $ ] , the next lagrange multiplier is obtained as the intersection of the lines originating in @xmath139 and @xmath140 , with slopes @xmath141 and @xmath142 , respectively .",
    "the method iterates until the termination is satisfied , in our case the difference @xmath143 for a given @xmath56 .",
    "the overall method is reported in algorithm  [ alg : bsec ] .",
    "[ alg : bsec ] input : @xmath144 and @xmath145 , @xmath146 such that @xmath147 and @xmath148 output : feasible solution that meets the termination criterion @xmath149 calculate @xmath150 and @xmath151 return @xmath152 @xmath153 @xmath154 return @xmath155    in this algorithm , the function @xmath156 returns the new search point  @xmath157 , at each iteration .",
    "the search intervals @xmath138 $ ] are such that the primal solution that correspond to the left border is always feasible , and the solution that corresponds to the right border is infeasible or optimal .",
    "after termination , the primal solution that corresponds to the left border is feasible , and therefore can be used as an upper bound .    naturally , this primal solution is not necessarily optimal for the original areltp , since a duality gap can exist . to solve the areltp exactly , we rely on this lagrangian relaxation to provide good combinatorial lower ( and upper ) bounds within a branch - and - bound framework .",
    "the details of this algorithm are described in the next section .",
    "the search space of the proposed branch and bound consists of areltp solutions where the duration constraint is not necessarily satisfied .",
    "the solution branches of the branch - and - bound tree explore subspaces that are restricted by excluding customers and also by defining mandatory customers .",
    "we thus represented a solution branch as a pair of sets @xmath158 , where @xmath159 the set of mandatory customers and @xmath106 is the set of excluded customers .",
    "solutions that satisfy the duration constraint are called feasible .    there are four determining design choices ; the choice of lower bounds , the construction of ( good ) feasible solutions ( ubs ) , the branching rule and the strategy for selecting the next branch . a general discussion of branch and bound strategies can be found in @xcite and a review on branching rules can be found in @xcite .    in our case ,",
    "the lower bounds are produced by the lagrangian relaxation with respect to the duration constraint .",
    "slight modification to the methods presented in the previous sections are necessary to reflect mandatory and excluded customers",
    ". excluded customers can be simply eliminated from the data set . to consider a mandatory customer @xmath160 , we eliminate the arcs @xmath11 that _ skip _ this customer , i.e. , such that @xmath161 for @xmath160 .",
    "the branching rule and the heuristic to obtain good feasible solutions ( ubs ) with respect to the duration constraint are based on the solution of the lagrangian relaxation , i.e. for a given solution branch @xmath158 a feasible solution can be obtained from the lagrangian relaxation . based on this solution , an augmented tour @xmath162 is constructed by sequentially inserting customers as long as it is possible to maintain feasibility .",
    "worsening the solution is allowed at this step . as a consequence , the set of solutions @xmath163 always satisfies the duration constraint , and we can find an optimal solution @xmath164 in @xmath165 using dp without duration constraint .",
    "this solution defines the upper bound for the solution branch .",
    "our branching rule is based on the selection or elimination of a customer visit @xmath166 . as a consequence , the branch @xmath167 is replaced by the branches @xmath168 and @xmath169 in the tree .",
    "the following rules were considered : sequential branching , strong branching with one - step look ahead and random selection . in case of sequential",
    "branching , the smallest index was selected . in case of strong branching ,",
    "the customer @xmath22 with the smallest upper bound was selected .",
    "strong branching significantly reduced the number of iterations ( a reduction of approximately 30% ) , but the evaluation of all candidates was time consuming . in average , the performance of sequential branching and random selection were not significantly different , but the occurrence of outliers were less frequent with random selection .",
    "therefore , the random selection has been selected .",
    "the selection of the next branch for exploration is based on `` best - estimate '' , i.e. , lowest upper bound .",
    "finally , we can not assume that the triangle inequality are satisfied for some lot sizing applications , leading to some necessary adaptations of the algorithms .",
    "this is discussed in the next section .",
    "in general , the triangle inequality is not satisfied for problems that include setup costs or setup times . in the lot",
    "sizing application lswrc , skipping a customer ( i.e. , a production period ) can increase the total setup costs as well as the total resource consumption , and render the solution infeasible .",
    "four adaptations of the code are needed to resolve these  issues :    * when applying dynamic programming to solve the lagrangian relaxation for a solution branch ( sections [ sec : dpnotmax ] and [ sec : bblr ] ) , the recursion formula considers the cost to reach a customer  @xmath170 directly after customer @xmath22 ( cost of @xmath171 ) .",
    "if the triangle inequality is not satisfied , then a shortest path between @xmath22 and  @xmath170 is used . * to find a good ub for a solution branch , our heuristic procedure performs successive customer insertions and checks the feasibility with respect to the duration constraint .",
    "if the triangle inequality holds , the insertion of a customer @xmath22 between two consecutive customers @xmath172 , @xmath173 results in an increase of the duration , which can not not be shortened by intermediate stops . if the triangle inequality is not satisfied , then a shortest path between  @xmath172 and @xmath22 and a shortest path between @xmath22 and @xmath173 is used .",
    "* the dynamic programming approach that considers the duration constraint ( based on equation [ formulat : dpt2 ] ) considers all feasible predecessors @xmath22 of @xmath170 . in general",
    ", the cost matrix @xmath174 and the duration matrix @xmath175 do not satisfy the triangle inequality .",
    "several non - dominated paths may connect @xmath22 and @xmath170 with respect to the two objectives : cost and duration .",
    "therefore all these paths need to be considered . * the initial route @xmath176 is used to check if the problem is infeasible and to obtain initial bounds for @xmath135 ( with respect to equation [ f : lbinterval ] ) . without the triangle inequality , this route can be infeasible , and a shortest path algorithm is used to generate an initial route .",
    "in the following , we evaluate the performance of the proposed methods on the areltp with and without the duration constraint . the corresponding experiments are based on instances for two types of applications , the evaluation of routes for the srltp ( srltp instances ) and lot sizing application ( lswrc instances ) .",
    "the srltp instances are based on two types of orienteering instances , the tsiligirides instances introduced in @xcite and the chao - golden instances introduced in @xcite ; where the distance matrix also serves as cost matrix ( @xmath177 ) . for each node ,",
    "a piecewise linear profit functions with four steps was generated .",
    "the duration limit @xmath9 is taken from the original instances and @xmath8 takes the values 30 , 60 and 120 . for each instance , twenty a - priori routes were constructed by a randomized nearest neighbor procedure .",
    "to the knowledge of the authors , instances with setup times that are dependent on idle times are not available in the literature . in the following section",
    ", the generation of the lswrc instances will be discussed .",
    "all instances are available at http://www.univie.ac.at / prolog / research / areltp/.      for simplicity , the setup related resource is defined as the setup related costs ( @xmath50 ) , therefore @xmath9 is the maximum budget for setup related costs . to investigate the influence of the structure of the instances on the performance ,",
    "the following factors are considered : the number of periods @xmath15 , the maximum setup cost @xmath9 and the capacity bounds @xmath8 .",
    "the production costs are piecewise linear and concave with three steps .",
    "each parameter setting for the random generator is replicated with eleven different random seeds .",
    "the number of periods is given by @xmath178 and @xmath179 .",
    "the tightness of the maximum setup cost constraint @xmath9 is strongly dependent on the setup costs @xmath13 and the number of periods @xmath15 .",
    "therefore , we used the following formula for @xmath9 , which considers a parameter @xmath180 :    @xmath181    as such , @xmath9 is the sum of the maximum setup cost and a portion of the value @xmath182 .",
    "this value is the setup cost of the lot - for - lot policy ( @xmath183 ) , where the demand of each period is satisfied by the production of this period directly ( zero inventory ) .",
    "if the triangle inequality holds for @xmath184 , then @xmath185 means that @xmath9 is larger than the setup cost for any feasible solution .",
    "the results will be reported with respect to the tightness of @xmath9 , i.e. , `` small '' will be used for @xmath186 , `` medium '' will be used for @xmath187 and `` large '' will be used for @xmath188 .",
    "analogously , the terms small , medium and large will be used for @xmath179 .    to evaluate the balance of the different cost components in the instances , we compare the value of each optimal solution @xmath189 with the value of the lot - for - lot strategy @xmath190 .",
    "the cost @xmath190 is the sum of the production costs @xmath191 plus setup costs @xmath192 . for an optimal solution @xmath193 , the relative savings @xmath194 with respect to the lot - for - lot solution",
    "is calculated as : @xmath195    the relative savings @xmath194 is the sum of the production savings @xmath196 minus the additional expenses due to setups @xmath197 and inventory @xmath198 in the optimized solution .",
    "figure [ statrelcosts ] reports the average value of these savings for all instance types , for different values of  @xmath9 and  @xmath8 .",
    "the value of the savings tends to increase with the capacity and duration limits  @xmath8 and  @xmath9 . indeed",
    ", larger capacities result in more opportunities to reduce production costs , at the cost of additional storage or setup costs .",
    "it is also noteworthy that all cost components have a significant impact , such that the instances are well - formed and the optimal solution does not correspond to a simple policy such as l4l .          in this section",
    ", we first evaluate the performance of the proposed dynamic programming algorithm ( section [ sec : dpnotmax ] ) for the areltp without duration limit constraint , in comparison with gurobi ( section [ sec : mipsolverformualtion ] ) .",
    "the experiments were done with the three families of instances : chao - golden , tsiligirides , and the new lswrc test sets .    for both types of instances",
    "the dynamic programming approach is significantly faster than gurobi . for the srltp and lswrc , we observe average speedup factors of @xmath199 and @xmath200 , respectively . on @xmath201 of instances",
    ", dp is faster than gurobi .",
    "the average the speedup factor is @xmath202 , with a minimum of @xmath203 and maximum of @xmath204 . according to a wilcoxon signed - rank test , the p - value of the null hypothesis ( both methods are equally fast ) is smaller than @xmath205 .",
    "this hypothesis can thus be rejected with high confidence , thus validating the significance of this speed - up .     and",
    "@xmath8.,scaledwidth=85.0% ]    now , figure [ fig : tsichaolotprocessingtimedpwotmax ] illustrates the influence of @xmath15 and @xmath8 on the performance of both methods .",
    "we relied on a logarithmic representation of the cpu time as a function of @xmath15 , and display the measures as boxplots for each instance class and each value of @xmath15 and @xmath8 . both algorithms display a cpu time which increases exponentially with problem size .",
    "as expected , the instances with large value of @xmath8 are more difficult for the dynamic programming algorithm , with a cpu time three to four times higher than for small @xmath8 .",
    "this is due to an increase of the number of labels needed to represent the value functions .",
    "in contrast , gurobi is relatively insensible to changes in the capacity limits .",
    "overall , dp is significantly faster than gurobi for all these test instances .      in this section ,",
    "we compare the performance of the three algorithms for the areltp with duration constraints :    * dp3d  the proposed pure dynamic programming approach ( section [ sec : dptmax ] ) , * bbdp  the proposed branch and bound method ( section [ sec : bb ] ) in combination with the dp approach for the lagrangian relaxation ( section [ sec : dpnotmax ] ) , and * gurobi  as a reference method , based on the mip formulation of section [ sec : mipsolverformualtion ] .    for this purpose , we rely on the same three classes of instances .",
    "figure [ fig : violin : detail ] illustrates the cpu time of each method for each set , and for each value of @xmath8 and @xmath9 . as it was impossible to display all results separately for each value of @xmath15 ( hence considering four combined factors , for a total of 5633 instances ) we aggregated these results and display the shape of the distribution of the cpu time for each sub - class of instances with varying @xmath15 as violin plots . in these plots ,",
    "the central bars represent the median and the stars represents the means .",
    "the detailed results , for all instances , are available at http://www.univie.ac.at / prolog / research / areltp/.     and @xmath9 .",
    "the results are reported as combined boxplots and violin - plots , hence illustrating the distribution of the cpu time each subclass of instances.,scaledwidth=90.0% ]    we observe in figure [ fig : violin : detail ] that the pure dynamic programming approach ( dp3d ) is in average slower than the two other methods in the presence of duration constraints , with the exception of some lot sizing instances with medium or large @xmath8 .",
    "for some of these latter instances , gurobi requires a long cpu time , as illustrated by the extended tail of the violin plot . comparing the branch - and - bound and dynamic programming approach ( bbdp ) with gurobi , we observe that bbdp performs significantly better than gurobi for the three classes of instances , with an average speedup factor of two on the srltp instances , and a speedup of ten on the lot sizing instances .",
    "bbdp is also more robust than gurobi : its cpu time never exceeds ten seconds , while gurobi uses up to blue thirty minutes to solve some specific instances .",
    "this impact is more acute for the lot sizing data sets .",
    "we finally observe a large proportion of instances solved in a few milliseconds by bbdp .    in the following ,",
    "we further investigate the impact of the problem size @xmath15 and the capacity  @xmath8 on the solution time .",
    "figure [ fig : cpufordpandbb ] displays boxplot representations of the cpu time of the three methods , for all instance classes .",
    "the same observations can be made : dp3d is slower than gurobi , which itself is in average slower than bbdp .",
    "furthermore , larger values of @xmath8 lead to increased cpu time for bbdp and dp3d .",
    "this effect is less marked when considering gurobi , although a small @xmath8 facilitates the resolution .",
    "on the figure , the boxplots representing the cpu time of gurobi are almost aligned , on the logarithmic scale , indicating an exponential growth of the resolution time as a function of @xmath15 .",
    "this growth tends to be more moderate for bbdp and dp3d , for large values of @xmath15 .",
    "finally , figure [ fig : boxplot : cpufordpandbbtmax4lot ] illustrates the impact of @xmath9 on the cpu time of the three methods , on the lot sizing instances .",
    "we observe that the resolution time of dp3d is almost not impacted by the value of this parameter , most likely because @xmath9 does not help to eliminate labels until the final stages of the resolution . for gurobi and bbdp , a medium @xmath9 appears to lead to more difficult instances , and a large @xmath9 is easier to solve . for bbdp , a large @xmath9 helps to reduce the size of the branch - and - bound tree .",
    "in particular , in the hypothetical case of @xmath206 , the bbdp procedure stops at the root node .",
    "in this paper , we have introduced the lateral transhipment problem with a - priori routes and piecewise linear profits ( areltp ) .",
    "we have also shown that this model covers an important class of lot sizing problems with requalification costs .",
    "two problem variants were studied , the areltp with and without duration constraint .",
    "both problems are np - hard . for the areltp without duration constraint , we proposed a dynamic programming algorithm ( dp ) with continuous labels . for the areltp with duration constraint",
    ", we introduced a generalization of this approach ( dp3d ) as well as a branch - and - bound method which relies on lagrangian relaxation and dynamic programming ( bbdp ) .",
    "the performance of the algorithms was evaluated on a large set of problem instances , for the arelp and for the lot sizing application .",
    "our computational experiments indicate that the proposed dp solves the areltp without duration constraint very efficiently , with average speedup factors of @xmath199 over a commercial solver ( gurobi ) . for the areltp with duration constraint",
    ", our hybrid bbdp approach outperforms the commercial mip solver and the dp3d in most cases , with an average speedup factor of four for the areltp instances , and ten for the lot sizing data sets .",
    "these results open the way to several avenues of research .",
    "one important application concerns the lateral transhipment problem with one or more routes .",
    "we aim to use these exact procedures iteratively , in further works , to evaluate fixed routes and optimize their transhipments during a heuristic resolution . using the lagrangian bounds and",
    "the proposed hybrid branch - and - bound , it is also possible to estimate if some subproblems ( e.g. , two new fixed routes evaluated during a local search move ) can be eliminated on the fly , before even attempting an exact resolution . in this context , the proposed methods will significantly contribute to solve some difficult multi - attribute vehicle routing problems .",
    "finally , these methods will be useful to address other complex lot sizing variants and subproblems .",
    "this section presents the details of the complexity results for the areltp ( [ areltp : obj][areltp : tmax ] ) . in (",
    "* section 3.3 ) we stated that the areltp is solvable in polynomial time if the following three simplifications are premised :    1 .",
    "@xmath21 is linear , [ cp:1 ] 2 .",
    "the travel costs are not considered ( @xmath207 ) and [ cp:2 ] 3 .",
    "travel time is not considered ( @xmath208 ) .",
    "[ cp:3 ]    however , if at least one of these simplifications is revoked , then the areltp is np hard .",
    "more precisely , the proofs of the following three statements will be provided in this section :    1 .",
    "areltp is np hard if @xmath21 is linear and travel time is not considered ( see lemma [ lem : complexity : cij ] ) .",
    "areltp is np hard if travel costs and travel time are not considered ( see lemma [ lem : complexity : flin ] ) .",
    "areltp is np hard if @xmath21 is linear and travel costs are not considered ( see lemma [ lem : complexity : tij ] ) .",
    "[ lem : complexity : cij ] the areltp is np hard for @xmath21 linear and @xmath208 .    consider the following reduction of balanced number partitioning ( or number partition ) @xcite for the numbers @xmath209 , @xmath210 to the areltp :    * @xmath211 * @xmath212 for @xmath213 $ ] * @xmath214 for @xmath215 $ ] * @xmath216 for @xmath210 and @xmath217 .",
    "the corresponding objective is : @xmath218 and for the transformation @xmath219 the objective has the following form : @xmath220 if @xmath221 is a solution to the number partitioning problem , then @xmath222 for @xmath223 and zero otherwise , therefore a solution for number partition is optimal . on the other hand an optimal solution of this problem with objective zero corresponds to a solution for the number partition problem .",
    "[ lem : complexity : flin ] the areltp is np hard for @xmath207 and @xmath208 .    a reduction of the knapsack problem ( @xmath224 ) to the areltp will be used in the proof .",
    "node @xmath130 is a source with @xmath225 $ ] and @xmath226 is identical to zero .",
    "the following cost change functions @xmath227 are proposed for the transformation : @xmath228 then , the corresponding areltp has the following equivalent form : @xmath229 the transformation @xmath219 results in the following : @xmath230 since this problem is equivalent to the knapsack problem the proof is complete .",
    "a simple modifications of the proof can be used to prove that areltp is np hard for @xmath207 and @xmath208 , and @xmath231 continuous .",
    "[ lem : complexity : tij ] the areltp is np hard for @xmath21 linear and @xmath207 .    again , a reduction of the knapsack problem ( @xmath224 ) to the areltp is possible .",
    "set @xmath232 and @xmath233 ; and let @xmath234 for @xmath235 $ ] and @xmath236 for @xmath237)$ ] then the areltp has the following form : @xmath238 the transformation @xmath239 results in : @xmath240 because of ( [ f : comp : w ] ) the weight @xmath241 is activated for @xmath242 and therefore @xmath243 is the optimal choice when maximizing @xmath244 ; hence @xmath245 is binary and the problem is equivalent to the knapsack problem .",
    "the dp approach for the areltp is based on two basic operations ; the envelope of functions and the superposition .",
    "the calculation of the envelope will be described in section [ appendix : envelope ] and the superposition of piecewise linear functions as defined in the main paper ( [ eq : superos ] ) will be described in section [ appendix : superpos ] .",
    "the relatedness of feasible states in dynamic programming and minkowski sums will be established and cases were the performance can be improved will be discussed . in section",
    "[ appendix : complexitydp ] , the complexity for resolving one stage of the dynamic program is discussed and a reduction of a sorting problem to calculating envelopes indicates that the complexity of the proposed algorithm is reasonable .",
    "the envelope is the minimum of a finite set of functions @xmath246 and the calculation is accomplished in a divide an conquer manner . in the lowest level ,",
    "the set of functions is decomposed into @xmath247 pairs plus at most one functions . for each pair",
    "the envelope is calculated and replaces the corresponding pair .",
    "therefore , there are at most @xmath248 functions in the next level . according to that ,",
    "the number of functions in level @xmath249 is one , and the corresponding function is the envelope of @xmath250 .",
    "+ therefore , to apply this method for a set of piecewise linear functions it is sufficient define the envelope of two piecewise linear functions @xmath81 and @xmath251 .",
    "the union of the domains of @xmath81 and @xmath251 can be decomposed into intervals such that each interval has exactly one of the following properties :      such a decomposition can be found by simply traversing the segments of @xmath81 and @xmath251 in @xmath252 and the envelope for each interval is computable in constant time .",
    "+ in each level @xmath253 , the envelopes of pairs of piecewise linear functions is calculated .",
    "based on @xcite , an upper bound for the number of segments in each level and a statement about the runtime complexity can be derived .",
    "more precisely , it is possible to employ results for davenport ",
    "schnizel sequences to get an upper bound on the number of edges .",
    "for a review on davenport ",
    "schnizel sequences , see @xcite .",
    "the main results for the continuous case can be found in @xcite and results for calculating the the envelope of a family of piecewise linear functions are taken from @xcite , stating that the number of segments is bounded by @xmath254 where @xmath99 denotes the inverse ackermann function and @xmath255 is the total number of segments in the first level .",
    "it is important to note that this result is only dependent on the number of edges and not dependent on the number of involved functions .",
    "therefore the number of edges in each level is also bounded by @xmath256 , and for estimating the worst case complexity , the calculation of the levels are considered as decoupled .",
    "more precisely , for level @xmath253 let @xmath257 be the number of involved functions . to calculate the functions for the next level , the envelope of @xmath258 pairs is computed . for each pair",
    "the complexity is linear with the number of involved edges , therefore the computational complexity for each level is bounded by @xmath254 , with makes @xmath259 in total for all levels",
    ".      a procedure to calculate the superposition @xmath260 will be presented .",
    "the functions @xmath88 and @xmath81 are represented by sequences of segments , where each segment is a linear function defined on an interval . throughout the paper , we assume that the profit functions are lower semicontinuous .",
    "since @xmath21 are piecewise linear the following is true : @xmath261    extending the domains of the segments to closed intervals does not lead to ambiguities , since dominated values do not occur in the envelope .",
    "therefore the following notation will be used ; the value function @xmath88 is represented by the segments @xmath262 for @xmath263 $ ] ; and the revenue change function @xmath81 is represented by the segments @xmath264 for @xmath265 and @xmath266 $ ] .    in order to calculate the superposition of @xmath88 and @xmath81 , the notion of feasible state and minkowski addition will be used . a feasible state with respect to @xmath88 and @xmath81",
    "is a point @xmath267 such that @xmath268 , @xmath269 and @xmath270 .",
    "the set of all feasible states is called @xmath271 and the superposition is the envelope of @xmath271 , or @xmath272 for short .",
    "this set can also expressed by the envelope of a minkowski sum : @xmath273    efficient algorithms to compute the border of minkowski sums are known for polygons ( cf .",
    "@xcite,@xcite ) and they can be applied to calculate the superposition . however , the polygons used to represent piecewise linear functions have specific properties , and the worst case complexity can be improved .",
    "more precisely , let @xmath274 be the number of segments in @xmath88 and let @xmath275 be the number of segments in @xmath81 , then @xmath276 can be improved to @xmath277 .      in the following ,",
    "a representation of the set of feasible states @xmath279 by corner points is established in lemma [ lem2 ] .",
    "it is the basis for the calculation of the superposition for piecewise linear functions , and it will be used to prove certain properties of the value function .",
    "a consequence of lemma [ lem2 ] is that the envelope of @xmath280 is the envelope of the following segments : @xmath288 and if the slope of @xmath289 is smaller than the slope of @xmath290 ( @xmath291 ) then the minimum of @xmath280 is defined by @xmath289 followed by @xmath292 , else it is defined by @xmath290 followed by @xmath293        obviously , @xmath272 can be constructed by successively adding segments of @xmath81 by using the following recursion formula : @xmath298 . according to ( [ def : omega12 ] ) and ( [ def : omega34 ] ) , all segments of @xmath299 can be grouped in the following way : @xmath300 note that @xmath289 and @xmath301 are defined for consecutive intervals .",
    "therefore @xmath302 can be used to define a function .",
    "the last segment of @xmath303 is @xmath304 , and it is defined for an interval that follows the segment @xmath305 . therefore , @xmath303 defines a function that starts in @xmath306 and ends in @xmath307 .",
    "analogously , @xmath308 defines a function that starts in @xmath306 and ends in @xmath307 .",
    "the segments in the groups @xmath309 , @xmath310 are collinear , but there may be gaps or overlapping in the domains .",
    "+ now , a definition of dominance with respect to feasible states will be stated :    a point @xmath267 ( weakly ) dominates a point @xmath311 if @xmath312 .",
    "a set of points @xmath313 dominates a set of points @xmath314 if for each point in @xmath315 a dominating point in @xmath313 exists , in symbols : @xmath316 and @xmath317 .",
    "for instance , if @xmath88 is monotonically increasing , then @xmath292 dominates @xmath318 . in short , @xmath319 .",
    "the following two lemmas will be useful to prove properties of the superposition @xmath260 :          first case : suppose that @xmath331 , then @xmath332 or @xmath333 .",
    "in the first case , the continuous function @xmath334 is positive for an interval with @xmath102 in the interior , a for the second case @xmath334 is negative inn a interval with @xmath102 in the interior . in both cases @xmath322",
    "is defined by one of the continuous function and therefore it is continuous .",
    "second case : if @xmath335 , then for a given sequence @xmath336 that converges to @xmath102 the property @xmath337 or @xmath338 is true for points that are infinitely close to @xmath102 . in both cases",
    "@xmath339 follows from the continuity of @xmath88 and @xmath320 .        1 .",
    "@xmath260 is piecewise linear .",
    "[ lem : vi1-p1 ] 2 .",
    "if @xmath88 and @xmath81 are monotonically increasing , then @xmath260 is monotonically increasing .",
    "[ lem : vi1-p2 ] 3 .",
    "if @xmath88 and @xmath81 are continuous , then @xmath260 is continuous .",
    "[ lem : vi1-p3 ]    * [ lem : vi1-p1 ] : this is a consequence of a representation of @xmath260 as the envelope of the minkowski sum of two polygons . * [ lem : vi1-p2 ] : the strategy to prove the monotonicity is to represent the envelope of @xmath272 by the minimum of a set of monotonically increasing functions @xmath341 , where each function starts in the same point and each function ends in the same point .",
    "the monotonicity of @xmath260 is then a consequence of lemma [ lem : vmon ] .",
    "+ in the following , a representation for @xmath299 is proposed where a set of @xmath342 is constructed for a single segment of @xmath81 such that : @xmath343 before proposing the construction , note that because of the monotonicity of @xmath88 the segments @xmath318 can be eliminated ( @xmath319 ) , and as a consequence @xmath344 can be eliminated .",
    "hence , according to ( [ f : gammarep ] ) , @xmath299 can be represented by @xmath345 and @xmath346 : @xmath347 + ( black ) , @xmath348(red ) and @xmath349(blue),scaledwidth=70.0% ] + figure [ fig : superposgamma ] demonstrates the construction of @xmath350(black ) , @xmath348(red ) and @xmath349(blue ) . to prove that @xmath351 is monotonically increasing ,",
    "it is sufficient to define a set of monotonically increasing functions @xmath342 on the whole domain such that each segment of @xmath303 , @xmath308 and @xmath308 is used in at least one function ; each function only consists of segments of @xmath303 , @xmath308 and @xmath308 ; and each function starts in @xmath306 and ends in @xmath307 .",
    "+ we know that @xmath303 and @xmath308 are functions . because of monotonicity of @xmath81 , they are also monotonically increasing and satisfy the assumptions . to complete the proof , it is sufficient to find monotonically increasing functions on the whole domain that integrate the missing segments in such a way that the function starts in @xmath306 and ends in @xmath307 . in the following ,",
    "the auxiliary functions @xmath352 are defined for each segment @xmath292 : @xmath353 obviously , @xmath352 contains @xmath292 and the first part of the sequence of segments @xmath354 is monotonically increasing , starting in @xmath306 .",
    "analogously , the last part of segments @xmath355 is monotonically increasing and ends in @xmath307 . finally the middle piece , @xmath356 is monotonically increasing because @xmath357 , hence proving that @xmath352 is monotonically increasing , starting in @xmath306 and ending in @xmath307 .",
    "now , the envelope of @xmath299 can be represented by : @xmath358 therefore , @xmath359 is monotonically increasing . to prove that @xmath260 is monotonically increasing for more than one segment",
    ", the following auxiliary statement will be used .",
    "a set of functions @xmath360 exists such that : 1 .",
    "@xmath361 2 .",
    "each functions is monotonically increasing [ prop : gammamon ] 3 .",
    "each function starts in @xmath362 and ends in @xmath363 .",
    "[ prop : gammarange ] + proof of the auxiliary statement by induction : for @xmath364 the statement is true , since : @xmath365 induction step : @xmath366 .",
    "the set of functions @xmath367 consists of two parts .",
    "the first part @xmath368 contains the functions that represent @xmath369 plus additional segments to meet [ prop : gammarange ] .",
    "the second set of functions @xmath370 represents @xmath371 and again additional segments are added to meet [ prop : gammarange ] . in the following definitions for @xmath368 and @xmath370 the symbol @xmath372 is used to indicate the concatenation of segments : @xmath373 @xmath374 finally , the envelope of @xmath375 can be represented by the minimum of @xmath368 and @xmath370 and since the functions of both sets meet [ prop : gammamon ] and [ prop : gammarange ] the minimum also satisfies [ prop : gammamon ] and [ prop : gammarange ] .",
    "@xmath376 + according to the auxiliary statement @xmath377 is monotonically increasing and since @xmath378 the proof for the monotonicity is complete . * [ lem : vi1-p3 ] : the proof is analogous to the proof for property [ lem : vi1-p2 ] but it is based on lemma [ lem : vcont ] and uses the fact that @xmath379 and @xmath380 and therefore @xmath381 .    when calculating the superposition for @xmath81 or @xmath88 with discontinuities , the concept of using auxiliary functions ( e.g. @xmath382 and @xmath383 ) can be used for pairs of continuous parts .",
    "this helps to reduce the number of involved segments when calculating the envelope of @xmath272 .    for convex value functions ,",
    "the calculations can be simplified ; for instance if @xmath81 consist of only one segment , then @xmath382 and @xmath383 may alternate in the envelope at most once and @xmath384 consists of at most one segment .",
    "an example can be found in figure [ fig : superposgammaconvex ] .",
    "[ prop : superpos : compl ] given the piecewise linear functions @xmath340 , the superposition @xmath260 can be calculated in at most @xmath385 time , where @xmath274 is the number of segments in @xmath88 and @xmath275 is the number of segments in @xmath81 .",
    "according to the construction given ( [ f : gammarep ] ) , it is possible to calculate @xmath351 in @xmath386 time . according to that ,",
    "the calculation of the envelopes for each segment in @xmath81 can be done in @xmath387 . to calculate the envelope of the envelopes we therefore get a runtime complexity of @xmath388 and the number of edges",
    "is bounded by @xmath389 .",
    "* @xmath400 for @xmath401 $ ] * @xmath402 \\\\                                -2 + 4q \\text { for } q \\in ( 1,2 ]                                  \\end{cases } $ ] * @xmath403 $ ] * @xmath404 \\\\                                -2 + 4q \\text { for } q \\in ( 1,2]\\\\                                 4q \\text { for } q \\in ( 2,3 ]                                  \\end{cases } $ ] * @xmath405\\\\                                -3 + 5q \\text { for } q \\in ( 2,3 ]                                  \\end{cases } $ ]",
    "we discuss the complexity for resolving a single stage of the dynamic programming recurrence , to calculate @xmath77 in stage @xmath22 as defined in formula ( [ f : rec ] ) in the main paper .",
    "the calculations consist of two parts , the first one is the calculation of @xmath84 and the second is the the superposition @xmath406 , which is equivalent to the calculation of the corresponding envelope @xmath272 . + according to section [ appendix : envelope ] the calculation of @xmath92 can be accomplished in a divide and conquer manner , by decomposing the functions @xmath407 into pairs of functions . in the present case the number of involved edges is @xmath408 , where @xmath409 is the number of segments in @xmath85 . therefore , @xmath410 is the complexity for each of the @xmath411 levels , which gives worst case complexity of @xmath412 in total .",
    "note that @xmath413 grows extremely slow and @xmath414 for any practical size of @xmath415 .    to compute the worst case complexity for the superposition",
    ", we note that @xmath416 can be used as bound for the maximum number of segments in @xmath92 . for each segment in @xmath92 , the number of edges in @xmath272",
    "is bounded the number of pairs of segments @xmath417 ( @xmath418 and @xmath419 ) . that makes @xmath420 , where @xmath421 is the number of segments in @xmath21 .",
    "overall , the complexity is therefore @xmath422 .",
    "since @xmath423 grows faster than the constant @xmath421 , the complexity for solving the dp recurrence relation for stage @xmath22 is @xmath424 . in order to show that the algorithm has a reasonable complexity",
    ", we will reduce a sorting problem to the calculation of the upper envelope of a set of piecewise linear functions , which is the core of the algorithm .",
    "this sorting problem is called sorting @xmath255 sets of @xmath425 numbers and it is defined as follows : for @xmath426 the sets @xmath427 are given and @xmath428 .",
    "the sets @xmath429 are defined by the elements @xmath430 for @xmath426 and @xmath431 , i.e. @xmath432 . the problem is to sort the collection @xmath433 .    before proposing a reduction to the calculation of the envelope",
    ", we note that for solving the problem of sorting @xmath425 numbers there is no algorithm that performs better than @xmath434 in the comparison model",
    ". therefore we can not expect for find an algorithm for sorting @xmath255 sets of @xmath425 numbers in less than @xmath435 .",
    "the instance is given by the sets @xmath437 , where @xmath426 and @xmath431 .",
    "the following transformation is used to map all @xmath438 with the same @xmath170 into the interval @xmath439 : @xmath440 according to that , sorting @xmath441 is equivalent to sorting @xmath429 . for fixed @xmath22",
    "the sets @xmath442 are defined by @xmath443 and the following properties hold : @xmath444 , @xmath445 and exactly one member in available in each interval @xmath439 where @xmath446 . for the reduction , we consider the following functions : @xmath447   \\\\       a_{i , j }   & \\mbox{if } y \\in ( a_{i , j-1 } , a_{i , j } ] \\quad ( j \\geq 2 ) \\end{cases}\\ ] ] the corresponding functions @xmath21 are monotonically increasing and stepwise constant .",
    "an example is given in figure [ fig : reductiontosortedlists ] .",
    "the proposed algorithm for calculating the envelope returns the minimum of the collection @xmath448 with a complexity of @xmath449 and due to the construction of the envelope , the elements of @xmath450 are sorted in @xmath451 .",
    "the maximum function in the interval @xmath439 returns the sorted values @xmath450 , hence leading to the order of the original values .",
    "sorting @xmath255 sets of @xmath425 numbers can be reduced to an envelope computation , currently done in @xmath452 . our algorithm for calculating",
    "the envelope is thus very close to its theoretical complexity bound .",
    "similar to the total unimodularity for the min cost flow subproblem discussed in @xcite where integer solutions come for free , it may be useful to consider restricting the domain of the labels of the dp algorithm to integers .",
    "suppose that the domains of the segment of @xmath21 have integer borders , then it will be shown that the domains of the segments of the value functions @xmath77 can also be restricted to intervals with integer borders .",
    "the benefit of this reduction may be explained by the following situation : when calculating the the envelope , tiny segments may appear that do not contain a single integer , therefore the corresponding segment could be eliminated to reduce the complexity . in the following , an algorithm for restricting the segments of a value function to integer domains will be presented .",
    "we show that the superposition of the integerized value functions is equivalent to the superposition of the integerized versions , if the domains of the segments of @xmath21 have integer borders .",
    "let @xmath453 denote the set of integers , then @xmath454 denotes that @xmath455 is an integerized version of @xmath88 .",
    "it means that @xmath455 is a value function that is identical to @xmath88 on the domain of @xmath455 , and it includes all integer values of the domain of @xmath88 . more precisely :",
    "it is sufficient to prove [ integerize : p3 ] .",
    "suppose that @xmath460 and @xmath461 then @xmath462 and @xmath463 therefore @xmath464 .",
    "it also follows that @xmath465 and therefore @xmath466 and in combination with @xmath467 it is obvious that @xmath468    algorithm [ algo : integerize ] is used to integerize the border of the domains of the segments of the piecewise linear function @xmath88 such that @xmath454 . in the following",
    "we will assume that the domains of @xmath469 are closed intervals @xmath470 . in order to formulate a more general algorithm that allows ` holes ' in the domain ,",
    "the interval domains @xmath470 are identified by @xmath471 $ ] where @xmath472 .",
    "the output of algorithm [ algo : integerize ] is called @xmath473 and the following lemma states that algorithm [ algo : integerize ] defines a integerized version of @xmath88 .",
    "@xmath474 [ algo : integerize:1 ] @xmath475 [ algo : integerize:2 ]  @xmath476   @xmath477  [ algo : integerize:3 ] @xmath478 [ algo : integerize:4a ] [ algo : integerize:4 ] @xmath479 [ algo : integerize:5 ]  @xmath480   @xmath481 and @xmath482  [ algo : integerize:6 ] [ algo : integerize:7 ] @xmath483 [ algo : integerize:8 ]  @xmath476   @xmath484 and @xmath482  [ algo : integerize:9 ] @xmath485 @xmath486        in step [ algo : integerize:1 ] and step [ algo : integerize:2 ] of algorithm [ algo : integerize ] , the domain of the segment is reduced without cutting integers off . in step [ algo : integerize:3 ]",
    "obsolete segments are removed .    in step [ algo : integerize:4a ]",
    "all pairs of segments where the domains intersect in one point are identified ; in step [ algo : integerize:4 ] and step [ algo : integerize:7 ] the case where one of the segments dominates the other is treated . in case of dominance ,",
    "the domain of the dominated segment is reduced in step [ algo : integerize:5 ] and step [ algo : integerize:8 ] . in both cases",
    "it may happen that the reduced domain vanishes and therefore the corresponding segment will be removed which corresponds to the steps [ algo : integerize:6 ] and [ algo : integerize:9 ] .",
    "a detailed procedure for removing segments can be found in algorithm [ algo : remove ] .    because of the step [ algo : integerize:1 ] and step [ algo : integerize:2 ] , the property [ integerize : p1 ] is satisfied .",
    "the other steps may reduce the domain by one but it can not happen that integers are cut off ; therefore [ integerize : p2 ] and [ integerize : p3 ] are satisfied .    according to the algorithm , each segment of the integerized version @xmath473 originates in a segment of @xmath88 with possibly reduced domain . in the proof of the main result of this section , the following property will be used :      the value functions @xmath320 and @xmath88 are identical on the corresponding restricted domain , and the same is true for @xmath494 and @xmath455 .",
    "the domain of @xmath495 is the union of the domains of @xmath320 and @xmath494 and the domain of @xmath496 is the union of the domains of @xmath88 and @xmath455 ; therefore the domain of @xmath495 is contained in the domain of @xmath496 and the values are identical for points in the domain of @xmath495 . according to that , [ integerize : p2 ] and [ integerize : p3 ] is the consequence .",
    "the property [ integerize : p1 ] is true because of integerizing the domains .",
    "the dp recurrence relation for integerized domains is defined as follows : @xmath501})_{\\mathbb{z } } \\\\ w_{i } = ( \\overbrace{\\min_{j <",
    "i } ( w_j - c_{j , i})_{\\mathbb{z}}}^{\\tilde{w}_{i } : = } \\boxplus f_{i})_{\\mathbb{z}}\\end{aligned}\\ ] ] in the following , the equivalence of @xmath502 and @xmath77 for @xmath21 having domains with integer borders will be stated in the following proposition :                suppose that @xmath516 is the set of feasible states in stage @xmath170 , then @xmath517 is part of the envelope .",
    "the set of @xmath516 is the union of minkowski sums of @xmath170 segments ( @xmath170-tuple ) and the envelope of @xmath516 is the envelope of these @xmath170-tuples .",
    "the envelope of each @xmath170-tuple can be represented by the envelope of a set of @xmath518 segments with integer borders ( cf .",
    "edges of a hypercube ) and the union of these segments ( when considering all possible tuples ) can be used to represent the envelope @xmath519 . according to that ,",
    "we can find a feasible segment @xmath520 with integer borders such that @xmath521 .",
    "obviously , either @xmath522 or @xmath523 and therefore @xmath115 can be replaced by @xmath524 or @xmath525 .",
    "+ for proving [ integerizeproof : p2 ] it is sufficient to show that : @xmath526 proof of ( [ integerizeproof : p2a ] ) by induction . for @xmath527",
    "there is nothing to prove .",
    "suppose that the above properties hold for @xmath509 and @xmath528 .",
    "therefore lemma [ envminintegerized ] can be used to show that @xmath529 because adding a constant does not change the domain of the segments .",
    "proof of ( [ integerizeproof : p2b ] ) by induction on the number of segments in @xmath530 . for a single segment",
    "it follows that the borders are integer and therefore the superposition with @xmath531 is defined by the the border of feasible states for the superposition with @xmath530 . according to that , each segment in @xmath532",
    "can be identified by a segment in @xmath532 .",
    "this , in combination with [ integerizeproof : p1 ] gives the proof for the first segment .",
    "suppose the assumption is true for @xmath530 with @xmath415 segments , then it will be shown that the assumption holds for @xmath533 .",
    "suppose that @xmath534 , then @xmath531 consists of segments that correspond to @xmath530 or @xmath535 ; they are denoted @xmath536 and @xmath537 respectively .      alternatively , if @xmath535 has a left border @xmath543 that is not integer , then @xmath544 consists of segment that correspond to segments where the domain is bounded to left by @xmath545 and @xmath546 correspond to segments where the domain is bounded to the right by @xmath547 .",
    "note that @xmath548 does not contain points of @xmath549 , and according to corollary [ envminintegerized2 ] the proof of [ integerizeproof : p2 ] is complete .",
    "figure [ fig : segments300 ] and figure [ fig : segments60 ] present a comparison of the number of segments in the final value function ( last stage ) for different @xmath8 .",
    "according to the example the reduction in the number of segments can be considerably large , especially regarding the outliers ."
  ],
  "abstract_text": [
    "<S> we propose exact solution approaches for a lateral transhipment problem which , given a pre - specified sequence of customers , seeks an optimal inventory redistribution plan considering travel costs and profits dependent on inventory levels . </S>",
    "<S> trip - duration and vehicle - capacity constraints are also imposed . </S>",
    "<S> the same problem arises in some lot sizing applications , in the presence of setup costs and equipment re - qualifications .    </S>",
    "<S> we introduce a pure dynamic programming approach and a branch - and - bound framework that combines dynamic programming with lagrangian relaxation . </S>",
    "<S> computational experiments are conducted to determine the most suitable solution approach for different instances , depending on their size , vehicle capacities and duration constraints . </S>",
    "<S> the branch - and - bound approach , in particular , solves problems with up to 50 delivery locations in less than ten seconds on a modern computer . </S>"
  ]
}