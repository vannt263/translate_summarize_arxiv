{
  "article_text": [
    "parser generators have been used for decades to create translators and other language processing tools .",
    "a parser generator is a tool that reads a specification of a language and generates code which is capable of checking its input text for syntactical correctness and construct an internal representation from it .",
    "this process involves several languages ( see figure  [ languages ] ) : the specification is written in a _ specification language _ and describes the _ parsed language _ , while the generated code ( which recognizes the parsed language ) is written in an _ implementation language _ ( e.g. , java or c ) .",
    "a specification language usually includes a notation for context - free grammars and some means to specify _ semantic actions _ which are the computations translating a program into the internal representation . in this paper",
    "we consider _ on - line _ parser generators such as yacc @xcite , antlr @xcite , coco / r @xcite and javacc @xcite , which are characterized by having the semantic actions defined on the concrete grammar , as opposed to attribute grammar ( ag ) systems such as eli @xcite and jastadd @xcite which define the computations on abstract syntax trees ( asts ) and usually require the complete input to be parsed before the computations are started .",
    "a parser generator translates a grammar specification into a parser and integrates user - defined semantic actions into it .",
    "since the user may make mistakes while writing the actions , this frequently leads to generating code that contains errors which are reported only by the implementation language compiler .",
    "we will now illustrate this problem with an example of a simple language of arithmetic expressions with variables .",
    "the antlr grammar for this language is shown in listing  [ arithexp ] ( no semantic actions are presented at this point ) .    .... //",
    "lexical rules fragment letter : ' a' .. 'z ' | ' a' .. 'z ' | ' _ ' ; fragment digit   : ' 0' .. '9 ' ; var     : letter ( letter | digit ) * ; int     : digit+ ; // syntactic rules expr    : term ( ( ' + ' | ' - ' ) term ) * ; term    : factor ( ' * ' factor ) * ; factor : var | int | ' ( ' expr ' ) ' ; ....    let us consider the case when one uses antlr to develop a parser that checks the syntax and evaluates the expressions in a given environment .",
    "evaluation of an expression is a special case of translation : the expression in essentially translated into a number .",
    "an environment stores values for all variables referenced in the expression .",
    "for example , if the parser is run on the input text `` ` x*(3 + 2 ) ` '' in the environment [ x=4 ] , it accepts the input and returns 20 .",
    "when run on `` ` ( x+*3 ) ` '' , it does not accept ( raises an exception ) , because the input is not syntactically correct .",
    "note that the notation in listing  [ arithexp ] does not describe environments : an environment is passed as a separate argument to the parser ( see the examples below ) .    to give an example of an error which may appear in the generated code ,",
    "let us consider the following set of semantic actions for the rule ` factor ` :    .... factor[environment env ] returns [ int result ]      : var { result = env.getvalue($var.gettext ( ) ) ; }      | int { result = $ int ; }      | ' ( ' e = expr[env ] ' ) ' { result = e ; } ; ....    when we run antlr on a specification containing this rule it will successfully generate code .",
    "the code generated for the second alternative will contain the following lines :    ....      int result = 0 ;      // ...      token int2=null ;      // ...      result = int2 ; ....    the java compiler yields an error message at the last line : a value of type ` token ` can not be assigned to a variable of type ` int ` .",
    "now we have to figure out that the cause of this error is that we forgot to extract the contents of the token by calling the ` gettext ( ) ` method on ` $ int ` in the specification .",
    "let us correct this error :    ....      | int { result = $ int.gettext ( ) ; } ....    we run antlr again and in the generated code the erroneous line changes to the following :    [ source , java ] ----      result = int2.gettext ( ) ; ----    the java compiler complains again at the same line : a ` string ` can not be assigned to an ` int ` variable .",
    "we have to correct the specification again :    ....      | int { result = integer.parseint($int.gettext ( ) ) ; } ....    after generating the code again , we can see that it compiles successfully .",
    "this process took us three complete runs of antlr , each followed by a compilation attempt , and we had to analyze the generated code twice to figure out which part of the specification causes the error .",
    "the development process has a form of the cycle shown in figure  [ cycles ] ( left side ) .",
    "the generated code is usually hard to read and , in case of long specifications , code generation may take up to several seconds .",
    "thus , this cycle may be time - consuming .",
    "the main motivation of the present study is to reduce the development cycle to the one given in figure  [ cycles ] ( right side ) .",
    "it corresponds to the usual way of working with compilers : change - compile - errors - change .",
    "this paper aims at achieving this goal by improving static checking of parser specifications .",
    "a parser generator may be logically divided into two parts ( see figure  [ languages ] ) : a _ front - end _ which reads a specification , performs the static checks and builds an internal representation of a parser , and a _ back - end _ which generates code . to support the shortened development cycle ,",
    "only the front - end may be allowed to report errors to the user .",
    "the back - end must silently produce code which must be error - free as soon as the front - end did not find any errors in the specification .",
    "most generators have front - ends which check only for errors which prevent them from building the internal representation , such as usage of undefined names .",
    "this leads to the problem described above .",
    "in this paper we present an extensible specification language and a front - end infrastructure which detects type incompatibilities in assignments and function calls . in combination with name - screening and import statement generation in the back - end",
    ", this prevents all types of compiler errors for implementation languages like java , c # , c or pascal .",
    "our approach is designed under the requirement of being applicable for many implementation languages , and thus the generic specification language may be extended to support a particular type system .",
    "we present an implementation of such a type system for java and a generic language which allows one to specify simple type systems declaratively .",
    "we report on grammatic@xmath0  a prototype implementation of our approach built on top of antlr .",
    "grammatic@xmath0 specifications are type - checked and transformed into antlr specifications .",
    "the antlr tool - chain can then be used to generate the parser .",
    "the rest of the paper is organized as follows .",
    "section  [ overview ] gives an overview of our specification language illustrating the language design and basic constructs .",
    "extensible type system of grammatic@xmath0 and a demonstration of how the development cycle changes with it is presented in section  [ typesystem ] .",
    "this type system is parameterized by the types of an implementation language and corresponding subtyping rules , and thus it must be _ instantiated _ to be actually used . in section  [ defaultextension ] we present a mechanism for declaratively describing type systems of implementation languages and instantiating grammatic@xmath0 using them .",
    "this mechanism describes the type systems as having a fixed number of types with subtyping rules specified explicitly . to provide a better integration with a particular implementation language",
    ", one can write a custom extension . the extension mechanism and an example extension supporting java",
    "are described in section  [ java ] . as we mentioned",
    "before , the front end provides an internal representation of a parser from which a back - end can generate error - free code .",
    "we show how the latter is done in our prototype in section  [ backend ] .",
    "section  [ relatedwork ] describes related work , and section  [ conclusion ] summarizes our contribution and points out directions for future work .",
    "attribute grammars ( ags ) introduced in @xcite are very convenient for describing translators , but in a general case they require the whole input to be parsed before the translation starts . this is why the most popular parser generators only use some concepts of ags , but not the whole framework .",
    "grammatic@xmath0 specification language corresponds to a restricted version of ags where each nonterminal symbol @xmath1 is associated with a set of attributes , which is divided into    * _ output _ attributes : computed by the productions defining @xmath1 ; * _ input _ attributes : computed by the productions which use @xmath1 .",
    "output attributes of grammatic@xmath0 directly correspond to _ synthesized _",
    "attributes used in ags , and input attributes represent a restricted case of _ inherited _ attributes .",
    "we use the terms `` input '' and `` output '' for attributes because they correspond very closely to inputs and outputs of functions .",
    "one can think of a _",
    "syntactic rule _ defining a nonterminal ( which is a set of all productions for this nonterminal ) as a `` _ _ translation function _ _ '' .",
    "the productions which use the nonterminal _ call _ this function , passing the input attributes to is ( as arguments ) .",
    "the function itself computes the output attributes and _ returns _ them to be used by the caller .",
    "a recursive descent parser implements this analogy in a one - to - one manner : for each nonterminal there is a corresponding function which takes the input attributes as parameters and returns the output attributes .    in principle",
    ", there may be many translation functions corresponding to the same syntactic rule . in grammatic@xmath0 notation ,",
    "one specifies these functions right after the rule .",
    "a translation function is described by its _ signature _ ( a name and lists of input and output attributes ) and a body ( this will be explained later ) , for example :    ....      n : ... ; //",
    "syntactic rule          translaten(int in ) -- > ( int out ) { //",
    "// body          } ....    note that all attributes are declared with their types .",
    "being a recursive descent parser generator , antlr also uses a function analogy for translation , although it does not support many translation functions for the same rule . in antlr notation",
    "the example given above looks as follows :    ....      n[int in ] returns [ int out ] : ... ; ....    unlike general ags ( and like antlr ) , grammatic@xmath0 prescribes the order of computations using translation schemes @xcite . in other words ,",
    "attributes are computed by _ semantic actions _ positioned somewhere inside productions . the most popular notation for translation schemes",
    "( it is used by the majority if not all parser generators , including antlr ) is the following :    @xmath2    this notation is rather intuitive but in practice ( e.g. , in large antlr grammars ) it makes the specifications unreadable because of mixing context - free productions and action code . to avoid this problem , in grammatic@xmath0 notation we separate the grammar productions from the actions by using a technique similar to aspectj s _ advice _",
    "the above mentioned production in our notation can be written as follows :    ....      a : b c ;          translatea ( ... ) -- > ( ... ) {              ...              after b : action ;              ...          } ....    the action is specified in the body of a translation function .",
    "the * after * keyword denotes that the action must be executed after the nonterminal @xmath3 is matched . another option to specify the same behaviour is to use the * before",
    "* keyword as follows :    ....      before c : action ; ....    the actions to the right of the `` : '' sign can assign values to attributes and call _ external functions _ to perform computations .",
    "external functions must be implemented outside the specification , in grammatic@xmath0 they are represented only by their signatures , for example    ....",
    "add(int x , int y ) -- > ( int sum ) ; ....    a developer must supply the implementation written separately ( in the implementation language ) .",
    "in addition to specifying which actions to execute before or after a certain position , one needs to say which translation function to call for a nonterminal on the right - hand side of the syntactic rule , what arguments to pass to it and where to store the returned values . for this purpose",
    "we use the * at * keyword followed by a name of the nonterminal :    ....      at c : tmp = translatec(a , b ) ; ....    this , written inside a translation function for ` a ` , means that for the occurrence of ` c ` on the right - hand side of the syntactic rule for ` a ` we must call the translation function ` translatec ` , passing arguments ` a ` and ` b ` and writing the returned value to ` tmp ` .    to illustrate some technical details of the grammatic@xmath0 notation",
    ", we will now proceed to the example of arithmetic expressions mentioned in the section  [ introduction ] .",
    "the grammar for arithmetic expression is given in listing  [ arithexp ] .",
    "our translation functions must evaluate an expression in a given environment which contains values for the variables used in the expression . to do this",
    ", we will need the appropriate external functions :    ....      strtoint(string s ) -- > ( int value ) ;      value(environment env , string variable ) -- > ( int value ) ;      zero ( ) -- > ( int zero ) ;      one ( ) -- > ( int one ) ;      neg(int x ) -- > ( int negx ) ;      add(int x , int y ) -- > ( int sum ) ;      mul(int x , int y ) -- > ( int prod ) ; ....    we do not fix an implementation language here : the example described in this section will work for any implementation language in which types can have names , and ` int ` , ` string ` and ` environment ` can be defined with the straightforward meanings .",
    "we are going to specify three translation functions : one for each of the nonterminals ` factor ` , ` term ` and ` expr ` .",
    "each of these functions must have an input attribute for the environment and an output attribute for the result .",
    "the translation function for ` factor ` is shown in listing  [ factortf ] .",
    ".... factor : var | int | ' ( ' expr ' ) ' ;               factor(environment env ) -- > ( int result ) {       after var : result = value(env , var # ) ; // external function       after int : result = strtoint(int # ) ;    // external function      at expr    : result = expr(env ) ;         // translation function    } ....    the actions for ` var ` and ` int ` use the notation `` _ _ name _ _ # '' which denotes a textual value of a token ( this value is of type ` string ` ) .",
    "note that ` value ` and ` strtoint ` which are called _",
    "after _ the tokens , are external functions , while ` expr ` is a translation function called _ at _ the occurrence of the corresponding nonterminal .",
    "one can not do anything but a call to a translation function in * at * position . in some cases",
    "calls to translation functions ( and thus , whole * at*-actions ) may be omitted , but in our example this is not the case : we have to specify what argument to pass to the translation function ` expr ` .",
    "the rule for ` term ` is different from what we have shown by now in the sense that it has two occurrences of the same nonterminal ` factor ` . at both these occurrences we need to call the translation function ` factor ` defined above and pass the environment object to it .",
    "the result will be assigned to a _ local attribute _ ` f ` , which is used inside the translation function as an auxiliary storage .",
    "this attribute ` f ` is declared inside the translation function to have the type ` int ` :    ....      int f ;      at factor : f = factor(env ) ; ....    this action is common for both occurrences of factor , but _ after _ the value is acquired we must treat it differently in each case . to be able to distinguish between different occurrences of the same nonterminal , one can use _ location labels _ available in grammatic@xmath0 . with the use of such labels , the translation function for factor looks as follows :    .... term : $ f1=factor ( ' * ' $ f2=factor ) * ;               term(environment env ) -- > ( int result ) {            int f ; // local attribute declaration          at factor : f = factor(env ) ;       // for both occurrences          after $ f1 : result = f ;               // only for $ f1          after $ f2 : result = mul(result , f ) ; // only for $ f2      } ....    a label may be attached not only to a nonterminal occurrence , but also to any phrase in a production . this feature is rather convenient when defining a translation function for ` expr ` ( see listing  [ exprtf ] ) .",
    "this function also give an example of a _ block _ which groups several statements together ( see the action for ` $ t1 ` ) .",
    ".... expr : $ t1=term ( $ sgn=('+ ' | ' - ' ) term ) * ;               expr(environment env ) -- > ( int result ) {            at      term : t = term(env ) ;          before $ t1   : {              result = zero ( ) ;              sign = one ( ) ;          }          after   term : result = add(result , mul(sign , t ) ) ;          before $ sgn : sign = one ( ) ;          after   ' - '   : sign = neg(sign ) ;    } ....    to motivate again our choice of notation , we provide the same rule in antlr notation ( in listing  [ exprantlr ] ) . as can be seen , it is rather hard to understand the structure of the syntactic rule from it , which is never the case for grammatic@xmath0 .    ....",
    "expr[environment env ] returns [ int result ]       : { result = 0 ; sign = 1 ; }         t = term[env ] { result = t ; }        (          { sign = 1 ; } ( ' + ' | ' - ' { sign = -1 ; } )           t = term[env ] { result + = t * sign ; }        ) *       ;           ....",
    "all functions used in our example have only one output attribute , but in general a function may return a tuple .",
    "for example , a function ` divide(x ,  y ) ` may return two numbers : a quotient and a remainder .",
    "grammatic@xmath0 does not support tuple - typed attributes , and a return value of this function can not be assigned to a single attribute .",
    "instead , grammatic@xmath0 supports attribute tuples .",
    "if one needs to receive a result of the ` divide ` function , it can be done in the following way :    .... int quot ; int rem ; ( quot , rem ) = divide(x , y ) ; ....    this code assigns the first component of a returned tuple to the attribute ` quot ` and the second  to the attribute ` rem ` .      before the first assignment , a value of an attribute is not defined and thus can not be read . to ensure that every attribute is initialized before the first usage , grammatic@xmath0 performs conventional data - flow analysis @xcite . if the analysis finds a read - access which may not be preceded by a corresponding write - access , the front - end reports an error .",
    "this analysis relies on the construction of a control flow graph .",
    "grammatic@xmath0 does not support conditional operators and loops as such , and all the branching and repetition happens according to the structure of grammar rules which is denoted by the common regular operations : concatenation ( sequence ) , alternative ( `` @xmath4 '' ) and iteration ( `` + '' ) .",
    "optional constructs ( `` ? '' and `` * '' ) are viewed as alternatives with an empty option .",
    "a control flow graph is constructed as follows : concatenation corresponds to sequential execution , alternative corresponds to branching and iteration corresponds to a loop .",
    "figure  [ cfg ] shows a control flow graph for the listing  [ exprtf ] ; edges are labeled with corresponding sequences of attribute reads and writes indicated as `` [ r ] '' and `` [ w ] '' respectively .",
    "grammatic@xmath0 checks translation functions for type safety : when a value is assigned to an attribute ( passing as an argument can also be interpreted as an assignment to an input attribute of a function ) , the type of the right - hand side must be a subtype of the type of the left - hand side .",
    "this prevents grammatic@xmath0 from generating code with typing errors such as those we discussed in section  [ introduction ] .    in listing  [ exprtf ] , two attributes , ` env ` and ` result",
    "` , are declared in the signature of the translation function to have types ` environment ` and ` int ` respectively , but the intermediate attribute ` t ` is not declared anywhere .",
    "what type does it have ?",
    "this is an example of _ local type inference _ which makes grammatic@xmath0 feel more like dynamic languages : if some attribute is used but not declared , the type checker assumes that it is a local attribute and tries to figure out an appropriate type for it considering the context in which it is used .    in our example , `",
    "t ` is first assigned the value returned by the ` term ` function , which has an output attribute ` result ` of type ` int ` . we write this as follows : @xmath5 then , it is passed to the ` mul ` function as a value for an input parameter ` y ` of type ` int ` : @xmath6 these two usages facilitate the following reasoning : assuming that there exists a type @xmath7 for ` t ` , such that the whole translation function is typed correctly , from  ( [ teqres ] ) we see that ` int ` must be a subtype of @xmath7 , and from ( [ yeqt ] ) we see that @xmath7 must be a subtype of ` int ` . hence , @xmath7 equals ` int ` , and we have inferred the type for ` t ` successfully .",
    "the type checker in grammatic@xmath0 applies this kind of reasoning for every attribute which is used but not declared . in some cases this procedure does not lead to a definitive conclusion . in these cases the type checker reports an error , which can be reconciled by providing an explicit declaration of the attribute in question .",
    "not only attribute types but also signatures of external functions can be inferred in this manner .",
    "for example , assume the following assignment appears in a specification :    .... a = f(b , c ) ....",
    "if ` f ` is not declared , grammatic@xmath0 assumes that there is an external function ` f ` with one output attribute and two input attributes , and applies the above reasoning to these attributes .",
    "if it succeeds , a complete type for ` f ` is inferred .",
    "we provide a more detailed description of type checking and type inference in grammatic@xmath0 in the next section .",
    "this section describes the extensible type system used in grammatic@xmath0 .",
    "the typing rules presented below are written under the assumption that all the attributes and external functions are declared explicitly .",
    "the purpose of type inference in this case is to reconstruct omitted annotations .",
    "if the reconstruction is not possible , the specification is considered to be inconsistent .",
    "let the implementation language be denoted by @xmath8 .",
    "the types of the implementation language will be denoted @xmath9 and referred to as _",
    "ground types_. let @xmath10 be the ground type which represents character strings .",
    "the types used in grammatic@xmath0 are defined by the following productions : @xmath11 as the names suggest , attributes may only have ground types , tuples are sequences of attributes and have corresponding types , and functions send tuples to tuples .",
    "as we explained above , attribute tuples are used to receive return values of functions having more than one output attribute .",
    "note that tuples can not be nested .",
    "function arguments and individual return attributes can only have ground types : for example , a single argument can not be a tuple .",
    "a _ subtyping relation _ on the set @xmath9 of ground types ( denoted @xmath12 ) represents subtyping rules of the implementation language .",
    "we assume that it is reflexive and transitive .",
    "we will use @xmath13 and @xmath14 interchangeably .",
    "each translation function is type - checked separately .",
    "a type - checking context @xmath15 comprises signatures of all functions available in the specification along with declarations of all input and output attributes of these functions and local attributes of the function being checked . since attributes in different signatures may have same names , each attribute is indexed with the name of the function it belongs to .",
    "for example , a context may contain the following declarations : + @xmath16    figure  [ exptypes ] provides straightforward typing rules for token values , attributes and tuples and a rule for function application which says that a type of an argument must be a subtype of the type of the corresponding formal parameter .",
    "@xmath17    in figure  [ statypes ] , @xmath18 denotes all the statements in which typing rules are respected .",
    "@xmath19    the only nontrivial constraint is expressed by the rule assignment : the type of the right - hand side must be a subtype of the type of the left - hand side . as the left - hand side may appear to be a tuple ( as well as the right - hand side in case of function application ) , we use an extended subtyping relation @xmath20 which is the minimal relation such that @xmath21 and @xmath22      the previous subsection formalizes the type system of grammatic@xmath0 under the assumption that every attribute and every function which is used is also declared explicitly . as we illustrated above",
    ", such declarations may be redundant in some cases , and grammatic@xmath0 ( after many programming languages ) provides a local type inference mechanism to enable omission of some of them .",
    "type inference works separately in each translation function .",
    "it represents all the statements as sequences of attribute assignments ( function arguments are treated as `` assigned '' to input attributes ) assigning unknown types to undeclared attributes . to reconstruct the declarations we use a modification of a conventional algorithm ( see , for example , @xcite ) which creates constraints ( subtyping inequalities ) for unknown types and finds ground types which satisfy these constraints ( see section  [ typeinf ] for a simplistic example ) .",
    "our modifications to the classical algorithm are not significant enough to formally present the entire type inference process .",
    "instead , we will only illustrate the behaviour of our algorithm in case of an ambiguity .",
    "let us assume that the implementation language has the following types : @xmath23 , where @xmath24 .",
    "consider the following function :    .... f(integer x ) -- > ( object result ) {      before ... : t = x ;      // ...      after   ... : result = t ; } ....    the local attribute ` t ` is not declared .",
    "let @xmath7 be the unknown type for ` t ` .",
    "the type inference algorithm will construct the following set of constraints : @xmath25 these constraints have at least two solutions : both @xmath26 and @xmath27 might be assigned as a type for ` t ` .",
    "the very existence of a solution already means that the specification does not have type inconsistencies , but the back - end will need the exact type information to generate code , so we have to decide which type to choose .",
    "this may be important when inferring the types for external functions since they will be visible to the user ( we provide details on the back - end below ) .    in such cases",
    "grammatic@xmath0 prefers lower bounds to upper bounds , which means that ` t ` will be assigned the type @xmath27 .",
    "the general procedure is the following : find a minimal solution satisfying all lower bounds , if it also satisfies all upper bounds , choose it as a final solution .",
    "if there are several ( incomparable ) minimal solutions for the lower bounds which satisfies all the upper bounds , the algorithm can not decide between them and reports an error .",
    "if no solution for lower bounds satisfies all the upper bounds , the specification is inconsistent , and we again report an error .",
    "if no lower bounds are present , we choose a _ maximal _ solution for the upper bounds .",
    "this procedure can be summarized as follows : we look for the type which is as close to the constraining ones as possible , preferring more concrete ( smaller ) types .",
    "this approach appears to be rather intuitive : it is very unlikely to infer a type which the developer does not expect .",
    "if no constraints are present at all , this means that all the attributes connected to the one at hand are not declared . in this case",
    "we ask if the ground type system has a top type @xmath28 ( such as ` java.lang.object ` ) , and if it has one , we choose it , otherwise we report an error .",
    "now we are ready to explain how the example from section  [ introduction ] is handled by grammatic@xmath0 .",
    "in that example we had a rule for ` factor ` analogous to the one in listing  [ factortf ] , in which there was an error : a name of the ` int ` token was used instead of its textual value ( ` int # ` ) .",
    "here is the modification of listing  [ factortf ] containing the same defect :    .... factor : var | int | ' ( ' expr ' ) ' ;                factor(environment env ) -- > ( int result ) {           after var : result = evaluate(env , var # ) ;            after int : result = int ;          at expr    : result = expr(env ) ;                 } ....    unlike antlr , grammatic@xmath0 reports the following error when we try to generate code : _ `` the local attribute int might have not been initialized''_. what happened ? ` int ` appears on the right - hand side of an assignment .",
    "thus , grammatic@xmath0 expects it to be an attribute .",
    "since such an attribute is not declared , the type checker treats it as a local attribute and infers a type for it : ` int ` . for the time being",
    ", no error has been found .",
    "after the type checking , the definitive assignment analysis is performed , and it finds that the local attribute ` int ` is read but never assigned .",
    "this leads to the error which is reported .    without generating the code and running a compiler ,",
    "we have got an error message which points precisely to the place in the specification where the defect is situated . following the logic of the example of section  [ introduction ]",
    ", we correct the specification :    ....      after int : result = int # ; ....    now the type checker complains : _",
    "`` incompatible types : string and int''_. again , we have got a precise error message without generating code and running a compiler .",
    "we correct the specification again :    ....      after int : result = strtoint(int # ) ; ....    this time all checks are passed successfully , the code is generated and will be compiled with no errors .",
    "as can be seen , the development cycle now takes the form shown in figure  [ cycles ] ( right side ) , which was our main goal .",
    "now we proceed to a description of the tools grammatic@xmath0 provides to support many implementation languages .",
    "the type checking procedure described above is parameterized by a set of ground types @xmath9 with distinguished types @xmath29 and @xmath28 , and a subtyping relation  @xmath12 . to incorporate a type system of the implementation language into grammatic@xmath0",
    ", one needs to substitute concrete implementations for these parameters . in general , this is done by adding front - end _ extensions _ ( plug - ins written in java ) , which provide support for particular implementation languages . developing such extensions",
    "requires some effort and may be undesirable in certain cases . for this reason grammatic@xmath0 provides a default extension which supports declarative descriptions of type systems of implementation languages .",
    "a type system description specifies a set of named types , a subtyping relation on these types , an optional top type and a string type .",
    "for example , the type system used above may be described as follows :    ....      typesystem simple (           _ ,",
    "// name of the top type ( nothing in this case )          string          // name of the string type      ) {          // type declarations          type int ;          type environment ;          type object ;            //",
    "subtyping rules          environment < : object ;          string       < : object ;      } ....",
    "this denotes a type system named ` simple ` , with no top type ( underscore is used to denote this , if there were a top type , its name would have been written ) and with the string type called ` string ` .",
    "it declares three more types : ` int ` , ` environment ` and ` object ` .",
    "the first two were used above , but the third one is added only for demonstration purposes , namely to introduce subtyping rules which state that ` environment ` and ` string ` are subtypes of ` object ` .",
    "note that since ` object ` is not the top type , ` int ` is not its subtype . in a general case , subtyping rules stated in a type system description form an incomplete form of a subtyping relation .",
    "a final subtyping relation is obtained as a reflexive - transitive closure of it .",
    "type system descriptions such as the one shown above are sufficient to check grammatic@xmath0 specifications for type safety and infer types , but they are not sufficient to generate code unless the implementation language has types with exactly the same names as used in a description . the latter is unlikely because normally types are defined inside some kind of namespaces , such as java packages , and can not be referred to by a simple name without import statements .",
    "thus , we have to provide another description which _ instantiates _ the types with their actual form in the implementation language .",
    "we call this a _ language description _ :    ....      language java for simple {          int = ' int ' ;          environment = ' java.util.map<string , integer > ' ;          string = ' string ' ;          object = ' object ' ;      } ....    the example shows a language description named ` java ` which instantiates the type system ` simple ` and says that ` int ` is implemented as ` int ` in java , and ` environment ` is implemented as a map from strings to integer objects",
    ". we might not specify the instantiations for ` string ` and ` object ` since they may be referred to just by their names .",
    "now a back - end can use the strings we have provided in generated code , and it will work correctly ( if the back - end generates java and not c or some other language ) .",
    "a back - end may need some extra information such as a package to put the generated code in and a name to give to the generated parser .",
    "these options are provided in a _ back - end profile _",
    ", such as    ....      backend ' org.grammatic.pg.backends.antlrjavabackend ' for java {          package = ' org.example.arithexp ' ;          parsername = ' expressionevaluator ' ;      } ....    this is a profile for a back - end implemented by a java class ` antlrjavabackend ` which applies for the language description ` java ` defined above . in the profile",
    "one simply writes name - value pairs which are processed by the back - end as options .",
    "to summarize , the declarative descriptions of type systems in grammatic@xmath0 are organized into three levels ( see figure  [ typesystem ] ) .",
    "this makes grammatic@xmath0 rather flexible when it comes to _ multi - targeted _ parser specifications , form which parsers in many implementation languages must be generated .",
    "in such a case one describes an abstract _ type system _ as shown above and provides many _ language descriptions _ for it , so that each _ back - end profile _ may use its own language . in some situations it is also convenient to have several back - end profiles for the same language , for example , when one needs to compare performance of different implementations or while migrating from one back - end to another .",
    "to provide tighter integration with a particular implementation language one can use a language - specific extension of the grammatic@xmath0 front - end instead of the default one described in the previous section . technically , a front - end extension consists of a ground type syntax specification and implementations of java interfaces which capture the semantical aspects of ground types : a subtyping relation , a set of predefined types and two distinguished types .",
    "let us describe these parts in more details .",
    "examples below present an extension supporting java types ( including generics ) , which we developed in our prototype .      the core specification of the grammatic@xmath0 notation ( see listing  [ short_notation ] ) has extension points : it uses but does not define two nonterminal symbols , ` type ` and ` declaration ` ( written in bold font in the listing ) .",
    "the language generated by ` type ` is a syntactical form of  @xmath9 .",
    "since the specification parser in grammatic@xmath0 is itself implemented using grammatic@xmath0 , ` type ` must be defined by grammar rules and translation functions .",
    "this is done in a separate specification file which is virtually `` appended '' to the generic specification when the whole system is built .",
    ".... specification       : declarations ?",
    "( externalfunctionsignature | ( grammarrule translationfunction * ) ) * ; attributedeclaration       : type name ; ....    a syntactic function for ` type ` must return an instance of ` java.lang.object ` ( grammatic@xmath0 is implemented in java ) , in other words , a type may be represented by an arbitrary object .",
    "the context - free rules for types in java  5 are given in listing  [ java_types ] .",
    "for the sake of brevity we do not include the corresponding translation functions .",
    ".... type      : identifier typearguments ? ( ' . '",
    "identifier typearguments ? ) * ( ' [ ' ' ] ' ) *      : basictype ; typearguments      : ' < ' typeargument ( ' , ' typeargument ) * ' > ' ; typeargument      : type      : ' ? ' ( ( ' extends ' | ' super ' ) type ) ? ; basictype      : ' byte ' | ' short ' | ' char ' | ' int ' | ' long ' | ' float ' | ' double '       | ' boolean ' ; ....    with the rules from listing  [ java_types ] used for defining the syntax of ground types , a signature of the ` evaluate ` function may be the following :    .... evaluate      ( java.utli.map<java.lang.string , java.lang.integer > environment )       -- >       ( java.lang.integer result ) ; ....    as can be seen , fully qualified class and interface names and generics can be used as types for attributes",
    ".      the names in the example above are quite long which is inconvenient . in java",
    "this problem is solved with the help of imports .",
    "grammatic@xmath0 does not know about the structure of java types and can not support imports itself .",
    "instead , it provides a generic mechanism for adding arbitrary _ declarations _ which are specific for an implementation language .",
    "the syntax for declarations is defined by the ` declarations ` nonterminal . a translation function for it does not take or accept any attributes",
    ": it is supposed to collect the information about the declarations and store it internally to be available when somebody else ( e.g. , the translation function for ` types ` ) needs it .    to support imports",
    "we can define ` declarations ` as follows :    .... declarations      : importdeclaration * ; importdeclaration      : ' import ' identifier   ( ' . ' indentifier ) * ( ' . ' ' * ' ) ? ; ....    the corresponding translation functions will collect the information about imported types and provide it to the translation function for ` types ` .",
    "now we can use java imports in grammatic@xmath0 specifications , for example    [ source , java ] ---- import java.util.map ;    evaluate(map < string , integer > environment ) -- > ( integer result ) ; ----    the complete syntax of declarations which we use for java is given in listing  [ java_decl ] .",
    "in addition to imports , it supports _ options _ which are used by the back - end and specify auxiliary information ( this corresponds to back - end profiles of the default extension ) .",
    ".... declarations      : options ?",
    "importdeclaration * ; options      : ' # javaoptions ' ' { ' option+ ' } ' ; option      : name ' = ' string ' ; ' ; importdeclaration      : ' import ' identifier   ( ' . ' indentifier ) * ( ' . ' ' * ' ) ? ; ....      .... public interface isubtypingrelation < t > {      boolean issubtypeof(t type , t supertype ) ; }    public interface itypesystem <",
    "t > {      isubtypingrelation < t > getsubtypingrelation ( ) ;      set < t > getpredefinedtypes ( ) ;      t gettoptype ( ) ;      t getstringtype ( ) ; } ....    semantics of ground types is provided by java classes that must implement the interfaces shown in listing  [ java_intf ] .    a subtyping relation is represented by a class which implements ` isubtypingrelation < t > ` interface , where the type parameter must be substituted by a class which is used by the extension to internally represent types , and the ` issubtypeof ` method returns true if and only if the following condition holds : @xmath30 for example , our implementation represents java types using the ` egenerictype ` abstraction from eclipse modeling framework @xcite . in this case the subtyping relation class is declared as follows :    [ source , java ] ---- public class javasubtypingrelation                implements isubtypingrelation < egenerictype > ----    the other interface , ` itypesystem ` has methods which return a subtyping relation represented as discussed above , a set of predefined types , a top type ( or ` null ` if no top type exists in the ground type system ) and a type for character strings .",
    "a back - end must use the ` tostring ( ) ` method of type objects to obtain their textual representation .",
    "by now we have presented an extensible front - end which can detect typing errors in specifications . here",
    "we will explain why detecting these errors is sufficient for the back - end to be able to generate error - free code .",
    "the techniques described below apply to virtually any language , and we believe that whenever the front - end can be extended to support a particular implementation language , a corresponding back - end can be developed .",
    "generating error - free code from a grammar with no semantic actions is relatively easy .",
    "the problems arise when we need to incorporate hand - written code fragments into the generated program .",
    "grammatic@xmath0 front - end guarantees that the actions do not contain errors themselves and thus the errors may be caused only by conflicts between hand - written and generated code .",
    "for example , semantic actions may introduce names which are already used in the generated code or require particular imports .",
    "the peculiar property of this sort of errors is that the back - end can always detect and prevent them while reading the internal representation of the specification .",
    "this is because the back - end has total control over the generated code .",
    "for example , to avoid name clashes , it is sufficient to rename variables , which the back - end can do .    in the case",
    "when the back - end generates antlr specifications with semantic actions in java , we have to prevent the following types of errors :    * a name used in the specification is a java or antlr keyword . *",
    "a name is used internally by antlr . *",
    "a type requires some classes or interfaces to be imported .",
    "other types of errors are either prevented by the analysis performed by the front - end ( e.g. , usage of uninitialized variables ) or do not appear because of the particular structure of the code generated by antlr .",
    "naming problems are easy to prevent since it is sufficient to use a fresh name which can be obtained by adding numbers to original names ( e.g. , ` result1 ` ) .",
    "the code remains readable enough and no errors appear .",
    "the import problem is also fixed straightforwardly : we can always import all the classes ever mentioned in the specification or use fully qualified names if some short names clash .",
    "correctness of external function signatures is guaranteed by the following design of generated parsers . along with an antlr specification",
    ", grammatic@xmath0 generates a java interface which has a method for each external function used in the specification .",
    "this interface must be supported in order to implement the functions , which makes java compiler to check if the functions are declared properly in the implementation .",
    "this interface being read and implemented by a human makes us select the most appropriate types during the type inference process ( see section  [ typeinference ] ) .    to summarize ,",
    "we have demonstrated how a back - end can prevent all the errors which are imposed by the structure of the generated code ( and thus not present in the specification , and not checked by a front - end ) .",
    "these techniques vary over implementation languages , but the essence stays unchanged : we can always generate code in such a way that these errors do not appear .",
    "thus , we have reached our goal : as soon as a specification is successfully type - checked , the generated code is error - free .",
    "we are not aware of any parser generators which support multiple implementation languages and have type checking in their front - ends .",
    "the most popular tools supporting multiple implementation languages are antlr @xcite and coco / r @xcite , and they do not perform any type checking in the front - ends . in most cases these tools can not generate code in different specification languages from the same specification ( the specifications , thus , are not _ multi - targeted _ in these systems ) , because the embedded actions are written in a particular implementation language and will not compile in another one . in sablecc",
    "@xcite specifications are multi - targeted , which is achieved by having no semantic actions : a developer has to manually process parse trees using visitors . in contrast , grammatic@xmath0 supports both multi - targeted specifications ( using type system descriptions ) and semantic actions .",
    "the following attribute grammar systems are capable of reducing the development cycle to the one shown in figure  [ cycles ] ( right side ) : eli @xcite automatically tracks compiler errors back to the specification .",
    "this approach is tied up not only to a specific implementation language ( eli uses c ) , but also to a specific implementation of its compiler , since the format of error messages usually varies from one compiler to another .",
    "the team behind jastadd @xcite system plans to integrate their own implementation of a java compiler into it , to check semantic actions .",
    "this approach is also tied up to a specific implementation language .",
    "none of these systems provide appropriate means by which they could be extended for other implementation languages .",
    "grammatic@xmath0 allows for this via front - end extensions and separated back ends .",
    "this paper addresses the problem of type checking in front - ends of parser generators supporting multiple implementation languages .",
    "the main goal is to prevent typing errors in the generated code to avoid the need of manually tracing such errors back to their causes in the specification .",
    "we have demonstrated that type checking of the specifications , which we implemented in a prototype tool grammatic@xmath0 , helps to reduce the development cycle compared to the one imposed by the tools currently available ( see figure  [ cycles ] ) .",
    "our approach is designed to be extensible for use with multiple implementation languages .",
    "the principle contributions of this paper are the following :    * a grammatic@xmath0 specification language supporting * * semantic actions , but having no problem of tangling between grammar rules and action code ; * * extensions to support type systems of implementation languages . * a type checking procedure for this language , supporting local type inference , compatible with the extensions . * a generic extension for declarative definitions of abstract type systems , their syntactical realizations for particular language and configuration profiles for different back - ends , which in complex enable multi - targeted specifications . *",
    "another extension providing tight integration with java .",
    "we have also reported on a prototype back - end for generating antlr / java , which , we believe , never produces erroneous code from successfully type - checked specifications .    one possible direction to continue this work is to investigate a possibility of declaratively specifying back - ends for particular implementation languages to obtain a complete generator from declarative specifications .",
    "another direction will be to integrate grammar inspections ( such as heuristic ambiguity tests ) into the static checking procedure .",
    "this work was partly done while the author was a visiting phd student at university of tartu , under a scholarship from european regional development funds through archimedes foundation .",
    "received his masters degree in computer science from st .",
    "petersburg state university of it , mechanics and optics in 2007 .",
    "he is currently a ph.d .",
    "student at the mathematics department of the same university and a visiting pd.d student at the institute of computer science of university of tartu .",
    "his research interests include the problems of declarative language descriptions , type systems and domain - specific languages ."
  ],
  "abstract_text": [
    "<S> _ parser generators _ generate translators from language specifications . in many cases , </S>",
    "<S> such specifications contain _ semantic actions _ written in the same language as the generated code . since these actions are subject to little static checking , they are usually a source of errors which are discovered only when generated code is compiled .    in this paper </S>",
    "<S> we propose a parser generator front - end which statically checks semantic actions for typing errors and prevents such errors from appearing in generated code . </S>",
    "<S> the type checking procedure is extensible to support many implementation languages . </S>",
    "<S> an extension for java is presented along with an extension for declarative type system descriptions .    </S>",
    "<S> parser generator , type checking , type system , generated code , errors . </S>"
  ]
}