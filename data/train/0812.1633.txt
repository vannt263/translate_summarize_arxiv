{
  "article_text": [
    "in our implementation temperatures are exchanged rather than coordinates .",
    "this allows to minimize the amount of data that has to be communicated , at the price of a slightly more complex analysis of the resulting trajectories .",
    "our asynchronous algorithm consists of the iteration of the following steps :    * each node sends ( asynchronously ) its temperature to the master node , then starts to integrate molecular dynamics .",
    "* when @xmath0 steps are elapsed since the last exchange attempt , the master node collects the temperatures of all the other nodes , sorts them , and establishes the exchange pattern ( i.e.  which pairs of nodes should attempt the exchange ) .",
    "then , it sends ( asynchronously ) a message to each node ( including itself ) containing the rank of the partner node .",
    "* at every step , each node checks if a message arrived from the master . if the answer is negative , computation is continued .",
    "otherwise , a message is sent ( asynchronously ) to the partner node , containing the actual temperature , potential energy and an uniformly distributed random number .",
    "then , the node waits for the corresponding message from the parter node .",
    "once both temperatures and energies are available , the random number generated by one of the two nodes ( arbitrarily fixed to be that with the lowest rank ) is used to establish if the exchange is successful using the standard metropolis rule  @xcite . in case of positive answer , the temperature and velocities are properly scaled .    as a further improvement ,",
    "the rank of the master node is changed at each exchange , so that the master overhead ( sorting replicas and sending / receiving many messages ) is distributed over the full set of nodes .    only two mpi calls",
    "need to be done in a blocking way : ( a ) the collection of temperatures done by the master node , since all the temperatures should be known to prepare the exchange pattern ; ( b ) the reception of the triplet of temperature , energy and random number , which is needed to determine whether the temperature has to be changed or not .",
    "all the other calls to the mpi library are asynchronous and allows for overlap of communication and computation .",
    "the scheme can be trivially extended to support non - nearest neighbor exchanges . when compared with the salsa framework  @xcite ,",
    "our scheme is simpler and has the advantage that it is based on a standard mpi library and do not require multi - thread capabilities .    as a reference",
    ", we also implement a synchronous version , where the collection of the temperature is done at every node with the prefixed stride using a mpi_allgather call . here",
    "all the nodes are able to decide the exchange pattern and perform the exchange after the same prefixed number of steps .",
    "we test our implementation using a lennard - jones liquid . this system does not exhibit significant barriers , and parallel tempering is in principles not needed to properly sample the phase space .",
    "however , the diffusion of the replicas in temperature space is similar to what is usually observed for simulation of solvated molecules , so that it can be used as a meaningful test case .",
    "we simulate 4000 particles at density @xmath1 , with cutoff in the interparticle interaction at 2.5 . throughout this section",
    "we use lennard - jones units for distances , energies and time .",
    "a neighbor - list containing pairs up to a distance 3.0 is used , and it is updated when the displacement of at least one particle is larger than half the skin width  @xcite .",
    "the integration time - step is 0.005 , and temperature is controlled using stochastic velocity rescaling  @xcite .",
    "@xmath2 replicas are simulated at exponentially distributed temperatures in the range from @xmath3 to @xmath4 , which gives an exchange acceptance of approximately 30% irrespectively of @xmath2 . in the asynchronous implementation",
    ", exchanges between replicas are attempted when the master node has done @xmath0 steps since the last attempt . since the number of steps performed by the other nodes is not prefixed , the actual average number of steps between attempts @xmath5 is not equal to @xmath0 . on the other hand ,",
    "when the synchronous implementation is used the same number of steps is performed by all the nodes between subsequent attempts , so that @xmath6 .",
    "all the calculations are performed on the bcx cluster at cineca .     in the log - temperature space , as a function of the average number of waiting steps @xmath5 .",
    "( b ) parallel efficiency @xmath7 , as a function of the number of replicas @xmath2 .",
    "both quantities are plotted for the synchronous ( diamonds ) and asynchronous ( circles ) implementations .",
    "see text for details .",
    "[ fig1 ] , scaledwidth=45.0% ]      a very important parameter in replica - exchange simulations is the speed at which each replica diffuses in the temperature space .",
    "this speed is inversely related to the average time required for a replica to cross the full temperature range from the lowest to the highest temperature .",
    "we here calculate the diffusion coefficient of the logarithm of the temperature in the case @xmath8 for different choices of @xmath0 in both the synchronous and asynchronous implementation .",
    "the results are plotted in fig .",
    "[ fig1](a ) as a function of the observed exchange stride @xmath5 . as it is seen , diffusion in both cases is equivalent and only depends on the effective exchange stride .",
    "moreover , as it has been observed in ref .",
    "@xcite , the optimal performance is obtained by using an exchange stride which is as small as possible .",
    "we then consider the overhead due to the exchanges as the number of replicas @xmath2 grows . to this aim",
    "we fix @xmath9 for the synchronous implementation and @xmath10 for the asynchronous implementation . for the latter",
    ", this choice gives a practical waiting time of @xmath11 , so that the two algorithms are comparable .",
    "we then define the parallel efficiency @xmath7 as the ratio between the total number of steps performed by all the replicas in a prefixed wall - clock time and the same number as obtained during a simulation without exchanges . in practice",
    ", this number should be equal to 1 if there was no computational overhead , and decreases towards zero as the overhead increases .",
    "in figure  [ fig1](b ) we plot the efficiency @xmath7 as a function of @xmath2 .",
    "it is clearly seen that the synchronous implementation is much less efficient than the asynchronous one , and that it gets slower and slower as @xmath2 increases . on the other hand ,",
    "the efficiency of the asynchronous implementation is very close to 1 even when more than a hundred replicas are used .",
    "we have shown an asynchronous implementation of replica exchange molecular dynamics , where the exchange attempts are driven by external commands sent by one of the replicas .",
    "this implementation is based on the mpi library .",
    "its performance is excellent and allows for a significant saving of computational effort in simulations with hundreds of replicas .",
    "the code is available on request ."
  ],
  "abstract_text": [
    "<S> we discuss the possibility of implementing asynchronous replica - exchange ( or parallel tempering ) molecular dynamics . in our scheme , </S>",
    "<S> the exchange attempts are driven by asynchronous messages sent by one of the computing nodes , so that different replicas are allowed to perform a different number of time - steps between subsequent attempts . </S>",
    "<S> the implementation is simple and based on the message - passing interface ( mpi ) . </S>",
    "<S> we illustrate the advantages of our scheme with respect to the standard synchronous algorithm and we benchmark it for a model lennard - jones liquid on an ibm - ls21 blade center cluster .    </S>",
    "<S> parallel tempering is a popular method used to enhance sampling in monte carlo or molecular dynamics simulations  @xcite , with applications ranging from molecular biology to statistical physics . in parallel tempering simulations , many replicas of the system are simulated at different temperatures and their temperatures are exchanged in a monte carlo fashion . </S>",
    "<S> the algorithm is very flexible , and can be extended to simulation parameters other than the temperature ( see e.g.  refs .  </S>",
    "<S> @xcite ) . in this </S>",
    "<S> generalized form the method is usually referred to as _ </S>",
    "<S> replica exchange_. furthermore , parallel tempering ( or replica exchange ) can be easily combined with other enhanced - sampling methods  @xcite .    </S>",
    "<S> a very important feature of replica - exchange simulations is that they allow exploiting large parallel machines : the standard implementation is done assigning a different computing node to each replica , so that inter - process communications are only needed when attempting an exchange move , which is typically done with a prefixed stride . </S>",
    "<S> moreover , parallel tempering can be coded in such a way that temperatures are exchanged instead of coordinates . in this case , the amount of data that are transmitted between computing nodes is negligible , resulting in a theoretically perfect scalability .    </S>",
    "<S> however , practical problems arise when the number of replicas grows . </S>",
    "<S> in fact , for hundreds of computing nodes , even the overhead of synchronization can be large , especially when using short strides between subsequent attempts as suggested e.g.  in ref .  </S>",
    "<S> @xcite . </S>",
    "<S> furthermore , there is no warranty that the different nodes will take the same time to perform the same number of steps . as an example </S>",
    "<S> , the frequency of updates of the neighbor list depends on the diffusion coefficient  @xcite , which in turns depends on the temperature , so that high temperature simulations are expected to be slower . </S>",
    "<S> the situation is even worse when heterogeneous machines are used .    </S>",
    "<S> a possible solution for these problems is the adoption of serial methods  @xcite . in this paper </S>",
    "<S> we will discuss a different approach , namely the implementation of replica exchange in an asynchronous manner . </S>",
    "<S> the present implementation is simple and based on the mpi library  @xcite . </S>",
    "<S> it is designed as a master - slave scheme , where a node is asynchronously driving the exchanges for the other replicas . to the best of our knowledge , the only other attempt to implement asynchronous parallel tempering is the salsa framework introduced in refs .  </S>",
    "<S> @xcite . </S>"
  ]
}