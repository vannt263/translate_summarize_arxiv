{
  "article_text": [
    "in contemporary communication networks , the nodes perform only routing , i.e. , they copy the data on incoming links to the outgoing links . in order to transmit messages generated simultaneously from multiple sources to multiple sinks",
    "the network may need to be used multiple times .",
    "this limits the throughput of the network and increases the time delay too .",
    "network coding is known to circumvent these problems @xcite . in network coding intermediate nodes in a network",
    "are permitted to perform coding operations , i.e. , encode data received on the incoming links and then transmit it on the outgoing links ( each outgoing link can get differently encoded data ) , the throughput of the network increases .",
    "thus , network coding subsumes routing .",
    "for example , consider the butterfly network @xcite of fig .",
    "[ b_fly ] wherein each link can carry one bit per link use , source node @xmath0 generates bits @xmath1 and @xmath2 , and both sink nodes @xmath3 and @xmath4 demand both source bits . with routing only ,",
    "two uses of link @xmath5 are required while with network coding only one .",
    "this is an example of single - source multi - sink linear multicast network coding , wherein there is a single source ( @xmath0 ) , generating a finite number of messages , ( @xmath6 ) , and multiple sinks , each demanding all the source messages and the encoding operations at all nodes are linear . in general , there may be several source nodes , each generating a different number of source messages , and several sink nodes , each demanding only a subset , and not necessarily all , of the source messages .",
    "decoding at sink nodes with such general demands is studied in this paper .",
    "we represent a network by a finite directed acyclic graph @xmath7 , where @xmath8 is the set of vertices or nodes and @xmath9 is the set of directed links or edges between nodes .",
    "all links are assumed to be error - free .",
    "let @xmath10 denote a @xmath11-ary finite field .",
    "the set @xmath12 is denoted by @xmath13 $ ] .",
    "the network has @xmath14 sources , @xmath15 $ ] , and @xmath16 sinks , @xmath17 $ ] .",
    "the source @xmath18 generates @xmath19 messages for all @xmath20 $ ] .",
    "let @xmath21 be the total number of source messages .",
    "the @xmath22-tuple of source messages is denoted by @xmath23}=(x_1,x_2,\\ldots , x_\\omega)$ ] , where @xmath24 for all @xmath25 $ ] . by @xmath26",
    "we denote the column vector of the source messages .",
    "the demand of the @xmath27 sink node is denoted by @xmath28 $ ] .",
    "given a set @xmath29 $ ] , let @xmath30 , i.e. , @xmath23}$ ] _ restricted _ to @xmath31 .",
    "for disjoint subsets @xmath31 and @xmath14 of @xmath32 $ ] , we do not differentiate between @xmath33 and @xmath34 . for a multi - variable binary - valued function @xmath35 , the subset of @xmath36 whose elements are mapped to @xmath37 by @xmath35",
    "is called its support and is denoted by @xmath38}))$ ] and @xmath39}))$ ] denotes the @xmath40-tuples in the support restricted to @xmath31 .",
    "a source message is denoted by edges without any originating node and terminating at a source node .",
    "data on a link @xmath41 is denoted by @xmath42 .",
    "a network code is a set of coding operations to be performed at each node such that the requisite source messages can be faithfully reproduced at the sink nodes .",
    "it can be specified using either local or global description @xcite .",
    "the former specifies the data on a particular outgoing edge as a function of data on the incoming edges while the latter specifies the data on a particular outgoing edge as a function of source messages . throughout the paper we use global description for our purposes .",
    "[ global description of a network code @xcite ] an @xmath22-dimensional network code on an acyclic network over a field @xmath10 consists of @xmath43 global encoding maps @xmath44 for all @xmath45 , i.e. , @xmath46 .",
    "let @xmath47 , be the incoming edges at the source , then @xmath48 .",
    "when the intermediate nodes perform only linear encoding operations , the resulting network code is said to be a linear network code ( lnc ) .",
    "[ global description of an lnc @xcite ] an @xmath22-dimensional lnc on an acyclic network over a field @xmath10 consists of @xmath43 number of @xmath49 global encoding vectors @xmath50 for all @xmath45 such that @xmath51 .",
    "the global encoding vectors for the incoming edges at the source are standard basis vectors for the vector space @xmath52 .",
    "the global encoding vectors of the lnc for butterfly network is given in fig .",
    "[ b_fly](b ) .",
    "hereafter we assume that the network is feasible , i.e. , demands of all sink nodes can be met using network coding , and the global description of a network code ( linear or nonlinear ) is available at the sink nodes .",
    "if a sink node demands @xmath53 ( @xmath54 @xmath22 ) source messages , it will have at least @xmath53 incoming edges .",
    "the decoding problem is to reproduce the desired source messages from the coded data received at the incoming edges .",
    "thus , decoding amounts to solving a set of at least @xmath53 simultaneous equations ( linear or nonlinear ) in @xmath22 unknowns for a specified set of @xmath53 unknowns .",
    "hence , the global description of a network code is more useful for decoding .",
    "while decoding of nonlinear network codes has not been studied , the common technique used for decoding an lnc for multicast networks is to perform gaussian elimination @xcite , which requires @xmath55 operations , followed by backward substitution , which requires @xmath56 operations @xcite .",
    "this is not recommendable when the number of equations ( incoming coded messages ) and/or variables ( source messages ) is very large . in such cases ,",
    "iterative methods are used .",
    "convergence and initial guess are some issues that arise while using iterative methods @xcite .",
    "we propose to use the sum - product ( sp ) algorithm to perform iterative decoding at the sinks . a similar scheme for decoding multicast network codes using factor graphs @xcite was studied in @xcite in which the authors considered the case of lncs .",
    "the problems associated with the proposed decoding scheme in @xcite are :    * to construct the factor graph , full knowledge of network topology is assumed at the sinks which is impractical if the network topology changes . for a particular sink node ( say @xmath57 ) , the factor graph constructed will have @xmath58 variable nodes and @xmath59 factor nodes , where @xmath60 is the set of incoming edges at node @xmath57 . *",
    "complete knowledge of local encoding matrix @xcite of each node is assumed at the sinks which again is impractical since local encoding matrix for different nodes will have different dimensions and hence variable number of overhead bits will be required to communicate to downstream nodes which will incur huge overhead .",
    "we also point out that the motivating examples , _ viz .",
    "_ , examples 1 and 4 , given in @xcite for which the proposed decoding method claims to exploit the network topology admits a simple routing solution and no network coding is required to achieve maximum throughput . solving a system of linear equations in boolean variables",
    "is also studied in ( * ? ? ?",
    "18 ) .",
    "algorithm * + * single - vertex * & @xmath61 & @xmath62 + * all - vertex * & @xmath63 & @xmath64 + * single - vertex with traceback * & not applicable & @xmath65 +    [ cols= \" < \" , ]     total number of operations ( ands and ors ) required with traceback is @xmath66 , which is @xmath67 operations , and that without traceback are @xmath68 , which is @xmath69 operations .",
    "thus , running single - vertex sp algorithm followed by traceback step affords computational advantage over the multiple - vertex version.@xmath70",
    "we will now determine the number of semiring operations required to compute the desired marginal functions in an mpf problem using the sp algorithm and the desired supports in an arg - mpf problem using the arg - sp algorithm with and without traceback in the boolean semiring .    in this section , by addition and multiplication we mean the boolean or and and operations .",
    "by remark  [ rem_supt_or ] , @xmath71 is considered same as addition .",
    "let @xmath72 be an acyclic factor graph with variable nodes @xmath73 and factor node @xmath74 .",
    "the local domain of a node @xmath75 is denoted by @xmath76 , the cardinality of its configuration space @xmath77 by @xmath78 , and its degree by @xmath79 . for an egde @xmath80 between nodes @xmath81 and @xmath82 , @xmath83 and @xmath84 . for every node @xmath85 ,",
    "define @xmath86 if @xmath87 and @xmath88 otherwise .",
    "the message passed from a variable node @xmath89 to a factor node @xmath90 as given in is @xmath91 in the above equation , for each of the @xmath92 values of @xmath93 , product of @xmath94 messages is required which requires @xmath95 multiplications . for each of the @xmath96 values of @xmath97 , @xmath98 additions and @xmath99 multiplications",
    "are required .",
    "thus , the total number of operations required are    @xmath100 additions and @xmath101 multiplications .",
    "the messages passed from a factor node @xmath90 to a variable node @xmath89 as given in is @xmath102 this involves product of a local functions with @xmath103 messages for each of the @xmath104 values of @xmath105 .",
    "the total number of operations required for this case is    @xmath106 additions and @xmath107 multiplications .",
    "the messages are passed by all nodes except the root node . at the root node @xmath108 ,",
    "the marginal function is the product of @xmath109 messages , requiring @xmath110 multiplications , if it is a variable node and the product of @xmath109 messages with the local function , requiring @xmath111 multiplications , if it is a factor node . in other words ,",
    "computation of marginal function at @xmath108 requires @xmath112 multiplications .",
    "thus , the total number of additions and multiplications required in the single - vertex sp algorithm is @xmath113 and @xmath114 the grand total of the number of additions and multiplications is @xmath115 in the arg - sp algorithm , support of marginal at @xmath108 is computed which requires @xmath116 additions ( by remark  [ rem_supt_ops ] ) so that the grand total of operations in this case is @xmath117      in this case , first the single - vertex arg - sp algorithm with @xmath108 as the root is executed on the factor graph",
    ". then the local domain @xmath76 of a neighbor @xmath75 of @xmath108 is partitioned into sets @xmath118 and @xmath119 .",
    "the value @xmath120 is already known from decoding at @xmath108 , and @xmath121 is computed using as follows : @xmath122 where the table of values of the partial marginal @xmath123 was already computed at @xmath75 while passing the message @xmath124 to the root @xmath108 .",
    "we need to look only at the rows for which @xmath125 and output the value of @xmath126 for which @xmath127 .",
    "this requires @xmath128 additions , where @xmath129 and @xmath130 .",
    "the total number of multiplications remains the same as in the single - vertex arg - sp algorithm , which is @xmath131 , but the number of additions is the sum of the number of additions required in single - vertex sp algorithm @xmath132 and the number of additions required at each node , which is at most @xmath133 .",
    "thus , the grand total of operations is at most @xmath134      in the all - vertex sp algorithm , first the messages are passed by all the nodes on the unique path towards the root .",
    "when the root has received messages from all its neighbors , messages are passed on each edge in the reverse direction , i.e. , away from the root and towards the leaves . when all the leaves have received the messages , marginal functions of each node is computed",
    "we use the method suggested in ( * ? ? ?",
    "v ) to compute messages and marginal function .",
    "let a node @xmath75 have degree @xmath135 and has received messages from all but one of its neighbors @xmath136 which is on the unique path from @xmath75 to the root .",
    "for an instance @xmath137 of @xmath76 , let @xmath138 be the values of the known messages , @xmath139 be the value of the message it is yet to receive from @xmath140 , and @xmath141 be the value of its local function , assumed to be @xmath37 if @xmath142 , i.e. , @xmath143 , @xmath144 . the messages @xmath145 involves the product of @xmath141 with all @xmath146s excluding @xmath147 and summing over suitable variables as in and ; there are @xmath135 such messages to be sent , one to each neighbor .    . ]",
    "this can be achieved by computing the following products consecutively : @xmath148 , @xmath149 , @xmath150 , @xmath151 , @xmath152 ; this step requires @xmath153 multiplications .",
    "now @xmath75 passes @xmath154 to @xmath140 ( after summing over suitable variables ) and awaits the reception of @xmath139 from @xmath136 .",
    "once @xmath139 is received , the marginal functions is computed , @xmath155 , which requires @xmath37 multiplication .",
    "then the following products are computed consecutively : @xmath156 , @xmath157 , @xmath158 , @xmath150 , @xmath159 ; this step requires @xmath160 multiplications .",
    "subsequently , @xmath145s are computed as follows : @xmath161 , @xmath162 , @xmath150 , @xmath163 , @xmath164 ; this step requires @xmath153 multiplication .",
    "various messages received and passed by node @xmath75 are depicted fig .",
    "[ cplxty ] .",
    "thus , computation of all the messages to be passed by @xmath75 and its marginal function requires @xmath165 multiplications for each of the @xmath78 values in @xmath77 .",
    "this is true for the root node also .",
    "hence , total number of multiplications required is @xmath166 $ ] .",
    "the number of additions required for computing each message remains the same as in the single - vertex sp algorithm , @xmath167 for a variable node passing message to @xmath90 . unlike in the single - vertex case ,",
    "now @xmath89 will pass messages to all its @xmath168 neighbors , thus requiring @xmath169 .",
    "same is true for all the factor nodes also .",
    "hence , the total number of additions required is @xmath170 .",
    "the grand total number of operations is then @xmath171    in the arg - sp algorithm , computation of support of marginal function at a node @xmath75 requires at most @xmath172 additions .",
    "thus , the total number of operations required in all - vertex arg - sp algorithm is @xmath173    the results of sections  iv - a , b , and c are tabulated in table  [ tab_nops ] .",
    "the operation counts presented in this section apply not only to mpf and arg - mpf problem in boolean semiring , but also to mpf and arg - mpf problem in min - sum , min - product , max - sum , and max - product semiring .",
    "the sp algorithm for decoding a network code is advantageous when the code is either nonlinear or it is linear but the number of messages is very large . for linear network codes with manageable value of @xmath22 , gaussian elimination with backward substitution",
    "is advisable .    for a node that demands all the source messages , for example a sink in a multicast network , if application of sp algorithm for decoding network codes leads to computational complexity strictly better than the brute - force decoding complexity , then the code",
    "is called a _ fast sp decodable network code_. the network code for network @xmath174 given in fig .",
    "[ fano ] is fast sp decodable for the sink with vertex label @xmath175 ; decoding complexity is only @xmath176 compared to the brute - force complexity of @xmath177 .    as stated above , in order to recover the requisite source messages at a sink we need only run the single - vertex arg - sp algorithm followed by traceback steps . for a given sink node , if the factor graph constructed using the method given in section  iii - a is cycle - free and the network code is such that the local domains of all factor nodes have cardinality at most @xmath178 , then the number of operations required for decoding using the sp algorithm is @xmath179 . if the sink demands all the source messages , then the brute - force decoding would require @xmath180 operations . thus , an acyclic factor graph with at most @xmath178 variables per equation is a sufficient condition for fast decodability of the network code at a sink which demands all the source messages .",
    "if the graph is not cycle - free then we remove the cycles by variable stretching .",
    "let @xmath181 be the size of maximum cardinality local domain in the new cycle - free factor graph .",
    "the number of computations required now will be @xmath182 and the code is fast decodable iff @xmath183 .",
    "in a communication network , some nodes may be interested not in the messages generated by some other nodes but in one or more functions of messages generated by other nodes .",
    "for example , in a wireless sensor network that comprises several sensor nodes , each measuring environmental parameters like ambient light , temperature , pressure , humidity , wind velocity etc . for long - term record - keeping and weather forecasting , average , minimum , maximum and variance of these meteorological parameters",
    "are of interest .",
    "environmental monitoring in an industrial unit is another field of application where relevant parameter may include temperature and level of exhaust gases which may assist in preventing fire and poisoning due to toxic gases respectively .",
    "we consider in - network function computation in a finite directed acyclic error - free network , @xmath184 , where codes can perform network coding .",
    "for brevity of expression , we use @xmath185 for @xmath23}$ ] in this section .",
    "the network model is same as given in section  i - a for network coding problem with the exception that the sink nodes demand a function of messages rather than a subset of messages , i.e. , a sink node @xmath186 demands the function @xmath187 .",
    "a network code comprises global encoding maps @xmath188 , one for each edge @xmath45 , such that there exist @xmath16 ( decoding ) maps , @xmath189 , for each sink @xmath17 $ ] , such that @xmath190 .",
    "this subsumes the network coding problem of section  i as a special case . by @xmath191",
    "we denote the @xmath192-tuple of coded messages received by @xmath186 on its incoming edges .",
    "[ rem_func ] though arguments of a demanded function @xmath193 may only be a subset , say @xmath194 for some @xmath195 $ ] , of messages , we assume it to be a map from @xmath52 to @xmath10 for simplicity rather than from @xmath196 to @xmath10 .",
    "if a sink demands @xmath197 functions , then such a sink may be replaced by @xmath198 sinks each demanding one function but the incoming information to these new sinks is the same ( see fig .  [ multi_func ] ) .",
    "the in - network function computation problem is to design network code that maximizes the frequency of target functions computation , called the _ computing capacity _ , per network use . in @xcite",
    ", bounds on rate of computing symmetric functions ( invariant to argument permutations ) , like minimum , maximum , mean , median and mode , of data collected by sensors in a wireless sensor network at a sink node were presented . the notion of min - cut bound for the network coding problem @xcite",
    "was extended to function computation problem in a directed acyclic network with multiple sources and one sink in @xcite .",
    "the case of directed acyclic network with multiple sources , multiple sinks and each sink demanding the sum of source messages was studied in @xcite ; such a network is called a sum - network .",
    "relation between linear solvability of multiple - unicast networks and sum - networks was established .",
    "furthermore , insufficiency of scalar and vector linear network codes to achieve computing capacity for sum - networks was shown .",
    "coding schemes for computation of arbitrary functions in directed acyclic network with multiple sources , multiple sinks and each sink demanding a function of source messages were presented in @xcite . in @xcite , routing capacity , linear coding capacity and nonlinear coding capacity for function computation in a multiple source single sink directed acyclic network were compared and depending upon the demanded functions and alphabet ( field or ring ) , advantage of linear network coding over routing and nonlinear network coding over linear network coding was shown .    in order to obtain the value of its desired functions , a sink node may require to perform some operations on the messages it receives on the incoming edges .",
    "though there are many results on bounds on the computing capacity and coding schemes for in - function computation problem , the decoding operation to be performed at the sink nodes to obtain the value of the desired functions has not been studied .",
    "we now formulate computation of the desired functions at sink nodes as an mpf problem over the boolean semiring and use the sp algorithm on a suitably constructed factor graph for each sink to obtain the value of the desired functions .",
    "we consider decoding at the sink node @xmath186 .",
    "it demands the function @xmath199 , where @xmath200 is the set of arguments of @xmath201 for some @xmath202 $ ] . for a realization @xmath203 of the message vector , we are interested in the value @xmath204 .",
    "since a network code only ensures computation of the correct value @xmath205 of the demanded target function given the incoming coded message vector @xmath191 and not the realization @xmath206 of the messages in the argument set , there may be multiple @xmath207-tuples that produce the same values of the incoming coded messages and function value when input to the demanded function , i.e. , the network code is a many - to - one mapping .",
    "we denote one such message vector by @xmath208 .",
    "it need not necessarily be equal to @xmath206 but @xmath209 for all @xmath210 and @xmath211 . using the sp algorithm ,",
    "we will first obtain @xmath208 and then evaluate @xmath212 to obtain @xmath205 .",
    "the arg - mpf formulation for obtaining @xmath208 is given below .",
    "let @xmath213 here @xmath214 is the global product function and @xmath215 are the local functions of the mpf problem at the sink @xmath186 .",
    "the set @xmath216 contains the coordinates indexed by @xmath217 of the message vectors @xmath185 for which @xmath218 , i.e. , the coordinates indexed by @xmath217 of all those message vectors for which @xmath219 , for all @xmath210 .",
    "though @xmath220 may output multiple @xmath207-tuples , we will choose any one as @xmath208 .",
    "the desired function values is then @xmath221 thus , the function computation can be performed by using sp algorithm to solve mpf problem in followed by .",
    "for all @xmath222 obtained using and each @xmath223 $ ] , we have @xmath224 .    by remark  [ rem_func ] , @xmath225 . a look - up table ( lut )",
    "approach to decoding is to maintain a table with @xmath226 rows and two columns at each sink : first column containing all possible incoming message vectors , @xmath227 , and the second column listing corresponding values of the demanded function , @xmath228 . given an instance of incoming messages , a sink node locates the row containing that @xmath192-tuple in the first column of the lut and then outputs the value in the second column of the row , which is the desired function value . if two rows in the lut have the same entry in the first column ( network code is a many - to - one map ) , the entry in the second column will also be same .",
    "on the contrary , if for two @xmath229 , @xmath230 but @xmath231 for all @xmath210 and some @xmath223 $ ] , then there will be ambiguity at the @xmath232th receiver because there are two distinct possible function values , @xmath233 and @xmath234 , that the decoder may output .",
    "thus , a valid network code that fulfills all receivers demands satisfies @xmath235 for all @xmath210 if @xmath230 for each @xmath223 $ ] and @xmath229 , @xmath236 .",
    "let @xmath203 be a realization of the message vector and @xmath191 the coded message received by @xmath186 on its incoming edges .",
    "the set @xmath237 contains all the message vectors @xmath238 such that @xmath239 including @xmath203 .",
    "thus , @xmath240 for all @xmath241 .",
    "since @xmath242 and @xmath225 , we have that @xmath243 for all @xmath222 .",
    "hence , the sp algorithm for can terminate as soon as a message vector @xmath208 with @xmath244 is found and we need not obtain all possible message vectors which evaluate to the given coded messages on incoming edges of a sink .",
    "for example , let @xmath245 , @xmath246 for all @xmath247 $ ] , and @xmath248 needs to be evaluated using @xmath249 , and @xmath250 . here @xmath251 .",
    "let @xmath252 be a realization of the message vector .",
    "then , @xmath253 , @xmath254 , @xmath255 , and @xmath256 .",
    "from , we have @xmath257}\\delta(\\tilde{f}_{e_j}(x),y_{e_j } ) \\;=\\ ; \\{000,111\\}\\end{aligned}\\ ] ] any element of @xmath0 can be chosen as @xmath258 and both evaluate to @xmath88 when input to @xmath259 .",
    "this illustrates that @xmath260 .",
    "@xmath70    the factor graph for computation of function @xmath199 at sink @xmath261 $ ] is constructed as follows :    1 .",
    "install @xmath22 variable nodes , one for each source message .",
    "these vertices are labeled by their corresponding source messages , @xmath262 .",
    "2 .   install @xmath192 factor nodes and label them @xmath263 .",
    "the associated local domain of each such vertex is the set of source messages that participate in that encoding map and the local kernel is @xmath264 .",
    "a variable node is connected to a factor node iff the source message corresponding to that variable node participates in the encoding map corresponding to the said factor node .",
    "4 .   install an additional dummy factor node with local domain @xmath265 , local kernel @xmath37 and label it @xmath201 .",
    "connect this node to variable nodes in the set @xmath265 , i.e. , to the arguments of @xmath201 .",
    "this node corresponds to the demanded function .    as before ,",
    "first the cycles in the factor graph are removed , if there are any .",
    "the single - vertex sp algorithm is run on the acyclic factor graph with the dummy factor node as the root using and .",
    "once it has received all the messages , its marginal function ( using ) and subsequently the set @xmath216 are computed as follows : @xmath266 where @xmath267 is the local domain of a neighboring variable node @xmath89 of @xmath201 .",
    "theorem  1 states that obtaining only an element @xmath208 of the set @xmath216 is sufficient to get the desired function value @xmath268 .",
    "in this paper , we proposed to use the sp algorithm for decoding network codes and performing in - network function computation .",
    "we posed the problem of network code decoding at each sink node in a network as an mpf problem over the boolean semiring .",
    "a method for constructing a factor graph for a given sink node using the global encoding maps ( or vectors in case of an lnc ) of the incoming edges and demands of the sink was provided .",
    "the graph so constructed had fewer nodes and led to fewer message being passed lowering the number of operations as compared to the scheme of @xcite .",
    "we discussed the advantages of traceback over multiple - vertex sp algorithm .",
    "the number of semiring operations required to perform the sp algorithm with and without traceback were derived . for the sinks demanding all the source messages",
    ", we introduced the concept of fast decodable network codes and provided a sufficient condition for a network code to be fast decodable .",
    "then we posed the problem of function computation at sink nodes in an in - network function computation problem as an mpf problem and provided a method to construct a factor graph for each sink node on which sp algorithm can be run to solve the mpf problem .",
    "r. appuswamy , m. franceschetti , n. karamchandani , and k. zeger , `` linear codes , target function classes , and network computing capacity , '' _ ieee trans .",
    "inf . theory _ ,",
    "9 , pp . 5741 - 5753 , september 2013 ."
  ],
  "abstract_text": [
    "<S> while the capacity , feasibility and methods to obtain codes for network coding problems are well studied , the decoding procedure and complexity have not garnered much attention . in this work </S>",
    "<S> , we pose the decoding problem at a sink node in a network as a marginalize a product function ( mpf ) problem over a boolean semiring and use the sum - product ( sp ) algorithm on a suitably constructed factor graph to perform iterative decoding . </S>",
    "<S> we use _ traceback _ to reduce the number of operations required for sp decoding at sink node with general demands and obtain the number of operations required for decoding using sp algorithm with and without traceback . for sinks demanding all messages , </S>",
    "<S> we define _ fast decodability _ of a network code and identify a sufficient condition for the same . </S>",
    "<S> next , we consider the in - network function computation problem wherein the sink nodes do not demand the source messages , but are only interested in computing a function of the messages . </S>",
    "<S> we present an mpf formulation for function computation at the sink nodes in this setting and use the sp algorithm to obtain the value of the demanded function . </S>",
    "<S> the proposed method can be used for both linear and nonlinear as well as scalar and vector codes for both decoding of messages in a network coding problem and computing linear and nonlinear functions in an in - network function computation problem .    </S>",
    "<S> network coding , decoding , sum - product algorithm , traceback , in - network function computation . </S>"
  ]
}