{
  "article_text": [
    "let us first explain the problem of oblivious transfer ( ot )  @xcite ; a formal definition can be found in  @xcite .",
    "alice ( the sender ) holds two input strings @xmath5   and bob ( the receiver ) holds a choice bit @xmath6 .",
    "if both nodes are honest , bob should receive the input of his choosing , @xmath7 , at the end of the protocol . if bob is honest , then our goal is to ensure that whatever attack alice may mount , she can nevertheless not gain any information about @xmath8 .",
    "conversely , if alice is honest , we want that a dishonest bob is unable to gain any information about at least one of alice s inputs , @xmath9 .",
    "whereas oblivious transfer by itself may seem like a rather obscure task , it has in fact been shown that alice and bob can use it to solve any other cryptographic problem securely  @xcite .",
    "below we use @xmath10 to indicate that we use a link - ot protocol as a black box .",
    "we now provide two protocols , where the first is unconditionally secure for the sender alice   and secure for the receiver bob provided there is an honest path .",
    "the second has exactly opposite security properties : it is unconditionally secure for bob and secure for alice provided there is an honest path .",
    "let @xmath11 be the number of paths connecting alice to bob and denote by @xmath12 the nodes adjacent to alice on the @xmath11 possible paths .",
    "we use @xmath13 and @xmath14 to indicate bitwise addition and multiplication modulo @xmath15 respectively , and @xmath16 to denote that a variable has been chosen uniformly and independently at random .",
    "input : @xmath5 for alice , @xmath6 for bob output : @xmath7 to bob .",
    "[ proto : pathot ]    chooses @xmath11 bits @xmath17 such that @xmath18 .",
    "he sends @xmath19 to node @xmath20 along the @xmath21-th path .",
    "chooses @xmath11 keys @xmath22 such that @xmath23 .    performs @xmath24 with @xmath25 and @xmath26 with node @xmath27 , and @xmath28 with @xmath29 and @xmath30 with nodes @xmath31 .",
    "node @xmath20 sends @xmath32 to bob along the @xmath21-th path .",
    "computes @xmath33 .",
    "first , the protocol is correct when both players are honest , since bob computes @xmath34    we now argue that the protocol is also secure ; details can be found in the appendix .",
    "suppose first that bob is dishonest .",
    "since alice uses fresh keys @xmath35 in each round , and @xmath36 and @xmath37 are themselves randomly chosen bit strings unknown to bob , bob would need to retrieve at least @xmath38 entries @xmath39 in order to compute both @xmath36 and @xmath37 .",
    "however , even if bob is working together with all intermediary nodes , he can only learn at most one of @xmath40 from each of the @xmath11 link - ots with alice .",
    "hence , bob learns nothing about one of @xmath41 or @xmath37 as desired .",
    "suppose now that bob is honest , and there exists an honest path between alice and bob .",
    "note that bob effectively performs a secret sharing of his input along all paths , so that alice needs all shares in order to recover @xmath8  @xcite .",
    "however , the share on the honest - path remains unknown to alice .",
    "the security of the link - ot ensures she can not use it to gain any information about @xmath8 either .",
    "our second protocol is similar , but with alice performing a secret sharing of her inputs .",
    "let @xmath42 be the nodes adjacent to bob on the @xmath11 possible paths .",
    "input : @xmath5 for alice , @xmath6 for bob output : @xmath7 to bob .",
    "[ proto : longot2 ]    chooses @xmath11 strings @xmath43 such that @xmath44 and similarly @xmath45 such that @xmath46 .",
    "she sends bits @xmath47 to node @xmath48 , i.e. the @xmath21-th neighbour of bob via the @xmath21-th path",
    ".    performs @xmath49 with node @xmath48 .",
    "computes @xmath50 .    clearly , the protocol is correct if both parties are honest .",
    "the security of the link - ot for the receiver ensures that even if a dishonest alice controls all nodes adjacent to bob , she nevertheless can not learn @xmath8 .",
    "finally , the protocol is secure against a dishonest bob , assuming that there exists an honest path : in this case , at least one of the shares @xmath51 or @xmath52 remains unknown to bob , since they are securely transmitted to node @xmath48 via the honest path , and the link - ot protocol between @xmath48 and bob is secure for the sender .",
    "hence , he can not learn both inputs @xmath53 .",
    "one may wonder whether we could have constructed a path - ot protocol without relying on the existence of a link - ot protocol , which is impossible to obtain without assumptions  @xcite .",
    "however , it is easy to see that the existence of _ any _ path - ot protocol would imply a secure link - ot protocol between two directly connected parties , anne and bill : first , anne picks a path from alice to bob in the original setting .",
    "then bill picks a path from bob to alice .",
    "the remaining paths they split arbitrarily .",
    "now anne acts as alice would and in addition simulates the action of all nodes in the paths assigned to her .",
    "bill also simulates the actions of bob together with all nodes in the paths assigned to him .",
    "clearly , no matter who will be dishonest , we are always in the setting where there is an honest path in the original protocol , as one path is always simulated by someone being honest .",
    "this means that we can not hope to achieve ot in the honest - path model without additional assumptions either  @xcite .",
    "however , one might still hope that given such a strong primitive as link - ot we might be able to achieve security using only classical communication , even without the assumption of an honest path .",
    "unfortunately , it turns out that an honest path is indeed a necessary condition for security : if there is no honest path , then there exists a subset of corrupted nodes @xmath54 , such that any communication between alice and bob goes through them",
    ". intuitively ( see appendix for details ) this means that either @xmath54 can gain information about @xmath8 , or else must know enough about @xmath36 and @xmath37 to be able to supply bob with the desired output .",
    "in the first case , dishonest alice can learn @xmath8 from @xmath54 , and in the second dishonest bob can break security by learning information about both of alice s inputs .    _ a security backup : _ nevertheless , the assumption of an honest path may appear quite strong , and it would be useful to have some security guarantees even if this assumption fails . fortunately , it is straightforward to adopt existing techniques from classical cryptography  @xcite to extend our protocols to be secure if either the honest - path assumption holds , or else if the dishonest party can not break a certain computational problem . to this end , we combine our protocol with a protocol for classical oblivious transfer .",
    "ot can be achieved classically under a large variety of assumptions . here , we choose to combine our protocol with the protocol of naor and pinkas  @xcite , which is secure against a dishonest sender if he can not break the decisional diffie hellman problem ( ddh ) , and unconditionally secure against a dishonest receiver .",
    "note that this means that just like for our honest - path assumption , we have unconditional security against one party , and security according to either the ddh or the honest - path assumption against the other  . using the @xmath55-robust uniform ot - combiner from  ( * ? ? ?",
    "* theorem 2 ) we hence immediately obtain that there exists an oblivious transfer protocol that is secure if either the honest path or the ddh assumption holds using two instances of protocol  1 , and two instances of the ot protocol of  @xcite .",
    "an explicit protocol can be found in  @xcite .    _",
    "secret keys : _ in the classical model for secure multiparty computation one usually assumes that there exist private links between all nodes and we are trying to show security against subsets of dishonest nodes .",
    "clearly , this is a strong assumption as it requires us to establish keys over potentially long distances .",
    "nevertheless , it is interesting to consider a hybrid - model , where there exists a complete network of classical private links and also a network of quantum links between neighboring nodes allowing them to perform link - ot .",
    "it is easy to see that our protocol can be transformed to achieve security as long as one of the neighbours of alice and bob is honest , instead of the entire path being honest : we use the private channels to directly communicate with the immediate neighbours instead of relying on the entire path .",
    "this easy example shows that allowing link - ot is indeed more powerful than what one can hope to gain in the classical model of secure multi - party computation .    _",
    "no assumptions : _ finally , let us consider what happens if we allow an _ arbitrary _ number of network nodes to be dishonest . curiously , some weak notion of security still remains .",
    "more specifically , by performing our two protocols sequentially with different inputs for alice and bob in the two executions , we can trivially construct a form of path - ot where alice has four inputs , and bob has two choice bits such that : if everyone is honest , then bob learns two of the four bits , and alice learns nothing about bob s two index bits . if alice is honest , but everyone else in the network is dishonest , then bob learns three bits , but _ not _ all four of them .",
    "if bob is honest , but everyone else is dishonest , then alice learns one of the two index bits of bob , but _ not _ both of them .",
    "these properties follow directly from our previous analysis .",
    "note that this weak form of security is still impossible classically on a complete network with private links , unless computational assumptions are added . in our model , it becomes possible because we added the neighboring quantum links and assumed that we can perform short distance ot protocols via these quantum links .",
    "one can turn this weak ot protocol into some weak bit commitment protocol as well , leading to weak forms of coin tossing over long distances .",
    "we have shown security against dishonest alice ( or bob ) whenever there is at least one honest path , or the dishonest party can not break a computational assumption .",
    "one can easily extend our protocol to be robust against the case where the intermediary nodes may be dishonest independently of alice and bob , and try to alter alice s or bob s input . in our present protocols",
    "this is of course possible since they could for example flip one of the bits @xmath56 . to make the protocol robust",
    "we can simply use a more advanced secret sharing scheme that , similar to an error correcting code , protects against ` errors ' introduced in the secrets  @xcite .",
    "note that depending on our choice of secret sharing scheme , we may require more than one honest path to achieve robustness or more communciation rounds  .",
    "our protocols show that two - party cryptographic primitives can be implemented over long distances in an extremely simple manner .",
    "our result enables us to extend the range of protocols in the noisy - storage model  in a similar way as has been done in qkd  @xcite .",
    "clearly , our protocols still require a considerable amount of classical communication . however , this is technologically much easier to achieve than entanglement swapping which of course still remains the more desirable solution .",
    "the quantum operations that the nodes are performing are no harder than the ones necessary in the link - ot protocols , i.e. it suffices that they create and measure bb84  @xcite states  @xcite .",
    "no complicated operations like bell state measurements , or memory are required .",
    "sw was supported by nsf grants phy-04056720 , phy-0803371 , as well as the national research foundation and the ministry of education , singapore .",
    "ik was supported by anr grants anr-09-jcjc-0067 - 01 and anr-08-emer-012 .",
    "part of this work was done while sw was at the institute for quantum information , caltech .",
    "26 natexlab#1#1bibnamefont # 1#1bibfnamefont # 1#1citenamefont # 1#1url # 1`#1`urlprefix[2]#2 [ 2][]#2    , in _ _",
    "( ) , pp . .    , * * , ( ) .    , , , * * , ( ) .    , , ( ) , .",
    "( ) , .    , , , , in _ _",
    "( , ) , vol . of _ _ , pp . .    , in _ _",
    "( ) , pp . .    , , , , , , , , , , , in _ _ ( ) , pp . .    , , , , , , , , , , ,",
    "* * , ( ) .    , , , , , , , , , , , * * , ( ) .",
    ", , , , , , * * , ( ) .    , * * , ( ) .",
    ", , , , , , , , , , ( ) , .    , , , , * * , ( ) .    , , , , * * , ( ) .    , , , , , , , ,",
    "* * , ( ) .    , , , , , , ,",
    "* * , ( ) .    , in _ _",
    "( ) , pp . .    , , , , , , * * , ( ) .    , , ( ) , .    , * * , ( ) .    , * * , ( ) .    , , , , , in _",
    "_ ( ) , vol . of _ _ , pp . .    , , , in _ _",
    "( ) , lecture notes in computer science .    , in _ _",
    "( ) , pp . .    , in _ _",
    "( ) , pp . .",
    "whereas we ideally show security using the formal definitions for fully - randomized ot  @xcite , we restrict ourselves to the simple arguments below in order to not obscure our argument , which is sufficient since our setting is very straightforward to analyze .",
    "protocol 1 forms a secure oblivious transfer scheme with unconditional security against alice , and security against bob whenever there exists an honest path .",
    "we first show that the protocol is correct when both alice and bob are honest .",
    "this follows immediately by noting that bob can compute    @xmath57    we now show that the protocol is secure if alice is honest , where we allow all intermediary players and bob to be dishonest . from the security of the link - ot protocol , it follows that bob can learn at most one of alice s inputs from each invocation . in the most general cheating strategy ,",
    "bob can arbitrarily choose values as his input bits to the @xmath11 link - ot protocols .",
    "let @xmath58 denote these inputs and let @xmath59 be the inputs of alice that bob learns .",
    "note that for any choice of bob s inputs @xmath60 there exists a @xmath6 such that @xmath61 .",
    "moreover , @xmath62 .",
    "our goal is now to show that bob can not gain any information about @xmath9 .",
    "first of all , note that since alice uses fresh keys @xmath35 in each link - ot , and @xmath36 and @xmath37 are themselves randomly chosen bit strings unknown to bob , the values of @xmath63 and @xmath64 are all independent .",
    "hence , bob would need to retrieve all such @xmath38 entries in order to compute both @xmath36 and @xmath37 , which contradicts the security of the link - ot .",
    "it remains to prove security if bob is honest .",
    "note that bob effectively performs a secret sharing of his input @xmath65 along all paths such that the bit @xmath8 can only be recovered if and only if alice learns all shares @xmath56 . however , alice has no information about the value of @xmath66 on the honest - path as links between honest players are secure .",
    "furthermore , the link - ot used between alice and @xmath20 is secure for the receiver , and hence we conclude that alice can not learn @xmath8 as promised .",
    "we now prove that an honest - path is a necessary condition for ot , where we use a weaker definition which is implied by the formal ones given e.g. for ( fully randomized ) oblivious transfer in  @xcite .",
    "note that this is sufficient to prove the impossibility of the more difficult task as well . more concretely",
    ", the following conditions must hold for any protocol that is both correct and secure .",
    "any impossibility proof for a protocol aiming for perfect security is rather unsatisfactory since we would be willing to accept a very small probability of failure .",
    "we hence include a security parameter @xmath67 which intuitively corresponds to the error we are willing to accept .",
    "first of all , for any protocol that is correct we must have that the probability that honest bob with input @xmath8 can guess honest alice s input , @xmath68 , satisfies @xmath69 \\geq 1 - { \\varepsilon}\\ .",
    "\\label{eq : correct}\\end{aligned}\\ ] ] furthermore , if alice is honest , then for whatever attack bob may conceive we have that he can not guess at least one of the two inputs @xmath70 \\leq \\frac{1}{2^\\ell } + { \\varepsilon}\\ ,      \\label{eq : bobcheats}\\end{aligned}\\ ] ] finally , if bob is honest and his input bit is @xmath8 , then for any strategy of dishonest alice , she is unable to learn bob s choice bit @xmath71 \\leq \\frac{1}{2 } + { \\varepsilon}\\ .",
    "\\label{eq : alicecheats}\\end{aligned}\\ ] ]    to obtain an impossibility proof , our goal is now to show that  ,   and   can never be satisfied simultaneously for small values of @xmath72 .",
    "that is , we can only hope to achieve very imperfect version of oblivious transfer with a large error @xmath72 .",
    "if there is no honest path , then there exists some subset of potentially dishonest nodes @xmath54 that separates the network into two disconnected components , one containing alice and the other bob .",
    "let us now establish some basic properties of the probabilities that alice , bob or @xmath54 can learn @xmath53 and @xmath8 in an honest execution of any protocol .",
    "note that in any protocol , bob can not gain more information about alice s inputs than @xmath54 can , since all information between alice and bob runs through @xmath54 ( wlog we can furthermore assume that dishonest bob would give any shared secret keys with alice to @xmath54 for free ) . hence , we have that @xmath74 \\leq \\pr[s_{b}|m]\\ .",
    "\\label{eq : conditiona }      \\end{aligned}\\ ] ] similarly , alice can not gain more information about bob s input than @xmath54 can , hence",
    "@xmath75 \\leq \\pr[{c}|m]\\ .",
    "\\label{eq : conditionb }      \\end{aligned}\\ ] ] first , suppose that for an honest execution of any protocol the probability that @xmath54 is able to guess @xmath8 satisfies @xmath76 > 1/2 + { \\varepsilon}$ ]",
    ". then , alice can violate the security condition   by running the protocol honestly with bob and then asking @xmath54 for a guess of @xmath8 .",
    "hence , it must hold that @xmath77 \\leq \\frac{1}{2 } + { \\varepsilon}\\ .",
    "\\label{eq : conditionc }      \\end{aligned}\\ ] ] second , by the correctness condition   and equation  , for an honest execution of any protocol , we have @xmath78 \\geq 1 - { \\varepsilon}\\ .",
    "\\label{eq : conditiond}\\end{aligned}\\ ] ] third , suppose that for an honest execution of any protocol , @xmath79 > \\frac{1}{2^\\ell } + { \\varepsilon}$ ]",
    ". then , bob can violate the security condition   by running the protocol honestly with alice and then asking @xmath54 for a guess for both @xmath36 and @xmath37 .",
    "hence , it must hold that @xmath80 \\leq \\frac{1}{2^\\ell } + { \\varepsilon}\\ .",
    "\\label{eq : conditione}\\end{aligned}\\ ] ] we now show that these conditions imply that whenever bob is honest , there exists a cheating strategy for alice .",
    "alice first chooses two random inputs @xmath5 , and runs the protocol as an honest alice would do .",
    "afterwards , she picks a random @xmath81 and asks @xmath54 , who by definition will willingly cooperate with any cheating party , to send her a guess @xmath82 for @xmath83 .",
    "note that   and   now tell us that the probability that @xmath54 succeeds is very large for @xmath68 , but extremely small for @xmath9 .",
    "alice then outputs @xmath81 as her guess for @xmath8 if @xmath54 guessed correctly and @xmath84 if @xmath54 guessed wrongly . the probability that alice succeeds using this strategy obeys @xmath85}\\\\           & = \\pr[b = c]\\pr[s_{c}|m]+\\pr[b=1-c ] ( 1 - \\pr[s_{1-c}|m])\\nonumber\\\\          & \\geq \\frac{1}{2}(1-{\\varepsilon})+\\frac{1}{2 } ( 1 - \\frac{1}{2^{\\ell}}-{\\varepsilon})\\\\                    & = ( 1-{\\varepsilon}- \\frac{1}{2^{\\ell+1 } } ) \\label{eq : loweralice}\\ .",
    "\\end{aligned}\\ ] ] comparing   with   concludes our claim ."
  ],
  "abstract_text": [
    "<S> any two - party cryptographic primitive can be implemented using quantum communication under the assumption that it is difficult to store a large number of quantum states perfectly . however , achieving reliable quantum communication over long distances remains a difficult problem . </S>",
    "<S> here , we consider a large network of nodes with only neighboring quantum links . we exploit properties of this cloud of nodes to enable any two nodes to achieve security </S>",
    "<S> even if they are not directly connected . </S>",
    "<S> our results are based on techniques from classical cryptography and do not resort to technologically difficult procedures like entanglement swapping . </S>",
    "<S> more precisely , we show that oblivious transfer can be achieved in such a network if and only if there exists a path in the network between the sender and the receiver along which all nodes are honest . </S>",
    "<S> finally , we show that useful notions of security can still be achieved when we relax the assumption of an honest path . </S>",
    "<S> for example , we show that we can combine our protocol for oblivious transfer with computational assumptions such that we obtain security if either there exists an honest path , or , as a backup , at least the adversary can not solve a computational problem .    </S>",
    "<S> quantum communication allows us to achieve cryptographic security without relying on unproven computational assumptions . </S>",
    "<S> two nodes , alice and bob , can establish a secure key using quantum key distribution  @xcite , and , moreover , solve any two - party cryptographic problem even if they do not trust each other in the noisy - storage model  @xcite . </S>",
    "<S> well - known examples of such problems include secure identification  @xcite , as well as electronic voting and secure auctions . </S>",
    "<S> more generally , alice and bob wish to solve problems where alice holds an input @xmath0 ( eg . the amount of money she is willing to bid for an item sold by bob ) and bob holds an input @xmath1 ( e.g. his minimum asking price ) , and they want to obtain the value of some function @xmath2 ( e.g. output no if @xmath3 , and @xmath0 otherwise ) as depicted below . in this </S>",
    "<S> setting , there is no outside eavesdropper but alice or bob themselves may be dishonest . </S>",
    "<S> security thereby means that alice should not learn anything about @xmath1 and bob should not learn anything about @xmath0 , apart from what can be inferred from the value of @xmath2  @xcite .        </S>",
    "<S> unfortunately , quantum communication over long distances poses a formidable problem . at present , </S>",
    "<S> quantum key distribution has been achieved over a distance of at most 145 km in fiber  @xcite or 144 km in freespace  @xcite . </S>",
    "<S> in addition , having a direct communication link between any two nodes that may wish to communicate is an infeasible problem even when it comes to classical communication . </S>",
    "<S> instead , we have networks of nodes , such as the present day internet , in which only some nodes are directly connected , but are willing to relay communication for other nodes who do not share a direct link . </S>",
    "<S> typically it is easy to connect two nodes who are physically close . in order to achieve longer distances , </S>",
    "<S> many forms of quantum repeaters have been proposed in order extend the range of quantum communication to obtain a quantum version of the internet  @xcite . </S>",
    "<S> broadly speaking , quantum repeaters used in key distribution come in two variants : in the first , the nodes along the path between alice and bob are trusted , and we perform quantum key distribution between each two neighbours . </S>",
    "<S> this form of repeater is known as trusted relay and was for example used in the network of secoqc  @xcite . </S>",
    "<S> the second method is to have the intermediary nodes create entanglement , allowing alice and bob to create entanglement between them using the concept of entanglement swapping  @xcite . </S>",
    "<S> this is clearly more desirable than relying on trusted relays , but technologically very difficult to achieve especially when there are many intermediary nodes . </S>",
    "<S> many experiments have been done over the last twelve years  @xcite , but still we are far from using this technology for qkd  @xcite , and similarly for the case of two - party computation in the noisy - storage model . </S>",
    "<S> what both of these approaches have in common is that they first try to create the analog of a point - to - point link between alice and bob to solve the final cryptographic task .    </S>",
    "<S> here , we take a novel approach using techniques from classical cryptography to bridge the potentially large physical distance between alice and bob . concretely , we for the first time consider the case where any two nodes that are directly connected by a ( quantum ) communication link can securely solve the universal cryptographic problem of oblivious transfer ( ot ) , which in turn enables them to solve any two - party cryptographic problem  @xcite . </S>",
    "<S> implementations of such protocols ( _ link_-ot ) can be found in noisy - storage model  @xcite . </S>",
    "<S> any node in the network may behave honestly , or be dishonest in the sense that it will collaborate with the dishonest alice or bob . </S>",
    "<S> a dishonest node also has full control over the communication links attached to it , making it more powerful than for example the eavesdropper in qkd who only has access to the communication link and not to any of the individual labs .     and </S>",
    "<S> @xmath4 ) along which all intermediary nodes are honest , or the cheating party can not solve a computational problem efficiently . ]    * results * we first provide a simple protocol for oblivious transfer between alice and bob , who do not share a direct quantum link , that is secure , as long as all nodes along one of the paths from alice to bob are honest ( _ path_-ot ) </S>",
    "<S> . we will refer to this path as an _ honest path _ from alice to bob , which is in flavor similar to recent extensions to the idea of trusted relays for qkd  @xcite . </S>",
    "<S> however , we prove that this is in fact all we can hope to achieve for secure two - party computation without any additional resources : given only the resource of link - ot and classical communication , no protocol between alice and bob can be secure without the existence of an honest path . </S>",
    "<S> furthermore , we show that link - ot is in fact a necessary condition for any protocol to be secure , i.e. , having access to a large network of nodes does not allow us to solve the problem of oblivious transfer on its own  .    </S>",
    "<S> then , we successively relax the assumption of an honest path . </S>",
    "<S> first , since relying on an honest path alone may still be rather unsatisfactory , we show that we can add a security backup in the sense that our protocol can be made secure if there is either an honest path , or at least the dishonest node can not break a computational assumption . </S>",
    "<S> we then show that the assumption of the honest path can be relaxed if each pair of nodes are given a classical shared key for free , and finally that a non - trivial notion of security is still achievable for a node , even if everyone else in the network is dishonest .    </S>",
    "<S> our results open the door for extending implementations of oblivious transfer in the noisy - storage model  to large distances similar to the case of qkd  @xcite . </S>"
  ]
}