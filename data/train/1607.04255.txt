{
  "article_text": [
    "job deadline satisfaction problems have been extensively studied in the operations research community due to their important applications in manufacturing and logistics .",
    "there is an enormous number of publications on this subject .",
    "for example , @xcite provides a thorough account on job shop scheduling problems with deadlines .",
    "@xcite gives a survey of scheduling with controllable processing times , in order to meet deadlines in an optimal manner , e.g. , reducing job earliness .",
    "when some deadlines are deemed infeasible to be fulfilled , relaxations can be considered , usually in an optimal manner .",
    "for example , in @xcite the authors consider a single machine scheduling problem with common due dates , and the performance is measured by the minimization of the sum of earliness and tardiness penalties of the jobs . in operations research",
    "usually mathematical and constraint programming models are used .",
    "recently , researchers in the supervisory control community have been formulating the job deadline satisfaction problems in automaton ( or language ) based models , motivated by the belief that supervisory control theory @xcite @xcite can ensure optimal performance while guaranteeing operational safety and liveness . in @xcite the authors adopt the brandin - wonham timed control paradigm  @xcite to deal with supervisory control for job deadlines in cluster tools applications , whose modeling formalism follows the ostroff s semantics for timed transition models  @xcite . in  @xcite",
    "the authors adopt the timed automaton modeling formalism  @xcite and use reachability analysis techniques to determine deadline satisfaction in an industrial case study . in @xcite",
    "a new time optimal supervisory control paradigm is introduced , in which a plant is modeled as a time - weighted automaton and a logic requirement is modeled as an unweighted automaton . the heap - of - pieces theory @xcite is used to describe execution time of each trajectory in a quasi - concurrent setup , i.e. , executions of different transitions in the trajectory can be overlapped but their starting moments must be sequentially ordered . the goal in @xcite is to achieve minimum makespan .    in this paper",
    "we adopt the time - weighted automaton modeling formalism introduced in @xcite to address the job deadline satisfaction problems .",
    "the basic setup consists of a plant modeled as a time - weighted automaton , a logic requirement language that takes care of general logic constraints about operational safety and progress , and a collection of job requirements associated with relevant job deadlines .",
    "we first tackle the problem of determining the least restrictive controllable sublanguage ( denoted as @xmath0 for easy reference ) of the plant that satisfies all requirements and deadlines .",
    "when @xmath0 exists , our second problem is to determine an optimal strategy to add delays to relevant transitions of the plant so that there exists the least restrictive controllable sublanguage that satisfies all requirements and deadlines with minimum job earliness . by solving a constraint optimization problem",
    "we show that the set of all optimal delays can be computed .",
    "when @xmath0 does not exist due to infeasibility of fulfilling some deadlines , our next problem is to determine how to relax some deadlines and in order to minimize the impact of deadline relaxation , we present an algorithm to determine the minimal sets of deadlines which need to be relaxed .",
    "we organize the paper as follows .",
    "firstly , we review some basic concepts of time - weighted automaton formalism introduced in @xcite in section ii",
    ". then we present the baseline problem of synthesizing the supremal controllable job - satisfaction sublanguages in section iii .",
    "after that , we bring in the problem of delay addition for minimum job earliness in section iv , and the problem of relaxing job deadlines in section v. after providing a simple illustration example in section vi , conclusions are drawn in section vii .",
    "we assume that the reader is familiar with concepts and operations in supervisory control theory @xcite and follow the notations in @xcite .",
    "given two strings @xmath1 , we write @xmath2 to denote @xmath3 being a _ prefix substring _ of @xmath4 . given a language @xmath5 we use @xmath6 to denote its _",
    "prefix closure_. given two languages @xmath7 , let @xmath8 denote their concatenation",
    ". given an arbitrary set @xmath0 we use @xmath9 to denote its cardinality .",
    "we write @xmath10 for the _ natural projection _ with respect to @xmath11 , where @xmath12 .",
    "the projection is naturally extended to mapping between languages .",
    "the inverse of @xmath13 is denoted by @xmath14 . given @xmath15 and @xmath16 , we write @xmath17 for their _ synchronous product_. let @xmath18 , @xmath19 and @xmath20 denote the collections of reals , positive reals and natural numbers respectively .",
    "finite - state time - weighted automaton _ is a 3-tuple @xmath21 , where @xmath22 is a finite - state automaton ; @xmath23 is the weight function , where @xmath24 denotes the set of transitions defined in @xmath22 , that assigns to each transition of @xmath22 a finite positive real representing the duration required for the corresponding transition to be completed ; @xmath25 is the reflexive and symmetric mutual exclusion relation .",
    "a pair @xmath26 if and only if @xmath27 can not be under execution simultaneously . for notational simplicity , we write @xmath26 to denote both @xmath26 and @xmath28 .",
    "let @xmath29 be the _ closed _ behavior of @xmath22 and @xmath30 be the _ marked _ behavior of @xmath22 .",
    "let @xmath31 and @xmath32 denote respectively the set of finite - state automata , and the set of finite - state time - weighted automata , whose alphabets are @xmath33 .",
    "we adopt the time - stamp interpretation of string execution time and the approach based on the heaps - of - pieces theory to calculate the string execution time @xmath34  @xcite . given @xmath21",
    ", we use @xmath35 to map each string in @xmath36 to the ( unique ) trajectory ( or path ) in @xmath22 , where @xmath37 .",
    "by @xcite we know that the mutual exclusion relation @xmath38 induces a resource set @xmath39 and a map @xmath40 , which maps each transition @xmath41 to its set of resources .",
    "let @xmath42 .",
    "then there exists a morphism @xmath43 , where @xmath44 is the collection of all matrices whose dimensions are @xmath45 such that @xmath46 is defined as the unit matrix @xmath47 , i.e. , all diagonal entries are 0 and all other entries are @xmath48 , and for each @xmath41 ,    @xmath49    in @xcite it has been shown that @xmath50 where @xmath51 is the @xmath52-dimensional column vector , whose entries are all @xmath53 , and @xmath54 is the transpose of @xmath55 . when the context is clear , we use @xmath56 to denote @xmath34 .",
    "let @xmath57 , where @xmath58 and @xmath59 denote respectively the sets of _ controllable _ events and _ uncontrollable _ events .",
    "[ def10]@xcite given @xmath60 , @xmath61 is _ controllable _ with respect to @xmath22 if @xmath62 .",
    "in this section , we propose an algorithm to compute the supremal controllable sublanguage that satisfies the job requirements and deadlines . to that end , we formally introduce the notion of job requirements and their deadlines below .",
    "let @xmath64 , where @xmath65 is a regular language , called _ job requirement _ , over @xmath66 and @xmath67 is its _ deadline _ ( or _ due date _ ) . here",
    "@xmath68 is a finite index set and each tuple @xmath69 is interpreted as follows : each job requirement @xmath65 has to be satisfied within its pre - specified due date @xmath70 . in this work , the completion of any _ process _",
    "@xmath71 is said to satisfy or complete the job requirement @xmath65 . since an operational sequence generated by the plant may involve events that contribute to the satisfaction of different jobs , we also say an operation sequence @xmath72 completes job @xmath65 if @xmath73 , where @xmath74 is the natural projection with respect to @xmath75 .",
    "we define the job @xmath65 execution time by @xmath3 ( under @xmath76 ) as @xmath77 i.e. , the job @xmath65 execution time by @xmath3 is the duration from the beginning of @xmath3 to the last event of @xmath3 in @xmath78 . for example , if @xmath79 , @xmath80 , @xmath81 , then @xmath82 is the job @xmath65 execution time by @xmath3 .",
    "if @xmath3 completes @xmath65 , i.e. , @xmath83 , then @xmath84 is said to be the _ job @xmath65 completion time by @xmath3 ( under @xmath76)_. for technical convenience , we assume @xmath85 .",
    "we allow @xmath86 for @xmath87 .",
    "hence each event executed by the plant contributes to the completion of some jobs and we allow the same event to contribute to the completion of several different jobs .",
    "let @xmath88 be the ( possibly empty ) collection of all strings which satisfy all job requirements and the corresponding job deadlines .",
    "@xmath89 is a finite language since the transition duration of each event is positive and @xmath85 .",
    "in addition to the job requirements , there is a _",
    "general logic requirement _",
    "@xmath90 used to specify the safety properties and the progress properties .",
    "we now bring in the notion of a _",
    "controllable job satisfaction sublanguage_.    given a time - weighted plant @xmath91 , the set of jobs and deadlines @xmath92 and a general logic requirement @xmath90 , let    @xmath93 + @xmath94    be the collection of all controllable sublanguages of @xmath95 satisfying all requirements and the job deadlines , i.e. , the collection of _ controllable job satisfaction sublanguages _ of @xmath96 under @xmath97 and @xmath98 .",
    "there exists a unique element @xmath99 such that @xmath100 we call @xmath101 the _ supremal controllable job satisfaction sublanguage of @xmath96 under @xmath97 and @xmath98 _ , denoted as @xmath102 .",
    "the first problem is stated below .",
    "+    [ prob1]given a plant @xmath96 , requirements @xmath97 and @xmath98 , compute @xmath102.@xmath63 +    a solution to problem  [ prob1 ] is given by the following algorithm .    1 .",
    "* input * : a centralized model @xmath91 , requirements @xmath103 and @xmath98 with @xmath104 .",
    "2 .   construct a trim tree - structured automaton for @xmath105 by constructing a tree - structured automaton for @xmath106 in breadth - first order with the following modifications : 1 .",
    "each state @xmath107 is maintained with a @xmath108-tuple @xmath109 , where @xmath3 is the unique string labeling the path from the root state @xmath110 to state @xmath107 .",
    "initially , @xmath111 .",
    "2 .   for the immediate successor state @xmath112 of @xmath107 via @xmath113 , let @xmath114 and @xmath115 . if @xmath116 , let @xmath117 , else let @xmath118 . if @xmath119 , the subtree rooted at state @xmath107 is cut .",
    "repeat step b ) for each reached but unexplored state @xmath107 .",
    "output * : the supremal sublanguage @xmath120 that is controllable w.r.t . @xmath22 .    here",
    "@xmath121 is interpreted as the job @xmath65 execution time @xmath84 , where @xmath3 is the unique string labeling the path from the root state @xmath110 to state @xmath107 . since @xmath122 is a finite language , step 2 ) of the above algorithm clearly terminates .",
    "we immediately have the following result .",
    "+    let @xmath101 be the output of algorithm  [ algorithm1 ] .",
    "then @xmath123.@xmath63 +    _ proof _ : the proof is straightforward .",
    "in problem [ prob1 ] , if @xmath125 , it is desirable to synthesize a non - empty controllable sublanguage with minimum job earliness , by adding proper delays to the occurrences of some controllable transitions . to formalize this idea we need to introduce the concept of _ earliness of job @xmath65 completion ( under @xmath76)_. +    [ def : hard ] given a string @xmath72 and a job requirement @xmath126 such that @xmath83 and @xmath127",
    "the _ earliness _ of completing @xmath65 by @xmath3 ( under @xmath76 ) is defined as @xmath128 .",
    "accordingly , the _ earliness _ of completing @xmath98 by @xmath3 is defined as @xmath129 , if @xmath130.@xmath63 +    given any finite language @xmath131 , the _ earliness _ of @xmath132 w.r.t .",
    "@xmath98 is defined as @xmath133 .",
    "@xmath63 +    the earliness of the empty set is defined to be zero , i.e. , @xmath134 .",
    "if @xmath125 , it is always possible to compute a non - empty controllable sublanguage with minimum job earliness by adding delays . to introduce delays to the plant model we have the following construction . for a given @xmath135 , let @xmath136 be a weight function such that @xmath137 for @xmath138 and @xmath139 for @xmath140 .",
    "let @xmath141 be the collection of delays that satisfy above constraint . for each @xmath142 , the firing duration of each transition @xmath143",
    "is extended to @xmath144 , where @xmath145 is an _ extended weight function",
    "_ parameterized by @xmath146 .",
    "recall that , when there is no delay , to compute string execution time @xmath34 we need to bring in an induced morphism @xmath147 . after introducing the delay @xmath148 ,",
    "the induced morphism becomes @xmath149 . here for each @xmath41 we have    @xmath150    which can be used in computing the new string execution time @xmath151 .",
    "the computation of earliness is also affected accordingly and changed from @xmath152 to @xmath153 after adding the delay .",
    "the existence of the _ supremal minimum - earliness controllable job satisfaction sublanguage _ is ensured by the following proposition .",
    "+    [ supre ]    _ proof _ : intuitively @xmath154 is the union of the set of minimum earliness controllable job satisfaction sublanguages .",
    "the proof is straightforward .",
    "@xmath124 + we call @xmath154 the _ supremal minimum - earliness controllable job satisfaction sublanguage of @xmath155 under @xmath97 and @xmath98 _ , denoted as @xmath156 . in the remaining of this paper , when we write @xmath156 ,",
    "we implicitly assume @xmath157 and thus @xmath156 exists .",
    "the problem of ensuring minimum earliness of job completions by adding proper delays is formalized below .",
    "+    [ prob2 ] if problem [ prob1 ] has a non - empty solution , i.e. , @xmath158 , then compute a delay function @xmath159 such that @xmath160.@xmath63 +    to solve this problem , we introduce the following concept .",
    "+    a non - empty controllable sublanguage @xmath161 of @xmath132 , where @xmath162 , with respect to @xmath22 , if it exists , is said to be minimal if for any non - empty controllable sublanguage @xmath163 , @xmath164 implies @xmath165 .",
    "@xmath166 +    given a finite , non - empty language @xmath162 , let @xmath167 denote the collection of all non - empty minimal controllable sublanguages contained in @xmath132 with respect to @xmath22 .",
    "we need the following definitions and operations .",
    "a state @xmath107 in a finite state automaton is said to be a controllable ( respectively , an uncontrollable ) state if all the transitions out of @xmath107 are controllable ( respectively , uncontrollable ) .",
    "it is said to be a mixed state if there are both controllable and uncontrollable transitions out of state @xmath107 .",
    "the controllable transitions out of each mixed state are removed and each mixed state is thus transformed into an uncontrollable state .",
    "it is easy to see that this preprocessing stage does not affect the computation of @xmath167 .",
    "given a set of languages @xmath168 , we define a new set of languages @xmath169 for each @xmath170 . for two sets of languages @xmath171 , we define another set of languages @xmath172 .",
    "we propose the following algorithm to compute @xmath167 when @xmath132 itself is controllable with respect to @xmath22 .",
    "* input * : a trim tree - structured automaton @xmath173 such that @xmath174 2 .",
    "assign each leave node @xmath107 of @xmath175 with @xmath176 .",
    "3 .   for each node",
    "@xmath107 whose children have been assigned a set of languages , do the following until the root node is reached : 1 .",
    "if @xmath107 is a controllable state but not a final state , such that @xmath177 is its branches , then @xmath178}a_i\\mathcal{l}(q_i)$ ] ; 2 .",
    "if @xmath107 is both a controllable state and a final state , then @xmath178}a_i\\mathcal{l}(q_i ) \\cup \\{\\{\\epsilon\\}\\}$ ] ; 3 .",
    "if @xmath107 is an uncontrollable state , then @xmath179}a_i\\mathcal{l}(q_i)$ ] .",
    "* output * @xmath180 , where @xmath110 is the root of @xmath175 .    when @xmath132 is controllable with respect to @xmath22 , @xmath181 .",
    "@xmath63 +    _ proof _ : it is not difficult to show by structural induction that , @xmath182 is the set of minimal marked behaviors that can be enforced by a supervisor on @xmath175 when the initial state of @xmath175 is @xmath107 .",
    "then the set of minimal controllable sublanguages of @xmath132 will be @xmath180 , i.e. , @xmath181 .",
    "@xmath124 + with the above technical preparation , a solution to problem [ prob2 ] is provided in algorithm  [ algo : opt ] .",
    "it is likely that two different delays lead to the same earliness associated with two different supremal minimum - earliness controllable job satisfaction sublanguages .",
    "algorithm  [ algo : opt ] indeed computes the set of all such optimal delays .",
    "we need the following lemma .",
    "+    [ lemm : linear ] let @xmath3 be any string of @xmath95 . for each @xmath183",
    "$ ] , there exist @xmath184 and @xmath185 , both of which are functions that depend on @xmath148 , such that @xmath186}((c_j^i(s , d))^td+c_{j , 0}^i(s , d))$ ] , where @xmath148 is a @xmath187-tuple vector corresponding to the delay function . @xmath63",
    "+    _ proof _ : this immediately follows from the theory of heaps - of - pieces and the definition of job execution time .",
    "in fact , @xmath188 is the maximum of the resource time among the @xmath52 different resources and here the @xmath189-th resource time after the insertion of delay is representable by @xmath190 , where the only involved operations are weighted additions of firing duration of each transition ( after delay insertion ) .",
    "the reason why both @xmath191 and @xmath192 depend on @xmath148 is because the delay function influences the choice of the maximum in the computation of each resource time .",
    "@xmath124 +    1 .",
    "* input * : @xmath193 from problem 1 . 2 .",
    "compute @xmath167 using algorithm  [ algorithm2 ] .",
    "3 .   for each @xmath194 , solve the following optimization problem : @xmath195 subject to + @xmath196 let @xmath197 denote the collection of optimal delays for @xmath198 and @xmath199 denote the minimum earliness that is achievable by @xmath198 with delays .",
    "4 .   let @xmath200 .",
    "set @xmath201 .",
    "* output * : @xmath202 .     according to the monotonicity property of the earliness function ,",
    "we only need to look at those non - empty minimal controllable sublanguages of @xmath102 , i.e. , the languages in @xmath203 , and compute the optimal delays for them , which is shown in step 3 ) of algorithm  [ algo : opt ] .",
    "we have the following theorem .",
    "+    given a plant @xmath96 and requirements @xmath97 and @xmath98 , if @xmath125 , then algorithm  [ algo : opt ] solves problem 2 .",
    "@xmath63 +    _ proof _ : let @xmath204 be a solution of the optimization problem @xmath205 . according to the definition of the earliness function",
    ", there exists a non - empty controllable sublanguage @xmath206 such that @xmath207 .",
    "it is not difficult to see that @xmath208 and @xmath209 .",
    "thus @xmath210 . on the other hand , for any @xmath211 ,",
    "let @xmath212 be any solution of the optimization problem @xmath213 subject to the constraint @xmath214 . clearly , @xmath215 , since @xmath211 .",
    "thus @xmath216 .",
    "@xmath124 +   it is possible to compute the set of all optimal delays by reducing the optimization problem to solving a set of linear programs .",
    "the matlab toolbox * fminimax * for solving minimax constraint problem can be used for efficiently computing optimal delays with different initializations of @xmath148 . for each @xmath217",
    ", we could also compute the corresponding supremal minimum - earliness controllable job satisfaction sublanguage @xmath156 by proposition  [ supre ] .",
    "we remark that for different delays , the supremal minimum earliness controllable job satisfaction sublanguages could be different .",
    "if @xmath218 , then there is no controllable sublanguage of @xmath95 that satisfies all jobs and the imposed deadlines .",
    "if the supremal controllable sublanguage of @xmath219 is non - empty , then it means that some job deadlines need to be relaxed in order to have a non - empty controllable job satisfaction sublanguage .",
    "thus it is practically important to know the maximal sets of job deadlines that can be met .",
    "dually , we would like to compute the minimal sets of job deadlines that need to be relaxed .",
    "formally , the following problem is considered : +    [ prob3 ] given a plant @xmath96 and requirements @xmath97 , @xmath98 , determine all the subsets of job requirements @xmath220 such that +    1 .",
    "@xmath221 2 .",
    "@xmath222).@xmath63 +    note that @xmath223 , denoted as @xmath224 for convenience , is in general an infinite language , since the new job requirements @xmath225 does not satisfy @xmath226 .",
    "the system is allowed to continuously generate events in @xmath227 after all the jobs have been completed .",
    "the tree - structured automaton construction method does not work in this case .",
    "we propose the following algorithm , which is quite similar to algorithm  [ algorithm1 ] , to compute @xmath224 .",
    "+    1 .   * input * : a centralized model @xmath228 , requirements @xmath103 , @xmath229 and @xmath230 .",
    "2 .   compute the minimal finite automaton @xmath231 for @xmath106 .",
    "3 .   construct a finite automaton @xmath232 over @xmath33 by constructing a tree - structured automaton for @xmath233 with the following modifications , such that each string accepted by @xmath232 satisfies the job requirements @xmath234 : 1 .",
    "each state @xmath107 is maintained with a @xmath108-tuple @xmath109 , where @xmath3 is the unique string labeling the path from the root state @xmath110 to state @xmath107 .",
    "initially , @xmath111 .",
    "2 .   for the immediate successor state @xmath112 of @xmath107 via @xmath113",
    ", let @xmath114 and @xmath115 . if @xmath116 , let @xmath117 , else let @xmath118 . if @xmath235 , loop at state @xmath112 for each @xmath236",
    "if @xmath237 , the subtree rooted at state @xmath107 is cut .",
    "repeat step b ) for each reached but unexplored state @xmath107 .",
    "4 .   compute @xmath238 .",
    "* output * : the supremal sublanguage @xmath120 that is controllable w.r.t . @xmath22 .",
    "+    the step 2 ) of algorithm  [ algo : iv ] terminates and the output @xmath101 satisfies @xmath239.@xmath166 +    _ proof _ : the proof is straightforward .",
    "@xmath124 + problem  [ prob3 ] is now solved by examining all the elements of the lattice @xmath240 , starting from the bottom element @xmath241 to the top element @xmath68 . once an element , i.e , a subset of @xmath68 , is found to be a solution",
    ", there is no need to examine all the greater elements . in general",
    ", there could be different solutions to problem  [ prob3 ] that are incomparable .",
    "to illustrate above setup , a simplified job shop depicted in fig .",
    "[ job_shop ] is used .",
    "[ job_shop ]    it consists of one i / o ( input / output ) buffer for feeding raw materials and dropping out those processed ones .",
    "there are two machines ( m1 and m2 ) that process the raw materials , and one robot that performs tasks of loading and unloading of parts . in this example",
    ", we deal with two types of product ( @xmath242 and @xmath243 ) and accordingly , based on product type , machines actions are differentiated . the timed - weighted model for each component",
    "is shown in fig .",
    "[ component ] .        [ component ]",
    "we assume that all events of @xmath244 are controllable , and the mutual exclusion relation is @xmath245 . in this example , to have the complete products , both parts are required to go through @xmath246 .",
    "let @xmath247 , where @xmath248 and @xmath249 are job requirements for product type @xmath242 and type @xmath243 respectively .",
    "the logic requirement and job requirements are depicted in fig .",
    "[ requirement ] .        [ requirement ]    upon applying algorithm  [ algorithm1 ]",
    ", we can compute the supremal controllable job satisfaction sublanguage , which is depicted in fig .",
    "[ supervisor ] .        [ supervisor ]",
    "we can easily see that the result of problem  [ prob1 ] consists of 5 non - empty minimal controllable sublanguages - each one is a singleton .",
    "the completion time of @xmath248 and @xmath249 for different strings are as follows : ( we order the strings from left to right )    for @xmath250 , t_{j_1 , f}(s_i)=16 , t_{j_2 , f}(s_i)=10 $ ] and for string @xmath251 .",
    "clearly @xmath252 for all @xmath250 $ ] and @xmath253 , thus @xmath254 is the supremal minimum - earliness controllable job satisfaction sublanguage .",
    "if delay functions are considered , it is easy to see that the achievable minimum earliness is zero .",
    "indeed , it suffices to check that if we choose @xmath204 such that @xmath255 , @xmath256 , and for all @xmath257 , then @xmath258 . here",
    ", we use events instead of transitions to specify @xmath148 as there is a clear one to one map between them in this example .",
    "in this paper we address the problem of timed control for multiple job deadlines .",
    "we have first introduced the concept of supremal controllable job satisfaction sublanguage , and provided algorithms to compute such a supremal sublanguage . considering that in practical applications large job earliness is usually undesirable , we have introduced the concept of supremal controllable minimum - earliness job satisfaction sublanguage , which ensures minimum job earliness by adding delays in properly chosen transition firings . in case that there does not exist a non - empty controllable job satisfaction sublanguage ,",
    "we have proposed an algorithm to compute the minimal sets of deadlines that need to be relaxed .          c.  m.  hino ,",
    "d.  p.  ronconi and a.  b.  mendes . minimizing earliness and tardiness penalties in a single - machine problem with a common due date .",
    "_ european journal of operational research _ , 160(1):190201 , 2005 .",
    "g.  behrmann , e.  brinksma , m.  hendriks and a.  mader .",
    "production scheduling by reachability analysis - a case study . in _ proc .",
    "19th ieee international parallel and distributed processing symposium _ , pages 140a140a , 2005 ."
  ],
  "abstract_text": [
    "<S> in this paper we model an operational planning and scheduling problem under multiple job deadlines in a time - weighted automaton framework . </S>",
    "<S> we first present a method to determine whether all given job specifications and deadlines can be met by computing a supremal controllable job satisfaction sublanguage . when this supremal sublanguage is not empty , we compute one of its controllable sublanguages that ensures the minimum total job earliness by adding proper delays . </S>",
    "<S> when this supremal sublangauge is empty , we will determine the minimal sets of job deadlines that need to be relaxed .    </S>",
    "<S> _ index terms _  time - weighted automaton , controllability , scheduling , earliness , timed supervisory control </S>"
  ]
}