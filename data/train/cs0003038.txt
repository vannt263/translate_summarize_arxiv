{
  "article_text": [
    "one of the most important areas in artificial intelligence is knowledge representation .",
    "traditional logic programming has proven itself to be a powerful tool for knowledge representation .",
    "there are , however , limitations to the expressibility of traditional logic programming . in an attempt to overcome some of the these limitations , new logic programming formalisms were introduced .",
    "these new formalisms expand the traditional formalism by including disjunction @xcite , classical negation @xcite , or both ( in the case of extended disjunctive logic programs)@xcite .",
    "these formalisms work well for certain classes of programs .",
    "unfortunately , these formalisms do not always allow for the correct representation of incomplete information in the presence of multiple belief sets . as an attempt at solving this problem ,",
    "the language of epistemic specifications was introduced @xcite .",
    "a good overview of each of the formalisms mentioned above can be found in @xcite .    as is usual with logic programming languages ,",
    "the problem of answering queries is intractable in the general case .",
    "it is often useful , however , to find methods which simplify the query answering task for certain subclasses of programs . in @xcite , the usefulness of splitting sets for the investigation of answer sets",
    "was shown . in this paper",
    "we will present an extended definition of splitting sets that will be applicable to epistemic specifications .",
    "this in turn leads to an extension of the splitting set theorem from @xcite . as with edlps",
    ", there is a strong relationship between stratification and splitting sets . using these ideas",
    ", we can develop an algorithmic method for computing world views of a subclass of epistemic logic programs .",
    "an overview of the syntax and semantics of epistemic specifications is covered in section 2 . in section 3",
    "we present splitting sets for epistemic specifications and the main theorem of the paper , the splitting set theorem .",
    "finally , section 4 contains a discussion of stratification , how it is related to splitting sets , and an algorithm for computing world views of stratified programs which is based the splitting set theorem .",
    "the language of epistemic specifications is an extension of the language of extended disjunctive logic programs ( edlps ) .",
    "in addition to the normal operators in edlps , the language of epistemic specifications also contains unary modal operators @xmath0 and @xmath1 .",
    "@xmath0 should be read as _ `` is known to be true '' _ while @xmath1 is read as _ `` may be believed to be true''_. atoms are defined in the usual way .",
    "literals in the language of epistemic specifications are split into two types , _ objective literals _ and _ subjective literals_. an _ objective literal _ is either an atom or an atom preceded by @xmath2 ( classical negation ) .",
    "a _ subjective literal _ is an objective literal preceded by @xmath0 , @xmath1 , @xmath3 , or @xmath4 . given an objective literal , @xmath5 , we will refer to the set of four subjective literals that can be built from @xmath5 as @xmath6 .",
    "given a set of objective literals , @xmath7 , @xmath8 and @xmath9 .",
    "the general form for rules in epistemic specifications is given in @xcite .",
    "in this paper we will restrict rules to the form :    @xmath10    where @xmath11 are objective literals , @xmath12 are either objective or subjective literals , and @xmath13 are objective literals .",
    "this form differs from the original only in the fact that in @xcite , @xmath14 were also allowed to be subjective literals .",
    "notice however that for any subjective literal , @xmath15 , the value of @xmath15 can never be unknown and hence @xmath16 is always equivalent to @xmath17 .",
    "it can therefore easily be seen that the restricted form of rules above can be used without any loss of expressibility .",
    "a collection of such rules will be referred to as an _ epistemic logic program _ or an _ epistemic specification_. given a rule , @xmath18 ,    * @xmath19 refers to the the set of literals , @xmath20 which occur in the head of the rule .",
    "* @xmath21 refers to the set of all objective literals , @xmath5 , such that either * * @xmath22 for some @xmath23 , or * * @xmath24 for some @xmath23 . * @xmath25 refers to the set of literals , @xmath26 . * @xmath27 .    given a epistemic logic program , @xmath28 , @xmath29 will denote the union of the sets @xmath30 for all @xmath31 .",
    "we now move from the syntax of the language to the semantics .",
    "a rule with variables is considered to be a shorthand for the set of all ground instances of the rule .",
    "the truth or falsity of a literal in an epistemic logic program is determined by the _ world views _ of that program .",
    "a _ world view _ is a collection of sets of ground objective literals which satisfy certain properties .",
    "an objective literal , @xmath5 , is true with respect to a collection of sets of literals , @xmath32 , if it is true in each set in that collection ( i.e. for each set @xmath33 , @xmath34 ) .",
    "if @xmath32 is a collection of sets of objective literals and @xmath5 is an objective literal then    * @xmath35 is true with respect to @xmath32 ( denoted @xmath36 ) iff for each set @xmath33 , @xmath34 , * @xmath37 iff there exists an @xmath33 such that @xmath34 , * @xmath38 iff @xmath39 , and * @xmath40 iff @xmath41 .",
    "a literal is true with respect to an epistemic logic program if it is true in every _ world view _ of that program .",
    "we will define the concept of a _ world view _ of an epistemic logic program in several steps .",
    "first let us consider the case when @xmath28 is an epistemic logic program which does not contain @xmath42 and does not contain any subjective literals .",
    "a set of literals , @xmath43 , is called a _",
    "belief set _ of @xmath28 iff @xmath43 is a minimal set satisfying the following two conditions :    * for every rule @xmath44 if @xmath45 then @xmath46 such that @xmath47 , * if @xmath43 contains a pair of contrary literals then @xmath48 .",
    "( this belief set is called _",
    "inconsistent_. )    next we consider an epistemic logic program , @xmath28 , which contains @xmath42 but does not contain subjective literals ( such programs are extended disjunctive logic programs ) . for",
    "any such @xmath28 and any set @xmath49 , let @xmath50 be the program obtained from @xmath28 by deleting    * each rule that contains @xmath51 in its body where @xmath34 , and * all formulas of the form @xmath51 in the bodies of the remaining rules .",
    "the resultant program @xmath50 does not contain @xmath42 or subjective literals and therefore its belief sets are as defined above .",
    "we will say a set , @xmath43 , of literals is a belief set of @xmath28 if @xmath43 is a belief set of @xmath50 .    finally , let @xmath28 be an arbitrary epistemic logic program .",
    "let , @xmath32 , be any collection of sets of literals from @xmath29 and let @xmath52 be the program obtained by    * removing each rule which contains a subjective literal , @xmath5 , where @xmath53 , and * removing all subjective literals from the bodies of the remaining rules .",
    "notice that @xmath52 does not contain subjective literals , therefore we can compute its belief sets as previously described . if @xmath32 is the set of all of the belief sets of @xmath52 then @xmath32 is a world view of @xmath28 .",
    "we will say that a world view of an epistemic logic program is _ consistent _ if it does not contain a belief set consisting of all literals .",
    "we will say an epistemic logic program is _ consistent _ if it has at least one consistent non - empty world view .    intuitively , a belief set is a set of literals that a rational agent may believe to be true .",
    "a world view is a set of belief sets that a rational agent may believe to be true with respect to that `` world '' .",
    "the following give examples of epistemic logic programs and their world views .",
    "let @xmath54 be the program which consists of the rules :    1 .",
    "@xmath55 2 .",
    "@xmath56 3 .",
    "@xmath57 4 .",
    "@xmath58    the set @xmath59 consisting of two belief sets , can be shown to be the only world view of @xmath54 .",
    "for the next example , consider the program , @xmath60 , consisting of the following two rules :    1 .",
    "@xmath61 2 .",
    "@xmath62    it can be seen that @xmath60 has two world views : @xmath63 and @xmath64 .    as a final example , consider the program , @xmath65 consisting of only one rule , @xmath66 it can be shown that this program does not have a world view .    in general , to find the world view of a epistemic logic program one must either try all possible collections of sets of literals or guess .",
    "it is infeasible to try all combinations since , even for the case where the number of ground literals , @xmath67 , is finite , there are @xmath68 possibilities . a guess - and - check method could possibly be used to find world views but the problem is how to create an algorithm which would make good `` educated '' guesses and would know when and if it has found all the of the world views .    in this paper , we are primarily interested in presenting a means of computing world views . as a first step in achieving this goal , we will limit ourselves to programs which have at most a finite number of world views . for the remainder of this paper we will only consider epistemic logic programs which do not contain function symbols and have a finite number of constants and predicate symbols .",
    "in this section we will present a definition of splitting sets of epistemic logic programs .",
    "the definition is an extension of the definition in @xcite .",
    "we will also present a version of the splitting set theorem that is applicable to epistemic logic programs .    a set , @xmath7 , of objective literals is a _ splitting set _ of a epistemic logic program , @xmath28 , iff    * for every rule @xmath69 , if @xmath70 then @xmath71 , and , * if @xmath28 contains @xmath0 or @xmath1 , then for any objective literal , @xmath72 , if @xmath73 then @xmath74 .",
    "if @xmath7 is a splitting set of @xmath28 , we also say that @xmath7 splits @xmath28 .",
    "the set of all rules @xmath69 such that @xmath75 is denoted by @xmath76 and is called the _ bottom _ of @xmath28 with respect to @xmath7 .",
    "the set @xmath77 is called the _ top _ of @xmath28 with respect to @xmath7 .    using a splitting set",
    ", one can break the computation of a world view of an epistemic specification into two parts , a bottom and a top .",
    "the basic idea is to first compute the world view of the bottom of the program .",
    "the world view of the top can then be computed , taking into consideration the what was already computed for the bottom .",
    "finally the two parts are merged together to get the world view of the complete program .",
    "the world view of the bottom can be computed without regard to the top since no literal which occurs in the head of a rule of the top can occur anywhere in the bottom . when computing the world view for the top however , one needs to take the world view of the bottom into consideration .",
    "the world view of the bottom of the program can be used to `` reduce '' the top of the program .",
    "we can remove from the top those rules which can not be satisfied because the value of a literal computed in the bottom makes their bodies false . from the remaining rules",
    "one can remove the portions of the bodies of the rules that were determined to be true .",
    "the reduction is performed in two steps ; one for subjective literals and one for objective ones .    to remove subjective literals we will introduce the idea of a _ restricted reduct_.",
    "let @xmath28 be an + epistemic logic program , @xmath32 be a collection of sets of literals , and @xmath7 be a set of literals .",
    "the _ restricted reduct _ is the program obtained from @xmath28 by :    1 .   removing from @xmath28 all rules containing subjective formulae @xmath78 where @xmath79 and @xmath80 .",
    "2 .   removing all other occurrences of subjective formula @xmath78 where @xmath79 .",
    "the resultant program will be denoted by @xmath81 and be referred to as the _ reduct _ of @xmath28 with respect to @xmath32 , _ restricted _ by @xmath7 .    in our intended use , @xmath28 ,",
    "would be the top of a program , @xmath7 , would be the set used to split the program , and @xmath32 would be the world view of the bottom .",
    "the following is an example of a restricted reduct .",
    "mmm = mmmmm = let @xmath82 @xmath83 , + @xmath84 @xmath85 , and + @xmath86 @xmath87 + @xmath88 + @xmath89 + @xmath90 + then @xmath91 @xmath92 + @xmath93    next we consider objective literals .",
    "recall that the world view of the bottom of a program is in essence a set of belief sets , all of which are different .",
    "because of this , the truth or falsity of the objective literals in the bodies of rules of the top may vary with respect to each belief set . due to this fact ,",
    "after performing the reduction described below , rather than being left with a single program , we have , in general , a different partially evaluated top for each belief set of the bottom .    given two sets of objective literals , @xmath7 and @xmath94 , and an epistemic specification , @xmath28 , for which none of the literals from @xmath7 or @xmath94 occur subjectively in its rules , then @xmath95 : @xmath96 rule @xmath69 such that @xmath97 and @xmath98 is disjoint from @xmath94 , @xmath99 is the rule which results from removing each sub - formula of the form @xmath5 or @xmath100 from @xmath18 , where @xmath101 .",
    "we refer to @xmath102 as the _ partial evaluation _ of @xmath28 with respect to @xmath94 .    here again , in our intended use @xmath28 would be the top of the program , @xmath7 would be the splitting set used , and @xmath94 would be one of belief sets from the world view of the bottom .",
    "as was mentioned above , after taking the restricted reduct of the top and then finding the partial evaluation of the result with respect to each of the belief sets of the bottom , we are often left with multiple `` tops '' .",
    "we can not simply take the world view of each `` top '' and merge them together .",
    "the reason for this is that it does not guarantee that the truth of subjective literals in the merged world view are the same as they were in each `` top '' . to handle this problem",
    "we introduce the idea of a _ multi - view_.    given epistemic logic + programs @xmath103 , then a collection of sets of objective literals , @xmath32 , is a _ multi - view _ of @xmath103 iff    1 .",
    "@xmath104 ( if @xmath105 s.t .",
    "@xmath106 is consistent ) 2 .",
    "@xmath107 ( otherwise )    a multi - view , @xmath32 , is _ consistent _ iff @xmath108 .",
    "for each @xmath109 , the set of all belief sets of @xmath110 is called the _ restricted view of @xmath109 with respect to w_.    here a simple example of a multi - view .       mmmmm = mmm = mmm = if @xmath111 @xmath112 + @xmath113 + @xmath114 + and @xmath115 @xmath116 + @xmath114    then @xmath117 has only one multi - view , \\{\\{a , b},\\{a}}.    before we present the main theorem of the paper we must first present a new notation and a definition .",
    "given a collection of sets of objective literals , @xmath32 , and a set of literals , @xmath7 , then @xmath118    given an epistemic specification @xmath28 with splitting set @xmath7 such that @xmath119 and @xmath120 , @xmath28 is said to be _ safe with respect to u _",
    "iff @xmath121 if @xmath122 then @xmath123 is consistent .",
    "let @xmath28 be an epistemic specification , @xmath7 be a splitting set of @xmath28 such that @xmath28 is safe with respect to @xmath7 . if we denote @xmath76 as @xmath124 , and @xmath125 as @xmath126 then :    1 .",
    "if @xmath127 is a consistent world view of @xmath124 and @xmath128 is a consistent multi - view of @xmath129 then if @xmath130 , where @xmath131 and @xmath132 is consistent @xmath133 then @xmath32 is a consistent world view of @xmath28 .",
    "if @xmath32 is a consistent world view of @xmath28 then @xmath134 such that @xmath94 is a world view of @xmath124 , @xmath128 is a multi - view of @xmath129 and @xmath135 and @xmath136    in the above theorem we require that the splitting set be safe with respect to the program .",
    "as we will show , this restriction is important .",
    "if one or more or the belief sets of the bottom does not have a consistent extension to the top , the value of subjective literals defined in the bottom may change . in this case , the above method may not compute a correct world view .    consider the program , @xmath137 , with the following rules :    1 .",
    "@xmath55 2 .",
    "@xmath138 3 .",
    "@xmath139 4 .",
    "@xmath140    if we split the program using @xmath141 as a splitting set , then @xmath142 , which consists of rules 1 and 2 , has one world view which contains 2 belief sets , @xmath143 and @xmath144 .",
    "with respect to the belief set @xmath144 , however , the top of the program is inconsistent . using the method from the theorem above ,",
    "not requiring the program be safe , we get one `` world view '' : @xmath145 .",
    "it can easily be seen however , that this is not a world view of @xmath137 .",
    "the only world view of the program is @xmath146 .",
    "the error occurred because , since @xmath147 was `` possible '' in the world view the bottom we concluded @xmath148 was therefore true even though we later find that @xmath147 is no longer `` possible '' after the computation of the top .    as can be seen from the definition , determining",
    "if a splitting set of a program is safe may be as difficult as finding the world views .",
    "we will give a property which is more intuitive and easier to check .",
    "while it is less general , it is reasonable and encompasses a large number of interesting programs .",
    "before we present the condition , we must first define _",
    "satisfies_.    given a program @xmath28 and a collection of sets of literals from @xmath29 , denoted @xmath32 , then we will say @xmath32 _ satisfies _ the body of a rule , @xmath69 , if each literal in the body is true with respect to @xmath32 .",
    "we say @xmath32 satisfies @xmath18 if either @xmath32 does not satisfy the body of @xmath18 or at least one literal in the head of @xmath18 is true with respect to @xmath32 .",
    "we now present the property .",
    "we will say that a program @xmath28 is _ guarded _ with respect to a splitting set @xmath7 if    * @xmath28 does not contain subjective literals , or * for every pair of rules @xmath149 and for every collection of sets of literals from @xmath29 , denoted as @xmath32 , if @xmath150 and @xmath151 contain contrary literals and @xmath32 satisfies all of the rules in @xmath76 then either @xmath32 does not satisfy the body of @xmath152 or @xmath32 does not satisfy the body of @xmath153 . note that a rule with an empty head can be rewritten as a rule which has the predicate @xmath154 as the head and by adding the rule @xmath155 to the program .",
    "a program containing rules with empty heads is guarded with respect to @xmath7 if the program rewritten without such rules is .",
    "it can be shown that , given any program @xmath28 with splitting set @xmath7 , if @xmath28 is guarded with respect to @xmath7 then @xmath7 is safe with respect to @xmath28 .",
    "in this section we will give a definition of stratification for epistemic logic programs , show how it relates to splitting sets , and illustrate how the splitting set theorem can be used to simplify the computation of the world view of a stratified epistemic logic program .",
    "we will start out with the definition of stratification .",
    "a partitioning @xmath156 of the set of all literals of an epistemic logic program , @xmath28 , is a _ stratification _ of @xmath28 , if for any literal , @xmath157 , then @xmath158 and for any other literal @xmath159 in @xmath29 and any rule @xmath69 :    * if @xmath160 then @xmath161 . * if @xmath162 and @xmath159 occurs objectively in @xmath21 then there exists an @xmath163 such that @xmath164 . *",
    "if @xmath162 and @xmath165 or @xmath159 occurs subjectively in @xmath18 , then there exists @xmath166 such that @xmath164 .",
    "this stratification of the literals defines a stratification of the rules of @xmath28 to strata @xmath167 where a strata @xmath109 contains all of the rules of @xmath28 whose heads consists of literal from @xmath168 .",
    "a program is called _ stratified _ if it has a stratification .",
    "it can easily be seen that , given a stratified epistemic logic program , @xmath28 , with stratification @xmath169 , the set of literal @xmath170 such that @xmath171 is a splitting set of @xmath28 . with each stratified epistemic logic program",
    "we will then associate a sequence @xmath172 of splitting sets formed as described .",
    "this leads us to an algorithm for computing the world view a safe , stratified epistemic specification .",
    "given an epistemic specification , @xmath28 , with stratification @xmath173 and associated splitting sets @xmath174 , such that @xmath28 is safe with respect to @xmath175 and each @xmath170 , we can compute the world view of @xmath28 as follows :    1 .",
    "using the splitting set theorem , compute the world view , @xmath176 , of @xmath177 with splitting set @xmath178 .",
    "note that @xmath179 and , by the definition of stratification , it does not contain @xmath42 or any subjective literals .",
    "@xmath180 is also safe with respect to @xmath175 .",
    "from these two facts , it can be seen that @xmath180 has a unique , consistent , world view which consists of all the belief sets of the edlp @xmath180 .",
    "given the world view , @xmath181 , of @xmath182 , the world view , @xmath183 , of @xmath184 can be computed using the splitting set theorem with the splitting set @xmath185 .",
    "notice that @xmath186 is the world view of @xmath28 .",
    "it can be seen from the definition of stratification that , in each step of the algorithm above , when we take the restricted reduct of the top of program we are left with a program which does not contain subjective literals .",
    "the multi - view is therefore simply the union of the world views obtained by taking the restricted reduct of the top and partially evaluating with respect to one of the belief sets of the world view of the bottom . to compute the world view of a safe , stratified , epistemic logic program therefore ,",
    "one only needs to be able to compute the belief sets of extended disjunctive logic programs .    the following theorem , which is a slightly modified version of a theorem from @xcite , also follows from the results above .    given any stratified , epistemic logic program , @xmath28 , which is safe with respect to @xmath175 as well as each of the splitting sets associated with its stratification , the program @xmath28 has a unique , consistent , world view .",
    "in this paper , we expanded the results from @xcite to include epistemic logic programs .",
    "we also presented definitions of what it means for a epistemic logic program to be _ safe _ , _ guarded _ , and _",
    "stratified_. this led to an algorithmic method for computing world views of a subclass of epistemic logic programs .",
    "it should be noted that the belief sets of an extended disjunctive logic program are simply the answer sets @xcite of that program .",
    "recently , there have been considerable advances in the computation of such answer sets .",
    "one such system which shows great promise is dlv @xcite . using their system and the results in this paper",
    ", it should be a reasonable task to create a inference engine for the subclass of epistemic logic programs mentioned here .    as this paper",
    "is meant to form a basis for the computation of world views , we restricted ourselves to epistemic logic programs with a finite number of finite world views .",
    "we believe that the theorem presented here can be expanded to cover programs with an infinite number of infinite world views .",
    "the author would like to thank michael gelfond and the anonymous reviewers for their helpful comments .",
    "mmm95 chitta baral and michael gelfond . logic programming and knowledge representation . in _ journal of logic programming _ , 1994 nicola leone et al . the dlv system : model generator and application frontends . in _ proceedings of the 12th workshop on logic programming _ , pages 128 - 137 , 1997 .",
    "michael gelfond .",
    "strong introspection . in _ proceedings of aaai-91",
    "_ , pages 386 - 391 , 1991 .",
    "michael gelfond . logic programming and reasoning with incomplete information . in _ annals of mathematics and artificial intelligence _ ,",
    "12 , pages 89 - 116 , 1994 .",
    "michael gelfond and vladimir lifschitz .",
    "logic programs with classical negation . in _ logic programming : proceedings of the 7th international conference _ , pages 579 - 597 , 1990 .",
    "michael gelfond and vladimir lifschitz .",
    "classical negation in logic programs and disjunctive databases . in _ new world computing _ , pages 365 - 387 , 1991 .",
    "michael gelfond and halina pryzmusinska .",
    "definitions in epistemic specifications . in _ logic programming and non - monotonic reasoning , proceedings of the first international workshop _ , pages 245 - 259 , 1991 .",
    "vladimir lifschitz and hudson turner .",
    "splitting a logic program . in _ proceedings of the eleventh international conference on logic programming _ ,",
    "pages 23 - 37 , 1994 .",
    "jack minker . on indefinite databases and the closed world assumption . in _ proceedings of cade-82",
    "_ , pages 292 - 308 , 1982 .",
    "richard watson .",
    "an inference engine for epistemic specifications , 1994 .",
    "thesis , department of computer science , university of texas at el paso ."
  ],
  "abstract_text": [
    "<S> over the past decade a considerable amount of research has been done to expand logic programming languages to handle incomplete information . </S>",
    "<S> one such language is the language of epistemic specifications . as is usual with logic programming languages , </S>",
    "<S> the problem of answering queries is intractable in the general case . for extended disjunctive logic programs , </S>",
    "<S> an idea that has proven useful in simplifying the investigation of answer sets is the use of splitting sets . in this paper </S>",
    "<S> we will present an extended definition of splitting sets that will be applicable to epistemic specifications . </S>",
    "<S> furthermore , an extension of the splitting set theorem will be presented . </S>",
    "<S> also , a characterization of stratified epistemic specifications will be given in terms of splitting sets . </S>",
    "<S> this characterization leads us to an algorithmic method of computing world views of a subclass of epistemic logic programs .    </S>"
  ]
}