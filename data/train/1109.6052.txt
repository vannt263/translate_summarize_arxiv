{
  "article_text": [
    "the distributed constraint satisfaction problem has become a very useful representation that is used to describe a number of problems in multi - agent systems including distributed resource allocation @xcite and distributed scheduling @xcite .",
    "some researchers in cooperative multi - agent systems have focused on developing methods for solving these problems that are based on one key assumption . particularly , the agents involved in the problem solving process are autonomous .",
    "this means that the agents are only willing to exchange information that is directly relevant to the shared problem and retain the ability to refuse a solution when it obviously conflicts with some internal goal .",
    "these researchers believe that the focus on agent autonomy precludes the use of centralization because it forces the agents to reveal all of their internal constraints and goals which may , for reasons of privacy or pure computational complexity , be impossible to achieve .",
    "several algorithms have been developed with the explicit purpose of allowing the agents to retain their autonomy even when they are involved in a shared problem which exhibits interdependencies .",
    "probably the best known algorithms that fit this description can be found in the work of yokoo et al . in the form of distributed breakout ( dba )",
    "@xcite , asynchronous backtracking ( abt ) @xcite , and asynchronous weak - commitment ( awc ) @xcite .",
    "unfortunately , a common drawback to each of these algorithms is that in an effort to provide the agents which * complete privacy * , these algorithms prevent the agents from making informed decisions about the global effects of changing their local allocation , schedule , value , etc .",
    "for example , in awc , agents have to try a value and wait for another agent to tell them that it will not work through a @xmath0 message .",
    "because of this , agents never learn true reason why another agent or set of agents is unable to accept the value , they only learn that their value in combination with other values does nt work .",
    "in addition , these techniques suffer because they have complete distribution of the control .",
    "in other words , each agent makes decisions based on its incomplete and often inaccurate view of the world .",
    "the result is that this leads to unnecessary thrashing in the problem solving because the agents are trying to adapt to the behavior of the other agents , who in turn are trying to adapt to them .",
    "pathologically , this behavior can be counter - productive to convergence of the protocol@xcite .",
    "this iterative trial and error approach to discovering the implicit and implied constraints within the problem causes the agents to pass an exponential number of messages and actually reveals a great deal of information about the agents constraints and domain values @xcite .",
    "in fact , in order to be complete , agents using awc have to be willing to reveal all of their _ shared _ constraints and domain values . the key thing to note about",
    "this statement is that awc still allows the agents to retain their autonomy even if they are forced to reveal information about the variables and constraints that form the global constraint network .    in this paper",
    ", we present a _ cooperative mediation _ based dcsp protocol , called asynchronous partial overlay ( apo ) .",
    "cooperative mediation represents a new methodology that lies somewhere between centralized and distributed problem solving because it uses dynamically constructed , partial centralization .",
    "this allows cooperative mediation based algorithms , like apo , to utilize the speed of current state - of - the - art centralized solvers while taking advantage of opportunities for parallelism by dynamically identifying relevant problem structure .",
    "apo works by having agents asynchronously take the role of mediator .",
    "when an agent acts as a mediator , it computes a solution to a portion of the overall problem and recommends value changes to the agents involved in the _ mediation session_. if , as a result of its recommendations , it causes conflicts for agents outside of the session , it links with them preventing itself from repeating the mistake in future sessions .    like awc",
    ", apo provides the agents with a great deal of autonomy by allowing anyone of them to take over as the mediator when they notice an undesirable state in the current solution to the shared problem . further adding to their autonomy",
    ", agents can also ignore recommendations for changing their local solution made by other agents . in a similar way to awc",
    ", apo is both sound and complete when the agents are willing to reveal the domains and constraints of their shared variables and allows the agents to obscure the states , domains , and constraints of their strictly local variables .    in the rest of this article",
    ", we present a formalization of the dcsp problem ( section [ apo : dcsp ] ) . in section [ assumptions ] , we describe the underlying assumptions and motivation for this work .",
    "we then present the apo algorithm ( section [ apo : protocol ] ) and give an example of the protocol s execution on a simple 3-coloring problem ( section [ apo : example ] ) .",
    "we go on to give the proofs for the soundness and completeness of the algorithm ( section [ apo : proof ] ) . in section [ apo :",
    "evaluation ] , we present the results of extensive testing that compares apo with awc within the distributed graph coloring domain and the complete compatibility version of the sensordcsp domain @xcite across a variety of metrics including number of cycles , messages , bytes transmitted , and serial runtime . in each of these cases , we will show that apo significantly outperforms awc @xcite .",
    "section [ summary ] summarizes the article and discusses some future research directions .",
    "a constraint satisfaction problem ( csp ) consists of the following :    * a set of _ n _ variables @xmath1 . * discrete , finite domains for each of the variables @xmath2 . * a set of constraints @xmath3 where each @xmath4 is a predicate on the cartesian product @xmath5 that returns true iff the value assignments of the variables satisfies the constraint .",
    "the problem is to find an assignment @xmath6 such that each of the constraints in @xmath7 is satisfied .",
    "csp has been shown to be np - complete , making some form of search a necessity .    in the distributed case , dcsp , using variable - based decomposition ,",
    "each agent is assigned one or more variables along with the constraints on their variables .",
    "the goal of each agent , from a local perspective , is to ensure that each of the constraints on its variables is satisfied . clearly , each agent s goal is not independent of the goals of the other agents in the system .",
    "in fact , in all but the simplest cases , the goals of the agents are strongly interrelated .",
    "for example , in order for one agent to satisfy its local constraints , another agent , potentially not directly related through a constraint , may have to change the value of its variable .    in this article , for the sake of clarity , we restrict ourselves to the case where each agent is assigned a single variable and is given knowledge of the constraints on that variable . since each agent",
    "is assigned a single variable , we will refer to the agent by the name of the variable it manages .",
    "also , we restrict ourselves to considering only binary constraints which are of the form @xmath8 . since apo uses centralization as its core , it is easy to see that the algorithm would work if both of these restrictions are removed .",
    "this point will be discussed as part of the algorithm description in section [ apo : remove ] .    throughout this article",
    ", we use the term _ constraint graph _ to refer to the graph formed by representing the variables as nodes and the constraints as edges . also , a variable s _ neighbors _ are the variables with which it shares constraints .",
    "the following are the assumptions made about the environments and agents for which this protocol was designed :    1 .",
    "agents are situated , autonomous , computing entities . as",
    "such , they are capable of sensing their environment , making local decisions based on some model of intentionality , and acting out their decisions .",
    "agents are rationally and resource bounded . as a result",
    ", agents must communicate to gain information about each others state , intentions , decisions , etc .",
    "agents within the multi - agent system share one or more joint goals . in this paper , this goal is boolean in nature stemming from the dcsp formulation .",
    "3 .   because this work focuses on cooperative problem solving , the agents are cooperative .",
    "this does not necessarily imply they will share all of their state , intentions , etc . with other agents , but are , to some degree , willing to exchange information to solve joint goals .",
    "it also does not imply that they will change their intentions , state , or decisions based on the demands of another agent .",
    "agents still maintain their autonomy and the ability to refuse or revise the decisions of other agents based on their local state , intentions , decisions , etc .",
    "4 .   each agent has the capability of computing solutions to the joint goal based on their potentially limited rationality .",
    "this follows naturally from the ability of agents to make their own decisions , i.e. , every agent is capable of computing a solution to its own portion of the joint goal based on its own desires .",
    "the websters dictionary defines the act of mediating as follows :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ * mediate * : 1 . to act as an intermediary ; especially to work with opposing sides in order to resolve ( as a dispute ) or bring about ( as a settlement ) .  2 .  to bring about , influence , or transmit by acting as an intermediate or controlling agent or mechanism . @xcite _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    by its very definition , mediation implies some degree of centralizing a shared problem in order for a group of individuals to derive a conflict free solution .",
    "clearly in situations where the participants are willing ( cooperative ) , mediation is a powerful paradigm for solving disputes .",
    "it s rather strange , considering this , that very little has been done on looking at mediation as a cooperative method for solving dcsps .    probably , the earliest mediation - based approach for solving conflicts amongst agents in an airspace management application@xcite .",
    "this work investigates using various conflict resolution strategies to deconflict airspace in a distributed air traffic control system .",
    "the author proposes a method for solving disputes where the involved agents elect a leader to solve the problem .",
    "once elected , the leader becomes responsible for recognizing the dispute , devising a plan to correct it , and acting out the plan .",
    "various election schemes are tested , but unfortunately , the leader only has authority to modify its own actions in order to resolve the conflicts .",
    "this obviously leads to situations where the plan is suboptimal .    in @xcite ,",
    "the authors describe mediation as one of a number possible coordination mechanisms . in this work ,",
    "the mediator acts as a intermediary between agents and can also act to coordinate their behavior . as an intermediary ,",
    "the mediator routes messages , provides directory services , etc .",
    "this provides for a loose coupling of the agents , since they only need to know the mediator .",
    "the mediator can also act to coordinate the agents behavior if they have tight interdependencies .",
    "most of the research work on mediation - based problem solving involved settling disputes between competitive or semi - competitive agents .",
    "probably one of the best examples of using mediation in this manner can be found in the persuader system@xcite .",
    "persuader was designed to settle conflicts between adversarial parties that are involved in a labor dispute .",
    "persuader uses case - based reasoning to suggest concessions in order to converge on a satisfactory solution .",
    "another example of using mediation in this way can be found in in a system called designer fabricator interpreter ( dfi ) @xcite . in dfi",
    ", mediation is used to resolve conflicts as one of a series of problem solving steps .",
    "whenever the first step fails , in this case iterative negotiation , a mediator agent steps in and tries to convince the agents to relax their constraints . if this fails , the mediator mandates a final solution",
    ".    there may be several reasons why mediation has not been more deeply explored as a cooperative problem solving method .",
    "first , researchers have focused strongly on using distributed computing as a way of exploiting concurrency to distribute the computation needed to solve hard problems @xcite .",
    "because of this , even partially and/or temporarily centralizing sections of the problem can be viewed as contradictory to the central goal .",
    "second , researchers have often claimed that part of the power of the distributed methods lies in the ability of the techniques to solve problems that are naturally distributed . for example , supply chain problems generally have no central monitoring authority . again , directly sharing the reasons why a particular choice is made in the form of a constraint can seem to contradict the use of distributed methods .",
    "lastly , researchers often claim that for reasons of privacy or security the problem should be solved in a distributed fashion . clearly , sharing information to solve a problem compromises an agents ability to be private and/or violates its security in some manner .",
    "= 0.7 in    although , parallelism , natural distribution , security , and privacy , may all seem like good justifications for entirely distributed problem solving , in actuality , whenever a problem has interdependencies between distributed problem solvers , some degree of centralization and information sharing must take place in order to derive a conflict - free solution .",
    "consider , as a simple example , the problem in figure [ simple - prob ] .",
    "in this figure , two problem solvers , each with one variable , share the common goal of having a different value from one another .",
    "each of the agents has only two allowable values : \\{1 , 2}. now , in order to solve this problem , each agent must individually decide that they have a different value from the other agent . to do this , at the very least , one agent must transmit its value to the other . by doing this ,",
    "it removes half of its privacy ( by revealing one of its possible values ) , eliminates security ( because the other agent could make him send other values by telling him that this value is no good ) , and partially centralizes the problem solving ( agent s2 has to compute solutions based on the solution s1 presented and decide if the problem is solved and agent s1 just relies on s2 to solve it . ) in even this simple example , achieving totally distributed problem solving is impossible .",
    "in fact , if you look at the details of any of the current approaches to solving dcsps , you will observe a significant amount of centralization occurring .",
    "most of these approaches perform this centralization incrementally as the problem solving unfolds in an attempt to restrict the amount of internal information being shared . unfortunately , on problems that have interdependencies among the problem solvers , revealing an agent s information ( such as the potential values of their variables ) is unavoidable .",
    "in fact , solutions that are derived when one or more agents conceals all of the information regarding a shared constraint or variable are based on incomplete information and therefore may not always be sound .",
    "it follows then , that since you can not avoid some amount of centralization , mediation is a natural method for solving problems that contain interdependencies among distributed problem solvers .",
    "as a cooperative mediation based protocol , the key ideas behind the creation of the apo algorithm are    * using mediation , agents can solve subproblems of the dcsp using internal search . *",
    "these local subproblems can and should overlap to allow for more rapid convergence of the problem solving . *",
    "agents should , over time , increase the size of the subproblem they work on along critical paths within the csp .",
    "this increases the overlap with other agents and ensures the completeness of the search .",
    "figures [ apo_init ] , [ apo_ok ] , [ apo_mediator ] , [ apo_choose ] , and [ apo_receive ] present the basic apo algorithm",
    ". the algorithm works by constructing a @xmath9 and maintaining a structure called the @xmath10 .",
    "the @xmath10 holds the names , values , domains , and constraints of variables to which an agent is linked .",
    "the @xmath9 holds the names of the variables that are known to be connected to the owner by a path in the constraint graph .    as the problem solving unfolds",
    ", each agent tries to solve the subproblem it has centralized within its @xmath9 or determine that it is unsolvable which indicates the entire global problem is over - constrained . to do this ,",
    "agents take the role of the mediator and attempt to change the values of the variables within the mediation session to achieve a satisfied subsystem .",
    "when this can not be achieved without causing a violation for agents outside of the session , the mediator links with those agents assuming that they are somehow related to the mediator s variable .",
    "this process continues until one of the agents finds an unsatisfiable subsystem , or all of the conflicts have been removed .    in order to facilitate the problem solving process",
    ", each agent has a dynamic priority that is based on the size of their @xmath9 ( if two agents have the same sized @xmath9 then the tie is broken using the lexicographical ordering of their names ) .",
    "priorities are used by the agents to decide who mediates a session when a conflicts arises .",
    "priority ordering is important for two reasons .",
    "first , priorities ensure that the agent with the most knowledge gets to make the decisions .",
    "this improves the efficiency of the algorithm by decreasing the effects of myopic decision making .",
    "second , priorities improve the effectiveness of the mediation process because lower priority agents expect higher priority agents to mediate .",
    "this improves the likelihood that lower priority agents will be available when a mediation request is sent .      on startup ,",
    "the agents are provided with the value ( they pick it randomly if one is nt assigned ) and the constraints on their variable .",
    "initialization proceeds by having each of the agents send out an `` init '' message to its neighbors .",
    "this initialization message includes the variable s name ( @xmath11 ) , priority ( @xmath12 ) , current value(@xmath13 ) , the agent s desire to mediate ( @xmath14 ) , domain ( @xmath15 ) , and constraints ( @xmath16 ) . the array _",
    "records the names of the agents that initialization messages have been sent to , the reason for which will become immediately apparent .    when an agent receives an initialization message ( either during the initialization or through a later link request ) , it records the information in its @xmath10 and adds the variable to the @xmath9 if it can .",
    "a variable is only added to the @xmath9 if it is a neighbor of another variable already in the @xmath9 .",
    "this ensures that the graph created by the variables in the @xmath9 always remains connected , which focuses the agent s internal problem solving on variables which it knows it has an interdependency with .",
    "the @xmath17 is then checked to see if this message is a link request or a response to a link request .",
    "if an agent is in the @xmath17 , it means that this message is a response , so the agent removes the name from the _ initlist _ and does nothing further .",
    "if the agent is not in the @xmath17 then it means this is a request , so a response `` init '' is generated and sent .",
    "it is important to note that the agents contained in the @xmath9 are a subset of the agents contained in the @xmath10 .",
    "this is done to maintain the integrity of the @xmath9 and allow links to be bidirectional . to understand this point ,",
    "consider the case when a single agent has repeatedly mediated and has extended its local subproblem down a long path in the constraint graph . as it does so , it links with agents that may have a very limited view and therefore are unaware of their indirect connection to the mediator . in order for the link to be bidirectional",
    ", the receiver of the link request has to store the name of the requester in its @xmath10 , but can not add them to their @xmath9 until a path can be identified . as can be seen in section [ apo : proof ]",
    ", the bi - directionality of links is important to ensure the protocol s soundness .",
    "after all of the initialization messages are received , the agents execute the check_agent_view procedure ( at the end of figure [ apo_init ] ) . in this procedure , the current @xmath10 ( which contains the assigned , known variable values ) is checked to identify conflicts between the variable owned by the agent and its * neighbors*. if , during this check ( called _ hasconflict _ in the figure ) , an agent finds a conflict with one or more of its neighbors and has not been told by a higher priority agent that they want to mediate , it assumes the role of the mediator .    an agent can tell when a higher priority agent wants to mediate because of the @xmath14 flag mentioned in the previous section . whenever an agent checks its @xmath10 it recomputes the value of this flag based on whether or not it has existing conflicts with its neighbors . when this flag is set to * true",
    "* it indicates that the agent wishes to mediate if it is given the opportunity .",
    "this mechanism acts like a two - phase commit protocol , commonly seen in database systems , and ensures that the protocol is live - lock and dead - lock free .",
    "when an agent becomes the mediator , it first attempts to rectify the conflict(s ) with its neighbors by changing its own variable .",
    "this simple , but effective technique prevents mediation sessions from occurring unnecessarily , which stabilizes the system and saves messages and time .",
    "if the mediator finds a value that removes the conflict , it makes the change and sends out an `` ok ? ''",
    "message to the agents in its @xmath10 .",
    "if it can not find a non - conflicting value , it starts a mediation session .",
    "an `` ok ? '' message is similar to an `` init '' message , in that it contains information about the priority , current value , etc . of a variable .",
    "the most complex and certainly most interesting part of the protocol is the mediation .",
    "as was previously mentioned in this section , an agent decides to mediate if it is in conflict with one of its neighbors and is not expecting a session request from a higher priority agent .",
    "the mediation starts with the mediator sending out `` evaluate ? ''",
    "messages to each of the agents in its @xmath9 .",
    "the purpose of this message is two - fold .",
    "first , it informs the receiving agent that a mediation is about to begin and tries to obtain a lock from that agent .",
    "this lock , referred to as @xmath18 in the figures , prevents the agent from engaging in two sessions simultaneously or from doing a local value change during the course of a session .",
    "the second purpose of the message is to obtain information from the agent about the effects of making them change their local value .",
    "this is a key point . by obtaining this information",
    ", the mediator gains information about variables and constraints outside of its local view without having to directly and immediately link with those agents .",
    "this allows the mediator to understand the greater impact of its decision and is also used to determine how to extend its view once it makes its final decision .",
    "when an agent receives a mediation request , it responds with either a `` wait ! '' or `` evaluate ! '' message .",
    "the `` wait '' message indicates to the requester that the agent is currently involved in a session or is expecting a request from an agent of higher priority than the requester , which in fact could be itself .",
    "if the agent is available , it labels each of its domain elements with the names of the agents that it would be in conflict with if it were asked to take that value .",
    "this information is returned in the `` evaluate ! '' message .    the size of the `` evaluate ! ''",
    "message is strongly related to the number of variables and the size of the agent s domain . in cases where either of these are extremely large",
    ", a number of techniques can be used to reduce the overall size of this message .",
    "some example techniques include standard message compression , limiting the domain elements that are returned to be only ones that actually create conflict or simply sending relevant value / variable pairs so the mediator can actually do the labeling .",
    "this fact means that the largest `` evaluate ! ''",
    "message ever actually needed is polynomial in the number of agents ( @xmath19 ) . in this implementation , for graph coloring , the largest possible",
    "`` evaluate ! ''",
    "message is @xmath20 , whenever an agent attempts to completely hide information about a shared variable or constraint in a distributed problem , the completeness is necessarily effected .",
    "when the mediator has received either a `` wait ! ''",
    "or `` evaluate ! ''",
    "message from the agents that it sent a request to , it chooses a solution .",
    "the mediator determines that it has received all of the responses by using the _ counter _",
    "variable which is set to the size of the good_list when the `` evaluate ? '' messages are first sent .",
    "as the mediator receives either a `` wait ! ''",
    "or `` evaluate ! ''",
    "message , it decrements this counter",
    ". when it reaches 0 , all of the agents have replied .",
    "agents that sent a `` wait ! ''",
    "message are dropped from the mediation while for agents that sent an `` evaluate ! ''",
    "message their labeled domains specified in the message are recorded and used in the search process .",
    "the mediator then uses the current values along with the labeled domains it has received in the `` evaluate ! '' messages to conduct a centralized search .    currently , solutions are generated using a branch and bound search @xcite where all of the constraints in the good_list must be satisfied and the number of outside conflicts are minimized .",
    "this is very similar to the the min - conflict heuristic @xcite .",
    "notice that although this search takes all of the variables and constraints in its good_list into consideration , the solution it generates may not adhere to the variable values of the agents that were dropped from the session .",
    "these variables are actually considered outside of the session and the impact of not being able to change their values is calculated as part of the min - conflict heuristic .",
    "this causes the search to consider the current values of dropped variables as weak - constraints on the final solution .",
    "in addition , the domain for each of the variables in the good_list is ordered such that the variable s current value is its first element .",
    "this causes the search to use the current value assignments as the first path in the search tree and has the tendency to minimize the changes being made to the current assignments .",
    "these heuristics , when combined together , form a lock and key mechanism that simultaneously exploits the work that was previously done by other mediators and acts to minimize the number of changes in those assignments . as will be presented in section [ apo : evaluation ] , these simple feed - forward mechanisms , combined with the limited centralization needed to solve problems , account for considerable improvements in the algorithms runtime performance .    if no satisfying assignments are found during this search , the mediator announces that the problem is unsatisfiable and the algorithm terminates .",
    "once the solution is chosen , `` accept ! ''",
    "messages are sent to the agents in the session , who , in turn , adopt the proposed answer .",
    "the mediator also sends `` ok '' messages to the agents that are in its @xmath10 , but for whatever reason were not in the session .",
    "this simply keeps those agents @xmath10s up - to - date , which is important for determining if a solution has been reached .",
    "lastly , using the information provided to it in the `` evaluate ! '' messages , the mediator sends `` init '' messages to any agent that is outside of its @xmath10 , but it caused conflict for by choosing a solution .",
    "this `` linking '' step extends the mediators view along paths that are likely to be critical to solving the problem or identifying an over - constrained condition .",
    "this step also ensures the completeness of the protocol .",
    "although termination detection is not explicitly part of the apo protocol , a technique similar to @xcite could easily be added to detect quiescence amongst the agents .",
    "removing the restrictions presented in section [ apo : dcsp ] is a fairly straightforward process .",
    "because apo uses linking as part of the problem solving process , working with @xmath21-ary constraints simply involves linking with the @xmath21 agents within the constraint during initialization and when a post - mediation linking needs to occur .",
    "priorities in this scheme are identical to those used for binary constraints .",
    "removing the single agent per variable restriction is also not very difficult and in fact is one of the strengths of this approach . by using a spanning tree algorithm on initialization",
    ", the agents can quickly identify the interdependencies between their internal variables which they can then use to create separate @xmath9s for each of the disconnected components of their internal constraint graph .",
    "in essence , on startup , the agents would treat each of these decomposed problems as a separate problem , using a separate @xmath14 flag , priority , @xmath9 , etc . as the problem solving unfolds , and the agent discovers connections between the internal variables ( through external constraints ) ,",
    "these decomposed problems could be merged together and utilize a single structure for all of this information .",
    "this technique has the advantages of being able to ensure consistency between dependent internal variables before attempting to mediate ( because of the local checking before mediation ) , but allows the agent to handle independent variables as separate problems .",
    "using a situation aware technique such as this one has been shown to yield the best results in previous work@xcite .",
    "in addition , this technique allows the agents to hide variables that are strictly internal . by doing pre - computation on the decomposed problems",
    ", the agents can construct constraints which encapsulate each of the subproblems as n - ary constraints where n is the number of variables that have external links .",
    "these derived constraints can then be sent as part of the `` init '' message whenever the agent receives a link request for one of its external variables .",
    "= 4.0 in      consider the 3-coloring problem presented in figure [ apo : base - ex ] . in this problem , there are 8 agents , each with a variable and 12 edges or constraints between them . because this is a 3-coloring problem ,",
    "each variable can only be assigned one of the three available colors \\{black , red , or blue}. the goal is to find an assignment of colors to the variables such that no two variables , connected by an edge , have the same color .    in this example , four constraints are in violation : ( nd0,nd1 ) , ( nd1,nd3 ) , ( nd2,nd4 ) , and ( nd6,nd7 ) . following the algorithm , upon startup each agent adds itself to its @xmath9 and sends an `` init '' message to its neighbors . upon receiving these messages , the agents add each of their neighbors to their @xmath9 because they are able to identify a shared constraint with themselves .",
    "once the startup has been completed , each of the agents checks its @xmath10 .",
    "all of the agents , except nd5 , find that they have conflicts .",
    "nd0 ( priority 3 ) waits for nd1 to mediate ( priority 5 ) .",
    "nd6 and nd7 , both priority 4 , wait for nd4 ( priority 5 , tie with nd3 broken using lexicographical ordering ) .",
    "nd1 , having an equal number of agents in its @xmath9 , but a lower lexicographical order , waits for nd4 to start a mediation . nd3 , knowing it is highest priority amongst its neighbors , first checks to see if it can resolve its conflict by changing its value , which in this case , it can not .",
    "nd3 starts a session that involves nd1 , nd5 , nd6 , and nd7 .",
    "it sends each of them an `` evaluate ? '' message .",
    "nd4 being highest priority amongst its neighbors , and unable to resolve its conflict locally , also starts a session by sending `` evaluate ? ''",
    "messages to nd1 , nd2 , nd6 , and nd7 .",
    "when each of the agents in the mediation receives the `` evaluate ? '' message , they first check to see if they are expecting a mediation from a higher priority agent . in this case , nd1 , nd6 , and nd7 are expecting from nd4 so tell nd3 to wait",
    ". then they label their domain elements with the names of the variables that they would be in conflict with as a result of adopting that value .",
    "this information is sent in an `` evaluate ! '' message .",
    "the following are the labeled domains for the agents that are sent to nd4 :    * nd1 - black causes no conflicts ; red conflicts with nd0 and nd3 ; blue conflicts with nd2 and nd4 * nd2 - black causes no conflicts ; red conflicts with nd0 and nd3 ; blue conflicts with nd4 * nd6 - black conflicts with nd7 ; red conflicts with nd3 ; blue conflicts with nd4 * nd7 - black conflicts with nd6 ; red conflicts with nd3 ; blue conflicts with nd4    the following are the responses sent to nd3 :    * nd1 - wait ! * nd5 - black causes no conflicts ; red conflicts with nd3 ; blue causes no conflicts * nd6 - wait ! * nd7 - wait !    = 4.0 in",
    "once all of the responses are received , the mediators , nd3 and nd4 , conduct a branch and bound searches that attempt to find a satisfying assignment to their subproblems and minimizes the amount of conflict that would be created outside of the mediation .",
    "if either of them can not find at least one satisfying assignment , it broadcasts that a solution can not be found .    in this example , nd3 , with the limited information that it has , computes a satisfying solution that changes its own color and to remain consistent would have also changed the colors of nd6 and nd7 .",
    "since it was told by nd6 and nd7 to wait , it changes its color , sends an `` accept ! '' message to nd5 and `` ok ? '' messages to nd1 , nd6 and nd7 . having more information",
    ", nd4 finds a solution that it thinks will solve its subproblem without creating outside conflicts .",
    "it changes its own color to red , nd7 to blue , and nd1 to black leaving the problem in the state shown in figure [ apo:400-ex ] .",
    "nd1 , nd4 , nd5 , nd6 and nd7 inform the agents in their @xmath10 of their new values , then check for conflicts . this time , nd1 , nd3 , and nd6 notice that their values are in conflict .",
    "nd3 , having the highest priority , becomes the mediator and mediates a session with nd1 , nd5 , nd6 , and nd7 .",
    "following the protocol , nd3 sends out the `` evaluate ? '' messages and the receiving agents label and respond .",
    "the following are the labeled domains that are returned :    = 4.0 in    * nd1 - black conflicts with nd3 ; red conflicts with nd0 and nd4 ; blue conflicts with nd2 * nd5 - black conflicts with nd3 ; red causes no conflicts ; blue causes no conflicts * nd6 - black conflicts with nd3 ; red conflicts with nd4 ; blue conflicts with nd7 * nd7 - black conflicts with nd3 and nd6 ; red conflicts with nd4 ; blue causes no conflicts    nd3 , after receiving these messages , conducts its search and finds a solution that solves its subproblem .",
    "it chooses to change its color to red .",
    "nd1 , nd3 , nd5 , nd6 , and nd7 check their @xmath10 and find no conflicts . since , at this point , none of the agents have any conflict , the problem is solved ( see figure [ apo : final - ex ] ) .      in this section we will show that the apo algorithm is both sound and complete .",
    "for these proofs , it is assumed that all communications are reliable , meaning that if a message is sent from @xmath11 to @xmath22 that @xmath22 will receive the message in a finite amount of time .",
    "we also assume that if @xmath11 sends message @xmath23 and then sends message @xmath24 to @xmath22 , that @xmath23 will be received before @xmath24 .",
    "lastly , we assume that the centralized solver used by the algorithm is sound and complete .",
    "before we prove the soundness and completeness , it helps to have a few principal lemmas established .",
    "links are bidirectional .",
    "i.e. if @xmath11 has @xmath22 in its @xmath10 then eventually @xmath22 will have @xmath11 in its @xmath10 .",
    "[ apo : bidirectional ]    * proof : *    assume that @xmath11 has @xmath22 in its @xmath10 and that @xmath11 is not in the @xmath10 of @xmath22 . in order for @xmath11 to have @xmath22 in its @xmath10 , @xmath11 must have received an `` init '' message at some point from @xmath22 .",
    "there are two cases .",
    "* case 1 : * @xmath22 is in the @xmath17 of @xmath11 . in this case",
    ", @xmath11 must have sent @xmath22 an `` init '' message first , meaning that @xmath22 received an `` init '' message and therefore has @xmath11 in its @xmath10 , a contradiction .",
    "* case 2 : * @xmath22 is not in the @xmath17 of @xmath11 . in this case , when @xmath11 receives the `` init '' message from @xmath22 , it responds with an `` init '' message .",
    "that means that if the reliable communication assumption holds , eventually @xmath22 will receive @xmath11 s `` init '' message and add @xmath11 to its @xmath10 .",
    "also a contradiction .",
    "if agent @xmath11 is linked to @xmath22 and @xmath22 changes its value , then @xmath11 will eventually be informed of this change and update its agent_view .",
    "[ apo : uptodate ]    * proof : *    assume that @xmath11 has a value in its @xmath10 for @xmath22 that is incorrect .",
    "this would mean that at some point @xmath22 altered its value without informing @xmath11 .",
    "there are two cases :    * case 1 : * @xmath22 did not know it needed to send @xmath11 an update .",
    "i.e. @xmath11 was not in @xmath22 s @xmath10 .",
    "contradicts lemma [ apo : bidirectional ] .",
    "* case 2 : * @xmath22 did not inform all of the agents in its @xmath10 when it changes its value . it is clear from the code that this can not happen .",
    "agents only change their values in the check_agent_view , choose_solution , and accept ! procedures . in each of these cases",
    ", it informs all of the agents within its @xmath10 by either sending an `` ok ? '' or through the `` accept ! '' message that a change to its value has occurred . a contradiction .",
    "if @xmath11 is in conflict with one or more of its neighbors , does not expect a mediation from another higher priority agent in its @xmath10 , and is currently not in a session , then it will act as mediator .",
    "[ apo : willmediate ]    * proof : *    directly from the procedure check_agent_view .",
    "if @xmath11 mediates a session that has a solution , then each of the constraints between the agents involved in the mediation will be satisfied .",
    "[ apo : mediatefix ]    * proof : *    assume that there are two agents @xmath22 and @xmath25 ( either of them could be @xmath11 ) , that were mediated over by @xmath11 and after the mediation there is a conflict between @xmath22 and @xmath25 .",
    "there are two ways this could have happened .    * case 1 : * one or both of the agents must have a value that @xmath11 did not assign to it as part of the mediation .",
    "assume that @xmath22 and/or @xmath25 has a value that @xmath11 did not assign .",
    "we know that since @xmath11 mediated a session including @xmath22 and @xmath25 , that @xmath11 did not receive a `` wait !",
    "'' message from either of @xmath22 or @xmath25 .",
    "this means that they could not have been mediating .",
    "this also means that they must have set their @xmath18 flags to true when @xmath11 sent them the `` evaluate ? '' message . since the only times",
    "an agent can change its value is when its @xmath18 flag is false , it is mediating , or has been told to by a mediator , @xmath22 and/or @xmath25 could only have changed their values is if @xmath11 told them to , which contradicts the assumption .",
    "* case 2 : * @xmath11 assigned them a value that caused them to be in conflict with one another .",
    "let s assume that @xmath11 assigned them conflicting values .",
    "this means that @xmath11 chose a solution that did not take into account the constraints between @xmath22 and @xmath25 .",
    "but , we know that @xmath11 only chooses satisfying solutions that include all of the constraints between all of the agents in the @xmath9 .",
    "this leads to a contradiction .",
    "this lemma is important because it says that once a mediator has successfully concluded its session , the only conflicts that can exist are on constraints that were outside of the mediation .",
    "this can be viewed as the mediator pushing the constraint violations outside of its view .",
    "in addition , because mediators get information about who the violations are being pushed to and establish links with those agents , over time , they gain more context .",
    "this is a very important point when considering the completeness of the algorithm .",
    "the apo algorithm is sound .",
    "i.e. it reaches a stable state only if it has either found an answer or no solution exists .",
    "[ apo : soundness ]    * proof : *    in order to be sound , the agents can only stop when they have reached an answer .",
    "the only condition in which they would stop without having found an answer is if one or more of the agents is expecting a mediation request from a higher priority agent that does not send it .",
    "in other words , the protocol has deadlocked .",
    "let s say we have 3 agents , @xmath11 , @xmath22 , and @xmath25 with @xmath26 ( @xmath27 could be equal to @xmath28 ) and @xmath25 has a conflict with @xmath22 .",
    "there are two cases in which @xmath22 would not mediate a session that included @xmath11 , when @xmath11 was expecting it to :    * case 1 : * @xmath11 has @xmath29 in its @xmath10 when the actual value should be * false*.    assume that @xmath11 has @xmath29 in its @xmath10 when the true value of @xmath30 .",
    "this would mean that at some point @xmath22 changed the value of @xmath31 to false without informing @xmath11 .",
    "there is only one place that @xmath22 changes the value of @xmath31 , this is in the check_agent_view procedure ( see figure [ apo_ok ] ) .",
    "note that in this procedure , whenever the flag changes value from true to false , the agent sends an `` ok '' message to all the agents in its @xmath10 .",
    "since by lemma [ apo : bidirectional ] we know that @xmath11 is in the @xmath10 of @xmath22 , @xmath11 must have received the message saying that @xmath30 , contradicting the assumption .",
    "* case 2 : * @xmath22 believes that @xmath11 should be mediating when @xmath11 does not believe it should be .",
    "i.e. @xmath22 thinks that @xmath32 and @xmath33 .    by the previous case , we know that if @xmath22 believes that @xmath32 that this must be the case .",
    "we only need to show that @xmath34 .",
    "let s say that @xmath35 is the priority that @xmath22 believes @xmath11 has and assume that @xmath22 believes that @xmath36 when , in fact @xmath37 .",
    "this means that at some point @xmath11 sent a message to @xmath22 informing it that its current priority was @xmath35 . since we know that priorities only increase over time ( the good_list only gets larger ) , we know that @xmath38 ( @xmath22 always has the correct value or underestimates the priority of @xmath11 ) . since @xmath39 and @xmath40 then @xmath41 which contradicts the assumption .",
    "this is also an important point when considering how the algorithm behaves .",
    "this proof says that agents always either know or underestimate the true value of their neighbors priorities .",
    "because of this , the agents will attempt to mediate when in fact sometimes , they should nt . the side effect of this attempt , however , is that the correct priorities are exchanged so the same mistake does nt get repeated .",
    "the other important thing to mention is the case were the priority values become equal . in this case , the tie is broken by using the alphabetical order of names of the agents .",
    "this ensures that there is always a way to break ties .",
    "oscillation is a condition that occurs when a subset @xmath42 of the agents are infinitely cycling through their allowable values without reaching a solution . in other words ,",
    "the agents are live - locked [ apo : oscillation ]    by this definition , in order to be considered part of an oscillation , an agent within the subset must be changing its value ( if it s stable , it s not oscillating ) and it must be connected to the other members of the subset by a constraint ( otherwise , it is not actually a part of the oscillation ) .",
    "the apo algorithm is complete .",
    "i.e. if a solution exists , the algorithm will find it . if a solution does not exist , it it will report that fact .",
    "[ apo : completeness ]    * proof : *    a solution does not exist whenever the problem is over - constrained . if the problem is over - constrained , the algorithm will eventually produce a @xmath9 where the variables within it and their associated constraints lead to no solution .",
    "since a subset of the variables is unsatisfiable , the entire problem is unsatisfiable , therefore , no solution is possible .",
    "the algorithm terminates with failure if and only if this condition is reached .",
    "since we have now shown in theorem [ apo : soundness ] that whenever the algorithm reaches a stable state , the problem is solved and that when it finds a subset of the variables that is unsatisfiable it terminates , we only need to show that it reaches one of these two states in finite time .",
    "the only way for the agents to not reach a stable state is when one or more of the agents in the system is in an oscillation .",
    "there are two cases to consider , the easy case is when a single agent is oscillating ( @xmath43 ) and the other case is when more than one agent is oscillating ( @xmath44 ) .    *",
    "case 1 : * there is an agent @xmath11 that is caught in an infinite loop and all other agents are stable .",
    "let s assume that @xmath11 is in an infinite processing loop .",
    "that means that no matter what it changes its value to , it is in conflict with one of its neighbors , because if it changed its value to something that does nt conflict with its neighbors , it would have a solution and stop .",
    "if it changes its value to be in conflict with some @xmath22 that is higher priority than it , then @xmath22 will mediate with @xmath11 , contradicting the assumption that all other agents are stable .",
    "if @xmath11 changes its value to be in conflict with a lower priority agent , then by lemma [ apo : willmediate ] , it will act as mediator with its neighbors .",
    "since it was assumed that each of the other agents is in a stable state , then all of the agents in @xmath11 s @xmath9 will participate in the session and by lemma [ apo : mediatefix ] , agent @xmath11 will have all of its conflicts removed .",
    "this means that @xmath11 will be in a stable state contradicting the assumption that it was in an infinite loop .",
    "* case 2 : * two or more agents are in an oscillation .",
    "let s say we have a set of agents @xmath42 that are in an oscillation .",
    "now consider an agent @xmath11 that is within @xmath45 .",
    "we know that the only conditions in which @xmath11 changes its value is when it can do so and solve all of its conflicts ( a contradiction because @xmath11 would nt be considered part of the oscillation ) , as the mediator , or as the receiver of a mediation from some other agent in @xmath45 .",
    "the interesting case is when an agent acts as the mediator .",
    "consider the case when @xmath11 is the mediator and call the set of agents that it is mediating over @xmath46 .",
    "we know according to definition [ apo : oscillation ] that after the mediation , that at least one conflict must be created or remain otherwise the oscillation would stop and the problem would be solved .",
    "in fact , we know that each of the remaining conflicts must contain an agent from the set @xmath47 by lemma [ apo : mediatefix ] .",
    "we also know that for each violated constraint that has a member from @xmath46 , that @xmath11 will link with any agent that is part of those constraints and not a member of @xmath46 . the next time @xmath11 mediates , the set @xmath46 will include these members and the number of agents in the set @xmath47",
    "is reduced .",
    "in fact , whenever @xmath11 mediates the set @xmath47 will be reduced ( assuming it is not told to wait ! by one or more agents . in this case",
    ", it takes longer to reduce this set , but the proof still holds ) .",
    "eventually , after @xmath48 mediations , some @xmath11 within @xmath45 must have @xmath49 ( every agent within the set must have mediated @xmath50 times in order for this to happen ) .",
    "when this agent mediates it will push the violations outside of the set @xmath45 or it will solve the subproblem by lemma [ apo : mediatefix ] .",
    "either of these conditions contradicts the oscillation assumption .",
    "therefore , the algorithm is complete .",
    "* qed *    it should be fairly clear that , in domains that are exponential , the algorithm s worse - case runtime is exponential .",
    "the space complexity of the algorithm is , however , polynomial , because the agents only retain the names , priorities , values , and constraints of other agents .",
    "a great deal of testing and evaluation has been conducted on the apo algorithm . almost exclusively",
    ", these test are done comparing the apo algorithm with the currently fastest known , complete algorithm for solving dcsps called the asynchronous weak commitment ( awc ) protocol . in this section",
    "we will describe the awc protocol ( section [ awc ] ) , then will describe the distributed 3-coloring domain and present results from extensive testing done in this domain ( section [ coloring ] ) .",
    "this testing compares these two algorithms across a variety of metrics , including the cycle time , number of messages , and serial runtime .",
    "next , we will describe the tracking domain ( section [ tracking ] ) and present results from testing in this domain as well . for this domain",
    ", we modified the core search algorithm of apo to take advantage of the polynomial complexity of this problem .",
    "this variant called , _ apo - flow _ , will also be described .",
    "the awc protocol @xcite was one of the first algorithms used for solving dcsps .",
    "like the apo algorithm , awc is based on variable decomposition .",
    "also , like apo , awc assigns each agent a priority value that dynamically changes .",
    "awc , however , uses the weak - commitment heuristic @xcite to assign these priorities values which is where it gets its name .    upon startup ,",
    "each of the agents selects a value for its variable and sends `` ok ? ''",
    "messages to its neighbors ( agents it shares a constraint with ) .",
    "this message includes the variables value and priority ( they all start at 0 ) .",
    "when an agent receives an `` ok ? '' message , it updates its @xmath10 and checks its _ nogood list _ for violated @xmath51 .",
    "each nogood is composed of a set of nogood pairs which describe the combination of agents and values that lead to an unsatisfiable condition .",
    "initially , the only nogoods in an agent s nogood list are the constraints on its variable .",
    "when checking its nogood list , agents only check for violations of higher priority nogoods .",
    "the priority of a nogood is defined as the priority of the lowest priority variable in the nogood .",
    "if this value is greater than the priority of the agent s variable , the nogood is higher priority .",
    "based on the results from this check , one of three things can happen :    1 .",
    "if no higher priority nogoods are violated , the agent does nothing .",
    "if there are higher priority nogoods that are violated and this can be repaired by simply changing the agent s variable value , then the agent changes its value and sends out `` ok ? '' messages to the agents in its @xmath10 .",
    "if there are multiple possible satisfying values , then the agent chooses the one that minimizes the number of violated lower priority nogoods .",
    "if there are violated higher priority nogoods and this can not be repaired by changing the value of its variable , the agent generates a new nogood .",
    "if this nogood is the same as a previously generated nogood , it does nothing . otherwise , it then sends this new nogood to every agent that has a variable contained in the nogood and raises the priority value of its variable .",
    "finally , it changes its variable value to one that causes the least amount of conflict and sends out `` ok ? '' messages .    upon receiving a nogood message from another agent",
    ", the agent adds the nogood to its nogood list and rechecks for nogood violations . if the new nogood includes the names of agents that are not in its @xmath10 it links to them .",
    "this linking step is essential to the completeness of the search@xcite , but causes the agents to communicate nogoods and ok ?",
    "messages to agents that are not their direct neighbors in the constraint graph .",
    "the overall effect is an increase in messages and a reduction in the amount of privacy being provided to the agents because they communicate potential domain values and information about their constraints through the exchange of ok ? and nogood messages with a larger number of agents .",
    "one of the more recent advances to the awc protocol has been the addition of resolvent - based nogood learning @xcite which is an adaptation of classical nogood learning methods @xcite .",
    "the resolvent method is used whenever an agent finds that it needs to generate a new nogood .",
    "agents only generate new nogoods when each of their domain values are in violation with at least one higher priority nogood already in their nogood list .",
    "the resolvent method works by selecting one of these higher priority nogoods for each of the domain values and aggregating them together into a new nogood .",
    "this is almost identical to a _",
    "resolvent _ in propositional logic which is why it is referred to as resolvent - based learning .",
    "the awc protocol used for all of our testing incorporates resolvent - based nogood learning .      following directly from the definition for a csp , a graph coloring problem , also known as a @xmath28-colorability problem , consists of the following :    * a set of _ n _ variables @xmath1 .",
    "* a set of possible colors for each of the variables @xmath2 where each @xmath15 is has exactly @xmath28 allowable colors . * a set of constraints @xmath3 where each @xmath52 is predicate which implements the `` not equals '' relationship .",
    "this predicate returns true iff the value assigned to @xmath11 differs from the value assigned to @xmath22 .",
    "= 5.0 in    the problem is to find an assignment @xmath6 such that each of the constraints in @xmath7 is satisfied . like the general csp",
    ", graph coloring has been shown to be np - complete for all values of @xmath53 .    to test the apo algorithm",
    ", we implemented the awc and apo algorithms and conducted experiments in the distributed 3-coloring domain .",
    "the distributed 3-coloring problem is a 3-coloring problem with _",
    "n _ variables and _ m _ binary constraints where each agent is given a single variable .",
    "we conducted 3 sets of graph coloring based experiments to compare the algorithms computation and communication costs .      in the first set of experiments",
    ", we created solvable graph instances with @xmath54 ( _ low - density _ ) , @xmath55 ( _ medium - density _ ) , and @xmath56 ( _ high - density _ ) according to the method presented in @xcite . generating graphs in this way",
    "involves partitioning the variables into @xmath28 equal - sized groups .",
    "edges are then added by selecting two of the groups at random and adding an edge between a random member of each group .",
    "this method ensures that the resulting graphs are satisfiable , but also tests a very limited and very likely easier subset of the possible graphs .",
    "these tests were done because they are traditionally used by other researchers in dcsps .",
    "these particular values for @xmath57 were chosen because they represent the three major regions within the phase - transition for 3-colorability @xcite . a phase transition in a csp",
    "is defined based on an order parameter , in this case the average node degree @xmath58 .",
    "the transition occurs at the point where random graphs created with that order value yield half satisfiable and half unsatisfiable instances .",
    "values of the order parameter that are lower than the transition point ( more than 50% of the instance are satisfiable ) are referred to being to the left of the transition .",
    "the opposite is true of values to the right .",
    "= 5.0 in    phase transitions are important because that are strongly correlated with the overall difficulty of finding a solution to the graph @xcite . within the phase transition ,",
    "randomly created instances are typically difficult to solve .",
    "interestingly , problems to the right and left of the phase transitions tend to be much easier .    in 3-colorability ,",
    "the value @xmath59 is to the left of the phase transition . in this region ,",
    "randomly created graphs are very likely to be satisfiable and are usually easy to find solve . at @xmath60 , which is in the middle of the phase transition",
    "the graph has about a 50% chance of being satisfiable and is usually hard to solve . for @xmath56 , right of the phase transition ,",
    "graphs are more than likely to be unsatisfiable and , again , are also easier to solve .",
    "= 5.0 in    [ cols=\"^,^ , > , > , > , > , > \" , ]",
    "in this article , we presented a new complete , distributed constraint satisfaction protocol called asynchronous partial overlay ( apo ) .",
    "like awc , apo allows the agents to retain their autonomy because they can obscure or completely hide internal variables and constraints .",
    "in addition , agents can refuse solutions posed by a mediator , instead taking over as the mediator if for some reason they are unhappy with a proposed solution .",
    "we also presented an example of its execution on a simple problem ( section [ apo : example ] ) and proved the soundness and completeness of the algorithm ( section [ apo : proof ] ) . through extensive empirical testing on 10,250 graph instances from the graph coloring and tracking domain",
    ", we also showed that apo significantly outperforms the currently best known distributed constraint satisfaction algorithm , awc @xcite .",
    "these tests have shown that apo is better than awc in terms of cycles to completion , message usage , and runtime performance .",
    "we have also shown that the runtime characteristics can not be directly attributed to the speed of the centralized solver .",
    "apo s performance enhancements can be attributed to a number of things .",
    "first , apo exhibits a hill - climbing nature early in the search which becomes more focused and controlled as time goes on .",
    "like other hill - climbing techniques this often leads to a satisfiable solution early in the search .",
    "second , by using partial overlaying of the information that the agents use in decision making , apo exploits the work that has been previously done by other mediators .",
    "this forms a lock and key mechanism which promotes solution stability .",
    "lastly , and most importantly , because apo uses dynamic , partial centralization , the agents work on smaller , highly relevant portions of the overall problem . by identifying these areas of decomposability ,",
    "the search space can be greatly reduced which , in some cases , improves the efficiency of the centralized search algorithm .",
    "there are a vast number of improvements planned for apo in the future .",
    "probably the most important is to improve the centralized solver that it uses . in this article ,",
    "an inefficient solver was chosen to show the strengths of the distributed portions of apo .",
    "we expect that additional improvements in the algorithm s runtime performance can be obtained by using a faster centralized search engine .",
    "in addition , modern solvers often use methods like graph reductions , unit propagation and backbone guided search .",
    "it is conceivable that information gained from the centralized search engine could be used to prune the domains from the variables for consistency reasons and variables from the centralized subproblem for relevance reasons .",
    "we expect this will further focus the efforts of the agents additionally reducing the search time and communications usage of the algorithm .    along with these improvements is the selective use of memory for recording _",
    "nogoods_. unlike awc which uses the nogoods to ensure a complete search , apo s completeness relies on one of the agents centralizing the entire problem in the worst case .",
    "because of this key difference , apo can be improved by simply remembering a small , powerful subset of the nogoods that it discovers from mediation session to session .",
    "this would allow the algorithm to improve future search by exploiting work that it had done previously .",
    "what should be clear is that apo , and the cooperative mediation methodology as a whole , opens up new areas for future exploration and new questions to be answered in distributed problem solving .",
    "we believe that this work shows a great deal of promise for addressing a vast number of problems and represents a bridge between centralized and distributed problem solving techniques .",
    "bejar , r. , krishnamachari , b. , gomes , c. ,  selman , b. 2001 .",
    "distributed constraint satisfaction in a wireless sensor tracking systemin workshop on distributed constraint reasoning , international joint conference on artificial intelligence , seattle , washington .",
    "cammarata , s. , mcarthur , d. ,  steeb , r. 1983 .",
    "strategies of cooperation in distributed problem solvingin proceedings of the 8th international joint conference on artificial intelligence ( ijcai-83 ) ,  2 ,  767770 .",
    "krishnamachari , b. , bejar , r. ,  wicker , s. 2002 .",
    "distributed problem solving and the boundaries of self - configuration in multi - hop wireless networksin hawaii international conference on system sciences ( hicss-35 ) .",
    "yokoo , m. 1994 .",
    "weak - commitment search for solving constraint satisfaction problemsin proceedings of the 12th national conference on artificial intelligence ( aaai-94 ) ; vol . 1 ,  313318 , seattle , wa , usa .",
    "aaai press , 1994 .",
    "yokoo , m. 1995 .",
    "asynchronous weak - commitment search for solving distributed constraint satisfaction problems.in proceedings of the first international conference on principles and practice of constraint programming ( cp-95 ) , lecture notes in computer science 976 ,  88102 .",
    "springer - verlag .",
    "yokoo , m. , durfee , e.  h. , ishida , t. ,  kuwabara , k. 1992 . distributed constraint satisfaction for formalizing distributed problem solvingin international conference on distributed computing systems ,  614621 .",
    "yokoo , m. , suzuki , k. ,  hirayama , k. 2002 .",
    "secure distributed constraint satisfaction : reaching agreement without revealing private informationin proceeding of the eighth international conference on principles and practice of constraint programming ( cp ) ."
  ],
  "abstract_text": [
    "<S> distributed constraint satisfaction ( dcsp ) has long been considered an important problem in multi - agent systems research . </S>",
    "<S> this is because many real - world problems can be represented as constraint satisfaction and these problems often present themselves in a distributed form . in this article </S>",
    "<S> , we present a new complete , distributed algorithm called _ asynchronous partial overlay ( apo ) _ for solving dcsps that is based on a cooperative mediation process . </S>",
    "<S> the primary ideas behind this algorithm are that agents , when acting as a mediator , centralize small , relevant portions of the dcsp , that these centralized subproblems overlap , and that agents increase the size of their subproblems along critical paths within the dcsp as the problem solving unfolds . </S>",
    "<S> we present empirical evidence that shows that apo outperforms other known , complete dcsp techniques .    </S>"
  ]
}