{
  "article_text": [
    "makespan minimization is a fundamental and extensively studied problem in scheduling theory .",
    "consider a sequence of jobs @xmath0 that has to be scheduled on @xmath1 identical parallel machines .",
    "each job @xmath11 is specified by a processing time @xmath12 , @xmath13 .",
    "preemption of jobs is not allowed .",
    "the goal is to minimize the makespan , i.e.  the maximum completion time of any job in the constructed schedule .",
    "we focus on the online version of the problem where the jobs of @xmath2 arrive one by one .",
    "each incoming job @xmath11 has to be assigned immediately to one of the machines without knowledge of any future jobs @xmath14 , @xmath15 .",
    "online algorithms for makespan minimization have been studied since the 1960s . in an early paper graham",
    "@xcite showed that the famous _ list _ scheduling algorithm is @xmath16-competitive .",
    "the best online strategy currently known achieves a competitiveness of about 1.92 .",
    "makespan minimization has also been studied with various types of _ resource augmentation _ , giving an online algorithm additional information or power while processing @xmath2 .",
    "the following scenarios were considered .",
    "( 1 )  an online algorithm knows the optimum makespan or the sum of the processing times of @xmath2 .",
    "( 2 )  an online strategy has a buffer that can be used to reorder @xmath2 .",
    "whenever a job arrives , it is inserted into the buffer ; then one job of the buffer is removed and placed in the current schedule .",
    "( 3 )  an online algorithm may migrate a certain number or volume of jobs .    in this paper",
    "we investigate makespan minimization assuming that an online algorithm is allowed to build several schedules in parallel while processing a job sequence @xmath2 .",
    "each incoming job is sequenced in each of the schedules . at the end of the scheduling process",
    "the best schedule is selected .",
    "we believe that this is a natural form of resource augmentation : in classical online makespan minimization , studied in the literature so far , an algorithm constructs a schedule while jobs arrive one by one .",
    "once all jobs have arrived , the schedule may be executed . hence in this standard framework",
    "there is a priori no reason why an algorithm should not be able to construct several solutions , the best of which is finally chosen .",
    "our new proposed setting can be viewed as providing an online algorithm with extra space , which is used to maintain several solutions .",
    "very little is known about the value of extra space in the design of online algorithms .",
    "makespan minimization with parallel schedules is of particular interest in parallel processing environments where each processor can take care of a single or a small set of schedules .",
    "we develop algorithms that require hardly any coordination or communication among the schedules .",
    "last not least the proposed setting is interesting w.r.t . to the foundations of scheduling theory , giving insight into the value of multiple candidate solutions .",
    "makespan minimization with parallel schedules was also addressed by kellerer et al .",
    "@xcite . however , the paper focused on the restricted setting with @xmath17 machines . in this paper",
    "we explore the problem for a general number @xmath1 of machines . as a main result",
    "we show that a constant number of schedules suffices to achieve a significantly improved competitiveness , compared to the standard setting without resource augmentation .",
    "the competitive ratios obtained are at least as good and in most cases better than those attained in the other models of resource augmentation mentioned above .    the approach to grant an online algorithm",
    "extra space , invested to maintain multiple solutions , could be interesting in other problems as well .",
    "the approach is viable in applications where an online algorithm constructs a solution that is used when the entire input has arrived .",
    "this is the case , for instance , in basic online graph coloring and matching problems  @xcite .",
    "the approach is also promising in problems that can be solved by a set of independent agents , each of which constructs a separate solution .",
    "good examples are online navigation and exploration problems in robotics  @xcite .",
    "some results are known for graph search and exploration , see e.g.  @xcite , but the approach has not been studied for geometric environments .",
    "* problem definition : * we investigate the problem _ makespan minimization with parallel schedules ( mps)_. as always , the jobs of a sequence @xmath0 arrive one by one and must be scheduled non - preemptively on @xmath1 identical parallel machines .",
    "each job @xmath11 has a processing time @xmath18 . in mps , an online algorithm @xmath19 may maintain a set @xmath20 of schedules during the scheduling process while jobs of @xmath2 arrive .",
    "each job @xmath11 is sequenced in each schedule @xmath21 , @xmath22 . at the end of @xmath2 ,",
    "algorithm @xmath23 selects a schedule @xmath24 having the smallest makespan and outputs this solution .",
    "the other schedules of @xmath25 are deleted .    as we shall show mps",
    "can be reduced to the problem variant where the optimum makespan of the job sequence to the processed is known in advance .",
    "hence let mps@xmath26  denote the variant of mps  where , prior to the arrival of the first job , an algorithm @xmath23 is given the value of the optimum makespan @xmath27 for the incoming job sequence @xmath2 .",
    "an algorithm @xmath19 for mps  or mps@xmath26  is @xmath28-competitive if , for every job sequence @xmath2 , it outputs a schedule whose makespan is at most @xmath28 times @xmath27 .",
    "we present a comprehensive study of mps .",
    "we develop a @xmath3-competitive algorithm , for any @xmath4 , using a constant number of @xmath5 schedules .",
    "furthermore , we give a @xmath6-competitive algorithm , for any @xmath4 , that uses a polynomial number of schedules .",
    "the number is @xmath7 , which depends on @xmath1 but is independent of the job sequence @xmath2 .",
    "these performance guarantees are nearly best possible .",
    "the algorithms are obtained via some intermediate results that may be of independent interest .",
    "first , in section  [ sec : redu ] we show that the original problem mps  can be reduced to the variant mps@xmath26  in which the optimum makespan is known .",
    "more specifically , given any @xmath28-competitive algorithm @xmath19 for mps@xmath26  we construct a @xmath29-competitive algorithm @xmath30 , for any @xmath31 .",
    "if @xmath19 uses @xmath32 schedules , then @xmath30 uses @xmath33 schedules .",
    "the construction works for any algorithm @xmath19 for mps@xmath26 .",
    "in particular we could use a 1.6-competitive algorithm by chen et al .",
    "@xcite that assumes that the optimum makespan is known and builds a single schedule .",
    "we would obtain a @xmath34-competitive algorithm that builds at most @xmath35 schedules .",
    "we proceed and develop algorithms for mps@xmath26 . in section  [ sec : ptas ] we give a @xmath6-competitive algorithm , for any @xmath4 , that uses @xmath36 schedules . in section  [ sec:4/3 ]",
    "we devise a @xmath3-competitive algorithm , for any @xmath4 , that uses @xmath5 schedules . combining these algorithms with @xmath30",
    ", we derive the two algorithms for mps  mentioned in the above paragraph ; see also section  [ sec : mps ] .",
    "the number of schedules used by our strategies depends on @xmath37 and exponentially on @xmath38 or @xmath37 .",
    "such a dependence seems inherent if we wish to explore the full power of parallel schedules .",
    "the trade - offs resemble those exhibited by ptases in offline approximation .",
    "recall that the ptas by hochbaum and shmoys  @xcite for makespan minimization achieves a @xmath6-approximation with a running time of @xmath39 .",
    "in section  [ sec : lb ] we present lower bounds .",
    "we show that any online algorithm for mps  that achieves a competitive ratio smaller than 4/3 must construct more than @xmath40 schedules . hence the competitive ratio of 4/3 is best possible using a constant number of schedules .",
    "we show a second lower bound that implies that the number of schedules of our @xmath6-competitive algorithm is nearly optimal , up to a polynomial factor .    our algorithms make use of novel guessing schemes .",
    "@xmath30 works with guesses on the optimum makespan .",
    "guessing and _ doubling _ the value of the optimal solution is a technique that has been applied in other load balancing problems , see e.g.  @xcite .",
    "however here we design a refined scheme that carefully sets and readjusts guesses so that the resulting competitive ratio increases by a factor of @xmath10 only , for any @xmath41",
    ". moreover , the readjustment and job assignment rules have to ensure that scheduling errors , made when guesses were to small , are not critical .",
    "our @xmath3-competitive algorithm works with guesses on the job processing times and their frequencies in @xmath2 . in order to achieve a constant number of schedules",
    ", we have to sparsify the set of all possible guesses .",
    "as far as we know such an approach has not been used in the literature before .",
    "all our algorithms have the property that the parallel schedules are constructed basically independently .",
    "the algorithms for mps@xmath26  require no coordination at all among the schedules . in @xmath30",
    "a schedule only has to report when it fails , i.e.  when a guess on the optimum makespan is too small .",
    "the competitive ratios achieved with parallel schedules are considerably smaller than the best ratios of about 1.92 known for the scenario without resource augmentation .",
    "our ratio of @xmath3 , for small @xmath42 , is lower than the competitiveness of about 1.46 obtained in the settings where a reordering buffer of size @xmath43 is available or @xmath43 jobs may be reassigned .",
    "skutella et al .",
    "@xcite gave an online algorithm that is @xmath6-competitive if , before the assignment of any job @xmath11 , jobs of processing volume @xmath44 may be migrated .",
    "hence the total amount of extra resources used while scheduling @xmath2 depends on the input sequence .",
    "* related work : * makespan minimization with parallel schedules was first studied by kellerer et al .",
    "they assume that @xmath17 machines are available and two schedules may be constructed .",
    "they show that in this case the optimal competitive ratio is 4/3 .",
    "we summarize results known for online makespan minimization without resource augmentation . as mentioned before , _ list _",
    "is @xmath16-competitive .",
    "deterministic online algorithms with a smaller competitive ratio were presented in  @xcite .",
    "the best algorithm currently known is 1.9201-competitive  @xcite .",
    "lower bounds on the performance of deterministic strategies were given in  @xcite .",
    "the best bound currently known is 1.88 , see  @xcite .",
    "no randomized online algorithm whose competitive ratio is provably below the deterministic lower bound is currently known for general @xmath1 .",
    "we next review the results for the various models of resource augmentation .",
    "articles  @xcite study makespan minimization assuming that an online algorithm knows the optimum makespan or the sum of the processing times of @xmath2 .",
    "chen et al .",
    "@xcite developed a 1.6-competitive algorithm .",
    "azar and regev  @xcite showed that no online algorithm can attain a competitive ratio smaller than 4/3 .",
    "the setting in which an online algorithm is given a reordering buffer was explored in  @xcite .",
    "englert et al .",
    "@xcite presented an algorithm that , using a buffer of size @xmath43 , achieves a competitive ratio of @xmath45 , where @xmath46 is the lambert @xmath47 function .",
    "no algorithm using a buffer of size @xmath48 can beat this ratio .",
    "makespan minimization with job migration was addressed in  @xcite .",
    "an algorithm that achieves again a competitiveness of @xmath45 and uses @xmath43 job reassignments was devised in  @xcite .",
    "no algorithm using @xmath48 reassignments can obtain a smaller competitiveness .",
    "sanders et al .",
    "@xcite study a scenario in which before the assignment of each job @xmath11 , jobs up to a total processing volume of @xmath49 may be migrated , for some constant @xmath50 . for @xmath51 , they present a 1.5-competitive algorithm .",
    "they also show a @xmath6-competitive algorithm , for any @xmath41 , where @xmath52 .    as for memory in online algorithms , sleator and tarjan  @xcite studied the paging problem assuming that an online algorithm has a larger fast memory than an offline strategy .",
    "raghavan and snir  @xcite traded memory for randomness in online caching .",
    "* notation : * throughout this paper it will be convenient to associate schedules with algorithms , i.e.  a schedule @xmath21 is maintained by an algorithm @xmath53 that specifies how to assign jobs to machines in @xmath21 .",
    "thus an algorithm @xmath19 for mps  or mps@xmath26  can be viewed as a family @xmath54 of algorithms that maintain the various schedules .",
    "we will write @xmath55 . if @xmath19 is an algorithm for mps@xmath26 ,",
    "then the value @xmath27 is of course given to all algorithms of @xmath54 .",
    "furthermore , the _ load _ of a machine always denotes the sum of the processing times of the jobs already assigned to that machine .",
    "in this section we will show that any @xmath28-competitive algorithm @xmath19 for mps@xmath26  can be used to construct a @xmath29-competitive algorithm @xmath56 for mps , for any @xmath4 .",
    "the main idea is to repeatedly execute @xmath19 for a set of guesses on the optimum makespan .",
    "the initial guesses are small and are increased whenever a guess turns out to be smaller than @xmath27 .",
    "the increments are done in small steps so that , among the final guesses , there exists one that is upper bounded by approximately @xmath57 . in the analysis of this scheme we will have to bound machine loads caused by scheduling `` errors '' made when guesses were too small .",
    "unfortunately the execution of @xmath19 , given a guess @xmath58 , can lead to undefined algorithmic behavior . as we shall show , guesses @xmath59 are not critical .",
    "however , guesses @xmath60 have to be handled carefully .",
    "so let @xmath55 be a @xmath28-competitive algorithm for mps@xmath26  that , given guess @xmath61 , is executed on a job sequence @xmath2 . upon the arrival of a job @xmath11 , an algorithm @xmath62 may _ fail _ because the scheduling rules of @xmath53 do not specify a machine where to place @xmath11 in the current schedule @xmath21 .",
    "we define two further conditions when an algorithm @xmath53 fails .",
    "the first one identifies situations where a makespan of @xmath63 is not preserved and hence @xmath28-competitiveness may not be guaranteed .",
    "more precisely , @xmath53 would assign @xmath11 to a machine @xmath64 such that @xmath65 , where @xmath66 denotes @xmath64 s machine load before the assignment .",
    "the second condition identifies situations where @xmath61 is not consistent with lower bounds on the optimum makespan , i.e.  @xmath61 is smaller than the average machine load or the processing time of @xmath11 . formally , an algorithm @xmath53 _ fails _ if a job @xmath11 , @xmath13 , has to be scheduled and one of the following conditions holds .",
    "a.   @xmath53 does not specify a machine where to place @xmath11 in the current schedule @xmath21 .",
    "b.   there holds @xmath67 , for the machine @xmath64 to which @xmath53 would assign @xmath11 in @xmath21 . c.   there holds @xmath68 or @xmath69 .",
    "we first show that guesses @xmath70 are not problematic .",
    "if a @xmath28-competitive algorithm @xmath55 for mps@xmath26 is given a guess @xmath59 , then there exists an algorithm @xmath62 that does not fail during the processing of @xmath2 and generates a schedule whose makespan is at most @xmath63 .",
    "this is shown by the next lemma .",
    "[ lem : guess1 ] let @xmath55 be a @xmath28-competitive algorithm for mps@xmath26 that , given guess @xmath61 , is executed on a job sequence @xmath2 with @xmath59 .",
    "then there exists an algorithm @xmath62 that does not fail during the processing of @xmath2 and generates a schedule whose makespan is at most @xmath63 .",
    "let @xmath71 be an optimal schedule for the job sequence @xmath0",
    ". moreover , let @xmath66 denote the load of machine @xmath64 in @xmath71 , @xmath72 .",
    "for any @xmath73 with @xmath74 , define a job @xmath75 of processing time @xmath76 .",
    "let @xmath77 be the job sequence consisting of @xmath2 followed by the new jobs @xmath75 .",
    "these up to @xmath1 jobs may be appended to @xmath2 in any order .",
    "obviously @xmath78 .",
    "hence when @xmath23 using guess @xmath61 is executed on @xmath77 , there must exist an algorithm @xmath79 that generates a schedule with a makespan of at most @xmath63 .",
    "since @xmath2 is a prefix of @xmath77 , this algorithm @xmath80 does not fail and generates a schedule with a makespan of at most @xmath63 , when @xmath19 given guess @xmath61 is executed on @xmath2 .",
    "* algorithm for mps : * we describe our algorithm @xmath81 for mps , where @xmath4 and @xmath82 may be chosen arbitrarily .",
    "the construction takes as input any algorithm @xmath55 for mps@xmath26 . for a proper choice of @xmath83",
    ", @xmath81 will be @xmath29-competitive , provided that @xmath19 is @xmath28-competitive .    at any time @xmath81 works with @xmath83 guesses @xmath84 on the optimum makespan for the incoming job sequence @xmath2 .",
    "these guesses may be adjusted during the processing of @xmath2 ; the update procedure will be described in detail below . for each guess",
    "@xmath85 , @xmath86 , @xmath81 executes @xmath19 .",
    "hence @xmath81 maintains a total of @xmath87 schedules , which can be partitioned into subsets @xmath88 .",
    "subset @xmath89 contains those schedules generated by @xmath19 using @xmath85 , @xmath86 .",
    "let @xmath90 denote the schedule generated by @xmath53 using @xmath85 .",
    "a job sequence @xmath2 is processed as follows .",
    "initially , upon the arrival of the first job @xmath91 , the guesses are initialized as @xmath92 and @xmath93 , for @xmath94 .",
    "each job @xmath11 , @xmath13 , is handled in the following way .",
    "of course each such job is sequenced in every schedule @xmath95 , @xmath86 and @xmath96 .",
    "algorithm @xmath81 checks if @xmath53 using @xmath85 fails when having to sequence @xmath11 in @xmath95 .",
    "we remark that this check can be performed easily by just verifying if one of the conditions ( i  iii ) holds .",
    "if @xmath53 using @xmath85 does not fail and has not failed since the last adjustment of @xmath85 , then in @xmath95 job @xmath11 is assigned to the machine specified by @xmath53 using @xmath85 .",
    "the initialization of a guess is also regarded as an adjustment .",
    "if @xmath53 using @xmath85 does fail , then @xmath11 and all future jobs are always assigned to a least loaded machine in @xmath95 until @xmath85 is adjusted the next time .",
    "suppose that after the sequencing of @xmath11 all algorithms of @xmath55 using a particular guess @xmath85 have failed since the last adjustment of this guess .",
    "let @xmath97 be the largest index @xmath98 with this property .",
    "then the guesses @xmath99 are adjusted .",
    "set @xmath100 and @xmath93 , for @xmath101 . for",
    "any readjusted guess @xmath85 , @xmath102 , algorithm @xmath19 using @xmath85 ignores all jobs @xmath14 with @xmath103 when processing future jobs of @xmath2 . specifically , when making scheduling decisions and determining machine loads , algorithm @xmath53 using @xmath85 ignores all job @xmath14 with @xmath103 in its schedule @xmath95 .",
    "these jobs are also ignored when @xmath81 checks if @xmath53 using guess @xmath85 fails on the arrival of a job .",
    "furthermore , after the assignment of @xmath11 , machines in @xmath95 machines are renumbered so that @xmath11 is located on a machine it would occupy if it were the first job of an input sequence .",
    "when guesses have been adjusted , they are renumbered , together with the corresponding schedule sets @xmath89 , such that again @xmath84 . hence at any time @xmath104 and @xmath105 , for @xmath94 .",
    "we also observe that whenever a guess is adjusted , its value increases by a factor of at least @xmath106 .",
    "a summary of @xmath81 is given in figure  [ fig:1 ] .",
    "we obtain the following theorem .",
    "[ th : guess1 ] let @xmath107 be a @xmath28-competitive algorithm for mps@xmath26 . then for any @xmath4 and @xmath108 , algorithm @xmath109 for mps is @xmath29-competitive and uses @xmath110 schedules .    for the analysis of @xmath81 we need the following lemma .",
    "[ lem : guess2 ] after @xmath81 has processed a job sequence @xmath2 , there holds @xmath111 .    at any time @xmath81",
    "maintains @xmath83 guesses .",
    "we can view these guesses as being stored in @xmath83 variables .",
    "a variable is updated whenever its current guess is increased .",
    "hence during the processing of @xmath2 a variable may take any position in the sorted sequence of guesses .",
    "we analyze the steps in which @xmath81 adjusts guesses .",
    "we first show that when @xmath81 adjusts a guess @xmath61 , then @xmath60 .",
    "so suppose that after the arrival of a job @xmath11 , @xmath81 adjust guesses @xmath112 , where @xmath97 is the largest index @xmath98 such that all algorithms @xmath54 using @xmath85 have failed .",
    "we prove @xmath113 , which implies the desired statement because guesses are numbered in order of increasing value .",
    "let @xmath114 , with @xmath115 , be the most recent time when the variable storing @xmath116 was updated last .",
    "if the variable has never been updated since its initialization , then let @xmath117 .",
    "all the algorithms @xmath54 using @xmath116 ignore the jobs having arrived before @xmath118 when making scheduling decisions for @xmath119 .",
    "let @xmath120 .",
    "there holds , @xmath121 .",
    "if @xmath122 held true , then by lemma  [ lem : guess1 ] there would be an algorithm @xmath123 that , using guess @xmath116 , does not fail when handling @xmath124 .",
    "this contradicts the fact that at time @xmath125 all algorithms @xmath54 using @xmath116 fail or have failed since the arrival of @xmath118 .",
    "let @xmath126 denote the value of the smallest guess when @xmath81 has finished processing @xmath2 .",
    "we distinguish two cases depending on whether or not the variable storing @xmath126 has ever been updated since its initialization .",
    "if the variable has never been updated , then @xmath127 , for some @xmath128 .",
    "if @xmath129 , there is nothing to show because @xmath130 . if @xmath131 , then the initial guess of value @xmath132 must have been adjusted",
    "this implies , as shown above , @xmath133 and the lemma follows because @xmath134 .",
    "in the remainder of the proof we assume that the variable @xmath135 storing @xmath126 has been updated .",
    "consider the last update of @xmath135 before the end of @xmath2 and suppose that it took place on the arrival of job @xmath118 .",
    "first assume that @xmath135 stores the smallest guess , among the @xmath83 guesses , before the update .",
    "then @xmath136 , where @xmath137 is the largest guess before the update .",
    "if @xmath137 is also adjusted on the arrival of @xmath118 , then we are done because , as shown above , @xmath138 and thus @xmath139 . if @xmath137 is not adjusted on the arrival of @xmath118 , then @xmath126 is the smallest guess greater than @xmath137 after the update . by the end of @xmath2 guess @xmath137 must be adjusted since otherwise @xmath126 can not become the smallest guess . again @xmath138 and we are done .    finally assume that before the update @xmath135 does not store the smallest guess .",
    "let @xmath140 be the variable that stores the largest guess smaller than that in @xmath135 .",
    "after the update there holds @xmath141 , where @xmath61 is the guess stored in @xmath140 after the update . until the end of @xmath2 , @xmath61 must be adjusted again since otherwise @xmath126 can not become the smallest guess . again",
    "@xmath142 and hence @xmath143 .    throughout the proof",
    "let @xmath108 and @xmath109 .",
    "consider an arbitrary job sequence and let @xmath144 be the smallest of the @xmath83 guesses maintained by @xmath56 at the end of @xmath2 .",
    "let @xmath145 be the set of schedules associated with @xmath144 , i.e.  @xmath145 was generated by @xmath107 using a series of guesses ending with @xmath144 .",
    "let @xmath146 , with @xmath147 , be this series and @xmath135 be the variable that stored these guesses . here",
    "@xmath148 is one of the initial guesses and @xmath149 .",
    "a first observation is that at the end of @xmath2 there exists an algorithm @xmath123 that using @xmath144 has not failed .",
    "this holds true if @xmath135 was set to @xmath150 upon the arrival of a job @xmath11 with @xmath151 because the failure of all algorithms @xmath54 using @xmath144 would have caused an adjustment of @xmath144 .",
    "this also holds true if @xmath135 was set to @xmath144 upon the arrival of @xmath152 because in this case none of the algorithms @xmath54 using @xmath144 has failed at the end of @xmath2 .",
    "so let @xmath123 be an algorithm that using @xmath144 has not failed and let @xmath153 be the associated schedule .",
    "we prove that the load of every machine in @xmath153 is upper bounded by @xmath154 .",
    "this establishes the theorem .",
    "let @xmath155 .",
    "if the variable @xmath135 was updated during the processing of @xmath2 , then let @xmath156 be these points in time , i.e.  the arrival of @xmath157 caused an update of @xmath135 and the variable was set to @xmath158 , @xmath159 . for any machine @xmath64 , @xmath160 , in @xmath153 let @xmath66 denote its final load at the end of @xmath2",
    ". moreover , let @xmath161 denote its load due to jobs @xmath11 with @xmath162 , for @xmath163 .",
    "obviously @xmath164",
    "we first show that @xmath165 .",
    "immediately after @xmath166 has been scheduled @xmath64 s load consisting of jobs @xmath14 with @xmath167 is at most @xmath168 .",
    "since @xmath135 was set to @xmath169 on the arrival of @xmath166 , the guess adjustment rule ensures @xmath170 .",
    "until the end of @xmath2 algorithm @xmath80 using @xmath144 does not fail and hence condition  ( ii ) specifying the failure of algorithms implies that the assignment of each further job does not create a machine load greater than @xmath171 in @xmath153 .",
    "we next show @xmath172 , for each @xmath173 .",
    "the latter difference is the load on machine @xmath64 caused by jobs of the subsequence @xmath174 .",
    "hence it suffices to show that after the assignment of any @xmath11 , with @xmath175 , @xmath64 s load due to jobs @xmath14 , with @xmath176 , is at most @xmath177 .",
    "after the assignment of @xmath157 @xmath64 s respective load @xmath161 is at most @xmath178 and this value is upper bounded by @xmath158 as ensured by the guess adjustment rule . at times",
    "@xmath179 , while @xmath80 using @xmath158 has not failed , @xmath64 s load due to jobs @xmath14 with @xmath176 does not exceed @xmath180 as ensured by condition  ( ii ) specifying the failure of algorithms . finally consider a time @xmath125 , @xmath181 , at which @xmath80 fails or has failed .",
    "the incoming job @xmath11 is assigned to a least loaded machine .",
    "hence if @xmath11 is placed on @xmath64 , then the resulting machine load due to jobs @xmath14 with @xmath176 is upper bounded by @xmath182 .",
    "observe that after the arrival of @xmath11 there exists an algorithm @xmath62 that using @xmath158 has not yet failed , since otherwise @xmath158 would be adjusted before time @xmath183 .",
    "condition  ( iii ) defining the failure of algorithms ensures that @xmath184 and @xmath185 .",
    "we obtain that @xmath64 s machine load is at most @xmath186 .",
    "we conclude that ( [ eq : b1 ] ) is upper bounded by @xmath187 by lemma  [ lem : guess2 ] , @xmath188 . at the end of the description of @xmath81 we observed that whenever a guess is adjusted it increases by a factor of at least @xmath106 .",
    "hence @xmath189 .",
    "it follows that @xmath190 , for every @xmath191 .",
    "hence  ( [ eq : b2 ] ) is upper bounded by @xmath192 here  ( [ eq : xb2 ] ) uses the fact that @xmath193 and , as mentioned above , is a consequence of lemma  [ lem : guess2 ] .",
    "line  ( [ eq : b3 ] ) follows from the geometric series and , finally , ( [ eq : b4 ] ) is by the choice of @xmath83 and the assumption @xmath31 .",
    "we present an algorithm @xmath195 for mps@xmath26  that attains a competitive ratio of @xmath10 , for any @xmath41 . the number of parallel schedules will be @xmath36 .",
    "the algorithms will yield a @xmath6-competitive strategy for @xmath196 and , furthermore , will be useful in the next section where we develop a @xmath3-competitive algorithm for mps@xmath26 . there",
    "@xmath195 will be used as subroutine for a small , constant number of @xmath1 .",
    "* description of @xmath195 : * let @xmath41 be arbitrary . recall that in mps@xmath26  the optimum makespan @xmath27 for the incoming job sequence @xmath2 is initially known .",
    "assume without loss of generality that @xmath197 .",
    "then all job processing times are in @xmath198 $ ] .",
    "set @xmath199 .",
    "first we partition the range of possible job processing times into intervals @xmath200 such , within each interval @xmath201 with @xmath202 , the values differ by a factor of at most @xmath203 .",
    "such a partitioning is standard and has been used e.g.  in the ptas for offline makespan minimization  @xcite .",
    "let @xmath204 .",
    "set @xmath205 $ ] and @xmath206 $ ] , for @xmath207 .",
    "obviously @xmath208 $ ] and @xmath198 \\subseteq ( 0 , ( 1+{\\varepsilon}')^l{\\varepsilon}']$ ] .",
    "a job is _ small _ if its processing time is at most @xmath209 and hence contained in @xmath210 ; otherwise the job is _",
    "large_.    each job sequence @xmath2 with @xmath211 contains at most @xmath212 large jobs . for each possible distribution of large jobs over the processing time intervals @xmath213 ,",
    "algorithm @xmath195 prepares one algorithm / schedule .",
    "let @xmath214 .",
    "there holds @xmath215 .",
    "let @xmath216 .",
    "for any vector @xmath217 , algorithm @xmath218 works as follows .",
    "it assumes that the incoming job sequence @xmath2 contains exactly @xmath219 jobs with a processing time in @xmath201 , for @xmath207 .",
    "moreover , it pessimistically assumes that each processing time in @xmath201 takes the largest possible value @xmath220 .",
    "hence , initially @xmath218 computes an optimal schedule @xmath221 for a job sequence consisting of @xmath219 jobs with a processing time of @xmath220 , for @xmath207 .",
    "small jobs are ignored . since running time",
    "is not an issue in the design of online algorithms , such a schedule @xmath221 can be computed exactly .",
    "alternatively , an @xmath222-approximation to the optimal schedule can be computed using the ptas by hochbaum and shmoys  @xcite .",
    "let @xmath223 denote the number of jobs with a processing time of @xmath224 assigned to machine @xmath64 in @xmath221 , where @xmath225 and @xmath160 .",
    "moreover , let @xmath226 be the load on machine @xmath64 in @xmath221 , @xmath72 .",
    "when processing the actual job sequence @xmath2 and constructing a real schedule @xmath227 , @xmath218 uses @xmath221 as a guideline to make scheduling decisions . at any time during the scheduling process , let @xmath228 be the number of jobs with a processing time in @xmath201 that have already been assigned to machine @xmath64 in @xmath227 , where again @xmath225 and @xmath160 .",
    "each incoming job @xmath11 , @xmath229 , is handled as follows .",
    "if @xmath11 is large , then let @xmath201 with @xmath225 be the interval such that @xmath230 .",
    "algorithm @xmath218 checks if there is a machine @xmath64 such that @xmath231 , i.e.  there is a machine that can still accept a job with a processing time in @xmath201 as suggested by the optimal schedule @xmath221 .",
    "if such a machine @xmath64 exists , then @xmath11 is assigned to it ; otherwise @xmath11 is scheduled on an arbitrary machine .",
    "if @xmath11 is small , then @xmath11 is assigned to a machine @xmath64 with the smallest current value @xmath232 . here",
    "@xmath233 denotes the current load on machine @xmath64 caused by small jobs in @xmath227 .",
    "a summary of @xmath195 is given in figure  [ fig:2 ] .",
    "subsequently we show theorem  [ th : guess2 ] .",
    "[ th : guess2 ] for any @xmath234 , @xmath195 is @xmath6-competitive and uses at most @xmath36 schedules .",
    "the bound on the number of schedules simply follows from the fact that @xmath195 maintains @xmath235 schedules where @xmath236 and @xmath204 .",
    "let @xmath2 be an arbitrary job sequence and let @xmath219 be the number of jobs with a processing time in @xmath201 , for @xmath207 . since any @xmath219 is upper bounded by @xmath237 , the resulting vector @xmath238 is in @xmath239 . for this vector @xmath240 ,",
    "consider the associated algorithm @xmath218 .",
    "we prove that when @xmath218 has finished processing @xmath2 , the resulting schedule @xmath227 has a makespan of at most @xmath241 .",
    "recall again that we assume without loss of generality that @xmath197 .",
    "we analyze the steps in which @xmath218 assigns jobs @xmath11 , @xmath229 , to machines in @xmath227 .",
    "if @xmath11 is large with @xmath230 , @xmath242 , then there must exist a machine @xmath64 in the current schedule @xmath227 such that @xmath243 .",
    "algorithm @xmath218 will assign @xmath11 to such a machine .",
    "hence after the processing of @xmath2 , for any @xmath64 in @xmath227 , the total load caused by large jobs is upper bounded by @xmath244 .",
    "we next argue that this value is at most @xmath245 .",
    "consider an optimal schedule @xmath71 for @xmath2 .",
    "modify this schedule by ( a )  deleting all small jobs and ( b )  rounding each job processing time in @xmath201 to @xmath220 , for @xmath246 . the resulting schedule schedule @xmath247 has a makespan of at most @xmath245 .",
    "furthermore @xmath247 is a schedule for an input sequence consisting of @xmath219 jobs of processing time @xmath220 .",
    "since @xmath248 is an optimal schedule for this input , each machine load @xmath244 is upper bounded by @xmath245 .",
    "we finally show that when @xmath218 has to sequence a small job @xmath11 , then there is a machine @xmath64 such that @xmath232 is upper bounded by @xmath245 .",
    "this implies that the assignment of @xmath11 causes a machine load of at most @xmath249 in the final schedule @xmath227 .",
    "so suppose that upon the arrival of a small job @xmath11 there holds @xmath250 for all machines @xmath64 , @xmath160 .",
    "recall that @xmath233 is the load on machine @xmath64 caused by small jobs in the current schedule @xmath227 .",
    "note that @xmath251 is the total processing time of large jobs in @xmath2 if processing times in @xmath201 are rounded up to @xmath220 , for @xmath207 .",
    "hence @xmath252 is a lower bound on the total processing time of large jobs in @xmath2 .",
    "it follows that the total processing time of all jobs in @xmath2 is at least @xmath253 .",
    "the assumption that @xmath250 holds for all machines @xmath64 implies that the total processing time of jobs in @xmath2 is at least @xmath254 , which contradicts the fact that @xmath27 is the optimum makespan .",
    "we develop an algorithm @xmath256 for mps@xmath26  that is @xmath3-competitive , for any @xmath4 , if the number @xmath1 of machines is not too small .",
    "we then combine @xmath256 with @xmath195 , presented in the last section , and derive a strategy @xmath257 that is @xmath3-competitive , for arbitrary @xmath1 .",
    "the number of required schedules is @xmath5 , which is a constant independent of @xmath258 and @xmath1 .",
    "we firstly present a description of the algorithm ; the corresponding analysis is given thereafter .    before describing @xmath256 in detail ,",
    "we explain the main ideas of the algorithm .",
    "one concept is identical to that used by @xmath195 : partition the range of possible job processing times into intervals or _ job classes _ and consider distributions of jobs over these classes .",
    "however , in order to achieve a constant number of schedules we have to refine this scheme and incorporate new ideas .",
    "first , the job classes have to be chosen properly so as to allow a compact packing of jobs on the machines .",
    "an important , new aspect in the construction of @xmath256 is that we will not consider the entire set @xmath239 of tuples specifying how large jobs of an input sequence  @xmath2 are distributed over the job classes .",
    "instead we will define a suitable sparsification @xmath259 of @xmath239 .",
    "each @xmath260 represents an estimate or guess on the number of large jobs arising in @xmath2 . more specifically ,",
    "if @xmath261 , then it is assumed that @xmath2 contains at least @xmath219 jobs with a processing time of job class @xmath98 .    obviously , the job sequence @xmath2 may contain more large jobs , the exact number of which is unknown .",
    "furthermore , it is unknown which portion of the total processing time of @xmath2 will arrive as small jobs . in order to cope with these uncertainties @xmath256",
    "has to construct robust schedules .",
    "to this end the number of machines is partitioned into two sets @xmath262 and @xmath263 . for the machines of @xmath262 ,",
    "the algorithm initially determines a good assignment or _ configuration _ assuming that @xmath219 jobs of job class @xmath98 will arrive .",
    "the machines of @xmath263 are reserve machines and will be assigned additional large jobs as they arise in @xmath2 .",
    "small jobs will always be placed on machines in @xmath262 .",
    "the initial configuration determined for these machines has the property that , no matter how many small jobs arrive , a machine load never exceeds @xmath264 times the optimum makespan .",
    "we proceed to describe @xmath256 in detail .",
    "let @xmath4 .",
    "moreover , set @xmath265 .",
    "again we assume without loss of generality that , for an incoming job sequence , there holds @xmath197 .",
    "hence the processing time of any job is upper bounded by  1 .    * job classes : * a job @xmath11 , @xmath13 , is _ small _ if @xmath266 ; otherwise @xmath11 is",
    "_ large_. we divide the range of possible job processing times into job classes .",
    "let @xmath267 $ ] be the interval containing the processing times of small jobs .",
    "let @xmath268 and @xmath269 , where the logarithm is taken to base  2 .",
    "for @xmath207 , let @xmath270 it is easy to verify that @xmath271 and @xmath272 , for @xmath207 . furthermore @xmath273 and @xmath274 . for @xmath207 define @xmath275 $ ] .",
    "there holds @xmath276 $ ] .",
    "moreover , for @xmath277 , let @xmath278 $ ] .",
    "intuitively , @xmath279 contains the processing times that are twice as large as those in @xmath201 , @xmath280 .",
    "there holds @xmath281 $ ] .",
    "hence @xmath282 $ ] . in",
    "the following @xmath201 represents _ job class _ @xmath98 , for @xmath283 .",
    "we say that @xmath11 is a _",
    "class-@xmath98 job _",
    "if @xmath230 , where @xmath284 .",
    "* definition of target configurations : * as mentioned above , for any incoming job sequence @xmath2 , @xmath256 works with estimates on the number of class-@xmath98 jobs arising in @xmath2 , @xmath284 . for each estimate",
    ", the algorithm initially determines a virtual schedule or _ target configuration _ on a subset of the machines , assuming that the estimated set of large jobs will indeed arrive .",
    "hence we partition the @xmath1 machines into two sets @xmath262 and @xmath263 .",
    "let @xmath285 .",
    "moreover , let @xmath286 and @xmath287 .",
    "set @xmath262 contains the machines for which a target configuration will be computed ; @xmath263 contains the reserve machines .",
    "the proportion of @xmath288 to @xmath289 is roughly @xmath290 .",
    "a target configuration has the important property that any machine @xmath291 contains large jobs of only one job class @xmath98 , @xmath284 .",
    "therefore , a target configuration is properly defined by a vector @xmath292 .",
    "if @xmath293 , then @xmath64 does not contain any large jobs in the target configuration , @xmath294 .",
    "if @xmath295 , where @xmath296 , then @xmath64 contains class-@xmath98 jobs , @xmath294 .",
    "the vector @xmath297 implicitly also specifies how many large jobs reside on a machine .",
    "if @xmath295 with @xmath225 , then @xmath64 contains two class-@xmath98 jobs .",
    "note that , for general @xmath298 , a third job can not be placed on the machine without exceeding a load bound of @xmath264 .",
    "if @xmath295 with @xmath299 , then @xmath64 contains one class-@xmath98 job .",
    "again , the assignment of a second job is not feasible in general . given a configuration @xmath297 , @xmath64 is referred to as a _ class-@xmath98 machine _ if @xmath295 , where @xmath300 and @xmath284 .    with the above interpretation of target configurations , each vector @xmath301 encodes inputs containing @xmath302 class-@xmath98 jobs , for @xmath246 , as well as @xmath303 class-@xmath98 jobs , for @xmath304 .",
    "hence , for an incoming job sequence , instead of considering estimates on the number of class-@xmath98 jobs , for any @xmath284 , we can equivalently consider target configurations .",
    "unfortunately , it will not be possible to work with all target configurations @xmath305 since the resulting number of schedules to be constructed would be @xmath306 .",
    "therefore , we will work with a suitable sparsification of the set of all configurations .",
    "* sparsification of the set of target configurations : * let @xmath307 and @xmath308 .",
    "we will show that @xmath309 if @xmath1 is not too small ( see lemma  [ lem : kappa ] ) .",
    "this property in turn will ensure that any job sequence @xmath2 can be mapped to a @xmath310 . for any vector @xmath311",
    ", we define a target configuration @xmath312 that contains @xmath313 class-@xmath98 machines , for @xmath283 , provided that @xmath314 does not exceed @xmath315 . more specifically , for any @xmath311 , let @xmath316 and @xmath317 , be the partial sums of the first @xmath98 entries of @xmath318 , multiplied by @xmath319 , for @xmath283 .",
    "let @xmath320 .",
    "first construct a vector @xmath321 of length @xmath322 that contains exactly @xmath313 class-@xmath98 machines .",
    "that is , for @xmath283 , let @xmath323 for @xmath324 .",
    "we now truncate or extend @xmath325 to obtain a vector of length @xmath315 .",
    "if @xmath326 , then @xmath312 is the vector consisting of the first @xmath315 entries of @xmath325 .",
    "if @xmath327 , then @xmath328 , i.e.the last @xmath329 entries are set to  0 .",
    "let @xmath330 be the set of all target configurations constructed from vectors @xmath310 .    * the algorithm family : * let @xmath331 .",
    "for any @xmath332 , algorithm @xmath333 works as follows .",
    "initially , prior to the arrival of any job of @xmath2 , @xmath333 determines the target configuration specified by @xmath334 and uses this virtual schedule for the machines of @xmath262 to make scheduling decisions .",
    "consider a machine @xmath291 and suppose @xmath335 , i.e.  @xmath64 is a class-@xmath98 machine for some @xmath202 .",
    "let @xmath336 and @xmath337 be the targeted minimal and maximal loads caused by large jobs on @xmath64 , according to the target configuration .",
    "more precisely , if @xmath298 , then @xmath338 and @xmath339 . recall that in a target configuration a class-@xmath98 machine contains two class-@xmath98 jobs if @xmath225 . if @xmath340 and hence @xmath341 for some @xmath342 , then @xmath343 and @xmath344 . if @xmath345 is a machine with @xmath346 , then @xmath347",
    ". while the job sequence @xmath2 is processed , a machine @xmath291 may or may not be _",
    "again assume that @xmath64 is a class-@xmath98 machine with @xmath202 .",
    "if @xmath348 , then at any time during the scheduling process @xmath64 is admissible if it has received less than two class-@xmath98 jobs so far .",
    "analogously , if @xmath349 , then @xmath64 is admissible if it has received no class-@xmath98 job so far . finally , at any time during the scheduling process , let @xmath66 be the current load of machine @xmath64 and let @xmath233 be the load due to small jobs , @xmath160 .",
    "algorithm @xmath333 schedules each incoming job @xmath11 , @xmath13 , in the following way .",
    "first assume that @xmath11 is a large job and , in particular , a class-@xmath98 job , @xmath284 .",
    "the algorithm checks if there is a class-@xmath98 machine in @xmath262 that is admissible .",
    "if so , @xmath11 is assigned to such a machine .",
    "if there is no admissible class-@xmath98 machine available , then @xmath11 is placed on a machine in @xmath263 .",
    "there jobs are scheduled according to the _ best - fit _ policy . more specifically , @xmath333 checks if there exists a machine @xmath350 such that @xmath351 .",
    "if this is the case , then @xmath11 is assigned to such a machine with the largest current load @xmath66 .",
    "if no such machine exists , @xmath11 is assigned to an arbitrary machine in @xmath263 .",
    "next assume that @xmath11 is small .",
    "the job is a assigned to a machine in @xmath262 , where preference is given to machines that have already received small jobs .",
    "algorithm @xmath333 checks if there is an @xmath291 with @xmath352 such that @xmath353 .",
    "if this is the case , then @xmath11 is assigned to any such machine .",
    "otherwise @xmath333 considers the machines of @xmath262 which have not yet received any small jobs . if there exists an @xmath291 with @xmath354 such that @xmath355 , then among these machines @xmath11 is assigned to one having the smallest targeted load @xmath336 .",
    "if again no such machine exists , @xmath11 is assigned to an arbitrary machine in @xmath262 .",
    "a summary of @xmath256 , which focuses on the job assignment rules , is given in figure  [ fig:3 ] .",
    "we obtain the following result .",
    "[ th : alg2 ] @xmath256 is @xmath3-competitive , for any @xmath31 and @xmath356 .",
    "the algorithm uses @xmath5 schedules .",
    "@xmath256 is @xmath3-competitive if , for the chosen @xmath42 , the number of machines is at least @xmath357",
    ". if the number of machines is smaller , we can simply apply algorithm @xmath195 with an accuracy of @xmath358 .",
    "let @xmath257 be the following combined algorithm . if for the chosen @xmath42 , @xmath359 , execute @xmath360 .",
    "otherwise execute @xmath256 .",
    "[ cor : a3 ] @xmath257 is @xmath3-competitive , for any @xmath31 , and uses @xmath5 schedules .",
    "if @xmath360 is executed for a machine number @xmath359 , then by theorem  [ th : guess2 ] the number of schedules is @xmath361 , which is @xmath362 .    in the remainder of this section",
    "we prove theorem  [ th : alg2 ] .",
    "the stated number of schedules follows from the fact that @xmath256 consists of @xmath363 algorithms .",
    "recall that @xmath307 and @xmath364 .",
    "hence @xmath365 and @xmath366 , which gives that @xmath367 is @xmath5 .",
    "hence it suffices to show that , for any job sequence @xmath2 , @xmath256 generates a schedule whose makespan is at most @xmath368 , which we will do in the remainder of this section .",
    "more specifically we will prove that , for any @xmath2 , there exists a target configuration @xmath332 that accurately models the large jobs arising in @xmath2 .",
    "we will refer to such a vector as a valid target configuration .",
    "then we will show that the corresponding algorithm @xmath333 builds a schedule with a makespan of at most @xmath368 .",
    "we introduce some notation .",
    "consider any job sequence @xmath2 .",
    "for any @xmath98 , @xmath284 , let @xmath369 be the number of class-@xmath98 jobs arising in @xmath2 , i.e.  @xmath369 is the number of jobs @xmath11 with @xmath230 .",
    "furthermore , for any target configuration @xmath370 and any @xmath98 with @xmath284 , let @xmath371 be the number of class-@xmath98 machines in @xmath297 , i.e.   @xmath372 .",
    "let @xmath373 be the total number of class-@xmath98 machines with @xmath348 .",
    "similarly , @xmath374 is the total number of class-@xmath98 machines with @xmath349 .",
    "given @xmath2 , vector @xmath332 will be a valid target configuration if , for any @xmath283 , @xmath2 contains as many class-@xmath98 jobs as specified in @xmath297 and , moreover , if all the additional large jobs can be feasibly scheduled on the @xmath375 reserve machines .",
    "recall that in a configuration @xmath297 , any class-@xmath98 machine with @xmath225 is supposed to contain two class-@xmath98 jobs .",
    "formally , @xmath332 is a _ valid target configuration _ if the following three conditions hold .",
    "a.   for @xmath246 , there holds @xmath376 .",
    "b.   for @xmath304 , there holds @xmath377 . c.   @xmath378    conditions ( i ) and",
    "( ii ) represent the constraint that @xmath2 contains as many class-@xmath98 jobs as specified in @xmath297 , @xmath284 . condition ( iii ) models the requirement that extra large jobs can be feasibly packed on the reserve machines . here",
    "@xmath379 is the extra number of class-@xmath98 jobs with @xmath348 in @xmath2 .",
    "any two of these can be packed on one machine since the processing time of any of these jobs is upper bounded by @xmath380 .",
    "hence two jobs incur a machine load of at most @xmath381 .",
    "analogously , @xmath382 is the extra number of class-@xmath98 jobs with @xmath349 , which can not be combined together because their processing times are greater than @xmath383 .    in order to prove that , for any @xmath2 , there exists a valid target configuration",
    "we need two lemmas .",
    "[ lem : jobs ] for any @xmath2 , there holds @xmath384 .",
    "consider any optimal schedule @xmath385 for @xmath2 and recall that we assume without loss of generality that @xmath197 . in @xmath385",
    "any machine containing a class-@xmath98 job with @xmath349 can not contain an additional large job : the class-@xmath98 job causes a load greater than @xmath386 and any additional large job , having a processing time greater than @xmath387 , would generate a total load greater than  1 .",
    "furthermore , any machine containing a class-@xmath98 job with @xmath298 can contain at most one additional job of the job classes @xmath388 because two further jobs would generate a total load greater than @xmath389 .",
    "[ lem : kappa ] for any @xmath390 , there holds @xmath391 if @xmath392 .",
    "there holds @xmath393 where the last line follows because of @xmath356 and @xmath394 , for any @xmath395 .",
    "the next lemma establishes the existence of valid target configurations .",
    "[ lem : config ] for any @xmath2 , there exists a valid target configuration @xmath332 if @xmath356 .    in this proof",
    "let @xmath396 .",
    "given @xmath2 , we first construct a vector @xmath310 .",
    "lemma  [ lem : jobs ] implies that for any job class @xmath98 , @xmath225 , there holds @xmath397 . for any job class @xmath98 , @xmath299",
    ", there holds @xmath398 . by lemma  [ lem : kappa ] , @xmath399 , which is equivalent to @xmath400 . for any @xmath98 with @xmath225 ,",
    "set @xmath401 .",
    "for any @xmath98 with @xmath299 , set @xmath402 .",
    "then @xmath403 , for @xmath404 , and the resulting vector @xmath405 is element of @xmath406 . we next show that the vector @xmath312 constructed by @xmath256 is a valid target configuration .",
    "when @xmath256 constructs @xmath312 , it first builds a vector @xmath407 of length @xmath408 containing exactly @xmath409 entries with @xmath323 , for @xmath404 . if @xmath326 , then @xmath312 contains the first @xmath315 entries of @xmath325 .",
    "if @xmath410 , then @xmath312 is obtained from @xmath325 by adding @xmath329 entries of value  0 . in either case @xmath312 contains at most @xmath409 entries of values @xmath98 , for @xmath404 .",
    "hence for the target configuration @xmath312 , there holds @xmath411 , for @xmath404 , where @xmath371 is again the total number of class-@xmath98 machines in @xmath312 .",
    "if @xmath412 , then @xmath413 , which is equivalent to @xmath376 .",
    "similarly , if @xmath349 , then @xmath414 .",
    "therefore , conditions  ( i ) and ( ii ) defining valid target configurations are satisfied and we are left to verify condition  ( iii ) .",
    "first assume @xmath326 .",
    "in this case the vector @xmath312 contains no entries of value  0 and hence @xmath415 . recall that @xmath373 is the total number of class-@xmath98 machines with @xmath298 specified in @xmath312 .",
    "similarly , @xmath374 is the total number of class-@xmath98 machines with @xmath340 . by lemma  [ lem : jobs ] , @xmath384 . subtracting the equation @xmath416",
    ", we obtain @xmath417 there holds @xmath418 because @xmath419 is an integer .",
    "hence condition  ( iii ) defining valid target configurations is satisfied .",
    "it remains to study the case @xmath420 . for any @xmath98 with @xmath340",
    ", there holds @xmath421 and hence @xmath422 , which is equivalent to @xmath423 .",
    "hence @xmath424 the sum @xmath425 is the total number of entries @xmath426 with @xmath427 in @xmath325 . since @xmath428 , none of these entries is deleted when @xmath312 is derived from @xmath325 .",
    "hence @xmath429 is the total number of class-@xmath98 machines with @xmath340 specified in @xmath312 .",
    "we conclude @xmath430    for any @xmath98 with @xmath298 , there holds @xmath431 and hence @xmath432 .",
    "this implies @xmath433 . since @xmath434 is an integer we obtain @xmath435 .",
    "thus @xmath436 again @xmath437 because @xmath325 contains exactly @xmath438 entries @xmath426 with @xmath439 and all of these entries are contained in @xmath312 representing class-@xmath98 machines for @xmath298 .",
    "inequalities  ( [ eq : n1 ] ) and ( [ eq : n2 ] ) together with the identity @xmath396 imply @xmath440 since again @xmath441 , condition  ( iii ) defining valid target configurations holds .",
    "we next analyze the scheduling steps of @xmath256 .",
    "[ lem : sched1 ] let @xmath333 be any algorithm of @xmath256 processing a job sequence @xmath2 . at any time there",
    "exists at most one machine @xmath291 with @xmath352 and @xmath442 in the schedule maintained by @xmath333 .",
    "consider any point in time while @xmath333 sequences @xmath2 .",
    "suppose that there exists a machine @xmath291 with @xmath352 and @xmath442 .",
    "we show that if a small job @xmath11 arrives and @xmath333 assigns it to a machine @xmath443 with @xmath444 , then @xmath445 so that no new machine with the property specified in the lemma is generated .",
    "a first observation is that @xmath64 is not a class-@xmath32 machine because in this case @xmath336 would be @xmath446 .",
    "also , if @xmath447 is a class-@xmath32 machine , there is nothing to show because , again , in this case @xmath448 .",
    "so assume that @xmath333 assigns @xmath11 to a machine @xmath443 , which is not a class-@xmath32 machine , and @xmath444 prior to the assignment .",
    "we first show that @xmath449 .",
    "consider the scheduling step in which @xmath333 assigned the first small job @xmath14 to @xmath64 . since @xmath64 is not a class-@xmath32 machine @xmath450",
    ", for some @xmath451 and the assignment of @xmath14 to @xmath64 led to a load of at most @xmath452 .",
    "since @xmath447 is not a class-@xmath32 machine either , @xmath14 could have also been assigned to @xmath447 incurring a resulting load of at most @xmath453 on this machine .",
    "note that when an algorithm @xmath333 can not assign a small job to a machine @xmath291 with @xmath352 and instead has to resort to machines @xmath454 with @xmath455 , it chooses a machine having the smallest @xmath456 value .",
    "we conclude @xmath457 .",
    "next consider the assignment of @xmath11 .",
    "algorithm @xmath333 would prefer to place @xmath11 on @xmath64 as it already contains small jobs .",
    "since this is impossible , there holds @xmath458 and thus @xmath459 .",
    "since by assumption @xmath460 it follows @xmath461 . suppose that @xmath450 , for some @xmath451 . then @xmath338 .",
    "since @xmath449 we obtain @xmath462 as desired .    the following lemmas focus on algorithms @xmath333",
    "such that @xmath297 is a valid target configuration for @xmath2 .",
    "[ lem : sched2 ] let @xmath2 be any job sequence and @xmath333 be an algorithm such that @xmath297 is a valid target configuration for @xmath2 .",
    "let @xmath356 .",
    "consider any point in time during the scheduling process .",
    "if the schedule of @xmath333 contains at most one machine @xmath291 with @xmath463 , then no further small job can arrive .    since @xmath297 is a valid target configuration for @xmath2 , the job sequence contains as many class-@xmath98 jobs , for any @xmath298 , as indicated by @xmath297 .",
    "hence the total processing time of large jobs in @xmath2 is lower bounded by @xmath464 .",
    "hence the total processing time of jobs in @xmath2 is at least @xmath465 , where the machine loads due to small jobs may be considered at an arbitrary point in time .",
    "hence if there exists a time such that @xmath466 for at most one @xmath345 , we obtain @xmath467 the last inequality holds because @xmath468 , for any @xmath469 .",
    "hence no further small job can arrive .",
    "[ lem : sched3 ] let @xmath2 be any job sequence and @xmath333 be an algorithm such that @xmath297 is a valid target configuration for @xmath2 .",
    "let @xmath356 . then in the final schedule constructed by @xmath333 , each machine in @xmath262 has a load of at most @xmath470 .",
    "we consider the scheduling steps in which @xmath333 assigns a job @xmath11 to a machine in @xmath262 .",
    "first suppose that @xmath11 is large .",
    "let @xmath11 be a class-@xmath98 job , where @xmath284 .",
    "if @xmath11 is assigned to an @xmath345 , then @xmath64 must be an admissible class-@xmath98 machine , i.e.  prior to the assignment of @xmath11 it contains fewer class-@xmath98 jobs as specified by the target configuration .",
    "this implies that for any machine @xmath345 , its load due to large jobs is always at most @xmath337 .",
    "the latter value is upper bounded by @xmath471 .",
    "hence , in order to establish the lemma it suffices to show that whenever a small job is assigned to a machine @xmath345 , the resulting load @xmath472 on @xmath64 is at most @xmath264 .",
    "suppose on the contrary that a small job @xmath11 arrives and @xmath333 schedules it on a machine in @xmath262 such that the resulting load is greater than @xmath264 .",
    "algorithm @xmath333 first tries to place @xmath11 on a machine @xmath345 with @xmath352 , which has already received small jobs . by lemma  [ lem : sched1 ] , among these machines there",
    "exists at most one having the property that @xmath442 .",
    "since an assignment to those machines is impossible without exceeding a load of @xmath264 , @xmath333 tries to place @xmath11 on a machine @xmath291 with @xmath473 .",
    "since this is also impossible without exceeding a load of @xmath264 , any @xmath291 with @xmath474 must be a class-@xmath32 machine .",
    "this holds true because for any class-@xmath98 machine with @xmath475 , there holds @xmath476 and an assignment of a small job would result in a total load of at most @xmath477 .",
    "observe that any class-@xmath32 machine has a targeted minimal load of @xmath478 .",
    "we conclude that immediately before the assignment of @xmath11 the schedule of @xmath333 contains at most one machine @xmath345 with @xmath442 .",
    "lemma  [ lem : sched2 ] implies that the incoming job @xmath11 can not be small , and we obtain a contradiction .",
    "[ lem : sched4 ] let @xmath2 be any job sequence and @xmath333 be an algorithm such that @xmath297 is a valid target configuration for @xmath2 . then in the final schedule constructed by @xmath333 , each machine in @xmath263 has a load of at most @xmath470 .",
    "algorithm @xmath333 assigns only large jobs to machines in @xmath263 .",
    "a first observation is that whenever there exists an @xmath479 that contains only one class-@xmath98 job with @xmath298 but no further jobs , then an incoming class-@xmath480 job with @xmath481 will not be assigned to an empty machine .",
    "this holds true because the two jobs can be combined , which results in a total load of at most @xmath482 .",
    "the observation implies that at any time while @xmath333 processes @xmath2 , the number of machines of @xmath263 containing at least one job is upper bounded by @xmath483 . here",
    "@xmath484 denotes the total number of class-@xmath98 jobs with @xmath298 that have been assigned to machines of @xmath263 so far .",
    "analogously , @xmath485 is the total number of class-@xmath98 jobs with @xmath340 currently residing on machines in @xmath263 .",
    "since @xmath297 is a valid target configuration for @xmath2 conditions  ( i ) and ( ii ) defining those configurations imply @xmath486 and @xmath487",
    ". moreover , since @xmath333 assigns large jobs preferably to machines in @xmath262 , there holds @xmath488 and @xmath489 . by condition  ( iii ) defining valid target configurations , @xmath490 .",
    "hence , while @xmath491 there holds @xmath492 and thus exists an empty machine @xmath263 to which an incoming class-@xmath98 jobs with @xmath340 can be assigned .",
    "similarly , while @xmath493 , there must exist an empty machine or a machine containing only one class-@xmath480 job with @xmath481 to which in incoming class-@xmath98 job with @xmath298 can be assigned . in either case , the assignment generates a load of at most @xmath264 on the selected machine .",
    "theorem  [ th : alg2 ] now follows from lemmas  [ lem : config ] , [ lem : sched3 ] and [ lem : sched4 ] .",
    "we derive our algorithms for mps .",
    "the strategies are obtained by simply combining @xmath56 , presented in section  [ sec : redu ] , with @xmath195 and @xmath257 . in order to achieve a precision of @xmath42 in the competitive ratio ,",
    "the strategies are combined with a precision of @xmath494 in its parameters . for any @xmath31 ,",
    "let @xmath495 be the algorithm obtained by executing @xmath496 in @xmath497 .",
    "for any @xmath31 , let @xmath498 be the algorithm obtained by executing @xmath499 in @xmath497 .",
    "[ cor:2 ] @xmath495 is a @xmath3-competitive algorithm for mps and uses no more than @xmath5 schedules , for any @xmath4 .",
    "theorem  [ th : guess1 ] and corollary  [ cor : a3 ] imply that @xmath495 is @xmath3-competitive , for any @xmath4 , and that the total number of schedules is the product of @xmath5 and @xmath500 , where @xmath501 . by the taylor series for @xmath502 , @xmath503 , we obtain @xmath504 , for any @xmath505 .",
    "hence the second term of the product is @xmath362 .",
    "[ cor:3 ] @xmath498 is a @xmath6-competitive algorithm for mps and uses no more than @xmath7 schedules , for any @xmath4 .    by theorems  [ th : guess1 ] and",
    "[ th : guess2 ] algorithm @xmath498 is @xmath6-competitive , for any @xmath4 .",
    "the total number of schedules is the product of @xmath506 and @xmath500 , where @xmath507 .",
    "again , by the taylor series , @xmath504 , for any @xmath505 .",
    "hence both terms of the product are upper bounded by @xmath7 .",
    "we develop lower bounds that apply to both mps  and mps@xmath26 .",
    "let @xmath19 be any deterministic online algorithm for mps  or mps@xmath26  that maintains at most @xmath509 schedules .",
    "we show that @xmath19 s competitive ratio is at least @xmath8 . to this end",
    "we construct an adversarial job sequence @xmath2 such that each schedule maintained by @xmath19 has a makespan of at least @xmath510 .",
    "the job sequence @xmath2 is composed of two subsequences @xmath511 and @xmath512 , i.e.@xmath513 .",
    "subsequence @xmath511 consists of @xmath1 jobs of processing time @xmath514 each .",
    "subsequence @xmath512 will consist of jobs having a processing time of either 2/3 or 1 .",
    "the exact number of these jobs depends on the schedules constructed by @xmath19 and will be determined later .",
    "consider the schedules that @xmath19 may have built after all jobs of @xmath511 have been assigned .",
    "each such schedule contains @xmath1 jobs of processing time 1/3 . for the moment we concentrate on schedules in which each machine contains either zero , one or three jobs , i.e.  there exists no machine containing two or more than three jobs .",
    "each such schedule @xmath515 can be represented by a pair @xmath516 , where @xmath517 denotes the number of machines containing exactly one job and @xmath518 is the number of machines containing three jobs . here",
    "@xmath517 and @xmath518 are non - negative integers such that @xmath519 .",
    "let @xmath520 be the set of all these pairs .",
    "set @xmath521 has @xmath508 elements because @xmath518 can take any value between  0 and @xmath509 and @xmath522 .",
    "let @xmath515 be an arbitrary schedule containing @xmath1 jobs of processing time 1/3 and @xmath523 .",
    "we say that @xmath515 is an _",
    "@xmath516-schedule _ if the number of machines containing exactly one job equals @xmath517 and the number of machines containing exactly three jobs equals @xmath518 .",
    "let @xmath524 be the set of schedules constructed by @xmath19 when the entire subsequence @xmath511 has arrived . by assumption @xmath19",
    "maintains at most @xmath509 schedules , i.e.  @xmath525 .",
    "hence there must exist a pair @xmath526 such that no schedule of @xmath524 is an @xmath527-schedule . on the other hand ,",
    "let @xmath528 be an @xmath527-schedule .",
    "in @xmath528 we number the machines in order of non - decreasing load such that @xmath529 . schedule @xmath528 contains @xmath530 machines with a load smaller than  1 and , in particular , @xmath531 empty machines .",
    "now the subsequence @xmath512 consists of @xmath532 jobs , where the @xmath73-th job has a processing time of @xmath533 , for @xmath534 .",
    "hence @xmath512 contains @xmath531 jobs of processing time  1 followed by @xmath535 jobs of processing time  @xmath536 .",
    "obviously , the makespan of an optimal schedule for @xmath2 is  1 : the jobs of @xmath511 are sequenced so that an @xmath527-schedule is obtained .",
    "again , after @xmath511 has arrived , the machines are numbered in order of non - decreasing load . while @xmath512 arrives , the @xmath73-th job is assigned to machine @xmath64 , having a load of @xmath244 , for @xmath534 .    in the remainder of this proof",
    "we consider any schedule @xmath537 and show that after @xmath512 has been sequenced , the resulting makespan is at least 4/3 .",
    "this establishes the theorem .",
    "so let @xmath538 be any schedule and recall that @xmath515 contains @xmath1 jobs of processing time 1/3 each .",
    "if in @xmath515 there exists a machine that contains at least four of these jobs , then the makespan is already 4/3 and there is nothing to show .",
    "therefore , we restrict ourselves to the case that every machine in @xmath515 contains at most three jobs . again",
    "we number the machines in @xmath515 in order of non - decreasing load so that @xmath539 .",
    "consider the @xmath527-schedule @xmath528 in which the machines loads satisfy @xmath529 .",
    "there must exist a machine @xmath540 , @xmath541 , such that @xmath542 : for , if @xmath543 held for all @xmath544 , then @xmath545 for all @xmath544 because @xmath515 and @xmath385 both contain jobs with a total processing time of @xmath546 .",
    "thus @xmath515 would be an @xmath527-schedule and we obtain a contradiction .",
    "the last @xmath547 machines in @xmath385 have a load of  1 .",
    "it follows that @xmath548 because otherwise @xmath540 in @xmath515 contained at least four jobs .",
    "the property @xmath542 implies @xmath549 because @xmath515 and @xmath385 only contain jobs of processing time @xmath514 .",
    "we finally show that sequencing of @xmath512 leads to a makespan of at least @xmath8 in @xmath515 .",
    "if @xmath19 assigns two jobs of @xmath512 to the same machine , then the resulting machine load is at least 4/3 because each job of @xmath512 has a processing time of at least @xmath536 .",
    "so assume that @xmath19 assigns the jobs of @xmath512 to different machines .",
    "the first @xmath550 jobs of @xmath512 each have a processing time of at least @xmath551 because the jobs arrive in order of non - increasing processing times . in @xmath515 there",
    "exist at most @xmath552 machines having a load strictly smaller than @xmath553 .",
    "hence , after the first @xmath550 jobs have been scheduled in @xmath515 , there exists a machine having a load of at least @xmath554 .",
    "this concludes the proof .",
    "the next theorem gives a lower bound on the number of schedules required by a @xmath6-competitive algorithm , where @xmath555 .",
    "it implies that , for any fixed @xmath42 , the number asymptotically depends on @xmath556 , as @xmath1 increases .",
    "for instance , any algorithm with a competitive ratio smaller than @xmath557 requires @xmath558 schedules .",
    "any algorithm with a competitive ratio smaller than @xmath559 needs @xmath560 schedules .",
    "[ th : lb2 ] let @xmath19 be a deterministic online algorithm for mps or mps@xmath26 . if @xmath19 attains a competitive ratio smaller than @xmath10 , where @xmath561 , then it must maintain at least @xmath562 schedules , where @xmath563 and @xmath564 .",
    "the binomial coefficient increases as @xmath42 decreases and is at least @xmath565 .",
    "we extend the proof of theorem  [ th : lb1 ] .",
    "let @xmath561 .",
    "furthermore , let @xmath566 and @xmath83 be defined as in the theorem",
    ". there holds @xmath567 .",
    "let @xmath568 and note that @xmath569 .",
    "we will define a set @xmath570 whose cardinality is at least @xmath562 , and show that if @xmath19 maintains less than @xmath571 schedules , then its competitive ratio is at least @xmath203 .",
    "we specify a job sequence @xmath2 and first assume that @xmath1 is even .",
    "later we will describe how to adapt @xmath2 if @xmath1 is odd .",
    "again @xmath2 is composed of two partial sequences @xmath511 and @xmath512 so that @xmath572 .",
    "subsequence @xmath511 consists of @xmath573 jobs of processing time @xmath209 each .",
    "subsequence @xmath512 depends on the schedules constructed by @xmath19 and will be specified below .",
    "consider the possible schedules after @xmath511 has been sequenced on the @xmath1 machines . we restrict ourselves to schedules having the following property :",
    "each machine has a load of exactly  1 or a load that is at most @xmath574 .",
    "observe that each machine of load  1 contains @xmath575 jobs .",
    "each machine of load at most @xmath574 contains up to @xmath576 jobs because @xmath577 .",
    "therefore any schedule with the stated property can be described by a vector @xmath578 , where @xmath579 is the number of machines having a load of  1 and @xmath371 is the number of machines containing exactly @xmath98 jobs , for @xmath580 .",
    "the vector @xmath581 satisfies @xmath582 and @xmath583 . the last equation specifies the constraint that the schedule contains @xmath573 jobs . let @xmath570 be the set of all these vectors , i.e.@xmath584 we remark that each @xmath585 uniquely identifies one schedule with our desired property .",
    "let @xmath515 be any schedule containing exactly @xmath573 jobs of processing time @xmath209 and @xmath586 .",
    "we say that @xmath515 is an _",
    "@xmath581-schedule _ if in @xmath515 there exist @xmath579 machines of load  1 and @xmath371 machines containing exactly @xmath98 jobs , for @xmath580 .",
    "now suppose that @xmath19 maintains less than @xmath571 schedules .",
    "let @xmath524 be the set of schedules constructed by @xmath19 after all jobs of @xmath511 have arrived . since @xmath587 there must exist an @xmath588 such that no schedule of @xmath524 is an @xmath589-schedule .",
    "let @xmath385 be an @xmath589-schedule in which machines are numbered in order of non - decreasing load such that @xmath529 .",
    "subsequence @xmath512 consists of @xmath590 jobs , where job @xmath73 has a processing time of @xmath533 , for @xmath591 .",
    "hence @xmath512 consists of @xmath592 jobs of processing time @xmath593 , for @xmath580 .",
    "these jobs arrive in order of non - increasing processing time .",
    "each job has a processing time of at least @xmath594 because @xmath595 .",
    "the makespan of an optimal schedule for @xmath2 is 1 .",
    "the jobs of @xmath511 are sequenced so that an @xmath589-schedule is obtained .",
    "machines are again numbered in order of non - decreasing load .",
    "then , while the jobs of @xmath512 arrive , the @xmath73-th job of the subsequence is assigned to machine @xmath64 in @xmath385 , @xmath596 .",
    "we next show that after @xmath19 has sequenced @xmath512 , each of its schedules has a makepan of at least @xmath203 .",
    "so consider any @xmath537 and , as always , number the machines in order of non - decreasing load such that @xmath597 .",
    "if in @xmath515 there exists a machine that has a load of at least @xmath203 and hence contains at least @xmath598 jobs , then there is nothing to show .",
    "so assume that each machine in @xmath515 contains at most @xmath575 jobs and thus has a load of at most  1 .",
    "we study the assignment of the jobs of @xmath512 to @xmath515 .",
    "if @xmath19 places two jobs of @xmath512 on the same machine , then we are done because each job has a processing time of at least @xmath594 .",
    "therefore we focus on the case that @xmath19 assigns the jobs of @xmath512 to different machines",
    ".    schedules @xmath515 and @xmath385 both contain jobs of total processing time @xmath599 . since @xmath515 is not an @xmath589-schedule there must exist a @xmath550 , @xmath600 , such that @xmath542 and hence @xmath601 .",
    "each machine in @xmath515 has a load of at most  1 while the last @xmath590 machines in @xmath385 have a load of exactly  1 .",
    "this implies @xmath602 .",
    "the first @xmath550 jobs of @xmath512 each have a processing time of at least @xmath551",
    ". however , there exist at most @xmath552 machines in @xmath515 having a load strictly smaller than @xmath603 .",
    "hence after @xmath19 has sequenced the first @xmath550 jobs of @xmath512 there must exist a machine in @xmath515 with a load of at least @xmath604 .",
    "so far we have assumed that @xmath1 is even .",
    "if @xmath1 is odd , we can easily modify @xmath2 .",
    "the first job of @xmath2 is a job of processing time  1 .",
    "then @xmath511 and @xmath512 follow .",
    "these subsequences are defined as above , where @xmath1 is replaced by the even number @xmath605 . in this case",
    "@xmath606 the analysis presented above carries over because the first job of @xmath2 , having a processing time of 1 , must be scheduled on a separate machine and can not be combined with any job of @xmath511 or @xmath512 if a competitive ratio smaller than @xmath203 is to be attained .",
    "we next lower bound the cardinality of @xmath570 .",
    "again we first focus on the case that @xmath1 is even .",
    "in the definition of @xmath570 the critical constraint is @xmath583 , which implies that not every vector of @xmath607 represents a schedule that can be built of @xmath573 jobs . in particular , the vector @xmath608 of length @xmath609 would require @xmath610 jobs .",
    "therefore , we introduce a set @xmath611 and show @xmath612 . set @xmath611 contains vectors of length @xmath609 in which the first @xmath613 entries as well as the last one are equal to  0 .",
    "the other entries sum to at most @xmath614 , i.e.@xmath615 we show that each @xmath616 can be mapped to a @xmath585 .",
    "the mapping has the property that any two different vectors of @xmath611 are mapped to different vectors of @xmath570 .",
    "this implies @xmath612 .",
    "consider any @xmath617 .",
    "let @xmath578 be defined as follows . for @xmath618 ,",
    "let @xmath619 . for @xmath620",
    ", let @xmath621 .",
    "finally , let @xmath622 .",
    "note that @xmath623 . we next show that @xmath585 .",
    "there holds @xmath624 .",
    "furthermore , @xmath625 it follows , as desired , @xmath585 .",
    "note that the last @xmath83 entries of @xmath581 are identical to the last @xmath83 entries of @xmath626 .",
    "hence no two vectors of @xmath611 that differ in at least one entry are mapped to the same vector of @xmath570 .",
    "hence @xmath612 .",
    "if the number @xmath1 of machines is odd , then in the definition of @xmath611 the entries of a vector sum to at most @xmath627 .",
    "the rest of the construction and analysis is the same .",
    "thus , for a general number @xmath1 of machines @xmath628 this set contains exactly @xmath562 elements , where again @xmath629 . in the remainder of this proof we lower",
    "bound this binomial coefficient .",
    "e.  angelelli , m.g .",
    "speranza and z.  tuza .",
    "new bounds and algorithms for on - line scheduling : two identical processors , known sum and upper bound on the tasks",
    ". _ discrete mathematics & theoretical computer science _ , 8:116 , 2006 ."
  ],
  "abstract_text": [
    "<S> online makespan minimization is a classical problem in which a sequence of jobs @xmath0 has to be scheduled on @xmath1 identical parallel machines so as to minimize the maximum completion time of any job . in this paper </S>",
    "<S> we investigate the problem with an essentially new model of resource augmentation . </S>",
    "<S> more specifically , an online algorithm is allowed to build several schedules in parallel while processing @xmath2 . at the end of the scheduling process </S>",
    "<S> the best schedule is selected . </S>",
    "<S> this model can be viewed as providing an online algorithm with extra space , which is invested to maintain multiple solutions . </S>",
    "<S> the setting is of particular interest in parallel processing environments where each processor can maintain a single or a small set of solutions .    as a main result we develop a @xmath3-competitive algorithm , for any @xmath4 , that uses a constant number of schedules . </S>",
    "<S> the constant is @xmath5 . </S>",
    "<S> we also give a @xmath6-competitive algorithm , for any @xmath4 , that builds a polynomial number of @xmath7 schedules . </S>",
    "<S> this value depends on @xmath1 but is independent of the input @xmath2 . </S>",
    "<S> the performance guarantees are nearly best possible . we show that any algorithm that achieves a competitiveness smaller than @xmath8 must construct @xmath9 schedules . our algorithms make use of novel guessing schemes that ( 1 )  predict the optimum makespan of a job sequence @xmath2 to within a factor of @xmath10 and ( 2 )  guess the job processing times and their frequencies in @xmath2 . in  </S>",
    "<S> ( 2 ) we have to sparsify the universe of all guesses so as to reduce the number of schedules to a constant .    </S>",
    "<S> the competitive ratios achieved using parallel schedules are considerably smaller than those in the standard problem without resource augmentation . </S>",
    "<S> furthermore they are at least as good and in most cases better than the ratios obtained with other means of resource augmentation for makespan minimization . </S>"
  ]
}