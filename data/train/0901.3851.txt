{
  "article_text": [
    "i got the idea for this paper from an exchange of emails between me , rolando somma , emmanuel knill , howard barnum , pawel wocjan and richard cleve.(everyone received the same emails ) .",
    "i offered to one of these individuals to include him as a co - author of this paper , but he refused the offer ( did nt even want to be acknowledged ) .",
    "none of the above mentioned people that corresponded with me has vetted or proof - read this paper .",
    "any errors are my own .",
    "there is some indirect precedent to this work . according to prof .",
    "wocjan ,  it is known how to efficiently simulate sparse hamiltonians ( for example , see the papers by dorit aharonov , et.al . ,",
    "sanders , cleve , et.al . , which rolando mentioned in his reply to you ) .",
    "these methods do not immediately allow to efficiently implement a sparse unitary matrix .",
    "stephen jordan and i found a simple method to simulate any sparse matrix by using the techniques for simulating sparse hamiltonians . while this method is not very difficult , we still want to write a short note because the ability to simulate sparse unitaries can be used to derive quantum algorithms for evaluating link invariants ... \" i have not seen the so far unpublished work of jordan / wocjan .",
    "i do nt believe that i use  the techniques for simulating sparse hamiltonians \" in this paper .",
    "furthermore , it appears that jordan / wocjan consider sparse unitary matrices in general , whereas i consider the very special sparse case of quantum multiplexors . sometimes , by considering a special case",
    ", one can say much more and be more specific . for these reasons",
    ", i believe that this paper might be significantly different to the one by jordan / wocjan , and that it might be useful to someone besides me ."
  ],
  "abstract_text": [
    "<S> we give a new quantum circuit approximation of quantum multiplexors based on the idea of complexity theory oracles . as an added bonus , our multiplexor approximation immediately gives a quantum circuit approximation of diagonal unitary matrices .    </S>",
    "<S> [ [ section ] ]    for an explanation of the notation used in this paper , see ref.@xcite section 2 .    </S>",
    "<S> quantum multiplexors have proved themselves to be very useful as building blocks for quantum computing circuits . for a review of quantum multiplexors , </S>",
    "<S> see ref.@xcite section 3 .    </S>",
    "<S> as shown in ref.@xcite , an @xmath0-multiplexor with @xmath1 controls can be compiled exactly using @xmath2 cnots . </S>",
    "<S> it is believed that this number of cnots is a lower bound . </S>",
    "<S> it is therefore of interest to find multiplexor approximations with a lower cnot count . </S>",
    "<S> various multiplexor approximations have been considered before@xcite . </S>",
    "<S> the goal of this paper is to give a new multiplexor approximation based on the idea of complexity theory oracles . </S>",
    "<S> as we shall see , any multiplexor approximation immediately gives an approximation of diagonal unitary matrices . </S>",
    "<S> diagonal unitary matrices of dimension @xmath3 can also be compiled exactly using about @xmath3 cnots@xcite , and this number is believed to be a lower bound .    </S>",
    "<S> consider an arbitrary @xmath0-multiplexor whose target qubit is labelled @xmath4 and whose @xmath5 control qubits are labelled @xmath6 .    </S>",
    "<S> [ eq - def - m ] @xmath7    for some @xmath8 . in the above , </S>",
    "<S> we define @xmath9 , @xmath10 , and @xmath11 . also , @xmath12 and @xmath13 , where @xmath14 is the so called  number operator \" . in eqs.([eq - def - m ] ) , we ve expressed @xmath15 in 3 equivalent forms , the exponential , sum and product forms . </S>",
    "<S> the equivalence of these forms is readily established by applying @xmath16 to the right hand side of each form . </S>",
    "<S> note that we can  pull \" the @xmath17 sum out of the exponential , but only if we also pull out the projector @xmath18 .    </S>",
    "<S> now we add a set of @xmath19 ancilla qubits labelled @xmath20 . for each @xmath17 , </S>",
    "<S> the angle @xmath21 can be expressed approximately , to a precision of @xmath19 fractional bits , and this information can be stored in the qubits @xmath22 . </S>",
    "<S> let @xmath23 . </S>",
    "<S> if    _ = 2_k=1^n _ , where @xmath24 , then    _ _ </S>",
    "<S> = 2_k=1^n _ _ . </S>",
    "<S> [ eq - theta - in ] we will use the following evocative notation for the finite series : _ k=1^n _ </S>",
    "<S> = 0.n(_1)n(_2 )  n(_n _ ) . </S>",
    "<S> [ eq - cute - notation ] substituting eqs . </S>",
    "<S> ( [ eq - cute - notation ] ) into eq.([eq - theta - in ] ) , and then using the resulting expression for @xmath25 in the definition eq.([eq - def - m ] ) for @xmath15 , gives :    & = & _ p _ ( ) e^i 2 0.n(_1)n(_2 )  </S>",
    "<S> n(_n _ ) </S>",
    "<S> ( ) _ + & = & ( ) e^i 2 0.n(_1)n(_2 )  n(_n _ ) ( ) ( ) _ , where    ( ) = _ k=1^n _ ( _ k ) , where    ( _ k)= _ p_()(_k)^ a _ , k = ( _ k)^_a _ , kp _ </S>",
    "<S> ( ) . </S>",
    "<S> @xmath26 is a product of @xmath19  standard quantum oracles \" @xmath27 . </S>",
    "<S> for example , if @xmath28 and @xmath29 with    l _ 00 = 20.01 + _ 01 = 20.11 + _ 10 = 20.10 + _ 11 = 20.00    , [ a_,k ] =    [ cols= \" < , < , < , < \" , ]     , then    ( ) =    c @c=1em @r=1em @!r & & & & & + & & & & & + & & & & & + & & & & &    . </S>",
    "<S> fig.[fig - m - approx ] is an example , expressed in circuit form , of the multiplexor approximation that we hath wrought .    </S>",
    "<S> c @c=1em @r=1em @!r & & & & & & & & & & & & & & & + & & & & & & & & & & & & & & & + & & & & & & & & & & & & & & & + & & & & & & & & & & & & & & & & + & & & & & & & & & & & & & & & & + & & & & & & & & & & & & & & & & + & & & & & & & & & & & & & & &    next , consider a diagonal unitary matrix @xmath30 acting on qubits @xmath31 :    d = ( i _ _ p _ ( ) ) , for some @xmath8 . by adding an ancilla target qubit @xmath4 </S>",
    "<S> , we can express @xmath30 in terms of an @xmath32-multiplexor :    d()_&= & ( i _ _ ( ) p _ ( ) ) _ + & = & e^-i ( ) ( i _ _ ( ) p _ ( ) ) e^i ( ) _ an oracular approximation of @xmath30 follows immediately from this and the oracular multiplexor approximation .    in general , </S>",
    "<S> if a classical algorithm of polynomial complexity is known for calculating @xmath21 given @xmath17 , then one can construct from this classical algorithm standard quantum oracles @xmath33 , of polynomial complexity . </S>",
    "<S> _ however , if no such classical algorithm of polynomial complexity is known , none may exist . if none exists , the standard quantum oracles @xmath27 have exponential complexity . </S>",
    "<S> _    an upper bound on the error of our oracular multiplexor approximation is easily obtained . </S>",
    "<S> let    = 2_k=1^ , = 2_k=1^n _ . </S>",
    "<S> then    @xmath34    to go from eq.([eq - bef - sin - ineq ] ) to eq.([eq - aft - sin - ineq ] ) , we used the inequality @xmath35 for @xmath36 . </S>",
    "<S> almost the same string of inequalities can be used to upper bound the error in our oracular multiplexor approximation . </S>",
    "<S> let @xmath15 be the multiplexor of eq.([eq - def - m ] ) with the exact @xmath21 , and @xmath37 the multiplexor with the approximate @xmath21 ( to a precision of @xmath19 fractional bits ) . </S>",
    "<S> using the matrix 2-norm 0 ) . for a review of matrix norms , see ref.@xcite ] , we get    m- & = & m 1- + & & 2 ( ) _ _ k = n_+1^ p _ ( ) 2 _ _ k = n_+1^ + & & 2| _ k = n_+1^ </S>",
    "<S> | = | _ k=1^ | = . above </S>",
    "<S> , we used the fact that @xmath38 as is the case for any unitary matrix . </S>"
  ]
}