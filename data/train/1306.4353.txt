{
  "article_text": [
    "a binary matrix @xmath0 satisfies the consecutive - ones property ( c1p ) if its columns can be ordered in such a way that , in each row , all 1 entries appear consecutively .",
    "the c1p has been studied in relation to a wide range of problems , from theoretical computer science @xcite to genome mapping ( see @xcite and references there ) .",
    "the c1p can be naturally described in terms of covering hypergraph edges by walks .",
    "assume a binary matrix @xmath0 is the incidence matrix of a hypergraph @xmath1 , where columns represent vertices and rows encode edges ; then @xmath0 is c1p if and only if @xmath1 can be covered by a path that contains all vertices and where every edge appears as a contiguous subpath .",
    "deciding if a binary matrix is c1p can be done in linear time and space ( see @xcite and references there ) .",
    "if a matrix is not c1p , a natural approach is to remove the smallest number of rows from this matrix in such a way that the resulting matrix is c1p .",
    "this problem , equivalent to an edge - deletion problem on hypergraphs that solves the hamiltonian path problem , is np - complete , although fixed - parameter tractability ( fpt ) results have recently been published .    at a high level of abstraction ,",
    "genome assembly problems can be seen as graph or hypergraph covering problems : vertices represent small genomic sequences , edges encode co - localisation information , and one wishes to cover the hypergraph with a set of linear walks ( or circular walks for genomes with circular chromosomes ) that respect co - localisation information .",
    "such walks encode the order of elements along chromosomal segments of the assembled genome .",
    "one of the major issues in genome assembly problems concerns _",
    "repeats_- genomic elements that appear , up to limited changes , in several locations in the genome being assembled .",
    "such repeats are known to confuse assembly algorithms and to introduce ambiguity in assemblies @xcite .",
    "modeling repeats in graph theoretical models of genome assembly can be done by associating to each vertex a _ multiplicity _ : the multiplicity of a vertex is an upper bound on the number of occurrences of this vertex in linear / circular walks that cover the hypergraph , and thus a vertex with a multiplicity greater than @xmath2 can traversed several times in these walks ( _ i.e. _ , encodes a repeat as defined above ) .",
    "this hypergraph covering problem naturally translates into a variant of the c1p , called the c1p with multiplicity ( mc1p ) that received little attention until recently , when it was investigated in several recent papers in relation to assembling ancestral genomes that describee both hardness and tractability results for decision and edge - deletion problems @xcite .    in the present paper , we formalize the previously studied c1p and mc1p notions in terms of _ covering of assembly hypergraphs _ by linear and circular walks and edge - deletion problems ( section  [ sec : preliminaries ] ) .",
    "next , we describe new tractability results for decision and edge - deletion problems ( section  [ sec : results ] ) : we show that deciding if a given assembly hypergraph admits a covering by linear and circular walks that respects the multiplicity of all vertices is fpt and we describe polynomial time algorithms for decision and edge - deletion problems for families of assembly hypergraphs which encode information allowing us to clear ambiguities due to repeats .",
    "we conclude with several open questions ( section  [ sec : conclusion ] ) .",
    "[ def : hypergraph ] an _ assembly hypergraph _ is a quadruple @xmath3 where @xmath4 is a hypergraph and @xmath5 are three mappings such that @xmath6 , @xmath7 , @xmath8 where @xmath9 is either a sequence on the alphabet @xmath10 where each element appears at least once , or @xmath11 ( the empty sequence ) .    from now , we consider that @xmath12 , @xmath13 , @xmath14 , @xmath15 , @xmath16 , @xmath17 .",
    "a vertex @xmath18 such that @xmath19 is called a _ repeat _ ; @xmath20 is the set of repeats and @xmath21 .",
    "edges s.t .",
    "@xmath22 are called _ adjacencies _ ; from now , without loss of generality , we assume that @xmath23 if @xmath24 is an adjacency .",
    "edges s.t .",
    "@xmath25 ( resp .",
    "@xmath26 ) are called _ intervals _ ( resp . _",
    "triples _ ) .",
    "we denote the set of adjacencies ( resp .",
    "weights of adjacencies ) by @xmath27 ( resp .",
    "@xmath28 ) and the set of intervals ( resp .",
    "weights of intervals ) by @xmath29 ( resp .",
    "@xmath30 ) .",
    "an interval is _ ordered _",
    "if @xmath31 ; an assembly graph with no ordered interval is _",
    "unordered_. from now , unless explicitly specified , our assembly hypergraphs will be unordered and unweighted .",
    "we call @xmath32 the _ multiplicity _ of @xmath18 .",
    "[ def : adjacencygraph ] an assembly hypergraph with no interval is an _",
    "adjacency graph_. given an assembly hypergraph @xmath33 , we denote its _ induced adjacency graph _ by @xmath34 for every @xmath35 , as adjacencies are unordered . ] .",
    "[ def : compatibility ] let @xmath36 be an assembly hypergraph and @xmath37 ( resp .",
    "@xmath38 ) a linear ( resp .",
    "circular ) sequence on the alphabet @xmath39 .",
    "an unordered interval @xmath24 is _ compatible _ with @xmath37 ( resp .",
    "@xmath38 ) if there is a contiguous subsequence of @xmath37 ( resp .",
    "@xmath38 ) whose content is equal to @xmath24 .",
    "an ordered interval @xmath24 is compatible with @xmath37 ( resp .",
    "@xmath38 ) if there exists a contiguous subsequence of @xmath37 ( resp .",
    "@xmath38 ) equal to @xmath40 or its mirror .",
    "[ def : assembly ] an assembly hypergraph @xmath3 admits a _ linear assembly _ ( resp . _ mixed assembly _ ) if there exists a set @xmath41 of linear sequences ( resp .",
    "linear and/or circular sequences ) on @xmath39 such that every edge @xmath42 is compatible with at least one sequence of @xmath41 , and every vertex @xmath18 appears at most @xmath32 times in @xmath41 .",
    "the weight of an assembly is @xmath43 .",
    "an assembly as defined above can naturally be seen as a set of walks ( some possibly closed in mixed assemblies ) on @xmath1 such that every edge of @xmath44 is traversed by a contiguous subwalk . in the following , we consider two kinds of algorithmic problems that we investigate for different families of assembly hypergraphs and genome models , a decision problem and an edge - deletion problem .    * the _ assembly decision problem _ : given an assembly hypergraph @xmath45 @xmath46 and a genome model ( linear or mixed ) , does there exist an assembly of @xmath47 in this model ? * the _ assembly maximum edge compatibility problem _ : given an assembly hypergraph @xmath33 and a genome model , compute a maximum weight subset @xmath48 of @xmath44 such that the assembly hypergraph @xmath49 admits an assembly in this model .",
    "[ def : repeatcluster ] let @xmath36 be an assembly hypergraph",
    "maximal repeat cluster _ is a connected component of the hypergraph whose vertex set is @xmath20 and edge set is @xmath50 .    as outlined in the introduction , vertices in an assembly hypergraph",
    "represent genomic elements , each with an associated copy number @xmath32 , while edges and their order ( for intervals ) encode hypothetical co - localisation information , each with an associated weight .",
    "linear and/or circular sequences of vertices defining an assembly represent the order of these genomic elements along chromosomal segments , the circular ones representing circular chromosomes .",
    "a maximal repeat cluster encodes a group of elements that are believed to appear in several locations of the genome to assemble , although different occurrences might differ in terms of content and/or order ( see @xcite for example ) .",
    "such repeated structures cause ambiguity in genome assemblies based solely on adjacencies ; for example , if @xmath51 , with @xmath52 and @xmath53 , and @xmath54 , then there are essentially three possible linear assemblies ( @xmath55 ) , while adding the ordered interval @xmath56 leads to a single possible assembly .",
    "when no repeats are allowed ( @xmath57 ) , the assembly decision problem in the linear genome model is equivalent to asking if a binary matrix has the c1p , which can be solved in @xmath58 time and space .",
    "the set of all linear assemblies can be encoded into a compact data structure , the _ pq - tree_. in the mixed genome model , the problem can also be solved in linear time , as it reduces to testing the circular c1p for every connected component of the overlap graph of the matrix . the _ pc - tree _ , a slightly modified pq - tree , can be used to encode all mixed genome assemblies .",
    "we summarize some of these results in the following theorem and refer to @xcite for a survey on these questions .",
    "[ thm : cis1 ] the assembly decision problem can be solved in @xmath58 time and space when @xmath59 , in the linear and mixed genome models .    in the linear genome model ,",
    "the assembly maximum edge compatibility problem is hard for adjacency graphs  it solves the problem of computing a set of paths that cover a maximum number of edges of the graph  but",
    "fpt results have recently appeared @xcite .",
    "tractability results are less general when repeats are allowed , as shown below .",
    "[ thm : adadjacencies1]_@xcite _ ( 1 ) the assembly decision problem can be solved in time and space @xmath58 for adjacency graphs ( @xmath60 ) in the linear and mixed genome models .",
    "( 2 ) in both genome models , the assembly decision problem is np - hard if @xmath61 and @xmath62 .",
    "the principle of the proof for ( 1 ) is that an adjacency graph admits a valid assembly if and only if every vertex has at most @xmath63 neighbours and , in the linear model , if every connected component @xmath38 satisfies @xmath64 .",
    "this result , combined with the use of pq - trees on the assembly hypergraph without its repeats , can be extended slightly in the linear genome model .",
    "[ thm : adadjacencies2]_@xcite _ the assembly decision problem can be solved in polynomial time and space in the linear genome model for unordered assembly hypergraphs where , for every edge @xmath24 containing a repeat , either @xmath24 is an adjacency or @xmath24 is an interval that contains a single repeat @xmath65 and there exists an edge @xmath66 .",
    "finally , to the best of our knowledge , the following is the only tractability result for edge - deletion problems when repeats are allowed , limited to adjacency graphs and the mixed genome model .",
    "[ thm : amedadjacencies1]_@xcite _ ( 1 ) the assembly maximum edge compatibility problem can be solved in polynomial time and space in the mixed genome model for adjacency graphs ( @xmath60 ) .",
    "( 2 ) the assembly maximum edge compatibility problem is np - hard in the mixed genome model if @xmath61 , even if @xmath57 .",
    "we first show that the assembly decision problem is fpt with respect to parameters @xmath67 and @xmath68 .",
    "then we describe positive results for the case where the induced adjacency graph @xmath69 is assumed to admit an assembly and specific families of intervals are added to clear ambiguities caused by repeats .",
    "we discuss the practical implications of our positive results at the end of the section .      the assembly decision problem can be solved in space @xmath70 and time @xmath71 in the linear and mixed genome models .",
    "the principle of the proof is , for the given assembly hypergraph @xmath72 and @xmath73 here as the weight does not impact decision problems and we deal with unordered hypergraphs .",
    "so , we eliminate both mappings from our notation . ] , to build another assembly hypergraph @xmath74 such that @xmath75 for all @xmath76 , by making @xmath77 copies of each @xmath78 and considering each possible set @xmath79 of choices of 2 neighbors for each of these copies .",
    "@xmath80 can then be checked for the existence of an assembly with theorem [ thm : cis1 ] . the sets @xmath79 of choices",
    "are made in such a way that @xmath81 has an assembly if and only if , for at least one of these sets @xmath79 of choices , @xmath82 has an assembly . finally ,",
    "if @xmath83 and @xmath68 are fixed , we prove that there is a fixed number of such sets @xmath79 .",
    "let @xmath84 be the set of copies we shall introduce for each @xmath78 ( and @xmath85 ) , @xmath86 be the _ neighborhood _ of @xmath18 in @xmath1 , that is the set of vertices belonging to edges containing @xmath18 , and    @xmath87    be the `` new neighborhood '' from which we choose neighbors for vertices in @xmath88 .",
    "we represent each set of possible choices of 2 neighbors of each @xmath89 with a mapping @xmath90 , where @xmath91 .",
    "let @xmath92 be the collection of these mappings ( itself a mapping @xmath93 where @xmath94 ) .",
    "we can now state the full algorithm as follows .    1 .",
    "for each @xmath95 , make @xmath77 copies of @xmath65 , which defines the set @xmath88 .",
    "let @xmath96 .",
    "2 .   for each @xmath97 , choose @xmath98 neighbours from @xmath99 , thus defining @xmath100 for every @xmath95 .",
    "this also defines @xmath79 as the collection of mappings @xmath100 over all @xmath95 .",
    "3 .   construct a new assembly hypergraph @xmath101 with @xmath102 , @xmath75 for all @xmath103 , and @xmath104 defined as follows : ( 1 ) for each @xmath89 , @xmath105 , @xmath106 for some @xmath107 , add @xmath108 and @xmath109 to @xmath110 ( @xmath79-edges ) and ( 2 ) for each @xmath111 , add an edge @xmath112 containing @xmath113 .",
    "4 .   for each @xmath114",
    "adjacent to a vertex of @xmath115 , let @xmath116 be the unique path in @xmath117 s.t . @xmath118 and @xmath119",
    "add all of @xmath120 to @xmath121 for each @xmath112 such that @xmath122 .",
    "5 .   use theorem  [ thm : cis1 ] on @xmath123 .",
    "output yes and exit if @xmath80 admits an assembly in the chosen genome model",
    "iterate over all possible sets of neighbour choices @xmath79 in step 2 .",
    "output no if no @xmath123 admits an assembly in the chosen genome model .",
    "[ [ algorithm - correctness . ] ] algorithm correctness .",
    "+ + + + + + + + + + + + + + + + + + + + + +    the premise for the algorithm is the following claim , which we state and prove below .",
    "@xmath81 has an assembly if and only if , for some @xmath79 , @xmath80 has an assembly .",
    "[ lem : mapping ]    first , if @xmath81 has the assembly @xmath124 , in @xmath124 , we replace each occurrence of a vertex @xmath78 by copies @xmath89 where @xmath125 .",
    "let this new assembly be called @xmath126 .",
    "each such @xmath127 is adjacent to at most 2 other distinct vertices .",
    "we consider the mapping @xmath79 which maps each such @xmath127 to its two neighbours in this assembly @xmath126 .",
    "if we can establish that the hypergraph obtained from this mapping and the new edges we introduce admits @xmath126 as an assembly , we are done .    to decide if @xmath80 has an assembly , we first note that any set of covering walks on @xmath80 is a set of paths ( we can not visit the same vertex twice because @xmath75 for all @xmath128 ) . since @xmath124 is a covering walk of @xmath81 , by splitting the vertices of @xmath20 into distinct copies ,",
    "we ensure that no vertex of @xmath80 is visited twice by @xmath126 .",
    "now , let us look at the set of edges @xmath110 .",
    "if all of them are covered as contiguous subsequences in @xmath126 , we are done .",
    "we show this by the following observations .    1 .   in @xmath124",
    ", every edge @xmath24 occurs as a contiguous subsequence .",
    "let @xmath121 be the edge in @xmath80 corresponding to @xmath24 .",
    "then , by definition of @xmath126 , @xmath121 must occur in it as a contiguous subsequence .",
    "2 .   for each @xmath129 for some @xmath78",
    ", we defined @xmath106 using the assembly @xmath124 .",
    "so , we definitely get both adjacencies @xmath130 in @xmath126 .",
    "so , @xmath126 must be an assembly for @xmath80 , which implies that @xmath80 has an assembly .",
    "conversely , if the graph @xmath80 has an assembly , it contains all vertices @xmath131 , and occurrences of each @xmath132 for all repeat vertices @xmath78 . if we remove the subscripts , _",
    "i.e. _ , @xmath127 becomes @xmath65 for all @xmath133 , we get an assembly @xmath124 , which we claim is an assembly for @xmath81 , as @xmath124 will have the following properties .    1 .",
    "every vertex @xmath134 appears at least once , and at most @xmath32 times .",
    "2 .   for every edge @xmath135",
    "consisting only of vertices in @xmath131 , we get a contiguous occurrence of @xmath111 , which is the corresponding edge in @xmath81 .",
    "3 .   for every edge @xmath111 , such that @xmath136 for some @xmath137",
    ", there is an edge @xmath112 such that @xmath89 has two neighbours and @xmath138 . in this case",
    ", we get a contiguous occurrence of @xmath121 including @xmath127 .",
    "removing the subscripts gives us a contiguous occurrence of @xmath24 in the new assembly @xmath124 .",
    "so , @xmath124 contains occurrences of every edge @xmath111 in @xmath81 as contiguous subsequences , which proves that @xmath124 is an assembly for @xmath81 .",
    "this proves the claim .",
    "this proof holds for both genome models as theorem [ thm : cis1 ] considers them both .",
    "[ [ algorithm - complexity . ] ] algorithm complexity .",
    "+ + + + + + + + + + + + + + + + + + + + +    the space complexity follows obviously from the construction of @xmath80 .",
    "the choice of neighbours can be made in at most @xmath139 ways for each new vertex .",
    "so , in total , we get at most @xmath140 possible mappings @xmath93 .",
    "the procedure on each @xmath141 can be done in time @xmath142 , since we just need to check its neighbours , which are at most @xmath98 .",
    "doing so for all vertices in @xmath143 takes time at most @xmath144 .",
    "the final step , checking for the existence of an assembly for a given @xmath80 , can be done in @xmath145 time , since we add at most @xmath146 new edges , and @xmath147 new vertices .",
    "now , we assume we are given an assembly hypergraph @xmath148 whose induced adjacency graph @xmath69 is known to have a mixed assembly . to state our result ,",
    "we extend slightly the notion of compatibility : an unordered interval @xmath24 is said to be _ compatible _ with @xmath69 if there exists a walk in @xmath149 whose vertex set is exactly @xmath24 .",
    "we consider the interval compatibility problem defined below .    the _ assembly maximum interval compatibility problem _ : given an assembly hypergraph @xmath33 such that @xmath69 admits a mixed assembly , compute a maximum weight subset of @xmath29 , @xmath150 , such that @xmath151 admits a mixed assembly .",
    "[ thm : maxcompatibility1 ] let @xmath152 be a weighted assembly hypergraph such that @xmath69 admits a mixed genome assembly , and each interval is a triple containing at most one repeat and compatible with @xmath69 .",
    "the assembly maximum interval compatibility problem in the mixed genome model can be solved for @xmath47 in linear space and @xmath153 time .",
    "the proof proceeds in two stages : we first show that repeat - free triples , as well as triples whose non - repeat vertices form an adjacency , must always be included in a maximum weight compatible set of triples .",
    "then , we present an algorithm which uses the adjacency compatibility algorithm of mauch et al .",
    "@xcite to decide which of the remaining triples to include . from now",
    ", we denote by @xmath154 a maximum weight subset of @xmath29 such that @xmath155 admits a mixed assembly .",
    "if a triple @xmath156 satisfies @xmath157 , with @xmath158 , then @xmath159 .    as @xmath24",
    "is assumed to be compatible with @xmath69 by hypothesis , there is a walk on these three vertices in @xmath160 . as a walk on three non - repeat vertices",
    "is a path , w.l.o.g we assume that the adjacencies in the path are @xmath161 and @xmath162 ( the argument holds by symmetry for the other cases ) .",
    "then , in any mixed assembly of @xmath69 , in order to contain both adjacencies , and to make sure that @xmath163 appears exactly once in the assembly , the assembly must contain @xmath24 , in the order @xmath164 .",
    "so , it must be included in @xmath154 , as @xmath154 is a maximum weight subset of @xmath165 .",
    "if a triple @xmath156 satisfies @xmath166 , with @xmath167 , @xmath168 and @xmath169 , then @xmath159 .    for the triple @xmath24 to be compatible with @xmath69 , @xmath65 needs to be adjacent to at least one of @xmath170 and @xmath163 .",
    "assume , w.l.o.g , that @xmath171 .",
    "if @xmath69 admits a mixed assembly , both @xmath161 and @xmath172 must occur in a path or a cycle .",
    "furthermore , since @xmath173 , these two adjacencies must occur in the same path or cycle , in the order @xmath174 .",
    "this is an occurrence of @xmath24 as a contiguous sequence , which implies that such a triple must occur in every assembly of @xmath47 , and must be included in @xmath154 .",
    "we are now left with the set @xmath175 of triples @xmath166 such that @xmath65 is a repeat and @xmath176 , which means that @xmath65 is adjacent to both @xmath170 and @xmath163 , and we need to find a maximum weight subset of triples of this form . to do this",
    ", we rely on the optimal edge - deletion algorithm designed by mauch et al .",
    "@xcite for adjacency graphs as shown below .    1 .",
    "initialize an empty set @xmath177 and @xmath178 .",
    "2 .   for every @xmath179 : a.   add an adjacency @xmath180 to @xmath177 , label @xmath181 with the triple @xmath24 , and set @xmath182",
    ". b.   remove @xmath183 and @xmath184 from @xmath48 , if present .",
    "3 .   for every remaining adjacency @xmath185 ,",
    "set @xmath186 .",
    "4 .   apply the linearization algorithm ( theorem  [ thm : amedadjacencies1 ] )  @xcite on @xmath187 .",
    "add the triples corresponding to the labels of the adjacencies from @xmath177 retained by the linearization algorithm to @xmath154 .",
    "_ algorithm correctness .",
    "_ given a triple @xmath166 with a repeat vertex @xmath65 and no adjacency @xmath188 , we consider a candidate mixed assembly of @xmath47 containing the elements of @xmath24 contiguously . in such an assembly , we would encounter the consecutive substring @xmath189 .",
    "we can contract this substring and label the newly formed adjacency @xmath161 , signifying that there is a path of length @xmath98 between @xmath170 and @xmath163 which passes through @xmath65 and contains no other vertices , _",
    "i.e. _ , it encodes the triple @xmath24 .",
    "so , we construct the new assembly hypergraph ( an adjacency graph ) by deleting the adjacencies @xmath190 and @xmath172 and encoding the path containing @xmath24 into the adjacency @xmath161 added to @xmath177 .    the optimal edge - deletion algorithm from @xcite",
    "computes a maximum weight set of adjacencies @xmath191 such that the assembly graph @xmath192 has a mixed assembly , where @xmath193 and @xmath194 are the restrictions of @xmath195 and @xmath196 to @xmath197 . in this assembly",
    ", we can replace every @xmath198 by the corresponding triple @xmath24 and the two corresponding adjacencies from @xmath27 .",
    "note that none of the adjacencies from @xmath27 are discarded during linearization since they are weighted so that discarding any one would be suboptimal when compared to discarding the entire set of adjacencies from @xmath177 .",
    "so the assembly obtained by this process will contain all the edges from @xmath27 , as well as a maximum weight set @xmath199 such that every @xmath200 is present .",
    "this implies that we computed a maximum weight compatible set of triples from @xmath175 .",
    "_ algorithm complexity .",
    "_ checking the compatibility of a triple @xmath24 with @xmath69 can be done in constant time , since we just need a @xmath201-step graph search from any vertex @xmath202 , and proceed until we find a path connecting all @xmath201 vertices in @xmath24 .",
    "we can also check the number of repeats in @xmath24 in constant time . to deal with triples from the set @xmath175",
    ", the new assembly hypergraph can obviously be constructed in @xmath203 time and space , and contains @xmath204 vertices and @xmath205 edges .",
    "so the optimal edge - deletion algorithm is the main component of the process , and is based on a maximum weight matching algorithm of time complexity @xmath153 @xcite .",
    "related to this theorem , we have the following corollary .",
    "[ thm : maxcompatibility2 ] let @xmath152 be an assembly hypergraph such that @xmath69 admits a mixed genome assembly , maximal repeat clusters are all of size @xmath2 , and each interval is an unordered compatible triple .",
    "the assembly maximum interval compatibility problem in the mixed genome model can be solved for @xmath47 in linear space and @xmath153 time .",
    "we already know that we can find a maximal weight compatible subset @xmath199 if there is no @xmath156 containing more than @xmath2 repeat .",
    "we now show that for the current problem , a triple @xmath206 , where @xmath207 and @xmath208 are repeats , and @xmath209 , can also be included in the set @xmath154 if it is compatible with @xmath69 .",
    "note that @xmath207 and @xmath208 can not have an adjacency between them , since the size of a maximal cluster can not exceed @xmath2 .",
    "so , for @xmath24 to be compatible , the corresponding adjacencies will be @xmath210 and @xmath211 . for @xmath69 to have a mixed assembly which contains both adjacencies , the assembly must contain @xmath24 in the order @xmath212 .",
    "this is a contiguous appearance of the elements of @xmath24 , and it must occur in every mixed assembly .",
    "it can thus be included in @xmath154 .",
    "theorem  [ thm : maxcompatibility1 ] concludes the proof .",
    "[ def : repeatinterval ] let @xmath36 be an assembly hypergraph .",
    "an interval @xmath213 is an _ ordered repeat spanning interval _ for a maximal repeat cluster @xmath214 if @xmath215 with @xmath216 , @xmath217 and @xmath218 , where @xmath219 is a sequence on the set @xmath220 , containing every element at least once .",
    "the subset of ordered repeat spanning intervals in @xmath165 is denoted by @xmath221    [ thm : repeat_spanning_compatibility ] let @xmath222 be an assembly hypergraph such that every repeat @xmath95 is either contained in an adjacency , or it is contained in an interval @xmath223 of one of the following forms .    1 .",
    "@xmath24 is an ordered repeat spanning interval .",
    "@xmath65 is the only repeat in @xmath24 , @xmath224 , and @xmath225 .",
    "the assembly decision problem in the linear genome model can be solved for @xmath47 in polynomial time and space .",
    "the basic idea of the proof is to realize the sequence @xmath40 for every repeat spanning interval @xmath226 by creating unique copies of the repeats in @xmath24 and decreasing the multiplicity accordingly .",
    "this leads to an assembly graph that can then be checked using theorem [ thm : adadjacencies2 ] .",
    "formally we define an extended assembly hypergraph , @xmath227 , as follows ( we omit @xmath228 from the notation , since we are addressing a decision problem ) .",
    "1 .   @xmath229 , @xmath230 , @xmath231 , @xmath232 , @xmath233 .",
    "2 .   for every repeat spanning interval @xmath234 .",
    "1 .   let @xmath235 , possibly @xmath236 for @xmath237 ( the @xmath127 are repeats ) .",
    "2 .   for @xmath133 from @xmath2 to @xmath238 1 .   add a unique vertex @xmath239 to @xmath240 , with multiplicity @xmath241 , 2 .",
    "add an adjacency @xmath242 to @xmath48 for @xmath243 , 3 .",
    "decrease @xmath244 by 1 . 3 .",
    "add edges @xmath245 and @xmath246 to @xmath48 .",
    "4 .   if the adjacencies @xmath247 and @xmath248 are present , add them to @xmath177 .",
    "3 .   check if the assembly hypergraph , @xmath249 admits a linear genome assembly using theorem [ thm : adadjacencies2 ] .",
    "@xmath47 admits a valid genome assembly in the linear genome model if and only if @xmath250 for every repeat @xmath251 and @xmath252 admits one .",
    "assume @xmath252 admits an assembly @xmath253 . by construction , every repeat @xmath65 of @xmath20 maps to a subset of @xmath240 composed of @xmath65 and the vertices added when reading occurrences of @xmath65 in the ordered repeat spanning intervals of @xmath29 . for a repeat @xmath254 ,",
    "let @xmath255 be this subset of @xmath240 and @xmath256 the inverse map . by construction",
    ", the adjacencies added to @xmath48 when reading the order @xmath40 of an interval @xmath24 , when the inverse map is applied @xmath256 to their vertices , define a walk in @xmath47 corresponding exactly to @xmath40 , which allows us to unambiguously translate the set of linear walks on @xmath257 defining @xmath253 into a set of linear walks @xmath41 on @xmath1 .",
    "this implies that every edge of @xmath44 is compatible with @xmath41 ( as defined in def .",
    "[ def : compatibility ] ) , and we only need to consider potential problems caused by multiplicities .",
    "assume that for every repeat @xmath251 one has @xmath250 and that for every @xmath258 , @xmath259 appears at most @xmath260 times in an assembly of @xmath252 , _",
    "i.e. _ , exactly @xmath2 time , since @xmath261 for all @xmath258 . for a vertex @xmath134",
    "such that @xmath262 , by construction @xmath263 , so an assembly of @xmath252 also satisfies the constraints of an assembly of @xmath47 for @xmath18 . for a repeat @xmath251",
    ", the number of occurrences of elements of @xmath264 in @xmath253 is at most @xmath265 . by construction , @xmath266 , so assuming that @xmath250 implies that the constraint on @xmath77 is satisfied in the linear walks on @xmath41 .",
    "now , consider @xmath47 admits an assembly @xmath41 in the linear genome model . by definition , for every repeat spanning interval @xmath24 , @xmath40 appears as a walk in @xmath41 . by replacing the repeats in such a walk by new vertices with multiplicity @xmath2",
    "as done in step 2.b of the algorithm above , one clearly obtains an assembly @xmath267 for @xmath252 , and the identity @xmath266 ensures that @xmath250 .    _",
    "_ the polynomial time and space complexity follows from theorem  [ thm : adadjacencies2 ] , since the the construction of @xmath252 results in an assembly hypergraph with the structure in which no two repeats are contained in an interval ( the repeat spanning intervals being resolved ) , and if an interval @xmath185 contains a repeat @xmath65 , there exists an edge @xmath268 in @xmath48 , since we added them directly from @xmath47 .",
    "the following corollary follows easily from the previous theorem .",
    "[ cor : repeatspanning ] let @xmath152 be an assembly hypergraph such that each interval is an ordered repeat spanning interval .",
    "the assembly decision problem in the mixed and linear genome models can be solved for @xmath47 in @xmath269 time and space .",
    "we make the same construction as in theorem  [ thm : repeat_spanning_compatibility ] . the extended assembly graph @xmath270 we create now is composed entirely of adjacencies , since @xmath271 .",
    "an application of theorem  [ thm : adadjacencies1 ] completes the proof .",
    "the time and space complexities follow immediately from the linear time and space complexities stated in theorem  [ thm : adadjacencies1 ] and from the size of @xmath270 .",
    "the results above have interesting practical implications that we outline now .",
    "first , corollary [ cor : repeatspanning ] shows that , if provided with ordered repeat spanning intervals , one can check for the existence of an assembly in both genome models .",
    "ordered repeat spanning intervals can be obtained in practice in several ways , such as mapping the elements of @xmath39 onto related genomes @xcite or long reads ( see appendix for more details ) .",
    "the tractability of the assembly decision problem , with linear time and space complexities , makes it possible to combine it with the tractability result of theorem [ thm : amedadjacencies1 ] to select a subset of adjacencies , followed by a greedy heuristic for the assembly maximum interval compatibility problem .",
    "note also that the condition on the unordered intervals in the statement of theorem [ thm : repeat_spanning_compatibility ] allows one to account for the important notion of _ telomeres _ @xcite .",
    "regarding theorem [ thm : maxcompatibility1 ] , it can be used to partially clear the ambiguities caused by repeats in assembly hypergraphs where triples are obtained from mate - pairs of reads from sequencing libraries defined with inserts of length greater than the length of repeats@xcite .",
    "if all maximal repeat clusters are `` collapsed '' into a single vertex ( with the maximum multiplicity among all initial repeats of the cluster ) , such mate - pairs spanning repeat clusters define the triples .",
    "solving the assembly maximum interval compatibility problem allows us to specify the locations of the different occurrences of the spanned repeat clusters in the assembled genome , thus resolving part of the ambiguity due to repeats and leaving only the internal structure of each repeat cluster ( content and order ) unresolved .",
    "in the present work , we presented a set of positive results on some hypergraph covering problems motivated by genome assembly questions . to the best of our knowledge , these are the first such results for handling repeats in assembly problems in an edge - deletion approach , as previous results focused on superstring approaches @xcite , and these new methods have been applied on real data @xcite .",
    "moreover , the initial results we presented suggest several open problems .",
    "first , our results about triples assume that they are compatible with @xmath69 ( _ i.e. _ , appear as walks in @xmath160 ) ; we conjecture that similar positive results can be obtained when relaxing this condition ( in particular when triple elements might not appear in the same connected component ) .",
    "next , our edge - deletion positive results assume that @xmath69 admits a genome assembly , and only intervals are considered for being deleted .",
    "this leads to a two - stage assembly process where adjacencies are deleted first , followed by intervals .",
    "it remains open to see if both adjacencies and limited families of intervals can be considered jointly . also of interest",
    "would be to see if the size of maximal repeat clusters or of intervals can be used as parameters for fpt results .",
    "regarding repeat - spanning intervals , it can be asked if one can relax the total order structure @xmath73 to account for uncertainty ; for example , if they are defined from the comparison of pairs of related genomes , it might happen that specific rearrangements lead to conserved genome segments that can be described by partial orders @xcite , which opens the question of solving the assembly decision problem with partial orders to describe repeat - spanning intervals .",
    "along the same line , it might happen that intervals spanning only prefixes or suffixes of repeat occurrences ( called _ repeat - overlapping intervals _ ) can be detected , and the tractability of the assembly decision problem with such intervals is open ; we conjecture it is fpt in the number of such intervals .    finally , _",
    "gaps _ , that can be described in terms of binary matrices , as entries @xmath272 appearing between entries @xmath2 , appears naturally in genome scaffolding problems @xcite ; the notion of gaps can naturally be described , for graphs , in terms of _ bandwidth _ and has been extended to binary matrices / hypergraphs in @xcite .",
    "very limited tractability result exist when gaps are allowed , whether it is for graphs @xcite or hypergraphs @xcite , none considering repeats , which opens a wide range of questions of practical importance .",
    "in this appendix , we describe how the assembly hypergraph relates to practical genome assembly problems .    our initial motivation for investigating the algorithmic problems described in this paper follows from earlier computational paleogenomics methods developed to compute genome maps and scaffolds for ancestral genomes @xcite .",
    "in this problem , the vertex set @xmath39 represents a set of @xmath204 ancestral genomic markers , obtained either through whole genome alignment @xcite , the analysis of gene families @xcite , or the sequencing of an ancient genome @xcite .",
    "the function @xmath273 encodes the multiplicity , that is an upper bound on the allowed number of copies of each marker in potential assemblies . for ancestral genomes",
    ", it can be obtained from traditional parsimony methods @xcite .",
    "an edge @xmath274 encodes the hypothesis that @xmath275 appear _ contiguously _ in an assembly of the elements of @xmath39 . for ordered intervals , that are edges @xmath24 , such that @xmath25 and @xmath276",
    ", @xmath40 encodes a total ordering information about the genomic elements they contain . in computational paleogenomics , edges and intervals",
    "( including order ) can be obtained from the comparison of pairs of genomes related to the ancient genome that is being assembled .",
    "the function @xmath228 is a weight that can be seen as a confidence measure on every edge ( the higher , the better ) , that can be based on phylogenetic conservation . more generally , the assembly hypergraph is a natural model for genome mapping problems @xcite .",
    "however , the assembly hypergraph also allows us to formalize other assembly problems .",
    "for example , in the _ scaffolding _",
    "problem @xcite , @xmath39 would represent _ contigs _ and @xmath273 can be obtained by methods based on the reads depth of coverage @xcite .",
    "co - localization information can be obtained from mate - pairs libraries with an insert that is short with respect to the minimum contig length , thus describing adjacencies , while ordered intervals can be obtained from mapping contigs onto long reads @xcite or related genome sequences @xcite .",
    "the assembly hypergraph can also be used to model the problem of assembling short reads into contigs , although contig assembly is generally based on eulerian superstring approaches @xcite instead of edge deletions approaches . in this problem ,",
    "the vertices @xmath39 represent short sequence elements , such as reads in the overlap graph approach @xcite or @xmath238-mers ( substrings of length @xmath238 ) in the widely used de bruijn graph approach @xcite .",
    "the function @xmath273 can here again be obtained from the reads depth of coverage .",
    "adjacencies follow from overlaps between elements of @xmath39 , whose statistical significance , combined with the read quality for example , can be used to define @xmath228 .",
    "intervals can here again be obtained from mapping short reads on long reads .    finally , it is important to remember that genomic segments are _ oriented _ along a chromosome , due to the double stranded nature of most genomes .",
    "the algorithms we described in the present paper can handle this problem in a very easy way .",
    "each genomic element is represented by two vertices , one for each extremity , with an adjacency linking them ( called a _ required _ adjacency , while adjacencies between extremities of different elements are called _ inferred _ adjacencies ) .",
    "a compatible assembly then needs to be composed of linear or circular walks where required adjacencies alternate with inferred adjacencies .",
    "this property can be handled naturally by the decision algorithms ( see @xcite ) , and also by the optimization algorithms by weighting each required adjacency by a weight greater than the cumulative weight of all inferred adjacencies .",
    "also , triples that overlap repeats need to be replaced by quadruples containing both extremities of a same initial genomic element , which can be handled by our algorithms ( full details will be given in the complete version of our work ) ."
  ],
  "abstract_text": [
    "<S> the consecutive - ones property ( c1p ) is a classical concept in discrete mathematics that has been used in several genomics applications , from physical mapping of contemporary genomes to the assembly of ancient genomes . a common issue in genome assembly concerns repeats , genomic sequences that appear in several locations of a genome . </S>",
    "<S> handling repeats leads to a variant of the c1p , the c1p with multiplicity ( mc1p ) , that can also be seen as the problem of covering edges of hypergraphs by linear and circular walks . in the present work , </S>",
    "<S> we describe variants of the mc1p that address specific issues of genome assembly , and polynomial time or fixed - parameter algorithms to solve them . </S>"
  ]
}