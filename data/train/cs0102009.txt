{
  "article_text": [
    "there is a long history of applications for the problem of adding edges to a graph in order to satisfy connectivity specifications ( see  @xcite for recent examples ) .",
    "correspondingly , the problem has been extensively studied for making general graphs @xmath0-edge connected or @xmath0-vertex connected for various values of @xmath0 @xcite as well as for making vertex subsets suitably connected @xcite .    in this paper , we focus on augmenting bipartite graphs .",
    "a graph is _ componentwise biconnected _ if every connected component either is biconnected or is an isolated vertex .",
    "this paper presents a linear - time algorithm for the problem of inserting the smallest number of edges into a given bipartite graph to make it componentwise biconnected while maintaining its bipartiteness .",
    "this problem and related bipartite augmentation problems arise naturally from research on statistical data security @xcite . to protect sensitive information in a cross tabulated table ,",
    "it is a common practice to suppress some of the cells in the table .",
    "a basic issue concerning the effectiveness of this practice is how a table maker can suppress a small number of cells in addition to the sensitive ones so that the resulting table does not leak significant information .",
    "this protection problem can be reduced to augmentation problems for bipartite graphs  @xcite . in particular",
    ", a linear - time algorithm for our augmentation problem immediately yields a linear - time algorithm for suppressing the smallest number of additional cells so that no nontrivial information about any individual row or column is revealed to an adversary  @xcite .",
    "section [ sec_def ] formally states our augmentation problem and discusses main results .",
    "section  [ sec_special_case ] proves an optimal bound on the smallest number of additional edges needed for the problem .",
    "section  [ sec_linear_time ] gives a linear - time algorithm to solve the augmentation problem .",
    "in this paper , all graphs are undirected and have neither self loops nor multiple edges .",
    "two vertices of a graph are _ biconnected _ if they are in the same connected component and remain so after the removal of any single edge or any single vertex other than either of them .",
    "a set of vertices is _ biconnected _ if every pair of its vertices are biconnected ; similarly , a graph is _ biconnected _ if its set of vertices is biconnected . to suit our application of protecting sensitive information in statistical tables ,",
    "this definition for biconnectivity is slightly different from the one used in standard textbooks . in particular",
    ", we define a connected component of an isolated vertex to be biconnected and one with exactly two vertices to be not biconnected .",
    "a _ block _ of a graph is the induced subgraph of a maximal subset of vertices that is biconnected .",
    "a graph is _ componentwise biconnected _ if every connected component is a block . throughout this paper",
    ", @xmath1 denotes a bipartite graph .",
    "a _ legal edge _ of @xmath2 is an edge in @xmath3 but not in @xmath4 .",
    "a _ biconnector _ of @xmath2 is a set @xmath5 of legal edges such that @xmath6 is componentwise biconnected .",
    "optimal _ biconnector is one with the smallest number of edges .",
    "note that if @xmath7 or @xmath8 , @xmath2 is componentwise biconnected . if @xmath9 and @xmath10 ( or @xmath11 and @xmath12 ) , @xmath2 has no biconnector .",
    "if @xmath13 and @xmath14 , @xmath2 has a biconnector . in light of these observations , the _ optimal biconnector problem",
    "_ is the following : given @xmath1 with @xmath15 and @xmath16 , find an optimal biconnector of @xmath2 .",
    "the remainder of this paper assumes @xmath15 and @xmath16 .",
    "also , let @xmath17 and @xmath18 be the numbers of vertices and edges in @xmath2 , respectively .",
    "given an edge subset @xmath19 and a vertex subset @xmath20 of @xmath2 , @xmath21 denotes @xmath2 without the vertices in @xmath20 and their adjacent edges .",
    "@xmath22 denotes @xmath23 ,",
    "i.e. , the resulting @xmath2 after the edges in @xmath19 are deleted .",
    "@xmath24 denotes @xmath25 , i.e. , the resulting @xmath2 after the edges in @xmath19 are added to @xmath2 .",
    "a _ cut vertex _ or _ edge _ of a graph is one whose removal increases the number of connected components .",
    "singular _ connected component is one formed by an isolated vertex . a _ singular _",
    "block is one with exactly one vertex .",
    "isolated _ block is one that is also a connected component .",
    "a _ pendant _",
    "block is a singular block consisting of a vertex of degree @xmath26 or a nonsingular block containing exactly one cut vertex .",
    "let @xmath27 denote the set of pendant blocks of @xmath2 .",
    "a vertex of @xmath2 is _ type @xmath28 _ or _ @xmath29 _ if it is in @xmath28 or @xmath29 , respectively .",
    "a block of @xmath2 is _ type @xmath28 _ or _",
    "_ if all of its noncut vertices are in @xmath28 or @xmath29 , respectively ; a block is _",
    "type @xmath30 _ if it has at least one noncut vertex in @xmath28 and one in @xmath29 .",
    "a _ legal pair _ of @xmath2 is formed by two distinct elements in @xmath27 paired according to the following rules .",
    "type @xmath28 may pair with type @xmath29 or @xmath30 .",
    "type @xmath29 may pair with type @xmath28 or @xmath30 .",
    "type @xmath30 may pair with all three types .",
    "a _ binding _",
    "edge for a legal pair is a legal edge between two noncut vertices , one from each of the two blocks of the pair .    [ lem_demanding ]    1 .",
    "[ lem_demanding_2 ] a noncut vertex is in exactly one block .",
    "each pendant block contains a noncut vertex .",
    "[ lem_block_type_2 ] a singular pendant block of @xmath2 is either type @xmath28 or @xmath29 while a nonsingular pendant block is type @xmath30 and has at least two vertices from @xmath28 and at least two from @xmath29 .",
    "3 .   [ lem_binding ] there exists a binding edge for each legal pair of @xmath2 .",
    "straightforward .",
    "let @xmath31 .",
    "a _ legal matching _ of @xmath32 is a set of legal pairs between elements in @xmath32 such that each element in @xmath32 is in at most one legal pair .",
    "a _ maximum _ legal matching of @xmath32 is one with the largest cardinality possible .",
    "@xmath33 denotes the cardinality of a maximum legal matching of @xmath32 . for a maximum legal matching of @xmath32 , let @xmath34 i.e. , the number of elements in @xmath32 that are not in the given maximum legal matching .",
    "note that @xmath35 is the same for any maximum legal matching of @xmath32 .",
    "[ lem_mat ]    1 .   [ lemma_matchings ]",
    "let @xmath36 and @xmath37 be two disjoint nonempty sets of pendant blocks with @xmath38 .",
    "then some @xmath39 and @xmath40 form a legal pair with @xmath41 .",
    "[ lem_match_num ] let @xmath42 and @xmath43 be the numbers of type @xmath28 , @xmath29 and @xmath30 pendant blocks in @xmath27 , respectively .",
    "then , @xmath44 , and @xmath45 , where @xmath46 , @xmath47 and @xmath48 .",
    "the first statement follows from the fact that @xmath49 has a maximum legal matching that contains a legal pair between @xmath36 and @xmath37 .",
    "the second statement follows from the fact that a maximum legal matching can be obtained by iteratively applying any applicable rule below : [ sec : match ]    * if there are one unpaired type @xmath28 pendant block and one unpaired type @xmath29 pendant block , then we pair a type @xmath28 pendant block and a type @xmath29 one .",
    "* if there is no unpaired type @xmath29 @xmath50respectively , @xmath28@xmath51 pendant block and there are one unpaired type @xmath28 @xmath50respectively , @xmath29@xmath51 pendant block and one unpaired type @xmath30 pendant block , then we pair a type @xmath28 @xmath50respectively , @xmath29@xmath51 pendant block with a type @xmath30 one . *",
    "if all unpaired pendant blocks are type @xmath30 , then we pair two such blocks .",
    "for all vertices @xmath52 , @xmath53 denotes the number of connected components in @xmath54 where @xmath55 is the connected component of @xmath2 containing @xmath56 .",
    "@xmath57 denotes the number of connected components in @xmath2 that are not blocks .",
    "@xmath58 denotes the number of edges in an optimal biconnector of @xmath2 .",
    "when @xmath2 is connected , our target size for an optimal biconnector is : @xmath59      we first prove a lower bound on the size of an optimal biconnector and then discuss two main results of this paper .",
    "[ lem_lower ]    1 .",
    "[ lem_alpha_biconnected ] @xmath2 is componentwise biconnected if and only if @xmath60 .",
    "[ theorem_lower_bound ] @xmath61 .",
    "statement  [ lem_alpha_biconnected ] is straightforward . to prove statement  [ theorem_lower_bound ]",
    ", it suffices to show @xmath62 and @xmath63 .",
    "let @xmath5 be an optimal biconnector of @xmath2 .    to prove @xmath64 , note that @xmath65 is empty .",
    "thus , every block in @xmath27 contains an endpoint of an edge in @xmath5 .",
    "since all the edges in @xmath5 are legal , @xmath5 contains at least @xmath66 edges .    to prove @xmath67 , we need such an @xmath5 that the non - block connected components of @xmath2 are all contained in the same connected component of @xmath68 .",
    "if a given @xmath5 has not yet satisfied this property , then let @xmath69 and @xmath70 be two non - block connected components of @xmath2 that are contained in two different connected components @xmath71 and @xmath72 of @xmath68 , respectively .",
    "let @xmath73 and @xmath74 be two edges in @xmath5 . such @xmath75 and @xmath76 exist because @xmath69 and @xmath70 are not biconnected in @xmath2 , but @xmath71 and @xmath72 are biconnected in @xmath68 .",
    "next , let @xmath77 and @xmath78 . then , @xmath79 remains an optimal biconnector of @xmath2 .",
    "also , @xmath80 connects @xmath81 and @xmath82 , which include @xmath69 and @xmath70 . by repeating this endpoint switching process",
    ", we can construct a desired @xmath5 .",
    "with such an @xmath5 , we proceed to prove @xmath63 . since this claim trivially holds",
    "if @xmath2 is componentwise biconnected , we focus on the case where @xmath2 is not componentwise biconnected . then , @xmath53 is maximized by some @xmath56 that is in a non - block connected component @xmath2 .",
    "let @xmath83 be the connected component of @xmath68 containing @xmath56 .",
    "since @xmath68 is componentwise biconnected , @xmath84 is connected .",
    "then , because @xmath85 has @xmath86 connected components , @xmath87 , proving our claim .",
    "the next theorem is a main result of this paper .",
    "[ thm_main_all_special ] if @xmath2 is connected , then @xmath88 .    by lemma  [ lem_lower ] , @xmath61 .",
    "for ease of understanding , the proof for @xmath89 is delayed to theorem  [ thm_main_special ] in  [ sec_special_case ] .",
    "the next theorem generalizes theorem  [ thm_main_all_special ] to @xmath2 that may or may not be connected .",
    "* let @xmath90 be the number of connected components of @xmath2 that are neither isolated edges nor blocks .",
    "* let @xmath91 be the number of isolated edges ; note that @xmath92 .",
    "* let @xmath93 be the number of connected components that are nonsingular blocks .",
    "[ thm_main ]    case m1 : @xmath94 and @xmath95 . then @xmath96 .",
    "case m2 : @xmath97 and @xmath98",
    ". then @xmath88 .",
    "case m3 : @xmath97 and @xmath99 .",
    "then @xmath88 .",
    "case m4 : @xmath100 , @xmath101 , and @xmath102",
    ". then @xmath103 .",
    "case m5 : @xmath100 , @xmath104 , and @xmath105",
    ". then @xmath106 .",
    "case m6 : @xmath107 .",
    "then @xmath108 .",
    "let @xmath109 be the connected component of @xmath2 that is neither an isolated edge nor a block .",
    "theorem  [ thm_main_all_special ] applies to the case where @xmath109 contains at least two vertices in @xmath28 and at least two in @xmath29 .",
    "thus , we may assume without loss of generality that @xmath109 contains exactly one vertex @xmath110 and @xmath111 vertices @xmath112 with @xmath113 .",
    "note that @xmath114 . because @xmath115 and @xmath116 , there is an isolated vertex @xmath117 or there is a nonsingular block in @xmath2 containing two vertices @xmath118 . in the former case",
    ", @xmath119 is an optimal biconnector ; in the latter case , @xmath120 is an optimal biconnector .",
    "case m2 . since @xmath98",
    ", we may assume without loss of generality that all the pendant blocks are type @xmath28 .",
    "note that @xmath121 , @xmath122 and @xmath123 .",
    "let @xmath124 be the connected components of @xmath2 that are neither isolated edges nor blocks .",
    "since each @xmath125 has more than two vertices , @xmath125 has a vertex @xmath126 .",
    "let @xmath127 be the pendant blocks of @xmath125 .",
    "each @xmath128 contains a noncut vertex @xmath129 .",
    "the set @xmath130 is a biconnector . by lemma  [ lem_lower]([theorem_lower_bound ] ) , this biconnector is optimal .    case m3 . by lemma  [ lem_lower ] , @xmath61 . to prove the upper bound ,",
    "let @xmath131 be a legal edge of @xmath2 .",
    "let @xmath132 .",
    "we first show how to choose @xmath131 so that @xmath133 . since @xmath99 , by lemma  [ lem_mat]([lemma_matchings ]",
    ") , we can find a legal pair @xmath134 and @xmath135 in different connected components with @xmath136 . by lemma  [ lem_demanding]([lem_binding ] ) ,",
    "let @xmath131 be a binding edge for @xmath134 and @xmath135 .",
    "note that @xmath137 , @xmath138 , @xmath139 , @xmath140 and @xmath141 .",
    "thus , @xmath142 .",
    "this process reduces @xmath57 and @xmath143 by @xmath26 each .",
    "we iterate this process until either ( 1 ) @xmath144 or ( 2 ) @xmath97 and @xmath145 . in the latter case , we use case m2 to complete the proof . in the former case ,",
    "note that we add an edge to combine two non - singular non - biconnected connected components into a connected component .",
    "this new connected component is neither an isolated edge nor a block .",
    "thus , @xmath146 ; i.e. , @xmath94 and @xmath121 in the resulting @xmath2 .",
    "we then use case m1 to complete the proof of this case .",
    "let @xmath147 be the isolated edge .",
    "let @xmath148 and @xmath149 be two isolated vertices .",
    "then , @xmath150 is an optimal biconnector of @xmath2 .",
    "let @xmath151 be a connected component that is a nonsingular block in @xmath2 .",
    "@xmath151 has a vertex @xmath152 and a vertex @xmath153 .",
    "let @xmath154 be the isolated edge of @xmath2 .",
    "then , @xmath155 is an optimal biconnector of @xmath2 .",
    "this case is straightforward .",
    "this section assumes that @xmath2 is connected .",
    "the _ block tree _ of @xmath2 is a tree @xmath157 defined as follows .",
    "@xmath158 denotes the set of nonsingular blocks of @xmath2 .",
    "@xmath159 is that of singular pendant ones .",
    "@xmath160 is that of singular non - pendant ones .",
    "@xmath161 is that of cut vertices .",
    "@xmath162 is that of cut edges .",
    "the vertex set of @xmath157 is @xmath163 , where @xmath160 is excluded because if @xmath164 , then @xmath165 . the vertices in @xmath157 corresponding to @xmath166",
    "are called the _ b - vertices _ ; those corresponding to @xmath167 are the _ c - vertices_. to distinguish between an edge in @xmath2 and one in @xmath157 , let @xmath168 instead of @xmath169 denote an edge between two vertices @xmath170 and @xmath171 in @xmath157 .",
    "the edge set of @xmath157 is the union of the following sets :    * @xmath172 ; * @xmath173 such that @xmath174 is an endpoint of @xmath175 ; * @xmath176",
    ".    figure  [ fig : v2.1 ] illustrates @xmath2 and its blocks while figure  [ fig : v2.2 ] illustrates its block tree .",
    "[ fact_bc_forest ]    1 .",
    "[ fact_bc_forest_leaf_block ] @xmath157 is a tree with @xmath177 vertices .",
    "its leaves are the @xmath178 pendant blocks of @xmath2 .",
    "[ fact_bc_forest_degree ] for all cut vertices @xmath56 in @xmath2 , @xmath53 equals the degree of @xmath56 in @xmath157 .",
    "the proof is straightforward and similar to that for similar constructs @xcite .",
    "let @xmath179 denote the tree path between two vertices @xmath56 and @xmath180 in @xmath157 .",
    "let @xmath181 be the number of vertices in @xmath179 .",
    "[ fact_connecting_bc_noncut ] let @xmath182 and @xmath183 be a legal pair of @xmath2 .",
    "let @xmath131 be a binding edge for @xmath182 and @xmath183 .",
    "let @xmath184 .    1 .   [ bc_1 ] the cut vertices of @xmath2 corresponding to c - vertices in @xmath185 and the vertices of @xmath2 in the b - vertices on @xmath185 form a new block @xmath186 in @xmath151 .",
    "the b - vertices of @xmath187 are @xmath186 and those of @xmath157 not on @xmath185 .",
    "[ bc_2 ] the c - vertices in @xmath187 are those in @xmath157 excluding the ones on @xmath185 that are of degree @xmath188 in @xmath157 .",
    "[ bc_3 ] the edge set of @xmath187 is the union of * the set of edges in @xmath157 whose two endpoints are still in @xmath187 ; * @xmath189 is a cut vertex of @xmath2 that remains in @xmath190 ; * @xmath191 is a cut vertex of @xmath2 incident to @xmath185 in @xmath192 .",
    "[ bc_size ] the number of vertices in @xmath187 is at most that for @xmath157 minus @xmath193 .",
    "[ fact_leaf_con ] if @xmath185 contains a b - vertex of degree at least four in @xmath157 or two vertices each of degree at least three , then @xmath194 .    the proof is straightforward and similar to those for similar constructs @xcite .",
    "a cut vertex @xmath56 of @xmath2 is _ massive _ if @xmath195 ; it is _ critical _ if @xmath196 .",
    "[ lemma_structure ] assume @xmath197 .    1",
    ".   [ structure_2c ] @xmath2 has at most two critical vertices .",
    "if it has two , then @xmath198 .",
    "[ structure_1 m ] @xmath2 has at most one massive vertex .",
    "if it has one , then it has no critical vertex .",
    "the proof follows from lemma  [ fact_bc_forest ] , the inequality @xmath199 , and basic counting arguments for trees .",
    "the next theorem is the main result of this section .",
    "[ thm_main_special ] @xmath89 .    by lemma  [ lemma_structure ]",
    ", we divide the proof into the following five cases .",
    "the first case is discussed in lemma  [ lem_case0 ] ; the other cases are proved in   [ subsec_case_a][subsec_case_b ] , respectively .",
    "_ case s1 _ : @xmath200 .",
    "_ case s2 _ : @xmath201 and @xmath98 .",
    "_ case s3 _ : @xmath201 , @xmath202 , and @xmath2 has two critical vertices .",
    "_ case s4 _ : @xmath201 , @xmath202 , and @xmath2 has no massive vertex and at most one critical vertex .    _ case s5 _ : @xmath201 , @xmath202 , and @xmath2 has exactly one massive vertex .",
    "[ lem_case0 ] for case  s1 , theorem  [ thm_main_special ] holds .",
    "furthermore , given @xmath2 , an optimal biconnector can be computed in @xmath203 time .",
    "straightforward .",
    "[ subsec_case_a ]    [ lem_case1 ] theorem  [ thm_main_special ] holds for case  s2 .",
    "let @xmath204 . since @xmath145 , @xmath205 by lemma  [ fact_bc_forest ] .",
    "it suffices to construct a biconnector @xmath5 of @xmath0 edges for @xmath2 .",
    "let @xmath206 be the pendant blocks of @xmath2 .",
    "since @xmath98 , @xmath207 and we may assume @xmath126 without loss of generality",
    ". then , @xmath2 has a cut edge @xmath208 for each @xmath209 , where @xmath210 .",
    "since @xmath15 and @xmath145 , there is some @xmath211 .",
    "let @xmath151 be the connected component of @xmath212 containing @xmath213 .",
    "let @xmath5 be the set of legal edges @xmath214 for all @xmath215 and @xmath216 for all @xmath217 .",
    "it is straightforward to prove that @xmath5 is as desired by means of lemma  [ fact_connecting_bc_noncut ] .",
    "a path @xmath218 in @xmath157 is _ branchless _",
    "if for all @xmath219 with @xmath220 the degree of @xmath221 in @xmath157 is two .",
    "let @xmath222 and @xmath223 be the critical vertices of @xmath2 .",
    "a leaf _ clings _ to @xmath224 in @xmath157 if there is a branchless path between it and @xmath224 .",
    "[ lem_2_critical_match ]    1 .",
    "[ lem_2_critical_match_2 ] @xmath225 .",
    "[ lem_2_critical_match_3 ] @xmath157 has a branchless path between @xmath222 and @xmath223 , and exactly @xmath226 leaves cling to @xmath222 only while the other @xmath226 leaves cling to @xmath223 only .",
    "@xmath27 has a maximum legal matching in which each legal pair is between one clinging to @xmath222 and one clinging to @xmath223 .",
    "statement 1 follows lemma  [ lemma_structure ] .",
    "statement 2 follows from basic counting arguments for trees .",
    "statement 3 follows from the first two and lemma  [ lem_mat]([lemma_matchings ] ) .",
    "[ lem_case2 ] theorem  [ thm_main_special ] holds for case  s3 .",
    "we add to @xmath2 a binding edge for each legal pair in the maximum legal matching of lemma  [ lem_2_critical_match ] . by lemmas",
    "[ fact_connecting_bc_noncut ] and [ lem_2_critical_match ] , the resulting graph is biconnected .",
    "we add @xmath226 edges , which by lemma  [ lem_2_critical_match]([lem_2_critical_match_2 ] ) is optimal .",
    "since @xmath201 , we can divide case s4 into two subcases :    _ case s4 - 1 _ : @xmath157 has exactly one vertex of degree at least three .    _",
    "case s4 - 2 _ : @xmath157 has more than one vertex of degree at least three .",
    "[ lem_case3_1 ] theorem  [ thm_main_special ] holds for case s4 - 1 .",
    "let @xmath227 be the vertex in @xmath157 of degree at least three .",
    "there are two cases :    _ case _ 1 : @xmath227 is a @xmath228-vertex .",
    "then , @xmath229 .",
    "_ case _ 2 : @xmath227 is a @xmath174-vertex . since @xmath227 is not massive , @xmath230 and @xmath231 .    in either case , let @xmath232 be a maximum legal matching of @xmath27 ; next , let @xmath233 be a set of legal pairs formed by pairing each pendant block not yet matched in @xmath232 with one already matched .",
    "then , @xmath234 is a set of the smallest number of legal pairs of @xmath2 such that each element in @xmath27 is in a pair .",
    "we add to @xmath2 a binding edge for each pair in @xmath235 . since @xmath202 , we add @xmath236 edges .",
    "since @xmath202 in case 1 and @xmath231 in case 2 , these edges form a desired biconnector by lemma  [ fact_connecting_bc_noncut ] .    to discuss case s4 - 2 , we further assume that @xmath157 is rooted at a vertex with at least two neighbors ; however , the degree of a vertex in @xmath157 still refers to its number of neighbors instead of children .",
    "the next lemma chooses an advantageous root for @xmath157 for our augmentation algorithm .",
    "given a vertex @xmath180 in @xmath157 , a _ branch _ of @xmath180 , also called a _",
    "@xmath180-branch _ , is the subtree of @xmath157 rooted at a child of @xmath180 .",
    "a _ chain _ of @xmath180 , also called a _",
    "@xmath180-chain _ , is a @xmath180-branch that contains exactly one leaf in @xmath157 .",
    "let @xmath237 be a c - vertex in @xmath157 of the largest possible degree .",
    "[ lem_nice_pair ] in case s4 - 2 , we can reroot @xmath157 at a vertex @xmath238 such that    1 .",
    "[ nice_1 ] either @xmath238 is of degree two and no @xmath238-branch is a chain or @xmath238 is of degree at least three ; 2 .",
    "[ nice_3 ] if @xmath237 is critical , then @xmath239 .",
    "let @xmath111 be the current root of @xmath157 .",
    "there are three cases .",
    "_ case _ 1 : @xmath237 is not critical , and either @xmath111 is of degree two and no @xmath111-branch is a chain or @xmath111 is of degree at least three .",
    "we set @xmath240 .",
    "_ case _ 2 : @xmath237 is not critical , @xmath111 is of degree two , and an @xmath111-branch is a chain . note that @xmath157 has a vertex @xmath241 of degree at least three .",
    "we set @xmath242 .",
    "_ case _ 3 : @xmath237 is critical . since @xmath201 , @xmath237 is of degree three or more .",
    "we set @xmath239 .",
    "[ lem_find_pair ] let @xmath238 be the root of @xmath157 . in case s4 - 2 , if either @xmath238 is of degree two and no @xmath238-branch is a chain or @xmath238 is of degree at least three , then @xmath2 has a legal pair @xmath134 and @xmath135 such that    1 .",
    "[ find_1 ] @xmath243 passes through @xmath238 and two vertices of degree at least three ; 2 .",
    "[ find_2 ] @xmath136 .",
    "there are two cases .",
    "_ case _ 1 : the degree of @xmath238 is two and no @xmath238-branch is a chain .",
    "let @xmath244 be an @xmath238-branch .",
    "_ case _ 2 : the degree of @xmath238 is at least three .",
    "since this is case  s4 - 2 , some descendant of @xmath238 has degree at least three .",
    "let @xmath244 be the @xmath238-branch containing that descendant .",
    "let @xmath36 be the set of leaves in @xmath244 .",
    "let @xmath245 . by lemma  [ lem_mat]([lemma_matchings ] ) , there exist a legal pair @xmath39 and @xmath40 with @xmath136 .",
    "then , @xmath243 contains @xmath238 as desired . furthermore , in case 1 , @xmath243 contains a vertex of degree at least three in @xmath244 and another in @xmath246 ; in case 2 , @xmath238 itself is of degree at least three , and @xmath243 contain a vertex of degree at least three in @xmath244 . in both cases , @xmath243 is as desired .",
    "[ lem_basic_case3 ] in case s4 - 2 , we can add a legal edge to @xmath2 such that    1 .",
    "[ case3_2 ] the resulting graph @xmath151 satisfies case  s1 , s2 , s3 or s4 ; 2 .",
    "[ case3_1 ] @xmath247 ; 3 .",
    "[ case3_3 ] if @xmath2 has a critical vertex , then that vertex remains critical in @xmath151 .",
    "we use lemma  [ lem_nice_pair ] to reroot @xmath157 , use lemma  [ lem_find_pair ] to pick a legal pair @xmath134 and @xmath135 , and then add a binding edge for this pair to @xmath2 . by lemmas  [ lem_find_pair]([find_1 ] ) and [ fact_connecting_bc_noncut]([fact_leaf_con ] ) , @xmath248 . by lemma  [ lem_find_pair]([find_2 ] ) , @xmath249 .",
    "hence @xmath250 .",
    "there are two cases .",
    "_ case _ 1 : @xmath2 has no critical vertex . then , by lemma",
    "[ fact_connecting_bc_noncut ] , @xmath251 @xmath252 .",
    "_ case _ 2 : @xmath2 has a critical vertex .",
    "then , @xmath237 is the critical vertex and @xmath253 . by lemmas  [ lem_nice_pair]([nice_3 ] ) , [ lem_find_pair]([find_1 ] ) , and lemma  [ fact_connecting_bc_noncut ] , @xmath254 @xmath255 .",
    "hence @xmath237 remains to be a critical vertex .    in either case , @xmath256",
    "then , @xmath133 . also , @xmath151 has no massive vertex and thus satisfies case  s1 , s2 , s3 or s4 .",
    "[ lem_case3 ] theorem  [ thm_main_special ] holds for case  s4 .    for case  s4 - 1 , we use lemma  [ lem_case3_1 ] . for case  s4 - 2",
    ", we add one edge to @xmath2 at a time using lemma  [ lem_basic_case3 ] until the resulting graph @xmath151 does not satisfy case  s4 - 2 . by lemma  [ lem_basic_case3]([case3_2 ] ) , @xmath151 satisfies case  s1 , s2 , s3 or s4 - 1 .",
    "thus , we apply lemma  [ lem_case0 ] , [ lem_case1 ] , [ lem_case2 ] , or [ lem_case3_1 ] to @xmath151 accordingly . by lemma  [ lem_basic_case3]([case3_1 ] ) , the number of edges added is @xmath236 .",
    "let @xmath111 be the massive cut vertex of @xmath2 .",
    "let @xmath157 be rooted at @xmath111 .",
    "[ lem_case_four ]     1 .",
    "[ lem_three_dec ] @xmath257 for any vertex @xmath258 .",
    "2 .   [ lem_b_r ] @xmath259 and there are at least four @xmath111-chains .",
    "[ lemma_b_pair ] the tree @xmath157 contains a legal pair @xmath182 and @xmath183 as well as two distinct @xmath111-branches @xmath260 and @xmath261 such that @xmath260 is a chain , @xmath262 , and @xmath263 .",
    "statement [ lem_three_dec ] .",
    "this statement follows from the definition of case s5 .",
    "statement [ lem_b_r ] .",
    "let @xmath264 be the number of @xmath111-chains .",
    "then , @xmath265 and @xmath266 .",
    "so @xmath267 .",
    "let @xmath268 . because @xmath111 is massive , @xmath269 .",
    "note that @xmath270 .",
    "thus @xmath271 .    statement  [ lemma_b_pair ] .",
    "let @xmath260 be an @xmath111-chain .",
    "let @xmath182 be the leaf of @xmath157 in @xmath260 . because @xmath202 , @xmath157 contains a leaf @xmath272 that forms a legal pair with @xmath182 .",
    "let @xmath261 be the @xmath111-branch that contains @xmath183 .",
    "then , @xmath182 , @xmath183 , @xmath260 and @xmath261 are as desired .",
    "[ lem_basic_case4 ] we can add a legal edge to @xmath2 such that for the resulting graph @xmath151 ,    1 .   [ case4_1 ] @xmath247 ; 2 .",
    "[ case4_2 ] @xmath273 .",
    "let @xmath182 , @xmath183 , @xmath260 and @xmath261 be as stated in lemma  [ lem_case_four]([lemma_b_pair ] ) .",
    "the added edge is a binding edge for @xmath182 and @xmath183 . by lemma  [ fact_connecting_bc_noncut ] , the b - vertices and c - vertices on @xmath185 form a new block @xmath274 in @xmath151 .",
    "@xmath274 may or may not be a leaf in @xmath187 ; in either case , @xmath275 .",
    "note that @xmath185 contains @xmath111 .",
    "thus , by lemmas  [ fact_connecting_bc_noncut ] and [ lem_case_four]([lem_b_r ] ) , @xmath111 remains a cut vertex in @xmath151 with @xmath276 while @xmath277 for all vertices @xmath278 .",
    "consequently , @xmath133 .",
    "[ time_vi ] theorem  [ thm_main_special ] holds for case  s5 .",
    "moreover , this case can be reduced in linear time to case s1 , s2 , s3 or s4 .",
    "we add one edge to @xmath2 at a time using lemma  [ lem_basic_case4 ] until the resulting graph @xmath151 satisfies case s1 , s2 , s3 or s4 .",
    "thus , we apply lemma  [ lem_case0 ] , [ lem_case1 ] , [ lem_case2 ] or [ lem_case3 ] accordingly . by lemma  [ lem_basic_case4]([case4_1 ] ) , @xmath236 edges are added . to implement this proof in linear time ,",
    "we first define a data structure as follows .",
    "let @xmath279 be the set of leaves of @xmath157 that are in the @xmath111-chains .",
    "we set up a counter for the number of these leaves .",
    "we also set up three doubly linked lists containing those of them that are types @xmath28 , @xmath29 , and @xmath30 , respectively .",
    "we set up a counter for the number of @xmath111-branches that are not chains . for each such branch , we set up a doubly linked list for the leaves of @xmath157 in it .",
    "we also set up three doubly linked lists for the leaves in these branches that are types @xmath28 , @xmath29 , and @xmath30 , respectively .",
    "given @xmath2 , we can set up these linked lists and counters in linear time .",
    "we next use this data structure to find a legal pair @xmath182 and @xmath183 by means of lemma  [ lem_case_four]([lemma_b_pair ] ) .",
    "since @xmath280 by lemma  [ lem_case_four]([lem_b_r ] ) , there are two cases .",
    "_ case _ 1 : some @xmath182 and @xmath281 form a legal pair .",
    "this is our desired pair .",
    "note the @xmath111-chains containing @xmath182 and @xmath183 in @xmath157 are contracted into a new chain in @xmath187 consisting of a single leaf of type @xmath30 .",
    "_ case _ 2 : @xmath279 contains only type @xmath28 or @xmath29 leaves .",
    "select any @xmath282 .",
    "since @xmath99 , some @xmath283 forms a desire legal pair with @xmath182 . note that @xmath182 and @xmath183 are no longer pendant blocks in @xmath151 and the newly created block is not a pendant block of @xmath151 , either .",
    "the @xmath111-branch containing @xmath183 becomes a chain if in @xmath2 it contains exactly two pendant blocks .",
    "it takes @xmath284 time to decide which of these two cases holds . in either case",
    ", the selection of @xmath182 and @xmath183 takes in @xmath284 time using the linked lists .",
    "once @xmath182 and @xmath183 are found , we can find a binding edge in @xmath284 time in a straightforward manner .",
    "after the edge is added to @xmath2 , we can update the data structure in @xmath284 time for @xmath151 .",
    "then , we use lemma  [ lem_mat]([lem_match_num ] ) and the counters to check whether @xmath151 satisfies case  s5 in @xmath284 time .",
    "we repeat this process until @xmath151 does not satisfies case  s5 . at this point",
    ", we complete the reduction .",
    "since we iteratively add at most @xmath177 edges in case  s5 , the reduction takes linear time .",
    "[ sec_linear_time ]    [ thm_linear_time ] given @xmath2 , an optimal biconnector is computable in @xmath203 time .",
    "we prove this theorem by means of theorems  [ thm_main ] and [ thm_main_special ] as follows .",
    "given @xmath2 , it takes @xmath203 time to determine which case of theorem  [ thm_main ] holds .",
    "then , it takes @xmath203 time in a straightforward manner to compute an optimal biconnector for cases m2 , m4 , m5 and m6 ; reduce case m3 to case m1 or m2 ; and reduce case m1 to theorem  [ thm_main_special ] .",
    "next , it takes @xmath203 time to determine which case of theorem  [ thm_main_special ] holds .",
    "then , it is straightforward to compute an optimal biconnector in @xmath203 time for cases s1 , s2 , and s3 .",
    "lemma  [ time_vi ] reduces case s5 in @xmath203 time to case s1 , s2 , s3 or s4 . by lemma  [ lem_case3_1 ]",
    ", we can find an optimal biconnector in @xmath203 time for case s4 - 1 .",
    "the remaining proof shows how to reduce case s4 - 2 to case s1 , s2 , s3 or s4 - 1 in @xmath203 time by implementing the proof of lemma  [ lem_case3 ] .",
    "we define a data structure @xmath285 as follows .",
    "first , we root @xmath157 at a vertex of degree two or more as in  [ subsec_case_c ] and classify each vertex @xmath56 by a 4-bit code @xmath286 based on the subtree @xmath287 of @xmath157 rooted at @xmath56 :    * @xmath288 if and only if @xmath287 has more than one leaf ; * @xmath289 , @xmath290 or @xmath291 if and only if @xmath287 contains a leaf of type @xmath28 , @xmath29 or @xmath30 , respectively .",
    "the code has at most ten combinations , i.e. , @xmath292 , @xmath293 , @xmath294 and all the combinations with @xmath295 except @xmath296 .",
    "@xmath285 is @xmath157 augmented with the following items :    1 .",
    "[ data_l ] at each vertex in @xmath157 , @xmath285 maintains its degree and a doubly linked list for the children of @xmath56 with the same @xmath286 code .",
    "there are ten such lists .",
    "[ data_ab ] there are three counters for the numbers of leaves in @xmath157 of types @xmath28 , @xmath29 and @xmath30 , respectively .",
    "[ data_c ] the c - vertices of degree at least three are partitioned into groups of the same degree .",
    "each nonempty group is arranged into a doubly linked list .",
    "the lists themselves are connected by a doubly linked list in the increasing order of vertex degrees .",
    "we do not need parent pointers in @xmath285 , which are subtle to update @xcite .",
    "this finishes the description of @xmath285 .",
    "we can build @xmath285 from @xmath2 in @xmath203 time .",
    "[ lem_time ]    1 .",
    "[ time_reroot ]",
    "let @xmath111 be the current root of @xmath285 .",
    "let @xmath238 be as stated in lemma  [ lem_nice_pair ] .",
    "given @xmath285 , if @xmath111 is critical , we can reroot @xmath285 in @xmath284 time according to lemma [ lem_nice_pair ] ; @xmath177 time if @xmath111 is not critical but @xmath238 is ; or @xmath297 time if neither is . 2 .   [ time_find ] given @xmath285",
    ", we can find @xmath134 and @xmath135 of lemma  [ lem_find_pair ] in @xmath298 time .",
    "statement [ time_reroot ] .",
    "we implement the proof lemma  [ lem_nice_pair ] using the following steps .    1 .",
    "[ step_r1 ] use item [ data_c ] of @xmath285 to find @xmath237 .",
    "[ step_r2 ] use items [ data_l ] and [ data_ab ] of @xmath285 and lemma  [ lem_mat]([lem_match_num ] ) to decide which case of the proof of lemma  [ lem_nice_pair ] holds .",
    "[ step_r3 ] 1 .",
    "[ step_a0 ] for case 1 of the proof of lemma  [ lem_nice_pair ] , set @xmath299 and @xmath285 is unchanged .",
    "[ step_a1 ] for case 2 of the proof of lemma  [ lem_nice_pair ] , first use item [ data_l ] of @xmath285 to find the nearest desired descendant @xmath241 of @xmath111 and then reroot @xmath285 at @xmath300 and update it accordingly .",
    "[ step_a2 ] for case 3 of the proof of lemma  [ lem_nice_pair ] , if @xmath301 , then recompute @xmath285 from @xmath157 to root at @xmath302 ; otherwise , @xmath303 , and @xmath285 is unchanged .",
    "since steps [ step_r1 ] and [ step_r2 ] take @xmath284 time , the the time complexity of each case of this statement is bounded by that of step [ step_r3 ] .",
    "_ case _ 1 : @xmath111 is critical .",
    "step  [ step_a2 ] runs with @xmath304 in @xmath284 time .",
    "_ case _ 2 : @xmath111 is not critical but @xmath238 is .",
    "step  [ step_a2 ] runs with @xmath301 in @xmath177 time .",
    "_ case _ 3 : neither @xmath111 nor @xmath238 is critical .",
    "then , step  [ step_a0 ] or step  [ step_a1 ] is performed .",
    "step  [ step_a0 ] takes @xmath284 time . for step  [ step_a1 ]",
    ", the search for @xmath241 takes @xmath284 time per vertex on @xmath305 .",
    "since the internal vertices of @xmath305 all have degree two , updating item  [ data_l ] of @xmath285 along this path takes @xmath284 time per vertex .",
    "item  [ data_l ] of @xmath285 outside this path and the other two items remain the same .",
    "thus , this case takes @xmath306 total time as desired .",
    "statement [ time_find ] .",
    "we implement the proof of lemma  [ lem_find_pair ] using the following steps .    1 .   [ step_bbc ]",
    "use item  [ data_l ] of @xmath285 to decide which case of the proof of lemma  [ lem_find_pair ] holds .",
    "[ step_b ] use item  [ data_ab ] of @xmath285 and lemma  [ lem_mat]([lem_match_num ] ) to find all possible pairs of types @xmath307 and @xmath308 such that @xmath27 has a maximum matching that contains a legal pair between type @xmath307 and type @xmath308 .",
    "[ step_ba ] for each such pair of @xmath307 and @xmath308 , perform the following computation until @xmath134 and @xmath135 are found . 1",
    ".   [ step_b2 ] for case 1 of the proof of lemma  [ lem_find_pair ] , @xmath134 and @xmath135 are in the two branches of the root of @xmath285 separately .",
    "use item  [ data_l ] of @xmath285 at the root to decide whether the desired @xmath134 and @xmath135 exist .",
    "if they exist , use item  [ data_l ] of @xmath285 to search for them .",
    "[ step_b1 ] for case 2 of the proof of lemma  [ lem_find_pair ] , @xmath134 and @xmath135 are in two separate branches of the root , of which one is not a chain .",
    "the remaining computation is similar to that of step  [ step_b2 ] .    by lemma  [ lem_nice_pair ] , some pair @xmath307 and @xmath308 yields the desired @xmath134 and @xmath135",
    ". steps [ step_bbc ] and [ step_b ] take @xmath284 time .",
    "there are @xmath284 possible pairs of @xmath307 and @xmath308 . for each such pair ,",
    "checking the existence of @xmath134 and @xmath135 takes @xmath284 time .",
    "if they exist , searching for them takes @xmath284 time per vertex on the path @xmath243 .",
    "the next lemma completes the proof of theorem  [ thm_linear_time ] .",
    "case s4 - 2 is reducible to case s1 , s2 , s3 or s4 - 1 in @xmath203 time .    given @xmath2 in case s4 - 2 as input , the reduction algorithm is as follows :    1 .",
    "[ step_1 ] construct @xmath285 .",
    "[ step_2 ] * repeat * 1",
    ".   [ step_a ] use lemma  [ lem_time]([time_reroot ] ) to reroot @xmath285 .",
    "[ step_a22 ] use lemma  [ lem_time]([time_find ] ) to find a legal pair @xmath134 and @xmath135 .",
    "[ step_bx ] add a binding edge @xmath131 for @xmath134 and @xmath135 into @xmath2 .",
    "[ step_c ] use lemma  [ fact_connecting_bc_noncut ] to update @xmath285 while rerooting it at the new b - vertex @xmath186 resulting from the insertion of @xmath131 . +",
    "* until * @xmath2 does not satisfy case s4 - 2 .",
    "since step  [ step_1 ] takes @xmath203 time , it suffices to prove that step  [ step_2 ] takes @xmath177 time . by lemma  [ lem_find_pair]([find_1 ] ) , each iteration of step  [ step_2 ] reduces @xmath178 by two . since @xmath309 , the repeat loop has less than @xmath17 iterations . then , since the until condition can be checked in @xmath284 time per iteration using lemma  [ lem_mat]([lem_match_num ] ) and items [ data_ab ] and [ data_c ] of @xmath285 , the until step takes @xmath177 total time .",
    "similarly , step  [ step_bx ] takes @xmath284 time per iteration and @xmath177 total time in a straightforward manner .",
    "we next show that steps  [ step_a ] , [ step_a22 ] and [ step_c ] also take @xmath177 total time . for a given iteration ,",
    "let @xmath310 and @xmath109 denote @xmath2 before and after @xmath131 is inserted , respectively .    step  [ step_a ] .",
    "we show that each case in the proof of lemma  [ lem_time]([time_reroot ] ) takes @xmath177 total time as follows .",
    "this case takes @xmath284 time per iteration and thus @xmath177 total time .",
    "case 2 . by lemma  [ lem_basic_case3]([case3_3 ] ) , this case can only happen once in the above augmentation algorithm . hence , this case takes @xmath177 total time .",
    "this case takes @xmath284 time per edge on @xmath311 for an iteration .",
    "note that the degree of a vertex in @xmath285 never increases by edge insertion . then , since @xmath312 is rooted at @xmath186 with @xmath131 connecting two leaves of @xmath313 , each edge on @xmath311 is traversed only once to reroot @xmath285 for this case throughout all the iterations",
    ". therefore , this case takes @xmath177 total time .",
    "step [ step_a22 ] .",
    "this step takes @xmath298 time per iteration .",
    "since there are @xmath177 iterations , by lemma  [ fact_connecting_bc_noncut]([bc_size ] ) , this step takes @xmath177 total time .",
    "step [ step_c ] .",
    "we bound the time for updating each item of @xmath285 as follows .",
    "item  [ data_l ] of @xmath285 .",
    "notice that @xmath243 passes through the root of @xmath313 .",
    "also , @xmath312 is rooted at @xmath183 .",
    "these properties make it straightforward to update this item in @xmath298 time per iteration .",
    "since there are @xmath177 iterations , by lemma  [ fact_connecting_bc_noncut]([bc_size ] ) , this step takes @xmath177 total time .    item  [ data_ab ] of @xmath285 . by lemma  [ lem_find_pair]([find_1 ] ) , @xmath314 .",
    "thus it takes @xmath284 time to update this item per iteration and @xmath177 total time .    item  [ data_c ] of @xmath285 .",
    "let @xmath56 be a c - vertex in @xmath313 .",
    "if @xmath315 , it has the same degree in @xmath313 and @xmath312 and is not relocated in this item . if @xmath316 , its degree reduces at most 2 in @xmath312 and can be relocated in @xmath284 time . therefore , this item can be updated in @xmath298 time per iteration , i.e. , @xmath177 total time as shown for item  [ data_l ] .",
    "we are very grateful to dan gusfield for insightful discussions and to the anonymous referee for extremely thorough comments .                  height 2pt depth -1.6pt width 23pt , _ connectivity augmentation problems in network design _ , in mathematical programming : state of the art 1994 , j.  r. birge and k.  g. murty , eds .",
    ", the university of michigan , 1994 , pp .  3463",
    ".            height 2pt depth -1.6pt width 23pt , _ undirected vertex - connectivity structure and smallest four - vertex - connectivity augmentation @xmath50extended abstract@xmath51 _ , in lecture notes in computer science 1004 : proceedings of the 6th annual international symposium on algorithms and computation , j.  staples , ed . , new york , ny , 1995 , springer - verlag , pp .",
    "274283 .    , _ optimal bi - level augmentation for selectively enhancing graph connectivity with applications _ , in lecture notes in computer science 1090 : proceedings of the 2nd annual international computing and combinatorics conference , j.  y. cai and c.  k. wong , eds .",
    ", springer - verlag , new york , ny , 1996 , pp .",
    "169178 .    height 2pt depth -1.6pt width 23pt , _ security problems for statistical databases with general cell suppressions _ , in proceedings of the 9th international conference on scientific and statistical database management , d.  hansen and y.  ioannidis , eds .",
    ", ieee computer society , washington , dc , 1997 , pp .",
    "155164 .                  , _ censoring statistical tables to protect sensitive information : easy and hard problems _ , in proceedings of the 8th international conference on scientific and statistical database management , 1996 , pp .",
    "1221 .          ,",
    "_ minimum augmentation to @xmath0-edge - connect specified vertices of a graph _ , in lecture notes in computer science 834 : proceedings of the 5th annual international symposium on algorithms and computation , d.  z. du and x.  s. zhang , eds . , springer - verlag , new york , ny , 1994 , pp .",
    "217225 .      height 2pt depth -1.6pt width 23pt , _ graph augmentation problems for a specified set of vertices _ , in lecture notes in computer science 450 : proceedings of the 1st annual international symposium on algorithms , t.  asano , t.  ibaraki , h.  imai , and t.  nishizeki , eds .",
    ", springer - verlag , new york , ny , 1990 , pp ."
  ],
  "abstract_text": [
    "<S> a graph is _ componentwise biconnected _ if every connected component either is an isolated vertex or is biconnected . </S>",
    "<S> we present a linear - time algorithm for the problem of adding the smallest number of edges to make a bipartite graph componentwise biconnected while preserving its bipartiteness . </S>",
    "<S> this algorithm has immediate applications for protecting sensitive information in statistical tables . </S>"
  ]
}