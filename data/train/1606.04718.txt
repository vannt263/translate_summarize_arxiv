{
  "article_text": [
    "motivated by the rapid growth of huge data set ( `` big data '' ) , algorithms that utilize space efficiently are becoming increasingly important than ever before .",
    "another reason for the importance of space efficient algorithms is the proliferation of specialized handheld devices and embedded systems that have a limited supply of memory .",
    "even if mobile devices and embedded systems are designed with large supply of memory , it might be useful to restrict the number of write operations specifically for two reasons .",
    "one being writing into flash memory is a costly operation in terms of speed and time , and , secondly , it reduces the longevity of such memory . hence , there is a growing body of work that considers algorithms that do not modify the input and use only a limited amount of work space , and following the recent trend , this paper continues this line of research for fundamental graph algorithms .",
    "we assume that the input graph is given in a read - only memory ( and so can not be modified ) .",
    "if an algorithm must do some outputting , this is done on a separate write - only memory . when something is written to this memory",
    ", the information can not be read or rewritten again .",
    "so the input is `` read only '' and the output is `` write only '' .",
    "in addition to the input and the output media , a limited random - access workspace is available .",
    "the data on this workspace is manipulated wordwise as on the standard word ram , where the machine consists of words of size @xmath29 bits , and any logical , arithmetic , and bitwise operations involving a constant number of words take a constant amount of time .",
    "we count space in terms of the number of bits used by the algorithms in workspace . in other words , storing the input and output is for free , but the input / output space can not be used by the computation for any other purpose .",
    "this model is called the _",
    "register input model _ , and it was introduced by frederickson @xcite while studying some problems related to sorting and selection .",
    "while designing space efficient algorithms in read - only memory model , the specific details of the input graph representation are of great significance as we can neither modify the input nor copy the whole input in workspace . thus space - efficient algorithms  @xcite assume more powerful form of input representation than what is typically assumed in classical settings .",
    "here we assume that the input graph @xmath4 is represented using the standard _",
    "adjacency list along with cross pointers _",
    ", i.e. , for undirected graphs given a vertex @xmath30 and the position in its list of a neighbor @xmath31 of @xmath30 , there is a pointer to the position of @xmath30 in the list of @xmath31 . in case of directed graphs , for every vertex @xmath30",
    ", we have a list of out - neighbors of @xmath30 and a list of in - neighbours of @xmath30 . and , finally we augment these two lists for every vertex with cross pointers , i.e. , for each @xmath32 , given @xmath30 and the position of @xmath31 in out - neighbors of @xmath30 , there is a pointer to the position of @xmath30 in in - neighbors of @xmath31 . this form of input graph representation was introduced recently in  @xcite and used subsequently in  @xcite to design various other space efficient graph algorithms .",
    "we note that some of our algorithms will work even with less powerful and the more traditional _",
    "adjacency list _ representation .",
    "we specify these details regarding the exact form of input graph representation at the respective sections while describing our algorithms .",
    "we use @xmath5 and @xmath6 to denote the number of vertices and the number of edges respectively , in the input graph @xmath4 . throughout the paper , we assume that the input graph is a connected graph , and hence @xmath33 .      asano et al .",
    "@xcite show that dfs of a directed or undirected graph @xmath4 on @xmath5 vertices and @xmath6 edges can be performed using @xmath11 bits and ( an unspecified ) polynomial time .",
    "using @xmath14 bits , they bring down the running time to @xmath34 time , and using a larger @xmath8 bits , the running time of their algorithm is @xmath35 . in a similar vein ,    * we show in section [ bfs ] that the vertices of a directed or undirected graph can be listed in bfs order using @xmath15 bits and @xmath36 time where @xmath17 is any ( extremely slow - growing ) function of @xmath5 i.e. , @xmath37 ( the @xmath18 term in the space is a function of @xmath17 ) , while the running time can be brought down to the optimal @xmath7 time using @xmath14 bits .",
    "+ en route to this algorithm , we develop in section  [ datastructure ] , * a data structure that maintains a set of elements from a universe of size @xmath5 , say @xmath38 $ ] , using @xmath11 bits to support , apart from the standard insert , search and delete operations , the operation _ findany _ of finding an arbitrary element of the set , and returning its value all in constant time .",
    "it can also output all elements of the set in no particular order in @xmath12 time where @xmath13 is the number of elements currently belonging to the set .",
    "+ our structure gives an explicit implementation , albeit for a weaker set of operations than that of elmasry et al .",
    "[ lemma 2.1 ,  @xcite ] whose space requirement was @xmath39 bits for an unspecified constant @xmath40 ; bits for the data structure .",
    "see section  [ relwork ] for more details .",
    "] furthermore , our structure is simple and is sufficient to implement bfs space efficiently , improving by a constant factor of their bfs implementation keeping the running time same .    in what follows , in section [ super_linear_bfs ] ,",
    "we improve the space for bfs further at the cost of slightly increased runtime .",
    "we also provide a similar tradeoff for the minimum spanning tree problem in section [ minspan ] .",
    "in particular , we provide an implementation to find a minimum weight spanning tree in a weighted undirected graph ( with weights bounded by polynomial in @xmath5 ) using @xmath24 bits and @xmath25 time , for any function @xmath17 such that @xmath26 . while this algorithm is similar in spirit to that of elmasry et al .",
    "@xcite which works in @xmath35 time using @xmath8 bits or @xmath41 time using @xmath42 bits , we work out the constants in the higher order term for space , and improve them slightly though with a slight degradation in time .",
    "* using our data structure , in section  [ topo ] we develop another data structure to represent a sequence @xmath19 of @xmath5 non - negative integers using @xmath43 bits where @xmath44 . in this",
    ", we can determine whether the @xmath21-th element is @xmath22 and if not , decrement it , all in constant time .",
    "in contrast , the data structure claimed ( without proof ) in  @xcite can even change ( not just decrement ) or access the elements , but in constant _ amortized _ time .",
    "however , their structure requires an @xmath1 limit on the @xmath45 values while we pose no such restriction . using this data structure , in the same section , *",
    "* we give an implementation of computing a topological sort of a directed acyclic graph in @xmath7 time and @xmath7 bits of space .",
    "we can even detect if the graph is not acyclic within the same time and space bounds .",
    "this implementation , contrasts with an earlier bound of @xmath7 time and @xmath46 space  @xcite , and is more space efficient for sparse directed graphs ( that includes those directed graphs whose underlying undirected graph is planar or has bounded treewidth or degeneracy ) . *",
    "* a graph has a degeneracy @xmath23 if every induced subgraph of the graph has a vertex with degree at most @xmath23 ( for example , planar graphs have degeneracy @xmath47 , and trees have degeneracy @xmath48 ) .",
    "an ordering @xmath49 of the vertices in such a graph is a degenerate order if for any @xmath21 , the @xmath21-th vertex has degree at most @xmath23 among vertices @xmath50 .",
    "there are algorithms @xcite that can find the degeneracy order in @xmath7 time using @xmath8 words .",
    "we show that , given a @xmath23 , we can output the vertices of a @xmath23-degenerate graph in @xmath7 time using @xmath7 bits of space in the degeneracy order .",
    "we can even detect if the graph is @xmath23-degenerate in the process . as @xmath6 is @xmath51",
    ", we have an @xmath51 bits algorithm which is more space efficient if @xmath23 is @xmath52 ( this is the case , for example , in planar graphs or trees ) . * for dfs , asano et al .",
    "@xcite showed that dfs in a directed or undirected graph can be performed in @xmath35 time and @xmath8 bits of space , and elmasry et al .",
    "@xcite improved the time to @xmath53 time still using @xmath8 bits of space .",
    "we show the following : * * in section [ dfs1 ] , we first show that , we can perform dfs in a directed or undirected graph in linear time using @xmath7 bits .",
    "this , for example , improves the runtime of the earlier known results for sparse graphs ( where @xmath6 is @xmath8 ) while still using the same asymptotic space .",
    "building on top of this dfs algorithm and other observations , we show how to efficiently compute the _ chain decomposition _ of a connected undirected graph .",
    "this lets us perform a variety of applications of dfs ( including testing biconnectivity and @xmath2-edge connectivity , finding cut vertices and edges among others ) within the same time and space bound .",
    "our algorithms for these applications improve the space requirement ( for sparse graphs ) of all the previous algorithms from @xmath54 bits to @xmath7 bits , preserving the same linear runtime . * * in section [ simp - bicon ] , for all the problems mentioned above and dealt in section [ dfs1 ] , we improve the space even further to @xmath55 bits keeping the same @xmath7 running time . the space used by these algorithms , for some ranges of @xmath6 ( say @xmath56 for some constant @xmath57 ) , is even better than that of the recent work by kammer et al .",
    "@xcite , that computes cut vertices using @xmath58 bits .      in computational complexity theory ,",
    "the constant work - space model is represented by the complexity class l or dlogspace  @xcite .",
    "there are several important algorithmic results for this class , most celebrated being reingold s method for checking reachability between two vertices in an undirected graph @xcite .",
    "barnes et al .",
    "@xcite gave a sub - linear space algorithm for directed graph reachability .",
    "recent work has focused on space requirement in special classes of graphs like planar and h - minor free graphs  @xcite .",
    "generally these algorithms have very large polynomial running time . in the algorithms literature , where the focus is also on improving time",
    ", a huge amount of research has been devoted to memory constrained algorithms , even as early as in the 1980s @xcite .",
    "early work on this focused on the selection problem  @xcite , but more recently on computational geometry problems  @xcite and graph algorithms @xcite .",
    "regarding the data structure we develop to support _ findany _ operation , elmasry et al .",
    "[ lemma 2.1 ,  @xcite ] state a data structure ( without proof ) that supports all the operations i.e. , insert , search , delete and findany ( they call it @xmath59 ) among others , in constant time . but their data structure takes @xmath8 bits of space where the constant in the @xmath60 term is not explicitly stated . since our initial version of the paper , hagerup and kammer @xcite have independently reported a structure with @xmath61 . though their lower order ( the little `` oh '' ) term @xmath62 is better than ours which is @xmath63 , we believe that our structure is a lot simpler and supports a fewer set of operations , yet sufficient for the space efficient bfs implementation .",
    "furthermore , we do provide a few other applications of our structure also .",
    "recently , poyias et al .",
    "@xcite considered the problem of compactly representing a rewritable array of bit - strings , and to achieve that they used our findany structure as the main building block in their algorithms .",
    "brodal et al .",
    "@xcite considered a version of the _ findany _ operation where the goal was to find any element of the set and return its rank ( the number of elements smaller than that ) .",
    "for that they gave a non - constant lower bound , though they do nt assume that the elements are from a bounded universe .",
    "they give a randomized data structure that takes a constant amortized time per operation .",
    "however their main objective was to provide time tradeoffs between operations supported by the data structure and they did nt worry about space considerations . we note that this operation and their setup is different from the _ findany _ query we support .",
    "several models of computation come close to _ read - only random - access _ model - the model we focus on this paper .",
    "a single thread common to all of them is that access to the input tape is restricted in some way . in the _",
    "multi - pass streaming _",
    "model @xcite the input is kept in a read - only sequentially - accessible media , and an algorithm tries to optimize on the number of passes it makes over the input . in the _ semi - streaming _ model @xcite , the elements ( or edges if the input is graph ) are revealed one by one and extra space allowed to the algorithm is @xmath64 bits .",
    "observe that , it is not possible to store the whole graph if it is dense .",
    "the efficiency of an algorithm in this model is measured by the space it uses , the time it requires to process each edge and the number of passes it makes over the stream . in the _ in - place _",
    "model @xcite , one is allowed a constant number of additional variables , but it is possible to rearrange ( and sometimes even modify ) the input values . in the _",
    "restore _ model @xcite , one is allowed to modify the input but it has to be brought back to its starting configuration afterwards .",
    "[ [ representing - a - vector ] ] representing a vector + + + + + + + + + + + + + + + + + + + + +    we will use the following theorem from @xcite :    [ nlgc ] @xcite on a word ram , one can represent a vector @xmath65 $ ] of elements from a finite alphabet @xmath66 using @xmath67 bits precomputed word constants , thus the second order @xmath68 bits . ] , such that any element of the vector can be read or written in constant time .",
    "[ [ rank - select ] ] rank - select + + + + + + + + + + +    we also make use of the following theorem .",
    "@xcite [ staticbit ] we can store a bitstring @xmath60 of length @xmath5 with additional @xmath69 bits such that rank and select operations ( defined below ) can be supported in @xmath70 time .",
    "such a structure can also be constructed from the given bitstring in @xmath8 time .    here",
    "the rank and select operations are defined as following :    * @xmath71 = number of occurrences of @xmath72 in @xmath73 $ ] , for @xmath74 ; * @xmath75 = position in @xmath60 of the @xmath21-th occurrence of @xmath72 .",
    "[ [ sec : terms ] ] graph theoretic terminology + + + + + + + + + + + + + + + + + + + + + + + + + + +    here we collect all the necessary graph theoretic definitions that will be used throughout the paper . in an undirected graph @xmath4 , a cut vertex is a vertex @xmath31 that when removed ( along with its incident edges ) from a graph creates more ( than what was there before ) components in the graph .",
    "a ( connected ) graph with at least three vertices is biconnected ( also called @xmath2-connected or @xmath2-vertex connected in the literature ) if and only if it has no cut vertex .",
    "a biconnected component is a maximal biconnected subgraph .",
    "these components are attached to each other at cut vertices .",
    "similarly in an undirected graph @xmath4 , a bridge is an edge that when removed ( without removing the vertices ) from a graph creates more components than previously in the graph . a (",
    "connected ) graph with at least two vertices is @xmath2-edge - connected if and only if it has no bridge .",
    "a @xmath2-edge connected component is a maximal @xmath2-edge connected subgraph .",
    "a graph has a degeneracy @xmath23 if every induced subgraph of the graph has a vertex with degree at most @xmath23 .",
    "an ordering @xmath49 of the vertices in such a graph is a degenerate order if for any @xmath21 , the @xmath21-th vertex has degree at most @xmath23 among vertices @xmath50 . a topological sort or topological ordering of a directed acyclic graph",
    "is a linear ordering of its vertices such that for every directed edge @xmath76 from vertex @xmath30 to vertex @xmath31 , @xmath30 comes before @xmath31 in the ordering .",
    "a minimum spanning tree ( mst ) or minimum weight spanning tree is a subset of the edges of a connected , edge - weighted undirected graph that connects all the vertices together , without any cycles and with the minimum possible total edge weight .",
    "that is , it is a spanning tree whose sum of edge weights is as small as possible .",
    "we consider the data structure problem of maintaining a set @xmath10 of elements from @xmath77 to support the following operations in constant time .    *",
    "_ insert ( @xmath21 ) _ : insert element @xmath21 into the set . * _ search ( @xmath21 ) _ : determine whether the element @xmath21 is in the set .",
    "* _ delete ( @xmath21 ) _ : delete the element @xmath21 from the set if it exists in the set . *",
    "_ findany _ : find any element from the set and return its value . if the set is empty , return a nil value .",
    "already there exist several solutions for this problem in the data structure literature , but not with the exact time and space bound which we are looking for . in what follows we mention some of these results .",
    "it is trivial to support the first three operations in constant time using @xmath5 bits of a characteristic vector .",
    "we could support the _ findany _ operation by keeping track of one of the elements , but once that element is deleted , we need to find another element to answer a subsequent _ findany _ query . this might take @xmath8 time in the worst case .",
    "but this is easy to support in constant time if we have the elements stored in a linked list which takes @xmath9 bits .",
    "one could also use the dynamic rank - select structure  @xcite where insert , delete and findany operations take @xmath78 time , and search takes @xmath70 time .",
    "another approach would be to the classical balanced binary search tree to support these operations .",
    "this can be slightly improved further by using the van emde boas tree .",
    "one can improve upon the results for balanced binary search trees and van emde boas trees by using the ` dynamic range report ' structure of mortensen et al .",
    "@xcite , though it still lacks the time and space bound we want here .",
    "our main result in this section is that the _ findany _ operation , along with the other three , can be supported in constant time using @xmath69 additional bits .",
    "we provide a comparison of our findany data structure with previous results in the table below .    [ cols=\"<,^,^,^,^,^,^\",options=\"header \" , ]     [ maindsbinary ] a set of elements from a universe of size @xmath5 can be maintained using @xmath79 bits to support _",
    "insert , delete , search and findany _ operations in constant time .",
    "we can also enumerate all elements of the set ( in no particular order ) in @xmath12 time where @xmath13 is the number of elements in the set .",
    "the data structure can be initialized in @xmath70 time .",
    "let @xmath10 be the characteristic bit vector of the set having @xmath5 bits .",
    "we follow a two level blocking structure of @xmath10 , as in the case of succinct structures supporting rank and select  @xcite . however , as @xmath10 is ` dynamic ' ( in that bit values can change due to insert and delete ) , we need more auxiliary information . in the discussion below , sometimes we omit floors and ceilings to keep the discussion simple , but they should be clear from the context .",
    "we divide the bit vector @xmath10 into @xmath80 blocks of consecutive @xmath81 bits each , and divide each such block into up to @xmath82 sub - blocks of size @xmath83 bits each .",
    "we call a block ( or sub - block ) non - empty if it contains at least a @xmath48 .",
    "we maintain the non - empty blocks , and the non - empty sub - blocks within each block in linked lists ( not necessarily in order ) . within a sub - block ,",
    "we find the first @xmath48 or the next @xmath48 by a table look up .",
    "we provide the specific details below .",
    "first , we maintain an array _ number _ indicating the number of @xmath48s in each block , i.e. , @xmath84 $ ] gives the number of @xmath48s in the @xmath21-th block of @xmath10 .",
    "it takes @xmath85 bits as each block can have at most @xmath81 elements of the given set",
    ". then we maintain a queue ( say implemented in a space efficient resizable array  @xcite ) _ block - queue _ having the block numbers that have a @xmath48 bit , and new block numbers are added to the list as and when new blocks get @xmath48 .",
    "it can have at most @xmath80 elements and so has @xmath86 indices taking totally @xmath62 bits .",
    "in addition , every element in _ block - queue _ has a pointer to another queue of sub - block numbers of that block that have an element of @xmath10 .",
    "each such queue has at most @xmath82 elements each of size at most @xmath87 bits each ( for the sub - block index ) .",
    "thus the queue _ block - queue _ along with the queues of sub - block indices takes @xmath63 bits .",
    "we also maintain an array , _ block - array _",
    ", of size @xmath80 where _ block - array@xmath88 $ ] _ points to the position of block @xmath21 in _ block - queue _ if it exists , and is a nil pointer otherwise and array , _ sub - block - array _ , of size @xmath89 where _ sub - block - array@xmath88 $ ] _ points to the position of the subblock @xmath21 in its block s queue if its block was present in _ block - queue _ , and is a nil pointer otherwise .",
    "so , _ block - array _ takes @xmath90 bits and _ sub - block - array",
    "_ takes @xmath91 bits .",
    "we also maintain a global table @xmath92 precomputed that stores for every bitstring of size @xmath83 , and a position @xmath21 , the position of the first @xmath48 bit after the @xmath21-th position .",
    "if there is no ` next @xmath48 ' , then the answer stored is @xmath93 indicating a nil value .",
    "the table takes @xmath94 bits .",
    "this concludes the description of the data structure that takes @xmath95 bits .",
    "see figure @xmath48 for an illustration .",
    "[ findany_ds_pic ]        now we explain how to support each of the required operations . membership is the easiest : just look at the @xmath21-th bit of @xmath10 and answer accordingly . in what follows , when we say the ` corresponding bit or pointer ' , we mean the bit or the pointer corresponding to the block or the sub - block corresponding to an element , which can be determined in constant time from the index of the element . to insert an element @xmath21 ,",
    "first determine from the table @xmath92 , whether there is a @xmath48 in the corresponding sub - block ( before the element is inserted ) , set the @xmath21-th bit of @xmath10 to @xmath48 , and increment the corresponding value in _",
    "number_. if the corresponding pointer of _ block - array _ was nil , then insert the block index to _ block - queue _ at the end of the queue , and add the sub - block corresponding to the @xmath21-th bit into the queue corresponding to the index of the block in _ block - queue _ , and update the corresponding pointers of _ block - array _ and _ sub - block - array_. if the corresponding bit of _ block - array _ was not nil ( the big block already had an element ) , and if the sub - block did not have an element before ( as determined using @xmath92 ) , then find the position of the block index in _ block - queue _ from _ block - array _ , and insert the sub - block index into the queue of that block at the end of the queue . update the corresponding pointer of _ sub - block - array_.    to support the delete operation , set the @xmath21-th bit of @xmath10 to @xmath22 ( if it was already @xmath22 , then there is nothing more to do ) and decrement the corresponding number in _ number_. determine from the table @xmath92 if the sub - block of @xmath21 has a @xmath48 ( after the @xmath21-th bit has been set to @xmath22 ) .",
    "if not , then find the index of the sub - block from the arrays _ block - array _ and _ sub - block - array _ and delete that index from the block s queue from _ block - queue_. if the corresponding number in _ number _ remains more than @xmath22 , then there is nothing more to do .",
    "if the number becomes @xmath22 , then find the corresponding block index in _ block - queue _ from the array _ block - array _ , and delete that block ( along with its queue that will have only one sub - block ) from _ block - queue_. update the pointers in _ block - array _ and _ sub - block - array _ respectively . as we do nt maintain any order in the queues in _ block - queue",
    "_ , if we delete an intermediate element from the queue , we can always replace that element by the last element in the queue updating the pointers appropriately .",
    "to support the findany operation , we go to the tail of the queue _ block - queue _ , if it is nil , we report that there is no element in the set , and return the nil value .",
    "otherwise , go to the block at the tail of _ block - queue _ , and get the first ( non - empty ) sub - block number from the queue , and find the first element in the sub - block from the table @xmath92 , and return the index of the element .    to enumerate the elements of the set",
    ", we traverse the list _ block - queue _ and the queues of each element of _ block - queue _ , and for each sub - block in the queues , we find the next @xmath48 in constant time using the table @xmath92 and output the index .",
    "to enable initialization in @xmath70 time , with each entry of the block ( sub - block ) queue , we also store the block index corresponding to that entry  analagous to the `` on - the - fly array initialization '' technique of [ exercise 2.12 of  @xcite , section iii.8.1 of  @xcite ,  @xcite ] , for example . the ( sub ) block index stored with the entries in the ( sub ) block queue act as the `` back pointers '' to the ( sub ) block - array . also , instead of storing the precomputed tables to compute the ` first 1 bit after the @xmath21-th position ' operation , we can support the operation using @xmath70 word operations  @xcite .",
    "we generalize to maintain a collection of more than one disjoint subsets of the given universe to support the insert , delete , membership and findany operations . in this case ,",
    "insert , delete and findany operations should come with a set index ( to be searched , inserted or deleted ) .",
    "[ mainds ] a collection of @xmath57 disjoint sets that partition the universe of size @xmath5 can be maintained using @xmath96 bits to support _",
    "insert , delete , search and findany _ operations in constant time .",
    "we can also enumerate all elements of any given set ( in no particular order ) in @xmath12 time where @xmath13 is the number of elements in the set .",
    "the data structure can be initialized in @xmath70 time .",
    "the higher order term is for representing the ( generalized ) characteristic vector @xmath10 where @xmath97 $ ] is set to the number ( index ) of the set where the element is present . from theorem  [ nlgc ] , @xmath10 can be represented using @xmath96 bits so that the @xmath21-th value can be retrieved or set in constant time .",
    "the rest of the data structures and the algorithms are as in the proof of theorem  [ maindsbinary ] ( hence the extra @xmath69 bits ) , we have a copy of such structures for each of the @xmath57 sets .",
    "we explain how breadth first search ( bfs ) can be performed in a space efficient manner using the data structure of theorem [ mainds ] .",
    "our goal is to output the vertices of the graph in the bfs order .",
    "the algorithm is similar in spirit to the @xmath8 space , @xmath7 algorithm of @xcite , ours is perhaps simpler , we explain the details for completeness . we start as in the textbook bfs by coloring all vertices white .",
    "the algorithm grows the search starting at a vertex @xmath98 , making it grey and adding it to a queue .",
    "then the algorithm repeatedly removes the first element of the queue , and adds all its white neighbors at the end of the queue ( coloring them grey ) , coloring the element black after removing it from the queue . as the queue can store up to @xmath8 elements , the space for the queue can be @xmath9 bits . to reduce the space to @xmath8 bits , we crucially observe the following two properties of bfs :    * elements in the queue are only from two consecutive levels of the bfs tree .",
    "* elements belonging to the same level can be processed in any order , but elements of the lower level must be processed before processing elements of the higher level .    the algorithm maintains four colors : white , grey1 , grey2 and black , and represents the vertices with each of these colors as sets @xmath99 and @xmath100 respectively using the data structure of theorem  [ mainds ] .",
    "it starts with initializing @xmath101 ( grey1 ) to @xmath98 , @xmath102 and @xmath100 as empty sets and @xmath103 to contain all other vertices .",
    "then it processes the elements in each set @xmath101 and @xmath102 switching between the two until both sets are empty .",
    "as we process an element from @xmath104 , we add its white neighbor to @xmath105 and delete it from @xmath104 and add it to @xmath100 . when @xmath101 and @xmath102 become empty , we scan the @xmath103 array to find the next white vertex and start a fresh bfs again from that vertex . as insert , delete , membership and findany operations take constant time , and we are maintaining four sets ,",
    "we have from theorem  [ mainds ] ,    [ bfs_theorem ] given a directed or undirected graph @xmath4 , its vertices can be output in a bfs order starting at a vertex using @xmath106 bits in @xmath7 time .    note that , we do nt need to build the findany structure on top of @xmath100 and @xmath103 i.e. , they can be implemented as plain bitmaps .",
    "the findany structures are only required on sets @xmath101 and @xmath102 respectively to efficiently find grey vertices .    in what follows ,",
    "we slightly deviate from the theme of the paper and show that we can improve the space further for performing bfs if we are willing to settle for more than a linear amount of time .",
    "we provide the algorithms below .",
    "there are several ways to implement bfs using just two of the three colors used in the standard bfs @xcite , but the space restriction , hence our inability to maintain the standard queue , provides challenges . for example , suppose we change a grey vertex to white after processing , and use two colors to distinguish the grey vertices in different levels .",
    "then we have the challenge of identifying those white vertices who have been processed ( and hence black in the standard bfs ) and those yet to be processed ( white ) . for this",
    ", we make the following observation .    *",
    "a vertex @xmath31 is black if and only if there exists a path consisting of all white vertices from the root @xmath98 to @xmath31 ( without going through vertices in the sets grey1 or grey2 i.e. without encountering any grey vertices ) .",
    "to check whether such a path exists we can use the reachabilty algorithm of reingold  @xcite or barnes et al .",
    "@xcite for an undirected or directed graph respectively on the white vertices ( similar idea was used by asano et al .",
    "@xcite in one of their space efficient dfs implementations ) .",
    "thus we could manage with just @xmath108 colors , hence using theorem  [ nlgc ] , and counting the space required by the reachabilty routine , we can get a bfs implementation using @xmath109 bits albeit using a large polynomial ( as needed by reingold s or barnes et al.s implementation ) time .",
    "thus we obtain the following result ,    [ bfs2 ] given a directed or undirected graph @xmath4 , its vertices can be output in a bfs order starting at a vertex in polynomial time using @xmath109 bits of space .    observe that the main bottleneck in the time complexity of the previous algorithm comes from the fact that we are using reingold s algorithm  @xcite or barnes et al.s algorithm  @xcite as subroutine to distinguish whether a vertex is black or white . to improve the runtime further ( from a large polynomial ) , we give another @xmath108 color implementation overloading grey and black vertices , i.e. , we use one color to represent grey and black vertices .",
    "grey vertices remain grey even after processing .",
    "this poses the challenge of separating the grey vertices from the black ones correctly before exploring .",
    "we will have three colors , one for the white unexplored vertices and two colors for those explored including those currently being explored .",
    "the two colors indicate the parity of the level ( the distance from the starting vertex ) of the explored vertices . thus the starting vertex @xmath98 is colored @xmath22 to mark that its distance from @xmath98 is of even length and every other vertex is colored @xmath2 to mark them as unexplored ( or white ) .",
    "we simply have these values stored in the representation of theorem  [ nlgc ] using @xmath110 bits and we call this as the color array .",
    "the algorithm repeatedly scans this array and in the @xmath21-th scan , it changes all the @xmath2 neighbors of @xmath111 to @xmath112 .",
    "i.e. , in one scan of the array , the algorithm changes all the @xmath2-neighbors of all the @xmath22 vertices to @xmath48 , and in the next , it changes all the @xmath2-neighbors of all of the @xmath48 vertices to @xmath22 .",
    "the exploration ( of the connected component ) stops when in two consecutive scans of the list , no @xmath2 neighbor is found .",
    "note that for those vertices which would have been colored black in the normal bfs , none of its neighbors will be marked @xmath2 , and so the algorithm will automatically figure them as black .",
    "the running time of @xmath34 follows because each scan of the list takes @xmath113 time ( to go over neighbors of vertices with one color , some of which could be black ) and at most @xmath114 scans of the list are performed as in each scan ( except the last two ) , the color of at least one vertex marked @xmath2 is changed .",
    "thus we have the following theorem ,    [ bfs2 ] given a directed or undirected graph , its vertices can be output in a bfs order starting at a vertex using @xmath110 bits and in @xmath34 time .    the @xmath113 time for each scan of the previous algorithm is because while looking for vertices labelled @xmath22 that are supposed to be ` grey ' , we might cross over spurious vertices labelled @xmath22 that are ` black ' ( in the normal bfs coloring ) . to improve the runtime further , we maintain two queues @xmath115 and @xmath116 each storing up to @xmath80 values to find the grey @xmath22 and grey @xmath48 vertices quickly , in addition to the color array that stores the values @xmath22 , @xmath48 or @xmath2 .",
    "we also store two boolean variables , _ overflow - q0 , overflow - q1 _ , initialized to @xmath22 and to be set to @xmath48 when more elements are to be added to these queues ( but they do nt have room ) .",
    "now the algorithm proceeds in a similar fashion as the previous algorithm except that , along with marking corresponding vertices @xmath22 or @xmath48 in the color array , we also insert them into the appropriate queues .",
    "i.e. when we expand vertices from @xmath115 ( @xmath116 ) , we insert their ( white ) neighbors colored @xmath2 to @xmath116 ( @xmath115 respectively ) apart from setting their color entries to @xmath48 ( @xmath22 respectively ) . due to the space restriction of these queues ,",
    "it is not always possible to accomodate all the vertices of some level during the execution of bfs .",
    "so , when we run out of space in any of these queues , we continue to make the changes ( i.e. @xmath2 to @xmath48 or @xmath2 to @xmath22 ) in the color array directly without adding those vertices to the queue , and we also set the corresponding overflow bit .",
    "now instead of scanning the color array for vertices labelled @xmath22 or @xmath48 , we traverse the appropriate queues spending time proportional to the sum of the degree of the vertices in the level .",
    "if the overflow bit in the corresponding queue is @xmath22 , then we simply move on to the next queue and continue .",
    "when the overflow bit of a queue is set to @xmath48 , then we switch to our previous algorithm and scan the array appropriately changing the colors of their white neighbors and adding them to the appropriate queue if possible .",
    "it is easy to see that this method correctly explores all the vertices of the graph .",
    "the color array uses @xmath110 bits of space . and , for other structures , @xmath115 , @xmath116 and other variables , we need at most @xmath62 bits .",
    "so , overall the space requirement is @xmath109 bits . to analyse the runtime , notice that as long as the overflow bit of a queue is @xmath22 , we spend time proportional the number of neighbors of the vertices in that level , and we spend @xmath113 time otherwise .",
    "when an overflow bit is @xmath48 , then the number of nodes in the level is at least @xmath80 and this can not happen for more than @xmath81 levels where we spend @xmath113 time each .",
    "hence , the total runtime is @xmath117 .",
    "[ bfs4 ] given a directed or undirected graph , its vertices can be output in a bfs order starting at a vertex using @xmath109 bits of space and in @xmath118 time .",
    "* remark : * we can slightly optimize the previous algorithm by observing the fact that a vertex @xmath31 belongs to an overflowed level then @xmath31 is expanded twice i.e. , first time when the algorithm was expanding vertices from the queue and deleting them . and , secondly , as the overflow bit is set , the algorithm switches to our previous algorithm of theorem [ bfs2 ] and scan the color array appropriately changing the colors of their white neighbors and adding them to the appropriate queue if possible",
    ". we can avoid this double expansion by checking the overflow bit first and if this bit is set , instead of taking vertices out of the corresponding queue and expanding , the algorithm can directly start working with the color array .",
    "we can still correctly retrieve all the vertices by checking the same condition .",
    "this ensures that all the vertices which belong to an overflowed level wo nt be expanded twice .",
    "note that by making the sizes of the two queues to @xmath119 for any ( slow growing ) function @xmath17 , the space required for the queues will be @xmath120 bits and the running time will be @xmath36 .    [ bfs5 ] given a directed or undirected graph , its vertices can be output in a bfs order starting at a vertex using @xmath121 bits and in @xmath122 time where @xmath17 is any extremely slow - growing function of @xmath5 .    since the appearance of the conference version of our paper @xcite , hagerup et al .",
    "@xcite presented an implementation of bfs taking @xmath123 bits of space and the optimal @xmath7 time , thus improving the result of our theorem [ bfs5 ] .",
    "but , note that , in our algorithm of theorem [ bfs2 ] , we improved the space ( in the second order ) even further than what is needed in their algorithm  @xcite albeit with degradation in time",
    ". we do not know whether we can reduce the space further ( to possibly @xmath61 bits ) while still maintaining the runtime to @xmath124 for some constant @xmath57 or even @xmath34 .",
    "we leave this as an open problem .",
    "however , in the next section we provide such an algorithm for mst .      in this section ,",
    "we give a space efficient implementation of the prim s algorithm  @xcite to find a minimum spanning tree . here",
    "we are given a weight function @xmath125 .",
    "we also assume that the weights of non - edges are @xmath126 and that the weights can be represented using @xmath1 bits . in particular , we show the following ,    [ mstproof ] a minimum spanning forest of a given undirected weighted graph , where the weights of any edge can be represented in @xmath1 bits , can be found using @xmath127 bits and in @xmath16 time , for any function @xmath17 such that @xmath26 .",
    "our algorithm is inspired by the mst algorithm of @xcite , but we work out the constants carefully .",
    "prim s algorithm starts with initializing a set @xmath10 with a vertex @xmath98 .",
    "for every vertex @xmath31 not in @xmath10 , it finds and maintains @xmath128 = \\min \\ { w(v , x ) : x \\in s\\}$ ] and @xmath129=x$ ] where @xmath130 is the minimum among @xmath131 .",
    "then it repeatedly deletes the vertex with the smallest @xmath23 value from @xmath132 adding it to @xmath10 .",
    "then the @xmath23 values are updated by looking at the neighbors of the newly added vertex .    the space for @xmath23 values can take up to @xmath9 bits .",
    "to reduce the space to @xmath8 bits , we find and keep , in @xmath8 time , the set @xmath133 of the smallest @xmath134 values among the @xmath23 values of the elements of @xmath135 in a binary heap .",
    "this takes @xmath120 bits and @xmath8 time .",
    "we maintain the set @xmath10 in a bit vector taking @xmath5 bits .",
    "we maintain the indices of @xmath133 in a balanced binary search tree , and each node ( index @xmath31 ) has a pointer to its position in the heap of the @xmath23 values , and also stores the index @xmath129 $ ] .",
    "thus we can think of @xmath133 as consisting of triples @xmath136 , \\pi[v])$ ] where @xmath128 $ ] is actually a pointer to @xmath128 $ ] in the heap .",
    "the storage for @xmath133 takes @xmath120 bits .",
    "we also find and store the max value of @xmath133 in a variable @xmath137 that also has the vertex label that achieves the maximum .",
    "now we execute prim s algorithm by repeatedly deleting elements only from @xmath133 and updating ( decreasing ) values in @xmath133 until @xmath133 becomes empty . in particular , while updating the values we check if the new value is larger than the variable @xmath137 . in such cases",
    ", we do nt do anything . otherwise , we insert the new value in @xmath133 and delete the current vertex realizing the maximum value and we proceed further till @xmath133 becomes empty .",
    "then ( for @xmath138 times ) we find the next smallest @xmath139 values from @xmath140 and continue the process .",
    "finding the @xmath23 values of every element in @xmath141 requires @xmath113 time ( for finding the minimum among all edges incident with vertices in @xmath10 ) , and finding the smallest @xmath142 values among them take @xmath8 time .",
    "these steps are repeated @xmath143 times resulting in the overall runtime of @xmath36 . in the heap , @xmath144 deletemins and up to @xmath6",
    "decrease key operations are executed which take @xmath145 time by using a binary heap .",
    "note that more sophisticated ( for example , fibonacci heap ) implementations are unnecessary as the other operations dominate the running time .",
    "in what follows we use our findany data structure of section  [ datastructure ] to develop a data structure as below .",
    "[ decrementds ] let @xmath19 be a sequence of non - negative integers , and let @xmath146 .",
    "then the sequence can be represented using at most @xmath147 bits such that we can determine whether the @xmath21-th element of the sequence is @xmath22 and decrement it otherwise , in constant time .",
    "our first attempt is to encode each integer in unary , delimited by a separate bit , to take @xmath148 bits .",
    "a select structure , as in theorem  [ staticbit ] , can help us access the corresponding elements .",
    "however , decrementing them involves changing this bitstring and so we need a dynamic version of theorem  [ staticbit ] that has a @xmath78 runtime for each of the operations  @xcite .",
    "now we show how to use our findany structure of theorem  [ mainds ] to obtain a linear time algorithm .",
    "we maintain conceptually separate findany structures for each @xmath45 using @xmath149 bits .",
    "each of them stores a subset of @xmath150 and is initialized to the full universe set .",
    "the total space is @xmath151 bits .",
    "the findany structures of all the integers are concatenated into a single array of bits , separated by a delimiter ( say the symbol @xmath2 ) .",
    "and we build a @xmath152 structure for the delimiter ( @xmath2 ) in @xmath7 time and using @xmath153 bits of extra space using a generalization of theorem  [ staticbit ] for 3 symbols ( see , for example @xcite ) so that we can identify the findany structure of vertex @xmath21 in constant time by navigating to the @xmath21-th delimiter symbol .",
    "note that though this bitstring will change in the course of an operation , the delimiter symbols are nt modified , and the length of the string does nt change and so a static @xmath152 structure suffices . now decrementing @xmath45 amounts to performing the findany operation on @xmath45 s structure ( that actually tests whether @xmath154 and deleting the element if any , that is output from the findany operation .    using the data structure we just developed ,",
    "we show the following theorems .",
    "[ top3 ] given a directed acyclic graph @xmath4 , its vertices can be output in topologically sorted order using @xmath7 time using @xmath155 bits of space .",
    "the algorithm can also detect if @xmath4 is not acyclic .",
    "a standard algorithm repeatedly outputs a vertex with indegree zero and deletes that vertex along with its outgoing edges , until there are no more vertices . to implement this ,",
    "we maintain first the set @xmath156 of indegree @xmath22 vertices in the datastructure of theorem  [ maindsbinary ] to support findany operation in constant time .",
    "this takes @xmath7 time and @xmath11 bits .",
    "we also represent the indegree sequence of the vertices using the data structure of theorem  [ decrementds ] .",
    "the algorithm repeatedly finds any element from @xmath156 , outputs and deletes it from @xmath156 .",
    "then it decrements the indegree of its out - neighbors , and includes them in @xmath156 if any of them has become @xmath22 ( that can be determined by another findany structure ) in the process .",
    "if @xmath156 becomes empty even before all elements are output ( that can be checked using a counter or a bit vector ) , then at some intermediate stage of the algorithm , we did not encounter a vertex with indegree zero which means that the graph is not acyclic .",
    "an undirected graph is @xmath23-degenerate if every induced subgraph of the graph has a vertex with degree at most @xmath23 .",
    "for example , a graph with degree at most @xmath23 is @xmath23-degenerate .",
    "a planar graph is @xmath157-degenerate as every planar graph has a vertex with degree at most @xmath157 .",
    "the degeneracy order of a @xmath23-degenerate graph is an ordering @xmath49 of the vertices such that @xmath158 has degree at most @xmath23 among @xmath50 .",
    "we show the following using our data structure developed in this section .",
    "[ degenerate ] given a @xmath23-degenerate graph @xmath4 , its vertices can be output in @xmath23-degenerate order using @xmath159 bits and @xmath7 time .",
    "the algorithm can also detect if the given graph is not @xmath23-degenerate .",
    "as in the topological sort algorithm , we maintain the set @xmath156 of vertices whose degree in the entire graph is at most @xmath23 , using our findany data structure .",
    "this takes @xmath7 time and @xmath11 bits .",
    "then we represent the degree sequence of the vertices using the data structure of theorem  [ decrementds ] except we subtract @xmath23 from each of them .",
    "i.e. @xmath160 where @xmath161 is the degree of the @xmath21-th vertex .",
    "the algorithm repeatedly finds any element from @xmath156 , outputs and deletes it from @xmath156 .",
    "then it decrements the degree of its neighbors , and includes them in @xmath156 if any of them has become @xmath22 .",
    "if @xmath156 becomes empty even before all elements are output ( that can be checked using a counter or a bit vector ) , then at some intermediate stage of the algorithm , we did not encounter a vertex with degree less than @xmath23 , which means that the graph is not @xmath23-degenerate .",
    "note that , for all the algorithms discussed in the last two sections i.e. , section [ bfs ] and [ topo ] respectively , we can assume that the input graph is represented as the standard _ adjacency list _",
    "@xcite instead of the more powerful adjacency list along with cross pointers representation .",
    "the classical and standard implementation of dfs using a stack and color array takes @xmath7 time and @xmath9 bits of space . improving on this ,",
    "recently elmasry et al .",
    "@xcite showed the following ,    [ general_dfs ] a dfs traversal of a directed or undirected graph @xmath4 with @xmath5 vertices and @xmath6 edges can be performed using @xmath46 bits of space and @xmath7 time .    in this section ,",
    "we start by improving upon the results of theorem  [ general_dfs ] of elmasry et al .",
    "@xcite and theorem @xmath157 of asano et al .",
    "@xcite by showing an @xmath8-bit dfs traversal method for sparse graphs that runs in linear time . using this dfs as backbone",
    ", we provide a space efficient implementation for computing several other useful properties of an undirected graph .      in what follows",
    "we describe how to perform dfs in @xmath162 time using @xmath162 bits of space .",
    "note that , this is better ( in terms of time ) than both the previous solutions for sparse graphs ( when @xmath163 ) with same space bounds .",
    "the class of sparse graphs includes a large class of graphs including planar graphs , bounded genus , bounded treewidth , bounded degree graphs , and h - minor - free graphs . these are also the majority of the graph classes which arise in practice , and as our algorithm is simple with no heavy data structures used , we believe that an implementation of our algorithm will work very fast in practice for these graphs . recall that , our input graphs @xmath164 are represented using the standard adjacency array along with cross pointers .",
    "we describe our algorithm for directed graphs , and mention the changes required for undirected graphs .",
    "central to our algorithm is an encoding of the out - degrees of the vertices in unary .",
    "let @xmath165 be the vertex set .",
    "the unary degree sequence encoding @xmath60 of the directed graph @xmath4 has @xmath5 @xmath22s to represent the @xmath5 vertices and each @xmath22 is followed by a number of @xmath48s equal to the out - degree of that vertex . moreover ,",
    "if @xmath23 is the degree of vertex @xmath158 , then @xmath23 @xmath48s following the @xmath21-th @xmath22 in the @xmath60 array corresponds to @xmath23 out - neighbors of @xmath158 ( or equivalently the edges from @xmath158 to the @xmath23 out - neighbors of @xmath158 ) in the same order as in the out - adjacency array of @xmath158 .",
    "clearly @xmath60 uses @xmath166 bits and can be obtained from the out - neighbors of each vertex in @xmath7 time .",
    "we use another bit string @xmath167 of the same length where every bit is initialized to @xmath22 .",
    "the array @xmath167 will be used to mark the tree edges of the dfs as we build the dfs tree , and will be used to backtrack when the dfs has finished exploring a vertex .",
    "the bits in @xmath167 are in one - to - one correspondence with bits in @xmath60 .",
    "if @xmath168 is an edge in the dfs tree where @xmath158 is the parent of @xmath169 , and suppose @xmath13 is the index of the edge @xmath168 in @xmath60 , then the corrsponding location in the @xmath167 array is marked as @xmath48 during dfs .",
    "thus once dfs finishes traversing the whole graph , the number of ones in the @xmath167 array is exactly the number of tree edges .",
    "we also store another array , say @xmath170 , having entries from \\{_white , gray , black } _ with the usual meaning i.e. , each vertex @xmath31 remains white until it is visited , is colored gray when dfs visits @xmath31 for the first time , and is colored black when its out - adjacency array has been checked completely .",
    "we can represent @xmath170 using lemma [ nlgc ] in @xmath109 bits so that individual entries can be accessed or modified in constant time .",
    "the bitvector @xmath60 is represented using the static rank - select data structure of theorem  [ staticbit ] that uses additional @xmath153 bits .",
    "so overall we need @xmath171 bits to represent the arrays @xmath172 and @xmath170 .",
    "suppose @xmath169 is a child of @xmath158 in the final dfs tree .",
    "we can think of the dfs procedure as performing the following two steps repeatedly until all the vertices are explored .",
    "first step takes place when dfs discovers a vertex @xmath169 for the first time , and as a result @xmath169 s color changes to gray from white .",
    "we call this phase as forward step",
    ". when dfs completes exploring @xmath169 i.e. the subtree rooted at @xmath169 in the dfs tree , it performs two tasks subsequently .",
    "first , it backtracks to its parent @xmath158 , and then finds in @xmath158 s list the next white neighbor to explore .",
    "the latter part is almost similar to the forward step described before .",
    "we call the first part alone as backtrack step . in",
    "what follows , we describe how to implement each step in detail .",
    "we start our dfs with the starting vertex , say @xmath173 , changing its color to gray in the color array @xmath170 .",
    "then , as in the usual dfs algorithm , we scan the out - adjacency list of @xmath173 , and find the first white neighbor , say @xmath31 , to make it gray .",
    "when the edge @xmath174 is added to the dfs tree , we mark the position corresponding to the edge @xmath174 in @xmath167 to  @xmath48 operation in theorem  [ staticbit ] . ] .",
    "we continue the process with the new vertex making it gray until we encounter a vertex @xmath175 that has no white out - neighbors . at this point ,",
    "we will color the vertex @xmath175 black , and we need to backtrack .    to find the vertex to backtrack , we do the following .",
    "we go to @xmath175 s in - neighbor list to find a gray vertex which is its parent . for each gray vertex @xmath176 in @xmath175 s in - neighbor list",
    ", we follow the cross pointers to reach @xmath175 in @xmath176 s out - adjacency list and check its corresponding entry @xmath177 in @xmath167 array ( using select operation to find @xmath175 after @xmath176-th @xmath22 ) . observe that , among all these gray in - neighbors of @xmath175 , only one edge out of them to @xmath175 will be marked in @xmath167 as this is the edge that dfs traversed while going in the forward direction to @xmath175 .",
    "so once we find an in - neighbor @xmath176 such that the position corresponding to @xmath177 in @xmath167 is marked and @xmath176 is gray , we know that @xmath175 s parent is @xmath176 in the dfs tree . also the cross pointer puts us in the position of @xmath175 in @xmath176 s out - neighbor list , and we start from that position to find the next white vertex to explore dfs . so the only extra computation we do is to spend time proportional to the degree of each black vertex ( to find its parent to backtrack ) and so overall there is an extra overhead of @xmath113 time .",
    "the navigation we do to determine the tree edges are on @xmath60 which is a static array , and so from theorem  [ staticbit ] , all these operations can be performed in constant time .",
    "thus we have    [ directed1 ] a dfs traversal of a directed graph @xmath4 can be performed in @xmath162 time using @xmath178 bits .    for undirected graphs ,",
    "first observe that the unary degree sequence encoding @xmath60 takes @xmath179 bits as each edge appeares twice .",
    "as @xmath167 also takes @xmath179 bits , overall we require @xmath180 bits of space . as for dfs , observe that the forward step , as defined before , can be implemented in exact same manner .",
    "it is crucial to mention one subtle point that , while marking an edge @xmath181 , we do nt mark its other entry i.e. @xmath182 .",
    "so when dfs finishes , _ for tree edges exactly one of the two entries will be marked one in @xmath167 array_. backtracking step is now little easier as we do nt have to switch between two lists .",
    "we essentially follow the same steps in the adjacency array to check for a vertex @xmath176 in @xmath175 s array such that @xmath176 is gray and the corresponding entry for the edge @xmath177 is marked in @xmath167 .",
    "once found , we start with the next white vertex .",
    "hence ,    [ undirected1 ] a dfs traversal of an undirected graph @xmath4 can be performed in @xmath162 time using @xmath180 bits .",
    "we can decrease the space slightly by observing that , we are not really using the third color _ black_. more specifically , we can continue to keep a vertex gray even after its subtree has been explored . as we only explore white vertices always and",
    "never expand gray or black , the correctness follows immediately .",
    "this gives us the following .",
    "[ mixed ] a dfs traversal of a directed graph @xmath4 can be performed in @xmath162 time using @xmath183 bits .",
    "for undirected graphs , the space required is @xmath184 bits .",
    "one of the classical applications of dfs is to determine , in a connected undirected graph , all the cut vertices and bridges which are defined as , respectively , the vertices and edges whose removal results in a disconnected graph . since the early days of designing graph algorithms ,",
    "researchers have developed several approaches to test biconnectivity and @xmath2-edge connectivity , find cut vertices and bridges of a given undirected graph .",
    "most of these methods use depth - first search as the backbone to design the main algorithm . for biconnectivity and @xmath2-edge connectivity , the classical algorithm due to tarjan",
    "@xcite computes the so - called  low - point \" values ( which are defined in terms of a dfs - tree ) for every vertex @xmath31 , and checks some conditions using that to determine cut vertices , bridges of @xmath4 and check whether @xmath4 is @xmath2-edge connected or biconnected .",
    "brandes  @xcite and gabow  @xcite gave considerably simpler algorithms for testing biconnectivity by using simple path- generating rules instead of low - points ; they call these algorithms path - based .",
    "all of these algorithms take @xmath7 time and @xmath8 words of space .",
    "another algorithm due to schmidt @xcite is based on chain decomposition of graphs to determine biconnectivity and @xmath2-edge connectivity .",
    "implementing this algorithm takes @xmath7 time and @xmath113 words of space . in what follows ,",
    "we present a space efficient implementation for schmidt s algorithm based on the dfs algorithm we designed in the previous section .",
    "we summarize our result in the theorem below .",
    "[ dfsapps ] given a connected undirected graph @xmath4 , in @xmath7 time and using @xmath7 bits of space we can determine whether @xmath4 is @xmath2-vertex ( and/or edge ) connected . if not , in the same amount of time and space , we can compute all the bridges and cut vertices of the graph .",
    "schmidt  @xcite introduced a decomposition of the input graph that partitions the edge set of the graph into cycles and paths , called chains , and used this to design an algorithm to find cut vertices and biconnected components @xcite and also to test 3-connectivity  @xcite among others .",
    "we briefly recall schimdt s algorithm and its main ingredient of _ chain decomposition_. the algorithm first performs a depth first search on @xmath4 .",
    "let @xmath173 be the root of the dfs tree @xmath92 .",
    "dfs assigns an index to every vertex @xmath31 i.e. the time vertex @xmath31 is discovered for the first time ( discovery time ) during dfs .",
    "call it depth - first - index ( @xmath185 ) .",
    "imagine that the the back edges are directed away from @xmath173 and the tree edges are directed towards @xmath173 .",
    "the algorithm decomposes the graph into a set of paths and cycles called chains as follows .",
    "see figure @xmath2 for an illustration .    .",
    "( b ) a dfs traversal of @xmath4 and the resulting edge - orientation along with dfis . ( c ) a chain decomposition @xmath186 of @xmath4 . the chains @xmath187 and @xmath188 are paths and rest of them are cycles .",
    "the edge @xmath189 is bridge as it is not contained in any chain . @xmath190 and",
    "@xmath191 are cut vertices . ]",
    "first we mark all the vertices as unvisited .",
    "then we visit every vertex starting at @xmath173 in increasing order of dfi , and do the following .",
    "for every back edge @xmath192 that originates at @xmath31 , we traverse a directed cycle or a path .",
    "this begins with @xmath31 and the back edge @xmath192 and proceeds along the tree towards the root and stops at the first visited vertex or the root . during this step ,",
    "we mark every encountered vertex visited .",
    "this forms the first chain .",
    "then we proceed with the next back edge at @xmath31 , if any , or move towards the next @xmath31 in increasing dfi order and continue the process . let @xmath186 be the collection of all such cycles and paths .",
    "notice that , the cardinality of this set is exactly the same as the number of back edges in the dfs tree as each back edge contributes to one cycle or a path .",
    "also as initially every vertex is unvisited , the first chain would be a cycle as it would end in the starting vertex .",
    "schmidt proved the following theorem .",
    "@xcite [ 2ec ] let @xmath186 be a chain decomposition of a connected graph @xmath193 .",
    "then @xmath4 is 2-edge - connected if and if the chains in @xmath186 partition @xmath167 . also , @xmath4 is 2-vertex - connected if and if @xmath194 ( where @xmath195 denotes the minimum degree of @xmath4 ) and @xmath196 is the only cycle in the set @xmath186 where @xmath196 is the first chain in the decomposition .",
    "an edge @xmath192 in @xmath4 is bridge if and if @xmath192 is not contained in any chain in @xmath186 .",
    "a vertex @xmath31 in @xmath4 is a cut vertex if and if @xmath31 is the first vertex of a cycle in @xmath197 .",
    "the algorithm ( the tests in theorems  [ 2ec ] ) can be implemented easily in @xmath7 time using @xmath7 words as we can store the dfis and entire chain decomposition @xmath186 . to reduce the space to @xmath7 bits ,",
    "we first perform a depth first search of the graph @xmath4 ( as mentioned in theorem [ undirected1 ] ) and recall that at the end of the dfs procedure , we have the color array @xmath170 with all colors black and the array @xmath167 which encodes the dfs tree . here for a tree edge @xmath198 where @xmath21 is closer to the root , the position corresponding to the edge @xmath198 is marked @xmath48 and that corresponding to @xmath199 is marked @xmath22 , and the backedges are marked @xmath22 . to implement the chain decomposition , we do not have space to store the chains or the dfs indices . to handle the latter ( dfi ) ,",
    "we ( re)run dfs and then use schmidt s algorithm along with dfs in an interleaved way . towards the end , we recolor all the vertices to white . to handle the former ,",
    "we use two more arrays , one to mark the vertices visited in the chain decomposition , called _ visited _ and another array @xmath133 , to mark the edges visited during the chain decomposition .",
    "the array @xmath133 has size @xmath200 bits , and it has the same initial structure as @xmath167 i.e. @xmath22 s separated by @xmath48 s where @xmath22 s denote edges and @xmath48 s denote vertices .",
    "the details of forming the chain decomposition and finding all cut vertices and bridges using these arrays @xmath60 ( original outdegree encoding ) , @xmath167 ( the dfs tree ) , @xmath170 ( color array ) , @xmath201 and @xmath133 ( to mark edges ) are explained below .",
    "_ of theorem [ dfsapps ] .",
    "_ we explain here the details of forming the chain decomposition and finding all cut vertices and bridges .",
    "we start at the root vertex @xmath173 , and using the array @xmath167 , find the first ` back edge ' ( non - tree edge ) @xmath202 to @xmath173 .",
    "this can be found by going to the @xmath173-th @xmath22 in @xmath60 and then to the corresponding position in @xmath167 that represents the vertex @xmath173 ( note that @xmath167 has a lot more zeroes , and so we should get to the corresponding @xmath22 of @xmath173 in @xmath167 by first getting to the corresponding position in @xmath60 ) .",
    "if @xmath60 has @xmath48s after the corresponding @xmath22 , then we look for the first @xmath22 after the corresponding position in @xmath167 to find the back edge ( as all the tree edges are marked @xmath48 ) .",
    "we mark @xmath173 and @xmath203 visited ( if they were unvisited before ) and mark both copies of the edge @xmath202 ( unlike what we do in the forward step of dfs ) using the cross pointer in @xmath133 . now to obtain the chain , we need to follow the tree edges from @xmath203 .",
    "we use the ` backtracking ' procedure we used earlier for dfs .",
    "we look for an ( the only ) edge marked @xmath48 in @xmath167 out of the edges incident on @xmath203 by scanning the adjacency list , and that gives the parent @xmath204 of @xmath203 ( here is where we use the fact we only mark one copy of the edge as we explore the dfs tree . ) .",
    "we continue after marking @xmath204 visited , and the edge @xmath205 ( both copies ) in @xmath133 until we reach @xmath173 or a visited vertex when we complete the chain .",
    "now we continue from where we left of in @xmath173 s neighborhood to look for the next back edge and continue this process .",
    "once we are done with back edges incident on @xmath173 , we need to proceed to the next vertex in dfs order .",
    "as we have not stored the depth first indices , we essentially ( re)run the dfs using the color array @xmath170 . for this",
    ", we flush out the color array to make every vertex white again . note that we do nt make any changes to array @xmath167 and @xmath60 respectively .",
    "as this dfs procedure is deterministic , it will follow exactly the same sequence of paths like before , ultimately leading to the same dfs tree structure , and note that , this structure is already saved in array @xmath167 . clearly , the amount of space taken is @xmath7 bits . to analyze the runtime , note that , we first perform a dfs traversal which takes linear time . at the second step ,",
    "we basically perform one more round of dfs . as a visited node",
    "is never explored ( using the _ visited _ array ) , the overall runtime is @xmath7 .",
    "edge connectivity ( theorem  [ 2ec ] ) can easily be checked using the array @xmath133 once we have the chain decomposition .",
    "the bridges are the edges marked @xmath22 in the array @xmath133 .",
    "cut vertices can be obtained and listed out if and and when we reach the starting vertex while forming a chain , except at the first chain ( if exists ) .",
    "this completes the proof .    combining all the main results from this section , we summarize our results in the following theorem below ,    [ dfsapps1 ] a dfs traversal of an undirected or directed",
    "graph @xmath4 can be performed in @xmath7 time using @xmath206 bits . in the same amount of time and space ,",
    "given a connected undirected graph @xmath4 , we can perform a chain decomposition of @xmath4 , and using that we can determine whether @xmath4 is @xmath2-vertex ( and/or edge ) connected .",
    "if not , in the same amount of time and space , we can compute all the bridges and cut vertices of @xmath4 .    in what follows ,",
    "we show in section [ simp - bicon ] how to improve the space bounds of theorem [ dfsapps1 ] keeping the same running time by applying different bookeeping technique but essentially using the same algorithm itself .",
    "as mentioned previously , one can easily implement the tests in theorem  [ 2ec ] in @xmath7 time using @xmath113 words , by storing the dfis and the entire chain decomposition , @xmath186 .",
    "theorem [ dfsapps1 ] shows how to perform the tests using @xmath7 bits and @xmath7 time .",
    "the central idea there is to maintain the dfs tree using @xmath7 bits using an unary encoding of the degree sequence of the graph . and",
    "later , build on top of it another @xmath7 bits structure to perform chain decompositions and the other tests of schimdt s algorithm .",
    "we first show how the space for the dfs tree representation can be improved to @xmath27 bits . also note that , all the algorithms from the last section assumes that the input graph must be respresented as adjacency array with cross pointers .",
    "our algorithms in this section also get rid of this assumption .",
    "here we only assume that the input graph is represented as a standard adjacency array .",
    "we start by proving the following useful lemma .",
    "[ lem : adjlist - pointers ] given the adjacency array representation of an undirected graph @xmath4 on @xmath5 vertices with @xmath6 edges , using @xmath113 time , one can construct an auxiliary structure of size @xmath55 bits that can store a `` pointer '' into an arbitrary position within the adjacency array of each vertex .",
    "also , updating any of these pointers ( within the adjacency array ) takes @xmath70 time .",
    "we first scan the adjacency array of each vertex and construct a bitvector @xmath100 as follows : starting with an empty bitvector @xmath100 , for @xmath207 , if @xmath161 is the length of the adjacency array of vertex @xmath158 ( i.e. , its degree ) , then we append the string @xmath208 to @xmath100 .",
    "the length of @xmath100 is @xmath209 , which is bounded by @xmath55 .",
    "we construct auxiliary structures to support @xmath152 queries on @xmath100 in constant time , using theorem  [ staticbit ] .",
    "we now construct another bitvector @xmath210 of the same size as @xmath100 , which stores pointers into the adjacency arrays of each vertex .",
    "the pointer into the adjacency array of vertex @xmath158 is stored using the @xmath211 bits in @xmath210 from position @xmath212 to position @xmath213 , where @xmath214 is defined to be @xmath22 .",
    "now , using select operations on @xmath100 and using constant time word - level read / write operations , one can access and/or modify these pointers in constant time .",
    "given that we can maintain such pointers into the lists of every vertex , the following lemma shows that , within the same time and space bounds , we can actually maintain the dfs tree of a given graph @xmath4 .",
    "details are provided below .",
    "[ sec : biconn - parentprts ]    [ lem : parent - pointers ] given a graph @xmath4 with @xmath5 vertices and @xmath6 edges , in the adjacency array representation in the read - only memory model , the representation of a dfs tree can be stored using @xmath55 additional bits , which can be constructed on the fly during the dfs algorithm .",
    "we use the representation of lemma  [ lem : adjlist - pointers ] to store _ parent _ pointers into the adjacency array of each vertex .",
    "in particular , whenever the dfs outputs an edge @xmath215 , where @xmath30 is the parent of @xmath31 , we scan the adjacency array of @xmath31 to find @xmath30 and store a pointer to that position ( within the adjacency array of @xmath31 ) . the additional time for scanning the adjacency arrays adds upto @xmath113 which would be subsumed by the running time of the dfs algorithm .",
    "we call the representation of the dfs tree of lemma  [ lem : parent - pointers ] as the _ parent pointer representation_. now given lemma [ lem : adjlist - pointers ] and [ lem : parent - pointers ] , we can simulate the dfs algorithm of theorem [ undirected1 ] to obtain an @xmath55 bits and @xmath7 time dfs implementation .",
    "the proof of theorem  [ dfsapps ] then uses another @xmath7 bits to construct the chain decomposition of @xmath4 and perform the tests as mentioned in theorem  [ 2ec ] , and we show here how even the space for the construction of a chain decomposition and performing the tests can be improved .",
    "we summarize our results in the following theorem below :    [ thm : biconn - parentptrs ] a dfs traversal of an undirected or directed graph @xmath4 can be performed in @xmath7 time using @xmath55 bits of space . in the same amount of time and space ,",
    "given a connected undirected graph @xmath4 , we can perform a chain decomposition of @xmath4 , and using that we can determine whether @xmath4 is @xmath2-vertex ( and/or edge ) connected . if not , in the same amount of time and space , we can compute and report all the bridges and cut vertices of @xmath4 .",
    "given lemma  [ lem : adjlist - pointers ] and  [ lem : parent - pointers ] , it is easy to verify that we can simulate the dfs algorithms of theorem  [ directed1 ] and  [ undirected1 ] to obtain an @xmath55 bits and @xmath7 time dfs implementation . in what follows we use this dfs algorithm to perform the tests in theorem  [ 2ec ] . with the help of the parent pointer representation",
    ", we can visit every vertex , starting at the root @xmath173 of the dfs tree , in increasing order of dfi , and enumerate ( or traverse through ) all the non - tree ( back ) edges of the graph as required in schimdt s algorithm as follows : for each node @xmath31 in dfi order , and for each node @xmath30 in its adjacency list , we check if @xmath30 is a parent of @xmath31 . if so , then @xmath215 is a tree edge , else it is a back edge .",
    "we maintain a bit vector _ visited _ of size @xmath5 , corresponding to the @xmath5 vertices , initialized to all zeros meaning all the vertices are unvisited at the beginning .",
    "we use _ visited _ array to mark vertices visited during the chain decomposition . when a new back edge is visited for the first time",
    ", the algorithm traverses the path starting with the back edge followed by a sequence of tree edges ( towards the root ) untill it encounters a marked vertex , and also marks all the vertices on this path . by checking whether the vertices are marked or not",
    ", we can also distinguish whether an edge is encountered for the first time or has already been processed .",
    "note that this procedure constructs the chains on the fly .    to check whether an edge is a bridge or not",
    ", we first note that only the tree edges can be bridges ( back edges always form a cycle along with some tree edges ) .",
    "also , from theorem  [ 2ec ] , it follows that any ( tree ) edge that is not covered in the chain decomposition algorithm is a bridge .",
    "thus , to report these , we maintain a bitvector @xmath133 of length @xmath5 , corresponding to the @xmath5 vertices , initialized to all zeros .",
    "whenever a tree edge @xmath215 is traversed during the chain decomposition algorithm , if @xmath31 is the child of @xmath30 , then we mark the child node @xmath31 in the bit vector @xmath133 . after reporting all the chains , we scan the bitvector @xmath133 to find all unmarked vertices @xmath31 and output the edges @xmath215 , where @xmath30 is the parent of @xmath31 , as bridges . if there are no bridges found in this process , then @xmath4 is @xmath2-edge connected . to check whether a vertex is a cut vertex ( using the characterization in theorem  [ 2ec ] ) ,",
    "we keep track the starting vertex of the current chain ( except for the first chain , which is a cycle ) , that is being traversed , and report that vertex as a cut vertex if the current chain is a cycle .",
    "if there are no cut vertices found in this process then @xmath4 is @xmath2-vertex connected .",
    "otherwise , we keep one more array of size @xmath5 bits to mark which vertices are cut vertices .",
    "this completes the proof .",
    "note that , all of our algorithms in this section do nt use cross pointers and hence we can just assume that the input graph @xmath4 is represented via _",
    "adjacency array _",
    "i.e. , given a vertex @xmath31 and an integer @xmath13 , we can access the @xmath13-th neighbor of vertex @xmath31 in constant time .",
    "we remark that this input representation was also used in @xcite recently to design various other space efficient graph algorithms .",
    "we have provided several implementations of bfs focusing on optimizing space without much degradation in time . in particular with @xmath14 bits we get an optimal linear time algorithm whereas squeezing space further gives an algorithm with running time @xmath36 where @xmath17 can be any ( extremely slow - growing ) function of @xmath5 .",
    "one can immediately obtain similar time - space tradeoffs for natural applications of bfs including testing whether a graph is bipartite or to obtain all connected components of a graph . to achieve this",
    ", we also provide a simple and space efficient implementation of the _ findany _ data structure .",
    "this data structure supports in constant time , apart from the standard insert , delete and membership queries , the operations findany and enumerate .",
    "very recently , poyias et al .",
    "@xcite considered the problem of compactly representing a rewritable array of bit - strings , and for this , they heavily used our findany data structure .",
    "it would be interesting to find other such applications for our data structure . using the findany data structure",
    ", we also provide a space efficient implementation of the _ decrement _ data structure which supports in constant time the decrement and check if any element is zero operations .",
    "we use this decrement data structure to design space efficient algorithms for performing topological sort in a directed acyclic graph and computing degeneracy ordering of a given undirected graph .",
    "for the mst problem , we could reduce the space further to @xmath11 bits .",
    "it is an interesting question whether we can perform bfs using @xmath11 bits with a runtime of @xmath124 for some constant @xmath57 or even @xmath34 .    for dfs",
    ", we provide an @xmath7 time and @xmath55 space dfs traversal method . for a large class of graphs including planar , bounded degree and bounded treewidth graphs , this gives an @xmath8 bits and @xmath7 time dfs algorithm , partially answering an open question in  @xcite , and improving the result of  @xcite . within the same time and space bound",
    ", we also show how to test biconnectivity and @xmath2-edge connectivity , obtain cut vertices and bridges , and compute a chain decomposition of a given undirected graph @xmath4 .",
    "it is a challenging and interesting open problem whether dfs and all these applications can be performed using @xmath7 time and @xmath8 bits .",
    "see  @xcite for some recent algorithms using @xmath8 bits for most of the problems considered in this paper and others , albeit with a slightly more than linear running time . + * acknowledgement * we thank saket saurabh for suggesting the question that led to results in section 5 .",
    "+                    n.  banerjee , s.  chakraborty , v.  raman , s.  roy , and s.  saurabh .",
    "time - space tradeoffs for dynamic programming in trees and bounded treewidth graphs . in _",
    "21st cocoon _ ,",
    "volume 9198 , pages 349360 .",
    "springer , lncs , 2015 ."
  ],
  "abstract_text": [
    "<S> research on space efficient graph algorithms , particularly for @xmath0-connectivity , has a long history including the celebrated polynomial time , @xmath1 bits to denote logarithm to the base @xmath2 . ] </S>",
    "<S> algorithm in undirected graphs by reingold ( jacm 2008 ) , and polynomial time , @xmath3 bits algorithm in directed graphs by barnes et al . </S>",
    "<S> ( sicomp 1998 ) . </S>",
    "<S> recent works by asano et al . </S>",
    "<S> ( isaac 2014 ) and elmasry et al . ( </S>",
    "<S> stacs 2015 ) , reconsidered classical fundamental graph algorithms focusing on improving the space complexity . </S>",
    "<S> elmasry et al </S>",
    "<S> . gave , among others , an implementation of breadth first search ( bfs ) in a graph @xmath4 with @xmath5 vertices and @xmath6 edges , taking the optimal @xmath7 time using @xmath8 bits of space improving the nave @xmath9 bits implementation . </S>",
    "<S> similarly , asano et al . provided several space efficient implementations for performing depth first search ( dfs ) in a graph @xmath4 . </S>",
    "<S> we continue this line of work focusing on improving the space requirement for implementing a few classical graph algorithms .    </S>",
    "<S> our first result is a simple data structure that can maintain any subset @xmath10 of a universe of @xmath5 elements using just @xmath11 bits and supports in constant time , apart from the standard insert , delete and membership queries , the operation _ findany _ that finds and returns any element of the set ( or outputs that the set is empty ) . </S>",
    "<S> it can also enumerate all elements present currently in the set in no particular order in @xmath12 time where @xmath13 is the number of elements currently belonging to the set . while this data structure supports a weaker set of operations than that of elmasry et al . </S>",
    "<S> ( stacs 2015 ) , it is simple , more space efficient and is sufficient to support a bfs implementation optimally in @xmath7 time using at most @xmath14 bits . </S>",
    "<S> later , we further improve the space requirement of bfs to at most @xmath15 bits albeit with a slight increase in running time to @xmath16 time where @xmath17 is any extremely slow growing function of @xmath5 , and the @xmath18 term in the space is a function of @xmath17 .    </S>",
    "<S> we demonstrate one application of our data structure by developing another data structure using it that can represent a sequence of @xmath5 non - negative integers @xmath19 using at most @xmath20 bits and , in constant time , determine whether the @xmath21-th element is @xmath22 or decrement it otherwise . </S>",
    "<S> we use this data structure to output , in @xmath7 time and using @xmath7 bits of space , the vertices of    * a directed acyclic graph in topological sorted order , and * an undirected graph with degeneracy @xmath23 in degeneracy order .    </S>",
    "<S> these results improve the space bounds of earlier implementations at least for sparse graphs while maintaining the same linear running time . </S>",
    "<S> we also discuss a time - space tradeoff result for finding a minimum weight spanning tree of a weighted ( bounded by polynomial in @xmath5 ) undirected graph using @xmath24 bits and @xmath25 time , for any function @xmath17 such that @xmath26 .    for dfs in a graph @xmath4 , we provide an implementation taking @xmath7 time and @xmath27 bits . </S>",
    "<S> this partially answers at least for sparse graphs , a question asked by asano et al . </S>",
    "<S> ( isaac 2014 ) whether dfs can be performed in @xmath7 time and using @xmath8 bits , and also simultaneously improves the dfs result of elmasry et al . </S>",
    "<S> ( stacs 2015 ) . using our dfs algorithm and other careful implementations , </S>",
    "<S> we show how one can also test for biconnectivity , @xmath2-edge connectivity , and find cut vertices and bridges of a given undirected graph within the same time and space bounds ; earlier classical linear time algorithms for these problems used @xmath28 bits of space . </S>"
  ]
}