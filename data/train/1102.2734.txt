{
  "article_text": [
    "a ( normal ) graphical realization of a linear code @xmath0 consists of an assignment of the coordinates of @xmath0 to the vertices of a graph , along with a specification of linear state spaces and linear `` local constraint '' codes to be associated with the edges and vertices , respectively , of the graph @xcite .",
    "cycle - free graphical realizations , or simply _ tree realizations _ , are those in which the underlying graph is a tree . tree realizations of linear codes are interesting because the sum - product algorithm ( spa ) on such a realization is an exact implementation of maximum - likelihood ( ml ) decoding @xcite .",
    "the notion of constraint complexity of a tree realization was introduced by forney @xcite as a measure of the computational complexity of the corresponding spa algorithm .",
    "it is defined to be the maximum dimension among the local constraint codes constituting the realization .",
    "the _ treewidth _ of a linear code is the least constraint complexity of any of its tree realizations .",
    "the minimal tree complexity measure defined for linear codes by halford and chugg @xcite is a close relative of treewidth .",
    "there are also closely related notions of treewidth defined for graphs @xcite and matroids @xcite ; these relationships are discussed in more detail in @xcite . known facts about the treewidth of graphs and matroids imply that computing the treewidth of a code is np - hard .    for a length-@xmath1 linear code over the field",
    "@xmath2 , the computational complexity of implementing ml decoding , via the spa on an optimal tree realization , is @xmath3 , where @xmath4 is the treewidth of the code @xcite . in particular ,",
    "ml decoding is fixed - parameter tractable with respect to treewidth , which means that for codes whose treewidth is bounded by a fixed constant @xmath4 , ml decoding can be performed in polynomial time .",
    "thus , treewidth provides a useful parametrization of ml decoding complexity .",
    "trellis representations ( or trellis realizations ) of codes are special cases of tree realizations which have received extensive attention in the literature ( see e.g. , @xcite ) . in the context of trellis representations ,",
    "constraint complexity is usually called branch complexity .",
    "we define here the _ trelliswidth _ of a code to be the least branch complexity of any of its trellis representations ( optimized over all possible orderings of the coordinates of the code ) .",
    "as trellis representations are instances of tree realizations , trelliswidth is at least as large as treewidth .",
    "in fact , it is known that trelliswidth can be much larger than treewidth : it was shown in @xcite that the ratio of trelliswidth to treewidth can grow at most logarithmically with blocklength , and that there are codes with arbitrarily large blocklengths that achieve this logarithmic growth rate .",
    "the only known code family achieving logarithmic growth rate of this ratio is a family consisting of cut - set codes of a certain class of graphs .",
    "the codes in this family all have treewidth equal to 2 , and rate approximately @xmath5 , but minimum distance only 4 @xcite .",
    "it is not known if there are any other code families for which there is a significant advantage to be gained in going from trellis representations to tree realizations that are topologically more complex . in",
    "the only previous investigation reported on this question , forney @xcite considered the family of reed - muller codes .",
    "he showed that for a certain natural tree realization of reed - muller codes , obtained from their well - known recursive @xmath6 construction , the constraint complexity is , in general , strictly larger than the trelliswidth of the code .",
    "but this still leaves open the possibility that there may be other tree realizations whose constraint complexity beats trelliswidth . in particular , it leaves undecided the question of whether the treewidth of a reed - muller code can be strictly less than its trelliswidth .    in this paper",
    ", we show that for reed - muller codes , treewidth is equal to trelliswidth .",
    "the proof of this makes use of structural properties known for optimal trellis realizations of reed - muller codes , and also relies strongly on a certain separator theorem for trees .",
    "a similar proof strategy also works on the much simpler case of maximum distance separable ( mds ) codes , where again we show that treewidth equals trelliswidth .",
    "these results yield the first explicit expressions for the treewidth of classical algebraic codes .",
    "the rest of this paper is organized as follows . after providing the necessary definitions and notation in section  [ sec : prelims ] ,",
    "we describe , in section  [ sec : strategy ] , our proof strategy for showing that treewidth equals trelliswidth for certain codes .",
    "sections  [ sec : mds ] and [ sec : rm ] deal with mds and reed - muller codes , respectively .",
    "the technical details of some of the proofs are given in appendices .",
    "the notation @xmath7 $ ] denotes the set of positive integers from 1 to @xmath1 ; @xmath8 $ ] denotes the set @xmath9 .",
    "an @xmath10 linear code is a code of length @xmath1 and dimension @xmath11 .",
    "the @xmath1 coordinates of the code are indexed by the elements of an index set @xmath12 ; unless specified otherwise , @xmath13 $ ] .",
    "given a linear code @xmath0 with index set @xmath12 , for @xmath14 , the shortening of @xmath0 to the coordinates in @xmath15 is denoted @xmath16 and defined as follows : @xmath17    the notions of treewidth and trelliswidth are central to this article , and we define these next .      for brevity , we provide only the necessary definitions and main results ; for details , see @xcite,@xcite .",
    "a tree is a connected graph with no cycles .",
    "the set of nodes and the set of edges of a tree @xmath18 are denoted by @xmath19 and @xmath20 , respectively .",
    "degree-1 nodes in a tree are called _ leaves _ , and all other nodes are called _ internal nodes_.",
    "we let @xmath21 denote the set of leaves of @xmath18 .",
    "a tree is a _ path _ if all its internal nodes have degree 2 ; and is a",
    "_ cubic tree _ if all its internal nodes have degree 3 .",
    "a path with at least one edge has exactly two leaves ; a cubic tree with @xmath1 leaves has @xmath22 internal nodes .",
    "let @xmath0 be an @xmath10 linear code with index set @xmath12 .",
    "a _ tree decomposition _ of @xmath0 is a pair @xmath23 , where @xmath18 is a tree and @xmath24 is an assignment of coordinates of @xmath0 to the nodes of @xmath18 .    given a tree decomposition @xmath23 of @xmath0 , for each node @xmath25 of @xmath18 , we define a quantity @xmath26 as follows .",
    "let @xmath27 denote the set of edges of @xmath18 incident on @xmath25 .",
    "for @xmath28 , let @xmath29 denote the component of @xmath30 ( @xmath18 with @xmath31 removed ) containing @xmath25 .",
    "finally , let @xmath32 be the set of coordinates of @xmath0 that are assigned to nodes in @xmath29 .",
    "then , @xmath33 the quantity @xmath26 above is the dimension of the local constraint code at node @xmath25 in the minimal realization of @xmath0 on @xmath23 , denoted by @xmath34 .",
    "let @xmath35 denote the constraint complexity of @xmath34 .",
    "the treewidth of a code @xmath0 , denoted by @xmath36 , is then defined as @xmath37 it is , in fact , enough to perform the minimization in ( [ treewidth_def ] ) over cubic trees @xmath18 with @xmath1 leaves , and mappings @xmath38 that are bijections between @xmath12 and @xmath21 .",
    "the trelliswidth of @xmath0 , which we will denote by @xmath39 , can be defined using the above notation as follows : @xmath40 where @xmath41 is the path on @xmath1 nodes , and the minimization is over mappings @xmath42 that are bijections between @xmath12 and @xmath43 . from ( [ treewidth_def ] ) and ( [ trellis_def ] ) ,",
    "it is clear that @xmath44 .",
    "let @xmath45 be the nodes of the path @xmath41 , listed in order from one leaf to the other .",
    "for the bijection @xmath46 that maps @xmath47 to @xmath48 ( @xmath49 ) , we obtain from ( [ eq:1 ] ) , @xmath50 } ) - \\dim(\\cc_{\\pi[i+1,n ] } ) , \\label{eq:6}\\ ] ] where @xmath51 = \\{\\pi(j ) : a \\le j \\le b\\}$ ] .",
    "the generalized hamming weights of a linear code , introduced and studied in @xcite , limit the possible dimensions of shortened versions of the code .",
    "so , they are related to the complexity of tree realizations in a natural way .",
    "let @xmath0 be an @xmath10 linear code with index set @xmath12 .",
    "we will use the notation @xmath52 to say that @xmath53 is a subcode of @xmath0 . for a subcode @xmath54",
    ", we define its support @xmath55 .",
    "the @xmath56-th generalized hamming weight of @xmath57 , denoted @xmath58 , is the size of the smallest support of a @xmath56-dimensional subcode of @xmath0 , i.e. , @xmath59 for @xmath60 .",
    "it is known that @xmath61 . also , @xmath62 is the minimum distance of @xmath0 .",
    "a closely related definition is that of maximal limited - support subcode dimensions . for @xmath63 ,",
    "@xmath64 is defined to be the maximum dimension of a subcode of @xmath0 with support at most @xmath65 , i.e. , @xmath66 .",
    "the maximal limited - support subcode dimensions can be computed using the generalized hamming weights as follows : @xmath67 with the convention that @xmath68 and @xmath69",
    ". we also define @xmath70 .",
    "from the relevant definitions , treewidth can not exceed trelliswidth for any code @xmath0 , i.e. , @xmath44 .",
    "we now describe a general strategy that can be used to show the opposite inequality in certain cases .",
    "consider an @xmath10 linear code @xmath0 , with index set @xmath12 .",
    "the idea of using maximal limited - support subcode dimensions to study the complexity of trellis realizations of @xmath0 was introduced in @xcite .",
    "we extend that idea to tree realizations here . for @xmath71",
    ", @xmath16 is a subcode of @xmath0 with support at most @xmath72 .",
    "so , @xmath73 . therefore , given any tree decomposition @xmath23 of @xmath0 , we obtain from ( [ eq:1 ] ) that for any @xmath74 , @xmath75    now , recall from the definition of treewidth that it suffices to carry out the minimization in ( [ treewidth_def ] ) over tree decompositions @xmath76 in which @xmath18 is a cubic tree with @xmath1 leaves , and @xmath38 is a bijection between @xmath12 and @xmath21 .",
    "for such a @xmath76 , we note that @xmath77 is simply the number of leaves in @xmath29 , and for an internal node @xmath74 , the summation in ( [ eq:10 ] ) contains exactly three terms .",
    "let @xmath78 denote the number of leaves in @xmath29 , and note that these numbers @xmath78 are determined purely by the topology of @xmath18 .",
    "at an internal node @xmath25 in a cubic tree @xmath18 with @xmath1 leaves , we will list the edges in @xmath27 in the form of an ordered triple @xmath79 $ ] such that @xmath80 .",
    "if the node @xmath25 is clear in the context , we will use the simplified notation @xmath81 for @xmath82 .",
    "suppose that @xmath18 is a cubic tree with @xmath1 leaves having an internal node @xmath25 such that the numbers @xmath83 satisfy @xmath84 .",
    "then , by ( [ eq:10 ] ) , for any bijection @xmath38 between @xmath12 and @xmath21 , we have @xmath85 , and hence @xmath86 . consequently ,",
    "if every cubic tree with @xmath1 leaves had such a node @xmath25 , then we would have @xmath87 .",
    "since the opposite inequality is always true , we have proved the following proposition .",
    "let @xmath0 be an @xmath10 linear code with the property that for any cubic tree @xmath18 with @xmath1 leaves , there always exists an internal node @xmath74 such that @xmath84 , where @xmath88 .",
    "then , @xmath89 .",
    "[ prop : k_eq_t ]    a comment on the proof strategy implied by proposition  [ prop : k_eq_t ] is in order .",
    "to show that @xmath87 ( and hence , @xmath90 ) , the obvious strategy would be to show , for each tree decomposition @xmath76 of @xmath0 , the existence of a node @xmath74 for which @xmath85 , where @xmath26 is given by ( [ eq:10 ] ) .",
    "in general , the node @xmath25 would depend on the tree @xmath18 as well as on the coordinate assignment @xmath91",
    ". however , in the proof method based upon proposition  [ prop : k_eq_t ] , the idea is to find , for a given @xmath76 , a node @xmath74 that depends only on the topology of @xmath18 , and thus , is _ independent _ of @xmath91 , for which @xmath85 holds .",
    "it is a remarkable fact that this proof strategy can be made to work for mds and reed - muller codes , as we will see in sections  [ sec : mds ] and [ sec : rm ] .",
    "the hypothesis of proposition [ prop : k_eq_t ] requires the existence of a node in any cubic tree , whose removal partitions the tree into components with a certain property .",
    "the property in this case is that the corresponding partition of the number of leaves , @xmath1 , into @xmath83 satisfies @xmath84 .",
    "structural results of this form are known as separator theorems ( see _ e.g. _ , @xcite )    a classical separator theorem is a theorem of jordan @xcite that states that any tree on @xmath1 nodes has an internal node whose removal leaves behind connected components with at most @xmath92 nodes each .",
    "a trivial modification of the simple proof of this theorem shows that the two occurrences of `` nodes '' in the theorem statement can be replaced by `` leaves '' . for easy reference",
    ", we record this as a proposition for the special case of cubic trees .",
    "in any cubic tree with @xmath93 leaves , there exists an internal node @xmath25 such that @xmath94 for @xmath82 .",
    "[ prop : n/2 ]    another classical ( edge ) separator theorem is the following result ( cf .",
    "@xcite ) : every cubic tree @xmath18 with @xmath1 leaves contains an edge @xmath31 such that both components of @xmath30 have at most @xmath95 leaves .",
    "now , one of these two components must have at least @xmath92 leaves ; let @xmath25 be the node incident with @xmath31 for which this component is @xmath29 .",
    "then , for this @xmath25 , we have @xmath96 $ ] .",
    "we record this fact below .",
    "in any cubic tree with @xmath93 leaves , there exists an internal node @xmath25 such that @xmath97 $ ] .",
    "[ prop : cubic ]    as we will see in the next two sections , propositions  [ prop : n/2 ] and [ prop : cubic ] allow us to deal with mds and reed - muller codes , respectively .",
    "we consider mds codes first .",
    "mds codes are @xmath10 linear codes for which the minimum distance equals @xmath98 .",
    "basic facts about mds codes can be found in @xcite .",
    "let @xmath0 be an @xmath10 mds code , with index set @xmath13 $ ] .",
    "the generalized hamming weights of @xmath0 were computed in @xcite as follows : @xmath99 from this , the maximal limited - support subcode dimensions , @xmath100 for @xmath63 , can be determined using ( [ eq : u_s ] ) .",
    "they are given by @xmath101 equivalently , @xmath102 .",
    "we use this to compute @xmath39 next .",
    "let @xmath103 be a parity - check matrix for @xmath0 .",
    "for a subset @xmath71 , the code @xmath16 has dimension equal to @xmath104 , where @xmath105 refers to the restriction of @xmath103 to the columns indexed by @xmath15 . as @xmath0 is mds , @xmath106 .",
    "hence , @xmath107 .",
    "therefore , for any permutation @xmath42 of @xmath12 , we have for integers @xmath108 , @xmath109 } ) = u_{b - a+1}(\\cc)$ ] .",
    "therefore , the right - hand - side of ( [ eq:6 ] ) is always equal to @xmath110 .",
    "it follows directly from this that @xmath111 a straightforward computation using ( [ eq : mds_us ] ) yields @xmath112 achieved for @xmath113 .",
    "we thus have the following result .",
    "the trelliswidth of an @xmath10 mds code @xmath0 is given by @xmath114 .",
    "[ prop : mds_trelliswidth ]    with this , we have @xmath115 we can now prove that the treewidth of an mds code equals its trelliswidth .",
    "for an @xmath10 mds code @xmath0 , we have @xmath116 [ thm : mds_treewidth ]    the statement is trivial for @xmath117 , or when @xmath118 , so we assume @xmath93 and @xmath119 . let @xmath18 be a cubic tree with @xmath1 leaves , and let @xmath25 be the node guaranteed by proposition  [ prop : n/2 ] .",
    "we will show that @xmath25 satisfies the hypothesis of proposition  [ prop : k_eq_t ] .",
    "set @xmath88 , @xmath120 , and recall that , by definition , @xmath121 . by choice of @xmath25 , we also have @xmath122 for @xmath82 . for convenience ,",
    "we write @xmath123 for @xmath124 .    .",
    "in this case , @xmath125 , so that @xmath126 by ( [ eq : mds_us ] ) . moreover , by ( [ eq : mds1 ] ) , @xmath127 .",
    "now , we have @xmath128 .",
    "we must show that @xmath129 .",
    "if @xmath130 , then @xmath126 .",
    "so , we assume @xmath131 , with @xmath132",
    ". then , @xmath133 and @xmath134 .",
    "so , we have @xmath135 where the last inequality holds because @xmath136 , @xmath137 and @xmath138 .",
    "thus , in both cases , we see that @xmath139 , and so , by proposition  [ prop : k_eq_t ] , we have @xmath90 .",
    "for a positive integer @xmath140 and a non - negative integer @xmath141 with @xmath142 , the @xmath141-th order binary reed - muller code of length @xmath143 , denoted rm@xmath144 , is defined as follows .",
    "let @xmath145 denote the set of all boolean polynomials in @xmath140 variables of degree less than or equal to @xmath141 .",
    "for an integer @xmath47 , @xmath146 , with binary expansion @xmath147 , @xmath148 , we let @xmath149 . for @xmath150",
    ", let @xmath151 .",
    "the code rm@xmath144 is defined as @xmath152 : f\\in p^m_r\\}.\\ ] ] the code @xmath153 has length @xmath154 , dimension @xmath155 , and minimum distance @xmath156 @xcite . in ( [ eq:5 ] ) , the order of evaluation of the function @xmath157 is according to the index set @xmath158 $ ] .",
    "this is called the standard bit order .",
    "we will denote the treewidth and trelliswidth of @xmath153 by @xmath159 and @xmath160 , respectively .",
    "let @xmath0 be the reed - muller code @xmath153 in the standard bit order , so that @xmath161 $ ] .",
    "in this section , we derive an exact expression for the trelliswidth of @xmath0 .",
    "let @xmath41 be the path on @xmath154 nodes , with @xmath162 being the nodes of @xmath41 , listed in order from one leaf to the other .",
    "for any @xmath163 , we obtain from ( [ eq:6 ] ) , in a manner analogous to the derivation of ( [ eq:10 ] ) , @xmath164 for @xmath165 .",
    "thus , @xmath166 note that the right - hand - side is independent of @xmath42 , so that by ( [ trellis_def ] ) , @xmath167 it is shown in @xcite that for @xmath153 in the standard bit order , we have for @xmath165 , @xmath168}))= u_{i+1}(\\cc ) \\ \\ \\text { and } \\ \\",
    "\\dim(\\cc_{[i , n-1 ] } ) = u_{n - i}(\\cc ) .",
    "\\label{eq : std_bit_order}\\ ] ] it follows that when @xmath42 simply maps @xmath47 to @xmath48 for all @xmath169 , then we have equality in ( [ eq : rm1 ] ) , and hence , in ( [ eq : rm2 ] ) . to put this another way ,",
    "the branch complexity of the minimal trellis representation of @xmath153 in the standard bit order attains the lower bound on , and thus equals , the trelliswidth of the code .",
    "techniques from @xcite allow us to compute , with very little effort , the branch complexity of this trellis representation .",
    "we give the details of this computation in appendix  a. from this , we obtain the following result .",
    "the trelliswidth of the reed - muller code @xmath153 is given by @xmath170 [ prop : rm_tau ]    recall that the dimension of the code @xmath153 is given by @xmath171 .",
    "we will find it convenient to define @xmath172 to be @xmath173 for all non - negative integers @xmath174 , including when @xmath175 .",
    "with the usual conventions that @xmath176 and @xmath177 for @xmath178 .",
    "thus , for @xmath179 , @xmath180 .",
    "following these conventions , we give an expression for the difference @xmath181 .",
    "for the reed - muller code @xmath153 , we have @xmath182 [ prop : srm ]    we present the algebraic manipulations required to prove this proposition in appendix  a.    it is instructive to explicitly write out some of the terms of the summation in the last proposition . when @xmath183 , we have @xmath184 and when @xmath185 , we have @xmath186      we state below our main result showing that the treewidth of a reed - muller code equals its trelliswidth .",
    "the treewidth of the reed - muller code @xmath153 is given by @xmath187 [ thm : rm_treewidth ]    the rest of this section is devoted to a proof of the above result , which follows the strategy outlined in section  [ sec : strategy ] .",
    "some of the technical details of the proof are presented in appendices b and c.    let @xmath153 be given .",
    "if @xmath188 , or @xmath189 , then @xmath153 is an mds code , which has been dealt with in section  [ sec : mds ] .",
    "henceforth , we will assume @xmath190 and @xmath191 .",
    "let @xmath18 be a cubic tree with @xmath192 leaves , @xmath190 , and let @xmath193\\}$ ] .",
    "by proposition  [ prop : cubic ] , @xmath194 is non - empty .",
    "let @xmath195 be a node that achieves @xmath196 .",
    "write @xmath197 , @xmath120 .",
    "we have @xmath198 [ lemma : n2 * ]    if @xmath199 , then from the fact that @xmath200 , we obtain @xmath201 , so that @xmath202 , a contradiction .",
    "so , @xmath203 .",
    "however , @xmath204 is not an integer for @xmath154 , and so , @xmath205 .    if @xmath206 , then @xmath207 .",
    "let @xmath25 be the neighbour of @xmath208 incident with edge @xmath209 . then , setting @xmath210 , we see that @xmath211 ; see figure  [ fig:1 ] . but",
    "this means that @xmath212 , which contradicts our choice of @xmath208 .    we will show that @xmath213 , which will prove theorem  [ thm : rm_treewidth ] by virtue of proposition  [ prop : k_eq_t ] . here , and",
    "in all that follows , we use @xmath214 as shorthand for @xmath215 ,    denote by @xmath216 and @xmath217 the largest integers in @xmath218 $ ] and @xmath219 $ ] , respectively .",
    "explicitly , @xmath220 and @xmath221 equivalently , in binary form , @xmath222 and @xmath223 when there is no ambiguity , we will drop the superscripts from @xmath216 and @xmath217 for notational ease .    now , what we know is that @xmath224 $ ] and @xmath225 $ ] .",
    "in fact , it can be directly verified from the expression for @xmath226 that @xmath227 .",
    "we wish to show that @xmath228 .",
    "we will do this in two steps : first , we show in lemma  [ lemma : u_ineq ] below that @xmath229 , and then , we prove in lemma  [ lemma : ua+ub+u1 ] that @xmath230 .",
    "write @xmath231 and @xmath232 , so that @xmath233 , where @xmath234 $ ] and @xmath235 $ ] .",
    "the following lemma shows that @xmath229 .    for @xmath234 $ ] , and @xmath235 $ ]",
    ", we have @xmath236 [ lemma : u_ineq ]    see appendix  b.    @xmath230 .",
    "[ lemma : ua+ub+u1 ]    the minimum distance of @xmath153 is @xmath156 .",
    "since we have assumed @xmath191 , the minimum distance is at least 2 , and hence , @xmath237 . in appendix  c",
    ", we show the following : when @xmath183 , @xmath238 examining the above summations term - by - term , it may be verified that the alternate terms on the right - hand side of ( [ srm_eq1 ] ) , beginning with @xmath239 , sum to @xmath240 , while the remaining terms sum to @xmath241 . hence ,",
    "when @xmath183 , the statement of the lemma holds .",
    "when @xmath242 , we show in appendix  c that @xmath243 and @xmath244 this time , it can be seen that the alternate terms on the right - hand side of ( [ srm_eq2 ] ) , beginning with @xmath239 , sum to @xmath240 , while the remaining terms sum to @xmath241 .",
    "this completes the proof of the lemma .    with this",
    ", the proof of theorem  [ thm : rm_treewidth ] is complete .",
    "in this paper , we proved the surprising fact that for the families of mds and reed - muller codes , if we use the maximum dimension of local constraint codes to measure the complexity of a graphical realization , then there is no advantage to be gained in going from trellis realizations to cycle - free realizations on more complex tree topologies .",
    "this is particularly surprising for reed - muller codes , given that they have a natural binary - tree structure arising from the recursive @xmath6 construction ( see e.g.  @xcite ) . of course",
    ", the situation could be different if we used some other measure for the complexity of a graphical realization , for example , the sum of the local constraint dimensions .",
    "it is also quite remarkable that the proof strategy outlined in section  [ sec : strategy ]  namely , identifying in any cubic tree @xmath18 a node @xmath74 such that @xmath85 for _ every _ tree decomposition of the code @xmath0 on @xmath18  succeeds for mds and reed - muller codes .",
    "as noted in that section , this strategy ignores the role played by the coordinate assignment @xmath91 in determining the local constraint code dimension , @xmath26 .",
    "it seems unlikely that this method of proof would succeed for other code families .",
    "it would of course be interesting to devise a set of tools that could be used to compute treewidth , or simply to determine whether or not treewidth can be strictly less than trelliswidth , for other families of algebraic codes .",
    "in this appendix , we compute the branch complexity of the minimal trellis representation of @xmath153 in the standard bit order , from which the expressions in proposition  [ prop : rm_tau ] and [ prop : srm ] are obtained .",
    "we refer the reader to the survey by vardy @xcite for the necessary background on the theory of trellis representations .",
    "let @xmath160 and @xmath245 denote , respectively , the branch complexity and state complexity of the minimal trellis representation of @xmath153 in the standard bit order .",
    "berger and beery @xcite gave an explicit expression for @xmath245 : @xmath246 a different derivation of the above was given by blackmore and norton @xcite .",
    "we rely heavily on tools from @xcite to prove the following result , which is equivalent to proposition  [ prop : rm_tau ] .",
    "@xmath247 [ app_prop1 ]    we introduce some terminology and notation that will be needed in the proof of the proposition .",
    "let @xmath0 be the code @xmath153 in the standard bit order , and let @xmath192 .",
    "let @xmath248 be the minimal trellis of @xmath0 . for @xmath249 ,",
    "the dimension of the state space at depth @xmath47 in @xmath248 is denoted @xmath250 .",
    "thus , @xmath251 . for @xmath165 , we denote by @xmath252 the dimension of the branch space between the state spaces at depths @xmath47 and @xmath253 ; then , @xmath254 .",
    "the following definitions were made in @xcite for @xmath255 :    * if @xmath256 } ) = \\dim(\\cc_{[i-1,n-1 ] } ) - 1 $ ] , then @xmath47 is called a _ point of gain _ of @xmath0 ; and * if @xmath257 } ) = \\dim(\\cc_{[0,i-1 ] } ) + 1 $ ] , then @xmath47 is called a _ point of fall _ of @xmath0 .    as per our notation from section  [ sec : rm ] , @xmath258 denotes the @xmath140-bit binary representation of @xmath47 , @xmath255 .",
    "let @xmath259 and @xmath260 denote the number of @xmath261s and @xmath262s , respectively , in @xmath258 .    for @xmath255 ,    *",
    "@xmath47 is a point of gain of @xmath0 iff @xmath263 ; * @xmath47 is a point of fall of @xmath0 iff @xmath264 .",
    "[ bn_lemma ]    _ proof of proposition  [ app_prop1]_.  it is a fact that for any minimal trellis representation , branch complexity either is equal to the state complexity or is exactly one more than the state complexity . in particular , @xmath265 .",
    "so , to prove proposition  [ app_prop1 ] , it suffices to show that @xmath266    suppose that @xmath267 for some @xmath268 $ ] . from the local behaviour of @xmath248 described in @xcite",
    ", it follows that we can have @xmath269 iff @xmath270 and @xmath253 is a point of gain as well as a point of fall of @xmath0 .",
    "thus , if @xmath271 , then by lemma  [ bn_lemma ] , @xmath272 .",
    "this proves the `` only if '' direction of ( [ app_eq1 ] ) .",
    "conversely , suppose @xmath273 .",
    "the proposition is clearly true if @xmath274 , since @xmath275 , and we have @xmath276 and @xmath277 .",
    "so , we may assume @xmath278 .",
    "take @xmath47 to be such that @xmath279 , with @xmath280 .",
    "then , by theorem  2.11 in @xcite , @xmath270 . also , @xmath281 , with @xmath282 and @xmath283 .",
    "hence , by lemma  [ bn_lemma ] , @xmath253 is a point of gain as well as a point of fall of @xmath0 .",
    "hence , @xmath269 , which completes the proof of ( [ app_eq1 ] ) , and hence , of proposition  [ app_prop1 ] .",
    "we next present the algebraic manipulations needed to prove proposition  [ prop : srm ] .",
    "_ proof of proposition  [ prop : srm]_.   we divide the proof into three cases .    .",
    "we have @xmath284 \\\\ & \\stackrel{(a)}{= } & \\sum_{j=1}^r \\sum_{i=0}^{2(r - j ) } \\binom{m-1-i}{j-1 } \\\\ & \\stackrel{(b)}{= } & \\sum_{i=0}^{2(r-1 ) } \\sum_{j=1}^{r-\\lceil{i/2}\\rceil } \\binom{m-1-i}{j-1 } \\\\ & = & \\sum_{i=0}^{2(r-1 ) } k(r-1-\\lceil{i/2}\\rceil , m-1-i).\\end{aligned}\\ ] ] in the above chain of equalities , equality  ( a ) uses the fact that for integers @xmath285 and @xmath286 , we have @xmath287 ; this is just repeated application of the identity @xmath288 .",
    "( b ) is obtained by exchanging the order of the summations in @xmath47 and @xmath289 .    .  here , @xmath290,\\end{aligned}\\ ]",
    "] and now we carry on from equality  ( a ) of case  1 .    .",
    "this is the most tedious case .",
    "we start with @xmath291   \\notag \\\\ & = & \\sum_{j=1}^{2r - m } \\binom{m}{j }        + \\sum_{j=2r - m+1}^r \\sum_{i=0}^{2(r - j ) } \\binom{m-1-i}{j-1 } \\notag \\\\ & = &   \\sum_{j=1}^{2r - m } \\binom{m}{j }        + \\sum_{i=0}^{2(m - r-1 ) } \\sum_{j=2r - m+1}^{r-\\lceil{i/2}\\rceil } \\binom{m-1-i}{j-1}. \\label{case3_eq1}\\end{aligned}\\ ] ] now , for @xmath286 , write @xmath292 .",
    "hence , @xmath293 also , @xmath294 as when @xmath295 , we have @xmath296 , so that the inner summation @xmath297 is empty . plugging ( [ case3_eq2 ] ) and ( [ case3_eq3 ] ) into ( [ case3_eq1 ] )",
    ", we find that @xmath298 this completes the proof of proposition  [ prop : srm ] .",
    "we recast the statement of lemma  [ lemma : u_ineq ] into an equivalent statement about binary representations of integers . from ( [ eq : std_bit_order ] ) and the notion of points of fall from @xcite ( see appendix  a ) , we see that for @xmath299 , @xmath300 is equal to the number of points of fall of @xmath153 within the interval @xmath301 $ ] .",
    "thus , by lemma  [ bn_lemma ] , @xmath300 is equal to the number of integers in @xmath301 $ ] whose @xmath140-bit binary representations have at least @xmath302 @xmath262s .    for an integer",
    "@xmath303 $ ] , let @xmath304 denote the hamming weight of ( i.e. , the number of 1s in ) the binary representation @xmath305 . for a subset",
    "@xmath306 $ ] , let @xmath307 denote the number of integers @xmath308 with @xmath309 .",
    "we set @xmath310 .",
    "then , lemma  [ lemma : u_ineq ] is equivalent to the following assertion : for @xmath311 $ ] and @xmath312 $ ] , we have @xmath313 )    + w_{m - r}([\\beta - j,\\beta-1 ] )    \\ge w_{m - r}([1,i+j ] ) .",
    "\\label{appb_eq1}\\ ] ] since lemma  [ lemma : u_ineq ] needs to be shown for any @xmath153 with @xmath314 , we see that ( [ appb_eq1 ] ) must be shown for any @xmath315 . with this in mind",
    ", we define for @xmath306 $ ] , @xmath316.\\ ] ] as usual , we will drop the superscript @xmath317 when it can be gleaned unambiguously from the context .    for @xmath318 and @xmath319",
    ", we have @xmath320 )    + \\w^{(m)}([\\beta^{(m)}-j,\\beta^{(m)}-1 ] )    \\ge \\w^{(m)}([1,i+j ] ) , \\label{eq : w_ineq}\\ ] ] with the inequality above holding componentwise . [ appb_prop ]",
    "observe that this proposition is slightly stronger than lemma  [ lemma : u_ineq ] , since the latter only requires @xmath321 .",
    "it is easy to verify that @xmath322 .",
    "the remainder of this appendix is devoted to a proof of proposition  [ appb_prop ] .",
    "the proof is by induction on @xmath140 , which is why we have taken care to include the superscripts on @xmath226 and @xmath323 in the statement of the proposition .",
    "the main ingredients in the inductive proof are the simple facts that for a non - negative integer @xmath289 , @xmath324 and @xmath325 .",
    "the rest is merely careful bookkeeping .",
    "let @xmath326 denote the inequality in ( [ eq : w_ineq ] ) .",
    "the induction argument is built upon certain implications among the @xmath326 , as stated in the series of lemmas below .",
    "we introduce here some notation that we will use in the proofs of these lemmas . for a set of integers @xmath327",
    ", we write @xmath328 and @xmath329 to mean the sets @xmath330 and @xmath331 , respectively . by @xmath332}$ ] , with @xmath333 , we mean the vector @xmath334 $ ] , with @xmath335 for @xmath336 , and @xmath337 otherwise .",
    "again , we will drop the superscript @xmath317 when there is no ambiguity .    for even @xmath140",
    ", @xmath326 implies @xmath338 . for odd @xmath140",
    ", @xmath326 implies @xmath339 .",
    "[ lem:1 ]    for even @xmath140 , we have @xmath340 , and @xmath341 . set @xmath342 $ ] and @xmath343 $ ] .",
    "now , @xmath326 implies @xmath344 )    \\label{eq : lem1.1 }   \\\\",
    "\\w^{(m+1)}(2s+1)+\\w^{(m+1)}(2t+1 )    & \\ge & \\w^{(m+1)}(2[1,i+j]+1 )    \\label{eq : lem1.2}\\end{aligned}\\ ] ] since @xmath324 and @xmath325 for any non - negative integer @xmath289 . henceforth , all the @xmath345 s in this proof are @xmath346 s . combining ( [ eq : lem1.1 ] ) and ( [ eq : lem1.2 ] ) , we have @xmath347 )   + \\mathbf{w}([2\\beta^{(m)}-2j,2\\beta^{(m)}-1 ] ) \\ge \\mathbf{w}([2,2i+2j+1]),\\ ] ] which is the same as @xmath348 )   + \\mathbf{w}([\\beta^{(m+1)}-2j,\\beta^{(m+1)}-1])\\ge\\mathbf{w}([2,2i+2j+1]).\\ ] ] now , @xmath349)=\\mathbf{w}([2,2i+2j+1])+\\1^{(m+1)}_{[1,1]}$ ] .",
    "also , @xmath350 ) = \\mathbf{w}([\\alpha^{(m+1)}-2i-1,\\alpha^{(m+1)}-2])+\\1^{(m+1)}_{[1,m/2]}$ ] , since @xmath351 , by ( [ eq : binary_alpha ] ) . therefore ,",
    "@xmath352)+\\w([b^{(m+1)}-2j , b^{(m+1)}-1 ] )     \\ge \\w([1,2i+2j+1]),\\ ] ] which is @xmath338 .    the proof for odd @xmath140 is along similar lines .",
    "* when @xmath353 is even , the two inequalities @xmath326 and @xmath354 together imply @xmath355 .",
    "* when @xmath356 is even , the two inequalities @xmath326 and @xmath357 together imply @xmath358 .",
    "[ lem:2 ]    we only prove ( a ) , as the proof of ( b ) is completely analogous . in this proof ,",
    "all omitted superscripts are to be taken to be @xmath317 .",
    "let @xmath359 and @xmath360 .",
    "we have @xmath361 ) = \\w([\\alpha - i,\\alpha-1 ] ) + \\1_{[1,x]}$ ] , and @xmath362 ) = \\w([1,i+j ] ) + \\1_{[1,y]}$ ] .",
    "we want to show @xmath355 : @xmath363 ) + \\1_{[1,x ] } + \\w([\\beta - j,\\beta-1 ] )   \\ge \\w([1,i+j ] ) + \\1_{[1,y]}.\\ ] ]    if @xmath364 , then @xmath326 clearly implies ( [ eq : lem2.1 ] ) .",
    "so , suppose @xmath365 .",
    "then , ( [ eq : lem2.1 ] ) becomes @xmath366 ) + \\w([\\beta - j,\\beta-1 ] )   \\ge \\w([1,i+j ] ) + \\1_{[x+1,y]},\\ ] ] or equivalently , @xmath367 ) + w_l([\\beta - j,\\beta-1 ] )   \\ge   \\begin{cases } w_l([1,i+j ] ) + 1 & \\text { if } x+1 \\le l \\le y \\\\ w_l([1,i+j ] ) & \\text { otherwise}. \\end{cases}\\ ] ]    let @xmath368 and @xmath369 . since @xmath370 is even , we see that @xmath371 or @xmath372 .",
    "now , we have @xmath373)&=&\\w([\\alpha - i,\\alpha-1])+\\1_{[1,x]}+\\1_{[1,x ' ] } \\\\ \\label{eq : lem2.4 }    \\w([1,i+j+2])&=&\\w([1,i+j])+\\1_{[1,y]}+\\1_{[1,y']}\\end{aligned}\\ ] ] thus , @xmath354 is equivalent to @xmath374)+\\1_{[1,x ' ] } + \\w([\\beta - j,\\beta-1 ] )   \\ge \\w([1,i+j ] ) + \\1_{[x+1,y]}+\\1_{[1,y']}.\\ ] ] using the fact that @xmath372 , ( [ eq : lem2.5 ] ) implies that for @xmath375 , @xmath376 ) + w_l([\\beta - j,\\beta-1 ] ) \\ge w_l([1,i+j ] ) + 1.\\ ] ] since @xmath326 clearly implies the `` otherwise '' part of ( [ eq : lem2.2 ] ) , we have shown that @xmath326 and @xmath354 together imply ( [ eq : lem2.2 ] ) , i.e. , @xmath355 .    for even @xmath140 , the following implications hold :    * @xmath377 ; * @xmath378 ; * @xmath379 ; * @xmath380 .    [ lem:3 ]",
    "\\(a ) follows directly from lemma  [ lem:1 ] .",
    "( b ) : if @xmath381 and @xmath326 are true , then by lemma  [ lem:1 ] , we have @xmath382 and @xmath338 being true . since @xmath383 is odd , @xmath384 is odd ( see ( [ eq : binary_alpha ] ) ) .",
    "it now follows from lemma  [ lem:2](a ) that @xmath385 holds .",
    "( c ) : this follows by an argument similar to part  ( b ) , except that lemma  [ lem:2](b ) is applied .",
    "( d ) : by part  ( b ) , @xmath385 and @xmath386 hold . therefore , by lemma  [ lem:2](b ) , @xmath339 holds .",
    "arguments similar to those used in the above proof show the next result .    for odd @xmath140 ,",
    "the following implications hold :    * @xmath387 ; * @xmath388 ; * @xmath389 ; * @xmath390 .",
    "[ lem:4 ]    we are now in a position to prove proposition  [ appb_prop ] .    _ proof of proposition  [ appb_prop]_.  set @xmath391 .",
    "we wish to show that for @xmath318 , @xmath326 holds for @xmath392 .",
    "it is easy to verify this directly for @xmath393 and @xmath394 , so we start the induction by assuming that for some odd @xmath190 , @xmath326 holds for @xmath392 .    for odd @xmath140 , the implications in lemma  [ lem:4 ]",
    "are enough to show that @xmath395 holds for @xmath396 and @xmath397 .",
    "note also that for odd @xmath140 , we have @xmath398 , as can be verified from ( [ eq : alpha ] ) . since @xmath399 , @xmath400 and @xmath401 trivially hold , we have that @xmath395 holds for @xmath402 and @xmath403 .",
    "now , @xmath383 is even , and we have shown above that @xmath395 is true for @xmath402 and @xmath403 .",
    "the implications in lemma  [ lem:3 ] are then sufficient to show that @xmath404 holds for @xmath405 .",
    "again , @xmath406 , @xmath407 and @xmath408 can be seen to hold trivially , so @xmath404 in fact holds for @xmath409 .",
    "this completes the induction step , since for even @xmath383 , it follows from ( [ eq : alpha ] ) that @xmath410 .",
    "as observed earlier , proposition  [ appb_prop ] proves lemma  [ lemma : u_ineq ] .",
    "to derive the expressions in ( [ us_eq1])([us_eq3 ] ) , we make use of ( [ eq : u_s ] ) and a result of wei @xcite that explicitly determines the generalized hamming weight hierarchy of @xmath153 .",
    "any non - negative integer @xmath411 can be uniquely expressed as a sum @xmath412 where @xmath413 , @xmath414 , and for all @xmath47 , @xmath415 ( * ? ? ?",
    "* lemma  2 ) .",
    "the above representation is called the _ @xmath144-canonical representation _ of @xmath416 .    for @xmath417 ,",
    "given the unique @xmath144-canonical representation of @xmath416 as in ( [ eq : canonical ] ) , we have @xmath418 .",
    "[ thm : wei ]    for convenience , we will henceforth write @xmath419 simply as @xmath420 .",
    "assume that @xmath183 .",
    "we want to show that ( [ us_eq1 ] ) holds .",
    "we will only prove here the result for @xmath421 , as the result for @xmath422 can be proved analogously .",
    "let @xmath423 be the integer given by @xmath424 note that the above is the @xmath144-canonical representation of @xmath423 . by theorem  [ thm : wei ]",
    ", we have @xmath425 . in binary form , @xmath426 , the number of 1s in @xmath427 being @xmath141 . comparing this with the binary form of @xmath226 given in ( [ eq : binary_alpha ] )",
    ", it is clear that @xmath428 .",
    "next , write @xmath429 as @xmath430 using the fact that @xmath431 .",
    "this is again in @xmath144-canonical form , and hence by theorem  [ thm : wei ] , we have @xmath432 . in binary form",
    ", this is @xmath433 @xmath434 , the number of 1s here being @xmath435 . comparing with ( [ eq : binary_alpha ] )",
    ", we see that @xmath436 .    since @xmath437 , we have by ( [ eq : u_s ] ) , @xmath438 .",
    "observe that @xmath423 as given by ( [ eq : hu ] ) is precisely equal to the claimed value of @xmath240 in ( [ us_eq1 ] ) .",
    "now , assume @xmath242 .",
    "we wish to show ( [ us_eq2 ] ) and ( [ us_eq3 ] ) .",
    "we sketch the proof for ( [ us_eq3 ] ) here ; the proof for ( [ us_eq2 ] ) is similar . set @xmath439",
    "the above is the @xmath144-canonical representation of @xmath440 , and hence , @xmath441 comparing @xmath442 with @xmath443 given in ( [ eq : binary_beta ] ) , it can be seen that @xmath444 .    the @xmath144-canonical representation of @xmath445 is given by @xmath446 again , @xmath447 can be obtained from theorem  [ thm : wei ] , and the subsequent comparison of binary forms shows that @xmath448 .",
    "hence , by ( [ eq : u_s ] ) , we have @xmath449 , which proves ( [ us_eq3 ] ) .",
    "a.  thangaraj thanks rakesh pokala for several helpful discussions .",
    "t.  kasami , t.  takata , t.  fujiwara , and s.  lin , `` on the optimum bit orders with respect to the state complexity of trellis diagrams for binary linear codes , '' _ ieee trans .  inform .",
    "theory _ , vol .",
    "39 , no .  1 ,",
    "pp .  242245 , jan ."
  ],
  "abstract_text": [
    "<S> the constraint complexity of a graphical realization of a linear code is the maximum dimension of the local constraint codes in the realization . </S>",
    "<S> the treewidth of a linear code is the least constraint complexity of any of its cycle - free graphical realizations . </S>",
    "<S> this notion provides a useful parametrization of the maximum - likelihood decoding complexity for linear codes . in this paper </S>",
    "<S> , we prove the surprising fact that for maximum distance separable codes and reed - muller codes , treewidth equals trelliswidth , which , for a code , is defined to be the least constraint complexity ( or branch complexity ) of any of its trellis realizations . from this , we obtain exact expressions for the treewidth of these codes , which constitute the only known explicit expressions for the treewidth of algebraic codes . </S>"
  ]
}