{
  "article_text": [
    "imagine a number of processes all need to use a particular resource for a period of time .",
    "each process @xmath4 specifies a starting time @xmath5 and a finishing time @xmath6 between which it needs to continuously occupy the resource .",
    "the resource can not be shared by two processes at any instance .",
    "one is required to design a scheduler which chooses a subset of these processes so that 1 )  there is no time conflict between processes in using the resource ; and 2 )  there are as many processes as possible that get chosen .",
    "the above is a typical set - up for the interval scheduling problem , one of the basic problems in the study of algorithms .",
    "formally , given a collection of intervals on the real line specified by their starting and finishing times , the problem asks for a subset of maximal size consisting of pairwise non - overlapping intervals .",
    "the interval scheduling problem and its variants appear in a wide range of areas in computer science and applications such as in logistics , telecommunication , and manufacturing .",
    "they form an important class of scheduling problems and have been studied under various names and with application - specific constraints  @xcite .",
    "the interval scheduling problem , as stated above , can be solved by a _",
    "greedy _ scheduler as follows  @xcite .",
    "the scheduler sorts intervals based on their finishing time , and then iteratively selects the interval with the least finishing time that is compatible with the intervals that have already been scheduled .",
    "the set of intervals chosen in this manner is guaranteed to have maximal size .",
    "this algorithm works in a _",
    "static _ context in the sense that the set of intervals is given a priori and it is not subject to change .    in a _ dynamic _ context",
    "the instance of the interval scheduling problem is usually changed by a real - time events , and a previously optimal schedule may become not optimal .",
    "examples of such real - time events include job cancelation , arrival of an urgent job , and change in job processing time . to avoid the repetitive work of rerunning the static algorithm every time when the problem instance has changed",
    ", there is a demand for efficient _ dynamic algorithms _ for solving the scheduling problem on the changed instances . in this dynamic context ,",
    "the set of intervals change through a number of _ update operations _ such as insertion or removal .",
    "our goal is to design algorithms that allow us to solve the interval scheduling problem in a dynamic setting .",
    "a natural setting for the problem is a special class of interval sets , which we call _ monotonic interval sets_. in a monotonic set no interval is properly contained by another interval .",
    "for example , if all processes require the same amount of time to be completed , then the set of intervals is monotonic .",
    "moreover , monotonic interval sets are closely related to proper interval graphs .",
    "an _ interval graph _ is an undirected graph whose nodes are intervals and two nodes are adjacent if the two corresponding intervals overlap .",
    "a _ proper interval graph _ is an interval graph for a monotonic set of intervals . there",
    "exist linear time algorithms for representing a proper interval graph by a monotonic set of intervals  @xcite .",
    "furthermore , solving the interval scheduling problem for monotonic intervals corresponds to finding a maximal independent set in a proper interval graph .      on a somewhat related work , s. fung ,",
    "c. poon and f. zheng  @xcite investigated an online version of interval scheduling problem for weighted intervals with equal length ( hence , the intervals are monotonic ) , and designed randomised algorithms .",
    "we also mention that r. lipton and a. tompkins  @xcite initiated the study of online version of the interval scheduling problem . in this version a set of intervals are presented to a scheduler in order of start time . upon seeing each interval",
    "the algorithm must decide whether to include the interval into the schedule .    a related problem on a set of intervals @xmath7 asks to find a minimal set of points @xmath8 such that every interval from @xmath7 contains at least one point from @xmath8 .",
    "such a set @xmath8 is called a _ piercing set _ of @xmath7 . a dynamic algorithm for maintaining a minimal piercing set @xmath8",
    "is studied in @xcite .",
    "the dynamic algorithm runs in time @xmath9 .",
    "we remark here that if one has a maximal set @xmath10 of disjoint intervals in @xmath7 , one can use @xmath10 to find a minimal piercing set of @xmath7 , where each point in the piercing set corresponds to the finishing time of an interval in @xmath10 in time @xmath11 .",
    "therefore our dynamic algorithm can be adapted to one that maintains a minimal piercing set .",
    "our algorithm improves the results in @xcite when the interval set @xmath7 is monotonic .",
    "kaplan et al . in @xcite studied a problem of maintaining a set of nested intervals with priorities .",
    "the problem asks for an algorithm that given a point @xmath12 finds the interval with maximal priority containing @xmath12 .",
    "similarly to our dynamic algorithm , the solution in @xcite also uses dynamic trees to represent a set of intervals .",
    "for the monotonic case , we provide two dynamic algorithms solving the interval scheduling problem .",
    "the first algorithm has @xmath13 amortised complexity for update operations and @xmath0 amortised complexity for the query operations .",
    "the second algorithm improves the complexity of update operations to @xmath0 amortised . for the general case , we extend the first algorithm .",
    "the complexity of the query operation remains the same , while the complexity of the update operation increases by the factor of @xmath3 , where @xmath3 is the maximal number of overlapping intervals .",
    "formal explanation are in the next sections .",
    "the first algorithm maintains the _ compatibility forest _ data structure denoted by @xmath14 .",
    "we say the _ right compatible interval _ of an interval @xmath4 is the interval @xmath15 such that @xmath16 and there does not exist an interval @xmath17 such that @xmath18 and @xmath19 .",
    "the @xmath14 data structure maintains the right compatible interval relation .",
    "the implementation of the data structure utilises , nontrivially , the dynamic tree data structure of sleator and tarjan @xcite . as a result , in * theorem  [ thm : cf - amortized - time ] * and * theorem  [ thm : cf - gen - amortized - time ] * we prove the amortised bounds for the monotonic and non - monotonic interval sets respectively .",
    "the second dynamic algorithm maintains the _ linearised tree _ data structure denoted by @xmath20 .",
    "we say that intervals are _ equivalent _ if their right compatible intervals coincide .",
    "the @xmath20 data structure maintains both the right compatibility relation and the equivalence relation.then , in * theorem  [ thm : lt - amortized - time ] * of section  [ sec : lt ] we prove that the insertion , removal and query operations take time amortised @xmath0 .",
    "however , this comes with a cost . as opposed to the @xmath14 data structure that keeps a representation of an optimal set after each update operation",
    ", the linearised tree data structure does not explicitly represent the optimal solution .    to test the performance of our algorithms for the monotonic interval sets",
    ", we carried out experiments on random sequences of update and query operations .",
    "the experiments show that the two data structures @xmath14 and @xmath20 perform similarly .",
    "the reason for this is that the first dynamic algorithm based on @xmath14 reaches the bound of @xmath21 only on specific sequences of operations , while on uniformly random sequences the algorithm may run much faster .",
    "_ organisation of the paper .",
    "_ section  [ sec : pre ] introduces the problem and monotonic interval sets .",
    "section  [ sec : cf ] describes the compatibility forest data structure and algorithms for monotonic and non - monotonic interval sets .",
    "section  [ sec : lt ] describes the linearsed tree data structures and present our second dynamic algorithm , which is based on the linearised tree .",
    "section  [ sec : ex ] discusses the experiments .",
    "_ interval scheduling basics .",
    "_ an _ interval _ is a pair @xmath22 with @xmath23 , where @xmath5 is the _ starting time _ and @xmath6 is the _ finishing time _ of the interval .",
    "we abuse notation and write @xmath4 for the interval @xmath24 .",
    "two intervals @xmath4 and @xmath15 are _ compatible _ if @xmath16 or @xmath25 . otherwise , these two intervals _ overlap_. given a collection of intervals @xmath26 , a _",
    "compatible set _ of @xmath7 is a subset @xmath27 such that the intervals in @xmath10 are pairwise compatible . an _ optimal set _ of @xmath7 is a compatible set of maximal size .",
    "the _ interval scheduling problem _ consists of designing an algorithm that finds an optimal set .",
    "we recall the greedy algorithm that solves the problem @xcite .",
    "the algorithm sorts intervals by their finishing time , and then iteratively chooses the interval with the least finishing time compatible with the last selected interval .",
    "the set of thus selected intervals is optimal .",
    "the algorithm takes @xmath28 worst - case time where @xmath2 is the size of @xmath7 .",
    "if the sorting is already given then the algorithm runs in linear time .",
    "below , we formally define the greedy optimal set found by this greedy algorithm .",
    "let @xmath29  be the ordering of the intervals by their finishing time . throughout , by the _",
    "least interval _ , the _ greatest interval _ , the _ next interval _",
    ", the _ previous interval _ , we mean the least , greatest , next and previous interval with respect to @xmath29 . without loss of generality",
    "we may assume that the intervals in @xmath7 have pairwise distinct finishing times .",
    "given the collection @xmath7 , we inductively define the set @xmath30 , the _ greedy optimal set _ of @xmath7 , as follows .",
    "the interval @xmath31 is the least interval in @xmath7 .",
    "the interval @xmath32 is the least interval compatible with @xmath33 such that @xmath34 .",
    "the set @xmath10 obtained this way is an optimal set @xcite .",
    "the set @xmath7 of intervals is called _ monotonic _ if no interval in @xmath7 contains another interval .",
    "right compatible interval _ of @xmath4 , denoted by @xmath35 , is the least interval @xmath15 compatible with @xmath4 such that @xmath36 .",
    "similarly , the _ left compatible interval _ of @xmath4 , written @xmath37 , is the greatest interval @xmath15 compatible with @xmath4 such that @xmath38 .      _",
    "binary search tree .",
    "_ a _ binary search tree _ is a standard data structure that maintains a linearly ordered collection of records .",
    "the data structure supports the operations @xmath39 where @xmath40 is a binary search tree and @xmath41 is an element from the domain . if a binary search tree is balanced , the complexity of all the above operations is @xmath0 where @xmath2 is the number of elements in the collection .",
    "we point out that there are well - known self - balancing binary search tree data structures such as avl tree and red - black tree",
    ".    _ splay tree . _ a _ splay tree _ is also a self - balancing binary search tree for storing linearly ordered objects .",
    "in addition to the operations for binary search trees , the splay tree data structure also supports the following operations .",
    "* @xmath42 : this operation reorganises a splay tree so that @xmath41 becomes the root .",
    "* @xmath43 : this operation joins two splay trees @xmath44 into one splay tree , where any interval in @xmath45 is less than any interval in @xmath46 , into one tree . *",
    "@xmath47 : this operation splits the splay tree @xmath45 of @xmath41 into two new splay trees @xmath48    all the operations for splay trees take @xmath0 amortised time  @xcite .    _ dynamic trees . _",
    "a dynamic tree data structure maintains a collection of objects that are stored in a number of rooted trees , viewed as directed graphs with edges pointing from children to parents .",
    "the trees can be manipulated using the following operations :    * @xmath49 : if @xmath50 is the root of a tree and @xmath41 is a node in another tree , add an edge from @xmath50 to @xmath41 and thus `` link '' the trees containing @xmath50 and @xmath41 together . *",
    "@xmath51 : if @xmath50 is not the root of a tree , delete the edge from @xmath50 to its parent and thus divide the tree containing @xmath50 into two .",
    "these operations have @xmath0 amortised time complexity  @xcite .      in this setting the collection @xmath7 of intervals changes over time .",
    "thus , the input to the problem is an arbitrary sequence @xmath52 of update and query operations described as follows :    * _ update operations _ : @xmath53 inserts an interval @xmath4 and @xmath54 removes an interval @xmath4 .",
    "* _ query operation _",
    ": the operation @xmath55 returns true if @xmath4 belongs to the greedy optimal set and false otherwise .",
    "our goal is to design algorithms for performing these operations that minimise the total running time .",
    "in this section we define compatibility forest and describe how to maintain efficiently maintain it for a set of intervals .",
    "we first show how to represent a monotonic set , and then we extend the algorithms for the general case .",
    "let @xmath7 be a set of intervals .",
    "we define the _ compatibility forest _ as a graph @xmath56 where @xmath57 and @xmath58 if @xmath59 . by a forest",
    "we mean a directed graph where the edge set contains links from nodes to their parents .",
    "we denote the parent of a node @xmath50 by @xmath60 .",
    "the _ roots _ and _ leaves _ are standard notions that we do not define .",
    "figure  [ fig : compat ] shows an example of a monotonic set of intervals with its compatibility forest .",
    "we note that for every forest one can construct in a linear time a monotonic set of intervals whose compatibility forest coincides ( up to isomorphism ) with the forest .",
    "( 0.5,3 ) ",
    "( 3,3 ) node @xmath61 ; ( 1,2 )  ( 4,2 ) node @xmath62 ; ( 1.5,1 )  ( 6,1 ) node @xmath63 ; ( 2,0 )  ( 7.2,0 ) node @xmath3 ;    ( 4.5,3 ) ",
    "( 8,3 ) node @xmath64 ; ( 5.0,2 )  ( 9,2 ) node @xmath65 ; ( 6.8,1 )  ( 11,1 ) node @xmath66 ;    ( 10,3 )  ( 12,3 ) node @xmath67 ;    \\(g ) @xmath66 child node @xmath63 ;    \\(h ) [ right=15",
    "mm ] @xmath67 child node @xmath3 child node @xmath64 child node @xmath61 child node @xmath62 child node @xmath65 ;    a _ path _ in the compatibility forest @xmath68 is a sequence of nodes @xmath69 where @xmath70 for any @xmath71 .",
    "it is clear that any path in the forest @xmath68 consists of compatible intervals .",
    "essentially , the forest @xmath68 connects nodes by the greedy rule : for any node @xmath4 in the forest @xmath68 , if the greedy rule is applied to @xmath4 , then the rule selects the parent @xmath15 of @xmath4 in the forest .",
    "hence , the longest paths in the compatibility forest correspond to an optimal sets of @xmath7 .",
    "in particular , the path starting from the least interval is the greedy optimal set",
    ". our first dynamic algorithm amounts to maintaining this path in the forest @xmath68 .",
    "we explain how we maintain paths in the compatibility forest @xmath68 .",
    "the representation of the forest is developed from the dynamic tree data structure as in  @xcite .",
    "the idea is to partition the compatibility forest into a set of node - disjoint paths .",
    "paths are defined by two types of edges , _ solid edges _ and _ dashed edges_. each node in the compatibility forest is required to have at most one incoming solid edge . a sequence of edges @xmath72 where each @xmath73 is a solid edge",
    "is called a _",
    "solid path_. a solid path is _ maximal _ if it is not properly contained in any other solid path .",
    "therefore , the solid edges in @xmath68 form several maximal solid paths in the forest .",
    "furthermore , the data structure ensures that each node belongs to some maximal solid path .",
    "there is an important subroutine in the dynamic tree data structure called the _",
    "operation  @xcite .",
    "the operation starts from a node @xmath50 and traverses the path from @xmath50 to the root : while traversing , if the edge @xmath74 is dashed , we declare @xmath75 solid and declare the incoming solid edge ( if it exists ) incident to @xmath76 dashed . thus , after exposing node @xmath50 , all the edges on the path from @xmath50 to the root become solid .",
    "note that in @xmath14 data structure the @xmath76 and @xmath77 are the same .",
    "we denote the representation of @xmath68 for the monotonic interval set by @xmath78 .",
    "the representation consists of two components .",
    "the first is a binary search tree @xmath79 .",
    "the nodes of @xmath79 are intervals in @xmath7 ordered by their starting time .",
    "note that monotonicity of @xmath7 implies that the order of intervals in @xmath79 coincide with @xmath29 , order of intervals by their finishing time .",
    "in addition to standard operations of binary search trees , we define the @xmath80 operation .",
    "given an interval , @xmath4 the operation returns @xmath35 , if it is in @xmath7 , or @xmath81 , otherwise .",
    "the second component is a set of splay trees .",
    "each splay tree stores the nodes of a maximal solid path in the compatibility forest @xmath68 we denote by @xmath82 the splay tree containing the interval  @xmath4 .",
    "@xmath83 @xmath84 the root in the interval tree @xmath79 .",
    "@xmath84 the right child of @xmath15 @xmath85 @xmath84 the left child of @xmath15 * return *",
    "@xmath86    [ lem : rc ] on monotonic set @xmath7 of intervals the operation @xmath87 run in time @xmath88 and return @xmath35 .    to prove the lemma we observe that for a monotonic set @xmath7 of intervals and @xmath89 , if @xmath4 overlaps @xmath15 , then each of the intervals between @xmath4 and @xmath15 overlaps both @xmath4 and @xmath15 .    for the complexity , note that the length of paths from a leaf to the root in @xmath79 is @xmath90 .",
    "thus , the operation takes time @xmath88 .    for the correctness , we use the following loop invariant :    initially , @xmath15 is the root of @xmath79 , so the invariant holds .",
    "each iteration of the * while * loop executes either line 5 or lines 7 - 8 of alg .",
    "[ alg : rc ] .",
    "if line 5 is executed , then we have @xmath91 or @xmath15 overlaps @xmath4 . if @xmath91 then all intervals in the left subtree of @xmath15 are less than @xmath4",
    ". if @xmath92 but @xmath15 overlaps @xmath4 , then by the observation above , all intervals between @xmath4 and @xmath15 overlap @xmath4 . in both cases ,",
    "none of the intervals in the left subtree of @xmath15 is @xmath35 . therefore setting @xmath15 to be the right child of @xmath15 preserves the invariant .",
    "if lines 7 - 8 are executed , then we have @xmath92 and @xmath15 is compatible with @xmath4 .",
    "if there exists an interval that is less than @xmath15 and compatible with @xmath4 , then such an interval is in the left subtree of @xmath15 .",
    "if such an interval does not exist , @xmath15 is the smallest interval which is compatible with @xmath4 . therefore setting @xmath86 to be @xmath15 and @xmath15 to be the right child of @xmath15 preserves the invariant .",
    "thus , the algorithm outputs @xmath35 if it exists and outputs @xmath81 otherwise . indeed , the loop terminates when @xmath93 . hence if the set of intervals @xmath7 contains @xmath35 then @xmath94 .",
    "if @xmath7 does not contain @xmath35 then line 5 is executed at every iteration , so @xmath95 .",
    "we now describe algorithms for maintaining compatibility forest data structure .",
    "we call the algorithms @xmath96 , @xmath97 and @xmath98 for the query , insertion , and removal operations , respectively .    _",
    "the operation @xmath96 : _ to perform this operation on an interval @xmath4 , we first find in the interval tree @xmath79 the minimum element @xmath99 .",
    "we then check if @xmath4 belongs to the splay tree @xmath100 .",
    "we return @xmath101 if @xmath102 ; otherwise we return @xmath103 .",
    "@xmath104 @xmath105    _ the operation @xmath106 : _ to expose an interval @xmath4 , we find the maximum element @xmath15 in the splay tree @xmath82 .",
    "then find the right compatible interval @xmath107 .",
    "if @xmath108 does not exist ( that is , @xmath15 is a root in the compatibility forest ) , we stop the process . otherwise , @xmath109 is a dashed edge .",
    "we split the splay tree at @xmath108 into trees @xmath110 and @xmath111 and join @xmath82 with @xmath112 .",
    "we then repeat the process taking @xmath108 as  @xmath4 .",
    "@xmath113 @xmath114 @xmath115 @xmath116 @xmath117 @xmath114    _ the operation @xmath97 : _ to insert an interval @xmath4 , we add @xmath4 into the tree @xmath79",
    ". then we locate the next interval @xmath86 of @xmath4 in the ordering @xmath29 .",
    "if such @xmath86 exists , we access @xmath86 in the splay tree @xmath118 and find the interval @xmath15 such that @xmath119 is a solid edge . if such a @xmath15 exists and @xmath15 is compatible with @xmath4 , we delete the edge @xmath119 and create a new edge @xmath120 and declare it solid .",
    "we restore the longest path of the compatibility forest by exposing the least interval in @xmath79 .",
    "@xmath121 @xmath122 find the next interval of @xmath4 @xmath123 find a solid edge @xmath119 @xmath124 destroy the solid edge @xmath119 @xmath125    _ the operation @xmath98 : _ to delete an interval @xmath4 , we delete the incoming and outgoing solid edges of @xmath4 if such edges exist .",
    "we then delete @xmath4 from the tree @xmath79 .",
    "we restore the longest path of the @xmath14 by exposing the least interval in @xmath79 .",
    "@xmath126 delete @xmath4 from its splay tree @xmath82 @xmath127 delete @xmath4 from the interval tree @xmath79",
    "@xmath128    _ correctness .",
    "_ for correctness of operations , we use the following invariants .",
    "* every splay tree represents a maximal path formed from solid edges .",
    "* let @xmath99 be the least interval in @xmath7 .",
    "the splay tree @xmath100 contains all intervals on the path from @xmath99 to the root .",
    "note that ( a2 ) guarantees that the query operation correctly determines if a given interval @xmath4 is in the greedy optimal set .",
    "the next lemma shows that ( a1 ) and ( a2 ) are invariants indeed and that the operations correctly solve the dynamic monotonic interval scheduling problem .",
    "[ lem : cf - correct ] ( a1 ) and ( a2 ) are invariants of @xmath97 , @xmath98 , and @xmath96 .    for ( a1 )",
    ", first consider the operation of joining two splay trees @xmath45 and @xmath46 via the operation @xmath129 .",
    "let @xmath15 be the maximal element in @xmath45 and @xmath130 be the minimum element in @xmath46 . in this case",
    ", @xmath130 is obtained by the operation @xmath131 .",
    "it is clear that @xmath132 is an edge in the forest @xmath68 .",
    "next , consider the case when we apply @xmath133 into the splay tree @xmath45 . in this case",
    ", @xmath45 is @xmath134 where @xmath86 is the next interval of @xmath4 in @xmath7 .",
    "let @xmath15 be the previous interval of @xmath86 in the tree @xmath118 . by ( a1 )",
    ", before inserting @xmath4 , @xmath119 is an edge in @xmath68 and thus @xmath135 .",
    "note we only insert @xmath4 to @xmath134 when @xmath15 is compatible with @xmath4 . since @xmath136 , after inserting @xmath4 , @xmath4 becomes the new right compatible interval of @xmath15 .",
    "so , joining @xmath134 with @xmath4 preserves ( a1 ) . operations @xmath137 and @xmath138 do not create new edges in splay trees .",
    "thus , ( a1 ) is preserved under all operations .    for ( a2 ) , the @xmath129 operation terminates when it reaches a root of the compatibility forest . as a result",
    ", @xmath82 contains all nodes on the path from @xmath4 to the root .",
    "since @xmath128 is called at the end of both @xmath133 and @xmath137 operations , ( a2 ) is preserved under every operation .",
    "_ complexity .",
    "_ let @xmath2 be the number of intervals in @xmath7 . as discussed in section  [ sec : pre ] , all operations for the interval tree have @xmath0 worst case complexity , and all operations for splay trees have @xmath0 amortised complexity .",
    "the query operation , involves finding the minimum interval in @xmath79 and searching @xmath4 in a splay tree .",
    "hence , the query operation runs in amortised time @xmath0 . for each insert and remove operation ,",
    "we perform a constant number of operations on @xmath79 and the splay trees plus one @xmath106 operation .",
    "to analyse @xmath106 operation , define the size @xmath139 of an interval @xmath4 to be the number of nodes in the subtree rooted at @xmath4 in @xmath68 .",
    "call an edge @xmath140 in @xmath68 _ heavy _",
    "if @xmath141 , and _ light _ otherwise .",
    "it is not hard to see that this partition of edges has the following properties :    * every node has at most one incoming heavy edge . * every path in the compatibility forest consists of at most @xmath142 light edges .",
    "[ lem : cf - complex ] in a sequence of @xmath143 update operations , the total number of dashed edges , traversed by @xmath106 operation , is @xmath144 .",
    "the number of iterations in @xmath106 operation is the number of dashed edges in a path from the least interval to the root .",
    "a dashed edge is either heavy or light . from ( @xmath145 ) , there are at most @xmath142 light dashed edges in the path . to count the number of heavy dashed edges , consider the previous update operations .",
    "after deletion of @xmath4 , all children of @xmath4 become children of the next interval of  @xmath4 . after inserting @xmath4 ,",
    "the children of the next interval of @xmath4 that are compatible with @xmath4 become children of  @xmath4 .",
    "therefore , there are at most two path where an update operation transforms light dashed edges to heavy dashed edges .",
    "figure  [ fig : update ] illustrates these structural changes .",
    "since there are at most @xmath142 light dashed edges on each path , an update operations creates at most @xmath142 heavy dashed edges .",
    "execution of @xmath106 in an update operation creates at most @xmath142 heavy dashed edges from heavy solid edges .",
    "hence , the total number of heavy dashed edges created after @xmath143 update operations is @xmath144 .    , where @xmath15 is the next interval of @xmath4.,scaledwidth=100.0% ]    lemma  [ lem : cf - correct ] and lemma  [ lem : cf - complex ] give us the following theorem :    [ thm : cf - amortized - time ] the algorithms @xmath96 , @xmath97 and @xmath98 solve the dynamic monotonic interval scheduling problem .",
    "the algorithms perform insert interval and remove interval operations in @xmath13 amortised time and query operation in @xmath0 amortised time , where @xmath2 is the size of the set @xmath7 of intervals .",
    "* remark*. tarjan and sleator s dynamic tree data structure has amortised time @xmath0 for update and query operations . to achieve this ,",
    "the algorithm maintains dashed edges explicitly .",
    "their technique can not be adapted directly to @xmath14 because insertion or removal of intervals may result in redirections of a linear number of edges .",
    "an example is depicted on the figure  [ fig : update].therefore , more care should be taken ;  for instance , one needs to maintain dashed edges implicitly in @xmath79 and compute them calling @xmath80 operation .    in @xmath14 data structure",
    "there exists a sequence of @xmath143 update operations with @xmath146 total running time .",
    "consider a sequence which creates a set of @xmath147 intervals .",
    "we assume that @xmath148 , where @xmath149 .",
    "the first @xmath2 operations of the sequence are @xmath97 such that the resulted compatibility forest is a perfect binary tree @xmath150 , that is , each internal node of @xmath150 has exactly two children and the height of each leaf in @xmath150 is @xmath67 .",
    "the next @xmath151 operations starting form @xmath150 are pairs of @xmath97 followed by @xmath98 . at stage @xmath152",
    ", @xmath97 inserts an interval @xmath153 into @xmath154 producing the tree @xmath155 .",
    "the interval @xmath153 is such that in @xmath155 the path from @xmath153 to the root is of length @xmath156 and the path consists of dashed edges only .",
    "then , at stage @xmath157 we delete @xmath153 .",
    "this produces a tree @xmath158 which is a perfect binary tree of height @xmath67 .",
    "we repeat this @xmath151 times .",
    "we can select @xmath153 as desired since each perfect binary tree @xmath159 always has a path of length @xmath67 consisting of dashed edges only .",
    "therefore a sequence of @xmath143 such operations takes time  @xmath146 .      in this section ,",
    "we show how to maintain compatibility forest for a set of non - monotonic intervals . in this case",
    ", extra care should be taken when we insert interval @xmath4 that is covered by other intervals since @xmath4 may become the new right compatible interval for several overlapping intervals .",
    "the example in figure  [ fig : bad - insert ] shows such insertion .",
    "therefore , when we insert an interval @xmath4 , we need to find all intervals covering @xmath4 .",
    "( 0,1 )  + + ( 3 , 0 ) ; at + + ( @xmath160 ) @xmath61 ; ( 1,0 )",
    " + + ( 4 , 0 ) ; at + + ( @xmath161 ) @xmath62 ;     ( 4,1 )  + + ( 4 , 0 ) ; at + + ( @xmath162 ) @xmath63 ; ( 6,0 )  + + ( 3 , 0 ) ; at + + ( @xmath163 ) @xmath3 ;     ( 9.5,1 )  + + ( 2 , 0 ) ; at + + ( @xmath164 ) @xmath64 ;     ( 6.6,1.8 )",
    " + + ( 1 , 0 ) ; at + + ( @xmath165 ) @xmath4 ;    at ( 0,-0.5 ) ;    //in a/0/0 , b/2/0 , i/-2/2 , c/0/2 , d/2/2 , e/1/4 ( ) at ( , ) @xmath166 ;    \\(e ) edge[dashed ] ( i ) edge[dashed ]",
    "( d ) edge ( c ) ; ( c ) edge[gray , very thin ] ( a ) ; ( d ) edge[gray , very thin ] ( b ) ; ( i ) edge[dashed ] ( b ) edge[dashed ] ( a ) ;    we describe a new operation @xmath167 , which returns all intervals covering a given interval . to support this operation , we introduce the third component - an interval tree data structure . an _ interval tree _",
    "@xcite is a leaf - oriented balanced binary search tree where leaves store endpoints of the intervals in increasing order .",
    "intervals themselves are stored in the internal nodes as follows .",
    "for each internal node @xmath50 the set @xmath168 consists of intervals that contain the _ split point _ of @xmath50 and are covered by the _ range _ of @xmath50 .",
    "the split point of @xmath50 , denoted by @xmath169 , is a number such that the leaves of the left subtree of @xmath50 store endpoints smaller than @xmath169 , and the leaves of the right subtree of @xmath50 store endpoints greater than @xmath169 .",
    "the range of @xmath50 , denoted by @xmath170 , is defined recursively as follows .",
    "the range of the root is @xmath171 $ ] . for a node @xmath50 , where @xmath172 $ ] , the range of the left child of @xmath50 is @xmath173 $ ] , and the range of the right child of @xmath50 is @xmath174 $ ] .    to allow insertions and deletions of intervals in the interval tree , we represent it as a red - black tree @xmath175 . in a red - black tree , insertion or deletion of",
    "a node takes @xmath0 time plus the time for at most 3 rotations to restore the balance . when performing a rotation around an edge @xmath176 the sets @xmath168 and @xmath177 change .",
    "let the range of @xmath60 be @xmath178 $ ] .",
    "if @xmath50 is the left child , the range of @xmath60 after rotation becomes @xmath179 $ ] .",
    "if @xmath50 is the right child , the range of @xmath12 shortens at the other end and becomes @xmath180 $ ] .",
    "therefore all intervals in @xmath177 that intersects with @xmath169 must be moved to @xmath168 .",
    "note that ranges of other nodes are not affected .",
    "we represent @xmath168 with two binary search trees . the first tree @xmath181 stores intervals of @xmath168 sorted from left to right by their starting point .",
    "the second tree @xmath182 stores intervals of @xmath168 sorted from right to left by their finishing point . to move intervals from @xmath168 to @xmath183 ,",
    "we perform join and split operations on the trees representing these sets .",
    "thus in total we need @xmath0 time to insert or delete a node in @xmath175 .    to find all intervals covering interval @xmath4 we do the following .",
    "we walk down in the interval tree starting at the root . at every node @xmath50",
    ", we compare @xmath169 with @xmath5 and @xmath6 . if @xmath184 or @xmath185 , we respectively traverse the tree @xmath181 or @xmath182 from left to right and report all intervals that covers @xmath4 .",
    "we continue to the left or right child of @xmath50 respectively . otherwise , the split point @xmath169 intersect with @xmath4 .",
    "we traverse @xmath181 , report intervals covering @xmath4 .",
    "we terminate the search at this node , because @xmath4 intersects with ranges of both children of @xmath50 , namely @xmath186 and @xmath187 , and therefore can not be covered by any interval , fully contained in these ranges .",
    "formally , the operation is described in algorithm  [ alg : covered ] .",
    "@xmath188 @xmath189 root of @xmath175 @xmath190 @xmath189 right child of @xmath50 @xmath191 @xmath189 left child of @xmath50 add @xmath4 into @xmath8 @xmath192 @xmath8    another thing we need to take care of is the @xmath80 operation . since the set of intervals is not monotonic , the observation , essential for the proof of lemma  [ lem : rc ] , does not hold . namely , there might exists intervals @xmath193 and @xmath143 covered by @xmath15 such that @xmath4 intersects with @xmath15 , but @xmath4 is compatible with @xmath143 . to overcome this difficulty",
    ", we augment the search tree @xmath79 and the operation @xmath80 as follows . in every node @xmath50 of @xmath79",
    "we keep a pointer to the interval @xmath99 in the subtree rooted at @xmath50 with the smallest finishing time .",
    "it is not hard to check that these pointers can be updated after a rotation in constant time .",
    "therefore , maintenance of these pointers does not change the asymptotic complexity of operations on @xmath79 .    recall that when we search for the right compatible interval of @xmath4 in the monotonic set , we go to the left child of the current interval @xmath15 if @xmath194 and @xmath4 is compatible with @xmath15 . in a non - monotonic set ,",
    "we need to check if there is an interval @xmath143 that is covered by @xmath15 and hence compatible with @xmath4 .",
    "if such @xmath143 exists , it is in the right subtree of @xmath15 and we can access it in constant time using the pointers we described above . therefore ,",
    "if we go to the left child of @xmath195 , we remember an interval with the smallest finishing time among three intervals : the last remembered interval , an interval at @xmath195 or an interval with the smallest finishing time in the right subtree of  @xmath195 .",
    "for example , if we search for @xmath196 in the tree shown in figure  [ fig : rc_gen_example ] , we traverse the path @xmath197 and remember intervals @xmath198 one after another .",
    "( 2 , 4 )  ( 4.5 , 4 ) node @xmath62 ; ( 5 , 4 )  ( 8.2 , 4 ) node @xmath3 ; ( 8.5 , 4 )  ( 17 , 4 ) node @xmath66 ;    ( 1 , 3 )  ( 3 , 3 ) node @xmath61 ; ( 4 , 3 )  ( 10.5 , 3 ) node @xmath63 ; ( 11.5 , 3 )  ( 16 , 3 ) node @xmath4 ;    ( 6 , 1 )  ( 9.5 , 1 ) node @xmath64 ; ( 11 , 2 )  ( 14 , 2 ) node @xmath67 ; ( 14.5 , 2 ) ",
    "( 18 , 2 ) node @xmath143 ;    ( 6.5 , 2 )  ( 10 , 2 ) node @xmath65 ; ( 13.5 , 1 ) ",
    "( 15 , 1 ) node @xmath15 ;    at ( 2,0 ) ;    \\(g ) at ( 0,0 ) [ yshift=10 cm ] @xmath66 child node @xmath3 child node @xmath62 child node @xmath61 child node @xmath63 child node @xmath64 child [ missing ] child node @xmath65 child node @xmath15 child node @xmath67 child [ missing ] child node @xmath4 child node @xmath143 ;    we are now ready to describe the operations , that maintain a compatibility forest for a non - monotonic set of intervals .",
    "the query operation @xmath199 and the remove operation @xmath200 are identical to @xmath138 and @xmath137 respectively .",
    "the insert operation @xmath201 does the following .",
    "first , we add @xmath4 into the trees @xmath79 and @xmath175 .",
    "second , as in the monotonic case , we check is there exists a solid edge @xmath202 such that @xmath4 substitutes @xmath86 .",
    "namely , we search for @xmath86 such that : ( i ) @xmath203 , ( ii ) @xmath4 is not covered by @xmath86 , ( iii ) for every @xmath204 , @xmath17 covers @xmath4 . then",
    ", if there exist a solid edge from @xmath15 to @xmath86 and @xmath15 is compatible to @xmath4 , we make this edge dashed .",
    "third , for every interval , which covers @xmath4 , we make the incoming solid edge , if any , dashed . finally , we restore the longest path of the compatibility forest by exposing the @xmath29-least interval .",
    "algorithm  [ alg : cf - insert - gen ] describes the operation in details .",
    "@xmath121 @xmath205    @xmath206-next interval that does not cover @xmath4 @xmath123 find a solid edge",
    "@xmath119 @xmath124    @xmath207 @xmath208 @xmath209 @xmath29-least interval @xmath210    in a sequence of @xmath143 update operations , the total number of dashed edges , traversed by @xmath106 operation , is @xmath211 , where @xmath3 is the size of a maximal subset of pairwise overlapping intervals .",
    "the proof is similar to the proof of lemma  [ lem : cf - complex ] .",
    "recall , that an edge @xmath140 in the compatibility forest is heavy if the number of nodes in the tree rooted at @xmath4 is two times greater than the number of nodes in a tree rooted at @xmath15 .",
    "we count the number of heavy dashed edges created by the sequence of @xmath143 update operations .",
    "let @xmath212 be the interval after performing @xmath213 operations .",
    "we define @xmath3 as follows @xmath214    let @xmath4 be deleted or inserted interval . in the monotonic case , there is at most one interval that exchanges children with @xmath4 . here",
    "we need to take into account all the intervals @xmath215 , that covers @xmath4 .",
    "when we insert @xmath4 , all children of each @xmath216 becomes children of @xmath4 .",
    "when we delete @xmath4 , the children of @xmath4 are distributed among the intervals , covering @xmath4 .",
    "since there are at most @xmath3 such intervals , and every path from @xmath216 to the root has at most @xmath142 light dashed edges , an update operation creates at most @xmath217 heavy dashed edges .",
    "thus , in total @xmath106 operation traverses @xmath211 dashed edges in a sequence of @xmath143 operations .",
    "[ thm : cf - gen - amortized - time ] the algorithms @xmath218 , @xmath219 and @xmath220 solve the dynamic interval scheduling problem .",
    "the algorithms perform insert interval and remove interval operations in @xmath1 amortised time and query operation in @xmath0 amortised time , where @xmath2 is the size of the set @xmath7 of intervals and @xmath3 is the size of a maximal subset of pairwise overlapping intervals .",
    "in this section , we develop a new data structure for the dynamic interval scheduling problem .",
    "the dynamic algorithm based on this data structure performs all operations in amortised @xmath0 time .",
    "however , the algorithm requires the interval set to be monotonic at all times .",
    "we say that intervals @xmath4 and @xmath15 are _ equivalent _ , written as @xmath221 , iff @xmath222 .",
    "denote the equivalence class of @xmath4 by @xmath223 $ ] .",
    "thus , two intervals are in the same equivalence class if they are siblings in the compatibility forest . in the linearised tree",
    "we arrange all intervals in an equivalence class in a path using the @xmath29-order .",
    "the linearised tree consists of all such `` linearised '' equivalence classes joined by edges .",
    "hence , there are two types of edges in the linearised tree .",
    "the first type connects intervals in the same equivalence class .",
    "the second type joins the greatest interval in an equivalence class with its right compatible interval .",
    "formally , the _ linearised tree _",
    "@xmath224 is a triple @xmath225 , where @xmath226 and @xmath227 are disjoint set of edges such that :    * @xmath228 if and only if @xmath221 and @xmath4 is the previous interval of @xmath15 .",
    "call @xmath4 the _ equivalent child _ of @xmath15 . *",
    "@xmath229 if and only if @xmath4 is the greatest interval in @xmath223 $ ] and @xmath230 .",
    "call @xmath4 the _ compatible child _ of @xmath15 .",
    "figure  [ fig : lt1 ] shows an example of a linearised tree .",
    "we stress three crucial differences between the @xmath14 and @xmath20 data structures .",
    "the first is that a path in a linearised tree may not be a compatible set of intervals .",
    "the second is that linearised trees are binary .",
    "the third is when we insert or remove an interval we need to redirect at most two existing edges in the linearised tree .",
    "we explain the last fact in more details below when we introduce the dynamic algorithm .",
    "\\(g ) @xmath66 child node @xmath63 ;    \\(h ) [ right=12 mm ] @xmath67 child node @xmath3 child node @xmath64 child node @xmath61 child node @xmath62 child node @xmath65 ;    //in a/0/0 , b/2/0 , d/1/2 , e/3/2 , f/5/2 , c/-1/2 , g/0/4 , h/6/4 ( ) at ( , ) @xmath166 ;    \\(b ) edge ( a ) ; ( g ) edge ( c ) ; ( f ) edge ( e ) ; ( e ) edge ( d ) edge ( b ) ; ( h ) edge ( g ) edge ( f ) ;    we use the dynamic tree data structure to represent the linearised tree .",
    "we also maintain the interval tree @xmath79 as an auxiliary data structure .",
    "the interval tree is used to compute previous and next intervals as well as left compatible and right compatible intervals of a given interval .      to maintain @xmath20",
    "we will need @xmath231 operations , which returns @xmath37 if it is in the interval set or @xmath81 otherwise .",
    "algorithms  [ alg : lc ] defines this operation .",
    "@xmath232 @xmath84 the root in the interval tree @xmath79 .",
    "@xmath84 the left child of @xmath15 @xmath233 @xmath84 the right child of @xmath15 * return * @xmath17    we now describe algorithms for maintaining linearised tree data structure .",
    "we call the algorithms @xmath234 , @xmath235 and @xmath236 for the query , insertion , and removal operations , respectively .",
    "_ the operation @xmath234 : _ to detect if an interval @xmath4 is in the greedy optimal set , consider the path @xmath237 from the least node @xmath99 to the root in the linearised tree  @xmath224 . if @xmath238 , return @xmath103 . otherwise , consider the direct predecessor @xmath15 of @xmath4 in the path @xmath237 .",
    "if @xmath15 does not exist or @xmath239 , return @xmath101 . otherwise , we return @xmath103 .",
    "@xmath104 @xmath4 is the least interval @xmath101 @xmath210 make the path from @xmath99 to the root solid @xmath4 is not on the path from @xmath99 to the root @xmath103",
    "@xmath240 @xmath120 is an edge in @xmath20 @xmath101 @xmath103    [ lem : query - lt ] the operation @xmath241 returns @xmath101 if and only if a given interval @xmath4 belongs to the greedy optimal set of @xmath7 .",
    "let @xmath10 be the greedy optimal set of @xmath7 and @xmath99 be the least element of @xmath7 .",
    "suppose the algorithm @xmath241 outputs @xmath101 . this can happen when ( 1 ) @xmath242 . in this case",
    "@xmath4 is the least element of @xmath7 , hence @xmath4 belongs to @xmath10 ; or ( 2 ) @xmath4 is compatible with @xmath243 .",
    "note that for every interval @xmath195 from @xmath244 there exists an interval @xmath245 from the greedy set @xmath10 such that @xmath246 $ ] .",
    "consider such an interval @xmath247 $ ] .",
    "since @xmath248 and @xmath4 is the next compatible interval of @xmath245 , @xmath4 belongs to the greedy optimal set @xmath10 .",
    "it is not hard to see by induction on the number of elements in @xmath10 that @xmath249 .",
    "suppose the algorithm @xmath241 outputs @xmath103 .",
    "it happens in two cases .",
    "first , @xmath4 is not in @xmath244 .",
    "then @xmath250 .",
    "second , @xmath243 exists and is not compatible with @xmath4 .",
    "then @xmath4 is not the least interval in @xmath223\\cap { \\mathrm{st}}_{m}$ ] , but every element @xmath251 is the least element in @xmath252\\cap { \\mathrm{st}}_{m}$ ] . hence @xmath250 .    _",
    "the operation @xmath235 : _ given @xmath4 , we insert @xmath4 into @xmath79 .",
    "if @xmath4 is the greatest interval in @xmath223 $ ] , then we add the edge @xmath253 into @xmath227 . otherwise , we add the edge @xmath140 to @xmath254 , where @xmath15 is the next interval equivalent to @xmath4 .",
    "if @xmath4 has an equivalent child @xmath143 then we add the edge @xmath255 to @xmath254 and delete the old outgoing edge from @xmath143 in case such edge exists . if @xmath4 has a compatible child @xmath17 then we add the edge @xmath256 to @xmath227 and delete the old outgoing edge in case such edge exists .",
    "@xmath257 @xmath4 has a parent @xmath258",
    "@xmath259 @xmath260 @xmath261 @xmath262 @xmath263 @xmath264 and @xmath265 @xmath266 @xmath267 @xmath264 and @xmath265    _ the operation @xmath236 : _ given @xmath4 , we delete @xmath4 from @xmath79 .",
    "we delete an edge from @xmath4 to the parent of @xmath4 and redirect the edge from the equivalent child @xmath15 of @xmath4 to the parent of @xmath4 .",
    "then we redirect an edge from the compatible child @xmath17 of @xmath4 .",
    "removing @xmath4 may add new intervals to the equivalence class of @xmath17 . therefore if @xmath17 is still the greatest interval in the updated equivalence class , we add an edge @xmath268 to @xmath227 .",
    "otherwise , we add the edge @xmath140 to @xmath254 , where @xmath15 is the next interval of  @xmath17 .",
    "@xmath269 @xmath270 @xmath263 @xmath264 @xmath35 is a new parent of @xmath15 @xmath271 @xmath272 is a new parent of @xmath15 @xmath273 @xmath266 @xmath267 @xmath264 @xmath274 @xmath275 @xmath276 as we removed @xmath4 from @xmath79 .",
    "@xmath277 @xmath278 @xmath274      to prove correctness of the algorithms above , we state two claims about linearised trees .",
    "the first claim allows us to check if the given interval the greatest in its equivalent class .",
    "the second claim says that changes of the linearised tree after insertion or deletion of an interval @xmath4 are local with respect to  @xmath4 .",
    "we abuse notation and write @xmath279 instead of @xmath280 and @xmath281 instead of  @xmath282 . which edges are used will be clear from the context .",
    "[ lem : greatest ] an interval @xmath4 is the greatest in @xmath223 $ ] if and only if @xmath283 .",
    "let @xmath4 be the greatest interval in @xmath223 $ ] .",
    "then for any @xmath284 $ ] we have that @xmath285 .",
    "assume that @xmath286 .",
    "then @xmath287 which is a contradiction .",
    "for the other direction , assume that @xmath4 is not the greatest interval in its equivalent class , that is there exists @xmath284 $ ] such that @xmath36 .",
    "clearly , @xmath15 is compatible with @xmath35",
    ". therefore @xmath288 , witch is a contradiction .",
    "[ lem : difflt ] let @xmath289 and @xmath290 be two linearised trees such that @xmath291 .",
    "let @xmath15 and @xmath143 be intervals from the set @xmath292 .",
    "then the following properties are satisfied :    * if @xmath293 and @xmath294 , then either @xmath295 or @xmath296 . * if @xmath297 and @xmath298 , then @xmath299 .    for the first property",
    ", we note that if two intervals from @xmath7 are not connected by an edge in @xmath224 then they are not connected by an edge in a bigger linearised tree @xmath300 .",
    "hence either @xmath301 or @xmath302 . for the second property ,",
    "let @xmath303 be a parent of @xmath15 in @xmath304 . because @xmath305 and @xmath306 , the property ( 1 ) implies that either @xmath301 or @xmath307 . thus  @xmath307 .",
    "[ lem : insert - lt ] the operation @xmath308 preserves linearised tree data structure .",
    "consider intervals @xmath309 , where @xmath310 and @xmath311 .",
    "let @xmath312 be the resulting tree after the algorithm @xmath308 is performed .",
    "we show that @xmath294 if and only if @xmath313 is an edge in @xmath304 .",
    "@xmath314 suppose that @xmath294 .",
    "we prove that @xmath313 is an edge in @xmath304 .",
    "* let @xmath293 .",
    "then the algorithm @xmath235 must have added @xmath313 into @xmath315 . any edge the algorithm adds is adjacent to @xmath4 .",
    "first , we consider outgoing edges , that is , we consider the case when @xmath301 .",
    "if the algorithm adds an edge from @xmath4 to @xmath35 , then @xmath316 ( see lines 3 - 4 of the algorithm  [ alg : lt - insert ] ) . by sublemma  [ lem : greatest ] , @xmath4 is the greatest interval in its equivalence class .",
    "if the algorithm adds an edge from @xmath4 to the next interval @xmath143 of @xmath4 , then @xmath4 is not the greatest interval in @xmath223 $ ] and @xmath317 ( see lines 3 - 6 ) .",
    "second , we consider incoming edges , that is , we consider the case when @xmath302 . if the algorithm adds an edge from @xmath37 to @xmath4 , then @xmath318 ( see lines 10 - 12 ) . by sublemma  [ lem : greatest ]",
    ", @xmath15 is the greatest interval in its equivalence class .",
    "if the algorithm adds an edge from the previous interval @xmath15 of @xmath4 to @xmath4 , then @xmath319 ( see lines 7 - 9 ) . note that any of the edges added by the algorithm is an edge in @xmath304 .",
    "hence @xmath313 is an edge in @xmath304 .",
    "* let @xmath297 .",
    "assume that @xmath313 is not an edge in @xmath304 .",
    "by sublemma  [ lem : difflt ] @xmath120 is an edge in @xmath304 . if @xmath15 is the equivalent child of @xmath4 , then @xmath15 is the previous interval of @xmath4 and @xmath320 . if @xmath15 is the compatible child of @xmath4 , then @xmath318 . in both of these cases",
    "the algorithm deletes the edge from @xmath15 ( see lines 7 - 9 and 10 - 12 correspondently ) .",
    "thus @xmath298 , which is a contradiction .",
    "@xmath321 suppose that @xmath313 is an edge in @xmath304 .",
    "we prove that @xmath294 .",
    "* let @xmath297 .",
    "assume that @xmath298 .",
    "then the algorithm @xmath235 must have deleted @xmath313 .",
    "there are two cases : @xmath15 is the previous interval of @xmath4 and @xmath319 ( see lines 7 - 9 ) , or @xmath322 and @xmath15 is the greatest interval in @xmath323 $ ] ( see lines 10 - 12 ) . in either case , @xmath15 is a child of @xmath4 in @xmath304 , that is @xmath302 , which is a contradiction to the assumption that @xmath324 .",
    "* let @xmath293 . by sublemma  [ lem : difflt ] , either @xmath295 or @xmath302 .",
    "suppose @xmath295 . if @xmath4 is the compatible child of @xmath143 in @xmath304 , then @xmath325 and , by sublemma  [ lem : greatest ] , @xmath316 . if @xmath4 is the equivalent child of @xmath143 , then @xmath143 is the next interval @xmath4 and @xmath317 .",
    "the algorithm @xmath235 adds the edge @xmath326 to @xmath315 in lines 3 - 6 .",
    "suppose , @xmath296 .",
    "if @xmath15 is the equivalent child of @xmath4 , @xmath15 is the previous interval of @xmath4 and @xmath319 . if @xmath15 is the compatible child of @xmath4 , then @xmath318 .",
    "the algorithm @xmath235 adds the edges @xmath120 to @xmath315 in lines 7 - 12 . in any case , the edge @xmath294 .",
    "[ lem : remove - lt ] the operation @xmath327 preserves linearised tree data structure .",
    "suppose @xmath328 is the linearised tree of a set @xmath7 of intervals and @xmath329 is the resulting tree after the algorithm @xmath327 is performed .",
    "consider intervals @xmath15 and @xmath143 in @xmath7 , where @xmath310 .",
    "we want to show that @xmath294 if and only if @xmath313 is an edge in @xmath330 .",
    "@xmath314 suppose @xmath294 .",
    "we prove that @xmath313 is an edge in @xmath330 .",
    "* let @xmath297 .",
    "assume that @xmath313 is not an edge in @xmath330 .",
    "by lemma  [ lem : difflt ] , either @xmath295 or @xmath296 . if @xmath301 , that is , @xmath4 is a child of @xmath143 in @xmath331 , then the algorithm removes the edge @xmath326 in line 2 .",
    "consider the case when @xmath302 , that is , @xmath15 is a child of @xmath4 .",
    "if @xmath15 is the equivalent child of @xmath4 , the algorithm removes the edge @xmath120 in lines 3 - 5 .",
    "if @xmath15 is the compatible child of @xmath4 , the algorithm removes @xmath120 in lines 10 - 12 . in either case @xmath298 , which is a contradiction .",
    "* let @xmath293 .",
    "the algorithm @xmath236 must have added the edge @xmath313 .",
    "there are four possible cases .",
    "first , the algorithm adds an edge in line 7 , that is , @xmath325 .",
    "then @xmath15 is the equivalent child of @xmath4 and @xmath4 is the greatest interval in @xmath223 $ ] . after removing @xmath4",
    ", @xmath15 is the greatest interval in @xmath323 $ ] , so that @xmath15 is the compatible child of @xmath143 .",
    "second , the algorithm adds an edge in line 9 , that is , @xmath143 is the next interval of @xmath4 .",
    "then @xmath332 . since @xmath15 is the equivalent child of @xmath4 , @xmath333 .",
    "third , the algorithm adds an edge in line 17 .",
    "then @xmath143 is the next interval of @xmath15 with respect to @xmath334 and @xmath333 .",
    "finally , the algorithm adds an edge in line 19 .",
    "then @xmath15 is the greatest interval in @xmath323 $ ] and @xmath335 with respect to @xmath334 . in all these case",
    "the edge @xmath313 is an edge in @xmath330 .",
    "@xmath321 suppose @xmath313 is an edge in @xmath330 .",
    "we prove that @xmath294 .",
    "* let @xmath297 .",
    "assume that @xmath298 .",
    "then the algorithm @xmath236 must have deleted the edge @xmath313 .",
    "first , the algorithm removes an edge from @xmath4 ( see line 2 ) .",
    "second , it removes an edge from the equivalent child of @xmath4 ( see lines 3 - 58 ) .",
    "finally , it removes an edge from the compatible child of @xmath4 ( see lines 10 - 12 ) . thus the algorithms removes only edges , incident to @xmath4 , but these edges are not in @xmath330 , which is a contradiction . * let @xmath293 . by lemma  [ lem : difflt ]",
    "@xmath120 is an edge in @xmath331 .",
    "suppose @xmath15 is the equivalent child of @xmath4 .",
    "the algorithm finds @xmath15 in lines 3 - 5 .",
    "if @xmath15 is the compatible child of @xmath143 in @xmath330 , then @xmath4 is the compatible child of @xmath143 in @xmath331 .",
    "if @xmath15 is the equivalent child of @xmath143 , then @xmath143 is the next interval of @xmath4 .",
    "the algorithm takes care of both cases in lines 6 - 9 and adds the edge @xmath313 in line  9 .",
    "suppose @xmath15 is the compatible child of @xmath4 .",
    "the algorithm finds @xmath15 in lines 10 - 11 .",
    "if @xmath15 is the equivalent child of @xmath143 , then @xmath143 is the next interval of @xmath15 and @xmath336 with respect to @xmath334 .",
    "the algorithm adds the edge @xmath313 in lines 15 - 17 .",
    "if @xmath15 is the compatible child of @xmath143 , then the algorithm adds the edge in line 19 .",
    "thus , @xmath294 .",
    "lemmas  [ lem : query - lt]-[lem : remove - lt ] lead us to the following theorem :    [ thm : lt - amortized - time ] the @xmath234 , @xmath235 and @xmath236 operations solve the dynamic monotonic interval scheduling problem in @xmath0 amortised time , where @xmath2 is the size of the set @xmath7 of intervals .",
    "* note*. the time complexity of the operations above depends on the type of dynamic trees , representing paths of  @xmath20 .",
    "we can achieve the worst - case bound instead of amortized if we use globally biased trees instead of splay trees  @xcite .",
    "however , after each operation we must ensure that for every pair of edges @xmath337 and @xmath338 of the linearised tree , nodes @xmath50 and @xmath41 are in the same dynamic tree if and only if the numbers of nodes in the subtree rooter at @xmath50 is greater or equal to the number of nodes in the subtree rooted at  @xmath41 .",
    "in this section we present an experimental comparison between three algorithms for solving monotonic case of the dynamic interval scheduling problem : ( i ) the naive dynamic algorithm @xmath339 , which keeps the intervals a binary search and calculate the greedy optimal set from scratch at every query operation ; ( ii ) the algorithm @xmath14 based on the compatibility forest ; ( iii ) the algorithm @xmath20 based on the linearised tree .",
    "we implemented these algorithms in java .",
    "the algorithm @xmath339 is based on the standard java implementation of red - black tree , which we extended with @xmath340 and @xmath341 operations .",
    "we use the implementation of @xmath339 in the algorithms @xmath14 and @xmath20 to store intervals and perform tree operations . in @xmath14 and @xmath20",
    "we implemented bottom - up splay operation as described in @xcite .",
    "we run the experiments on a laptop with _ 4 gb of ram _ memory and _ intel core 2 duo 2130 mhz , 3 mb of l2 cache memory _ processor .    in our experiments",
    ", we measure the total and the average running time of a sequence of @xmath99 operations on initially empty interval set .",
    "the sequence consists of @xmath2 insert operations , @xmath342 remove operations and @xmath343 query operation , where @xmath2 is a linearly increasing number and @xmath86 and @xmath344 are fixed parameters of the experiment .",
    "we create a sequence of operations randomly while satisfying two conditions .",
    "first , whenever we invoke an insert operation of an interval @xmath4 , we make sure that there is no interval @xmath4 in the set .",
    "second , whenever we invoke a remove operation of @xmath4 , we make sure that @xmath4 exists in the set .",
    "thus every update operation calls for an actual change of the interval set .    to better understand the algorithms performance , we defined the _ sparsity _ of an interval set @xmath7 to be the upper bound on the ratio between the size of the greedy optimal set @xmath10 and the size of @xmath7 .",
    "the smaller the sparsity , the more intervals pairwise overlap . for example , if the sparsity is @xmath345 , we make sure by creating intervals of the length @xmath346 that at most every second interval can belong to @xmath10 .",
    "the sparsity of @xmath7 has an important influence on the algorithms @xmath339 and @xmath14 . in the compatibility forest",
    "we conclude every update operation with the expose operation on the least interval in the set , which restores the missing edges between intervals from @xmath10 .",
    "therefore the smaller sparsity , the smaller chance of an update operation to affects the splay tree , representing set @xmath10 . in the naive algorithm",
    ", the query operation may visit every interval from @xmath10 .",
    "therefore the smaller sparsity , the less maximal number of intervals the query operation may visit .    _ experiment 1 . _",
    "the analysis of the algorithms shows that @xmath339 updates the interval set faster than @xmath14 and @xmath20 , but queries the set slower .",
    "therefore in the first experiment we measured the efficiency of the algorithms undergoing @xmath2 insert , @xmath347 remove and @xmath348 query operations .",
    "the operations are shuffled as described above .",
    "we set the sparsity parameter to be @xmath349 .",
    "the result of the experiment is shown on the figure [ fig : slownaive ] .",
    "the experiment shows that the difference of total running time between algorithms undergoing a sequence of operations with number of insertion less then 6000 is small , especially between @xmath14 and @xmath339 .",
    "however , when we increase the number of insert operations , @xmath339 performs much slower than two other algorithms .",
    "the average running time per operation of @xmath339 is increasing similarly to a linear function , whereas the average running time per operation of @xmath14 and @xmath20 increases much slower .",
    "the experiment also shows that @xmath14 updates the interval set with low sparsity faster than @xmath20 .",
    "_ experiments 2 and 3_. in the next two experiments we measure the performance of @xmath14 and @xmath20 undergoing a sequence of operations with the equal number of insert and query operations .",
    "we excluded @xmath339 from the experiments because @xmath339 performs too slowly when the number of query operations increases .",
    "the difference between the second and the third experiment is in the number of remove operations .",
    "sequences in experiment  2 do not contain remove operations .",
    "sequences in experiment  3 contain @xmath347 remove operations .",
    "we set the sparsity parameter to be @xmath350 .",
    "figure [ fig : badlt ] shows the results of experiment  2 , figure [ fig : similar ] shows the results of experiment  3 .",
    "the third experiment shows that if we do not allow remove operations , @xmath14 performs faster than @xmath20 .",
    "if we allow remove operations , @xmath14 performs slightly slower than @xmath20 .",
    "however , the results of experiment  2 show that if the interval set is not sparse , @xmath14 inserts and removes intervals faster than @xmath20 .",
    "_ conclusion_. the experimental result verifies our theoretical analysis and shows that both @xmath14 and @xmath20 runs significantly faster than the naive algorithm .",
    "moreover , the results show that in a random environment @xmath14 performs as fast as @xmath20 to within a constant factor , despite the worst ( @xmath351 ) time upper bound . considering that @xmath14 is relatively easy to implement ,",
    "@xmath14 can find its practical applications ."
  ],
  "abstract_text": [
    "<S> we investigate dynamic algorithms for the interval scheduling problem . </S>",
    "<S> our algorithm runs in amortised time @xmath0 for query operation and @xmath1 for insertion and removal operations , where @xmath2 and @xmath3 are the maximal numbers of intervals and pairwise overlapping intervals respectively . </S>",
    "<S> we also show that for a monotonic set , that is when no interval properly contains another interval , the amortised complexity is @xmath0 for both query and update operations . </S>",
    "<S> we compare the two algorithms for the monotonic interval sets using experiments . </S>"
  ]
}