{
  "article_text": [
    "this report continues our work on bespaced by introducing new operators for filtering , folding and normalization of bespaced descriptions .",
    "the new operators are inspired by operations from functional programming languages and are applied to spatio - temporal models .",
    "bespaced is our framework for spatio - temporal reasoning @xcite .",
    "bespaced is characterised by    * a description language that is based on abstract datatypes .",
    "* means to reason about descriptions formulated in the description language .",
    "related work comprises process algebra based formalisms @xcite and @xcite . similar to this work , we have created a formal specification language as part of our bespaced framework . in our case , specifications are instances of abstract datatypes and follow a more functional programming style .",
    "further related is work on type systems in connection with this process algebra work that has been introduced in @xcite .",
    "analog to the work presented in @xcite , bespaced can also be used to define spatio - temporal types . a verification tool to check properties based on the process algebra inspired formalism is described in @xcite .",
    "applications include concurrency and ressource control .",
    "further related are approaches for the specification of hybrid systems .",
    "a framework for specifying hybrid programs with stochastic features is presented in @xcite .",
    "other logic approaches to spatial reasoning can be found , e.g. , in @xcite .",
    "specialised solutions for reasoning about geometric constraints have been developed for robot path planning .",
    "this area has already been studied for decades , see e.g. , @xcite .",
    "this report provides an overview on bespaced in section  [ sec : bes ] .",
    "filtering is covered in section  [ sec : filt ] .",
    "folding of time and space is covered in section  [ sec : fold ] while normalization is described in section  [ sec : norm ] .",
    "section  [ sec : concl ] concludes the report .",
    "bespaced is a spatio - temporal modeling and reasoning framework . here",
    ", we describe the modeling language , bespaced - based reasoning , and provide some implementation background information .",
    "bespaced is implemented in scala .",
    "its core functionality runs in a java environment . in the past",
    ", we have successfully applied bespaced in different contexts such as decision support for factory automation  @xcite , coverage analysis for mobile devices  @xcite and for verification of spatio - temporal properties for industrial robots  @xcite .",
    "bespaced models are created using scala case classes .",
    "thus , we provide a functional abstract datatype - like feeling .",
    "major language constructs which are currently available ( see also @xcite ) are provided below .",
    "an invariant is the basic logical entity , something that is supposed to hold for a system throughout space and time .",
    "invariants can and typically do , however , contain conditional parts , something that requires a precondition to hold , e.g. , a certain time implies a certain state of a system .",
    "constructors for basic logical operations connect invariants to form a new invariant .",
    "some of these basic constructors are provided below :    .... abstract class invariant ;    abstract class atom extends invariant ;    case class or ( t1 : invariant , t2 : invariant ) extends invariant ; case class and ( t1 : invariant , t2 : invariant )   extends invariant ; case class not ( t : invariant ) extends invariant ; case class implies ( t1 : invariant , t2 : invariant )   extends invariant ;    case class bigor ( t : list[invariant ] ) extends invariant ; case class bigand ( t : list[invariant ] ) extends invariant ;    case class true ( ) extends atom ; case class false ( ) extends atom ; ....    additional predicates are used to indicate timepoints , timeintervals , events , ownership , and related information .    .... ... case class timepoint [ t ] ( timepoint : t ) extends atom ;   case class timeinterval [ t](timepoint1 : t , timepoint2 : t ) extends atom ;   ... case class event[e ] ( event : e ) extends atom ; case class owner[o ] ( owner : o ) extends atom ; case class prob ( probability : double ) extends atom ;   case class componentstate[s ] ( state : s ) extends atom ; ....    some geometric constructs are provided below :    .... case class occupybox ( x1 : int , y1 : int , x2 : int , y2 : int ) extends atom ; case class occupyboxsi ( x1 : si , y1 : si , x2 : si ,",
    "y2 : si ) extends atom ;   case class eroccupybox      ( x1 : ( ertp = > int),y1 : ( ertp = > int ) ,      x2 : ( ertp = > int),y2 : ( ertp = > int ) ) extends atom ;   case class ownbox[c ] ( owningcomponent : c , x1 : int , y1 : int , x2 : int , y2 : int )               extends atom ;   ... case class occupy3dbox ( x1 : int , y1 : int , z1 : int ,                x2 : int , y2 : int , z2 : int ) extends atom ; ... case class occupypoint ( x : int , y : int ) extends atom case class ownpoint[c ] ( owningcomponent : c , x : int , y : int ) extends atom    case class occupy3dpoint ( x : int , y : int , z : int ) extends atom ... case class occupycircle ( x1 : int , y1 : int , radius : int ) extends atom ;   case class owncircle[c ] ( owningcomponent : c ,                x1 : int , y1 : int , radius : int ) extends atom ; ... ....    in addition , we have topological constructs which are shown below :    .... case class occupynode[n ] ( node : n ) extends atom ... case class edge[n ] ( source : n , target : n ) extends atom   case class transition[n , e ] ( source : n , event : e , target : n ) extends atom   ....    in summary , the language constructs comprise basic logical operators ( e.g. , and , or ) and constructs for space , time , and topology . for instance , occupybox refers to a rectangular two - dimensional geometric space",
    ". it is parameterized by its left lower and its right upper corner points .",
    "an example is provided below : if we want to express that the rectangular space with the corner points @xmath0 and @xmath1 is subject to a semantic condition `` a '' between integer - defined time points @xmath2 and @xmath3 , we may use the following bespaced formula :    .... ...",
    "implies(and(timeinterval(100,150 ) ,                 owner(\"a \" ) ) ,        occupybox(42,3056,1531,2605 ) ) ... ....      bespaced comes with a variety of library - like functionality that involves the handling of specifications .",
    "bespaced formulas can be efficiently analyzed , i.e. , verifying spatio - temporal and other properties .",
    "a simple example involves the specification of a point in time and a predicate .",
    "bespaced can derive the spatial implications from these definitions .",
    "we have implemented algorithms and connected tools such as an external smt solvers ( e.g. , we have a connection to z3 @xcite )",
    ". these can help to resolve geometric constraints such as overlapping of different areas in time and space .",
    "different operators ( for instance , breaking geometric constraints on areas down to geometric constraints on points ) exist . in this report",
    ", we are looking at filtering in datatypes , normalization and spatio - temporal fold operations .",
    "filtering and normalization were already supported in previous versions but have seen some updates in the implementation .",
    "the folding functionality is new to this report .      in the implementation of the presented operations we are using the scala programming language .",
    "in particular scala s case classes are used to define the language and we make heavy use of pattern matching on types to implement algorithms .",
    "for unit testing we use _ scalatest _   which allows us to easily code tests with assertions and rapidly re - run them as needed .",
    "the team used a combination of the eclipse `` scala ide '' ( mostly for runtime execution ) and intellij idea   ( mostly for for editing and refactoring ) .",
    "filtering allows the selection of relevant information out of larger bespaced invariants thereby returning a sub - invariant .",
    "filter functions have the following signiture scheme :    .... filter(inv : invariant , filtercondition ) : invariant   ....    an invariant is filtered following a filtercondition . the filter condition may be a spatial area or a timeinterval .",
    "all relevant information for the filtercondition is encapsulated in the returned invariant .",
    "a variety of different filter functions are possible , each one evaluating the invariant with respect to different levels of semantic depth .      as part of the implementation of a fold",
    ", a filter function is required .",
    "to illustrate one interesting example of this we will discuss the filtertime function .",
    "presented below is one of our versions of filtering time which is of particular interest because it uses an elegant ",
    "rewrite then simplify  algorithm that greatly reduces the code complexity compared to other versions of filtertime .",
    "however , we did not perform an analysis of algorithmic complexity so far .",
    "the key line of source code is :    .... case tp : timepoint[integertime ] = >              if ( withintimewindow(tp , starttime , stoptime ) ) tp              else successreturn.not ....    this line rewrites the time point predicate as either a true or false value .",
    "`` tp '' effects no change to the invariant and `` successreturn.not '' will rewrite it as either a true or false value .",
    "this depends on the parent context of the re - write : false for conjunctions and true for disjunctions . later in the simplification process :    ....    simplifyinvariant(filteredinvariant ) ....    will cause whole branches of the abstract datatype tree to be truncated where the time point is rewritten as false because one of the standard simplification rules is :    ....    case implies(false(),t2 ) = > true ( ) ....    in effect this filters out all the sub expressions that do not match the desired time point .",
    "other aspects of the source code can be found below :    ....      def filtertime2(starttime : integertime ,                     stoptime : integertime ,                     successreturn : bool )                       ( invariant : invariant ) : invariant =    {      val filter = filtertime2(starttime , stoptime , successreturn ) _",
    "def withintimewindow(timepoint : timepoint[integertime ] ,                            starttimeinclusive : integertime ,                            stoptimeexclusive : integertime ) : boolean =      {        val time = timepoint.timepoint          time > = starttimeinclusive & & time < stoptimeexclusive      }        val filteredinvariant : invariant = invariant match      {        case tp : timepoint[integertime ] = >                    if ( withintimewindow(tp , starttime , stoptime ) ) tp                    else successreturn.not          case implies(premise , conclusion ) = >                 implies(filter(premise ) , filter(conclusion ) )          case and(t1 , t2 ) = > and(filter(t1 ) , filter(t2 ) )        case bigand(sublist ) = > bigand(sublist map filter )          case or(t1 , t2 ) = > or ( filter(t1 ) , filter(t2 ) )        case bigor(sublist ) = > bigor(sublist map filter )            case other = > other      }        simplifyinvariant(filteredinvariant )    } ....",
    "figure  [ fig : foldop ] shows an illustration of our fold operation for time and space .",
    "the general principle of folding , the iteration through time and space while accumulating processed information is shown .        in this section ,",
    "we discuss the folding of time and space in separate subsections and follow our implementation .",
    "a generalized signature for a folding time function is provided below .",
    "no assumptions are made on the implementation of time , other than that time has to be partially ordered .    ....",
    "foldtime[a , t ] ( invariant : invariant , a : a , starttime : t ,                         stoptime : t , step : t , f [ a - > invariant - > a ] ) ....      we are exemplifying the folding of time by using an example with weather data . we are regarding a geometric space ( a matrix - like structure ) that contains values indicating cloud coverage of an area . to validate folding time we devised a complex test case that aggregates clouded areas over multiple time points .",
    "this test case uses a naive approach as it requires a strict format for the knowledge invariants .",
    "the knowledge about the space and whether its cloudy or not is encoded as follows :    .... //",
    "time val t1 = new integertime(1 ) val t2 = new integertime(2 ) val t3 = new integertime(3 )    // overlapping boxes val b1 = occupybox(1 , 1 , 10 , 10 ) //",
    "area 100 val b2 = occupybox(5 , 5 , 15 , 15 ) // area 121 val b3 = occupybox(10 , 10 , 20 , 20 ) //",
    "area 121    //",
    "time occupied val to1",
    "= implies(timepoint(t1 ) , b1 ) val to2 = implies(timepoint(t2 ) , b2 ) val to3 = implies(timepoint(t3 ) , b3 )    val timeseries = list(to1 , to2 , to3 ) val conjunction = bigand(timeseries ) ....    in order to calculate the area occupied for one time step we implemented a function called addareaoccupied .",
    "this function takes two parameters :    1 .",
    "total : this is called the accumulator as it will store the running total ( an integer ) as the fold is being called recursively .",
    "2 .   item : this is bespaced data ( an invariant ) that represents the knowledge of the spatial cloud system .",
    "....    def calculatearea(box : occupybox ) : int =     math.abs((box.x2 - box.x1 + 1 ) * ( box.y2 - box.y1 + 1 ) )    def addareaoccupied(total : int , item : invariant ) : int = {    val area = item match {      case implies(imp , box : occupybox ) = > calculatearea(box )      case _",
    "= > 0    }      total + area } ....    it is interesting to note that the result of this function is a calculation derived from the two parameters ( as seen in the last line above ) . in this case",
    "the accumulator ( total ) is added to the area which is calculated from the second parameter ( item ) .",
    "this is the essence of an `` aggregation function '' that is commonly used by all fold operations : the accumulated value and a function applied to the next iteration item are combined to give the next accumulated value .",
    "the signature for an implemented function that folds time is as follows :    ....    def foldtime[a ] (                     invariant : invariant ,                     accumulator : a ,                     starttime : integertime ,                     stoptime : integertime ,                     step : integertime.step ,                     f : ( a , invariant ) = > a                     ): a ....    additionally , for our example , we need to setup a few more parameters .",
    "the accumulator used in the fold needs an initial value :    .... val initialvalue = 0 ....    and finally we need to define a series of `` steps '' in time for the fold operation to `` fold '' . in this test case",
    "we specified the following :    .... t1 , t3 , 1 ....",
    "this series of values simply represents start with time point 1 , stop at time point 3 and step through time incrementing by 1 .",
    "here is what the call to the foldtime function with the parameters described above looks like :    .... val foldedtime = foldtime[int ] (    conjunction ,    initialvalue ,    t1 , t3 , 1 ,    addareaoccupied ) ....    to validate the test runs correctly we assert the expected result :    .... assertresult(expected = 342)(actual = foldedtime ) ....    the expected result of 342 is explained as follows : there are three time points : 1 , 2 and 3 each with their own boxes : b1 , b2 , b3 .",
    "the area of each are 100 , 121 , 121",
    ". the fold of these three areas will be the sum which is 342 .",
    "the actual fold over time example is also depicted in figure  [ fig : foldtime ] .",
    "the regarded spatial area stays the same , but the _ cloud _ moves over time ( depicted in different colors ) .          folding space in general is done by using a function with the following signature .",
    "note , that it works using generic area descriptions .    ....",
    "foldspace[a ] (      invariant : invariant ,      z : a , startarea : invariant ,      stoparea : invariant ,      stepareaorbox : invariant ,      f : ( a - > invariant - > a ) )   ....      a concrete signature for an implemented function that folds space is as follows and assumes that areas are boxes :    .... foldspace[a ] (                    invariant : invariant ,                    accumulator : a ,                    startarea : occupybox ,                    stoparea : occupybox ,                    translation : translation ,                    f : ( a , invariant ) = > a                    ): a ....    to validate folding space we devised a simple test case that aggregates clouded areas over multiple spatial iteration steps .",
    "this test case uses a naive approach as it requires a strict format for the knowledge invariants .",
    "the knowledge about the space and whether its cloudy or not is encoded as follows :    ....      //",
    "boxes      val b1 = occupybox(1 , 1 , 10 , 10 )      val b2 = occupybox(5 , 5 , 15 , 15 )      val b3 = occupybox(10,10 , 20,20 )      val b4 = occupybox(21,21 , 30,30 )        //",
    "space owner - occupied      val s1 = implies(mountain , b1 )      val s2 = implies(cloud , b2 )      val s3 = implies(cloud , b3 )      val s4 = implies(mountain , b4 )        val spaceseries = list(s1 , s2 , s3 , s4 )      val conjunction = bigand(spaceseries ) ....    in order to apply the foldspace function we need to pass in the calculatearea function from the above example as the parameter f and a spatial model as the invariant .",
    "additionally we need to setup a few more parameters .",
    "the accumulator using in the fold needs an initial value :    .... val initialvalue = 0 ....    and finally we need to define a series of steps in space for the fold operation to `` fold '' . in this test case",
    "we defined the following :    ....      val startbox = occupybox(1 , 1 , 5 , 5 )      val stopbox   = occupybox(26,26,30,30 )      val step : translation = ( 5 , 5 ) ....",
    "this means we want the first box cover coordinates : ( 1,1 ) ...",
    "( 1,5 ) , ( 2,1 ) ...",
    "( 2,5 ) ...",
    "in this example there are six iteration steps none of which overlap .",
    "in addition , as future work we would like to regard overlapping steps and explore semantic implications for this .",
    "the code piece below shows a call to the foldspace function with the parameters described above :    ....      val foldedspace = foldspace[int ] (        normaliseddata ,        initialvalue ,        startbox , stopbox , step ,        addcloudyarea      ) ....    to validate the test runs we assert the expected result using the following code line :    ....      assertresult(expected = 76)(actual = foldedspace ) ....    the expected result on 76 is explained as follows :    the first iteration box ( 1,1 ... 5,5 ) is indicated to contain a mountain ( see above ) .",
    "however , one point also contains a cloud .",
    "this point is counted for cloud coverage .",
    "we further iterate through the boxes . the second iteration box ( 6,6 ... 10,10 )",
    "is indicated to contain a cloud .",
    "we continue iterating through the iteration path thereby examining all 6 boxes in the path .",
    "the total cloud covered area in the iteration path adds up to 1 + 25 + 25 + 25 + 0 + 0= 76 .    in order to calculate a `` degree of cloudiness '' for one spatial step we implemented a function called addcloudyarea",
    "this function takes two parameters :    1 .",
    "total : this is called the accumulator as it will store the running total ( an integer ) as the fold is being called recursively .",
    "invariant : this is bespaced data that represents the model containing clouds and other spatio - temporal information .",
    ".... def addcloudyarea(total : int , invariant : invariant ) : int =   {    def iscloudyarea(owner : owner[any ] ) : boolean = owner = = cloud      def calculatearea(list : list[invariant ] ) : int = {      val areas : list[int ] = list map {        inv : invariant = >          inv match {            case implies(owner : owner[any ] , point : occupypoint ) = >                if ( iscloudyarea(owner ) ) 1 else 0            case implies(owner : owner[any ] ,                          and(p1 : occupypoint , p2 : occupypoint ) ) = >                if ( iscloudyarea(owner ) ) 2 else 0            case implies(owner : owner[any ] ,                          bigand(points : list[occupypoint ] ) ) = >                if ( iscloudyarea(owner ) ) points.length else 0            case _",
    "= > 0          }      }      areas.sum    }      val area = invariant match {      case and(t1 , t2 ) = > calculatearea(t1 : : t2 : : nil )      case bigand(sublist : list[invariant ] ) = > calculatearea(sublist )      case _",
    "= > 0    }      total + area } ....    it is interesting to note that the result of this function is a calculation derived from the two parameters ( as seen in the last line above ) . in this case",
    "the accumulator ( total ) is added to the area which is calculated from the second parameter ( invariant ) .",
    "the folding of space example is also illustrated in figure  [ fig : foldspaceex ] .",
    "different boxes are shown for the different steps in our example .",
    "in order to make invariants comparable , we need to normalize them .",
    "normalization ensures , that the same invariants are represented in the same way . however , there are different levels of normalization .",
    "normalization can take a higher or lower degree of semantics into account . at the lower end",
    ", we may just reorder arguments for logical operators such as `` and '' and `` or '' . on the other end",
    ", we may look into the semantic meaning of geometric shapes and , e.g. , replace areas with sets of points in order to make them comparable .",
    "different normalization strategies may require different resources and work on different subsets of our language .",
    "choosing an appropriate form of normalization depends on the actual use - case .",
    "this is why we have not implemented a single normalization function , but rather have a family of functions .    in general normalization",
    "involves term rewriting steps until a fix point is reached .",
    "the invariant is then in a normal form .",
    "several properties of the term rewriting should be fulfilled such as confluence .",
    "comparison is then carried out by checking the resulting terms for equality .      to implement normalization in bespaced we used functional composition in chains .",
    "the type of each element in the chain is a function from invariant to invariant :    .... type processor[i , o ] =",
    "i = > o type invariantprocessor = processor[invariant , invariant ] ....    we have created various invariant processors each of which perform one step in the normalisation process .",
    "the following is a general normalization function , showing the composition of four processors :    .... val normalize : invariantprocessor =        flatten        compose        order        compose        deduplicate        compose        simplify ....    a more specific example of a normalization function designed for data of the form    .... owner  >   occupypoints ....    is described in the following .",
    "it composes the standard normalization with a further processor specific to the data structure .",
    ".... val normalizeowneroccupied : invariantprocessor = mergeowners compose normalize ....    below is a brief description of the step each processor does in the normalization process :    * flatten  rewrites nested conjunctions and disjunctions into single level conjunctions and disjunctions where possible .",
    "* order  orders the terms of all conjunctions and disjunctions according to a standard ordering .",
    "* deduplicate  removes duplicate terms of conjunctions and disjunctions . *",
    "simplify  uses term rewriting to rewrite expressions in a simpler form .",
    "e.g. implies(true , t2 ) is rewritten as t2 * mergeowners - expects a bigand of implies and conjuncts all the conclusions of implications that have identical premises .",
    "e.g. + ....",
    "bigand(implies(a , x ) , implies(b , y ) , implies(a , z ) )   .... + is rewritten as + ....",
    "bigand(implies(a , and(x , z ) ) , implies(b , y ) ) ....",
    "we presented new operators for bespaced in this paper .",
    "these operators comprise filtering , folding and normalization for spatio - temporal formulas .",
    "the operations are inspired by functional programming languages and are ported to the spatio - temporal context .",
    "in addition to theoretical considerations we presented an implementation and a testing infrastructure for the bespaced framework .      the implementation work presented in this paper is open source and freely available .",
    "it has been done as part of the research and development activities in the australia - india centre for automation software engineering at rmit university in melbourne .",
    "b. bennett , a. g. cohn , f. wolter , m. zakharyaschev .",
    "multi - dimensional modal logic as a framework for spatio - temporal reasoning . applied intelligence , volume 17 , issue 3 , kluwer academic publishers , november 2002 .",
    "j.  o.  blech and h.  schmidt .",
    "bespaced : towards a tool framework and methodology for the specification and verification of spatial behavior of distributed software component systems . in _",
    "arxiv.org_ , http://arxiv.org/abs/1404.3537 , 2014 .",
    "j.  o.  blech , i.  peake , h.  schmidt , m.  kande , a.  rahman , s.  ramaswamy , sudarsan  sd .",
    ", and v.  narayanan .",
    "efficient incident handling in industrial automation through collaborative engineering .",
    "_ emerging technologies and factory automation ( etfa ) _ , ieee , 2015 .",
    "l. caires and h. torres vieira .",
    "slmc : a tool for model checking concurrent systems against dynamical spatial logic specifications .",
    "tools and algorithms for the construction and analysis of systems .",
    "springer , 2012 ."
  ],
  "abstract_text": [
    "<S> in this report , we present some spatio - temporal operators for our bespaced framework . </S>",
    "<S> we port operators known from functional programming languages such as filtering , folding and normalization on abstract data structures to the bespaced specification language . </S>",
    "<S> we present the general ideas behind the operators , highlight implementation details and present some simple examples . </S>"
  ]
}