{
  "article_text": [
    "the parlor game best known as `` twenty questions '' has a long history and a broad appeal .",
    "it was used to advance the plot of charles dickens _ _ a christmas carol__@xcite , in which it is called `` yes and no , '' and it was used to explain information theory in alfrd rnyi s _ _ a diary on information theory__@xcite , in which it is called `` bar - kochba . '' the two - person game begins with an answerer thinking up an object and then being asked a series of questions about the object by a questioner .",
    "these questions must be answered either `` yes '' or `` no . ''",
    "usually the questioner can ask at most twenty questions , and the winner is determined by whether or not the questioner can sufficiently surmise the object from these questions .",
    "many variants of the game exist  both in name and in rules .",
    "a recent popular variant replaces the questioner with an electronic device@xcite .",
    "the answerer can answer the device s questions with one of four answers  `` yes , '' `` no , '' `` sometimes , '' and `` unknown . ''",
    "the game also differs from the traditional game in that the device often needs to ask more than twenty questions .",
    "if the device needs to ask more than the customary twenty questions , the answerer can view this as a partial victory , since the device has not answered correctly given the initial twenty .",
    "however , the device eventually gives up after @xmath8 questions if it can not guess the questioner s object .",
    "consider a short example of such a series of questions , with only `` yes , '' `` no , '' and `` sometimes '' as possible answers .",
    "the object to guess is one of the seven newtonian colors@xcite , which we choose to enumerate as follows :    1 .",
    "green ( g ) 2 .",
    "yellow ( y ) 3 .",
    "red ( r ) 4 .",
    "orange ( o ) 5 .   indigo ( i ) 6 .",
    "violet ( v ) 7 .",
    "blue ( b ) .    a first question we ask might be , `` is the color seen as a warm color ? '' if the answer is `` sometimes , ''",
    "the color is green .",
    "if it is `` yes , '' it is one of colors @xmath9 through  @xmath10 .",
    "if so , we then ask , `` is the color considered primary ? '' `` sometimes '' implies yellow , `` yes '' implies red , and `` no '' implies orange .",
    "if the color is not warm , it is one of colors @xmath11 through @xmath12 , and we ask whether the color is considered purple , a different question than the one for colors @xmath9 through @xmath10 .",
    "`` sometimes '' implies indigo , `` yes '' implies violet , and `` no '' implies blue .",
    "thus we can distinguish the seven colors with an average of @xmath13 questions if @xmath14 is the probability that color in question is green .",
    "this series of questions is expressible using code tree notation , e.g. , @xcite , in which a tree is formed with each child split from its parent according to the corresponding output symbol , i.e. , the answer of the corresponding question . a code tree corresponding to the above series of questions is shown in fig .  [ codetree ] , where a left branch means `` sometimes , '' a middle branch means `` yes , '' and a right branch means `` no . ''",
    "the number of answers possible is referred to by the constant @xmath15 and the tree is a @xmath15-ary tree . in this case ,",
    "@xmath16 and the code tree is ternary .",
    "the number of outputs , @xmath17 , is the number of colors .",
    "the analogous problem in prefix coding is as follows : a source ( the answerer ) emits input symbols ( objects ) drawn from the alphabet @xmath18 , where @xmath0 is an integer .",
    "symbol @xmath19 has probability @xmath20 , thus defining probability vector @xmath21 .",
    "only possible symbols are considered for coding and these are sorted in decreasing order of probability ; thus @xmath22 and @xmath23 for every @xmath24 such that @xmath25 .",
    "( since sorting is only @xmath26 time and @xmath27 space , this can be assumed without loss of generality . )",
    "each input symbol is encoded into a codeword composed of output symbols of the @xmath15-ary alphabet @xmath28 .",
    "( in the example of colors , @xmath29 represents `` sometimes , '' @xmath30 `` yes , '' and @xmath9 `` no . '' ) the codeword @xmath31 corresponding to input symbol @xmath19 has length @xmath32 , thus defining length vector @xmath33 . in fig .",
    "[ codetree ] , for example , @xmath34 is @xmath35  the codeword corresponding to blue  so length @xmath36 . the overall code should be a prefix code , that is , no codeword @xmath31 should begin with the entirety of another codeword  @xmath37 . in the game , equivalently",
    ", we should know when to end the questioning , this being the point at which we know the answer .    for the variant introduced here , all codewords must have lengths lying in a given interval [ @xmath4,@xmath1 ] . in the example of the device mentioned above , @xmath39 and @xmath40 .",
    "a more practical variant is the problem of designing a data codec which is efficient in terms of both compression ratio and coding speed .",
    "moffat and turpin proposed a variety of efficient implementations of prefix encoding and decoding in @xcite , each involving table lookups rather than code trees .",
    "they noted that the length of the longest codeword should be limited for computational efficiency s sake .",
    "computational efficiency is also improved by restricting the overall range of codeword lengths , reducing the size of the tables and the expected time of searches required for decoding .",
    "thus , one might wish to have a minimum codeword size of , say , @xmath41 bits and a maximum codeword size of @xmath42 bits ( @xmath43 ) .",
    "if expected codeword length for an optimal code found under these restrictions is too long , @xmath4 can be reduced and the algorithm rerun until the proper trade - off between coding speed and compression ratio is found .",
    "a similar problem is one of determining opcodes of a microprocessor designed to use variable - length opcodes , each a certain number of bytes ( @xmath44 ) with a lower limit and an upper limit to size , e.g. , a restriction to opcodes being 16 , 24 , or 32 bits long ( @xmath45 , @xmath46 ) .",
    "this problem clearly falls within the context considered here , as does the problem of assigning video recorder scheduling codes ; these human - readable decimal codes ( @xmath47 ) have lower and upper bounds on their size , such as @xmath48 and @xmath49 , respectively .",
    "other problems of interest have @xmath50 and are thus length limited but have no practical lower bound on length@xcite .",
    "yet other problems have not fixed bounds but a constraint on the difference between minimum and maximum codeword length , a quantity referred to as fringe @xcite . as previously noted , large",
    "fringe has a negative effect of the speed of a decoder . in section  [ conclusion ] of this paper",
    "we discuss how to find such codes .",
    "note that a problem of size @xmath0 is trivial for certain values of @xmath4 and  @xmath1 .",
    "if @xmath51 , then all codewords can have @xmath4 output symbols , which , by any reasonable objective , forms an optimal code . if @xmath52 , then we can not code all input symbols and the problem , as presented here , has no solution . since only other values are interesting , we can assume that @xmath53 $ ] .",
    "for example , for the modified form of twenty questions , @xmath54 , @xmath39 , and @xmath55 , so we are only interested in problems where @xmath56 $ ] .",
    "since most instances of twenty questions have fewer possible outcomes , this is usually not an interesting problem after all , as instructive as it is .",
    "in fact , the fallibility of the answerer and ambiguity of the questioner mean that a decision tree model is not , strictly speaking , correct .",
    "for example , the aforementioned answers to questions about the seven colors are debatable .",
    "the other applications of length - bounded prefix coding mentioned previously , however , do fall within this model .",
    "if we either do not require a minimum or do not require a maximum , it is easy to find values of @xmath4 or @xmath1 which do not limit the problem .",
    "as mentioned , setting @xmath50 results in a trivial minimum , as does @xmath57 .",
    "similarly , setting @xmath58 or using the hard upper bound @xmath59 results in a trivial maximum value . in the case of trivial maximum values , one can actually minimize expected codeword length in linear time given sorted inputs .",
    "this is possible because , at each stage in the standard huffman coding algorithm , the set of huffman trees is an optimal forest ( set of trees)@xcite .",
    "we describe the linear - time algorithm in section  [ refine ] .",
    "if both minimum and maximum values are trivial , huffman coding  @xcite yields a prefix code minimizing expected codeword length @xmath60 the conditions necessary and sufficient for the existence of a prefix code with length vector @xmath61 are the integer constraint , @xmath62 , and the kraft ( mcmillan ) inequality  @xcite , @xmath63 finding values for @xmath61 is sufficient to find a corresponding code , as a code tree with the optimal length vector can be built from sorted codeword lengths in @xmath27 time and space .",
    "it is not always obvious that we should minimize the expected number of questions @xmath64 ( or , equivalently , the expected number of questions in excess of the first  @xmath4 , @xmath65 where @xmath66 is @xmath67 if @xmath67 is positive , @xmath29 otherwise ) .",
    "consider the example of video recorder scheduling codes .",
    "in such an application , one might instead want to minimize mean square distance from  @xmath4 , @xmath68 we generalize and investigate how to minimize the value @xmath69 under the above constraints for any penalty function @xmath70 convex and increasing on  @xmath71 .",
    "such an additive measurement of cost is called a quasiarithmetic penalty , in this case a convex quasiarithmetic penalty .",
    "one such function @xmath72 is @xmath73 , a quadratic value useful in optimizing a communications delay problem  @xcite .",
    "another function , @xmath74 for @xmath75 , can be used to minimize the probability of buffer overflow in a queueing system@xcite .    mathematically stating the length - bounded problem , @xmath76 note that we need not assume that probabilities @xmath20 sum to @xmath30 ; they could instead be arbitrary positive weights .",
    "thus , in this paper , given a finite @xmath0-symbol input alphabet with an associated probability vector @xmath77 , a @xmath15-symbol output alphabet with codewords of lengths @xmath78 $ ] allowed , and a constant - time - calculable convex penalty function @xmath72 , we describe an @xmath79-time @xmath27-space algorithm for constructing a @xmath72-optimal code , and sketch an even less complex reduction for the most convex penalty function , @xmath80 , minimization of expected codeword length . in the next section , we present a brief review of the relevant literature . in section  [ nodeset ] , we extend to @xmath15-ary codes an alternative to code tree notation first presented in @xcite .",
    "this notation aids in solving the problem in question by reformulating it as an instance of the @xmath15-ary coin collector s problem , presented in section  [ cc ] as an extension of the ( binary ) coin collector s problem@xcite .",
    "an extension of the package - merge algorithm solves this problem ; we introduce the reduction and resulting algorithm in section  [ algorithm ] .",
    "we make it @xmath27 space in section  [ linear ] and refine it in section  [ refine ] . the alternative approach for the expected length problem of minimizing ( [ huff ] )",
    " i.e. , @xmath80  is often faster ; this approach is sketched in section  [ linpen ] .",
    "algorithmic modifications , applications , possible extensions of this work are discussed in section  [ conclusion ] .",
    "reviewing how the problem in question differs from binary huffman coding :    1 .",
    "it can be nonbinary , a case considered by huffman in his original paper@xcite ; 2 .",
    "there is a maximum codeword length , a restriction previously considered , e.g. , @xcite in @xmath81 time @xcite and @xmath82 space , but solved efficiently only for binary coding , e.g. , @xcite in @xmath83 time @xmath27 space and most efficiently in @xcite ; 3 .",
    "there is a minimum codeword length , a novel restriction ; 4 .",
    "the penalty can be nonlinear , a modification previously considered , but only for binary coding , e.g. , @xcite .",
    "there are several methods for finding optimal codes for various constraints and various types of optimality ; we review the three most common families of methods here .",
    "note that other methods fall outside of these families , such as a linear - time method for finding minimum expected length codewords for a uniform distribution with a given fringe@xcite .",
    "( this differs from the limited - fringe problem of section  [ conclusion ] , in which the distribution need not be uniform and fringe is upper - bounded , not fixed . )    the first and computationally simplest of these are huffman - like methods , originating with huffman in 1952@xcite and discussed in , e.g. , @xcite .",
    "such algorithms are generally linear time given sorted weights and thus @xmath26 time in general .",
    "these are useful for a variety of problems involving penalties in linear , exponential , or minimax form , but not for other nonlinearities nor for length - limited coding",
    ". more complex variants of this algorithm are used to find optimal alphabetic codes , that is , codes with codewords constrained to be in a given lexicographical order .",
    "these variants are in the hu - tucker family of algorithms@xcite , which , at @xmath26 time and @xmath27 space@xcite , are the most efficient algorithms known for solving such problems ( although some instances can be solved in linear time@xcite ) .",
    "the second type of method , dynamic programming , is also conceptually simple but much more computationally complex .",
    "gilbert and moore proposed a dynamic programming approach in 1959 for finding optimal alphabetic codes , and , unlike the hu - tucker algorithm , this approach is readily extensible to search trees@xcite .",
    "such an approach can also solve the nonalphabetic problem as a special case , e.g. , @xcite , since any probability vector satisfying @xmath84 for every @xmath24 has an optimal alphabetic code that optimizes the nonalphabetic case .",
    "a different dynamic programming approach can be used to find optimal `` 1''-ended codes@xcite and optimal codes with unequal letters costs@xcite .",
    "itai@xcite used dynamic programming to optimize a large variety of coding and search tree problems , including nonbinary length - limited coding , which is done with @xmath85 time and @xmath82 space by a reduction to the alphabetic case .",
    "we reduce complexity significantly in this paper .",
    "the third family is that of package - merge - based algorithms , and this is the type of approach we use for the generalized algorithm considered here",
    ". introduced in 1990 by larmore and hirschberg@xcite , this approach is most often used for binary length - limited linear - penalty huffman coding , although it has been extended for application to binary alphabetic codes @xcite and to binary convex quasiarithmetic penalty functions @xcite .",
    "the algorithms in this approach generally have @xmath86-time @xmath27-space complexity , although space complexity can vary by application and implementation , and the alphabetic variant and some nonquasiarithmetic ( and thus nonlinear ) variants have slightly higher time complexity ( @xmath87 ) .",
    "to use this approach for nonbinary coding with a lower bound on codeword length , we need to alter the approach , generalizing to the problem of interest .",
    "the minimum size constraint on codeword length requires a relatively simple change of solution range .",
    "the nonbinary coding generalization is a bit more involved ; it requires first modifying the package - merge algorithm to allow for an arbitrary numerical base ( binary , ternary , etc . ) , then modifying the coding problem to allow for a provable reduction to the modified package - merge algorithm . at times",
    "`` dummy '' inputs are added in order to assist in finding an optimal nonbinary code . in order to make the algorithm precise , the @xmath79-time @xmath27-space algorithm , unlike some other implementations@xcite",
    ", minimizes height ( that is , maximum codeword length ) among optimal codes ( if multiple optimal codes exist ) .",
    "before presenting an algorithm for optimizing the above problem , we introduce a notation for codes that generalizes one first presented in  @xcite and modified in @xcite .",
    "nodeset notation , an alternative to code tree notation , has previously been used for binary alphabets , but not for general @xmath15-ary alphabet coding , thus the need for generalization .    _ the key idea : _ each node @xmath88 represents both the share of the penalty ( [ penalty ] ) ( weight ) and the ( scaled ) share of the kraft sum ( [ kraft ] ) ( width ) assumed for the @xmath89th bit of the @xmath19th codeword . by showing that total weight is an increasing function of the penalty and that there is a one - to - one correspondence between an optimal code and a corresponding optimal nodeset , we reduce the problem to an efficiently solvable problem , the coin collector s problem .    in order to do this , we first need to make a modification to the problem analogous to one huffman made in his original nonbinary solution .",
    "we must in some cases add a `` dummy '' input or `` dummy '' inputs of infinitesimal probability @xmath90 to the probability vector to assure that the optimal code has the kraft inequality satisfied with equality , an assumption underlying both the huffman algorithm and ours .",
    "the positive probabilities of these dummy inputs mean that codes obtained could be slightly suboptimal , but we later specify an algorithm where @xmath91 , obviating this concern .    as with traditional huffman coding@xcite , the number of dummy values needed is @xmath92 , where @xmath93 for all integers @xmath67 ( not just nonnegative integers ) .",
    "such dummy inputs allow us to assume that the optimal tree ( for real plus dummy items ) is an optimal full tree ( i.e. , that @xmath94 , where @xmath95 is as defined in ( [ kraft ] ) ) . for sufficiently small @xmath96",
    ", the code will be identical to that for @xmath97 , and , as in traditional huffman coding , nondummy codewords are identical to the codewords of an optimal code for the original input distribution .",
    "we can thus assume for our algorithm that @xmath94 and @xmath98 .    with this we now present nodeset notation :",
    "a node is an ordered pair of integers @xmath99 such that @xmath100 and @xmath101 .",
    "call the set of all possible nodes  @xmath102 .",
    "this set can be arranged in an @xmath103 grid , e.g. , fig .",
    "[ nodesetnum ] .",
    "the set of nodes , or nodeset , corresponding to input symbol @xmath19 ( assigned codeword  @xmath31 with length  @xmath104 ) is the set of the first  @xmath105 nodes of column  @xmath19 , that is , @xmath106 .",
    "the nodeset corresponding to length vector  @xmath61 is @xmath107 ; this corresponds to a set of @xmath0 codewords , a code .",
    "thus , in fig .  [ nodesetnum ] , the dashed line surrounds a nodeset corresponding to @xmath108 .",
    "we say a node @xmath88 has width @xmath109 and weight @xmath110 , as shown in the example in fig .",
    "[ nodesetnum ] .",
    "note that if @xmath111 , @xmath112 .",
    "we must emphasize that the above `` nodes '' are unlike nodes in a graph ; similar structures are sometimes instead called tiles@xcite , but we retain the original , more prevalent term `` nodes . ''",
    "given valid nodeset @xmath113 , it is straightforward to find the corresponding length vector and , if it satisfies the kraft inequality , a code .",
    "we find optimal codes by first solving a related problem , the coin collector s problem .",
    "let @xmath114 denote the set of all integer powers of a fixed integer @xmath115 .",
    "the coin collector s problem of size @xmath116 considers `` coins '' indexed by @xmath117 .",
    "each coin has a width , @xmath118 ; one can think of width as coin face value , e.g. , @xmath119 for a quarter dollar ( 25 cents ) .",
    "each coin also has a weight , @xmath120 .",
    "the final problem parameter is total width , denoted  @xmath121 .",
    "the problem is then : @xmath122 we thus wish to choose coins with total width @xmath121 such that their total weight is as small as possible .",
    "this problem is an input - restricted variant of the knapsack problem .",
    "however , given sorted inputs , a linear - time solution to ( [ knap ] ) for @xmath43 was proposed in @xcite .",
    "the algorithm in question is called the package - merge algorithm and we extend it here to arbitrary  @xmath15 .    in our notation",
    ", we use @xmath123 to denote both the index of a coin and the coin itself , and @xmath124 to represent the @xmath116 items along with their weights and widths .",
    "the optimal solution , a function of total width @xmath121 and items @xmath124 , is denoted @xmath125 ( the optimal coin collection for @xmath124 and @xmath121 ) .",
    "note that , due to ties , this need not be unique , but we assume that one of the optimal solutions is chosen ; at the end of section  [ linear ] , we discuss how to break ties .    because we only consider cases in which a solution exists , @xmath126 for some @xmath127 and @xmath128 . here , assuming @xmath129 , @xmath130 and @xmath131 are the unique pair of a power of @xmath15 and an integer that is not a multiple of @xmath15 , respectively , which , multiplied , form  @xmath121 . if @xmath132 , @xmath131 and @xmath130 are not used .",
    "note that @xmath130 need not be an integer .",
    "* algorithm variables * + at any point in the algorithm , given nontrivial @xmath124 and @xmath121 , we use the following definitions :    [ cols=\">,^ , < \" , ]     @xmath133    where @xmath134 denotes integer multiples of @xmath15 and @xmath135 denotes that , for all @xmath136 and @xmath137 , @xmath138 .",
    "then the following is a recursive description of the algorithm :    @xmath133    * recursive @xmath15-ary package - merge procedure *    _ basis . @xmath132 _ : @xmath139 .",
    "@xmath140 and @xmath141 _ : @xmath142 .",
    "_ case 2a .",
    "@xmath143 , @xmath141 , and @xmath144 _ : @xmath145 .",
    "_ case 2b .",
    "@xmath143 , @xmath141 , and @xmath146 _ : create @xmath147 , a new item with weight @xmath148 and width @xmath149 .",
    "this new item is thus a combined item , or package , formed by combining the @xmath15 least weighted items of width  @xmath150 .",
    "let @xmath151 ( the optimization of the packaged version ) .",
    "if @xmath152 , then @xmath153 ; otherwise , @xmath154 .",
    "if an optimal solution to the coin collector s problem exists , the above recursive ( package - merge ) algorithm will terminate with an optimal solution .",
    "we show that the package - merge algorithm produces an optimal solution via induction on the number of input items .",
    "the basis is trivially correct , and each inductive case reduces the number of items by at least one . the inductive hypothesis on @xmath155 and @xmath141 is that the algorithm is correct for any problem instance with fewer input items than instance @xmath156 .",
    "if @xmath157 , or if @xmath158 and @xmath159 , then there is no solution to the problem , contrary to our assumption .",
    "thus all feasible cases are covered by those given in the procedure .",
    "case 1 indicates that the solution must contain at least one element ( item or package ) of width  @xmath150 .",
    "these must include the minimum weight item in @xmath160 , since otherwise we could substitute one of the items with this `` first '' item and achieve improvement .",
    "case  2 indicates that the solution must contain a number of elements of width @xmath150 that is a multiple of  @xmath15",
    ". if this number is  @xmath29 , none of the items in @xmath161 are in the solution",
    ". if it is not , then they all are .",
    "thus , if @xmath162 , the number is  @xmath29 , and we have case 2a . if not , we may `` package '' the items , considering the replaced package as one item , as in case 2b . thus the inductive hypothesis holds .",
    "[ pm ] presents a simple example of this algorithm at work for @xmath16 , finding minimum total weight items of total width @xmath163 ( or , in ternary , @xmath164 ) . in the figure",
    ", item width represents numeric width and item area represents numeric weight .",
    "initially , as shown in the top row , the minimum weight item has width @xmath165 .",
    "this item is put into the solution set , and the next step repeats the task on the items remaining outside the solution set .",
    "then , the remaining minimum width items are packaged into a merged item of width @xmath166 ( @xmath167 ) , as in the middle row .",
    "finally , the minimum weight item / package with width @xmath168 is added to complete the solution set , which is now of weight  @xmath12 .",
    "the remaining packaged item is left out in this case ; when the algorithm is used for coding , several items are usually left out of the optimal set .",
    "given input sorted first by width then weight , the resulting algorithm is @xmath169 time and space .",
    "we now formalize the reduction from the coding problem to the coin collector s problem .",
    "this generalizes the similar reduction shown in @xcite for binary codes with only a limit on maximum length , which is in turn a generalization of @xcite for length - limited binary codes with linear @xmath72 , the traditional penalty function .",
    "we assert that any optimal solution @xmath170 of the coin collector s problem with total width @xmath171 on coins @xmath124 ( identical to the set of all possible nodes @xmath102 ) is a nodeset for an optimal solution of the coding problem .",
    "this yields a suitable method for solving the problem .    to show this reduction",
    ", we first define @xmath172 in a natural manner for any @xmath173 : @xmath174 where @xmath175 is the kraft sum  ( [ kraft ] ) .",
    "given @xmath176 , all optimal codes have the kraft inequality satisfied with equality ; otherwise , the longest codeword length could be shortened by one , strictly decreasing the penalty without violating the inequality .",
    "thus the optimal solution has @xmath94 and @xmath177    also define : @xmath178 note that @xmath179 since the subtracted term is a constant , if the optimal nodeset corresponds to a valid code , solving the coin collector s problem solves this coding problem . to prove the reduction",
    ", we need to prove that the optimal nodeset indeed corresponds to a valid code .",
    "we begin with the following lemma :    [ lllemma ] suppose that @xmath170 is a nodeset of width @xmath180 where @xmath181 and @xmath67 are integers and @xmath182",
    ". then @xmath170 has a subset @xmath183 with width  @xmath184 .",
    "let us use induction on the cardinality of the set .",
    "the base case @xmath185 is trivial since then @xmath186 .",
    "assume the lemma holds for all @xmath187 , and suppose @xmath188 .",
    "let @xmath189 and @xmath190 .",
    "we can view item @xmath191 of width @xmath192 as the smallest contributor to the width of @xmath193 and @xmath184 as the portion of the @xmath15-ary expansion of the width of @xmath193 to the right of  @xmath194",
    ". then @xmath184 must be an integer multiple of  @xmath150 .",
    "if @xmath195 , @xmath196 is a solution .",
    "otherwise let @xmath197 ( so @xmath198 ) and let @xmath199 be the subset obtained from solving the lemma for set @xmath200 of width @xmath201",
    ". then @xmath202 .",
    "we now prove the reduction :    [ cceqll ] any @xmath170 that is a solution of the coin collector s problem for @xmath203 has a corresponding length vector @xmath204 such that @xmath205 and @xmath206 .",
    "any optimal length vector nodeset has @xmath207 .",
    "suppose @xmath170 is a solution to the coin collector s problem but is not a valid nodeset of a length vector .",
    "then there exists an @xmath88 with @xmath208 $ ] such that @xmath209 and @xmath210 .",
    "let @xmath211 .",
    "then @xmath212 and , due to convexity , @xmath213 .",
    "using @xmath214 , we know that @xmath121 is an integer multiple of @xmath215 .",
    "thus , using lemma  [ lllemma ] with @xmath216 , @xmath217 , and @xmath218 , there exists an @xmath219 such that @xmath220 . since @xmath221 , @xmath222",
    "this is a contradiction to @xmath170 being an optimal solution to the coin collector s problem , and thus any optimal solution of the coin collector s problem corresponds to an optimal length vector .    because the coin collector s problem is linear in time and space",
    " same - width inputs are presorted by weight , numerical operations and comparisons are constant time  the overall algorithm finds an optimal code in @xmath79 time and space .",
    "space complexity , however , can be decreased .",
    "if @xmath223 , we are guaranteed no particular inequality relation between @xmath104 and @xmath224 since we did not specify a method for breaking ties . thus the length vector returned by the algorithm need not have the property that @xmath225 whenever @xmath226 .",
    "we would like to have an algorithm that has such a monotonicity property .",
    "a monotonic nodeset , @xmath170 , is one with the following properties : @xmath227 in other words , a nodeset is monotonic if and only if it corresponds to a length vector @xmath61 with lengths sorted in increasing order ; this definition is equivalent to that given in @xcite",
    ".    examples of monotonic nodesets include the sets of nodes enclosed by dashed lines in fig .",
    "[ nodesetnum ] and fig .",
    "[ abcd ] . in the latter case , @xmath228 , @xmath229 , @xmath230 , and @xmath231 , so @xmath232 . as indicated ,",
    "if @xmath223 for some @xmath19 and @xmath233 , then an optimal nodeset need not be monotonic .",
    "however , if all probabilities are distinct , the optimal nodeset is monotonic .",
    "[ dmlemma ] if @xmath77 has no repeated values , then any optimal solution @xmath234 is monotonic .",
    "the second monotonic property ( [ validlen ] ) was proved for optimal nodesets in theorem  [ cceqll ] .",
    "the first property ( [ firstprop ] ) can be shown via a simple exchange argument .",
    "consider optimal @xmath61 with @xmath24 so that @xmath235 , and also consider @xmath236 with lengths for inputs @xmath19 and @xmath233 interchanged , as in @xcite .",
    "then @xmath237 \\\\",
    "\\quad \\leq 0   \\end{array}\\ ] ] where the inequality is to due to the optimality of  @xmath61 . since @xmath238 and @xmath72 is monotonically increasing",
    ", @xmath239 for all @xmath24 and an optimal nodeset without repeated @xmath77 must be monotonic .",
    "taking advantage of monotonicity in a package - merge coding implementation to trade off a constant factor of time for drastically reduced space complexity is done in @xcite for length - limited binary codes .",
    "we extend this to the length - bounded problem , first for @xmath77 without repeated values , then for arbitrary  @xmath77 .",
    "note that the total width of items that are each less than or equal to width @xmath240 is less than  @xmath241 .",
    "thus , when we are processing items and packages of width @xmath240 , fewer than @xmath242 packages are kept in memory . the key idea in reducing space complexity is to keep only four attributes of each package in memory instead of the full contents . in this manner",
    ", we use @xmath27 space while retaining enough information to reconstruct the optimal nodeset in algorithmic postprocessing .",
    "define @xmath243 for each package @xmath244 , we retain only the following attributes :    1 .",
    "@xmath245 2 .",
    "@xmath246 3 .",
    "@xmath247 4 .   @xmath248    where @xmath249 and @xmath250 .",
    "we also define @xmath251 .    with only these parameters , the `` first run '' of the algorithm takes @xmath27 space .",
    "the output of this run is the package attributes of the optimal nodeset @xmath170 .",
    "thus , at the end of this first run , we know the value for @xmath252 , and we can consider @xmath170 as the disjoint union of four sets , shown in fig .",
    "[ abcd ] :    1 .",
    "@xmath253 = nodes in @xmath254 with indices in @xmath255 $ ] , 2 .",
    "@xmath256 = nodes in @xmath254 with indices in @xmath257 $ ] , 3 .",
    "@xmath258 = nodes in @xmath259 , 4 .",
    "@xmath260 = nodes in @xmath261 .    due to the monotonicity of @xmath170 ,",
    "it is clear that @xmath262 \\times [ l_{\\min}+1 , l_\\mid-1]$ ] and @xmath263 \\times \\{l_\\mid\\}$ ] .",
    "note then that @xmath264 and @xmath265 .",
    "thus we need merely to recompute which nodes are in @xmath253 and in  @xmath260 .    because @xmath260 is a subset of @xmath266 , @xmath267 and @xmath268 .",
    "given their respective widths , @xmath253 is a minimal weight subset of @xmath255 \\times [ l_{\\min}+1,l_{\\mid}-1]$ ] and @xmath260 is a minimal weight subset of @xmath269 \\times [ l_{\\mid}+1,l_{\\max}]$ ] .",
    "these are monotonic if the overall nodeset is monotonic .",
    "the nodes at each level of @xmath253 and @xmath260 can thus be found by recursive calls to the algorithm .",
    "this approach uses only @xmath27 space while preserving time complexity ; one run of an algorithm on @xmath270 nodes is replaced with a series of runs , first one on @xmath270 nodes , then two on an average of at most @xmath271 nodes each , then four on an average of at most @xmath272 , and so forth .",
    "an optimization of the same complexity is made in @xcite , where it is proven that this yields @xmath79 time complexity with a linear space requirement .",
    "given the hard bounds for @xmath1 and @xmath4 , this is always @xmath273 .",
    "the assumption of distinct @xmath274 puts an undesirable restriction on our input that we now relax . in doing so",
    ", we make the algorithm deterministic , resolving ties that make certain minimization steps of the algorithm implementation dependent .",
    "this results in what in some sense is the `` best '' optimal code if multiple monotonic optimal codes exist .",
    "recall that @xmath77 is a nonincreasing vector .",
    "thus items of a given width are sorted for use in the package - merge algorithm ; this order is used to break ties .",
    "for example , if we look at the problem in fig .",
    "[ nodesetnum ]  @xmath275 , @xmath17 , @xmath16 , @xmath57 , @xmath46  with probability vector @xmath276 , then nodes @xmath277 , @xmath278 , and @xmath279 are the first to be grouped , the tie between @xmath279 and @xmath280 broken by order .",
    "thus , at any step , all identical - width items in one package have adjacent indices .",
    "recall that packages of items will be either in the final nodeset or absent from it as a whole .",
    "this scheme then prevents any of the nonmonotonicity that identical @xmath274 might bring about .    in order to assure that the algorithm is fully deterministic , the manner in which",
    "packages and single items are merged must also be taken into account .",
    "we choose to combine nonmerged items before merged items in the case of ties , in a similar manner to the two - queue bottom - merge method of huffman coding@xcite .",
    "thus , in our example , there is a point at which the node @xmath281 is chosen ( to be merged with @xmath282 and @xmath283 ) while the identical - weight package of items @xmath284 , @xmath285 , and @xmath286 is not .",
    "this leads to the optimal length vector @xmath108 , rather than @xmath287 or @xmath288 , which are also optimal .",
    "the corresponding nodeset is enclosed within the dashed line in fig .",
    "[ nodesetnum ] , and the resulting monotonic code tree is the code tree shown in fig .",
    "[ codetree ] .",
    "this approach also enables us to set @xmath96 , the value for dummy variables , equal to @xmath29 without violating monotonicity . as in bottom - merge huffman coding ,",
    "the code with the minimum reverse lexicographical order among optimal codes ( and thus the one with minimum height ) is the one produced ; reverse lexicographical order is the lexicographical order of lengths after their being sorted largest to smallest .",
    "an identical result can be obtained by using the position of the `` largest '' node in a package ( in terms of position number @xmath289 ) in order to choose those with lower values , as in @xcite . however",
    ", our approach , which can be shown to be equivalent via simple induction , eliminates the need for keeping track of the maximum value of @xmath289 for each package .",
    "there are changes we can make to the algorithm that , for certain inputs , result in even better performance .",
    "for example , if @xmath290 , then , rather than minimizing the weight of nodes of a certain total width , it is easier to maximize weight over a complementary total width and find the complementary set of nodes .",
    "similarly , if most input symbols have one of a handful of probability values , one can consider this and simplify calculations . these and other similar optimizations have been done in the past for the special case @xmath80 , @xmath291 , @xmath43@xcite , though we do not address or extend such improvements here .",
    "so far we have assumed that @xmath1 is the best upper bound on codeword length we could obtain .",
    "however , there are many cases in which we can narrow the range of codeword lengths , thus making the algorithm faster . for example , since , as stated previously , we can assume without loss of generality that @xmath292 , we can eliminate the bottom row of nodes from consideration in fig .",
    "[ nodesetnum ] .",
    "consider also when @xmath291 .",
    "an upper bound on @xmath293 can be derived from a theorem and a definition due to larmore :    consider penalty functions @xmath72 and  @xmath294 .",
    "we say that @xmath294 is flatter than @xmath72 if , for positive integers @xmath295 , @xmath296 .",
    "@xcite .",
    "a consequence of the convex hull theorem of @xcite is that , given @xmath294 flatter than @xmath72 , for any @xmath77 , there exist @xmath72-optimal @xmath297 and @xmath294-optimal @xmath298 such that @xmath297 is greater than @xmath298 in terms of reverse lexicographical order .",
    "this explains why the word `` flatter '' is used .",
    "penalties flatter than the linear penalty  i.e. , convex  @xmath72  can therefore yield a useful upper bound , reducing complexity .",
    "thus , if @xmath291 , we can use the results of a pre - algorithmic huffman coding of the input symbols to find an upper bound on codeword length in linear time , one that might be better than  @xmath1 .",
    "alternatively , we can use the least probable input to find a looser upper bound , as in @xcite .",
    "@xmath133    when @xmath299 , one can still use a modified pre - algorithmic huffman coding to find an upper bound as long as @xmath80 .",
    "this is done via a modification of the huffman algorithm allowing an arbitrary minimum @xmath4 and a trivial maximum ( e.g. , @xmath300 or @xmath301 ) :    * procedure for length - lower - bounded ( `` truncated huffman '' ) coding *    1 .   add @xmath92 dummy items of probability  @xmath29 .",
    "2 .   combine the items with the @xmath15 smallest probabilities @xmath302 into one item with the combined probability @xmath303 .",
    "this item has codeword @xmath304 , to be determined later , while these @xmath15 smallest items are assigned concatenations of this yet - to - be - determined codeword and every possible output symbol , that is , @xmath305 .",
    "since these have been assigned in terms of @xmath304 , replace the smallest @xmath15 items with @xmath306 in @xmath77 to form @xmath307 .",
    "3 .   repeat previous step , now with the remaining @xmath308 codewords and corresponding probabilities , until only @xmath309 items are left .",
    "4 .   assign all possible @xmath4 long codewords to these items , thus defining the overall code based on the fixed - length code assigned to these combined items .",
    "this procedure is huffman coding truncated midway through coding , the resulting trees serving as subtrees of nodes of identical depth . excluding the last step , the algorithm is identical to that shown in @xcite to result in an optimal huffman forest .",
    "the optimality of the algorithm for length - lower - bounded coding is an immediate consequence of the optimality of the forest , as both have the same constraints and the same value to minimize . as with the usual huffman algorithm , this can be made linear time given sorted inputs@xcite and can be made to find a code with the minimum reverse lexicographical order among optimal codes via the bottom - merge variant .",
    "clearly , this algorithm finds the optimal code for the length - bounded problem if the resulting code has no codeword longer than @xmath1 , whether this be because @xmath1 is trivial or because of other specifications of the problem .",
    "if this truncated huffman algorithm fails , then we know that @xmath310 , that is , we can not have that @xmath311 for the length - bounded code .",
    "this is an intuitive result , but one worth stating and proving , as it is used in the next section :    [ hclemma ] if a ( truncated ) huffman code ( @xmath312 ) for @xmath4 has a codeword longer than some @xmath313 , then there exists an optimal length - bounded code for bound @xmath314 $ ] with codewords of length @xmath313 .",
    "it suffices to show that , if an optimal code for the bound @xmath315 $ ] has a codeword with length @xmath1 , then an optimal code for the bound @xmath316 $ ] has a codeword with length @xmath317 , since this can be applied inductively from @xmath318 ( assuming @xmath319 is the length of the longest codeword of the truncated huffman code ) to @xmath313 , obtaining the desired result .",
    "the optimal nodeset @xmath170 for the bound @xmath320 $ ] has width @xmath321 .",
    "therefore , in the course of the package - merge algorithm , we at one point have @xmath322 packages of width @xmath215 which will eventually comprise optimal nodeset @xmath170 , these packages having weight no larger than the remaining packages of the same width .",
    "consider the nodeset @xmath200 formed by making each @xmath88 in @xmath170 into @xmath323 .",
    "this nodeset is the solution to the package - merge algorithm for the total width @xmath324 with bounds @xmath325 and @xmath317 .",
    "let @xmath326 denote the number of nodes on level @xmath89 .",
    "then @xmath327 since at most @xmath309 nodes can have length @xmath4 .",
    "the subset of @xmath200 not of depth @xmath325 is thus an optimal solution for bounds @xmath4 and @xmath317 with total width @xmath328 that is , at one point in the algorithm this solution corresponds to the @xmath329 least weighted packages of width @xmath215 . due to the bounds on @xmath330 , this number of packages is less than the number of packages of the same width in the optimal nodeset for bounds @xmath4 and @xmath317 ( with total width @xmath331 ) .",
    "thus an optimal nodeset to the shortened problem can contain the ( shifted - by - one ) original nodeset and must have its maximum length achieved for all input symbols for which the original nodeset achieves maximum length",
    ".    thus we can find whether @xmath332 by merely doing pre - algorithmic bottom - merge huffman coding ( which , when @xmath333 , results in reduced computation ) .",
    "this is useful in finding a faster algorithm for large @xmath334 and linear  @xmath72 .",
    "a somewhat different reduction , one analogous to the reduction of @xcite , is applicable if @xmath312 .",
    "this more specific algorithm has similar space complexity and strictly better time complexity unless @xmath335 .",
    "however , we only sketch this approach here roughly compared to our previous explanation of the simpler , more general approach .",
    "consider again the code tree representation , that using a @xmath15-ary tree to represent the code .",
    "a codeword is represented by successive splits from the root to a leaf  one split for each output symbol  so that the length of a codeword is represented by the length of the path to its corresponding leaf .",
    "a vertex that is not a leaf is called an internal vertex ; each internal vertex of the tree in fig .",
    "[ codetree ] is shown as a black circle .",
    "we continue to use dummy variables to ensure that @xmath336 , and thus an optimal tree has @xmath94 ; equivalently , all internal vertices have @xmath15 children .",
    "we also continue to assume without loss of generality that the output tree is monotonic .",
    "an optimal tree given the constraints of the problem will have no internal vertices at level @xmath1 , @xmath322 internal vertices in the @xmath334 previous levels , and @xmath337 internal vertices  with no leaves  in the levels above this , if any .",
    "the solution to a linear length - bounded problem can be expressed by the number of internal vertices in the unknown levels , that is , by @xmath338 \\end{array } \\label{alpha}\\ ] ] so that we know that @xmath339    if the truncated huffman coding algorithm ( as in the previous section ) fails to find a code with all @xmath340 , then we are assured that there exists an @xmath341 , so that @xmath342 can be assumed to be a sequence of strictly increasing integers .",
    "a strictly increasing sequence can be represented by a path on a different type of graph , a directed acyclic graph with vertices numbered @xmath29 to @xmath322 , e.g. , the graph of vertices in fig .",
    "the @xmath19th edge of the path begins at @xmath343 and ends at @xmath342 , and each @xmath342 represents the number of internal vertices at and below the corresponding level of the tree according to ( [ alpha ] ) .",
    "[ codetree ] shows a code tree with corresponding @xmath344 as a count of internal vertices .",
    "the path length is identical to the height of the corresponding tree , and the path weight is @xmath345 for edge weight function @xmath346 , to be determined .",
    "larmore and przytycka used such a representation for binary codes@xcite ; here we use the generalized representation for @xmath15-ary codes .    , @xmath16 , @xmath57 , @xmath347 ( @xmath312 ) ]    in order to make this representation correspond to the above problem , we need a way of making weighted path length correspond to coding penalty and a way of assuring a one - to - one correspondence between valid paths and valid monotonic code trees .",
    "first let us define the cumulative probabilities @xmath348 so that there are @xmath349 possible values for @xmath350 , each of which can be accessed in constant time after @xmath27-time preprocessing .",
    "we then use these values to weigh paths such that @xmath351 where we recall that @xmath66 denotes @xmath352 and @xmath353 is necessary for cases in which the numbers of internal vertices are incompatible ; this rules out paths not corresponding to valid trees .",
    "thus path length and penalty are equal , that is , @xmath354    this graph weighting has the concave monge property or quadrangle inequality , @xmath355 for all @xmath356 , since this inequality reduces to the already - assumed @xmath357 ( where @xmath358 for @xmath359 ) .",
    "[ dag ] shows such a graph .",
    "a single - edge path corresponds to @xmath360 while the two - edge path corresponds to @xmath361 . in practice",
    ", only the latter would be under consideration using the algorithm in question , since the pre - algorithmic huffman coding assured that @xmath362 .",
    "thus , if @xmath363 and @xmath364 we wish to find the minimum @xmath181-link path from @xmath29 to @xmath322 on this weighted graph of @xmath365 vertices . given the concave monge property , an @xmath366-time @xmath367-space algorithm for solving this problem is presented in @xcite . thus the problem in question can be solved in @xmath368 time and @xmath369 space  @xmath27 space if one counts the pre - algorithmic huffman coding and/or necessary reconstruction of the huffman code or codeword lengths  an improvement on the package - merge - based approach except for @xmath370 .",
    "one might wonder whether the time complexity of the aforementioned algorithms is the minimum achievable .",
    "special cases ( e.g. , @xmath371 for @xmath80 , @xmath291 , and @xmath43 ) can be addressed using modifications of the package - merge approach@xcite .",
    "also , @xmath77 often implies ranges of values , obtainable without coding , for @xmath372 and  @xmath319 .",
    "this enables one to use values of @xmath4 and @xmath1 that result in a significant improvement , as in @xcite for @xmath373 .",
    "an important problem that can be solved with the techniques in this paper is that of finding an optimal code given an upper bound on fringe , the difference between minimum and maximum codeword length .",
    "one might , for example , wish to find a fringe - limited prefix code in order to have a near - optimal code that can be simply implemented , as in section viii of  @xcite . such a problem is mentioned in @xcite , where it is suggested that if there are @xmath374 codes better than the best code having fringe at most @xmath375 , one can find this @xmath376-best code with the @xmath377-time algorithm in @xcite , thus solving the fringe - limited problem .",
    "however , this presumes we know an upper bound for @xmath376 before running this algorithm .",
    "more importantly , if a probability vector is far from uniform , @xmath376 can be very large , since the number of viable code trees is @xmath378@xcite .",
    "thus this is a poor approach in general .    instead , we can use the aforementioned algorithms for finding the optimal length - bounded code with codeword lengths restricted to @xmath379 $ ] for each @xmath380 , keeping the best of these codes ; this covers all feasible cases of fringe upper bounded by  @xmath375 .",
    "( here we again assume , without loss of generality , that @xmath336 . )",
    "the overall procedure thus has time complexity @xmath381 for the general convex quasiarithmetic case and @xmath382 when applying the algorithm of section  [ linpen ] to the most common penalty of expected length ; the latter approach is of lower complexity unless @xmath383 .",
    "both algorithms operate with only @xmath27 space complexity .",
    "the author wishes to thank zhen zhang for first bringing a related problem to his attention and david morgenthaler for constructive discussions on this topic .",
    "m.  j. golin and g.  rote , `` a dynamic programming algorithm for constructing optimal prefix - free codes for unequal letter costs , '' _ ieee trans .",
    "inf . theory _",
    "it-44 , no .  5 , pp . 17701781 , sept .",
    "1998 .        t.  c. hu , l.  l. larmore , and j.  d. morgenthaler , `` optimal integer alphabetic trees in linear time , '' in _ proc .",
    "13th annual european symposium on algorithms_.1em plus 0.5em minus 0.4emspringer - verlag , oct .",
    "2005 , pp . 226237 .    t.  c. hu and j.  d. morgenthaler , `` optimum alphabetic binary trees , '' in _ combinatorics and computer science _",
    "lecture notes in computer science , vol .",
    "1120.1em plus 0.5em minus 0.4emspringer - verlag , aug . 1996 , pp . 234243 .",
    "a.  rnyi , _ a diary on information theory_.1em plus 0.5em minus 0.4emnew york , ny : john wiley & sons inc . , 1987 , original publication : _ napl az informcielmletrl _ , gondolat , budapest , hungary , 1976 ."
  ],
  "abstract_text": [
    "<S> efficient optimal prefix coding has long been accomplished via the huffman algorithm . however , there is still room for improvement and exploration regarding variants of the huffman problem . </S>",
    "<S> length - limited huffman coding , useful for many practical applications , is one such variant , for which codes are restricted to the set of codes in which none of the @xmath0 codewords is longer than a given length , @xmath1 . </S>",
    "<S> binary length - limited coding can be done in @xmath2 time and @xmath3 space via the widely used package - merge algorithm and with even smaller asymptotic complexity using a lesser - known algorithm . in this paper </S>",
    "<S> these algorithms are generalized without increasing complexity in order to introduce a minimum codeword length constraint @xmath4 , to allow for objective functions other than the minimization of expected codeword length , and to be applicable to both binary and nonbinary codes ; nonbinary codes were previously addressed using a slower dynamic programming approach . </S>",
    "<S> these extensions have various applications  including fast decompression and a modified version of the game `` twenty questions ''  and can be used to solve the problem of finding an optimal code with limited fringe , that is , finding the best code among codes with a maximum difference between the longest and shortest codewords . </S>",
    "<S> the previously proposed method for solving this problem was nonpolynomial time , whereas solving this using the novel linear - space algorithm requires only @xmath5 time , or even less if @xmath6 is not @xmath7 . </S>"
  ]
}