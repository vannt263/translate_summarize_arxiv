{
  "article_text": [
    "a trapezoid diagram consists of two horizontal lines and a set of trapezoids with corner points lying on these two lines .",
    "a graph @xmath3 is a trapezoid graph when a trapezoid diagram exists with trapezoid set @xmath4 , such that each vertex @xmath5 corresponds to a trapezoid @xmath6 $ ] and an edge exists @xmath7 if and only if trapezoids @xmath6 $ ] and @xmath8 $ ] intersect within the trapezoid diagram . a trapezoid @xmath6 $ ] between these lines has four corner points @xmath9 $ ] , @xmath10 $ ] , @xmath11 $ ] and @xmath12 $ ]  which represent the upper left , upper right , lower left and lower right corner points of trapezoid  @xmath13 , respectively .",
    "no two trapezoids share a common endpoint ( see figure [ fig : example ] ) .",
    "trapezoid graphs were first investigated by corneil and kamula @xcite .",
    "these graphs and their generalizations were applied in various fields , including modeling channel routing problems in vlsi design @xcite and identifying the optimal chain of non - overlapping fragments in bioinformatics  @xcite . given some labeled terminals on the upper and lower side of a two - sided channel , terminals with the same label will be connected in a common net .",
    "each net can be modeled by a trapezoid that connects rightmost and leftmost terminals of that net on two horizontal lines . in the channel routing problem",
    "we want to connect all terminals of each net so that no two nets intersect .",
    "one can show @xcite that two nets can be routed without intersection in the same layer if and only if their corresponding trapezoids do not intersect .",
    "therefore , the number of colors needed to color the trapezoid graph is the number of layers needed to route the nets without intersection .",
    "let @xmath2 and @xmath14 denote the number of vertices and edges of a trapezoid graph @xmath0 .",
    "ma and spinrad @xcite showed that trapezoid graphs can be recognized in @xmath15 time , while mertzios and corneil @xcite designed structural trapezoid recognition algorithm based on the vertex splitting method in @xmath16 time , which is easier for implementation .",
    "trapezoid graphs are perfect , subclass of cocomparability graphs and properly contain both interval graphs and permutation graphs .",
    "if @xmath9 = b [ i]$ ] and @xmath11 = d [ i]$ ] then the corresponding trapezoid @xmath6 $ ] reduces to a straight line , and the trapezoid graph reduces to a permutation graph if the condition holds for all @xmath17 .",
    "similarly , the trapezoid graph reduces to the interval graph if @xmath18 = c [ i]$ ] and @xmath10 = d [ i]$ ] for all @xmath13 .",
    "[ fig : example ]    many common graph problems , such as minimum connected dominating sets @xcite , all - pair shortest paths @xcite , maximum weighted cliques @xcite , all cut vertices @xcite , chromatic number and clique cover @xcite , all hinge vertices @xcite in trapezoid graphs , can be solved in polynomial time . for other related problems",
    "see @xcite .",
    "recently , lin and chen @xcite presented @xmath19 algorithms for counting the number of vertex covers ( vc ) , minimal vcs , minimum vcs and maximum minimal vcs in a trapezoid graph .",
    "ili ' c and ili ' c @xcite improved algorithms for calculating the size and the number of minimum vertex covers ( or independent sets ) , as well as the total number of vertex covers , and reduce the time complexity to @xmath20 .",
    "ghosh and pal @xcite presented an efficient algorithm to find the maximum matching in trapezoid graphs , which turns out to be not correct @xcite .",
    "let @xmath3 be a simple undirected graph with @xmath21 .",
    "a vertex cut or separating set of a connected graph @xmath0 is a set of vertices whose removal disconnects @xmath0 .",
    "the connectivity or vertex connectivity @xmath22 ( where @xmath0 is not complete ) is the size of a smallest vertex cut .",
    "a graph is called @xmath23connected or @xmath23vertex  connected if its vertex connectivity is greater than or equal to @xmath23 . a complete graph with @xmath2 vertices , denoted by @xmath24 ,",
    "has no vertex cuts , but by convention @xmath25 . a connected graph",
    "is said to be separable if its vertex connectivity is one . in that case , a vertex which disconnects the graph is called a cut - vertex or an articulation point .",
    "the edge cut of @xmath0 is a group of edges whose total removal disconnects the graph .",
    "connectivity @xmath26 is the size of a smallest edge cut . in the simple case",
    "in which cutting a single edge would disconnect the graph , that edge is called a bridge .",
    "let @xmath27 be minimum vertex degree of @xmath0 , then @xmath28    since the strength of the network @xmath0 is proportional to @xmath22 , graph connectivity is one of the most fundamental problem in graph theory .",
    "even and tarjan @xcite have obtained @xmath29 time sequential algorithm for finding vertex connectivity of a general graph .",
    "the authors in @xcite obtained parallel algorithm for testing @xmath23vertex connectivity in interval graphs .",
    "ghosh and pal in @xcite presented rather complicated algorithm with a lot of different cases to solve the vertex connectivity problem , which takes @xmath15 time and @xmath30 space for a trapezoid graph . in this paper , we designed an algorithm with time complexity @xmath31 for calculating the vertex connectivity of a trapezoid graph .",
    "the rest of the paper is organized as follows . in section 2",
    "we introduce the modified binary indexed tree data structure . in section 3",
    "we design @xmath1 time algorithm for calculating the vertex connectivity of trapezoid graphs , improving the algorithm from @xcite . in section 4",
    "we establish sufficient and necessary condition for a trapezoid graph @xmath0 to be bipartite and characterize trees that can be represented as trapezoid graphs .",
    "we close the paper in section 5 by proposing topics for the further research .",
    "the binary indexed tree ( bit ) is an efficient data structure for maintaining the cumulative frequencies .",
    "we will modify this standard structure to work with minimal / maximal partial summations .",
    "let @xmath32 be an array of @xmath2 elements .",
    "the modified binary indexed tree ( mbit ) supports the following basic operations :    1 .   for given value @xmath33 and index @xmath13 ,",
    "add @xmath33 to the element @xmath34 $ ] , @xmath17 ; 2 .   for given interval @xmath35 $ ] , find the sum of values @xmath36 , a [ 2 ] , \\ldots , a [ i]$ ] , @xmath17 .",
    "3 .   for given interval @xmath35 $ ] , find the minimum value among partial sums @xmath36 , a [ 1 ] + a [ 2 ] , a [ 1 ] + a [ 2 ] + a [ 3 ] , \\ldots , a [ 1 ] + a [ 2 ] + \\ldots + a [ i]$ ] , @xmath37 .",
    "naive implementation of these operations have complexities @xmath38 , @xmath30 and @xmath30 , respectively .",
    "we can achieve better complexity , if we speed up the second and third operation which will also affect the first operation .",
    "the main idea of the modified binary indexed tree structure is that sum of elements from the segment @xmath35 $ ] can be represented as sum of appropriate set of subsegments .",
    "the mbit structure is based on decomposition of the cumulative sums into segments and the operations to access this data structure are based on the binary representation of the index . this way the time complexity for all operations will be the same @xmath39 .",
    "the structure is a complete binary tree with the root node 1 .",
    "its leafs correspond to the elements from the array @xmath32 , starting from left to right in the last level .",
    "therefore , the elements of the array @xmath32 are stored at the positions starting from @xmath40 to @xmath41 , where @xmath42 is the depth of the binary tree ( defined as the smallest integer such that @xmath43 ) .",
    "the internal nodes store the cumulative values of the leafs in the subtrees rooted at these nodes .",
    "this implies that the value of the internal node @xmath13 is just the cumulative value of its two children .",
    "the parent of the node @xmath13 is @xmath44 , while the left and the right child of the node @xmath13 are @xmath45 = 2i$ ] and @xmath46 = 2i + 1 $ ] , respectively . by definition",
    ", it follows that the number of nodes in mbit is at most @xmath47 , while the depth is @xmath48 .",
    "in addition to the values of the array @xmath32 , for each node we will keep two information : @xmath49 $ ] will be the sum of the @xmath34 $ ] values of all nodes in @xmath33 s subtree , and @xmath50 $ ] will be the minimum possible cumulative sum of @xmath34 $ ] s in the subtree rooted at @xmath33 ( starting at the leftmost node in the subtree ) .",
    "we will demonstrate how to compute these fields using only information at each node and its children .",
    "the sum of the @xmath51 $ ] s of the subtree rooted at node @xmath33 will simply be @xmath52 = sum [ 2x ] + sum [ 2x + 1].\\ ] ]    the minimum cumulative sum can either be in the left subtree or in the right subtree . if it is in the left subtree , it is simply @xmath53 $ ] , while if it is in the right subtree , we have to add the cumulative sum up till the right subtree to the minimum value of the right subtree @xmath54 + min\\_sum [ right [ x]]$ ] . finally , we get @xmath55 = \\min ( min\\_sum [ 2x ] , sum [ 2x ] + min\\_sum [ 2x + 1]).\\ ] ]    for the update procedure , we just need to traverse the vertices from the leaf to the root and update the values in the parent vertices based on the above formulas . for the query procedure ,",
    "we traverse the binary tree in a top - down manner starting from the root vertex @xmath56 .",
    "the important thing it to maintain the partial sums of the array @xmath32 ( starting from @xmath36 $ ] ) .",
    "if the leaf that stores @xmath57 $ ] belongs to the left child  we just go left and do nothing ; otherwise we update the partial sum of the left subtree and the index , and go right .    for detailed implementation see algorithms 1 and 2 .",
    "the structure is space - efficient in the sense that it needs the same amount of storage as just a simple array of @xmath2 elements .",
    "furthermore we can use fast bitwise operations ( xor , and , shift left ) for more efficient implementation .    calculating the sum of the elements from @xmath36 $ ] to @xmath34 $ ] , calculating the minimum value among partial sums @xmath36 , a [ 1 ] + a [ 2 ] , \\ldots , a [ 1 ] + a [ 2 ] + \\ldots + a [ i]$ ] , and updating the element @xmath34 $ ] in the modified binary indexed tree",
    "is performed in @xmath58 time , @xmath37 .",
    "@xmath59 @xmath60 = value$ ] @xmath61 = value$ ]    @xmath62 @xmath63 @xmath64 @xmath65 @xmath66    this approach is very similar to the problem regarding calculating the point of maximum overlap among intervals ( see @xcite problem 14 - 1 ) , that can be solved using red - black trees .",
    "let @xmath67 and @xmath68 . the elements of the array @xmath32 will be stored on positions @xmath69 $ ] to @xmath70 $ ] and @xmath71 $ ] to @xmath72 $ ] .",
    "the node 5 will contain the following information @xmath73 = sum [ 20 ] + sum [ 21 ] + sum [ 22 ] + sum [ 23 ] = a [ 5 ] + a [ 6 ] + a [ 7 ] + a [ 8]\\ ] ] @xmath74 = \\min ( a [ 5 ] , a [ 5 ] + a [ 6 ] , a [ 5 ] + a [ 6 ] + a [ 7 ] , a [ 5 ] + a [ 6 ] + a [ 7 ] + a [ 8]).\\ ] ]    if we change the value @xmath75 $ ] , we will start from the corresponding index @xmath76 and change the following nodes of the modified binary index tree : 21 , 10 , 5 , 2 and 1 .",
    "if we want to calculate the minimum among partial sums with elements @xmath36 , a [ 2 ] , \\ldots , a [ 13]$ ] , we calculate the following minimum @xmath77 , sum [ 2 ] + min\\_sum [ 6 ] , sum [ 2 ] + sum [ 6 ] + min\\_sum [ 28 ] \\right).\\ ] ]",
    "let @xmath78 denote the set of trapezoids in the trapezoid graph @xmath3 . for simplicity",
    ", the trapezoid in @xmath4 that corresponds to vertex @xmath13 in @xmath79 is called trapezoid @xmath6 $ ] . without loss of generality ,",
    "the points on each horizontal line of the trapezoid diagram are labeled with distinct integers between @xmath56 and @xmath47 .",
    "trapezoid @xmath13 lies entirely to the left of trapezoid @xmath80 , denoted by @xmath81 , if @xmath10 < a [ j]$ ] and @xmath12 < c [ j]$ ] .",
    "it follows that @xmath82 is a partial order over the trapezoid set @xmath4 and @xmath83 is a strictly partially ordered set .",
    "@xcite two vertices @xmath6 $ ] and @xmath8 $ ] of a trapezoid graph are not adjacent iff either ( @xmath13 ) @xmath10 < a [ j]$ ] and @xmath12 < c [ j]$ ] or ( @xmath84 ) @xmath85 < a [ i]$ ] and @xmath86 < c [ i]$ ] .",
    "define a cut line as line @xmath42 that passes through the intervals @xmath87 and @xmath88 on the upper and the bottom horizontal line , respectively , and does not contain the integer points @xmath89 . for a such cut , let @xmath90 be the number of trapezoids that have common points with the line @xmath42 .",
    "define @xmath91 if there are no trapezoids completely left and no trapezoids completely right of the line @xmath42 .",
    "let @xmath92 be a trapezoid graph .",
    "then @xmath93    let @xmath94 be a vertex cut of the graph @xmath0 with the minimum cardinality @xmath22 .",
    "the removal of @xmath94 disconnects @xmath0 , and consider the component @xmath95 that contains a trapezoid with the smallest upper left corner @xmath9 $ ] .",
    "let @xmath33 be the maximum value among upper right corners in the component  @xmath95 , @xmath96 $ ] , and let @xmath97 be the maximum value among lower right corners in the component  @xmath95 , @xmath98 $ ] . since the right border of trapezoids from @xmath95 form concave broken line  the line @xmath42 that passes through intervals @xmath87 and @xmath99 is one cut of a trapezoid graph .",
    "it follows that @xmath100 .",
    "the other inequality follows immediately , and this completes the proof .",
    "note that in the above theorem the points @xmath101 and @xmath102 , as well as @xmath103 and @xmath104 , can be excluded from the consideration .",
    "therefore , one can traverse all values @xmath33 and @xmath97 and compute the number of trapezoids that have non - empty intersection with the line @xmath42 determined by the intervals @xmath87 and @xmath88 .",
    "the important thing is to ensure that there are trapezoids lying entirely to the left and to the right of the line @xmath42 .",
    "this can be easily done in @xmath19 .",
    "we will first precompute the leftmost and the rightmost trapezoids for each interval @xmath87 from the upper line .",
    "let @xmath105 be the index of a trapezoid with @xmath106 \\leq x$ ] and minimal lower right corner @xmath107 .",
    "similarly let @xmath108 be the index of a trapezoid with @xmath109 \\geq x + 1 $ ] and maximal lower left corner @xmath110 .",
    "if there are no such trapezoids , set the values of @xmath105 and @xmath108 to @xmath111 .",
    "we need additional arrays @xmath112 and @xmath113 , such that @xmath114 $ ] contains the index of the trapezoid with the left or right coordinate equal to @xmath80 on the upper line , and similarly for the bottom line .",
    "this can be done in linear time @xmath115 as shown in algorithm  [ alg : leftmost ] ( implementation for the @xmath108 array is similar and , thus , omitted ) .",
    "[ alg : leftmost ]    @xmath116 = -1 $ ] @xmath105    we will traverse the coordinates on the upper line from @xmath101 to @xmath102 , and skip the values with @xmath117 = -1 $ ] or @xmath118 = -1 $ ] . for each value @xmath97 between",
    "@xmath119 $ ] and @xmath120 $ ] , we need to calculate the number of trapezoids @xmath90 that cut the line @xmath42 .",
    "the trapezoid @xmath6 $ ] cuts the line @xmath42 if    * it contains the interval @xmath87 ; * it is left trapezoid with the lower right corner greater than @xmath97 , i. e. if @xmath10 \\leq x$ ] and @xmath12 > y$ ] ; * it is right trapezoid with the lower left corner less than or equal to @xmath97 , i. e. if @xmath9 > x$ ] and @xmath11 \\leq y$ ] .",
    "furthermore , we will maintain the binary array @xmath121 of length @xmath2 that indicates whether the trapezoid @xmath6 $ ] contains the interval @xmath87 .",
    "in other words , @xmath122 = true$ ] if and only if @xmath9 \\leq x <",
    "x + 1 \\leq b [ i]$ ] .",
    "since no two trapezoids have a common corner , we can update this array in the constant time by traversing from @xmath33 to @xmath123 .",
    "therefore , for each trapezoid @xmath124 $ ] with @xmath122 = true$ ] we easily check whether this trapezoid is on the left of @xmath33 or on the right of  @xmath33 .",
    "we can also keep the number of left and right trapezoids in the variables @xmath125 and @xmath126 ( see algorithm [ alg : new ] ) .    in order to calculate the minimum value @xmath90 for the fixed @xmath33 coordinate ,",
    "we will traverse @xmath97 coordinates , and count the number of trapezoids with @xmath122 = false$ ] that intersect the line  @xmath42 .",
    "the idea is to calculate the cumulative sum by adding @xmath127 for each coordinate @xmath11 $ ] of right trapezoids and by adding @xmath111 for each coordinate @xmath12 $ ] of left trapezoids .",
    "the starting value of the cumulative sum is @xmath125 .",
    "the number @xmath90 is equal to the number of trapezoids that contain the interval @xmath87 plus the cumulative sum .",
    "the pseudo - code of this approach is given in algorithm [ alg : quadratic ] .",
    "[ alg : quadratic ]    @xmath128 @xmath129    the vertex connectivity of the graph @xmath0 in figure [ fig : example ] is two . for @xmath130",
    ", we have the following parameters @xmath131 , @xmath132 , @xmath133 = true$ ] and @xmath122 = false$ ] for @xmath134 and @xmath135 .",
    "the execution of algorithm [ alg : quadratic ] is presented in table 1 .",
    "[ tab : example ]    l|llllllllllllllll @xmath13 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 + @xmath105 & -1 & -1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 + @xmath108 & 7 & 7 & 7 & 7 & 7 & 7 & 7 & 7 & 7 & 7 & 7 & 8 & 8 & -1 & -1 & -1 + @xmath32 & 0 & 0 & -1 & -1 & 0 & 0 & 0 & -1 & 0 & -1 & 0 & 1 & -1 & 1 & 0 & 0 + @xmath136 & 5 & 5 & 4 & 3 & 3 & 3 & 3 & 2 & 2 & 1 & 1 & 2 & 1 & 2 & 2 & 2 +    from the above table , we conclude that the minimum value of cumulative sums from @xmath137 to @xmath138 equals 1 and it is achieved for @xmath139 .",
    "this shows that the vertex connectivity of @xmath0 is less than or equal to @xmath140 .",
    "for the efficient implementation , we will use the modified binary indexed tree data structure . the array @xmath32 will correspond to the lower coordinates from @xmath56 to @xmath47 . for each trapezoid",
    "@xmath6 $ ] with @xmath122 = false$ ] , assign @xmath141 = 0 $ ] and @xmath142 = -1 $ ] if @xmath6 $ ] is a left trapezoid , and assign @xmath141 = 1 $ ] and @xmath142 = 0 $ ] if @xmath6 $ ] is a right trapezoid . in order to find the minimum value of @xmath90 for @xmath143 , we can just return @xmath144)$ ] .",
    "the only problem is to ensure that there is at least one left trapezoid for each unit interval @xmath87 .",
    "we can solve this by setting @xmath145 for the value @xmath146]$ ] and taking this into account when calculating the minimum values .",
    "the number @xmath147 is big enough and all partial sums before the index @xmath117 $ ] will be greater than @xmath2 ( we update the vertex connectivity only if @xmath90 is less than or equal to @xmath2 ) . at the end",
    "we need to handle the special case  when @xmath0 is a complete graph .",
    "the pseudo - code of this algorithm is presented below .",
    "[ alg : new ]    @xmath148 @xmath149 @xmath150    ( ) @xmath151    since every trapezoid will be added and removed exactly once from the modified binary indexed tree data structure , the total time complexity is @xmath1 .",
    "this modified data structure with variable left ends is a novel approach to the best of our knowledge and makes this problem very interesting .",
    "we conclude this section by summing the results in the following theorem .",
    "the proposed algorithm calculates the vertex connectivity of a trapezoid graph with @xmath2 vertices in time @xmath1 and space @xmath115 .",
    "in this section we establish local test for bipartiteness of trapezoid graphs .",
    "[ thm : bipartite ] the trapezoid graph @xmath0 is bipartite if and only if it does not contain a triangle .",
    "the first part directly follows from the well - known result : the graph @xmath0 is bipartite if and only if it does not contain odd cycles .",
    "let @xmath0 be a triangle - free trapezoid graph and let @xmath152 t [ 2 ] \\ldots t [ k]$ ] be the smallest odd cycle contained in @xmath0 with @xmath153 .",
    "it can be easily seen that there are no chords in @xmath95 , i. e. there are no edges of the form @xmath6 t [ j]$ ] with @xmath154 ( otherwise we could find smaller odd cycle ) .",
    "consider the intersection of the trapezoids @xmath155 $ ] and @xmath156 $ ] . if their intersection is a trapezoid with height equal to the distance of two parallel lines ( see the first part of figure [ fig : bipartite1 ] ) , then all trapezoids @xmath157 , t [ 4 ] , \\ldots , t [ k]$ ] must be on the right side of @xmath155 $ ]  which is impossible , since @xmath158 $ ] must have common points with @xmath155 $ ] .",
    "otherwise , the trapezoids @xmath155 $ ] and @xmath156 $ ] have intersection as shown in the second part of figure [ fig : bipartite1 ] . without loss of generality",
    "we can assume that the trapezoids @xmath157 $ ] and @xmath158 $ ] are independent and positioned as shown in the figure . in order to connect the trapezoids @xmath157 $ ] and @xmath158 $ ] by a path of trapezoids @xmath159 t [ 5 ] \\ldots t [ k - 1]$ ]  some trapezoids of this path must intersect either @xmath155 $ ] or @xmath156 $ ] , which is impossible .",
    "therefore , the graph @xmath0 does not contain cycles of odd length and it follows that @xmath0 is bipartite .",
    "[ fig : bipartite1 ]    note that from the above proof it follows that each cycle of length greater than four contains a chord ( an edge joining two nodes that are not adjacent in the cycle ) .",
    "a caterpillar graph is a tree such that if all pendent vertices and their incident edges are removed , the remainder of the graph forms a path .",
    "let @xmath160 be a caterpillar with @xmath2 vertices obtained from a path @xmath161 by attaching @xmath162 pendent vertices to the vertex @xmath163 , @xmath164 , where @xmath165 .",
    "it can be easily seen that each caterpillar @xmath166 has trapezoid representation as triangle - free interval graph @xcite .",
    "assume now that tree @xmath0 is not a caterpillar and has trapezoid representation .",
    "then it contains a vertex @xmath167 with neighbors @xmath168 , such that each vertex @xmath163 has another neighbor @xmath169 different than @xmath167 , @xmath170 .",
    "the trapezoids @xmath171 $ ] , @xmath172 $ ] and @xmath173 $ ] corresponding to the vertices @xmath174 , @xmath175 and @xmath176 are independent . without loss of generality we can assume the order @xmath171 \\ll t [ v_2 ] \\ll t [ v_3]$ ] . since all trapezoids @xmath171 $ ] , @xmath172 $ ] and @xmath177 $ ] intersect the trapezoid @xmath178 $ ] , it can be easily seen that all neighbors of @xmath172 $ ] ( trapezoid @xmath179 $ ] in particular ) also must intersect @xmath178 $ ] .",
    "this is a contradiction , and @xmath0 does not have trapezoid representation .",
    "therefore , we proved the following    [ thm : trees ] a trapezoid graph @xmath0 represents a tree if and only if it is a caterpillar .",
    "in this paper we presented an efficient algorithm for calculating the vertex connectivity number @xmath22 of a trapezoid graph .",
    "we leave as an open problem to design efficient algorithm for finding the edge connectivity number @xmath26 in trapezoid graphs .",
    "the @xmath23trapezoid graphs are an extension of trapezoid graphs to higher dimension orders .",
    "the @xmath23dimensional box representation @xmath180 of a graph @xmath3 consists of mappings @xmath181 and @xmath182 such that @xmath183 $ ] is the lower and @xmath184 $ ] the upper corner of a box @xmath185 $ ] where two vertices of the graph are joined by an edge iff their corresponding boxes are incomparable @xcite .",
    "if a graph has such a representation , it is a @xmath23trapezoid graph .",
    "if we additionally have a weight @xmath186 on the vertices of @xmath0 then the @xmath23trapezoid graph is weighted .",
    "for the case @xmath187 , we have simple trapezoid graphs .",
    "another generalization are circular trapezoid graphs  the intersection graphs of circular trapezoids between two parallel ( concentric ) circles @xcite .",
    "it seems that the presented approach can be modified and adapted for calculating the vertex connectivity number of @xmath23trapezoid graphs and circular trapezoid graphs ."
  ],
  "abstract_text": [
    "<S> the intersection graph of a collection of trapezoids with corner points lying on two parallel lines is called a trapezoid graph . </S>",
    "<S> these graphs and their generalizations were applied in various fields , including modeling channel routing problems in vlsi design and identifying the optimal chain of non - overlapping fragments in bioinformatics . using modified binary indexed tree data structure , we design an algorithm for calculating the vertex connectivity of trapezoid graph @xmath0 with time complexity @xmath1 , where @xmath2 is the number of trapezoids . </S>",
    "<S> furthermore , we establish sufficient and necessary condition for a trapezoid graph @xmath0 to be bipartite and characterize trees that can be represented as trapezoid graphs .    </S>",
    "<S> * keywords : * trapezoid graphs ; vertex connectivity ; algorithms ; binary indexed tree .    * </S>",
    "<S> ams classifications : * 05c85 , 68r10 , 05c40 . </S>"
  ]
}