{
  "article_text": [
    "* background .",
    "* leader election is a basic symmetry breaking problem in distributed computing @xcite .",
    "all nodes of a network have to agree on a single node , called the leader . performing",
    "leader election is essential in applications where a single node has to subsequently broadcast a message to coordinate some network task , or when all nodes have to transmit data to a single node .",
    "if the nodes of the network have distinct labels , then agreeing on a single node means that all nodes have to output the label of the elected leader .",
    "however , in many applications , even if nodes have distinct identities , they may refuse to reveal them , e.g. , for privacy or security reasons .",
    "hence , it is often important to design leader election algorithms that do not depend on the knowledge of such labels . thus we model networks as anonymous graphs . under this scenario ,",
    "we formulate the leader election problem as in @xcite : every node has to output a simple path ( coded as a sequence of port numbers ) from it to a common node .",
    "* model and problem description .",
    "* we focus on deterministic leader election algorithms for trees .",
    "the network is modeled as a simple undirected tree with @xmath1 nodes and diameter @xmath2 .",
    "nodes do not have any identifiers . on the other hand , we assume that , at each node @xmath3 , each edge incident to @xmath3 has a distinct _ port number _ from @xmath4 , where @xmath5 is the degree of @xmath3 .",
    "hence each edge has two corresponding port numbers , one at each of its endpoints .",
    "port numbering is _ local _ to each node , i.e. , there is no relation between port numbers at the two endpoints of an edge .",
    "initially , each node knows only its own degree .",
    "the task of leader election is formally defined as follows .",
    "every node @xmath3 of the tree must output a sequence @xmath6 of nonnegative integers .",
    "for each node @xmath3 , let @xmath7 be the path starting at @xmath3 that results from taking the number @xmath8 from @xmath9 as the outgoing port at the @xmath10 node of the path .",
    "all paths @xmath7 must be simple paths in the tree that end at a common node , called the leader .",
    "note that , in the absence of port numbers , there would be no way to identify the elected leader by non - leaders , as all ports , and hence all neighbors , would be indistinguishable to a node .",
    "the above mentioned security and privacy reasons for not revealing node identifiers are irrelevant in the case of port numbers .",
    "our aim is to establish tradeoffs between the allocated time and the amount of information that has to be given _ a priori _ to the nodes to enable them to perform leader election .",
    "following the framework of _ algorithms with advice _ , see , e.g. , @xcite , this information is provided to all nodes at the start by an oracle knowing the entire tree , in the form of binary strings assigned to all nodes .",
    "there are two possible variants of formulating this advice assignment .",
    "either the strings provided to all nodes are all identical @xcite , or strings assigned to different nodes may be potentially different , i.e. , advice can be _ customized _ @xcite .",
    "as opposed to previous papers on leader election with advice @xcite , in this paper we consider the latter option .    for a given tree @xmath11 , the advice assigned by the oracle to nodes of @xmath12 is formally defined as a function @xmath13 , where @xmath14 is the set of finite binary strings .",
    "the string @xmath15 , given by the oracle to node @xmath3 , is an input to a leader election algorithm .",
    "apart from @xmath15 , node @xmath3 knows a priori only its own degree .",
    "the maximum of all lengths of strings @xmath15 , for @xmath16 , is called the _ size of advice_. the size of the range @xmath17 is called the _ valency of advice_. when valency is 1 , the advice given to all nodes is identical .",
    "as mentioned above , in this paper we assume that valency of advice is larger than 1 .",
    "we consider two scenarios . in the first one ,",
    "valency is unbounded , i.e. , every node can potentially get a different advice string . in the second scenario",
    ", we bound valency of possible advice by a constant @xmath18 .",
    "this may be important in some applications , as a small number of binary strings may be sometimes easier to distribute among nodes .",
    "we use the well - known @xmath19 communication model @xcite .",
    "communication proceeds in synchronous rounds and all nodes start simultaneously .",
    "model can be simulated in an asynchronous network using time stamps .",
    "] in each round , each node can exchange arbitrary messages with all of its neighbors , and perform arbitrary local computations . for any tree @xmath12 ,",
    "any advice @xmath20 given to the nodes of @xmath12 , any node @xmath3 , and any nonnegative integer @xmath0 , we define the _ labeled ball _",
    "@xmath21 acquired in @xmath12 by @xmath3 within @xmath0 communication rounds .",
    "this is all the information that @xmath3 gets about the tree @xmath12 in @xmath0 rounds .",
    "thus the labeled ball @xmath21 consists of the port - labeled subtree induced by all nodes at distance at most @xmath0 from @xmath3 , with every node @xmath22 of the subtree labeled by @xmath23 , together with the degrees of all nodes at distance exactly @xmath0 from @xmath3 .",
    "the decisions of @xmath3 in round @xmath0 in any deterministic algorithm are a function of @xmath21 .",
    "the _ time _ of leader election is the minimum number of rounds sufficient to complete it by all nodes .    for advice of valency",
    "larger than 1 , leader election is always feasible for some advice of size 1 , given sufficient time .",
    "indeed , it is enough to give advice 1 to some node , advice 0 to all others , and allocate time @xmath2 . by this time , all nodes can see the unique node with advice 1 , and hence can find a simple path to it .",
    "this is in sharp contrast with the scenario of advice with valency 1 @xcite , as for such advice , if the tree is perfectly symmetric ( e.g. , the two - node tree ) then symmetry can not be broken , and leader election is impossible to carry out , regardless of the allocated time .",
    "however , the difficulty of _ fast _ leader election ( in time smaller than @xmath24 ) with _ small _ customized advice , lies in the ability of the oracle to code the part of the path from the node @xmath3 to the leader that the node @xmath3 can not see within the allocated time @xmath0 , by appropriately assigning advice to nodes in the labeled ball @xmath21 that the node can see .",
    "this is challenging , as advice given to a node @xmath22 must be used by all nodes to whose labeled balls node @xmath22 belongs .",
    "efficient coding schemes using constant size advice are at the heart of our most involved election algorithm , the one working for constant valency and large diameter",
    ".    one may ask if leader election is possible in a very short time , provided that sufficiently large advice of some valency larger than 1 is given to the nodes .",
    "this is , of course , the case when valency is unbounded : then leader election is possible in time 0 , as every node can be simply given as advice a code of a simple path to a chosen leader .",
    "however , for bounded valency , this is not the case .",
    "[ fig : intro2 ] gives an example of a tree in which leader election is impossible in time at most 1 , for any 2-valent advice , regardless of its size .",
    "indeed , consider the labeled balls @xmath25 of the 5 leaves @xmath26 of this tree .",
    "with @xmath27 , scaledwidth=50.0% ]    for any 2-valent advice , there are 4 different possible labeled balls .",
    "hence , at least two of these 5 leaves must have identical labeled balls , and hence must output identical paths to the leader .",
    "however , regardless of the choice of the leader in this tree , for one of these leaves this path must be incorrect .    hence , for any tree @xmath12 and any integer constant @xmath28",
    ", it is important to introduce the parameter @xmath29 , called the @xmath30-_election index _ of @xmath12 , defined as the minimum time in which leader election is feasible in @xmath12 , where the minimum is taken over all possible @xmath30-valent advice assignments in @xmath12 .",
    "since , as observed above , given sufficient time , leader election is always possible in any tree , if @xmath18 , the @xmath30-election index is always well defined for @xmath28 .    by definition , asking about the minimum size of @xmath30-valent advice to solve leader election in time @xmath0 is meaningful only in the class of trees @xmath12 for which @xmath31 , because otherwise , no @xmath30-valent advice can help .",
    "in the light of these remarks , we are now able to precisely formulate the two central problems considered in this paper .    * for a given time @xmath0 , what is the minimum size of advice ( of unbounded valency ) that permits leader election in time @xmath0 for all trees ? * for a given time @xmath0 , what is the minimum size of advice of valency @xmath30 that permits leader election in time @xmath0 for all trees @xmath12 for which @xmath31",
    "?    if the allocated time is at least @xmath32 , then advice of size 1 suffices .",
    "indeed , in every tree there is a node whose distance from any other node is at most @xmath32 , and thus it is enough to give advice 1 to this node and 0 to all others .",
    "hence we concentrate on time smaller than @xmath32 .    * our results . * for advice of unbounded valency ,",
    "we give tight upper and lower bounds on the minimum size of advice sufficient to perform leader election , for the entire spectrum of the allocated time @xmath0 .",
    "for the class of @xmath1-node trees of diameter @xmath2 , the minimum size of advice is @xmath33 for @xmath34 , and it is @xmath35 , for @xmath36 .    for @xmath30-valent advice , where @xmath30 is any integer constant larger than 1 , we give upper and lower bounds on the minimum size of advice sufficient to perform leader election , for a large part of the spectrum of the allocated time @xmath0 .",
    "our lower bounds are again tight , except in one case , where the ratio between the upper and the lower bound is smaller than any polynomial .",
    "it turns out that , for @xmath30-valent advice , the minimum size of advice obeys a dichotomy rule : it is either very large or very small .",
    "more precisely , we prove the following results",
    ".    consider the class of @xmath1-node trees of diameter @xmath2 .    *",
    "if @xmath2 is small ( @xmath37 and @xmath38 ) , and the allocated time is @xmath39 , for some positive constant @xmath40 , then the minimum size of advice is in @xmath41 , for any constant @xmath42 .",
    "since it is in @xmath43 by @xcite , the ratio between the upper and the lower bound is smaller than @xmath44 , for any positive constant @xmath45 .",
    "this is the only pair of bounds that are not tight . *",
    "if @xmath2 is medium ( @xmath46 and @xmath47 ) , and the allocated time is @xmath39 , for some constant @xmath40 , then the minimum size of advice is @xmath48 . *",
    "if @xmath2 is large ( @xmath49 , for some positive constant @xmath50 ) then there exist two positive reals @xmath51 , depending only on constants @xmath50 and @xmath30 , with the following properties : 1 .   if @xmath52 for any constant @xmath53 , then the minimum size of advice is @xmath48 , 2 .   if @xmath54 for any constant @xmath55 , then the minimum size of advice is constant , 3 .",
    "@xmath56 , for all constants @xmath50 and @xmath30 ( the part of the time spectrum not covered by our results is small , regardless of @xmath50 and @xmath30 ) .",
    "the main challenge in our positive results is the design of advice and of the accompanying election algorithm , such that the advice given to nodes in the labeled ball @xmath21 codes the part of the path from node @xmath3 to the leader that node @xmath3 can not see .",
    "every node @xmath3 must be able to decode this part of the path unambiguously , although labeled balls may heavily intersect .",
    "the main difficulty in our negative results is the construction of trees , for which the labeled ball @xmath21 is so small and the possible paths unseen by @xmath3 are so numerous , that the information that can be coded by the advice given to nodes of @xmath21 is insufficient , for some nodes @xmath3 , to compute their path to any potential leader .",
    "* related work . *",
    "the leader election problem was introduced in @xcite .",
    "its study started for rings , in the scenario where all nodes have distinct labels . a synchronous algorithm based on label comparisons and using",
    "@xmath57 messages was given in @xcite .",
    "in @xcite it was proved that this complexity is optimal for comparison - based algorithms .",
    "an asynchronous algorithm using @xmath57 messages was given , e.g. , in @xcite , and the optimality of this message complexity was shown in @xcite .",
    "deterministic leader election in radio networks was studied , e.g. , in @xcite , and randomized leader election , e.g. , in @xcite . in @xcite",
    ", the leader election problem was investigated in a model based on mobile agents , for networks with labeled nodes .    in many papers @xcite leader election",
    "was studied in anonymous networks .",
    "in particular , @xcite characterized anonymous message - passing networks in which leader election can be achieved . in @xcite ,",
    "the authors studied leader election in general networks under the assumption that node labels are not unique . in @xcite , the authors studied feasibility and message complexity of leader election in rings with possibly nonunique labels , while , in @xcite , the authors constructed algorithms for a generalized leader election problem in rings with arbitrary labels , unknown ( and arbitrary ) size of the ring , and for both synchronous and asynchronous communication .",
    "memory needed for leader election in unlabeled networks was studied in @xcite . in @xcite ,",
    "the authors investigated the time of leader election in anonymous networks by characterizing this time in terms of the network size , the diameter of the network , and an additional parameter called the level of symmetry , which measures how deeply nodes have to inspect the network in order to notice differences in their views of it .",
    "the paradigm of _ algorithms with advice _ that studies how arbitrary kinds of information ( coded as binary strings provided to nodes of the network or to agents ) can be used to perform network tasks more efficiently was previously proposed in @xcite .",
    "there are two possible ways of assigning advice to nodes .",
    "either all the binary strings provided to nodes are identical @xcite , or strings assigned to different nodes may be potentially different @xcite . in the latter case , instead of advice ,",
    "the term _ informative labeling schemes _ is sometimes used .    in this paradigm ,",
    "the focus is on establishing the minimum size of advice required to solve network problems in an efficient way . in @xcite ,",
    "the authors compared the minimum size of advice required to solve two information dissemination problems using a linear number of messages . in @xcite , it was shown that advice of constant size given to the nodes enables the distributed construction of a minimum spanning tree in logarithmic time . in @xcite , the advice paradigm was used for online problems . in @xcite , the authors established lower bounds on the size of advice needed to beat time @xmath58 for 3-coloring cycles and to achieve time @xmath58 for 3-coloring unoriented trees . in the case of @xcite ,",
    "the issue was not efficiency but feasibility : it was shown that @xmath59 is the minimum size of advice required to perform monotone connected graph clearing . in @xcite ,",
    "the authors studied radio networks for which it is possible to perform centralized broadcasting in constant time .",
    "they proved that constant time is achievable with @xmath43 bits of advice in such networks , while @xmath60 bits are not enough . in @xcite",
    ", the authors studied the problem of topology recognition with advice given to the nodes . in @xcite ,",
    "the task of drawing an isomorphic map by an agent in a graph was considered , and the problem was to determine the minimum advice that has to be given to the agent for the task to be feasible .",
    "in @xcite , the authors investigated the minimum size of advice sufficient to find the largest - labeled node in a graph .",
    "the problem of leader election with advice was previously studied for anonymous networks in @xcite .",
    "the main difference between these papers and the present paper is that in @xcite the binary strings provided to nodes were all identical , while in the present paper they may be potentially different .",
    "this is a significant difference : while in the former case advice can not break symmetry and can be only used to extract existing asymmetries from the network more efficiently , in our case advice has double role : it can break symmetry and provide additional information that enables nodes to use it fast to perform leader election . for example , with the possibility of customizing advice , advice of size 1 is always sufficient to perform leader election in time larger than half of the diameter of the tree , while it was proved in @xcite that large advice was sometimes needed for such allocated time , if all advice strings had to be identical .",
    "for any rooted tree @xmath12 with root @xmath61 and diameter @xmath2 , the _ depth _ of a node is defined as its distance from the root @xmath61 .",
    "the _ height _ of the tree is the length of the longest path from the root to a leaf . for two given nodes @xmath3 and @xmath22 ,",
    "if @xmath3 lies on the unique simple path between @xmath22 and the root @xmath61 , then @xmath22 is a _ descendant _ of @xmath3 , and @xmath3 is an _ ancestor _ of @xmath22 .",
    "every tree has either a central node or a central edge , depending on whether the diameter of the tree is even or odd .",
    "if the diameter @xmath2 is even , then the central node is the unique node in the middle of every simple path of length @xmath2 , and if the diameter @xmath2 is odd , then the central edge is the unique edge in the middle of every simple path of length @xmath2 .    since there are @xmath62 @xmath1-node anonymous port - labeled trees ( cf .",
    "@xcite ) , @xmath30-valent advice of size",
    "@xmath43 is sufficient to perform leader election in any tree @xmath12 , in time @xmath63 , for any @xmath64 .",
    "hence , whenever we prove a lower bound @xmath65 on the size of advice , it is tight ( up to multiplicative constants ) .    throughout the paper , by path , we mean a simple path . for a sequence @xmath66 ,",
    "we denote by @xmath67 the reverse sequence .",
    "we use the abbreviation @xmath68 for a string of @xmath69 ones and @xmath70 for a string of @xmath69 zeroes .",
    "we will need to efficiently code sequences of natural numbers in a non - ambiguous way , using binary strings .",
    "we will use the following coding .",
    "let @xmath71 be a sequence of natural numbers .",
    "let @xmath72 be the binary representation of @xmath8 , for @xmath73 .",
    "the binary code @xmath74 of @xmath75 is defined in three steps .",
    "consider the sequence @xmath76 .",
    "the terms of this sequence are 0,1 and `` , '' .",
    "+ step 1 : replace each 0 by the string of bits 10 , and replace each 1 by by the string of bits 11 .",
    "notice that each comma is now followed by the bit 1 .",
    "+ step 2 : remove the bit 1 after each comma .",
    "+ step 3 : replace each comma by the bit 0 .",
    "the resulting binary sequence is @xmath77 .",
    "for example , the sequence @xmath78 will be transformed as follows : @xmath79 .",
    "after step 1 the sequence becomes @xmath80 . after step 2",
    "the sequence becomes @xmath81 .",
    "after step 3 it becomes @xmath82 .",
    "notice that the length of the sequence @xmath77 is @xmath83 because @xmath84 is the sum of the lengths of the binary representations @xmath85 .",
    "the transformation @xmath86 is one - to - one because the sequence @xmath77 can be decoded as follows .",
    "divide the sequence @xmath77 into consecutive pairs of bits , until a pair @xmath87 .",
    "decode the obtained preceding pairs by replacing 10 by 0 and 11 by 1 .",
    "the obtained sequence is @xmath88 .",
    "add a comma , and replace the pair @xmath87 by @xmath89 .",
    "repeat the above steps to find the consecutive strings @xmath72 , for @xmath90 .",
    "this gives the sequence @xmath76 .",
    "now @xmath71 , where @xmath72 is the binary representation of @xmath8 , for @xmath73 .",
    "the above coding can be easily generalized to the case when @xmath91 colors @xmath92 are used in the coding instead of 0 and 1 .",
    "now @xmath72 is the @xmath30-ary representation of @xmath8 .",
    "the three above coding steps are changed as follows : + step 1 : replace each color @xmath93 by @xmath94 .",
    "+ step 2 : remove the color @xmath95 after each comma .",
    "+ step 3 : replace each comma by @xmath96 .",
    "the obtained code @xmath77 has length at most @xmath97 .",
    "in this section we give tight upper and lower bounds on the minimum size of advice ( of unbounded valency ) sufficient to perform leader election in any time @xmath98 .",
    "we first present a leader election algorithm working for any tree of diameter @xmath2 in time @xmath98 , with advice of unbounded valency .",
    "let @xmath12 be a rooted @xmath1-node tree of diameter @xmath2 .",
    "if @xmath2 is even , then the root @xmath61 is the central node , and if @xmath2 is odd , the root @xmath61 is one of the endpoints of the central edge .",
    "this is the node that the algorithm will elect .",
    "the height of the tree is @xmath32 .    at a high level ,",
    "the idea of the algorithm is to partition every branch of the tree into segments of length @xmath99 and assign advice to the nodes of the segment in such a way that the concatenation of the advice strings in a given segment , read bottom - up , can be decoded as the sequence of port numbers corresponding to the path from the upper endpoint of the segment to the root .",
    "every node can see some entire segment , and thus can output the correct path to the leader .",
    "care should be taken to indicate the upward direction in each segment , as nodes can not recognize this direction a priori .",
    "we first give a detailed description of algorithm advice@xmath100 constructing the advice , and then present the details of the leader election algorithm using this advice . if @xmath101 , it is straightforward to elect a leader using advice of size 1 . in the sequel",
    "we assume that @xmath102 .    the construction of the advice proceeds as follows .",
    "@xmath103 denotes the path from @xmath104 to @xmath3 , defined as the sequence of nodes including @xmath104 and @xmath3 . for @xmath105 ,",
    "the advice given to each node is simply the string of port numbers corresponding to the path from it to the leader .",
    "otherwise , algorithm advice@xmath100 computes the advice @xmath106 for each node @xmath3 .",
    "for every branch @xmath107 from the leader to a leaf , we define @xmath108 , @xmath109 , @xmath110 , @xmath111 , @xmath112 , @xmath113 , @xmath114 , and so on .",
    "the component @xmath115 of the advice helps a node to identify the upward direction in the following way . for any node @xmath3 , if @xmath116 , and if @xmath117 is the neighbor of @xmath3 with @xmath118 , then the node will identify @xmath117 as its parent , i.e. , its neighbor on the path towards the leader .",
    "the component @xmath119 of the advice is used to mark every node at depth @xmath120 , for all @xmath121 .",
    "we set @xmath122 if the depth of @xmath3 is @xmath120 , for @xmath121 , otherwise @xmath123 .",
    "the component @xmath124 of the advice is used to mark all nodes at depth at least @xmath125 .",
    "we set @xmath126 if the depth of @xmath3 is at least @xmath125 , otherwise @xmath127 .",
    "the component @xmath128 of the advice is assigned in the following way .",
    "let @xmath129 , such that @xmath130 , and @xmath131 , for @xmath132 , i.e , @xmath133 is a path between two nodes which are at depths multiple of @xmath99 and the path is going towards the root @xmath61 .",
    "the binary string @xmath134 unambiguously coding the sequence of port numbers @xmath135 that represents the path of length at most @xmath125 from some node @xmath22 of the tree to the leader @xmath61 , is divided into @xmath99 segments of lengths differing by at most 1 , and these segments are given as the component @xmath136 to the nodes @xmath137 .",
    "if the depth of @xmath138 is less than @xmath125 , then @xmath138 is chosen as @xmath22 . otherwise , the node at depth @xmath125 on the path from @xmath138 to @xmath61 is chosen as @xmath22 .",
    "since the advice given to every node should be a binary string , the advice outputted by algorithm advice@xmath100 is the binary string @xmath139 unambiguously coding @xmath106 .",
    "this can be done by coding @xmath140 on three bits , and all the other components without any change .",
    "[ step : algo1 ] [ step : algo2 ]    [ alg : alg1 ]    algorithm election@xmath141 using advice @xmath139 given by algorithm advice@xmath100 works as follows .",
    "every node @xmath3 decodes from its advice the terms @xmath140 , @xmath119 , @xmath124 , and @xmath128 of the sequence @xmath106 .",
    "if @xmath142 , then the node decodes the sequence of port numbers from @xmath128 ( which corresponds to the path from @xmath3 to @xmath61 ) and outputs it .",
    "suppose that @xmath143 .",
    "if a node @xmath3 can see a node @xmath104 with @xmath144 , then @xmath3 outputs the sequence of port numbers corresponding to the simple path from @xmath3 to @xmath104 . this sequence is seen in the ball @xmath21 .",
    "otherwise , each node @xmath3 can see in time @xmath0 a path @xmath129 , such that @xmath145 is an ancestor of @xmath3 , @xmath130 , and @xmath146 , for @xmath132 , because , for every node @xmath104 at depth @xmath120 , we have @xmath147 . from the advice at nodes @xmath148 , node @xmath3 decodes @xmath149 , @xmath150 , @xmath151 , @xmath152 .",
    "next , node @xmath3 computes the string @xmath153 which is the concatenation of @xmath149 , @xmath150 , @xmath151 , @xmath152 .",
    "this string @xmath153 unambiguously codes the sequence @xmath154 of port numbers corresponding to the path from @xmath22 to @xmath61 , where @xmath155 if the depth of @xmath138 is less than @xmath156 , and where @xmath22 is the node at depth @xmath157 on @xmath158 , if the depth of @xmath138 is at least @xmath156 .",
    "let @xmath159 be the sequence of port numbers corresponding to the path from @xmath3 to @xmath22 , which can be seen in the ball @xmath21 .",
    "the node @xmath3 outputs the concatenation of sequences @xmath159 and @xmath154 .",
    "[ step:1 ] [ step:2 ]    [ alg : alg2 ]    the following two lemmas establish an upper bound on the size of advice provided by algorithm advice@xmath100 .",
    "[ lem : path ] let @xmath160 be the the sequence of port numbers corresponding to the path @xmath133 from @xmath3 to @xmath61 .",
    "then the length of @xmath161 is in @xmath162 for every node @xmath163 of depth at most @xmath164 .",
    "let @xmath3 be a node of @xmath12 of depth at most @xmath164 .",
    "it is enough to prove that the sum of logarithms of degrees of nodes on the path @xmath133 is in @xmath162 . since the depth of @xmath3 in @xmath12 is at most @xmath165 ,",
    "there exist at least @xmath0 nodes in @xmath12 with depth larger than @xmath165 .",
    "also , since the diameter of @xmath12 is @xmath2 , there exists at least one path of length @xmath166 with no common node with @xmath133 other than @xmath61 .",
    "let @xmath167 .",
    "let @xmath168 denote the degree of node @xmath104 .",
    "then , @xmath169 .",
    "the sum of logarithms of these degrees is @xmath170 .",
    "the value of @xmath171 is maximized when @xmath172 for @xmath173 .",
    "hence , this sum of logarithms is at most @xmath174 .",
    "[ lem : size ] assume that the diameter @xmath2 of the tree is at least 3 .",
    "the size of the advice given to each node @xmath3 in @xmath12 by algorithm advice@xmath100 is in @xmath175 , when @xmath36 , and it is in @xmath176 , when @xmath177 .",
    "first suppose that @xmath178 . in this case , the advice given to every node @xmath3 codes the sequence of port numbers corresponding to the path from @xmath3 to @xmath61 .",
    "by lemma [ lem : path ] , the size of the advice is @xmath175 .    in the rest of the proof",
    "we assume that @xmath179 .",
    "consider any path @xmath129 , such that @xmath180 , and @xmath146 , for @xmath181 .",
    "let @xmath66 be the concatenation @xmath182 . according to steps [ step : algo1]-[step : algo2 ] of algorithm [ alg : alg1 ] , @xmath66 is the binary string coding the sequence of port numbers corresponding to the path from a node of depth at most @xmath164 to @xmath61 .",
    "hence , by lemma [ lem : path ] , the length @xmath183 of @xmath66 is in @xmath162 . since @xmath184 , therefore , @xmath185 . for all other nodes @xmath3 of @xmath12",
    ", we have @xmath186 .",
    "therefore , @xmath187 , for all nodes @xmath3 of @xmath12 . the other three components of @xmath188 are of constant size .",
    "hence the size of the binary string @xmath139 coding the advice @xmath188 is in @xmath176 .",
    "the following lemma proves the correctness of our election algorithm .",
    "[ lem : correctness ] every node @xmath3 of a tree @xmath12 executing , in time @xmath0 , algorithm election@xmath141 with advice @xmath139 given by algorithm advice@xmath100 , chooses node @xmath61 as the leader and outputs the sequence of port numbers corresponding to the path from @xmath3 to @xmath61 .    if there exists a node @xmath104 in @xmath21 , such that @xmath189 , i.e. , if a node @xmath3 can see the node @xmath190 , then @xmath3 outputs the sequence of port numbers corresponding to the path from @xmath3 to @xmath61 , reading it from @xmath21 . otherwise , consider two cases .",
    "if @xmath142 , the advice assigned to each node codes the sequence of port numbers corresponding to the path from this node to @xmath61 .",
    "if @xmath143 , then the components @xmath128 of the advice given to nodes @xmath3 have the following property .",
    "their concatenation , for nodes in a segment of length @xmath99 , between nodes at depths which are multiples of @xmath99 , read bottom - up , can be decoded as the sequence of port numbers corresponding to the path from node @xmath22 defined in steps [ step:1]-[step:2 ] to the root @xmath61 .",
    "every node can see at least one such entire segment , recognizes the direction bottom - up , and can see this node @xmath22 .",
    "therefore , every node @xmath3 can output the sequence of port numbers corresponding to the path from @xmath3 to @xmath61 .",
    "lemmas [ lem : size ] and [ lem : correctness ] imply the following theorem .",
    "[ th : ub ] for any @xmath1-node tree with diameter @xmath2 , algorithm election@xmath141 performs election in time @xmath0 with advice of size @xmath175 , when @xmath36 , and with advice of size @xmath176 when @xmath191 .",
    "let @xmath192 .",
    "let @xmath193 be a line of length @xmath2 with nodes @xmath194 , @xmath195 , @xmath151 , @xmath196 from left to right , and with port numbers 0 and 1 at each edge from left to right . let @xmath197 .",
    "we construct an @xmath1-node tree @xmath12 from @xmath193 as follows , see fig .",
    "[ t1 ] and fig .",
    "[ t2 ] . for each @xmath198 ,",
    "such that @xmath199 , attach @xmath200 nodes of degree one to each of the nodes @xmath201 and @xmath202 .",
    "the port numbers corresponding to the newly added edges at the nodes on @xmath193 are @xmath203 .",
    "the total number of nodes in @xmath12 is given by @xmath204 .",
    "therefore ,    @xmath205 + which implies , @xmath206    since @xmath207 , we have @xmath208 .",
    "let @xmath209 and @xmath210 be two sequences such that @xmath211 , @xmath212 , for @xmath213 and @xmath214 for @xmath213 .",
    "we construct a tree @xmath215 from @xmath12 by exchanging the ports @xmath216 and @xmath217 at @xmath218 , for @xmath213 , and we construct a tree @xmath219 from @xmath12 by exchanging the ports @xmath220 and @xmath221 at @xmath222 , for @xmath213 .",
    "let @xmath223 be the set of all such trees @xmath215 constructed from @xmath12 and let @xmath224 be the set of all trees @xmath219 constructed from @xmath12 .",
    "then @xmath225 . let @xmath226 .     for @xmath2 even , scaledwidth=60.0% ]     for @xmath2 odd , scaledwidth=60.0%",
    "]    the following theorem gives a lower bound on the size of advice sufficient to perform election in time @xmath227 , using the class of trees @xmath228 constructed above .",
    "this bound matches the upper bound from theorem [ th : ub ] .",
    "[ lem : lem1 ] consider any algorithm elect which solves election in @xmath229 rounds , for every tree .",
    "for all integers @xmath230 , there exists a tree @xmath231 with @xmath208 nodes and diameter @xmath2 , for which algorithm elect requires advice of size @xmath232 , when @xmath36 , and advice of size @xmath233 , when @xmath234 .",
    "we prove the theorem by contradiction .",
    "consider an algorithm elect that solves election in @xmath0 rounds with advice of size @xmath235 .",
    "consider the execution of algorithm elect for the trees in @xmath228 . for any choice of the leader , at least one of the nodes @xmath194 or @xmath196 must be at distance at least @xmath236 from it .",
    "without loss of generality , let the distance from @xmath194 to the leader be at least @xmath236 .    with the size of advice at most @xmath237 ,",
    "there are at most @xmath238 possible labeled balls @xmath239 .",
    "hence , the number of different pieces of information that @xmath194 can get within time @xmath0 is at most @xmath240 .",
    "therefore , there exist at least two trees @xmath241 , @xmath242 @xmath243 such that the nodes @xmath194 in @xmath241 and @xmath194 in @xmath242 see the same labeled balls .",
    "hence , @xmath194 in @xmath241 and @xmath194 in @xmath242 must output the same sequence of port numbers to give the path to the leader . according to the construction of the trees in @xmath223 , for every two such trees , the paths from @xmath194 of length",
    "at least @xmath244 must correspond to different sequences of port numbers .",
    "this contradicts the correctness of the algorithm elect .",
    "therefore , the size of the advice must be in @xmath245 , i.e. , it is in @xmath232 , when @xmath36 , and it is in @xmath233 , when @xmath234 .",
    "theorems [ th : ub ] and [ lem : lem1 ] imply the following corollary .",
    "the minimum size of advice sufficient to perform leader election in time @xmath229 in all @xmath1-node trees of diameter @xmath2 is @xmath246 , when @xmath36 , and it is @xmath247 , when @xmath234 .",
    "in this section we study the minimum size of advice to perform election in time @xmath248 , where @xmath249 is a positive constant , assuming that the advice is of constant valency @xmath18 .",
    "the section is organized as follows .",
    "we first give a general construction of a class @xmath228 of trees that will be used to prove our lower bounds on the size of advice .",
    "the rest of the section is divided into three parts , corresponding , respectively , to the cases of small , medium and large diameter @xmath2 of the tree , with respect to its size @xmath1 . in each part",
    "we give a lower bound , using a particular case of our general construction .    in all parts , the proof of the lower bound",
    "is split into two facts .",
    "the first fact gives the requirement of the minimum size of advice that any leader election algorithm for trees in @xmath228 , working in time @xmath0 , has to satisfy .",
    "the second fact establishes the condition @xmath250 for any tree @xmath251 .",
    "this condition asserts that the time @xmath0 is sufficient to elect the leader in any tree from @xmath252 , if sufficiently large @xmath30-valent advice is given to the nodes of the tree .    as for the upper bounds , in the cases of small and of medium diameter",
    ", we use the previously mentioned upper bound @xmath43 on the size of advice sufficient for leader election . for small diameter",
    "this leaves a sub - polynomial gap in advice size , and for medium diameter it is tight . in the case of large diameter",
    ", we provide an election algorithm using advice of constant size , whenever the allocated time is sufficiently large .",
    "let @xmath253 be a positive real constant and @xmath28 a positive integer constant .",
    "let @xmath254 be positive integers .",
    "let @xmath255 .",
    "we first suppose that @xmath2 is even .",
    "later we will address the case when @xmath2 is odd .",
    "we use the variables @xmath256 , @xmath257 , @xmath258 , @xmath259 in the following construction of a tree @xmath12 .",
    "we assume that @xmath257 is even .",
    "the values of these variables will be specified later to obtain our lower bounds for various ranges of the diameter @xmath2 .",
    "let @xmath260 be the tree consisting of a central node @xmath61 and @xmath256 subtrees @xmath261 , @xmath262 , @xmath151 , @xmath263 with @xmath61 as a common endpoint , see fig .",
    "for @xmath264 to @xmath256 , the subtree @xmath265 consists of @xmath257 paths @xmath266 , @xmath267 , @xmath151 , @xmath268 of length @xmath269 with @xmath61 as a common endpoint . for",
    "@xmath270 and @xmath271 , let @xmath272 , @xmath273 , @xmath151 , @xmath274 be the nodes on @xmath275 , where @xmath272 is the endpoint of @xmath275 other than @xmath61 , and with port numbers 0 and 1 at each edge of @xmath275 , from @xmath272 to @xmath61 .",
    ", scaledwidth=50.0% ]    a tree @xmath12 is constructed from @xmath260 by attaching some leaves to the nodes of @xmath260 in the following way .    1 .   for each @xmath276 , such that @xmath277 , @xmath278 , and @xmath279 , + attach @xmath200 leaves to each of the nodes @xmath280 .",
    "these nodes are called _",
    "white_. the port numbers corresponding to the newly added edges at the node @xmath280 are @xmath203 .",
    "2 .   for each @xmath281 ,",
    "such that @xmath277 , @xmath278 , attach @xmath282 additional leaves to each of the nodes @xmath280 , for @xmath283 for @xmath284 .",
    "these nodes are called _ grey_. the port numbers corresponding to these additional edges at the node @xmath280 are @xmath285 .",
    "3 .   for each @xmath281 ,",
    "such that @xmath277 , @xmath278 , attach @xmath286 additional leaves to each of the nodes @xmath280 , for @xmath287 for @xmath284 .",
    "these nodes are called _",
    "black_. the port numbers corresponding to these additional edges are @xmath288 at @xmath280 , for @xmath287 and @xmath289 , and the port numbers corresponding to these additional edges are @xmath290 at @xmath291 .",
    "4 .   for each @xmath281 ,",
    "such that @xmath277 , @xmath278 , attach @xmath259 additional leaves to each of the nodes @xmath280 , for @xmath292 for @xmath284 .",
    "these nodes are called _",
    "dotted_. the port numbers corresponding to these additional edges are @xmath293 at @xmath280 , for @xmath292 and @xmath289 , and the port numbers corresponding to these additional edges are @xmath294 at @xmath295 .",
    "let @xmath296 be the subtree which is constructed by attaching the nodes as stated above to the nodes of @xmath275 , see fig .",
    "[ fig : ng1 ] .    0.65 ,",
    "title=\"fig : \" ]    0.65 , title=\"fig : \" ]    let @xmath297 .",
    "the total number @xmath1 of nodes in the tree @xmath12 is given by @xmath298 .",
    "let @xmath299 .",
    "let @xmath300 , and @xmath301 be any sequences of integers such that @xmath302 and @xmath303 , @xmath304 , for @xmath305 , @xmath306 and @xmath307 .",
    "the tree @xmath215 is constructed from @xmath12 by exchanging the port numbers @xmath308 and @xmath216 at the node @xmath309 for @xmath305 , @xmath306 and @xmath307 .",
    "the tree @xmath310 is constructed from @xmath12 by exchanging the port numbers @xmath311 and @xmath216 at the node @xmath312 for @xmath305 , @xmath313 and @xmath307 .",
    "let @xmath223 be the set of all such trees @xmath215 and let @xmath314 be the set of all such trees @xmath315 .",
    "then @xmath316 . let @xmath317 .",
    "when @xmath2 is odd , the tree @xmath12 is obtained by the same construction for @xmath318 , adding an extra edge to @xmath319 in the construction of @xmath260 .",
    "the rest is the same as above .",
    "let @xmath322 be a real constant .",
    "let @xmath2 and @xmath323 be positive integers such that @xmath320 and @xmath324 .",
    "in order to prove the lower bound on the size of advice for small diameter , we use the construction of the class @xmath228 of trees from section [ sec : constant ] for @xmath325 , @xmath326 , @xmath327 , and @xmath328 .    the total number of nodes in a tree from @xmath252 is @xmath329 since @xmath255 , @xmath330 and @xmath331 is constant , we have @xmath208 .",
    "before formulating our lower bound , we explain the intuitive role of each node in a tree in @xmath228 .",
    "there are four types of nodes attached to nodes of @xmath275 in the construction of the tree @xmath12 .",
    "the nodes of each type have a different role in proving the lower bound in this section .",
    "the proof of our lower bound is split into two lemmas .",
    "the first lemma gives the minimum size of advice that any leader election algorithm for trees in @xmath228 , working in time @xmath0 , has to satisfy .",
    "the second lemma establishes the condition @xmath250 for any tree @xmath251 .    in the construction of the tree @xmath12 , @xmath258",
    "white nodes are attached to all the nodes @xmath280 , for @xmath332 , @xmath333 and @xmath334 .",
    "these nodes are added , so that port number variation at nodes @xmath280 can make the class @xmath228 sufficiently large .",
    "all the other three types of nodes attached are used to prove the second lemma : every node must be able to identify its position in the tree @xmath335 , given sufficiently large @xmath30-valent advice .",
    "to identify its position in @xmath241 , every node must identify the integers @xmath198 , @xmath336 , such that it belongs to the subtree @xmath296 , and must identify its position in @xmath296 .",
    "the @xmath286 black nodes that are attached to the nodes @xmath280 , for @xmath287 , @xmath284 , help every node to identify the integer @xmath198 .",
    "the @xmath259 dotted nodes which are attached to the nodes @xmath280 , for @xmath292 , @xmath284 , help every node to identify the integer @xmath336 .",
    "the @xmath282 grey nodes which are attached to the nodes @xmath280 , for @xmath283 , @xmath284 , help every node to identify its distance from the node @xmath61 , i.e. , its position in @xmath296 .",
    "the next lemma gives the lower bound on the size of advice sufficient for leader election , using the class @xmath228 of trees .",
    "[ lem : lb ] let @xmath253 , @xmath42 be positive real constants and @xmath28 an integer constant .",
    "let @xmath2 and @xmath323 be positive integers such that @xmath320 and @xmath324 . consider any algorithm elect which solves election in @xmath255 rounds with @xmath30-valent advice , for every tree with @xmath30-election index at most @xmath0 .",
    "there exists a tree @xmath337 for which algorithm elect with @xmath30-valent advice , working in time @xmath0 , requires advice of size @xmath338 .",
    "we prove the lemma by contradiction .",
    "it is enough to prove the lemma for sufficiently large @xmath323 , and for @xmath339 .",
    "we assume that @xmath2 is even .",
    "the proof for odd @xmath2 is similar .",
    "fix @xmath340 .",
    "it is enough to prove the lemma for @xmath341 .",
    "consider an algorithm elect that solves election in @xmath255 rounds with advice of size @xmath342 .",
    "consider the execution of algorithm elect for the trees in @xmath228 .",
    "algorithm elect chooses the leader either in some @xmath296 for @xmath277 , @xmath343 or in some @xmath296 , for @xmath277 , @xmath344 . without loss of generality",
    "suppose that the leader is chosen in some @xmath296 for @xmath345 .",
    "therefore , the distance from the leader to the node @xmath272 for @xmath277 , @xmath346 is at least @xmath269 .",
    "now , @xmath347 .",
    "therefore , @xmath348 .",
    "we have @xmath349 @xmath350    let @xmath351 be the ordered collection of all labeled balls @xmath352 , for @xmath270 , @xmath353 , in the tree @xmath14 from the class @xmath223 . with the size of advice at most @xmath237 , there are at most @xmath354 possible advice strings .",
    "hence there are at most @xmath355 choices of @xmath30 such strings , and thus there are at most @xmath356 possible sequences @xmath357 because the size of the ball @xmath352 is @xmath358 .",
    "now , @xmath359 hence , there exist at least two trees @xmath360 such that @xmath361 .",
    "therefore the nodes @xmath272 in @xmath241 and @xmath272 in @xmath242 , for @xmath270 , @xmath362 , must output the same sequence of port numbers to give the path to the leader . according to the construction of the trees in @xmath223",
    ", there exists a node @xmath272 , for some @xmath363 and @xmath364 , such that the path to the leader from @xmath272 in @xmath241 and the path to the leader from @xmath272 in @xmath242 correspond to different sequences of port numbers .",
    "this is a contradiction .",
    "therefore , the size of the advice is @xmath41 .",
    "the next lemma shows that the @xmath30-election index of trees in @xmath228 does not exceed @xmath0 .",
    "[ lem : xi ] for any tree @xmath365 , @xmath250 .",
    "we assume that @xmath2 is even .",
    "the proof for odd @xmath2 is similar .",
    "let @xmath366 .",
    "since @xmath367 , we may assume that @xmath368 .",
    "in order to prove the lemma , we present a leader election algorithm working in time @xmath0 , if some @xmath30-valent advice of sufficient size is available to the nodes . for any tree in @xmath228 ,",
    "the node @xmath61 is chosen as the leader .    at a high level",
    ", we assign to each subtree @xmath296 of @xmath265 a different string of length @xmath369 with at most @xmath30 terms , called _",
    "colors_. the pieces of advice at the @xmath259 dotted nodes attached to each node @xmath370 , for @xmath284 , form such a string .",
    "since @xmath371 and @xmath328 , therefore , such a one - to - one assignment is possible .",
    "the degree of the node @xmath372 is @xmath373 for @xmath374 , and is @xmath375 for @xmath376 . in time",
    "@xmath0 , every node can see at least one node @xmath372 , for @xmath284 .",
    "it knows @xmath258 , hence it can learn @xmath198 , and thus can identify the subtree @xmath265 to which it belongs .",
    "the grey nodes attached to the nodes @xmath280 of @xmath275 are used to identify the distance from @xmath280 to @xmath61 .",
    "knowing @xmath198 , every node identifies the subtree @xmath296 to which it belongs , by computing the unique string associated with @xmath296 in the subtree @xmath265 , in time @xmath0 .",
    "the node identifies its position in @xmath296 by either seeing the endpoint @xmath272 or by seeing two nodes of degree @xmath377 , together with their neighbors .",
    "we now describe formally the advice assignment to the nodes of a tree @xmath365 .",
    "let @xmath378 be a set of @xmath30 colors .",
    "let @xmath379 and let @xmath380 be the set of sequences of colors of length @xmath381 .",
    "let @xmath382 be the @xmath383th term of @xmath384 .",
    "let @xmath385 be the set of nodes of @xmath241 .",
    "define @xmath386 as follows .",
    "assign @xmath387 .",
    "we divide all the nodes in @xmath296 , for @xmath270 and @xmath333 , into the following four types , and assign colors to them as follows .    *",
    "type 1 : * all nodes @xmath388 , @xmath389 are of this type .",
    "assign @xmath390 for @xmath389 .",
    "* type 2 : * all grey nodes are of this type .",
    "let @xmath391 , for @xmath392 , be the grey node attached to its only neighbor using port @xmath393 at this neighbor .",
    "assign @xmath394 , so that the sequence @xmath395 be the binary representation of the distance from @xmath61 to the only neighbor of @xmath396 , with @xmath95 standing for 0 and @xmath96 standing for 1 .",
    "* type 3 : * all dotted nodes are of this type .",
    "let @xmath397 , for @xmath398 , be the dotted node in @xmath296 attached to its only neighbor using port @xmath393 at this neighbor .",
    "assign @xmath399 , so that @xmath400 .",
    "* type 4 : * all white and black nodes are of this type .",
    "assign @xmath401 for all these nodes .",
    "for all other nodes @xmath402 , assign @xmath401 .",
    "let @xmath403 be the node - colored map of @xmath241 corresponding to the color assignment @xmath404 .",
    "the advice provided to each node @xmath3 in @xmath241 is @xmath405 .",
    "we show that each node @xmath3 in @xmath241 can identify itself in @xmath403 in time @xmath0 , using advice @xmath405 .",
    "this is enough to output the sequence of port numbers corresponding to the path to the leader .",
    "consider a node @xmath3 in @xmath241 .",
    "* @xmath406 .",
    "+ the node @xmath61 can identify itself in time 1 ( without using any advice ) as the unique node of degree larger than 2 all of whose neighbors have degree larger than 2 .",
    "* @xmath407 is of type 1 .",
    "+ if @xmath408 , then it can identify itself as one of the endpoints of some @xmath275 , for @xmath409 and @xmath410 , as every node @xmath272 can see a line of length @xmath381 with itself as one end point . the labeled ball @xmath411 is a labeled subtree of diameter @xmath0 with @xmath412 nodes .",
    "@xmath272 identifies the integer @xmath198 by looking at the degree of the only non - leaf at distance @xmath0 .",
    "for example , if the degree of this node is 5 , then the node computes @xmath198 as 4 , because according to the construction of the tree @xmath12 , the degree of the node @xmath291 is @xmath375 .",
    "therefore , the node @xmath272 identifies the subtree @xmath265 to which it belongs .",
    "the node @xmath272 computes the string of length @xmath381 by looking at the colors of the dotted nodes attached to the only node of degree @xmath413 in @xmath352 .",
    "since this string of length @xmath381 uniquely determines @xmath296 in @xmath265 , node @xmath272 identifies itself as a node in @xmath296 .",
    "+ if @xmath414 , for @xmath415 , then it can identify itself as a node in some @xmath275 , @xmath409 and @xmath410 .",
    "the node @xmath272 is in @xmath21 , and hence @xmath3 learns the distance to @xmath272 by seeing @xmath21 . then the node @xmath3 computes the integer @xmath198 and the string of colors similarly as stated for @xmath272 , identifies the subtree @xmath296 in @xmath265 to which it belongs , and identifies its position in @xmath296 .",
    "+ if @xmath414 , for @xmath416 , then the node @xmath3 can see five kinds of nodes in @xmath21 : nodes of degree one , nodes of degree @xmath417 , at least two nodes of degree @xmath418 , at least one node of degree @xmath419 and at least one node of degree @xmath373 . since the colored map @xmath403 is a part of the advice given to every node",
    ", the nodes can distinguish between the above kinds of nodes .",
    "the node identifies @xmath198 and thus @xmath265 to which it belongs , since it knows @xmath258 .",
    "then it computes the string @xmath66 of length @xmath381 by collecting the colors from the leaves attached to a node with degree @xmath419 .",
    "hence , it identifies @xmath336 , and thus identifies the subtree @xmath296 in the class @xmath265 to which it belongs .",
    "+ the node @xmath3 sees at least two nodes @xmath420 in @xmath21 with degree @xmath418 , and all the neighbors of @xmath421 and @xmath422 are also in @xmath21 .",
    "the node @xmath3 first computes the binary strings @xmath153 and @xmath423 from the advice at the leaves attached to @xmath421 and @xmath422 , respectively , by ports @xmath424 . without loss of generality , let @xmath153 represent the integer which is larger than the integer represented by @xmath423 . recall that these integers are the distances from the respective nodes to @xmath61 .",
    "hence the node @xmath3 can identify the direction towards @xmath61 which is from @xmath421 to @xmath422 along @xmath275 , and it can identify its position in @xmath296 . * @xmath425 is of type 2 or of type 3 or of type 4 .",
    "+ the node @xmath3 follows similar steps as in case 2 , where @xmath414 , for @xmath416 , to identify the subtree @xmath296 to which it belongs , and to identify its position in @xmath296 .",
    "lemmas [ lem : lb ] and [ lem : xi ] imply the following result .",
    "let @xmath253 and @xmath42 be positive real constants .",
    "let @xmath28 be an integer constant .",
    "let @xmath2 and @xmath323 be positive integers such that @xmath320 and @xmath324 . consider any algorithm elect which solves election in @xmath255 rounds with @xmath30-valent advice , for every tree with @xmath30-election index at most @xmath0 .",
    "there exists an @xmath1-node tree @xmath241 , where @xmath208 , with diameter @xmath2 and @xmath426 , for which algorithm elect with @xmath30-valent advice , working in time @xmath0 , requires advice of size @xmath41 .",
    "let @xmath2 and @xmath323 be positive integers such that @xmath429 and @xmath430 .",
    "let @xmath431 be a positive real constant , such that @xmath432 and @xmath433 .",
    "in order to prove our lower bound on the size of advice , we now use the construction of the class @xmath228 of trees in section [ sec : constant ] for @xmath434 , @xmath435 , @xmath436 , and @xmath437 .",
    "the total number of nodes in a tree from @xmath252 is @xmath438 since @xmath255 , @xmath439 and @xmath331 is constant , we have @xmath208 .    since @xmath434 , in what follows , we omit the running index ranging from 1 to @xmath440 .",
    "in particular , @xmath275 , @xmath296 and @xmath441 are replaced , respectively , by @xmath442 , @xmath443 and @xmath444 .    as in section",
    "[ small ] , we explain the role of each node in @xmath12 in this case .",
    "the role of the white nodes is the same as before , i.e. , these nodes are added , so that port number variation at nodes @xmath444 , for @xmath445 and @xmath446 , can make the class @xmath228 sufficiently large .",
    "the nodes on @xmath442 are used to assign a different string of colors to each @xmath443 . since @xmath427 in our present case ,",
    "there are enough such nodes , as opposed to the situation of small @xmath2 , when dotted nodes had to be added for this purpose .",
    "the @xmath282 grey nodes which are attached to the nodes @xmath444 , for @xmath447 , @xmath284 , are there to help every node to identify its distance from the node @xmath61 , i.e. , its position in @xmath443 .    as before , the proof of the lower bound",
    "is split into two lemmas , concerning , respectively , the size of advice needed for election in trees from @xmath228 , and the @xmath30-election index of these trees .",
    "[ lem1 ] let @xmath253 be a positive real constant and @xmath28 an integer constant .",
    "let @xmath2 and @xmath323 be positive integers such that @xmath429 and @xmath430 . consider any algorithm elect which solves election in @xmath255 rounds with @xmath30-valent advice , for every tree with @xmath30-election index at most @xmath0 .",
    "there exists a tree @xmath337 for which algorithm elect with @xmath30-valent advice , working in time @xmath0 , requires advice of size @xmath65 .",
    "we prove the lemma by contradiction .",
    "it is enough to prove the lemma for sufficiently large @xmath323 .",
    "we assume that @xmath2 is even .",
    "the proof for odd @xmath2 is similar .",
    "consider an algorithm elect that solves election in @xmath255 rounds with advice of size @xmath448 .",
    "algorithm elect chooses the leader either in some @xmath443 for @xmath449 , or in some @xmath443 for @xmath450 . without loss of generality",
    "suppose that the leader is chosen in some @xmath443 for @xmath450 .",
    "therefore , the distance from the leader to the node @xmath451 for @xmath452 is at least  @xmath269 .",
    "now , @xmath453",
    "@xmath454 @xmath455 also , @xmath456 .",
    "therefore , @xmath457 the last inequality follows from @xmath458 ( as @xmath429 ) .",
    "let @xmath459 be the ordered collection of all labeled balls @xmath460 , for @xmath461 for a tree @xmath14 from the class @xmath223 . with the size of advice at most @xmath237",
    ", there are at most @xmath354 possible advice strings .",
    "hence there are at most @xmath355 choices of @xmath30 such strings , and thus there are at most @xmath462 possible sequences @xmath357 .    since @xmath432 , then @xmath463",
    ". therefore , @xmath464 .",
    "we have @xmath465 @xmath466 hence , there exist at least two trees @xmath360 such that @xmath361 . therefore the nodes @xmath451 in @xmath241 and @xmath451 in @xmath242 for @xmath467 , must output the same sequence of port numbers to give the path to the leader . according to the construction of the trees in @xmath223 , there exists a node @xmath468 , @xmath469 such that the path to the leader from @xmath468 in @xmath241 and the path to the leader from @xmath468 in @xmath242 correspond to different sequences of port numbers .",
    "this is a contradiction .",
    "therefore , the size of the advice is @xmath65 .",
    "[ lem2 ] for any tree @xmath365 , @xmath250 .",
    "the proof of this lemma is similar to the proof of lemma [ lem : xi ] . since @xmath434",
    ", every node has to identify the subtree @xmath443 to which it belongs , and its position in @xmath443 . since @xmath46",
    ", we may assume that @xmath368 . in order to prove the lemma",
    ", we present a leader election algorithm working in time @xmath0 , if some @xmath30-valent advice of sufficient size is available to the nodes .",
    "the node @xmath61 of a tree @xmath365 is chosen as the leader . at a high level",
    ", we assign to each subtree @xmath443 a different string of length @xmath369 with at most @xmath30 colors , using the nodes in @xmath442 . since @xmath427 and @xmath255 , then @xmath470 .",
    "therefore , such a one - to - one mapping is always possible .",
    "the grey nodes attached to the nodes @xmath444 of @xmath442 are used to identify the distance from @xmath444 to @xmath61 .",
    "every node identifies the subtree @xmath443 to which it belongs , by computing the unique string associated with @xmath443 , in time @xmath0 .",
    "the node identifies its position in @xmath443 by either seeing the endpoint @xmath471 or by seeing two nodes of degree @xmath377 , together with their grey neighbors .    as before ,",
    "@xmath379 and @xmath380 is the set of sequences of colors of length @xmath381 .",
    "let @xmath472 be the @xmath473th term of @xmath384 .",
    "the main difference with respect to the proof of lemma [ lem : xi ] is the following .",
    "while in the previous proof we assigned colors @xmath474 to dotted nodes in order to assign a different string of colors to each @xmath296 , we now assign the colors to the nodes on @xmath442 in the following way .",
    "assign @xmath475 ; @xmath476 , for @xmath477 .",
    "for all nodes @xmath478 , @xmath479 , assign @xmath476 , for @xmath480 .",
    "the values of the function @xmath404 for all other nodes are identical as in the proof of lemma [ lem : xi ] .",
    "as before , let @xmath403 be the node - colored map of @xmath241 corresponding to the color assignment @xmath404 .",
    "the advice provided to each node @xmath3 in @xmath241 is @xmath405 .",
    "it remains to explain how a node @xmath3 identifies the sequence @xmath481 corresponding to the subtree @xmath443 to which it belongs , and its position in @xmath443 .",
    "node @xmath3 can either see the nodes @xmath482 or it can see two nodes of degree @xmath418 on @xmath442 , together with their grey neighbors . in the first case ,",
    "node @xmath3 finds the sequence @xmath66 of length @xmath381 by reading the colors @xmath483 in this order .",
    "since it can see the node @xmath451 , it can also identify its position on the map . in the second case ,",
    "node @xmath3 decides which of the two nodes of degree @xmath418 is closer to @xmath61 by reading advice in their grey neighbors , similarly as in the proof of lemma [ lem : xi ] .",
    "it then finds the string @xmath66 by reading the colors assigned to nodes between these two nodes , from the farther to the closer .",
    "it identifies its position with respect to the farther of them .",
    "lemmas [ lem1 ] and [ lem2 ] imply the following theorem .",
    "let @xmath253 be a positive real constant and @xmath28 an integer constant .",
    "let @xmath2 and @xmath323 be positive integers such that @xmath429 and @xmath430 . consider any algorithm elect which solves election in @xmath255 rounds with @xmath30-valent advice , for every tree with @xmath30-election index at most @xmath0 .",
    "there exists an @xmath1-node tree @xmath241 , where @xmath208 , with diameter @xmath2 and @xmath426 , for which algorithm elect with @xmath30-valent advice , working in time @xmath0 , requires advice of size @xmath65 .",
    "let @xmath2 and @xmath323 be positive integers such that @xmath485 , for some positive constant @xmath486 .",
    "let @xmath28 be a constant integer .",
    "the main result of this section gives two reals @xmath487 , whose difference is small , which depend only on constants @xmath50 and @xmath30 , and which satisfy the following properties :    1 .",
    "for any constant @xmath53 , any election algorithm working in time @xmath488 requires @xmath30-valent advice of size @xmath65 , in some trees of diameter @xmath2 and size @xmath489 , with @xmath30-election index at most  @xmath0 ; 2 .   for any constant @xmath490",
    ", there exists an election algorithm working in time @xmath491 with @xmath30-valent advice of constant size , for all @xmath323-node trees of diameter @xmath2 whose @xmath30-election index is at most  @xmath0 .",
    "the proof of the first ( negative ) result is split , as before , into two lemmas , concerning , respectively , the size of advice needed for election in trees from @xmath228 , and the @xmath30-election index of these trees .",
    "[ lem : large1 ] let @xmath2 and @xmath323 be positive integers such that @xmath485 , for some positive constant @xmath486 .",
    "let @xmath28 be a constant integer .",
    "there exists a real @xmath492 , @xmath493 , depending only on @xmath50 and @xmath30 , such that for any algorithm elect which solves election in @xmath494 rounds with @xmath30-valent advice , for every tree with @xmath30-election index at most @xmath0 , for any constant @xmath495 , there exists a tree @xmath337 with diameter @xmath2 and @xmath489 nodes , for which algorithm elect with @xmath30-valent advice , working in time @xmath0 , requires advice of size @xmath65 .",
    "we first do the proof for @xmath496 .",
    "it is enough to prove the lemma for @xmath497 .",
    "let @xmath498 . we show that if a real @xmath492 satisfies the equation @xmath499",
    ", then any algorithm working in time @xmath500 , for @xmath501 , with @xmath30-valent advice , requires advice of size @xmath65 .",
    "consider an algorithm elect that solves election in @xmath494 rounds with advice of size @xmath502 .",
    "we use the construction of the class @xmath228 of trees in section [ sec : constant ] for @xmath434 , @xmath503 , @xmath504 , and @xmath437 .",
    "the total number of nodes @xmath1 is at most @xmath505 .",
    "this implies that @xmath506 . without loss of generality , we assume that the distance from @xmath507 to the leader is at least @xmath244 .",
    "we have @xmath508 .",
    "@xmath509 .    with the size of advice at most @xmath237 ,",
    "there are at most @xmath510 possible labeled balls @xmath239 .",
    "hence , the number of different pieces of information that @xmath194 can get within time @xmath0 is at most @xmath511 .",
    "the last inequality follows from the fact that the function @xmath512 is a strictly decreasing function for @xmath513",
    ".    therefore , @xmath514 .",
    "hence , there exist at least two trees @xmath241 , @xmath242 @xmath243 such that the node @xmath507 in @xmath241 and @xmath507 in @xmath242 see the same labeled balls .",
    "hence , @xmath507 in @xmath241 and @xmath507 in @xmath242 must output the same sequence of port numbers to give the path to the leader . according to the construction of the trees in @xmath223 , for every two such trees",
    ", the paths of length at least @xmath244 from @xmath507 must correspond to different sequences of port numbers .",
    "this contradicts the correctness of the algorithm elect .",
    "therefore , the size of the advice must be in @xmath65 .",
    "the generalization of the reasoning to the case @xmath515 follows from continuity arguments .",
    "it can be observed that the real @xmath492 in this case can be found arbitrarily close to that derived for the case @xmath496 , for sufficiently large @xmath323 .",
    "[ lem : xi1 ] for any tree @xmath365 , @xmath250 .",
    "the proof of this lemma is similar to the proof of lemma [ lem : xi ] .",
    "we present a leader election algorithm working in time @xmath0 , if some @xmath30-valent advice of sufficient size is available to the nodes .",
    "the node @xmath61 of a tree @xmath365 is chosen as the leader .    since @xmath434 , and @xmath503 ,",
    "every node has to identify whether it belongs to the subtree @xmath516 or @xmath517 , and has to learn its position in the respective subtree . after doing this",
    ", it can output the path to leader , using the colored map . at a high level , each node in @xmath518",
    "is assigned the color @xmath95 and each node in @xmath519 is assigned the color @xmath96 .",
    "every node can identify the subtree to which it belongs by seeing the advice provided to the nodes in @xmath518 or @xmath519 .",
    "the advice at the attached @xmath282 nodes , coding the distance from @xmath61 , helps to find the positions of the nodes in the respective subtree , as explained before .",
    "lemmas [ lem : large1 ] and [ lem : xi1 ] imply the following theorem .",
    "let @xmath2 and @xmath323 be positive integers such that @xmath485 , for some positive constant @xmath486 .",
    "let @xmath28 be a constant integer .",
    "there exists a real @xmath492 , @xmath493 , depending only on @xmath50 and @xmath30 , such that for any algorithm elect which solves election in @xmath494 rounds with @xmath30-valent advice , for every tree with @xmath30-election index at most @xmath0 , for any constant @xmath495 , there exists a tree with @xmath30-election index at most @xmath0 with diameter @xmath2 and @xmath489 nodes , for which algorithm elect with @xmath30-valent advice , working in time @xmath0 , requires advice of size @xmath65 .      for the second ( positive ) result",
    ", we propose an election algorithm , working for any @xmath1-node tree of diameter @xmath2 , with @xmath30-valent advice of constant size .",
    "our algorithm works in time @xmath494 , for trees with @xmath30-election index at most @xmath0 , for any constant @xmath490 , where @xmath520 satisfies the equation @xmath521 , with @xmath498 .",
    "first , we propose an algorithm working in time @xmath494 , that solves election for trees with @xmath30-election index at most @xmath0 , using @xmath522-valent advice of constant size .",
    "later , we show how to modify the algorithm , so that @xmath30-valent advice of constant size is enough .",
    "let @xmath523 .",
    "equivalently , we show an algorithm working in time @xmath524 , for any constant @xmath525 .",
    "let @xmath12 be a rooted @xmath1-node tree of diameter @xmath2 with @xmath30-election index at most @xmath0 .",
    "if @xmath2 is even , then the root @xmath61 is the central node , and if @xmath2 is odd , the root @xmath61 is one of the endpoints of the central edge .",
    "this is the node that the algorithm will elect .",
    "the height of the tree is @xmath32 . at a high level ,",
    "the advice is assigned to each of the nodes in @xmath12 in two steps . in the first step ,",
    "certain nodes in @xmath12 of different depths are marked using five additional markers .",
    "we will later specify how these markers are coded .",
    "the coding will also include information about the direction from the marked node to the root . in the second step ,",
    "all the non - marked nodes are assigned advice in such a way that the advice strings in these nodes collected in a specified way represent the sequence of port numbers from a marked node to the leader . in",
    "what follows , we use an integer parameter @xmath69 , which will be defined later .",
    "let @xmath193 be initialized to the set of all leaves in @xmath12 .",
    "the marking of the nodes in @xmath193 is done using five markers , @xmath526 , @xmath527 , @xmath528 , @xmath529 and @xmath530 , as described below .",
    "a.   mark the root @xmath61 with the marker _",
    "white_. b.   let @xmath3 be the node in @xmath193 of largest depth .",
    "if @xmath3 has an ancestor @xmath104 at distance at most @xmath531 with @xmath532 or @xmath3 has an ancestor @xmath104 at distance @xmath533 with @xmath534 or @xmath535 , then remove @xmath3 from @xmath193 .",
    "otherwise , let @xmath104 be the ancestor of @xmath3 at distance @xmath536 .",
    "mark @xmath104 with the marker @xmath528 .",
    "if @xmath3 is not a leaf , mark it with the marker _",
    "green_. add @xmath104 to @xmath193 and remove @xmath3 from @xmath193 .",
    "c.   if @xmath193 is non - empty , go to step b. d.   for every path of length @xmath536 whose top node is green or blue , which ends with a green node or a leaf , and does not have any blue internal node , mark every @xmath537-th internal node in this path , from top to bottom , with the marker _",
    "red_. e.   for every path of length @xmath533 whose top node is green or blue , which ends with a blue node or a leaf , and does not have any blue internal node , mark every @xmath537-th internal node @xmath22 in this path , from the top to bottom , with the marker _ black _ , if this node is not already marked red and the distance between @xmath22 and @xmath3 is at least @xmath538 .        fig . [ marking ] and fig .",
    "[ coding ] show an example of a tree @xmath12 and the marking of the nodes of @xmath12 .",
    "more precisely , fig .",
    "[ marking ] shows the marking of the nodes of @xmath12 by the markers blue and green .",
    "initially , the set @xmath193 contains the nodes @xmath539 , @xmath540 , @xmath541 , @xmath2 , @xmath542 , @xmath543 , and @xmath544 .",
    "first , the root is marked white .",
    "then the nodes @xmath545 , @xmath546 , and @xmath547 are marked blue and included in @xmath193 .",
    "they are at distance @xmath548 from the nodes @xmath539 , @xmath540 , and @xmath543 , respectively .",
    "the other leaves of @xmath12 are removed from the set @xmath193 because one of the nodes @xmath545 , @xmath546 , and @xmath547 is an ancestor of each of these leaves , at distance less than @xmath548 .",
    "the root @xmath61 is the ancestor of @xmath545 and @xmath546 at distance less than @xmath548 , hence these two nodes are removed from @xmath193 .",
    "the node @xmath549 is marked blue .",
    "it is an ancestor of @xmath547 at distance @xmath548 .",
    "hence the mark of @xmath547 is changed to green and @xmath547 is removed from @xmath193 .",
    "finally , @xmath549 is removed from @xmath193 and @xmath193 becomes empty .",
    "[ coding ] shows the marking of red and black nodes on an example of two paths .",
    "every @xmath550-th node of the path @xmath545 to @xmath539 is marked red .",
    "every @xmath550-th node of the path from @xmath545 to @xmath540 , which is not marked red , gets the mark black .",
    "we give a formal description of the above marking in algorithm [ alg : marking ] .    according to algorithm [ alg :",
    "marking ] , the following statements are true .    1 .   every node @xmath3 in @xmath12 at depth at least @xmath551 has a blue or green ancestor at distance at most @xmath536 .",
    "2 .   every non - leaf node @xmath104 , which is either green or blue , has at least one green descendant @xmath552 at distance @xmath536 , and the path from @xmath104 to @xmath552 does not contain any blue internal node .",
    "the depth of every node @xmath104 , which is either green or blue , is at most @xmath553 .",
    "[ alg : marking ]    according to algorithm [ alg : marking ] , there can be two kinds of paths whose top node is green or blue , of length at most @xmath536 .",
    "the first kind of paths are of length exactly @xmath536 and end with a green node .",
    "all internal marked nodes on this path are red .",
    "the second kind of paths are of length less than @xmath536 , end with a non - marked leaf or a blue node , and there is no internal blue node on the path . all marked internal nodes on this path are black or red .",
    "the advice @xmath554 of a node @xmath104 which is not previously marked is assigned depending on which kind of path it belongs to .",
    "below we explain the high - level idea of the advice assignment and its interpretation for each type of paths .",
    "consider a path @xmath133 of the first kind , of length @xmath536 .",
    "let @xmath133 start with the top node @xmath104 , @xmath534 or @xmath555 and end with a node @xmath3 , @xmath556 .",
    "all the nodes in @xmath133 are used to code the sequence of port numbers that represents the path from @xmath104 to the root @xmath61 .",
    "every node which belongs to such a path , can see the entire path in @xmath0 and thus can decode the path to the leader by collecting the advice from top to bottom .",
    "consider a path @xmath133 of the second kind , of length smaller than @xmath536 .",
    "let @xmath133 start with the top node @xmath104 , @xmath534 or @xmath535 , end with a node @xmath3 which is either blue or a non - marked leaf , and contains @xmath557 black internal nodes and no blue internal nodes .",
    "let @xmath552 be the closest green descendant of @xmath104",
    ". in time @xmath0 , any node @xmath3 in @xmath133 can see at least @xmath558 red nodes on the path from @xmath104 to @xmath552 .",
    "the advice given to non - marked nodes in the path from @xmath104 to @xmath552 codes the path from @xmath104 to @xmath61 .",
    "the node @xmath3 can see all nodes between these @xmath558 marked nodes .",
    "it concatenates top down the advice strings given to these nodes , obtaining a string @xmath559 .",
    "the other part @xmath560 of the desired string is coded in the path @xmath133 .",
    "the node @xmath3 obtains the string @xmath560 by collecting the advice from non - marked nodes of @xmath133 .",
    "finally , the node @xmath3 decodes the path from @xmath3 to the leader , using the concatenation @xmath561 .",
    "[ coding ] shows the advice assignment at the non - marked nodes of the path from @xmath545 to @xmath539 , which is a path of the first kind .",
    "the advice assignment at the non - marked nodes between the black nodes of the path from @xmath545 to @xmath540 , which is a path of the second kind , is also shown in this figure .",
    "below we give the pseudocode of the algorithm coding@xmath100 , used to produce the advice for each node .",
    "the algorithm calls one of the two procedures specified in algorithms [ alg : codingp1 ] , and [ alg : codingp2 ] , depending on the kind of path to which the node belongs .",
    "[ alg : coding ]    [ alg : codingp1 ]    [ alg : codingp2 ]    we now show how any node @xmath3 can compute the path to the leader @xmath61 from the advice seen in the labeled ball @xmath21 .",
    "we consider the following cases , depending on what the node @xmath3 sees in the labeled ball @xmath21 .    * case 1 . *",
    "a node @xmath3 sees a white node . + node @xmath3 outputs the sequence of port numbers from itself to the white node .",
    "* a node @xmath3 does not see a white node but sees a path of length @xmath536 whose top node is green or blue , which ends with a green node or a leaf , and does not contain any blue internal node .",
    "let @xmath562 , @xmath563 be a path of the first kind , seen by node @xmath3 , such that @xmath534 or @xmath535 , @xmath564 or @xmath552 is a leaf , @xmath104 is an ancestor of @xmath552 , and , for @xmath565 , @xmath566 .",
    "the node @xmath3 computes the sequence @xmath66 which is the concatenation @xmath567 this string @xmath66 unambiguously codes the sequence of port numbers corresponding to the path from @xmath104 to @xmath61 .",
    "let @xmath568 be the sequence of port numbers corresponding to the path from @xmath104 to @xmath61 represented by @xmath66 . if @xmath104 is an ancestor of @xmath3 , then @xmath3 computes @xmath569 by seeing @xmath21 .",
    "then it outputs the path to the leader as @xmath569 followed by @xmath568 .",
    "otherwise , if @xmath104 is a descendant of @xmath3 , then let @xmath570 be the distance from @xmath104 to @xmath3 .",
    "let @xmath568 be the sequence of port numbers corresponding to the path from @xmath104 to @xmath61 represented by @xmath66 .",
    "the node @xmath3 computes @xmath571 by deleting the first @xmath570 port numbers from @xmath568 and outputs it .",
    "* case 1 and case 2 are false",
    ". + according to algorithm [ alg : marking ] , node @xmath3 sees at least one blue or green ancestor in time @xmath0 .",
    "let @xmath104 be the closest green or blue ancestor of @xmath3 . since , @xmath534 or @xmath535 , there exists at least one descendant @xmath552 of @xmath104 at distance @xmath536 such that , @xmath572 is green or @xmath552 is a leaf , and there is no blue internal node in the path from @xmath104 to @xmath552",
    ". let @xmath421 , @xmath422 , @xmath573 be the black nodes between @xmath104 and @xmath3 .",
    "let @xmath574 , @xmath575 , @xmath151 , @xmath576 be the nodes between the nodes @xmath577 and @xmath578 , for @xmath579 .",
    "the node @xmath3 sees at least the @xmath558 highest red nodes , @xmath580 , of the path from @xmath104 to @xmath552 .",
    "let @xmath581 , @xmath582 , @xmath151 , @xmath583 be the non - marked nodes between the nodes @xmath584 and @xmath585 , for @xmath586 .",
    "let @xmath587 , @xmath588 , @xmath151 , @xmath589 be the non - marked nodes between the nodes @xmath104 and @xmath590 .",
    "the node @xmath3 computes the string @xmath153 which is the concatenation @xmath591",
    "@xmath151 @xmath592 .",
    "node @xmath3 computes the string @xmath423 which is the concatenation @xmath593",
    "@xmath151 @xmath594 .",
    "then node @xmath3 computes @xmath595 . the string",
    "@xmath66 unambiguously codes the sequence @xmath568 of port numbers , corresponding to the path from @xmath104 to @xmath61 .",
    "the node @xmath3 computes the sequence @xmath569 of port numbers corresponding to the path from @xmath3 to @xmath104 , by seeing @xmath21 .",
    "finally , @xmath3 outputs the sequence @xmath569 followed by @xmath596 .",
    "below we give the pseudocode of algorithm decoding@xmath597 , executed by a node @xmath3 , which outputs the path from @xmath3 to the leader .",
    "the algorithm uses one of the two procedures specified in algorithms [ alg : dcodingp1 ] , [ alg : dcodingp2 ] , depending on the labeled ball @xmath21 .",
    "[ alg : dcoding ]    [ alg : dcodingp1 ]    [ alg : dcodingp2 ]    note that the @xmath522-valent advice described in algorithms [ alg : marking ] and [ alg : coding ] has constant size : indeed , each of the five markers can be coded in constant size , and each of the unmarked nodes gets one of the @xmath30 colors as advice , which is also of constant size , since @xmath30 is constant .",
    "we now describe how to code the five markers needed in algorithm [ alg : dcoding ] , using @xmath30 colors . instead of a single node ,",
    "a sequence of constant length of consecutive nodes is used to code each marker in such a way that every node seeing the advice given to nodes of this sequence can identify a marker and can detect the direction to the root .",
    "we give the description for the case when @xmath598 . in this case , every node gets a single bit as advice . for @xmath91",
    "the solution is similar .",
    "let @xmath524 , where @xmath525 is any positive real constant .",
    "there exists an integer constant @xmath599 , such that @xmath600 .",
    "we consider the time @xmath601 and @xmath602 .",
    "let @xmath161 be the binary string coding the sequence @xmath160 of port numbers , corresponding to the path from @xmath3 to @xmath61 .",
    "we compute the binary sequence @xmath153 from @xmath161 as follows .",
    "let @xmath603 , @xmath604 , @xmath151 , @xmath605 be the substrings of @xmath161 such that @xmath606 , for @xmath607 , @xmath608 , and @xmath161 is the concatenation @xmath609 .",
    "the binary string @xmath153 is the concatenation @xmath610 .",
    "note that , the binary string @xmath611 is never a substring of @xmath153 .",
    "we use the substring @xmath611 to code the markers as follows .",
    "each marker is formed by a sequence of @xmath612 consecutive nodes .",
    "we will prove that these sequences are disjoint for different markers .",
    "* white marker * : all the nodes of a path starting from the root @xmath61 to a node of depth @xmath613 are used to code the white marker .",
    "consecutive @xmath612 nodes , starting from the node @xmath61 to a node at depth @xmath613 , are assigned the advice in the following way . give the node @xmath61 the advice 0 .",
    "the next @xmath614 nodes are assigned the advice 1 .",
    "the next five nodes are assigned the advice 1,0,1,0,0 , respectively .",
    "the next @xmath614 nodes are assigned the advice 1 .",
    "the last node at depth @xmath613 is assigned the advice 0 .",
    "* green marker * : let @xmath104 be a node in @xmath12 that gets the marker green , if algorithm [ alg : marking ] is applied on @xmath12 .",
    "for all the paths @xmath133 from @xmath104 to a node @xmath3 , of length @xmath615 , such that @xmath3 is a descendant of @xmath104 , @xmath556 , or @xmath3 is a leaf , and there is no blue internal node in the path , consecutive @xmath612 nodes of @xmath133 starting from @xmath104 as the top node are used to code the green marker . give the first node @xmath104 the advice 0 .",
    "the next @xmath614 nodes are assigned the advice 1 .",
    "the next five nodes are assigned the advice 1,0,0,0,0 , respectively .",
    "the next @xmath614 nodes are assigned the advice 1 .",
    "the last node at depth @xmath616 in @xmath133 is assigned the advice 0 .",
    "* blue marker * : let @xmath104 be a node in @xmath12 that gets the marker blue , if algorithm [ alg : marking ] is applied on @xmath12 .",
    "for all the paths @xmath133 from @xmath104 to a node @xmath3 , of length @xmath615 , such that @xmath3 is a descendant of @xmath104 , @xmath556 , or @xmath3 is a leaf , and there is no blue internal node in the path , consecutive @xmath612 nodes of @xmath133 starting from @xmath104 as the top node are used to code the blue marker . give the first node @xmath104 the advice 0 .",
    "the next @xmath614 nodes are assigned the advice 1 .",
    "the next five nodes are assigned the advice 1,1,0,0,0 , respectively .",
    "the next @xmath614 nodes are assigned the advice 1 .",
    "the last node at depth @xmath616 in @xmath133 is assigned the advice 0 .    * red marker * : let @xmath104 be a node on a path @xmath133 of the first kind that gets the marker red , if algorithm [ alg : marking ] is applied on @xmath12 .",
    "consecutive @xmath612 nodes of @xmath133 starting from @xmath104 as the top node are used to code the red marker .",
    "give the first node @xmath104 the advice 0 .",
    "the next @xmath614 nodes are assigned the advice 1 .",
    "the next five nodes are assigned the advice 1,1,1,0,0 , respectively .",
    "the next @xmath614 nodes are assigned the advice 1 .",
    "the last node at depth @xmath616 in @xmath133 is assigned the advice 0 .",
    "* black marker * : let @xmath104 be a node on a path @xmath133 of the second kind that gets the marker black , if algorithm [ alg : marking ] is applied on @xmath12 .",
    "consecutive @xmath612 nodes of @xmath133 starting from @xmath104 as the top node are used to code the black marker .",
    "give the first node @xmath104 the advice 0 .",
    "the next @xmath614 nodes are assigned the advice 1 .",
    "the next five nodes are assigned the advice 1,1,1,1,0 , respectively .",
    "the next @xmath614 nodes are assigned the advice 1 .",
    "the last node at depth @xmath616 in @xmath133 is assigned the advice 0 .",
    "[ disjoint ] sequences of nodes forming different markers are disjoint .",
    "let @xmath104 and @xmath3 be different nodes marked by algorithm [ alg : marking ] .",
    "let @xmath617 be a sequence of consecutive nodes with the top node @xmath104 , and let @xmath618 be a sequence of consecutive nodes with the top node @xmath3 .",
    "we prove that @xmath619 , for @xmath620 .",
    "according to algorithm [ alg : marking ] , the distance between two red markers , two black markers , two green markers , a green marker and a red marker , the white and a green marker , the white and a blue marker , the white and a red marker , the white and a black marker , a red and a black marker , a black and a green marker , a red and a blue marker , is at least @xmath550 . since @xmath621 , therefore @xmath619 , for @xmath620 in these cases .",
    "let @xmath104 and @xmath3 be both marked blue by algorithm [ alg : marking ] . according to this algorithm",
    ", every blue marker has a descendant at distance @xmath548 , which is either green or a leaf , and there is no blue marker in the path to this descendant .",
    "let @xmath552 be such a descendant of @xmath104 and let @xmath117 be such a descendant of @xmath3 .",
    "hence , @xmath104 ( respectively @xmath3 ) does not belong to the path from @xmath3 to @xmath117 ( respectively from @xmath104 to @xmath552 ) .",
    "the sequence of @xmath612 consecutive nodes forming the blue marker corresponding to the node @xmath104 ( respectively @xmath3 ) , with @xmath104 ( respectively @xmath3 ) as the top node , is a part of the path from @xmath104 to @xmath552 ( respectively from @xmath3 to @xmath117 ) . since the two paths from @xmath104 to @xmath552 and from @xmath3 to @xmath117 are disjoint , therefore , @xmath619 , for @xmath620 .",
    "if one of the nodes @xmath104 and @xmath3 is marked green and the other is marked blue by algorithm [ alg : marking ] , then the argument is similar as above .",
    "the remaining case is when one of the nodes @xmath104 and @xmath3 is marked black by algorithm [ alg : marking ] , and the other is marked blue . according to algorithm [ alg : marking ] , the distance between a blue marker and a black marker is at least @xmath538 .",
    "hence , @xmath619 , for @xmath620 , if @xmath104 is marked black and @xmath3 is marked blue or vice - versa .    in view of proposition [ disjoint ] ,",
    "every node @xmath3 can unambiguously identify the markers by seeing the advice given to nodes in @xmath21 , as explained below .",
    "consider a sequence of @xmath612 consecutive nodes , with advice @xmath622 at these consecutive nodes , respectively . according to the marking strategy , if this sequence forms a marker , then the string of advice bits at these nodes must be one of the following .    1",
    ".   @xmath623 or @xmath624 , where the first bit corresponds to a node @xmath258 and the last bit corresponds to a node @xmath259 .",
    "the node @xmath3 identifies the marker as white in this case .",
    "if the node sees the first string , it identifies @xmath259 as the root @xmath61 .",
    "otherwise , it identifies @xmath258 as the root @xmath61 .",
    "2 .   @xmath625 or @xmath626 , where the first bit corresponds to a node @xmath258 and the last bit corresponds to a node @xmath259 .",
    "the node @xmath3 identifies the marker as green in this case .",
    "3 .   @xmath627 or @xmath628 , where the first bit corresponds to a node @xmath258 and the last bit corresponds to a node @xmath259 .",
    "the node @xmath3 identifies the marker as blue in this case .",
    "4 .   @xmath629 or @xmath630 , where the first bit corresponds to a node @xmath258 and the last bit corresponds to a node @xmath259 .",
    "the node @xmath3 identifies the marker as red in this case .",
    "the node sees the string @xmath631 or @xmath632 .",
    "the node @xmath3 identifies the marker as black in this case .    in cases 2.5 .",
    ", if the node @xmath3 sees the first string , it identifies the direction to the root as @xmath259 to @xmath258 .",
    "otherwise , it identifies the direction to the root as @xmath258 to @xmath259 .",
    "nodes that are not in a segment coding a marker are called _ non - marker nodes_. the non - marker nodes of a path of the first kind with the top node @xmath104 are used to code the path from @xmath104 to the root @xmath61 .",
    "after the coding of the markers described above , the number of non - marker nodes in a path of the first kind is @xmath633 .",
    "the following two lemmas show that @xmath633 nodes are indeed sufficient to code the path from @xmath104 to @xmath61 .",
    "[ lem : large ] let @xmath12 be an @xmath1-node tree of diameter @xmath49 , where @xmath634 .",
    "let @xmath160 be the sequence of port numbers corresponding to the path @xmath133 from @xmath3 to @xmath61 .",
    "then the length of the binary sequence @xmath635 coding @xmath160 with @xmath30 colors is at most @xmath636 for every node @xmath163 of depth at most @xmath637 .    as before , we first do the proof for a tree with diameter @xmath638 .",
    "+ @xmath638 and @xmath523 implies @xmath639 .",
    "we have @xmath640 where @xmath641 .",
    "@xmath642    since , @xmath498 and @xmath634 , therefore , @xmath643 .",
    "hence ,    @xmath644    @xmath645    @xmath646    @xmath647    let @xmath3 be a node of @xmath12 of depth at most @xmath637 .",
    "let @xmath648 be the path from @xmath3 to @xmath61 .",
    "let @xmath168 denote the degree of node @xmath104 .",
    "since the depth of @xmath3 in @xmath12 is at most @xmath649 , there exist at least @xmath650 nodes in @xmath12 with depth larger than @xmath649 .",
    "also , since the diameter of @xmath12 is @xmath2 , there exists at least one path of length @xmath166 with no common node with @xmath133 other than @xmath61 . then @xmath651 .",
    "the sum of logarithms of these degrees is @xmath652 .",
    "the value of @xmath653 is maximized when @xmath654 for @xmath655 .",
    "hence , this sum of logarithms is at most @xmath656 .",
    "let @xmath657 be the sequence of port numbers corresponding to the path @xmath133 from @xmath3 to @xmath61 .",
    "then the length of @xmath161 is at most @xmath658 .",
    "therefore , the length of the sequence @xmath635 is at most @xmath636 , for every node @xmath163 of depth at most @xmath164 .",
    "the generalization of the reasoning to the case @xmath49 follows from continuity arguments .",
    "it can be observed that the real @xmath520 in this case can be found arbitrarily close to that derived for the case @xmath638 , for sufficiently large @xmath1 .    the length of the binary sequence @xmath153 , computed from @xmath161 , where @xmath3 is the highest node of a blue or a green marker , is at most @xmath633 .",
    "according to the marking strategy , the length of the path from @xmath3 to the root @xmath61 is at most @xmath659 .    by lemma [ lem : large ] ,",
    "the length of the binary string @xmath161 is at most @xmath636 .",
    "the binary string @xmath153 is computed from @xmath161 by inserting a 0 after every @xmath69-th bit of @xmath161 .",
    "hence , @xmath660 .",
    "now ,    @xmath661 .",
    "since @xmath601 , we have @xmath662 . therefore ,    @xmath663 .",
    "we are now ready to formulate the two final algorithms working for @xmath664-valent advice : algorithm bounded valency advice@xmath100 which assigns @xmath664-valent advice of constant size to all nodes , and algorithm bounded valency election@xmath597 , which uses this advice to perform election in time @xmath524 , where @xmath665 and @xmath331 is any constant greater than 1 .",
    "let @xmath599 be an integer such that @xmath666 .",
    "* bounded valency advice@xmath100 * + if @xmath667 or @xmath668 , then the advice is assigned to each node of the tree in the following way .",
    "consider a mapping @xmath669 .",
    "let @xmath670 be the node - colored map of @xmath12 corresponding to the mapping @xmath404 .",
    "let @xmath671 .",
    "let @xmath672 be the mapping such that for any two nodes @xmath673 , @xmath674 .",
    "such a mapping exists because @xmath675 , by assumption .",
    "the mapping @xmath676 can be found by computing @xmath21 for each node @xmath3 , for all the mappings in @xmath677 .",
    "( recall that this work is done by the oracle , so exhaustive search can be used , because time does not matter here . ) the advice assigned to each node @xmath3 is the binary string unambiguously coding the couple @xmath678 .    for @xmath679 and @xmath602 ,",
    "the advice is assigned to each node of the tree in two steps . in the first step ,",
    "one - bit advice is assigned to some nodes of the tree to code markers of five types , as explained at the beginning of this section . in the second step , we apply algorithms [ alg : codingp1 ] , and [ alg : codingp2 ] in the following way .",
    "consider segments of @xmath612 consecutive nodes , coding the markers of various colors .",
    "call such segments green , red etc .",
    ", if the corresponding marker is green , red etc . contract any such segment into one node , giving it the corresponding color , and apply algorithms [ alg : codingp1 ] and [ alg : codingp2 ] , with the following modification .",
    "the length of each subsequence @xmath66 is @xmath633 instead of @xmath680 , and the length of the subsequences @xmath384 of @xmath66 is @xmath681 instead of @xmath682 .    *",
    "bounded valency election@xmath597 * + if @xmath667 or @xmath668 , then the advice provided to the node @xmath3 is a binary code of @xmath683 , for some mapping @xmath404 .",
    "the node @xmath3 learns @xmath21 in time @xmath0 , and identifies its unique position in @xmath670 .",
    "then it outputs the sequence of port numbers corresponding to the path from @xmath3 to @xmath61 by seeing this path in @xmath670 .    otherwise , the advice provided to each node is either 0 or 1 .",
    "we apply algorithm [ alg : dcoding ] , using which every node performs leader election , in the following way . consider segments of @xmath612 consecutive nodes , coding the markers of various colors .",
    "the node @xmath3 unambiguously identifies these segments in @xmath21 , as explained above .",
    "call such segments green , red etc .",
    ", if the corresponding marker is green , red etc . contract any such segment into one node , giving it the corresponding color , and apply algorithm [ alg : dcoding ] to this contracted tree , with the following modification .",
    "the length of each subsequence @xmath66 is @xmath633 instead of @xmath680 , and the length of the subsequences @xmath384 of @xmath66 is @xmath681 instead of @xmath682 .",
    "the following result estimates the size of advice given to the nodes by algorithm bounded valency advice@xmath100 , whenever the allocated time @xmath0 is at least @xmath684 , for a constant @xmath525 .    for any real constant @xmath525 ,",
    "the advice assigned to each node @xmath3 of the tree @xmath12 by algorithm bounded valency advice@xmath100 is of constant size .",
    "first consider the case when @xmath667 or @xmath668 .",
    "since @xmath331 is constant , @xmath69 is also constant and hence @xmath0 is constant in this case . since , @xmath524 , @xmath685 , and @xmath49 , therefore @xmath2 and @xmath1 are constant in this case .",
    "hence , the size of the tree is constant .",
    "the advice provided to each node codes the colored map @xmath686 and the bit given to the node in the map , and hence this code is of constant size .",
    "if @xmath687 and @xmath634 , then according to algorithm bounded valency advice@xmath100 , every node gets either 0 or 1 as advice .",
    "hence the advice provided to every node is of size 1 in this case .",
    "we finally prove the correctness of algorithm bounded valency election@xmath597 .",
    "[ th : correctness ] every node @xmath3 of a tree @xmath12 with @xmath30-election index at most @xmath0 , executing algorithm bounded valency election@xmath597 in time @xmath0 , outputs the sequence of port numbers corresponding to the path from @xmath3 to  @xmath61 .",
    "the proof is trivial when @xmath667 or @xmath668 .",
    "suppose that @xmath687 and @xmath634 .",
    "* node @xmath3 sees a white marker in @xmath21 .",
    "it identifies the root @xmath61 as one of the two extremities of this marker , as explained above , by seeing the advice string on the nodes of the marker .",
    "the node @xmath3 outputs the sequence of port numbers corresponding to the path from @xmath3 to @xmath61 , reading it from @xmath21 .    * case 2 .",
    "* node @xmath3 sees a path of length @xmath688 whose top @xmath612 nodes form a green or a blue marker , the lowest @xmath612 nodes form a green marker and which does not contain any internal blue marker .",
    "let @xmath104 be the highest node of the top blue or green marker and let @xmath552 be the highest node of the bottom green marker . according to algorithm [ alg : codingp1 ] , the advice pieces at the non - marker nodes on the path from @xmath104 to @xmath552 , read top - down , form the binary sequence @xmath66 representing the sequence of port numbers corresponding to the path from @xmath104 to @xmath61 .",
    "since the node can see the entire path between @xmath104 and @xmath552 , it correctly computes @xmath66 by collecting the advice from the non - marker nodes top to bottom between these two markers .",
    "the node computes the correct path to the leader according to algorithm [ alg : dcodingp1 ] .",
    "* node @xmath3 sees a path of length @xmath536 whose top @xmath612 nodes form a green or a blue marker , the lowest node is a leaf and which does not contain any blue marker .",
    "let @xmath104 be the highest node of the top blue or green marker and let @xmath552 be the leaf .",
    "the path from @xmath104 to @xmath552 is of the first kind , and hence the advice pieces at the non - marker nodes on the path from @xmath104 to @xmath552 , read top - down , form the binary sequence @xmath66 representing the sequence of port numbers corresponding to the path from @xmath104 to @xmath61 .",
    "therefore , by a similar argument as in case 2 , the node @xmath3 computes the correct path to the leader from itself .",
    "* case 1 , case 2 , and case 3 are not true .",
    "according to the marking strategy , in time @xmath0 the node @xmath3 sees at least one green or blue marker , whose top node @xmath104 is an ancestor of @xmath3 . since @xmath104 is the top node of a green or a blue marker , according to algorithm [ alg : marking ] , there exists a descendant @xmath552 at distance @xmath536 from @xmath104 , such that @xmath552 is a top node of a green marker or @xmath552 is a leaf .",
    "let there be @xmath557 black markers in the path from @xmath3 to @xmath104 . in time @xmath0",
    ", @xmath3 can see at least @xmath558 highest red markers on the path from @xmath104 to @xmath552 .",
    "then , according to algorithm [ alg : codingp2 ] , the advice pieces at the non - marker nodes between the @xmath557 black markers , read top - down , form the concatenation @xmath689 .",
    "denote this concatenation by @xmath153 .",
    "the advice pieces at the non - marker nodes between @xmath104 and these @xmath558 highest red markers , read top - down , form the concatenation @xmath690 .",
    "denote this concatenation by @xmath423 .",
    "therefore , the node @xmath3 computes the sequence @xmath66 correctly by computing @xmath691 .",
    "the node computes the correct path to the leader according to algorithm [ alg : dcodingp2 ]",
    ".    * remark . * in the case of @xmath30-valent advice for @xmath91 , no changes are needed in the solution given above , because markers can be coded using the first two colors among @xmath692 , and the non - marker nodes get the advice prescribed by algorithm [ alg : coding ] , which was formulated for any @xmath693 .      in the two previous sections",
    ", we proved that for an @xmath1-node tree with diameter @xmath49 , there exist two positive reals @xmath492 and @xmath520 , depending only on @xmath50 and @xmath30 , such that any leader election algorithm , working in time @xmath494 , for any constant @xmath53 requires advice of size @xmath48 and there exists a leader election algorithm , working in time @xmath494 , for any constant @xmath490 , with advice of constant size .",
    "hence , the time values @xmath695 are the part of the time spectrum that our ( tight ) results do not cover . in this section",
    "we show that this unchartered region is small .",
    "in particular , we show that @xmath56 , for any @xmath50 and @xmath30 .     for different values of @xmath30,scaledwidth=60.0% ]    , @xmath520 and @xmath694 as functions of @xmath50 , for @xmath598,scaledwidth=60.0% ]    we plot the two equations @xmath499 and @xmath521 using matlab .",
    "we plot the maximum difference between @xmath520 and @xmath492 , for different values of @xmath50 and for a fixed integer value of @xmath30 .",
    "figure [ fig : lambda ] shows that the maximum difference between @xmath520 and @xmath492 , over all values of @xmath50 , is decreasing as a function of @xmath30 .",
    "hence we concentrate on the worst case @xmath598 .",
    "figure [ fig : lambda_2 ] shows the values of @xmath520 , @xmath492 and @xmath694 , for @xmath598 as functions of @xmath50 .",
    "the maximum value of @xmath694 is @xmath696 , and it is taken for @xmath50 approximately 0.8 .",
    "while our results for advice of unbounded valency are complete , for advice of constant valency they leave a small ( sub - polynomial ) gap for small diameter @xmath2 . also , there are parts of the allocated time spectrum where our results do not work ( in particular , for large diameter ) although , as we argued , this unchartered territory is small . filling these gaps",
    "is a natural open problem . also generalizing our results to arbitrary graphs",
    "remains open . as suggested by the comparison of results in @xcite and @xcite , where the minimum size of 1-valent advice sufficient for leader election was studied for trees and for graphs respectively",
    ", results for arbitrary graphs may be very different from those for trees .",
    "another open problem is related to the precise definition of leader election in anonymous networks .",
    "the definition adopted in this paper is the same as in @xcite , and requires each node to output a path to the leader .",
    "it should be noted that , apart from this formulation of leader election in anonymous networks , there are two other possibilities involving weaker requirements .",
    "the weakest of all is the requirement that the leader has to learn that it is a leader , and non - leaders have to learn that they are not , without the necessity of learning who is the leader .",
    "the latter variant was called _ selection _ in @xcite , and",
    "differences between election and selection were discussed there in a related context of finding the largest - labeled node in a labeled graph .",
    "of course , in our context , selection can be achieved in time 0 with 2-valent advice of size 1 .    even if all nodes have to learn who is the leader in an anonymous network",
    ", one might argue that it is enough for every node to learn a port corresponding to a shortest path towards the leader , as then , e.g. , for the task when all nodes have to send some data to the leader , packets could be routed to the leader from node to node , using only this local information .",
    "this is indeed true , if nodes want to cooperate with others by revealing the local port towards the leader when retransmitting packets . in some applications , however , such a cooperation may be uncertain , and even when it occurs , it may slow down transmission , as the local port has to be retrieved from the memory of the relaying node .",
    "it should be noted that , for trees and for @xmath30-valent advice with @xmath91 , this weaker variation of leader election can be achieved in time 1 and with advice of size 2 .",
    "it is enough to choose any node @xmath61 of the tree as the leader , and give to every node its distance modulo 3 from the leader as advice . in time 1",
    ", every node at distance @xmath559 ( mod 3 ) from @xmath61 can see a neighbor at distance @xmath697 ( mod 3 ) from @xmath61 ( its parent in the tree rooted at @xmath61 ) , and output the port towards it . for @xmath598 , a similar solution can be obtained in time 2 and with advice of size 1 .",
    "p. boldi , s. shammah , s. vigna , b. codenotti , p. gemmell , and j. simon , symmetry breaking in anonymous networks : characterizations .",
    "4th israel symposium on theory of computing and systems , ( istcs 1996 ) , 16 - 26 .",
    "p. fraigniaud , d. ilcinkas , a. pelc , communication algorithms with advice , journal of computer and system sciences 76 ( 2010 ) , 222232 .",
    "p. fraigniaud , d. ilcinkas , a. pelc , tree exploration with advice , information and computation 206 ( 2008 ) , 12761287 .",
    "p. fraigniaud , a. korman , e. lebhar , local mst computation with short advice , theory of computing systems 47 ( 2010 ) , 920933 .",
    "haddar , a.h .",
    "kacem , y. mtivier , m. mosbah , and m. jmaiel , electing a leader in the local computation model using mobile agents",
    "6th acs / ieee international conference on computer systems and applications ( aiccsa 2008 ) , 473 - 480 .                    a. miller , a. pelc , election vs. selection : how much advice is needed to find the largest node in a graph ? , proc .",
    "28th acm symposium on parallelism in algorithms and architectures ( spaa 2016 ) , 377386 ."
  ],
  "abstract_text": [
    "<S> leader election is a basic symmetry breaking problem in distributed computing . </S>",
    "<S> all nodes of a network have to agree on a single node , called the leader . </S>",
    "<S> if the nodes of the network have distinct labels , then agreeing on a single node means that all nodes have to output the label of the elected leader . </S>",
    "<S> if the nodes are anonymous , the task of leader election is formulated as follows : every node of the network must output a simple path starting at it , which is coded as a sequence of port numbers , such that all these paths end at a common node , the leader . in this paper </S>",
    "<S> , we study deterministic leader election in anonymous trees .    </S>",
    "<S> our goal is to establish tradeoffs between the allocated time @xmath0 and the amount of information that has to be given _ a priori _ to the nodes of a network to enable leader election in time @xmath0 . following the framework of _ algorithms with advice _ </S>",
    "<S> , this information is provided to all nodes at the start by an oracle knowing the entire tree , in form of binary strings assigned to all nodes . </S>",
    "<S> there are two possible variants of formulating this advice assignment . </S>",
    "<S> either the strings provided to all nodes are identical , or strings assigned to different nodes may be potentially different , i.e. , advice can be _ </S>",
    "<S> customized_. as opposed to previous papers on leader election with advice , in this paper we consider the latter option .    </S>",
    "<S> the maximum length of all assigned binary strings is called the _ size of advice_. for a given time @xmath0 allocated to leader election , we give upper and lower bounds on the minimum size of advice sufficient to perform leader election in time @xmath0 . </S>",
    "<S> all our bounds except one pair are tight up to multiplicative constants , and in this one exceptional case , the gap between the upper and the lower bound is very small .    </S>",
    "<S> * keywords : * leader election , tree , advice , deterministic distributed algorithm , time . </S>"
  ]
}