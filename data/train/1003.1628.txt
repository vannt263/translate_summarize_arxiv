{
  "article_text": [
    "the lambert @xmath0 function is defined as the inverse function of the solution being given by or shortly    since the @xmath3 mapping is not injective , no unique inverse of the @xmath4 function exists . as can be seen in fig .",
    "[ f : lambertw ] , the lambert function has two real branches with a branching point located at @xmath5 .",
    "the bottom branch , @xmath6 , is defined in the interval @xmath7 $ ] and has a negative singularity for @xmath8 .",
    "the upper branch is defined for @xmath9 $ ] .    the earliest mention of problem of eq .",
    "is attributed to euler . however , euler himself credited lambert for his previous work in this subject .",
    "the @xmath0 function started to be named after lambert only recently , in the last 10 years or so .",
    "the letter @xmath10 was chosen by the first implementation of the @xmath0 function in the maple computer software .",
    "recently , the @xmath0 function amassed quite a following in the mathematical community .",
    "its most faithful proponents are suggesting to elevate it among the present set of elementary functions , such as @xmath11 , @xmath12 , @xmath13 , etc .",
    "the main argument for doing so is the fact that it is the root of the simplest exponential polynomial function .    while the lambert w function is simply called w in the mathematics software tool _ maple _ ,",
    "in the _ mathematica _ computer algebra framework this function is implemented under the name ` productlog ` ( in the recent versions an alias ` lambertw ` is also supported ) .",
    "there are numerous , well documented applications of @xmath0 in mathematics , physics , and computer science @xcite . here",
    "we will give two examples that arise from the physics related to the pierre auger observatory .",
    "moyal function is defined as its inverse can be written in terms of the two branches of the lambert w function , and can be seen in fig .",
    "[ f : moyal - gh ] ( left ) .    within the event reconstruction of the data taken by the pierre auger observatory , the moyal function is used for phenomenological recovery of the saturated signals from the photomultipliers .",
    "in astrophysics the gaisser - hillas function is used to model the longitudinal particle density in a cosmic - ray air showers @xcite .",
    "we can show that the inverse of the three - parametric gaisser - hillas function , is intimately related to the lambert w function . using rescale substitutions ,",
    "the gaisser - hillas function is modified into a function of one parameter only , the family of one - parametric gaisser - hillas functions is shown in fig .",
    "[ f : moyal - gh ] ( right ) . the problem of finding an inverse , for @xmath14 , can be rewritten into according to the definition , the two ( real ) solutions for @xmath15 are obtained from the two branches of the lambert w function , note that the branch @xmath16 or @xmath17 simply chooses the right or left side relative to the maximum , respectively .",
    "before moving to the actual implementation let us review some of the possible nimerical and analytical approaches .      for @xmath18 and @xmath19 we can take the natural logarithm of and rearrange it , it is clear , that a possible analytical expression for @xmath0 exhibits a degree of self similarity .",
    "the @xmath0 function has multiple branches in the complex domain . due to the @xmath18 and @xmath19 conditions , the eq .",
    "represents the positive part of the @xmath20 principal branch , but as it turns out , in this form it is suitable for evaluation when @xmath21 , i.e.  when @xmath22 .    unrolling the self - similarity as a recursive relation , one obtains the following curious expression for @xmath20 , or in a shorthand of a continued logarithm , the above expression is clearly a form of successive approximation , the final result given by the limit , when it exists .    for @xmath23 and @xmath24 we can multiply both sides of eq .",
    "with @xmath16 , take logarithm , and rewrite it to get a similar expansion for the @xmath6 branch , again , this leads to a similar recursive expression , or as a continued logarithm , for this continued logarithm we will use the symbol @xmath25}(x)$ ] where @xmath26 denotes the depth of the recursion .    starting from yet another rearrangement of eq .  , we can obtain a recursion relation for the @xmath27 part of the principal branch @xmath28 ,      we can apply halley s root - finding method @xcite to derive an iteration scheme for @xmath29 by writing the second - order taylor series since root @xmath30 of @xmath31 satisfies @xmath32 we can approximate the left - hand side of eq .   with 0 and replace @xmath30 with @xmath33 . rewriting the obtained result into and using newton s method @xmath34 on the last bracket , we arrive at the expression for the halley s iteration for lambert function where    this method is of the third order , i.e.  having @xmath35 will give @xmath36 . supplying this iteration with sufficiently accurate first approximation of the order of @xmath37",
    "will thus give a machine - size floating point precission @xmath38 in at least two iterations .",
    "for both branches of lambert function a more efficient iteration scheme exists @xcite , where @xmath39 is the relative difference of successive approximations at iteration @xmath26 , the relative difference can be expressed as where the error term in this iteration is of a fourth order , i.e. with @xmath40 we get @xmath41 .",
    "supplying this iteration with a sufficiently reasonable first guess , accurate to the order of @xmath37 , will therefore deliver machine - size floating point precission @xmath38 in only one iteration and excessive @xmath42 in two !",
    "we have to find reliable first order approximation that can be fed into the fritsch iteration . due to the lively landscape of the lambert function properties",
    ", the approximations will have to be found in all the particular ranges of the function behavior .",
    "the following section deals with finding the appropriate initial approximations in the whole definition ranges of the two branches of the lambert function .",
    "the inverse of the lambert function , @xmath43 , has two extrema located at @xmath44 and @xmath45 .",
    "expanding @xmath46 to the second order around the minimum at @xmath47 we obtain the inverse @xmath46 is thus in the lowest order approximated with a parabolic term implying that the lambert function will have square - root behavior in the vicinity of the branch point @xmath48 , to obtain the additional terms in expression we proceed by defining an inverse function , centered and rescaled around the minimum , i.e.  @xmath49 . due to the centering and rescaling",
    "the taylor series of this function around @xmath50 becomes particularly neat , using this taylor expansion we can derive coefficients @xcite of the corresponding inverse function from eq .",
    "we see that @xmath51 . using @xmath52 as independent variable we can write this series expansion as where the lowest few coefficients @xmath53 are    [ cols=\"<,>,>,>,>,>,>,>,>,>,>\",options=\"header \" , ]     is enough .",
    "to quantify the accuracy of a particular approximation @xmath54 of the lambert function @xmath0 we can introduce a quantity @xmath55 defined as so that it gives us a number of correct decimal places the approximation @xmath54 is producing for some parameter @xmath15 .    in fig .",
    "[ f : approx - w0 ] all mentioned approximations for the @xmath20 are shown in the linear interval @xmath56 $ ] on the left and logarithmic interval @xmath57 $ ] on the right .",
    "for each of the approximations an use interval is chosen so that the number of accurate decimal places is maximized over the whole definition range . for the @xmath20 branch",
    "the resulting piecewise approximation is accurate in the definition range @xmath58 $ ] to at least 5 decimal places and to at least 3 decimal places in the whole definition range .",
    "the @xmath59}(x)$ ] is from eq .",
    ", @xmath60}(x)$ ] and @xmath61}(x)$ ] are from eq .  , and @xmath62 is from eq .  .    the final piecewise approximation @xmath63 is shown in fig .",
    "[ f : approx - w0-step ] in black line . using this approximation a single step of the halley iteration ( in red ) and the fritsch iteration ( in blue )",
    "is performed and the resulting number of accurate decimal places is shown .",
    "as can be seen both iterations produce machine - size accurate floating point numbers in the whole definition interval except for the @xmath64 $ ] interval where the halley method requires another step of the iteration .",
    "for that reason we have decided to use only ( one step of ) the fritsch iteration in the c++ implementation of the lambert function .    in fig .",
    "[ f : approx - w-1 ] ( left ) the same procedure is shown for the @xmath6 branch .",
    "the final approximation is accurate to at least 5 decimal places in the whole definition range @xmath65 $ ] and where @xmath66}(x)$ ] is from eq .",
    ", @xmath67 is from eq .  , and @xmath68}(x)$ ] is from eq .  .",
    "[ f : approx - w-1 ] ( right ) the combined approximation @xmath69 is shown in black line .",
    "the values after one step of the halley iteration are shown in red and after one step of the fritsch iteration in blue .",
    "similarly as for the previous branch , the fritsch iteration is superior , yielding machine - size accurate results in the whole definition range , while the halley is accurate to at least 13 decimal places .    9    # 1#2#3*#1 * ( # 2 ) # 3    r.m .",
    "corless , g.h .",
    "gonnet , d.e.g .",
    "hare , d.j .",
    "jeffrey , and d.e .",
    "knuth , _ on the lambert w function _",
    "math ..    n.g .",
    "de bruijn , _ asymptotic methods in analysis _ , new york , dover ( 1981 ) 27 .",
    "corless , g.h .",
    "gonnet , d.e.g .  hare , and d.j .",
    "jeffrey , _",
    "lambert s w function in maple _ , maple technical newsletter .",
    "gaisser and a.m.  hillas , proceedings of the 15th internation cosmic - ray conference , plavdiv , .",
    "jeffrey , r.m .",
    "corless , d.e.g .  hare , and d.e .",
    "sur linversion de @xmath70 au moyen des nombers de stirling associs _ , comptes rendus acad .",
    "sloane , _ a handbook of integer sequences _ , academic press ( 1973 ) ; _ database of integer sequences ( www version ) _",
    "+ ` http://netlib.att.com/math/sloane/doc/eisbt0.html `    i.c .",
    "mari , m.  roth , and t.  schmidt , _ a phenomenological method to recover the signal from saturated stations _ , .",
    "scavo and j.b .",
    "thoo , _ on the geometry of halley s method _ ,",
    "math .  monthly .",
    "fritsch , r.e .",
    "shafer , and w.p .",
    "crowley , _ algorithm 443 : solution of the transcendental equation @xmath71 _ , commun .",
    "p.m.  morse and h.  feshbach , _ methods of theoretical physics , part i _ , mcgraw - hill , new york ( 1953 ) 411 .",
    "sources are available also from http://www.ung.si/~darko/lambertw.tar.gz [ http://www.ung.si/~darko/lambertw.tar.gz ]              this program is free software : you can redistribute it and/or modify    it under the terms of the gnu general public license as published by    the free software foundation , either version 3 of the license , or    ( at your option ) any later version .      this program is distributed in the hope that it will be useful ,    but without any warranty ; without even the implied warranty of    merchantability or fitness for a particular purpose .   see the    gnu general public license for more details .",
    "lambert function \\f$y={\\rm w}(x)\\f$ is defined as a solution    to the \\f$x = ye^y\\f$ expression and is also known as    \" product logarithm \" .",
    "since the inverse of \\f$ye^y\\f$ is not    single - valued , the lambert function has two real branches    \\f${\\rm w}_0\\f$ and \\f${\\rm w}_{-1}\\f$.      \\f${\\rm w}_0(x)\\f$ has real values in the interval    \\f$[-1/e,\\infty]\\f$ and \\f${\\rm w}_{-1}(x)\\f$ has real values    in the interval \\f$[-1/e,0]\\f$.    accuracy is the nominal double type resolution    ( 16 decimal places ) .",
    "this program is free software : you can redistribute it and/or modify    it under the terms of the gnu general public license as published by    the free software foundation , either version 3 of the license , or    ( at your option ) any later version .",
    "this program is distributed in the hope that it will be useful ,    but without any warranty ; without even the implied warranty of    merchantability or fitness for a particular purpose .",
    "see the    gnu general public license for more details .",
    "template < >    inline    double    branchpointpolynomial<7>(const double p )    {      return        -1 + p*(1 + p*(-1./3 + p*(11./72 + p*(-43./540 + p*(769./17280        + p*(-221./8505 + p*(680863./43545600 ) ) ) ) ) ) ) ;    }       template < >    inline    double    branchpointpolynomial<8>(const double p )    {      return        -1 + p*(1 + p*(-1./3 + p*(11./72 + p*(-43./540 + p*(769./17280        + p*(-221./8505 + p*(680863./43545600 + p*(-1963./204120 ) ) ) ) ) ) ) ) ;    }       template < >    inline    double    branchpointpolynomial<9>(const double p )    {      return        -1 + p*(1 + p*(-1./3 + p*(11./72 + p*(-43./540 + p*(769./17280        + p*(-221./8505 + p*(680863./43545600 + p*(-1963./204120        + p*(226287557./37623398400 . ) ) ) ) ) ) ) ) ) ;    }               template < >    inline    double    asymptoticexpansion<3>(const double a , const double b )    {      const double ia = 1 / a ;      return a - b + b / a *        ( 1 + ia *          ( 0.5*(-2 + b ) + ia *             1/6.*(6 + b*(-9 + b*2 ) )          )        ) ;    }       template < >    inline    double    asymptoticexpansion<4>(const double a , const double b )    {      const double ia = 1 / a ;      return a - b + b / a *        ( 1 + ia *          ( 0.5*(-2 + b ) + ia *            ( 1/6.*(6 + b*(-9 + b*2 ) ) + ia *              1/12.*(-12 + b*(36 + b*(-22 + b*3 ) ) )            )          )        ) ;    }       template < >    inline    double    asymptoticexpansion<5>(const double a , const double b )    {      const double ia = 1 / a ;      return a - b + b / a *        ( 1 + ia *          ( 0.5*(-2 + b ) + ia *            ( 1/6.*(6 + b*(-9 + b*2 ) ) + ia *              ( 1/12.*(-12 + b*(36 + b*(-22 + b*3 ) ) ) + ia *                1/60.*(60 + b*(-300 + b*(350 + b*(-125 + b*12 ) ) ) )              )            )          )        ) ;    }            //",
    "asymptotic expansion      //",
    "corless et al .",
    "1996 , de bruijn ( 1981 )      template < int order >      static      double      asymptoticexpansion(const double x )      {        const double logsx = log(esign * x ) ;        const double logslogsx = log(esign * logsx ) ;        return lambertwdetail::asymptoticexpansion < order>(logsx , logslogsx ) ;      }                     template < >    template < >    inline    double    branch<0>::rationalapproximation<1>(const double x )    {      // branch 0 , valid for [ -0.31,0.3 ]      return        x * ( 1 + x *          ( 5.931375839364438 + x *            ( 11.392205505329132 + x *              ( 7.338883399111118 + x*0.6534490169919599 )            )          )        ) /        ( 1 + x *          ( 6.931373689597704 + x *            ( 16.82349461388016 + x *              ( 16.43072324143226 + x*5.115235195211697 )            )          )        ) ;    }       template < >    template < >    inline    double    branch<0>::rationalapproximation<2>(const double x )    {      // branch 0 , valid for [ -0.31,0.5 ]      return        x * ( 1 + x *          ( 4.790423028527326 + x *            ( 6.695945075293267 + x * 2.4243096805908033 )          )        ) /        ( 1 + x *          ( 5.790432723810737 + x *            ( 10.986445930034288 + x *              ( 7.391303898769326 + x * 1.1414723648617864 )            )          )        ) ;    }       template < >    template < >    inline    double    branch<0>::rationalapproximation<3>(const double x )    {      // branch 0 , valid for [ 0.3,7 ]      return        x * ( 1 + x *          ( 2.4450530707265568 + x *            ( 1.3436642259582265 + x *              ( 0.14844005539759195 + x * 0.0008047501729129999 )            )          )        ) /        ( 1 + x *          ( 3.4447089864860025 + x *            ( 3.2924898573719523 + x *              ( 0.9164600188031222 + x * 0.05306864044833221 )            )          )        ) ;    }       template < >    template < >    inline    double    branch<-1>::rationalapproximation<4>(const double x )    {      //",
    "branch -1 , valid for [ -0.3,-0.05 ]      return        ( -7.814176723907436 + x *          ( 253.88810188892484 + x * 657.9493176902304 )        ) /        ( 1 + x *          ( -60.43958713690808 + x *            ( 99.98567083107612 + x *              ( 682.6073999909428 + x *                ( 962.1784396969866 + x * 1477.9341280760887 )              )            )          )        ) ;    }             template < >    inline    double    branch<0>::approximation(const double x )    {      if ( x < -0.32358170806015724 ) {        if ( x < -kinve )          return numeric_limits < double>::quiet_nan ( ) ;        else if ( x < -kinve+1e-5 )          return branchpointexpansion<5>(x ) ;        else          return branchpointexpansion<9>(x ) ;      } else {        if ( x < 0.14546954290661823 )          return rationalapproximation<1>(x ) ;        else if ( x < 8.706658967856612 )          return rationalapproximation<3>(x ) ;        else          return asymptoticexpansion<5>(x ) ;      }    }       template < >    inline    double    branch<-1>::approximation(const double x )    {      if ( x < -0.051012917658221676 ) {        if ( x < -kinve+1e-5 ) {          if ( x < -kinve )            return numeric_limits < double>::quiet_nan ( ) ;          else            return branchpointexpansion<5>(x ) ;        } else {          if ( x < -0.30298541769 )            return branchpointexpansion<9>(x ) ;          else            return rationalapproximation<4>(x ) ;        }      } else {        if ( x < 0 )          return logrecursion<9>(x ) ;        else if ( x = = 0 )        return -numeric_limits < double>::infinity ( ) ;        else          return numeric_limits < double>::quiet_nan ( ) ;      }    }        inline    double    halleystep(const double x , const double w )    {      const double ew = exp(w ) ;      const double wew = w * ew ;      const double wewx = wew - x ;      const double w1 = w + 1 ;      return w - wewx / ( ew * w1 - ( w + 2 ) * wewx/(2*w1 ) ) ;    }       inline    double    fritschstep(const double x , const double w )    {      const double z = log(x / w ) - w ;      const double w1 = w + 1 ;      const double q = 2 * w1 * ( w1 + ( 2/3.)*z ) ;      const double eps = z / w1 * ( q - z ) / ( q - 2*z ) ;      return w * ( 1 + eps ) ;    }       template <      double iterationstep(const double x , const double w )    >    inline    double    iterate(const double x , double w , const double eps = 1e-6 )    {      for ( int i = 0 ; i < 100 ; + + i ) {        const double ww = iterationstep(x , w ) ;        if ( fabs(ww - w ) < = eps )          return ww ;        w = ww ;      }      cerr < < \" convergence not reached . \"",
    "< < endl ;      return w ;    }                          template < > double lambertw<0>(const double x ) {    if ( fabs(x ) > 1e-6 & & x >",
    "-lambertwdetail::kinve + 1e-5 )      return        lambertwdetail : :          iterator <",
    "lambertwdetail::fritschstep > : :            depth<1 > : :              recurse(x , lambertwapproximation<0>(x ) ) ;    else      return lambertwapproximation<0>(x ) ; }    template < > double lambertw<-1>(const double x ) {    if ( x > -lambertwdetail::kinve + 1e-5 )      return        lambertwdetail : :          iterator <",
    "lambertwdetail::fritschstep > : :            depth<1 > : :              recurse(x , lambertwapproximation<-1>(x ) ) ;    else      return lambertwapproximation<-1>(x ) ; }"
  ],
  "abstract_text": [
    "<S> this short note presents the lambert @xmath0 function and its possible application in the framework of physics related to the pierre auger observatory . the actual numerical implementation in c++ consists of halley s and fritsch s iteration with branch - point expansion , asymptotic series and rational fits as initial approximations .     </S>",
    "<S> + @xmath1 + * having fun with lambert @xmath2 function * +   + </S>"
  ]
}