{
  "article_text": [
    "researchers have long been advocating using mathematically - precise ( `` formal '' ) specifications in software projects  @xcite .",
    "these specifications aid in removing errors early in the software lifecycle and can be reused in a variety of ways : as a reference point during system design and during development of test cases , as documentation during maintenance , etc .",
    "however , there is a strong resistance against adopting formal methods in practice , especially outside the domain of safety - critical systems .",
    "the primary reason for this resistance is the perception of software developers regarding the applicability of formal methods ",
    "these methods are considered to be hard ( require a level of mathematical sophistication beyond that possessed by many software developers ) , expensive , and not relevant for `` real '' software systems  @xcite .",
    "although case - studies ( e.g. @xcite ) have shown applicability and effectiveness of formal methods for various industrial - size systems , this perception still remains .",
    "currently , most research in formal methods concentrates on improving modeling languages and tool support to be able to specify and verify larger and more complex problems ( e.g. @xcite ) .",
    "however , to facilitate a wide - spread use of formal methods , another , complimentary approach is necessary : to improve _ usability _ of the methods and the tools and to demonstrate the cost - effectiveness of applying them to software systems .",
    "we believe that the way to make formal methods more usable is by    * amortizing the cost of creating formal documentation throughout the software lifecycle , i.e. using this documentation for checking correctness of programs , generating test cases and test environments , etc . ; * using ( or developing ) easy to read and review notations ( e.g. , state - machines and tables ) ; * decreasing analysis cost through automation ; and * adopting existing technologies wherever possible .",
    "we are interested in specifying and verifying event - driven systems , and chose scr ( software cost reduction ) to be the requirements notation used in our project .",
    "the scr requirements notation was developed by a research group at the naval research laboratory as part of the software cost reduction project  @xcite .",
    "this notation specifies event - driven systems as communicating state machines which move between states as the environment changes .",
    "the functional part of the system requirements describes the values of the system s output variables as a function of the system s input ( event ) and internal state .",
    "these requirements can be formally specified by providing structured decision tables . for each output variable",
    ", there is a table which specifies how to compute the variable s value based on its previous value and input events .",
    "representing logical formulae using tables is a powerful way to visualize information which gained acceptance among many practitioners .",
    "table structure makes specifications easy to write and review and allows for high - yield mechanical analysis .",
    "tools were developed to check mode tables of scr for correctness with respect to global properties using model - checking  @xcite and theorem - proving  @xcite .",
    "a group at the naval research lab developed an industrial - quality tool called scr * which allows specifying and reasoning about complex systems using scr  @xcite .",
    "scr * performs checks to ensure that the tables are complete and consistent .",
    "tool - building is not limited to the scr community .",
    "for example , david parnas and his colleagues are working on methods and tools to document programs using tables  @xcite , and a group at odyssey research associates are developing tablewise - a tool to reason about decision tables  @xcite .",
    "however , none of these tools are aimed at _ using _ tabular requirements once they have been created .    during the past several years",
    ", we have been developing a number of tools that use scr requirements throughout the various stages of software lifecycle , and have recently integrated them into a toolset called sc(r)@xmath0  which stands for the scr requirements reuse .",
    "sc(r)@xmath0  allows users to specify their requirements through a visual interface , conducts simple syntactical checks , and invokes various tools to perform analysis of software artifacts .",
    "we have developed tools to check requirements for correctness and to verify consistency between annotated code and requirements , and will describe these activities using the cruise control system  a case study that we recently undertook .",
    "the rest of this paper is organized as follows : section  [ casestudy ] describes requirements of the cruise control system .",
    "sections  [ reqanalysis ] and  [ codeanalysis ] outline techniques to analyze the consistency of the requirements and the correspondence between the code and the requirements , respectively . in section  [ conclusion ] we summarize our work and outline future research directions .    [ cols=\"<,<\",options=\"header \" , ]     * initial : * false    ' '' ''    the cruise control system has one mode class cc , whose modes are described in table  [ table_modes ] .",
    "the system is in exactly one mode of each modeclass at all times , so we can think of modeclasses as finite - state machines .",
    "the mode transition table of mode class cc is shown in table  [ table_cc ] .",
    "each row of the table specifies an event that activates a transition from the mode on the left to the mode on the right .",
    "the system starts in mode off if ignition is false , and transitions to mode inactive when ignition _ becomes true _ , i.e. , has a value false in the current state and a value true in the next , indicated by `` @t '' in the mode transition table .",
    "once in mode inactive , the system remains there until ignition _ becomes false _ ( indicated by `` @f '' ) , at which point it switches to mode off .",
    "the system also transitions from inactive to cruise if b_cruise _ becomes true _ while running is true ( indicated by `` t '' ) , and toofast , brake , accel are false ( indicated by `` f '' ) .",
    "values of monitored variables indicated by ``  '' are not relevant to that particular transition , e.g. , a variable brake in the transition from off to inactive .",
    "an scr specification defines one mode transition table for each mode class of the system .",
    "such tables are entered into sc(r)@xmath0using a mode class editor shown in figure  [ fig_modeclass_editor ] .",
    "the cruise control system has a number of controlled variables to control the car throttle and display messages when the car is due for service or when it needs more oil .",
    "for example , a variable throttleaccel is true when the throttle is in the accelerating position and false otherwise .",
    "the condition table for this variable is shown in table  [ table_throttleaccel ] .",
    "throttleaccel is only evaluated in mode cruise .",
    "the first row of the table specifies that throttleaccel should become true when the speed is too slow , and false when the system exits the mode cruise ( indicated as @f(inmode ) ) . when the system enters cruise because the user pressed the resume button , the cruise control needs to maintain the previously set speed .",
    "thus , the current speed is immediately evaluated , and if it is too slow , throttleaccel should become true , as indicated in the second row of the table .",
    "an scr specification defines one table for each controlled variable of the system .",
    "the sc(r)@xmath0  module for specifying these variables is shown in figure  [ fig_control_table ] .",
    "sc(r)@xmath0  allows to record assumptions of the requirements about the behavior of the environment .",
    "assumptions specify constraints on the values of conditions , imposed by laws of nature or by other mode classes in the system .",
    "in particular , we can assume that the engine is running only if the ignition is on ( running @xmath1 ignition ) , the car can be going `` too fast '' only if it is running ( toofast @xmath1 running ) , and various boolean conditions are related by enumeration .",
    "the later category includes predicates on the vehicle s speed ( speed_slow / speed_ok / speed_fast ) and buttons controlling the cruise control system ( b_off / b_cruise / b_resume ) .",
    "the last section of requirements specification consists of the system goals .",
    "these are not constraints on the system behaviour but rather _ putative theorems _  global properties that should hold in the system under specification , e.g. `` the light will eventually become green '' , or `` reversing a list twice gives us the original list '' .",
    "the language for specifying these properties in sc(r)@xmath0  is an extension of ctl ( computational tree logic ) .",
    "ctl is a branching - time temporal logic  @xcite which allows quantification over some or all possible futures .",
    "ctl formulae are defined recursively : all propositional formulae are in ctl ; if @xmath2 and @xmath3 are in ctl , so are @xmath4 ( negation ) , @xmath5 ( conjunction ) , and @xmath6 ( disjunction ) .",
    "furthermore , the universal ( @xmath7 ) and the existential ( @xmath8 ) quantifiers are used alongside the `` next state '' ( @xmath9 ) , `` until '' ( @xmath10 ) , `` future '' ( @xmath11 ) and `` global '' ( @xmath12 ) operators .",
    "thus , the formula @xmath13 means that it is invariantly true that @xmath2 implies @xmath3 .",
    "in addition to propositional formulae , our language allows to express properties involving scr events , e.g.    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ * [ property 1 ] * @xmath14 if the system is in mode override , then it will react to the event @f(ignition ) by immediately going to the mode off . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the semantics of events @t(@xmath15 ) ( @f(@xmath15 ) ) is that @xmath15 is true ( false ) in the current state and false ( true ) in the previous . to ease the phrasing of ctl formulas that refer to the occurrence of conditioned events , we use unary logic connectives @t and @f to express the scr notions of _ becoming true _ and _ becoming false_.    typically , the properties we are interested in specifying include invariants , reachability properties  these are important to ensure that the invariant properties are not true vacuously , and `` progress '' ( bounded liveness ) properties . for example ,",
    "some of the invariant properties of the cruise control system is `` whenever the system is in mode override of modeclass cc , the system is running and the ignition is on '' , formalized as @xmath16 and `` predicates representing the state of the throttle are related by enumeration '' , formalized as @xmath17    @xmath18 `` progress '' properties are used to check that the system behaves according to our expectations .",
    "for example , one of the `` progress '' properties of the cruise control system is property 1 given above , formalized as @xmath19    @xmath20    note that in this property we use a logical connective @f .",
    "system goals allow semantical checks on requirements , i.e. checks that these goals hold in the specification of the system .",
    "we chose to use _ model - checking _",
    "@xcite to perform these checks .",
    "a symbolic model - checker smv developed by mcmillan  @xcite , uses state exploration to check if temporal properties hold in a finite - state model .",
    "however , we first needed to translate the behavioral specifications of scr into a format accepted by smv , which is done using a tool gensmv .",
    "the requirements analysis process is depicted in figure  [ fig_reqs ] , where tools and artifacts are represented by ellipses and boxes , respectively . in this section ,",
    "we briefly describe gensmv , outline counter - example facilities of smv and sc(r)@xmath0 , and present results of verification of the cruise control system .",
    "gensmv  @xcite was developed at the university of waterloo to reason about mode transition tables . before translating scr specifications ,",
    "gensmv details the mode transition tables with information derived from environmental assumptions .",
    "for example , an assumption running @xmath1 ignition adds information to the second transition from mode inactive to mode cruise ( third row of table  [ table_cc ] ) : if running is true , then ignition should already be true .",
    "detailed scr tables are translated into the smv input language . in order to translate added logic connectives @t and @f to regular ctl , accepted by smv , gensmv needs to store previous values of variables which can occur in events .",
    "this is facilitated by introducing additional variables in the smv model .",
    "for example , in order to reason about a property involving @f(ignition ) , we need an additional variable pignition , which is assigned the current value of ignition before the next value of this variable is computed .",
    "thus , property 1 is translated into ctl as @xmath21    @xmath22 we extended gensmv to translate condition tables of controlled variables into the smv modeling language  @xcite .",
    "this way , we are able to reason about the entire sc(r)@xmath0  specification .      during verification of ctl properties",
    ", smv explores all possible behaviors of the model and either declares that the property holds or gives a counter - example .",
    "since we wanted to make calls to smv completely transparent to the user , and because of the introduction of extra variables into the smv model , we found it necessary to automatically capture smv s counter - examples and translate them into the scr format .",
    "this translation allows the user to easily determine where errors occur , without having to understand the intricacies of translation between the scr and the smv models .",
    "for example , if we try to check the property `` pressing the cruise button at any point when the system is running will turn the cruise control system on '' , formalized as @xmath23    @xmath24 sc(r)@xmath0  reports a scenario that would violate this property , shown in figure  [ fig_error ] .",
    "thus , the system does not react to changes in b_cruise if the car is running too fast to be controlled by the automatic system .       of vars",
    "* +   + -reorder & 26487.25s & 420.31s & 34315278 & 47 +   + base & 5.67s & 0.2s & 112687 & 26 + -f -inc & 11.06s & 0.07s & 18714 & 26 + -reorder & 5.69s & 0.15s & 75356 & 26 + -f -inc -reorder & 12.28s & 0.1s & 18630 & 26 +   + base & 8102.76s & 50.59s & 9780674 & 43 + -f -inc & 18783.8s & 263.46s & 3406360 & 43 + -reorder & 4237.56s & 7.37s & 4425504 & 43 + -f -inc -reorder & 13599.5s & 12.54s & 3406360 & 43 +    ' '' ''    we were successfully able to model and verify the automobile cruise control system using the sc(r)@xmath0  toolset .",
    "the verification was performed on a moderately loaded sparcstation-20 ( 2 75 mhz processors ) with 256 megabytes of ram using smv version 2.4 .",
    "the complete cruise control specification consists of 22 monitored and 13 controlled variables , translated into 47 smv variables .",
    "given that the size of the model grows exponentially to the number of variables in the system , we were not surprised that the initial runs of smv did not complete after two days .",
    "however , we explored various ways to reduce the time and memory requirements necessary to verify the system .",
    "the following is the summary of our findings .",
    "@xmath25 the most effective technique is `` slicing '' , i.e. , removing variables that are not used in properties under verification .",
    "currently , if a variable does not appear in any of the properties and no other variables depend on it , smv still includes it into the models it builds .",
    "however , it is safe to remove such variables from consideration , thus greatly reducing sizes of the models . in scr",
    ", there is a hierarchy of dependencies between requirements variables , which is very easy to compute and take advantage of , although at the expense of producing separate smv models . in sc(r)@xmath0 , the later process",
    "can only be done by hand so far , although we are developing an automatic model generation .",
    "@xmath25 another technique is turning the variable reordering on .",
    "smv uses binary decision diagrams ( bdds ) to quickly manipulate logical expressions .",
    "unfortunately , the size of the bdds is extremely sensitive to the order of the variables used to build them  @xcite .",
    "smv has an option  reorder that allows it to heuristically compute and use a `` better '' variable reordering which is typically very effective . however , even with reordering turned on , smv took a long time to verify the cruise control specification ( 26487.25 seconds of user time ) . to overcome this problem , we split the model into two : mode classes and controlled variables related to the throttle , and mode classes and all other controlled variables .",
    "results of our experiments appear in table  [ exp_results ] . in this table",
    ", we list the user and the system time in seconds , and the total number of bdd nodes used during the verification , as reported by smv .",
    "the last column of the table is the number of variables in the smv model .",
    "we were unable to measure the running time in terms of real time , since smv does not keep this information .    @xmath25 a more controversial technique is building the state space incrementally , removing unreachable parts of the model ( smv options f and inc ) .",
    "this technique reduces the size of bdds at the expense of the longer running time . combining this option with reorder",
    "typically yields a smaller number of bdd nodes than either of the options alone , but the verification time is slightly worse than by running smv with with reorder alone ( see table  [ exp_results ] ) . we feel that both options should be turned on on a fast machine with a limited amount of memory , whereas just reorder should be turned on on a slower machine .     & + & speed_slow & speed_ok & & speed_fast & & accel & +   &   & @xmath26accel & @xmath26accel & @xmath26 speed_slow + & accel & maintain & decel & off +    ' '' ''    the verification effort yielded a number of errors , most of which could be traced back to the original specification  @xcite .",
    "we found no errors in the mode transition table because this table has been analyzed earlier by atlee and her colleagues  @xcite .",
    "however , we did find errors in controlled variable tables of the original specification .",
    "for example , the cruise control system includes a controlled variable oilon which represents lighting up an indicator when the vehicle is due for an oil change , i.e. , it has traveled a certain distance since its previous oil change . in kirby s specification",
    ", this controlled variable is evaluated when we enter any mode other than off ( @t(inmode ) when omiles_low ) .",
    "thus , the vehicle could be traveling with the cruise control system turned off , not changing its modes and never setting oilon to true .",
    "we modified the table for oilon to set the variable to true when omiles_low becomes true , regardless of the mode .",
    "another problem was found in the table for evaluating the throttle . in the notation used by kirby , throttle was an enumerated variable whose values are evaluated in mode cruise as specified in table  [ throttle ] .",
    "we found that condition @xmath26accel is redundant  the system exits mode cruise as soon as accel becomes true .",
    "we also suspected that the throttle might never become off . to check that , we modeled the variable throttle in smv and ran it against the property @xmath27 which was verified , confirming our suspicion . finally , the correctness of the specification is conditional upon the time when the predicate on the vehicle s speed is evaluated .",
    "it works correctly only when speed_ok , speed_slow and speed_fast get evaluated _ before _ the system transitions into mode cruise .",
    "at some point in the future it will be possible to generate code from the black - box requirements specified in scr .",
    "however , this code will likely require some hand - tuning , e.g. , because it is too slow , or might even have to be rewritten from scratch .",
    "mathematically precise software requirements , like scr , can be used to reason about correctness of implementations .",
    "sc(r)@xmath0  incorporates a tool called cord  @xcite that takes specially annotated source code and an scr specification and checks for the correspondence between them .",
    "cord uses data - flow analysis instead of exhaustive state enumeration to enable effective verification in low - degree polynomial time .",
    "however , the analysis can sometimes be imprecise , i.e. `` there _ may be _ a problem on this line of the code '' . in this section ,",
    "we describe how to ( correctly ) annotate the code , outline the algorithms used in cord to check consistency between requirements and annotated code , and present results of verifying the implementation of the cruise control system .    ' '' ''      code is annotated with special statements which describe changes in the system state .",
    "these changes involve local ( rather than invariant ) information and therefore are relatively easy to specify .",
    "the annotations , described in detail in @xcite , are of three types .",
    "_ initial _ annotations indicate the starting states of the program .",
    "they unconditionally assign values to variables and correspond to initialization information specified in the requirements",
    ". _ update _ annotations assign values to controlled , monitored or mode class variables .",
    "these annotations identify points at which the program changes its state .",
    "_ assert _ annotations assert that variables have particular values in the current system state .",
    "this makes our analysis more precise and serves as documentation of what the developer assumes about the system at a given point in the program .",
    "consider the following annotated code fragment , taken from the implementation of the cruise control system :    ....      if ( !",
    "vignition ) {        @@ assert ~ignition ;        vignition = true ;        @@ update ignition ;        vcc = minactive ;        @@ update cc = inactive ;      }      else {        @@ assert ignition ;        vignition = false ;        @@ update ~ignition ;        vcc = moff ;        @@ update cc = off ;      } ....    in this fragment , code variables vignition and vcc correspond to requirements variables ignition and cc . in the then branch of the",
    "if statement we assert that ignition is false , register that ignition becomes true , marked by an update annotation , and then change the mode of the system to inactive .",
    "this is also marked by an update annotation .",
    "the else branch is similar .",
    "as stated above , cord uses annotations and control - flow information of the code to check it for correctness .",
    "that is , `` the analysis is as good as the annotations '' .",
    "although annotations are easy to insert , we found ourselves frequently making mistakes , and also noticed that code maintenance greatly reduces the correspondence between the code and the annotations .",
    "thus , the sc(r)@xmath0  toolset includes a tool called sac  @xcite designed to check that the code is annotated correctly . to use the tool ,",
    "the programmer creates a list of _ correspondences _ between variables in the requirements and the code .",
    "for example , the following is the specification of correspondences for the above code fragment :    ....     correspondences :      { ignition } - > { vignition } ;      { cc } - > { vcc } ; ....    these correspondences can be one - to - one ( one requirements variable corresponds to one code variable ) , one - to - many ( one requirements variable corresponds to several code variables ) , and many - to - one .",
    "sac ensures that an assignment to ( a check of ) a code variable is always followed by an update ( an assert ) of an appropriate requirements variable .",
    "the entire process of code verification with sc(r)@xmath0  is depicted in figure  [ fig_cord ] . here , tools ( sac and cord ) and artifacts are represented by ellipses and boxes , respectively .",
    "analysis done by cord is described in detail elsewhere  @xcite . in this section",
    ", we give a quick summary of this process .",
    "cord checks that transitions implemented in the code are exactly the same as those specified in the requirements .",
    "these checks correspond to three types of properties : ( 1 ) the code and the specification start out in the same initial state ; ( 2 ) the code implements _ all _ specified transitions ; and ( 3 ) the code implements _ only _ specified transitions . properties of types ( 2 ) and ( 3 ) are called alt ( `` all legal transitions '' ) and olt ( `` only legal transitions '' ) , respectively . for example , cord checks an alt property that a transition from mode cruise to mode off on event @f(ignition ) exists in the code .",
    "this transition refers to the fourth row of table  [ table_cc ] .",
    "one of the olt properties is `` the only transitions into mode off are from mode inactive on event @f(ignition ) , or from mode cruise on event @f(ignition ) , or from mode override on event @f(ignition ) '' .",
    "verification is done via static analysis of the annotated code . a technique similar to _ constant propagation _",
    "is used to create a finite - state abstraction of the annotations and control - flow program statements of the program .",
    "we use an aggressive state - folding strategy aimed at minimizing the number of states .",
    "this number is bound above by the number of annotations and control - flow structures in the code and is almost not affected by the number of variables in the specification .",
    "after the model has been created , we check it for consistency with the specification .",
    "typically , the properties involve fairly short ( 2 - 3 states ) fragments of the paths through the code , thus enabling very efficient checking .",
    "in addition , cord can verify invariant and reachability properties , find unreachable states , and check that environmental assumptions are not violated in the code .",
    "fast and highly scalable processing comes at a price of inexact verification .",
    "abstraction used in cord leads to computing more behaviors than can be present in the code .",
    "thus , olt properties and invariants are checked _ pessimistically _ , i.e. , some violations that are not present in the code can be reported .",
    "alt and reachability properties are checked _ optimistically _ , i.e. , some violations in the code can be overlooked .",
    "we believe that cord should be used as a debugging rather than a verification tool and found it to be extremely effective in discovering errors ( see section  [ checkcc ] ) .",
    "we had to resort to annotating code because our analysis techniques could only handle simple operations on booleans and enumerated types .",
    "a next generation of cord is currently being developed . for finite types ,",
    "this version of the tool will be able to handle more interesting operations , like addition and comparison .",
    "it will also be able to approximate infinite types and perform operations on them using abstract interpretation  @xcite .",
    "this will allow us to analyze code directly rather than using annotations .",
    "we have implemented the cruise control system in c with an xlib interface .",
    "the implementation was not originally annotated and consisted of 675 lines of code , out of which roughly 380 lines were used to implement the gui of the system .",
    "the code was then annotated by another member of the group in about 40 minutes ; the annotation effort was trivial and resulted in 37 update , 25 assert and 1 initial annotation .    ' '' ''    after fixing annotation errors reported by sac , we ran cord on the code of the cruise control system .",
    "the analysis took 7.62 seconds ( 3.45 user , 0.74 system , as reported by tshell s time command ) on a moderately loaded sparcstation-4 ( 85 mhz processor ) with 64 megabytes of ram , and resulted in reporting 14 alt and 5 olt violations ( see figure  [ fig - errors ] ) . the alt and the olt violations are shown in figures  [ fig - alt ] and [ fig - olt ] , respectively .",
    "one olt and one alt violation were caused by an incorrect annotation overlooked by sac .",
    "sac does not consider values of variables when checking code for correct annotations , and did not report a violation when we annotated an assignment with accel instead of @xmath26accel .",
    "another pair of olt and alt violations came from an incorrect transition in the code ( line 388 )  to mode override instead of cruise .",
    "in addition , cord computed that the system can be in all possible modes before this line , whereas only cruise is possible . this problem arises because of the imprecise analysis used in cord and can be fixed by adding an extra assert annotation .",
    "a yet another pair of olt and alt violations came from a transition from override to cruise .",
    "the code did not check that this transition is only enabled when toofast , brake and accel are false .",
    "out of the remaining two olt violations , one was a false negative and the second was an incorrect triggering event for the variable throttleoff .",
    "all other alt properties came from transitions that were not implemented in the code .",
    "in this paper we presented sc(r)@xmath0   an integrated toolset for specification and reasoning about tabular requirements . through a unified interface , sc(r)@xmath0  allows to check software requirements for correctness and analyze consistency between annotated code and requirements .",
    "we are currently working on developing support for automatic code generation and are looking into ways of using scr for generation of black - box test cases .",
    "we believe that sc(r)@xmath0  is an important step towards increasing usability of formal methods : it attempts to replace free - form reasoning in logic by easy to write and review structured tables and amortizes the cost of creation of formal requirements through multiple automated analysis activities .",
    "we envision the following methodology for using sc(r)@xmath0 :    1 .",
    "a ( human ) requirements designer provides an scr tabular specification of the system s required behavior and a set of global properties that should be satisfied by the system .",
    "2 .   sc(r)@xmath0  automatically translates the scr specification into the input to a model - checker , verifies properties and translates counter - examples into the scr notation .",
    "once the specification is considered correct , sc(r)@xmath0  generates an implementation of the mode logic and stubs for interface code , which are filled in by a human developer .",
    "4 .   using the specification , sc(r)@xmath0  generates test cases .",
    "although the mode logic is correct by construction , interface is likely to need testing .",
    "the resulting implementation is analyzed for performance and optionally manually fine - tuned .",
    "if manual fine - tuning was used , the code is automatically checked for consistency with its specifications .",
    "once the problems pointed out by the analysis are fixed , the code is tested using ( a subset of ) test cases generated in step ( 4 ) above .      in figure  [ bigpicture ] ,",
    "analysis activities performed within sc(r)@xmath0  and software artifacts are shown inside ellipses and boxes , respectively .",
    "for example , the code generation activity takes scr requirements as an input and generates an implementation in c. a dashed line signifies that the generated code and the code that is analyzed for correctness , represent the same artifact .    in sc(r)@xmath0",
    ", requirements analysis is done via model - checking .",
    "although model - checking is an effective verification technique which can be used without any user input , it has a number of limitations .",
    "checking can often be prohibitively expensive and can not usually be applied to infinite - state systems .",
    "thus , we are limited to verifying just control ( as opposed to data or timing ) aspects of the specification . in order to use model - checking effectively , we had to reduce the expressive power of our input logic , which may not be feasible for many applications .",
    "we recognize that more sophisticated verification might be necessary and are planning to experiment with using a theorem - prover , e.g. pvs  @xcite , to check complex typechecking and timing properties of systems .",
    "code verification in sc(r)@xmath0  is done via a static - analysis tool cord .",
    "although effective in finding errors in our case studies , cord is still a prototype tool in need of major improvements .",
    "we are currently redesigning it to process a more expressive annotation language and reason about infinite - domain variables .",
    "this would make cord able to verify implementations of unrestricted scr specifications .",
    "joanne atlee and her students developed gensmv and performed the initial analysis of the cruise control system .",
    "they also helped in shaping the look and feel of the gui for specifying requirements .",
    "the author is also grateful to john gannon and rich gerber for teaching her about formal methods , to connie heitmeyer and stuart faulk for many fruitful discussions about scr , to david wendland and hicham mouline who implemented and improved many aspects of the tools , to sai sudha for developing sac , and to matthew cwirko - godycki for his help with the cruise control case study .",
    "marsha chechik is an assistant professor in the department of computer science at the university of toronto .",
    "she can be reached at the address department of computer science , university of toronto , 10 king s college rd . ,",
    "toronto , on m5s 3g4 .",
    "her e - mail address is chechik@cs.toronto.edu .",
    "sam owre , john rushby , and natarajan shankar . .",
    "in _ proceedings of the conference on tools and algorithms for the construction and analysis of systems ( tacas97 ) , lncs 1217 _ , pages 366383 , april 1997 ."
  ],
  "abstract_text": [
    "<S> this paper gives an overview of sc(r)@xmath0   a toolset designed to increase the usability of formal methods for software development . </S>",
    "<S> formal requirements are specified in sc(r)@xmath0  in an easy to use and review format , and then used in checking requirements for correctness and in verifying consistency between annotated code and requirements .    in this paper </S>",
    "<S> we discuss motivations behind this work , describe several tools which are part of sc(r)@xmath0 , and illustrate their operation on an example of a cruise control system .    </S>",
    "<S> epsf 8.5 in 6.0 in 0.37 in 0.25 in 0.25 in -.3 in </S>"
  ]
}